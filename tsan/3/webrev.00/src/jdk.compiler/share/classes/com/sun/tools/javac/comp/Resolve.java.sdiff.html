<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Operators.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TransTypes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  26 package com.sun.tools.javac.comp;
  27 
  28 import com.sun.tools.javac.api.Formattable.LocalizedString;
  29 import com.sun.tools.javac.code.*;
  30 import com.sun.tools.javac.code.Scope.WriteableScope;
  31 import com.sun.tools.javac.code.Source.Feature;
  32 import com.sun.tools.javac.code.Symbol.*;
  33 import com.sun.tools.javac.code.Type.*;
  34 import com.sun.tools.javac.comp.Attr.ResultInfo;
  35 import com.sun.tools.javac.comp.Check.CheckContext;
  36 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  37 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  38 import com.sun.tools.javac.comp.DeferredAttr.DeferredType;
  39 import com.sun.tools.javac.comp.Resolve.MethodResolutionContext.Candidate;
  40 import com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.Template;
  41 import com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind;
  42 import com.sun.tools.javac.jvm.*;
  43 import com.sun.tools.javac.main.Option;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.resources.CompilerProperties.Fragments;

  46 import com.sun.tools.javac.tree.*;
  47 import com.sun.tools.javac.tree.JCTree.*;
  48 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
  49 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  50 import com.sun.tools.javac.util.*;
  51 import com.sun.tools.javac.util.DefinedBy.Api;
  52 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  53 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  54 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;

  55 
  56 import java.util.Arrays;
  57 import java.util.Collection;
  58 import java.util.EnumSet;
  59 import java.util.HashSet;
  60 import java.util.Iterator;
  61 import java.util.LinkedHashMap;
  62 import java.util.Map;
  63 import java.util.Set;
  64 import java.util.function.BiFunction;
  65 import java.util.function.BiPredicate;

  66 import java.util.function.Function;
  67 import java.util.function.Predicate;
  68 import java.util.stream.Stream;
  69 
  70 import javax.lang.model.element.ElementVisitor;
  71 
  72 import static com.sun.tools.javac.code.Flags.*;
  73 import static com.sun.tools.javac.code.Flags.BLOCK;
  74 import static com.sun.tools.javac.code.Flags.STATIC;
  75 import static com.sun.tools.javac.code.Kinds.*;
  76 import static com.sun.tools.javac.code.Kinds.Kind.*;
  77 import static com.sun.tools.javac.code.TypeTag.*;
  78 import static com.sun.tools.javac.comp.Resolve.MethodResolutionPhase.*;
  79 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  80 import static com.sun.tools.javac.util.Iterators.createCompoundIterator;
  81 
  82 /** Helper class for name resolution, used mostly by the attribution phase.
  83  *
  84  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  85  *  If you write code that depends on this, you do so at your own risk.
</pre>
<hr />
<pre>
  88  */
  89 public class Resolve {
  90     protected static final Context.Key&lt;Resolve&gt; resolveKey = new Context.Key&lt;&gt;();
  91 
  92     Names names;
  93     Log log;
  94     Symtab syms;
  95     Attr attr;
  96     DeferredAttr deferredAttr;
  97     Check chk;
  98     Infer infer;
  99     ClassFinder finder;
 100     ModuleFinder moduleFinder;
 101     Types types;
 102     JCDiagnostic.Factory diags;
 103     public final boolean allowFunctionalInterfaceMostSpecific;
 104     public final boolean allowModules;
 105     public final boolean checkVarargsAccessAfterResolution;
 106     private final boolean compactMethodDiags;
 107     private final boolean allowLocalVariableTypeInference;

 108     final EnumSet&lt;VerboseResolutionMode&gt; verboseResolutionMode;
 109 
 110     WriteableScope polymorphicSignatureScope;
 111 
 112     protected Resolve(Context context) {
 113         context.put(resolveKey, this);
 114         syms = Symtab.instance(context);
 115 
 116         varNotFound = new SymbolNotFoundError(ABSENT_VAR);
 117         methodNotFound = new SymbolNotFoundError(ABSENT_MTH);
 118         typeNotFound = new SymbolNotFoundError(ABSENT_TYP);
 119         referenceNotFound = ReferenceLookupResult.error(methodNotFound);
 120 
 121         names = Names.instance(context);
 122         log = Log.instance(context);
 123         attr = Attr.instance(context);
 124         deferredAttr = DeferredAttr.instance(context);
 125         chk = Check.instance(context);
 126         infer = Infer.instance(context);
 127         finder = ClassFinder.instance(context);
 128         moduleFinder = ModuleFinder.instance(context);
 129         types = Types.instance(context);
 130         diags = JCDiagnostic.Factory.instance(context);

 131         Source source = Source.instance(context);
 132         Options options = Options.instance(context);
 133         compactMethodDiags = options.isSet(Option.XDIAGS, &quot;compact&quot;) ||
 134                 options.isUnset(Option.XDIAGS) &amp;&amp; options.isUnset(&quot;rawDiagnostics&quot;);
 135         verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);
 136         Target target = Target.instance(context);
 137         allowFunctionalInterfaceMostSpecific = Feature.FUNCTIONAL_INTERFACE_MOST_SPECIFIC.allowedInSource(source);
 138         allowLocalVariableTypeInference = Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source);


 139         checkVarargsAccessAfterResolution =
 140                 Feature.POST_APPLICABILITY_VARARGS_ACCESS_CHECK.allowedInSource(source);
 141         polymorphicSignatureScope = WriteableScope.create(syms.noSymbol);
 142         allowModules = Feature.MODULES.allowedInSource(source);
 143     }
 144 
 145     /** error symbols, which are returned when resolution fails
 146      */
 147     private final SymbolNotFoundError varNotFound;
 148     private final SymbolNotFoundError methodNotFound;
 149     private final SymbolNotFoundError typeNotFound;
 150 
 151     /** empty reference lookup result */
 152     private final ReferenceLookupResult referenceNotFound;
 153 
 154     public static Resolve instance(Context context) {
 155         Resolve instance = context.get(resolveKey);
 156         if (instance == null)
 157             instance = new Resolve(context);
 158         return instance;
</pre>
<hr />
<pre>
 272 
 273     /** An environment is &quot;static&quot; if its static level is greater than
 274      *  the one of its outer environment
 275      */
 276     protected static boolean isStatic(Env&lt;AttrContext&gt; env) {
 277         return env.outer != null &amp;&amp; env.info.staticLevel &gt; env.outer.info.staticLevel;
 278     }
 279 
 280     /** An environment is an &quot;initializer&quot; if it is a constructor or
 281      *  an instance initializer.
 282      */
 283     static boolean isInitializer(Env&lt;AttrContext&gt; env) {
 284         Symbol owner = env.info.scope.owner;
 285         return owner.isConstructor() ||
 286             owner.owner.kind == TYP &amp;&amp;
 287             (owner.kind == VAR ||
 288              owner.kind == MTH &amp;&amp; (owner.flags() &amp; BLOCK) != 0) &amp;&amp;
 289             (owner.flags() &amp; STATIC) == 0;
 290     }
 291 
<span class="line-modified"> 292     /** Is class accessible in given evironment?</span>
 293      *  @param env    The current environment.
 294      *  @param c      The class whose accessibility is checked.
 295      */
 296     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c) {
 297         return isAccessible(env, c, false);
 298     }
 299 
 300     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c, boolean checkInner) {
 301 
 302         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 303            to refer to an inaccessible type
 304         */
 305         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 306             return true;
 307 
 308         if (env.info.visitingServiceImplementation &amp;&amp;
 309             env.toplevel.modle == c.packge().modle) {
 310             return true;
 311         }
 312 
</pre>
<hr />
<pre>
1363                         JCTree speculativeTree = ((DeferredType)expr.type).speculativeTree(deferredAttrContext);
1364                         if (speculativeTree != deferredAttr.stuckTree) {
1365                             expr = (JCExpression)speculativeTree;
1366                         }
1367                     }
1368                     return expr;
1369                 }
1370             }
1371 
1372         }
1373 
1374         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1375             Assert.error(&quot;Cannot get here!&quot;);
1376             return null;
1377         }
1378     }
1379 
1380     public static class InapplicableMethodException extends RuntimeException {
1381         private static final long serialVersionUID = 0;
1382 
<span class="line-modified">1383         JCDiagnostic diagnostic;</span>
1384 
1385         InapplicableMethodException(JCDiagnostic diag) {
1386             this.diagnostic = diag;
1387         }
1388 
1389         public JCDiagnostic getDiagnostic() {
1390             return diagnostic;
1391         }
1392     }
1393 
1394 /* ***************************************************************************
1395  *  Symbol lookup
1396  *  the following naming conventions for arguments are used
1397  *
1398  *       env      is the environment where the symbol was mentioned
1399  *       site     is the type of which the symbol is a member
1400  *       name     is the symbol&#39;s name
1401  *                if no arguments are given
1402  *       argtypes are the value arguments, if we search for a method
1403  *
</pre>
<hr />
<pre>
1465      */
1466     Symbol findVar(Env&lt;AttrContext&gt; env, Name name) {
1467         Symbol bestSoFar = varNotFound;
1468         Env&lt;AttrContext&gt; env1 = env;
1469         boolean staticOnly = false;
1470         while (env1.outer != null) {
1471             Symbol sym = null;
1472             if (isStatic(env1)) staticOnly = true;
1473             for (Symbol s : env1.info.scope.getSymbolsByName(name)) {
1474                 if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1475                     sym = s;
1476                     break;
1477                 }
1478             }
1479             if (sym == null) {
1480                 sym = findField(env1, env1.enclClass.sym.type, name, env1.enclClass.sym);
1481             }
1482             if (sym.exists()) {
1483                 if (staticOnly &amp;&amp;
1484                     sym.kind == VAR &amp;&amp;
<span class="line-modified">1485                     sym.owner.kind == TYP &amp;&amp;</span>






1486                     (sym.flags() &amp; STATIC) == 0)
1487                     return new StaticError(sym);
1488                 else
1489                     return sym;
1490             } else {
1491                 bestSoFar = bestOf(bestSoFar, sym);
1492             }
1493 
1494             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1495             env1 = env1.outer;
1496         }
1497 
1498         Symbol sym = findField(env, syms.predefClass.type, name, syms.predefClass);
1499         if (sym.exists())
1500             return sym;
1501         if (bestSoFar.exists())
1502             return bestSoFar;
1503 
1504         Symbol origin = null;
1505         for (Scope sc : new Scope[] { env.toplevel.namedImportScope, env.toplevel.starImportScope }) {
</pre>
<hr />
<pre>
2313             if (sym.exists()) return sym;
2314             else bestSoFar = bestOf(bestSoFar, sym);
2315 
2316             sym = findGlobalType(env, env.toplevel.toplevelScope, name, noRecovery);
2317             if (sym.exists()) return sym;
2318             else bestSoFar = bestOf(bestSoFar, sym);
2319 
2320             sym = findGlobalType(env, env.toplevel.packge.members(), name, noRecovery);
2321             if (sym.exists()) return sym;
2322             else bestSoFar = bestOf(bestSoFar, sym);
2323 
2324             sym = findGlobalType(env, env.toplevel.starImportScope, name, starImportScopeRecovery);
2325             if (sym.exists()) return sym;
2326             else bestSoFar = bestOf(bestSoFar, sym);
2327         }
2328 
2329         return bestSoFar;
2330     }
2331 
2332     /** Find an unqualified identifier which matches a specified kind set.


2333      *  @param env       The current environment.
2334      *  @param name      The identifier&#39;s name.
2335      *  @param kind      Indicates the possible symbol kinds
2336      *                   (a subset of VAL, TYP, PCK).
2337      */
<span class="line-modified">2338     Symbol findIdent(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {</span>
<span class="line-modified">2339         return checkVarType(findIdentInternal(env, name, kind), name);</span>
2340     }
2341 
2342     Symbol findIdentInternal(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2343         Symbol bestSoFar = typeNotFound;
2344         Symbol sym;
2345 
2346         if (kind.contains(KindSelector.VAL)) {
2347             sym = findVar(env, name);
2348             if (sym.exists()) return sym;
2349             else bestSoFar = bestOf(bestSoFar, sym);
2350         }
2351 
2352         if (kind.contains(KindSelector.TYP)) {
2353             sym = findType(env, name);
2354 
2355             if (sym.exists()) return sym;
2356             else bestSoFar = bestOf(bestSoFar, sym);
2357         }
2358 
2359         if (kind.contains(KindSelector.PCK))
2360             return lookupPackage(env, name);
2361         else return bestSoFar;
2362     }
2363 
2364     /** Find an identifier in a package which matches a specified kind set.


2365      *  @param env       The current environment.
2366      *  @param name      The identifier&#39;s name.
2367      *  @param kind      Indicates the possible symbol kinds
2368      *                   (a nonempty subset of TYP, PCK).
2369      */
<span class="line-modified">2370     Symbol findIdentInPackage(Env&lt;AttrContext&gt; env, TypeSymbol pck,</span>

2371                               Name name, KindSelector kind) {
<span class="line-modified">2372         return checkVarType(findIdentInPackageInternal(env, pck, name, kind), name);</span>
2373     }
2374 
2375     Symbol findIdentInPackageInternal(Env&lt;AttrContext&gt; env, TypeSymbol pck,
2376                               Name name, KindSelector kind) {
2377         Name fullname = TypeSymbol.formFullName(name, pck);
2378         Symbol bestSoFar = typeNotFound;
2379         if (kind.contains(KindSelector.TYP)) {
2380             RecoveryLoadClass recoveryLoadClass =
2381                     allowModules &amp;&amp; !kind.contains(KindSelector.PCK) &amp;&amp;
<span class="line-modified">2382                     !pck.exists() &amp;&amp; !env.info.isSpeculative ?</span>
2383                         doRecoveryLoadClass : noRecovery;
2384             Symbol sym = loadClass(env, fullname, recoveryLoadClass);
2385             if (sym.exists()) {
2386                 // don&#39;t allow programs to use flatnames
2387                 if (name == sym.name) return sym;
2388             }
2389             else bestSoFar = bestOf(bestSoFar, sym);
2390         }
2391         if (kind.contains(KindSelector.PCK)) {
2392             return lookupPackage(env, fullname);
2393         }
2394         return bestSoFar;
2395     }
2396 
2397     /** Find an identifier among the members of a given type `site&#39;.


2398      *  @param env       The current environment.
2399      *  @param site      The type containing the symbol to be found.
2400      *  @param name      The identifier&#39;s name.
2401      *  @param kind      Indicates the possible symbol kinds
2402      *                   (a subset of VAL, TYP).
2403      */
<span class="line-modified">2404     Symbol findIdentInType(Env&lt;AttrContext&gt; env, Type site,</span>

2405                            Name name, KindSelector kind) {
<span class="line-modified">2406         return checkVarType(findIdentInTypeInternal(env, site, name, kind), name);</span>
2407     }
2408 
2409     Symbol findIdentInTypeInternal(Env&lt;AttrContext&gt; env, Type site,
2410                            Name name, KindSelector kind) {
2411         Symbol bestSoFar = typeNotFound;
2412         Symbol sym;
2413         if (kind.contains(KindSelector.VAL)) {
2414             sym = findField(env, site, name, site.tsym);
2415             if (sym.exists()) return sym;
2416             else bestSoFar = bestOf(bestSoFar, sym);
2417         }
2418 
2419         if (kind.contains(KindSelector.TYP)) {
2420             sym = findMemberType(env, site, name, site.tsym);
2421             if (sym.exists()) return sym;
2422             else bestSoFar = bestOf(bestSoFar, sym);
2423         }
2424         return bestSoFar;
2425     }
2426 
<span class="line-modified">2427     private Symbol checkVarType(Symbol bestSoFar, Name name) {</span>
<span class="line-modified">2428         if (allowLocalVariableTypeInference &amp;&amp; name.equals(names.var) &amp;&amp;</span>
<span class="line-modified">2429                 (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP)) {</span>
<span class="line-modified">2430             bestSoFar = new BadVarTypeError();</span>







2431         }
2432         return bestSoFar;
2433     }
2434 
2435 /* ***************************************************************************
2436  *  Access checking
2437  *  The following methods convert ResolveErrors to ErrorSymbols, issuing
2438  *  an error message in the process
2439  ****************************************************************************/
2440 
2441     /** If `sym&#39; is a bad symbol: report error and return errSymbol
2442      *  else pass through unchanged,
2443      *  additional arguments duplicate what has been used in trying to find the
2444      *  symbol {@literal (--&gt; flyweight pattern)}. This improves performance since we
2445      *  expect misses to happen frequently.
2446      *
2447      *  @param sym       The symbol that was found, or a ResolveError.
2448      *  @param pos       The position to use for error reporting.
2449      *  @param location  The symbol the served as a context for this lookup
2450      *  @param site      The original type from where the selection took place.
</pre>
<hr />
<pre>
2580         if ((sym.flags() &amp; ABSTRACT) != 0 &amp;&amp; (sym.flags() &amp; DEFAULT) == 0)
2581             log.error(pos,
2582                       Errors.AbstractCantBeAccessedDirectly(kindName(sym),sym, sym.location()));
2583     }
2584 
2585 /* ***************************************************************************
2586  *  Name resolution
2587  *  Naming conventions are as for symbol lookup
2588  *  Unlike the find... methods these methods will report access errors
2589  ****************************************************************************/
2590 
2591     /** Resolve an unqualified (non-method) identifier.
2592      *  @param pos       The position to use for error reporting.
2593      *  @param env       The environment current at the identifier use.
2594      *  @param name      The identifier&#39;s name.
2595      *  @param kind      The set of admissible symbol kinds for the identifier.
2596      */
2597     Symbol resolveIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2598                         Name name, KindSelector kind) {
2599         return accessBase(
<span class="line-modified">2600             findIdent(env, name, kind),</span>
2601             pos, env.enclClass.sym.type, name, false);
2602     }
2603 
2604     /** Resolve an unqualified method identifier.
2605      *  @param pos       The position to use for error reporting.
2606      *  @param env       The environment current at the method invocation.
2607      *  @param name      The identifier&#39;s name.
2608      *  @param argtypes  The types of the invocation&#39;s value arguments.
2609      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2610      */
2611     Symbol resolveMethod(DiagnosticPosition pos,
2612                          Env&lt;AttrContext&gt; env,
2613                          Name name,
2614                          List&lt;Type&gt; argtypes,
2615                          List&lt;Type&gt; typeargtypes) {
2616         return lookupMethod(env, pos, env.enclClass.sym, resolveMethodCheck,
2617                 new BasicLookupHelper(name, env.enclClass.sym.type, argtypes, typeargtypes) {
2618                     @Override
2619                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2620                         return findFun(env, name, argtypes, typeargtypes,
</pre>
<hr />
<pre>
2780                                         List&lt;Type&gt; argtypes,
2781                                         List&lt;Type&gt; typeargtypes) {
2782         MethodResolutionContext resolveContext = new MethodResolutionContext();
2783         resolveContext.internalResolution = true;
2784         Symbol sym = resolveConstructor(resolveContext, pos, env, site, argtypes, typeargtypes);
2785         if (sym.kind == MTH) return (MethodSymbol)sym;
2786         else throw new FatalError(
2787                  diags.fragment(Fragments.FatalErrCantLocateCtor(site)));
2788     }
2789 
2790     Symbol findConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2791                               Type site, List&lt;Type&gt; argtypes,
2792                               List&lt;Type&gt; typeargtypes,
2793                               boolean allowBoxing,
2794                               boolean useVarargs) {
2795         Symbol sym = findMethod(env, site,
2796                                     names.init, argtypes,
2797                                     typeargtypes, allowBoxing,
2798                                     useVarargs);
2799         chk.checkDeprecated(pos, env.info.scope.owner, sym);

2800         return sym;
2801     }
2802 
2803     /** Resolve constructor using diamond inference.
2804      *  @param pos       The position to use for error reporting.
2805      *  @param env       The environment current at the constructor invocation.
2806      *  @param site      The type of class for which a constructor is searched.
2807      *                   The scope of this class has been touched in attribution.
2808      *  @param argtypes  The types of the constructor invocation&#39;s value
2809      *                   arguments.
2810      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2811      *                   arguments.
2812      */
2813     Symbol resolveDiamond(DiagnosticPosition pos,
2814                               Env&lt;AttrContext&gt; env,
2815                               Type site,
2816                               List&lt;Type&gt; argtypes,
2817                               List&lt;Type&gt; typeargtypes) {
2818         return lookupMethod(env, pos, site.tsym, resolveMethodCheck,
2819                 new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
</pre>
<hr />
<pre>
3184             }
3185         }
3186     };
3187 
3188     /**
3189      * This chooser implements the selection strategy used during an arity-based lookup; this logic
3190      * is described in JLS SE 8 (15.12.2.1).
3191      */
3192     ReferenceChooser structuralReferenceChooser = new ReferenceChooser() {
3193 
3194         @Override
3195         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3196             return (!boundRes.isSuccess() || !boundRes.hasKind(StaticKind.STATIC)) ?
3197                     boundRes : //the search has at least one applicable non-static method
3198                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3199         }
3200 
3201         @Override
3202         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3203             if (boundRes.isSuccess() &amp;&amp; !boundRes.hasKind(StaticKind.NON_STATIC)) {
<span class="line-modified">3204                 //the first serach has at least one applicable static method</span>
3205                 return boundRes;
3206             } else if (unboundRes.isSuccess() &amp;&amp; !unboundRes.hasKind(StaticKind.STATIC)) {
3207                 //the second search has at least one applicable non-static method
3208                 return unboundRes;
3209             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3210                 //either the first search produces a non-static method, or second search produces
3211                 //a non-static method (error recovery)
3212                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3213                         boundRes.sym : unboundRes.sym, true));
3214             } else {
3215                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3216                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3217                         unboundRes : boundRes;
3218             }
3219         }
3220     };
3221 
3222     /**
3223      * Helper for defining custom method-like lookup logic; a lookup helper
3224      * provides hooks for (i) the actual lookup logic and (ii) accessing the
</pre>
<hr />
<pre>
3816 
3817         @Override
3818         public boolean exists() {
3819             return true;
3820         }
3821 
3822         @Override
3823         public String toString() {
3824              return super.toString() + &quot; wrongSym=&quot; + sym;
3825         }
3826 
3827         @Override
3828         public Symbol access(Name name, TypeSymbol location) {
3829             if (!sym.kind.isResolutionError() &amp;&amp; sym.kind.matches(KindSelector.TYP))
3830                 return types.createErrorType(name, location, sym.type).tsym;
3831             else
3832                 return sym;
3833         }
3834     }
3835 
<span class="line-modified">3836     class BadVarTypeError extends ResolveError {</span>
<span class="line-modified">3837         BadVarTypeError() {</span>
<span class="line-modified">3838             super(Kind.BAD_VAR, &quot;bad var use&quot;);</span>


3839         }
3840 
3841         @Override
3842         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<span class="line-modified">3843             return diags.create(dkind, log.currentSource(), pos, &quot;illegal.ref.to.var.type&quot;);</span>
3844         }
3845     }
3846 
3847     /**
3848      * InvalidSymbolError error class indicating that a symbol matching a
3849      * given name does not exists in a given site.
3850      */
3851     class SymbolNotFoundError extends ResolveError {
3852 
3853         SymbolNotFoundError(Kind kind) {
3854             this(kind, &quot;symbol not found error&quot;);
3855         }
3856 
3857         SymbolNotFoundError(Kind kind, String debugName) {
3858             super(kind, debugName);
3859         }
3860 
3861         @Override
3862         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3863                 DiagnosticPosition pos,
</pre>
<hr />
<pre>
4545 
4546     /**
4547      * Helper class for method resolution diagnostic simplification.
4548      * Certain resolution diagnostic are rewritten as simpler diagnostic
4549      * where the enclosing resolution diagnostic (i.e. &#39;inapplicable method&#39;)
4550      * is stripped away, as it doesn&#39;t carry additional info. The logic
4551      * for matching a given diagnostic is given in terms of a template
4552      * hierarchy: a diagnostic template can be specified programmatically,
4553      * so that only certain diagnostics are matched. Each templete is then
4554      * associated with a rewriter object that carries out the task of rewtiting
4555      * the diagnostic to a simpler one.
4556      */
4557     static class MethodResolutionDiagHelper {
4558 
4559         /**
4560          * A diagnostic rewriter transforms a method resolution diagnostic
4561          * into a simpler one
4562          */
4563         interface DiagnosticRewriter {
4564             JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
<span class="line-modified">4565                     DiagnosticPosition preferedPos, DiagnosticSource preferredSource,</span>
4566                     DiagnosticType preferredKind, JCDiagnostic d);
4567         }
4568 
4569         /**
4570          * A diagnostic template is made up of two ingredients: (i) a regular
4571          * expression for matching a diagnostic key and (ii) a list of sub-templates
4572          * for matching diagnostic arguments.
4573          */
4574         static class Template {
4575 
4576             /** regex used to match diag key */
4577             String regex;
4578 
4579             /** templates used to match diagnostic args */
4580             Template[] subTemplates;
4581 
4582             Template(String key, Template... subTemplates) {
4583                 this.regex = key;
4584                 this.subTemplates = subTemplates;
4585             }
</pre>
<hr />
<pre>
4601                     }
4602                 }
4603                 return true;
4604             }
4605         }
4606 
4607         /**
4608          * Common rewriter for all argument mismatch simplifications.
4609          */
4610         static class ArgMismatchRewriter implements DiagnosticRewriter {
4611 
4612             /** the index of the subdiagnostic to be used as primary. */
4613             int causeIndex;
4614 
4615             public ArgMismatchRewriter(int causeIndex) {
4616                 this.causeIndex = causeIndex;
4617             }
4618 
4619             @Override
4620             public JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
<span class="line-modified">4621                     DiagnosticPosition preferedPos, DiagnosticSource preferredSource,</span>
4622                     DiagnosticType preferredKind, JCDiagnostic d) {
4623                 JCDiagnostic cause = (JCDiagnostic)d.getArgs()[causeIndex];
4624                 DiagnosticPosition pos = d.getDiagnosticPosition();
4625                 if (pos == null) {
<span class="line-modified">4626                     pos = preferedPos;</span>
4627                 }
4628                 return diags.create(preferredKind, preferredSource, pos,
4629                         &quot;prob.found.req&quot;, cause);
4630             }
4631         }
4632 
4633         /** a dummy template that match any diagnostic argument */
4634         static final Template skip = new Template(&quot;&quot;) {
4635             @Override
4636             boolean matches(Object d) {
4637                 return true;
4638             }
4639         };
4640 
4641         /** template for matching inference-free arguments mismatch failures */
4642         static final Template argMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip);
4643 
4644         /** template for matching inference related arguments mismatch failures */
4645         static final Template inferArgMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip, skip) {
4646             @Override
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  26 package com.sun.tools.javac.comp;
  27 
  28 import com.sun.tools.javac.api.Formattable.LocalizedString;
  29 import com.sun.tools.javac.code.*;
  30 import com.sun.tools.javac.code.Scope.WriteableScope;
  31 import com.sun.tools.javac.code.Source.Feature;
  32 import com.sun.tools.javac.code.Symbol.*;
  33 import com.sun.tools.javac.code.Type.*;
  34 import com.sun.tools.javac.comp.Attr.ResultInfo;
  35 import com.sun.tools.javac.comp.Check.CheckContext;
  36 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  37 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  38 import com.sun.tools.javac.comp.DeferredAttr.DeferredType;
  39 import com.sun.tools.javac.comp.Resolve.MethodResolutionContext.Candidate;
  40 import com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.Template;
  41 import com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind;
  42 import com.sun.tools.javac.jvm.*;
  43 import com.sun.tools.javac.main.Option;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
<span class="line-added">  46 import com.sun.tools.javac.resources.CompilerProperties.Warnings;</span>
  47 import com.sun.tools.javac.tree.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
  50 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  51 import com.sun.tools.javac.util.*;
  52 import com.sun.tools.javac.util.DefinedBy.Api;
  53 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  54 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  55 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
<span class="line-added">  56 import com.sun.tools.javac.util.JCDiagnostic.Warning;</span>
  57 
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.EnumSet;
  61 import java.util.HashSet;
  62 import java.util.Iterator;
  63 import java.util.LinkedHashMap;
  64 import java.util.Map;
  65 import java.util.Set;
  66 import java.util.function.BiFunction;
  67 import java.util.function.BiPredicate;
<span class="line-added">  68 import java.util.function.Consumer;</span>
  69 import java.util.function.Function;
  70 import java.util.function.Predicate;
  71 import java.util.stream.Stream;
  72 
  73 import javax.lang.model.element.ElementVisitor;
  74 
  75 import static com.sun.tools.javac.code.Flags.*;
  76 import static com.sun.tools.javac.code.Flags.BLOCK;
  77 import static com.sun.tools.javac.code.Flags.STATIC;
  78 import static com.sun.tools.javac.code.Kinds.*;
  79 import static com.sun.tools.javac.code.Kinds.Kind.*;
  80 import static com.sun.tools.javac.code.TypeTag.*;
  81 import static com.sun.tools.javac.comp.Resolve.MethodResolutionPhase.*;
  82 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  83 import static com.sun.tools.javac.util.Iterators.createCompoundIterator;
  84 
  85 /** Helper class for name resolution, used mostly by the attribution phase.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
</pre>
<hr />
<pre>
  91  */
  92 public class Resolve {
  93     protected static final Context.Key&lt;Resolve&gt; resolveKey = new Context.Key&lt;&gt;();
  94 
  95     Names names;
  96     Log log;
  97     Symtab syms;
  98     Attr attr;
  99     DeferredAttr deferredAttr;
 100     Check chk;
 101     Infer infer;
 102     ClassFinder finder;
 103     ModuleFinder moduleFinder;
 104     Types types;
 105     JCDiagnostic.Factory diags;
 106     public final boolean allowFunctionalInterfaceMostSpecific;
 107     public final boolean allowModules;
 108     public final boolean checkVarargsAccessAfterResolution;
 109     private final boolean compactMethodDiags;
 110     private final boolean allowLocalVariableTypeInference;
<span class="line-added"> 111     private final boolean allowYieldStatement;</span>
 112     final EnumSet&lt;VerboseResolutionMode&gt; verboseResolutionMode;
 113 
 114     WriteableScope polymorphicSignatureScope;
 115 
 116     protected Resolve(Context context) {
 117         context.put(resolveKey, this);
 118         syms = Symtab.instance(context);
 119 
 120         varNotFound = new SymbolNotFoundError(ABSENT_VAR);
 121         methodNotFound = new SymbolNotFoundError(ABSENT_MTH);
 122         typeNotFound = new SymbolNotFoundError(ABSENT_TYP);
 123         referenceNotFound = ReferenceLookupResult.error(methodNotFound);
 124 
 125         names = Names.instance(context);
 126         log = Log.instance(context);
 127         attr = Attr.instance(context);
 128         deferredAttr = DeferredAttr.instance(context);
 129         chk = Check.instance(context);
 130         infer = Infer.instance(context);
 131         finder = ClassFinder.instance(context);
 132         moduleFinder = ModuleFinder.instance(context);
 133         types = Types.instance(context);
 134         diags = JCDiagnostic.Factory.instance(context);
<span class="line-added"> 135         Preview preview = Preview.instance(context);</span>
 136         Source source = Source.instance(context);
 137         Options options = Options.instance(context);
 138         compactMethodDiags = options.isSet(Option.XDIAGS, &quot;compact&quot;) ||
 139                 options.isUnset(Option.XDIAGS) &amp;&amp; options.isUnset(&quot;rawDiagnostics&quot;);
 140         verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);
 141         Target target = Target.instance(context);
 142         allowFunctionalInterfaceMostSpecific = Feature.FUNCTIONAL_INTERFACE_MOST_SPECIFIC.allowedInSource(source);
 143         allowLocalVariableTypeInference = Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source);
<span class="line-added"> 144         allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 145                 Feature.SWITCH_EXPRESSION.allowedInSource(source);</span>
 146         checkVarargsAccessAfterResolution =
 147                 Feature.POST_APPLICABILITY_VARARGS_ACCESS_CHECK.allowedInSource(source);
 148         polymorphicSignatureScope = WriteableScope.create(syms.noSymbol);
 149         allowModules = Feature.MODULES.allowedInSource(source);
 150     }
 151 
 152     /** error symbols, which are returned when resolution fails
 153      */
 154     private final SymbolNotFoundError varNotFound;
 155     private final SymbolNotFoundError methodNotFound;
 156     private final SymbolNotFoundError typeNotFound;
 157 
 158     /** empty reference lookup result */
 159     private final ReferenceLookupResult referenceNotFound;
 160 
 161     public static Resolve instance(Context context) {
 162         Resolve instance = context.get(resolveKey);
 163         if (instance == null)
 164             instance = new Resolve(context);
 165         return instance;
</pre>
<hr />
<pre>
 279 
 280     /** An environment is &quot;static&quot; if its static level is greater than
 281      *  the one of its outer environment
 282      */
 283     protected static boolean isStatic(Env&lt;AttrContext&gt; env) {
 284         return env.outer != null &amp;&amp; env.info.staticLevel &gt; env.outer.info.staticLevel;
 285     }
 286 
 287     /** An environment is an &quot;initializer&quot; if it is a constructor or
 288      *  an instance initializer.
 289      */
 290     static boolean isInitializer(Env&lt;AttrContext&gt; env) {
 291         Symbol owner = env.info.scope.owner;
 292         return owner.isConstructor() ||
 293             owner.owner.kind == TYP &amp;&amp;
 294             (owner.kind == VAR ||
 295              owner.kind == MTH &amp;&amp; (owner.flags() &amp; BLOCK) != 0) &amp;&amp;
 296             (owner.flags() &amp; STATIC) == 0;
 297     }
 298 
<span class="line-modified"> 299     /** Is class accessible in given environment?</span>
 300      *  @param env    The current environment.
 301      *  @param c      The class whose accessibility is checked.
 302      */
 303     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c) {
 304         return isAccessible(env, c, false);
 305     }
 306 
 307     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c, boolean checkInner) {
 308 
 309         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 310            to refer to an inaccessible type
 311         */
 312         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 313             return true;
 314 
 315         if (env.info.visitingServiceImplementation &amp;&amp;
 316             env.toplevel.modle == c.packge().modle) {
 317             return true;
 318         }
 319 
</pre>
<hr />
<pre>
1370                         JCTree speculativeTree = ((DeferredType)expr.type).speculativeTree(deferredAttrContext);
1371                         if (speculativeTree != deferredAttr.stuckTree) {
1372                             expr = (JCExpression)speculativeTree;
1373                         }
1374                     }
1375                     return expr;
1376                 }
1377             }
1378 
1379         }
1380 
1381         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1382             Assert.error(&quot;Cannot get here!&quot;);
1383             return null;
1384         }
1385     }
1386 
1387     public static class InapplicableMethodException extends RuntimeException {
1388         private static final long serialVersionUID = 0;
1389 
<span class="line-modified">1390         transient JCDiagnostic diagnostic;</span>
1391 
1392         InapplicableMethodException(JCDiagnostic diag) {
1393             this.diagnostic = diag;
1394         }
1395 
1396         public JCDiagnostic getDiagnostic() {
1397             return diagnostic;
1398         }
1399     }
1400 
1401 /* ***************************************************************************
1402  *  Symbol lookup
1403  *  the following naming conventions for arguments are used
1404  *
1405  *       env      is the environment where the symbol was mentioned
1406  *       site     is the type of which the symbol is a member
1407  *       name     is the symbol&#39;s name
1408  *                if no arguments are given
1409  *       argtypes are the value arguments, if we search for a method
1410  *
</pre>
<hr />
<pre>
1472      */
1473     Symbol findVar(Env&lt;AttrContext&gt; env, Name name) {
1474         Symbol bestSoFar = varNotFound;
1475         Env&lt;AttrContext&gt; env1 = env;
1476         boolean staticOnly = false;
1477         while (env1.outer != null) {
1478             Symbol sym = null;
1479             if (isStatic(env1)) staticOnly = true;
1480             for (Symbol s : env1.info.scope.getSymbolsByName(name)) {
1481                 if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1482                     sym = s;
1483                     break;
1484                 }
1485             }
1486             if (sym == null) {
1487                 sym = findField(env1, env1.enclClass.sym.type, name, env1.enclClass.sym);
1488             }
1489             if (sym.exists()) {
1490                 if (staticOnly &amp;&amp;
1491                     sym.kind == VAR &amp;&amp;
<span class="line-modified">1492                         // if it is a field</span>
<span class="line-added">1493                         (sym.owner.kind == TYP ||</span>
<span class="line-added">1494                         // or it is a local variable but it is not declared inside of the static local type</span>
<span class="line-added">1495                         // only records so far, then error</span>
<span class="line-added">1496                         (sym.owner.kind == MTH) &amp;&amp;</span>
<span class="line-added">1497                         (env.enclClass.sym.flags() &amp; STATIC) != 0 &amp;&amp;</span>
<span class="line-added">1498                         sym.enclClass() != env.enclClass.sym) &amp;&amp;</span>
1499                     (sym.flags() &amp; STATIC) == 0)
1500                     return new StaticError(sym);
1501                 else
1502                     return sym;
1503             } else {
1504                 bestSoFar = bestOf(bestSoFar, sym);
1505             }
1506 
1507             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1508             env1 = env1.outer;
1509         }
1510 
1511         Symbol sym = findField(env, syms.predefClass.type, name, syms.predefClass);
1512         if (sym.exists())
1513             return sym;
1514         if (bestSoFar.exists())
1515             return bestSoFar;
1516 
1517         Symbol origin = null;
1518         for (Scope sc : new Scope[] { env.toplevel.namedImportScope, env.toplevel.starImportScope }) {
</pre>
<hr />
<pre>
2326             if (sym.exists()) return sym;
2327             else bestSoFar = bestOf(bestSoFar, sym);
2328 
2329             sym = findGlobalType(env, env.toplevel.toplevelScope, name, noRecovery);
2330             if (sym.exists()) return sym;
2331             else bestSoFar = bestOf(bestSoFar, sym);
2332 
2333             sym = findGlobalType(env, env.toplevel.packge.members(), name, noRecovery);
2334             if (sym.exists()) return sym;
2335             else bestSoFar = bestOf(bestSoFar, sym);
2336 
2337             sym = findGlobalType(env, env.toplevel.starImportScope, name, starImportScopeRecovery);
2338             if (sym.exists()) return sym;
2339             else bestSoFar = bestOf(bestSoFar, sym);
2340         }
2341 
2342         return bestSoFar;
2343     }
2344 
2345     /** Find an unqualified identifier which matches a specified kind set.
<span class="line-added">2346      *  @param pos       position on which report warnings, if any;</span>
<span class="line-added">2347      *                   null warnings should not be reported</span>
2348      *  @param env       The current environment.
2349      *  @param name      The identifier&#39;s name.
2350      *  @param kind      Indicates the possible symbol kinds
2351      *                   (a subset of VAL, TYP, PCK).
2352      */
<span class="line-modified">2353     Symbol findIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {</span>
<span class="line-modified">2354         return checkRestrictedType(pos, findIdentInternal(env, name, kind), name);</span>
2355     }
2356 
2357     Symbol findIdentInternal(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2358         Symbol bestSoFar = typeNotFound;
2359         Symbol sym;
2360 
2361         if (kind.contains(KindSelector.VAL)) {
2362             sym = findVar(env, name);
2363             if (sym.exists()) return sym;
2364             else bestSoFar = bestOf(bestSoFar, sym);
2365         }
2366 
2367         if (kind.contains(KindSelector.TYP)) {
2368             sym = findType(env, name);
2369 
2370             if (sym.exists()) return sym;
2371             else bestSoFar = bestOf(bestSoFar, sym);
2372         }
2373 
2374         if (kind.contains(KindSelector.PCK))
2375             return lookupPackage(env, name);
2376         else return bestSoFar;
2377     }
2378 
2379     /** Find an identifier in a package which matches a specified kind set.
<span class="line-added">2380      *  @param pos       position on which report warnings, if any;</span>
<span class="line-added">2381      *                   null warnings should not be reported</span>
2382      *  @param env       The current environment.
2383      *  @param name      The identifier&#39;s name.
2384      *  @param kind      Indicates the possible symbol kinds
2385      *                   (a nonempty subset of TYP, PCK).
2386      */
<span class="line-modified">2387     Symbol findIdentInPackage(DiagnosticPosition pos,</span>
<span class="line-added">2388                               Env&lt;AttrContext&gt; env, TypeSymbol pck,</span>
2389                               Name name, KindSelector kind) {
<span class="line-modified">2390         return checkRestrictedType(pos, findIdentInPackageInternal(env, pck, name, kind), name);</span>
2391     }
2392 
2393     Symbol findIdentInPackageInternal(Env&lt;AttrContext&gt; env, TypeSymbol pck,
2394                               Name name, KindSelector kind) {
2395         Name fullname = TypeSymbol.formFullName(name, pck);
2396         Symbol bestSoFar = typeNotFound;
2397         if (kind.contains(KindSelector.TYP)) {
2398             RecoveryLoadClass recoveryLoadClass =
2399                     allowModules &amp;&amp; !kind.contains(KindSelector.PCK) &amp;&amp;
<span class="line-modified">2400                     !pck.exists() &amp;&amp; !env.info.attributionMode.isSpeculative ?</span>
2401                         doRecoveryLoadClass : noRecovery;
2402             Symbol sym = loadClass(env, fullname, recoveryLoadClass);
2403             if (sym.exists()) {
2404                 // don&#39;t allow programs to use flatnames
2405                 if (name == sym.name) return sym;
2406             }
2407             else bestSoFar = bestOf(bestSoFar, sym);
2408         }
2409         if (kind.contains(KindSelector.PCK)) {
2410             return lookupPackage(env, fullname);
2411         }
2412         return bestSoFar;
2413     }
2414 
2415     /** Find an identifier among the members of a given type `site&#39;.
<span class="line-added">2416      *  @param pos       position on which report warnings, if any;</span>
<span class="line-added">2417      *                   null warnings should not be reported</span>
2418      *  @param env       The current environment.
2419      *  @param site      The type containing the symbol to be found.
2420      *  @param name      The identifier&#39;s name.
2421      *  @param kind      Indicates the possible symbol kinds
2422      *                   (a subset of VAL, TYP).
2423      */
<span class="line-modified">2424     Symbol findIdentInType(DiagnosticPosition pos,</span>
<span class="line-added">2425                            Env&lt;AttrContext&gt; env, Type site,</span>
2426                            Name name, KindSelector kind) {
<span class="line-modified">2427         return checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name);</span>
2428     }
2429 
2430     Symbol findIdentInTypeInternal(Env&lt;AttrContext&gt; env, Type site,
2431                            Name name, KindSelector kind) {
2432         Symbol bestSoFar = typeNotFound;
2433         Symbol sym;
2434         if (kind.contains(KindSelector.VAL)) {
2435             sym = findField(env, site, name, site.tsym);
2436             if (sym.exists()) return sym;
2437             else bestSoFar = bestOf(bestSoFar, sym);
2438         }
2439 
2440         if (kind.contains(KindSelector.TYP)) {
2441             sym = findMemberType(env, site, name, site.tsym);
2442             if (sym.exists()) return sym;
2443             else bestSoFar = bestOf(bestSoFar, sym);
2444         }
2445         return bestSoFar;
2446     }
2447 
<span class="line-modified">2448     private Symbol checkRestrictedType(DiagnosticPosition pos, Symbol bestSoFar, Name name) {</span>
<span class="line-modified">2449         if (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP) {</span>
<span class="line-modified">2450             if (allowLocalVariableTypeInference &amp;&amp; name.equals(names.var)) {</span>
<span class="line-modified">2451                 bestSoFar = new BadRestrictedTypeError(names.var);</span>
<span class="line-added">2452             } else if (name.equals(names.yield)) {</span>
<span class="line-added">2453                 if (allowYieldStatement) {</span>
<span class="line-added">2454                     bestSoFar = new BadRestrictedTypeError(names.yield);</span>
<span class="line-added">2455                 } else if (pos != null) {</span>
<span class="line-added">2456                     log.warning(pos, Warnings.IllegalRefToRestrictedType(names.yield));</span>
<span class="line-added">2457                 }</span>
<span class="line-added">2458             }</span>
2459         }
2460         return bestSoFar;
2461     }
2462 
2463 /* ***************************************************************************
2464  *  Access checking
2465  *  The following methods convert ResolveErrors to ErrorSymbols, issuing
2466  *  an error message in the process
2467  ****************************************************************************/
2468 
2469     /** If `sym&#39; is a bad symbol: report error and return errSymbol
2470      *  else pass through unchanged,
2471      *  additional arguments duplicate what has been used in trying to find the
2472      *  symbol {@literal (--&gt; flyweight pattern)}. This improves performance since we
2473      *  expect misses to happen frequently.
2474      *
2475      *  @param sym       The symbol that was found, or a ResolveError.
2476      *  @param pos       The position to use for error reporting.
2477      *  @param location  The symbol the served as a context for this lookup
2478      *  @param site      The original type from where the selection took place.
</pre>
<hr />
<pre>
2608         if ((sym.flags() &amp; ABSTRACT) != 0 &amp;&amp; (sym.flags() &amp; DEFAULT) == 0)
2609             log.error(pos,
2610                       Errors.AbstractCantBeAccessedDirectly(kindName(sym),sym, sym.location()));
2611     }
2612 
2613 /* ***************************************************************************
2614  *  Name resolution
2615  *  Naming conventions are as for symbol lookup
2616  *  Unlike the find... methods these methods will report access errors
2617  ****************************************************************************/
2618 
2619     /** Resolve an unqualified (non-method) identifier.
2620      *  @param pos       The position to use for error reporting.
2621      *  @param env       The environment current at the identifier use.
2622      *  @param name      The identifier&#39;s name.
2623      *  @param kind      The set of admissible symbol kinds for the identifier.
2624      */
2625     Symbol resolveIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2626                         Name name, KindSelector kind) {
2627         return accessBase(
<span class="line-modified">2628             findIdent(pos, env, name, kind),</span>
2629             pos, env.enclClass.sym.type, name, false);
2630     }
2631 
2632     /** Resolve an unqualified method identifier.
2633      *  @param pos       The position to use for error reporting.
2634      *  @param env       The environment current at the method invocation.
2635      *  @param name      The identifier&#39;s name.
2636      *  @param argtypes  The types of the invocation&#39;s value arguments.
2637      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2638      */
2639     Symbol resolveMethod(DiagnosticPosition pos,
2640                          Env&lt;AttrContext&gt; env,
2641                          Name name,
2642                          List&lt;Type&gt; argtypes,
2643                          List&lt;Type&gt; typeargtypes) {
2644         return lookupMethod(env, pos, env.enclClass.sym, resolveMethodCheck,
2645                 new BasicLookupHelper(name, env.enclClass.sym.type, argtypes, typeargtypes) {
2646                     @Override
2647                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2648                         return findFun(env, name, argtypes, typeargtypes,
</pre>
<hr />
<pre>
2808                                         List&lt;Type&gt; argtypes,
2809                                         List&lt;Type&gt; typeargtypes) {
2810         MethodResolutionContext resolveContext = new MethodResolutionContext();
2811         resolveContext.internalResolution = true;
2812         Symbol sym = resolveConstructor(resolveContext, pos, env, site, argtypes, typeargtypes);
2813         if (sym.kind == MTH) return (MethodSymbol)sym;
2814         else throw new FatalError(
2815                  diags.fragment(Fragments.FatalErrCantLocateCtor(site)));
2816     }
2817 
2818     Symbol findConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2819                               Type site, List&lt;Type&gt; argtypes,
2820                               List&lt;Type&gt; typeargtypes,
2821                               boolean allowBoxing,
2822                               boolean useVarargs) {
2823         Symbol sym = findMethod(env, site,
2824                                     names.init, argtypes,
2825                                     typeargtypes, allowBoxing,
2826                                     useVarargs);
2827         chk.checkDeprecated(pos, env.info.scope.owner, sym);
<span class="line-added">2828         chk.checkPreview(pos, sym);</span>
2829         return sym;
2830     }
2831 
2832     /** Resolve constructor using diamond inference.
2833      *  @param pos       The position to use for error reporting.
2834      *  @param env       The environment current at the constructor invocation.
2835      *  @param site      The type of class for which a constructor is searched.
2836      *                   The scope of this class has been touched in attribution.
2837      *  @param argtypes  The types of the constructor invocation&#39;s value
2838      *                   arguments.
2839      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2840      *                   arguments.
2841      */
2842     Symbol resolveDiamond(DiagnosticPosition pos,
2843                               Env&lt;AttrContext&gt; env,
2844                               Type site,
2845                               List&lt;Type&gt; argtypes,
2846                               List&lt;Type&gt; typeargtypes) {
2847         return lookupMethod(env, pos, site.tsym, resolveMethodCheck,
2848                 new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
</pre>
<hr />
<pre>
3213             }
3214         }
3215     };
3216 
3217     /**
3218      * This chooser implements the selection strategy used during an arity-based lookup; this logic
3219      * is described in JLS SE 8 (15.12.2.1).
3220      */
3221     ReferenceChooser structuralReferenceChooser = new ReferenceChooser() {
3222 
3223         @Override
3224         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3225             return (!boundRes.isSuccess() || !boundRes.hasKind(StaticKind.STATIC)) ?
3226                     boundRes : //the search has at least one applicable non-static method
3227                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3228         }
3229 
3230         @Override
3231         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3232             if (boundRes.isSuccess() &amp;&amp; !boundRes.hasKind(StaticKind.NON_STATIC)) {
<span class="line-modified">3233                 //the first search has at least one applicable static method</span>
3234                 return boundRes;
3235             } else if (unboundRes.isSuccess() &amp;&amp; !unboundRes.hasKind(StaticKind.STATIC)) {
3236                 //the second search has at least one applicable non-static method
3237                 return unboundRes;
3238             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3239                 //either the first search produces a non-static method, or second search produces
3240                 //a non-static method (error recovery)
3241                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3242                         boundRes.sym : unboundRes.sym, true));
3243             } else {
3244                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3245                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3246                         unboundRes : boundRes;
3247             }
3248         }
3249     };
3250 
3251     /**
3252      * Helper for defining custom method-like lookup logic; a lookup helper
3253      * provides hooks for (i) the actual lookup logic and (ii) accessing the
</pre>
<hr />
<pre>
3845 
3846         @Override
3847         public boolean exists() {
3848             return true;
3849         }
3850 
3851         @Override
3852         public String toString() {
3853              return super.toString() + &quot; wrongSym=&quot; + sym;
3854         }
3855 
3856         @Override
3857         public Symbol access(Name name, TypeSymbol location) {
3858             if (!sym.kind.isResolutionError() &amp;&amp; sym.kind.matches(KindSelector.TYP))
3859                 return types.createErrorType(name, location, sym.type).tsym;
3860             else
3861                 return sym;
3862         }
3863     }
3864 
<span class="line-modified">3865     class BadRestrictedTypeError extends ResolveError {</span>
<span class="line-modified">3866         private final Name typeName;</span>
<span class="line-modified">3867         BadRestrictedTypeError(Name typeName) {</span>
<span class="line-added">3868             super(Kind.BAD_RESTRICTED_TYPE, &quot;bad var use&quot;);</span>
<span class="line-added">3869             this.typeName = typeName;</span>
3870         }
3871 
3872         @Override
3873         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<span class="line-modified">3874             return diags.create(dkind, log.currentSource(), pos, &quot;illegal.ref.to.restricted.type&quot;, typeName);</span>
3875         }
3876     }
3877 
3878     /**
3879      * InvalidSymbolError error class indicating that a symbol matching a
3880      * given name does not exists in a given site.
3881      */
3882     class SymbolNotFoundError extends ResolveError {
3883 
3884         SymbolNotFoundError(Kind kind) {
3885             this(kind, &quot;symbol not found error&quot;);
3886         }
3887 
3888         SymbolNotFoundError(Kind kind, String debugName) {
3889             super(kind, debugName);
3890         }
3891 
3892         @Override
3893         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3894                 DiagnosticPosition pos,
</pre>
<hr />
<pre>
4576 
4577     /**
4578      * Helper class for method resolution diagnostic simplification.
4579      * Certain resolution diagnostic are rewritten as simpler diagnostic
4580      * where the enclosing resolution diagnostic (i.e. &#39;inapplicable method&#39;)
4581      * is stripped away, as it doesn&#39;t carry additional info. The logic
4582      * for matching a given diagnostic is given in terms of a template
4583      * hierarchy: a diagnostic template can be specified programmatically,
4584      * so that only certain diagnostics are matched. Each templete is then
4585      * associated with a rewriter object that carries out the task of rewtiting
4586      * the diagnostic to a simpler one.
4587      */
4588     static class MethodResolutionDiagHelper {
4589 
4590         /**
4591          * A diagnostic rewriter transforms a method resolution diagnostic
4592          * into a simpler one
4593          */
4594         interface DiagnosticRewriter {
4595             JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
<span class="line-modified">4596                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,</span>
4597                     DiagnosticType preferredKind, JCDiagnostic d);
4598         }
4599 
4600         /**
4601          * A diagnostic template is made up of two ingredients: (i) a regular
4602          * expression for matching a diagnostic key and (ii) a list of sub-templates
4603          * for matching diagnostic arguments.
4604          */
4605         static class Template {
4606 
4607             /** regex used to match diag key */
4608             String regex;
4609 
4610             /** templates used to match diagnostic args */
4611             Template[] subTemplates;
4612 
4613             Template(String key, Template... subTemplates) {
4614                 this.regex = key;
4615                 this.subTemplates = subTemplates;
4616             }
</pre>
<hr />
<pre>
4632                     }
4633                 }
4634                 return true;
4635             }
4636         }
4637 
4638         /**
4639          * Common rewriter for all argument mismatch simplifications.
4640          */
4641         static class ArgMismatchRewriter implements DiagnosticRewriter {
4642 
4643             /** the index of the subdiagnostic to be used as primary. */
4644             int causeIndex;
4645 
4646             public ArgMismatchRewriter(int causeIndex) {
4647                 this.causeIndex = causeIndex;
4648             }
4649 
4650             @Override
4651             public JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
<span class="line-modified">4652                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,</span>
4653                     DiagnosticType preferredKind, JCDiagnostic d) {
4654                 JCDiagnostic cause = (JCDiagnostic)d.getArgs()[causeIndex];
4655                 DiagnosticPosition pos = d.getDiagnosticPosition();
4656                 if (pos == null) {
<span class="line-modified">4657                     pos = preferredPos;</span>
4658                 }
4659                 return diags.create(preferredKind, preferredSource, pos,
4660                         &quot;prob.found.req&quot;, cause);
4661             }
4662         }
4663 
4664         /** a dummy template that match any diagnostic argument */
4665         static final Template skip = new Template(&quot;&quot;) {
4666             @Override
4667             boolean matches(Object d) {
4668                 return true;
4669             }
4670         };
4671 
4672         /** template for matching inference-free arguments mismatch failures */
4673         static final Template argMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip);
4674 
4675         /** template for matching inference related arguments mismatch failures */
4676         static final Template inferArgMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip, skip) {
4677             @Override
</pre>
</td>
</tr>
</table>
<center><a href="Operators.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TransTypes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
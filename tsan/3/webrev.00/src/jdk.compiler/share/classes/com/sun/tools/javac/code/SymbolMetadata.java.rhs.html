<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/code/SymbolMetadata.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.code;
 27 
 28 
 29 import com.sun.tools.javac.code.Attribute.TypeCompound;
 30 import com.sun.tools.javac.code.Kinds.Kind;
 31 import com.sun.tools.javac.util.Assert;
 32 import com.sun.tools.javac.util.List;
 33 import com.sun.tools.javac.util.ListBuffer;
<a name="2" id="anc2"></a><span class="line-added"> 34 import com.sun.tools.javac.util.Pair;</span>
 35 
 36 /**
 37  * Container for all annotations (attributes in javac) on a Symbol.
 38  *
 39  * This class is explicitly mutable. Its contents will change when attributes
 40  * are annotated onto the Symbol. However this class depends on the facts that
 41  * List (in javac) is immutable.
 42  *
 43  * An instance of this class can be in one of three states:
 44  *
 45  * NOT_STARTED indicates that the Symbol this instance belongs to has not been
 46  * annotated (yet). Specifically if the declaration is not annotated this
 47  * instance will never move past NOT_STARTED. You can never go back to
 48  * NOT_STARTED.
 49  *
 50  * IN_PROGRESS annotations have been found on the declaration. Will be processed
 51  * later. You can reset to IN_PROGRESS. While IN_PROGRESS you can set the list
 52  * of attributes (and this moves out of the IN_PROGRESS state).
 53  *
 54  * &quot;unnamed&quot; this SymbolMetadata contains some attributes, possibly the final set.
 55  * While in this state you can only prepend or append to the attributes not set
 56  * it directly. You can also move back to the IN_PROGRESS state using reset().
 57  *
 58  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API. If you write code that depends
 59  * on this, you do so at your own risk. This code and its internal interfaces
 60  * are subject to change or deletion without notice.&lt;/b&gt;
 61  */
 62 public class SymbolMetadata {
 63 
 64     private static final List&lt;Attribute.Compound&gt; DECL_NOT_STARTED = List.of(null);
 65     private static final List&lt;Attribute.Compound&gt; DECL_IN_PROGRESS = List.of(null);
 66 
 67     /*
 68      * This field should never be null
 69      */
 70     private List&lt;Attribute.Compound&gt; attributes = DECL_NOT_STARTED;
 71 
 72     /*
 73      * Type attributes for this symbol.
 74      * This field should never be null.
 75      */
 76     private List&lt;Attribute.TypeCompound&gt; type_attributes = List.nil();
 77 
 78     /*
 79      * Type attributes of initializers in this class.
 80      * Unused if the current symbol is not a ClassSymbol.
 81      */
 82     private List&lt;Attribute.TypeCompound&gt; init_type_attributes = List.nil();
 83 
 84     /*
 85      * Type attributes of class initializers in this class.
 86      * Unused if the current symbol is not a ClassSymbol.
 87      */
 88     private List&lt;Attribute.TypeCompound&gt; clinit_type_attributes = List.nil();
 89 
 90     /*
 91      * The Symbol this SymbolMetadata instance belongs to
 92      */
 93     private final Symbol sym;
 94 
 95     public SymbolMetadata(Symbol sym) {
 96         this.sym = sym;
 97     }
 98 
 99     public List&lt;Attribute.Compound&gt; getDeclarationAttributes() {
100         return filterDeclSentinels(attributes);
101     }
102 
103     public List&lt;Attribute.TypeCompound&gt; getTypeAttributes() {
104         return type_attributes;
105     }
106 
107     public List&lt;Attribute.TypeCompound&gt; getInitTypeAttributes() {
108         return init_type_attributes;
109     }
110 
111     public List&lt;Attribute.TypeCompound&gt; getClassInitTypeAttributes() {
112         return clinit_type_attributes;
113     }
114 
115     public void setDeclarationAttributes(List&lt;Attribute.Compound&gt; a) {
116         Assert.check(pendingCompletion() || !isStarted());
117         if (a == null) {
118             throw new NullPointerException();
119         }
120         attributes = a;
121     }
122 
123     public void setTypeAttributes(List&lt;Attribute.TypeCompound&gt; a) {
124         if (a == null) {
125             throw new NullPointerException();
126         }
127         type_attributes = a;
128     }
129 
130     public void setInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; a) {
131         if (a == null) {
132             throw new NullPointerException();
133         }
134         init_type_attributes = a;
135     }
136 
137     public void setClassInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; a) {
138         if (a == null) {
139             throw new NullPointerException();
140         }
141         clinit_type_attributes = a;
142     }
143 
144     public void setAttributes(SymbolMetadata other) {
145         if (other == null) {
146             throw new NullPointerException();
147         }
148         setDeclarationAttributes(other.getDeclarationAttributes());
149         if ((sym.flags() &amp; Flags.BRIDGE) != 0) {
150             Assert.check(other.sym.kind == Kind.MTH);
151             ListBuffer&lt;TypeCompound&gt; typeAttributes = new ListBuffer&lt;&gt;();
152             for (TypeCompound tc : other.getTypeAttributes()) {
153                 // Carry over only contractual type annotations: i.e nothing interior to method body.
154                 if (!tc.position.type.isLocal())
155                     typeAttributes.append(tc);
156             }
157             setTypeAttributes(typeAttributes.toList());
158         } else {
159             setTypeAttributes(other.getTypeAttributes());
160         }
161         if (sym.kind == Kind.TYP) {
162             setInitTypeAttributes(other.getInitTypeAttributes());
163             setClassInitTypeAttributes(other.getClassInitTypeAttributes());
164         }
165     }
166 
167     public SymbolMetadata reset() {
168         attributes = DECL_IN_PROGRESS;
169         return this;
170     }
171 
172     public boolean isEmpty() {
173         return !isStarted()
174                 || pendingCompletion()
175                 || attributes.isEmpty();
176     }
177 
178     public boolean isTypesEmpty() {
179         return type_attributes.isEmpty();
180     }
181 
182     public boolean pendingCompletion() {
183         return attributes == DECL_IN_PROGRESS;
184     }
185 
186     public SymbolMetadata append(List&lt;Attribute.Compound&gt; l) {
187         attributes = filterDeclSentinels(attributes);
188 
189         if (l.isEmpty()) {
190             // no-op
191         } else if (attributes.isEmpty()) {
192             attributes = l;
193         } else {
194             attributes = attributes.appendList(l);
195         }
196         return this;
197     }
198 
199     public SymbolMetadata appendUniqueTypes(List&lt;Attribute.TypeCompound&gt; l) {
200         if (l.isEmpty()) {
201             // no-op
202         } else if (type_attributes.isEmpty()) {
203             type_attributes = l;
204         } else {
205             // TODO: in case we expect a large number of annotations, this
206             // might be inefficient.
207             for (Attribute.TypeCompound tc : l) {
208                 if (!type_attributes.contains(tc))
209                     type_attributes = type_attributes.append(tc);
210             }
211         }
212         return this;
213     }
214 
215     public SymbolMetadata appendInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
216         if (l.isEmpty()) {
217             // no-op
218         } else if (init_type_attributes.isEmpty()) {
219             init_type_attributes = l;
220         } else {
221             init_type_attributes = init_type_attributes.appendList(l);
222         }
223         return this;
224     }
225 
226     public SymbolMetadata appendClassInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
227         if (l.isEmpty()) {
228             // no-op
229         } else if (clinit_type_attributes.isEmpty()) {
230             clinit_type_attributes = l;
231         } else {
232             clinit_type_attributes = clinit_type_attributes.appendList(l);
233         }
234         return this;
235     }
236 
237     public SymbolMetadata prepend(List&lt;Attribute.Compound&gt; l) {
238         attributes = filterDeclSentinels(attributes);
239 
240         if (l.isEmpty()) {
241             // no-op
242         } else if (attributes.isEmpty()) {
243             attributes = l;
244         } else {
245             attributes = attributes.prependList(l);
246         }
247         return this;
248     }
249 
250     private List&lt;Attribute.Compound&gt; filterDeclSentinels(List&lt;Attribute.Compound&gt; a) {
251         return (a == DECL_IN_PROGRESS || a == DECL_NOT_STARTED)
252                 ? List.nil()
253                 : a;
254     }
255 
256     private boolean isStarted() {
257         return attributes != DECL_NOT_STARTED;
258     }
<a name="3" id="anc3"></a><span class="line-added">259 </span>
<span class="line-added">260     private List&lt;Attribute.Compound&gt; removeFromCompoundList(List&lt;Attribute.Compound&gt; l, Attribute.Compound compound) {</span>
<span class="line-added">261         ListBuffer&lt;Attribute.Compound&gt; lb = new ListBuffer&lt;&gt;();</span>
<span class="line-added">262         for (Attribute.Compound c : l) {</span>
<span class="line-added">263             if (c != compound) {</span>
<span class="line-added">264                 lb.add(c);</span>
<span class="line-added">265             }</span>
<span class="line-added">266         }</span>
<span class="line-added">267         return lb.toList();</span>
<span class="line-added">268     }</span>
<span class="line-added">269 </span>
<span class="line-added">270     public void removeDeclarationMetadata(Attribute.Compound compound) {</span>
<span class="line-added">271         if (attributes.contains(compound)) {</span>
<span class="line-added">272             attributes = removeFromCompoundList(attributes, compound);</span>
<span class="line-added">273         } else {</span>
<span class="line-added">274             // slow path, it could be that attributes list contains annotation containers, so we have to dig deeper</span>
<span class="line-added">275             for (Attribute.Compound attrCompound : attributes) {</span>
<span class="line-added">276                 if (attrCompound.isSynthesized() &amp;&amp; !attrCompound.values.isEmpty()) {</span>
<span class="line-added">277                     Pair&lt;Symbol.MethodSymbol, Attribute&gt; val = attrCompound.values.get(0);</span>
<span class="line-added">278                     if (val.fst.getSimpleName().contentEquals(&quot;value&quot;) &amp;&amp;</span>
<span class="line-added">279                             val.snd instanceof Attribute.Array) {</span>
<span class="line-added">280                         Attribute.Array arr = (Attribute.Array) val.snd;</span>
<span class="line-added">281                         if (arr.values.length != 0</span>
<span class="line-added">282                                 &amp;&amp; arr.values[0] instanceof Attribute.Compound</span>
<span class="line-added">283                                 &amp;&amp; arr.values[0].type == compound.type) {</span>
<span class="line-added">284                             attributes = removeFromCompoundList(attributes, attrCompound);</span>
<span class="line-added">285                         }</span>
<span class="line-added">286                     }</span>
<span class="line-added">287                 }</span>
<span class="line-added">288             }</span>
<span class="line-added">289         }</span>
<span class="line-added">290     }</span>
291 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
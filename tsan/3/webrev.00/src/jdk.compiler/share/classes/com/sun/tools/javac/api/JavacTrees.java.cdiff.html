<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/api/JavacTrees.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavacTaskPool.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../code/Attribute.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/api/JavacTrees.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,17 ***</span>
  package com.sun.tools.javac.api;
  
  import java.io.FileNotFoundException;
  import java.io.IOException;
  import java.text.BreakIterator;
<span class="line-modified">! import java.util.Collections;</span>
  import java.util.HashSet;
  import java.util.Map;
  import java.util.Set;
  import java.util.WeakHashMap;
<span class="line-removed">- import java.util.regex.Matcher;</span>
<span class="line-removed">- import java.util.regex.Pattern;</span>
  
  import javax.annotation.processing.ProcessingEnvironment;
  import javax.lang.model.element.AnnotationMirror;
  import javax.lang.model.element.AnnotationValue;
  import javax.lang.model.element.Element;
<span class="line-new-header">--- 26,16 ---</span>
  package com.sun.tools.javac.api;
  
  import java.io.FileNotFoundException;
  import java.io.IOException;
  import java.text.BreakIterator;
<span class="line-modified">! import java.util.HashMap;</span>
  import java.util.HashSet;
  import java.util.Map;
<span class="line-added">+ import java.util.Map.Entry;</span>
  import java.util.Set;
  import java.util.WeakHashMap;
  
  import javax.annotation.processing.ProcessingEnvironment;
  import javax.lang.model.element.AnnotationMirror;
  import javax.lang.model.element.AnnotationValue;
  import javax.lang.model.element.Element;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,28 ***</span>
  import javax.tools.JavaFileObject.Kind;
  import javax.tools.StandardLocation;
  
  import com.sun.source.doctree.DocCommentTree;
  import com.sun.source.doctree.DocTree;
<span class="line-removed">- import com.sun.source.doctree.EndElementTree;</span>
<span class="line-removed">- import com.sun.source.doctree.StartElementTree;</span>
  import com.sun.source.tree.CatchTree;
  import com.sun.source.tree.CompilationUnitTree;
  import com.sun.source.tree.Scope;
  import com.sun.source.tree.Tree;
  import com.sun.source.util.DocSourcePositions;
  import com.sun.source.util.DocTreePath;
  import com.sun.source.util.DocTreeScanner;
  import com.sun.source.util.DocTrees;
  import com.sun.source.util.JavacTask;
<span class="line-removed">- import com.sun.source.util.SimpleDocTreeVisitor;</span>
  import com.sun.source.util.TreePath;
  import com.sun.tools.javac.code.Flags;
  import com.sun.tools.javac.code.Scope.NamedImportScope;
  import com.sun.tools.javac.code.Scope.StarImportScope;
  import com.sun.tools.javac.code.Scope.WriteableScope;
<span class="line-removed">- import com.sun.tools.javac.code.Symbol;</span>
  import com.sun.tools.javac.code.Symbol.ClassSymbol;
  import com.sun.tools.javac.code.Symbol.MethodSymbol;
  import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  import com.sun.tools.javac.code.Symbol.PackageSymbol;
  import com.sun.tools.javac.code.Symbol.TypeSymbol;
<span class="line-new-header">--- 57,25 ---</span>
  import javax.tools.JavaFileObject.Kind;
  import javax.tools.StandardLocation;
  
  import com.sun.source.doctree.DocCommentTree;
  import com.sun.source.doctree.DocTree;
  import com.sun.source.tree.CatchTree;
<span class="line-added">+ import com.sun.source.tree.ClassTree;</span>
  import com.sun.source.tree.CompilationUnitTree;
  import com.sun.source.tree.Scope;
  import com.sun.source.tree.Tree;
  import com.sun.source.util.DocSourcePositions;
  import com.sun.source.util.DocTreePath;
  import com.sun.source.util.DocTreeScanner;
  import com.sun.source.util.DocTrees;
  import com.sun.source.util.JavacTask;
  import com.sun.source.util.TreePath;
  import com.sun.tools.javac.code.Flags;
  import com.sun.tools.javac.code.Scope.NamedImportScope;
  import com.sun.tools.javac.code.Scope.StarImportScope;
  import com.sun.tools.javac.code.Scope.WriteableScope;
  import com.sun.tools.javac.code.Symbol.ClassSymbol;
  import com.sun.tools.javac.code.Symbol.MethodSymbol;
  import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  import com.sun.tools.javac.code.Symbol.PackageSymbol;
  import com.sun.tools.javac.code.Symbol.TypeSymbol;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,15 ***</span>
<span class="line-new-header">--- 88,17 ---</span>
  import com.sun.tools.javac.code.Type.UnionClassType;
  import com.sun.tools.javac.code.Types;
  import com.sun.tools.javac.code.Types.TypeRelation;
  import com.sun.tools.javac.comp.Attr;
  import com.sun.tools.javac.comp.AttrContext;
<span class="line-added">+ import com.sun.tools.javac.comp.Check;</span>
  import com.sun.tools.javac.comp.Enter;
  import com.sun.tools.javac.comp.Env;
  import com.sun.tools.javac.comp.MemberEnter;
  import com.sun.tools.javac.comp.Modules;
  import com.sun.tools.javac.comp.Resolve;
<span class="line-added">+ import com.sun.tools.javac.code.Symbol;</span>
  import com.sun.tools.javac.file.BaseFileManager;
  import com.sun.tools.javac.model.JavacElements;
  import com.sun.tools.javac.parser.DocCommentParser;
  import com.sun.tools.javac.parser.ParserFactory;
  import com.sun.tools.javac.parser.Tokens.Comment;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,12 ***</span>
<span class="line-new-header">--- 107,14 ---</span>
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
  import com.sun.tools.javac.resources.CompilerProperties.Notes;
  import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  import com.sun.tools.javac.tree.DCTree;
  import com.sun.tools.javac.tree.DCTree.DCBlockTag;
<span class="line-added">+ import com.sun.tools.javac.tree.DCTree.DCComment;</span>
  import com.sun.tools.javac.tree.DCTree.DCDocComment;
  import com.sun.tools.javac.tree.DCTree.DCEndPosTree;
<span class="line-added">+ import com.sun.tools.javac.tree.DCTree.DCEntity;</span>
  import com.sun.tools.javac.tree.DCTree.DCErroneous;
  import com.sun.tools.javac.tree.DCTree.DCIdentifier;
  import com.sun.tools.javac.tree.DCTree.DCParam;
  import com.sun.tools.javac.tree.DCTree.DCReference;
  import com.sun.tools.javac.tree.DCTree.DCText;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,10 ***</span>
<span class="line-new-header">--- 131,11 ---</span>
  import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
  import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
  import com.sun.tools.javac.tree.TreeCopier;
  import com.sun.tools.javac.tree.TreeInfo;
  import com.sun.tools.javac.tree.TreeMaker;
<span class="line-added">+ import com.sun.tools.javac.tree.TreeScanner;</span>
  import com.sun.tools.javac.util.Abort;
  import com.sun.tools.javac.util.Assert;
  import com.sun.tools.javac.util.Context;
  import com.sun.tools.javac.util.DefinedBy;
  import com.sun.tools.javac.util.DefinedBy.Api;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 169,10 ***</span>
<span class="line-new-header">--- 170,11 ---</span>
      private Resolve resolve;
      private Enter enter;
      private Log log;
      private MemberEnter memberEnter;
      private Attr attr;
<span class="line-added">+     private Check chk;</span>
      private TreeMaker treeMaker;
      private JavacElements elements;
      private JavacTaskImpl javacTaskImpl;
      private Names names;
      private Types types;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 216,10 ***</span>
<span class="line-new-header">--- 218,11 ---</span>
      }
  
      private void init(Context context) {
          modules = Modules.instance(context);
          attr = Attr.instance(context);
<span class="line-added">+         chk = Check.instance(context);</span>
          enter = Enter.instance(context);
          elements = JavacElements.instance(context);
          log = Log.instance(context);
          resolve = Resolve.instance(context);
          treeMaker = TreeMaker.instance(context);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,10 ***</span>
<span class="line-new-header">--- 302,18 ---</span>
  
                              DCBlockTag block = (DCBlockTag) tree;
  
                              return dcComment.comment.getSourcePos(block.pos + block.getTagName().length() + 1);
                          }
<span class="line-added">+                         case ENTITY: {</span>
<span class="line-added">+                             DCEntity endEl = (DCEntity) tree;</span>
<span class="line-added">+                             return dcComment.comment.getSourcePos(endEl.pos + (endEl.name != names.error ? endEl.name.length() : 0) + 2);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         case COMMENT: {</span>
<span class="line-added">+                             DCComment endEl = (DCComment) tree;</span>
<span class="line-added">+                             return dcComment.comment.getSourcePos(endEl.pos + endEl.body.length());</span>
<span class="line-added">+                         }</span>
                          default:
                              DocTree last = getLastChild(tree);
  
                              if (last != null) {
                                  return getEndPosition(file, comment, last);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,14 ***</span>
          return sym;
      }
  
      @Override @DefinedBy(Api.COMPILER_TREE)
      public Element getElement(DocTreePath path) {
<span class="line-modified">!         DocTree forTree = path.getLeaf();</span>
<span class="line-modified">!         if (forTree instanceof DCReference)</span>
<span class="line-modified">!             return attributeDocReference(path.getTreePath(), ((DCReference) forTree));</span>
<span class="line-modified">!         if (forTree instanceof DCIdentifier) {</span>
              if (path.getParentPath().getLeaf() instanceof DCParam) {
                  return attributeParamIdentifier(path.getTreePath(), (DCParam) path.getParentPath().getLeaf());
              }
          }
          return null;
<span class="line-new-header">--- 418,14 ---</span>
          return sym;
      }
  
      @Override @DefinedBy(Api.COMPILER_TREE)
      public Element getElement(DocTreePath path) {
<span class="line-modified">!         DocTree tree = path.getLeaf();</span>
<span class="line-modified">!         if (tree instanceof DCReference)</span>
<span class="line-modified">!             return attributeDocReference(path.getTreePath(), ((DCReference) tree));</span>
<span class="line-modified">!         if (tree instanceof DCIdentifier) {</span>
              if (path.getParentPath().getLeaf() instanceof DCParam) {
                  return attributeParamIdentifier(path.getTreePath(), (DCParam) path.getParentPath().getLeaf());
              }
          }
          return null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 523,28 ***</span>
          } finally {
              log.popDiagnosticHandler(deferredDiagnosticHandler);
          }
      }
  
<span class="line-modified">!     private Symbol attributeParamIdentifier(TreePath path, DCParam ptag) {</span>
          Symbol javadocSymbol = getElement(path);
          if (javadocSymbol == null)
              return null;
          ElementKind kind = javadocSymbol.getKind();
          List&lt;? extends Symbol&gt; params = List.nil();
          if (kind == ElementKind.METHOD || kind == ElementKind.CONSTRUCTOR) {
              MethodSymbol ee = (MethodSymbol) javadocSymbol;
<span class="line-modified">!             params = ptag.isTypeParameter()</span>
                      ? ee.getTypeParameters()
                      : ee.getParameters();
          } else if (kind.isClass() || kind.isInterface()) {
              ClassSymbol te = (ClassSymbol) javadocSymbol;
<span class="line-modified">!             params = te.getTypeParameters();</span>
          }
  
          for (Symbol param : params) {
<span class="line-modified">!             if (param.getSimpleName() == ptag.getName().getName()) {</span>
                  return param;
              }
          }
          return null;
      }
<span class="line-new-header">--- 534,30 ---</span>
          } finally {
              log.popDiagnosticHandler(deferredDiagnosticHandler);
          }
      }
  
<span class="line-modified">!     private Symbol attributeParamIdentifier(TreePath path, DCParam paramTag) {</span>
          Symbol javadocSymbol = getElement(path);
          if (javadocSymbol == null)
              return null;
          ElementKind kind = javadocSymbol.getKind();
          List&lt;? extends Symbol&gt; params = List.nil();
          if (kind == ElementKind.METHOD || kind == ElementKind.CONSTRUCTOR) {
              MethodSymbol ee = (MethodSymbol) javadocSymbol;
<span class="line-modified">!             params = paramTag.isTypeParameter()</span>
                      ? ee.getTypeParameters()
                      : ee.getParameters();
          } else if (kind.isClass() || kind.isInterface()) {
              ClassSymbol te = (ClassSymbol) javadocSymbol;
<span class="line-modified">!             params = paramTag.isTypeParameter()</span>
<span class="line-added">+                     ? te.getTypeParameters()</span>
<span class="line-added">+                     : te.getRecordComponents();</span>
          }
  
          for (Symbol param : params) {
<span class="line-modified">!             if (param.getSimpleName() == paramTag.getName().getName()) {</span>
                  return param;
              }
          }
          return null;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 913,49 ***</span>
  //                    System.err.println(&quot;BLOCK: &quot;);
                      if (method != null) {
                          try {
                              Assert.check(method.body == tree);
                              method.body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
<span class="line-modified">!                             env = attribStatToTree(method.body, env, copier.leafCopy);</span>
                          } finally {
                              method.body = (JCBlock) tree;
                          }
                      } else {
                          JCBlock body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
<span class="line-modified">!                         env = attribStatToTree(body, env, copier.leafCopy);</span>
                      }
                      return env;
                  }
                  default:
  //                    System.err.println(&quot;DEFAULT: &quot; + tree.getKind());
                      if (field != null &amp;&amp; field.getInitializer() == tree) {
                          env = memberEnter.getInitEnv(field, env);
                          JCExpression expr = copier.copy((JCExpression)tree, (JCTree) path.getLeaf());
<span class="line-modified">!                         env = attribExprToTree(expr, env, copier.leafCopy);</span>
                          return env;
                      }
              }
          }
          return (field != null) ? memberEnter.getInitEnv(field, env) : env;
      }
  
<span class="line-modified">!     private Env&lt;AttrContext&gt; attribStatToTree(JCTree stat, Env&lt;AttrContext&gt;env, JCTree tree) {</span>
<span class="line-modified">!         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             return attr.attribStatToTree(stat, env, tree);</span>
<span class="line-modified">!         } finally {</span>
<span class="line-modified">!             log.useSource(prev);</span>
          }
      }
  
<span class="line-modified">!     private Env&lt;AttrContext&gt; attribExprToTree(JCExpression expr, Env&lt;AttrContext&gt;env, JCTree tree) {</span>
<span class="line-modified">!         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             return attr.attribExprToTree(expr, env, tree);</span>
<span class="line-modified">!         } finally {</span>
<span class="line-modified">!             log.useSource(prev);</span>
          }
      }
  
      static JavaFileObject asJavaFileObject(FileObject fileObject) {
          JavaFileObject jfo = null;
  
<span class="line-new-header">--- 926,148 ---</span>
  //                    System.err.println(&quot;BLOCK: &quot;);
                      if (method != null) {
                          try {
                              Assert.check(method.body == tree);
                              method.body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
<span class="line-modified">!                             env = attribStatToTree(method.body, env, copier.leafCopy, copier.copiedClasses);</span>
                          } finally {
                              method.body = (JCBlock) tree;
                          }
                      } else {
                          JCBlock body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
<span class="line-modified">!                         env = attribStatToTree(body, env, copier.leafCopy, copier.copiedClasses);</span>
                      }
                      return env;
                  }
                  default:
  //                    System.err.println(&quot;DEFAULT: &quot; + tree.getKind());
                      if (field != null &amp;&amp; field.getInitializer() == tree) {
                          env = memberEnter.getInitEnv(field, env);
                          JCExpression expr = copier.copy((JCExpression)tree, (JCTree) path.getLeaf());
<span class="line-modified">!                         env = attribExprToTree(expr, env, copier.leafCopy, copier.copiedClasses);</span>
                          return env;
                      }
              }
          }
          return (field != null) ? memberEnter.getInitEnv(field, env) : env;
      }
  
<span class="line-modified">!     private Env&lt;AttrContext&gt; attribStatToTree(JCTree stat, Env&lt;AttrContext&gt;env,</span>
<span class="line-modified">!                                               JCTree tree, Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses) {</span>
<span class="line-modified">!         Env&lt;AttrContext&gt; result = attr.attribStatToTree(stat, env, tree);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         fixLocalClassNames(copiedClasses, env);</span>
<span class="line-modified">! </span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private Env&lt;AttrContext&gt; attribExprToTree(JCExpression expr, Env&lt;AttrContext&gt;env,</span>
<span class="line-added">+                                               JCTree tree, Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses) {</span>
<span class="line-added">+         Env&lt;AttrContext&gt; result = attr.attribExprToTree(expr, env, tree);</span>
<span class="line-added">+ </span>
<span class="line-added">+         fixLocalClassNames(copiedClasses, env);</span>
<span class="line-added">+ </span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Change the flatnames of the local and anonymous classes in the Scope to</span>
<span class="line-added">+      * the names they would have if the whole file was attributed normally.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void fixLocalClassNames(Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses,</span>
<span class="line-added">+                                     Env&lt;AttrContext&gt; lastEnv) {</span>
<span class="line-added">+         Map&lt;JCClassDecl, Name&gt; flatnameForClass = null;</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (Entry&lt;JCClassDecl, JCClassDecl&gt; e : copiedClasses.entrySet()) {</span>
<span class="line-added">+             if (e.getKey().sym != null) {</span>
<span class="line-added">+                 Name origName;</span>
<span class="line-added">+                 if (e.getValue().sym != null) {</span>
<span class="line-added">+                     //if the source tree was already attributed, use the flatname</span>
<span class="line-added">+                     //from the source tree&#39;s Symbol:</span>
<span class="line-added">+                     origName = e.getValue().sym.flatname;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     //otherwise, compute the flatnames (for source trees) as</span>
<span class="line-added">+                     //if the full source code would be attributed:</span>
<span class="line-added">+                     if (flatnameForClass == null) {</span>
<span class="line-added">+                         flatnameForClass = prepareFlatnameForClass(lastEnv);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     origName = flatnameForClass.get(e.getValue());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (origName != null) {</span>
<span class="line-added">+                     e.getKey().sym.flatname = origName;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
          }
      }
  
<span class="line-modified">!     /* This method computes and assigns flatnames to trees, as if they would be</span>
<span class="line-modified">!      * normally assigned during attribution of the full source code.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private Map&lt;JCTree.JCClassDecl, Name&gt; prepareFlatnameForClass(Env&lt;AttrContext&gt; env) {</span>
<span class="line-modified">!         Map&lt;JCClassDecl, Name&gt; flatNameForClass = new HashMap&lt;&gt;();</span>
<span class="line-modified">!         Symbol enclClass = env.enclClass.sym;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (enclClass != null &amp;&amp; (enclClass.flags_field &amp; Flags.UNATTRIBUTED) != 0) {</span>
<span class="line-added">+             ListBuffer&lt;ClassSymbol&gt; toClear = new ListBuffer&lt;&gt;();</span>
<span class="line-added">+             new TreeScanner() {</span>
<span class="line-added">+                 Symbol owner;</span>
<span class="line-added">+                 boolean localContext;</span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public void visitClassDef(JCClassDecl tree) {</span>
<span class="line-added">+                     //compute the name (and ClassSymbol) which would be used</span>
<span class="line-added">+                     //for this class for full attribution</span>
<span class="line-added">+                     Symbol prevOwner = owner;</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         ClassSymbol c;</span>
<span class="line-added">+                         if (tree.sym != null) {</span>
<span class="line-added">+                             //already entered:</span>
<span class="line-added">+                             c = tree.sym;</span>
<span class="line-added">+                         } else {</span>
<span class="line-added">+                             c = syms.defineClass(tree.name, owner);</span>
<span class="line-added">+                             if (owner.kind != TYP) {</span>
<span class="line-added">+                                 //for local classes, assign the flatname</span>
<span class="line-added">+                                 c.flatname = chk.localClassName(c);</span>
<span class="line-added">+                                 chk.putCompiled(c);</span>
<span class="line-added">+                                 toClear.add(c);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                             flatNameForClass.put(tree, c.flatname);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         owner = c;</span>
<span class="line-added">+                         super.visitClassDef(tree);</span>
<span class="line-added">+                     } finally {</span>
<span class="line-added">+                         owner = prevOwner;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public void visitBlock(JCBlock tree) {</span>
<span class="line-added">+                     Symbol prevOwner = owner;</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         owner = new MethodSymbol(0, names.empty, Type.noType, owner);</span>
<span class="line-added">+                         super.visitBlock(tree);</span>
<span class="line-added">+                     } finally {</span>
<span class="line-added">+                         owner = prevOwner;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public void visitVarDef(JCVariableDecl tree) {</span>
<span class="line-added">+                     Symbol prevOwner = owner;</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         owner = new MethodSymbol(0, names.empty, Type.noType, owner);</span>
<span class="line-added">+                         super.visitVarDef(tree);</span>
<span class="line-added">+                     } finally {</span>
<span class="line-added">+                         owner = prevOwner;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }.scan(env.enclClass);</span>
<span class="line-added">+             //revert changes done by the visitor:</span>
<span class="line-added">+             toClear.stream().forEach(c -&gt; {</span>
<span class="line-added">+                 chk.clearLocalClassNameIndexes(c);</span>
<span class="line-added">+                 chk.removeCompiled(c);</span>
<span class="line-added">+             });</span>
          }
<span class="line-added">+ </span>
<span class="line-added">+         return flatNameForClass;</span>
      }
  
      static JavaFileObject asJavaFileObject(FileObject fileObject) {
          JavaFileObject jfo = null;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1063,10 ***</span>
<span class="line-new-header">--- 1175,11 ---</span>
      /**
       * Makes a copy of a tree, noting the value resulting from copying a particular leaf.
       **/
      protected static class Copier extends TreeCopier&lt;JCTree&gt; {
          JCTree leafCopy = null;
<span class="line-added">+         private Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses = new HashMap&lt;&gt;();</span>
  
          protected Copier(TreeMaker M) {
              super(M);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1075,10 ***</span>
<span class="line-new-header">--- 1188,18 ---</span>
              T t2 = super.copy(t, leaf);
              if (t == leaf)
                  leafCopy = t2;
              return t2;
          }
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public JCTree visitClass(ClassTree node, JCTree p) {</span>
<span class="line-added">+             JCTree nue = super.visitClass(node, p);</span>
<span class="line-added">+             copiedClasses.put((JCClassDecl) nue, (JCClassDecl) node);</span>
<span class="line-added">+             return nue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
      }
  
      protected Copier createCopier(TreeMaker maker) {
          return new Copier(maker);
      }
</pre>
<center><a href="JavacTaskPool.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../code/Attribute.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
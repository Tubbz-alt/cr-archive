<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 #
<a name="1" id="anc1"></a><span class="line-modified">   2 # Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4 #
   5 # This code is free software; you can redistribute it and/or modify it
   6 # under the terms of the GNU General Public License version 2 only, as
   7 # published by the Free Software Foundation.  Oracle designates this
   8 # particular file as subject to the &quot;Classpath&quot; exception as provided
   9 # by Oracle in the LICENSE file that accompanied this code.
  10 #
  11 # This code is distributed in the hope that it will be useful, but WITHOUT
  12 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14 # version 2 for more details (a copy is included in the LICENSE file that
  15 # accompanied this code).
  16 #
  17 # You should have received a copy of the GNU General Public License version
  18 # 2 along with this work; if not, write to the Free Software Foundation,
  19 # Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20 #
  21 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22 # or visit www.oracle.com if you need additional information or have any
  23 # questions.
  24 #
  25 
  26 # Messages in this file which use &quot;placeholders&quot; for values (e.g. {0}, {1})
  27 # are preceded by a stylized comment describing the type of the corresponding
  28 # values.
  29 # The simple types currently in use are:
  30 #
  31 # annotation        annotation compound
  32 # boolean           true or false
  33 # diagnostic        a sub-message; see compiler.misc.*
  34 # fragment          similar to &#39;message segment&#39;, but with more specific type
  35 # modifier          a Java modifier; e.g. public, private, protected
  36 # file              a file URL
  37 # file object       a file URL - similar to &#39;file&#39; but typically used for source/class files, hence more specific
  38 # flag              a Flags.Flag instance
  39 # name              a name, typically a Java identifier
  40 # number            an integer
  41 # option name       the name of a command line option
  42 # path              a path
  43 # profile           a profile name
  44 # source            a source version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.code.Source
  45 # source version    a source version number, such as 1.5, 1.6, 1.7, taken from a javax.lang.model.SourceVersion
  46 # string            a general string
  47 # symbol            the name of a declared type
  48 # symbol kind       the kind of a symbol (i.e. method, variable)
  49 # kind name         an informative description of the kind of a declaration; see compiler.misc.kindname.*
  50 # target            a target version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.jvm.Target
  51 # token             the name of a non-terminal in source code; see compiler.misc.token.*
  52 # tree tag          the name of a non-terminal in source code; see compiler.misc.token.*
  53 # type              a Java type; e.g. int, X, X&lt;T&gt;
  54 # url               a URL
  55 # object            a Java object (unspecified)
  56 # unused            the value is not used in this message
  57 #
  58 # The following compound types are also used:
  59 #
  60 # collection of X   a comma-separated collection of items; e.g. collection of type
  61 # list of X         a comma-separated list of items; e.g. list of type
  62 # set of X          a comma-separated set of items; e.g. set of modifier
  63 #
  64 # These may be composed:
  65 #
  66 # list of type or message segment
  67 #
  68 # The following type aliases are supported:
  69 #
  70 # message segment --&gt; diagnostic or fragment
  71 # file name --&gt; file, path or file object
  72 #
  73 # Custom comments are supported in parenthesis i.e.
  74 #
  75 # number (classfile major version)
  76 #
  77 # These comments are used internally in order to generate an enum-like class declaration containing
  78 # a method/field for each of the diagnostic keys listed here. Those methods/fields can then be used
  79 # by javac code to build diagnostics in a type-safe fashion.
  80 #
  81 # In addition, these comments are verified by the jtreg test test/tools/javac/diags/MessageInfo,
  82 # using info derived from the collected set of examples in test/tools/javac/diags/examples.
  83 # MessageInfo can also be run as a standalone utility providing more facilities
  84 # for manipulating this file. For more details, see MessageInfo.java.
  85 
  86 ##
  87 ## errors
  88 ##
  89 
  90 # 0: symbol
  91 compiler.err.abstract.cant.be.instantiated=\
  92     {0} is abstract; cannot be instantiated
  93 
  94 compiler.err.abstract.meth.cant.have.body=\
  95     abstract methods cannot have a body
  96 
  97 # 0: kind name, 1: symbol
  98 compiler.err.already.annotated=\
  99     {0} {1} has already been annotated
 100 
 101 # 0: kind name, 1: symbol, 2: kind name, 3: symbol
 102 compiler.err.already.defined=\
 103     {0} {1} is already defined in {2} {3}
 104 
 105 # 0: kind name, 1: symbol, 2: kind name, 3: kind name, 4: symbol
 106 compiler.err.already.defined.in.clinit=\
 107     {0} {1} is already defined in {2} of {3} {4}
 108 
 109 # 0: symbol
 110 compiler.err.already.defined.single.import=\
 111     a type with the same simple name is already defined by the single-type-import of {0}
 112 
 113 # 0: symbol
 114 compiler.err.already.defined.static.single.import=\
 115     a type with the same simple name is already defined by the static single-type-import of {0}
 116 
 117 # 0: symbol
 118 compiler.err.already.defined.this.unit=\
 119     {0} is already defined in this compilation unit
 120 
 121 # 0: type, 1: list of name
 122 compiler.err.annotation.missing.default.value=\
 123     annotation @{0} is missing a default value for the element &#39;&#39;{1}&#39;&#39;
 124 
 125 # 0: type, 1: list of name
 126 compiler.err.annotation.missing.default.value.1=\
 127     annotation @{0} is missing default values for elements {1}
 128 
 129 # 0: type
 130 compiler.err.annotation.not.valid.for.type=\
 131     annotation not valid for an element of type {0}
 132 
 133 compiler.err.annotation.type.not.applicable=\
 134     annotation type not applicable to this kind of declaration
 135 
 136 # 0: type
 137 compiler.err.annotation.type.not.applicable.to.type=\
 138     annotation @{0} not applicable in this type context
 139 
 140 compiler.err.annotation.value.must.be.annotation=\
 141     annotation value must be an annotation
 142 
 143 compiler.err.annotation.value.must.be.class.literal=\
 144     annotation value must be a class literal
 145 
 146 compiler.err.annotation.value.must.be.name.value=\
 147     annotation values must be of the form &#39;&#39;name=value&#39;&#39;
 148 
 149 compiler.err.annotation.value.not.allowable.type=\
 150     annotation value not of an allowable type
 151 
 152 compiler.err.expression.not.allowable.as.annotation.value=\
 153     expression not allowed as annotation value
 154 
 155 compiler.err.anon.class.impl.intf.no.args=\
 156     anonymous class implements interface; cannot have arguments
 157 
 158 compiler.err.anon.class.impl.intf.no.typeargs=\
 159     anonymous class implements interface; cannot have type arguments
 160 
 161 compiler.err.anon.class.impl.intf.no.qual.for.new=\
 162     anonymous class implements interface; cannot have qualifier for new
 163 
 164 compiler.err.cant.inherit.from.anon=\
 165     cannot inherit from anonymous class
 166 
 167 # 0: symbol, 1: symbol, 2: symbol
 168 compiler.err.array.and.varargs=\
 169     cannot declare both {0} and {1} in {2}
 170 
 171 compiler.err.array.dimension.missing=\
 172     array dimension missing
 173 
 174 compiler.err.illegal.array.creation.both.dimension.and.initialization=\
 175     array creation with both dimension expression and initialization is illegal
 176 
 177 # 0: type
 178 compiler.err.array.req.but.found=\
 179     array required, but {0} found
 180 
 181 compiler.err.attribute.value.must.be.constant=\
 182     element value must be a constant expression
 183 
 184 # 0: string (statement type)
 185 compiler.err.bad.initializer=\
 186     bad initializer for {0}
 187 
 188 compiler.err.break.outside.switch.loop=\
 189     break outside switch or loop
 190 
<a name="2" id="anc2"></a><span class="line-removed"> 191 compiler.err.break.missing.value=\</span>
<span class="line-removed"> 192     missing break value</span>
<span class="line-removed"> 193 </span>
 194 compiler.err.break.outside.switch.expression=\
<a name="3" id="anc3"></a><span class="line-modified"> 195     break outside of enclosing switch expression</span>
 196 
 197 compiler.err.continue.outside.switch.expression=\
<a name="4" id="anc4"></a><span class="line-modified"> 198     continue outside of enclosing switch expression</span>
 199 
 200 compiler.err.return.outside.switch.expression=\
<a name="5" id="anc5"></a><span class="line-modified"> 201     return outside of enclosing switch expression</span>
 202 
 203 compiler.err.rule.completes.normally=\
 204     switch rule completes without providing a value\n\
 205     (switch rules in switch expressions must either provide a value or throw)
 206 
 207 compiler.err.switch.expression.completes.normally=\
 208     switch expression completes without providing a value\n\
 209     (switch expressions must either provide a value or throw for all possible input values)
 210 
<a name="6" id="anc6"></a><span class="line-modified"> 211 # 0: name</span>
<span class="line-modified"> 212 compiler.err.break.ambiguous.target=\</span>
<span class="line-modified"> 213     ambiguous reference to &#39;&#39;{0}&#39;&#39;\n\</span>
<span class="line-modified"> 214     (&#39;&#39;{0}&#39;&#39; is both a label and an expression)</span>


 215 
<a name="7" id="anc7"></a><span class="line-modified"> 216 # 0: tree tag</span>
<span class="line-modified"> 217 compiler.err.break.expr.not.immediate=\</span>
<span class="line-modified"> 218     value break not supported in &#39;&#39;{0}&#39;&#39;</span>
 219 
<a name="8" id="anc8"></a><span class="line-modified"> 220 compiler.err.break.complex.value.no.switch.expression=\</span>
<span class="line-modified"> 221     unexpected value break</span>

 222 
 223 compiler.err.switch.expression.empty=\
 224     switch expression does not have any case clauses
 225 
<a name="9" id="anc9"></a>


 226 # 0: name
 227 compiler.err.call.must.be.first.stmt.in.ctor=\
 228     call to {0} must be first statement in constructor
 229 
 230 # 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
 231 compiler.err.cant.apply.symbol=\
 232     {0} {1} in {4} {5} cannot be applied to given types;\n\
 233     required: {2}\n\
 234     found:    {3}\n\
 235     reason: {6}
 236 
 237 # 0: symbol kind, 1: name, 2: list of type
 238 compiler.err.cant.apply.symbols=\
 239     no suitable {0} found for {1}({2})
 240 
 241 # 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
 242 compiler.misc.cant.apply.symbol=\
 243     {0} {1} in {4} {5} cannot be applied to given types\n\
 244     required: {2}\n\
 245     found:    {3}\n\
 246     reason: {6}
 247 
 248 # 0: symbol kind, 1: name, 2: list of type
 249 compiler.misc.cant.apply.symbols=\
 250     no suitable {0} found for {1}({2})
 251 
 252 # 0: kind name, 1: symbol
 253 compiler.misc.no.abstracts=\
 254     no abstract method found in {0} {1}
 255 
 256 # 0: kind name, 1: symbol
 257 compiler.misc.incompatible.abstracts=\
 258     multiple non-overriding abstract methods found in {0} {1}
 259 
 260 compiler.err.bad.functional.intf.anno=\
 261     Unexpected @FunctionalInterface annotation
 262 
 263 # 0: message segment
 264 compiler.err.bad.functional.intf.anno.1=\
 265     Unexpected @FunctionalInterface annotation\n\
 266     {0}
 267 
 268 # 0: message segment
 269 compiler.err.anonymous.diamond.method.does.not.override.superclass=\
 270     method does not override or implement a method from a supertype\n\
 271     {0}
 272 
 273 # 0: symbol
 274 compiler.misc.not.a.functional.intf=\
 275     {0} is not a functional interface
 276 
 277 # 0: symbol, 1: message segment
 278 compiler.misc.not.a.functional.intf.1=\
 279     {0} is not a functional interface\n\
 280     {1}
 281 
 282 # 0: type, 1: kind name, 2: symbol
 283 compiler.misc.invalid.generic.lambda.target=\
 284     invalid functional descriptor for lambda expression\n\
 285     method {0} in {1} {2} is generic
 286 
 287 # 0: kind name, 1: symbol
 288 compiler.misc.incompatible.descs.in.functional.intf=\
 289     incompatible function descriptors found in {0} {1}
 290 
 291 # 0: name, 1: list of type, 2: type, 3: list of type
 292 compiler.misc.descriptor=\
 293     descriptor: {2} {0}({1})
 294 
 295 # 0: name, 1: list of type, 2: type, 3: list of type
 296 compiler.misc.descriptor.throws=\
 297     descriptor: {2} {0}({1}) throws {3}
 298 
 299 # 0: type
 300 compiler.misc.no.suitable.functional.intf.inst=\
 301     cannot infer functional interface descriptor for {0}
 302 
 303 # 0: message segment
 304 compiler.misc.bad.intersection.target.for.functional.expr=\
 305     bad intersection type target for lambda or method reference\n\
 306     {0}
 307 
 308 # 0: symbol or type
 309 compiler.misc.not.an.intf.component=\
 310     component type {0} is not an interface
 311 
 312 # 0: kind name, 1: message segment
 313 compiler.err.invalid.mref=\
 314     invalid {0} reference\n\
 315     {1}
 316 
 317 # 0: kind name, 1: message segment
 318 compiler.misc.invalid.mref=\
 319     invalid {0} reference\n\
 320     {1}
 321 
 322 compiler.misc.static.mref.with.targs=\
 323     parameterized qualifier on static method reference
 324 
 325 # 0: symbol
 326 compiler.err.cant.assign.val.to.final.var=\
 327     cannot assign a value to final variable {0}
 328 
 329 compiler.err.cant.assign.val.to.this=\
 330     cannot assign to &#39;&#39;this&#39;&#39;
 331 
 332 # 0: symbol, 1: message segment
 333 compiler.err.cant.ref.non.effectively.final.var=\
 334     local variables referenced from {1} must be final or effectively final
 335 
 336 compiler.err.try.with.resources.expr.needs.var=\
 337     the try-with-resources resource must either be a variable declaration or an expression denoting \
 338 a reference to a final or effectively final variable
 339 
 340 # 0: symbol
 341 compiler.err.try.with.resources.expr.effectively.final.var=\
 342     variable {0} used as a try-with-resources resource neither final nor effectively final
 343 
 344 
 345 compiler.misc.lambda=\
 346     a lambda expression
 347 
 348 compiler.misc.inner.cls=\
 349     an inner class
 350 
 351 # 0: type
 352 compiler.err.cant.deref=\
 353     {0} cannot be dereferenced
 354 
 355 compiler.err.cant.extend.intf.annotation=\
 356     &#39;&#39;extends&#39;&#39; not allowed for @interfaces
 357 
 358 compiler.err.annotation.decl.not.allowed.here=\
 359     annotation type declaration not allowed here
 360 
 361 # 0: symbol
 362 compiler.err.cant.inherit.from.final=\
 363     cannot inherit from final {0}
 364 
 365 # 0: symbol or string
 366 compiler.err.cant.ref.before.ctor.called=\
 367     cannot reference {0} before supertype constructor has been called
 368 
 369 compiler.err.cant.select.static.class.from.param.type=\
 370     cannot select a static class from a parameterized type
 371 
 372 # 0: symbol, 1: string, 2: string
 373 compiler.err.cant.inherit.diff.arg=\
 374     {0} cannot be inherited with different arguments: &lt;{1}&gt; and &lt;{2}&gt;
 375 
 376 compiler.err.catch.without.try=\
 377     &#39;&#39;catch&#39;&#39; without &#39;&#39;try&#39;&#39;
 378 
 379 # 0: kind name, 1: symbol
 380 compiler.err.clash.with.pkg.of.same.name=\
 381     {0} {1} clashes with package of same name
 382 
 383 compiler.err.class.not.allowed=\
 384     class, interface or enum declaration not allowed here
 385 
 386 compiler.err.const.expr.req=\
 387     constant expression required
 388 
 389 compiler.err.cont.outside.loop=\
 390     continue outside of loop
 391 
 392 # 0: symbol or type
 393 compiler.err.cyclic.inheritance=\
 394     cyclic inheritance involving {0}
 395 
 396 # 0: symbol
 397 compiler.err.cyclic.annotation.element=\
 398     type of element {0} is cyclic
 399 
 400 # 0: symbol
 401 compiler.err.call.to.super.not.allowed.in.enum.ctor=\
 402     call to super not allowed in enum constructor
 403 
 404 # 0: type
 405 compiler.err.no.superclass=\
 406     {0} has no superclass.
 407 
 408 # 0: symbol, 1: type, 2: symbol, 3: type, 4: type
 409 compiler.err.concrete.inheritance.conflict=\
 410     methods {0} from {1} and {2} from {3} are inherited with the same signature
 411 
 412 compiler.err.default.allowed.in.intf.annotation.member=\
 413     default value only allowed in an annotation type declaration
 414 
 415 # 0: symbol
 416 compiler.err.doesnt.exist=\
 417     package {0} does not exist
 418 
 419 # 0: type
 420 compiler.err.duplicate.annotation.invalid.repeated=\
 421     annotation {0} is not a valid repeatable annotation
 422 
 423 # 0: name, 1: type
 424 compiler.err.duplicate.annotation.member.value=\
 425     duplicate element &#39;&#39;{0}&#39;&#39; in annotation @{1}.
 426 
 427 # 0: type
 428 compiler.err.duplicate.annotation.missing.container=\
 429     {0} is not a repeatable annotation type
 430 
 431 # 0: symbol
 432 compiler.err.invalid.repeatable.annotation=\
 433     duplicate annotation: {0} is annotated with an invalid @Repeatable annotation
 434 
 435 # 0: symbol or type
 436 compiler.err.invalid.repeatable.annotation.no.value=\
 437     {0} is not a valid @Repeatable, no value element method declared
 438 
 439 # 0: type, 1: number
 440 compiler.err.invalid.repeatable.annotation.multiple.values=\
 441     {0} is not a valid @Repeatable, {1} element methods named &#39;&#39;value&#39;&#39; declared
 442 
 443 # 0: type
 444 compiler.err.invalid.repeatable.annotation.invalid.value=\
 445     {0} is not a valid @Repeatable: invalid value element
 446 
 447 # 0: symbol or type, 1: type, 2: type
 448 compiler.err.invalid.repeatable.annotation.value.return=\
 449     containing annotation type ({0}) must declare an element named &#39;&#39;value&#39;&#39; of type {2}
 450 
 451 # 0: symbol or type, 1: symbol
 452 compiler.err.invalid.repeatable.annotation.elem.nondefault=\
 453     containing annotation type ({0}) does not have a default value for element {1}
 454 
 455 # 0: symbol, 1: string, 2: symbol, 3: string
 456 compiler.err.invalid.repeatable.annotation.retention=\
 457     retention of containing annotation type ({0}) is shorter than the retention of repeatable annotation type ({2})
 458 
 459 # 0: symbol, 1: symbol
 460 compiler.err.invalid.repeatable.annotation.not.documented=\
 461     repeatable annotation type ({1}) is @Documented while containing annotation type ({0}) is not
 462 
 463 # 0: symbol, 1: symbol
 464 compiler.err.invalid.repeatable.annotation.not.inherited=\
 465     repeatable annotation type ({1}) is @Inherited while containing annotation type ({0}) is not
 466 
 467 # 0: symbol, 1: symbol
 468 compiler.err.invalid.repeatable.annotation.incompatible.target=\
 469     containing annotation type ({0}) is applicable to more targets than repeatable annotation type ({1})
 470 
 471 # 0: symbol
 472 compiler.err.invalid.repeatable.annotation.repeated.and.container.present=\
 473     container {0} must not be present at the same time as the element it contains
 474 
 475 # 0: type, 1: symbol
 476 compiler.err.invalid.repeatable.annotation.not.applicable=\
 477     container {0} is not applicable to element {1}
 478 
 479 # 0: type
 480 compiler.err.invalid.repeatable.annotation.not.applicable.in.context=\
 481     container {0} is not applicable in this type context
 482 
 483 # 0: name
 484 compiler.err.duplicate.class=\
 485     duplicate class: {0}
 486 
 487 # 0: name, 1: name
 488 compiler.err.same.binary.name=\
 489     classes: {0} and {1} have the same binary name
 490 
 491 compiler.err.duplicate.case.label=\
 492     duplicate case label
 493 
 494 compiler.err.duplicate.default.label=\
 495     duplicate default label
 496 
 497 compiler.err.else.without.if=\
 498     &#39;&#39;else&#39;&#39; without &#39;&#39;if&#39;&#39;
 499 
 500 compiler.err.empty.char.lit=\
 501     empty character literal
 502 
 503 # 0: symbol
 504 compiler.err.encl.class.required=\
 505     an enclosing instance that contains {0} is required
 506 
 507 compiler.err.enum.annotation.must.be.enum.constant=\
 508     an enum annotation value must be an enum constant
 509 
 510 compiler.err.enum.cant.be.instantiated=\
 511     enum types may not be instantiated
 512 
 513 compiler.err.enum.label.must.be.unqualified.enum=\
 514     an enum switch case label must be the unqualified name of an enumeration constant
 515 
 516 compiler.err.enum.no.subclassing=\
 517     classes cannot directly extend java.lang.Enum
 518 
 519 compiler.err.enum.types.not.extensible=\
 520     enum types are not extensible
 521 
 522 compiler.err.enum.no.finalize=\
 523     enums cannot have finalize methods
 524 
 525 # 0: file name, 1: string
 526 compiler.err.error.reading.file=\
 527     error reading {0}; {1}
 528 
 529 # 0: type
 530 compiler.err.except.already.caught=\
 531     exception {0} has already been caught
 532 
 533 # 0: type
 534 compiler.err.except.never.thrown.in.try=\
 535     exception {0} is never thrown in body of corresponding try statement
 536 
 537 # 0: symbol
 538 compiler.err.final.parameter.may.not.be.assigned=\
 539     final parameter {0} may not be assigned
 540 
 541 # 0: symbol
 542 compiler.err.try.resource.may.not.be.assigned=\
 543     auto-closeable resource {0} may not be assigned
 544 
<a name="10" id="anc10"></a>



 545 # 0: symbol
 546 compiler.err.multicatch.parameter.may.not.be.assigned=\
 547     multi-catch parameter {0} may not be assigned
 548 
 549 # 0: type, 1: type
 550 compiler.err.multicatch.types.must.be.disjoint=\
 551     Alternatives in a multi-catch statement cannot be related by subclassing\n\
 552     Alternative {0} is a subclass of alternative {1}
 553 
 554 compiler.err.finally.without.try=\
 555     &#39;&#39;finally&#39;&#39; without &#39;&#39;try&#39;&#39;
 556 
 557 # 0: type, 1: message segment
 558 compiler.err.foreach.not.applicable.to.type=\
 559     for-each not applicable to expression type\n\
 560     required: {1}\n\
 561     found:    {0}
 562 
 563 compiler.err.fp.number.too.large=\
 564     floating point number too large
 565 
 566 compiler.err.fp.number.too.small=\
 567     floating point number too small
 568 
 569 compiler.err.generic.array.creation=\
 570     generic array creation
 571 
 572 compiler.err.generic.throwable=\
 573     a generic class may not extend java.lang.Throwable
 574 
 575 # 0: symbol
 576 compiler.err.icls.cant.have.static.decl=\
 577     Illegal static declaration in inner class {0}\n\
 578     modifier \&#39;&#39;static\&#39;&#39; is only allowed in constant variable declarations
 579 
 580 # 0: string
 581 compiler.err.illegal.char=\
 582     illegal character: &#39;&#39;{0}&#39;&#39;
 583 
 584 # 0: string, 1: string
 585 compiler.err.illegal.char.for.encoding=\
 586     unmappable character (0x{0}) for encoding {1}
 587 
 588 # 0: set of flag, 1: set of flag
 589 compiler.err.illegal.combination.of.modifiers=\
 590     illegal combination of modifiers: {0} and {1}
 591 
 592 compiler.err.illegal.enum.static.ref=\
 593     illegal reference to static field from initializer
 594 
 595 compiler.err.illegal.esc.char=\
 596     illegal escape character
 597 
 598 compiler.err.illegal.forward.ref=\
 599     illegal forward reference
 600 
 601 # 0: symbol, 1: object
 602 compiler.err.not.in.profile=\
 603     {0} is not available in profile &#39;&#39;{1}&#39;&#39;
 604 
 605 # 0: symbol
 606 compiler.warn.forward.ref=\
 607     reference to variable &#39;&#39;{0}&#39;&#39; before it has been initialized
 608 
 609 compiler.err.illegal.self.ref=\
 610     self-reference in initializer
 611 
 612 # 0: symbol
 613 compiler.warn.self.ref=\
 614     self-reference in initializer of variable &#39;&#39;{0}&#39;&#39;
 615 
 616 compiler.err.illegal.generic.type.for.instof=\
 617     illegal generic type for instanceof
 618 
 619 # 0: type
 620 compiler.err.illegal.initializer.for.type=\
 621     illegal initializer for {0}
 622 
 623 compiler.err.illegal.line.end.in.char.lit=\
 624     illegal line end in character literal
 625 
<a name="11" id="anc11"></a>








 626 compiler.err.illegal.nonascii.digit=\
 627     illegal non-ASCII digit
 628 
 629 compiler.err.illegal.underscore=\
 630     illegal underscore
 631 
 632 compiler.err.illegal.dot=\
 633     illegal &#39;&#39;.&#39;&#39;
 634 
 635 # 0: symbol
 636 compiler.err.illegal.qual.not.icls=\
 637     illegal qualifier; {0} is not an inner class
 638 
 639 compiler.err.illegal.start.of.expr=\
 640     illegal start of expression
 641 
 642 compiler.err.illegal.start.of.stmt=\
 643     illegal start of statement
 644 
 645 compiler.err.illegal.start.of.type=\
 646     illegal start of type
 647 
 648 compiler.err.illegal.parenthesized.expression=\
 649     illegal parenthesized expression
 650 
 651 compiler.err.illegal.unicode.esc=\
 652     illegal unicode escape
 653 
 654 # 0: symbol
 655 compiler.err.import.requires.canonical=\
 656     import requires canonical name for {0}
 657 
 658 compiler.err.improperly.formed.type.param.missing=\
 659     improperly formed type, some parameters are missing
 660 
 661 compiler.err.improperly.formed.type.inner.raw.param=\
 662     improperly formed type, type arguments given on a raw type
 663 
 664 # 0: type, 1: type
 665 compiler.err.incomparable.types=\
 666     incomparable types: {0} and {1}
 667 
 668 # 0: string
 669 compiler.err.int.number.too.large=\
 670     integer number too large
 671 
 672 compiler.err.intf.annotation.members.cant.have.params=\
 673     elements in annotation type declarations cannot declare formal parameters
 674 
 675 # 0: symbol
 676 compiler.err.intf.annotation.cant.have.type.params=\
 677     annotation type {0} cannot be generic
 678 
 679 compiler.err.intf.annotation.members.cant.have.type.params=\
 680     elements in annotation type declarations cannot be generic methods
 681 
 682 # 0: symbol, 1: type
 683 compiler.err.intf.annotation.member.clash=\
 684     annotation type {1} declares an element with the same name as method {0}
 685 
 686 compiler.err.intf.expected.here=\
 687     interface expected here
 688 
 689 compiler.err.intf.meth.cant.have.body=\
 690     interface abstract methods cannot have body
 691 
 692 compiler.err.invalid.annotation.member.type=\
 693     invalid type for annotation type element
 694 
 695 compiler.err.invalid.binary.number=\
 696     binary numbers must contain at least one binary digit
 697 
 698 compiler.err.invalid.hex.number=\
 699     hexadecimal numbers must contain at least one hexadecimal digit
 700 
 701 compiler.err.invalid.meth.decl.ret.type.req=\
 702     invalid method declaration; return type required
 703 
 704 compiler.err.varargs.and.old.array.syntax=\
 705     legacy array notation not allowed on variable-arity parameter
 706 
 707 compiler.err.varargs.and.receiver =\
 708     varargs notation not allowed on receiver parameter
 709 
 710 compiler.err.varargs.must.be.last =\
 711     varargs parameter must be the last parameter
 712 
 713 compiler.err.array.and.receiver =\
 714     legacy array notation not allowed on receiver parameter
 715 
 716 compiler.err.wrong.receiver =\
 717     wrong receiver parameter name
 718 
 719 compiler.err.variable.not.allowed=\
 720     variable declaration not allowed here
 721 
 722 # 0: name
 723 compiler.err.label.already.in.use=\
 724     label {0} already in use
 725 
 726 # 0: symbol
 727 compiler.err.local.var.accessed.from.icls.needs.final=\
 728     local variable {0} is accessed from within inner class; needs to be declared final
 729 
 730 compiler.err.local.enum=\
 731     enum types must not be local
 732 
 733 compiler.err.cannot.create.array.with.type.arguments=\
 734     cannot create array with type arguments
 735 
 736 compiler.err.cannot.create.array.with.diamond=\
 737     cannot create array with &#39;&#39;&lt;&gt;&#39;&#39;
 738 
 739 compiler.err.invalid.module.directive=\
 740   module directive keyword or &#39;&#39;}&#39;&#39; expected
 741 
 742 #
 743 # limits.  We don&#39;t give the limits in the diagnostic because we expect
 744 # them to change, yet we want to use the same diagnostic.  These are all
 745 # detected during code generation.
 746 #
 747 compiler.err.limit.code=\
 748     code too large
 749 
 750 compiler.err.limit.code.too.large.for.try.stmt=\
 751     code too large for try statement
 752 
 753 compiler.err.limit.dimensions=\
 754     array type has too many dimensions
 755 
 756 compiler.err.limit.locals=\
 757     too many local variables
 758 
 759 compiler.err.limit.parameters=\
 760     too many parameters
 761 
 762 compiler.err.limit.pool=\
 763     too many constants
 764 
 765 compiler.err.limit.pool.in.class=\
 766     too many constants in class {0}
 767 
 768 compiler.err.limit.stack=\
 769     code requires too much stack
 770 
 771 compiler.err.limit.string=\
 772     constant string too long
 773 
 774 # 0: string
 775 compiler.err.limit.string.overflow=\
 776     UTF8 representation for string \&quot;{0}...\&quot; is too long for the constant pool
 777 
 778 compiler.err.malformed.fp.lit=\
 779     malformed floating point literal
 780 
 781 compiler.err.method.does.not.override.superclass=\
 782     method does not override or implement a method from a supertype
 783 
 784 compiler.err.static.methods.cannot.be.annotated.with.override=\
 785     static methods cannot be annotated with @Override
 786 
 787 compiler.err.missing.meth.body.or.decl.abstract=\
 788     missing method body, or declare abstract
 789 
 790 compiler.err.missing.ret.stmt=\
 791     missing return statement
 792 
 793 # 0: type
 794 compiler.misc.missing.ret.val=\
 795     missing return value
 796 
 797 compiler.misc.unexpected.ret.val=\
 798     unexpected return value
 799 
 800 # 0: set of flag
 801 compiler.err.mod.not.allowed.here=\
 802     modifier {0} not allowed here
 803 
 804 # 0: name
 805 compiler.err.modifier.not.allowed.here=\
 806     modifier {0} not allowed here
 807 
 808 compiler.err.intf.not.allowed.here=\
 809     interface not allowed here
 810 
 811 compiler.err.enums.must.be.static=\
 812     enum declarations allowed only in static contexts
 813 
 814 # 0: symbol, 1: symbol
 815 compiler.err.name.clash.same.erasure=\
 816     name clash: {0} and {1} have the same erasure
 817 
 818 # 0: name, 1: list of type, 2: symbol, 3: name, 4: list of type, 5: symbol
 819 compiler.err.name.clash.same.erasure.no.override=\
 820     name clash: {0}({1}) in {2} and {3}({4}) in {5} have the same erasure, yet neither overrides the other
 821 
 822 # 0: string, 1: name, 2: name, 3: list of type, 4: symbol, 5: name, 6: list of type, 7: symbol
 823 compiler.err.name.clash.same.erasure.no.override.1=\
 824     name clash: {0} {1} has two methods with the same erasure, yet neither overrides the other\n\
 825     first method:  {2}({3}) in {4}\n\
 826     second method: {5}({6}) in {7}
 827 
 828 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
 829 compiler.err.name.clash.same.erasure.no.hide=\
 830     name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither hides the other
 831 
 832 compiler.err.name.reserved.for.internal.use=\
 833     {0} is reserved for internal use
 834 
 835 compiler.err.native.meth.cant.have.body=\
 836     native methods cannot have a body
 837 
 838 
 839 # 0: message segment
 840 compiler.misc.incompatible.type.in.conditional=\
 841     bad type in conditional expression\n\
 842     {0}
 843 
 844 compiler.misc.conditional.target.cant.be.void=\
 845     target-type for conditional expression cannot be void
 846 
 847 compiler.misc.switch.expression.target.cant.be.void=\
 848     target-type for switch expression cannot be void
 849 
 850 # 0: message segment
 851 compiler.misc.incompatible.type.in.switch.expression=\
 852     bad type in switch expression\n\
 853     {0}
 854 
 855 # 0: message segment
 856 compiler.misc.incompatible.ret.type.in.lambda=\
 857     bad return type in lambda expression\n\
 858     {0}
 859 
 860 compiler.misc.stat.expr.expected=\
 861     lambda body is not compatible with a void functional interface\n\
 862     (consider using a block lambda body, or use a statement expression instead)
 863 
 864 # 0: message segment
 865 compiler.misc.incompatible.ret.type.in.mref=\
 866     bad return type in method reference\n\
 867     {0}
 868 
 869 compiler.err.lambda.body.neither.value.nor.void.compatible=\
 870     lambda body is neither value nor void compatible
 871 
 872 # 0: list of type
 873 compiler.err.incompatible.thrown.types.in.mref=\
 874     incompatible thrown types {0} in functional expression
 875 
 876 compiler.misc.incompatible.arg.types.in.lambda=\
 877     incompatible parameter types in lambda expression
 878 
 879 compiler.misc.incompatible.arg.types.in.mref=\
 880     incompatible parameter types in method reference
 881 
 882 compiler.err.new.not.allowed.in.annotation=\
 883     &#39;&#39;new&#39;&#39; not allowed in an annotation
 884 
 885 # 0: name, 1: type
 886 compiler.err.no.annotation.member=\
 887     no annotation member {0} in {1}
 888 
 889 # 0: symbol
 890 compiler.err.no.encl.instance.of.type.in.scope=\
 891     no enclosing instance of type {0} is in scope
 892 
 893 compiler.err.no.intf.expected.here=\
 894     no interface expected here
 895 
 896 compiler.err.no.match.entry=\
 897     {0} has no match in entry in {1}; required {2}
 898 
 899 # 0: type
 900 compiler.err.not.annotation.type=\
 901     {0} is not an annotation type
 902 
 903 # 0: symbol, 1: symbol, 2: message segment
 904 compiler.err.not.def.access.package.cant.access=\
 905     {0} is not visible\n\
 906     ({2})
 907 
 908 # 0: symbol, 1: symbol, 2: message segment
 909 compiler.misc.not.def.access.package.cant.access=\
 910     {0} is not visible\n\
 911     ({2})
 912 
 913 # 0: symbol, 1: message segment
 914 compiler.err.package.not.visible=\
 915     package {0} is not visible\n\
 916     ({1})
 917 
 918 # 0: symbol, 1: message segment
 919 compiler.misc.package.not.visible=\
 920     package {0} is not visible\n\
 921     ({1})
 922 
 923 # {0} - current module
 924 # {1} - package in which the invisible class is declared
 925 # {2} - module in which {1} is declared
 926 # 0: symbol, 1: symbol, 2: symbol
 927 compiler.misc.not.def.access.does.not.read=\
 928     package {1} is declared in module {2}, but module {0} does not read it
 929 
 930 # {0} - package in which the invisible class is declared
 931 # {1} - module in which {0} is declared
 932 # 0: symbol, 1: symbol
 933 compiler.misc.not.def.access.does.not.read.from.unnamed=\
 934     package {0} is declared in module {1}, which is not in the module graph
 935 
 936 # {0} - package in which the invisible class is declared
 937 # {1} - current module
 938 # 0: symbol, 1: symbol
 939 compiler.misc.not.def.access.does.not.read.unnamed=\
<a name="12" id="anc12"></a><span class="line-modified"> 940     package {0} is declared in the unnamed module, but module {0} does not read it</span>
 941 
 942 # {0} - package in which the invisible class is declared
 943 # {1} - module in which {0} is declared
 944 # 0: symbol, 1: symbol
 945 compiler.misc.not.def.access.not.exported=\
 946     package {0} is declared in module {1}, which does not export it
 947 
 948 # {0} - package in which the invisible class is declared
 949 # {1} - module in which {0} is declared
 950 # 0: symbol, 1: symbol
 951 compiler.misc.not.def.access.not.exported.from.unnamed=\
 952     package {0} is declared in module {1}, which does not export it
 953 
 954 # {0} - package in which the invisible class is declared
 955 # {1} - module in which {0} is declared
 956 # {2} - current module
 957 # 0: symbol, 1: symbol, 2: symbol
 958 compiler.misc.not.def.access.not.exported.to.module=\
 959     package {0} is declared in module {1}, which does not export it to module {2}
 960 
 961 # {0} - package in which the invisible class is declared
 962 # {1} - module in which {0} is declared
 963 # 0: symbol, 1: symbol
 964 compiler.misc.not.def.access.not.exported.to.module.from.unnamed=\
 965     package {0} is declared in module {1}, which does not export it to the unnamed module
 966 
 967 # 0: symbol, 1: symbol
 968 compiler.err.not.def.access.class.intf.cant.access=\
 969     {1}.{0} is defined in an inaccessible class or interface
 970 
 971 # 0: symbol, 1: symbol
 972 compiler.misc.not.def.access.class.intf.cant.access=\
 973     {1}.{0} is defined in an inaccessible class or interface
 974 
 975 # 0: symbol, 1: symbol, 2: symbol, 3: message segment
 976 compiler.err.not.def.access.class.intf.cant.access.reason=\
 977     {1}.{0} in package {2} is not accessible\n\
 978     ({3})
 979 
 980 # 0: symbol, 1: symbol, 2: symbol, 3: message segment
 981 compiler.misc.not.def.access.class.intf.cant.access.reason=\
 982     {1}.{0} in package {2} is not accessible\n\
 983     ({3})
 984 
 985 # 0: symbol, 1: list of type, 2: type
 986 compiler.misc.cant.access.inner.cls.constr=\
 987     cannot access constructor {0}({1})\n\
 988     an enclosing instance of type {2} is not in scope
 989 
 990 # 0: symbol, 1: symbol
 991 compiler.err.not.def.public.cant.access=\
 992     {0} is not public in {1}; cannot be accessed from outside package
 993 
 994 # 0: symbol, 1: symbol
 995 compiler.err.not.def.public=\
 996     {0} is not public in {1}
 997 
 998 # 0: symbol, 1: symbol
 999 compiler.misc.not.def.public.cant.access=\
1000     {0} is not public in {1}; cannot be accessed from outside package
1001 
1002 # 0: name
1003 compiler.err.not.loop.label=\
1004     not a loop label: {0}
1005 
1006 compiler.err.not.stmt=\
1007     not a statement
1008 
1009 # 0: symbol
1010 compiler.err.not.encl.class=\
1011     not an enclosing class: {0}
1012 
1013 # 0: name, 1: type
1014 compiler.err.operator.cant.be.applied=\
1015     bad operand type {1} for unary operator &#39;&#39;{0}&#39;&#39;
1016 
1017 # 0: name, 1: type, 2: type
1018 compiler.err.operator.cant.be.applied.1=\
1019     bad operand types for binary operator &#39;&#39;{0}&#39;&#39;\n\
1020     first type:  {1}\n\
1021     second type: {2}
1022 
1023 compiler.err.pkg.annotations.sb.in.package-info.java=\
1024     package annotations should be in file package-info.java
1025 
1026 compiler.err.no.pkg.in.module-info.java=\
1027     package declarations not allowed in file module-info.java
1028 
1029 # 0: symbol
1030 compiler.err.pkg.clashes.with.class.of.same.name=\
1031     package {0} clashes with class of same name
1032 
1033 compiler.err.warnings.and.werror=\
1034     warnings found and -Werror specified
1035 
1036 # Errors related to annotation processing
1037 
1038 # 0: symbol, 1: message segment, 2: string (stack-trace)
1039 compiler.err.proc.cant.access=\
1040     cannot access {0}\n\
1041     {1}\n\
1042     Consult the following stack trace for details.\n\
1043     {2}
1044 
1045 # 0: symbol, 1: message segment
1046 compiler.err.proc.cant.access.1=\
1047     cannot access {0}\n\
1048     {1}
1049 
1050 # 0: string
1051 compiler.err.proc.cant.find.class=\
1052     Could not find class file for &#39;&#39;{0}&#39;&#39;.
1053 
<a name="13" id="anc13"></a>



1054 # Print a client-generated error message; assumed to be localized, no translation required
1055 # 0: string
1056 compiler.err.proc.messager=\
1057     {0}
1058 
1059 # 0: string
1060 compiler.misc.exception.message=\
1061     {0}
1062 
1063 compiler.misc.user.selected.completion.failure=\
1064     user-selected completion failure by class name
1065 
1066 # 0: collection of string
1067 compiler.err.proc.no.explicit.annotation.processing.requested=\
1068     Class names, &#39;&#39;{0}&#39;&#39;, are only accepted if annotation processing is explicitly requested
1069 
1070 compiler.err.proc.no.service=\
1071     A ServiceLoader was not usable and is required for annotation processing.
1072 
1073 # 0: string, 1: string
1074 compiler.err.proc.processor.bad.option.name=\
1075     Bad option name &#39;&#39;{0}&#39;&#39; provided by processor &#39;&#39;{1}&#39;&#39;
1076 
1077 # 0: string
1078 compiler.err.proc.processor.cant.instantiate=\
1079     Could not instantiate an instance of processor &#39;&#39;{0}&#39;&#39;
1080 
1081 # 0: string
1082 compiler.err.proc.processor.not.found=\
1083     Annotation processor &#39;&#39;{0}&#39;&#39; not found
1084 
1085 # 0: string
1086 compiler.err.proc.processor.wrong.type=\
1087     Annotation processor &#39;&#39;{0}&#39;&#39; does not implement javax.annotation.processing.Processor
1088 
1089 compiler.err.proc.service.problem=\
1090     Error creating a service loader to load Processors.
1091 
1092 # 0: string
1093 compiler.err.proc.bad.config.file=\
1094     Bad service configuration file, or exception thrown while constructing Processor object: {0}
1095 
1096 compiler.err.proc.cant.create.loader=\
1097     Could not create class loader for annotation processors: {0}
1098 
1099 # 0: symbol
1100 compiler.err.qualified.new.of.static.class=\
1101     qualified new of static class
1102 
1103 compiler.err.recursive.ctor.invocation=\
1104     recursive constructor invocation
1105 
1106 # 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
1107 compiler.err.ref.ambiguous=\
1108     reference to {0} is ambiguous\n\
1109     both {1} {2} in {3} and {4} {5} in {6} match
1110 
1111 # 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
1112 compiler.misc.ref.ambiguous=\
1113     reference to {0} is ambiguous\n\
1114     both {1} {2} in {3} and {4} {5} in {6} match
1115 
1116 compiler.err.repeated.annotation.target=\
1117     repeated annotation target
1118 
1119 compiler.err.repeated.interface=\
1120     repeated interface
1121 
1122 compiler.err.repeated.modifier=\
1123     repeated modifier
1124 
1125 # 0: symbol, 1: set of modifier, 2: symbol
1126 compiler.err.report.access=\
1127     {0} has {1} access in {2}
1128 
1129 # 0: symbol, 1: set of modifier, 2: symbol
1130 compiler.misc.report.access=\
1131     {0} has {1} access in {2}
1132 
1133 compiler.err.ret.outside.meth=\
1134     return outside method
1135 
1136 compiler.err.signature.doesnt.match.supertype=\
1137     signature does not match {0}; incompatible supertype
1138 
1139 compiler.err.signature.doesnt.match.intf=\
1140     signature does not match {0}; incompatible interfaces
1141 
1142 # 0: symbol, 1: symbol, 2: symbol
1143 compiler.err.does.not.override.abstract=\
1144     {0} is not abstract and does not override abstract method {1} in {2}
1145 
1146 # 0: file object
1147 compiler.err.source.cant.overwrite.input.file=\
1148     error writing source; cannot overwrite input file {0}
1149 
1150 # 0: symbol
1151 compiler.err.stack.sim.error=\
1152     Internal error: stack sim error on {0}
1153 
1154 compiler.err.static.imp.only.classes.and.interfaces=\
1155     static import only from classes and interfaces
1156 
1157 compiler.err.string.const.req=\
1158     constant string expression required
1159 
1160 # 0: symbol, 1: fragment
1161 compiler.err.cannot.generate.class=\
1162     error while generating class {0}\n\
1163     ({1})
1164 
1165 # 0: symbol, 1: symbol
1166 compiler.misc.synthetic.name.conflict=\
1167     the symbol {0} conflicts with a compiler-synthesized symbol in {1}
1168 
1169 # 0: symbol, 1: type
1170 compiler.misc.illegal.signature=\
1171     illegal signature attribute for type {1}
1172 
1173 compiler.err.throws.not.allowed.in.intf.annotation=\
1174     throws clause not allowed in @interface members
1175 
1176 compiler.err.try.without.catch.finally.or.resource.decls=\
1177     &#39;&#39;try&#39;&#39; without &#39;&#39;catch&#39;&#39;, &#39;&#39;finally&#39;&#39; or resource declarations
1178 
1179 # 0: symbol
1180 compiler.err.type.doesnt.take.params=\
1181     type {0} does not take parameters
1182 
1183 compiler.err.type.var.cant.be.deref=\
1184     cannot select from a type variable
1185 
1186 compiler.err.type.var.may.not.be.followed.by.other.bounds=\
1187     a type variable may not be followed by other bounds
1188 
1189 compiler.err.type.var.more.than.once=\
1190     type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
1191 
1192 compiler.err.type.var.more.than.once.in.result=\
1193     type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
1194 
1195 # 0: type, 1: type, 2: fragment
1196 compiler.err.types.incompatible=\
1197     types {0} and {1} are incompatible;\n\
1198     {2}
1199 
1200 # 0: name, 1: list of type
1201 compiler.misc.incompatible.diff.ret=\
1202     both define {0}({1}), but with unrelated return types
1203 
1204 # 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
1205 compiler.misc.incompatible.unrelated.defaults=\
1206     {0} {1} inherits unrelated defaults for {2}({3}) from types {4} and {5}
1207 
1208 # 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
1209 compiler.misc.incompatible.abstract.default=\
1210     {0} {1} inherits abstract and default for {2}({3}) from types {4} and {5}
1211 
1212 # 0: name, 1: kind name, 2: symbol
1213 compiler.err.default.overrides.object.member=\
1214     default method {0} in {1} {2} overrides a member of java.lang.Object
1215 
1216 # 0: type
1217 compiler.err.illegal.static.intf.meth.call=\
1218     illegal static interface method call\n\
1219     the receiver expression should be replaced with the type qualifier &#39;&#39;{0}&#39;&#39;
1220 
1221 # 0: symbol or type, 1: message segment
1222 compiler.err.illegal.default.super.call=\
1223     bad type qualifier {0} in default super call\n\
1224     {1}
1225 
1226 # 0: symbol, 1: type
1227 compiler.misc.overridden.default=\
1228     method {0} is overridden in {1}
1229 
1230 # 0: symbol, 1: type or symbol
1231 compiler.misc.redundant.supertype=\
1232     redundant interface {0} is extended by {1}
1233 
1234 compiler.err.unclosed.char.lit=\
1235     unclosed character literal
1236 
1237 compiler.err.unclosed.comment=\
1238     unclosed comment
1239 
1240 compiler.err.unclosed.str.lit=\
1241     unclosed string literal
1242 
<a name="14" id="anc14"></a>


1243 # 0: string
1244 compiler.err.unsupported.encoding=\
1245     unsupported encoding: {0}
1246 
1247 compiler.err.io.exception=\
1248     error reading source file: {0}
1249 
1250 # 0: name
1251 compiler.err.undef.label=\
1252     undefined label: {0}
1253 
<a name="15" id="anc15"></a><span class="line-modified">1254 compiler.err.illegal.ref.to.var.type=\</span>
<span class="line-modified">1255     illegal reference to restricted type &#39;&#39;var&#39;&#39;</span>










1256 
<a name="16" id="anc16"></a><span class="line-modified">1257 compiler.err.var.not.allowed=\</span>
<span class="line-modified">1258     &#39;&#39;var&#39;&#39; not allowed here\n\</span>
<span class="line-modified">1259     as of release 10, &#39;&#39;var&#39;&#39; is a restricted local variable type and cannot be used for type declarations</span>
1260 
<a name="17" id="anc17"></a><span class="line-modified">1261 compiler.warn.var.not.allowed=\</span>
<span class="line-modified">1262     as of release 10, &#39;&#39;var&#39;&#39; is a restricted local variable type and cannot be used for type declarations or as the element type of an array</span>

1263 
1264 # 0: name (variable), 1: message segment
1265 compiler.err.cant.infer.local.var.type=\
1266     cannot infer type for local variable {0}\n\
1267     ({1})
1268 
<a name="18" id="anc18"></a><span class="line-modified">1269 compiler.err.var.not.allowed.here=\</span>
<span class="line-modified">1270     &#39;&#39;var&#39;&#39; is not allowed here</span>

1271 
<a name="19" id="anc19"></a><span class="line-modified">1272 compiler.err.var.not.allowed.array=\</span>
<span class="line-modified">1273     &#39;&#39;var&#39;&#39; is not allowed as an element type of an array</span>

1274 
<a name="20" id="anc20"></a><span class="line-modified">1275 compiler.err.var.not.allowed.compound=\</span>
<span class="line-modified">1276     &#39;&#39;var&#39;&#39; is not allowed in a compound declaration</span>

1277 
1278 # 0: fragment
1279 compiler.err.invalid.lambda.parameter.declaration=\
1280     invalid lambda parameter declaration\n\
1281     ({0})
1282 
1283 compiler.misc.implicit.and.explicit.not.allowed=\
1284     cannot mix implicitly-typed and explicitly-typed parameters
1285 
1286 compiler.misc.var.and.explicit.not.allowed=\
1287     cannot mix &#39;&#39;var&#39;&#39; and explicitly-typed parameters
1288 
1289 compiler.misc.var.and.implicit.not.allowed=\
1290     cannot mix &#39;&#39;var&#39;&#39; and implicitly-typed parameters
1291 
1292 compiler.misc.local.cant.infer.null=\
1293     variable initializer is &#39;&#39;null&#39;&#39;
1294 
1295 compiler.misc.local.cant.infer.void=\
1296     variable initializer is &#39;&#39;void&#39;&#39;
1297 
1298 compiler.misc.local.missing.init=\
1299     cannot use &#39;&#39;var&#39;&#39; on variable without initializer
1300 
1301 compiler.misc.local.lambda.missing.target=\
1302     lambda expression needs an explicit target-type
1303 
1304 compiler.misc.local.mref.missing.target=\
1305     method reference needs an explicit target-type
1306 
1307 compiler.misc.local.array.missing.target=\
1308     array initializer needs an explicit target-type
1309 
1310 compiler.misc.local.self.ref=\
1311     cannot use &#39;&#39;var&#39;&#39; on self-referencing variable
1312 
1313 # 0: message segment, 1: unused
1314 compiler.err.cant.apply.diamond=\
1315     cannot infer type arguments for {0}
1316 
1317 # 0: message segment or type, 1: message segment
1318 compiler.err.cant.apply.diamond.1=\
1319     cannot infer type arguments for {0}\n\
1320     reason: {1}
1321 
1322 # 0: message segment or type, 1: message segment
1323 compiler.misc.cant.apply.diamond.1=\
1324     cannot infer type arguments for {0}\n\
1325     reason: {1}
1326 
1327 compiler.err.unreachable.stmt=\
1328     unreachable statement
1329 
1330 compiler.err.not.exhaustive=\
1331     the switch expression does not cover all possible input values
1332 
1333 compiler.err.initializer.must.be.able.to.complete.normally=\
1334     initializer must be able to complete normally
1335 
1336 compiler.err.initializer.not.allowed=\
1337     initializers not allowed in interfaces
1338 
1339 # 0: type
1340 compiler.err.unreported.exception.need.to.catch.or.throw=\
1341     unreported exception {0}; must be caught or declared to be thrown
1342 
1343 # 0: type
1344 compiler.err.unreported.exception.default.constructor=\
1345     unreported exception {0} in default constructor
1346 
1347 # 0: type, 1: name
1348 compiler.err.unreported.exception.implicit.close=\
1349     unreported exception {0}; must be caught or declared to be thrown\n\
1350     exception thrown from implicit call to close() on resource variable &#39;&#39;{1}&#39;&#39;
1351 
1352 compiler.err.unsupported.cross.fp.lit=\
1353     hexadecimal floating-point literals are not supported on this VM
1354 
1355 compiler.err.void.not.allowed.here=\
1356     &#39;&#39;void&#39;&#39; type not allowed here
1357 
1358 # 0: string
1359 compiler.err.wrong.number.type.args=\
1360     wrong number of type arguments; required {0}
1361 
1362 # 0: symbol
1363 compiler.err.var.might.already.be.assigned=\
1364     variable {0} might already have been assigned
1365 
1366 # 0: symbol
1367 compiler.err.var.might.not.have.been.initialized=\
1368     variable {0} might not have been initialized
1369 
1370 # 0: symbol
1371 compiler.err.var.not.initialized.in.default.constructor=\
1372     variable {0} not initialized in the default constructor
1373 
1374 # 0: symbol
1375 compiler.err.var.might.be.assigned.in.loop=\
1376     variable {0} might be assigned in loop
1377 
1378 # 0: symbol, 1: message segment
1379 compiler.err.varargs.invalid.trustme.anno=\
1380     Invalid {0} annotation. {1}
1381 
1382 # 0: type
1383 compiler.misc.varargs.trustme.on.reifiable.varargs=\
1384     Varargs element type {0} is reifiable.
1385 
<a name="21" id="anc21"></a>



1386 # 0: symbol
1387 compiler.misc.varargs.trustme.on.non.varargs.meth=\
1388     Method {0} is not a varargs method.
1389 
1390 # 0: symbol
1391 compiler.misc.varargs.trustme.on.virtual.varargs=\
1392     Instance method {0} is neither final nor private.
1393 
1394 # 0: symbol
1395 compiler.misc.varargs.trustme.on.virtual.varargs.final.only=\
1396     Instance method {0} is not final.
1397 
1398 # 0: type, 1: symbol kind, 2: symbol
1399 compiler.misc.inaccessible.varargs.type=\
1400     formal varargs element type {0} is not accessible from {1} {2}
1401 
1402 # In the following string, {1} will always be the detail message from
1403 # java.io.IOException.
1404 # 0: symbol, 1: string
1405 compiler.err.class.cant.write=\
1406     error while writing {0}: {1}
1407 
1408 # In the following string, {0} is the name of the class in the Java source.
1409 # It really should be used two times..
1410 # 0: kind name, 1: name
1411 compiler.err.class.public.should.be.in.file=\
1412     {0} {1} is public, should be declared in a file named {1}.java
1413 
1414 ## All errors which do not refer to a particular line in the source code are
1415 ## preceded by this string.
1416 compiler.err.error=\
1417     error:\u0020
1418 
1419 # The following error messages do not refer to a line in the source code.
1420 compiler.err.cant.read.file=\
1421     cannot read: {0}
1422 
1423 # 0: string
1424 compiler.err.plugin.not.found=\
1425     plug-in not found: {0}
1426 
1427 # 0: path
1428 compiler.warn.locn.unknown.file.on.module.path=\
1429     unknown file on module path: {0}
1430 
1431 
1432 # 0: path
1433 compiler.err.locn.bad.module-info=\
1434     problem reading module-info.class in {0}
1435 
1436 # 0: path
1437 compiler.err.locn.cant.read.directory=\
1438     cannot read directory {0}
1439 
1440 # 0: path
1441 compiler.err.locn.cant.read.file=\
1442     cannot read file {0}
1443 
1444 # 0: path
1445 compiler.err.locn.cant.get.module.name.for.jar=\
1446     cannot determine module name for {0}
1447 
1448 # 0: path
1449 compiler.err.multi-module.outdir.cannot.be.exploded.module=\
1450     in multi-module mode, the output directory cannot be an exploded module: {0}
1451 
1452 # 0: path
1453 compiler.warn.outdir.is.in.exploded.module=\
1454     the output directory is within an exploded module: {0}
1455 
1456 # 0: file object
1457 compiler.err.locn.module-info.not.allowed.on.patch.path=\
1458     module-info.class not allowed on patch path: {0}
1459 
1460 # 0: string
1461 compiler.err.locn.invalid.arg.for.xpatch=\
1462     invalid argument for --patch-module option: {0}
1463 
1464 compiler.err.file.sb.on.source.or.patch.path.for.module=\
1465     file should be on source path, or on patch path for module
1466 
1467 #####
1468 
1469 # Fatal Errors
1470 
1471 compiler.misc.fatal.err.no.java.lang=\
1472     Fatal Error: Unable to find package java.lang in classpath or bootclasspath
1473 
1474 # 0: name
1475 compiler.misc.fatal.err.cant.locate.meth=\
1476     Fatal Error: Unable to find method {0}
1477 
1478 # 0: name
1479 compiler.misc.fatal.err.cant.locate.field=\
1480     Fatal Error: Unable to find field {0}
1481 
1482 # 0: type
1483 compiler.misc.fatal.err.cant.locate.ctor=\
1484     Fatal Error: Unable to find constructor for {0}
1485 
1486 compiler.misc.fatal.err.cant.close=\
1487     Fatal Error: Cannot close compiler resources
1488 
1489 #####
1490 
1491 ##
1492 ## miscellaneous strings
1493 ##
1494 
1495 compiler.misc.diamond.anonymous.methods.implicitly.override=\
1496     (due to &lt;&gt;, every non-private method declared in this anonymous class must override or implement a method from a supertype)
1497 
1498 compiler.misc.source.unavailable=\
1499     (source unavailable)
1500 
1501 compiler.misc.base.membership=\
1502     all your base class are belong to us
1503 
1504 # 0: string, 1: string, 2: boolean
1505 compiler.misc.x.print.processor.info=\
1506     Processor {0} matches {1} and returns {2}.
1507 
1508 # 0: number, 1: string, 2: set of symbol, 3: boolean
1509 compiler.misc.x.print.rounds=\
1510     Round {0}:\n\tinput files: {1}\n\tannotations: {2}\n\tlast round: {3}
1511 
1512 # 0: file name
1513 compiler.warn.file.from.future=\
1514     Modification date is in the future for file {0}
1515 
1516 #####
1517 
1518 ## The following string will appear before all messages keyed as:
1519 ## &quot;compiler.note&quot;.
1520 
1521 compiler.note.compressed.diags=\
1522     Some messages have been simplified; recompile with -Xdiags:verbose to get full output
1523 
1524 # 0: boolean, 1: symbol
1525 compiler.note.lambda.stat=\
1526     Translating lambda expression\n\
1527     alternate metafactory = {0}\n\
1528     synthetic method = {1}
1529 
1530 # 0: boolean, 1: unused
1531 compiler.note.mref.stat=\
1532     Translating method reference\n\
1533     alternate metafactory = {0}\n\
1534 
1535 # 0: boolean, 1: symbol
1536 compiler.note.mref.stat.1=\
1537     Translating method reference\n\
1538     alternate metafactory = {0}\n\
1539     bridge method = {1}
1540 
1541 compiler.note.note=\
1542     Note:\u0020
1543 
1544 # 0: file name
1545 compiler.note.deprecated.filename=\
1546     {0} uses or overrides a deprecated API.
1547 
1548 compiler.note.deprecated.plural=\
1549     Some input files use or override a deprecated API.
1550 
1551 # The following string may appear after one of the above deprecation
1552 # messages.
1553 compiler.note.deprecated.recompile=\
1554     Recompile with -Xlint:deprecation for details.
1555 
1556 # 0: file name
1557 compiler.note.deprecated.filename.additional=\
1558     {0} has additional uses or overrides of a deprecated API.
1559 
1560 compiler.note.deprecated.plural.additional=\
1561     Some input files additionally use or override a deprecated API.
1562 
1563 # 0: file name
1564 compiler.note.removal.filename=\
1565     {0} uses or overrides a deprecated API that is marked for removal.
1566 
1567 compiler.note.removal.plural=\
1568     Some input files use or override a deprecated API that is marked for removal.
1569 
1570 # The following string may appear after one of the above removal messages.
1571 compiler.note.removal.recompile=\
1572     Recompile with -Xlint:removal for details.
1573 
1574 # 0: file name
1575 compiler.note.removal.filename.additional=\
1576     {0} has additional uses or overrides of a deprecated API that is marked for removal.
1577 
1578 compiler.note.removal.plural.additional=\
1579     Some input files additionally use or override a deprecated API that is marked for removal.
1580 
1581 # 0: file name
1582 compiler.note.unchecked.filename=\
1583     {0} uses unchecked or unsafe operations.
1584 
1585 compiler.note.unchecked.plural=\
1586     Some input files use unchecked or unsafe operations.
1587 
1588 # The following string may appear after one of the above unchecked messages.
1589 compiler.note.unchecked.recompile=\
1590     Recompile with -Xlint:unchecked for details.
1591 
1592 # 0: file name
1593 compiler.note.unchecked.filename.additional=\
1594     {0} has additional unchecked or unsafe operations.
1595 
1596 compiler.note.unchecked.plural.additional=\
1597     Some input files additionally use unchecked or unsafe operations.
1598 
1599 # 0: file name
1600 compiler.note.preview.filename=\
1601     {0} uses preview language features.
1602 
1603 compiler.note.preview.plural=\
1604     Some input files use preview language features.
1605 
1606 # The following string may appear after one of the above deprecation
1607 # messages.
1608 compiler.note.preview.recompile=\
1609     Recompile with -Xlint:preview for details.
1610 
1611 # 0: file name
1612 compiler.note.preview.filename.additional=\
1613     {0} has additional uses of preview language features.
1614 
1615 compiler.note.preview.plural.additional=\
1616     Some input files additionally use preview language features.
1617 
1618 # Notes related to annotation processing
1619 
1620 # Print a client-generated note; assumed to be localized, no translation required
1621 # 0: string
1622 compiler.note.proc.messager=\
1623     {0}
1624 
1625 # 0: string, 1: string, 2: string
1626 compiler.note.multiple.elements=\
1627     Multiple elements named &#39;&#39;{1}&#39;&#39; in modules &#39;&#39;{2}&#39;&#39; were found by javax.lang.model.util.Elements.{0}.
1628 
1629 #####
1630 
1631 # 0: number
1632 compiler.misc.count.error=\
1633     {0} error
1634 
1635 # 0: number
1636 compiler.misc.count.error.plural=\
1637     {0} errors
1638 
<a name="22" id="anc22"></a>







1639 # 0: number
1640 compiler.misc.count.warn=\
1641     {0} warning
1642 
1643 # 0: number
1644 compiler.misc.count.warn.plural=\
1645     {0} warnings
1646 
1647 compiler.misc.version.not.available=\
1648     (version info not available)
1649 
1650 ## extra output when using -verbose (JavaCompiler)
1651 
1652 # 0: symbol
1653 compiler.misc.verbose.checking.attribution=\
1654     [checking {0}]
1655 
1656 # 0: string
1657 compiler.misc.verbose.parsing.done=\
1658     [parsing completed {0}ms]
1659 
1660 # 0: file name
1661 compiler.misc.verbose.parsing.started=\
1662     [parsing started {0}]
1663 
1664 # 0: string
1665 compiler.misc.verbose.total=\
1666     [total {0}ms]
1667 
1668 # 0: file name
1669 compiler.misc.verbose.wrote.file=\
1670     [wrote {0}]
1671 
1672 ## extra output when using -verbose (code/ClassReader)
1673 # 0: string
1674 compiler.misc.verbose.loading=\
1675     [loading {0}]
1676 
1677 # 0: string
1678 compiler.misc.verbose.sourcepath=\
1679     [search path for source files: {0}]
1680 
1681 # 0: string
1682 compiler.misc.verbose.classpath=\
1683     [search path for class files: {0}]
1684 
1685 ## extra output when using -prompt (util/Log)
1686 compiler.misc.resume.abort=\
1687     R)esume, A)bort&gt;
1688 
1689 #####
1690 
1691 ##
1692 ## warnings
1693 ##
1694 
1695 ## All warning messages are preceded by the following string.
1696 compiler.warn.warning=\
1697     warning:\u0020
1698 
1699 ## Warning messages may also include the following prefix to identify a
1700 ## lint option
1701 # 0: option name
1702 compiler.warn.lintOption=\
1703     [{0}]\u0020
1704 
1705 # 0: symbol
1706 compiler.warn.constant.SVUID=\
1707     serialVersionUID must be constant in class {0}
1708 
1709 # 0: path
1710 compiler.warn.dir.path.element.not.found=\
1711     bad path element &quot;{0}&quot;: no such directory
1712 
1713 # 0: file name
1714 compiler.warn.dir.path.element.not.directory=\
1715     bad path element &quot;{0}&quot;: not a directory
1716 
1717 compiler.warn.finally.cannot.complete=\
1718     finally clause cannot complete normally
1719 
1720 # 0: name
1721 compiler.warn.poor.choice.for.module.name=\
1722     module name component {0} should avoid terminal digits
1723 
1724 # 0: string
1725 compiler.warn.incubating.modules=\
1726     using incubating module(s): {0}
1727 
1728 # 0: symbol, 1: symbol
1729 compiler.warn.has.been.deprecated=\
1730     {0} in {1} has been deprecated
1731 
1732 # 0: symbol, 1: symbol
1733 compiler.warn.has.been.deprecated.for.removal=\
1734     {0} in {1} has been deprecated and marked for removal
1735 
<a name="23" id="anc23"></a>







1736 # 0: symbol
1737 compiler.warn.has.been.deprecated.module=\
1738     module {0} has been deprecated
1739 
1740 # 0: symbol
1741 compiler.warn.has.been.deprecated.for.removal.module=\
1742     module {0} has been deprecated and marked for removal
1743 
1744 # 0: symbol
1745 compiler.warn.sun.proprietary=\
1746     {0} is internal proprietary API and may be removed in a future release
1747 
1748 compiler.warn.illegal.char.for.encoding=\
1749     unmappable character for encoding {0}
1750 
1751 # 0: symbol
1752 compiler.warn.improper.SVUID=\
1753     serialVersionUID must be declared static final in class {0}
1754 
1755 # 0: type, 1: type
1756 compiler.warn.inexact.non-varargs.call=\
1757     non-varargs call of varargs method with inexact argument type for last parameter;\n\
1758     cast to {0} for a varargs call\n\
1759     cast to {1} for a non-varargs call and to suppress this warning
1760 
1761 # 0: list of type
1762 compiler.warn.unreachable.catch=\
1763     unreachable catch clause\n\
1764     thrown type {0} has already been caught
1765 
1766 # 0: list of type
1767 compiler.warn.unreachable.catch.1=\
1768     unreachable catch clause\n\
1769     thrown types {0} have already been caught
1770 
1771 # 0: symbol
1772 compiler.warn.long.SVUID=\
1773     serialVersionUID must be of type long in class {0}
1774 
1775 # 0: symbol
1776 compiler.warn.missing.SVUID=\
1777     serializable class {0} has no definition of serialVersionUID
1778 
1779 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
1780 compiler.warn.potentially.ambiguous.overload=\
1781     {0} in {1} is potentially ambiguous with {2} in {3}
1782 
1783 # 0: message segment
1784 compiler.warn.override.varargs.missing=\
1785     {0}; overridden method has no &#39;&#39;...&#39;&#39;
1786 
1787 # 0: message segment
1788 compiler.warn.override.varargs.extra=\
1789     {0}; overriding method is missing &#39;&#39;...&#39;&#39;
1790 
1791 # 0: message segment
1792 compiler.warn.override.bridge=\
1793     {0}; overridden method is a bridge method
1794 
1795 # 0: symbol
1796 compiler.warn.pkg-info.already.seen=\
1797     a package-info.java file has already been seen for package {0}
1798 
1799 # 0: path
1800 compiler.warn.path.element.not.found=\
1801     bad path element &quot;{0}&quot;: no such file or directory
1802 
1803 compiler.warn.possible.fall-through.into.case=\
1804     possible fall-through into case
1805 
1806 # 0: type
1807 compiler.warn.redundant.cast=\
1808     redundant cast to {0}
1809 
1810 # 0: number
1811 compiler.warn.position.overflow=\
1812     Position encoding overflows at line {0}
1813 
1814 # 0: file name, 1: number, 2: number
1815 compiler.warn.big.major.version=\
1816     {0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\n\
1817     It is recommended that the compiler be upgraded.
1818 
1819 # 0: kind name, 1: symbol
1820 compiler.warn.static.not.qualified.by.type=\
1821     static {0} should be qualified by type name, {1}, instead of by an expression
1822 
1823 # 0: string
1824 compiler.warn.source.no.bootclasspath=\
1825     bootstrap class path not set in conjunction with -source {0}
1826 
<a name="24" id="anc24"></a>



1827 # 0: string
1828 compiler.warn.option.obsolete.source=\
1829     source value {0} is obsolete and will be removed in a future release
1830 
1831 # 0: target
1832 compiler.warn.option.obsolete.target=\
1833     target value {0} is obsolete and will be removed in a future release
1834 
1835 # 0: string, 1: string
1836 compiler.err.option.removed.source=\
1837     Source option {0} is no longer supported. Use {1} or later.
1838 
1839 # 0: target, 1: target
1840 compiler.err.option.removed.target=\
1841     Target option {0} is no longer supported. Use {1} or later.
1842 
1843 
1844 # 0: target, 1: target
1845 compiler.warn.option.parameters.unsupported=\
1846     -parameters is not supported for target value {0}. Use {1} or later.
1847 
1848 compiler.warn.option.obsolete.suppression=\
1849     To suppress warnings about obsolete options, use -Xlint:-options.
1850 
1851 # 0: name, 1: number, 2: number, 3: number, 4: number
1852 compiler.warn.future.attr=\
1853     {0} attribute introduced in version {1}.{2} class files is ignored in version {3}.{4} class files
1854 
1855 compiler.warn.requires.automatic=\
1856     requires directive for an automatic module
1857 
1858 compiler.warn.requires.transitive.automatic=\
1859     requires transitive directive for an automatic module
1860 
1861 # Warnings related to annotation processing
1862 # 0: string
1863 compiler.warn.proc.package.does.not.exist=\
1864     package {0} does not exist
1865 
1866 # 0: string
1867 compiler.warn.proc.file.reopening=\
1868     Attempt to create a file for &#39;&#39;{0}&#39;&#39; multiple times
1869 
1870 # 0: string
1871 compiler.warn.proc.type.already.exists=\
1872     A file for type &#39;&#39;{0}&#39;&#39; already exists on the sourcepath or classpath
1873 
1874 # 0: string
1875 compiler.warn.proc.type.recreate=\
1876     Attempt to create a file for type &#39;&#39;{0}&#39;&#39; multiple times
1877 
1878 # 0: string
1879 compiler.warn.proc.illegal.file.name=\
1880     Cannot create file for illegal name &#39;&#39;{0}&#39;&#39;.
1881 
1882 # 0: string, 1: string
1883 compiler.warn.proc.suspicious.class.name=\
1884     Creating file for a type whose name ends in {1}: &#39;&#39;{0}&#39;&#39;
1885 
1886 # 0: string
1887 compiler.warn.proc.file.create.last.round=\
1888     File for type &#39;&#39;{0}&#39;&#39; created in the last round will not be subject to annotation processing.
1889 
1890 # 0: string, 1: string
1891 compiler.warn.proc.malformed.supported.string=\
1892     Malformed string &#39;&#39;{0}&#39;&#39; for a supported annotation type returned by processor &#39;&#39;{1}&#39;&#39;
1893 
1894 # 0: set of string
1895 compiler.warn.proc.annotations.without.processors=\
1896     No processor claimed any of these annotations: {0}
1897 
1898 # 0: source version, 1: string, 2: string
1899 compiler.warn.proc.processor.incompatible.source.version=\
1900     Supported source version &#39;&#39;{0}&#39;&#39; from annotation processor &#39;&#39;{1}&#39;&#39; less than -source &#39;&#39;{2}&#39;&#39;
1901 
<a name="25" id="anc25"></a>











1902 compiler.warn.proc.proc-only.requested.no.procs=\
1903     Annotation processing without compilation requested but no processors were found.
1904 
1905 compiler.warn.proc.use.implicit=\
1906     Implicitly compiled files were not subject to annotation processing.\n\
1907     Use -implicit to specify a policy for implicit compilation.
1908 
1909 compiler.warn.proc.use.proc.or.implicit=\
1910     Implicitly compiled files were not subject to annotation processing.\n\
1911     Use -proc:none to disable annotation processing or -implicit to specify a policy for implicit compilation.
1912 
1913 # Print a client-generated warning; assumed to be localized, no translation required
1914 # 0: string
1915 compiler.warn.proc.messager=\
1916     {0}
1917 
1918 # 0: set of string
1919 compiler.warn.proc.unclosed.type.files=\
1920     Unclosed files for the types &#39;&#39;{0}&#39;&#39;; these types will not undergo annotation processing
1921 
1922 # 0: string
1923 compiler.warn.proc.unmatched.processor.options=\
1924     The following options were not recognized by any processor: &#39;&#39;{0}&#39;&#39;
1925 
1926 compiler.warn.try.explicit.close.call=\
1927     explicit call to close() on an auto-closeable resource
1928 
1929 # 0: symbol
1930 compiler.warn.try.resource.not.referenced=\
1931     auto-closeable resource {0} is never referenced in body of corresponding try statement
1932 
1933 # 0: type
1934 compiler.warn.try.resource.throws.interrupted.exc=\
1935     auto-closeable resource {0} has a member method close() that could throw InterruptedException
1936 
1937 compiler.warn.unchecked.assign=\
1938     unchecked assignment: {0} to {1}
1939 
1940 # 0: symbol, 1: type
1941 compiler.warn.unchecked.assign.to.var=\
1942     unchecked assignment to variable {0} as member of raw type {1}
1943 
1944 # 0: symbol, 1: type
1945 compiler.warn.unchecked.call.mbr.of.raw.type=\
1946     unchecked call to {0} as a member of the raw type {1}
1947 
1948 compiler.warn.unchecked.cast.to.type=\
1949     unchecked cast to type {0}
1950 
1951 # 0: kind name, 1: name, 2: object, 3: object, 4: kind name, 5: symbol
1952 compiler.warn.unchecked.meth.invocation.applied=\
1953     unchecked method invocation: {0} {1} in {4} {5} is applied to given types\n\
1954     required: {2}\n\
1955     found:    {3}
1956 
1957 # 0: type
1958 compiler.warn.unchecked.generic.array.creation=\
1959     unchecked generic array creation for varargs parameter of type {0}
1960 
1961 # 0: type
1962 compiler.warn.unchecked.varargs.non.reifiable.type=\
1963     Possible heap pollution from parameterized vararg type {0}
1964 
1965 # 0: symbol
1966 compiler.warn.varargs.unsafe.use.varargs.param=\
1967     Varargs method could cause heap pollution from non-reifiable varargs parameter {0}
1968 
1969 compiler.warn.missing.deprecated.annotation=\
1970     deprecated item is not annotated with @Deprecated
1971 
1972 # 0: kind name
1973 compiler.warn.deprecated.annotation.has.no.effect=\
1974     @Deprecated annotation has no effect on this {0} declaration
1975 
1976 # 0: string
1977 compiler.warn.invalid.path=\
1978     Invalid filename: {0}
1979 
1980 # 0: string
1981 compiler.err.invalid.path=\
1982     Invalid filename: {0}
1983 
1984 
1985 # 0: path
1986 compiler.warn.invalid.archive.file=\
1987     Unexpected file on path: {0}
1988 
1989 # 0: path
1990 compiler.warn.unexpected.archive.file=\
1991     Unexpected extension for archive file: {0}
1992 
1993 # 0: path
1994 compiler.err.no.zipfs.for.archive=\
1995     No file system provider is available to handle this file: {0}
1996 
1997 compiler.warn.div.zero=\
1998     division by zero
1999 
2000 compiler.warn.empty.if=\
2001     empty statement after if
2002 
2003 # 0: type, 1: name
2004 compiler.warn.annotation.method.not.found=\
2005     Cannot find annotation method &#39;&#39;{1}()&#39;&#39; in type &#39;&#39;{0}&#39;&#39;
2006 
2007 # 0: type, 1: name, 2: message segment
2008 compiler.warn.annotation.method.not.found.reason=\
2009     Cannot find annotation method &#39;&#39;{1}()&#39;&#39; in type &#39;&#39;{0}&#39;&#39;: {2}
2010 
2011 # 0: file object, 1: symbol, 2: name
2012 compiler.warn.unknown.enum.constant=\
2013     unknown enum constant {1}.{2}
2014 
2015 # 0: file object, 1: symbol, 2: name, 3: message segment
2016 compiler.warn.unknown.enum.constant.reason=\
2017     unknown enum constant {1}.{2}\n\
2018     reason: {3}
2019 
2020 # 0: type, 1: type
2021 compiler.warn.raw.class.use=\
2022     found raw type: {0}\n\
2023     missing type arguments for generic class {1}
2024 
2025 compiler.warn.diamond.redundant.args=\
2026     Redundant type arguments in new expression (use diamond operator instead).
2027 
2028 compiler.warn.local.redundant.type=\
2029     Redundant type for local variable (replace explicit type with &#39;&#39;var&#39;&#39;).
2030 
2031 compiler.warn.potential.lambda.found=\
2032     This anonymous inner class creation can be turned into a lambda expression.
2033 
2034 compiler.warn.method.redundant.typeargs=\
2035     Redundant type arguments in method call.
2036 
2037 # 0: symbol, 1: message segment
2038 compiler.warn.varargs.redundant.trustme.anno=\
2039     Redundant {0} annotation. {1}
2040 
2041 # 0: symbol
2042 compiler.warn.access.to.member.from.serializable.element=\
2043     access to member {0} from serializable element can be publicly accessible to untrusted code
2044 
2045 # 0: symbol
2046 compiler.warn.access.to.member.from.serializable.lambda=\
2047     access to member {0} from serializable lambda can be publicly accessible to untrusted code
2048 
2049 #####
2050 
2051 ## The following are tokens which are non-terminals in the language. They should
2052 ## be named as JLS3 calls them when translated to the appropriate language.
2053 compiler.misc.token.identifier=\
2054     &lt;identifier&gt;
2055 
2056 compiler.misc.token.character=\
2057     &lt;character&gt;
2058 
2059 compiler.misc.token.string=\
2060     &lt;string&gt;
2061 
2062 compiler.misc.token.integer=\
2063     &lt;integer&gt;
2064 
2065 compiler.misc.token.long-integer=\
2066     &lt;long integer&gt;
2067 
2068 compiler.misc.token.float=\
2069     &lt;float&gt;
2070 
2071 compiler.misc.token.double=\
2072     &lt;double&gt;
2073 
2074 compiler.misc.token.bad-symbol=\
2075     &lt;bad symbol&gt;
2076 
2077 compiler.misc.token.end-of-input=\
2078     &lt;end of input&gt;
2079 
2080 ## The argument to the following string will always be one of the following:
2081 ## 1. one of the above non-terminals
2082 ## 2. a keyword (JLS1.8)
2083 ## 3. a boolean literal (JLS3.10.3)
2084 ## 4. the null literal (JLS3.10.7)
2085 ## 5. a Java separator (JLS3.11)
2086 ## 6. an operator (JLS3.12)
2087 ##
2088 ## This is the only place these tokens will be used.
2089 # 0: token
2090 compiler.err.expected=\
2091     {0} expected
2092 
2093 # 0: string
2094 compiler.err.expected.str=\
2095     {0} expected
2096 
2097 # 0: token, 1: token
2098 compiler.err.expected2=\
2099     {0} or {1} expected
2100 
2101 # 0: token, 1: token, 2: token
2102 compiler.err.expected3=\
2103     {0}, {1}, or {2} expected
2104 
<a name="26" id="anc26"></a>



2105 compiler.err.premature.eof=\
2106     reached end of file while parsing
2107 
<a name="27" id="anc27"></a>





2108 ## The following are related in form, but do not easily fit the above paradigm.
2109 compiler.err.expected.module=\
2110     &#39;&#39;module&#39;&#39; expected
2111 
2112 compiler.err.expected.module.or.open=\
2113     &#39;&#39;module&#39;&#39; or &#39;&#39;open&#39;&#39; expected
2114 
2115 compiler.err.dot.class.expected=\
2116     &#39;&#39;.class&#39;&#39; expected
2117 
2118 ## The argument to this string will always be either &#39;case&#39; or &#39;default&#39;.
2119 # 0: token
2120 compiler.err.orphaned=\
2121     orphaned {0}
2122 
2123 # 0: name
2124 compiler.misc.anonymous.class=\
2125     &lt;anonymous {0}&gt;
2126 
2127 # 0: name, 1: type
2128 compiler.misc.type.captureof=\
2129     capture#{0} of {1}
2130 
2131 compiler.misc.type.captureof.1=\
2132     capture#{0}
2133 
2134 compiler.misc.type.none=\
2135     &lt;none&gt;
2136 
2137 compiler.misc.unnamed.package=\
2138     unnamed package
2139 
2140 compiler.misc.unnamed.module=\
2141     unnamed module
2142 
2143 #####
2144 
2145 # 0: symbol, 1: message segment
2146 compiler.err.cant.access=\
2147     cannot access {0}\n\
2148     {1}
2149 
2150 # 0: name
2151 compiler.misc.bad.class.file=\
2152     class file is invalid for class {0}
2153 
2154 # 0: file name, 1: string (expected constant pool entry type), 2: number (constant pool index)
2155 compiler.misc.bad.const.pool.entry=\
2156     bad constant pool entry in {0}\n\
2157     expected {1} at index {2}
2158 
<a name="28" id="anc28"></a>




2159 # 0: file name, 1: message segment
2160 compiler.misc.bad.class.file.header=\
2161     bad class file: {0}\n\
2162     {1}\n\
2163     Please remove or make sure it appears in the correct subdirectory of the classpath.
2164 
2165 # 0: file name, 1: message segment
2166 compiler.misc.bad.source.file.header=\
2167     bad source file: {0}\n\
2168     {1}\n\
2169     Please remove or make sure it appears in the correct subdirectory of the sourcepath.
2170 
2171 ## The following are all possible strings for the second argument ({1}) of the
2172 ## above strings.
2173 compiler.misc.bad.class.signature=\
2174     bad class signature: {0}
2175 
2176 #0: symbol, 1: symbol
2177 compiler.misc.bad.enclosing.class=\
2178     bad enclosing class for {0}: {1}
2179 
2180 # 0: symbol
2181 compiler.misc.bad.enclosing.method=\
2182     bad enclosing method attribute for class {0}
2183 
2184 compiler.misc.bad.runtime.invisible.param.annotations=\
2185     bad RuntimeInvisibleParameterAnnotations attribute: {0}
2186 
2187 compiler.misc.bad.const.pool.tag=\
2188     bad constant pool tag: {0}
2189 
2190 compiler.misc.bad.const.pool.tag.at=\
2191     bad constant pool tag: {0} at {1}
2192 
2193 compiler.misc.bad.signature=\
2194     bad signature: {0}
2195 
2196 compiler.misc.bad.type.annotation.value=\
2197     bad type annotation target type value: {0}
2198 
2199 compiler.misc.bad.module-info.name=\
2200     bad class name
2201 
2202 compiler.misc.class.file.wrong.class=\
2203     class file contains wrong class: {0}
2204 
2205 compiler.misc.module.info.invalid.super.class=\
2206     module-info with invalid super class
2207 
2208 # 0: name
2209 compiler.misc.class.file.not.found=\
2210     class file for {0} not found
2211 
2212 # 0: string (constant value), 1: symbol (constant field), 2: type (field type)
2213 compiler.misc.bad.constant.range=\
2214     constant value &#39;&#39;{0}&#39;&#39; for {1} is outside the expected range for {2}
2215 
2216 # 0: string (constant value), 1: symbol (constant field), 2: string (expected class)
2217 compiler.misc.bad.constant.value=\
2218     bad constant value &#39;&#39;{0}&#39;&#39; for {1}, expected {2}
2219 
<a name="29" id="anc29"></a>



2220 # 0: string (classfile major version), 1: string (classfile minor version)
2221 compiler.misc.invalid.default.interface=\
2222     default method found in version {0}.{1} classfile
2223 
2224 # 0: string (classfile major version), 1: string (classfile minor version)
2225 compiler.misc.invalid.static.interface=\
2226     static method found in version {0}.{1} classfile
2227 
2228 # 0: string (classfile major version), 1: string (classfile minor version)
2229 compiler.misc.anachronistic.module.info=\
2230     module declaration found in version {0}.{1} classfile
2231 
2232 # 0: name
2233 compiler.misc.file.doesnt.contain.class=\
2234     file does not contain class {0}
2235 
2236 # 0: symbol
2237 compiler.misc.file.does.not.contain.package=\
2238     file does not contain package {0}
2239 
2240 compiler.misc.file.does.not.contain.module=\
2241     file does not contain module declaration
2242 
2243 compiler.misc.illegal.start.of.class.file=\
2244     illegal start of class file
2245 
2246 compiler.misc.unable.to.access.file=\
2247     unable to access file: {0}
2248 
2249 compiler.misc.unicode.str.not.supported=\
2250     unicode string in class file not supported
2251 
2252 compiler.misc.undecl.type.var=\
2253     undeclared type variable: {0}
2254 
2255 compiler.misc.malformed.vararg.method=\
2256     class file contains malformed variable arity method: {0}
2257 
2258 compiler.misc.wrong.version=\
2259     class file has wrong version {0}.{1}, should be {2}.{3}
2260 
2261 #####
2262 
2263 # 0: type, 1: type or symbol
2264 compiler.err.not.within.bounds=\
2265     type argument {0} is not within bounds of type-variable {1}
2266 
2267 ## The following are all possible strings for the second argument ({1}) of the
2268 ## above string.
2269 
2270 ## none yet...
2271 
2272 #####
2273 
2274 # 0: message segment
2275 compiler.err.prob.found.req=\
2276     incompatible types: {0}
2277 
2278 # 0: message segment
2279 compiler.misc.prob.found.req=\
2280     incompatible types: {0}
2281 
2282 # 0: message segment, 1: type, 2: type
2283 compiler.warn.prob.found.req=\
2284     {0}\n\
2285     required: {2}\n\
2286     found:    {1}
2287 
2288 # 0: type, 1: type
2289 compiler.misc.inconvertible.types=\
2290     {0} cannot be converted to {1}
2291 
2292 # 0: type, 1: type
2293 compiler.misc.possible.loss.of.precision=\
2294     possible lossy conversion from {0} to {1}
2295 
2296 compiler.misc.unchecked.assign=\
2297     unchecked conversion
2298 
2299 # compiler.misc.storecheck=\
2300 #     assignment might cause later store checks to fail
2301 # compiler.misc.unchecked=\
2302 #     assigned array cannot dynamically check its stores
2303 compiler.misc.unchecked.cast.to.type=\
2304     unchecked cast
2305 
2306 # compiler.err.star.expected=\
2307 #     &#39;&#39;*&#39;&#39; expected
2308 # compiler.err.no.elem.type=\
2309 #     \[\*\] cannot have a type
2310 
2311 # 0: message segment
2312 compiler.misc.try.not.applicable.to.type=\
2313     try-with-resources not applicable to variable type\n\
2314     ({0})
2315 
2316 #####
2317 
2318 # 0: object, 1: message segment
2319 compiler.err.type.found.req=\
2320     unexpected type\n\
2321     required: {1}\n\
2322     found:    {0}
2323 
2324 ## The following are all possible strings for the first argument ({0}) of the
2325 ## above string.
2326 compiler.misc.type.req.class=\
2327     class
2328 
2329 compiler.misc.type.req.class.array=\
2330     class or array
2331 
2332 compiler.misc.type.req.array.or.iterable=\
2333     array or java.lang.Iterable
2334 
2335 compiler.misc.type.req.ref=\
2336     reference
2337 
2338 compiler.misc.type.req.exact=\
2339     class or interface without bounds
2340 
2341 # 0: type
2342 compiler.misc.type.parameter=\
2343     type parameter {0}
2344 
2345 #####
2346 
2347 ## The following are all possible strings for the last argument of all those
2348 ## diagnostics whose key ends in &quot;.1&quot;
2349 
2350 # 0: type, 1: list of type
2351 compiler.misc.no.unique.maximal.instance.exists=\
2352     no unique maximal instance exists for type variable {0} with upper bounds {1}
2353 
2354 # 0: type, 1: list of type
2355 compiler.misc.no.unique.minimal.instance.exists=\
2356     no unique minimal instance exists for type variable {0} with lower bounds {1}
2357 
2358 # 0: type, 1: list of type
2359 compiler.misc.incompatible.upper.bounds=\
2360     inference variable {0} has incompatible upper bounds {1}
2361 
2362 # 0: type, 1: list of type
2363 compiler.misc.incompatible.eq.bounds=\
2364     inference variable {0} has incompatible equality constraints {1}
2365 
2366 # 0: type, 1: fragment, 2: fragment
2367 compiler.misc.incompatible.bounds=\
2368     inference variable {0} has incompatible bounds\n\
2369     {1}\n\
2370     {2}
2371 
2372 # 0: list of type
2373 compiler.misc.lower.bounds=\
2374         lower bounds: {0}
2375 
2376 # 0: list of type
2377 compiler.misc.eq.bounds=\
2378         equality constraints: {0}
2379 
2380 # 0: list of type
2381 compiler.misc.upper.bounds=\
2382         lower bounds: {0}
2383 
2384 # 0: list of type, 1: type, 2: type
2385 compiler.misc.infer.no.conforming.instance.exists=\
2386     no instance(s) of type variable(s) {0} exist so that {1} conforms to {2}
2387 
2388 # 0: list of type, 1: message segment
2389 compiler.misc.infer.no.conforming.assignment.exists=\
2390     cannot infer type-variable(s) {0}\n\
2391     (argument mismatch; {1})
2392 
2393 # 0: list of type
2394 compiler.misc.infer.arg.length.mismatch=\
2395     cannot infer type-variable(s) {0}\n\
2396     (actual and formal argument lists differ in length)
2397 
2398 # 0: list of type, 1: message segment
2399 compiler.misc.infer.varargs.argument.mismatch=\
2400     cannot infer type-variable(s) {0}\n\
2401     (varargs mismatch; {1})
2402 
2403 # 0: type, 1: list of type
2404 compiler.misc.inferred.do.not.conform.to.upper.bounds=\
2405     inferred type does not conform to upper bound(s)\n\
2406     inferred: {0}\n\
2407     upper bound(s): {1}
2408 
2409 # 0: type, 1: list of type
2410 compiler.misc.inferred.do.not.conform.to.lower.bounds=\
2411     inferred type does not conform to lower bound(s)\n\
2412     inferred: {0}\n\
2413     lower bound(s): {1}
2414 
2415 # 0: type, 1: list of type
2416 compiler.misc.inferred.do.not.conform.to.eq.bounds=\
2417     inferred type does not conform to equality constraint(s)\n\
2418     inferred: {0}\n\
2419     equality constraints(s): {1}
2420 
2421 # 0: symbol
2422 compiler.misc.diamond=\
2423     {0}&lt;&gt;
2424 
2425 # 0: type
2426 compiler.misc.diamond.non.generic=\
2427     cannot use &#39;&#39;&lt;&gt;&#39;&#39; with non-generic class {0}
2428 
2429 # 0: list of type, 1: message segment
2430 compiler.misc.diamond.invalid.arg=\
2431     type argument {0} inferred for {1} is not allowed in this context\n\
2432     inferred argument is not expressible in the Signature attribute
2433 
2434 # 0: list of type, 1: message segment
2435 compiler.misc.diamond.invalid.args=\
2436     type arguments {0} inferred for {1} are not allowed in this context\n\
2437     inferred arguments are not expressible in the Signature attribute
2438 
2439 # 0: type
2440 compiler.misc.diamond.and.explicit.params=\
2441     cannot use &#39;&#39;&lt;&gt;&#39;&#39; with explicit type parameters for constructor
2442 
2443 compiler.misc.mref.infer.and.explicit.params=\
2444     cannot use raw constructor reference with explicit type parameters for constructor
2445 
2446 # 0: type, 1: list of type
2447 compiler.misc.explicit.param.do.not.conform.to.bounds=\
2448     explicit type argument {0} does not conform to declared bound(s) {1}
2449 
2450 compiler.misc.arg.length.mismatch=\
2451     actual and formal argument lists differ in length
2452 
2453 # 0: string
2454 compiler.misc.wrong.number.type.args=\
2455     wrong number of type arguments; required {0}
2456 
2457 # 0: message segment
2458 compiler.misc.no.conforming.assignment.exists=\
2459     argument mismatch; {0}
2460 
2461 # 0: message segment
2462 compiler.misc.varargs.argument.mismatch=\
2463     varargs mismatch; {0}
2464 
2465 #####
2466 
2467 # 0: symbol or type, 1: file name
2468 compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=\
2469     auxiliary class {0} in {1} should not be accessed from outside its own source file
2470 
2471 ## The first argument ({0}) is a &quot;kindname&quot;.
2472 # 0: kind name, 1: symbol, 2: symbol
2473 compiler.err.abstract.cant.be.accessed.directly=\
2474     abstract {0} {1} in {2} cannot be accessed directly
2475 
2476 ## The first argument ({0}) is a &quot;kindname&quot;.
2477 # 0: symbol kind, 1: symbol
2478 compiler.err.non-static.cant.be.ref=\
2479     non-static {0} {1} cannot be referenced from a static context
2480 
2481 # 0: symbol kind, 1: symbol
2482 compiler.misc.bad.static.method.in.unbound.lookup=\
2483     unexpected static {0} {1} found in unbound lookup
2484 
2485 # 0: symbol kind, 1: symbol
2486 compiler.misc.bad.instance.method.in.unbound.lookup=\
2487     unexpected instance {0} {1} found in unbound lookup
2488 
2489 # 0: symbol kind, 1: symbol
2490 compiler.misc.bad.static.method.in.bound.lookup=\
2491     unexpected static {0} {1} found in bound lookup
2492 
2493 ## Both arguments ({0}, {1}) are &quot;kindname&quot;s.  {0} is a comma-separated list
2494 ## of kindnames (the list should be identical to that provided in source.
2495 # 0: set of kind name, 1: set of kind name
2496 compiler.err.unexpected.type=\
2497     unexpected type\n\
2498     required: {0}\n\
2499     found:    {1}
2500 
2501 compiler.err.unexpected.lambda=\
2502    lambda expression not expected here
2503 
2504 compiler.err.unexpected.mref=\
2505    method reference not expected here
2506 
2507 ## The first argument {0} is a &quot;kindname&quot; (e.g. &#39;constructor&#39;, &#39;field&#39;, etc.)
2508 ## The second argument {1} is the non-resolved symbol
2509 ## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
2510 ## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
2511 # 0: kind name, 1: name, 2: unused, 3: unused
2512 compiler.err.cant.resolve=\
2513     cannot find symbol\n\
2514     symbol: {0} {1}
2515 
2516 # 0: kind name, 1: name, 2: unused, 3: list of type
2517 compiler.err.cant.resolve.args=\
2518     cannot find symbol\n\
2519     symbol: {0} {1}({3})
2520 
2521 # 0: kind name, 1: name, 2: unused, 3: list of type
2522 compiler.misc.cant.resolve.args=\
2523     cannot find symbol\n\
2524     symbol: {0} {1}({3})
2525 
2526 # 0: kind name, 1: name, 2: list of type, 3: list of type
2527 compiler.err.cant.resolve.args.params=\
2528     cannot find symbol\n\
2529     symbol: {0} &lt;{2}&gt;{1}({3})
2530 
2531 ## arguments from {0} to {3} have the same meaning as above
2532 ## The fifth argument {4} is a location subdiagnostic (see below)
2533 # 0: kind name, 1: name, 2: unused, 3: unused, 4: message segment
2534 compiler.err.cant.resolve.location=\
2535     cannot find symbol\n\
2536     symbol:   {0} {1}\n\
2537     location: {4}
2538 
2539 # 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
2540 compiler.err.cant.resolve.location.args=\
2541     cannot find symbol\n\
2542     symbol:   {0} {1}({3})\n\
2543     location: {4}
2544 
2545 # 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
2546 compiler.err.cant.resolve.location.args.params=\
2547     cannot find symbol\n\
2548     symbol:   {0} &lt;{2}&gt;{1}({3})\n\
2549     location: {4}
2550 
2551 ### Following are replicated/used for method reference diagnostics
2552 
2553 # 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
2554 compiler.misc.cant.resolve.location.args=\
2555     cannot find symbol\n\
2556     symbol:   {0} {1}({3})\n\
2557     location: {4}
2558 
2559 # 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
2560 compiler.misc.cant.resolve.location.args.params=\
2561     cannot find symbol\n\
2562     symbol:   {0} &lt;{2}&gt;{1}({3})\n\
2563     location: {4}
2564 
2565 ##a location subdiagnostic is composed as follows:
2566 ## The first argument {0} is the location &quot;kindname&quot; (e.g. &#39;constructor&#39;, &#39;field&#39;, etc.)
2567 ## The second argument {1} is the location name
2568 ## The third argument {2} is the location type (only when {1} is a variable name)
2569 
2570 # 0: kind name, 1: type or symbol, 2: unused
2571 compiler.misc.location=\
2572     {0} {1}
2573 
2574 # 0: kind name, 1: symbol, 2: type
2575 compiler.misc.location.1=\
2576     {0} {1} of type {2}
2577 
2578 ## The following are all possible string for &quot;kindname&quot;.
2579 ## They should be called whatever the JLS calls them after it been translated
2580 ## to the appropriate language.
2581 # compiler.misc.kindname.constructor=\
2582 #     static member
2583 compiler.misc.kindname.annotation=\
2584     @interface
2585 
2586 compiler.misc.kindname.constructor=\
2587     constructor
2588 
2589 compiler.misc.kindname.enum=\
2590     enum
2591 
2592 compiler.misc.kindname.interface=\
2593     interface
2594 
2595 compiler.misc.kindname.static=\
2596     static
2597 
2598 compiler.misc.kindname.type.variable=\
2599     type variable
2600 
2601 compiler.misc.kindname.type.variable.bound=\
2602     bound of type variable
2603 
2604 compiler.misc.kindname.variable=\
2605     variable
2606 
2607 compiler.misc.kindname.value=\
2608     value
2609 
2610 compiler.misc.kindname.method=\
2611     method
2612 
2613 compiler.misc.kindname.class=\
2614     class
2615 
2616 compiler.misc.kindname.package=\
2617     package
2618 
2619 compiler.misc.kindname.module=\
2620     module
2621 
2622 compiler.misc.kindname.static.init=\
2623     static initializer
2624 
2625 compiler.misc.kindname.instance.init=\
2626     instance initializer
2627 
<a name="30" id="anc30"></a><span class="line-modified">2628 # the following are names of tree kinds:</span>
<span class="line-modified">2629 compiler.misc.tree.tag.forloop=\</span>
<span class="line-removed">2630     for</span>
<span class="line-removed">2631 </span>
<span class="line-removed">2632 compiler.misc.tree.tag.foreachloop=\</span>
<span class="line-removed">2633     for</span>
2634 
<a name="31" id="anc31"></a><span class="line-modified">2635 compiler.misc.tree.tag.whileloop=\</span>
<span class="line-modified">2636     while</span>
<span class="line-removed">2637 </span>
<span class="line-removed">2638 compiler.misc.tree.tag.doloop=\</span>
<span class="line-removed">2639     do</span>
<span class="line-removed">2640 </span>
<span class="line-removed">2641 compiler.misc.tree.tag.switch=\</span>
<span class="line-removed">2642     switch</span>
2643 
2644 #####
2645 
2646 compiler.misc.no.args=\
2647     no arguments
2648 
2649 # 0: message segment
2650 compiler.err.override.static=\
2651     {0}\n\
2652     overriding method is static
2653 
2654 # 0: message segment, 1: set of flag
2655 compiler.err.override.meth=\
2656     {0}\n\
2657     overridden method is {1}
2658 
2659 # 0: message segment, 1: type
2660 compiler.err.override.meth.doesnt.throw=\
2661     {0}\n\
2662     overridden method does not throw {1}
2663 
2664 # In the following string {1} is a space separated list of Java Keywords, as
2665 # they would have been declared in the source code
2666 # 0: message segment, 1: set of flag or string
2667 compiler.err.override.weaker.access=\
2668     {0}\n\
2669     attempting to assign weaker access privileges; was {1}
2670 
2671 # 0: message segment, 1: type, 2: type
2672 compiler.err.override.incompatible.ret=\
2673     {0}\n\
2674     return type {1} is not compatible with {2}
2675 
2676 # 0: message segment, 1: type, 2: type
2677 compiler.warn.override.unchecked.ret=\
2678     {0}\n\
2679     return type requires unchecked conversion from {1} to {2}
2680 
2681 # 0: message segment, 1: type
2682 compiler.warn.override.unchecked.thrown=\
2683     {0}\n\
2684     overridden method does not throw {1}
2685 
2686 # 0: symbol
2687 compiler.warn.override.equals.but.not.hashcode=\
2688     Class {0} overrides equals, but neither it nor any superclass overrides hashCode method
2689 
2690 ## The following are all possible strings for the first argument ({0}) of the
2691 ## above strings.
2692 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2693 compiler.misc.cant.override=\
2694     {0} in {1} cannot override {2} in {3}
2695 
2696 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2697 compiler.misc.cant.hide=\
2698     {0} in {1} cannot hide {2} in {3}
2699 
2700 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2701 compiler.misc.cant.implement=\
2702     {0} in {1} cannot implement {2} in {3}
2703 
2704 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2705 compiler.misc.clashes.with=\
2706     {0} in {1} clashes with {2} in {3}
2707 
2708 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2709 compiler.misc.unchecked.override=\
2710     {0} in {1} overrides {2} in {3}
2711 
2712 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2713 compiler.misc.unchecked.implement=\
2714     {0} in {1} implements {2} in {3}
2715 
2716 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2717 compiler.misc.unchecked.clash.with=\
2718     {0} in {1} overrides {2} in {3}
2719 
2720 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2721 compiler.misc.varargs.override=\
2722     {0} in {1} overrides {2} in {3}
2723 
2724 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2725 compiler.misc.varargs.implement=\
2726     {0} in {1} implements {2} in {3}
2727 
2728 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2729 compiler.misc.varargs.clash.with=\
2730     {0} in {1} overrides {2} in {3}
2731 
2732 # 0: kind name, 1: symbol, 2: symbol, 3: message segment
2733 compiler.misc.inapplicable.method=\
2734     {0} {1}.{2} is not applicable\n\
2735     ({3})
2736 
2737 ########################################
2738 # Diagnostics for language feature changes.
2739 # Such diagnostics have a common template which can be customized by using a feature
2740 # diagnostic fragment (one of those given below).
2741 ########################################
2742 
2743 # 0: message segment (feature), 1: string (found version), 2: string (expected version)
2744 compiler.err.feature.not.supported.in.source=\
2745    {0} is not supported in -source {1}\n\
2746     (use -source {2} or higher to enable {0})
2747 
2748 # 0: message segment (feature), 1: string (found version), 2: string (expected version)
2749 compiler.err.feature.not.supported.in.source.plural=\
2750    {0} are not supported in -source {1}\n\
2751     (use -source {2} or higher to enable {0})
2752 
2753 # 0: message segment (feature), 1: string (found version), 2: string (expected version)
2754 compiler.misc.feature.not.supported.in.source=\
2755    {0} is not supported in -source {1}\n\
2756     (use -source {2} or higher to enable {0})
2757 
2758 # 0: message segment (feature), 1: string (found version), 2: string (expected version)
2759 compiler.misc.feature.not.supported.in.source.plural=\
2760    {0} are not supported in -source {1}\n\
2761     (use -source {2} or higher to enable {0})
2762 
2763 # 0: message segment (feature)
2764 compiler.err.preview.feature.disabled=\
2765    {0} is a preview feature and is disabled by default.\n\
2766    (use --enable-preview to enable {0})
2767 
2768 # 0: message segment (feature)
2769 compiler.err.preview.feature.disabled.plural=\
2770    {0} are a preview feature and are disabled by default.\n\
2771    (use --enable-preview to enable {0})
2772 
2773 # 0: file object (classfile), 1: string (expected version)
2774 compiler.err.preview.feature.disabled.classfile=\
2775    classfile for {0} uses preview features of Java SE {1}.\n\
2776    (use --enable-preview to allow loading of classfiles which contain preview features)
2777 
2778 # 0: message segment (feature)
2779 compiler.warn.preview.feature.use=\
2780    {0} is a preview feature and may be removed in a future release.
2781 
2782 # 0: message segment (feature)
2783 compiler.warn.preview.feature.use.plural=\
2784    {0} are a preview feature and may be removed in a future release.
2785 
2786 # 0: file object (classfile), 1: string (expected version)
2787 compiler.warn.preview.feature.use.classfile=\
2788    classfile for {0} uses preview features of Java SE {1}.
2789 
2790 
2791 compiler.misc.feature.modules=\
2792     modules
2793 
2794 compiler.misc.feature.diamond.and.anon.class=\
2795     &#39;&#39;&lt;&gt;&#39;&#39; with anonymous inner classes
2796 
2797 compiler.misc.feature.var.in.try.with.resources=\
2798     variables in try-with-resources
2799 
2800 compiler.misc.feature.type.annotations=\
2801     type annotations
2802 
2803 compiler.misc.feature.annotations.after.type.params=\
2804     annotations after method type parameters
2805 
2806 compiler.misc.feature.repeatable.annotations=\
2807     repeated annotations
2808 
2809 compiler.misc.feature.diamond=\
2810     diamond operator
2811 
2812 compiler.misc.feature.lambda=\
2813     lambda expressions
2814 
2815 compiler.misc.feature.method.references=\
2816     method references
2817 
2818 compiler.misc.feature.default.methods=\
2819     default methods
2820 
2821 compiler.misc.feature.intersection.types.in.cast=\
2822     intersection types
2823 
2824 compiler.misc.feature.static.intf.methods=\
2825     static interface methods
2826 
2827 compiler.misc.feature.static.intf.method.invoke=\
2828     static interface method invocations
2829 
2830 compiler.misc.feature.private.intf.methods=\
2831     private interface methods
2832 
<a name="32" id="anc32"></a>


2833 compiler.misc.feature.multiple.case.labels=\
2834     multiple case labels
2835 
2836 compiler.misc.feature.switch.rules=\
2837     switch rules
2838 
2839 compiler.misc.feature.switch.expressions=\
2840     switch expressions
2841 
2842 compiler.misc.feature.var.syntax.in.implicit.lambda=\
2843     var syntax in implicit lambdas
2844 
<a name="33" id="anc33"></a>








2845 compiler.warn.underscore.as.identifier=\
2846     as of release 9, &#39;&#39;_&#39;&#39; is a keyword, and may not be used as an identifier
2847 
2848 compiler.err.underscore.as.identifier=\
2849     as of release 9, &#39;&#39;_&#39;&#39; is a keyword, and may not be used as an identifier
2850 
2851 compiler.err.underscore.as.identifier.in.lambda=\
2852     &#39;&#39;_&#39;&#39; used as an identifier\n\
2853     (use of &#39;&#39;_&#39;&#39; as an identifier is forbidden for lambda parameters)
2854 
2855 compiler.err.enum.as.identifier=\
2856     as of release 5, &#39;&#39;enum&#39;&#39; is a keyword, and may not be used as an identifier
2857 
2858 compiler.err.assert.as.identifier=\
2859     as of release 1.4, &#39;&#39;assert&#39;&#39; is a keyword, and may not be used as an identifier
2860 
2861 # TODO 308: make a better error message
2862 compiler.err.this.as.identifier=\
2863     as of release 8, &#39;&#39;this&#39;&#39; is allowed as the parameter name for the receiver type only\n\
2864     which has to be the first parameter, and cannot be a lambda parameter
2865 
2866 compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class=\
2867     receiver parameter not applicable for constructor of top-level class
2868 
2869 # TODO 308: make a better error message
2870 # 0: annotation
2871 compiler.err.cant.type.annotate.scoping.1=\
2872     scoping construct cannot be annotated with type-use annotation: {0}
2873 
2874 # TODO 308: make a better error message
2875 # 0: list of annotation
2876 compiler.err.cant.type.annotate.scoping=\
2877     scoping construct cannot be annotated with type-use annotations: {0}
2878 
2879 # 0: type, 1: type
2880 compiler.err.incorrect.receiver.name=\
2881     the receiver name does not match the enclosing class type\n\
2882     required: {0}\n\
2883     found:    {1}
2884 
2885 # 0: type, 1: type
2886 compiler.err.incorrect.receiver.type=\
2887     the receiver type does not match the enclosing class type\n\
2888     required: {0}\n\
2889     found:    {1}
2890 
2891 # 0: type, 1: type
2892 compiler.err.incorrect.constructor.receiver.type=\
2893     the receiver type does not match the enclosing outer class type\n\
2894     required: {0}\n\
2895     found:    {1}
2896 
2897 # 0: type, 1: type
2898 compiler.err.incorrect.constructor.receiver.name=\
2899     the receiver name does not match the enclosing outer class type\n\
2900     required: {0}\n\
2901     found:    {1}
2902 
2903 compiler.err.no.annotations.on.dot.class=\
2904     no annotations are allowed in the type of a class literal
2905 
2906 ########################################
2907 # Diagnostics for verbose resolution
2908 # used by Resolve (debug only)
2909 ########################################
2910 
2911 # 0: number, 1: symbol, 2: unused
2912 compiler.misc.applicable.method.found=\
2913     #{0} applicable method found: {1}
2914 
2915 # 0: number, 1: symbol, 2: message segment
2916 compiler.misc.applicable.method.found.1=\
2917     #{0} applicable method found: {1}\n\
2918     ({2})
2919 
2920 # 0: number, 1: symbol, 2: message segment
2921 compiler.misc.not.applicable.method.found=\
2922     #{0} not applicable method found: {1}\n\
2923     ({2})
2924 
2925 # 0: type
2926 compiler.misc.partial.inst.sig=\
2927     partially instantiated to: {0}
2928 
2929 # 0: name, 1: symbol, 2: number, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
2930 compiler.note.verbose.resolve.multi=\
2931     resolving method {0} in type {1} to candidate {2}\n\
2932     phase: {3}\n\
2933     with actuals: {4}\n\
2934     with type-args: {5}\n\
2935     candidates:
2936 
2937 # 0: name, 1: symbol, 2: unused, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
2938 compiler.note.verbose.resolve.multi.1=\
2939     erroneous resolution for method {0} in type {1}\n\
2940     phase: {3}\n\
2941     with actuals: {4}\n\
2942     with type-args: {5}\n\
2943     candidates:
2944 
2945 # 0: symbol, 1: type, 2: type
2946 compiler.note.deferred.method.inst=\
2947     Deferred instantiation of method {0}\n\
2948     instantiated signature: {1}\n\
2949     target-type: {2}
2950 
2951 ########################################
2952 # Diagnostics for lambda deduplication
2953 # used by LambdaToMethod (debug only)
2954 ########################################
2955 
2956 # 0: symbol
2957 compiler.note.verbose.l2m.deduplicate=\
2958     deduplicating lambda implementation method {0}
2959 
2960 ########################################
2961 # Diagnostics for where clause implementation
2962 # used by the RichDiagnosticFormatter.
2963 ########################################
2964 
2965 compiler.misc.type.null=\
2966     &lt;null&gt;
2967 
2968 # X#n (where n is an int id) is disambiguated tvar name
2969 # 0: name, 1: number
2970 compiler.misc.type.var=\
2971     {0}#{1}
2972 
2973 # CAP#n (where n is an int id) is an abbreviation for &#39;captured type&#39;
2974 # 0: number
2975 compiler.misc.captured.type=\
2976     CAP#{0}
2977 
2978 # &lt;INT#n&gt; (where n is an int id) is an abbreviation for &#39;intersection type&#39;
2979 # 0: number
2980 compiler.misc.intersection.type=\
2981     INT#{0}
2982 
2983 # where clause for captured type: contains upper (&#39;extends {1}&#39;) and lower
2984 # (&#39;super {2}&#39;) bound along with the wildcard that generated this captured type ({3})
2985 # 0: type, 1: type, 2: type, 3: type
2986 compiler.misc.where.captured=\
2987     {0} extends {1} super: {2} from capture of {3}
2988 
2989 # compact where clause for captured type: contains upper (&#39;extends {1}&#39;) along
2990 # with the wildcard that generated this captured type ({3})
2991 # 0: type, 1: type, 2: unused, 3: type
2992 compiler.misc.where.captured.1=\
2993     {0} extends {1} from capture of {3}
2994 
2995 # where clause for type variable: contains upper bound(s) (&#39;extends {1}&#39;) along with
2996 # the kindname ({2}) and location ({3}) in which the typevar has been declared
2997 # 0: type, 1: list of type, 2: symbol kind, 3: symbol
2998 compiler.misc.where.typevar=\
2999     {0} extends {1} declared in {2} {3}
3000 
3001 # compact where clause for type variable: contains the kindname ({2}) and location ({3})
3002 # in which the typevar has been declared
3003 # 0: type, 1: list of type, 2: symbol kind, 3: symbol
3004 compiler.misc.where.typevar.1=\
3005     {0} declared in {2} {3}
3006 
3007 # where clause for fresh type variable: contains upper bound(s) (&#39;extends {1}&#39;).
3008 # Since a fresh type-variable is synthetic - there&#39;s no location/kindname here.
3009 # 0: type, 1: list of type
3010 compiler.misc.where.fresh.typevar=\
3011     {0} extends {1}
3012 
3013 # where clause for type variable: contains all the upper bound(s) (&#39;extends {1}&#39;)
3014 # of this intersection type
3015 # 0: type, 1: list of type
3016 compiler.misc.where.intersection=\
3017     {0} extends {1}
3018 
3019 ### Where clause headers ###
3020 compiler.misc.where.description.captured=\
3021     where {0} is a fresh type-variable:
3022 
3023 # 0: set of type
3024 compiler.misc.where.description.typevar=\
3025     where {0} is a type-variable:
3026 
3027 # 0: set of type
3028 compiler.misc.where.description.intersection=\
3029     where {0} is an intersection type:
3030 
3031 # 0: set of type
3032 compiler.misc.where.description.captured.1=\
3033     where {0} are fresh type-variables:
3034 
3035 # 0: set of type
3036 compiler.misc.where.description.typevar.1=\
3037     where {0} are type-variables:
3038 
3039 # 0: set of type
3040 compiler.misc.where.description.intersection.1=\
3041     where {0} are intersection types:
3042 
3043 ###
3044 # errors related to doc comments
3045 
3046 compiler.err.dc.bad.entity=\
3047     bad HTML entity
3048 
3049 compiler.err.dc.bad.gt=\
3050     bad use of &#39;&#39;&gt;&#39;&#39;
3051 
3052 compiler.err.dc.bad.inline.tag=\
3053     incorrect use of inline tag
3054 
3055 compiler.err.dc.identifier.expected=\
3056     identifier expected
3057 
3058 compiler.err.dc.malformed.html=\
3059     malformed HTML
3060 
3061 compiler.err.dc.missing.semicolon=\
3062     semicolon missing
3063 
3064 compiler.err.dc.no.content=\
3065     no content
3066 
3067 compiler.err.dc.no.tag.name=\
3068     no tag name after &#39;@&#39;
3069 
3070 compiler.err.dc.gt.expected=\
3071     &#39;&#39;&gt;&#39;&#39; expected
3072 
3073 compiler.err.dc.ref.bad.parens=\
3074     &#39;&#39;)&#39;&#39; missing in reference
3075 
3076 compiler.err.dc.ref.syntax.error=\
3077     syntax error in reference
3078 
3079 compiler.err.dc.ref.unexpected.input=\
3080     unexpected text
3081 
3082 compiler.err.dc.unexpected.content=\
3083     unexpected content
3084 
3085 compiler.err.dc.unterminated.inline.tag=\
3086     unterminated inline tag
3087 
3088 compiler.err.dc.unterminated.signature=\
3089     unterminated signature
3090 
3091 compiler.err.dc.unterminated.string=\
3092     unterminated string
3093 
3094 ###
3095 # errors related to modules
3096 
3097 compiler.err.expected.module=\
3098     expected &#39;&#39;module&#39;&#39;
3099 
3100 # 0: symbol
3101 compiler.err.module.not.found=\
3102     module not found: {0}
3103 
3104 # 0: symbol
3105 compiler.warn.module.not.found=\
3106     module not found: {0}
3107 
3108 compiler.err.too.many.modules=\
3109     too many module declarations found
3110 
3111 compiler.err.module.not.found.on.module.source.path=\
3112     module not found on module source path
3113 
3114 compiler.err.not.in.module.on.module.source.path=\
3115     not in a module on the module source path
3116 
3117 # 0: symbol
3118 compiler.err.duplicate.module=\
3119     duplicate module: {0}
3120 
3121 # 0: symbol
3122 compiler.err.duplicate.requires=\
3123     duplicate requires: {0}
3124 
3125 # 0: symbol
3126 compiler.err.conflicting.exports=\
3127     duplicate or conflicting exports: {0}
3128 
3129 # 0: symbol
3130 compiler.err.conflicting.opens=\
3131     duplicate or conflicting opens: {0}
3132 
3133 # 0: symbol
3134 compiler.err.conflicting.exports.to.module=\
3135     duplicate or conflicting exports to module: {0}
3136 
3137 # 0: symbol
3138 compiler.err.conflicting.opens.to.module=\
3139     duplicate or conflicting opens to module: {0}
3140 
3141 compiler.err.no.opens.unless.strong=\
3142     &#39;&#39;opens&#39;&#39; only allowed in strong modules
3143 
3144 # 0: symbol
3145 compiler.err.repeated.provides.for.service=\
3146     multiple &#39;&#39;provides&#39;&#39; for service {0}
3147 
3148 # 0: symbol, 1: symbol
3149 compiler.err.duplicate.provides=\
3150     duplicate provides: service {0}, implementation {1}
3151 
3152 # 0: symbol
3153 compiler.err.duplicate.uses=\
3154     duplicate uses: {0}
3155 
3156 # 0: symbol
3157 compiler.err.service.implementation.is.abstract=\
3158     the service implementation is an abstract class: {0}
3159 
3160 compiler.err.service.implementation.must.be.subtype.of.service.interface=\
3161     the service implementation type must be a subtype of the service interface type, or \
3162     have a public static no-args method named &quot;provider&quot; returning the service implementation
3163 
3164 compiler.err.service.implementation.provider.return.must.be.subtype.of.service.interface=\
3165     the &quot;provider&quot; method return type must be a subtype of the service interface type
3166 
3167 # 0: symbol
3168 compiler.err.service.implementation.is.inner=\
3169     the service implementation is an inner class: {0}
3170 
3171 # 0: symbol
3172 compiler.err.service.definition.is.enum=\
3173     the service definition is an enum: {0}
3174 
3175 # 0: symbol
3176 compiler.err.service.implementation.doesnt.have.a.no.args.constructor=\
3177     the service implementation does not have a default constructor: {0}
3178 
3179 # 0: symbol
3180 compiler.err.service.implementation.no.args.constructor.not.public=\
3181     the no arguments constructor of the service implementation is not public: {0}
3182 
3183 # 0: symbol
3184 compiler.err.package.empty.or.not.found=\
3185     package is empty or does not exist: {0}
3186 
3187 # 0: symbol
3188 compiler.warn.package.empty.or.not.found=\
3189     package is empty or does not exist: {0}
3190 
3191 compiler.err.no.output.dir=\
3192     no class output directory specified
3193 
3194 compiler.err.unnamed.pkg.not.allowed.named.modules=\
3195     unnamed package is not allowed in named modules
3196 
3197 # 0: name, 1: name
3198 compiler.err.module.name.mismatch=\
3199     module name {0} does not match expected name {1}
3200 
3201 # 0: name, 1: name
3202 compiler.misc.module.name.mismatch=\
3203     module name {0} does not match expected name {1}
3204 
3205 # 0: name
3206 compiler.err.module.non.zero.opens=\
3207     open module {0} has non-zero opens_count
3208 
3209 # 0: name
3210 compiler.misc.module.non.zero.opens=\
3211     open module {0} has non-zero opens_count
3212 
3213 compiler.err.module.decl.sb.in.module-info.java=\
3214     module declarations should be in a file named module-info.java
3215 
3216 # 0: set of string
3217 compiler.err.too.many.patched.modules=\
3218     too many patched modules ({0}), use --module-source-path
3219 
3220 # 0: name, 1: name
3221 compiler.err.file.patched.and.msp=\
3222     file accessible from both --patch-module and --module-source-path, \
3223     but belongs to a different module on each path: {0}, {1}
3224 
3225 compiler.err.processorpath.no.processormodulepath=\
3226     illegal combination of -processorpath and --processor-module-path
3227 
3228 # 0: symbol
3229 compiler.err.package.in.other.module=\
3230     package exists in another module: {0}
3231 
3232 # 0: symbol, 1: name, 2: symbol, 3: symbol
3233 compiler.err.package.clash.from.requires=\
3234     module {0} reads package {1} from both {2} and {3}
3235 
3236 # 0: name, 1: symbol, 2: symbol
3237 compiler.err.package.clash.from.requires.in.unnamed=\
3238     the unnamed module reads package {0} from both {1} and {2}
3239 
3240 # 0: string
3241 compiler.err.module.not.found.in.module.source.path=\
3242     module {0} not found in module source path
3243 
3244 compiler.err.output.dir.must.be.specified.with.dash.m.option=\
3245     class output directory must be specified if -m option is used
3246 
3247 compiler.err.modulesourcepath.must.be.specified.with.dash.m.option=\
3248     module source path must be specified if -m option is used
3249 
3250 # 0: symbol
3251 compiler.err.service.implementation.not.in.right.module=\
3252     service implementation must be defined in the same module as the provides directive
3253 
3254 # 0: symbol
3255 compiler.err.cyclic.requires=\
3256     cyclic dependence involving {0}
3257 
3258 # 0: fragment, 1: name
3259 compiler.err.duplicate.module.on.path=\
3260     duplicate module on {0}\nmodule in {1}
3261 
3262 # 0: option name, 1: string
3263 compiler.warn.bad.name.for.option=\
3264     bad name in value for {0} option: &#39;&#39;{1}&#39;&#39;
3265 
3266 # 0: option name, 1: string
3267 compiler.err.bad.name.for.option=\
3268     bad name in value for {0} option: &#39;&#39;{1}&#39;&#39;
3269 
3270 # 0: option name, 1: symbol
3271 compiler.warn.module.for.option.not.found=\
3272     module name in {0} option not found: {1}
3273 
3274 compiler.err.addmods.all.module.path.invalid=\
<a name="34" id="anc34"></a><span class="line-modified">3275     --add-modules ALL-MODULE-PATH can only be used when compiling the unnamed module</span>

3276 
3277 # 0: symbol
3278 compiler.err.add.exports.with.release=\
3279     exporting a package from system module {0} is not allowed with --release
3280 
3281 # 0: symbol
3282 compiler.err.add.reads.with.release=\
3283     adding read edges for system module {0} is not allowed with --release
3284 
3285 compiler.warn.addopens.ignored=\
3286     --add-opens has no effect at compile time
3287 
3288 compiler.misc.locn.module_source_path=\
3289     module source path
3290 
3291 compiler.misc.locn.upgrade_module_path=\
3292     upgrade module path
3293 
3294 compiler.misc.locn.system_modules=\
3295     system modules
3296 
3297 compiler.misc.locn.module_path=\
3298     application module path
3299 
3300 compiler.misc.cant.resolve.modules=\
3301     cannot resolve modules
3302 
3303 compiler.misc.bad.requires.flag=\
3304     bad requires flag: {0}
3305 
3306 # 0: string
3307 compiler.err.invalid.module.specifier=\
3308     module specifier not allowed: {0}
3309 
3310 # 0: symbol
3311 compiler.warn.service.provided.but.not.exported.or.used=\
3312     service interface provided but not exported or used
3313 
3314 # 0: kind name, 1: symbol, 2: symbol
3315 compiler.warn.leaks.not.accessible=\
3316     {0} {1} in module {2} is not accessible to clients that require this module
3317 # 0: kind name, 1: symbol, 2: symbol
3318 compiler.warn.leaks.not.accessible.unexported=\
3319     {0} {1} in module {2} is not exported
3320 # 0: kind name, 1: symbol, 2: symbol
3321 compiler.warn.leaks.not.accessible.not.required.transitive=\
3322     {0} {1} in module {2} is not indirectly exported using &#39;requires transitive&#39;
3323 # 0: kind name, 1: symbol, 2: symbol
3324 compiler.warn.leaks.not.accessible.unexported.qualified=\
3325     {0} {1} in module {2} may not be visible to all clients that require this module
3326 
3327 ###
3328 # errors related to options
3329 
3330 # 0: string, 1: string
3331 compiler.err.illegal.argument.for.option=\
3332     illegal argument for {0}: {1}
3333 
<a name="35" id="anc35"></a>


3334 compiler.err.switch.null.not.allowed=\
3335     null label in case is not allowed
3336 
3337 compiler.err.switch.case.unexpected.statement=\
3338     unexpected statement in case, expected is an expression, a block or a throw statement
3339 
3340 compiler.err.switch.mixing.case.types=\
3341     different case kinds used in the switch
3342 
<a name="36" id="anc36"></a>























































































3343 ############################################
<a name="37" id="anc37"></a><span class="line-modified">3344 # messages previouly at javac.properties</span>
3345 
3346 compiler.err.empty.A.argument=\
3347     -A requires an argument; use &#39;&#39;-Akey&#39;&#39; or &#39;&#39;-Akey=value&#39;&#39;
3348 
3349 # 0: string
3350 compiler.err.invalid.A.key=\
3351     key in annotation processor option &#39;&#39;{0}&#39;&#39; is not a dot-separated sequence of identifiers
3352 
3353 # 0: string
3354 compiler.err.invalid.flag=\
3355     invalid flag: {0}
3356 
3357 compiler.err.profile.bootclasspath.conflict=\
3358     profile and bootclasspath options cannot be used together
3359 
3360 # 0: string
3361 compiler.err.invalid.profile=\
3362     invalid profile: {0}
3363 
3364 # 0: string
3365 compiler.err.invalid.target=\
3366     invalid target release: {0}
3367 
3368 # 0: option name, 1: target
3369 compiler.err.option.not.allowed.with.target=\
3370     option {0} not allowed with target {1}
3371 
3372 # 0: string
3373 compiler.err.option.too.many=\
3374     option {0} can only be specified once
3375 
3376 compiler.err.no.source.files=\
3377     no source files
3378 
3379 compiler.err.no.source.files.classes=\
3380     no source files or class names
3381 
3382 # 0: string
3383 compiler.err.req.arg=\
3384     {0} requires an argument
3385 
3386 # 0: string
3387 compiler.err.invalid.source=\
3388     invalid source release: {0}
3389 
3390 # 0: string, 1: string
3391 compiler.err.error.writing.file=\
3392     error writing {0}; {1}
3393 
3394 compiler.err.sourcepath.modulesourcepath.conflict=\
3395     cannot specify both --source-path and --module-source-path
3396 
3397 # 0: string, 1: target
3398 compiler.warn.source.target.conflict=\
3399     source release {0} requires target release {1}
3400 
3401 # 0: string, 1: target
3402 compiler.warn.target.default.source.conflict=\
3403     target release {0} conflicts with default source release {1}
3404 
3405 # 0: profile, 1: target
3406 compiler.warn.profile.target.conflict=\
3407     profile {0} is not valid for target release {1}
3408 
3409 # 0: string
3410 compiler.err.file.not.directory=\
3411     not a directory: {0}
3412 
3413 # 0: object
3414 compiler.err.file.not.file=\
3415     not a file: {0}
3416 
3417 compiler.err.two.class.loaders.1=\
3418     javac is split between multiple class loaders: check your configuration
3419 
3420 # 0: url, 1: url
3421 compiler.err.two.class.loaders.2=\
3422     javac is split between multiple class loaders:\n\
3423     one class comes from file: {0}\n\
3424     while javac comes from {1}
3425 
3426 # 0: string, 1: string
3427 compiler.err.bad.value.for.option=\
3428     bad value for {0} option: &#39;&#39;{1}&#39;&#39;
3429 
3430 # 0: string
3431 compiler.err.no.value.for.option=\
3432     no value for {0} option
3433 
3434 # 0: string
3435 compiler.err.repeated.value.for.patch.module=\
3436     --patch-module specified more than once for module {0}
3437 
3438 # 0: string
3439 compiler.err.repeated.value.for.module.source.path=\
3440     --module-source-path specified more than once for module {0}
3441 
3442 compiler.err.multiple.values.for.module.source.path=\
3443     --module-source-path specified more than once with a pattern argument
3444 
3445 # 0: string
3446 compiler.err.unmatched.quote=\
3447     unmatched quote in environment variable {0}
3448 
3449 # 0: option name
3450 compiler.err.release.bootclasspath.conflict=\
3451     option {0} cannot be used together with --release
3452 
3453 # 0: string
3454 compiler.err.unsupported.release.version=\
3455     release version {0} not supported
3456 
3457 # 0: string
3458 compiler.err.file.not.found=\
3459     file not found: {0}
3460 
3461 # 0: string, 1: source
3462 compiler.err.preview.not.latest=\
3463     invalid source release {0} with --enable-preview\n\
3464     (preview language features are only supported for release {1})
3465 
3466 compiler.err.preview.without.source.or.release=\
3467     --enable-preview must be used with either -source or --release
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
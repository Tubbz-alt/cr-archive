<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 package com.sun.tools.javac.comp;
  28 
  29 import java.io.IOException;
  30 import java.util.Arrays;
  31 import java.util.Collection;
  32 import java.util.Collections;
  33 import java.util.EnumSet;
  34 import java.util.HashMap;
  35 import java.util.HashSet;
  36 import java.util.LinkedHashMap;
  37 import java.util.LinkedHashSet;
  38 import java.util.Map;
  39 import java.util.Set;
  40 import java.util.function.Consumer;
  41 import java.util.function.Predicate;
  42 import java.util.regex.Matcher;
  43 import java.util.regex.Pattern;
  44 import java.util.stream.Collectors;
  45 import java.util.stream.Stream;
  46 
  47 import javax.lang.model.SourceVersion;
  48 import javax.tools.JavaFileManager;
  49 import javax.tools.JavaFileManager.Location;
  50 import javax.tools.JavaFileObject;
  51 import javax.tools.JavaFileObject.Kind;
  52 import javax.tools.StandardLocation;
  53 
  54 import com.sun.source.tree.ModuleTree.ModuleKind;
  55 import com.sun.tools.javac.code.ClassFinder;
  56 import com.sun.tools.javac.code.DeferredLintHandler;
  57 import com.sun.tools.javac.code.Directive;
  58 import com.sun.tools.javac.code.Directive.ExportsDirective;
  59 import com.sun.tools.javac.code.Directive.ExportsFlag;
  60 import com.sun.tools.javac.code.Directive.OpensDirective;
  61 import com.sun.tools.javac.code.Directive.OpensFlag;
  62 import com.sun.tools.javac.code.Directive.RequiresDirective;
  63 import com.sun.tools.javac.code.Directive.RequiresFlag;
  64 import com.sun.tools.javac.code.Directive.UsesDirective;
  65 import com.sun.tools.javac.code.Flags;
  66 import com.sun.tools.javac.code.Flags.Flag;
  67 import com.sun.tools.javac.code.Lint.LintCategory;
  68 import com.sun.tools.javac.code.ModuleFinder;
  69 import com.sun.tools.javac.code.Source;
  70 import com.sun.tools.javac.code.Source.Feature;
  71 import com.sun.tools.javac.code.Symbol;
  72 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  73 import com.sun.tools.javac.code.Symbol.Completer;
  74 import com.sun.tools.javac.code.Symbol.CompletionFailure;
  75 import com.sun.tools.javac.code.Symbol.MethodSymbol;
  76 import com.sun.tools.javac.code.Symbol.ModuleFlags;
  77 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  78 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  79 import com.sun.tools.javac.code.Symtab;
  80 import com.sun.tools.javac.code.Type;
  81 import com.sun.tools.javac.code.Types;
  82 import com.sun.tools.javac.jvm.ClassWriter;
  83 import com.sun.tools.javac.jvm.JNIWriter;
  84 import com.sun.tools.javac.jvm.Target;
  85 import com.sun.tools.javac.main.Option;
  86 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  87 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  88 import com.sun.tools.javac.tree.JCTree;
  89 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
  90 import com.sun.tools.javac.tree.JCTree.JCDirective;
  91 import com.sun.tools.javac.tree.JCTree.JCExports;
  92 import com.sun.tools.javac.tree.JCTree.JCExpression;
  93 import com.sun.tools.javac.tree.JCTree.JCModuleDecl;
  94 import com.sun.tools.javac.tree.JCTree.JCOpens;
  95 import com.sun.tools.javac.tree.JCTree.JCProvides;
  96 import com.sun.tools.javac.tree.JCTree.JCRequires;
  97 import com.sun.tools.javac.tree.JCTree.JCUses;
  98 import com.sun.tools.javac.tree.JCTree.Tag;
  99 import com.sun.tools.javac.tree.TreeInfo;
 100 import com.sun.tools.javac.util.Assert;
 101 import com.sun.tools.javac.util.Context;
 102 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 103 import com.sun.tools.javac.util.List;
 104 import com.sun.tools.javac.util.ListBuffer;
 105 import com.sun.tools.javac.util.Log;
 106 import com.sun.tools.javac.util.Name;
 107 import com.sun.tools.javac.util.Names;
 108 import com.sun.tools.javac.util.Options;
 109 
 110 import static com.sun.tools.javac.code.Flags.ABSTRACT;
 111 import static com.sun.tools.javac.code.Flags.ENUM;
 112 import static com.sun.tools.javac.code.Flags.PUBLIC;
 113 import static com.sun.tools.javac.code.Flags.UNATTRIBUTED;
 114 
 115 import com.sun.tools.javac.code.Kinds;
 116 
 117 import static com.sun.tools.javac.code.Kinds.Kind.ERR;
 118 import static com.sun.tools.javac.code.Kinds.Kind.MDL;
 119 import static com.sun.tools.javac.code.Kinds.Kind.MTH;
 120 
 121 import com.sun.tools.javac.code.Symbol.ModuleResolutionFlags;
 122 
 123 import static com.sun.tools.javac.code.TypeTag.CLASS;
 124 
 125 /**
 126  *  TODO: fill in
 127  *
 128  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 129  *  If you write code that depends on this, you do so at your own risk.
 130  *  This code and its internal interfaces are subject to change or
 131  *  deletion without notice.&lt;/b&gt;
 132  */
 133 public class Modules extends JCTree.Visitor {
 134     private static final String ALL_SYSTEM = &quot;ALL-SYSTEM&quot;;
 135     private static final String ALL_MODULE_PATH = &quot;ALL-MODULE-PATH&quot;;
 136 
 137     private final Log log;
 138     private final Names names;
 139     private final Symtab syms;
 140     private final Attr attr;
 141     private final Check chk;
 142     private final DeferredLintHandler deferredLintHandler;
 143     private final TypeEnvs typeEnvs;
 144     private final Types types;
 145     private final JavaFileManager fileManager;
 146     private final ModuleFinder moduleFinder;
 147     private final Source source;
 148     private final Target target;
 149     private final boolean allowModules;
 150     private final boolean allowAccessIntoSystem;
 151 
 152     public final boolean multiModuleMode;
 153 
 154     private final Name java_se;
 155     private final Name java_;
 156 
 157     ModuleSymbol defaultModule;
 158 
 159     private final String addExportsOpt;
 160     private Map&lt;ModuleSymbol, Set&lt;ExportsDirective&gt;&gt; addExports;
 161     private final String addReadsOpt;
 162     private Map&lt;ModuleSymbol, Set&lt;RequiresDirective&gt;&gt; addReads;
 163     private final String addModsOpt;
 164     private final Set&lt;String&gt; extraAddMods = new HashSet&lt;&gt;();
 165     private final String limitModsOpt;
 166     private final Set&lt;String&gt; extraLimitMods = new HashSet&lt;&gt;();
 167     private final String moduleVersionOpt;
 168 
 169     private final boolean lintOptions;
 170 
 171     private Set&lt;ModuleSymbol&gt; rootModules = null;
 172     private final Set&lt;ModuleSymbol&gt; warnedMissing = new HashSet&lt;&gt;();
 173 
 174     public PackageNameFinder findPackageInFile;
 175 
 176     public static Modules instance(Context context) {
 177         Modules instance = context.get(Modules.class);
 178         if (instance == null)
 179             instance = new Modules(context);
 180         return instance;
 181     }
 182 
 183     protected Modules(Context context) {
 184         context.put(Modules.class, this);
 185         log = Log.instance(context);
 186         names = Names.instance(context);
 187         syms = Symtab.instance(context);
 188         attr = Attr.instance(context);
 189         chk = Check.instance(context);
 190         deferredLintHandler = DeferredLintHandler.instance(context);
 191         typeEnvs = TypeEnvs.instance(context);
 192         moduleFinder = ModuleFinder.instance(context);
 193         types = Types.instance(context);
 194         fileManager = context.get(JavaFileManager.class);
 195         source = Source.instance(context);
 196         target = Target.instance(context);
 197         allowModules = Feature.MODULES.allowedInSource(source);
 198         Options options = Options.instance(context);
 199 
 200         allowAccessIntoSystem = options.isUnset(Option.RELEASE);
 201         lintOptions = options.isUnset(Option.XLINT_CUSTOM, &quot;-&quot; + LintCategory.OPTIONS.option);
 202 
 203         multiModuleMode = fileManager.hasLocation(StandardLocation.MODULE_SOURCE_PATH);
 204         ClassWriter classWriter = ClassWriter.instance(context);
 205         classWriter.multiModuleMode = multiModuleMode;
 206         JNIWriter jniWriter = JNIWriter.instance(context);
 207         jniWriter.multiModuleMode = multiModuleMode;
 208 
 209         java_se = names.fromString(&quot;java.se&quot;);
 210         java_ = names.fromString(&quot;java.&quot;);
 211 
 212         addExportsOpt = options.get(Option.ADD_EXPORTS);
 213         addReadsOpt = options.get(Option.ADD_READS);
 214         addModsOpt = options.get(Option.ADD_MODULES);
 215         limitModsOpt = options.get(Option.LIMIT_MODULES);
 216         moduleVersionOpt = options.get(Option.MODULE_VERSION);
 217     }
 218     //where
 219         private static final String XMODULES_PREFIX = &quot;-Xmodule:&quot;;
 220 
 221     int depth = -1;
 222 
 223     public void addExtraAddModules(String... extras) {
 224         extraAddMods.addAll(Arrays.asList(extras));
 225     }
 226 
 227     boolean inInitModules;
 228     public void initModules(List&lt;JCCompilationUnit&gt; trees) {
 229         Assert.check(!inInitModules);
 230         try {
 231             inInitModules = true;
 232             Assert.checkNull(rootModules);
 233             enter(trees, modules -&gt; {
 234                 Assert.checkNull(rootModules);
 235                 Assert.checkNull(allModules);
 236                 this.rootModules = modules;
 237                 setupAllModules(); //initialize the module graph
 238                 Assert.checkNonNull(allModules);
 239                 inInitModules = false;
 240             }, null);
 241         } finally {
 242             inInitModules = false;
 243         }
 244     }
 245 
 246     public boolean enter(List&lt;JCCompilationUnit&gt; trees, ClassSymbol c) {
 247         Assert.check(rootModules != null || inInitModules || !allowModules);
 248         return enter(trees, modules -&gt; {}, c);
 249     }
 250 
 251     private boolean enter(List&lt;JCCompilationUnit&gt; trees, Consumer&lt;Set&lt;ModuleSymbol&gt;&gt; init, ClassSymbol c) {
 252         if (!allowModules) {
 253             for (JCCompilationUnit tree: trees) {
 254                 tree.modle = syms.noModule;
 255             }
 256             defaultModule = syms.noModule;
 257             return true;
 258         }
 259 
 260         int startErrors = log.nerrors;
 261 
 262         depth++;
 263         try {
 264             // scan trees for module defs
 265             Set&lt;ModuleSymbol&gt; roots = enterModules(trees, c);
 266 
 267             setCompilationUnitModules(trees, roots, c);
 268 
 269             init.accept(roots);
 270 
 271             for (ModuleSymbol msym: roots) {
 272                 msym.complete();
 273             }
 274         } catch (CompletionFailure ex) {
 275             chk.completionError(null, ex);
 276         } finally {
 277             depth--;
 278         }
 279 
 280         return (log.nerrors == startErrors);
 281     }
 282 
 283     public Completer getCompleter() {
 284         return mainCompleter;
 285     }
 286 
 287     public ModuleSymbol getDefaultModule() {
 288         return defaultModule;
 289     }
 290 
 291     public boolean modulesInitialized() {
 292         return allModules != null;
 293     }
 294 
 295     private Set&lt;ModuleSymbol&gt; enterModules(List&lt;JCCompilationUnit&gt; trees, ClassSymbol c) {
 296         Set&lt;ModuleSymbol&gt; modules = new LinkedHashSet&lt;&gt;();
 297         for (JCCompilationUnit tree : trees) {
 298             JavaFileObject prev = log.useSource(tree.sourcefile);
 299             try {
 300                 enterModule(tree, c, modules);
 301             } finally {
 302                 log.useSource(prev);
 303             }
 304         }
 305         return modules;
 306     }
 307 
 308 
 309     private void enterModule(JCCompilationUnit toplevel, ClassSymbol c, Set&lt;ModuleSymbol&gt; modules) {
 310         boolean isModuleInfo = toplevel.sourcefile.isNameCompatible(&quot;module-info&quot;, Kind.SOURCE);
 311         boolean isModuleDecl = toplevel.getModuleDecl() != null;
 312         if (isModuleDecl) {
 313             JCModuleDecl decl = toplevel.getModuleDecl();
 314             if (!isModuleInfo) {
 315                 log.error(decl.pos(), Errors.ModuleDeclSbInModuleInfoJava);
 316             }
 317             Name name = TreeInfo.fullName(decl.qualId);
 318             ModuleSymbol sym;
 319             if (c != null) {
 320                 sym = (ModuleSymbol) c.owner;
 321                 Assert.checkNonNull(sym.name);
 322                 Name treeName = TreeInfo.fullName(decl.qualId);
 323                 if (sym.name != treeName) {
 324                     log.error(decl.pos(), Errors.ModuleNameMismatch(name, sym.name));
 325                 }
 326             } else {
 327                 sym = syms.enterModule(name);
 328                 if (sym.module_info.sourcefile != null &amp;&amp; sym.module_info.sourcefile != toplevel.sourcefile) {
 329                     log.error(decl.pos(), Errors.DuplicateModule(sym));
 330                     return;
 331                 }
 332             }
 333             sym.completer = getSourceCompleter(toplevel);
 334             sym.module_info.sourcefile = toplevel.sourcefile;
 335             decl.sym = sym;
 336 
 337             if (multiModuleMode || modules.isEmpty()) {
 338                 modules.add(sym);
 339             } else {
 340                 log.error(toplevel.pos(), Errors.TooManyModules);
 341             }
 342 
 343             Env&lt;AttrContext&gt; provisionalEnv = new Env&lt;&gt;(decl, null);
 344 
 345             provisionalEnv.toplevel = toplevel;
 346             typeEnvs.put(sym, provisionalEnv);
 347         } else if (isModuleInfo) {
 348             if (multiModuleMode) {
 349                 JCTree tree = toplevel.defs.isEmpty() ? toplevel : toplevel.defs.head;
 350                 log.error(tree.pos(), Errors.ExpectedModule);
 351             }
 352         }
 353     }
 354 
 355     private void setCompilationUnitModules(List&lt;JCCompilationUnit&gt; trees, Set&lt;ModuleSymbol&gt; rootModules, ClassSymbol c) {
 356         // update the module for each compilation unit
 357         if (multiModuleMode) {
 358             checkNoAllModulePath();
 359             for (JCCompilationUnit tree: trees) {
 360                 if (tree.defs.isEmpty()) {
 361                     tree.modle = syms.unnamedModule;
 362                     continue;
 363                 }
 364 
 365                 JavaFileObject prev = log.useSource(tree.sourcefile);
 366                 try {
 367                     Location msplocn = getModuleLocation(tree);
 368                     Location plocn = fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH) ?
 369                             fileManager.getLocationForModule(StandardLocation.PATCH_MODULE_PATH,
 370                                                              tree.sourcefile) :
 371                             null;
 372 
 373                     if (plocn != null) {
 374                         Name name = names.fromString(fileManager.inferModuleName(plocn));
 375                         ModuleSymbol msym = moduleFinder.findModule(name);
 376                         tree.modle = msym;
 377                         rootModules.add(msym);
 378 
 379                         if (msplocn != null) {
 380                             Name mspname = names.fromString(fileManager.inferModuleName(msplocn));
 381                             if (name != mspname) {
 382                                 log.error(tree.pos(), Errors.FilePatchedAndMsp(name, mspname));
 383                             }
 384                         }
 385                     } else if (msplocn != null) {
 386                         if (tree.getModuleDecl() != null) {
 387                             JavaFileObject canonical =
 388                                     fileManager.getJavaFileForInput(msplocn, &quot;module-info&quot;, Kind.SOURCE);
 389                             if (canonical == null || !fileManager.isSameFile(canonical, tree.sourcefile)) {
 390                                 log.error(tree.pos(), Errors.ModuleNotFoundOnModuleSourcePath);
 391                             }
 392                         }
 393                         Name name = names.fromString(fileManager.inferModuleName(msplocn));
 394                         ModuleSymbol msym;
 395                         JCModuleDecl decl = tree.getModuleDecl();
 396                         if (decl != null) {
 397                             msym = decl.sym;
 398                             if (msym.name != name) {
 399                                 log.error(decl.qualId, Errors.ModuleNameMismatch(msym.name, name));
 400                             }
 401                         } else {
 402                             if (tree.getPackage() == null) {
 403                                 log.error(tree.pos(), Errors.UnnamedPkgNotAllowedNamedModules);
 404                             }
 405                             msym = syms.enterModule(name);
 406                         }
 407                         if (msym.sourceLocation == null) {
 408                             msym.sourceLocation = msplocn;
 409                             if (fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH)) {
 410                                 msym.patchLocation = fileManager.getLocationForModule(
 411                                         StandardLocation.PATCH_MODULE_PATH, msym.name.toString());
 412                             }
 413                             if (fileManager.hasLocation(StandardLocation.CLASS_OUTPUT)) {
 414                                 Location outputLocn = fileManager.getLocationForModule(
 415                                         StandardLocation.CLASS_OUTPUT, msym.name.toString());
 416                                 if (msym.patchLocation == null) {
 417                                     msym.classLocation = outputLocn;
 418                                 } else {
 419                                     msym.patchOutputLocation = outputLocn;
 420                                 }
 421                             }
 422                         }
 423                         tree.modle = msym;
 424                         rootModules.add(msym);
 425                     } else if (c != null &amp;&amp; c.packge().modle == syms.unnamedModule) {
 426                         tree.modle = syms.unnamedModule;
 427                     } else {
 428                         if (tree.getModuleDecl() != null) {
 429                             log.error(tree.pos(), Errors.ModuleNotFoundOnModuleSourcePath);
 430                         } else {
 431                             log.error(tree.pos(), Errors.NotInModuleOnModuleSourcePath);
 432                         }
 433                         tree.modle = syms.errModule;
 434                     }
 435                 } catch (IOException e) {
 436                     throw new Error(e); // FIXME
 437                 } finally {
 438                     log.useSource(prev);
 439                 }
 440             }
 441             if (syms.unnamedModule.sourceLocation == null) {
 442                 syms.unnamedModule.completer = getUnnamedModuleCompleter();
 443                 syms.unnamedModule.sourceLocation = StandardLocation.SOURCE_PATH;
 444                 syms.unnamedModule.classLocation = StandardLocation.CLASS_PATH;
 445             }
 446             defaultModule = syms.unnamedModule;
 447         } else {
 448             ModuleSymbol module = null;
 449             if (defaultModule == null) {
 450                 String moduleOverride = singleModuleOverride(trees);
 451                 switch (rootModules.size()) {
 452                     case 0:
 453                         try {
 454                             defaultModule = moduleFinder.findSingleModule();
 455                         } catch (CompletionFailure cf) {
 456                             chk.completionError(null, cf);
 457                             defaultModule = syms.unnamedModule;
 458                         }
 459                         if (defaultModule == syms.unnamedModule) {
 460                             if (moduleOverride != null) {
 461                                 checkNoAllModulePath();
 462                                 defaultModule = moduleFinder.findModule(names.fromString(moduleOverride));
 463                                 defaultModule.patchOutputLocation = StandardLocation.CLASS_OUTPUT;
 464                             } else {
 465                                 // Question: why not do findAllModules and initVisiblePackages here?
 466                                 // i.e. body of unnamedModuleCompleter
 467                                 defaultModule.completer = getUnnamedModuleCompleter();
 468                                 defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 469                                 defaultModule.classLocation = StandardLocation.CLASS_PATH;
 470                             }
 471                         } else {
 472                             checkNoAllModulePath();
 473                             defaultModule.complete();
 474                             // Question: why not do completeModule here?
 475                             defaultModule.completer = sym -&gt; completeModule((ModuleSymbol) sym);
 476                             defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 477                         }
 478                         rootModules.add(defaultModule);
 479                         break;
 480                     case 1:
 481                         checkNoAllModulePath();
 482                         defaultModule = rootModules.iterator().next();
 483                         defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 484                         if (fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH)) {
 485                             try {
 486                                 defaultModule.patchLocation = fileManager.getLocationForModule(
 487                                         StandardLocation.PATCH_MODULE_PATH, defaultModule.name.toString());
 488                             } catch (IOException ex) {
 489                                 throw new Error(ex);
 490                             }
 491                         }
 492                         if (defaultModule.patchLocation == null) {
 493                             defaultModule.classLocation = StandardLocation.CLASS_OUTPUT;
 494                         } else {
 495                             defaultModule.patchOutputLocation = StandardLocation.CLASS_OUTPUT;
 496                         }
 497                         break;
 498                     default:
 499                         Assert.error(&quot;too many modules&quot;);
 500                 }
 501             } else if (rootModules.size() == 1) {
 502                 module = rootModules.iterator().next();
 503                 module.complete();
 504                 module.completer = sym -&gt; completeModule((ModuleSymbol) sym);
 505             } else {
 506                 Assert.check(rootModules.isEmpty());
 507                 Assert.checkNonNull(c);
 508                 module = c.packge().modle;
 509                 rootModules.add(module);
 510             }
 511 
 512             if (defaultModule != syms.unnamedModule) {
 513                 syms.unnamedModule.completer = getUnnamedModuleCompleter();
 514                 syms.unnamedModule.classLocation = StandardLocation.CLASS_PATH;
 515             }
 516 
 517             if (module == null) {
 518                 module = defaultModule;
 519             }
 520 
 521             for (JCCompilationUnit tree : trees) {
 522                 if (defaultModule != syms.unnamedModule
 523                         &amp;&amp; defaultModule.sourceLocation == StandardLocation.SOURCE_PATH
 524                         &amp;&amp; fileManager.hasLocation(StandardLocation.SOURCE_PATH)) {
 525                     checkSourceLocation(tree, module);
 526                 }
 527                 tree.modle = module;
 528             }
 529         }
 530     }
 531 
 532     private void checkSourceLocation(JCCompilationUnit tree, ModuleSymbol msym) {
 533         try {
 534             JavaFileObject fo = tree.sourcefile;
 535             if (fileManager.contains(msym.sourceLocation, fo)) {
 536                 return;
 537             }
 538             if (msym.patchLocation != null &amp;&amp; fileManager.contains(msym.patchLocation, fo)) {
 539                 return;
 540             }
 541             if (fileManager.hasLocation(StandardLocation.SOURCE_OUTPUT)) {
 542                 if (fileManager.contains(StandardLocation.SOURCE_OUTPUT, fo)) {
 543                     return;
 544                 }
 545             } else {
 546                 if (fileManager.contains(StandardLocation.CLASS_OUTPUT, fo)) {
 547                     return;
 548                 }
 549             }
 550         } catch (IOException e) {
 551             throw new Error(e);
 552         }
 553 
 554         JavaFileObject prev = log.useSource(tree.sourcefile);
 555         try {
 556             log.error(tree.pos(), Errors.FileSbOnSourceOrPatchPathForModule);
 557         } finally {
 558             log.useSource(prev);
 559         }
 560     }
 561 
 562     private String singleModuleOverride(List&lt;JCCompilationUnit&gt; trees) {
 563         if (!fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH)) {
 564             return null;
 565         }
 566 
 567         Set&lt;String&gt; override = new LinkedHashSet&lt;&gt;();
 568         for (JCCompilationUnit tree : trees) {
 569             JavaFileObject fo = tree.sourcefile;
 570 
 571             try {
 572                 Location loc =
 573                         fileManager.getLocationForModule(StandardLocation.PATCH_MODULE_PATH, fo);
 574 
 575                 if (loc != null) {
 576                     override.add(fileManager.inferModuleName(loc));
 577                 }
 578             } catch (IOException ex) {
 579                 throw new Error(ex);
 580             }
 581         }
 582 
 583         switch (override.size()) {
 584             case 0: return null;
 585             case 1: return override.iterator().next();
 586             default:
 587                 log.error(Errors.TooManyPatchedModules(override));
 588                 return null;
 589         }
 590     }
 591 
 592     /**
 593      * Determine the location for the module on the module source path
 594      * or source output directory which contains a given CompilationUnit.
 595      * If the source output directory is unset, the class output directory
 596      * will be checked instead.
 597      * {@code null} is returned if no such module can be found.
 598      * @param tree the compilation unit tree
 599      * @return the location for the enclosing module
 600      * @throws IOException if there is a problem while searching for the module.
 601      */
 602     private Location getModuleLocation(JCCompilationUnit tree) throws IOException {
 603         JavaFileObject fo = tree.sourcefile;
 604 
 605         Location loc =
 606                 fileManager.getLocationForModule(StandardLocation.MODULE_SOURCE_PATH, fo);
 607         if (loc == null) {
 608             Location sourceOutput = fileManager.hasLocation(StandardLocation.SOURCE_OUTPUT) ?
 609                     StandardLocation.SOURCE_OUTPUT : StandardLocation.CLASS_OUTPUT;
 610             loc =
 611                 fileManager.getLocationForModule(sourceOutput, fo);
 612         }
 613         return loc;
 614     }
 615 
 616     private void checkNoAllModulePath() {
 617         if (addModsOpt != null &amp;&amp; Arrays.asList(addModsOpt.split(&quot;,&quot;)).contains(ALL_MODULE_PATH)) {
 618             log.error(Errors.AddmodsAllModulePathInvalid);
 619         }
 620     }
 621 
 622     private final Completer mainCompleter = new Completer() {
 623         @Override
 624         public void complete(Symbol sym) throws CompletionFailure {
 625             ModuleSymbol msym = moduleFinder.findModule((ModuleSymbol) sym);
 626 
 627             if (msym.kind == ERR) {
 628                 //make sure the module is initialized:
 629                 msym.directives = List.nil();
 630                 msym.exports = List.nil();
 631                 msym.provides = List.nil();
 632                 msym.requires = List.nil();
 633                 msym.uses = List.nil();
 634             } else if ((msym.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0) {
 635                 setupAutomaticModule(msym);
 636             } else {
 637                 msym.module_info.complete();
 638             }
 639 
 640             // If module-info comes from a .java file, the underlying
 641             // call of classFinder.fillIn will have called through the
 642             // source completer, to Enter, and then to Modules.enter,
 643             // which will call completeModule.
 644             // But, if module-info comes from a .class file, the underlying
 645             // call of classFinder.fillIn will just call ClassReader to read
 646             // the .class file, and so we call completeModule here.
 647             if (msym.module_info.classfile == null || msym.module_info.classfile.getKind() == Kind.CLASS) {
 648                 completeModule(msym);
 649             }
 650         }
 651 
 652         @Override
 653         public String toString() {
 654             return &quot;mainCompleter&quot;;
 655         }
 656     };
 657 
 658     private void setupAutomaticModule(ModuleSymbol msym) throws CompletionFailure {
 659         try {
 660             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
 661             ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
 662             Set&lt;String&gt; seenPackages = new HashSet&lt;&gt;();
 663 
 664             for (JavaFileObject clazz : fileManager.list(msym.classLocation, &quot;&quot;, EnumSet.of(Kind.CLASS), true)) {
 665                 String binName = fileManager.inferBinaryName(msym.classLocation, clazz);
 666                 String pack = binName.lastIndexOf(&#39;.&#39;) != (-1) ? binName.substring(0, binName.lastIndexOf(&#39;.&#39;)) : &quot;&quot;; //unnamed package????
 667                 if (seenPackages.add(pack)) {
 668                     ExportsDirective d = new ExportsDirective(syms.enterPackage(msym, names.fromString(pack)), null);
 669                     //TODO: opens?
 670                     directives.add(d);
 671                     exports.add(d);
 672                 }
 673             }
 674 
 675             msym.exports = exports.toList();
 676             msym.provides = List.nil();
 677             msym.requires = List.nil();
 678             msym.uses = List.nil();
 679             msym.directives = directives.toList();
 680         } catch (IOException ex) {
 681             throw new IllegalStateException(ex);
 682         }
 683     }
 684 
 685     private void completeAutomaticModule(ModuleSymbol msym) throws CompletionFailure {
 686         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
 687 
 688         directives.addAll(msym.directives);
 689 
 690         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
 691 
 692         for (ModuleSymbol ms : allModules()) {
 693             if (ms == syms.unnamedModule || ms == msym)
 694                 continue;
 695             Set&lt;RequiresFlag&gt; flags = (ms.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0 ?
 696                     EnumSet.of(RequiresFlag.TRANSITIVE) : EnumSet.noneOf(RequiresFlag.class);
 697             RequiresDirective d = new RequiresDirective(ms, flags);
 698             directives.add(d);
 699             requires.add(d);
 700         }
 701 
 702         RequiresDirective requiresUnnamed = new RequiresDirective(syms.unnamedModule);
 703         directives.add(requiresUnnamed);
 704         requires.add(requiresUnnamed);
 705 
 706         msym.requires = requires.toList();
 707         msym.directives = directives.toList();
 708     }
 709 
 710     private Completer getSourceCompleter(JCCompilationUnit tree) {
 711         return new Completer() {
 712             @Override
 713             public void complete(Symbol sym) throws CompletionFailure {
 714                 ModuleSymbol msym = (ModuleSymbol) sym;
 715                 msym.flags_field |= UNATTRIBUTED;
 716                 ModuleVisitor v = new ModuleVisitor();
 717                 JavaFileObject prev = log.useSource(tree.sourcefile);
 718                 JCModuleDecl moduleDecl = tree.getModuleDecl();
 719                 DiagnosticPosition prevLintPos = deferredLintHandler.setPos(moduleDecl.pos());
 720 
 721                 try {
 722                     moduleDecl.accept(v);
 723                     completeModule(msym);
 724                     checkCyclicDependencies(moduleDecl);
 725                 } finally {
 726                     log.useSource(prev);
 727                     deferredLintHandler.setPos(prevLintPos);
 728                     msym.flags_field &amp;= ~UNATTRIBUTED;
 729                 }
 730             }
 731 
 732             @Override
 733             public String toString() {
 734                 return &quot;SourceCompleter: &quot; + tree.sourcefile.getName();
 735             }
 736 
 737         };
 738     }
 739 
 740     public boolean isRootModule(ModuleSymbol module) {
 741         Assert.checkNonNull(rootModules);
 742         return rootModules.contains(module);
 743     }
 744 
 745     public Set&lt;ModuleSymbol&gt; getRootModules() {
 746         Assert.checkNonNull(rootModules);
 747         return rootModules;
 748     }
 749 
 750     class ModuleVisitor extends JCTree.Visitor {
 751         private ModuleSymbol sym;
 752         private final Set&lt;ModuleSymbol&gt; allRequires = new HashSet&lt;&gt;();
 753         private final Map&lt;PackageSymbol,List&lt;ExportsDirective&gt;&gt; allExports = new HashMap&lt;&gt;();
 754         private final Map&lt;PackageSymbol,List&lt;OpensDirective&gt;&gt; allOpens = new HashMap&lt;&gt;();
 755 
 756         @Override
 757         public void visitModuleDef(JCModuleDecl tree) {
 758             sym = Assert.checkNonNull(tree.sym);
 759 
 760             if (tree.getModuleType() == ModuleKind.OPEN) {
 761                 sym.flags.add(ModuleFlags.OPEN);
 762             }
 763             sym.flags_field |= (tree.mods.flags &amp; Flags.DEPRECATED);
 764 
 765             sym.requires = List.nil();
 766             sym.exports = List.nil();
 767             sym.opens = List.nil();
 768             tree.directives.forEach(t -&gt; t.accept(this));
 769             sym.requires = sym.requires.reverse();
 770             sym.exports = sym.exports.reverse();
 771             sym.opens = sym.opens.reverse();
 772             ensureJavaBase();
 773         }
 774 
 775         @Override
 776         public void visitRequires(JCRequires tree) {
 777             ModuleSymbol msym = lookupModule(tree.moduleName);
 778             if (msym.kind != MDL) {
 779                 log.error(tree.moduleName.pos(), Errors.ModuleNotFound(msym));
 780                 warnedMissing.add(msym);
 781             } else if (allRequires.contains(msym)) {
 782                 log.error(tree.moduleName.pos(), Errors.DuplicateRequires(msym));
 783             } else {
 784                 allRequires.add(msym);
 785                 Set&lt;RequiresFlag&gt; flags = EnumSet.noneOf(RequiresFlag.class);
 786                 if (tree.isTransitive) {
 787                     if (msym == syms.java_base &amp;&amp; source.compareTo(Source.JDK10) &gt;= 0) {
 788                         log.error(tree.pos(), Errors.ModifierNotAllowedHere(names.transitive));
 789                     } else {
 790                         flags.add(RequiresFlag.TRANSITIVE);
 791                     }
 792                 }
 793                 if (tree.isStaticPhase) {
 794                     if (msym == syms.java_base &amp;&amp; source.compareTo(Source.JDK10) &gt;= 0) {
 795                         log.error(tree.pos(), Errors.ModNotAllowedHere(EnumSet.of(Flag.STATIC)));
 796                     } else {
 797                         flags.add(RequiresFlag.STATIC_PHASE);
 798                     }
 799                 }
 800                 RequiresDirective d = new RequiresDirective(msym, flags);
 801                 tree.directive = d;
 802                 sym.requires = sym.requires.prepend(d);
 803             }
 804         }
 805 
 806         @Override
 807         public void visitExports(JCExports tree) {
 808             Name name = TreeInfo.fullName(tree.qualid);
 809             PackageSymbol packge = syms.enterPackage(sym, name);
 810             attr.setPackageSymbols(tree.qualid, packge);
 811 
 812             List&lt;ExportsDirective&gt; exportsForPackage = allExports.computeIfAbsent(packge, p -&gt; List.nil());
 813             for (ExportsDirective d : exportsForPackage) {
 814                 reportExportsConflict(tree, packge);
 815             }
 816 
 817             List&lt;ModuleSymbol&gt; toModules = null;
 818             if (tree.moduleNames != null) {
 819                 Set&lt;ModuleSymbol&gt; to = new LinkedHashSet&lt;&gt;();
 820                 for (JCExpression n: tree.moduleNames) {
 821                     ModuleSymbol msym = lookupModule(n);
 822                     chk.checkModuleExists(n.pos(), msym);
 823                     for (ExportsDirective d : exportsForPackage) {
 824                         checkDuplicateExportsToModule(n, msym, d);
 825                     }
 826                     if (!to.add(msym)) {
 827                         reportExportsConflictToModule(n, msym);
 828                     }
 829                 }
 830                 toModules = List.from(to);
 831             }
 832 
 833             if (toModules == null || !toModules.isEmpty()) {
 834                 Set&lt;ExportsFlag&gt; flags = EnumSet.noneOf(ExportsFlag.class);
 835                 ExportsDirective d = new ExportsDirective(packge, toModules, flags);
 836                 sym.exports = sym.exports.prepend(d);
 837                 tree.directive = d;
 838 
 839                 allExports.put(packge, exportsForPackage.prepend(d));
 840             }
 841         }
 842 
 843         private void reportExportsConflict(JCExports tree, PackageSymbol packge) {
 844             log.error(tree.qualid.pos(), Errors.ConflictingExports(packge));
 845         }
 846 
 847         private void checkDuplicateExportsToModule(JCExpression name, ModuleSymbol msym,
 848                 ExportsDirective d) {
 849             if (d.modules != null) {
 850                 for (ModuleSymbol other : d.modules) {
 851                     if (msym == other) {
 852                         reportExportsConflictToModule(name, msym);
 853                     }
 854                 }
 855             }
 856         }
 857 
 858         private void reportExportsConflictToModule(JCExpression name, ModuleSymbol msym) {
 859             log.error(name.pos(), Errors.ConflictingExportsToModule(msym));
 860         }
 861 
 862         @Override
 863         public void visitOpens(JCOpens tree) {
 864             Name name = TreeInfo.fullName(tree.qualid);
 865             PackageSymbol packge = syms.enterPackage(sym, name);
 866             attr.setPackageSymbols(tree.qualid, packge);
 867 
 868             if (sym.flags.contains(ModuleFlags.OPEN)) {
 869                 log.error(tree.pos(), Errors.NoOpensUnlessStrong);
 870             }
 871             List&lt;OpensDirective&gt; opensForPackage = allOpens.computeIfAbsent(packge, p -&gt; List.nil());
 872             for (OpensDirective d : opensForPackage) {
 873                 reportOpensConflict(tree, packge);
 874             }
 875 
 876             List&lt;ModuleSymbol&gt; toModules = null;
 877             if (tree.moduleNames != null) {
 878                 Set&lt;ModuleSymbol&gt; to = new LinkedHashSet&lt;&gt;();
 879                 for (JCExpression n: tree.moduleNames) {
 880                     ModuleSymbol msym = lookupModule(n);
 881                     chk.checkModuleExists(n.pos(), msym);
 882                     for (OpensDirective d : opensForPackage) {
 883                         checkDuplicateOpensToModule(n, msym, d);
 884                     }
 885                     if (!to.add(msym)) {
 886                         reportOpensConflictToModule(n, msym);
 887                     }
 888                 }
 889                 toModules = List.from(to);
 890             }
 891 
 892             if (toModules == null || !toModules.isEmpty()) {
 893                 Set&lt;OpensFlag&gt; flags = EnumSet.noneOf(OpensFlag.class);
 894                 OpensDirective d = new OpensDirective(packge, toModules, flags);
 895                 sym.opens = sym.opens.prepend(d);
 896                 tree.directive = d;
 897 
 898                 allOpens.put(packge, opensForPackage.prepend(d));
 899             }
 900         }
 901 
 902         private void reportOpensConflict(JCOpens tree, PackageSymbol packge) {
 903             log.error(tree.qualid.pos(), Errors.ConflictingOpens(packge));
 904         }
 905 
 906         private void checkDuplicateOpensToModule(JCExpression name, ModuleSymbol msym,
 907                 OpensDirective d) {
 908             if (d.modules != null) {
 909                 for (ModuleSymbol other : d.modules) {
 910                     if (msym == other) {
 911                         reportOpensConflictToModule(name, msym);
 912                     }
 913                 }
 914             }
 915         }
 916 
 917         private void reportOpensConflictToModule(JCExpression name, ModuleSymbol msym) {
 918             log.error(name.pos(), Errors.ConflictingOpensToModule(msym));
 919         }
 920 
 921         @Override
 922         public void visitProvides(JCProvides tree) { }
 923 
 924         @Override
 925         public void visitUses(JCUses tree) { }
 926 
 927         private void ensureJavaBase() {
 928             if (sym.name == names.java_base)
 929                 return;
 930 
 931             for (RequiresDirective d: sym.requires) {
 932                 if (d.module.name == names.java_base)
 933                     return;
 934             }
 935 
 936             ModuleSymbol java_base = syms.enterModule(names.java_base);
 937             Directive.RequiresDirective d =
 938                     new Directive.RequiresDirective(java_base,
 939                             EnumSet.of(Directive.RequiresFlag.MANDATED));
 940             sym.requires = sym.requires.prepend(d);
 941         }
 942 
 943         private ModuleSymbol lookupModule(JCExpression moduleName) {
 944             Name name = TreeInfo.fullName(moduleName);
 945             ModuleSymbol msym = moduleFinder.findModule(name);
 946             TreeInfo.setSymbol(moduleName, msym);
 947             return msym;
 948         }
 949     }
 950 
 951     public Completer getUsesProvidesCompleter() {
 952         return sym -&gt; {
 953             ModuleSymbol msym = (ModuleSymbol) sym;
 954 
 955             msym.complete();
 956 
 957             Env&lt;AttrContext&gt; env = typeEnvs.get(msym);
 958             UsesProvidesVisitor v = new UsesProvidesVisitor(msym, env);
 959             JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 960             JCModuleDecl decl = env.toplevel.getModuleDecl();
 961             DiagnosticPosition prevLintPos = deferredLintHandler.setPos(decl.pos());
 962 
 963             try {
 964                 decl.accept(v);
 965             } finally {
 966                 log.useSource(prev);
 967                 deferredLintHandler.setPos(prevLintPos);
 968             }
 969         };
 970     }
 971 
 972     class UsesProvidesVisitor extends JCTree.Visitor {
 973         private final ModuleSymbol msym;
 974         private final Env&lt;AttrContext&gt; env;
 975 
 976         private final Set&lt;ClassSymbol&gt; allUses = new HashSet&lt;&gt;();
 977         private final Map&lt;ClassSymbol, Set&lt;ClassSymbol&gt;&gt; allProvides = new HashMap&lt;&gt;();
 978 
 979         public UsesProvidesVisitor(ModuleSymbol msym, Env&lt;AttrContext&gt; env) {
 980             this.msym = msym;
 981             this.env = env;
 982         }
 983 
 984         @Override @SuppressWarnings(&quot;unchecked&quot;)
 985         public void visitModuleDef(JCModuleDecl tree) {
 986             msym.directives = List.nil();
 987             msym.provides = List.nil();
 988             msym.uses = List.nil();
 989             tree.directives.forEach(t -&gt; t.accept(this));
 990             msym.directives = msym.directives.reverse();
 991             msym.provides = msym.provides.reverse();
 992             msym.uses = msym.uses.reverse();
 993 
 994             if (msym.requires.nonEmpty() &amp;&amp; msym.requires.head.flags.contains(RequiresFlag.MANDATED))
 995                 msym.directives = msym.directives.prepend(msym.requires.head);
 996 
 997             msym.directives = msym.directives.appendList(List.from(addReads.getOrDefault(msym, Collections.emptySet())));
 998 
 999             checkForCorrectness();
1000         }
1001 
1002         @Override
1003         public void visitExports(JCExports tree) {
1004             Iterable&lt;Symbol&gt; packageContent = tree.directive.packge.members().getSymbols();
1005             List&lt;JavaFileObject&gt; filesToCheck = List.nil();
1006             boolean packageNotEmpty = false;
1007             for (Symbol sym : packageContent) {
1008                 if (sym.kind != Kinds.Kind.TYP)
1009                     continue;
1010                 ClassSymbol csym = (ClassSymbol) sym;
1011                 if (sym.completer.isTerminal() ||
1012                     csym.classfile.getKind() == Kind.CLASS) {
1013                     packageNotEmpty = true;
1014                     filesToCheck = List.nil();
1015                     break;
1016                 }
1017                 if (csym.classfile.getKind() == Kind.SOURCE) {
1018                     filesToCheck = filesToCheck.prepend(csym.classfile);
1019                 }
1020             }
1021             for (JavaFileObject jfo : filesToCheck) {
1022                 if (findPackageInFile.findPackageNameOf(jfo) == tree.directive.packge.fullname) {
1023                     packageNotEmpty = true;
1024                     break;
1025                 }
1026             }
1027             if (!packageNotEmpty) {
1028                 log.error(tree.qualid.pos(), Errors.PackageEmptyOrNotFound(tree.directive.packge));
1029             }
1030             msym.directives = msym.directives.prepend(tree.directive);
1031         }
1032 
1033         @Override
1034         public void visitOpens(JCOpens tree) {
1035             chk.checkPackageExistsForOpens(tree.qualid, tree.directive.packge);
1036             msym.directives = msym.directives.prepend(tree.directive);
1037         }
1038 
1039         MethodSymbol noArgsConstructor(ClassSymbol tsym) {
1040             for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {
1041                 MethodSymbol mSym = (MethodSymbol)sym;
1042                 if (mSym.params().isEmpty()) {
1043                     return mSym;
1044                 }
1045             }
1046             return null;
1047         }
1048 
1049         MethodSymbol factoryMethod(ClassSymbol tsym) {
1050             for (Symbol sym : tsym.members().getSymbolsByName(names.provider, sym -&gt; sym.kind == MTH)) {
1051                 MethodSymbol mSym = (MethodSymbol)sym;
1052                 if (mSym.isStatic() &amp;&amp; (mSym.flags() &amp; Flags.PUBLIC) != 0 &amp;&amp; mSym.params().isEmpty()) {
1053                     return mSym;
1054                 }
1055             }
1056             return null;
1057         }
1058 
1059         Map&lt;Directive.ProvidesDirective, JCProvides&gt; directiveToTreeMap = new HashMap&lt;&gt;();
1060 
1061         @Override
1062         public void visitProvides(JCProvides tree) {
1063             Type st = attr.attribType(tree.serviceName, env, syms.objectType);
1064             ClassSymbol service = (ClassSymbol) st.tsym;
1065             if (allProvides.containsKey(service)) {
1066                 log.error(tree.serviceName.pos(), Errors.RepeatedProvidesForService(service));
1067             }
1068             ListBuffer&lt;ClassSymbol&gt; impls = new ListBuffer&lt;&gt;();
1069             for (JCExpression implName : tree.implNames) {
1070                 Type it;
1071                 boolean prevVisitingServiceImplementation = env.info.visitingServiceImplementation;
1072                 try {
1073                     env.info.visitingServiceImplementation = true;
1074                     it = attr.attribType(implName, env, syms.objectType);
1075                 } finally {
1076                     env.info.visitingServiceImplementation = prevVisitingServiceImplementation;
1077                 }
1078                 ClassSymbol impl = (ClassSymbol) it.tsym;
1079                 if ((impl.flags_field &amp; PUBLIC) == 0) {
1080                     log.error(implName.pos(), Errors.NotDefPublic(impl, impl.location()));
1081                 }
1082                 //find provider factory:
1083                 MethodSymbol factory = factoryMethod(impl);
1084                 if (factory != null) {
1085                     Type returnType = factory.type.getReturnType();
1086                     if (!types.isSubtype(returnType, st)) {
1087                         log.error(implName.pos(), Errors.ServiceImplementationProviderReturnMustBeSubtypeOfServiceInterface);
1088                     }
1089                 } else {
1090                     if (!types.isSubtype(it, st)) {
1091                         log.error(implName.pos(), Errors.ServiceImplementationMustBeSubtypeOfServiceInterface);
1092                     } else if ((impl.flags() &amp; ABSTRACT) != 0) {
1093                         log.error(implName.pos(), Errors.ServiceImplementationIsAbstract(impl));
1094                     } else if (impl.isInner()) {
1095                         log.error(implName.pos(), Errors.ServiceImplementationIsInner(impl));
1096                     } else {
1097                         MethodSymbol constr = noArgsConstructor(impl);
1098                         if (constr == null) {
1099                             log.error(implName.pos(), Errors.ServiceImplementationDoesntHaveANoArgsConstructor(impl));
1100                         } else if ((constr.flags() &amp; PUBLIC) == 0) {
1101                             log.error(implName.pos(), Errors.ServiceImplementationNoArgsConstructorNotPublic(impl));
1102                         }
1103                     }
1104                 }
1105                 if (it.hasTag(CLASS)) {
1106                     if (allProvides.computeIfAbsent(service, s -&gt; new HashSet&lt;&gt;()).add(impl)) {
1107                         impls.append(impl);
1108                     } else {
1109                         log.error(implName.pos(), Errors.DuplicateProvides(service, impl));
1110                     }
1111                 }
1112             }
1113             if (st.hasTag(CLASS) &amp;&amp; !impls.isEmpty()) {
1114                 Directive.ProvidesDirective d = new Directive.ProvidesDirective(service, impls.toList());
1115                 msym.provides = msym.provides.prepend(d);
1116                 msym.directives = msym.directives.prepend(d);
1117                 directiveToTreeMap.put(d, tree);
1118             }
1119         }
1120 
1121         @Override
1122         public void visitRequires(JCRequires tree) {
1123             if (tree.directive != null &amp;&amp; allModules().contains(tree.directive.module)) {
1124                 chk.checkDeprecated(tree.moduleName.pos(), msym, tree.directive.module);
1125                 chk.checkModuleRequires(tree.moduleName.pos(), tree.directive);
1126                 msym.directives = msym.directives.prepend(tree.directive);
1127             }
1128         }
1129 
1130         @Override
1131         public void visitUses(JCUses tree) {
1132             Type st = attr.attribType(tree.qualid, env, syms.objectType);
1133             Symbol sym = TreeInfo.symbol(tree.qualid);
1134             if ((sym.flags() &amp; ENUM) != 0) {
1135                 log.error(tree.qualid.pos(), Errors.ServiceDefinitionIsEnum(st.tsym));
1136             } else if (st.hasTag(CLASS)) {
1137                 ClassSymbol service = (ClassSymbol) st.tsym;
1138                 if (allUses.add(service)) {
1139                     Directive.UsesDirective d = new Directive.UsesDirective(service);
1140                     msym.uses = msym.uses.prepend(d);
1141                     msym.directives = msym.directives.prepend(d);
1142                 } else {
1143                     log.error(tree.pos(), Errors.DuplicateUses(service));
1144                 }
1145             }
1146         }
1147 
1148         private void checkForCorrectness() {
1149             for (Directive.ProvidesDirective provides : msym.provides) {
1150                 JCProvides tree = directiveToTreeMap.get(provides);
1151                 for (ClassSymbol impl : provides.impls) {
1152                     /* The implementation must be defined in the same module as the provides directive
1153                      * (else, error)
1154                      */
1155                     PackageSymbol implementationDefiningPackage = impl.packge();
1156                     if (implementationDefiningPackage.modle != msym) {
1157                         // TODO: should use tree for the implentation name, not the entire provides tree
1158                         // TODO: should improve error message to identify the implementation type
1159                         log.error(tree.pos(), Errors.ServiceImplementationNotInRightModule(implementationDefiningPackage.modle));
1160                     }
1161 
1162                     /* There is no inherent requirement that module that provides a service should actually
1163                      * use it itself. However, it is a pointless declaration if the service package is not
1164                      * exported and there is no uses for the service.
1165                      */
1166                     PackageSymbol interfaceDeclaringPackage = provides.service.packge();
1167                     boolean isInterfaceDeclaredInCurrentModule = interfaceDeclaringPackage.modle == msym;
1168                     boolean isInterfaceExportedFromAReadableModule =
1169                             msym.visiblePackages.get(interfaceDeclaringPackage.fullname) == interfaceDeclaringPackage;
1170                     if (isInterfaceDeclaredInCurrentModule &amp;&amp; !isInterfaceExportedFromAReadableModule) {
1171                         // ok the interface is declared in this module. Let&#39;s check if it&#39;s exported
1172                         boolean warn = true;
1173                         for (ExportsDirective export : msym.exports) {
1174                             if (interfaceDeclaringPackage == export.packge) {
1175                                 warn = false;
1176                                 break;
1177                             }
1178                         }
1179                         if (warn) {
1180                             for (UsesDirective uses : msym.uses) {
1181                                 if (provides.service == uses.service) {
1182                                     warn = false;
1183                                     break;
1184                                 }
1185                             }
1186                         }
1187                         if (warn) {
1188                             log.warning(tree.pos(), Warnings.ServiceProvidedButNotExportedOrUsed(provides.service));
1189                         }
1190                     }
1191                 }
1192             }
1193         }
1194     }
1195 
1196     private Set&lt;ModuleSymbol&gt; allModules;
1197 
1198     public Set&lt;ModuleSymbol&gt; allModules() {
1199         Assert.checkNonNull(allModules);
1200         return allModules;
1201     }
1202 
1203     private void setupAllModules() {
1204         Assert.checkNonNull(rootModules);
1205         Assert.checkNull(allModules);
1206 
1207         Set&lt;ModuleSymbol&gt; observable;
1208 
1209         if (limitModsOpt == null &amp;&amp; extraLimitMods.isEmpty()) {
1210             observable = null;
1211         } else {
1212             Set&lt;ModuleSymbol&gt; limitMods = new HashSet&lt;&gt;();
1213             if (limitModsOpt != null) {
1214                 for (String limit : limitModsOpt.split(&quot;,&quot;)) {
1215                     if (!isValidName(limit))
1216                         continue;
1217                     limitMods.add(syms.enterModule(names.fromString(limit)));
1218                 }
1219             }
1220             for (String limit : extraLimitMods) {
1221                 limitMods.add(syms.enterModule(names.fromString(limit)));
1222             }
1223             observable = computeTransitiveClosure(limitMods, rootModules, null);
1224             observable.addAll(rootModules);
1225             if (lintOptions) {
1226                 for (ModuleSymbol msym : limitMods) {
1227                     if (!observable.contains(msym)) {
1228                         log.warning(LintCategory.OPTIONS,
1229                                 Warnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));
1230                     }
1231                 }
1232             }
1233         }
1234 
1235         Predicate&lt;ModuleSymbol&gt; observablePred = sym -&gt;
1236              (observable == null) ? (moduleFinder.findModule(sym).kind != ERR) : observable.contains(sym);
1237         Predicate&lt;ModuleSymbol&gt; systemModulePred = sym -&gt; (sym.flags() &amp; Flags.SYSTEM_MODULE) != 0;
1238         Set&lt;ModuleSymbol&gt; enabledRoot = new LinkedHashSet&lt;&gt;();
1239 
1240         if (rootModules.contains(syms.unnamedModule)) {
1241             Predicate&lt;ModuleSymbol&gt; jdkModulePred;
1242             if (target.allApiModulesAreRoots()) {
1243                 jdkModulePred = sym -&gt; {
1244                     sym.complete();
1245                     return sym.exports.stream().anyMatch(e -&gt; e.modules == null);
1246                 };
1247             } else {
1248                 ModuleSymbol javaSE = syms.getModule(java_se);
1249                 if (javaSE != null &amp;&amp; (observable == null || observable.contains(javaSE))) {
1250                     jdkModulePred = sym -&gt; {
1251                         sym.complete();
1252                         return !sym.name.startsWith(java_)
1253                             &amp;&amp; sym.exports.stream().anyMatch(e -&gt; e.modules == null);
1254                     };
1255                     enabledRoot.add(javaSE);
1256                 } else {
1257                     jdkModulePred = sym -&gt; true;
1258                 }
1259             }
1260 
1261             Predicate&lt;ModuleSymbol&gt; noIncubatorPred = sym -&gt; {
1262                 sym.complete();
1263                 return !sym.resolutionFlags.contains(ModuleResolutionFlags.DO_NOT_RESOLVE_BY_DEFAULT);
1264             };
1265 
1266             for (ModuleSymbol sym : new HashSet&lt;&gt;(syms.getAllModules())) {
1267                 try {
1268                     if (systemModulePred.test(sym) &amp;&amp; observablePred.test(sym) &amp;&amp; jdkModulePred.test(sym) &amp;&amp; noIncubatorPred.test(sym)) {
1269                         enabledRoot.add(sym);
1270                     }
1271                 } catch (CompletionFailure ex) {
1272                     chk.completionError(null, ex);
1273                 }
1274             }
1275         }
1276 
1277         enabledRoot.addAll(rootModules);
1278 
1279         if (addModsOpt != null || !extraAddMods.isEmpty()) {
1280             Set&lt;String&gt; fullAddMods = new HashSet&lt;&gt;();
1281             fullAddMods.addAll(extraAddMods);
1282 
1283             if (addModsOpt != null) {
1284                 fullAddMods.addAll(Arrays.asList(addModsOpt.split(&quot;,&quot;)));
1285             }
1286 
1287             for (String added : fullAddMods) {
1288                 Stream&lt;ModuleSymbol&gt; modules;
1289                 switch (added) {
1290                     case ALL_SYSTEM:
1291                         modules = new HashSet&lt;&gt;(syms.getAllModules())
1292                                 .stream()
1293                                 .filter(systemModulePred.and(observablePred));
1294                         break;
1295                     case ALL_MODULE_PATH:
1296                         modules = new HashSet&lt;&gt;(syms.getAllModules())
1297                                 .stream()
1298                                 .filter(systemModulePred.negate().and(observablePred));
1299                         break;
1300                     default:
1301                         if (!isValidName(added))
1302                             continue;
1303                         modules = Stream.of(syms.enterModule(names.fromString(added)));
1304                         break;
1305                 }
1306                 modules.forEach(sym -&gt; {
1307                     enabledRoot.add(sym);
1308                     if (observable != null)
1309                         observable.add(sym);
1310                 });
1311             }
1312         }
1313 
1314         Set&lt;ModuleSymbol&gt; result = computeTransitiveClosure(enabledRoot, rootModules, observable);
1315 
1316         result.add(syms.unnamedModule);
1317 
1318         boolean hasAutomatic = result.stream().anyMatch(IS_AUTOMATIC);
1319 
1320         if (hasAutomatic) {
1321             syms.getAllModules()
1322                 .stream()
1323                 .filter(IS_AUTOMATIC)
1324                 .forEach(result::add);
1325         }
1326 
1327         String incubatingModules = result.stream()
1328                 .filter(msym -&gt; msym.resolutionFlags.contains(ModuleResolutionFlags.WARN_INCUBATING))
1329                 .map(msym -&gt; msym.name.toString())
1330                 .collect(Collectors.joining(&quot;,&quot;));
1331 
1332         if (!incubatingModules.isEmpty()) {
1333             log.warning(Warnings.IncubatingModules(incubatingModules));
1334         }
1335 
1336         allModules = result;
1337 
1338         //add module versions from options, if any:
1339         if (moduleVersionOpt != null) {
1340             Name version = names.fromString(moduleVersionOpt);
1341             rootModules.forEach(m -&gt; m.version = version);
1342         }
1343     }
1344     //where:
1345         private static final Predicate&lt;ModuleSymbol&gt; IS_AUTOMATIC =
1346                 m -&gt; (m.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0;
1347 
1348     public boolean isInModuleGraph(ModuleSymbol msym) {
1349         return allModules == null || allModules.contains(msym);
1350     }
1351 
1352     private Set&lt;ModuleSymbol&gt; computeTransitiveClosure(Set&lt;? extends ModuleSymbol&gt; base,
1353                                                        Set&lt;? extends ModuleSymbol&gt; rootModules,
1354                                                        Set&lt;ModuleSymbol&gt; observable) {
1355         List&lt;ModuleSymbol&gt; primaryTodo = List.nil();
1356         List&lt;ModuleSymbol&gt; secondaryTodo = List.nil();
1357 
1358         for (ModuleSymbol ms : base) {
1359             if (rootModules.contains(ms)) {
1360                 primaryTodo = primaryTodo.prepend(ms);
1361             } else {
1362                 secondaryTodo = secondaryTodo.prepend(ms);
1363             }
1364         }
1365 
1366         Set&lt;ModuleSymbol&gt; result = new LinkedHashSet&lt;&gt;();
1367         result.add(syms.java_base);
1368 
1369         while (primaryTodo.nonEmpty() || secondaryTodo.nonEmpty()) {
1370             try {
1371                 ModuleSymbol current;
1372                 boolean isPrimaryTodo;
1373                 if (primaryTodo.nonEmpty()) {
1374                     current = primaryTodo.head;
1375                     primaryTodo = primaryTodo.tail;
1376                     isPrimaryTodo = true;
1377                 } else {
1378                     current = secondaryTodo.head;
1379                     secondaryTodo = secondaryTodo.tail;
1380                     isPrimaryTodo = false;
1381                 }
1382                 if (observable != null &amp;&amp; !observable.contains(current))
1383                     continue;
1384                 if (!result.add(current) || current == syms.unnamedModule || ((current.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0))
1385                     continue;
1386                 current.complete();
1387                 if (current.kind == ERR &amp;&amp; (isPrimaryTodo || base.contains(current)) &amp;&amp; warnedMissing.add(current)) {
1388                     log.error(Errors.ModuleNotFound(current));
1389                 }
1390                 for (RequiresDirective rd : current.requires) {
1391                     if (rd.module == syms.java_base) continue;
1392                     if ((rd.isTransitive() &amp;&amp; isPrimaryTodo) || rootModules.contains(current)) {
1393                         primaryTodo = primaryTodo.prepend(rd.module);
1394                     } else {
1395                         secondaryTodo = secondaryTodo.prepend(rd.module);
1396                     }
1397                 }
1398             } catch (CompletionFailure ex) {
1399                 chk.completionError(null, ex);
1400             }
1401         }
1402 
1403         return result;
1404     }
1405 
1406     public ModuleSymbol getObservableModule(Name name) {
1407         ModuleSymbol mod = syms.getModule(name);
1408 
1409         if (allModules().contains(mod)) {
1410             return mod;
1411         }
1412 
1413         return null;
1414     }
1415 
1416     private Completer getUnnamedModuleCompleter() {
1417         moduleFinder.findAllModules();
1418         return new Symbol.Completer() {
1419             @Override
1420             public void complete(Symbol sym) throws CompletionFailure {
1421                 if (inInitModules) {
1422                     sym.completer = this;
1423                     return ;
1424                 }
1425                 ModuleSymbol msym = (ModuleSymbol) sym;
1426                 Set&lt;ModuleSymbol&gt; allModules = new HashSet&lt;&gt;(allModules());
1427                 allModules.remove(syms.unnamedModule);
1428                 for (ModuleSymbol m : allModules) {
1429                     m.complete();
1430                 }
1431                 initVisiblePackages(msym, allModules);
1432             }
1433 
1434             @Override
1435             public String toString() {
1436                 return &quot;unnamedModule Completer&quot;;
1437             }
1438         };
1439     }
1440 
1441     private final Map&lt;ModuleSymbol, Set&lt;ModuleSymbol&gt;&gt; requiresTransitiveCache = new HashMap&lt;&gt;();
1442 
1443     private void completeModule(ModuleSymbol msym) {
1444         if (inInitModules) {
1445             msym.completer = sym -&gt; completeModule(msym);
1446             return ;
1447         }
1448 
1449         if ((msym.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0) {
1450             completeAutomaticModule(msym);
1451         }
1452 
1453         Assert.checkNonNull(msym.requires);
1454 
1455         initAddReads();
1456 
1457         msym.requires = msym.requires.appendList(List.from(addReads.getOrDefault(msym, Collections.emptySet())));
1458 
1459         List&lt;RequiresDirective&gt; requires = msym.requires;
1460 
1461         while (requires.nonEmpty()) {
1462             if (!allModules().contains(requires.head.module)) {
1463                 Env&lt;AttrContext&gt; env = typeEnvs.get(msym);
1464                 if (env != null) {
1465                     JavaFileObject origSource = log.useSource(env.toplevel.sourcefile);
1466                     try {
1467                         log.error(/*XXX*/env.tree, Errors.ModuleNotFound(requires.head.module));
1468                     } finally {
1469                         log.useSource(origSource);
1470                     }
1471                 } else {
1472                     Assert.check((msym.flags() &amp; Flags.AUTOMATIC_MODULE) == 0);
1473                 }
1474                 msym.requires = List.filter(msym.requires, requires.head);
1475             }
1476             requires = requires.tail;
1477         }
1478 
1479         Set&lt;ModuleSymbol&gt; readable = new LinkedHashSet&lt;&gt;();
1480         Set&lt;ModuleSymbol&gt; requiresTransitive = new HashSet&lt;&gt;();
1481 
1482         for (RequiresDirective d : msym.requires) {
1483             d.module.complete();
1484             readable.add(d.module);
1485             Set&lt;ModuleSymbol&gt; s = retrieveRequiresTransitive(d.module);
1486             Assert.checkNonNull(s, () -&gt; &quot;no entry in cache for &quot; + d.module);
1487             readable.addAll(s);
1488             if (d.flags.contains(RequiresFlag.TRANSITIVE)) {
1489                 requiresTransitive.add(d.module);
1490                 requiresTransitive.addAll(s);
1491             }
1492         }
1493 
1494         requiresTransitiveCache.put(msym, requiresTransitive);
1495         initVisiblePackages(msym, readable);
1496         for (ExportsDirective d: msym.exports) {
1497             if (d.packge != null) {
1498                 d.packge.modle = msym;
1499             }
1500         }
1501     }
1502 
1503     private Set&lt;ModuleSymbol&gt; retrieveRequiresTransitive(ModuleSymbol msym) {
1504         Set&lt;ModuleSymbol&gt; requiresTransitive = requiresTransitiveCache.get(msym);
1505 
1506         if (requiresTransitive == null) {
1507             //the module graph may contain cycles involving automatic modules or --add-reads edges
1508             requiresTransitive = new HashSet&lt;&gt;();
1509 
1510             Set&lt;ModuleSymbol&gt; seen = new HashSet&lt;&gt;();
1511             List&lt;ModuleSymbol&gt; todo = List.of(msym);
1512 
1513             while (todo.nonEmpty()) {
1514                 ModuleSymbol current = todo.head;
1515                 todo = todo.tail;
1516                 if (!seen.add(current))
1517                     continue;
1518                 requiresTransitive.add(current);
1519                 current.complete();
1520                 Iterable&lt;? extends RequiresDirective&gt; requires;
1521                 if (current != syms.unnamedModule) {
1522                     Assert.checkNonNull(current.requires, () -&gt; current + &quot;.requires == null; &quot; + msym);
1523                     requires = current.requires;
1524                     for (RequiresDirective rd : requires) {
1525                         if (rd.isTransitive())
1526                             todo = todo.prepend(rd.module);
1527                     }
1528                 } else {
1529                     for (ModuleSymbol mod : allModules()) {
1530                         todo = todo.prepend(mod);
1531                     }
1532                 }
1533             }
1534 
1535             requiresTransitive.remove(msym);
1536         }
1537 
1538         return requiresTransitive;
1539     }
1540 
1541     private void initVisiblePackages(ModuleSymbol msym, Collection&lt;ModuleSymbol&gt; readable) {
1542         initAddExports();
1543 
1544         msym.visiblePackages = new LinkedHashMap&lt;&gt;();
1545         msym.readModules = new HashSet&lt;&gt;(readable);
1546 
1547         Map&lt;Name, ModuleSymbol&gt; seen = new HashMap&lt;&gt;();
1548 
1549         for (ModuleSymbol rm : readable) {
1550             if (rm == syms.unnamedModule)
1551                 continue;
1552             addVisiblePackages(msym, seen, rm, rm.exports);
1553         }
1554 
1555         addExports.forEach((exportsFrom, exports) -&gt; {
1556             if (msym.readModules.contains(exportsFrom)) {
1557                 addVisiblePackages(msym, seen, exportsFrom, exports);
1558             }
1559         });
1560     }
1561 
1562     private void addVisiblePackages(ModuleSymbol msym,
1563                                     Map&lt;Name, ModuleSymbol&gt; seenPackages,
1564                                     ModuleSymbol exportsFrom,
1565                                     Collection&lt;ExportsDirective&gt; exports) {
1566         for (ExportsDirective d : exports) {
1567             if (d.modules == null || d.modules.contains(msym)) {
1568                 Name packageName = d.packge.fullname;
1569                 ModuleSymbol previousModule = seenPackages.get(packageName);
1570 
1571                 if (previousModule != null &amp;&amp; previousModule != exportsFrom) {
1572                     Env&lt;AttrContext&gt; env = typeEnvs.get(msym);
1573                     JavaFileObject origSource = env != null ? log.useSource(env.toplevel.sourcefile)
1574                                                             : null;
1575                     DiagnosticPosition pos = env != null ? env.tree.pos() : null;
1576                     try {
1577                         if (msym.isUnnamed()) {
1578                             log.error(pos, Errors.PackageClashFromRequiresInUnnamed(packageName,
1579                                                                                     previousModule, exportsFrom));
1580                         } else {
1581                             log.error(pos, Errors.PackageClashFromRequires(msym, packageName,
1582                                                                            previousModule, exportsFrom));
1583                         }
1584                     } finally {
1585                         if (env != null)
1586                             log.useSource(origSource);
1587                     }
1588                     continue;
1589                 }
1590 
1591                 seenPackages.put(packageName, exportsFrom);
1592                 msym.visiblePackages.put(d.packge.fullname, d.packge);
1593             }
1594         }
1595     }
1596 
1597     private void initAddExports() {
1598         if (addExports != null)
1599             return;
1600 
1601         addExports = new LinkedHashMap&lt;&gt;();
1602         Set&lt;ModuleSymbol&gt; unknownModules = new HashSet&lt;&gt;();
1603 
1604         if (addExportsOpt == null)
1605             return;
1606 
1607         Pattern ep = Pattern.compile(&quot;([^/]+)/([^=]+)=(.*)&quot;);
1608         for (String s: addExportsOpt.split(&quot;\0+&quot;)) {
1609             if (s.isEmpty())
1610                 continue;
1611             Matcher em = ep.matcher(s);
1612             if (!em.matches()) {
1613                 continue;
1614             }
1615 
1616             // Terminology comes from
1617             //  --add-exports module/package=target,...
1618             // Compare to
1619             //  module module { exports package to target, ... }
1620             String moduleName = em.group(1);
1621             String packageName = em.group(2);
1622             String targetNames = em.group(3);
1623 
1624             if (!isValidName(moduleName))
1625                 continue;
1626 
1627             ModuleSymbol msym = syms.enterModule(names.fromString(moduleName));
1628             if (!isKnownModule(msym, unknownModules))
1629                 continue;
1630 
1631             if (!isValidName(packageName))
1632                 continue;
1633 
1634             if (!allowAccessIntoSystem &amp;&amp; (msym.flags() &amp; Flags.SYSTEM_MODULE) != 0) {
1635                 log.error(Errors.AddExportsWithRelease(msym));
1636                 continue;
1637             }
1638 
1639             PackageSymbol p = syms.enterPackage(msym, names.fromString(packageName));
1640             p.modle = msym;  // TODO: do we need this?
1641 
1642             List&lt;ModuleSymbol&gt; targetModules = List.nil();
1643             for (String toModule : targetNames.split(&quot;[ ,]+&quot;)) {
1644                 ModuleSymbol m;
1645                 if (toModule.equals(&quot;ALL-UNNAMED&quot;)) {
1646                     m = syms.unnamedModule;
1647                 } else {
1648                     if (!isValidName(toModule))
1649                         continue;
1650                     m = syms.enterModule(names.fromString(toModule));
1651                     if (!isKnownModule(m, unknownModules))
1652                         continue;
1653                 }
1654                 targetModules = targetModules.prepend(m);
1655             }
1656 
1657             Set&lt;ExportsDirective&gt; extra = addExports.computeIfAbsent(msym, _x -&gt; new LinkedHashSet&lt;&gt;());
1658             ExportsDirective d = new ExportsDirective(p, targetModules);
1659             extra.add(d);
1660         }
1661     }
1662 
1663     private boolean isKnownModule(ModuleSymbol msym, Set&lt;ModuleSymbol&gt; unknownModules) {
1664         if (allModules.contains(msym)) {
1665             return true;
1666         }
1667 
1668         if (!unknownModules.contains(msym)) {
1669             if (lintOptions) {
1670                 log.warning(LintCategory.OPTIONS,
1671                         Warnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));
1672             }
1673             unknownModules.add(msym);
1674         }
1675         return false;
1676     }
1677 
1678     private void initAddReads() {
1679         if (addReads != null)
1680             return;
1681 
1682         addReads = new LinkedHashMap&lt;&gt;();
1683 
1684         if (addReadsOpt == null)
1685             return;
1686 
1687         Pattern rp = Pattern.compile(&quot;([^=]+)=(.*)&quot;);
1688         for (String s : addReadsOpt.split(&quot;\0+&quot;)) {
1689             if (s.isEmpty())
1690                 continue;
1691             Matcher rm = rp.matcher(s);
1692             if (!rm.matches()) {
1693                 continue;
1694             }
1695 
1696             // Terminology comes from
1697             //  --add-reads source-module=target-module,...
1698             // Compare to
1699             //  module source-module { requires target-module; ... }
1700             String sourceName = rm.group(1);
1701             String targetNames = rm.group(2);
1702 
1703             if (!isValidName(sourceName))
1704                 continue;
1705 
1706             ModuleSymbol msym = syms.enterModule(names.fromString(sourceName));
1707             if (!allModules.contains(msym)) {
1708                 if (lintOptions) {
1709                     log.warning(Warnings.ModuleForOptionNotFound(Option.ADD_READS, msym));
1710                 }
1711                 continue;
1712             }
1713 
1714             if (!allowAccessIntoSystem &amp;&amp; (msym.flags() &amp; Flags.SYSTEM_MODULE) != 0) {
1715                 log.error(Errors.AddReadsWithRelease(msym));
1716                 continue;
1717             }
1718 
1719             for (String targetName : targetNames.split(&quot;[ ,]+&quot;, -1)) {
1720                 ModuleSymbol targetModule;
1721                 if (targetName.equals(&quot;ALL-UNNAMED&quot;)) {
1722                     targetModule = syms.unnamedModule;
1723                 } else {
1724                     if (!isValidName(targetName))
1725                         continue;
1726                     targetModule = syms.enterModule(names.fromString(targetName));
1727                     if (!allModules.contains(targetModule)) {
1728                         if (lintOptions) {
1729                             log.warning(LintCategory.OPTIONS, Warnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));
1730                         }
1731                         continue;
1732                     }
1733                 }
1734                 addReads.computeIfAbsent(msym, m -&gt; new HashSet&lt;&gt;())
1735                         .add(new RequiresDirective(targetModule, EnumSet.of(RequiresFlag.EXTRA)));
1736             }
1737         }
1738     }
1739 
1740     private void checkCyclicDependencies(JCModuleDecl mod) {
1741         for (JCDirective d : mod.directives) {
1742             JCRequires rd;
1743             if (!d.hasTag(Tag.REQUIRES) || (rd = (JCRequires) d).directive == null)
1744                 continue;
1745             Set&lt;ModuleSymbol&gt; nonSyntheticDeps = new HashSet&lt;&gt;();
1746             List&lt;ModuleSymbol&gt; queue = List.of(rd.directive.module);
1747             while (queue.nonEmpty()) {
1748                 ModuleSymbol current = queue.head;
1749                 queue = queue.tail;
1750                 if (!nonSyntheticDeps.add(current))
1751                     continue;
1752                 current.complete();
1753                 if ((current.flags() &amp; Flags.AUTOMATIC_MODULE) != 0)
1754                     continue;
1755                 Assert.checkNonNull(current.requires, current::toString);
1756                 for (RequiresDirective dep : current.requires) {
1757                     if (!dep.flags.contains(RequiresFlag.EXTRA))
1758                         queue = queue.prepend(dep.module);
1759                 }
1760             }
1761             if (nonSyntheticDeps.contains(mod.sym)) {
1762                 log.error(rd.moduleName.pos(), Errors.CyclicRequires(rd.directive.module));
1763             }
1764         }
1765     }
1766 
1767     private boolean isValidName(CharSequence name) {
1768         return SourceVersion.isName(name, Source.toSourceVersion(source));
1769     }
1770 
1771     // DEBUG
1772     private String toString(ModuleSymbol msym) {
1773         return msym.name + &quot;[&quot;
1774                 + &quot;kind:&quot; + msym.kind + &quot;;&quot;
1775                 + &quot;locn:&quot; + toString(msym.sourceLocation) + &quot;,&quot; + toString(msym.classLocation) + &quot;;&quot;
1776                 + &quot;info:&quot; + toString(msym.module_info.sourcefile) + &quot;,&quot;
1777                             + toString(msym.module_info.classfile) + &quot;,&quot;
1778                             + msym.module_info.completer
1779                 + &quot;]&quot;;
1780     }
1781 
1782     // DEBUG
1783     String toString(Location locn) {
1784         return (locn == null) ? &quot;--&quot; : locn.getName();
1785     }
1786 
1787     // DEBUG
1788     String toString(JavaFileObject fo) {
1789         return (fo == null) ? &quot;--&quot; : fo.getName();
1790     }
1791 
1792     public void newRound() {
1793         allModules = null;
1794         rootModules = null;
1795         defaultModule = null;
1796         warnedMissing.clear();
1797     }
1798 
1799     public interface PackageNameFinder {
1800         public Name findPackageNameOf(JavaFileObject jfo);
1801     }
1802 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransPatterns.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import com.sun.tools.javac.code.Flags;
 29 import com.sun.tools.javac.code.Symbol;
 30 import com.sun.tools.javac.code.Symbol.BindingSymbol;
 31 import com.sun.tools.javac.code.Symbol.VarSymbol;
 32 import com.sun.tools.javac.code.Symtab;
 33 import com.sun.tools.javac.code.Type;
 34 import com.sun.tools.javac.code.Types;
 35 import com.sun.tools.javac.tree.JCTree;
 36 import com.sun.tools.javac.tree.JCTree.JCAssign;
 37 import com.sun.tools.javac.tree.JCTree.JCBinary;
 38 import com.sun.tools.javac.tree.JCTree.JCConditional;
 39 import com.sun.tools.javac.tree.JCTree.JCExpression;
 40 import com.sun.tools.javac.tree.JCTree.JCForLoop;
 41 import com.sun.tools.javac.tree.JCTree.JCIdent;
 42 import com.sun.tools.javac.tree.JCTree.JCIf;
 43 import com.sun.tools.javac.tree.JCTree.JCInstanceOf;
 44 import com.sun.tools.javac.tree.JCTree.JCLabeledStatement;
 45 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 46 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 47 import com.sun.tools.javac.tree.JCTree.JCBindingPattern;
 48 import com.sun.tools.javac.tree.JCTree.JCWhileLoop;
 49 import com.sun.tools.javac.tree.JCTree.Tag;
 50 import com.sun.tools.javac.tree.TreeMaker;
 51 import com.sun.tools.javac.tree.TreeTranslator;
 52 import com.sun.tools.javac.util.Assert;
 53 import com.sun.tools.javac.util.Context;
 54 import com.sun.tools.javac.util.ListBuffer;
 55 import com.sun.tools.javac.util.Log;
 56 import com.sun.tools.javac.util.Names;
 57 import com.sun.tools.javac.util.Options;
 58 
 59 import java.util.Map;
 60 import java.util.Map.Entry;
 61 
 62 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 63 import static com.sun.tools.javac.code.TypeTag.BOT;
 64 import com.sun.tools.javac.jvm.Target;
 65 import com.sun.tools.javac.tree.JCTree;
 66 import com.sun.tools.javac.tree.JCTree.JCBlock;
 67 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
 68 import com.sun.tools.javac.tree.JCTree.JCLambda;
 69 import com.sun.tools.javac.tree.JCTree.JCStatement;
 70 import com.sun.tools.javac.tree.JCTree.LetExpr;
 71 import com.sun.tools.javac.util.List;
 72 import java.util.HashMap;
 73 
 74 /**
 75  * This pass translates pattern-matching constructs, such as instanceof &lt;pattern&gt;.
 76  */
 77 public class TransPatterns extends TreeTranslator {
 78 
 79     protected static final Context.Key&lt;TransPatterns&gt; transPatternsKey = new Context.Key&lt;&gt;();
 80 
 81     public static TransPatterns instance(Context context) {
 82         TransPatterns instance = context.get(transPatternsKey);
 83         if (instance == null)
 84             instance = new TransPatterns(context);
 85         return instance;
 86     }
 87 
 88     private final Symtab syms;
 89     private final Types types;
 90     private final Operators operators;
 91     private final Log log;
 92     private final ConstFold constFold;
 93     private final Names names;
 94     private final Target target;
 95     private TreeMaker make;
 96 
 97     BindingContext bindingContext = new BindingContext() {
 98         @Override
 99         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
100             return null;
101         }
102 
103         @Override
104         VarSymbol getBindingFor(BindingSymbol varSymbol) {
105             return null;
106         }
107 
108         @Override
109         JCStatement decorateStatement(JCStatement stat) {
110             return stat;
111         }
112 
113         @Override
114         JCExpression decorateExpression(JCExpression expr) {
115             return expr;
116         }
117 
118         @Override
119         BindingContext pop() {
120             //do nothing
121             return this;
122         }
123 
124         @Override
125         boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
126             return false;
127         }
128     };
129 
130     JCLabeledStatement pendingMatchLabel = null;
131 
132     boolean debugTransPatterns;
133 
134     private MethodSymbol currentMethodSym = null;
135 
136     protected TransPatterns(Context context) {
137         context.put(transPatternsKey, this);
138         syms = Symtab.instance(context);
139         make = TreeMaker.instance(context);
140         types = Types.instance(context);
141         operators = Operators.instance(context);
142         log = Log.instance(context);
143         constFold = ConstFold.instance(context);
144         names = Names.instance(context);
145         target = Target.instance(context);
146         debugTransPatterns = Options.instance(context).isSet(&quot;debug.patterns&quot;);
147     }
148 
149     @Override
150     public void visitTypeTest(JCInstanceOf tree) {
151         if (tree.pattern.hasTag(Tag.BINDINGPATTERN)) {
152             //E instanceof T N
153             //=&gt;
154             //(let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))
155             JCBindingPattern patt = (JCBindingPattern)tree.pattern;
156             VarSymbol pattSym = patt.symbol;
157             Type tempType = tree.expr.type.hasTag(BOT) ?
158                     syms.objectType
159                     : tree.expr.type;
160             VarSymbol temp = new VarSymbol(pattSym.flags() | Flags.SYNTHETIC,
161                     names.fromString(pattSym.name.toString() + target.syntheticNameChar() + &quot;temp&quot;),
162                     tempType,
163                     patt.symbol.owner);
164             JCExpression translatedExpr = translate(tree.expr);
165             Type castTargetType = types.boxedTypeOrType(pattSym.erasure(types));
166 
167             result = makeTypeTest(make.Ident(temp), make.Type(castTargetType));
168 
169             VarSymbol bindingVar = bindingContext.bindingDeclared(patt.symbol);
170             if (bindingVar != null) { //TODO: cannot be null here?
171                 JCAssign fakeInit = (JCAssign)make.at(tree.pos).Assign(
172                         make.Ident(bindingVar), convert(make.Ident(temp), castTargetType)).setType(bindingVar.erasure(types));
173                 LetExpr nestedLE = make.LetExpr(List.of(make.Exec(fakeInit)),
174                                                 make.Literal(true));
175                 nestedLE.needsCond = true;
176                 nestedLE.setType(syms.booleanType);
177                 result = makeBinary(Tag.AND, (JCExpression)result, nestedLE);
178             }
179             result = make.at(tree.pos).LetExpr(make.VarDef(temp, translatedExpr), (JCExpression)result).setType(syms.booleanType);
180             ((LetExpr) result).needsCond = true;
181         } else {
182             super.visitTypeTest(tree);
183         }
184     }
185 
186     @Override
187     public void visitBinary(JCBinary tree) {
188         bindingContext = new BasicBindingContext();
189         try {
190             super.visitBinary(tree);
191             result = bindingContext.decorateExpression(tree);
192         } finally {
193             bindingContext.pop();
194         }
195     }
196 
197     @Override
198     public void visitConditional(JCConditional tree) {
199         bindingContext = new BasicBindingContext();
200         try {
201             super.visitConditional(tree);
202             result = bindingContext.decorateExpression(tree);
203         } finally {
204             bindingContext.pop();
205         }
206     }
207 
208     @Override
209     public void visitIf(JCIf tree) {
210         bindingContext = new BasicBindingContext();
211         try {
212             super.visitIf(tree);
213             result = bindingContext.decorateStatement(tree);
214         } finally {
215             bindingContext.pop();
216         }
217     }
218 
219     @Override
220     public void visitForLoop(JCForLoop tree) {
221         bindingContext = new BasicBindingContext();
222         try {
223             super.visitForLoop(tree);
224             result = bindingContext.decorateStatement(tree);
225         } finally {
226             bindingContext.pop();
227         }
228     }
229 
230     @Override
231     public void visitWhileLoop(JCWhileLoop tree) {
232         bindingContext = new BasicBindingContext();
233         try {
234             super.visitWhileLoop(tree);
235             result = bindingContext.decorateStatement(tree);
236         } finally {
237             bindingContext.pop();
238         }
239     }
240 
241     @Override
242     public void visitDoLoop(JCDoWhileLoop tree) {
243         bindingContext = new BasicBindingContext();
244         try {
245             super.visitDoLoop(tree);
246             result = bindingContext.decorateStatement(tree);
247         } finally {
248             bindingContext.pop();
249         }
250     }
251 
252     @Override
253     public void visitMethodDef(JCMethodDecl tree) {
254         MethodSymbol prevMethodSym = currentMethodSym;
255         try {
256             currentMethodSym = tree.sym;
257             super.visitMethodDef(tree);
258         } finally {
259             currentMethodSym = prevMethodSym;
260         }
261     }
262 
263     @Override
264     public void visitIdent(JCIdent tree) {
265         VarSymbol bindingVar = null;
266         if ((tree.sym.flags() &amp; Flags.MATCH_BINDING) != 0) {
267             bindingVar = bindingContext.getBindingFor((BindingSymbol)tree.sym);
268         }
269         if (bindingVar == null) {
270             super.visitIdent(tree);
271         } else {
272             result = make.at(tree.pos).Ident(bindingVar);
273         }
274     }
275 
276     @Override
277     public void visitBlock(JCBlock tree) {
278         ListBuffer&lt;JCStatement&gt; statements = new ListBuffer&lt;&gt;();
279         bindingContext = new BindingDeclarationFenceBindingContext() {
280             boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
281                 //{
282                 //    if (E instanceof T N) {
283                 //        return ;
284                 //    }
285                 //    //use of N:
286                 //}
287                 //=&gt;
288                 //{
289                 //    T N;
290                 //    if ((let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))) {
291                 //        return ;
292                 //    }
293                 //    //use of N:
294                 //}
295                 hoistedVarMap.put(binding, var.sym);
296                 statements.append(var);
297                 return true;
298             }
299         };
300         try {
301             for (List&lt;JCStatement&gt; l = tree.stats; l.nonEmpty(); l = l.tail) {
302                 statements.append(translate(l.head));
303             }
304 
305             tree.stats = statements.toList();
306             result = tree;
307         } finally {
308             bindingContext.pop();
309         }
310     }
311 
312     @Override
313     public void visitLambda(JCLambda tree) {
314         BindingContext prevContent = bindingContext;
315         try {
316             bindingContext = new BindingDeclarationFenceBindingContext();
317             super.visitLambda(tree);
318         } finally {
319             bindingContext = prevContent;
320         }
321     }
322 
323     public JCTree translateTopLevelClass(Env&lt;AttrContext&gt; env, JCTree cdef, TreeMaker make) {
324         try {
325             this.make = make;
326             translate(cdef);
327         } finally {
328             // note that recursive invocations of this method fail hard
329             this.make = null;
330         }
331 
332         return cdef;
333     }
334 
335     /** Make an instanceof expression.
336      *  @param lhs      The expression.
337      *  @param type     The type to be tested.
338      */
339 
340     JCInstanceOf makeTypeTest(JCExpression lhs, JCExpression type) {
341         JCInstanceOf tree = make.TypeTest(lhs, type);
342         tree.type = syms.booleanType;
343         return tree;
344     }
345 
346     /** Make an attributed binary expression (copied from Lower).
347      *  @param optag    The operators tree tag.
348      *  @param lhs      The operator&#39;s left argument.
349      *  @param rhs      The operator&#39;s right argument.
350      */
351     JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {
352         JCBinary tree = make.Binary(optag, lhs, rhs);
353         tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);
354         tree.type = tree.operator.type.getReturnType();
355         return tree;
356     }
357 
358     JCExpression convert(JCExpression expr, Type target) {
359         JCExpression result = make.at(expr.pos()).TypeCast(make.Type(target), expr);
360         result.type = target;
361         return result;
362     }
363 
364     abstract class BindingContext {
365         abstract VarSymbol bindingDeclared(BindingSymbol varSymbol);
366         abstract VarSymbol getBindingFor(BindingSymbol varSymbol);
367         abstract JCStatement decorateStatement(JCStatement stat);
368         abstract JCExpression decorateExpression(JCExpression expr);
369         abstract BindingContext pop();
370         abstract boolean tryPrepend(BindingSymbol binding, JCVariableDecl var);
371     }
372 
373     class BasicBindingContext extends BindingContext {
374         Map&lt;BindingSymbol, VarSymbol&gt; hoistedVarMap;
375         BindingContext parent;
376 
377         public BasicBindingContext() {
378             this.parent = bindingContext;
379             this.hoistedVarMap = new HashMap&lt;&gt;();
380         }
381 
382         @Override
383         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
384             VarSymbol res = parent.bindingDeclared(varSymbol);
385             if (res == null) {
386                 res = new VarSymbol(varSymbol.flags(), varSymbol.name, varSymbol.type, varSymbol.owner);
387                 res.setTypeAttributes(varSymbol.getRawTypeAttributes());
388                 hoistedVarMap.put(varSymbol, res);
389             }
390             return res;
391         }
392 
393         @Override
394         VarSymbol getBindingFor(BindingSymbol varSymbol) {
395             VarSymbol res = parent.getBindingFor(varSymbol);
396             if (res != null) {
397                 return res;
398             }
399             return hoistedVarMap.entrySet().stream()
400                     .filter(e -&gt; e.getKey().isAliasFor(varSymbol))
401                     .findFirst()
402                     .map(e -&gt; e.getValue()).orElse(null);
403         }
404 
405         @Override
406         JCStatement decorateStatement(JCStatement stat) {
407             if (hoistedVarMap.isEmpty()) return stat;
408             //if (E instanceof T N) {
409             //     //use N
410             //}
411             //=&gt;
412             //{
413             //    T N;
414             //    if ((let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))) {
415             //        //use N
416             //    }
417             //}
418             ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
419             for (Entry&lt;BindingSymbol, VarSymbol&gt; e : hoistedVarMap.entrySet()) {
420                 JCVariableDecl decl = makeHoistedVarDecl(stat.pos, e.getValue());
421                 if (!e.getKey().isPreserved() ||
422                     !parent.tryPrepend(e.getKey(), decl)) {
423                     stats.add(decl);
424                 }
425             }
426             if (stats.nonEmpty()) {
427                 stats.add(stat);
428                 stat = make.at(stat.pos).Block(0, stats.toList());
429             }
430             return stat;
431         }
432 
433         @Override
434         JCExpression decorateExpression(JCExpression expr) {
435             //E instanceof T N &amp;&amp; /*use of N*/
436             //=&gt;
437             //(let T N; (let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp)) &amp;&amp; /*use of N*/)
438             for (VarSymbol vsym : hoistedVarMap.values()) {
439                 expr = make.at(expr.pos).LetExpr(makeHoistedVarDecl(expr.pos, vsym), expr).setType(expr.type);
440             }
441             return expr;
442         }
443 
444         @Override
445         BindingContext pop() {
446             return bindingContext = parent;
447         }
448 
449         @Override
450         boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
451             return false;
452         }
453 
454         private JCVariableDecl makeHoistedVarDecl(int pos, VarSymbol varSymbol) {
455             return make.at(pos).VarDef(varSymbol, null);
456         }
457     }
458 
459     private class BindingDeclarationFenceBindingContext extends BasicBindingContext {
460 
461         @Override
462         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
463             return null;
464         }
465 
466     }
467 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Infer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Flow.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InferenceContext.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Infer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 135,11 ***</span>
      * to inference errors that can arise during a method applicability check.
      */
      public static class InferenceException extends InapplicableMethodException {
          private static final long serialVersionUID = 0;
  
<span class="line-modified">!         List&lt;JCDiagnostic&gt; messages = List.nil();</span>
  
          InferenceException() {
              super(null);
          }
  
<span class="line-new-header">--- 135,11 ---</span>
      * to inference errors that can arise during a method applicability check.
      */
      public static class InferenceException extends InapplicableMethodException {
          private static final long serialVersionUID = 0;
  
<span class="line-modified">!         transient List&lt;JCDiagnostic&gt; messages = List.nil();</span>
  
          InferenceException() {
              super(null);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,11 ***</span>
                  return List.of(mt.getReturnType());
              }
          }
  
      /**
<span class="line-modified">!      * A partially infered method/constructor type; such a type can be checked multiple times</span>
       * against different targets.
       */
      public class PartiallyInferredMethodType extends MethodType {
          public PartiallyInferredMethodType(MethodType mtype, InferenceContext inferenceContext, Env&lt;AttrContext&gt; env, Warner warn) {
              super(mtype.getParameterTypes(), mtype.getReturnType(), mtype.getThrownTypes(), mtype.tsym);
<span class="line-new-header">--- 277,11 ---</span>
                  return List.of(mt.getReturnType());
              }
          }
  
      /**
<span class="line-modified">!      * A partially inferred method/constructor type; such a type can be checked multiple times</span>
       * against different targets.
       */
      public class PartiallyInferredMethodType extends MethodType {
          public PartiallyInferredMethodType(MethodType mtype, InferenceContext inferenceContext, Env&lt;AttrContext&gt; env, Warner warn) {
              super(mtype.getParameterTypes(), mtype.getReturnType(), mtype.getThrownTypes(), mtype.tsym);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,11 ***</span>
              return true;
          }
  
          /**
           * Checks this type against a target; this means generating return type constraints, solve
<span class="line-modified">!          * and then roll back the results (to avoid poolluting the context).</span>
           */
          Type check(Attr.ResultInfo resultInfo) {
              Warner noWarnings = new Warner(null);
              List&lt;Type&gt; saved_undet = null;
              try {
<span class="line-new-header">--- 304,11 ---</span>
              return true;
          }
  
          /**
           * Checks this type against a target; this means generating return type constraints, solve
<span class="line-modified">!          * and then roll back the results (to avoid polluting the context).</span>
           */
          Type check(Attr.ResultInfo resultInfo) {
              Warner noWarnings = new Warner(null);
              List&lt;Type&gt; saved_undet = null;
              try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1319,11 ***</span>
           * to pick the next node to solve in the inference graph.
           */
          public static class NodeNotFoundException extends RuntimeException {
              private static final long serialVersionUID = 0;
  
<span class="line-modified">!             InferenceGraph graph;</span>
  
              public NodeNotFoundException(InferenceGraph graph) {
                  this.graph = graph;
              }
          }
<span class="line-new-header">--- 1319,11 ---</span>
           * to pick the next node to solve in the inference graph.
           */
          public static class NodeNotFoundException extends RuntimeException {
              private static final long serialVersionUID = 0;
  
<span class="line-modified">!             transient InferenceGraph graph;</span>
  
              public NodeNotFoundException(InferenceGraph graph) {
                  this.graph = graph;
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1619,14 ***</span>
          /** bound dependency */
          BOUND(&quot;dotted&quot;),
          /** stuck dependency */
          STUCK(&quot;dashed&quot;);
  
<span class="line-modified">!         final String dotSyle;</span>
  
<span class="line-modified">!         private DependencyKind(String dotSyle) {</span>
<span class="line-modified">!             this.dotSyle = dotSyle;</span>
          }
      }
  
      /**
       * This is the graph inference solver - the solver organizes all inference variables in
<span class="line-new-header">--- 1619,14 ---</span>
          /** bound dependency */
          BOUND(&quot;dotted&quot;),
          /** stuck dependency */
          STUCK(&quot;dashed&quot;);
  
<span class="line-modified">!         final String dotStyle;</span>
  
<span class="line-modified">!         private DependencyKind(String dotStyle) {</span>
<span class="line-modified">!             this.dotStyle = dotStyle;</span>
          }
      }
  
      /**
       * This is the graph inference solver - the solver organizes all inference variables in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1827,11 ***</span>
                  }
  
                  @Override
                  public Properties dependencyAttributes(Node sink, GraphUtils.DependencyKind dk) {
                      Properties p = new Properties();
<span class="line-modified">!                     p.put(&quot;style&quot;, ((DependencyKind)dk).dotSyle);</span>
                      StringBuilder buf = new StringBuilder();
                      String sep = &quot;&quot;;
                      for (Type from : data) {
                          UndetVar uv = (UndetVar)inferenceContext.asUndetVar(from);
                          for (Type bound : uv.getBounds(InferenceBound.values())) {
<span class="line-new-header">--- 1827,11 ---</span>
                  }
  
                  @Override
                  public Properties dependencyAttributes(Node sink, GraphUtils.DependencyKind dk) {
                      Properties p = new Properties();
<span class="line-modified">!                     p.put(&quot;style&quot;, ((DependencyKind)dk).dotStyle);</span>
                      StringBuilder buf = new StringBuilder();
                      String sep = &quot;&quot;;
                      for (Type from : data) {
                          UndetVar uv = (UndetVar)inferenceContext.asUndetVar(from);
                          for (Type bound : uv.getBounds(InferenceBound.values())) {
</pre>
<center><a href="Flow.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InferenceContext.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
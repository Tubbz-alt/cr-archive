diff a/src/jdk.compiler/share/man/javac.1 b/src/jdk.compiler/share/man/javac.1
--- a/src/jdk.compiler/share/man/javac.1
+++ b/src/jdk.compiler/share/man/javac.1
@@ -1,16 +1,15 @@
-'\" t
-.\" Copyright (c) 1994, 2015, Oracle and/or its affiliates. All rights reserved.
+.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
 .\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 .\"
 .\" This code is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License version 2 only, as
 .\" published by the Free Software Foundation.
 .\"
 .\" This code is distributed in the hope that it will be useful, but WITHOUT
 .\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-.\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+.\" FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 .\" version 2 for more details (a copy is included in the LICENSE file that
 .\" accompanied this code).
 .\"
 .\" You should have received a copy of the GNU General Public License version
 .\" 2 along with this work; if not, write to the Free Software Foundation,
@@ -18,1349 +17,2365 @@
 .\"
 .\" Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 .\" or visit www.oracle.com if you need additional information or have any
 .\" questions.
 .\"
-.\"     Arch: generic
-.\"     Software: JDK 8
-.\"     Date: 03 March 2015
-.\"     SectDesc: Basic Tools
-.\"     Title: javac.1
+.\" Automatically generated by Pandoc 2.3.1
 .\"
-.if n .pl 99999
-.TH javac 1 "03 March 2015" "JDK 8" "Basic Tools"
-.\" -----------------------------------------------------------------
-.\" * Define some portability stuff
-.\" -----------------------------------------------------------------
-.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-.\" http://bugs.debian.org/507673
-.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
-.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-.ie \n(.g .ds Aq \(aq
-.el       .ds Aq '
-.\" -----------------------------------------------------------------
-.\" * set default formatting
-.\" -----------------------------------------------------------------
-.\" disable hyphenation
-.nh
-.\" disable justification (adjust text to left margin only)
-.ad l
-.\" -----------------------------------------------------------------
-.\" * MAIN CONTENT STARTS HERE *
-.\" -----------------------------------------------------------------
-
-.SH NAME    
-javac \- Reads Java class and interface definitions and compiles them into bytecode and class files\&.
-.SH SYNOPSIS    
-.sp     
-.nf     
-
-\fBjavac\fR [ \fIoptions\fR ] [ \fIsourcefiles\fR ] [ \fIclasses\fR] [ \fI@argfiles\fR ]
-.fi     
-.sp     
-Arguments can be in any order:
-.TP     
-\fIoptions\fR
-Command-line options\&. See Options\&.
-.TP     
-\fIsourcefiles\fR
-One or more source files to be compiled (such as \f3MyClass\&.java\fR)\&.
-.TP     
-\fIclasses\fR
-One or more classes to be processed for annotations (such as \f3MyPackage\&.MyClass\fR)\&.
-.TP     
-\fI@argfiles\fR
-One or more files that list options and source files\&. The \f3-J\fR options are not allowed in these files\&. See Command-Line Argument Files\&.
-.SH DESCRIPTION    
-The \f3javac\fR command reads class and interface definitions, written in the Java programming language, and compiles them into bytecode class files\&. The \f3javac\fR command can also process annotations in Java source files and classes\&.
-.PP
-There are two ways to pass source code file names to \f3javac\fR\&.
-.TP 0.2i    
-\(bu
-For a small number of source files, list the file names on the command line\&.
-.TP 0.2i    
-\(bu
-For a large number of source files, list the file names in a file that is separated by blanks or line breaks\&. Use the list file name preceded by an at sign (@) with the \f3javac\fR command\&.
-.PP
-Source code file names must have \&.java suffixes, class file names must have \&.class suffixes, and both source and class files must have root names that identify the class\&. For example, a class called \f3MyClass\fR would be written in a source file called \f3MyClass\&.java\fR and compiled into a bytecode class file called \f3MyClass\&.class\fR\&.
-.PP
-Inner class definitions produce additional class files\&. These class files have names that combine the inner and outer class names, such as \f3MyClass$MyInnerClass\&.class\fR\&.
-.PP
-Arrange source files in a directory tree that reflects their package tree\&. For example, if all of your source files are in \f3/workspace\fR, then put the source code for \f3com\&.mysoft\&.mypack\&.MyClass\fR in \f3/workspace/com/mysoft/mypack/MyClass\&.java\fR\&.
-.PP
-By default, the compiler puts each class file in the same directory as its source file\&. You can specify a separate destination directory with the \f3-d\fR option\&.
-.SH OPTIONS    
-The compiler has a set of standard options that are supported on the current development environment\&. An additional set of nonstandard options are specific to the current virtual machine and compiler implementations and are subject to change in the future\&. Nonstandard options begin with the \f3-X\fR option\&.
-.TP 0.2i    
-\(bu
-See also Cross-Compilation Options
-.TP 0.2i    
-\(bu
-See also Nonstandard Options
-.SS STANDARD\ OPTIONS    
-.TP
--A\fIkey\fR[\fI=value\fR]
-.br
-Specifies options to pass to annotation processors\&. These options are not interpreted by \f3javac\fR directly, but are made available for use by individual processors\&. The \f3key\fR value should be one or more identifiers separated by a dot (\&.)\&.
-.TP
--cp \fIpath\fR or -classpath \fIpath\fR
-.br
-Specifies where to find user class files, and (optionally) annotation processors and source files\&. This class path overrides the user class path in the \f3CLASSPATH\fR environment variable\&. If neither \f3CLASSPATH\fR, \f3-cp\fR nor \f3-classpath\fR is specified, then the user \fIclass path\fR is the current directory\&. See Setting the Class Path\&.
-
-If the \f3-sourcepath\fR option is not specified, then the user class path is also searched for source files\&.
-
-If the \f3-processorpath\fR option is not specified, then the class path is also searched for annotation processors\&.
+.TH "JAVAC" "1" "2020" "JDK 14" "JDK Commands"
+.hy
+.SH NAME
+.PP
+javac \- read Java declarations and compile them into class files
+.SH SYNOPSIS
+.PP
+\f[CB]javac\f[R] [\f[I]options\f[R]] [\f[I]sourcefiles\-or\-classnames\f[R]]
 .TP
--Djava\&.ext\&.dirs=\fIdirectories\fR
-.br
-Overrides the location of installed extensions\&.
+.B \f[I]options\f[R]
+Command\-line options.
+.RS
+.RE
 .TP
--Djava\&.endorsed\&.dirs=\fIdirectories\fR
-.br
-Overrides the location of the endorsed standards path\&.
+.B \f[I]sourcefiles\-or\-classnames\f[R]
+Source files to be compiled (for example, \f[CB]Shape.java\f[R]) or the
+names of previously compiled classes to be processed for annotations
+(for example, \f[CB]geometry.MyShape\f[R]).
+.RS
+.RE
+.SH DESCRIPTION
+.PP
+The \f[CB]javac\f[R] command reads \f[I]source files\f[R] that contain
+module, package and type declarations written in the Java programming
+language, and compiles them into \f[I]class files\f[R] that run on the
+Java Virtual Machine.
+.PP
+The \f[CB]javac\f[R] command can also \f[B]process annotations\f[R] in Java
+source files and classes.
+.PP
+Source files must have a file name extension of \f[CB]\&.java\f[R].
+Class files have a file name extension of \f[CB]\&.class\f[R].
+Both source and class files normally have file names that identify the
+contents.
+For example, a class called \f[CB]Shape\f[R] would be declared in a source
+file called \f[CB]Shape.java\f[R], and compiled into a class file called
+\f[CB]Shape.class\f[R].
+.PP
+There are two ways to specify source files to \f[CB]javac\f[R]:
+.IP \[bu] 2
+For a small number of source files, you can list their file names on the
+command line.
+.IP \[bu] 2
+For a large number of source files, you can use the
+\f[B]\f[BC]\@\f[B]\f[BI]filename\f[B]\f[R] option on the command line to
+specify an \f[I]argument file\f[R] that lists their file names.
+See \f[B]Standard Options\f[R] for a description of the option and
+\f[B]Command\-Line Argument Files\f[R] for a description of
+\f[CB]javac\f[R] argument files.
+.PP
+The order of source files specified on the command line or in an
+argument file is not important.
+\f[CB]javac\f[R] will compile the files together, as a group, and will
+automatically resolve any dependencies between the declarations in the
+various source files.
+.PP
+\f[CB]javac\f[R] expects that source files are arranged in one or more
+directory hierarchies on the file system, described in \f[B]Arrangement
+of Source Code\f[R].
+.PP
+To compile a source file, \f[CB]javac\f[R] needs to find the declaration
+of every class or interface that is used, extended, or implemented by
+the code in the source file.
+This lets \f[CB]javac\f[R] check that the code has the right to access
+those classes and interfaces.
+Rather than specifying the source files of those classes and interfaces
+explicitly, you can use command\-line options to tell \f[CB]javac\f[R]
+where to search for their source files.
+If you have compiled those source files previously, you can use options
+to tell \f[CB]javac\f[R] where to search for the corresponding class
+files.
+The options, which all have names ending in "path", are described in
+\f[B]Standard Options\f[R], and further described in \f[B]Configuring a
+Compilation\f[R] and \f[B]Searching for Module, Package and Type
+Declarations\f[R].
+.PP
+By default, \f[CB]javac\f[R] compiles each source file to a class file in
+the same directory as the source file.
+However, it is recommended to specify a separate destination directory
+with the \f[B]\f[BC]\-d\f[B]\f[R] option.
+.PP
+Command\-line \f[B]options\f[R] and \f[B]environment variables\f[R] also
+control how \f[CB]javac\f[R] performs various tasks:
+.IP \[bu] 2
+Compiling code to run on earlier releases of the JDK.
+.IP \[bu] 2
+Compiling code to run under a debugger.
+.IP \[bu] 2
+Checking for stylistic issues in Java source code.
+.IP \[bu] 2
+Checking for problems in \f[CB]javadoc\f[R] comments
+(\f[CB]/**\ ...\ */\f[R]).
+.IP \[bu] 2
+Processing annotations in source files and class files.
+.IP \[bu] 2
+Upgrading and patching modules in the compile\-time environment.
+.PP
+\f[CB]javac\f[R] supports \f[B]Compiling for Earlier Releases Of The
+Platform\f[R] and can also be invoked from Java code using one of a
+number of \f[B]APIs\f[R]
+.SH OPTIONS
+.PP
+\f[CB]javac\f[R] provides \f[B]standard options\f[R], and \f[B]extra
+options\f[R] that are either non\-standard or are for advanced use.
+.PP
+Some options take one or more arguments.
+If an argument contains spaces or other whitespace characters, the value
+should be quoted according to the conventions of the environment being
+used to invoke javac.
+If the option begins with a single dash (\f[CB]\-\f[R]) the argument
+should either directly follow the option name, or should be separated
+with a colon (\f[CB]:\f[R]) or whitespace, depending on the option.
+If the option begins with a double dash (\f[CB]\-\-\f[R]), the argument
+may be separated either by whitespace or by an equals (\f[CB]=\f[R])
+character with no additional whitespace.
+For example,
+.IP
+.nf
+\f[CB]
+\-Aname="J.\ Duke"
+\-proc:only
+\-d\ myDirectory
+\-\-module\-version\ 3
+\-\-module\-version=3
+\f[R]
+.fi
+.PP
+In the following lists of options, an argument of \f[I]path\f[R]
+represents a search path, composed of a list of file system locations
+separated by the platform path separator character, (semicolon
+\f[CB];\f[R] on Windows, or colon \f[CB]:\f[R] on other systems.) Depending
+on the option, the file system locations may be directories, JAR files
+or JMOD files.
+.SS Standard Options
 .TP
--d \fIdirectory\fR
-.br
-Sets the destination directory for class files\&. The directory must already exist because \f3javac\fR does not create it\&. If a class is part of a package, then \f3javac\fR puts the class file in a subdirectory that reflects the package name and creates directories as needed\&.
-
-If you specify \f3-d\fR\f3/home/myclasses\fR and the class is called \f3com\&.mypackage\&.MyClass\fR, then the class file is \f3/home/myclasses/com/mypackage/MyClass\&.class\fR\&.
-
-If the \fI-d\fR option is not specified, then \f3javac\fR puts each class file in the same directory as the source file from which it was generated\&.
-
-\fINote:\fR The directory specified by the \fI-d\fR option is not automatically added to your user class path\&.
+.B \f[CB]\@\f[R]\f[I]filename\f[R]
+Reads options and file names from a file.
+To shorten or simplify the \f[CB]javac\f[R] command, you can specify one
+or more files that contain arguments to the \f[CB]javac\f[R] command
+(except \f[B]\f[BC]\-J\f[B]\f[R] options).
+This lets you to create \f[CB]javac\f[R] commands of any length on any
+operating system.
+See \f[B]Command\-Line Argument Files\f[R].
+.RS
+.RE
 .TP
--deprecation
-.br
-Shows a description of each use or override of a deprecated member or class\&. Without the \f3-deprecation\fR option, \f3javac\fR shows a summary of the source files that use or override deprecated members or classes\&. The \f3-deprecation\fR option is shorthand for \f3-Xlint:deprecation\fR\&.
+.B \f[CB]\-A\f[R]\f[I]key\f[R][\f[CB]=\f[R]\f[I]value\f[R]]
+Specifies options to pass to annotation processors.
+These options are not interpreted by \f[CB]javac\f[R] directly, but are
+made available for use by individual processors.
+The \f[I]key\f[R] value should be one or more identifiers separated by a
+dot (\f[CB]\&.\f[R]).
+.RS
+.RE
 .TP
--encoding \fIencoding\fR
-.br
-Sets the source file encoding name, such as EUC-JP and UTF-8\&. If the \f3-encoding\fR option is not specified, then the platform default converter is used\&.
+.B \f[CB]\-\-add\-modules\f[R] \f[I]module\f[R]\f[CB],\f[R]\f[I]module\f[R]
+Specifies root modules to resolve in addition to the initial modules, or
+all modules on the module path if \f[I]module\f[R] is
+\f[CB]ALL\-MODULE\-PATH\f[R].
+.RS
+.RE
 .TP
--endorseddirs \fIdirectories\fR
-.br
-Overrides the location of the endorsed standards path\&.
+.B \f[CB]\-\-boot\-class\-path\f[R] \f[I]path\f[R] or \f[CB]\-bootclasspath\f[R] \f[I]path\f[R]
+Overrides the location of the bootstrap class files.
+.RS
+.PP
+\f[B]Note:\f[R] This can only be used when compiling for releases prior
+to JDK 9.
+As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
+\f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
+details.
+For JDK 9 or later, see \f[B]\f[BC]\-\-system\f[B]\f[R].
+.RE
 .TP
--extdirs \fIdirectories\fR
-.br
-Overrides the location of the \f3ext\fR directory\&. The directories variable is a colon-separated list of directories\&. Each JAR file in the specified directories is searched for class files\&. All JAR files found become part of the class path\&.
-
-If you are cross-compiling (compiling classes against bootstrap and extension classes of a different Java platform implementation), then this option specifies the directories that contain the extension classes\&. See Cross-Compilation Options for more information\&.
-.TP
--g
-.br
-Generates all debugging information, including local variables\&. By default, only line number and source file information is generated\&.
-.TP
--g:none
-.br
-Does not generate any debugging information\&.
-.TP
--g:[\fIkeyword list\fR]
-.br
-Generates only some kinds of debugging information, specified by a comma separated list of keywords\&. Valid keywords are:
-.RS     
-.TP     
-source
-Source file debugging information\&.
-.TP     
-lines
-Line number debugging information\&.
-.TP     
-vars
-Local variable debugging information\&.
-.RE     
-
+.B \f[CB]\-\-class\-path\f[R] \f[I]path\f[R], \f[CB]\-classpath\f[R] \f[I]path\f[R], or \f[CB]\-cp\f[R] \f[I]path\f[R]
+Specifies where to find user class files and annotation processors.
+This class path overrides the user class path in the \f[CB]CLASSPATH\f[R]
+environment variable.
+.RS
+.IP \[bu] 2
+If \f[CB]\-\-class\-path\f[R], \f[CB]\-classpath\f[R], or \f[CB]\-cp\f[R] are
+not specified, then the user class path is the value of the
+\f[CB]CLASSPATH\f[R] environment variable, if that is set, or else the
+current directory.
+.IP \[bu] 2
+If not compiling code for modules, if the
+\f[B]\f[BC]\-\-source\-path\f[B]\f[R] or \-sourcepath` option is not
+specified, then the user class path is also searched for source files.
+.IP \[bu] 2
+If the \f[B]\f[BC]\-processorpath\f[B]\f[R] option is not specified, then
+the class path is also searched for annotation processors.
+.RE
 .TP
--help
-.br
-Prints a synopsis of standard options\&.
+.B \f[CB]\-d\f[R] \f[I]directory\f[R]
+Sets the destination directory (or \f[I]class output directory\f[R]) for
+class files.
+If a class is part of a package, then \f[CB]javac\f[R] puts the class file
+in a subdirectory that reflects the module name (if appropriate) and
+package name.
+The directory, and any necessary subdirectories, will be created if they
+do not already exist.
+.RS
+.PP
+If the \f[CB]\-d\f[R] option is not specified, then \f[CB]javac\f[R] puts
+each class file in the same directory as the source file from which it
+was generated.
+.PP
+Except when compiling code for multiple modules, the contents of the
+class output directory will be organized in a package hierarchy.
+When compiling code for multiple modules, the contents of the output
+directory will be organized in a module hierarchy, with the contents of
+each module in a separate subdirectory, each organized as a package
+hierarchy.
+.PP
+\f[B]Note:\f[R] When compiling code for one or more modules, the class
+output directory will automatically be checked when searching for
+previously compiled classes.
+When not compiling for modules, for backwards compatibility, the
+directory is \f[I]not\f[R] automatically checked for previously compiled
+classes, and so it is recommended to specify the class output directory
+as one of the locations on the user class path, using the
+\f[CB]\-\-class\-path\f[R] option or one of its alternate forms.
+.RE
 .TP
--implicit:[\fIclass, none\fR]
-.br
-Controls the generation of class files for implicitly loaded source files\&. To automatically generate class files, use \f3-implicit:class\fR\&. To suppress class file generation, use \f3-implicit:none\fR\&. If this option is not specified, then the default is to automatically generate class files\&. In this case, the compiler issues a warning if any such class files are generated when also doing annotation processing\&. The warning is not issued when the \f3-implicit\fR option is set explicitly\&. See Searching for Types\&.
+.B \f[CB]\-deprecation\f[R]
+Shows a description of each use or override of a deprecated member or
+class.
+Without the \f[CB]\-deprecation\f[R] option, \f[CB]javac\f[R] shows a
+summary of the source files that use or override deprecated members or
+classes.
+The \f[CB]\-deprecation\f[R] option is shorthand for
+\f[CB]\-Xlint:deprecation\f[R].
+.RS
+.RE
 .TP
--J\fIoption\fR
-.br
-Passes \f3option\fR to the Java Virtual Machine (JVM), where option is one of the options described on the reference page for the Java launcher\&. For example, \f3-J-Xms48m\fR sets the startup memory to 48 MB\&. See java(1)\&.
-
-\fINote:\fR The \fICLASSPATH\fR, \f3-classpath\fR, \f3-bootclasspath\fR, and \f3-extdirs\fR options do not specify the classes used to run \f3javac\fR\&. Trying to customize the compiler implementation with these options and variables is risky and often does not accomplish what you want\&. If you must customize the complier implementation, then use the \f3-J\fR option to pass options through to the underlying \f3\fRJava launcher\&.
+.B \f[CB]\-\-enable\-preview\f[R]
+Enables preview language features.
+Used in conjunction with either \f[B]\f[BC]\-source\f[B]\f[R] or
+\f[B]\f[BC]\-\-release\f[B]\f[R].
+.RS
+.RE
 .TP
--nowarn
-.br
-Disables warning messages\&. This option operates the same as the \f3-Xlint:none\fR option\&.
+.B \f[CB]\-encoding\f[R] \f[I]encoding\f[R]
+Specifies character encoding used by source files, such as EUC\-JP and
+UTF\-8.
+If the \f[CB]\-encoding\f[R] option is not specified, then the platform
+default converter is used.
+.RS
+.RE
 .TP
--parameters
-.br
-Stores formal parameter names of constructors and methods in the generated class file so that the method \f3java\&.lang\&.reflect\&.Executable\&.getParameters\fR from the Reflection API can retrieve them\&.
+.B \f[CB]\-endorseddirs\f[R] \f[I]directories\f[R]
+Overrides the location of the endorsed standards path.
+.RS
+.PP
+\f[B]Note:\f[R] This can only be used when compiling for releases prior
+to JDK 9.
+As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
+\f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
+details.
+.RE
 .TP
--proc: [\fInone\fR, \fIonly\fR]
-.br
-Controls whether annotation processing and compilation are done\&. \f3-proc:none\fR means that compilation takes place without annotation processing\&. \f3-proc:only\fR means that only annotation processing is done, without any subsequent compilation\&.
+.B \f[CB]\-extdirs\f[R] \f[I]directories\f[R]
+Overrides the location of the installed extensions.
+\f[CB]directories\f[R] is a list of directories, separated by the platform
+path separator (\f[CB];\f[R] on Windows, and \f[CB]:\f[R] otherwise).
+Each JAR file in the specified directories is searched for class files.
+All JAR files found become part of the class path.
+.RS
+.PP
+If you are compiling for a release of the platform that supports the
+Extension Mechanism, then this option specifies the directories that
+contain the extension classes.
+See [Compiling for Other Releases of the Platform].
+.PP
+\f[B]Note:\f[R] This can only be used when compiling for releases prior
+to JDK 9.
+As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
+\f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
+details.
+.RE
 .TP
--processor \fIclass1\fR [,\fIclass2\fR,\fIclass3\fR\&.\&.\&.]
-.br
-Names of the annotation processors to run\&. This bypasses the default discovery process\&.
+.B \f[CB]\-g\f[R]
+Generates all debugging information, including local variables.
+By default, only line number and source file information is generated.
+.RS
+.RE
 .TP
--processorpath \fIpath\fR
-.br
-Specifies where to find annotation processors\&. If this option is not used, then the class path is searched for processors\&.
+.B \f[CB]\-g:\f[R][\f[CB]lines\f[R], \f[CB]vars\f[R], \f[CB]source\f[R]]
+Generates only the kinds of debugging information specified by the
+comma\-separated list of keywords.
+Valid keywords are:
+.RS
 .TP
--s \fIdir\fR
-.br
-Specifies the directory where to place the generated source files\&. The directory must already exist because \f3javac\fR does not create it\&. If a class is part of a package, then the compiler puts the source file in a subdirectory that reflects the package name and creates directories as needed\&.
-
-If you specify \f3-s /home/mysrc\fR and the class is called \f3com\&.mypackage\&.MyClass\fR, then the source file is put in \f3/home/mysrc/com/mypackage/MyClass\&.java\fR\&.
-.TP
--source \fIrelease\fR
-.br
-Specifies the version of source code accepted\&. The following values for \f3release\fR are allowed:
-.RS     
-.TP     
-1\&.3
-The compiler does not support assertions, generics, or other language features introduced after Java SE 1\&.3\&.
-.TP     
-1\&.4
-The compiler accepts code containing assertions, which were introduced in Java SE 1\&.4\&.
-.TP     
-1\&.5
-The compiler accepts code containing generics and other language features introduced in Java SE 5\&.
-.TP     
-5
-Synonym for 1\&.5\&.
-.TP     
-1\&.6
-No language changes were introduced in Java SE 6\&. However, encoding errors in source files are now reported as errors instead of warnings as in earlier releases of Java Platform, Standard Edition\&.
-.TP     
-6
-Synonym for 1\&.6\&.
-.TP     
-1\&.7
-The compiler accepts code with features introduced in Java SE 7\&.
-.TP     
-7
-Synonym for 1\&.7\&.
-.TP     
-1\&.8
-This is the default value\&. The compiler accepts code with features introduced in Java SE 8\&.
-.TP     
-8
-Synonym for 1\&.8\&.
-.RE     
-
+.B \f[CB]lines\f[R]
+Line number debugging information.
+.RS
+.RE
 .TP
--sourcepath \fIsourcepath\fR
-.br
-Specifies the source code path to search for class or interface definitions\&. As with the user class path, source path entries are separated by colons (:) on Oracle Solaris and semicolons on Windows and can be directories, JAR archives, or ZIP archives\&. If packages are used, then the local path name within the directory or archive must reflect the package name\&.
-
-\fINote:\fR Classes found through the class path might be recompiled when their source files are also found\&. See Searching for Types\&.
+.B \f[CB]vars\f[R]
+Local variable debugging information.
+.RS
+.RE
 .TP
--verbose
-.br
-Uses verbose output, which includes information about each class loaded and each source file compiled\&.
+.B \f[CB]source\f[R]
+Source file debugging information.
+.RS
+.RE
+.RE
 .TP
--version
-.br
-Prints release information\&.
+.B \f[CB]\-g:none\f[R]
+Does not generate debugging information.
+.RS
+.RE
 .TP
--werror
-.br
-Terminates compilation when warnings occur\&.
+.B \f[CB]\-h\f[R] \f[I]directory\f[R]
+Specifies where to place generated native header files.
+.RS
+.PP
+When you specify this option, a native header file is generated for each
+class that contains native methods or that has one or more constants
+annotated with the \f[B]\f[BC]java.lang.annotation.Native\f[B]\f[R]
+annotation.
+If the class is part of a package, then the compiler puts the native
+header file in a subdirectory that reflects the module name (if
+appropriate) and package name.
+The directory, and any necessary subdirectories, will be created if they
+do not already exist.
+.RE
 .TP
--X
-.br
-Displays information about nonstandard options and exits\&.
-.SS CROSS-COMPILATION\ OPTIONS    
-By default, classes are compiled against the bootstrap and extension classes of the platform that \f3javac\fR shipped with\&. But \f3javac\fR also supports cross-compiling, where classes are compiled against a bootstrap and extension classes of a different Java platform implementation\&. It is important to use the \f3-bootclasspath\fR and \f3-extdirs\fR options when cross-compiling\&.
+.B \f[CB]\-\-help\f[R], \f[CB]\-help\f[R] or \f[CB]\-?\f[R]
+Prints a synopsis of the standard options.
+.RS
+.RE
 .TP
--target \fIversion\fR
-.br
-Generates class files that target a specified release of the virtual machine\&. Class files will run on the specified target and on later releases, but not on earlier releases of the JVM\&. Valid targets are 1\&.1, 1\&.2, 1\&.3, 1\&.4, 1\&.5 (also 5), 1\&.6 (also 6), 1\&.7 (also 7), and 1\&.8 (also 8)\&.
-
-The default for the \f3-target\fR option depends on the value of the \f3-source\fR option:
-.RS     
-.TP 0.2i    
-\(bu
-If the \f3-source\fR option is not specified, then the value of the \f3-target\fR option is 1\&.8
-.TP 0.2i    
-\(bu
-If the \f3-source\fR option is 1\&.2, then the value of the \f3-target\fR option is 1\&.4
-.TP 0.2i    
-\(bu
-If the \f3-source\fR option is 1\&.3, then the value of the \f3-target\fR option is 1\&.4
-.TP 0.2i    
-\(bu
-If the \f3-source\fR option is 1\&.5, then the value of the \f3-target\fR option is 1\&.8
-.TP 0.2i    
-\(bu
-If the \f3-source\fR option is 1\&.6, then the value of the \f3-target\fR is option 1\&.8
-.TP 0.2i    
-\(bu
-If the \f3-source\fR option is 1\&.7, then the value of the \f3-target\fR is option 1\&.8
-.TP 0.2i    
-\(bu
-For all other values of the \f3-source\fR option, the value of the \f3-target\fR option is the value of the \f3-source\fR option\&.
-.RE     
-
+.B \f[CB]\-\-help\-extra\f[R] or \f[CB]\-X\f[R]
+Prints a synopsis of the set of extra options.
+.RS
+.RE
 .TP
--bootclasspath \fIbootclasspath\fR
-.br
-Cross-compiles against the specified set of boot classes\&. As with the user class path, boot class path entries are separated by colons (:) and can be directories, JAR archives, or ZIP archives\&.
-.SS COMPACT\ PROFILE\ OPTION    
-Beginning with JDK 8, the \f3javac\fR compiler supports compact profiles\&. With compact profiles, applications that do not require the entire Java platform can be deployed and run with a smaller footprint\&. The compact profiles feature could be used to shorten the download time for applications from app stores\&. This feature makes for more compact deployment of Java applications that bundle the JRE\&. This feature is also useful in small devices\&.
-.PP
-The supported profile values are \f3compact1\fR, \f3compact2\fR, and \f3compact3\fR\&. These are additive layers\&. Each higher-numbered compact profile contains all of the APIs in profiles with smaller number names\&.
-.TP
--profile
-.br
-When using compact profiles, this option specifies the profile name when compiling\&. For example:
-.sp     
-.nf     
-\f3javac \-profile compact1 Hello\&.java\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-javac does not compile source code that uses any Java SE APIs that is not in the specified profile\&. Here is an example of the error message that results from attempting to compile such source code:
-.sp     
-.nf     
-\f3cd jdk1\&.8\&.0/bin\fP
-.fi     
-.nf     
-\f3\&./javac \-profile compact1 Paint\&.java\fP
-.fi     
-.nf     
-\f3Paint\&.java:5: error: Applet is not available in profile \&'compact1\&'\fP
-.fi     
-.nf     
-\f3import java\&.applet\&.Applet;\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-In this example, you can correct the error by modifying the source to not use the \f3Applet\fR class\&. You could also correct the error by compiling without the -profile option\&. Then the compilation would be run against the full set of Java SE APIs\&. (None of the compact profiles include the \f3Applet\fR class\&.)
-
-An alternative way to compile with compact profiles is to use the \f3-bootclasspath\fR option to specify a path to an \f3rt\&.jar\fR file that specifies a profile\&'s image\&. Using the \f3-profile\fR option instead does not require a profile image to be present on the system at compile time\&. This is useful when cross-compiling\&.
-.SS NONSTANDARD\ OPTIONS    
+.B \f[CB]\-implicit:\f[R][\f[CB]none\f[R], \f[CB]class\f[R]]
+Specifies whether or not to generate class files for implicitly
+referenced files:
+.RS
+.IP \[bu] 2
+\f[CB]\-implicit:class\f[R] \-\-\- Automatically generates class files.
+.IP \[bu] 2
+\f[CB]\-implicit:none\f[R] \-\-\- Suppresses class file generation.
+.PP
+If this option is not specified, then the default automatically
+generates class files.
+In this case, the compiler issues a warning if any class files are
+generated when also doing annotation processing.
+The warning is not issued when the \f[CB]\-implicit\f[R] option is
+explicitly set.
+See \f[B]Searching for Module, Package and Type Declarations\f[R].
+.RE
 .TP
--Xbootclasspath/p:\fIpath\fR
-.br
-Adds a suffix to the bootstrap class path\&.
+.B \f[CB]\-J\f[R]\f[I]option\f[R]
+Passes \f[I]option\f[R] to the runtime system, where \f[I]option\f[R] is
+one of the Java options described on \f[B]java\f[R] command.
+For example, \f[CB]\-J\-Xms48m\f[R] sets the startup memory to 48 MB.
+.RS
+.PP
+\f[B]Note:\f[R] The \f[CB]CLASSPATH\f[R] environment variable,
+\f[CB]\-classpath\f[R] option, \f[CB]\-bootclasspath\f[R] option, and
+\f[CB]\-extdirs\f[R] option do not specify the classes used to run
+\f[CB]javac\f[R].
+Trying to customize the compiler implementation with these options and
+variables is risky and often does not accomplish what you want.
+If you must customize the compiler implementation, then use the
+\f[CB]\-J\f[R] option to pass options through to the underlying Java
+launcher.
+.RE
 .TP
--Xbootclasspath/a:\fIpath\fR
-.br
-Adds a prefix to the bootstrap class path\&.
+.B \f[CB]\-\-limit\-modules\f[R] \f[I]module\f[R]\f[CB],\f[R]\f[I]module\f[R]*
+Limits the universe of observable modules.
+.RS
+.RE
 .TP
--Xbootclasspath/:\fIpath\fR
-.br
-Overrides the location of the bootstrap class files\&.
+.B \f[CB]\-\-module\f[R] \f[I]module\-name\f[R] (\f[CB],\f[R]\f[I]module\-name\f[R])* or \f[CB]\-m\f[R] \f[I]module\-name\f[R] (\f[CB],\f[R]\f[I]module\-name\f[R])*
+Compiles those source files in the named modules that are newer than the
+corresponding files in the output directory.
+.RS
+.RE
 .TP
--Xdoclint:[-]\fIgroup\fR [\fI/access\fR]
-.br
-Enables or disables specific groups of checks, where \fIgroup\fR is one of the following values: \f3accessibility\fR, \f3syntax\fR, \f3reference\fR, \f3html\fR or \f3missing\fR\&. For more information about these groups of checks see the \f3-Xdoclint\fR option of the \f3javadoc\fR command\&. The \f3-Xdoclint\fR option is disabled by default in the \f3javac\fR command\&.
-
-The variable \fIaccess\fR specifies the minimum visibility level of classes and members that the \f3-Xdoclint\fR option checks\&. It can have one of the following values (in order of most to least visible) : \f3public\fR, \f3protected\fR, \f3package\fR and \f3private\fR\&. For example, the following option checks classes and members (with all groups of checks) that have the access level protected and higher (which includes protected, package and public):
-.sp     
-.nf     
-\f3\-Xdoclint:all/protected\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-The following option enables all groups of checks for all access levels, except it will not check for HTML errors for classes and members that have access level package and higher (which includes package and public):
-.sp     
-.nf     
-\f3\-Xdoclint:all,\-html/package\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
+.B \f[CB]\-\-module\-path\f[R] \f[I]path\f[R] or \f[CB]\-p\f[R] \f[I]path\f[R]
+Specifies where to find application modules.
+.RS
+.RE
 .TP
--Xdoclint:none
-.br
-Disables all groups of checks\&.
-.TP
--Xdoclint:all[\fI/access\fR]
-.br
-Enables all groups of checks\&.
-.TP
--Xlint
-.br
-\fI\fREnables all recommended warnings\&. In this release, enabling all available warnings is recommended\&.
-.TP
--Xlint:all
-.br
-\fI\fREnables all recommended warnings\&. In this release, enabling all available warnings is recommended\&.
-.TP
--Xlint:none
-.br
-Disables all warnings\&.
-.TP
--Xlint:\fIname\fR
-.br
-Disables warning name\&. See Enable or Disable Warnings with the -Xlint Option for a list of warnings you can disable with this option\&.
-.TP
--Xlint:\fI-name\fR
-.br
-Disables warning name\&. See Enable or Disable Warnings with the -Xlint Option with the \f3-Xlint\fR option to get a list of warnings that you can disable with this option\&.
-.TP
--Xmaxerrs \fInumber\fR
-.br
-Sets the maximum number of errors to print\&.
-.TP
--Xmaxwarns \fInumber\fR
-.br
-Sets the maximum number of warnings to print\&.
-.TP
--Xstdout \fIfilename\fR
-.br
-Sends compiler messages to the named file\&. By default, compiler messages go to \f3System\&.err\fR\&.
-.TP
--Xprefer:[\fInewer,source\fR]
-.br
-Specifies which file to read when both a source file and class file are found for a type\&. (See Searching for Types)\&. If the \f3-Xprefer:newer\fR option is used, then it reads the newer of the source or class file for a type (default)\&. If the \f3-Xprefer:source\fR option is used, then it reads the source file\&. Use -\f3Xprefer:source\fR when you want to be sure that any annotation processors can access annotations declared with a retention policy of \f3SOURCE\fR\&.
-.TP
--Xpkginfo:[\fIalways\fR,\fIlegacy\fR,\fInonempty\fR]
-.br
-Control whether javac generates \f3package-info\&.class\fR files from package-info\&.java files\&. Possible mode arguments for this option include the following\&.
-.RS     
-.TP     
-always
-Always generate a \f3package-info\&.class\fR file for every \f3package-info\&.java\fR file\&. This option may be useful if you use a build system such as Ant, which checks that each \f3\&.java\fR file has a corresponding \f3\&.class\fR file\&.
-.TP     
-legacy
-Generate a \f3package-info\&.class\fR file only if package-info\&.java contains annotations\&. Don\&'t generate a \f3package-info\&.class\fR file if package-info\&.java only contains comments\&.
-
-\fINote:\fR A \f3package-info\&.class\fR file might be generated but be empty if all the annotations in the package-info\&.java file have \f3RetentionPolicy\&.SOURCE\fR\&.
-.TP     
-nonempty
-Generate a \f3package-info\&.class\fR file only if package-info\&.java contains annotations with \f3RetentionPolicy\&.CLASS\fR or \f3RetentionPolicy\&.RUNTIME\fR\&.
-.RE     
-
+.B \f[CB]\-\-module\-source\-path\f[R] \f[I]module\-source\-path\f[R]
+Specifies where to find source files when compiling code in multiple
+modules.
+See [Compilation Modes] and \f[B]The Module Source Path Option\f[R].
+.RS
+.RE
+.TP
+.B \f[CB]\-\-module\-version\f[R] \f[I]version\f[R]
+Specifies the version of modules that are being compiled.
+.RS
+.RE
+.TP
+.B \f[CB]\-nowarn\f[R]
+Disables warning messages.
+This option operates the same as the \f[CB]\-Xlint:none\f[R] option.
+.RS
+.RE
+.TP
+.B \f[CB]\-parameters\f[R]
+Generates metadata for reflection on method parameters.
+Stores formal parameter names of constructors and methods in the
+generated class file so that the method
+\f[CB]java.lang.reflect.Executable.getParameters\f[R] from the Reflection
+API can retrieve them.
+.RS
+.RE
+.TP
+.B \f[CB]\-proc:\f[R][\f[CB]none\f[R], \f[CB]only\f[R]]
+Controls whether annotation processing and compilation are done.
+\f[CB]\-proc:none\f[R] means that compilation takes place without
+annotation processing.
+\f[CB]\-proc:only\f[R] means that only annotation processing is done,
+without any subsequent compilation.
+.RS
+.RE
+.TP
+.B \f[CB]\-processor\f[R] \f[I]class1\f[R][\f[CB],\f[R]\f[I]class2\f[R]\f[CB],\f[R]\f[I]class3\f[R]...]
+Names of the annotation processors to run.
+This bypasses the default discovery process.
+.RS
+.RE
+.TP
+.B \f[CB]\-\-processor\-module\-path\f[R] \f[I]path\f[R]
+Specifies the module path used for finding annotation processors.
+.RS
+.RE
+.TP
+.B \f[CB]\-\-processor\-path\f[R] \f[I]path\f[R] or \f[CB]\-processorpath\f[R] \f[I]path\f[R]
+Specifies where to find annotation processors.
+If this option is not used, then the class path is searched for
+processors.
+.RS
+.RE
+.TP
+.B \f[CB]\-profile\f[R] \f[I]profile\f[R]
+Checks that the API used is available in the specified profile.
+.RS
+.PP
+\f[B]Note:\f[R] This can only be used when compiling for releases prior
+to JDK 9.
+As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
+\f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
+details.
+.RE
+.TP
+.B \f[CB]\-\-release\f[R] \f[I]release\f[R]
+Compiles source code according to the rules of the Java programming
+language for the specified Java SE release, generating class files which
+target that release.
+Source code is compiled against the combined Java SE and JDK API for the
+specified release.
+.RS
+.PP
+The supported values of \f[I]release\f[R] are the current Java SE release
+and a limited number of previous releases, detailed in the command\-line
+help.
+.PP
+For the current release, the Java SE API consists of the
+\f[CB]java.*\f[R], \f[CB]javax.*\f[R], and \f[CB]org.*\f[R] packages that are
+exported by the Java SE modules in the release; the JDK API consists of
+the \f[CB]com.*\f[R] and \f[CB]jdk.*\f[R] packages that are exported by the
+JDK modules in the release, plus the \f[CB]javax.*\f[R] packages that are
+exported by standard, but non\-Java SE, modules in the release.
+.PP
+For previous releases, the Java SE API and the JDK API are as defined in
+that release.
+.PP
+\f[B]Note:\f[R] When using \f[CB]\-\-release\f[R], you cannot also use the
+\f[B]\f[BC]\-\-source\f[B]\f[R]/\f[CB]\-source\f[R] or
+\f[B]\f[BC]\-\-target\f[B]\f[R]/\f[CB]\-target\f[R] options.
+.PP
+\f[B]Note:\f[R] When using \f[CB]\-\-release\f[R] to specify a release that
+supports the Java Platform Module System, the \f[CB]\-\-add\-exports\f[R]
+option cannot be used to enlarge the set of packages exported by the
+Java SE, JDK, and standard modules in the specified release.
+.RE
+.TP
+.B \f[CB]\-s\f[R] \f[I]directory\f[R]
+Specifies the directory used to place the generated source files.
+If a class is part of a package, then the compiler puts the source file
+in a subdirectory that reflects the module name (if appropriate) and
+package name.
+The directory, and any necessary subdirectories, will be created if they
+do not already exist.
+.RS
+.PP
+Except when compiling code for multiple modules, the contents of the
+source output directory will be organized in a package hierarchy.
+When compiling code for multiple modules, the contents of the source
+output directory will be organized in a module hierarchy, with the
+contents of each module in a separate subdirectory, each organized as a
+package hierarchy.
+.RE
+.TP
+.B \f[CB]\-\-source\f[R] \f[I]release\f[R] or \f[CB]\-source\f[R] \f[I]release\f[R]
+Compiles source code according to the rules of the Java programming
+language for the specified Java SE release.
+The supported values of \f[I]release\f[R] are the current Java SE release
+and a limited number of previous releases, detailed in the command\-line
+help.
+.RS
+.PP
+If the option is not specified, the default is to compile source code
+according to the rules of the Java programming language for the current
+Java SE release.
+.RE
+.TP
+.B \f[CB]\-\-source\-path\f[R] \f[I]path\f[R] or \f[CB]\-sourcepath\f[R] \f[I]path\f[R]
+Specifies where to find source files.
+Except when compiling multiple modules together, this is the source code
+path used to search for class or interface definitions.
+.RS
+.PP
+\f[B]Note:\f[R] Classes found through the class path might be recompiled
+when their source files are also found.
+See \f[B]Searching for Module, Package and Type Declarations\f[R].
+.RE
+.TP
+.B \f[CB]\-\-system\f[R] \f[I]jdk\f[R] | \f[CB]none\f[R]
+Overrides the location of system modules.
+.RS
+.RE
+.TP
+.B \f[CB]\-\-target\f[R] \f[I]release\f[R] or \f[CB]\-target\f[R] \f[I]release\f[R]
+Generates \f[CB]class\f[R] files suitable for the specified Java SE
+release.
+The supported values of \f[I]release\f[R] are the current Java SE release
+and a limited number of previous releases, detailed in the command\-line
+help.
+.RS
+.PP
+\f[B]Note:\f[R] The target release must be equal to or higher than the
+source release.
+(See \f[B]\f[BC]\-\-source\f[B]\f[R].)
+.RE
+.TP
+.B \f[CB]\-\-upgrade\-module\-path\f[R] \f[I]path\f[R]
+Overrides the location of upgradeable modules.
+.RS
+.RE
+.TP
+.B \f[CB]\-verbose\f[R]
+Outputs messages about what the compiler is doing.
+Messages include information about each class loaded and each source
+file compiled.
+.RS
+.RE
+.TP
+.B \f[CB]\-\-version\f[R] or \f[CB]\-version\f[R]
+Prints version information.
+.RS
+.RE
+.TP
+.B \f[CB]\-Werror\f[R]
+Terminates compilation when warnings occur.
+.RS
+.RE
+.SS Extra Options
+.TP
+.B \f[CB]\-\-add\-exports\f[R] \f[I]module\f[R]\f[CB]/\f[R]\f[I]package\f[R]\f[CB]=\f[R]\f[I]other\-module\f[R](\f[CB],\f[R]\f[I]other\-module\f[R])*
+Specifies a package to be considered as exported from its defining
+module to additional modules or to all unnamed modules when the value of
+\f[I]other\-module\f[R] is \f[CB]ALL\-UNNAMED\f[R].
+.RS
+.RE
+.TP
+.B \f[CB]\-\-add\-reads\f[R] \f[I]module\f[R]\f[CB]=\f[R]\f[I]other\-module\f[R](\f[CB],\f[R]\f[I]other\-module\f[R])*
+Specifies additional modules to be considered as required by a given
+module.
+.RS
+.RE
+.TP
+.B \f[CB]\-\-default\-module\-for\-created\-files\f[R] \f[I]module\-name\f[R]
+Specifies the fallback target module for files created by annotation
+processors, if none is specified or inferred.
+.RS
+.RE
+.TP
+.B \f[CB]\-Djava.endorsed.dirs=\f[R]\f[I]dirs\f[R]
+Overrides the location of the endorsed standards path.
+.RS
+.PP
+\f[B]Note:\f[R] This can only be used when compiling for releases prior
+to JDK 9.
+As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
+\f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
+details.
+.RE
+.TP
+.B \f[CB]\-Djava.ext.dirs=\f[R]\f[I]dirs\f[R]
+Overrides the location of installed extensions.
+.RS
+.PP
+\f[B]Note:\f[R] This can only be used when compiling for releases prior
+to JDK 9.
+As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
+\f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
+details.
+.RE
+.TP
+.B \f[CB]\-\-doclint\-format\f[R] [\f[CB]html4\f[R]|\f[CB]html5\f[R]]
+Specifies the format for documentation comments.
+.RS
+.RE
+.TP
+.B \f[CB]\-\-patch\-module\f[R] \f[I]module\f[R]\f[CB]=\f[R]\f[I]path\f[R]
+Overrides or augments a module with classes and resources in JAR files
+or directories.
+.RS
+.RE
+.TP
+.B \f[CB]\-Xbootclasspath:\f[R]\f[I]path\f[R]
+Overrides the location of the bootstrap class files.
+.RS
+.PP
+\f[B]Note:\f[R] This can only be used when compiling for releases prior
+to JDK 9.
+As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
+\f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
+details.
+.RE
+.TP
+.B \f[CB]\-Xbootclasspath/a:\f[R]\f[I]path\f[R]
+Adds a suffix to the bootstrap class path.
+.RS
+.PP
+\f[B]Note:\f[R] This can only be used when compiling for releases prior
+to JDK 9.
+As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
+\f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
+details.
+.RE
+.TP
+.B \f[CB]\-Xbootclasspath/p:\f[R]\f[I]path\f[R]
+Adds a prefix to the bootstrap class path.
+.RS
+.PP
+\f[B]Note:\f[R] This can only be used when compiling for releases prior
+to JDK 9.
+As applicable, see the descriptions in \f[B]\f[BC]\-\-release\f[B]\f[R],
+\f[B]\f[BC]\-source\f[B]\f[R], or \f[B]\f[BC]\-target\f[B]\f[R] for
+details.
+.RE
+.TP
+.B \f[CB]\-Xdiags:\f[R][\f[CB]compact\f[R], \f[CB]verbose\f[R]]
+Selects a diagnostic mode.
+.RS
+.RE
+.TP
+.B \f[CB]\-Xdoclint\f[R]
+Enables recommended checks for problems in \f[CB]javadoc\f[R] comments
+.RS
+.RE
+.TP
+.B \f[CB]\-Xdoclint:\f[R](\f[CB]all\f[R]|\f[CB]none\f[R]|[\f[CB]\-\f[R]]\f[I]group\f[R])[\f[CB]/\f[R]\f[I]access\f[R]]
+Enables or disables specific groups of checks,
+.RS
+.PP
+\f[I]group\f[R] can have one of the following values:
+.IP \[bu] 2
+\f[CB]accessibility\f[R]
+.IP \[bu] 2
+\f[CB]html\f[R]
+.IP \[bu] 2
+\f[CB]missing\f[R]
+.IP \[bu] 2
+\f[CB]reference\f[R]
+.IP \[bu] 2
+\f[CB]syntax\f[R]
+.PP
+The variable \f[I]access\f[R] specifies the minimum visibility level of
+classes and members that the \f[CB]\-Xdoclint\f[R] option checks.
+It can have one of the following values (in order of most to least
+visible):
+.IP \[bu] 2
+\f[CB]public\f[R]
+.IP \[bu] 2
+\f[CB]protected\f[R]
+.IP \[bu] 2
+\f[CB]package\f[R]
+.IP \[bu] 2
+\f[CB]private\f[R]
+.PP
+The default \f[I]access\f[R] level is \f[CB]private\f[R].
+.PP
+For more information about these groups of checks, see the
+\f[CB]\-Xdoclint\f[R] option of the \f[CB]javadoc\f[R] command.
+The \f[CB]\-Xdoclint\f[R] option is disabled by default in the
+\f[CB]javac\f[R] command.
+.PP
+For example, the following option checks classes and members (with all
+groups of checks) that have the access level of protected and higher
+(which includes protected and public):
+.RS
+.PP
+\f[CB]\-Xdoclint:all/protected\f[R]
+.RE
+.PP
+The following option enables all groups of checks for all access levels,
+except it will not check for HTML errors for classes and members that
+have the access level of package and higher (which includes package,
+protected and public):
+.RS
+.PP
+\f[CB]\-Xdoclint:all,\-html/package\f[R]
+.RE
+.RE
+.TP
+.B \f[CB]\-Xdoclint/package:\f[R][\f[CB]\-\f[R]]\f[I]packages\f[R](\f[CB],\f[R][\f[CB]\-\f[R]]\f[I]package\f[R])*
+Enables or disables checks in specific packages.
+Each \f[I]package\f[R] is either the qualified name of a package or a
+package name prefix followed by \f[CB]\&.*\f[R], which expands to all
+sub\-packages of the given package.
+Each \f[I]package\f[R] can be prefixed with a hyphen (\f[CB]\-\f[R]) to
+disable checks for a specified package or packages.
+.RS
+.RE
+.TP
+.B \f[CB]\-Xlint\f[R]
+Enables all recommended warnings.
+In this release, enabling all available warnings is recommended.
+.RS
+.RE
+.TP
+.B \f[CB]\-Xlint:\f[R][\f[CB]\-\f[R]]\f[I]key\f[R](\f[CB],\f[R][\f[CB]\-\f[R]]\f[I]key\f[R])*
+Supplies warnings to enable or disable, separated by comma.
+Precede a key by a hyphen (\f[CB]\-\f[R]) to disable the specified
+warning.
+.RS
+.PP
+Supported values for \f[I]key\f[R] are:
+.IP \[bu] 2
+\f[CB]all\f[R]: Enables all warnings.
+.IP \[bu] 2
+\f[CB]auxiliaryclass\f[R]: Warns about an auxiliary class that\[aq]s
+hidden in a source file, and is used from other files.
+.IP \[bu] 2
+\f[CB]cast\f[R]: Warns about the use of unnecessary casts.
+.IP \[bu] 2
+\f[CB]classfile\f[R]: Warns about the issues related to classfile
+contents.
+.IP \[bu] 2
+\f[CB]deprecation\f[R]: Warns about the use of deprecated items.
+.IP \[bu] 2
+\f[CB]dep\-ann\f[R]: Warns about the items marked as deprecated in
+\f[CB]javadoc\f[R] but without the \f[CB]\@Deprecated\f[R] annotation.
+.IP \[bu] 2
+\f[CB]divzero\f[R]: Warns about the division by the constant integer 0.
+.IP \[bu] 2
+\f[CB]empty\f[R]: Warns about an empty statement after \f[CB]if\f[R].
+.IP \[bu] 2
+\f[CB]exports\f[R]: Warns about the issues regarding module exports.
+.IP \[bu] 2
+\f[CB]fallthrough\f[R]: Warns about the falling through from one case of a
+switch statement to the next.
+.IP \[bu] 2
+\f[CB]finally\f[R]: Warns about \f[CB]finally\f[R] clauses that do not
+terminate normally.
+.IP \[bu] 2
+\f[CB]module\f[R]: Warns about the module system\-related issues.
+.IP \[bu] 2
+\f[CB]opens\f[R]: Warns about the issues related to module opens.
+.IP \[bu] 2
+\f[CB]options\f[R]: Warns about the issues relating to use of command line
+options.
+.IP \[bu] 2
+\f[CB]overloads\f[R]: Warns about the issues related to method overloads.
+.IP \[bu] 2
+\f[CB]overrides\f[R]: Warns about the issues related to method overrides.
+.IP \[bu] 2
+\f[CB]path\f[R]: Warns about the invalid path elements on the command l
+ine.
+.IP \[bu] 2
+\f[CB]processing\f[R]: Warns about the issues related to annotation
+processing.
+.IP \[bu] 2
+\f[CB]rawtypes\f[R]: Warns about the use of raw types.
+.IP \[bu] 2
+\f[CB]removal\f[R]: Warns about the use of an API that has been marked for
+removal.
+.IP \[bu] 2
+\f[CB]requires\-automatic\f[R]: Warns developers about the use of
+automatic modules in requires clauses.
+.IP \[bu] 2
+\f[CB]requires\-transitive\-automatic\f[R]: Warns about automatic modules
+in requires transitive.
+.IP \[bu] 2
+\f[CB]serial\f[R]: Warns about the serializable classes that do not
+provide a serial version ID.
+Also warns about access to non\-public members from a serializable
+element.
+.IP \[bu] 2
+\f[CB]static\f[R]: Warns about the accessing a static member using an
+instance.
+.IP \[bu] 2
+\f[CB]try\f[R]: Warns about the issues relating to the use of try blocks (
+that is, try\-with\-resources).
+.IP \[bu] 2
+\f[CB]unchecked\f[R]: Warns about the unchecked operations.
+.IP \[bu] 2
+\f[CB]varargs\f[R]: Warns about the potentially unsafe \f[CB]vararg\f[R]
+methods.
+.IP \[bu] 2
+\f[CB]none\f[R]: Disables all warnings.
+.PP
+See \f[B]Examples of Using \-Xlint keys\f[R].
+.RE
+.TP
+.B \f[CB]\-Xmaxerrs\f[R] \f[I]number\f[R]
+Sets the maximum number of errors to print.
+.RS
+.RE
+.TP
+.B \f[CB]\-Xmaxwarns\f[R] \f[I]number\f[R]
+Sets the maximum number of warnings to print.
+.RS
+.RE
+.TP
+.B \f[CB]\-Xpkginfo:\f[R][\f[CB]always\f[R], \f[CB]legacy\f[R], \f[CB]nonempty\f[R]]
+Specifies when and how the \f[CB]javac\f[R] command generates
+\f[CB]package\-info.class\f[R] files from \f[CB]package\-info.java\f[R]
+files using one of the following options:
+.RS
+.TP
+.B \f[CB]always\f[R]
+Generates a \f[CB]package\-info.class\f[R] file for every
+\f[CB]package\-info.java\f[R] file.
+This option may be useful if you use a build system such as Ant, which
+checks that each \f[CB]\&.java\f[R] file has a corresponding
+\f[CB]\&.class\f[R] file.
+.RS
+.RE
+.TP
+.B \f[CB]legacy\f[R]
+Generates a \f[CB]package\-info.class\f[R] file only if
+\f[CB]package\-info.java\f[R] contains annotations.
+This option does not generate a \f[CB]package\-info.class\f[R] file if
+\f[CB]package\-info.java\f[R] contains only comments.
+.RS
+.PP
+\f[B]Note:\f[R] A \f[CB]package\-info.class\f[R] file might be generated
+but be empty if all the annotations in the \f[CB]package\-info.java\f[R]
+file have \f[CB]RetentionPolicy.SOURCE\f[R].
+.RE
+.TP
+.B \f[CB]nonempty\f[R]
+Generates a \f[CB]package\-info.class\f[R] file only if
+\f[CB]package\-info.java\f[R] contains annotations with
+\f[CB]RetentionPolicy.CLASS\f[R] or \f[CB]RetentionPolicy.RUNTIME\f[R].
+.RS
+.RE
+.RE
+.TP
+.B \f[CB]\-Xplugin:\f[R]\f[I]name\f[R] \f[I]args\f[R]
+Specifies the name and optional arguments for a plug\-in to be run.
+If \f[I]args\f[R] are provided, \f[I]name\f[R] and \f[I]args\f[R] should be
+quoted or otherwise escape the whitespace characters between the name
+and all the arguments.
+For details on the API for a plugin, see the API documentation for
+\f[B]jdk.compiler/com.sun.source.util.Plugin\f[R].
+.RS
+.RE
+.TP
+.B \f[CB]\-Xprefer:\f[R][\f[CB]source\f[R], \f[CB]newer\f[R]]
+Specifies which file to read when both a source file and class file are
+found for an implicitly compiled class using one of the following
+options.
+See \f[B]Searching for Module, Package and Type Declarations\f[R].
+.RS
+.IP \[bu] 2
+\f[CB]\-Xprefer:newer\f[R]: Reads the newer of the source or class files
+for a type (default).
+.IP \[bu] 2
+\f[CB]\-Xprefer:source\f[R] : Reads the source file.
+Use \f[CB]\-Xprefer:source\f[R] when you want to be sure that any
+annotation processors can access annotations declared with a retention
+policy of \f[CB]SOURCE\f[R].
+.RE
+.TP
+.B \f[CB]\-Xprint\f[R]
+Prints a textual representation of specified types for debugging
+purposes.
+This does not perform annotation processing or compilation.
+The format of the output could change.
+.RS
+.RE
+.TP
+.B \f[CB]\-XprintProcessorInfo\f[R]
+Prints information about which annotations a processor is asked to
+process.
+.RS
+.RE
+.TP
+.B \f[CB]\-XprintRounds\f[R]
+Prints information about initial and subsequent annotation processing
+rounds.
+.RS
+.RE
+.TP
+.B \f[CB]\-Xstdout\f[R] \f[I]filename\f[R]
+Sends compiler messages to the named file.
+By default, compiler messages go to \f[CB]System.err\f[R].
+.RS
+.RE
+.SH ENVIRONMENT VARIABLES
+.SS CLASSPATH
+.PP
+If the \f[B]\f[BC]\-\-class\-path\f[B]\f[R] option or any of its
+alternate forms are not specified, the class path will default to the
+value of the \f[CB]CLASSPATH\f[R] environment variable if it is set.
+However, it is recommended that this environment variable should
+\f[I]not\f[R] be set, and that the \f[CB]\-\-class\-path\f[R] option should
+be used to provide an explicit value for the class path when one is
+required.
+.SS JDK_JAVAC_OPTIONS
+.PP
+The content of the \f[CB]JDK_JAVAC_OPTIONS\f[R] environment variable,
+separated by white\-spaces ( ) or white\-space characters (\f[CB]\\n\f[R],
+\f[CB]\\t\f[R], \f[CB]\\r\f[R], or \f[CB]\\f\f[R]) is prepended to the command
+line arguments passed to \f[CB]javac\f[R] as a list of arguments.
+.PP
+The encoding requirement for the environment variable is the same as the
+\f[CB]javac\f[R] command line on the system.
+\f[CB]JDK_JAVAC_OPTIONS\f[R] environment variable content is treated in
+the same manner as that specified in the command line.
+.PP
+Single quotes (\f[CB]\[aq]\f[R]) or double quotes (\f[CB]"\f[R]) can be used
+to enclose arguments that contain whitespace characters.
+All content between the open quote and the first matching close quote
+are preserved by simply removing the pair of quotes.
+In case a matching quote is not found, the launcher will abort with an
+error message.
+\f[CB]\@\f[R]\f[I]files\f[R] are supported as they are specified in the
+command line.
+However, as in \f[CB]\@\f[R]\f[I]files\f[R], use of a wildcard is not
+supported.
+.PP
+\f[B]Examples of quoting arguments containing white spaces:\f[R]
+.RS
+.PP
+\f[CB]export\ JDK_JAVAC_OPTIONS=\[aq]\@"C:\\white\ spaces\\argfile"\[aq]\f[R]
+.RE
+.RS
+.PP
+\f[CB]export\ JDK_JAVAC_OPTIONS=\[aq]"\@C:\\white\ spaces\\argfile"\[aq]\f[R]
+.RE
+.RS
+.PP
+\f[CB]export\ JDK_JAVAC_OPTIONS=\[aq]\@C:\\"white\ spaces"\\argfile\[aq]\f[R]
+.RE
+.SH COMMAND\-LINE ARGUMENT FILES
+.PP
+An argument file can include command\-line options and source file names
+in any combination.
+The arguments within a file can be separated by spaces or new line
+characters.
+If a file name contains embedded spaces, then put the whole file name in
+double quotation marks.
+.PP
+File names within an argument file are relative to the current
+directory, not to the location of the argument file.
+Wildcards (\f[CB]*\f[R]) are not allowed in these lists (such as for
+specifying \f[CB]*.java\f[R]).
+Use of the at sign (\f[CB]\@\f[R]) to recursively interpret files is not
+supported.
+The \f[CB]\-J\f[R] options are not supported because they\[aq]re passed to
+the launcher, which does not support argument files.
+.PP
+When executing the \f[CB]javac\f[R] command, pass in the path and name of
+each argument file with the at sign (\f[CB]\@\f[R]) leading character.
+When the \f[CB]javac\f[R] command encounters an argument beginning with
+the at sign (\f[CB]\@\f[R]), it expands the contents of that file into the
+argument list.
+.SS Examples of Using javac \@filename
+.TP
+.B Single Argument File
+You could use a single argument file named \f[CB]argfile\f[R] to hold all
+\f[CB]javac\f[R] arguments:
+.RS
+.RS
+.PP
+\f[CB]javac\ \@argfile\f[R]
+.RE
+.PP
+This argument file could contain the contents of both files shown in the
+following \f[B]Two Argument Files\f[R] example.
+.RE
+.TP
+.B Two Argument Files
+You can create two argument files: one for the \f[CB]javac\f[R] options
+and the other for the source file names.
+Note that the following lists have no line\-continuation characters.
+.RS
+.PP
+Create a file named \f[CB]options\f[R] that contains the following:
+.PP
+\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+.IP
+.nf
+\f[CB]
+\-d\ classes
+\-g
+\-sourcepath\ /java/pubs/ws/1.3/src/share/classes
+\f[R]
+.fi
+.PP
+\f[B]Windows:\f[R]
+.IP
+.nf
+\f[CB]
+\-d\ classes
+\-g
+\-sourcepath\ C:\\java\\pubs\\ws\\1.3\\src\\share\\classes
+\f[R]
+.fi
+.PP
+Create a file named \f[CB]classes\f[R] that contains the following:
+.IP
+.nf
+\f[CB]
+MyClass1.java
+MyClass2.java
+MyClass3.java
+\f[R]
+.fi
+.PP
+Then, run the \f[CB]javac\f[R] command as follows:
+.RS
+.PP
+\f[CB]javac\ \@options\ \@classes\f[R]
+.RE
+.RE
+.TP
+.B Argument Files with Paths
+The argument files can have paths, but any file names inside the files
+are relative to the current working directory (not \f[CB]path1\f[R] or
+\f[CB]path2\f[R]):
+.RS
+.RS
+.PP
+\f[CB]javac\ \@path1/options\ \@path2/classes\f[R]
+.RE
+.RE
+.SH ARRANGEMENT OF SOURCE CODE
+.PP
+In the Java language, classes and interfaces can be organized into
+packages, and packages can be organized into modules.
+\f[CB]javac\f[R] expects that the physical arrangement of source files in
+directories of the file system will mirror the organization of classes
+into packages, and packages into modules.
+.PP
+It is a widely adopted convention that module names and package names
+begin with a lower\-case letter, and that class names begin with an
+upper\-case letter.
+.SS Arrangement of Source Code for a Package
+.PP
+When classes and interfaces are organized into a package, the package is
+represented as a directory, and any subpackages are represented as
+subdirectories.
+.PP
+For example:
+.IP \[bu] 2
+The package \f[CB]p\f[R] is represented as a directory called \f[CB]p\f[R].
+.IP \[bu] 2
+The package \f[CB]p.q\f[R] \-\- that is, the subpackage \f[CB]q\f[R] of
+package \f[CB]p\f[R] \-\- is represented as the subdirectory \f[CB]q\f[R] of
+directory \f[CB]p\f[R].
+The directory tree representing package \f[CB]p.q\f[R] is therefore
+\f[CB]p\\q\f[R] on Windows, and \f[CB]p/q\f[R] on other systems.
+.IP \[bu] 2
+The package \f[CB]p.q.r\f[R] is represented as the directory tree
+\f[CB]p\\q\\r\f[R] (on Windows) or \f[CB]p/q/r\f[R] (on other systems).
+.PP
+Within a directory or subdirectory, \f[CB]\&.java\f[R] files represent
+classes and interfaces in the corresponding package or subpackage.
+.PP
+For example:
+.IP \[bu] 2
+The class \f[CB]X\f[R] declared in package \f[CB]p\f[R] is represented by
+the file \f[CB]X.java\f[R] in the \f[CB]p\f[R] directory.
+.IP \[bu] 2
+The class \f[CB]Y\f[R] declared in package \f[CB]p.q\f[R] is represented by
+the file \f[CB]Y.java\f[R] in the \f[CB]q\f[R] subdirectory of directory
+\f[CB]p\f[R].
+.IP \[bu] 2
+The class \f[CB]Z\f[R] declared in package \f[CB]p.q.r\f[R] is represented
+by the file \f[CB]Z.java\f[R] in the \f[CB]r\f[R] subdirectory of
+\f[CB]p\\q\f[R] (on Windows) or \f[CB]p/q\f[R] (on other systems).
+.PP
+In some situations, it is convenient to split the code into separate
+directories, each structured as described above, and the aggregate list
+of directories specified to \f[CB]javac\f[R].
+.SS Arrangement of Source Code for a Module
+.PP
+In the Java language, a module is a set of packages designed for reuse.
+In addition to \f[CB]\&.java\f[R] files for classes and interfaces, each
+module has a source file called \f[CB]module\-info.java\f[R] which:
+.IP "1." 3
+declares the module\[aq]s name;
+.IP "2." 3
+lists the packages exported by the module (to allow reuse by other
+modules);
+.IP "3." 3
+lists other modules required by the module (to reuse their exported
+packages).
+.PP
+When packages are organized into a module, the module is represented by
+one or more directories representing the packages in the module, one of
+which contains the \f[CB]module\-info.java\f[R] file.
+It may be convenient, but it is not required, to use a single directory,
+named after the module, to contain the \f[CB]module\-info.java\f[R] file
+alongside the directory tree which represents the packages in the module
+(i.e., the \f[I]package hierarchy\f[R] described above).
+The exact arrangement of source code for a module is typically dictated
+by the conventions adopted by a development environment (IDE) or build
+system.
+.PP
+For example:
+.IP \[bu] 2
+The module \f[CB]a.b.c\f[R] may be represented by the directory
+\f[CB]a.b.c\f[R], on all systems.
+.IP \[bu] 2
+The module\[aq]s declaration is represented by the file
+\f[CB]module\-info.java\f[R] in the \f[CB]a.b.c\f[R] directory.
+.IP \[bu] 2
+If the module contains package \f[CB]p.q.r\f[R], then the \f[CB]a.b.c\f[R]
+directory contains the directory tree \f[CB]p\\q\\r\f[R] (on Windows) or
+\f[CB]p/q/r\f[R] (on other systems).
+.PP
+The development environment may prescribe some directory hierarchy
+between the directory named for the module and the source files to be
+read by \f[CB]javac\f[R].
+.PP
+For example:
+.IP \[bu] 2
+The module \f[CB]a.b.c\f[R] may be represented by the directory
+\f[CB]a.b.c\f[R]
+.IP \[bu] 2
+The module\[aq]s declaration and the module\[aq]s packages may be in
+some subdirectory of \f[CB]a.b.c\f[R], such as \f[CB]src\\main\\java\f[R]
+(on Windows) or \f[CB]src/main/java\f[R] (on other systems).
+.SH CONFIGURING A COMPILATION
+.PP
+This section describes how to configure \f[CB]javac\f[R] to perform a
+basic compilation.
+.PP
+See \f[B]Configuring the Module System\f[R] for additional details for
+use when compiling for a release of the platform that supports modules.
+.SS Source Files
+.IP \[bu] 2
+Specify the source files to be compiled on the command line.
+.PP
+If there are no compilation errors, the corresponding class files will
+be placed in the \f[B]output directory\f[R].
+.PP
+Some systems may limit the amount you can put on a command line; to work
+around those limits, you can use \f[B]argument files\f[R].
+.PP
+When compiling code for modules, you can also specify source files
+indirectly, by using the \f[B]\f[BC]\-\-module\f[B]\f[R] or \f[CB]\-m\f[R]
+option.
+.SS Output Directory
+.IP \[bu] 2
+Use the \f[B]\f[BC]\-d\f[B]\f[R] option to specify an output directory in
+which to put the compiled class files.
+.PP
+This will normally be organized in a \f[B]package hierarchy\f[R], unless
+you are compiling source code from multiple modules, in which case it
+will be organized as a \f[B]module hierarchy\f[R].
+.PP
+When the compilation has been completed, if you are compiling one or
+more modules, you can place the output directory on the module path for
+the Java \f[B]launcher\f[R]; otherwise, you can place the place the
+output directory on the class path for the Java launcher.
+.SS Precompiled Code
+.PP
+The code to be compiled may refer to libraries beyond what is provided
+by the platform.
+If so, you must place these libraries on the class path or module path.
+If the library code is not in a module, place it on the class path; if
+it is in a module, place it on the module path.
+.IP \[bu] 2
+Use the \f[B]\f[BC]\-\-class\-path\f[B]\f[R] option to specify libraries
+to be placed on the class path.
+Locations on the class path should be organized in a \f[B]package
+hierarchy\f[R].
+You can also use alternate forms of the option: \f[CB]\-classpath\f[R] or
+\f[CB]\-cp\f[R].
+.IP \[bu] 2
+Use the \f[B]\f[BC]\-\-module\-path\f[B]\f[R] option to specify libraries
+to be placed on the module path.
+Locations on the module path should either be modules or directories of
+modules.
+You can also use an alternate form of the option: \f[CB]\-p\f[R].
+.RS 2
+.PP
+See \f[B]Configuring the Module System\f[R] for details on how to modify
+the default configuration of library modules.
+.RE
+.PP
+\f[B]Note\f[R]: the options for the class path and module path are not
+mutually exclusive, although it is not common to specify the class path
+when compiling code for one or more modules.
+.SS Additional Source Files
+.PP
+The code to be compiled may refer to types in additional source files
+that are not specified on the command line.
+If so, you must put those source files on either the source path or
+module path.
+You can only specify one of these options: if you are not compiling code
+for a module, or if you are only compiling code for a single module, use
+the source path; if you are compiling code for multiple modules, use the
+module source path.
+.IP \[bu] 2
+Use the \f[B]\f[BC]\-\-source\-path\f[B]\f[R] option to specify the
+locations of additional source files that may be read by javac.
+Locations on the source path should be organized in a \f[B]package
+hierarchy\f[R].
+You can also use an alternate form of the option: \f[CB]\-sourcepath\f[R].
+.IP \[bu] 2
+Use the \f[B]\f[BC]\-\-module\-source\-path\f[B]\f[R] option one or more
+times to specify the location of additional source files in different
+modules that may be read by javac, or when compiling source files in
+multiple modules.
+You can either specify the locations for each module
+\f[B]individually\f[R], or you can organize the source files so that you
+can specify the locations all \f[B]together\f[R].
+For more details, see \f[B]The Module Source Path Option\f[R].
+.PP
+If you want to be able to refer to types in additional source files but
+do not want them to be compiled, use the \f[B]\f[BC]\-implicit\f[B]\f[R]
+option.
+.PP
+\f[B]Note\f[R]: if you are compiling code for multiple modules, you must
+always specify a module source path, and all source files specified on
+the command line must be in one of the directories on the module source
+path, or in a subdirectory thereof.
+.SS Example of Compiling Multiple Source Files
+.PP
+This example compiles the \f[CB]Aloha.java\f[R], \f[CB]GutenTag.java\f[R],
+\f[CB]Hello.java\f[R], and \f[CB]Hi.java\f[R] source files in the
+\f[CB]greetings\f[R] package.
+.PP
+\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+.IP
+.nf
+\f[CB]
+%\ javac\ greetings/*.java
+%\ ls\ greetings
+Aloha.class\ \ \ \ \ \ \ \ \ GutenTag.class\ \ \ \ \ \ Hello.class\ \ \ \ \ \ \ \ \ Hi.class
+Aloha.java\ \ \ \ \ \ \ \ \ \ GutenTag.java\ \ \ \ \ \ \ Hello.java\ \ \ \ \ \ \ \ \ \ Hi.java
+\f[R]
+.fi
+.PP
+\f[B]Windows:\f[R]
+.IP
+.nf
+\f[CB]
+C:\\>javac\ greetings\\*.java
+C:\\>dir\ greetings
+Aloha.class\ \ \ \ \ \ \ \ \ GutenTag.class\ \ \ \ \ \ Hello.class\ \ \ \ \ \ \ \ \ Hi.class
+Aloha.java\ \ \ \ \ \ \ \ \ \ GutenTag.java\ \ \ \ \ \ \ Hello.java\ \ \ \ \ \ \ \ \ \ Hi.java
+\f[R]
+.fi
+.SS Example of Specifying a User Class Path
+.PP
+After changing one of the source files in the previous example,
+recompile it:
+.PP
+\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+.IP
+.nf
+\f[CB]
+pwd
+/examples
+javac\ greetings/Hi.java
+\f[R]
+.fi
+.PP
+\f[B]Windows:\f[R]
+.IP
+.nf
+\f[CB]
+C:\\>cd
+\\examples
+C:\\>javac\ greetings\\Hi.java
+\f[R]
+.fi
+.PP
+Because \f[CB]greetings.Hi\f[R] refers to other classes in the
+\f[CB]greetings\f[R] package, the compiler needs to find these other
+classes.
+The previous example works because the default user class path is the
+directory that contains the package directory.
+If you want to recompile this file without concern for which directory
+you are in, then add the examples directory to the user class path by
+setting \f[CB]CLASSPATH\f[R].
+This example uses the \f[CB]\-classpath\f[R] option.
+.PP
+\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+.RS
+.PP
+\f[CB]javac\ \-classpath\ /examples\ /examples/greetings/Hi.java\f[R]
+.RE
+.PP
+\f[B]Windows:\f[R]
+.RS
+.PP
+\f[CB]C:\\>javac\ \-classpath\ \\examples\ \\examples\\greetings\\Hi.java\f[R]
+.RE
+.PP
+If you change \f[CB]greetings.Hi\f[R] to use a banner utility, then that
+utility also needs to be accessible through the user class path.
+.PP
+\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+.IP
+.nf
+\f[CB]
+javac\ \-classpath\ /examples:/lib/Banners.jar\ \\
+\ \ \ \ \ \ \ \ \ \ \ \ /examples/greetings/Hi.java
+\f[R]
+.fi
+.PP
+\f[B]Windows:\f[R]
+.IP
+.nf
+\f[CB]
+C:\\>javac\ \-classpath\ \\examples;\\lib\\Banners.jar\ ^
+\ \ \ \ \ \ \ \ \ \ \ \ \\examples\\greetings\\Hi.java
+\f[R]
+.fi
+.PP
+To execute a class in the \f[CB]greetings\f[R] package, the program needs
+access to the \f[CB]greetings\f[R] package, and to the classes that the
+\f[CB]greetings\f[R] classes use.
+.PP
+\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+.RS
+.PP
+\f[CB]java\ \-classpath\ /examples:/lib/Banners.jar\ greetings.Hi\f[R]
+.RE
+.PP
+\f[B]Windows:\f[R]
+.RS
+.PP
+\f[CB]C:\\>java\ \-classpath\ \\examples;\\lib\\Banners.jar\ greetings.Hi\f[R]
+.RE
+.SH CONFIGURING THE MODULE SYSTEM
+.PP
+If you want to include additional modules in your compilation, use the
+\f[B]\f[BC]\-\-add\-modules\f[B]\f[R] option.
+This may be necessary when you are compiling code that is not in a
+module, or which is in an automatic module, and the code refers to API
+in the additional modules.
+.PP
+If you want to restrict the set of modules in your compilation, use the
+\f[B]\f[BC]\-\-limit\-modules\f[B]\f[R] option.
+This may be useful if you want to ensure that the code you are compiling
+is capable of running on a system with a limited set of modules
+installed.
+.PP
+If you want to break encapsulation and specify that additional packages
+should be considered as exported from a module, use the
+\f[B]\f[BC]\-\-add\-exports\f[B]\f[R] option.
+This may be useful when performing white\-box testing; relying on access
+to internal API in production code is strongly discouraged.
+.PP
+If you want to specify that additional packages should be considered as
+required by a module, use the \f[B]\f[BC]\-\-add\-reads\f[B]\f[R] option.
+This may be useful when performing white\-box testing; relying on access
+to internal API in production code is strongly discouraged.
+.PP
+You can patch additional content into any module using the
+\f[B]\f[BC]\-\-patch\-module\f[B]\f[R] option.
+See [Patching a Module] for more details.
+.SH SEARCHING FOR MODULE, PACKAGE AND TYPE DECLARATIONS
+.PP
+To compile a source file, the compiler often needs information about a
+module or type, but the declaration is not in the source files specified
+on the command line.
+.PP
+\f[CB]javac\f[R] needs type information for every class or interface used,
+extended, or implemented in the source file.
+This includes classes and interfaces not explicitly mentioned in the
+source file, but that provide information through inheritance.
+.PP
+For example, when you create a subclass of \f[CB]java.awt.Window\f[R], you
+are also using the ancestor classes of \f[CB]Window\f[R]:
+\f[CB]java.awt.Container\f[R], \f[CB]java.awt.Component\f[R], and
+\f[CB]java.lang.Object\f[R].
+.PP
+When compiling code for a module, the compiler also needs to have
+available the declaration of that module.
+.PP
+A successful search may produce a class file, a source file, or both.
+If both are found, then you can use the \f[B]\f[BC]\-Xprefer\f[B]\f[R]
+option to instruct the compiler which to use.
+.PP
+If a search finds and uses a source file, then by default \f[CB]javac\f[R]
+compiles that source file.
+This behavior can be altered with \f[B]\f[BC]\-implicit\f[B]\f[R].
+.PP
+The compiler might not discover the need for some type information until
+after annotation processing completes.
+When the type information is found in a source file and no
+\f[B]\f[BC]\-implicit\f[B]\f[R] option is specified, the compiler gives a
+warning that the file is being compiled without being subject to
+annotation processing.
+To disable the warning, either specify the file on the command line (so
+that it will be subject to annotation processing) or use the
+\f[B]\f[BC]\-implicit\f[B]\f[R] option to specify whether or not class
+files should be generated for such source files.
+.PP
+The way that \f[CB]javac\f[R] locates the declarations of those types
+depends on whether the reference exists within code for a module or not.
+.SS Searching Package Oriented Paths
+.PP
+When searching for a source or class file on a path composed of package
+oriented locations, \f[CB]javac\f[R] will check each location on the path
+in turn for the possible presence of the file.
+The first occurrence of a particular file shadows (hides) any subsequent
+occurrences of like\-named files.
+This shadowing does not affect any search for any files with a different
+name.
+This can be convenient when searching for source files, which may be
+grouped in different locations, such as shared code, platform\-specific
+code and generated code.
+It can also be useful when injecting alternate versions of a class file
+into a package, to debugging or other instrumentation reasons.
+But, it can also be dangerous, such as when putting incompatible
+different versions of a library on the class path.
+.SS Searching Module Oriented Paths
+.PP
+Prior to scanning any module paths for any package or type declarations,
+\f[CB]javac\f[R] will lazily scan the following paths and locations to
+determine the modules that will be used in the compilation.
+.IP \[bu] 2
+The module source path (see the
+\f[B]\f[BC]\-\-module\-source\-path\f[B]\f[R] option)
+.IP \[bu] 2
+The path for upgradeable modules (see the
+\f[B]\f[BC]\-\-upgrade\-module\-path\f[B]\f[R] option)
+.IP \[bu] 2
+The system modules (see the \f[B]\f[BC]\-\-system\f[B]\f[R] option)
+.IP \[bu] 2
+The user module path ( see the \f[B]\f[BC]\-\-module\-path\f[B]\f[R]
+option)
+.PP
+For any module, the first occurrence of the module during the scan
+completely shadows (hides) any subsequent appearance of a like\-named
+module.
+While locating the modules, \f[CB]javac\f[R] is able to determine the
+packages exported by the module and to associate with each module a
+package oriented path for the contents of the module.
+For any previously compiled module, this path will typically be a single
+entry for either a directory or a file that provides an internal
+directory\-like hierarchy, such as a JAR file.
+Thus, when searching for a type that is in a package that is known to be
+exported by a module, \f[CB]javac\f[R] can locate the declaration directly
+and efficiently.
+.SS Searching for the Declaration of a Module
+.PP
+If the module has been previously compiled, the module declaration is
+located in a file named \f[CB]module\-info.class\f[R] in the root of the
+package hierarchy for the content of the module.
+.PP
+If the module is one of those currently being compiled, the module
+declaration will be either the file named \f[CB]module\-info.class\f[R] in
+the root of the package hierarchy for the module in the class output
+directory, or the file named \f[CB]module\-info.java\f[R] in one of the
+locations on the source path or one the module source path for the
+module.
+.SS Searching for the Declaration of a Type When the Reference is not in
+a Module
+.PP
+When searching for a type that is referenced in code that is not in a
+module, \f[CB]javac\f[R] will look in the following places:
+.IP \[bu] 2
+The platform classes (or the types in exported packages of the platform
+modules) (This is for compiled class files only.)
+.IP \[bu] 2
+Types in exported packages of any modules on the module path, if
+applicable.
+(This is for compiled class files only.)
+.IP \[bu] 2
+Types in packages on the class path and/or source path:
+.RS 2
+.IP \[bu] 2
+If both are specified, \f[CB]javac\f[R] looks for compiled class files on
+the class path and for source files on the source path.
+.IP \[bu] 2
+If the class path is specified, but not source path, \f[CB]javac\f[R]
+looks for both compiled class files and source files on the class path.
+.IP \[bu] 2
+If the class path is not specified, it defaults to the current
+directory.
+.RE
+.PP
+When looking for a type on the class path and/or source path, if both a
+compiled class file and a source file are found, the most recently
+modified file will be used by default.
+If the source file is newer, it will be compiled and will may override
+any previously compiled version of the file.
+You can use the \f[B]\f[BC]\-Xprefer\f[B]\f[R] option to override the
+default behavior.
+.SS Searching for the Declaration of a Type When the Reference is in a
+Module
+.PP
+When searching for a type that is referenced in code in a module,
+\f[CB]javac\f[R] will examine the declaration of the enclosing module to
+determine if the type is in a package that is exported from another
+module that is readable by the enclosing module.
+If so, \f[CB]javac\f[R] will simply and directly go to the definition of
+that module to find the definition of the required type.
+Unless the module is another of the modules being compiled,
+\f[CB]javac\f[R] will only look for compiled class files files.
+In other words, \f[CB]javac\f[R] will not look for source files in
+platform modules or modules on the module path.
+.PP
+If the type being referenced is not in some other readable module,
+\f[CB]javac\f[R] will examine the module being compiled to try and find
+the declaration of the type.
+\f[CB]javac\f[R] will look for the declaration of the type as follows:
+.IP \[bu] 2
+Source files specified on the command line or on the source path or
+module source path.
+.IP \[bu] 2
+Previously compiled files in the output directory.
+.SH DIRECTORY HIERARCHIES
+.PP
+\f[CB]javac\f[R] generally assumes that source files and compiled class
+files will be organized in a file system directory hierarchy or in a
+type of file that supports in an internal directory hierarchy, such as a
+JAR file.
+Three different kinds of hierarchy are supported: a \f[I]package
+hierarchy\f[R], a \f[I]module hierarchy\f[R], and a \f[I]module source
+hierarchy\f[R].
+.PP
+While \f[CB]javac\f[R] is fairly relaxed about the organization of source
+code, beyond the expectation that source will be organized in one or
+package hierarchies, and can generally accomodate organizations
+prescribed by development environments and build tools, Java tools in
+general, and \f[CB]javac\f[R] and the Java launcher in particular, are
+more stringent regarding the organization of compiled class files, and
+will be organized in package hierarchies or module hierarchies, as
+appropriate.
+.PP
+The location of these hierarchies are specified to \f[CB]javac\f[R] with
+command\-line options, whose names typically end in "path", like
+\f[B]\f[BC]\-\-source\-path\f[B]\f[R] or
+\f[B]\f[BC]\-\-class\-path\f[B]\f[R].
+Also as a general rule, path options whose name includes the word
+\f[CB]module\f[R], like \f[B]\f[BC]\-\-module\-path\f[B]\f[R], are used to
+specify module hierarchies, although some module\-related path options
+allow a package hierarchy to be specified on a per\-module basis.
+All other path options are used to specify package hierarchies.
+.SS Package Hierarchy
+.PP
+In a package hierarchy, directories and subdirectories are used to
+represent the component parts of the package name, with the source file
+or compiled class file for a type being stored as a file with an
+extension of \f[CB]\&.java\f[R] or \f[CB]\&.class\f[R] in the most nested
+directory.
+.PP
+For example, in a package hierarchy, the source file for a class
+\f[CB]com.example.MyClass\f[R] will be stored in the file
+\f[I]com/example/MyClass.java\f[R]
+.SS Module Hierarchy
+.PP
+In a module hierarchy, the first level of directories are named for the
+modules in the hierarchy; within each of those directories the contents
+of the module are organized in package hierarchies.
+.PP
+For example, in a module hierarchy, the compiled class file for a type
+called \f[CB]com.example.MyClass\f[R] in a module called
+\f[CB]my.library\f[R] will be stored in
+\f[I]my.library/com/example/MyClass.class\f[R].
+.PP
+The various output directories used by \f[CB]javac\f[R] (the class output
+directory, the source output directory, and native header output
+directory) will all be organized in a module hierarchy when multiple
+modules are being compiled.
+.SS Module Source Hierarchy
+.PP
+Although the source for each individual module should always be
+organized in a package hierarchy, it may be convenient to group those
+hierarchies into a module source hierarchy.
+This is similar to a module hierarchy, except that there may be
+intervening directories between the directory for the module and the
+directory that is the root of the package hierarchy for the source code
+of the module.
+.PP
+For example, in a module source hierarchy, the source file for a type
+called \f[CB]com.example.MyClass\f[R] in a module called
+\f[CB]my.library\f[R] may be stored in a file such as
+\f[I]my.library/src/main/java/com/example/MyClass.java\f[R].
+.SH THE MODULE SOURCE PATH OPTION
+.PP
+The \f[B]\f[BC]\-\-module\-source\-path\f[B]\f[R] option has two forms: a
+\f[I]module\-specific form\f[R], in which a package path is given for
+each module containing code to be compiled, and a
+\f[I]module\-pattern\f[R] form, in which the source path for each module
+is specified by a pattern.
+The module\-specific form is generally simpler to use when only a small
+number of modules are involved; the module\-pattern form may be more
+convenient when the number of modules is large and the modules are
+organized in a regular manner that can be described by a pattern.
+.PP
+Multiple instances of the \f[CB]\-\-module\-source\-path\f[R] option may
+be given, each one using either the module\-pattern form or the
+module\-specific form, subject to the following limitations:
+.IP \[bu] 2
+the module\-pattern form may be used at most once
+.IP \[bu] 2
+the module\-specific form may be used at most once for any given module
+.PP
+If the module\-specific form is used for any module, the associated
+search path overrides any path that might otherwise have been inferred
+from the module\-pattern form.
+.SS Module\-specific form
+.PP
+The module\-specific form allows an explicit search path to be given for
+any specific module.
+This form is:
+.IP \[bu] 2
+\f[CB]\-\-module\-source\-path\f[R]
+\f[I]module\-name\f[R]\f[CB]=\f[R]\f[I]file\-path\f[R]
+(\f[I]path\-separator\f[R] \f[I]file\-path\f[R])*
+.PP
+The path separator character is \f[CB];\f[R] on Windows, and \f[CB]:\f[R]
+otherwise.
+.PP
+\f[B]Note:\f[R] this is similar to the form used for the
+\f[B]\f[BC]\-\-patch\-module\f[B]\f[R] option.
+.SS Module\-pattern form
+.PP
+The module\-pattern form allows a concise specification of the module
+source path for any number of modules organized in regular manner.
+.IP \[bu] 2
+\f[CB]\-\-module\-source\-path\f[R] \f[I]pattern\f[R]
+.PP
+The pattern is defined by the following rules, which are applied in
+order:
+.IP \[bu] 2
+The argument is considered to be a series of segments separated by the
+path separator character (\f[CB];\f[R] on Windows, and \f[CB]:\f[R]
+otherwise).
+.IP \[bu] 2
+Each segment containing curly braces of the form
+.RS 2
+.IP
+.nf
+\f[CB]
+string1{alt1\ (\ ,alt2\ )*\ }\ string2
+\f[R]
+.fi
+.PP
+is considered to be replaced by a series of segments formed by
+"expanding" the braces:
+.IP
+.nf
+\f[CB]
+string1\ alt1\ string2
+string1\ alt2\ string2
+and\ so\ on...
+\f[R]
+.fi
+.PP
+The braces may be nested.
+.PP
+This rule is applied for all such usages of braces.
+.RE
+.IP \[bu] 2
+Each segment must have at most one asterisk (\f[CB]*\f[R]).
+If a segment does not contain an asterisk, it is considered to be as
+though the file separator character and an asterisk are appended.
+.RS 2
+.PP
+For any module \f[I]M\f[R], the source path for that module is formed
+from the series of segments obtained by substituting the module name
+\f[I]M\f[R] for the asterisk in each segment.
+.PP
+\f[B]Note\f[R]: in this context, the asterisk is just used as a special
+marker, to denote the position in the path of the module name.
+It should not be confused with the use of \f[CB]*\f[R] as a file name
+wildcard character, as found on most operating systems.
+.RE
+.SH PATCHING MODULES
+.PP
+javac allows any content, whether in source or compiled form, to be
+patched into any module using the \f[B]\f[BC]\-\-patch\-module\f[B]\f[R]
+option.
+You may want to do this to compile alternative implementations of a
+class to be patched at runtime into a JVM, or to inject additional
+classes into the module, such as when testing.
+.PP
+The form of the option is:
+.IP \[bu] 2
+\f[CB]\-\-patch\-module\f[R]
+\f[I]module\-name\f[R]\f[CB]=\f[R]\f[I]file\-path\f[R]
+(\f[I]path\-separator\f[R] \f[I]file\-path\f[R] )*
+.PP
+The path separator character is \f[CB];\f[R] on Windows, and \f[CB]:\f[R]
+otherwise.
+The paths given for the module must specify the root of a package
+hierarchy for the contents of the module
+.PP
+The option may be given at most once for any given module.
+Any content on the path will hide any like\-named content later in the
+path and in the patched module.
+.PP
+When patching source code into more than one module, the
+\f[B]\f[BC]\-\-module\-source\-path\f[B]\f[R] must also be used, so that
+the output directory is organized in a module hierarchy, and capable of
+holding the compiled class files for the modules being compiled.
+.SH ANNOTATION PROCESSING
+.PP
+The \f[CB]javac\f[R] command provides direct support for annotation
+processing.
+.PP
+The API for annotation processors is defined in the
+\f[CB]javax.annotation.processing\f[R] and \f[CB]javax.lang.model\f[R]
+packages and subpackages.
+.SS How Annotation Processing Works
+.PP
+Unless annotation processing is disabled with the
+\f[B]\f[BC]\-proc:none\f[B]\f[R] option, the compiler searches for any
+annotation processors that are available.
+The search path can be specified with the
+\f[B]\f[BC]\-processorpath\f[B]\f[R] option.
+If no path is specified, then the user class path is used.
+Processors are located by means of service provider\-configuration files
+named \f[CB]META\-INF/services/javax.annotation.processing\f[R].
+Processor on the search path.
+Such files should contain the names of any annotation processors to be
+used, listed one per line.
+Alternatively, processors can be specified explicitly, using the
+\f[B]\f[BC]\-processor\f[B]\f[R] option.
+.PP
+After scanning the source files and classes on the command line to
+determine what annotations are present, the compiler queries the
+processors to determine what annotations they process.
+When a match is found, the processor is called.
+A processor can claim the annotations it processes, in which case no
+further attempt is made to find any processors for those annotations.
+After all of the annotations are claimed, the compiler does not search
+for additional processors.
+.PP
+If any processors generate new source files, then another round of
+annotation processing occurs: Any newly generated source files are
+scanned, and the annotations processed as before.
+Any processors called on previous rounds are also called on all
+subsequent rounds.
+This continues until no new source files are generated.
+.PP
+After a round occurs where no new source files are generated, the
+annotation processors are called one last time, to give them a chance to
+complete any remaining work.
+Finally, unless the \f[B]\f[BC]\-proc:only\f[B]\f[R] option is used, the
+compiler compiles the original and all generated source files.
+.PP
+If you use an annotation processor that generates additional source
+files to be included in the compilation, you can specify a default
+module to be used for the newly generated files, for use when a module
+declaration is not also generated.
+In this case, use the
+\f[B]\f[BC]\-\-default\-module\-for\-created\-files\f[B]\f[R] option.
+.SS Compilation Environment and Runtime Environment.
+.PP
+The declarations in source files and previously compiled class files are
+analyzed by \f[CB]javac\f[R] in a \f[I]compilation environment\f[R] that is
+distinct from the \f[I]runtime environment\f[R] used to execute
+\f[CB]javac\f[R] itself.
+Although there is a deliberate similarity between many \f[CB]javac\f[R]
+options and like\-named options for the Java \f[B]launcher\f[R], such as
+\f[CB]\-\-class\-path\f[R], \f[CB]\-\-module\-path\f[R] and so on, it is
+important to understand that in general the \f[CB]javac\f[R] options just
+affect the environment in which the source files are compiled, and do
+not affect the operation of \f[CB]javac\f[R] itself.
+.PP
+The distinction between the compilation environment and runtime
+environment is significant when it comes to using annotation processors.
+Although annotations processors process elements (declarations) that
+exist in the compilation environment, the annotation processor itself is
+executed in the runtime environment.
+If an annotation processor has dependencies on libraries that are not in
+modules, the libraries can be placed, along with the annotation
+processor itself, on the processor path.
+(See the \f[B]\f[BC]\-\-processor\-path\f[B]\f[R] option.) If the
+annotation processor and its dependencies are in modules, you should use
+the processor module path instead.
+(See the \f[B]\f[BC]\-\-processor\-module\-path\f[B]\f[R] option.) When
+those are insufficient, it may be necessary to provide further
+configuration of the runtime environment.
+This can be done in two ways:
+.IP "1." 3
+If \f[CB]javac\f[R] is invoked from the command line, options can be
+passed to the underlying runtime by prefixing the option with
+\f[B]\f[BC]\-J\f[B]\f[R].
+.IP "2." 3
+You can start an instance of a Java Virtual Machine directly and use
+command line options and API to configure an environment in which
+\f[CB]javac\f[R] can be invoked via one of its \f[B]APIs\f[R].
+.SH COMPILING FOR EARLIER RELEASES OF THE PLATFORM
+.PP
+\f[CB]javac\f[R] can compile code that is to be used on other releases of
+the platform, using either the \f[B]\f[BC]\-\-release\f[B]\f[R] option,
+or the \f[B]\f[BC]\-\-source\f[B]\f[R]/\f[CB]\-source\f[R] and
+\f[B]\f[BC]\-\-target\f[B]\f[R]/\f[CB]\-target\f[R] options, together with
+additional options to specify the platform classes.
+.PP
+Depending on the desired platform release, there are some restrictions
+on some of the options that can be used.
+.IP \[bu] 2
+When compiling for JDK 8 and earlier releases, you cannot use any option
+that is intended for use with the module system.
+This includes all of the following options:
+.RS 2
+.IP \[bu] 2
+\f[B]\f[BC]\-\-module\-source\-path\f[B]\f[R],
+\f[B]\f[BC]\-\-upgrade\-module\-path\f[B]\f[R],
+\f[B]\f[BC]\-\-system\f[B]\f[R], \f[B]\f[BC]\-\-module\-path\f[B]\f[R],
+\f[B]\f[BC]\-\-add\-modules\f[B]\f[R],
+\f[B]\f[BC]\-\-add\-exports\f[B]\f[R], \f[CB]\-\-add\-opens\f[R],
+\f[B]\f[BC]\-\-add\-reads\f[B]\f[R],
+\f[B]\f[BC]\-\-limit\-modules\f[B]\f[R],
+\f[B]\f[BC]\-\-patch\-module\f[B]\f[R]
+.PP
+If you use the \f[CB]\-\-source\f[R]/\f[CB]\-source\f[R] or
+\f[CB]\-\-target\f[R]/\f[CB]\-target\f[R] options, you should also set the
+appropriate platform classes using the boot class path family of
+options.
+.RE
+.IP \[bu] 2
+When compiling for JDK 9 and later releases, you cannot use any option
+that is intended to configure the boot class path.
+This includes all of the following options:
+.RS 2
+.IP \[bu] 2
+\f[B]\f[BC]\-Xbootclasspath/p:\f[B]\f[R],
+\f[B]\f[BC]\-Xbootclasspath\f[B]\f[R],
+\f[B]\f[BC]\-Xbootclasspath/a:\f[B]\f[R],
+\f[B]\f[BC]\-endorseddirs\f[B]\f[R],
+\f[B]\f[BC]\-Djava.endorsed.dirs\f[B]\f[R],
+\f[B]\f[BC]\-extdirs\f[B]\f[R], \f[B]\f[BC]\-Djava.ext.dirs\f[B]\f[R],
+\f[B]\f[BC]\-profile\f[B]\f[R]
+.PP
+If you use the \f[CB]\-\-source\f[R]/\f[CB]\-source\f[R] or
+\f[CB]\-\-target\f[R]/\f[CB]\-target\f[R] options, you should also set the
+appropriate platform classes using the \f[CB]\-\-system\f[R] option to
+give the location of an appropriate installed release of JDK.
+.RE
+.PP
+When using the \f[CB]\-\-release\f[R] option, only the supported
+documented API for that release may be used; you cannot use any options
+to break encapsulation to access any internal classes.
+.SH APIS
+.PP
+The \f[CB]javac\f[R] compiler can be invoked using an API in three
+different ways:
+.TP
+.B The \f[B]Java Compiler API\f[R]
+This provides the most flexible way to invoke the compiler, including
+the ability to compile source files provided in memory buffers or other
+non\-standard file systems.
+.RS
+.RE
 .TP
--Xprint
-.br
-Prints a textual representation of specified types for debugging purposes\&. Perform neither annotation processing nor compilation\&. The format of the output could change\&.
-.TP
--XprintProcessorInfo
-.br
-Prints information about which annotations a processor is asked to process\&.
-.TP
--XprintRounds
-.br
-Prints information about initial and subsequent annotation processing rounds\&.
-.SH ENABLE\ OR\ DISABLE\ WARNINGS\ WITH\ THE\ -XLINT\ OPTION    
-Enable warning \fIname\fR with the \f3-Xlint:name\fR option, where \f3name\fR is one of the following warning names\&. Note that you can disable a warning with the \f3-Xlint:-name:\fR option\&.
-.TP     
-cast
+.B The \f[B]ToolProvider API\f[R]
+A \f[CB]ToolProvider\f[R] for \f[CB]javac\f[R] can be obtained by calling
+\f[CB]ToolProvider.findFirst("javac")\f[R].
+This returns an object with the equivalent functionality of the
+command\-line tool.
+.RS
+.PP
+\f[B]Note\f[R]: This API should not be confused with the like\-named API
+in the \f[B]\f[BC]javax.tools\f[B]\f[R] package.
+.RE
+.TP
+.B The \f[CB]javac\f[R] \f[B]Legacy API\f[R]
+This API is retained for backward compatibility only.
+All new code should use either the Java Compiler API or the ToolProvider
+API.
+.RS
+.RE
+.PP
+\f[B]Note:\f[R] All other classes and methods found in a package with
+names that start with \f[CB]com.sun.tools.javac\f[R] (subpackages of
+\f[CB]com.sun.tools.javac\f[R]) are strictly internal and subject to
+change at any time.
+.SH EXAMPLES OF USING \-XLINT KEYS
+.TP
+.B \f[CB]cast\f[R]
 Warns about unnecessary and redundant casts, for example:
-.sp     
-.nf     
-\f3String s = (String) "Hello!"\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-.TP     
-classfile
-Warns about issues related to class file contents\&.
-.TP     
-deprecation
-Warns about the use of deprecated items, for example:
-.sp     
-.nf     
-\f3java\&.util\&.Date myDate = new java\&.util\&.Date();\fP
-.fi     
-.nf     
-\f3int currentDay = myDate\&.getDay();\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-The method \f3java\&.util\&.Date\&.getDay\fR has been deprecated since JDK 1\&.1
-.TP     
-dep-ann
-Warns about items that are documented with an \f3@deprecated\fR Javadoc comment, but do not have a \f3@Deprecated\fR annotation, for example:
-.sp     
-.nf     
-\f3/**\fP
-.fi     
-.nf     
-\f3  * @deprecated As of Java SE 7, replaced by {@link #newMethod()}\fP
-.fi     
-.nf     
-\f3  */\fP
-.fi     
-.nf     
-\f3public static void deprecatedMethood() { }\fP
-.fi     
-.nf     
-\f3public static void newMethod() { }\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-.TP     
-divzero
+.RS
+.RS
+.PP
+\f[CB]String\ s\ =\ (String)\ "Hello!"\f[R]
+.RE
+.RE
+.TP
+.B \f[CB]classfile\f[R]
+Warns about issues related to class file contents.
+.RS
+.RE
+.TP
+.B \f[CB]deprecation\f[R]
+Warns about the use of deprecated items.
+For example:
+.RS
+.IP
+.nf
+\f[CB]
+java.util.Date\ myDate\ =\ new\ java.util.Date();
+int\ currentDay\ =\ myDate.getDay();
+\f[R]
+.fi
+.PP
+The method \f[CB]java.util.Date.getDay\f[R] has been deprecated since JDK
+1.1.
+.RE
+.TP
+.B \f[CB]dep\-ann\f[R]
+Warns about items that are documented with the \f[CB]\@deprecated\f[R]
+Javadoc comment, but do not have the \f[CB]\@Deprecated\f[R] annotation,
+for example:
+.RS
+.IP
+.nf
+\f[CB]
+/**
+\ \ *\ \@deprecated\ As\ of\ Java\ SE\ 7,\ replaced\ by\ {\@link\ #newMethod()}
+\ \ */
+public\ static\ void\ deprecatedMethod()\ {\ }
+public\ static\ void\ newMethod()\ {\ }
+\f[R]
+.fi
+.RE
+.TP
+.B \f[CB]divzero\f[R]
 Warns about division by the constant integer 0, for example:
-.sp     
-.nf     
-\f3int divideByZero = 42 / 0;\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-.TP     
-empty
-Warns about empty statements after \f3if\fRstatements, for example:
-.sp     
-.nf     
-\f3class E {\fP
-.fi     
-.nf     
-\f3    void m() {\fP
-.fi     
-.nf     
-\f3         if (true) ;\fP
-.fi     
-.nf     
-\f3    }\fP
-.fi     
-.nf     
-\f3}\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-.TP     
-fallthrough
-Checks the switch blocks for fall-through cases and provides a warning message for any that are found\&. Fall-through cases are cases in a switch block, other than the last case in the block, whose code does not include a break statement, allowing code execution to fall through from that case to the next case\&. For example, the code following the case 1 label in this switch block does not end with a break statement:
-.sp     
-.nf     
-\f3switch (x) {\fP
-.fi     
-.nf     
-\f3case 1:\fP
-.fi     
-.nf     
-\f3  System\&.out\&.println("1");\fP
-.fi     
-.nf     
-\f3  // No break statement here\&.\fP
-.fi     
-.nf     
-\f3case 2:\fP
-.fi     
-.nf     
-\f3  System\&.out\&.println("2");\fP
-.fi     
-.nf     
-\f3}\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-If the \f3-Xlint:fallthrough\fR option was used when compiling this code, then the compiler emits a warning about possible fall-through into case, with the line number of the case in question\&.
-.TP     
-finally
-Warns about \f3finally\fR clauses that cannot complete normally, for example:
-.sp     
-.nf     
-\f3public static int m() {\fP
-.fi     
-.nf     
-\f3  try {\fP
-.fi     
-.nf     
-\f3     throw new NullPointerException();\fP
-.fi     
-.nf     
-\f3  }  catch (NullPointerException(); {\fP
-.fi     
-.nf     
-\f3     System\&.err\&.println("Caught NullPointerException\&.");\fP
-.fi     
-.nf     
-\f3     return 1;\fP
-.fi     
-.nf     
-\f3   } finally {\fP
-.fi     
-.nf     
-\f3     return 0;\fP
-.fi     
-.nf     
-\f3   }\fP
-.fi     
-.nf     
-\f3  }\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-The compiler generates a warning for the \f3finally\fR block in this example\&. When the \f3int\fR method is called, it returns a value of 0\&. A \f3finally\fR block executes when the \f3try\fR block exits\&. In this example, when control is transferred to the \f3catch\fR block, the \f3int\fR method exits\&. However, the \f3finally\fR block must execute, so it is executed, even though control was transferred outside the method\&.
-.TP     
-options
-Warns about issues that related to the use of command-line options\&. See Cross-Compilation Options\&.
-.TP     
-overrides
-Warns about issues regarding method overrides\&. For example, consider the following two classes:
-.sp     
-.nf     
-\f3public class ClassWithVarargsMethod {\fP
-.fi     
-.nf     
-\f3  void varargsMethod(String\&.\&.\&. s) { }\fP
-.fi     
-.nf     
-\f3}\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.nf     
-\f3public class ClassWithOverridingMethod extends ClassWithVarargsMethod {\fP
-.fi     
-.nf     
-\f3   @Override\fP
-.fi     
-.nf     
-\f3   void varargsMethod(String[] s) { }\fP
-.fi     
-.nf     
-\f3}\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-The compiler generates a warning similar to the following:\&.
-.sp     
-.nf     
-\f3warning: [override] varargsMethod(String[]) in ClassWithOverridingMethod \fP
-.fi     
-.nf     
-\f3overrides varargsMethod(String\&.\&.\&.) in ClassWithVarargsMethod; overriding\fP
-.fi     
-.nf     
-\f3method is missing \&'\&.\&.\&.\&'\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-When the compiler encounters a \f3varargs\fR method, it translates the \f3varargs\fR formal parameter into an array\&. In the method \f3ClassWithVarargsMethod\&.varargsMethod\fR, the compiler translates the \f3varargs\fR formal parameter \f3String\&.\&.\&. s\fR to the formal parameter \f3String[] s\fR, an array, which matches the formal parameter of the method \f3ClassWithOverridingMethod\&.varargsMethod\fR\&. Consequently, this example compiles\&.
-.TP     
-path
-Warns about invalid path elements and nonexistent path directories on the command line (with regard to the class path, the source path, and other paths)\&. Such warnings cannot be suppressed with the \f3@SuppressWarnings\fR annotation, for example:
-.sp     
-.nf     
-\f3javac \-Xlint:path \-classpath /nonexistentpath Example\&.java\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-.TP     
-processing
-Warn about issues regarding annotation processing\&. The compiler generates this warning when you have a class that has an annotation, and you use an annotation processor that cannot handle that type of exception\&. For example, the following is a simple annotation processor:
-
-\fISource file AnnocProc\&.java\fR:
-.sp     
-.nf     
-\f3import java\&.util\&.*;\fP
-.fi     
-.nf     
-\f3import javax\&.annotation\&.processing\&.*;\fP
-.fi     
-.nf     
-\f3import javax\&.lang\&.model\&.*;\fP
-.fi     
-.nf     
-\f3import\&.javaz\&.lang\&.model\&.element\&.*;\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.nf     
-\f3@SupportedAnnotationTypes("NotAnno")\fP
-.fi     
-.nf     
-\f3public class AnnoProc extends AbstractProcessor {\fP
-.fi     
-.nf     
-\f3  public boolean process(Set<? extends TypeElement> elems, RoundEnvironment renv){\fP
-.fi     
-.nf     
-\f3     return true;\fP
-.fi     
-.nf     
-\f3  }\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.nf     
-\f3  public SourceVersion getSupportedSourceVersion() {\fP
-.fi     
-.nf     
-\f3     return SourceVersion\&.latest();\fP
-.fi     
-.nf     
-\f3   }\fP
-.fi     
-.nf     
-\f3}\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-\fISource file AnnosWithoutProcessors\&.java\fR:
-.sp     
-.nf     
-\f3@interface Anno { }\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.nf     
-\f3@Anno\fP
-.fi     
-.nf     
-\f3class AnnosWithoutProcessors { }\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-The following commands compile the annotation processor \f3AnnoProc\fR, then run this annotation processor against the source file \f3AnnosWithoutProcessors\&.java\fR:
-.sp     
-.nf     
-\f3javac AnnoProc\&.java\fP
-.fi     
-.nf     
-\f3javac \-cp \&. \-Xlint:processing \-processor AnnoProc \-proc:only AnnosWithoutProcessors\&.java\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-When the compiler runs the annotation processor against the source file \f3AnnosWithoutProcessors\&.java\fR, it generates the following warning:
-.sp     
-.nf     
-\f3warning: [processing] No processor claimed any of these annotations: Anno\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-To resolve this issue, you can rename the annotation defined and used in the class \f3AnnosWithoutProcessors\fR from \f3Anno\fR to \f3NotAnno\fR\&.
-.TP     
-rawtypes
-Warns about unchecked operations on raw types\&. The following statement generates a \f3rawtypes\fR warning:
-.sp     
-.nf     
-\f3void countElements(List l) { \&.\&.\&. }\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-The following example does not generate a \f3rawtypes\fR warning
-.sp     
-.nf     
-\f3void countElements(List<?> l) { \&.\&.\&. }\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-\f3List\fR is a raw type\&. However, \f3List<?>\fR is an unbounded wildcard parameterized type\&. Because \f3List\fR is a parameterized interface, always specify its type argument\&. In this example, the \f3List\fR formal argument is specified with an unbounded wildcard (\f3?\fR) as its formal type parameter, which means that the \f3countElements\fR method can accept any instantiation of the \f3List\fR interface\&.
-.TP     
-Serial
-Warns about missing \f3serialVersionUID\fR definitions on serializable classes, for example:
-.sp     
-.nf     
-\f3public class PersistentTime implements Serializable\fP
-.fi     
-.nf     
-\f3{\fP
-.fi     
-.nf     
-\f3  private Date time;\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.nf     
-\f3   public PersistentTime() {\fP
-.fi     
-.nf     
-\f3     time = Calendar\&.getInstance()\&.getTime();\fP
-.fi     
-.nf     
-\f3   }\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.nf     
-\f3   public Date getTime() {\fP
-.fi     
-.nf     
-\f3     return time;\fP
-.fi     
-.nf     
-\f3   }\fP
-.fi     
-.nf     
-\f3}\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
+.RS
+.RS
+.PP
+\f[CB]int\ divideByZero\ =\ 42\ /\ 0;\f[R]
+.RE
+.RE
+.TP
+.B \f[CB]empty\f[R]
+Warns about empty statements after \f[CB]if\f[R]statements, for example:
+.RS
+.IP
+.nf
+\f[CB]
+class\ E\ {
+\ \ \ \ void\ m()\ {
+\ \ \ \ \ \ \ \ \ if\ (true)\ ;
+\ \ \ \ }
+}
+\f[R]
+.fi
+.RE
+.TP
+.B \f[CB]fallthrough\f[R]
+Checks the switch blocks for fall\-through cases and provides a warning
+message for any that are found.
+Fall\-through cases are cases in a switch block, other than the last
+case in the block, whose code does not include a \f[CB]break\f[R]
+statement, allowing code execution to fall through from that case to the
+next case.
+For example, the code following the case 1 label in this switch block
+does not end with a \f[CB]break\f[R] statement:
+.RS
+.IP
+.nf
+\f[CB]
+switch\ (x)\ {
+case\ 1:
+\ \ System.out.println("1");
+\ \ //\ No\ break\ statement\ here.
+case\ 2:
+\ \ System.out.println("2");
+}
+\f[R]
+.fi
+.PP
+If the \f[CB]\-Xlint:fallthrough\f[R] option was used when compiling this
+code, then the compiler emits a warning about possible fall\-through
+into case, with the line number of the case in question.
+.RE
+.TP
+.B \f[CB]finally\f[R]
+Warns about \f[CB]finally\f[R] clauses that cannot be completed normally,
+for example:
+.RS
+.IP
+.nf
+\f[CB]
+public\ static\ int\ m()\ {
+\ \ try\ {
+\ \ \ \ \ throw\ new\ NullPointerException();
+\ \ }\ \ catch\ (NullPointerException();\ {
+\ \ \ \ \ System.err.println("Caught\ NullPointerException.");
+\ \ \ \ \ return\ 1;
+\ \ \ }\ finally\ {
+\ \ \ \ \ return\ 0;
+\ \ \ }
+\ \ }
+\f[R]
+.fi
+.PP
+The compiler generates a warning for the \f[CB]finally\f[R] block in this
+example.
+When the \f[CB]int\f[R] method is called, it returns a value of 0.
+A \f[CB]finally\f[R] block executes when the \f[CB]try\f[R] block exits.
+In this example, when control is transferred to the \f[CB]catch\f[R]
+block, the \f[CB]int\f[R] method exits.
+However, the \f[CB]finally\f[R] block must execute, so it\[aq]s executed,
+even though control was transferred outside the method.
+.RE
+.TP
+.B \f[CB]options\f[R]
+Warns about issues that related to the use of command\-line options.
+See \f[B]Compiling for Earlier Releases of the Platform\f[R].
+.RS
+.RE
+.TP
+.B \f[CB]overrides\f[R]
+Warns about issues related to method overrides.
+For example, consider the following two classes:
+.RS
+.IP
+.nf
+\f[CB]
+public\ class\ ClassWithVarargsMethod\ {
+\ \ void\ varargsMethod(String...\ s)\ {\ }
+}
+
+public\ class\ ClassWithOverridingMethod\ extends\ ClassWithVarargsMethod\ {
+\ \ \ \@Override
+\ \ \ void\ varargsMethod(String[]\ s)\ {\ }
+}
+\f[R]
+.fi
+.PP
+The compiler generates a warning similar to the following:.
+.IP
+.nf
+\f[CB]
+warning:\ [override]\ varargsMethod(String[])\ in\ ClassWithOverridingMethod
+overrides\ varargsMethod(String...)\ in\ ClassWithVarargsMethod;\ overriding
+method\ is\ missing\ \[aq]...\[aq]
+\f[R]
+.fi
+.PP
+When the compiler encounters a \f[CB]varargs\f[R] method, it translates
+the \f[CB]varargs\f[R] formal parameter into an array.
+In the method \f[CB]ClassWithVarargsMethod.varargsMethod\f[R], the
+compiler translates the \f[CB]varargs\f[R] formal parameter
+\f[CB]String...\ s\f[R] to the formal parameter \f[CB]String[]\ s\f[R], an
+array that matches the formal parameter of the method
+\f[CB]ClassWithOverridingMethod.varargsMethod\f[R].
+Consequently, this example compiles.
+.RE
+.TP
+.B \f[CB]path\f[R]
+Warns about invalid path elements and nonexistent path directories on
+the command line (with regard to the class path, the source path, and
+other paths).
+Such warnings cannot be suppressed with the \f[CB]\@SuppressWarnings\f[R]
+annotation.
+For example:
+.RS
+.IP \[bu] 2
+\f[B]Oracle Solaris, Linux, and macOS:\f[R]
+\f[CB]javac\ \-Xlint:path\ \-classpath\ /nonexistentpath\ Example.java\f[R]
+.IP \[bu] 2
+\f[B]Windows:\f[R]
+\f[CB]javac\ \-Xlint:path\ \-classpath\ C:\\nonexistentpath\ Example.java\f[R]
+.RE
+.TP
+.B \f[CB]processing\f[R]
+Warns about issues related to annotation processing.
+The compiler generates this warning when you have a class that has an
+annotation, and you use an annotation processor that cannot handle that
+type of exception.
+For example, the following is a simple annotation processor:
+.RS
+.PP
+\f[B]Source file AnnocProc.java\f[R]:
+.IP
+.nf
+\f[CB]
+import\ java.util.*;
+import\ javax.annotation.processing.*;
+import\ javax.lang.model.*;
+import\ javaz.lang.model.element.*;
+
+\@SupportedAnnotationTypes("NotAnno")
+public\ class\ AnnoProc\ extends\ AbstractProcessor\ {
+\ \ public\ boolean\ process(Set<?\ extends\ TypeElement>\ elems,\ RoundEnvironment\ renv){
+\ \ \ \ \ return\ true;
+\ \ }
+
+\ \ public\ SourceVersion\ getSupportedSourceVersion()\ {
+\ \ \ \ \ return\ SourceVersion.latest();
+\ \ \ }
+}
+\f[R]
+.fi
+.PP
+\f[B]Source file AnnosWithoutProcessors.java\f[R]:
+.IP
+.nf
+\f[CB]
+\@interface\ Anno\ {\ }
+
+\@Anno
+class\ AnnosWithoutProcessors\ {\ }
+\f[R]
+.fi
+.PP
+The following commands compile the annotation processor
+\f[CB]AnnoProc\f[R], then run this annotation processor against the source
+file \f[CB]AnnosWithoutProcessors.java\f[R]:
+.IP
+.nf
+\f[CB]
+javac\ AnnoProc.java
+javac\ \-cp\ .\ \-Xlint:processing\ \-processor\ AnnoProc\ \-proc:only\ AnnosWithoutProcessors.java
+\f[R]
+.fi
+.PP
+When the compiler runs the annotation processor against the source file
+\f[CB]AnnosWithoutProcessors.java\f[R], it generates the following
+warning:
+.IP
+.nf
+\f[CB]
+warning:\ [processing]\ No\ processor\ claimed\ any\ of\ these\ annotations:\ Anno
+\f[R]
+.fi
+.PP
+To resolve this issue, you can rename the annotation defined and used in
+the class \f[CB]AnnosWithoutProcessors\f[R] from \f[CB]Anno\f[R] to
+\f[CB]NotAnno\f[R].
+.RE
+.TP
+.B \f[CB]rawtypes\f[R]
+Warns about unchecked operations on raw types.
+The following statement generates a \f[CB]rawtypes\f[R] warning:
+.RS
+.RS
+.PP
+\f[CB]void\ countElements(List\ l)\ {\ ...\ }\f[R]
+.RE
+.PP
+The following example does not generate a \f[CB]rawtypes\f[R] warning:
+.RS
+.PP
+\f[CB]void\ countElements(List<?>\ l)\ {\ ...\ }\f[R]
+.RE
+.PP
+\f[CB]List\f[R] is a raw type.
+However, \f[CB]List<?>\f[R] is an unbounded wildcard parameterized type.
+Because \f[CB]List\f[R] is a parameterized interface, always specify its
+type argument.
+In this example, the \f[CB]List\f[R] formal argument is specified with an
+unbounded wildcard (\f[CB]?\f[R]) as its formal type parameter, which
+means that the \f[CB]countElements\f[R] method can accept any
+instantiation of the \f[CB]List\f[R] interface.
+.RE
+.TP
+.B \f[CB]serial\f[R]
+Warns about missing \f[CB]serialVersionUID\f[R] definitions on
+serializable classes.
+For example:
+.RS
+.IP
+.nf
+\f[CB]
+public\ class\ PersistentTime\ implements\ Serializable
+{
+\ \ private\ Date\ time;
+
+\ \ \ public\ PersistentTime()\ {
+\ \ \ \ \ time\ =\ Calendar.getInstance().getTime();
+\ \ \ }
+
+\ \ \ public\ Date\ getTime()\ {
+\ \ \ \ \ return\ time;
+\ \ \ }
+}
+\f[R]
+.fi
+.PP
 The compiler generates the following warning:
-.sp     
-.nf     
-\f3warning: [serial] serializable class PersistentTime has no definition of\fP
-.fi     
-.nf     
-\f3serialVersionUID\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-If a serializable class does not explicitly declare a field named \f3serialVersionUID\fR, then the serialization runtime environment calculates a default \f3serialVersionUID\fR value for that class based on various aspects of the class, as described in the Java Object Serialization Specification\&. However, it is strongly recommended that all serializable classes explicitly declare \f3serialVersionUID\fR values because the default process of computing \f3serialVersionUID\fR vales is highly sensitive to class details that can vary depending on compiler implementations, and as a result, might cause an unexpected \f3InvalidClassExceptions\fR during deserialization\&. To guarantee a consistent \f3serialVersionUID\fR value across different Java compiler implementations, a serializable class must declare an explicit \f3serialVersionUID\fR value\&.
-.TP     
-static
-Warns about issues relating to the use of statics, for example:
-.sp     
-.nf     
-\f3class XLintStatic {\fP
-.fi     
-.nf     
-\f3    static void m1() { }\fP
-.fi     
-.nf     
-\f3    void m2() { this\&.m1(); }\fP
-.fi     
-.nf     
-\f3}\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
+.IP
+.nf
+\f[CB]
+warning:\ [serial]\ serializable\ class\ PersistentTime\ has\ no\ definition\ of
+serialVersionUID
+\f[R]
+.fi
+.PP
+If a serializable class does not explicitly declare a field named
+\f[CB]serialVersionUID\f[R], then the serialization runtime environment
+calculates a default \f[CB]serialVersionUID\f[R] value for that class
+based on various aspects of the class, as described in the Java Object
+Serialization Specification.
+However, it\[aq]s strongly recommended that all serializable classes
+explicitly declare \f[CB]serialVersionUID\f[R] values because the default
+process of computing \f[CB]serialVersionUID\f[R] values is highly
+sensitive to class details that can vary depending on compiler
+implementations.
+As a result, this might cause an unexpected
+\f[CB]InvalidClassExceptions\f[R] during deserialization.
+To guarantee a consistent \f[CB]serialVersionUID\f[R] value across
+different Java compiler implementations, a serializable class must
+declare an explicit \f[CB]serialVersionUID\f[R] value.
+.RE
+.TP
+.B \f[CB]static\f[R]
+Warns about issues relating to the use of static variables, for example:
+.RS
+.IP
+.nf
+\f[CB]
+class\ XLintStatic\ {
+\ \ \ \ static\ void\ m1()\ {\ }
+\ \ \ \ void\ m2()\ {\ this.m1();\ }
+}
+\f[R]
+.fi
+.PP
 The compiler generates the following warning:
-.sp     
-.nf     
-\f3warning: [static] static method should be qualified by type name, \fP
-.fi     
-.nf     
-\f3XLintStatic, instead of by an expression\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-To resolve this issue, you can call the \f3static\fR method \f3m1\fR as follows:
-.sp     
-.nf     
-\f3XLintStatic\&.m1();\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-Alternately, you can remove the \f3static\fR keyword from the declaration of the method \f3m1\fR\&.
-.TP     
-try
-Warns about issues relating to use of \f3try\fR blocks, including try-with-resources statements\&. For example, a warning is generated for the following statement because the resource \f3ac\fR declared in the \f3try\fR block is not used:
-.sp     
-.nf     
-\f3try ( AutoCloseable ac = getResource() ) {    // do nothing}\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-.TP     
-unchecked
-Gives more detail for unchecked conversion warnings that are mandated by the Java Language Specification, for example:
-.sp     
-.nf     
-\f3List l = new ArrayList<Number>();\fP
-.fi     
-.nf     
-\f3List<String> ls = l;       // unchecked warning\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-During type erasure, the types \f3ArrayList<Number>\fR and \f3List<String>\fR become \f3ArrayList\fR and \f3List\fR, respectively\&.
-
-The \f3ls\fR command has the parameterized type \f3List<String>\fR\&. When the \f3List\fR referenced by \f3l\fR is assigned to \f3ls\fR, the compiler generates an unchecked warning\&. At compile time, the compiler and JVM cannot determine whether \f3l\fR refers to a \f3List<String>\fR type\&. In this case, \f3l\fR does not refer to a \f3List<String>\fR type\&. As a result, heap pollution occurs\&.
-
-A heap pollution situation occurs when the \f3List\fR object \f3l\fR, whose static type is \f3List<Number>\fR, is assigned to another \f3List\fR object, \f3ls\fR, that has a different static type, \f3List<String>\fR\&. However, the compiler still allows this assignment\&. It must allow this assignment to preserve backward compatibility with releases of Java SE that do not support generics\&. Because of type erasure, \f3List<Number>\fR and \f3List<String>\fR both become \f3List\fR\&. Consequently, the compiler allows the assignment of the object \f3l\fR\f3,\fR which has a raw type of \f3List\fR, to the object \f3ls\fR\&.
-.TP     
-varargs
-Warns about unsafe usages of variable arguments (\f3varargs\fR) methods, in particular, those that contain non-reifiable arguments, for example:
-.sp     
-.nf     
-\f3public class ArrayBuilder {\fP
-.fi     
-.nf     
-\f3  public static <T> void addToList (List<T> listArg, T\&.\&.\&. elements) {\fP
-.fi     
-.nf     
-\f3    for (T x : elements) {\fP
-.fi     
-.nf     
-\f3      listArg\&.add(x);\fP
-.fi     
-.nf     
-\f3    }\fP
-.fi     
-.nf     
-\f3  }\fP
-.fi     
-.nf     
-\f3}\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-\fINote:\fR A non-reifiable type is a type whose type information is not fully available at runtime\&.
-
-The compiler generates the following warning for the definition of the method \f3ArrayBuilder\&.addToList\fR
-.sp     
-.nf     
-\f3warning: [varargs] Possible heap pollution from parameterized vararg type T\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-
-
-When the compiler encounters a varargs method, it translates the \f3varargs\fR formal parameter into an array\&. However, the Java programming language does not permit the creation of arrays of parameterized types\&. In the method \f3ArrayBuilder\&.addToList\fR, the compiler translates the \f3varargs\fR formal parameter \f3T\&.\&.\&.\fR elements to the formal parameter \f3T[]\fR elements, an array\&. However, because of type erasure, the compiler converts the \f3varargs\fR formal parameter to \f3Object[]\fR elements\&. Consequently, there is a possibility of heap pollution\&.
-.SH COMMAND-LINE\ ARGUMENT\ FILES    
-To shorten or simplify the \f3javac\fR command, you can specify one or more files that contain arguments to the \f3javac\fR command (except \f3-J\fR options)\&. This enables you to create \f3javac\fR commands of any length on any operating system\&.
-.PP
-An argument file can include \f3javac\fR options and source file names in any combination\&. The arguments within a file can be separated by spaces or new line characters\&. If a file name contains embedded spaces, then put the whole file name in double quotation marks\&.
-.PP
-File Names within an argument file are relative to the current directory, not the location of the argument file\&. Wild cards (*) are not allowed in these lists (such as for specifying \f3*\&.java\fR)\&. Use of the at sign (@) to recursively interpret files is not supported\&. The \f3-J\fR options are not supported because they are passed to the launcher, which does not support argument files\&.
-.PP
-When executing the \f3javac\fR command, pass in the path and name of each argument file with the at sign (@) leading character\&. When the \f3javac\fR command encounters an argument beginning with the at sign (@), it expands the contents of that file into the argument list\&.
-.PP
-\f3Example 1 Single Argument File\fR
-.PP
-You could use a single argument file named \f3argfile\fR to hold all \f3javac\fR arguments:
-.sp     
-.nf     
-\f3javac @argfile\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-This argument file could contain the contents of both files shown in Example 2
-.PP
-\f3Example 2 Two Argument Files\fR
-.PP
-You can create two argument files: one for the \f3javac\fR options and the other for the source file names\&. Note that the following lists have no line-continuation characters\&.
-.PP
-Create a file named options that contains the following:
-.sp     
-.nf     
-\f3\-d classes\fP
-.fi     
-.nf     
-\f3\-g\fP
-.fi     
-.nf     
-\f3\-sourcepath /java/pubs/ws/1\&.3/src/share/classes\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-Create a file named classes that contains the following:
-.sp     
-.nf     
-\f3MyClass1\&.java\fP
-.fi     
-.nf     
-\f3MyClass2\&.java\fP
-.fi     
-.nf     
-\f3MyClass3\&.java\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-Then, run the \f3javac\fR command as follows:
-.sp     
-.nf     
-\f3javac @options @classes\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-\f3Example 3 Argument Files with Paths\fR
-.PP
-The argument files can have paths, but any file names inside the files are relative to the current working directory (not \f3path1\fR or \f3path2\fR):
-.sp     
-.nf     
-\f3javac @path1/options @path2/classes\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-.SH ANNOTATION\ PROCESSING    
-The \f3javac\fR command provides direct support for annotation processing, superseding the need for the separate annotation processing command, \f3apt\fR\&.
-.PP
-The API for annotation processors is defined in the \f3javax\&.annotation\&.processing\fR and j\f3avax\&.lang\&.model\fR packages and subpackages\&.
-.SS HOW\ ANNOTATION\ PROCESSING\ WORKS    
-Unless annotation processing is disabled with the \f3-proc:none\fR option, the compiler searches for any annotation processors that are available\&. The search path can be specified with the \f3-processorpath\fR option\&. If no path is specified, then the user class path is used\&. Processors are located by means of service provider-configuration files named \f3META-INF/services/javax\&.annotation\&.processing\fR\&.Processor on the search path\&. Such files should contain the names of any annotation processors to be used, listed one per line\&. Alternatively, processors can be specified explicitly, using the \f3-processor\fR option\&.
-.PP
-After scanning the source files and classes on the command line to determine what annotations are present, the compiler queries the processors to determine what annotations they process\&. When a match is found, the processor is called\&. A processor can claim the annotations it processes, in which case no further attempt is made to find any processors for those annotations\&. After all of the annotations are claimed, the compiler does not search for additional processors\&.
-.PP
-If any processors generate new source files, then another round of annotation processing occurs: Any newly generated source files are scanned, and the annotations processed as before\&. Any processors called on previous rounds are also called on all subsequent rounds\&. This continues until no new source files are generated\&.
-.PP
-After a round occurs where no new source files are generated, the annotation processors are called one last time, to give them a chance to complete any remaining work\&. Finally, unless the \f3-proc:only\fR option is used, the compiler compiles the original and all generated source files\&.
-.SS IMPLICITLY\ LOADED\ SOURCE\ FILES    
-To compile a set of source files, the compiler might need to implicitly load additional source files\&. See Searching for Types\&. Such files are currently not subject to annotation processing\&. By default, the compiler gives a warning when annotation processing occurred and any implicitly loaded source files are compiled\&. The \f3-implicit\fR option provides a way to suppress the warning\&.
-.SH SEARCHING\ FOR\ TYPES    
-To compile a source file, the compiler often needs information about a type, but the type definition is not in the source files specified on the command line\&. The compiler needs type information for every class or interface used, extended, or implemented in the source file\&. This includes classes and interfaces not explicitly mentioned in the source file, but that provide information through inheritance\&.
-.PP
-For example, when you create a subclass \f3java\&.applet\&.Applet\fR, you are also using the ancestor classes of \f3Applet\fR: \f3java\&.awt\&.Panel\fR, \f3java\&.awt\&.Container\fR, \f3java\&.awt\&.Component\fR, and \f3java\&.lang\&.Object\fR\&.
-.PP
-When the compiler needs type information, it searches for a source file or class file that defines the type\&. The compiler searches for class files first in the bootstrap and extension classes, then in the user class path (which by default is the current directory)\&. The user class path is defined by setting the \f3CLASSPATH\fR environment variable or by using the \f3-classpath\fR option\&.
-.PP
-If you set the \f3-sourcepath\fR option, then the compiler searches the indicated path for source files\&. Otherwise, the compiler searches the user class path for both class files and source files\&.
-.PP
-You can specify different bootstrap or extension classes with the \f3-bootclasspath\fR and the \f3-extdirs\fR options\&. See Cross-Compilation Options\&.
-.PP
-A successful type search may produce a class file, a source file, or both\&. If both are found, then you can use the \f3-Xprefer\fR option to instruct the compiler which to use\&. If \f3newer\fR is specified, then the compiler uses the newer of the two files\&. If \f3source\fR is specified, the compiler uses the source file\&. The default is \f3newer\fR\&.
-.PP
-If a type search finds a source file for a required type, either by itself, or as a result of the setting for the \f3-Xprefer\fR option, then the compiler reads the source file to get the information it needs\&. By default the compiler also compiles the source file\&. You can use the \f3-implicit\fR option to specify the behavior\&. If \f3none\fR is specified, then no class files are generated for the source file\&. If \f3class\fR is specified, then class files are generated for the source file\&.
-.PP
-The compiler might not discover the need for some type information until after annotation processing completes\&. When the type information is found in a source file and no \f3-implicit\fR option is specified, the compiler gives a warning that the file is being compiled without being subject to annotation processing\&. To disable the warning, either specify the file on the command line (so that it will be subject to annotation processing) or use the \f3-implicit\fR option to specify whether or not class files should be generated for such source files\&.
-.SH PROGRAMMATIC\ INTERFACE    
-The \f3javac\fR command supports the new Java Compiler API defined by the classes and interfaces in the \f3javax\&.tools\fR package\&.
-.SS EXAMPLE    
-To compile as though providing command-line arguments, use the following syntax:
-.sp     
-.nf     
-\f3JavaCompiler javac = ToolProvider\&.getSystemJavaCompiler();\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-The example writes diagnostics to the standard output stream and returns the exit code that \f3javac\fR would give when called from the command line\&.
-.PP
-You can use other methods in the \f3javax\&.tools\&.JavaCompiler\fR interface to handle diagnostics, control where files are read from and written to, and more\&.
-.SS OLD\ INTERFACE    
-\fINote:\fR This API is retained for backward compatibility only\&. All new code should use the newer Java Compiler API\&.
-.PP
-The \f3com\&.sun\&.tools\&.javac\&.Main\fR class provides two static methods to call the compiler from a program:
-.sp     
-.nf     
-\f3public static int compile(String[] args);\fP
-.fi     
-.nf     
-\f3public static int compile(String[] args, PrintWriter out);\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-The \f3args\fR parameter represents any of the command-line arguments that would typically be passed to the compiler\&.
-.PP
-The \f3out\fR parameter indicates where the compiler diagnostic output is directed\&.
-.PP
-The \f3return\fR value is equivalent to the \f3exit\fR value from \f3javac\fR\&.
-.PP
-\fINote:\fR All other classes and methods found in a package with names that start with \f3com\&.sun\&.tools\&.javac\fR (subpackages of \f3com\&.sun\&.tools\&.javac\fR) are strictly internal and subject to change at any time\&.
-.SH EXAMPLES    
-\f3Example 1 Compile a Simple Program\fR
-.PP
-This example shows how to compile the \f3Hello\&.java\fR source file in the greetings directory\&. The class defined in \f3Hello\&.java\fR is called \f3greetings\&.Hello\fR\&. The greetings directory is the package directory both for the source file and the class file and is underneath the current directory\&. This makes it possible to use the default user class path\&. It also makes it unnecessary to specify a separate destination directory with the \f3-d\fR option\&.
-.PP
-The source code in \f3Hello\&.java\fR:
-.sp     
-.nf     
-\f3package greetings;\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.nf     
-\f3public class Hello {\fP
-.fi     
-.nf     
-\f3    public static void main(String[] args) {\fP
-.fi     
-.nf     
-\f3        for (int i=0; i < args\&.length; i++) {\fP
-.fi     
-.nf     
-\f3            System\&.out\&.println("Hello " + args[i]);\fP
-.fi     
-.nf     
-\f3        }\fP
-.fi     
-.nf     
-\f3    }\fP
-.fi     
-.nf     
-\f3}\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-Compile greetings\&.Hello:
-.sp     
-.nf     
-\f3javac greetings/Hello\&.java\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-Run \f3greetings\&.Hello\fR:
-.sp     
-.nf     
-\f3java greetings\&.Hello World Universe Everyone\fP
-.fi     
-.nf     
-\f3Hello World\fP
-.fi     
-.nf     
-\f3Hello Universe\fP
-.fi     
-.nf     
-\f3Hello Everyone\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-\f3Example 2 Compile Multiple Source Files\fR
-.PP
-This example compiles the \f3Aloha\&.java\fR, \f3GutenTag\&.java\fR, \f3Hello\&.java\fR, and \f3Hi\&.java\fR source files in the \f3greetings\fR package\&.
-.sp     
-.nf     
-\f3% javac greetings/*\&.java\fP
-.fi     
-.nf     
-\f3% ls greetings\fP
-.fi     
-.nf     
-\f3Aloha\&.class         GutenTag\&.class      Hello\&.class         Hi\&.class\fP
-.fi     
-.nf     
-\f3Aloha\&.java          GutenTag\&.java       Hello\&.java          Hi\&.java\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-\f3Example 3 Specify a User Class Path\fR
-.PP
-After changing one of the source files in the previous example, recompile it:
-.sp     
-.nf     
-\f3pwd\fP
-.fi     
-.nf     
-\f3/examples\fP
-.fi     
-.nf     
-\f3javac greetings/Hi\&.java\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-Because \f3greetings\&.Hi\fR refers to other classes in the \f3greetings\fR package, the compiler needs to find these other classes\&. The previous example works because the default user class path is the directory that contains the package directory\&. If you want to recompile this file without concern for which directory you are in, then add the examples directory to the user class path by setting \f3CLASSPATH\fR\&. This example uses the \f3-classpath\fR option\&.
-.sp     
-.nf     
-\f3javac \-classpath /examples /examples/greetings/Hi\&.java\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-If you change \f3greetings\&.Hi\fR to use a banner utility, then that utility also needs to be accessible through the user class path\&.
-.sp     
-.nf     
-\f3javac \-classpath /examples:/lib/Banners\&.jar \e\fP
-.fi     
-.nf     
-\f3            /examples/greetings/Hi\&.java\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-To execute a class in the \f3greetings\fR package, the program needs access to the \f3greetings\fR package, and to the classes that the \f3greetings\fR classes use\&.
-.sp     
-.nf     
-\f3java \-classpath /examples:/lib/Banners\&.jar greetings\&.Hi\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-\f3Example 4 Separate Source Files and Class Files\fR
-.PP
-The following example uses \f3javac\fR to compile code that runs on JVM 1\&.7\&.
-.sp     
-.nf     
-\f3javac \-source 1\&.7 \-target 1\&.7 \-bootclasspath jdk1\&.7\&.0/lib/rt\&.jar \e \fP
-.fi     
-.nf     
-\f3\-extdirs "" OldCode\&.java\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-The \f3-source 1\&.7\fR option specifies that release 1\&.7 (or 7) of the Java programming language be used to compile \f3OldCode\&.java\fR\&. The option \f3-target 1\&.7\fR option ensures that the generated class files are compatible with JVM 1\&.7\&. Note that in most cases, the value of the \f3-target\fR option is the value of the \f3-source\fR option; in this example, you can omit the \f3-target\fR option\&.
-.PP
-You must specify the \f3-bootclasspath\fR option to specify the correct version of the bootstrap classes (the \f3rt\&.jar\fR library)\&. If not, then the compiler generates a warning:
-.sp     
-.nf     
-\f3javac \-source 1\&.7 OldCode\&.java\fP
-.fi     
-.nf     
-\f3warning: [options] bootstrap class path not set in conjunction with \fP
-.fi     
-.nf     
-\f3\-source 1\&.7\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-If you do not specify the correct version of bootstrap classes, then the compiler uses the old language rules (in this example, it uses version 1\&.7 of the Java programming language) combined with the new bootstrap classes, which can result in class files that do not work on the older platform (in this case, Java SE 7) because reference to nonexistent methods can get included\&.
-.PP
-\f3Example 5 Cross Compile\fR
-.PP
-This example uses \f3javac\fR to compile code that runs on JVM 1\&.7\&.
-.sp     
-.nf     
-\f3javac \-source 1\&.7 \-target 1\&.7 \-bootclasspath jdk1\&.7\&.0/lib/rt\&.jar \e\fP
-.fi     
-.nf     
-\f3            \-extdirs "" OldCode\&.java\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-The\f3-source 1\&.7\fR option specifies that release 1\&.7 (or 7) of the Java programming language to be used to compile OldCode\&.java\&. The \f3-target 1\&.7\fR option ensures that the generated class files are compatible with JVM 1\&.7\&.
-.PP
-You must specify the \f3-bootclasspath\fR option to specify the correct version of the bootstrap classes (the \f3rt\&.jar\fR library)\&. If not, then the compiler generates a warning:
-.sp     
-.nf     
-\f3javac \-source 1\&.7 OldCode\&.java\fP
-.fi     
-.nf     
-\f3warning: [options] bootstrap class path not set in conjunction with \-source 1\&.7\fP
-.fi     
-.nf     
-\f3\fP
-.fi     
-.sp     
-If you do not specify the correct version of bootstrap classes, then the compiler uses the old language rules combined with the new bootstrap classes\&. This combination can result in class files that do not work on the older platform (in this case, Java SE 7) because reference to nonexistent methods can get included\&. In this example, the compiler uses release 1\&.7 of the Java programming language\&.
-.SH SEE\ ALSO    
-.TP 0.2i    
-\(bu
-java(1)
-.TP 0.2i    
-\(bu
-jdb(1)
-.TP 0.2i    
-\(bu
-javadoc(1)
-.TP 0.2i    
-\(bu
-jar(1)
-.TP 0.2i    
-\(bu
-jdb(1)
-.RE
-.br
-'pl 8.5i
-'bp
+.IP
+.nf
+\f[CB]
+warning:\ [static]\ static\ method\ should\ be\ qualified\ by\ type\ name,
+XLintStatic,\ instead\ of\ by\ an\ expression
+\f[R]
+.fi
+.PP
+To resolve this issue, you can call the \f[CB]static\f[R] method
+\f[CB]m1\f[R] as follows:
+.RS
+.PP
+\f[CB]XLintStatic.m1();\f[R]
+.RE
+.PP
+Alternately, you can remove the \f[CB]static\f[R] keyword from the
+declaration of the method \f[CB]m1\f[R].
+.RE
+.TP
+.B \f[CB]try\f[R]
+Warns about issues relating to the use of \f[CB]try\f[R] blocks, including
+try\-with\-resources statements.
+For example, a warning is generated for the following statement because
+the resource \f[CB]ac\f[R] declared in the \f[CB]try\f[R] block is not used:
+.RS
+.IP
+.nf
+\f[CB]
+try\ (\ AutoCloseable\ ac\ =\ getResource()\ )\ {\ \ \ \ //\ do\ nothing}
+\f[R]
+.fi
+.RE
+.TP
+.B \f[CB]unchecked\f[R]
+Gives more detail for unchecked conversion warnings that are mandated by
+the Java Language Specification, for example:
+.RS
+.IP
+.nf
+\f[CB]
+List\ l\ =\ new\ ArrayList<Number>();
+List<String>\ ls\ =\ l;\ \ \ \ \ \ \ //\ unchecked\ warning
+\f[R]
+.fi
+.PP
+During type erasure, the types \f[CB]ArrayList<Number>\f[R] and
+\f[CB]List<String>\f[R] become \f[CB]ArrayList\f[R] and \f[CB]List\f[R],
+respectively.
+.PP
+The \f[CB]ls\f[R] command has the parameterized type
+\f[CB]List<String>\f[R].
+When the \f[CB]List\f[R] referenced by \f[CB]l\f[R] is assigned to
+\f[CB]ls\f[R], the compiler generates an unchecked warning.
+At compile time, the compiler and JVM cannot determine whether
+\f[CB]l\f[R] refers to a \f[CB]List<String>\f[R] type.
+In this case, \f[CB]l\f[R] does not refer to a \f[CB]List<String>\f[R] type.
+As a result, heap pollution occurs.
+.PP
+A heap pollution situation occurs when the \f[CB]List\f[R] object
+\f[CB]l\f[R], whose static type is \f[CB]List<Number>\f[R], is assigned to
+another \f[CB]List\f[R] object, \f[CB]ls\f[R], that has a different static
+type, \f[CB]List<String>\f[R].
+However, the compiler still allows this assignment.
+It must allow this assignment to preserve backward compatibility with
+releases of Java SE that do not support generics.
+Because of type erasure, \f[CB]List<Number>\f[R] and \f[CB]List<String>\f[R]
+both become \f[CB]List\f[R].
+Consequently, the compiler allows the assignment of the object
+\f[CB]l\f[R], which has a raw type of \f[CB]List\f[R], to the object
+\f[CB]ls\f[R].
+.RE
+.TP
+.B \f[CB]varargs\f[R]
+Warns about unsafe use of variable arguments (\f[CB]varargs\f[R]) methods,
+in particular, those that contain non\-reifiable arguments, for example:
+.RS
+.IP
+.nf
+\f[CB]
+public\ class\ ArrayBuilder\ {
+\ \ public\ static\ <T>\ void\ addToList\ (List<T>\ listArg,\ T...\ elements)\ {
+\ \ \ \ for\ (T\ x\ :\ elements)\ {
+\ \ \ \ \ \ listArg.add(x);
+\ \ \ \ }
+\ \ }
+}
+\f[R]
+.fi
+.PP
+A non\-reifiable type is a type whose type information is not fully
+available at runtime.
+.PP
+The compiler generates the following warning for the definition of the
+method \f[CB]ArrayBuilder.addToList\f[R]:
+.IP
+.nf
+\f[CB]
+warning:\ [varargs]\ Possible\ heap\ pollution\ from\ parameterized\ vararg\ type\ T
+\f[R]
+.fi
+.PP
+When the compiler encounters a varargs method, it translates the
+\f[CB]varargs\f[R] formal parameter into an array.
+However, the Java programming language does not permit the creation of
+arrays of parameterized types.
+In the method \f[CB]ArrayBuilder.addToList\f[R], the compiler translates
+the \f[CB]varargs\f[R] formal parameter \f[CB]T...\f[R] elements to the
+formal parameter \f[CB]T[]\f[R] elements, an array.
+However, because of type erasure, the compiler converts the
+\f[CB]varargs\f[R] formal parameter to \f[CB]Object[]\f[R] elements.
+Consequently, there\[aq]s a possibility of heap pollution.
+.RE

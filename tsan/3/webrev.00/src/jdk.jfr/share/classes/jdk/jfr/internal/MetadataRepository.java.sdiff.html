<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MetadataReader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MetadataWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 29 import static jdk.jfr.internal.LogTag.JFR_SYSTEM;
 30 
 31 import java.io.ByteArrayOutputStream;
 32 import java.io.DataOutputStream;
 33 import java.io.IOException;
 34 import java.util.ArrayList;
 35 import java.util.Collections;
 36 import java.util.HashMap;
 37 import java.util.HashSet;
 38 import java.util.List;
 39 import java.util.Map;
 40 
 41 import jdk.jfr.AnnotationElement;
 42 import jdk.jfr.Event;
 43 import jdk.jfr.EventType;
 44 import jdk.jfr.Period;
 45 import jdk.jfr.StackTrace;
 46 import jdk.jfr.Threshold;
 47 import jdk.jfr.ValueDescriptor;
 48 import jdk.jfr.internal.RequestEngine.RequestHook;

 49 import jdk.jfr.internal.handlers.EventHandler;
 50 
 51 public final class MetadataRepository {
 52 
 53     private static final JVM jvm = JVM.getJVM();
 54     private static final MetadataRepository instace = new MetadataRepository();
 55 
 56     private final List&lt;EventType&gt; nativeEventTypes = new ArrayList&lt;&gt;(100);
 57     private final List&lt;EventControl&gt; nativeControls = new ArrayList&lt;EventControl&gt;(100);
 58     private final TypeLibrary typeLibrary = TypeLibrary.getInstance();
 59     private final SettingsManager settingsManager = new SettingsManager();
 60     private final Map&lt;String, Class&lt;? extends Event&gt;&gt; mirrors = new HashMap&lt;&gt;();
 61     private boolean staleMetadata = true;
 62     private boolean unregistered;
 63     private long lastUnloaded = -1;
 64 
 65     public MetadataRepository() {
 66         initializeJVMEventTypes();
 67     }
 68 
</pre>
<hr />
<pre>
190            handlerClass = ehc.makeEventHandlerClass();
191            Logger.log(LogTag.JFR_SYSTEM, DEBUG, &quot;Created event handler for &quot; + eventType.getName());
192        }
193         EventHandler handler = EventHandlerCreator.instantiateEventHandler(handlerClass, true, eventType, ec);
194         Utils.setHandler(eventClass, handler);
195         return handler;
196     }
197 
198 
199     public synchronized void setSettings(List&lt;Map&lt;String, String&gt;&gt; list) {
200         settingsManager.setSettings(list);
201     }
202 
203     synchronized void disableEvents() {
204         for (EventControl c : getEventControls()) {
205             c.disable();
206         }
207     }
208 
209     public synchronized List&lt;EventControl&gt; getEventControls() {
<span class="line-modified">210         List&lt;EventControl&gt; controls = new ArrayList&lt;&gt;();</span>

211         controls.addAll(nativeControls);
<span class="line-modified">212         for (EventHandler eh : getEventHandlers()) {</span>
<span class="line-modified">213             controls.add(eh.getEventControl());</span>



214         }
215         return controls;
216     }
217 
218     private void storeDescriptorInJVM() throws InternalError {
219         jvm.storeMetadataDescriptor(getBinaryRepresentation());
220         staleMetadata = false;
221     }
222 
223     private static List&lt;EventHandler&gt; getEventHandlers() {
224         List&lt;Class&lt;? extends jdk.internal.event.Event&gt;&gt; allEventClasses = jvm.getAllEventClasses();
225         List&lt;EventHandler&gt; eventHandlers = new ArrayList&lt;&gt;(allEventClasses.size());
226         for (Class&lt;? extends jdk.internal.event.Event&gt; clazz : allEventClasses) {
227             EventHandler eh = Utils.getHandler(clazz);
228             if (eh != null) {
229                 eventHandlers.add(eh);
230             }
231         }
232         return eventHandlers;
233     }
</pre>
<hr />
<pre>
238         try {
239             List&lt;Type&gt; types = typeLibrary.getTypes();
240             Collections.sort(types);
241             MetadataDescriptor.write(types, daos);
242             daos.flush();
243             return baos.toByteArray();
244         } catch (IOException e) {
245             // should not happen
246             throw new InternalError(e);
247         }
248     }
249 
250     synchronized boolean isEnabled(String eventName) {
251         return settingsManager.isEnabled(eventName);
252     }
253 
254     synchronized void setStaleMetadata() {
255         staleMetadata = true;
256     }
257 
<span class="line-modified">258     // Lock around setOutput ensures that other threads dosn&#39;t</span>
<span class="line-modified">259     // emit event after setOutput and unregister the event class, before a call</span>
260     // to storeDescriptorInJVM
261     synchronized void setOutput(String filename) {



262         jvm.setOutput(filename);
<span class="line-modified">263 </span>


264         unregisterUnloaded();
265         if (unregistered) {
<span class="line-modified">266             staleMetadata = typeLibrary.clearUnregistered();</span>


267             unregistered = false;
268         }
<span class="line-removed">269         if (staleMetadata) {</span>
<span class="line-removed">270             storeDescriptorInJVM();</span>
<span class="line-removed">271         }</span>
272     }
273 
274     private void unregisterUnloaded() {
275         long unloaded = jvm.getUnloadedEventClassCount();
276         if (this.lastUnloaded != unloaded) {
277             this.lastUnloaded = unloaded;
278             List&lt;Class&lt;? extends jdk.internal.event.Event&gt;&gt; eventClasses = jvm.getAllEventClasses();
279             HashSet&lt;Long&gt; knownIds = new HashSet&lt;&gt;(eventClasses.size());
280             for (Class&lt;? extends jdk.internal.event.Event&gt;  ec: eventClasses) {
281                 knownIds.add(Type.getTypeId(ec));
282             }
283             for (Type type : typeLibrary.getTypes()) {
284                 if (type instanceof PlatformEventType) {
285                     if (!knownIds.contains(type.getId())) {
286                         PlatformEventType pe = (PlatformEventType) type;
287                         if (!pe.isJVM()) {
288                             pe.setRegistered(false);
289                         }
290                     }
291                 }
292             }
293         }
294     }
295 
296     synchronized void setUnregistered() {
297        unregistered = true;
298     }
299 
300     public synchronized void registerMirror(Class&lt;? extends Event&gt; eventClass) {
301         MirrorEvent me = eventClass.getAnnotation(MirrorEvent.class);
302         if (me != null) {
303             String fullName = me.module() + &quot;:&quot; + me.className();
304             mirrors.put(fullName, eventClass);
305             return;
306         }
307         throw new InternalError(&quot;Mirror class must have annotation &quot; + MirrorEvent.class.getName());
308     }
309 







310 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 29 import static jdk.jfr.internal.LogTag.JFR_SYSTEM;
 30 
 31 import java.io.ByteArrayOutputStream;
 32 import java.io.DataOutputStream;
 33 import java.io.IOException;
 34 import java.util.ArrayList;
 35 import java.util.Collections;
 36 import java.util.HashMap;
 37 import java.util.HashSet;
 38 import java.util.List;
 39 import java.util.Map;
 40 
 41 import jdk.jfr.AnnotationElement;
 42 import jdk.jfr.Event;
 43 import jdk.jfr.EventType;
 44 import jdk.jfr.Period;
 45 import jdk.jfr.StackTrace;
 46 import jdk.jfr.Threshold;
 47 import jdk.jfr.ValueDescriptor;
 48 import jdk.jfr.internal.RequestEngine.RequestHook;
<span class="line-added"> 49 import jdk.jfr.internal.consumer.RepositoryFiles;</span>
 50 import jdk.jfr.internal.handlers.EventHandler;
 51 
 52 public final class MetadataRepository {
 53 
 54     private static final JVM jvm = JVM.getJVM();
 55     private static final MetadataRepository instace = new MetadataRepository();
 56 
 57     private final List&lt;EventType&gt; nativeEventTypes = new ArrayList&lt;&gt;(100);
 58     private final List&lt;EventControl&gt; nativeControls = new ArrayList&lt;EventControl&gt;(100);
 59     private final TypeLibrary typeLibrary = TypeLibrary.getInstance();
 60     private final SettingsManager settingsManager = new SettingsManager();
 61     private final Map&lt;String, Class&lt;? extends Event&gt;&gt; mirrors = new HashMap&lt;&gt;();
 62     private boolean staleMetadata = true;
 63     private boolean unregistered;
 64     private long lastUnloaded = -1;
 65 
 66     public MetadataRepository() {
 67         initializeJVMEventTypes();
 68     }
 69 
</pre>
<hr />
<pre>
191            handlerClass = ehc.makeEventHandlerClass();
192            Logger.log(LogTag.JFR_SYSTEM, DEBUG, &quot;Created event handler for &quot; + eventType.getName());
193        }
194         EventHandler handler = EventHandlerCreator.instantiateEventHandler(handlerClass, true, eventType, ec);
195         Utils.setHandler(eventClass, handler);
196         return handler;
197     }
198 
199 
200     public synchronized void setSettings(List&lt;Map&lt;String, String&gt;&gt; list) {
201         settingsManager.setSettings(list);
202     }
203 
204     synchronized void disableEvents() {
205         for (EventControl c : getEventControls()) {
206             c.disable();
207         }
208     }
209 
210     public synchronized List&lt;EventControl&gt; getEventControls() {
<span class="line-modified">211         List&lt;Class&lt;? extends jdk.internal.event.Event&gt;&gt; eventClasses = jvm.getAllEventClasses();</span>
<span class="line-added">212         ArrayList&lt;EventControl&gt; controls = new ArrayList&lt;&gt;(eventClasses.size() + nativeControls.size());</span>
213         controls.addAll(nativeControls);
<span class="line-modified">214         for (Class&lt;? extends jdk.internal.event.Event&gt; clazz : eventClasses) {</span>
<span class="line-modified">215             EventHandler eh = Utils.getHandler(clazz);</span>
<span class="line-added">216             if (eh != null) {</span>
<span class="line-added">217                 controls.add(eh.getEventControl());</span>
<span class="line-added">218             }</span>
219         }
220         return controls;
221     }
222 
223     private void storeDescriptorInJVM() throws InternalError {
224         jvm.storeMetadataDescriptor(getBinaryRepresentation());
225         staleMetadata = false;
226     }
227 
228     private static List&lt;EventHandler&gt; getEventHandlers() {
229         List&lt;Class&lt;? extends jdk.internal.event.Event&gt;&gt; allEventClasses = jvm.getAllEventClasses();
230         List&lt;EventHandler&gt; eventHandlers = new ArrayList&lt;&gt;(allEventClasses.size());
231         for (Class&lt;? extends jdk.internal.event.Event&gt; clazz : allEventClasses) {
232             EventHandler eh = Utils.getHandler(clazz);
233             if (eh != null) {
234                 eventHandlers.add(eh);
235             }
236         }
237         return eventHandlers;
238     }
</pre>
<hr />
<pre>
243         try {
244             List&lt;Type&gt; types = typeLibrary.getTypes();
245             Collections.sort(types);
246             MetadataDescriptor.write(types, daos);
247             daos.flush();
248             return baos.toByteArray();
249         } catch (IOException e) {
250             // should not happen
251             throw new InternalError(e);
252         }
253     }
254 
255     synchronized boolean isEnabled(String eventName) {
256         return settingsManager.isEnabled(eventName);
257     }
258 
259     synchronized void setStaleMetadata() {
260         staleMetadata = true;
261     }
262 
<span class="line-modified">263     // Lock around setOutput ensures that other threads don&#39;t</span>
<span class="line-modified">264     // emit events after setOutput and unregister the event class, before a call</span>
265     // to storeDescriptorInJVM
266     synchronized void setOutput(String filename) {
<span class="line-added">267         if (staleMetadata) {</span>
<span class="line-added">268             storeDescriptorInJVM();</span>
<span class="line-added">269         }</span>
270         jvm.setOutput(filename);
<span class="line-modified">271         if (filename != null) {</span>
<span class="line-added">272             RepositoryFiles.notifyNewFile();</span>
<span class="line-added">273         }</span>
274         unregisterUnloaded();
275         if (unregistered) {
<span class="line-modified">276             if (typeLibrary.clearUnregistered()) {</span>
<span class="line-added">277                 storeDescriptorInJVM();</span>
<span class="line-added">278             }</span>
279             unregistered = false;
280         }



281     }
282 
283     private void unregisterUnloaded() {
284         long unloaded = jvm.getUnloadedEventClassCount();
285         if (this.lastUnloaded != unloaded) {
286             this.lastUnloaded = unloaded;
287             List&lt;Class&lt;? extends jdk.internal.event.Event&gt;&gt; eventClasses = jvm.getAllEventClasses();
288             HashSet&lt;Long&gt; knownIds = new HashSet&lt;&gt;(eventClasses.size());
289             for (Class&lt;? extends jdk.internal.event.Event&gt;  ec: eventClasses) {
290                 knownIds.add(Type.getTypeId(ec));
291             }
292             for (Type type : typeLibrary.getTypes()) {
293                 if (type instanceof PlatformEventType) {
294                     if (!knownIds.contains(type.getId())) {
295                         PlatformEventType pe = (PlatformEventType) type;
296                         if (!pe.isJVM()) {
297                             pe.setRegistered(false);
298                         }
299                     }
300                 }
301             }
302         }
303     }
304 
305     synchronized void setUnregistered() {
306        unregistered = true;
307     }
308 
309     public synchronized void registerMirror(Class&lt;? extends Event&gt; eventClass) {
310         MirrorEvent me = eventClass.getAnnotation(MirrorEvent.class);
311         if (me != null) {
312             String fullName = me.module() + &quot;:&quot; + me.className();
313             mirrors.put(fullName, eventClass);
314             return;
315         }
316         throw new InternalError(&quot;Mirror class must have annotation &quot; + MirrorEvent.class.getName());
317     }
318 
<span class="line-added">319     public synchronized void flush() {</span>
<span class="line-added">320         if (staleMetadata) {</span>
<span class="line-added">321             storeDescriptorInJVM();</span>
<span class="line-added">322         }</span>
<span class="line-added">323         jvm.flush();</span>
<span class="line-added">324     }</span>
<span class="line-added">325 </span>
326 }
</pre>
</td>
</tr>
</table>
<center><a href="MetadataReader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MetadataWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
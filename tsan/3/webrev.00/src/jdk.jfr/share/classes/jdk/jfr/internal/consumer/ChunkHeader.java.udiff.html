<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/ChunkHeader.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../WriteableUserPath.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RecordingInput.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/ChunkHeader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,109 +23,208 @@</span>
   * questions.
   */
  
  package jdk.jfr.internal.consumer;
  
<span class="udiff-line-removed">- import java.io.DataInput;</span>
  import java.io.IOException;
  
  import jdk.jfr.internal.LogLevel;
  import jdk.jfr.internal.LogTag;
  import jdk.jfr.internal.Logger;
  import jdk.jfr.internal.MetadataDescriptor;
<span class="udiff-line-added">+ import jdk.jfr.internal.Utils;</span>
  
  public final class ChunkHeader {
<span class="udiff-line-added">+     private static final long HEADER_SIZE = 68;</span>
<span class="udiff-line-added">+     private static final byte UPDATING_CHUNK_HEADER = (byte) 255;</span>
<span class="udiff-line-added">+     private static final long CHUNK_SIZE_POSITION = 8;</span>
<span class="udiff-line-added">+     private static final long DURATION_NANOS_POSITION = 40;</span>
<span class="udiff-line-added">+     private static final long FILE_STATE_POSITION = 64;</span>
<span class="udiff-line-added">+     private static final long FLAG_BYTE_POSITION = 67;</span>
      private static final long METADATA_TYPE_ID = 0;
      private static final byte[] FILE_MAGIC = { &#39;F&#39;, &#39;L&#39;, &#39;R&#39;, &#39;\0&#39; };
<span class="udiff-line-added">+     private static final int MASK_FINAL_CHUNK = 1 &lt;&lt; 1;</span>
  
      private final short major;
      private final short minor;
<span class="udiff-line-removed">-     private final long chunkSize;</span>
      private final long chunkStartTicks;
      private final long ticksPerSecond;
      private final long chunkStartNanos;
<span class="udiff-line-removed">-     private final long metadataPosition;</span>
<span class="udiff-line-removed">-  //   private final long absoluteInitialConstantPoolPosition;</span>
<span class="udiff-line-removed">-     private final long absoluteChunkEnd;</span>
<span class="udiff-line-removed">-     private final long absoluteEventStart;</span>
      private final long absoluteChunkStart;
<span class="udiff-line-removed">-     private final boolean lastChunk;</span>
      private final RecordingInput input;
<span class="udiff-line-removed">-     private final long durationNanos;</span>
      private final long id;
<span class="udiff-line-modified-removed">-     private long constantPoolPosition;</span>
<span class="udiff-line-modified-added">+     private long absoluteEventStart;</span>
<span class="udiff-line-added">+     private long chunkSize = 0;</span>
<span class="udiff-line-added">+     private long constantPoolPosition = 0;</span>
<span class="udiff-line-added">+     private long metadataPosition = 0;</span>
<span class="udiff-line-added">+     private long durationNanos;</span>
<span class="udiff-line-added">+     private long absoluteChunkEnd;</span>
<span class="udiff-line-added">+     private boolean isFinished;</span>
<span class="udiff-line-added">+     private boolean finished;</span>
<span class="udiff-line-added">+     private boolean finalChunk;</span>
  
      public ChunkHeader(RecordingInput input) throws IOException {
          this(input, 0, 0);
      }
  
      private ChunkHeader(RecordingInput input, long absoluteChunkStart, long id) throws IOException {
<span class="udiff-line-added">+         this.absoluteChunkStart = absoluteChunkStart;</span>
<span class="udiff-line-added">+         this.absoluteEventStart = absoluteChunkStart + HEADER_SIZE;</span>
<span class="udiff-line-added">+         if (input.getFileSize() &lt; HEADER_SIZE) {</span>
<span class="udiff-line-added">+             throw new IOException(&quot;Not a complete Chunk header&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         input.setValidSize(absoluteChunkStart + HEADER_SIZE);</span>
          input.position(absoluteChunkStart);
          if (input.position() &gt;= input.size()) {
<span class="udiff-line-modified-removed">-             throw new IOException(&quot;Chunk contains no data&quot;);</span>
<span class="udiff-line-modified-added">+            throw new IOException(&quot;Chunk contains no data&quot;);</span>
          }
          verifyMagic(input);
          this.input = input;
          this.id = id;
<span class="udiff-line-modified-removed">-         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk &quot; + id);</span>
<span class="udiff-line-modified-added">+         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: &quot; + id);</span>
<span class="udiff-line-added">+         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: file=&quot; + input.getFilename());</span>
          Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: startPosition=&quot; + absoluteChunkStart);
          major = input.readRawShort();
          Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: major=&quot; + major);
          minor = input.readRawShort();
          Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: minor=&quot; + minor);
          if (major != 1 &amp;&amp; major != 2) {
              throw new IOException(&quot;File version &quot; + major + &quot;.&quot; + minor + &quot;. Only Flight Recorder files of version 1.x and 2.x can be read by this JDK.&quot;);
          }
<span class="udiff-line-modified-removed">-         chunkSize = input.readRawLong();</span>
<span class="udiff-line-modified-added">+         input.readRawLong(); // chunk size</span>
          Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: chunkSize=&quot; + chunkSize);
<span class="udiff-line-modified-removed">-         this.constantPoolPosition = input.readRawLong();</span>
<span class="udiff-line-modified-added">+         input.readRawLong(); // constant pool position</span>
          Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: constantPoolPosition=&quot; + constantPoolPosition);
<span class="udiff-line-modified-removed">-         metadataPosition = input.readRawLong();</span>
<span class="udiff-line-modified-added">+         input.readRawLong(); // metadata position</span>
          Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: metadataPosition=&quot; + metadataPosition);
          chunkStartNanos = input.readRawLong(); // nanos since epoch
          Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: startNanos=&quot; + chunkStartNanos);
          durationNanos = input.readRawLong(); // duration nanos, not used
          Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: durationNanos=&quot; + durationNanos);
          chunkStartTicks = input.readRawLong();
          Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: startTicks=&quot; + chunkStartTicks);
          ticksPerSecond = input.readRawLong();
          Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: ticksPerSecond=&quot; + ticksPerSecond);
<span class="udiff-line-modified-removed">-         input.readRawInt(); // features, not used</span>
<span class="udiff-line-modified-added">+         input.readRawInt(); // ignore file state and flag bits</span>
<span class="udiff-line-added">+         refresh();</span>
<span class="udiff-line-added">+         input.position(absoluteEventStart);</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         // set up boundaries</span>
<span class="udiff-line-modified-removed">-         this.absoluteChunkStart = absoluteChunkStart;</span>
<span class="udiff-line-modified-removed">-         absoluteChunkEnd = absoluteChunkStart + chunkSize;</span>
<span class="udiff-line-modified-removed">-         lastChunk = input.size() == absoluteChunkEnd;</span>
<span class="udiff-line-modified-removed">-         absoluteEventStart = input.position();</span>
<span class="udiff-line-modified-added">+     void refresh() throws IOException {</span>
<span class="udiff-line-modified-added">+         while (true) {</span>
<span class="udiff-line-modified-added">+             byte fileState1;</span>
<span class="udiff-line-modified-added">+             input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);</span>
<span class="udiff-line-modified-added">+             while ((fileState1 = input.readPhysicalByte()) == UPDATING_CHUNK_HEADER) {</span>
<span class="udiff-line-added">+                 Utils.takeNap(1);</span>
<span class="udiff-line-added">+                 input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             input.positionPhysical(absoluteChunkStart + CHUNK_SIZE_POSITION);</span>
<span class="udiff-line-added">+             long chunkSize = input.readPhysicalLong();</span>
<span class="udiff-line-added">+             long constantPoolPosition = input.readPhysicalLong();</span>
<span class="udiff-line-added">+             long metadataPosition = input.readPhysicalLong();</span>
<span class="udiff-line-added">+             input.positionPhysical(absoluteChunkStart + DURATION_NANOS_POSITION);</span>
<span class="udiff-line-added">+             long durationNanos = input.readPhysicalLong();</span>
<span class="udiff-line-added">+             input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);</span>
<span class="udiff-line-added">+             byte fileState2 =  input.readPhysicalByte();</span>
<span class="udiff-line-added">+             input.positionPhysical(absoluteChunkStart + FLAG_BYTE_POSITION);</span>
<span class="udiff-line-added">+             int flagByte = input.readPhysicalByte();</span>
<span class="udiff-line-added">+             if (fileState1 == fileState2) { // valid header</span>
<span class="udiff-line-added">+                 finished = fileState1 == 0;</span>
<span class="udiff-line-added">+                 if (metadataPosition != 0) {</span>
<span class="udiff-line-added">+                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Setting input size to &quot; + (absoluteChunkStart + chunkSize));</span>
<span class="udiff-line-added">+                     if (finished) {</span>
<span class="udiff-line-added">+                         // This assumes that the whole recording</span>
<span class="udiff-line-added">+                         // is finished if the first chunk is.</span>
<span class="udiff-line-added">+                         // This is a limitation we may want to</span>
<span class="udiff-line-added">+                         // remove, but greatly improves performance as</span>
<span class="udiff-line-added">+                         // data can be read across chunk boundaries</span>
<span class="udiff-line-added">+                         // of multi-chunk files and only once.</span>
<span class="udiff-line-added">+                         input.setValidSize(input.getFileSize());</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         input.setValidSize(absoluteChunkStart + chunkSize);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     this.chunkSize = chunkSize;</span>
<span class="udiff-line-added">+                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: chunkSize=&quot; + chunkSize);</span>
<span class="udiff-line-added">+                     this.constantPoolPosition = constantPoolPosition;</span>
<span class="udiff-line-added">+                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: constantPoolPosition=&quot; + constantPoolPosition);</span>
<span class="udiff-line-added">+                     this.metadataPosition = metadataPosition;</span>
<span class="udiff-line-added">+                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: metadataPosition=&quot; + metadataPosition);</span>
<span class="udiff-line-added">+                     this.durationNanos = durationNanos;</span>
<span class="udiff-line-added">+                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: durationNanos =&quot; + durationNanos);</span>
<span class="udiff-line-added">+                     isFinished = fileState2 == 0;</span>
<span class="udiff-line-added">+                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: generation=&quot; + fileState2);</span>
<span class="udiff-line-added">+                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: finished=&quot; + isFinished);</span>
<span class="udiff-line-added">+                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: fileSize=&quot; + input.size());</span>
<span class="udiff-line-added">+                     this.finalChunk = (flagByte &amp; MASK_FINAL_CHUNK) != 0;</span>
<span class="udiff-line-added">+                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: finalChunk=&quot; + finalChunk);</span>
<span class="udiff-line-added">+                     absoluteChunkEnd = absoluteChunkStart + chunkSize;</span>
<span class="udiff-line-added">+                     return;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         // read metadata</span>
<span class="udiff-line-modified-removed">-         input.position(absoluteEventStart);</span>
<span class="udiff-line-modified-added">+     public void awaitFinished() throws IOException {</span>
<span class="udiff-line-modified-added">+         if (finished) {</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         long pos = input.position();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);</span>
<span class="udiff-line-added">+             while (true) {</span>
<span class="udiff-line-added">+                 byte filestate = input.readPhysicalByte();</span>
<span class="udiff-line-added">+                 if (filestate == 0) {</span>
<span class="udiff-line-added">+                     finished = true;</span>
<span class="udiff-line-added">+                     return;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 Utils.takeNap(1);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             input.position(pos);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public boolean isLastChunk() throws IOException {</span>
<span class="udiff-line-added">+         awaitFinished();</span>
<span class="udiff-line-added">+         // streaming files only have one chunk</span>
<span class="udiff-line-added">+         return input.getFileSize() == absoluteChunkEnd;</span>
<span class="udiff-line-added">+    }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public boolean isFinalChunk() {</span>
<span class="udiff-line-added">+         return finalChunk;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public boolean isFinished() throws IOException {</span>
<span class="udiff-line-added">+         return isFinished;</span>
      }
  
      public ChunkHeader nextHeader() throws IOException {
          return new ChunkHeader(input, absoluteChunkEnd, id + 1);
      }
<span class="udiff-line-removed">- </span>
      public MetadataDescriptor readMetadata() throws IOException {
<span class="udiff-line-added">+         return readMetadata(null);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public MetadataDescriptor readMetadata(MetadataDescriptor previous) throws IOException {</span>
          input.position(absoluteChunkStart + metadataPosition);
          input.readInt(); // size
          long id = input.readLong(); // event type id
          if (id != METADATA_TYPE_ID) {
              throw new IOException(&quot;Expected metadata event. Type id=&quot; + id + &quot;, should have been &quot; + METADATA_TYPE_ID);
          }
          input.readLong(); // start time
          input.readLong(); // duration
          long metadataId = input.readLong();
<span class="udiff-line-modified-removed">-         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE, &quot;Metadata id=&quot; + metadataId);</span>
<span class="udiff-line-modified-removed">-         // No need to read if metadataId == lastMetadataId, but we</span>
<span class="udiff-line-modified-removed">-         // do it for verification purposes.</span>
<span class="udiff-line-modified-removed">-         return MetadataDescriptor.read(input);</span>
<span class="udiff-line-modified-added">+         if (previous != null &amp;&amp; metadataId == previous.metadataId) {</span>
<span class="udiff-line-modified-added">+             return previous;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE, &quot;New metadata id = &quot; + metadataId);</span>
<span class="udiff-line-added">+         MetadataDescriptor m =  MetadataDescriptor.read(input);</span>
<span class="udiff-line-added">+         m.metadataId = metadataId;</span>
<span class="udiff-line-added">+         return m;</span>
      }
  
<span class="udiff-line-removed">-     public boolean isLastChunk() {</span>
<span class="udiff-line-removed">-         return lastChunk;</span>
<span class="udiff-line-removed">-     }</span>
  
      public short getMajor() {
          return major;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -135,17 +234,26 @@</span>
  
      public long getAbsoluteChunkStart() {
          return absoluteChunkStart;
      }
  
<span class="udiff-line-added">+     public long getAbsoluteEventStart() {</span>
<span class="udiff-line-added">+         return absoluteEventStart;</span>
<span class="udiff-line-added">+     }</span>
      public long getConstantPoolPosition() {
          return constantPoolPosition;
      }
  
<span class="udiff-line-added">+     public long getMetataPosition() {</span>
<span class="udiff-line-added">+         return metadataPosition;</span>
<span class="udiff-line-added">+     }</span>
      public long getStartTicks() {
          return chunkStartTicks;
      }
<span class="udiff-line-added">+     public long getChunkSize() {</span>
<span class="udiff-line-added">+         return chunkSize;</span>
<span class="udiff-line-added">+     }</span>
  
      public double getTicksPerSecond() {
          return ticksPerSecond;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -167,11 +275,11 @@</span>
  
      public RecordingInput getInput() {
          return input;
      }
  
<span class="udiff-line-modified-removed">-     private static void verifyMagic(DataInput input) throws IOException {</span>
<span class="udiff-line-modified-added">+     private static void verifyMagic(RecordingInput input) throws IOException {</span>
          for (byte c : FILE_MAGIC) {
              if (input.readByte() != c) {
                  throw new IOException(&quot;Not a Flight Recorder file&quot;);
              }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -179,6 +287,13 @@</span>
  
      public long getEventStart() {
          return absoluteEventStart;
      }
  
<span class="udiff-line-added">+     static long headerSize() {</span>
<span class="udiff-line-added">+         return HEADER_SIZE;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public long getLastNanos() {</span>
<span class="udiff-line-added">+         return getStartNanos() + getDurationNanos();</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="../WriteableUserPath.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RecordingInput.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
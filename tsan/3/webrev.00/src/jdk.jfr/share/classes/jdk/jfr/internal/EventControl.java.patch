diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -30,15 +30,11 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
 
 import jdk.internal.module.Modules;
 import jdk.jfr.AnnotationElement;
 import jdk.jfr.Enabled;
 import jdk.jfr.Name;
@@ -57,36 +53,43 @@
 
 // This class can't have a hard reference from PlatformEventType, since it
 // holds SettingControl instances that need to be released
 // when a class is unloaded (to avoid memory leaks).
 public final class EventControl {
-
+    final static class NamedControl {
+        public final String name;
+        public final Control control;
+        NamedControl(String name, Control control) {
+            this.name = name;
+            this.control = control;
+        }
+    }
     static final String FIELD_SETTING_PREFIX = "setting";
     private static final Type TYPE_ENABLED = TypeLibrary.createType(EnabledSetting.class);
     private static final Type TYPE_THRESHOLD = TypeLibrary.createType(ThresholdSetting.class);
     private static final Type TYPE_STACK_TRACE = TypeLibrary.createType(StackTraceSetting.class);
     private static final Type TYPE_PERIOD = TypeLibrary.createType(PeriodSetting.class);
     private static final Type TYPE_CUTOFF = TypeLibrary.createType(CutoffSetting.class);
 
-    private final List<SettingInfo> settingInfos = new ArrayList<>();
-    private final Map<String, Control> eventControls = new HashMap<>(5);
+    private final ArrayList<SettingInfo> settingInfos = new ArrayList<>();
+    private final ArrayList<NamedControl> namedControls = new ArrayList<>(5);
     private final PlatformEventType type;
     private final String idName;
 
     EventControl(PlatformEventType eventType) {
-        eventControls.put(Enabled.NAME, defineEnabled(eventType));
+        addControl(Enabled.NAME, defineEnabled(eventType));
         if (eventType.hasDuration()) {
-            eventControls.put(Threshold.NAME, defineThreshold(eventType));
+            addControl(Threshold.NAME, defineThreshold(eventType));
         }
         if (eventType.hasStackTrace()) {
-            eventControls.put(StackTrace.NAME, defineStackTrace(eventType));
+            addControl(StackTrace.NAME, defineStackTrace(eventType));
         }
         if (eventType.hasPeriod()) {
-            eventControls.put(Period.NAME, definePeriod(eventType));
+            addControl(Period.NAME, definePeriod(eventType));
         }
         if (eventType.hasCutoff()) {
-            eventControls.put(Cutoff.NAME, defineCutoff(eventType));
+            addControl(Cutoff.NAME, defineCutoff(eventType));
         }
 
         ArrayList<AnnotationElement> aes = new ArrayList<>(eventType.getAnnotationElements());
         remove(eventType, aes, Threshold.class);
         remove(eventType, aes, Period.class);
@@ -97,10 +100,23 @@
         eventType.setAnnotations(aes);
         this.type = eventType;
         this.idName = String.valueOf(eventType.getId());
     }
 
+    private boolean hasControl(String name) {
+        for (NamedControl nc : namedControls) {
+            if (name.equals(nc.name)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void addControl(String name, Control control) {
+        namedControls.add(new NamedControl(name, control));
+    }
+
     static void remove(PlatformEventType type, List<AnnotationElement> aes, Class<? extends java.lang.annotation.Annotation> clazz) {
         long id = Type.getTypeId(clazz);
         for (AnnotationElement a : type.getAnnotationElements()) {
             if (a.getTypeId() == id && a.getTypeName().equals(clazz.getName())) {
                 aes.remove(a);
@@ -129,11 +145,12 @@
                             String name = m.getName();
                             Name n = m.getAnnotation(Name.class);
                             if (n != null) {
                                 name = n.value();
                             }
-                            if (!eventControls.containsKey(name)) {
+
+                            if (!hasControl(name)) {
                                 defineSetting((Class<? extends SettingControl>) settingClass, m, type, name);
                             }
                         }
                     }
                 }
@@ -161,11 +178,11 @@
                     if (ae != null) {
                         aes.add(ae);
                     }
                 }
                 aes.trimToSize();
-                eventControls.put(settingName, si.settingControl);
+                addControl(settingName, si.settingControl);
                 eventType.add(PrivateAccess.getInstance().newSettingDescriptor(settingType, settingName, defaultValue, aes));
                 settingInfos.add(si);
             }
         } catch (InstantiationException e) {
             // Programming error by user, fail fast
@@ -245,40 +262,39 @@
         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_PERIOD, PeriodSetting.NAME, def, Collections.emptyList()));
         return new PeriodSetting(type, def);
     }
 
     void disable() {
-        for (Control c : eventControls.values()) {
-            if (c instanceof EnabledSetting) {
-                c.setValueSafe("false");
+        for (NamedControl nc : namedControls) {
+            if (nc.control instanceof EnabledSetting) {
+                nc.control.setValueSafe("false");
                 return;
             }
         }
     }
 
     void writeActiveSettingEvent() {
         if (!type.isRegistered()) {
             return;
         }
-        for (Map.Entry<String, Control> entry : eventControls.entrySet()) {
-            Control c = entry.getValue();
-            if (Utils.isSettingVisible(c, type.hasEventHook())) {
-                String value = c.getLastValue();
+        ActiveSettingEvent event = ActiveSettingEvent.EVENT.get();
+        for (NamedControl nc : namedControls) {
+            if (Utils.isSettingVisible(nc.control, type.hasEventHook())) {
+                String value = nc.control.getLastValue();
                 if (value == null) {
-                    value = c.getDefaultValue();
+                    value = nc.control.getDefaultValue();
                 }
-                ActiveSettingEvent ase = new ActiveSettingEvent();
-                ase.id = type.getId();
-                ase.name = entry.getKey();
-                ase.value = value;
-                ase.commit();
+                event.id = type.getId();
+                event.name = nc.name;
+                event.value = value;
+                event.commit();
             }
         }
     }
 
-    public Set<Entry<String, Control>> getEntries() {
-        return eventControls.entrySet();
+    public ArrayList<NamedControl> getNamedControls() {
+        return namedControls;
     }
 
     public PlatformEventType getEventType() {
         return type;
     }

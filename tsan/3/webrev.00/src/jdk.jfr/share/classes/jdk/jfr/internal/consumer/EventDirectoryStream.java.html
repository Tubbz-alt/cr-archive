<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/EventDirectoryStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.security.AccessControlContext;
 31 import java.time.Instant;
 32 import java.util.Arrays;
 33 import java.util.Comparator;
 34 import java.util.Objects;
 35 
 36 import jdk.jfr.consumer.RecordedEvent;
 37 import jdk.jfr.internal.JVM;
 38 import jdk.jfr.internal.PlatformRecording;
 39 import jdk.jfr.internal.Utils;
 40 import jdk.jfr.internal.consumer.ChunkParser.ParserConfiguration;
 41 
 42 /**
 43  * Implementation of an {@code EventStream}} that operates against a directory
 44  * with chunk files.
 45  *
 46  */
 47 public class EventDirectoryStream extends AbstractEventStream {
 48 
 49     private final static Comparator&lt;? super RecordedEvent&gt; EVENT_COMPARATOR = JdkJfrConsumer.instance().eventComparator();
 50 
 51     private final RepositoryFiles repositoryFiles;
 52     private final PlatformRecording recording;
 53     private final FileAccess fileAccess;
 54 
 55     private ChunkParser currentParser;
 56     private long currentChunkStartNanos;
 57     private RecordedEvent[] sortedCache;
 58     private int threadExclusionLevel = 0;
 59 
 60     public EventDirectoryStream(AccessControlContext acc, Path p, FileAccess fileAccess, PlatformRecording recording) throws IOException {
 61         super(acc, recording);
 62         this.fileAccess = Objects.requireNonNull(fileAccess);
 63         this.recording = recording;
 64         this.repositoryFiles = new RepositoryFiles(fileAccess, p);
 65     }
 66 
 67     @Override
 68     public void close() {
 69         setClosed(true);
 70         dispatcher().runCloseActions();
 71         repositoryFiles.close();
 72         if (currentParser != null) {
 73             currentParser.close();
 74         }
 75     }
 76 
 77     @Override
 78     public void start() {
 79         start(Utils.timeToNanos(Instant.now()));
 80     }
 81 
 82     @Override
 83     public void startAsync() {
 84         startAsync(Utils.timeToNanos(Instant.now()));
 85     }
 86 
 87     @Override
 88     protected void process() throws IOException {
 89         JVM jvm = JVM.getJVM();
 90         Thread t = Thread.currentThread();
 91         try {
 92             if (jvm.isExcluded(t)) {
 93                 threadExclusionLevel++;
 94             } else {
 95                 jvm.exclude(t);
 96             }
 97             processRecursionSafe();
 98         } finally {
 99             if (threadExclusionLevel &gt; 0) {
100                 threadExclusionLevel--;
101             } else {
102                 jvm.include(t);
103             }
104         }
105     }
106 
107     protected void processRecursionSafe() throws IOException {
108         Dispatcher lastDisp = null;
109         Dispatcher disp = dispatcher();
110         Path path;
111         boolean validStartTime = recording != null || disp.startTime != null;
112         if (validStartTime) {
113             path = repositoryFiles.firstPath(disp.startNanos);
114         } else {
115             path = repositoryFiles.lastPath();
116         }
117         if (path == null) { // closed
118             return;
119         }
120         currentChunkStartNanos = repositoryFiles.getTimestamp(path);
121         try (RecordingInput input = new RecordingInput(path.toFile(), fileAccess)) {
122             currentParser = new ChunkParser(input, disp.parserConfiguration);
123             long segmentStart = currentParser.getStartNanos() + currentParser.getChunkDuration();
124             long filterStart = validStartTime ? disp.startNanos : segmentStart;
125             long filterEnd = disp.endTime != null ? disp.endNanos: Long.MAX_VALUE;
126 
127             while (!isClosed()) {
128                 while (!isClosed() &amp;&amp; !currentParser.isChunkFinished()) {
129                     disp = dispatcher();
130                     if (disp != lastDisp) {
131                         ParserConfiguration pc = disp.parserConfiguration;
132                         pc.filterStart = filterStart;
133                         pc.filterEnd = filterEnd;
134                         currentParser.updateConfiguration(pc, true);
135                         currentParser.setFlushOperation(getFlushOperation());
136                         lastDisp = disp;
137                     }
138                     if (disp.parserConfiguration.isOrdered()) {
139                         processOrdered(disp);
140                     } else {
141                         processUnordered(disp);
142                     }
143                     if (currentParser.getStartNanos() + currentParser.getChunkDuration() &gt; filterEnd) {
144                         close();
145                         return;
146                     }
147                 }
148                 if (isLastChunk()) {
149                     // Recording was stopped/closed externally, and no more data to process.
150                     return;
151                 }
152 
153                 if (repositoryFiles.hasFixedPath() &amp;&amp; currentParser.isFinalChunk()) {
154                     // JVM process exited/crashed, or repository migrated to an unknown location
155                     return;
156                 }
157                 if (isClosed()) {
158                     // Stream was closed
159                     return;
160                 }
161                 long durationNanos = currentParser.getChunkDuration();
162                 if (durationNanos == 0) {
163                     // Avoid reading the same chunk again and again if
164                     // duration is 0 ns
165                     durationNanos++;
166                 }
167                 path = repositoryFiles.nextPath(currentChunkStartNanos + durationNanos);
168                 if (path == null) {
169                     return; // stream closed
170                 }
171                 currentChunkStartNanos = repositoryFiles.getTimestamp(path);
172                 input.setFile(path);
173                 currentParser = currentParser.newChunkParser();
174                 // TODO: Optimization. No need filter when we reach new chunk
175                 // Could set start = 0;
176             }
177         }
178     }
179 
180     private boolean isLastChunk() {
181         if (recording == null) {
182             return false;
183         }
184         return recording.getFinalChunkStartNanos() &gt;= currentParser.getStartNanos();
185     }
186 
187     private void processOrdered(Dispatcher c) throws IOException {
188         if (sortedCache == null) {
189             sortedCache = new RecordedEvent[100_000];
190         }
191         int index = 0;
192         while (true) {
193             RecordedEvent e = currentParser.readStreamingEvent();
194             if (e == null) {
195                 break;
196             }
197             if (index == sortedCache.length) {
198                 sortedCache = Arrays.copyOf(sortedCache, sortedCache.length * 2);
199             }
200             sortedCache[index++] = e;
201         }
202         // no events found
203         if (index == 0 &amp;&amp; currentParser.isChunkFinished()) {
204             return;
205         }
206         // at least 2 events, sort them
207         if (index &gt; 1) {
208             Arrays.sort(sortedCache, 0, index, EVENT_COMPARATOR);
209         }
210         for (int i = 0; i &lt; index; i++) {
211             c.dispatch(sortedCache[i]);
212         }
213         return;
214     }
215 
216     private boolean processUnordered(Dispatcher c) throws IOException {
217         while (true) {
218             RecordedEvent e = currentParser.readStreamingEvent();
219             if (e == null) {
220                 return true;
221             } else {
222                 c.dispatch(e);
223             }
224         }
225     }
226 
227 }
    </pre>
  </body>
</html>
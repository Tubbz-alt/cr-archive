<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/RequestEngine.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="RepositoryChunk.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SecuritySupport.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/RequestEngine.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.security.AccessControlContext;
 29 import java.security.AccessController;
 30 import java.security.PrivilegedAction;
 31 import java.util.ArrayList;
 32 import java.util.Collection;

 33 import java.util.List;
 34 import java.util.Objects;
 35 import java.util.concurrent.CopyOnWriteArrayList;
 36 import java.util.function.Predicate;
 37 import jdk.jfr.Event;
 38 import jdk.jfr.EventType;
 39 
 40 public final class RequestEngine {
 41 
 42     private final static JVM jvm = JVM.getJVM();
 43 
 44     final static class RequestHook {
 45         private final Runnable hook;
 46         private final PlatformEventType type;
 47         private final AccessControlContext accessControllerContext;
 48         private long delta;
 49 
 50         // Java events
 51         private RequestHook(AccessControlContext acc, PlatformEventType eventType, Runnable hook) {
 52             this.hook = hook;
</pre>
<hr />
<pre>
 79 
 80         private void executeSecure() {
 81             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 82                 @Override
 83                 public Void run() {
 84                     try {
 85                         hook.run();
 86                         Logger.log(LogTag.JFR_EVENT, LogLevel.DEBUG, ()-&gt; &quot;Executed periodic hook for &quot; + type.getLogName());
 87                     } catch (Throwable t) {
 88                         // Prevent malicious user to propagate exception callback in the wrong context
 89                         Logger.log(LogTag.JFR_EVENT, LogLevel.WARN, &quot;Exception occured during execution of period hook for &quot; + type.getLogName());
 90                     }
 91                     return null;
 92                 }
 93             }, accessControllerContext);
 94         }
 95     }
 96 
 97     private final static List&lt;RequestHook&gt; entries = new CopyOnWriteArrayList&lt;&gt;();
 98     private static long lastTimeMillis;


 99 
100     public static void addHook(AccessControlContext acc, PlatformEventType type, Runnable hook) {
101         Objects.requireNonNull(acc);
102         addHookInternal(acc, type, hook);
103     }
104 
105     private static void addHookInternal(AccessControlContext acc, PlatformEventType type, Runnable hook) {
106         RequestHook he = new RequestHook(acc, type, hook);
107         for (RequestHook e : entries) {
108             if (e.hook == hook) {
109                 throw new IllegalArgumentException(&quot;Hook has already been added&quot;);
110             }
111         }
112         he.type.setEventHook(true);
113         // Insertion takes O(2*n), could be O(1) with HashMap, but
114         // thinking is that CopyOnWriteArrayList is faster
115         // to iterate over, which will happen more over time.
116         entries.add(he);
117         logHook(&quot;Added&quot;, type);
118     }
</pre>
<hr />
<pre>
192         // Keeping direct call os::elapsed_counter() here for reliable
193         // real time values in order to decide when registered requestable
194         // events are due.
195         long now = System.currentTimeMillis();
196         long min = 0;
197         long delta = 0;
198 
199         if (last == 0) {
200             last = now;
201         }
202 
203         // time from then to now
204         delta = now - last;
205 
206         if (delta &lt; 0) {
207             // to handle time adjustments
208             // for example Daylight Savings
209             lastTimeMillis = now;
210             return 0;
211         }
<span class="line-modified">212         for (RequestHook he : entries) {</span>


213             long left = 0;
214             PlatformEventType es = he.type;
215             // Not enabled, skip.
216             if (!es.isEnabled() || es.isEveryChunk()) {
217                 continue;
218             }
219             long r_period = es.getPeriod();
220             long r_delta = he.delta;
221 
222             // add time elapsed.
223             r_delta += delta;
224 
225             // above threshold?
226             if (r_delta &gt;= r_period) {
227                 // Bug 9000556 - don&#39;t try to compensate
228                 // for wait &gt; period
229                 r_delta = 0;
230                 he.execute();
<span class="line-removed">231                 ;</span>
232             }
233 
234             // calculate time left
235             left = (r_period - r_delta);
236 
237             /**
238              * nothing outside checks that a period is &gt;= 0, so left can end up
239              * negative here. ex. (r_period =(-1)) - (r_delta = 0) if it is,
240              * handle it.
241              */
242             if (left &lt; 0) {
243                 left = 0;
244             }
245 
246             // assign delta back
247             he.delta = r_delta;
248 
249             if (min == 0 || left &lt; min) {
250                 min = left;
251             }
252         }





















253         lastTimeMillis = now;
254         return min;
255     }











256 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.security.AccessControlContext;
 29 import java.security.AccessController;
 30 import java.security.PrivilegedAction;
 31 import java.util.ArrayList;
 32 import java.util.Collection;
<span class="line-added"> 33 import java.util.Iterator;</span>
 34 import java.util.List;
 35 import java.util.Objects;
 36 import java.util.concurrent.CopyOnWriteArrayList;
 37 import java.util.function.Predicate;
 38 import jdk.jfr.Event;
 39 import jdk.jfr.EventType;
 40 
 41 public final class RequestEngine {
 42 
 43     private final static JVM jvm = JVM.getJVM();
 44 
 45     final static class RequestHook {
 46         private final Runnable hook;
 47         private final PlatformEventType type;
 48         private final AccessControlContext accessControllerContext;
 49         private long delta;
 50 
 51         // Java events
 52         private RequestHook(AccessControlContext acc, PlatformEventType eventType, Runnable hook) {
 53             this.hook = hook;
</pre>
<hr />
<pre>
 80 
 81         private void executeSecure() {
 82             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 83                 @Override
 84                 public Void run() {
 85                     try {
 86                         hook.run();
 87                         Logger.log(LogTag.JFR_EVENT, LogLevel.DEBUG, ()-&gt; &quot;Executed periodic hook for &quot; + type.getLogName());
 88                     } catch (Throwable t) {
 89                         // Prevent malicious user to propagate exception callback in the wrong context
 90                         Logger.log(LogTag.JFR_EVENT, LogLevel.WARN, &quot;Exception occured during execution of period hook for &quot; + type.getLogName());
 91                     }
 92                     return null;
 93                 }
 94             }, accessControllerContext);
 95         }
 96     }
 97 
 98     private final static List&lt;RequestHook&gt; entries = new CopyOnWriteArrayList&lt;&gt;();
 99     private static long lastTimeMillis;
<span class="line-added">100     private static long flushInterval = Long.MAX_VALUE;</span>
<span class="line-added">101     private static long streamDelta;</span>
102 
103     public static void addHook(AccessControlContext acc, PlatformEventType type, Runnable hook) {
104         Objects.requireNonNull(acc);
105         addHookInternal(acc, type, hook);
106     }
107 
108     private static void addHookInternal(AccessControlContext acc, PlatformEventType type, Runnable hook) {
109         RequestHook he = new RequestHook(acc, type, hook);
110         for (RequestHook e : entries) {
111             if (e.hook == hook) {
112                 throw new IllegalArgumentException(&quot;Hook has already been added&quot;);
113             }
114         }
115         he.type.setEventHook(true);
116         // Insertion takes O(2*n), could be O(1) with HashMap, but
117         // thinking is that CopyOnWriteArrayList is faster
118         // to iterate over, which will happen more over time.
119         entries.add(he);
120         logHook(&quot;Added&quot;, type);
121     }
</pre>
<hr />
<pre>
195         // Keeping direct call os::elapsed_counter() here for reliable
196         // real time values in order to decide when registered requestable
197         // events are due.
198         long now = System.currentTimeMillis();
199         long min = 0;
200         long delta = 0;
201 
202         if (last == 0) {
203             last = now;
204         }
205 
206         // time from then to now
207         delta = now - last;
208 
209         if (delta &lt; 0) {
210             // to handle time adjustments
211             // for example Daylight Savings
212             lastTimeMillis = now;
213             return 0;
214         }
<span class="line-modified">215         Iterator&lt;RequestHook&gt; hookIterator = entries.iterator();</span>
<span class="line-added">216         while(hookIterator.hasNext()) {</span>
<span class="line-added">217             RequestHook he = hookIterator.next();</span>
218             long left = 0;
219             PlatformEventType es = he.type;
220             // Not enabled, skip.
221             if (!es.isEnabled() || es.isEveryChunk()) {
222                 continue;
223             }
224             long r_period = es.getPeriod();
225             long r_delta = he.delta;
226 
227             // add time elapsed.
228             r_delta += delta;
229 
230             // above threshold?
231             if (r_delta &gt;= r_period) {
232                 // Bug 9000556 - don&#39;t try to compensate
233                 // for wait &gt; period
234                 r_delta = 0;
235                 he.execute();

236             }
237 
238             // calculate time left
239             left = (r_period - r_delta);
240 
241             /**
242              * nothing outside checks that a period is &gt;= 0, so left can end up
243              * negative here. ex. (r_period =(-1)) - (r_delta = 0) if it is,
244              * handle it.
245              */
246             if (left &lt; 0) {
247                 left = 0;
248             }
249 
250             // assign delta back
251             he.delta = r_delta;
252 
253             if (min == 0 || left &lt; min) {
254                 min = left;
255             }
256         }
<span class="line-added">257         // Flush should happen after all periodic events has been emitted</span>
<span class="line-added">258         // Repeat of the above algorithm, but using the stream interval.</span>
<span class="line-added">259         if (flushInterval != Long.MAX_VALUE) {</span>
<span class="line-added">260             long r_period = flushInterval;</span>
<span class="line-added">261             long r_delta = streamDelta;</span>
<span class="line-added">262             r_delta += delta;</span>
<span class="line-added">263             if (r_delta &gt;= r_period) {</span>
<span class="line-added">264                 r_delta = 0;</span>
<span class="line-added">265                 MetadataRepository.getInstance().flush();</span>
<span class="line-added">266                 Utils.notifyFlush();</span>
<span class="line-added">267             }</span>
<span class="line-added">268             long left = (r_period - r_delta);</span>
<span class="line-added">269             if (left &lt; 0) {</span>
<span class="line-added">270                 left = 0;</span>
<span class="line-added">271             }</span>
<span class="line-added">272             streamDelta = r_delta;</span>
<span class="line-added">273             if (min == 0 || left &lt; min) {</span>
<span class="line-added">274                 min = left;</span>
<span class="line-added">275             }</span>
<span class="line-added">276         }</span>
<span class="line-added">277 </span>
278         lastTimeMillis = now;
279         return min;
280     }
<span class="line-added">281 </span>
<span class="line-added">282     static void setFlushInterval(long millis) {</span>
<span class="line-added">283         // Don&#39;t accept shorter interval than 1 s.</span>
<span class="line-added">284         long interval = millis &lt; 1000 ? 1000  : millis;</span>
<span class="line-added">285         flushInterval = interval;</span>
<span class="line-added">286         if (interval &lt; flushInterval) {</span>
<span class="line-added">287             synchronized (JVM.FILE_DELTA_CHANGE) {</span>
<span class="line-added">288                 JVM.FILE_DELTA_CHANGE.notifyAll();</span>
<span class="line-added">289             }</span>
<span class="line-added">290         }</span>
<span class="line-added">291     }</span>
292 }
</pre>
</td>
</tr>
</table>
<center><a href="RepositoryChunk.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SecuritySupport.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
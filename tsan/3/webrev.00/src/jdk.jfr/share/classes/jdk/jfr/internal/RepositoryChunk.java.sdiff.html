<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/RepositoryChunk.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Repository.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RequestEngine.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/RepositoryChunk.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 46             return c1.endTime.compareTo(c2.endTime);
 47         }
 48     };
 49 
 50     private final SafePath repositoryPath;
 51     private final SafePath unFinishedFile;
 52     private final SafePath file;
 53     private final Instant startTime;
 54     private final RandomAccessFile unFinishedRAF;
 55 
 56     private Instant endTime = null; // unfinished
 57     private int refCount = 0;
 58     private long size;
 59 
 60     RepositoryChunk(SafePath path, Instant startTime) throws Exception {
 61         ZonedDateTime z = ZonedDateTime.now();
 62         String fileName = Repository.REPO_DATE_FORMAT.format(
 63                 LocalDateTime.ofInstant(startTime, z.getZone()));
 64         this.startTime = startTime;
 65         this.repositoryPath = path;
<span class="line-modified"> 66         this.unFinishedFile = findFileName(repositoryPath, fileName, &quot;.part&quot;);</span>
 67         this.file = findFileName(repositoryPath, fileName, &quot;.jfr&quot;);
 68         this.unFinishedRAF = SecuritySupport.createRandomAccessFile(unFinishedFile);
<span class="line-modified"> 69         SecuritySupport.touch(file);</span>
 70     }
 71 
 72     private static SafePath findFileName(SafePath directory, String name, String extension) throws Exception {
 73         Path p = directory.toPath().resolve(name + extension);
 74         for (int i = 1; i &lt; MAX_CHUNK_NAMES; i++) {
 75             SafePath s = new SafePath(p);
 76             if (!SecuritySupport.exists(s)) {
 77                 return s;
 78             }
 79             String extendedName = String.format(&quot;%s_%02d%s&quot;, name, i, extension);
 80             p = directory.toPath().resolve(extendedName);
 81         }
 82         p = directory.toPath().resolve(name + &quot;_&quot; + System.currentTimeMillis() + extension);
 83         return SecuritySupport.toRealPath(new SafePath(p));
 84     }
 85 
 86     public SafePath getUnfishedFile() {
 87         return unFinishedFile;
 88     }
 89 
 90     void finish(Instant endTime) {
 91         try {
 92             finishWithException(endTime);
 93         } catch (IOException e) {
 94             Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Could not finish chunk. &quot; + e.getMessage());
 95         }
 96     }
 97 
 98     private void finishWithException(Instant endTime) throws IOException {
 99         unFinishedRAF.close();
100         this.size = finish(unFinishedFile, file);
101         this.endTime = endTime;
102         Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, () -&gt; &quot;Chunk finished: &quot; + file);
103     }
104 
105     private static long finish(SafePath unFinishedFile, SafePath file) throws IOException {
106         Objects.requireNonNull(unFinishedFile);
107         Objects.requireNonNull(file);
<span class="line-removed">108         SecuritySupport.delete(file);</span>
<span class="line-removed">109         SecuritySupport.moveReplace(unFinishedFile, file);</span>
110         return SecuritySupport.getFileSize(file);
111     }
112 
113     public Instant getStartTime() {
114         return startTime;
115     }
116 
117     public Instant getEndTime() {
118         return endTime;
119     }
120 
121     private void delete(SafePath f) {
122         try {
123             SecuritySupport.delete(f);
124             Logger.log(LogTag.JFR, LogLevel.DEBUG, () -&gt; &quot;Repository chunk &quot; + f + &quot; deleted&quot;);
125         } catch (IOException e) {
<span class="line-modified">126             Logger.log(LogTag.JFR, LogLevel.ERROR, ()  -&gt; &quot;Repository chunk &quot; + f + &quot; could not be deleted: &quot; + e.getMessage());</span>


127             if (f != null) {
<span class="line-modified">128                 SecuritySupport.deleteOnExit(f);</span>
129             }
130         }
131     }
132 
133     private void destroy() {
134         if (!isFinished()) {
135             finish(Instant.MIN);
136         }
137         if (file != null) {
138             delete(file);
139         }
140         try {
141             unFinishedRAF.close();
142         } catch (IOException e) {
143             Logger.log(LogTag.JFR, LogLevel.ERROR, () -&gt; &quot;Could not close random access file: &quot; + unFinishedFile.toString() + &quot;. File will not be deleted due to: &quot; + e.getMessage());
144         }
145     }
146 
147     public synchronized void use() {
148         ++refCount;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 46             return c1.endTime.compareTo(c2.endTime);
 47         }
 48     };
 49 
 50     private final SafePath repositoryPath;
 51     private final SafePath unFinishedFile;
 52     private final SafePath file;
 53     private final Instant startTime;
 54     private final RandomAccessFile unFinishedRAF;
 55 
 56     private Instant endTime = null; // unfinished
 57     private int refCount = 0;
 58     private long size;
 59 
 60     RepositoryChunk(SafePath path, Instant startTime) throws Exception {
 61         ZonedDateTime z = ZonedDateTime.now();
 62         String fileName = Repository.REPO_DATE_FORMAT.format(
 63                 LocalDateTime.ofInstant(startTime, z.getZone()));
 64         this.startTime = startTime;
 65         this.repositoryPath = path;
<span class="line-modified"> 66         this.unFinishedFile = findFileName(repositoryPath, fileName, &quot;.jfr&quot;);</span>
 67         this.file = findFileName(repositoryPath, fileName, &quot;.jfr&quot;);
 68         this.unFinishedRAF = SecuritySupport.createRandomAccessFile(unFinishedFile);
<span class="line-modified"> 69  //       SecuritySupport.touch(file);</span>
 70     }
 71 
 72     private static SafePath findFileName(SafePath directory, String name, String extension) throws Exception {
 73         Path p = directory.toPath().resolve(name + extension);
 74         for (int i = 1; i &lt; MAX_CHUNK_NAMES; i++) {
 75             SafePath s = new SafePath(p);
 76             if (!SecuritySupport.exists(s)) {
 77                 return s;
 78             }
 79             String extendedName = String.format(&quot;%s_%02d%s&quot;, name, i, extension);
 80             p = directory.toPath().resolve(extendedName);
 81         }
 82         p = directory.toPath().resolve(name + &quot;_&quot; + System.currentTimeMillis() + extension);
 83         return SecuritySupport.toRealPath(new SafePath(p));
 84     }
 85 
 86     public SafePath getUnfishedFile() {
 87         return unFinishedFile;
 88     }
 89 
 90     void finish(Instant endTime) {
 91         try {
 92             finishWithException(endTime);
 93         } catch (IOException e) {
 94             Logger.log(LogTag.JFR, LogLevel.ERROR, &quot;Could not finish chunk. &quot; + e.getMessage());
 95         }
 96     }
 97 
 98     private void finishWithException(Instant endTime) throws IOException {
 99         unFinishedRAF.close();
100         this.size = finish(unFinishedFile, file);
101         this.endTime = endTime;
102         Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, () -&gt; &quot;Chunk finished: &quot; + file);
103     }
104 
105     private static long finish(SafePath unFinishedFile, SafePath file) throws IOException {
106         Objects.requireNonNull(unFinishedFile);
107         Objects.requireNonNull(file);


108         return SecuritySupport.getFileSize(file);
109     }
110 
111     public Instant getStartTime() {
112         return startTime;
113     }
114 
115     public Instant getEndTime() {
116         return endTime;
117     }
118 
119     private void delete(SafePath f) {
120         try {
121             SecuritySupport.delete(f);
122             Logger.log(LogTag.JFR, LogLevel.DEBUG, () -&gt; &quot;Repository chunk &quot; + f + &quot; deleted&quot;);
123         } catch (IOException e) {
<span class="line-modified">124             // Probably happens because file is being streamed</span>
<span class="line-added">125             // on Windows where files in use can&#39;t be removed.</span>
<span class="line-added">126             Logger.log(LogTag.JFR, LogLevel.DEBUG, ()  -&gt; &quot;Repository chunk &quot; + f + &quot; could not be deleted: &quot; + e.getMessage());</span>
127             if (f != null) {
<span class="line-modified">128                 FilePurger.add(f);</span>
129             }
130         }
131     }
132 
133     private void destroy() {
134         if (!isFinished()) {
135             finish(Instant.MIN);
136         }
137         if (file != null) {
138             delete(file);
139         }
140         try {
141             unFinishedRAF.close();
142         } catch (IOException e) {
143             Logger.log(LogTag.JFR, LogLevel.ERROR, () -&gt; &quot;Could not close random access file: &quot; + unFinishedFile.toString() + &quot;. File will not be deleted due to: &quot; + e.getMessage());
144         }
145     }
146 
147     public synchronized void use() {
148         ++refCount;
</pre>
</td>
</tr>
</table>
<center><a href="Repository.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RequestEngine.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
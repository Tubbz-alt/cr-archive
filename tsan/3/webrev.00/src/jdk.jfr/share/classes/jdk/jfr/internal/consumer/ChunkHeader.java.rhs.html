<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/ChunkHeader.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
<a name="2" id="anc2"></a>
 28 import java.io.IOException;
 29 
 30 import jdk.jfr.internal.LogLevel;
 31 import jdk.jfr.internal.LogTag;
 32 import jdk.jfr.internal.Logger;
 33 import jdk.jfr.internal.MetadataDescriptor;
<a name="3" id="anc3"></a><span class="line-added"> 34 import jdk.jfr.internal.Utils;</span>
 35 
 36 public final class ChunkHeader {
<a name="4" id="anc4"></a><span class="line-added"> 37     private static final long HEADER_SIZE = 68;</span>
<span class="line-added"> 38     private static final byte UPDATING_CHUNK_HEADER = (byte) 255;</span>
<span class="line-added"> 39     private static final long CHUNK_SIZE_POSITION = 8;</span>
<span class="line-added"> 40     private static final long DURATION_NANOS_POSITION = 40;</span>
<span class="line-added"> 41     private static final long FILE_STATE_POSITION = 64;</span>
<span class="line-added"> 42     private static final long FLAG_BYTE_POSITION = 67;</span>
 43     private static final long METADATA_TYPE_ID = 0;
 44     private static final byte[] FILE_MAGIC = { &#39;F&#39;, &#39;L&#39;, &#39;R&#39;, &#39;\0&#39; };
<a name="5" id="anc5"></a><span class="line-added"> 45     private static final int MASK_FINAL_CHUNK = 1 &lt;&lt; 1;</span>
 46 
 47     private final short major;
 48     private final short minor;
<a name="6" id="anc6"></a>
 49     private final long chunkStartTicks;
 50     private final long ticksPerSecond;
 51     private final long chunkStartNanos;
<a name="7" id="anc7"></a>



 52     private final long absoluteChunkStart;
<a name="8" id="anc8"></a>
 53     private final RecordingInput input;
<a name="9" id="anc9"></a>
 54     private final long id;
<a name="10" id="anc10"></a><span class="line-modified"> 55     private long absoluteEventStart;</span>
<span class="line-added"> 56     private long chunkSize = 0;</span>
<span class="line-added"> 57     private long constantPoolPosition = 0;</span>
<span class="line-added"> 58     private long metadataPosition = 0;</span>
<span class="line-added"> 59     private long durationNanos;</span>
<span class="line-added"> 60     private long absoluteChunkEnd;</span>
<span class="line-added"> 61     private boolean isFinished;</span>
<span class="line-added"> 62     private boolean finished;</span>
<span class="line-added"> 63     private boolean finalChunk;</span>
 64 
 65     public ChunkHeader(RecordingInput input) throws IOException {
 66         this(input, 0, 0);
 67     }
 68 
 69     private ChunkHeader(RecordingInput input, long absoluteChunkStart, long id) throws IOException {
<a name="11" id="anc11"></a><span class="line-added"> 70         this.absoluteChunkStart = absoluteChunkStart;</span>
<span class="line-added"> 71         this.absoluteEventStart = absoluteChunkStart + HEADER_SIZE;</span>
<span class="line-added"> 72         if (input.getFileSize() &lt; HEADER_SIZE) {</span>
<span class="line-added"> 73             throw new IOException(&quot;Not a complete Chunk header&quot;);</span>
<span class="line-added"> 74         }</span>
<span class="line-added"> 75         input.setValidSize(absoluteChunkStart + HEADER_SIZE);</span>
 76         input.position(absoluteChunkStart);
 77         if (input.position() &gt;= input.size()) {
<a name="12" id="anc12"></a><span class="line-modified"> 78            throw new IOException(&quot;Chunk contains no data&quot;);</span>
 79         }
 80         verifyMagic(input);
 81         this.input = input;
 82         this.id = id;
<a name="13" id="anc13"></a><span class="line-modified"> 83         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: &quot; + id);</span>
<span class="line-added"> 84         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: file=&quot; + input.getFilename());</span>
 85         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: startPosition=&quot; + absoluteChunkStart);
 86         major = input.readRawShort();
 87         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: major=&quot; + major);
 88         minor = input.readRawShort();
 89         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: minor=&quot; + minor);
 90         if (major != 1 &amp;&amp; major != 2) {
 91             throw new IOException(&quot;File version &quot; + major + &quot;.&quot; + minor + &quot;. Only Flight Recorder files of version 1.x and 2.x can be read by this JDK.&quot;);
 92         }
<a name="14" id="anc14"></a><span class="line-modified"> 93         input.readRawLong(); // chunk size</span>
 94         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: chunkSize=&quot; + chunkSize);
<a name="15" id="anc15"></a><span class="line-modified"> 95         input.readRawLong(); // constant pool position</span>
 96         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: constantPoolPosition=&quot; + constantPoolPosition);
<a name="16" id="anc16"></a><span class="line-modified"> 97         input.readRawLong(); // metadata position</span>
 98         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: metadataPosition=&quot; + metadataPosition);
 99         chunkStartNanos = input.readRawLong(); // nanos since epoch
100         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: startNanos=&quot; + chunkStartNanos);
101         durationNanos = input.readRawLong(); // duration nanos, not used
102         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: durationNanos=&quot; + durationNanos);
103         chunkStartTicks = input.readRawLong();
104         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: startTicks=&quot; + chunkStartTicks);
105         ticksPerSecond = input.readRawLong();
106         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: ticksPerSecond=&quot; + ticksPerSecond);
<a name="17" id="anc17"></a><span class="line-modified">107         input.readRawInt(); // ignore file state and flag bits</span>
<span class="line-added">108         refresh();</span>
<span class="line-added">109         input.position(absoluteEventStart);</span>
<span class="line-added">110     }</span>
111 
<a name="18" id="anc18"></a><span class="line-modified">112     void refresh() throws IOException {</span>
<span class="line-modified">113         while (true) {</span>
<span class="line-modified">114             byte fileState1;</span>
<span class="line-modified">115             input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);</span>
<span class="line-modified">116             while ((fileState1 = input.readPhysicalByte()) == UPDATING_CHUNK_HEADER) {</span>
<span class="line-added">117                 Utils.takeNap(1);</span>
<span class="line-added">118                 input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);</span>
<span class="line-added">119             }</span>
<span class="line-added">120             input.positionPhysical(absoluteChunkStart + CHUNK_SIZE_POSITION);</span>
<span class="line-added">121             long chunkSize = input.readPhysicalLong();</span>
<span class="line-added">122             long constantPoolPosition = input.readPhysicalLong();</span>
<span class="line-added">123             long metadataPosition = input.readPhysicalLong();</span>
<span class="line-added">124             input.positionPhysical(absoluteChunkStart + DURATION_NANOS_POSITION);</span>
<span class="line-added">125             long durationNanos = input.readPhysicalLong();</span>
<span class="line-added">126             input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);</span>
<span class="line-added">127             byte fileState2 =  input.readPhysicalByte();</span>
<span class="line-added">128             input.positionPhysical(absoluteChunkStart + FLAG_BYTE_POSITION);</span>
<span class="line-added">129             int flagByte = input.readPhysicalByte();</span>
<span class="line-added">130             if (fileState1 == fileState2) { // valid header</span>
<span class="line-added">131                 finished = fileState1 == 0;</span>
<span class="line-added">132                 if (metadataPosition != 0) {</span>
<span class="line-added">133                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Setting input size to &quot; + (absoluteChunkStart + chunkSize));</span>
<span class="line-added">134                     if (finished) {</span>
<span class="line-added">135                         // This assumes that the whole recording</span>
<span class="line-added">136                         // is finished if the first chunk is.</span>
<span class="line-added">137                         // This is a limitation we may want to</span>
<span class="line-added">138                         // remove, but greatly improves performance as</span>
<span class="line-added">139                         // data can be read across chunk boundaries</span>
<span class="line-added">140                         // of multi-chunk files and only once.</span>
<span class="line-added">141                         input.setValidSize(input.getFileSize());</span>
<span class="line-added">142                     } else {</span>
<span class="line-added">143                         input.setValidSize(absoluteChunkStart + chunkSize);</span>
<span class="line-added">144                     }</span>
<span class="line-added">145                     this.chunkSize = chunkSize;</span>
<span class="line-added">146                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: chunkSize=&quot; + chunkSize);</span>
<span class="line-added">147                     this.constantPoolPosition = constantPoolPosition;</span>
<span class="line-added">148                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: constantPoolPosition=&quot; + constantPoolPosition);</span>
<span class="line-added">149                     this.metadataPosition = metadataPosition;</span>
<span class="line-added">150                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: metadataPosition=&quot; + metadataPosition);</span>
<span class="line-added">151                     this.durationNanos = durationNanos;</span>
<span class="line-added">152                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: durationNanos =&quot; + durationNanos);</span>
<span class="line-added">153                     isFinished = fileState2 == 0;</span>
<span class="line-added">154                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: generation=&quot; + fileState2);</span>
<span class="line-added">155                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: finished=&quot; + isFinished);</span>
<span class="line-added">156                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: fileSize=&quot; + input.size());</span>
<span class="line-added">157                     this.finalChunk = (flagByte &amp; MASK_FINAL_CHUNK) != 0;</span>
<span class="line-added">158                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: finalChunk=&quot; + finalChunk);</span>
<span class="line-added">159                     absoluteChunkEnd = absoluteChunkStart + chunkSize;</span>
<span class="line-added">160                     return;</span>
<span class="line-added">161                 }</span>
<span class="line-added">162             }</span>
<span class="line-added">163         }</span>
<span class="line-added">164     }</span>
165 
<a name="19" id="anc19"></a><span class="line-modified">166     public void awaitFinished() throws IOException {</span>
<span class="line-modified">167         if (finished) {</span>
<span class="line-added">168             return;</span>
<span class="line-added">169         }</span>
<span class="line-added">170         long pos = input.position();</span>
<span class="line-added">171         try {</span>
<span class="line-added">172             input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);</span>
<span class="line-added">173             while (true) {</span>
<span class="line-added">174                 byte filestate = input.readPhysicalByte();</span>
<span class="line-added">175                 if (filestate == 0) {</span>
<span class="line-added">176                     finished = true;</span>
<span class="line-added">177                     return;</span>
<span class="line-added">178                 }</span>
<span class="line-added">179                 Utils.takeNap(1);</span>
<span class="line-added">180             }</span>
<span class="line-added">181         } finally {</span>
<span class="line-added">182             input.position(pos);</span>
<span class="line-added">183         }</span>
<span class="line-added">184     }</span>
<span class="line-added">185 </span>
<span class="line-added">186     public boolean isLastChunk() throws IOException {</span>
<span class="line-added">187         awaitFinished();</span>
<span class="line-added">188         // streaming files only have one chunk</span>
<span class="line-added">189         return input.getFileSize() == absoluteChunkEnd;</span>
<span class="line-added">190    }</span>
<span class="line-added">191 </span>
<span class="line-added">192     public boolean isFinalChunk() {</span>
<span class="line-added">193         return finalChunk;</span>
<span class="line-added">194     }</span>
<span class="line-added">195 </span>
<span class="line-added">196     public boolean isFinished() throws IOException {</span>
<span class="line-added">197         return isFinished;</span>
198     }
199 
200     public ChunkHeader nextHeader() throws IOException {
201         return new ChunkHeader(input, absoluteChunkEnd, id + 1);
202     }
<a name="20" id="anc20"></a>
203     public MetadataDescriptor readMetadata() throws IOException {
<a name="21" id="anc21"></a><span class="line-added">204         return readMetadata(null);</span>
<span class="line-added">205     }</span>
<span class="line-added">206 </span>
<span class="line-added">207     public MetadataDescriptor readMetadata(MetadataDescriptor previous) throws IOException {</span>
208         input.position(absoluteChunkStart + metadataPosition);
209         input.readInt(); // size
210         long id = input.readLong(); // event type id
211         if (id != METADATA_TYPE_ID) {
212             throw new IOException(&quot;Expected metadata event. Type id=&quot; + id + &quot;, should have been &quot; + METADATA_TYPE_ID);
213         }
214         input.readLong(); // start time
215         input.readLong(); // duration
216         long metadataId = input.readLong();
<a name="22" id="anc22"></a><span class="line-modified">217         if (previous != null &amp;&amp; metadataId == previous.metadataId) {</span>
<span class="line-modified">218             return previous;</span>
<span class="line-modified">219         }</span>
<span class="line-modified">220         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE, &quot;New metadata id = &quot; + metadataId);</span>
<span class="line-added">221         MetadataDescriptor m =  MetadataDescriptor.read(input);</span>
<span class="line-added">222         m.metadataId = metadataId;</span>
<span class="line-added">223         return m;</span>
224     }
225 
<a name="23" id="anc23"></a>


226 
227     public short getMajor() {
228         return major;
229     }
230 
231     public short getMinor() {
232         return minor;
233     }
234 
235     public long getAbsoluteChunkStart() {
236         return absoluteChunkStart;
237     }
238 
<a name="24" id="anc24"></a><span class="line-added">239     public long getAbsoluteEventStart() {</span>
<span class="line-added">240         return absoluteEventStart;</span>
<span class="line-added">241     }</span>
242     public long getConstantPoolPosition() {
243         return constantPoolPosition;
244     }
245 
<a name="25" id="anc25"></a><span class="line-added">246     public long getMetataPosition() {</span>
<span class="line-added">247         return metadataPosition;</span>
<span class="line-added">248     }</span>
249     public long getStartTicks() {
250         return chunkStartTicks;
251     }
<a name="26" id="anc26"></a><span class="line-added">252     public long getChunkSize() {</span>
<span class="line-added">253         return chunkSize;</span>
<span class="line-added">254     }</span>
255 
256     public double getTicksPerSecond() {
257         return ticksPerSecond;
258     }
259 
260     public long getStartNanos() {
261         return chunkStartNanos;
262     }
263 
264     public long getEnd() {
265         return absoluteChunkEnd;
266     }
267 
268     public long getSize() {
269         return chunkSize;
270     }
271 
272     public long getDurationNanos() {
273         return durationNanos;
274     }
275 
276     public RecordingInput getInput() {
277         return input;
278     }
279 
<a name="27" id="anc27"></a><span class="line-modified">280     private static void verifyMagic(RecordingInput input) throws IOException {</span>
281         for (byte c : FILE_MAGIC) {
282             if (input.readByte() != c) {
283                 throw new IOException(&quot;Not a Flight Recorder file&quot;);
284             }
285         }
286     }
287 
288     public long getEventStart() {
289         return absoluteEventStart;
290     }
291 
<a name="28" id="anc28"></a><span class="line-added">292     static long headerSize() {</span>
<span class="line-added">293         return HEADER_SIZE;</span>
<span class="line-added">294     }</span>
<span class="line-added">295 </span>
<span class="line-added">296     public long getLastNanos() {</span>
<span class="line-added">297         return getStartNanos() + getDurationNanos();</span>
<span class="line-added">298     }</span>
299 }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataDescriptor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
<a name="2" id="anc2"></a>
 28 import java.io.DataOutput;
 29 import java.io.IOException;
 30 import java.util.ArrayList;
 31 import java.util.Collection;
 32 import java.util.List;
 33 import java.util.Locale;
 34 import java.util.TimeZone;
 35 
 36 import jdk.jfr.EventType;
<a name="3" id="anc3"></a><span class="line-added"> 37 import jdk.jfr.internal.consumer.RecordingInput;</span>
 38 
 39 /**
 40  * Metadata about a chunk
 41  */
 42 public final class MetadataDescriptor {
 43 
 44     static final class Attribute {
 45         final String name;
 46         final String value;
 47 
 48         private Attribute(String name, String value) {
 49             this.name = name;
 50             this.value = value;
 51         }
 52     }
 53 
 54     static final class Element {
 55         final String name;
 56         final List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
 57         final List&lt;Attribute&gt; attributes = new ArrayList&lt;&gt;();
 58 
 59         Element(String name) {
 60             this.name = name;
 61         }
 62 
 63         long longValue(String name) {
 64             String v = attribute(name);
 65             if (v != null)
 66                 return Long.parseLong(v);
 67             else
 68                 throw new IllegalArgumentException(name);
 69         }
 70 
 71         String attribute(String name) {
 72             for (Attribute a : attributes) {
 73                 if (a.name.equals(name)) {
 74                     return a.value;
 75                 }
 76             }
 77             return null;
 78         }
 79 
 80         @Override
 81         public String toString() {
 82             StringBuilder sb = new StringBuilder();
 83             try {
 84                 prettyPrintXML(sb, &quot;&quot;, this);
 85             } catch (IOException e) {
 86                 // should not happen
 87             }
 88             return sb.toString();
 89         }
 90 
 91         long attribute(String name, long defaultValue) {
 92             String text = attribute(name);
 93             if (text == null) {
 94                 return defaultValue;
 95             }
 96             return Long.parseLong(text);
 97         }
 98 
 99         String attribute(String name, String defaultValue) {
100             String text = attribute(name);
101             if (text == null) {
102                 return defaultValue;
103             }
104             return text;
105         }
106 
107         List&lt;Element&gt; elements(String... names) {
108             List&lt;Element&gt; filteredElements = new ArrayList&lt;&gt;();
109             for (String name : names) {
110                 for (Element e : elements) {
111                     if (e.name.equals(name)) {
112                         filteredElements.add(e);
113                     }
114                 }
115             }
116             return filteredElements;
117         }
118 
119         void add(Element element) {
120             elements.add(element);
121         }
122 
123         void addAttribute(String name, Object value) {
124             attributes.add(new Attribute(name, String.valueOf(value)));
125         }
126 
127         Element newChild(String name) {
128             Element e = new Element(name);
129             elements.add(e);
130             return e;
131         }
132 
133         public void addArrayAttribute(Element element, String name, Object value) {
134             String typeName = value.getClass().getComponentType().getName();
135             switch (typeName) {
136             case &quot;int&quot;:
137                 int[] ints = (int[]) value;
138                 for (int i = 0; i &lt; ints.length; i++) {
139                     addAttribute(name  + &quot;-&quot; + i , ints[i]);
140                 }
141                 break;
142             case &quot;long&quot;:
143                 long[] longs = (long[]) value;
144                 for (int i = 0; i &lt; longs.length; i++) {
145                     addAttribute(name  + &quot;-&quot; + i , longs[i]);
146                 }
147                 break;
148             case &quot;float&quot;:
149                 float[] floats = (float[]) value;
150                 for (int i = 0; i &lt; floats.length; i++) {
151                     addAttribute(name  + &quot;-&quot; + i , floats[i]);
152                 }
153                 break;
154 
155             case &quot;double&quot;:
156                 double[] doubles = (double[]) value;
157                 for (int i = 0; i &lt; doubles.length; i++) {
158                     addAttribute(name  + &quot;-&quot; + i , doubles[i]);
159                 }
160                 break;
161             case &quot;short&quot;:
162                 short[] shorts = (short[]) value;
163                 for (int i = 0; i &lt; shorts.length; i++) {
164                     addAttribute(name  + &quot;-&quot; + i , shorts[i]);
165                 }
166                 break;
167             case &quot;char&quot;:
168                 char[] chars = (char[]) value;
169                 for (int i = 0; i &lt; chars.length; i++) {
170                     addAttribute(name  + &quot;-&quot; + i , chars[i]);
171                 }
172                 break;
173             case &quot;byte&quot;:
174                 byte[] bytes = (byte[]) value;
175                 for (int i = 0; i &lt; bytes.length; i++) {
176                     addAttribute(name  + &quot;-&quot; + i , bytes[i]);
177                 }
178                 break;
179             case &quot;boolean&quot;:
180                 boolean[] booleans = (boolean[]) value;
181                 for (int i = 0; i &lt; booleans.length; i++) {
182                     addAttribute(name  + &quot;-&quot; + i , booleans[i]);
183                 }
184                 break;
185             case &quot;java.lang.String&quot;:
186                 String[] strings = (String[]) value;
187                 for (int i = 0; i &lt; strings.length; i++) {
188                     addAttribute(name  + &quot;-&quot; + i , strings[i]);
189                 }
190                 break;
191             default:
192                 throw new InternalError(&quot;Array type of &quot; + typeName + &quot; is not supported&quot;);
193             }
194         }
195     }
196 
197     static final String ATTRIBUTE_ID = &quot;id&quot;;
198     static final String ATTRIBUTE_SIMPLE_TYPE = &quot;simpleType&quot;;
199     static final String ATTRIBUTE_GMT_OFFSET = &quot;gmtOffset&quot;;
200     static final String ATTRIBUTE_LOCALE = &quot;locale&quot;;
201     static final String ELEMENT_TYPE = &quot;class&quot;;
202     static final String ELEMENT_SETTING = &quot;setting&quot;;
203     static final String ELEMENT_ANNOTATION = &quot;annotation&quot;;
204     static final String ELEMENT_FIELD = &quot;field&quot;;
205     static final String ATTRIBUTE_SUPER_TYPE = &quot;superType&quot;;
206     static final String ATTRIBUTE_TYPE_ID = &quot;class&quot;;
207     static final String ATTRIBUTE_DIMENSION = &quot;dimension&quot;;
208     static final String ATTRIBUTE_NAME = &quot;name&quot;;
209     static final String ATTRIBUTE_CONSTANT_POOL = &quot;constantPool&quot;;
210     static final String ATTRIBUTE_DEFAULT_VALUE = &quot;defaultValue&quot;;
211 
212     final List&lt;EventType&gt; eventTypes = new ArrayList&lt;&gt;();
213     final Collection&lt;Type&gt; types = new ArrayList&lt;&gt;();
214     long gmtOffset;
215     String locale;
216     Element root;
<a name="4" id="anc4"></a><span class="line-added">217     public long metadataId;</span>
218 
219     // package private
220     MetadataDescriptor() {
221     }
222 
223     private static void prettyPrintXML(Appendable sb, String indent, Element e) throws IOException {
224         sb.append(indent + &quot;&lt;&quot; + e.name);
225         for (Attribute a : e.attributes) {
226             sb.append(&quot; &quot;).append(a.name).append(&quot;=\&quot;&quot;).append(a.value).append(&quot;\&quot;&quot;);
227         }
228         if (e.elements.size() == 0) {
229             sb.append(&quot;/&quot;);
230         }
231         sb.append(&quot;&gt;\n&quot;);
232         for (Element child : e.elements) {
233             prettyPrintXML(sb, indent + &quot;  &quot;, child);
234         }
235         if (e.elements.size() != 0) {
236             sb.append(indent).append(&quot;&lt;/&quot;).append(e.name).append(&quot;&gt;\n&quot;);
237         }
238     }
239 
240     public Collection&lt;Type&gt; getTypes() {
241         return types;
242     }
243 
244     public List&lt;EventType&gt; getEventTypes() {
245         return eventTypes;
246     }
247 
248     public int getGMTOffset() {
249         return (int) gmtOffset;
250     }
251 
252     public String getLocale() {
253         return locale;
254     }
255 
<a name="5" id="anc5"></a><span class="line-modified">256     public static MetadataDescriptor read(RecordingInput input) throws IOException {</span>
257         MetadataReader r = new MetadataReader(input);
258         return r.getDescriptor();
259     }
260 
261     static void write(List&lt;Type&gt; types, DataOutput output) throws IOException {
262         MetadataDescriptor m = new MetadataDescriptor();
263         m.locale = Locale.getDefault().toString();
264         m.gmtOffset = TimeZone.getDefault().getRawOffset();
265         m.types.addAll(types);
266         MetadataWriter w = new MetadataWriter(m);
267         w.writeBinary(output);
268     }
269 
270     @Override
271     public String toString() {
272         return root.toString();
273     }
274 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
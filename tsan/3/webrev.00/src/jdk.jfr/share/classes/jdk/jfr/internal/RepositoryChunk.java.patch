diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/RepositoryChunk.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/RepositoryChunk.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/RepositoryChunk.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/RepositoryChunk.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -61,14 +61,14 @@
         ZonedDateTime z = ZonedDateTime.now();
         String fileName = Repository.REPO_DATE_FORMAT.format(
                 LocalDateTime.ofInstant(startTime, z.getZone()));
         this.startTime = startTime;
         this.repositoryPath = path;
-        this.unFinishedFile = findFileName(repositoryPath, fileName, ".part");
+        this.unFinishedFile = findFileName(repositoryPath, fileName, ".jfr");
         this.file = findFileName(repositoryPath, fileName, ".jfr");
         this.unFinishedRAF = SecuritySupport.createRandomAccessFile(unFinishedFile);
-        SecuritySupport.touch(file);
+ //       SecuritySupport.touch(file);
     }
 
     private static SafePath findFileName(SafePath directory, String name, String extension) throws Exception {
         Path p = directory.toPath().resolve(name + extension);
         for (int i = 1; i < MAX_CHUNK_NAMES; i++) {
@@ -103,12 +103,10 @@
     }
 
     private static long finish(SafePath unFinishedFile, SafePath file) throws IOException {
         Objects.requireNonNull(unFinishedFile);
         Objects.requireNonNull(file);
-        SecuritySupport.delete(file);
-        SecuritySupport.moveReplace(unFinishedFile, file);
         return SecuritySupport.getFileSize(file);
     }
 
     public Instant getStartTime() {
         return startTime;
@@ -121,13 +119,15 @@
     private void delete(SafePath f) {
         try {
             SecuritySupport.delete(f);
             Logger.log(LogTag.JFR, LogLevel.DEBUG, () -> "Repository chunk " + f + " deleted");
         } catch (IOException e) {
-            Logger.log(LogTag.JFR, LogLevel.ERROR, ()  -> "Repository chunk " + f + " could not be deleted: " + e.getMessage());
+            // Probably happens because file is being streamed
+            // on Windows where files in use can't be removed.
+            Logger.log(LogTag.JFR, LogLevel.DEBUG, ()  -> "Repository chunk " + f + " could not be deleted: " + e.getMessage());
             if (f != null) {
-                SecuritySupport.deleteOnExit(f);
+                FilePurger.add(f);
             }
         }
     }
 
     private void destroy() {

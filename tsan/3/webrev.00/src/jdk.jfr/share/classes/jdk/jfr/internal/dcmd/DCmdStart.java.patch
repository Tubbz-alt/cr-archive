diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -22,10 +22,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.jfr.internal.dcmd;
 
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.InvalidPathException;
 import java.nio.file.Path;
 import java.nio.file.Paths;
@@ -40,10 +41,11 @@
 import jdk.jfr.internal.JVM;
 import jdk.jfr.internal.LogLevel;
 import jdk.jfr.internal.LogTag;
 import jdk.jfr.internal.Logger;
 import jdk.jfr.internal.OldObjectSample;
+import jdk.jfr.internal.PlatformRecording;
 import jdk.jfr.internal.PrivateAccess;
 import jdk.jfr.internal.SecuritySupport.SafePath;
 import jdk.jfr.internal.Type;
 import jdk.jfr.internal.jfc.JFC;
 
@@ -78,19 +80,20 @@
      * @return result output
      *
      * @throws DCmdException if recording could not be started
      */
     @SuppressWarnings("resource")
-    public String execute(String name, String[] settings, Long delay, Long duration, Boolean disk, String path, Long maxAge, Long maxSize, Boolean dumpOnExit, Boolean pathToGcRoots) throws DCmdException {
+    public String execute(String name, String[] settings, Long delay, Long duration, Boolean disk, String path, Long maxAge, Long maxSize, Long flush, Boolean dumpOnExit, Boolean pathToGcRoots) throws DCmdException {
         if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {
             Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, "Executing DCmdStart: name=" + name +
                     ", settings=" + Arrays.asList(settings) +
                     ", delay=" + delay +
                     ", duration=" + duration +
                     ", disk=" + disk+
                     ", filename=" + path +
                     ", maxage=" + maxAge +
+                    ", flush=" + flush +
                     ", maxsize=" + maxSize +
                     ", dumponexit =" + dumpOnExit +
                     ", path-to-gc-roots=" + pathToGcRoots);
         }
         if (name != null) {
@@ -103,17 +106,21 @@
         }
 
         if (duration == null && Boolean.FALSE.equals(dumpOnExit) && path != null) {
             throw new DCmdException("Filename can only be set for a time bound recording or if dumponexit=true. Set duration/dumponexit or omit filename.");
         }
-
+        if (settings.length == 1 && settings[0].length() == 0) {
+            throw new DCmdException("No settings specified. Use settings=none to start without any settings");
+        }
         Map<String, String> s = new HashMap<>();
         for (String configName : settings) {
             try {
                 s.putAll(JFC.createKnown(configName).getSettings());
+            } catch(FileNotFoundException e) {
+                throw new DCmdException("Could not find settings file'" + configName + "'", e);
             } catch (IOException | ParseException e) {
-                throw new DCmdException("Could not parse setting " + settings[0], e);
+                throw new DCmdException("Could not parse settings file '" + settings[0] + "'", e);
             }
         }
 
         OldObjectSample.updateSettingPathToGcRoots(s, pathToGcRoots);
 
@@ -129,10 +136,16 @@
                 // to avoid typo, delay shorter than 1s makes no sense.
                 throw new DCmdException("Could not start recording, delay must be at least 1 second.");
             }
         }
 
+        if (flush != null) {
+            if (Boolean.FALSE.equals(disk)) {
+                throw new DCmdException("Flush can only be set for recordings that are to disk.");
+            }
+        }
+
         if (!FlightRecorder.isInitialized() && delay == null) {
             initializeWithForcedInstrumentation(s);
         }
 
         Recording recording = new Recording();
@@ -141,10 +154,11 @@
         }
 
         if (disk != null) {
             recording.setToDisk(disk.booleanValue());
         }
+
         recording.setSettings(s);
         SafePath safePath = null;
 
         if (path != null) {
             try {
@@ -170,10 +184,15 @@
 
         if (maxAge != null) {
             recording.setMaxAge(Duration.ofNanos(maxAge));
         }
 
+        if (flush != null) {
+            PlatformRecording p = PrivateAccess.getInstance().getPlatformRecording(recording);
+            p.setFlushInterval(Duration.ofNanos(flush));
+        }
+
         if (maxSize != null) {
             recording.setMaxSize(maxSize);
         }
 
         if (duration != null) {
@@ -215,10 +234,11 @@
                 recordingspecifier = "name=" + quoteIfNeeded(name);
             }
             print("Use jcmd " + getPid() + " JFR." + cmd + " " + recordingspecifier + " " + fileOption + "to copy recording data to file.");
             println();
         }
+
         return getResult();
     }
 
 
     // Instruments JDK-events on class load to reduce startup time

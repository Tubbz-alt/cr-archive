<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../events/ActiveSettingEvent.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="EventInstrumentation.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.lang.annotation.Annotation;
 29 import java.lang.reflect.Constructor;
 30 import java.lang.reflect.InvocationTargetException;
 31 import java.lang.reflect.Method;
 32 import java.lang.reflect.Modifier;
 33 import java.util.ArrayList;
 34 import java.util.Collections;
<span class="line-removed"> 35 import java.util.HashMap;</span>
 36 import java.util.List;
<span class="line-removed"> 37 import java.util.Map;</span>
<span class="line-removed"> 38 import java.util.Map.Entry;</span>
<span class="line-removed"> 39 import java.util.Set;</span>
 40 
 41 import jdk.internal.module.Modules;
 42 import jdk.jfr.AnnotationElement;
 43 import jdk.jfr.Enabled;
 44 import jdk.jfr.Name;
 45 import jdk.jfr.Period;
 46 import jdk.jfr.SettingControl;
 47 import jdk.jfr.SettingDefinition;
 48 import jdk.jfr.StackTrace;
 49 import jdk.jfr.Threshold;
 50 import jdk.jfr.events.ActiveSettingEvent;
 51 import jdk.jfr.internal.EventInstrumentation.SettingInfo;
 52 import jdk.jfr.internal.settings.CutoffSetting;
 53 import jdk.jfr.internal.settings.EnabledSetting;
 54 import jdk.jfr.internal.settings.PeriodSetting;
 55 import jdk.jfr.internal.settings.StackTraceSetting;
 56 import jdk.jfr.internal.settings.ThresholdSetting;
 57 
 58 // This class can&#39;t have a hard reference from PlatformEventType, since it
 59 // holds SettingControl instances that need to be released
 60 // when a class is unloaded (to avoid memory leaks).
 61 public final class EventControl {
<span class="line-modified"> 62 </span>







 63     static final String FIELD_SETTING_PREFIX = &quot;setting&quot;;
 64     private static final Type TYPE_ENABLED = TypeLibrary.createType(EnabledSetting.class);
 65     private static final Type TYPE_THRESHOLD = TypeLibrary.createType(ThresholdSetting.class);
 66     private static final Type TYPE_STACK_TRACE = TypeLibrary.createType(StackTraceSetting.class);
 67     private static final Type TYPE_PERIOD = TypeLibrary.createType(PeriodSetting.class);
 68     private static final Type TYPE_CUTOFF = TypeLibrary.createType(CutoffSetting.class);
 69 
<span class="line-modified"> 70     private final List&lt;SettingInfo&gt; settingInfos = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 71     private final Map&lt;String, Control&gt; eventControls = new HashMap&lt;&gt;(5);</span>
 72     private final PlatformEventType type;
 73     private final String idName;
 74 
 75     EventControl(PlatformEventType eventType) {
<span class="line-modified"> 76         eventControls.put(Enabled.NAME, defineEnabled(eventType));</span>
 77         if (eventType.hasDuration()) {
<span class="line-modified"> 78             eventControls.put(Threshold.NAME, defineThreshold(eventType));</span>
 79         }
 80         if (eventType.hasStackTrace()) {
<span class="line-modified"> 81             eventControls.put(StackTrace.NAME, defineStackTrace(eventType));</span>
 82         }
 83         if (eventType.hasPeriod()) {
<span class="line-modified"> 84             eventControls.put(Period.NAME, definePeriod(eventType));</span>
 85         }
 86         if (eventType.hasCutoff()) {
<span class="line-modified"> 87             eventControls.put(Cutoff.NAME, defineCutoff(eventType));</span>
 88         }
 89 
 90         ArrayList&lt;AnnotationElement&gt; aes = new ArrayList&lt;&gt;(eventType.getAnnotationElements());
 91         remove(eventType, aes, Threshold.class);
 92         remove(eventType, aes, Period.class);
 93         remove(eventType, aes, Enabled.class);
 94         remove(eventType, aes, StackTrace.class);
 95         remove(eventType, aes, Cutoff.class);
 96         aes.trimToSize();
 97         eventType.setAnnotations(aes);
 98         this.type = eventType;
 99         this.idName = String.valueOf(eventType.getId());
100     }
101 













102     static void remove(PlatformEventType type, List&lt;AnnotationElement&gt; aes, Class&lt;? extends java.lang.annotation.Annotation&gt; clazz) {
103         long id = Type.getTypeId(clazz);
104         for (AnnotationElement a : type.getAnnotationElements()) {
105             if (a.getTypeId() == id &amp;&amp; a.getTypeName().equals(clazz.getName())) {
106                 aes.remove(a);
107             }
108         }
109     }
110 
111     EventControl(PlatformEventType es, Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
112         this(es);
113         defineSettings(eventClass);
114     }
115 
116     @SuppressWarnings(&quot;unchecked&quot;)
117     private void defineSettings(Class&lt;?&gt; eventClass) {
118         // Iterate up the class hierarchy and let
119         // subclasses shadow base classes.
120         boolean allowPrivateMethod = true;
121         while (eventClass != null) {
122             for (Method m : eventClass.getDeclaredMethods()) {
123                 boolean isPrivate = Modifier.isPrivate(m.getModifiers());
124                 if (m.getReturnType() == Boolean.TYPE &amp;&amp; m.getParameterCount() == 1 &amp;&amp; (!isPrivate || allowPrivateMethod)) {
125                     SettingDefinition se = m.getDeclaredAnnotation(SettingDefinition.class);
126                     if (se != null) {
127                         Class&lt;?&gt; settingClass = m.getParameters()[0].getType();
128                         if (!Modifier.isAbstract(settingClass.getModifiers()) &amp;&amp; SettingControl.class.isAssignableFrom(settingClass)) {
129                             String name = m.getName();
130                             Name n = m.getAnnotation(Name.class);
131                             if (n != null) {
132                                 name = n.value();
133                             }
<span class="line-modified">134                             if (!eventControls.containsKey(name)) {</span>

135                                 defineSetting((Class&lt;? extends SettingControl&gt;) settingClass, m, type, name);
136                             }
137                         }
138                     }
139                 }
140             }
141             eventClass = eventClass.getSuperclass();
142             allowPrivateMethod = false;
143         }
144     }
145 
146     private void defineSetting(Class&lt;? extends SettingControl&gt; settingsClass, Method method, PlatformEventType eventType, String settingName) {
147         try {
148             Module settingModule = settingsClass.getModule();
149             Modules.addReads(settingModule, EventControl.class.getModule());
150             int index = settingInfos.size();
151             SettingInfo si = new SettingInfo(FIELD_SETTING_PREFIX + index, index);
152             si.settingControl = instantiateSettingControl(settingsClass);
153             Control c = si.settingControl;
154             c.setDefault();
155             String defaultValue = c.getValueSafe();
156             if (defaultValue != null) {
157                 Type settingType = TypeLibrary.createType(settingsClass);
158                 ArrayList&lt;AnnotationElement&gt; aes = new ArrayList&lt;&gt;();
159                 for (Annotation a : method.getDeclaredAnnotations()) {
160                     AnnotationElement ae = TypeLibrary.createAnnotation(a);
161                     if (ae != null) {
162                         aes.add(ae);
163                     }
164                 }
165                 aes.trimToSize();
<span class="line-modified">166                 eventControls.put(settingName, si.settingControl);</span>
167                 eventType.add(PrivateAccess.getInstance().newSettingDescriptor(settingType, settingName, defaultValue, aes));
168                 settingInfos.add(si);
169             }
170         } catch (InstantiationException e) {
171             // Programming error by user, fail fast
172             throw new InstantiationError(&quot;Could not instantiate setting &quot; + settingsClass.getName() + &quot; for event &quot; + eventType.getLogName() + &quot;. &quot; + e.getMessage());
173         } catch (IllegalAccessException e) {
174             // Programming error by user, fail fast
175             throw new IllegalAccessError(&quot;Could not access setting &quot; + settingsClass.getName() + &quot; for event &quot; + eventType.getLogName() + &quot;. &quot; + e.getMessage());
176         }
177     }
178 
179     private SettingControl instantiateSettingControl(Class&lt;? extends SettingControl&gt; settingControlClass) throws IllegalAccessException, InstantiationException {
180         SecuritySupport.makeVisibleToJFR(settingControlClass);
181         final Constructor&lt;?&gt; cc;
182         try {
183             cc = settingControlClass.getDeclaredConstructors()[0];
184         } catch (Exception e) {
185             throw (Error) new InternalError(&quot;Could not get constructor for &quot; + settingControlClass.getName()).initCause(e);
186         }
</pre>
<hr />
<pre>
230         String def = Cutoff.INIFITY;
231         if (cutoff != null) {
232             def = cutoff.value();
233         }
234         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_CUTOFF, Cutoff.NAME, def, Collections.emptyList()));
235         return new CutoffSetting(type, def);
236     }
237 
238 
239     private static Control definePeriod(PlatformEventType type) {
240         Period period = type.getAnnotation(Period.class);
241         String def = &quot;everyChunk&quot;;
242         if (period != null) {
243             def = period.value();
244         }
245         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_PERIOD, PeriodSetting.NAME, def, Collections.emptyList()));
246         return new PeriodSetting(type, def);
247     }
248 
249     void disable() {
<span class="line-modified">250         for (Control c : eventControls.values()) {</span>
<span class="line-modified">251             if (c instanceof EnabledSetting) {</span>
<span class="line-modified">252                 c.setValueSafe(&quot;false&quot;);</span>
253                 return;
254             }
255         }
256     }
257 
258     void writeActiveSettingEvent() {
259         if (!type.isRegistered()) {
260             return;
261         }
<span class="line-modified">262         for (Map.Entry&lt;String, Control&gt; entry : eventControls.entrySet()) {</span>
<span class="line-modified">263             Control c = entry.getValue();</span>
<span class="line-modified">264             if (Utils.isSettingVisible(c, type.hasEventHook())) {</span>
<span class="line-modified">265                 String value = c.getLastValue();</span>
266                 if (value == null) {
<span class="line-modified">267                     value = c.getDefaultValue();</span>
268                 }
<span class="line-modified">269                 ActiveSettingEvent ase = new ActiveSettingEvent();</span>
<span class="line-modified">270                 ase.id = type.getId();</span>
<span class="line-modified">271                 ase.name = entry.getKey();</span>
<span class="line-modified">272                 ase.value = value;</span>
<span class="line-removed">273                 ase.commit();</span>
274             }
275         }
276     }
277 
<span class="line-modified">278     public Set&lt;Entry&lt;String, Control&gt;&gt; getEntries() {</span>
<span class="line-modified">279         return eventControls.entrySet();</span>
280     }
281 
282     public PlatformEventType getEventType() {
283         return type;
284     }
285 
286     public String getSettingsId() {
287         return idName;
288     }
289 
290     public List&lt;SettingInfo&gt; getSettingInfos() {
291         return settingInfos;
292     }
293 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.lang.annotation.Annotation;
 29 import java.lang.reflect.Constructor;
 30 import java.lang.reflect.InvocationTargetException;
 31 import java.lang.reflect.Method;
 32 import java.lang.reflect.Modifier;
 33 import java.util.ArrayList;
 34 import java.util.Collections;

 35 import java.util.List;



 36 
 37 import jdk.internal.module.Modules;
 38 import jdk.jfr.AnnotationElement;
 39 import jdk.jfr.Enabled;
 40 import jdk.jfr.Name;
 41 import jdk.jfr.Period;
 42 import jdk.jfr.SettingControl;
 43 import jdk.jfr.SettingDefinition;
 44 import jdk.jfr.StackTrace;
 45 import jdk.jfr.Threshold;
 46 import jdk.jfr.events.ActiveSettingEvent;
 47 import jdk.jfr.internal.EventInstrumentation.SettingInfo;
 48 import jdk.jfr.internal.settings.CutoffSetting;
 49 import jdk.jfr.internal.settings.EnabledSetting;
 50 import jdk.jfr.internal.settings.PeriodSetting;
 51 import jdk.jfr.internal.settings.StackTraceSetting;
 52 import jdk.jfr.internal.settings.ThresholdSetting;
 53 
 54 // This class can&#39;t have a hard reference from PlatformEventType, since it
 55 // holds SettingControl instances that need to be released
 56 // when a class is unloaded (to avoid memory leaks).
 57 public final class EventControl {
<span class="line-modified"> 58     final static class NamedControl {</span>
<span class="line-added"> 59         public final String name;</span>
<span class="line-added"> 60         public final Control control;</span>
<span class="line-added"> 61         NamedControl(String name, Control control) {</span>
<span class="line-added"> 62             this.name = name;</span>
<span class="line-added"> 63             this.control = control;</span>
<span class="line-added"> 64         }</span>
<span class="line-added"> 65     }</span>
 66     static final String FIELD_SETTING_PREFIX = &quot;setting&quot;;
 67     private static final Type TYPE_ENABLED = TypeLibrary.createType(EnabledSetting.class);
 68     private static final Type TYPE_THRESHOLD = TypeLibrary.createType(ThresholdSetting.class);
 69     private static final Type TYPE_STACK_TRACE = TypeLibrary.createType(StackTraceSetting.class);
 70     private static final Type TYPE_PERIOD = TypeLibrary.createType(PeriodSetting.class);
 71     private static final Type TYPE_CUTOFF = TypeLibrary.createType(CutoffSetting.class);
 72 
<span class="line-modified"> 73     private final ArrayList&lt;SettingInfo&gt; settingInfos = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 74     private final ArrayList&lt;NamedControl&gt; namedControls = new ArrayList&lt;&gt;(5);</span>
 75     private final PlatformEventType type;
 76     private final String idName;
 77 
 78     EventControl(PlatformEventType eventType) {
<span class="line-modified"> 79         addControl(Enabled.NAME, defineEnabled(eventType));</span>
 80         if (eventType.hasDuration()) {
<span class="line-modified"> 81             addControl(Threshold.NAME, defineThreshold(eventType));</span>
 82         }
 83         if (eventType.hasStackTrace()) {
<span class="line-modified"> 84             addControl(StackTrace.NAME, defineStackTrace(eventType));</span>
 85         }
 86         if (eventType.hasPeriod()) {
<span class="line-modified"> 87             addControl(Period.NAME, definePeriod(eventType));</span>
 88         }
 89         if (eventType.hasCutoff()) {
<span class="line-modified"> 90             addControl(Cutoff.NAME, defineCutoff(eventType));</span>
 91         }
 92 
 93         ArrayList&lt;AnnotationElement&gt; aes = new ArrayList&lt;&gt;(eventType.getAnnotationElements());
 94         remove(eventType, aes, Threshold.class);
 95         remove(eventType, aes, Period.class);
 96         remove(eventType, aes, Enabled.class);
 97         remove(eventType, aes, StackTrace.class);
 98         remove(eventType, aes, Cutoff.class);
 99         aes.trimToSize();
100         eventType.setAnnotations(aes);
101         this.type = eventType;
102         this.idName = String.valueOf(eventType.getId());
103     }
104 
<span class="line-added">105     private boolean hasControl(String name) {</span>
<span class="line-added">106         for (NamedControl nc : namedControls) {</span>
<span class="line-added">107             if (name.equals(nc.name)) {</span>
<span class="line-added">108                 return true;</span>
<span class="line-added">109             }</span>
<span class="line-added">110         }</span>
<span class="line-added">111         return false;</span>
<span class="line-added">112     }</span>
<span class="line-added">113 </span>
<span class="line-added">114     private void addControl(String name, Control control) {</span>
<span class="line-added">115         namedControls.add(new NamedControl(name, control));</span>
<span class="line-added">116     }</span>
<span class="line-added">117 </span>
118     static void remove(PlatformEventType type, List&lt;AnnotationElement&gt; aes, Class&lt;? extends java.lang.annotation.Annotation&gt; clazz) {
119         long id = Type.getTypeId(clazz);
120         for (AnnotationElement a : type.getAnnotationElements()) {
121             if (a.getTypeId() == id &amp;&amp; a.getTypeName().equals(clazz.getName())) {
122                 aes.remove(a);
123             }
124         }
125     }
126 
127     EventControl(PlatformEventType es, Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
128         this(es);
129         defineSettings(eventClass);
130     }
131 
132     @SuppressWarnings(&quot;unchecked&quot;)
133     private void defineSettings(Class&lt;?&gt; eventClass) {
134         // Iterate up the class hierarchy and let
135         // subclasses shadow base classes.
136         boolean allowPrivateMethod = true;
137         while (eventClass != null) {
138             for (Method m : eventClass.getDeclaredMethods()) {
139                 boolean isPrivate = Modifier.isPrivate(m.getModifiers());
140                 if (m.getReturnType() == Boolean.TYPE &amp;&amp; m.getParameterCount() == 1 &amp;&amp; (!isPrivate || allowPrivateMethod)) {
141                     SettingDefinition se = m.getDeclaredAnnotation(SettingDefinition.class);
142                     if (se != null) {
143                         Class&lt;?&gt; settingClass = m.getParameters()[0].getType();
144                         if (!Modifier.isAbstract(settingClass.getModifiers()) &amp;&amp; SettingControl.class.isAssignableFrom(settingClass)) {
145                             String name = m.getName();
146                             Name n = m.getAnnotation(Name.class);
147                             if (n != null) {
148                                 name = n.value();
149                             }
<span class="line-modified">150 </span>
<span class="line-added">151                             if (!hasControl(name)) {</span>
152                                 defineSetting((Class&lt;? extends SettingControl&gt;) settingClass, m, type, name);
153                             }
154                         }
155                     }
156                 }
157             }
158             eventClass = eventClass.getSuperclass();
159             allowPrivateMethod = false;
160         }
161     }
162 
163     private void defineSetting(Class&lt;? extends SettingControl&gt; settingsClass, Method method, PlatformEventType eventType, String settingName) {
164         try {
165             Module settingModule = settingsClass.getModule();
166             Modules.addReads(settingModule, EventControl.class.getModule());
167             int index = settingInfos.size();
168             SettingInfo si = new SettingInfo(FIELD_SETTING_PREFIX + index, index);
169             si.settingControl = instantiateSettingControl(settingsClass);
170             Control c = si.settingControl;
171             c.setDefault();
172             String defaultValue = c.getValueSafe();
173             if (defaultValue != null) {
174                 Type settingType = TypeLibrary.createType(settingsClass);
175                 ArrayList&lt;AnnotationElement&gt; aes = new ArrayList&lt;&gt;();
176                 for (Annotation a : method.getDeclaredAnnotations()) {
177                     AnnotationElement ae = TypeLibrary.createAnnotation(a);
178                     if (ae != null) {
179                         aes.add(ae);
180                     }
181                 }
182                 aes.trimToSize();
<span class="line-modified">183                 addControl(settingName, si.settingControl);</span>
184                 eventType.add(PrivateAccess.getInstance().newSettingDescriptor(settingType, settingName, defaultValue, aes));
185                 settingInfos.add(si);
186             }
187         } catch (InstantiationException e) {
188             // Programming error by user, fail fast
189             throw new InstantiationError(&quot;Could not instantiate setting &quot; + settingsClass.getName() + &quot; for event &quot; + eventType.getLogName() + &quot;. &quot; + e.getMessage());
190         } catch (IllegalAccessException e) {
191             // Programming error by user, fail fast
192             throw new IllegalAccessError(&quot;Could not access setting &quot; + settingsClass.getName() + &quot; for event &quot; + eventType.getLogName() + &quot;. &quot; + e.getMessage());
193         }
194     }
195 
196     private SettingControl instantiateSettingControl(Class&lt;? extends SettingControl&gt; settingControlClass) throws IllegalAccessException, InstantiationException {
197         SecuritySupport.makeVisibleToJFR(settingControlClass);
198         final Constructor&lt;?&gt; cc;
199         try {
200             cc = settingControlClass.getDeclaredConstructors()[0];
201         } catch (Exception e) {
202             throw (Error) new InternalError(&quot;Could not get constructor for &quot; + settingControlClass.getName()).initCause(e);
203         }
</pre>
<hr />
<pre>
247         String def = Cutoff.INIFITY;
248         if (cutoff != null) {
249             def = cutoff.value();
250         }
251         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_CUTOFF, Cutoff.NAME, def, Collections.emptyList()));
252         return new CutoffSetting(type, def);
253     }
254 
255 
256     private static Control definePeriod(PlatformEventType type) {
257         Period period = type.getAnnotation(Period.class);
258         String def = &quot;everyChunk&quot;;
259         if (period != null) {
260             def = period.value();
261         }
262         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_PERIOD, PeriodSetting.NAME, def, Collections.emptyList()));
263         return new PeriodSetting(type, def);
264     }
265 
266     void disable() {
<span class="line-modified">267         for (NamedControl nc : namedControls) {</span>
<span class="line-modified">268             if (nc.control instanceof EnabledSetting) {</span>
<span class="line-modified">269                 nc.control.setValueSafe(&quot;false&quot;);</span>
270                 return;
271             }
272         }
273     }
274 
275     void writeActiveSettingEvent() {
276         if (!type.isRegistered()) {
277             return;
278         }
<span class="line-modified">279         ActiveSettingEvent event = ActiveSettingEvent.EVENT.get();</span>
<span class="line-modified">280         for (NamedControl nc : namedControls) {</span>
<span class="line-modified">281             if (Utils.isSettingVisible(nc.control, type.hasEventHook())) {</span>
<span class="line-modified">282                 String value = nc.control.getLastValue();</span>
283                 if (value == null) {
<span class="line-modified">284                     value = nc.control.getDefaultValue();</span>
285                 }
<span class="line-modified">286                 event.id = type.getId();</span>
<span class="line-modified">287                 event.name = nc.name;</span>
<span class="line-modified">288                 event.value = value;</span>
<span class="line-modified">289                 event.commit();</span>

290             }
291         }
292     }
293 
<span class="line-modified">294     public ArrayList&lt;NamedControl&gt; getNamedControls() {</span>
<span class="line-modified">295         return namedControls;</span>
296     }
297 
298     public PlatformEventType getEventType() {
299         return type;
300     }
301 
302     public String getSettingsId() {
303         return idName;
304     }
305 
306     public List&lt;SettingInfo&gt; getSettingInfos() {
307         return settingInfos;
308     }
309 }
</pre>
</td>
</tr>
</table>
<center><a href="../events/ActiveSettingEvent.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="EventInstrumentation.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
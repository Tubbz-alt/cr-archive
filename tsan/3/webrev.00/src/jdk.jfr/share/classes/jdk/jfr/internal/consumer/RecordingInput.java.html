<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RecordingInput.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.DataInput;
 29 import java.io.EOFException;
 30 import java.io.File;
 31 import java.io.IOException;
 32 import java.io.RandomAccessFile;
 33 import java.nio.file.Path;
 34 
 35 public final class RecordingInput implements DataInput, AutoCloseable {
 36 
 37     private final static int DEFAULT_BLOCK_SIZE = 64_000;
 38 
 39     private static final class Block {
 40         private byte[] bytes = new byte[0];
 41         private long blockPosition;
 42         private long blockPositionEnd;
 43 
 44         boolean contains(long position) {
 45             return position &gt;= blockPosition &amp;&amp; position &lt; blockPositionEnd;
 46         }
 47 
 48         public void read(RandomAccessFile file, int amount) throws IOException {
 49             blockPosition = file.getFilePointer();
 50             // reuse byte array, if possible
 51             if (amount &gt; bytes.length) {
 52                 bytes = new byte[amount];
 53             }
 54             this.blockPositionEnd = blockPosition + amount;
 55             file.readFully(bytes, 0, amount);
 56         }
 57 
 58         public byte get(long position) {
 59             return bytes[(int) (position - blockPosition)];
 60         }
 61 
 62         public void reset() {
 63             blockPosition = 0;
 64             blockPositionEnd = 0;
 65         }
 66     }
 67     private final int blockSize;
 68     private final FileAccess fileAccess;
 69     private RandomAccessFile file;
 70     private String filename;
 71     private Block currentBlock = new Block();
 72     private Block previousBlock = new Block();
 73     private long position;
 74     private long size = -1; // Fail fast if setSize(...) has not been called
 75                             // before parsing
 76 
 77     RecordingInput(File f, FileAccess fileAccess, int blockSize) throws IOException {
 78         this.blockSize = blockSize;
 79         this.fileAccess = fileAccess;
 80         initialize(f);
 81     }
 82 
 83     private void initialize(File f) throws IOException {
 84         this.filename = fileAccess.getAbsolutePath(f);
 85         this.file = fileAccess.openRAF(f, &quot;r&quot;);
 86         this.position = 0;
 87         this.size = -1;
 88         this.currentBlock.reset();
 89         previousBlock.reset();
 90         if (fileAccess.length(f) &lt; 8) {
 91             throw new IOException(&quot;Not a valid Flight Recorder file. File length is only &quot; + fileAccess.length(f) + &quot; bytes.&quot;);
 92         }
 93     }
 94 
 95     public RecordingInput(File f, FileAccess fileAccess) throws IOException {
 96         this(f, fileAccess, DEFAULT_BLOCK_SIZE);
 97     }
 98 
 99     void positionPhysical(long position) throws IOException {
100         file.seek(position);
101     }
102 
103     byte readPhysicalByte() throws IOException {
104         return file.readByte();
105     }
106 
107     long readPhysicalLong() throws IOException {
108         return file.readLong();
109     }
110 
111     @Override
112     public final byte readByte() throws IOException {
113         if (!currentBlock.contains(position)) {
114             position(position);
115         }
116         return currentBlock.get(position++);
117     }
118 
119     @Override
120     public final void readFully(byte[] dest, int offset, int length) throws IOException {
121         // TODO: Optimize, use Arrays.copy if all bytes are in current block
122         // array
123         for (int i = 0; i &lt; length; i++) {
124             dest[i + offset] = readByte();
125         }
126     }
127 
128     @Override
129     public final void readFully(byte[] dst) throws IOException {
130         readFully(dst, 0, dst.length);
131     }
132 
133     short readRawShort() throws IOException {
134         // copied from java.io.Bits
135         byte b0 = readByte();
136         byte b1 = readByte();
137         return (short) ((b1 &amp; 0xFF) + (b0 &lt;&lt; 8));
138     }
139 
140     @Override
141     public double readDouble() throws IOException {
142         // copied from java.io.Bits
143         return Double.longBitsToDouble(readRawLong());
144     }
145 
146     @Override
147     public float readFloat() throws IOException {
148         // copied from java.io.Bits
149         return Float.intBitsToFloat(readRawInt());
150     }
151 
152     int readRawInt() throws IOException {
153         // copied from java.io.Bits
154         byte b0 = readByte();
155         byte b1 = readByte();
156         byte b2 = readByte();
157         byte b3 = readByte();
158         return ((b3 &amp; 0xFF)) + ((b2 &amp; 0xFF) &lt;&lt; 8) + ((b1 &amp; 0xFF) &lt;&lt; 16) + ((b0) &lt;&lt; 24);
159     }
160 
161     long readRawLong() throws IOException {
162         // copied from java.io.Bits
163         byte b0 = readByte();
164         byte b1 = readByte();
165         byte b2 = readByte();
166         byte b3 = readByte();
167         byte b4 = readByte();
168         byte b5 = readByte();
169         byte b6 = readByte();
170         byte b7 = readByte();
171         return ((b7 &amp; 0xFFL)) + ((b6 &amp; 0xFFL) &lt;&lt; 8) + ((b5 &amp; 0xFFL) &lt;&lt; 16) + ((b4 &amp; 0xFFL) &lt;&lt; 24) + ((b3 &amp; 0xFFL) &lt;&lt; 32) + ((b2 &amp; 0xFFL) &lt;&lt; 40) + ((b1 &amp; 0xFFL) &lt;&lt; 48) + (((long) b0) &lt;&lt; 56);
172     }
173 
174     public final long position() {
175         return position;
176     }
177 
178     public final void position(long newPosition) throws IOException {
179         if (!currentBlock.contains(newPosition)) {
180             if (!previousBlock.contains(newPosition)) {
181                 if (newPosition &gt; size) {
182                     throw new EOFException(&quot;Trying to read at &quot; + newPosition + &quot;, but file is only &quot; + size + &quot; bytes.&quot;);
183                 }
184                 long blockStart = trimToFileSize(calculateBlockStart(newPosition));
185                 file.seek(blockStart);
186                 // trim amount to file size
187                 long amount = Math.min(size - blockStart, blockSize);
188                 previousBlock.read(file, (int) amount);
189             }
190             // swap previous and current
191             Block tmp = currentBlock;
192             currentBlock = previousBlock;
193             previousBlock = tmp;
194         }
195         position = newPosition;
196     }
197 
198     private final long trimToFileSize(long position) throws IOException {
199         return Math.min(size(), Math.max(0, position));
200     }
201 
202     private final long calculateBlockStart(long newPosition) {
203         // align to end of current block
204         if (currentBlock.contains(newPosition - blockSize)) {
205             return currentBlock.blockPosition + currentBlock.bytes.length;
206         }
207         // align before current block
208         if (currentBlock.contains(newPosition + blockSize)) {
209             return currentBlock.blockPosition - blockSize;
210         }
211         // not near current block, pick middle
212         return newPosition - blockSize / 2;
213     }
214 
215     long size() {
216         return size;
217     }
218 
219     @Override
220     public void close() throws IOException {
221         file.close();
222     }
223 
224     @Override
225     public final int skipBytes(int n) throws IOException {
226         long position = position();
227         position(position + n);
228         return (int) (position() - position);
229     }
230 
231     @Override
232     public final boolean readBoolean() throws IOException {
233         return readByte() != 0;
234     }
235 
236     @Override
237     public int readUnsignedByte() throws IOException {
238         return readByte() &amp; 0x00FF;
239     }
240 
241     @Override
242     public int readUnsignedShort() throws IOException {
243         return readShort() &amp; 0xFFFF;
244     }
245 
246     @Override
247     public final String readLine() throws IOException {
248         throw new UnsupportedOperationException();
249     }
250 
251     // NOTE, this method should really be called readString
252     // but can&#39;t be renamed without making RecordingInput a
253     // public class.
254     //
255     // This method DOES Not read as expected (s2 + utf8 encoded character)
256     // instead it read:
257     // byte encoding
258     // int size
259     // data (byte or char)
260     //
261     // where encoding
262     //
263     // 0, means null
264     // 1, means UTF8 encoded byte array
265     // 2, means char array
266     // 3, means latin-1 (ISO-8859-1) encoded byte array
267     // 4, means &quot;&quot;
268     @Override
269     public String readUTF() throws IOException {
270         throw new UnsupportedOperationException(&quot;Use StringParser&quot;);
271     }
272 
273     @Override
274     public char readChar() throws IOException {
275         return (char) readLong();
276     }
277 
278     @Override
279     public short readShort() throws IOException {
280         return (short) readLong();
281     }
282 
283     @Override
284     public int readInt() throws IOException {
285         return (int) readLong();
286     }
287 
288     @Override
289     public long readLong() throws IOException {
290         final byte[] bytes = currentBlock.bytes;
291         final int index = (int) (position - currentBlock.blockPosition);
292 
293         if (index + 8 &lt; bytes.length &amp;&amp; index &gt;= 0) {
294             byte b0 = bytes[index];
295             long ret = (b0 &amp; 0x7FL);
296             if (b0 &gt;= 0) {
297                 position += 1;
298                 return ret;
299             }
300             int b1 = bytes[index + 1];
301             ret += (b1 &amp; 0x7FL) &lt;&lt; 7;
302             if (b1 &gt;= 0) {
303                 position += 2;
304                 return ret;
305             }
306             int b2 = bytes[index + 2];
307             ret += (b2 &amp; 0x7FL) &lt;&lt; 14;
308             if (b2 &gt;= 0) {
309                 position += 3;
310                 return ret;
311             }
312             int b3 = bytes[index + 3];
313             ret += (b3 &amp; 0x7FL) &lt;&lt; 21;
314             if (b3 &gt;= 0) {
315                 position += 4;
316                 return ret;
317             }
318             int b4 = bytes[index + 4];
319             ret += (b4 &amp; 0x7FL) &lt;&lt; 28;
320             if (b4 &gt;= 0) {
321                 position += 5;
322                 return ret;
323             }
324             int b5 = bytes[index + 5];
325             ret += (b5 &amp; 0x7FL) &lt;&lt; 35;
326             if (b5 &gt;= 0) {
327                 position += 6;
328                 return ret;
329             }
330             int b6 = bytes[index + 6];
331             ret += (b6 &amp; 0x7FL) &lt;&lt; 42;
332             if (b6 &gt;= 0) {
333                 position += 7;
334                 return ret;
335             }
336             int b7 = bytes[index + 7];
337             ret += (b7 &amp; 0x7FL) &lt;&lt; 49;
338             if (b7 &gt;= 0) {
339                 position += 8;
340                 return ret;
341             }
342             int b8 = bytes[index + 8];// read last byte raw
343             position += 9;
344             return ret + (((long) (b8 &amp; 0XFF)) &lt;&lt; 56);
345         } else {
346             return readLongSlow();
347         }
348     }
349 
350     private long readLongSlow() throws IOException {
351         byte b0 = readByte();
352         long ret = (b0 &amp; 0x7FL);
353         if (b0 &gt;= 0) {
354             return ret;
355         }
356 
357         int b1 = readByte();
358         ret += (b1 &amp; 0x7FL) &lt;&lt; 7;
359         if (b1 &gt;= 0) {
360             return ret;
361         }
362 
363         int b2 = readByte();
364         ret += (b2 &amp; 0x7FL) &lt;&lt; 14;
365         if (b2 &gt;= 0) {
366             return ret;
367         }
368 
369         int b3 = readByte();
370         ret += (b3 &amp; 0x7FL) &lt;&lt; 21;
371         if (b3 &gt;= 0) {
372             return ret;
373         }
374 
375         int b4 = readByte();
376         ret += (b4 &amp; 0x7FL) &lt;&lt; 28;
377         if (b4 &gt;= 0) {
378             return ret;
379         }
380 
381         int b5 = readByte();
382         ret += (b5 &amp; 0x7FL) &lt;&lt; 35;
383         if (b5 &gt;= 0) {
384             return ret;
385         }
386 
387         int b6 = readByte();
388         ret += (b6 &amp; 0x7FL) &lt;&lt; 42;
389         if (b6 &gt;= 0) {
390             return ret;
391         }
392 
393         int b7 = readByte();
394         ret += (b7 &amp; 0x7FL) &lt;&lt; 49;
395         if (b7 &gt;= 0) {
396             return ret;
397 
398         }
399 
400         int b8 = readByte(); // read last byte raw
401         return ret + (((long) (b8 &amp; 0XFF)) &lt;&lt; 56);
402     }
403 
404     public void setValidSize(long size) {
405         if (size &gt; this.size) {
406             this.size = size;
407         }
408     }
409 
410     public long getFileSize() throws IOException {
411         return file.length();
412     }
413 
414     public String getFilename() {
415         return filename;
416     }
417 
418     // Purpose of this method is to reuse block cache from a
419     // previous RecordingInput
420     public void setFile(Path path) throws IOException {
421         try {
422             file.close();
423         } catch (IOException e) {
424             // perhaps deleted
425         }
426         file = null;
427         initialize(path.toFile());
428     }
429 /*
430 
431 
432 
433 
434 
435  *
436  *
437  */
438 }
    </pre>
  </body>
</html>
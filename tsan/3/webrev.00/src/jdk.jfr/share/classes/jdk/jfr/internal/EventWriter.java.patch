diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriter.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriter.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriter.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,11 +24,11 @@
  */
 
 package jdk.jfr.internal;
 
 import jdk.internal.misc.Unsafe;
-import jdk.jfr.internal.consumer.RecordingInput;
+import jdk.jfr.internal.consumer.StringParser;
 
 /**
  * Class must reside in a package with package restriction.
  *
  * Users should not have direct access to underlying memory.
@@ -113,22 +113,22 @@
         }
     }
 
     public void putString(String s, StringPool pool) {
         if (s == null) {
-            putByte(RecordingInput.STRING_ENCODING_NULL);
+            putByte(StringParser.Encoding.NULL.byteValue());
             return;
         }
         int length = s.length();
         if (length == 0) {
-            putByte(RecordingInput.STRING_ENCODING_EMPTY_STRING);
+            putByte(StringParser.Encoding.EMPTY_STRING.byteValue());
             return;
         }
         if (length > StringPool.MIN_LIMIT && length < StringPool.MAX_LIMIT) {
             long l = StringPool.addString(s);
             if (l > 0) {
-                putByte(RecordingInput.STRING_ENCODING_CONSTANT_POOL);
+                putByte(StringParser.Encoding.CONSTANT_POOL.byteValue());
                 putLong(l);
                 return;
             }
         }
         putStringValue(s);
@@ -136,11 +136,11 @@
     }
 
     private void putStringValue(String s) {
         int length = s.length();
         if (isValidForSize(1 + 5 + 3 * length)) {
-            putUncheckedByte(RecordingInput.STRING_ENCODING_CHAR_ARRAY); // 1 byte
+            putUncheckedByte(StringParser.Encoding.CHAR_ARRAY.byteValue()); // 1 byte
             putUncheckedInt(length); // max 5 bytes
             for (int i = 0; i < length; i++) {
                 putUncheckedChar(s.charAt(i)); // max 3 bytes
             }
         }
@@ -195,15 +195,11 @@
             return false;
         }
         if (currentPosition + requestedSize > maxPosition) {
             flushOnEnd = flush(usedSize(), requestedSize);
             // retry
-            if (currentPosition + requestedSize > maxPosition) {
-                Logger.log(LogTag.JFR_SYSTEM,
-                           LogLevel.WARN, () ->
-                               "Unable to commit. Requested size " + requestedSize + " too large");
-                valid = false;
+            if (!valid) {
                 return false;
             }
         }
         return true;
     }
@@ -256,11 +252,12 @@
             reset();
             // returning false will trigger restart of the event write attempt
             return false;
         }
         startPosition = currentPosition;
-        unsafe.putAddress(startPositionAddress, startPosition);
+        unsafe.storeStoreFence();
+        unsafe.putAddress(startPositionAddress, currentPosition);
         // the event is now committed
         if (flushOnEnd) {
             flushOnEnd = flush();
         }
         started = false;

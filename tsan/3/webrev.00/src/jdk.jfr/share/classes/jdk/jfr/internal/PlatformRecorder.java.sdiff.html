<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecorder.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlatformEventType.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PlatformRecording.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecorder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 37 import java.time.Duration;
 38 import java.time.Instant;
 39 import java.util.ArrayList;
 40 import java.util.Collections;
 41 import java.util.HashMap;
 42 import java.util.HashSet;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Set;
 46 import java.util.Timer;
 47 import java.util.TimerTask;
 48 import java.util.concurrent.CopyOnWriteArrayList;
 49 
 50 import jdk.jfr.EventType;
 51 import jdk.jfr.FlightRecorder;
 52 import jdk.jfr.FlightRecorderListener;
 53 import jdk.jfr.Recording;
 54 import jdk.jfr.RecordingState;
 55 import jdk.jfr.events.ActiveRecordingEvent;
 56 import jdk.jfr.events.ActiveSettingEvent;

 57 import jdk.jfr.internal.SecuritySupport.SecureRecorderListener;
 58 import jdk.jfr.internal.instrument.JDKEvents;
 59 
 60 public final class PlatformRecorder {
 61 

 62     private final List&lt;PlatformRecording&gt; recordings = new ArrayList&lt;&gt;();
 63     private final static List&lt;SecureRecorderListener&gt; changeListeners = new ArrayList&lt;&gt;();
 64     private final Repository repository;
 65     private final Timer timer;
 66     private final static JVM jvm = JVM.getJVM();
 67     private final EventType activeRecordingEvent;
 68     private final EventType activeSettingEvent;
 69     private final Thread shutdownHook;
 70 
 71     private long recordingCounter = 0;
 72     private RepositoryChunk currentChunk;

 73 
 74     public PlatformRecorder() throws Exception {
 75         repository = Repository.getRepository();
 76         Logger.log(JFR_SYSTEM, INFO, &quot;Initialized disk repository&quot;);
 77         repository.ensureRepository();
 78         jvm.createNativeJFR();
 79         Logger.log(JFR_SYSTEM, INFO, &quot;Created native&quot;);
 80         JDKEvents.initialize();
 81         Logger.log(JFR_SYSTEM, INFO, &quot;Registered JDK events&quot;);
 82         JDKEvents.addInstrumentation();
 83         startDiskMonitor();
 84         activeRecordingEvent = EventType.getEventType(ActiveRecordingEvent.class);
 85         activeSettingEvent = EventType.getEventType(ActiveSettingEvent.class);
 86         shutdownHook = SecuritySupport.createThreadWitNoPermissions(&quot;JFR: Shutdown Hook&quot;, new ShutdownHook(this));
 87         SecuritySupport.setUncaughtExceptionHandler(shutdownHook, new ShutdownHook.ExceptionHandler());
 88         SecuritySupport.registerShutdownHook(shutdownHook);
 89         timer = createTimer();
 90     }
 91 
 92 
 93     private static Timer createTimer() {
 94         try {
 95             List&lt;Timer&gt; result = new CopyOnWriteArrayList&lt;&gt;();
 96             Thread t = SecuritySupport.createThreadWitNoPermissions(&quot;Permissionless thread&quot;, ()-&gt; {
 97                 result.add(new Timer(&quot;JFR Recording Scheduler&quot;, true));
 98             });

 99             t.start();
100             t.join();
101             return result.get(0);
102         } catch (InterruptedException e) {
103             throw new IllegalStateException(&quot;Not able to create timer task. &quot; + e.getMessage(), e);
104         }
105     }
106 
107     public synchronized PlatformRecording newRecording(Map&lt;String, String&gt; settings) {
108         return newRecording(settings, ++recordingCounter);
109     }
110 
111     // To be used internally when doing dumps.
112     // Caller must have recorder lock and close recording before releasing lock
113     public PlatformRecording newTemporaryRecording() {
114         if(!Thread.holdsLock(this)) {
115             throw new InternalError(&quot;Caller must have recorder lock&quot;);
116         }
117         return newRecording(new HashMap&lt;&gt;(), 0);
118     }
</pre>
<hr />
<pre>
158             }
159         }
160         return false;
161     }
162 
163     static synchronized List&lt;FlightRecorderListener&gt; getListeners() {
164         return new ArrayList&lt;&gt;(changeListeners);
165     }
166 
167     Timer getTimer() {
168         return timer;
169     }
170 
171     public static void notifyRecorderInitialized(FlightRecorder recorder) {
172         Logger.log(JFR_SYSTEM, TRACE, &quot;Notifying listeners that Flight Recorder is initialized&quot;);
173         for (FlightRecorderListener r : getListeners()) {
174             r.recorderInitialized(recorder);
175         }
176     }
177 




178     // called by shutdown hook
179     synchronized void destroy() {
180         try {
181             timer.cancel();
182         } catch (Exception ex) {
183             Logger.log(JFR_SYSTEM, WARN, &quot;Shutdown hook could not cancel timer&quot;);
184         }
185 
186         for (PlatformRecording p : getRecordings()) {
187             if (p.getState() == RecordingState.RUNNING) {
188                 try {
189                     p.stop(&quot;Shutdown&quot;);
190                 } catch (Exception ex) {
191                     Logger.log(JFR, WARN, &quot;Recording &quot; + p.getName() + &quot;:&quot; + p.getId() + &quot; could not be stopped&quot;);
192                 }
193             }
194         }
195 
196         JDKEvents.remove();
197 
198         if (jvm.hasNativeJFR()) {
199             if (jvm.isRecording()) {
<span class="line-modified">200                 jvm.endRecording_();</span>
201             }
202             jvm.destroyNativeJFR();
203         }
204         repository.clear();
205     }
206 
<span class="line-modified">207     synchronized void start(PlatformRecording recording) {</span>
208         // State can only be NEW or DELAYED because of previous checks
209         Instant now = Instant.now();
210         recording.setStartTime(now);
211         recording.updateTimer();
212         Duration duration = recording.getDuration();
213         if (duration != null) {
214             recording.setStopTime(now.plus(duration));
215         }
216         boolean toDisk = recording.isToDisk();
217         boolean beginPhysical = true;

218         for (PlatformRecording s : getRecordings()) {
219             if (s.getState() == RecordingState.RUNNING) {
220                 beginPhysical = false;
221                 if (s.isToDisk()) {
222                     toDisk = true;
223                 }

224             }
225         }

226         if (beginPhysical) {
227             RepositoryChunk newChunk = null;
228             if (toDisk) {
229                 newChunk = repository.newChunk(now);
230                 MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());
231             } else {
232                 MetadataRepository.getInstance().setOutput(null);
233             }
234             currentChunk = newChunk;
<span class="line-modified">235             jvm.beginRecording_();</span>

236             recording.setState(RecordingState.RUNNING);
237             updateSettings();
238             writeMetaEvents();
239         } else {
240             RepositoryChunk newChunk = null;
241             if (toDisk) {
242                 newChunk = repository.newChunk(now);
243                 RequestEngine.doChunkEnd();
244                 MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());

245             }
246             recording.setState(RecordingState.RUNNING);
247             updateSettings();
248             writeMetaEvents();
249             if (currentChunk != null) {
250                 finishChunk(currentChunk, now, recording);
251             }
252             currentChunk = newChunk;
253         }
<span class="line-modified">254 </span>


255         RequestEngine.doChunkBegin();


256     }
257 
258     synchronized void stop(PlatformRecording recording) {
259         RecordingState state = recording.getState();
260 
261         if (Utils.isAfter(state, RecordingState.RUNNING)) {
262             throw new IllegalStateException(&quot;Can&#39;t stop an already stopped recording.&quot;);
263         }
264         if (Utils.isBefore(state, RecordingState.RUNNING)) {
265             throw new IllegalStateException(&quot;Recording must be started before it can be stopped.&quot;);
266         }
267         Instant now = Instant.now();
268         boolean toDisk = false;
269         boolean endPhysical = true;

270         for (PlatformRecording s : getRecordings()) {
271             RecordingState rs = s.getState();
272             if (s != recording &amp;&amp; RecordingState.RUNNING == rs) {
273                 endPhysical = false;
274                 if (s.isToDisk()) {
275                     toDisk = true;
276                 }

277             }
278         }
279         OldObjectSample.emit(recording);

280 
281         if (endPhysical) {
282             RequestEngine.doChunkEnd();
283             if (recording.isToDisk()) {
284                 if (currentChunk != null) {



285                     MetadataRepository.getInstance().setOutput(null);
286                     finishChunk(currentChunk, now, null);
287                     currentChunk = null;
288                 }
289             } else {
290                 // last memory
291                 dumpMemoryToDestination(recording);
292             }
<span class="line-modified">293             jvm.endRecording_();</span>
294             disableEvents();
295         } else {
296             RepositoryChunk newChunk = null;
297             RequestEngine.doChunkEnd();
298             updateSettingsButIgnoreRecording(recording);
299             if (toDisk) {
300                 newChunk = repository.newChunk(now);
301                 MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());
302             } else {
303                 MetadataRepository.getInstance().setOutput(null);
304             }
305             writeMetaEvents();
306             if (currentChunk != null) {
307                 finishChunk(currentChunk, now, null);
308             }
309             currentChunk = newChunk;
310             RequestEngine.doChunkBegin();
311         }






312         recording.setState(RecordingState.STOPPED);
313     }
314 
315     private void dumpMemoryToDestination(PlatformRecording recording)  {
316         WriteableUserPath dest = recording.getDestination();
317         if (dest != null) {
<span class="line-modified">318             MetadataRepository.getInstance().setOutput(dest.getText());</span>
319             recording.clearDestination();
320         }
321     }
322     private void disableEvents() {
323         MetadataRepository.getInstance().disableEvents();
324     }
325 
326     void updateSettings() {
327         updateSettingsButIgnoreRecording(null);
328     }
329 
330     void updateSettingsButIgnoreRecording(PlatformRecording ignoreMe) {
331         List&lt;PlatformRecording&gt; recordings = getRunningRecordings();
332         List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;(recordings.size());
333         for (PlatformRecording r : recordings) {
334             if (r != ignoreMe) {
335                 list.add(r.getSettings());
336             }
337         }
338         MetadataRepository.getInstance().setSettings(list);
339     }
340 


341     synchronized void rotateDisk() {
342         Instant now = Instant.now();
343         RepositoryChunk newChunk = repository.newChunk(now);
344         RequestEngine.doChunkEnd();
345         MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());
346         writeMetaEvents();
347         if (currentChunk != null) {
348             finishChunk(currentChunk, now, null);
349         }
350         currentChunk = newChunk;
351         RequestEngine.doChunkBegin();
352     }
353 
354     private List&lt;PlatformRecording&gt; getRunningRecordings() {
355         List&lt;PlatformRecording&gt; runningRecordings = new ArrayList&lt;&gt;();
356         for (PlatformRecording recording : getRecordings()) {
357             if (recording.getState() == RecordingState.RUNNING) {
358                 runningRecordings.add(recording);
359             }
360         }
</pre>
<hr />
<pre>
378             Collections.sort(chunks, RepositoryChunk.END_TIME_COMPARATOR);
379             return chunks;
380         }
381 
382         return Collections.emptyList();
383     }
384 
385     private void startDiskMonitor() {
386         Thread t = SecuritySupport.createThreadWitNoPermissions(&quot;JFR Periodic Tasks&quot;, () -&gt; periodicTask());
387         SecuritySupport.setDaemonThread(t, true);
388         t.start();
389     }
390 
391     private void finishChunk(RepositoryChunk chunk, Instant time, PlatformRecording ignoreMe) {
392         chunk.finish(time);
393         for (PlatformRecording r : getRecordings()) {
394             if (r != ignoreMe &amp;&amp; r.getState() == RecordingState.RUNNING) {
395                 r.appendChunk(chunk);
396             }
397         }

398     }
399 
400     private void writeMetaEvents() {
<span class="line-removed">401 </span>
402         if (activeRecordingEvent.isEnabled()) {

403             for (PlatformRecording r : getRecordings()) {
404                 if (r.getState() == RecordingState.RUNNING &amp;&amp; r.shouldWriteMetadataEvent()) {
<span class="line-removed">405                     ActiveRecordingEvent event = new ActiveRecordingEvent();</span>
406                     event.id = r.getId();
407                     event.name = r.getName();
408                     WriteableUserPath p = r.getDestination();
<span class="line-modified">409                     event.destination = p == null ? null : p.getText();</span>
410                     Duration d = r.getDuration();
411                     event.recordingDuration = d == null ? Long.MAX_VALUE : d.toMillis();
412                     Duration age = r.getMaxAge();
413                     event.maxAge = age == null ? Long.MAX_VALUE : age.toMillis();
414                     Long size = r.getMaxSize();
415                     event.maxSize = size == null ? Long.MAX_VALUE : size;
416                     Instant start = r.getStartTime();
417                     event.recordingStart = start == null ? Long.MAX_VALUE : start.toEpochMilli();


418                     event.commit();
419                 }
420             }
421         }
422         if (activeSettingEvent.isEnabled()) {
423             for (EventControl ec : MetadataRepository.getInstance().getEventControls()) {
424                 ec.writeActiveSettingEvent();
425             }
426         }
427     }
428 
429     private void periodicTask() {
430         if (!jvm.hasNativeJFR()) {
431             return;
432         }
433         while (true) {
434             synchronized (this) {
435                 if (jvm.shouldRotateDisk()) {
436                     rotateDisk();
437                 }
438             }
439             long minDelta = RequestEngine.doPeriodic();
440             long wait = Math.min(minDelta, Options.getWaitInterval());
441             takeNap(wait);
442         }
443     }
444 
445     private void takeNap(long duration) {
446         try {
447             synchronized (JVM.FILE_DELTA_CHANGE) {
448                 JVM.FILE_DELTA_CHANGE.wait(duration &lt; 10 ? 10 : duration);
449             }
450         } catch (InterruptedException e) {
<span class="line-modified">451             e.printStackTrace();</span>
452         }
453     }
454 
455     synchronized Recording newCopy(PlatformRecording r, boolean stop) {
456         Recording newRec = new Recording();
457         PlatformRecording copy = PrivateAccess.getInstance().getPlatformRecording(newRec);
458         copy.setSettings(r.getSettings());
459         copy.setMaxAge(r.getMaxAge());
460         copy.setMaxSize(r.getMaxSize());
461         copy.setDumpOnExit(r.getDumpOnExit());
462         copy.setName(&quot;Clone of &quot; + r.getName());
463         copy.setToDisk(r.isToDisk());
464         copy.setInternalDuration(r.getDuration());
465         copy.setStartTime(r.getStartTime());
466         copy.setStopTime(r.getStopTime());
467 
468         if (r.getState() == RecordingState.NEW) {
469             return newRec;
470         }
471         if (r.getState() == RecordingState.DELAYED) {
</pre>
<hr />
<pre>
533 
534         for (RepositoryChunk c : target.getChunks()) {
535             if (startTime == null || c.getStartTime().isBefore(startTime)) {
536                 startTime = c.getStartTime();
537             }
538             if (endTime == null || c.getEndTime().isAfter(endTime)) {
539                 endTime = c.getEndTime();
540             }
541         }
542         Instant now = Instant.now();
543         if (startTime == null) {
544             startTime = now;
545         }
546         if (endTime == null) {
547             endTime = now;
548         }
549         target.setStartTime(startTime);
550         target.setStopTime(endTime);
551         target.setInternalDuration(Duration.between(startTime, endTime));
552     }
















553 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 37 import java.time.Duration;
 38 import java.time.Instant;
 39 import java.util.ArrayList;
 40 import java.util.Collections;
 41 import java.util.HashMap;
 42 import java.util.HashSet;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Set;
 46 import java.util.Timer;
 47 import java.util.TimerTask;
 48 import java.util.concurrent.CopyOnWriteArrayList;
 49 
 50 import jdk.jfr.EventType;
 51 import jdk.jfr.FlightRecorder;
 52 import jdk.jfr.FlightRecorderListener;
 53 import jdk.jfr.Recording;
 54 import jdk.jfr.RecordingState;
 55 import jdk.jfr.events.ActiveRecordingEvent;
 56 import jdk.jfr.events.ActiveSettingEvent;
<span class="line-added"> 57 import jdk.jfr.internal.SecuritySupport.SafePath;</span>
 58 import jdk.jfr.internal.SecuritySupport.SecureRecorderListener;
 59 import jdk.jfr.internal.instrument.JDKEvents;
 60 
 61 public final class PlatformRecorder {
 62 
<span class="line-added"> 63 </span>
 64     private final List&lt;PlatformRecording&gt; recordings = new ArrayList&lt;&gt;();
 65     private final static List&lt;SecureRecorderListener&gt; changeListeners = new ArrayList&lt;&gt;();
 66     private final Repository repository;
 67     private final Timer timer;
 68     private final static JVM jvm = JVM.getJVM();
 69     private final EventType activeRecordingEvent;
 70     private final EventType activeSettingEvent;
 71     private final Thread shutdownHook;
 72 
 73     private long recordingCounter = 0;
 74     private RepositoryChunk currentChunk;
<span class="line-added"> 75     private boolean inShutdown;</span>
 76 
 77     public PlatformRecorder() throws Exception {
 78         repository = Repository.getRepository();
 79         Logger.log(JFR_SYSTEM, INFO, &quot;Initialized disk repository&quot;);
 80         repository.ensureRepository();
 81         jvm.createNativeJFR();
 82         Logger.log(JFR_SYSTEM, INFO, &quot;Created native&quot;);
 83         JDKEvents.initialize();
 84         Logger.log(JFR_SYSTEM, INFO, &quot;Registered JDK events&quot;);
 85         JDKEvents.addInstrumentation();
 86         startDiskMonitor();
 87         activeRecordingEvent = EventType.getEventType(ActiveRecordingEvent.class);
 88         activeSettingEvent = EventType.getEventType(ActiveSettingEvent.class);
 89         shutdownHook = SecuritySupport.createThreadWitNoPermissions(&quot;JFR: Shutdown Hook&quot;, new ShutdownHook(this));
 90         SecuritySupport.setUncaughtExceptionHandler(shutdownHook, new ShutdownHook.ExceptionHandler());
 91         SecuritySupport.registerShutdownHook(shutdownHook);
 92         timer = createTimer();
 93     }
 94 
 95 
 96     private static Timer createTimer() {
 97         try {
 98             List&lt;Timer&gt; result = new CopyOnWriteArrayList&lt;&gt;();
 99             Thread t = SecuritySupport.createThreadWitNoPermissions(&quot;Permissionless thread&quot;, ()-&gt; {
100                 result.add(new Timer(&quot;JFR Recording Scheduler&quot;, true));
101             });
<span class="line-added">102             jvm.exclude(t);</span>
103             t.start();
104             t.join();
105             return result.get(0);
106         } catch (InterruptedException e) {
107             throw new IllegalStateException(&quot;Not able to create timer task. &quot; + e.getMessage(), e);
108         }
109     }
110 
111     public synchronized PlatformRecording newRecording(Map&lt;String, String&gt; settings) {
112         return newRecording(settings, ++recordingCounter);
113     }
114 
115     // To be used internally when doing dumps.
116     // Caller must have recorder lock and close recording before releasing lock
117     public PlatformRecording newTemporaryRecording() {
118         if(!Thread.holdsLock(this)) {
119             throw new InternalError(&quot;Caller must have recorder lock&quot;);
120         }
121         return newRecording(new HashMap&lt;&gt;(), 0);
122     }
</pre>
<hr />
<pre>
162             }
163         }
164         return false;
165     }
166 
167     static synchronized List&lt;FlightRecorderListener&gt; getListeners() {
168         return new ArrayList&lt;&gt;(changeListeners);
169     }
170 
171     Timer getTimer() {
172         return timer;
173     }
174 
175     public static void notifyRecorderInitialized(FlightRecorder recorder) {
176         Logger.log(JFR_SYSTEM, TRACE, &quot;Notifying listeners that Flight Recorder is initialized&quot;);
177         for (FlightRecorderListener r : getListeners()) {
178             r.recorderInitialized(recorder);
179         }
180     }
181 
<span class="line-added">182     synchronized void setInShutDown() {</span>
<span class="line-added">183         this.inShutdown = true;</span>
<span class="line-added">184     }</span>
<span class="line-added">185 </span>
186     // called by shutdown hook
187     synchronized void destroy() {
188         try {
189             timer.cancel();
190         } catch (Exception ex) {
191             Logger.log(JFR_SYSTEM, WARN, &quot;Shutdown hook could not cancel timer&quot;);
192         }
193 
194         for (PlatformRecording p : getRecordings()) {
195             if (p.getState() == RecordingState.RUNNING) {
196                 try {
197                     p.stop(&quot;Shutdown&quot;);
198                 } catch (Exception ex) {
199                     Logger.log(JFR, WARN, &quot;Recording &quot; + p.getName() + &quot;:&quot; + p.getId() + &quot; could not be stopped&quot;);
200                 }
201             }
202         }
203 
204         JDKEvents.remove();
205 
206         if (jvm.hasNativeJFR()) {
207             if (jvm.isRecording()) {
<span class="line-modified">208                 jvm.endRecording();</span>
209             }
210             jvm.destroyNativeJFR();
211         }
212         repository.clear();
213     }
214 
<span class="line-modified">215     synchronized long start(PlatformRecording recording) {</span>
216         // State can only be NEW or DELAYED because of previous checks
217         Instant now = Instant.now();
218         recording.setStartTime(now);
219         recording.updateTimer();
220         Duration duration = recording.getDuration();
221         if (duration != null) {
222             recording.setStopTime(now.plus(duration));
223         }
224         boolean toDisk = recording.isToDisk();
225         boolean beginPhysical = true;
<span class="line-added">226         long streamInterval = recording.getStreamIntervalMillis();</span>
227         for (PlatformRecording s : getRecordings()) {
228             if (s.getState() == RecordingState.RUNNING) {
229                 beginPhysical = false;
230                 if (s.isToDisk()) {
231                     toDisk = true;
232                 }
<span class="line-added">233                 streamInterval = Math.min(streamInterval, s.getStreamIntervalMillis());</span>
234             }
235         }
<span class="line-added">236         long startNanos = -1;</span>
237         if (beginPhysical) {
238             RepositoryChunk newChunk = null;
239             if (toDisk) {
240                 newChunk = repository.newChunk(now);
241                 MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());
242             } else {
243                 MetadataRepository.getInstance().setOutput(null);
244             }
245             currentChunk = newChunk;
<span class="line-modified">246             jvm.beginRecording();</span>
<span class="line-added">247             startNanos = jvm.getChunkStartNanos();</span>
248             recording.setState(RecordingState.RUNNING);
249             updateSettings();
250             writeMetaEvents();
251         } else {
252             RepositoryChunk newChunk = null;
253             if (toDisk) {
254                 newChunk = repository.newChunk(now);
255                 RequestEngine.doChunkEnd();
256                 MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());
<span class="line-added">257                 startNanos = jvm.getChunkStartNanos();</span>
258             }
259             recording.setState(RecordingState.RUNNING);
260             updateSettings();
261             writeMetaEvents();
262             if (currentChunk != null) {
263                 finishChunk(currentChunk, now, recording);
264             }
265             currentChunk = newChunk;
266         }
<span class="line-modified">267         if (toDisk) {</span>
<span class="line-added">268             RequestEngine.setFlushInterval(streamInterval);</span>
<span class="line-added">269         }</span>
270         RequestEngine.doChunkBegin();
<span class="line-added">271 </span>
<span class="line-added">272         return startNanos;</span>
273     }
274 
275     synchronized void stop(PlatformRecording recording) {
276         RecordingState state = recording.getState();
277 
278         if (Utils.isAfter(state, RecordingState.RUNNING)) {
279             throw new IllegalStateException(&quot;Can&#39;t stop an already stopped recording.&quot;);
280         }
281         if (Utils.isBefore(state, RecordingState.RUNNING)) {
282             throw new IllegalStateException(&quot;Recording must be started before it can be stopped.&quot;);
283         }
284         Instant now = Instant.now();
285         boolean toDisk = false;
286         boolean endPhysical = true;
<span class="line-added">287         long streamInterval = Long.MAX_VALUE;</span>
288         for (PlatformRecording s : getRecordings()) {
289             RecordingState rs = s.getState();
290             if (s != recording &amp;&amp; RecordingState.RUNNING == rs) {
291                 endPhysical = false;
292                 if (s.isToDisk()) {
293                     toDisk = true;
294                 }
<span class="line-added">295                 streamInterval = Math.min(streamInterval, s.getStreamIntervalMillis());</span>
296             }
297         }
298         OldObjectSample.emit(recording);
<span class="line-added">299         recording.setFinalStartnanos(jvm.getChunkStartNanos());</span>
300 
301         if (endPhysical) {
302             RequestEngine.doChunkEnd();
303             if (recording.isToDisk()) {
304                 if (currentChunk != null) {
<span class="line-added">305                     if (inShutdown) {</span>
<span class="line-added">306                         jvm.markChunkFinal();</span>
<span class="line-added">307                     }</span>
308                     MetadataRepository.getInstance().setOutput(null);
309                     finishChunk(currentChunk, now, null);
310                     currentChunk = null;
311                 }
312             } else {
313                 // last memory
314                 dumpMemoryToDestination(recording);
315             }
<span class="line-modified">316             jvm.endRecording();</span>
317             disableEvents();
318         } else {
319             RepositoryChunk newChunk = null;
320             RequestEngine.doChunkEnd();
321             updateSettingsButIgnoreRecording(recording);
322             if (toDisk) {
323                 newChunk = repository.newChunk(now);
324                 MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());
325             } else {
326                 MetadataRepository.getInstance().setOutput(null);
327             }
328             writeMetaEvents();
329             if (currentChunk != null) {
330                 finishChunk(currentChunk, now, null);
331             }
332             currentChunk = newChunk;
333             RequestEngine.doChunkBegin();
334         }
<span class="line-added">335 </span>
<span class="line-added">336         if (toDisk) {</span>
<span class="line-added">337             RequestEngine.setFlushInterval(streamInterval);</span>
<span class="line-added">338         } else {</span>
<span class="line-added">339             RequestEngine.setFlushInterval(Long.MAX_VALUE);</span>
<span class="line-added">340         }</span>
341         recording.setState(RecordingState.STOPPED);
342     }
343 
344     private void dumpMemoryToDestination(PlatformRecording recording)  {
345         WriteableUserPath dest = recording.getDestination();
346         if (dest != null) {
<span class="line-modified">347             MetadataRepository.getInstance().setOutput(dest.getRealPathText());</span>
348             recording.clearDestination();
349         }
350     }
351     private void disableEvents() {
352         MetadataRepository.getInstance().disableEvents();
353     }
354 
355     void updateSettings() {
356         updateSettingsButIgnoreRecording(null);
357     }
358 
359     void updateSettingsButIgnoreRecording(PlatformRecording ignoreMe) {
360         List&lt;PlatformRecording&gt; recordings = getRunningRecordings();
361         List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;(recordings.size());
362         for (PlatformRecording r : recordings) {
363             if (r != ignoreMe) {
364                 list.add(r.getSettings());
365             }
366         }
367         MetadataRepository.getInstance().setSettings(list);
368     }
369 
<span class="line-added">370 </span>
<span class="line-added">371 </span>
372     synchronized void rotateDisk() {
373         Instant now = Instant.now();
374         RepositoryChunk newChunk = repository.newChunk(now);
375         RequestEngine.doChunkEnd();
376         MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());
377         writeMetaEvents();
378         if (currentChunk != null) {
379             finishChunk(currentChunk, now, null);
380         }
381         currentChunk = newChunk;
382         RequestEngine.doChunkBegin();
383     }
384 
385     private List&lt;PlatformRecording&gt; getRunningRecordings() {
386         List&lt;PlatformRecording&gt; runningRecordings = new ArrayList&lt;&gt;();
387         for (PlatformRecording recording : getRecordings()) {
388             if (recording.getState() == RecordingState.RUNNING) {
389                 runningRecordings.add(recording);
390             }
391         }
</pre>
<hr />
<pre>
409             Collections.sort(chunks, RepositoryChunk.END_TIME_COMPARATOR);
410             return chunks;
411         }
412 
413         return Collections.emptyList();
414     }
415 
416     private void startDiskMonitor() {
417         Thread t = SecuritySupport.createThreadWitNoPermissions(&quot;JFR Periodic Tasks&quot;, () -&gt; periodicTask());
418         SecuritySupport.setDaemonThread(t, true);
419         t.start();
420     }
421 
422     private void finishChunk(RepositoryChunk chunk, Instant time, PlatformRecording ignoreMe) {
423         chunk.finish(time);
424         for (PlatformRecording r : getRecordings()) {
425             if (r != ignoreMe &amp;&amp; r.getState() == RecordingState.RUNNING) {
426                 r.appendChunk(chunk);
427             }
428         }
<span class="line-added">429         FilePurger.purge();</span>
430     }
431 
432     private void writeMetaEvents() {

433         if (activeRecordingEvent.isEnabled()) {
<span class="line-added">434             ActiveRecordingEvent event = ActiveRecordingEvent.EVENT.get();</span>
435             for (PlatformRecording r : getRecordings()) {
436                 if (r.getState() == RecordingState.RUNNING &amp;&amp; r.shouldWriteMetadataEvent()) {

437                     event.id = r.getId();
438                     event.name = r.getName();
439                     WriteableUserPath p = r.getDestination();
<span class="line-modified">440                     event.destination = p == null ? null : p.getRealPathText();</span>
441                     Duration d = r.getDuration();
442                     event.recordingDuration = d == null ? Long.MAX_VALUE : d.toMillis();
443                     Duration age = r.getMaxAge();
444                     event.maxAge = age == null ? Long.MAX_VALUE : age.toMillis();
445                     Long size = r.getMaxSize();
446                     event.maxSize = size == null ? Long.MAX_VALUE : size;
447                     Instant start = r.getStartTime();
448                     event.recordingStart = start == null ? Long.MAX_VALUE : start.toEpochMilli();
<span class="line-added">449                     Duration fi = r.getFlushInterval();</span>
<span class="line-added">450                     event.flushInterval = fi == null ? Long.MAX_VALUE : fi.toMillis();</span>
451                     event.commit();
452                 }
453             }
454         }
455         if (activeSettingEvent.isEnabled()) {
456             for (EventControl ec : MetadataRepository.getInstance().getEventControls()) {
457                 ec.writeActiveSettingEvent();
458             }
459         }
460     }
461 
462     private void periodicTask() {
463         if (!jvm.hasNativeJFR()) {
464             return;
465         }
466         while (true) {
467             synchronized (this) {
468                 if (jvm.shouldRotateDisk()) {
469                     rotateDisk();
470                 }
471             }
472             long minDelta = RequestEngine.doPeriodic();
473             long wait = Math.min(minDelta, Options.getWaitInterval());
474             takeNap(wait);
475         }
476     }
477 
478     private void takeNap(long duration) {
479         try {
480             synchronized (JVM.FILE_DELTA_CHANGE) {
481                 JVM.FILE_DELTA_CHANGE.wait(duration &lt; 10 ? 10 : duration);
482             }
483         } catch (InterruptedException e) {
<span class="line-modified">484             // Ignore</span>
485         }
486     }
487 
488     synchronized Recording newCopy(PlatformRecording r, boolean stop) {
489         Recording newRec = new Recording();
490         PlatformRecording copy = PrivateAccess.getInstance().getPlatformRecording(newRec);
491         copy.setSettings(r.getSettings());
492         copy.setMaxAge(r.getMaxAge());
493         copy.setMaxSize(r.getMaxSize());
494         copy.setDumpOnExit(r.getDumpOnExit());
495         copy.setName(&quot;Clone of &quot; + r.getName());
496         copy.setToDisk(r.isToDisk());
497         copy.setInternalDuration(r.getDuration());
498         copy.setStartTime(r.getStartTime());
499         copy.setStopTime(r.getStopTime());
500 
501         if (r.getState() == RecordingState.NEW) {
502             return newRec;
503         }
504         if (r.getState() == RecordingState.DELAYED) {
</pre>
<hr />
<pre>
566 
567         for (RepositoryChunk c : target.getChunks()) {
568             if (startTime == null || c.getStartTime().isBefore(startTime)) {
569                 startTime = c.getStartTime();
570             }
571             if (endTime == null || c.getEndTime().isAfter(endTime)) {
572                 endTime = c.getEndTime();
573             }
574         }
575         Instant now = Instant.now();
576         if (startTime == null) {
577             startTime = now;
578         }
579         if (endTime == null) {
580             endTime = now;
581         }
582         target.setStartTime(startTime);
583         target.setStopTime(endTime);
584         target.setInternalDuration(Duration.between(startTime, endTime));
585     }
<span class="line-added">586 </span>
<span class="line-added">587     public synchronized void migrate(SafePath repo) throws IOException {</span>
<span class="line-added">588         // Must set repository while holding recorder lock so</span>
<span class="line-added">589         // the final chunk in repository gets marked correctly</span>
<span class="line-added">590         Repository.getRepository().setBasePath(repo);</span>
<span class="line-added">591         boolean disk = false;</span>
<span class="line-added">592         for (PlatformRecording s : getRecordings()) {</span>
<span class="line-added">593             if (RecordingState.RUNNING == s.getState() &amp;&amp; s.isToDisk()) {</span>
<span class="line-added">594                 disk = true;</span>
<span class="line-added">595             }</span>
<span class="line-added">596         }</span>
<span class="line-added">597         if (disk) {</span>
<span class="line-added">598             jvm.markChunkFinal();</span>
<span class="line-added">599             rotateDisk();</span>
<span class="line-added">600         }</span>
<span class="line-added">601     }</span>
602 }
</pre>
</td>
</tr>
</table>
<center><a href="PlatformEventType.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PlatformRecording.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="RequestEngine.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SettingsManager.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.io.File;
 29 import java.io.FileNotFoundException;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.RandomAccessFile;
 33 import java.io.Reader;
 34 import java.lang.invoke.MethodHandles;
 35 import java.lang.reflect.Constructor;
 36 import java.lang.reflect.Field;
 37 import java.lang.reflect.Method;
 38 import java.lang.reflect.ReflectPermission;
 39 import java.nio.channels.FileChannel;
 40 import java.nio.channels.ReadableByteChannel;

 41 import java.nio.file.FileVisitResult;
 42 import java.nio.file.Files;
 43 import java.nio.file.Path;
 44 import java.nio.file.Paths;
 45 import java.nio.file.SimpleFileVisitor;
 46 import java.nio.file.StandardOpenOption;
 47 import java.nio.file.attribute.BasicFileAttributes;
 48 import java.security.AccessControlContext;
 49 import java.security.AccessController;
 50 import java.security.Permission;
 51 import java.security.PrivilegedAction;
 52 import java.security.PrivilegedActionException;
 53 import java.security.PrivilegedExceptionAction;
 54 import java.util.ArrayList;
 55 import java.util.Iterator;
 56 import java.util.List;
 57 import java.util.Objects;
 58 import java.util.PropertyPermission;
 59 import java.util.concurrent.Callable;
 60 
 61 import jdk.internal.misc.Unsafe;
 62 import jdk.internal.module.Modules;
 63 import jdk.jfr.Event;
 64 import jdk.jfr.FlightRecorder;
 65 import jdk.jfr.FlightRecorderListener;
 66 import jdk.jfr.FlightRecorderPermission;
 67 import jdk.jfr.Recording;

 68 
 69 /**
 70  * Contains JFR code that does
 71  * {@link AccessController#doPrivileged(PrivilegedAction)}
 72  */
 73 public final class SecuritySupport {
 74     private final static Unsafe unsafe = Unsafe.getUnsafe();
 75     private final static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
 76     private final static Module JFR_MODULE = Event.class.getModule();
 77     public  final static SafePath JFC_DIRECTORY = getPathInProperty(&quot;java.home&quot;, &quot;lib/jfr&quot;);
<span class="line-modified"> 78 </span>
 79     static final SafePath USER_HOME = getPathInProperty(&quot;user.home&quot;, null);
 80     static final SafePath JAVA_IO_TMPDIR = getPathInProperty(&quot;java.io.tmpdir&quot;, null);
 81 
 82     static {
 83         // ensure module java.base can read module jdk.jfr as early as possible
 84         addReadEdge(Object.class);
 85         addHandlerExport(Object.class);
 86         addEventsExport(Object.class);
 87         addInstrumentExport(Object.class);
 88     }
 89 
 90     final static class SecureRecorderListener implements FlightRecorderListener {
 91 
 92         private final AccessControlContext context;
 93         private final FlightRecorderListener changeListener;
 94 
 95         SecureRecorderListener(AccessControlContext context, FlightRecorderListener changeListener) {
 96             this.context = Objects.requireNonNull(context);
 97             this.changeListener = Objects.requireNonNull(changeListener);
 98         }
</pre>
<hr />
<pre>
133         public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {
134             Files.delete(path);
135             return FileVisitResult.CONTINUE;
136         }
137 
138         @Override
139         public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
140             if (exc != null) {
141                 throw exc;
142             }
143             Files.delete(dir);
144             return FileVisitResult.CONTINUE;
145         }
146     }
147 
148     /**
149      * Path created by the default file provider,and not
150      * a malicious provider.
151      *
152      */
<span class="line-modified">153     public static final class SafePath {</span>
154         private final Path path;
155         private final String text;
156 
157         public SafePath(Path p) {
158             // sanitize
159             text = p.toString();
160             path = Paths.get(text);
161         }
162 
163         public SafePath(String path) {
164             this(Paths.get(path));
165         }
166 
167         public Path toPath() {
168             return path;
169         }
170 




171         public String toString() {
172             return text;
173         }


















174     }
175 
176     private interface RunnableWithCheckedException {
177         public void run() throws Exception;
178     }
179 
180     private interface CallableWithoutCheckException&lt;T&gt; {
181         public T call();
182     }
183 
184     private static &lt;U&gt; U doPrivilegedIOWithReturn(Callable&lt;U&gt; function) throws IOException {
185         try {
186             return AccessController.doPrivileged(new PrivilegedExceptionAction&lt;U&gt;() {
187                 @Override
188                 public U run() throws Exception {
189                     return function.call();
190                 }
191             }, null);
192         } catch (PrivilegedActionException e) {
193             Throwable t = e.getCause();
</pre>
<hr />
<pre>
273     static void addEventsExport(Class&lt;?&gt; clazz) {
274         Modules.addExports(JFR_MODULE, Utils.EVENTS_PACKAGE_NAME, clazz.getModule());
275     }
276 
277     static void addInstrumentExport(Class&lt;?&gt; clazz) {
278         Modules.addExports(JFR_MODULE, Utils.INSTRUMENT_PACKAGE_NAME, clazz.getModule());
279     }
280 
281     static void addReadEdge(Class&lt;?&gt; clazz) {
282         Modules.addReads(clazz.getModule(), JFR_MODULE);
283     }
284 
285     public static void registerEvent(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
286         doPrivileged(() -&gt;  MetadataRepository.getInstance().register(eventClass), new FlightRecorderPermission(Utils.REGISTER_EVENT));
287     }
288 
289     public static void registerMirror(Class&lt;? extends Event&gt; eventClass) {
290         doPrivileged(() -&gt;  MetadataRepository.getInstance().registerMirror(eventClass), new FlightRecorderPermission(Utils.REGISTER_EVENT));
291     }
292 




293     static boolean getBooleanProperty(String propertyName) {
294         return doPrivilegedWithReturn(() -&gt; Boolean.getBoolean(propertyName), new PropertyPermission(propertyName, &quot;read&quot;));
295     }
296 
297     private static SafePath getPathInProperty(String prop, String subPath) {
298         return doPrivilegedWithReturn(() -&gt; {
299             String path = System.getProperty(prop);
300             if (path == null) {
301                 return null;
302             }
303             File file = subPath == null ? new File(path) : new File(path, subPath);
304             return new SafePath(file.getAbsolutePath());
305         }, new PropertyPermission(&quot;*&quot;, &quot;read&quot;));
306     }
307 
308     // Called by JVM during initialization of JFR
309     static Thread createRecorderThread(ThreadGroup systemThreadGroup, ClassLoader contextClassLoader) {
310         // The thread should have permission = new Permission[0], and not &quot;modifyThreadGroup&quot; and &quot;modifyThread&quot; on the stack,
311         // but it&#39;s hard circumvent if we are going to pass in system thread group in the constructor
312         Thread thread = doPrivilegedWithReturn(() -&gt; new Thread(systemThreadGroup, &quot;JFR Recorder Thread&quot;), new RuntimePermission(&quot;modifyThreadGroup&quot;), new RuntimePermission(&quot;modifyThread&quot;));
313         doPrivileged(() -&gt; thread.setContextClassLoader(contextClassLoader), new RuntimePermission(&quot;setContextClassLoader&quot;), new RuntimePermission(&quot;modifyThread&quot;));
314         return thread;
315     }
316 
317     static void registerShutdownHook(Thread shutdownHook) {
318         doPrivileged(() -&gt; Runtime.getRuntime().addShutdownHook(shutdownHook), new RuntimePermission(&quot;shutdownHooks&quot;));
319     }
320 
321     static void setUncaughtExceptionHandler(Thread thread, Thread.UncaughtExceptionHandler eh) {
322         doPrivileged(() -&gt; thread.setUncaughtExceptionHandler(eh), new RuntimePermission(&quot;modifyThread&quot;));
323     }
324 
325     static void moveReplace(SafePath from, SafePath to) throws IOException {
326         doPrivilegedIOWithReturn(() -&gt; Files.move(from.toPath(), to.toPath()));
327     }
328 
329     static void clearDirectory(SafePath safePath) throws IOException {
330         doPriviligedIO(() -&gt; Files.walkFileTree(safePath.toPath(), new DirectoryCleaner()));
331     }
332 
<span class="line-modified">333     static SafePath toRealPath(SafePath safePath) throws Exception {</span>
334         return new SafePath(doPrivilegedIOWithReturn(() -&gt; safePath.toPath().toRealPath()));
335     }
336 
337     static boolean existDirectory(SafePath directory) throws IOException {
338         return doPrivilegedIOWithReturn(() -&gt; Files.exists(directory.toPath()));
339     }
340 
341     static RandomAccessFile createRandomAccessFile(SafePath path) throws Exception {
342         return doPrivilegedIOWithReturn(() -&gt; new RandomAccessFile(path.toPath().toFile(), &quot;rw&quot;));
343     }
344 
345     public static InputStream newFileInputStream(SafePath safePath) throws IOException {
346         return doPrivilegedIOWithReturn(() -&gt; Files.newInputStream(safePath.toPath()));
347     }
348 
349     public static long getFileSize(SafePath safePath) throws IOException {
350         return doPrivilegedIOWithReturn(() -&gt; Files.size(safePath.toPath()));
351     }
352 
353     static SafePath createDirectories(SafePath safePath) throws IOException {
354         Path p = doPrivilegedIOWithReturn(() -&gt; Files.createDirectories(safePath.toPath()));
355         return new SafePath(p);
356     }
357 
358     public static boolean exists(SafePath safePath) throws IOException {
<span class="line-modified">359         return doPrivilegedIOWithReturn(() -&gt; Files.exists(safePath.toPath()));</span>

360     }
361 
362     public static boolean isDirectory(SafePath safePath) throws IOException {
363         return doPrivilegedIOWithReturn(() -&gt; Files.isDirectory(safePath.toPath()));
364     }
365 
366     static void delete(SafePath localPath) throws IOException {
367         doPriviligedIO(() -&gt; Files.delete(localPath.toPath()));
368     }
369 
370     static boolean isWritable(SafePath safePath) throws IOException {
371         return doPrivilegedIOWithReturn(() -&gt; Files.isWritable(safePath.toPath()));
372     }
373 
374     static void deleteOnExit(SafePath safePath) {
375         doPrivileged(() -&gt; safePath.toPath().toFile().deleteOnExit());
376     }
377 
378     static ReadableByteChannel newFileChannelToRead(SafePath safePath) throws IOException {
379         return doPrivilegedIOWithReturn(() -&gt; FileChannel.open(safePath.toPath(), StandardOpenOption.READ));
</pre>
<hr />
<pre>
391         doPriviligedIO(() -&gt; new RandomAccessFile(path.toPath().toFile(), &quot;rw&quot;).close());
392     }
393 
394     static void setAccessible(Method method) {
395         doPrivileged(() -&gt; method.setAccessible(true), new ReflectPermission(&quot;suppressAccessChecks&quot;));
396     }
397 
398     static void setAccessible(Field field) {
399         doPrivileged(() -&gt; field.setAccessible(true), new ReflectPermission(&quot;suppressAccessChecks&quot;));
400     }
401 
402     static void setAccessible(Constructor&lt;?&gt; constructor) {
403         doPrivileged(() -&gt; constructor.setAccessible(true), new ReflectPermission(&quot;suppressAccessChecks&quot;));
404     }
405 
406     static void ensureClassIsInitialized(Class&lt;?&gt; clazz) {
407         unsafe.ensureClassInitialized(clazz);
408     }
409 
410     static Class&lt;?&gt; defineClass(Class&lt;?&gt; lookupClass, byte[] bytes) {
<span class="line-modified">411         return AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {</span>
412             @Override
413             public Class&lt;?&gt; run() {
414                 try {
415                     return MethodHandles.privateLookupIn(lookupClass, LOOKUP).defineClass(bytes);
416                 } catch (IllegalAccessException e) {
417                     throw new InternalError(e);
418                 }
419             }
420         });
421     }
422 
<span class="line-modified">423     static Thread createThreadWitNoPermissions(String threadName, Runnable runnable) {</span>
424         return doPrivilegedWithReturn(() -&gt; new Thread(runnable, threadName), new Permission[0]);
425     }
426 
427     static void setDaemonThread(Thread t, boolean daeomn) {
428       doPrivileged(()-&gt; t.setDaemon(daeomn), new RuntimePermission(&quot;modifyThread&quot;));
429     }
430 
431     public static SafePath getAbsolutePath(SafePath path) throws IOException {
432         return new SafePath(doPrivilegedIOWithReturn((()-&gt; path.toPath().toAbsolutePath())));
433     }




























434 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.io.File;
 29 import java.io.FileNotFoundException;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.RandomAccessFile;
 33 import java.io.Reader;
 34 import java.lang.invoke.MethodHandles;
 35 import java.lang.reflect.Constructor;
 36 import java.lang.reflect.Field;
 37 import java.lang.reflect.Method;
 38 import java.lang.reflect.ReflectPermission;
 39 import java.nio.channels.FileChannel;
 40 import java.nio.channels.ReadableByteChannel;
<span class="line-added"> 41 import java.nio.file.DirectoryStream;</span>
 42 import java.nio.file.FileVisitResult;
 43 import java.nio.file.Files;
 44 import java.nio.file.Path;
 45 import java.nio.file.Paths;
 46 import java.nio.file.SimpleFileVisitor;
 47 import java.nio.file.StandardOpenOption;
 48 import java.nio.file.attribute.BasicFileAttributes;
 49 import java.security.AccessControlContext;
 50 import java.security.AccessController;
 51 import java.security.Permission;
 52 import java.security.PrivilegedAction;
 53 import java.security.PrivilegedActionException;
 54 import java.security.PrivilegedExceptionAction;
 55 import java.util.ArrayList;
 56 import java.util.Iterator;
 57 import java.util.List;
 58 import java.util.Objects;
 59 import java.util.PropertyPermission;
 60 import java.util.concurrent.Callable;
 61 
 62 import jdk.internal.misc.Unsafe;
 63 import jdk.internal.module.Modules;
 64 import jdk.jfr.Event;
 65 import jdk.jfr.FlightRecorder;
 66 import jdk.jfr.FlightRecorderListener;
 67 import jdk.jfr.FlightRecorderPermission;
 68 import jdk.jfr.Recording;
<span class="line-added"> 69 import jdk.jfr.internal.consumer.FileAccess;</span>
 70 
 71 /**
 72  * Contains JFR code that does
 73  * {@link AccessController#doPrivileged(PrivilegedAction)}
 74  */
 75 public final class SecuritySupport {
 76     private final static Unsafe unsafe = Unsafe.getUnsafe();
 77     private final static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
 78     private final static Module JFR_MODULE = Event.class.getModule();
 79     public  final static SafePath JFC_DIRECTORY = getPathInProperty(&quot;java.home&quot;, &quot;lib/jfr&quot;);
<span class="line-modified"> 80     public final static FileAccess PRIVILIGED = new Privileged();</span>
 81     static final SafePath USER_HOME = getPathInProperty(&quot;user.home&quot;, null);
 82     static final SafePath JAVA_IO_TMPDIR = getPathInProperty(&quot;java.io.tmpdir&quot;, null);
 83 
 84     static {
 85         // ensure module java.base can read module jdk.jfr as early as possible
 86         addReadEdge(Object.class);
 87         addHandlerExport(Object.class);
 88         addEventsExport(Object.class);
 89         addInstrumentExport(Object.class);
 90     }
 91 
 92     final static class SecureRecorderListener implements FlightRecorderListener {
 93 
 94         private final AccessControlContext context;
 95         private final FlightRecorderListener changeListener;
 96 
 97         SecureRecorderListener(AccessControlContext context, FlightRecorderListener changeListener) {
 98             this.context = Objects.requireNonNull(context);
 99             this.changeListener = Objects.requireNonNull(changeListener);
100         }
</pre>
<hr />
<pre>
135         public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {
136             Files.delete(path);
137             return FileVisitResult.CONTINUE;
138         }
139 
140         @Override
141         public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
142             if (exc != null) {
143                 throw exc;
144             }
145             Files.delete(dir);
146             return FileVisitResult.CONTINUE;
147         }
148     }
149 
150     /**
151      * Path created by the default file provider,and not
152      * a malicious provider.
153      *
154      */
<span class="line-modified">155     public static final class SafePath implements Comparable&lt;SafePath&gt; {</span>
156         private final Path path;
157         private final String text;
158 
159         public SafePath(Path p) {
160             // sanitize
161             text = p.toString();
162             path = Paths.get(text);
163         }
164 
165         public SafePath(String path) {
166             this(Paths.get(path));
167         }
168 
169         public Path toPath() {
170             return path;
171         }
172 
<span class="line-added">173         public File toFile() {</span>
<span class="line-added">174             return path.toFile();</span>
<span class="line-added">175         }</span>
<span class="line-added">176 </span>
177         public String toString() {
178             return text;
179         }
<span class="line-added">180 </span>
<span class="line-added">181         @Override</span>
<span class="line-added">182         public int compareTo(SafePath that) {</span>
<span class="line-added">183             return that.text.compareTo(this.text);</span>
<span class="line-added">184         }</span>
<span class="line-added">185 </span>
<span class="line-added">186         @Override</span>
<span class="line-added">187         public boolean equals(Object other) {</span>
<span class="line-added">188             if(other != null &amp;&amp; other instanceof SafePath){</span>
<span class="line-added">189                 return this.toPath().equals(((SafePath) other).toPath());</span>
<span class="line-added">190             }</span>
<span class="line-added">191             return false;</span>
<span class="line-added">192         }</span>
<span class="line-added">193 </span>
<span class="line-added">194         @Override</span>
<span class="line-added">195         public int hashCode() {</span>
<span class="line-added">196             return this.toPath().hashCode();</span>
<span class="line-added">197         }</span>
198     }
199 
200     private interface RunnableWithCheckedException {
201         public void run() throws Exception;
202     }
203 
204     private interface CallableWithoutCheckException&lt;T&gt; {
205         public T call();
206     }
207 
208     private static &lt;U&gt; U doPrivilegedIOWithReturn(Callable&lt;U&gt; function) throws IOException {
209         try {
210             return AccessController.doPrivileged(new PrivilegedExceptionAction&lt;U&gt;() {
211                 @Override
212                 public U run() throws Exception {
213                     return function.call();
214                 }
215             }, null);
216         } catch (PrivilegedActionException e) {
217             Throwable t = e.getCause();
</pre>
<hr />
<pre>
297     static void addEventsExport(Class&lt;?&gt; clazz) {
298         Modules.addExports(JFR_MODULE, Utils.EVENTS_PACKAGE_NAME, clazz.getModule());
299     }
300 
301     static void addInstrumentExport(Class&lt;?&gt; clazz) {
302         Modules.addExports(JFR_MODULE, Utils.INSTRUMENT_PACKAGE_NAME, clazz.getModule());
303     }
304 
305     static void addReadEdge(Class&lt;?&gt; clazz) {
306         Modules.addReads(clazz.getModule(), JFR_MODULE);
307     }
308 
309     public static void registerEvent(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
310         doPrivileged(() -&gt;  MetadataRepository.getInstance().register(eventClass), new FlightRecorderPermission(Utils.REGISTER_EVENT));
311     }
312 
313     public static void registerMirror(Class&lt;? extends Event&gt; eventClass) {
314         doPrivileged(() -&gt;  MetadataRepository.getInstance().registerMirror(eventClass), new FlightRecorderPermission(Utils.REGISTER_EVENT));
315     }
316 
<span class="line-added">317     public static void setProperty(String propertyName, String value) {</span>
<span class="line-added">318         doPrivileged(() -&gt; System.setProperty(propertyName, value), new PropertyPermission(propertyName, &quot;write&quot;));</span>
<span class="line-added">319     }</span>
<span class="line-added">320 </span>
321     static boolean getBooleanProperty(String propertyName) {
322         return doPrivilegedWithReturn(() -&gt; Boolean.getBoolean(propertyName), new PropertyPermission(propertyName, &quot;read&quot;));
323     }
324 
325     private static SafePath getPathInProperty(String prop, String subPath) {
326         return doPrivilegedWithReturn(() -&gt; {
327             String path = System.getProperty(prop);
328             if (path == null) {
329                 return null;
330             }
331             File file = subPath == null ? new File(path) : new File(path, subPath);
332             return new SafePath(file.getAbsolutePath());
333         }, new PropertyPermission(&quot;*&quot;, &quot;read&quot;));
334     }
335 
336     // Called by JVM during initialization of JFR
337     static Thread createRecorderThread(ThreadGroup systemThreadGroup, ClassLoader contextClassLoader) {
338         // The thread should have permission = new Permission[0], and not &quot;modifyThreadGroup&quot; and &quot;modifyThread&quot; on the stack,
339         // but it&#39;s hard circumvent if we are going to pass in system thread group in the constructor
340         Thread thread = doPrivilegedWithReturn(() -&gt; new Thread(systemThreadGroup, &quot;JFR Recorder Thread&quot;), new RuntimePermission(&quot;modifyThreadGroup&quot;), new RuntimePermission(&quot;modifyThread&quot;));
341         doPrivileged(() -&gt; thread.setContextClassLoader(contextClassLoader), new RuntimePermission(&quot;setContextClassLoader&quot;), new RuntimePermission(&quot;modifyThread&quot;));
342         return thread;
343     }
344 
345     static void registerShutdownHook(Thread shutdownHook) {
346         doPrivileged(() -&gt; Runtime.getRuntime().addShutdownHook(shutdownHook), new RuntimePermission(&quot;shutdownHooks&quot;));
347     }
348 
349     static void setUncaughtExceptionHandler(Thread thread, Thread.UncaughtExceptionHandler eh) {
350         doPrivileged(() -&gt; thread.setUncaughtExceptionHandler(eh), new RuntimePermission(&quot;modifyThread&quot;));
351     }
352 
353     static void moveReplace(SafePath from, SafePath to) throws IOException {
354         doPrivilegedIOWithReturn(() -&gt; Files.move(from.toPath(), to.toPath()));
355     }
356 
357     static void clearDirectory(SafePath safePath) throws IOException {
358         doPriviligedIO(() -&gt; Files.walkFileTree(safePath.toPath(), new DirectoryCleaner()));
359     }
360 
<span class="line-modified">361     static SafePath toRealPath(SafePath safePath) throws IOException {</span>
362         return new SafePath(doPrivilegedIOWithReturn(() -&gt; safePath.toPath().toRealPath()));
363     }
364 
365     static boolean existDirectory(SafePath directory) throws IOException {
366         return doPrivilegedIOWithReturn(() -&gt; Files.exists(directory.toPath()));
367     }
368 
369     static RandomAccessFile createRandomAccessFile(SafePath path) throws Exception {
370         return doPrivilegedIOWithReturn(() -&gt; new RandomAccessFile(path.toPath().toFile(), &quot;rw&quot;));
371     }
372 
373     public static InputStream newFileInputStream(SafePath safePath) throws IOException {
374         return doPrivilegedIOWithReturn(() -&gt; Files.newInputStream(safePath.toPath()));
375     }
376 
377     public static long getFileSize(SafePath safePath) throws IOException {
378         return doPrivilegedIOWithReturn(() -&gt; Files.size(safePath.toPath()));
379     }
380 
381     static SafePath createDirectories(SafePath safePath) throws IOException {
382         Path p = doPrivilegedIOWithReturn(() -&gt; Files.createDirectories(safePath.toPath()));
383         return new SafePath(p);
384     }
385 
386     public static boolean exists(SafePath safePath) throws IOException {
<span class="line-modified">387         // Files.exist(path) is allocation intensive</span>
<span class="line-added">388         return doPrivilegedIOWithReturn(() -&gt; safePath.toPath().toFile().exists());</span>
389     }
390 
391     public static boolean isDirectory(SafePath safePath) throws IOException {
392         return doPrivilegedIOWithReturn(() -&gt; Files.isDirectory(safePath.toPath()));
393     }
394 
395     static void delete(SafePath localPath) throws IOException {
396         doPriviligedIO(() -&gt; Files.delete(localPath.toPath()));
397     }
398 
399     static boolean isWritable(SafePath safePath) throws IOException {
400         return doPrivilegedIOWithReturn(() -&gt; Files.isWritable(safePath.toPath()));
401     }
402 
403     static void deleteOnExit(SafePath safePath) {
404         doPrivileged(() -&gt; safePath.toPath().toFile().deleteOnExit());
405     }
406 
407     static ReadableByteChannel newFileChannelToRead(SafePath safePath) throws IOException {
408         return doPrivilegedIOWithReturn(() -&gt; FileChannel.open(safePath.toPath(), StandardOpenOption.READ));
</pre>
<hr />
<pre>
420         doPriviligedIO(() -&gt; new RandomAccessFile(path.toPath().toFile(), &quot;rw&quot;).close());
421     }
422 
423     static void setAccessible(Method method) {
424         doPrivileged(() -&gt; method.setAccessible(true), new ReflectPermission(&quot;suppressAccessChecks&quot;));
425     }
426 
427     static void setAccessible(Field field) {
428         doPrivileged(() -&gt; field.setAccessible(true), new ReflectPermission(&quot;suppressAccessChecks&quot;));
429     }
430 
431     static void setAccessible(Constructor&lt;?&gt; constructor) {
432         doPrivileged(() -&gt; constructor.setAccessible(true), new ReflectPermission(&quot;suppressAccessChecks&quot;));
433     }
434 
435     static void ensureClassIsInitialized(Class&lt;?&gt; clazz) {
436         unsafe.ensureClassInitialized(clazz);
437     }
438 
439     static Class&lt;?&gt; defineClass(Class&lt;?&gt; lookupClass, byte[] bytes) {
<span class="line-modified">440         return AccessController.doPrivileged(new PrivilegedAction&lt;Class&lt;?&gt;&gt;() {</span>
441             @Override
442             public Class&lt;?&gt; run() {
443                 try {
444                     return MethodHandles.privateLookupIn(lookupClass, LOOKUP).defineClass(bytes);
445                 } catch (IllegalAccessException e) {
446                     throw new InternalError(e);
447                 }
448             }
449         });
450     }
451 
<span class="line-modified">452     public static Thread createThreadWitNoPermissions(String threadName, Runnable runnable) {</span>
453         return doPrivilegedWithReturn(() -&gt; new Thread(runnable, threadName), new Permission[0]);
454     }
455 
456     static void setDaemonThread(Thread t, boolean daeomn) {
457       doPrivileged(()-&gt; t.setDaemon(daeomn), new RuntimePermission(&quot;modifyThread&quot;));
458     }
459 
460     public static SafePath getAbsolutePath(SafePath path) throws IOException {
461         return new SafePath(doPrivilegedIOWithReturn((()-&gt; path.toPath().toAbsolutePath())));
462     }
<span class="line-added">463 </span>
<span class="line-added">464     private final static class Privileged extends FileAccess {</span>
<span class="line-added">465         @Override</span>
<span class="line-added">466         public RandomAccessFile openRAF(File f, String mode) throws IOException {</span>
<span class="line-added">467             return doPrivilegedIOWithReturn( () -&gt; new RandomAccessFile(f, mode));</span>
<span class="line-added">468         }</span>
<span class="line-added">469 </span>
<span class="line-added">470         @Override</span>
<span class="line-added">471         public  DirectoryStream&lt;Path&gt; newDirectoryStream(Path directory)  throws IOException  {</span>
<span class="line-added">472             return doPrivilegedIOWithReturn( () -&gt; Files.newDirectoryStream(directory));</span>
<span class="line-added">473         }</span>
<span class="line-added">474 </span>
<span class="line-added">475         @Override</span>
<span class="line-added">476         public  String getAbsolutePath(File f) throws IOException {</span>
<span class="line-added">477             return doPrivilegedIOWithReturn( () -&gt; f.getAbsolutePath());</span>
<span class="line-added">478         }</span>
<span class="line-added">479         @Override</span>
<span class="line-added">480         public long length(File f) throws IOException {</span>
<span class="line-added">481             return doPrivilegedIOWithReturn( () -&gt; f.length());</span>
<span class="line-added">482         }</span>
<span class="line-added">483 </span>
<span class="line-added">484         @Override</span>
<span class="line-added">485         public  long fileSize(Path p) throws IOException {</span>
<span class="line-added">486             return doPrivilegedIOWithReturn( () -&gt; Files.size(p));</span>
<span class="line-added">487         }</span>
<span class="line-added">488     }</span>
<span class="line-added">489 </span>
<span class="line-added">490 </span>
491 }
</pre>
</td>
</tr>
</table>
<center><a href="RequestEngine.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SettingsManager.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/JVM.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="EventWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LogTag.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/JVM.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.io.IOException;
 29 import java.util.List;
 30 
 31 import jdk.internal.HotSpotIntrinsicCandidate;
 32 import jdk.jfr.Event;

 33 
 34 /**
 35  * Interface against the JVM.
 36  *
 37  */
 38 public final class JVM {
 39     private static final JVM jvm = new JVM();
 40 
 41     // JVM signals file changes by doing Object#notifu on this object
 42     static final Object FILE_DELTA_CHANGE = new Object();
 43 
 44     static final long RESERVED_CLASS_ID_LIMIT = 400;
 45 
<span class="line-removed"> 46     private volatile boolean recording;</span>
 47     private volatile boolean nativeOK;
 48 
 49     private static native void registerNatives();
 50 
 51     static {
 52         registerNatives();
 53         for (LogTag tag : LogTag.values()) {
 54             subscribeLogLevel(tag, tag.id);
 55         }
 56         Options.ensureInitialized();
 57     }
 58 
 59     /**
 60      * Get the one and only JVM.
 61      *
 62      * @return the JVM
 63      */
 64     public static JVM getJVM() {
 65         return jvm;
 66     }
 67 
 68     private JVM() {
 69     }
 70 









 71     /**
 72      * Begin recording events
 73      *
 74      * Requires that JFR has been started with {@link #createNativeJFR()}
 75      */
 76     public native void beginRecording();
 77 













 78     /**
 79      * Return ticks
 80      *
 81      * @return the time, in ticks
 82      *
 83      */
 84     @HotSpotIntrinsicCandidate
 85     public static native long counterTime();
 86 
 87 
 88     /**
 89      * Emits native periodic event.
 90      *
 91      * @param eventTypeId type id
 92      *
 93      * @param timestamp commit time for event
 94      * @param when when it is being done {@link Periodic.When}
 95      *
 96      * @return true if the event was committed
 97      */
 98     public native boolean emitEvent(long eventTypeId, long timestamp, long when);
 99 
<span class="line-modified">100     /**</span>
<span class="line-removed">101      * End recording events, which includes flushing data in thread buffers</span>
<span class="line-removed">102      *</span>
<span class="line-removed">103      * Requires that JFR has been started with {@link #createNativeJFR()}</span>
<span class="line-removed">104      *</span>
<span class="line-removed">105      */</span>
<span class="line-removed">106     public native void endRecording();</span>
107 
108     /**
109      * Return a list of all classes deriving from {@link jdk.internal.event.Event}
110      *
111      * @return list of event classes.
112      */
113     public native List&lt;Class&lt;? extends jdk.internal.event.Event&gt;&gt; getAllEventClasses();
114 
115     /**
116      * Return a count of the number of unloaded classes deriving from {@link Event}
117      *
118      * @return number of unloaded event classes.
119      */
120     public native long getUnloadedEventClassCount();
121 
122     /**
123      * Return a unique identifier for a class. The class is marked as being
124      * &quot;in use&quot; in JFR.
125      *
126      * @param clazz clazz
</pre>
<hr />
<pre>
171      *
172      * @param tagSetId the tagset id
173      * @param level on level
174      * @param message log message
175      *
176      */
177     public static native void log(int tagSetId, int level, String message);
178 
179     /**
180      * Subscribe to LogLevel updates for LogTag
181      *
182      * @param lt the log tag to subscribe
183      * @param tagSetId the tagset id
184      */
185     public static native void subscribeLogLevel(LogTag lt, int tagSetId);
186 
187     /**
188      * Call to invoke event tagging and retransformation of the passed classes
189      *
190      * @param classes


191      */
192     public native synchronized void retransformClasses(Class&lt;?&gt;[] classes);
193 
194     /**
195      * Enable event
196      *
197      * @param eventTypeId event type id
198      *
199      * @param enabled enable event
200      */
201     public native void setEnabled(long eventTypeId, boolean enabled);
202 
203     /**
204      * Interval at which the JVM should notify on {@link #FILE_DELTA_CHANGE}
205      *
206      * @param delta number of bytes, reset after file rotation
207      */
208     public native void setFileNotification(long delta);
209 
210     /**
</pre>
<hr />
<pre>
253      *
254      * Requires that JFR has been started with {@link #createNativeJFR()}
255      *
256      * &lt;pre&gt;
257      * Recording  Previous  Current  Action
258      * ==============================================
259      *    true     null      null     Ignore, keep recording in-memory
260      *    true     null      file1    Start disk recording
261      *    true     file      null     Copy out metadata to disk and continue in-memory recording
262      *    true     file1     file2    Copy out metadata and start with new File (file2)
263      *    false     *        null     Ignore, but start recording to memory with {@link #beginRecording()}
264      *    false     *        file     Ignore, but start recording to disk with {@link #beginRecording()}
265      *
266      * &lt;/pre&gt;
267      *
268      * recording can be set to true/false with {@link #beginRecording()}
269      * {@link #endRecording()}
270      *
271      * @param file the file where data should be written, or null if it should
272      *        not be copied out (in memory).
<span class="line-removed">273      *</span>
274      * @throws IOException
275      */
276     public native void setOutput(String file);
277 
278     /**
279      * Controls if a class deriving from jdk.jfr.Event should
280      * always be instrumented on class load.
281      *
282      * @param force, true to force initialization, false otherwise
283      */
284     public native void setForceInstrumentation(boolean force);
285 
286     /**
287      * Turn on/off thread sampling.
288      *
289      * @param sampleThreads true if threads should be sampled, false otherwise.
290      *
291      * @throws IllegalStateException if state can&#39;t be changed.
292      */
293     public native void setSampleThreads(boolean sampleThreads) throws IllegalStateException;
</pre>
<hr />
<pre>
338      *
339      * @param eventTypeId the id of the event type
340      * @param ticks threshold in ticks,
341      * @return true, if it could be set
342      */
343     public native boolean setThreshold(long eventTypeId, long ticks);
344 
345     /**
346      * Store the metadata descriptor that is to be written at the end of a
347      * chunk, data should be written after GMT offset and size of metadata event
348      * should be adjusted
349      *
350      * Requires that JFR has been started with {@link #createNativeJFR()}
351      *
352      * @param bytes binary representation of metadata descriptor
353      *
354      * @param binary representation of descriptor
355      */
356     public native void storeMetadataDescriptor(byte[] bytes);
357 
<span class="line-removed">358     public void endRecording_() {</span>
<span class="line-removed">359         endRecording();</span>
<span class="line-removed">360         recording = false;</span>
<span class="line-removed">361     }</span>
<span class="line-removed">362 </span>
<span class="line-removed">363     public void beginRecording_() {</span>
<span class="line-removed">364         beginRecording();</span>
<span class="line-removed">365         recording = true;</span>
<span class="line-removed">366     }</span>
<span class="line-removed">367 </span>
<span class="line-removed">368     public boolean isRecording() {</span>
<span class="line-removed">369         return recording;</span>
<span class="line-removed">370     }</span>
<span class="line-removed">371 </span>
372     /**
373      * If the JVM supports JVM TI and retransformation has not been disabled this
374      * method will return true. This flag can not change during the lifetime of
375      * the JVM.
376      *
377      * @return if transform is allowed
378      */
379     public native boolean getAllowedToDoEventRetransforms();
380 
381     /**
382      * Set up native resources, data structures, threads etc. for JFR
383      *
384      * @param simulateFailure simulate a initialization failure and rollback in
385      *        native, used for testing purposes
386      *
387      * @throws IllegalStateException if native part of JFR could not be created.
388      *
389      */
390     private native boolean createJFR(boolean simulateFailure) throws IllegalStateException;
391 
</pre>
<hr />
<pre>
442     /**
443      * Fast path fetching the EventWriter using VM intrinsics
444      *
445      * @return thread local EventWriter
446      */
447     @HotSpotIntrinsicCandidate
448     public static native Object getEventWriter();
449 
450     /**
451      * Create a new EventWriter
452      *
453      * @return thread local EventWriter
454      */
455     public static native EventWriter newEventWriter();
456 
457     /**
458      * Flushes the EventWriter for this thread.
459      */
460     public static native boolean flush(EventWriter writer, int uncommittedSize, int requestedSize);
461 










462     /**
463      * Sets the location of the disk repository, to be used at an emergency
464      * dump.
465      *
466      * @param dirText
467      */
468     public native void setRepositoryLocation(String dirText);
469 
470     /**
471     * Access to VM termination support.
472     *
473     *@param errorMsg descriptive message to be include in VM termination sequence
474     */
475     public native void abort(String errorMsg);
476 
477     /**
478      * Adds a string to the string constant pool.
479      *
480      * If the same string is added twice, two entries will be created.
481      *
</pre>
<hr />
<pre>
506      * @param eventTypeId the id of the event type
507      * @param cutoffTicks cutoff in ticks,
508      * @return true, if it could be set
509      */
510     public native boolean setCutoff(long eventTypeId, long cutoffTicks);
511 
512     /**
513      * Emit old object sample events.
514      *
515      * @param cutoff the cutoff in ticks
516      * @param emitAll emit all samples in old object queue
517      */
518     public native void emitOldObjectSamples(long cutoff, boolean emitAll);
519 
520     /**
521      * Test if a chunk rotation is warranted.
522      *
523      * @return if it is time to perform a chunk rotation
524      */
525     public native boolean shouldRotateDisk();















































526 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.io.IOException;
 29 import java.util.List;
 30 
 31 import jdk.internal.HotSpotIntrinsicCandidate;
 32 import jdk.jfr.Event;
<span class="line-added"> 33 import jdk.jfr.internal.handlers.EventHandler;</span>
 34 
 35 /**
 36  * Interface against the JVM.
 37  *
 38  */
 39 public final class JVM {
 40     private static final JVM jvm = new JVM();
 41 
 42     // JVM signals file changes by doing Object#notifu on this object
 43     static final Object FILE_DELTA_CHANGE = new Object();
 44 
 45     static final long RESERVED_CLASS_ID_LIMIT = 400;
 46 

 47     private volatile boolean nativeOK;
 48 
 49     private static native void registerNatives();
 50 
 51     static {
 52         registerNatives();
 53         for (LogTag tag : LogTag.values()) {
 54             subscribeLogLevel(tag, tag.id);
 55         }
 56         Options.ensureInitialized();
 57     }
 58 
 59     /**
 60      * Get the one and only JVM.
 61      *
 62      * @return the JVM
 63      */
 64     public static JVM getJVM() {
 65         return jvm;
 66     }
 67 
 68     private JVM() {
 69     }
 70 
<span class="line-added"> 71     /**</span>
<span class="line-added"> 72      * Marks current chunk as final</span>
<span class="line-added"> 73      * &lt;p&gt;</span>
<span class="line-added"> 74      * This allows streaming clients to read the chunk header and</span>
<span class="line-added"> 75      * close the stream when no more data will be written into</span>
<span class="line-added"> 76      * the current repository.</span>
<span class="line-added"> 77      */</span>
<span class="line-added"> 78     public native void markChunkFinal();</span>
<span class="line-added"> 79 </span>
 80     /**
 81      * Begin recording events
 82      *
 83      * Requires that JFR has been started with {@link #createNativeJFR()}
 84      */
 85     public native void beginRecording();
 86 
<span class="line-added"> 87     /**</span>
<span class="line-added"> 88      * Return true if the JVM is recording</span>
<span class="line-added"> 89      */</span>
<span class="line-added"> 90     public native boolean isRecording();</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92     /**</span>
<span class="line-added"> 93      * End recording events, which includes flushing data in thread buffers</span>
<span class="line-added"> 94      *</span>
<span class="line-added"> 95      * Requires that JFR has been started with {@link #createNativeJFR()}</span>
<span class="line-added"> 96      *</span>
<span class="line-added"> 97      */</span>
<span class="line-added"> 98     public native void endRecording();</span>
<span class="line-added"> 99 </span>
100     /**
101      * Return ticks
102      *
103      * @return the time, in ticks
104      *
105      */
106     @HotSpotIntrinsicCandidate
107     public static native long counterTime();
108 
109 
110     /**
111      * Emits native periodic event.
112      *
113      * @param eventTypeId type id
114      *
115      * @param timestamp commit time for event
116      * @param when when it is being done {@link Periodic.When}
117      *
118      * @return true if the event was committed
119      */
120     public native boolean emitEvent(long eventTypeId, long timestamp, long when);
121 
<span class="line-modified">122 </span>






123 
124     /**
125      * Return a list of all classes deriving from {@link jdk.internal.event.Event}
126      *
127      * @return list of event classes.
128      */
129     public native List&lt;Class&lt;? extends jdk.internal.event.Event&gt;&gt; getAllEventClasses();
130 
131     /**
132      * Return a count of the number of unloaded classes deriving from {@link Event}
133      *
134      * @return number of unloaded event classes.
135      */
136     public native long getUnloadedEventClassCount();
137 
138     /**
139      * Return a unique identifier for a class. The class is marked as being
140      * &quot;in use&quot; in JFR.
141      *
142      * @param clazz clazz
</pre>
<hr />
<pre>
187      *
188      * @param tagSetId the tagset id
189      * @param level on level
190      * @param message log message
191      *
192      */
193     public static native void log(int tagSetId, int level, String message);
194 
195     /**
196      * Subscribe to LogLevel updates for LogTag
197      *
198      * @param lt the log tag to subscribe
199      * @param tagSetId the tagset id
200      */
201     public static native void subscribeLogLevel(LogTag lt, int tagSetId);
202 
203     /**
204      * Call to invoke event tagging and retransformation of the passed classes
205      *
206      * @param classes
<span class="line-added">207      *</span>
<span class="line-added">208      * @throws IllegalStateException if wrong JVMTI phase.</span>
209      */
210     public native synchronized void retransformClasses(Class&lt;?&gt;[] classes);
211 
212     /**
213      * Enable event
214      *
215      * @param eventTypeId event type id
216      *
217      * @param enabled enable event
218      */
219     public native void setEnabled(long eventTypeId, boolean enabled);
220 
221     /**
222      * Interval at which the JVM should notify on {@link #FILE_DELTA_CHANGE}
223      *
224      * @param delta number of bytes, reset after file rotation
225      */
226     public native void setFileNotification(long delta);
227 
228     /**
</pre>
<hr />
<pre>
271      *
272      * Requires that JFR has been started with {@link #createNativeJFR()}
273      *
274      * &lt;pre&gt;
275      * Recording  Previous  Current  Action
276      * ==============================================
277      *    true     null      null     Ignore, keep recording in-memory
278      *    true     null      file1    Start disk recording
279      *    true     file      null     Copy out metadata to disk and continue in-memory recording
280      *    true     file1     file2    Copy out metadata and start with new File (file2)
281      *    false     *        null     Ignore, but start recording to memory with {@link #beginRecording()}
282      *    false     *        file     Ignore, but start recording to disk with {@link #beginRecording()}
283      *
284      * &lt;/pre&gt;
285      *
286      * recording can be set to true/false with {@link #beginRecording()}
287      * {@link #endRecording()}
288      *
289      * @param file the file where data should be written, or null if it should
290      *        not be copied out (in memory).

291      * @throws IOException
292      */
293     public native void setOutput(String file);
294 
295     /**
296      * Controls if a class deriving from jdk.jfr.Event should
297      * always be instrumented on class load.
298      *
299      * @param force, true to force initialization, false otherwise
300      */
301     public native void setForceInstrumentation(boolean force);
302 
303     /**
304      * Turn on/off thread sampling.
305      *
306      * @param sampleThreads true if threads should be sampled, false otherwise.
307      *
308      * @throws IllegalStateException if state can&#39;t be changed.
309      */
310     public native void setSampleThreads(boolean sampleThreads) throws IllegalStateException;
</pre>
<hr />
<pre>
355      *
356      * @param eventTypeId the id of the event type
357      * @param ticks threshold in ticks,
358      * @return true, if it could be set
359      */
360     public native boolean setThreshold(long eventTypeId, long ticks);
361 
362     /**
363      * Store the metadata descriptor that is to be written at the end of a
364      * chunk, data should be written after GMT offset and size of metadata event
365      * should be adjusted
366      *
367      * Requires that JFR has been started with {@link #createNativeJFR()}
368      *
369      * @param bytes binary representation of metadata descriptor
370      *
371      * @param binary representation of descriptor
372      */
373     public native void storeMetadataDescriptor(byte[] bytes);
374 














375     /**
376      * If the JVM supports JVM TI and retransformation has not been disabled this
377      * method will return true. This flag can not change during the lifetime of
378      * the JVM.
379      *
380      * @return if transform is allowed
381      */
382     public native boolean getAllowedToDoEventRetransforms();
383 
384     /**
385      * Set up native resources, data structures, threads etc. for JFR
386      *
387      * @param simulateFailure simulate a initialization failure and rollback in
388      *        native, used for testing purposes
389      *
390      * @throws IllegalStateException if native part of JFR could not be created.
391      *
392      */
393     private native boolean createJFR(boolean simulateFailure) throws IllegalStateException;
394 
</pre>
<hr />
<pre>
445     /**
446      * Fast path fetching the EventWriter using VM intrinsics
447      *
448      * @return thread local EventWriter
449      */
450     @HotSpotIntrinsicCandidate
451     public static native Object getEventWriter();
452 
453     /**
454      * Create a new EventWriter
455      *
456      * @return thread local EventWriter
457      */
458     public static native EventWriter newEventWriter();
459 
460     /**
461      * Flushes the EventWriter for this thread.
462      */
463     public static native boolean flush(EventWriter writer, int uncommittedSize, int requestedSize);
464 
<span class="line-added">465     /**</span>
<span class="line-added">466      * Flushes all thread buffers to disk and the constant pool data needed to read</span>
<span class="line-added">467      * them.</span>
<span class="line-added">468      * &lt;p&gt;</span>
<span class="line-added">469      * When the method returns, the chunk header should be updated with valid</span>
<span class="line-added">470      * pointers to the metadata event, last check point event, correct file size and</span>
<span class="line-added">471      * the generation id.</span>
<span class="line-added">472      *</span>
<span class="line-added">473      */</span>
<span class="line-added">474     public native void flush();</span>
475     /**
476      * Sets the location of the disk repository, to be used at an emergency
477      * dump.
478      *
479      * @param dirText
480      */
481     public native void setRepositoryLocation(String dirText);
482 
483     /**
484     * Access to VM termination support.
485     *
486     *@param errorMsg descriptive message to be include in VM termination sequence
487     */
488     public native void abort(String errorMsg);
489 
490     /**
491      * Adds a string to the string constant pool.
492      *
493      * If the same string is added twice, two entries will be created.
494      *
</pre>
<hr />
<pre>
519      * @param eventTypeId the id of the event type
520      * @param cutoffTicks cutoff in ticks,
521      * @return true, if it could be set
522      */
523     public native boolean setCutoff(long eventTypeId, long cutoffTicks);
524 
525     /**
526      * Emit old object sample events.
527      *
528      * @param cutoff the cutoff in ticks
529      * @param emitAll emit all samples in old object queue
530      */
531     public native void emitOldObjectSamples(long cutoff, boolean emitAll);
532 
533     /**
534      * Test if a chunk rotation is warranted.
535      *
536      * @return if it is time to perform a chunk rotation
537      */
538     public native boolean shouldRotateDisk();
<span class="line-added">539 </span>
<span class="line-added">540     /**</span>
<span class="line-added">541      * Exclude a thread from the jfr system</span>
<span class="line-added">542      *</span>
<span class="line-added">543      */</span>
<span class="line-added">544     public native void exclude(Thread thread);</span>
<span class="line-added">545 </span>
<span class="line-added">546     /**</span>
<span class="line-added">547      * Include a thread back into the jfr system</span>
<span class="line-added">548      *</span>
<span class="line-added">549      */</span>
<span class="line-added">550     public native void include(Thread thread);</span>
<span class="line-added">551 </span>
<span class="line-added">552     /**</span>
<span class="line-added">553      * Test if a thread ius currently excluded from the jfr system.</span>
<span class="line-added">554      *</span>
<span class="line-added">555      * @return is thread currently excluded</span>
<span class="line-added">556      */</span>
<span class="line-added">557     public native boolean isExcluded(Thread thread);</span>
<span class="line-added">558 </span>
<span class="line-added">559     /**</span>
<span class="line-added">560      * Get the start time in nanos from the header of the current chunk</span>
<span class="line-added">561      *</span>
<span class="line-added">562      *@return start time of the recording in nanos, -1 in case of in-memory</span>
<span class="line-added">563      */</span>
<span class="line-added">564     public native long getChunkStartNanos();</span>
<span class="line-added">565 </span>
<span class="line-added">566     /**</span>
<span class="line-added">567      * Stores an EventHandler to the eventHandler field of an event class.</span>
<span class="line-added">568      *</span>
<span class="line-added">569      * @param eventClass the class, not {@code null}</span>
<span class="line-added">570      *</span>
<span class="line-added">571      * @param handler the handler, may be {@code null}</span>
<span class="line-added">572      *</span>
<span class="line-added">573      * @return if the field could be set</span>
<span class="line-added">574      */</span>
<span class="line-added">575     public native boolean setHandler(Class&lt;? extends jdk.internal.event.Event&gt; eventClass, EventHandler handler);</span>
<span class="line-added">576 </span>
<span class="line-added">577     /**</span>
<span class="line-added">578      * Retrieves the EventHandler for an event class.</span>
<span class="line-added">579      *</span>
<span class="line-added">580      * @param eventClass the class, not {@code null}</span>
<span class="line-added">581      *</span>
<span class="line-added">582      * @return the handler, may be {@code null}</span>
<span class="line-added">583      */</span>
<span class="line-added">584     public native Object getHandler(Class&lt;? extends jdk.internal.event.Event&gt; eventClass);</span>
<span class="line-added">585 </span>
586 }
</pre>
</td>
</tr>
</table>
<center><a href="EventWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LogTag.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
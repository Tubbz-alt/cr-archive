<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="TypeLibrary.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="WriteableUserPath.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/Utils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 package jdk.jfr.internal;
 27 
 28 import static java.util.concurrent.TimeUnit.MICROSECONDS;
 29 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 30 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 31 import static java.util.concurrent.TimeUnit.SECONDS;
 32 
 33 import java.io.FileOutputStream;
 34 import java.io.FileWriter;
 35 import java.io.IOException;
 36 import java.io.PrintWriter;
 37 import java.io.RandomAccessFile;
 38 import java.lang.annotation.Annotation;
 39 import java.lang.annotation.Repeatable;
 40 import java.lang.reflect.Field;
 41 import java.lang.reflect.InvocationTargetException;
 42 import java.lang.reflect.Method;
 43 import java.lang.reflect.Modifier;
 44 import java.nio.file.Path;
 45 import java.time.Duration;

 46 import java.time.LocalDateTime;

 47 import java.util.ArrayList;
 48 import java.util.Arrays;
 49 import java.util.Collections;
 50 import java.util.HashMap;
 51 import java.util.List;
 52 import java.util.Map;
 53 import java.util.Objects;
 54 
 55 import jdk.internal.org.objectweb.asm.ClassReader;
 56 import jdk.internal.org.objectweb.asm.util.CheckClassAdapter;
 57 import jdk.jfr.Event;
 58 import jdk.jfr.FlightRecorderPermission;
 59 import jdk.jfr.Recording;
 60 import jdk.jfr.RecordingState;
 61 import jdk.jfr.internal.handlers.EventHandler;
 62 import jdk.jfr.internal.settings.PeriodSetting;
 63 import jdk.jfr.internal.settings.StackTraceSetting;
 64 import jdk.jfr.internal.settings.ThresholdSetting;
 65 
 66 public final class Utils {
 67 

 68     private static final String INFINITY = &quot;infinity&quot;;
<span class="line-removed"> 69 </span>
<span class="line-removed"> 70     private static Boolean SAVE_GENERATED;</span>
<span class="line-removed"> 71 </span>
 72     public static final String EVENTS_PACKAGE_NAME = &quot;jdk.jfr.events&quot;;
 73     public static final String INSTRUMENT_PACKAGE_NAME = &quot;jdk.jfr.internal.instrument&quot;;
 74     public static final String HANDLERS_PACKAGE_NAME = &quot;jdk.jfr.internal.handlers&quot;;
 75     public static final String REGISTER_EVENT = &quot;registerEvent&quot;;
 76     public static final String ACCESS_FLIGHT_RECORDER = &quot;accessFlightRecorder&quot;;
<span class="line-removed"> 77 </span>
 78     private final static String LEGACY_EVENT_NAME_PREFIX = &quot;com.oracle.jdk.&quot;;
 79 














 80     public static void checkAccessFlightRecorder() throws SecurityException {
 81         SecurityManager sm = System.getSecurityManager();
 82         if (sm != null) {
 83             sm.checkPermission(new FlightRecorderPermission(ACCESS_FLIGHT_RECORDER));
 84         }
 85     }
 86 
 87     public static void checkRegisterPermission() throws SecurityException {
 88         SecurityManager sm = System.getSecurityManager();
 89         if (sm != null) {
 90             sm.checkPermission(new FlightRecorderPermission(REGISTER_EVENT));
 91         }
 92     }
 93 
 94     private static enum TimespanUnit {
 95         NANOSECONDS(&quot;ns&quot;, 1000), MICROSECONDS(&quot;us&quot;, 1000), MILLISECONDS(&quot;ms&quot;, 1000), SECONDS(&quot;s&quot;, 60), MINUTES(&quot;m&quot;, 60), HOURS(&quot;h&quot;, 24), DAYS(&quot;d&quot;, 7);
 96 
 97         final String text;
 98         final long amount;
 99 
</pre>
<hr />
<pre>
578             if (cMirror != null) {
579                 cMirror = cMirror.getSuperclass();
580             }
581             cReal = cReal.getSuperclass();
582         }
583     }
584 
585     private static boolean isSupportedType(Class&lt;?&gt; type) {
586         if (Modifier.isTransient(type.getModifiers()) || Modifier.isStatic(type.getModifiers())) {
587             return false;
588         }
589         return Type.isValidJavaFieldType(type.getName());
590     }
591 
592     public static String makeFilename(Recording recording) {
593         String pid = JVM.getJVM().getPid();
594         String date = Repository.REPO_DATE_FORMAT.format(LocalDateTime.now());
595         String idText = recording == null ? &quot;&quot; :  &quot;-id-&quot; + Long.toString(recording.getId());
596         return &quot;hotspot-&quot; + &quot;pid-&quot; + pid + idText + &quot;-&quot; + date + &quot;.jfr&quot;;
597     }

















































































































598 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 package jdk.jfr.internal;
 27 
 28 import static java.util.concurrent.TimeUnit.MICROSECONDS;
 29 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 30 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 31 import static java.util.concurrent.TimeUnit.SECONDS;
 32 
 33 import java.io.FileOutputStream;
 34 import java.io.FileWriter;
 35 import java.io.IOException;
 36 import java.io.PrintWriter;
 37 import java.io.RandomAccessFile;
 38 import java.lang.annotation.Annotation;
 39 import java.lang.annotation.Repeatable;
 40 import java.lang.reflect.Field;
 41 import java.lang.reflect.InvocationTargetException;
 42 import java.lang.reflect.Method;
 43 import java.lang.reflect.Modifier;
 44 import java.nio.file.Path;
 45 import java.time.Duration;
<span class="line-added"> 46 import java.time.Instant;</span>
 47 import java.time.LocalDateTime;
<span class="line-added"> 48 import java.time.temporal.ChronoUnit;</span>
 49 import java.util.ArrayList;
 50 import java.util.Arrays;
 51 import java.util.Collections;
 52 import java.util.HashMap;
 53 import java.util.List;
 54 import java.util.Map;
 55 import java.util.Objects;
 56 
 57 import jdk.internal.org.objectweb.asm.ClassReader;
 58 import jdk.internal.org.objectweb.asm.util.CheckClassAdapter;
 59 import jdk.jfr.Event;
 60 import jdk.jfr.FlightRecorderPermission;
 61 import jdk.jfr.Recording;
 62 import jdk.jfr.RecordingState;
 63 import jdk.jfr.internal.handlers.EventHandler;
 64 import jdk.jfr.internal.settings.PeriodSetting;
 65 import jdk.jfr.internal.settings.StackTraceSetting;
 66 import jdk.jfr.internal.settings.ThresholdSetting;
 67 
 68 public final class Utils {
 69 
<span class="line-added"> 70     private static final Object flushObject = new Object();</span>
 71     private static final String INFINITY = &quot;infinity&quot;;



 72     public static final String EVENTS_PACKAGE_NAME = &quot;jdk.jfr.events&quot;;
 73     public static final String INSTRUMENT_PACKAGE_NAME = &quot;jdk.jfr.internal.instrument&quot;;
 74     public static final String HANDLERS_PACKAGE_NAME = &quot;jdk.jfr.internal.handlers&quot;;
 75     public static final String REGISTER_EVENT = &quot;registerEvent&quot;;
 76     public static final String ACCESS_FLIGHT_RECORDER = &quot;accessFlightRecorder&quot;;

 77     private final static String LEGACY_EVENT_NAME_PREFIX = &quot;com.oracle.jdk.&quot;;
 78 
<span class="line-added"> 79     private static Boolean SAVE_GENERATED;</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82     private static final Duration MICRO_SECOND = Duration.ofNanos(1_000);</span>
<span class="line-added"> 83     private static final Duration SECOND = Duration.ofSeconds(1);</span>
<span class="line-added"> 84     private static final Duration MINUTE = Duration.ofMinutes(1);</span>
<span class="line-added"> 85     private static final Duration HOUR = Duration.ofHours(1);</span>
<span class="line-added"> 86     private static final Duration DAY = Duration.ofDays(1);</span>
<span class="line-added"> 87     private static final int NANO_SIGNIFICANT_FIGURES = 9;</span>
<span class="line-added"> 88     private static final int MILL_SIGNIFICANT_FIGURES = 3;</span>
<span class="line-added"> 89     private static final int DISPLAY_NANO_DIGIT = 3;</span>
<span class="line-added"> 90     private static final int BASE = 10;</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92 </span>
 93     public static void checkAccessFlightRecorder() throws SecurityException {
 94         SecurityManager sm = System.getSecurityManager();
 95         if (sm != null) {
 96             sm.checkPermission(new FlightRecorderPermission(ACCESS_FLIGHT_RECORDER));
 97         }
 98     }
 99 
100     public static void checkRegisterPermission() throws SecurityException {
101         SecurityManager sm = System.getSecurityManager();
102         if (sm != null) {
103             sm.checkPermission(new FlightRecorderPermission(REGISTER_EVENT));
104         }
105     }
106 
107     private static enum TimespanUnit {
108         NANOSECONDS(&quot;ns&quot;, 1000), MICROSECONDS(&quot;us&quot;, 1000), MILLISECONDS(&quot;ms&quot;, 1000), SECONDS(&quot;s&quot;, 60), MINUTES(&quot;m&quot;, 60), HOURS(&quot;h&quot;, 24), DAYS(&quot;d&quot;, 7);
109 
110         final String text;
111         final long amount;
112 
</pre>
<hr />
<pre>
591             if (cMirror != null) {
592                 cMirror = cMirror.getSuperclass();
593             }
594             cReal = cReal.getSuperclass();
595         }
596     }
597 
598     private static boolean isSupportedType(Class&lt;?&gt; type) {
599         if (Modifier.isTransient(type.getModifiers()) || Modifier.isStatic(type.getModifiers())) {
600             return false;
601         }
602         return Type.isValidJavaFieldType(type.getName());
603     }
604 
605     public static String makeFilename(Recording recording) {
606         String pid = JVM.getJVM().getPid();
607         String date = Repository.REPO_DATE_FORMAT.format(LocalDateTime.now());
608         String idText = recording == null ? &quot;&quot; :  &quot;-id-&quot; + Long.toString(recording.getId());
609         return &quot;hotspot-&quot; + &quot;pid-&quot; + pid + idText + &quot;-&quot; + date + &quot;.jfr&quot;;
610     }
<span class="line-added">611 </span>
<span class="line-added">612     public static String formatDuration(Duration d) {</span>
<span class="line-added">613         Duration roundedDuration = roundDuration(d);</span>
<span class="line-added">614         if (roundedDuration.equals(Duration.ZERO)) {</span>
<span class="line-added">615             return &quot;0 s&quot;;</span>
<span class="line-added">616         } else if(roundedDuration.isNegative()){</span>
<span class="line-added">617             return &quot;-&quot; + formatPositiveDuration(roundedDuration.abs());</span>
<span class="line-added">618         } else {</span>
<span class="line-added">619             return formatPositiveDuration(roundedDuration);</span>
<span class="line-added">620         }</span>
<span class="line-added">621     }</span>
<span class="line-added">622 </span>
<span class="line-added">623     private static String formatPositiveDuration(Duration d){</span>
<span class="line-added">624         if (d.compareTo(MICRO_SECOND) &lt; 0) {</span>
<span class="line-added">625             // 0.000001 ms - 0.000999 ms</span>
<span class="line-added">626             double outputMs = (double) d.toNanosPart() / 1_000_000;</span>
<span class="line-added">627             return String.format(&quot;%.6f ms&quot;,  outputMs);</span>
<span class="line-added">628         } else if (d.compareTo(SECOND) &lt; 0) {</span>
<span class="line-added">629             // 0.001 ms - 999 ms</span>
<span class="line-added">630             int valueLength = countLength(d.toNanosPart());</span>
<span class="line-added">631             int outputDigit = NANO_SIGNIFICANT_FIGURES - valueLength;</span>
<span class="line-added">632             double outputMs = (double) d.toNanosPart() / 1_000_000;</span>
<span class="line-added">633             return String.format(&quot;%.&quot; + outputDigit + &quot;f ms&quot;,  outputMs);</span>
<span class="line-added">634         } else if (d.compareTo(MINUTE) &lt; 0) {</span>
<span class="line-added">635             // 1.00 s - 59.9 s</span>
<span class="line-added">636             int valueLength = countLength(d.toSecondsPart());</span>
<span class="line-added">637             int outputDigit = MILL_SIGNIFICANT_FIGURES - valueLength;</span>
<span class="line-added">638             double outputSecond = d.toSecondsPart() + (double) d.toMillisPart() / 1_000;</span>
<span class="line-added">639             return String.format(&quot;%.&quot; + outputDigit + &quot;f s&quot;,  outputSecond);</span>
<span class="line-added">640         } else if (d.compareTo(HOUR) &lt; 0) {</span>
<span class="line-added">641             // 1 m 0 s - 59 m 59 s</span>
<span class="line-added">642             return String.format(&quot;%d m %d s&quot;,  d.toMinutesPart(), d.toSecondsPart());</span>
<span class="line-added">643         } else if (d.compareTo(DAY) &lt; 0) {</span>
<span class="line-added">644             // 1 h 0 m - 23 h 59 m</span>
<span class="line-added">645             return String.format(&quot;%d h %d m&quot;,  d.toHoursPart(), d.toMinutesPart());</span>
<span class="line-added">646         } else {</span>
<span class="line-added">647             // 1 d 0 h -</span>
<span class="line-added">648             return String.format(&quot;%d d %d h&quot;,  d.toDaysPart(), d.toHoursPart());</span>
<span class="line-added">649         }</span>
<span class="line-added">650     }</span>
<span class="line-added">651 </span>
<span class="line-added">652     private static int countLength(long value){</span>
<span class="line-added">653         return (int) Math.log10(value) + 1;</span>
<span class="line-added">654     }</span>
<span class="line-added">655 </span>
<span class="line-added">656     private static Duration roundDuration(Duration d) {</span>
<span class="line-added">657         if (d.equals(Duration.ZERO)) {</span>
<span class="line-added">658             return d;</span>
<span class="line-added">659         } else if(d.isNegative()){</span>
<span class="line-added">660             Duration roundedPositiveDuration = roundPositiveDuration(d.abs());</span>
<span class="line-added">661             return roundedPositiveDuration.negated();</span>
<span class="line-added">662         } else {</span>
<span class="line-added">663             return roundPositiveDuration(d);</span>
<span class="line-added">664         }</span>
<span class="line-added">665     }</span>
<span class="line-added">666 </span>
<span class="line-added">667     private static Duration roundPositiveDuration(Duration d){</span>
<span class="line-added">668         if (d.compareTo(MICRO_SECOND) &lt; 0) {</span>
<span class="line-added">669             // No round</span>
<span class="line-added">670             return d;</span>
<span class="line-added">671         } else if (d.compareTo(SECOND) &lt; 0) {</span>
<span class="line-added">672             // Round significant figures to three digits</span>
<span class="line-added">673             int valueLength = countLength(d.toNanosPart());</span>
<span class="line-added">674             int roundValue = (int) Math.pow(BASE, valueLength - DISPLAY_NANO_DIGIT);</span>
<span class="line-added">675             long roundedNanos = Math.round((double) d.toNanosPart() / roundValue) * roundValue;</span>
<span class="line-added">676             return d.truncatedTo(ChronoUnit.SECONDS).plusNanos(roundedNanos);</span>
<span class="line-added">677         } else if (d.compareTo(MINUTE) &lt; 0) {</span>
<span class="line-added">678             // Round significant figures to three digits</span>
<span class="line-added">679             int valueLength = countLength(d.toSecondsPart());</span>
<span class="line-added">680             int roundValue = (int) Math.pow(BASE, valueLength);</span>
<span class="line-added">681             long roundedMills = Math.round((double) d.toMillisPart() / roundValue) * roundValue;</span>
<span class="line-added">682             return d.truncatedTo(ChronoUnit.SECONDS).plusMillis(roundedMills);</span>
<span class="line-added">683         } else if (d.compareTo(HOUR) &lt; 0) {</span>
<span class="line-added">684             // Round for more than 500 ms or less</span>
<span class="line-added">685             return d.plusMillis(SECOND.dividedBy(2).toMillisPart()).truncatedTo(ChronoUnit.SECONDS);</span>
<span class="line-added">686         } else if (d.compareTo(DAY) &lt; 0) {</span>
<span class="line-added">687             // Round for more than 30 seconds or less</span>
<span class="line-added">688             return d.plusSeconds(MINUTE.dividedBy(2).toSecondsPart()).truncatedTo(ChronoUnit.MINUTES);</span>
<span class="line-added">689         } else {</span>
<span class="line-added">690             // Round for more than 30 minutes or less</span>
<span class="line-added">691             return d.plusMinutes(HOUR.dividedBy(2).toMinutesPart()).truncatedTo(ChronoUnit.HOURS);</span>
<span class="line-added">692         }</span>
<span class="line-added">693     }</span>
<span class="line-added">694 </span>
<span class="line-added">695 </span>
<span class="line-added">696     public static void takeNap(long millis) {</span>
<span class="line-added">697         try {</span>
<span class="line-added">698             Thread.sleep(millis);</span>
<span class="line-added">699         } catch (InterruptedException e) {</span>
<span class="line-added">700             // ok</span>
<span class="line-added">701         }</span>
<span class="line-added">702     }</span>
<span class="line-added">703 </span>
<span class="line-added">704     public static void notifyFlush() {</span>
<span class="line-added">705         synchronized (flushObject) {</span>
<span class="line-added">706             flushObject.notifyAll();</span>
<span class="line-added">707         }</span>
<span class="line-added">708     }</span>
<span class="line-added">709 </span>
<span class="line-added">710     public static void waitFlush(long timeOut) {</span>
<span class="line-added">711         synchronized (flushObject) {</span>
<span class="line-added">712             try {</span>
<span class="line-added">713                 flushObject.wait(timeOut);</span>
<span class="line-added">714             } catch (InterruptedException e) {</span>
<span class="line-added">715                 // OK</span>
<span class="line-added">716             }</span>
<span class="line-added">717         }</span>
<span class="line-added">718 </span>
<span class="line-added">719     }</span>
<span class="line-added">720 </span>
<span class="line-added">721     public static long timeToNanos(Instant timestamp) {</span>
<span class="line-added">722         return timestamp.getEpochSecond() * 1_000_000_000L + timestamp.getNano();</span>
<span class="line-added">723     }</span>
724 }
</pre>
</td>
</tr>
</table>
<center><a href="TypeLibrary.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="WriteableUserPath.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
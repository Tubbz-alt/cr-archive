<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/Dispatcher.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.time.Instant;
 29 import java.util.ArrayList;
 30 import java.util.List;
 31 import java.util.function.Consumer;
 32 
 33 import jdk.jfr.EventType;
 34 import jdk.jfr.consumer.RecordedEvent;
 35 import jdk.jfr.internal.LongMap;
 36 import jdk.jfr.internal.consumer.ChunkParser.ParserConfiguration;
 37 
 38 final class Dispatcher {
 39 
 40     final static class EventDispatcher {
 41         private final static EventDispatcher[] NO_DISPATCHERS = new EventDispatcher[0];
 42 
 43         private final String eventName;
 44         private final Consumer&lt;RecordedEvent&gt; action;
 45 
 46         public EventDispatcher(String eventName, Consumer&lt;RecordedEvent&gt; action) {
 47             this.eventName = eventName;
 48             this.action = action;
 49         }
 50 
 51         private void offer(RecordedEvent event) {
 52             action.accept(event);
 53         }
 54 
 55         private boolean accepts(EventType eventType) {
 56             return (eventName == null || eventType.getName().equals(eventName));
 57         }
 58 
 59         public Consumer&lt;RecordedEvent&gt; getAction() {
 60             return action;
 61         }
 62     }
 63 
 64     private final Consumer&lt;Throwable&gt;[] errorActions;
 65     private final Runnable[] flushActions;
 66     private final Runnable[] closeActions;
 67     private final EventDispatcher[] dispatchers;
 68     private final LongMap&lt;EventDispatcher[]&gt; dispatcherLookup = new LongMap&lt;&gt;();
 69     final ParserConfiguration parserConfiguration;
 70     final Instant startTime;
 71     final Instant endTime;
 72     final long startNanos;
 73     final long endNanos;
 74 
 75     // Cache
 76     private EventType cacheEventType;
 77     private EventDispatcher[] cacheDispatchers;
 78 
 79     @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
 80     public Dispatcher(StreamConfiguration c) {
 81         this.flushActions = c.flushActions.toArray(new Runnable[0]);
 82         this.closeActions = c.closeActions.toArray(new Runnable[0]);
 83         this.errorActions = c.errorActions.toArray(new Consumer[0]);
 84         this.dispatchers = c.eventActions.toArray(new EventDispatcher[0]);
 85         this.parserConfiguration = new ParserConfiguration(0, Long.MAX_VALUE, c.reuse, c.ordered, buildFilter(dispatchers));
 86         this.startTime = c.startTime;
 87         this.endTime = c.endTime;
 88         this.startNanos = c.startNanos;
 89         this.endNanos = c.endNanos;
 90     }
 91 
 92     public void runFlushActions() {
 93         Runnable[] flushActions = this.flushActions;
 94         for (int i = 0; i &lt; flushActions.length; i++) {
 95             try {
 96                 flushActions[i].run();
 97             } catch (Exception e) {
 98                 handleError(e);
 99             }
100         }
101     }
102 
103     public void runCloseActions() {
104         Runnable[] closeActions = this.closeActions;
105         for (int i = 0; i &lt; closeActions.length; i++) {
106             try {
107                 closeActions[i].run();
108             } catch (Exception e) {
109                 handleError(e);
110             }
111         }
112     }
113 
114     private static ParserFilter buildFilter(EventDispatcher[] dispatchers) {
115         ParserFilter ef = new ParserFilter();
116         for (EventDispatcher ed : dispatchers) {
117             String name = ed.eventName;
118             if (name == null) {
119                 return ParserFilter.ACCEPT_ALL;
120             }
121             ef.setThreshold(name, 0);
122         }
123         return ef;
124     }
125 
126     void dispatch(RecordedEvent event) {
127         EventType type = event.getEventType();
128         EventDispatcher[] dispatchers = null;
129         if (type == cacheEventType) {
130             dispatchers = cacheDispatchers;
131         } else {
132             dispatchers = dispatcherLookup.get(type.getId());
133             if (dispatchers == null) {
134                 List&lt;EventDispatcher&gt; list = new ArrayList&lt;&gt;();
135                 for (EventDispatcher e : this.dispatchers) {
136                     if (e.accepts(type)) {
137                         list.add(e);
138                     }
139                 }
140                 dispatchers = list.isEmpty() ? EventDispatcher.NO_DISPATCHERS : list.toArray(new EventDispatcher[0]);
141                 dispatcherLookup.put(type.getId(), dispatchers);
142             }
143             cacheDispatchers = dispatchers;
144         }
145         // Expected behavior if exception occurs in onEvent:
146         //
147         // Synchronous:
148         //  - User has added onError action:
149         //     Catch exception, call onError and continue with next event
150         //     Let Errors propagate to caller of EventStream::start
151         //  - Default action
152         //     Catch exception, e.printStackTrace() and continue with next event
153         //     Let Errors propagate to caller of EventStream::start
154         //
155         // Asynchronous
156         //  - User has added onError action
157         //     Catch exception, call onError and continue with next event
158         //     Let Errors propagate, shutdown thread and stream
159         //  - Default action
160         //    Catch exception, e.printStackTrace() and continue with next event
161         //    Let Errors propagate and shutdown thread and stream
162         //
163         for (int i = 0; i &lt; dispatchers.length; i++) {
164             try {
165                 dispatchers[i].offer(event);
166             } catch (Exception e) {
167                 handleError(e);
168             }
169         }
170     }
171 
172     private void handleError(Throwable e) {
173         Consumer&lt;?&gt;[] consumers = this.errorActions;
174         if (consumers.length == 0) {
175             defaultErrorHandler(e);
176             return;
177         }
178         for (int i = 0; i &lt; consumers.length; i++) {
179             @SuppressWarnings(&quot;unchecked&quot;)
180             Consumer&lt;Throwable&gt; consumer = (Consumer&lt;Throwable&gt;) consumers[i];
181             consumer.accept(e);
182         }
183     }
184 
185     private void defaultErrorHandler(Throwable e) {
186         e.printStackTrace();
187     }
188 }
    </pre>
  </body>
</html>
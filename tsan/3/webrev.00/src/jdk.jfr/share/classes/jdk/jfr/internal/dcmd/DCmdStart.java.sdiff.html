<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DCmdDump.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../instrument/JDKEvents.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.jfr.internal.dcmd;
 26 

 27 import java.io.IOException;
 28 import java.nio.file.Files;
 29 import java.nio.file.InvalidPathException;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.text.ParseException;
 33 import java.time.Duration;
 34 import java.util.Arrays;
 35 import java.util.HashMap;
 36 import java.util.Map;
 37 
 38 import jdk.jfr.FlightRecorder;
 39 import jdk.jfr.Recording;
 40 import jdk.jfr.internal.JVM;
 41 import jdk.jfr.internal.LogLevel;
 42 import jdk.jfr.internal.LogTag;
 43 import jdk.jfr.internal.Logger;
 44 import jdk.jfr.internal.OldObjectSample;

 45 import jdk.jfr.internal.PrivateAccess;
 46 import jdk.jfr.internal.SecuritySupport.SafePath;
 47 import jdk.jfr.internal.Type;
 48 import jdk.jfr.internal.jfc.JFC;
 49 
 50 /**
 51  * JFR.start
 52  *
 53  */
 54 //Instantiated by native
 55 final class DCmdStart extends AbstractDCmd {
 56 
 57     /**
 58      * Execute JFR.start.
 59      *
 60      * @param name optional name that can be used to identify recording.
 61      * @param settings names of settings files to use, i.e. &quot;default&quot; or
 62      *        &quot;default.jfc&quot;.
 63      * @param delay delay before recording is started, in nanoseconds. Must be
 64      *        at least 1 second.
 65      * @param duration duration of the recording, in nanoseconds. Must be at
 66      *        least 1 second.
 67      * @param disk if recording should be persisted to disk
 68      * @param path file path where recording data should be written
 69      * @param maxAge how long recording data should be kept in the disk
 70      *        repository, or &lt;code&gt;0&lt;/code&gt; if no limit should be set.
 71      *
 72      * @param maxSize the minimum amount data to keep in the disk repository
 73      *        before it is discarded, or &lt;code&gt;0&lt;/code&gt; if no limit should be
 74      *        set.
 75      *
 76      * @param dumpOnExit if recording should dump on exit
 77      *
 78      * @return result output
 79      *
 80      * @throws DCmdException if recording could not be started
 81      */
 82     @SuppressWarnings(&quot;resource&quot;)
<span class="line-modified"> 83     public String execute(String name, String[] settings, Long delay, Long duration, Boolean disk, String path, Long maxAge, Long maxSize, Boolean dumpOnExit, Boolean pathToGcRoots) throws DCmdException {</span>
 84         if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {
 85             Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, &quot;Executing DCmdStart: name=&quot; + name +
 86                     &quot;, settings=&quot; + Arrays.asList(settings) +
 87                     &quot;, delay=&quot; + delay +
 88                     &quot;, duration=&quot; + duration +
 89                     &quot;, disk=&quot; + disk+
 90                     &quot;, filename=&quot; + path +
 91                     &quot;, maxage=&quot; + maxAge +

 92                     &quot;, maxsize=&quot; + maxSize +
 93                     &quot;, dumponexit =&quot; + dumpOnExit +
 94                     &quot;, path-to-gc-roots=&quot; + pathToGcRoots);
 95         }
 96         if (name != null) {
 97             try {
 98                 Integer.parseInt(name);
 99                 throw new DCmdException(&quot;Name of recording can&#39;t be numeric&quot;);
100             } catch (NumberFormatException nfe) {
101                 // ok, can&#39;t be mixed up with name
102             }
103         }
104 
105         if (duration == null &amp;&amp; Boolean.FALSE.equals(dumpOnExit) &amp;&amp; path != null) {
106             throw new DCmdException(&quot;Filename can only be set for a time bound recording or if dumponexit=true. Set duration/dumponexit or omit filename.&quot;);
107         }
<span class="line-modified">108 </span>


109         Map&lt;String, String&gt; s = new HashMap&lt;&gt;();
110         for (String configName : settings) {
111             try {
112                 s.putAll(JFC.createKnown(configName).getSettings());


113             } catch (IOException | ParseException e) {
<span class="line-modified">114                 throw new DCmdException(&quot;Could not parse setting &quot; + settings[0], e);</span>
115             }
116         }
117 
118         OldObjectSample.updateSettingPathToGcRoots(s, pathToGcRoots);
119 
120         if (duration != null) {
121             if (duration &lt; 1000L * 1000L * 1000L) {
122                 // to avoid typo, duration below 1s makes no sense
123                 throw new DCmdException(&quot;Could not start recording, duration must be at least 1 second.&quot;);
124             }
125         }
126 
127         if (delay != null) {
128             if (delay &lt; 1000L * 1000L * 1000) {
129                 // to avoid typo, delay shorter than 1s makes no sense.
130                 throw new DCmdException(&quot;Could not start recording, delay must be at least 1 second.&quot;);
131             }
132         }
133 






134         if (!FlightRecorder.isInitialized() &amp;&amp; delay == null) {
135             initializeWithForcedInstrumentation(s);
136         }
137 
138         Recording recording = new Recording();
139         if (name != null) {
140             recording.setName(name);
141         }
142 
143         if (disk != null) {
144             recording.setToDisk(disk.booleanValue());
145         }

146         recording.setSettings(s);
147         SafePath safePath = null;
148 
149         if (path != null) {
150             try {
151                 if (dumpOnExit == null) {
152                     // default to dumponexit=true if user specified filename
153                     dumpOnExit = Boolean.TRUE;
154                 }
155                 Path p = Paths.get(path);
156                 if (Files.isDirectory(p) &amp;&amp; Boolean.TRUE.equals(dumpOnExit)) {
157                     // Decide destination filename at dump time
158                     // Purposely avoid generating filename in Recording#setDestination due to
159                     // security concerns
160                     PrivateAccess.getInstance().getPlatformRecording(recording).setDumpOnExitDirectory(new SafePath(p));
161                 } else {
162                     safePath = resolvePath(recording, path);
163                     recording.setDestination(safePath.toPath());
164                 }
165             } catch (IOException | InvalidPathException e) {
166                 recording.close();
167                 throw new DCmdException(&quot;Could not start recording, not able to write to file %s. %s &quot;, path, e.getMessage());
168             }
169         }
170 
171         if (maxAge != null) {
172             recording.setMaxAge(Duration.ofNanos(maxAge));
173         }
174 





175         if (maxSize != null) {
176             recording.setMaxSize(maxSize);
177         }
178 
179         if (duration != null) {
180             recording.setDuration(Duration.ofNanos(duration));
181         }
182 
183         if (dumpOnExit != null) {
184             recording.setDumpOnExit(dumpOnExit);
185         }
186 
187         if (delay != null) {
188             Duration dDelay = Duration.ofNanos(delay);
189             recording.scheduleStart(dDelay);
190             print(&quot;Recording &quot; + recording.getId() + &quot; scheduled to start in &quot;);
191             printTimespan(dDelay, &quot; &quot;);
192             print(&quot;.&quot;);
193         } else {
194             recording.start();
</pre>
<hr />
<pre>
200             recording.setMaxSize(250*1024L*1024L);
201         }
202 
203         if (safePath != null &amp;&amp; duration != null) {
204             println(&quot; The result will be written to:&quot;);
205             println();
206             printPath(safePath);
207         } else {
208             println();
209             println();
210             String cmd = duration == null ? &quot;dump&quot; : &quot;stop&quot;;
211             String fileOption = path == null ? &quot;filename=FILEPATH &quot; : &quot;&quot;;
212             String recordingspecifier = &quot;name=&quot; + recording.getId();
213             // if user supplied a name, use it.
214             if (name != null) {
215                 recordingspecifier = &quot;name=&quot; + quoteIfNeeded(name);
216             }
217             print(&quot;Use jcmd &quot; + getPid() + &quot; JFR.&quot; + cmd + &quot; &quot; + recordingspecifier + &quot; &quot; + fileOption + &quot;to copy recording data to file.&quot;);
218             println();
219         }

220         return getResult();
221     }
222 
223 
224     // Instruments JDK-events on class load to reduce startup time
225     private void initializeWithForcedInstrumentation(Map&lt;String, String&gt; settings) {
226         if (!hasJDKEvents(settings)) {
227             return;
228         }
229         JVM jvm = JVM.getJVM();
230         try {
231             jvm.setForceInstrumentation(true);
232             FlightRecorder.getFlightRecorder();
233         } finally {
234             jvm.setForceInstrumentation(false);
235         }
236     }
237 
238     private boolean hasJDKEvents(Map&lt;String, String&gt; settings) {
239         String[] eventNames = new String[7];
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.jfr.internal.dcmd;
 26 
<span class="line-added"> 27 import java.io.FileNotFoundException;</span>
 28 import java.io.IOException;
 29 import java.nio.file.Files;
 30 import java.nio.file.InvalidPathException;
 31 import java.nio.file.Path;
 32 import java.nio.file.Paths;
 33 import java.text.ParseException;
 34 import java.time.Duration;
 35 import java.util.Arrays;
 36 import java.util.HashMap;
 37 import java.util.Map;
 38 
 39 import jdk.jfr.FlightRecorder;
 40 import jdk.jfr.Recording;
 41 import jdk.jfr.internal.JVM;
 42 import jdk.jfr.internal.LogLevel;
 43 import jdk.jfr.internal.LogTag;
 44 import jdk.jfr.internal.Logger;
 45 import jdk.jfr.internal.OldObjectSample;
<span class="line-added"> 46 import jdk.jfr.internal.PlatformRecording;</span>
 47 import jdk.jfr.internal.PrivateAccess;
 48 import jdk.jfr.internal.SecuritySupport.SafePath;
 49 import jdk.jfr.internal.Type;
 50 import jdk.jfr.internal.jfc.JFC;
 51 
 52 /**
 53  * JFR.start
 54  *
 55  */
 56 //Instantiated by native
 57 final class DCmdStart extends AbstractDCmd {
 58 
 59     /**
 60      * Execute JFR.start.
 61      *
 62      * @param name optional name that can be used to identify recording.
 63      * @param settings names of settings files to use, i.e. &quot;default&quot; or
 64      *        &quot;default.jfc&quot;.
 65      * @param delay delay before recording is started, in nanoseconds. Must be
 66      *        at least 1 second.
 67      * @param duration duration of the recording, in nanoseconds. Must be at
 68      *        least 1 second.
 69      * @param disk if recording should be persisted to disk
 70      * @param path file path where recording data should be written
 71      * @param maxAge how long recording data should be kept in the disk
 72      *        repository, or &lt;code&gt;0&lt;/code&gt; if no limit should be set.
 73      *
 74      * @param maxSize the minimum amount data to keep in the disk repository
 75      *        before it is discarded, or &lt;code&gt;0&lt;/code&gt; if no limit should be
 76      *        set.
 77      *
 78      * @param dumpOnExit if recording should dump on exit
 79      *
 80      * @return result output
 81      *
 82      * @throws DCmdException if recording could not be started
 83      */
 84     @SuppressWarnings(&quot;resource&quot;)
<span class="line-modified"> 85     public String execute(String name, String[] settings, Long delay, Long duration, Boolean disk, String path, Long maxAge, Long maxSize, Long flush, Boolean dumpOnExit, Boolean pathToGcRoots) throws DCmdException {</span>
 86         if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {
 87             Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, &quot;Executing DCmdStart: name=&quot; + name +
 88                     &quot;, settings=&quot; + Arrays.asList(settings) +
 89                     &quot;, delay=&quot; + delay +
 90                     &quot;, duration=&quot; + duration +
 91                     &quot;, disk=&quot; + disk+
 92                     &quot;, filename=&quot; + path +
 93                     &quot;, maxage=&quot; + maxAge +
<span class="line-added"> 94                     &quot;, flush=&quot; + flush +</span>
 95                     &quot;, maxsize=&quot; + maxSize +
 96                     &quot;, dumponexit =&quot; + dumpOnExit +
 97                     &quot;, path-to-gc-roots=&quot; + pathToGcRoots);
 98         }
 99         if (name != null) {
100             try {
101                 Integer.parseInt(name);
102                 throw new DCmdException(&quot;Name of recording can&#39;t be numeric&quot;);
103             } catch (NumberFormatException nfe) {
104                 // ok, can&#39;t be mixed up with name
105             }
106         }
107 
108         if (duration == null &amp;&amp; Boolean.FALSE.equals(dumpOnExit) &amp;&amp; path != null) {
109             throw new DCmdException(&quot;Filename can only be set for a time bound recording or if dumponexit=true. Set duration/dumponexit or omit filename.&quot;);
110         }
<span class="line-modified">111         if (settings.length == 1 &amp;&amp; settings[0].length() == 0) {</span>
<span class="line-added">112             throw new DCmdException(&quot;No settings specified. Use settings=none to start without any settings&quot;);</span>
<span class="line-added">113         }</span>
114         Map&lt;String, String&gt; s = new HashMap&lt;&gt;();
115         for (String configName : settings) {
116             try {
117                 s.putAll(JFC.createKnown(configName).getSettings());
<span class="line-added">118             } catch(FileNotFoundException e) {</span>
<span class="line-added">119                 throw new DCmdException(&quot;Could not find settings file&#39;&quot; + configName + &quot;&#39;&quot;, e);</span>
120             } catch (IOException | ParseException e) {
<span class="line-modified">121                 throw new DCmdException(&quot;Could not parse settings file &#39;&quot; + settings[0] + &quot;&#39;&quot;, e);</span>
122             }
123         }
124 
125         OldObjectSample.updateSettingPathToGcRoots(s, pathToGcRoots);
126 
127         if (duration != null) {
128             if (duration &lt; 1000L * 1000L * 1000L) {
129                 // to avoid typo, duration below 1s makes no sense
130                 throw new DCmdException(&quot;Could not start recording, duration must be at least 1 second.&quot;);
131             }
132         }
133 
134         if (delay != null) {
135             if (delay &lt; 1000L * 1000L * 1000) {
136                 // to avoid typo, delay shorter than 1s makes no sense.
137                 throw new DCmdException(&quot;Could not start recording, delay must be at least 1 second.&quot;);
138             }
139         }
140 
<span class="line-added">141         if (flush != null) {</span>
<span class="line-added">142             if (Boolean.FALSE.equals(disk)) {</span>
<span class="line-added">143                 throw new DCmdException(&quot;Flush can only be set for recordings that are to disk.&quot;);</span>
<span class="line-added">144             }</span>
<span class="line-added">145         }</span>
<span class="line-added">146 </span>
147         if (!FlightRecorder.isInitialized() &amp;&amp; delay == null) {
148             initializeWithForcedInstrumentation(s);
149         }
150 
151         Recording recording = new Recording();
152         if (name != null) {
153             recording.setName(name);
154         }
155 
156         if (disk != null) {
157             recording.setToDisk(disk.booleanValue());
158         }
<span class="line-added">159 </span>
160         recording.setSettings(s);
161         SafePath safePath = null;
162 
163         if (path != null) {
164             try {
165                 if (dumpOnExit == null) {
166                     // default to dumponexit=true if user specified filename
167                     dumpOnExit = Boolean.TRUE;
168                 }
169                 Path p = Paths.get(path);
170                 if (Files.isDirectory(p) &amp;&amp; Boolean.TRUE.equals(dumpOnExit)) {
171                     // Decide destination filename at dump time
172                     // Purposely avoid generating filename in Recording#setDestination due to
173                     // security concerns
174                     PrivateAccess.getInstance().getPlatformRecording(recording).setDumpOnExitDirectory(new SafePath(p));
175                 } else {
176                     safePath = resolvePath(recording, path);
177                     recording.setDestination(safePath.toPath());
178                 }
179             } catch (IOException | InvalidPathException e) {
180                 recording.close();
181                 throw new DCmdException(&quot;Could not start recording, not able to write to file %s. %s &quot;, path, e.getMessage());
182             }
183         }
184 
185         if (maxAge != null) {
186             recording.setMaxAge(Duration.ofNanos(maxAge));
187         }
188 
<span class="line-added">189         if (flush != null) {</span>
<span class="line-added">190             PlatformRecording p = PrivateAccess.getInstance().getPlatformRecording(recording);</span>
<span class="line-added">191             p.setFlushInterval(Duration.ofNanos(flush));</span>
<span class="line-added">192         }</span>
<span class="line-added">193 </span>
194         if (maxSize != null) {
195             recording.setMaxSize(maxSize);
196         }
197 
198         if (duration != null) {
199             recording.setDuration(Duration.ofNanos(duration));
200         }
201 
202         if (dumpOnExit != null) {
203             recording.setDumpOnExit(dumpOnExit);
204         }
205 
206         if (delay != null) {
207             Duration dDelay = Duration.ofNanos(delay);
208             recording.scheduleStart(dDelay);
209             print(&quot;Recording &quot; + recording.getId() + &quot; scheduled to start in &quot;);
210             printTimespan(dDelay, &quot; &quot;);
211             print(&quot;.&quot;);
212         } else {
213             recording.start();
</pre>
<hr />
<pre>
219             recording.setMaxSize(250*1024L*1024L);
220         }
221 
222         if (safePath != null &amp;&amp; duration != null) {
223             println(&quot; The result will be written to:&quot;);
224             println();
225             printPath(safePath);
226         } else {
227             println();
228             println();
229             String cmd = duration == null ? &quot;dump&quot; : &quot;stop&quot;;
230             String fileOption = path == null ? &quot;filename=FILEPATH &quot; : &quot;&quot;;
231             String recordingspecifier = &quot;name=&quot; + recording.getId();
232             // if user supplied a name, use it.
233             if (name != null) {
234                 recordingspecifier = &quot;name=&quot; + quoteIfNeeded(name);
235             }
236             print(&quot;Use jcmd &quot; + getPid() + &quot; JFR.&quot; + cmd + &quot; &quot; + recordingspecifier + &quot; &quot; + fileOption + &quot;to copy recording data to file.&quot;);
237             println();
238         }
<span class="line-added">239 </span>
240         return getResult();
241     }
242 
243 
244     // Instruments JDK-events on class load to reduce startup time
245     private void initializeWithForcedInstrumentation(Map&lt;String, String&gt; settings) {
246         if (!hasJDKEvents(settings)) {
247             return;
248         }
249         JVM jvm = JVM.getJVM();
250         try {
251             jvm.setForceInstrumentation(true);
252             FlightRecorder.getFlightRecorder();
253         } finally {
254             jvm.setForceInstrumentation(false);
255         }
256     }
257 
258     private boolean hasJDKEvents(Map&lt;String, String&gt; settings) {
259         String[] eventNames = new String[7];
</pre>
</td>
</tr>
</table>
<center><a href="DCmdDump.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../instrument/JDKEvents.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
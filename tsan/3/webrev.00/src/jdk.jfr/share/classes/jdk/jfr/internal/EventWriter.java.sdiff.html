<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="EventInstrumentation.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="JVM.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/EventWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import jdk.internal.misc.Unsafe;
<span class="line-modified"> 29 import jdk.jfr.internal.consumer.RecordingInput;</span>
 30 
 31 /**
 32  * Class must reside in a package with package restriction.
 33  *
 34  * Users should not have direct access to underlying memory.
 35  *
 36  */
 37 public final class EventWriter {
 38     private static final Unsafe unsafe = Unsafe.getUnsafe();
 39     private final static JVM jvm = JVM.getJVM();
 40 
 41     private long startPosition;
 42     private long startPositionAddress;
 43     private long currentPosition;
 44     private long maxPosition;
 45     private final long threadID;
 46     private PlatformEventType eventType;
 47     private int maxEventSize;
 48     private boolean started;
 49     private boolean valid;
</pre>
<hr />
<pre>
 98     public void putFloat(float i) {
 99         if (isValidForSize(Float.BYTES)) {
100             currentPosition += Bits.putFloat(currentPosition, i);
101         }
102     }
103 
104     public void putLong(long v) {
105         if (isValidForSize(Long.BYTES + 1)) {
106             putUncheckedLong(v);
107         }
108     }
109 
110     public void putDouble(double i) {
111         if (isValidForSize(Double.BYTES)) {
112             currentPosition += Bits.putDouble(currentPosition, i);
113         }
114     }
115 
116     public void putString(String s, StringPool pool) {
117         if (s == null) {
<span class="line-modified">118             putByte(RecordingInput.STRING_ENCODING_NULL);</span>
119             return;
120         }
121         int length = s.length();
122         if (length == 0) {
<span class="line-modified">123             putByte(RecordingInput.STRING_ENCODING_EMPTY_STRING);</span>
124             return;
125         }
126         if (length &gt; StringPool.MIN_LIMIT &amp;&amp; length &lt; StringPool.MAX_LIMIT) {
127             long l = StringPool.addString(s);
128             if (l &gt; 0) {
<span class="line-modified">129                 putByte(RecordingInput.STRING_ENCODING_CONSTANT_POOL);</span>
130                 putLong(l);
131                 return;
132             }
133         }
134         putStringValue(s);
135         return;
136     }
137 
138     private void putStringValue(String s) {
139         int length = s.length();
140         if (isValidForSize(1 + 5 + 3 * length)) {
<span class="line-modified">141             putUncheckedByte(RecordingInput.STRING_ENCODING_CHAR_ARRAY); // 1 byte</span>
142             putUncheckedInt(length); // max 5 bytes
143             for (int i = 0; i &lt; length; i++) {
144                 putUncheckedChar(s.charAt(i)); // max 3 bytes
145             }
146         }
147     }
148 
149     public void putEventThread() {
150         putLong(threadID);
151     }
152 
153     public void putThread(Thread athread) {
154         if (athread == null) {
155             putLong(0L);
156         } else {
157             putLong(jvm.getThreadId(athread));
158         }
159     }
160 
161     public void putClass(Class&lt;?&gt; aClass) {
</pre>
<hr />
<pre>
180             currentPosition += Integer.BYTES;
181         }
182     }
183 
184     private void reset() {
185         currentPosition = startPosition;
186         if (flushOnEnd) {
187             flushOnEnd = flush();
188         }
189         valid = true;
190         started = false;
191     }
192 
193     private boolean isValidForSize(int requestedSize) {
194         if (!valid) {
195             return false;
196         }
197         if (currentPosition + requestedSize &gt; maxPosition) {
198             flushOnEnd = flush(usedSize(), requestedSize);
199             // retry
<span class="line-modified">200             if (currentPosition + requestedSize &gt; maxPosition) {</span>
<span class="line-removed">201                 Logger.log(LogTag.JFR_SYSTEM,</span>
<span class="line-removed">202                            LogLevel.WARN, () -&gt;</span>
<span class="line-removed">203                                &quot;Unable to commit. Requested size &quot; + requestedSize + &quot; too large&quot;);</span>
<span class="line-removed">204                 valid = false;</span>
205                 return false;
206             }
207         }
208         return true;
209     }
210 
211     private boolean isNotified() {
212         return notified;
213     }
214 
215     private void resetNotified() {
216         notified = false;
217     }
218 
219     private int usedSize() {
220         return (int) (currentPosition - startPosition);
221     }
222 
223     private boolean flush() {
224         return flush(usedSize(), 0);
</pre>
<hr />
<pre>
241     }
242 
243     public boolean endEvent() {
244         if (!valid) {
245             reset();
246             return true;
247         }
248         final int eventSize = usedSize();
249         if (eventSize &gt; maxEventSize) {
250             reset();
251             return true;
252         }
253         Bits.putInt(startPosition, makePaddedInt(eventSize));
254         if (isNotified()) {
255             resetNotified();
256             reset();
257             // returning false will trigger restart of the event write attempt
258             return false;
259         }
260         startPosition = currentPosition;
<span class="line-modified">261         unsafe.putAddress(startPositionAddress, startPosition);</span>

262         // the event is now committed
263         if (flushOnEnd) {
264             flushOnEnd = flush();
265         }
266         started = false;
267         return true;
268     }
269 
270     private EventWriter(long startPos, long maxPos, long startPosAddress, long threadID, boolean valid) {
271         startPosition = currentPosition = startPos;
272         maxPosition = maxPos;
273         startPositionAddress = startPosAddress;
274         this.threadID = threadID;
275         started = false;
276         flushOnEnd = false;
277         this.valid = valid;
278         notified = false;
279         // event may not exceed size for a padded integer
280         maxEventSize = (1 &lt;&lt; 28) -1;
281     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import jdk.internal.misc.Unsafe;
<span class="line-modified"> 29 import jdk.jfr.internal.consumer.StringParser;</span>
 30 
 31 /**
 32  * Class must reside in a package with package restriction.
 33  *
 34  * Users should not have direct access to underlying memory.
 35  *
 36  */
 37 public final class EventWriter {
 38     private static final Unsafe unsafe = Unsafe.getUnsafe();
 39     private final static JVM jvm = JVM.getJVM();
 40 
 41     private long startPosition;
 42     private long startPositionAddress;
 43     private long currentPosition;
 44     private long maxPosition;
 45     private final long threadID;
 46     private PlatformEventType eventType;
 47     private int maxEventSize;
 48     private boolean started;
 49     private boolean valid;
</pre>
<hr />
<pre>
 98     public void putFloat(float i) {
 99         if (isValidForSize(Float.BYTES)) {
100             currentPosition += Bits.putFloat(currentPosition, i);
101         }
102     }
103 
104     public void putLong(long v) {
105         if (isValidForSize(Long.BYTES + 1)) {
106             putUncheckedLong(v);
107         }
108     }
109 
110     public void putDouble(double i) {
111         if (isValidForSize(Double.BYTES)) {
112             currentPosition += Bits.putDouble(currentPosition, i);
113         }
114     }
115 
116     public void putString(String s, StringPool pool) {
117         if (s == null) {
<span class="line-modified">118             putByte(StringParser.Encoding.NULL.byteValue());</span>
119             return;
120         }
121         int length = s.length();
122         if (length == 0) {
<span class="line-modified">123             putByte(StringParser.Encoding.EMPTY_STRING.byteValue());</span>
124             return;
125         }
126         if (length &gt; StringPool.MIN_LIMIT &amp;&amp; length &lt; StringPool.MAX_LIMIT) {
127             long l = StringPool.addString(s);
128             if (l &gt; 0) {
<span class="line-modified">129                 putByte(StringParser.Encoding.CONSTANT_POOL.byteValue());</span>
130                 putLong(l);
131                 return;
132             }
133         }
134         putStringValue(s);
135         return;
136     }
137 
138     private void putStringValue(String s) {
139         int length = s.length();
140         if (isValidForSize(1 + 5 + 3 * length)) {
<span class="line-modified">141             putUncheckedByte(StringParser.Encoding.CHAR_ARRAY.byteValue()); // 1 byte</span>
142             putUncheckedInt(length); // max 5 bytes
143             for (int i = 0; i &lt; length; i++) {
144                 putUncheckedChar(s.charAt(i)); // max 3 bytes
145             }
146         }
147     }
148 
149     public void putEventThread() {
150         putLong(threadID);
151     }
152 
153     public void putThread(Thread athread) {
154         if (athread == null) {
155             putLong(0L);
156         } else {
157             putLong(jvm.getThreadId(athread));
158         }
159     }
160 
161     public void putClass(Class&lt;?&gt; aClass) {
</pre>
<hr />
<pre>
180             currentPosition += Integer.BYTES;
181         }
182     }
183 
184     private void reset() {
185         currentPosition = startPosition;
186         if (flushOnEnd) {
187             flushOnEnd = flush();
188         }
189         valid = true;
190         started = false;
191     }
192 
193     private boolean isValidForSize(int requestedSize) {
194         if (!valid) {
195             return false;
196         }
197         if (currentPosition + requestedSize &gt; maxPosition) {
198             flushOnEnd = flush(usedSize(), requestedSize);
199             // retry
<span class="line-modified">200             if (!valid) {</span>




201                 return false;
202             }
203         }
204         return true;
205     }
206 
207     private boolean isNotified() {
208         return notified;
209     }
210 
211     private void resetNotified() {
212         notified = false;
213     }
214 
215     private int usedSize() {
216         return (int) (currentPosition - startPosition);
217     }
218 
219     private boolean flush() {
220         return flush(usedSize(), 0);
</pre>
<hr />
<pre>
237     }
238 
239     public boolean endEvent() {
240         if (!valid) {
241             reset();
242             return true;
243         }
244         final int eventSize = usedSize();
245         if (eventSize &gt; maxEventSize) {
246             reset();
247             return true;
248         }
249         Bits.putInt(startPosition, makePaddedInt(eventSize));
250         if (isNotified()) {
251             resetNotified();
252             reset();
253             // returning false will trigger restart of the event write attempt
254             return false;
255         }
256         startPosition = currentPosition;
<span class="line-modified">257         unsafe.storeStoreFence();</span>
<span class="line-added">258         unsafe.putAddress(startPositionAddress, currentPosition);</span>
259         // the event is now committed
260         if (flushOnEnd) {
261             flushOnEnd = flush();
262         }
263         started = false;
264         return true;
265     }
266 
267     private EventWriter(long startPos, long maxPos, long startPosAddress, long threadID, boolean valid) {
268         startPosition = currentPosition = startPos;
269         maxPosition = maxPos;
270         startPositionAddress = startPosAddress;
271         this.threadID = threadID;
272         started = false;
273         flushOnEnd = false;
274         this.valid = valid;
275         notified = false;
276         // event may not exceed size for a padded integer
277         maxEventSize = (1 &lt;&lt; 28) -1;
278     }
</pre>
</td>
</tr>
</table>
<center><a href="EventInstrumentation.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="JVM.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RepositoryFiles.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.DirectoryStream;
 30 import java.nio.file.Path;
 31 import java.util.ArrayList;
 32 import java.util.Collections;
 33 import java.util.HashMap;
 34 import java.util.HashSet;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.NavigableMap;
 38 import java.util.Set;
 39 import java.util.SortedMap;
 40 import java.util.TreeMap;
 41 
 42 import jdk.jfr.internal.LogLevel;
 43 import jdk.jfr.internal.LogTag;
 44 import jdk.jfr.internal.Logger;
 45 import jdk.jfr.internal.Repository;
 46 import jdk.jfr.internal.SecuritySupport.SafePath;
 47 
 48 public final class RepositoryFiles {
 49     private static final Object WAIT_OBJECT = new Object();
 50     public static void notifyNewFile() {
 51         synchronized (WAIT_OBJECT) {
 52             WAIT_OBJECT.notifyAll();
 53         }
 54     }
 55 
 56     private final FileAccess fileAccess;
 57     private final NavigableMap&lt;Long, Path&gt; pathSet = new TreeMap&lt;&gt;();
 58     private final Map&lt;Path, Long&gt; pathLookup = new HashMap&lt;&gt;();
 59     private final Path repository;
 60     private final Object waitObject;
 61 
 62     private volatile boolean closed;
 63 
 64     RepositoryFiles(FileAccess fileAccess, Path repository) {
 65         this.repository = repository;
 66         this.fileAccess = fileAccess;
 67         this.waitObject = repository == null ? WAIT_OBJECT : new Object();
 68     }
 69 
 70     long getTimestamp(Path p) {
 71         return pathLookup.get(p);
 72     }
 73 
 74     Path lastPath() {
 75         if (waitForPaths()) {
 76             return pathSet.lastEntry().getValue();
 77         }
 78         return null; // closed
 79     }
 80 
 81     Path firstPath(long startTimeNanos) {
 82         if (waitForPaths()) {
 83             // Pick closest chunk before timestamp
 84             Long time = pathSet.floorKey(startTimeNanos);
 85             if (time != null) {
 86                 startTimeNanos = time;
 87             }
 88             return path(startTimeNanos);
 89         }
 90         return null; // closed
 91     }
 92 
 93     private boolean waitForPaths() {
 94         while (!closed) {
 95             try {
 96                 if (updatePaths()) {
 97                     break;
 98                 }
 99             } catch (IOException e) {
100                 Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG, &quot;IOException during repository file scan &quot; + e.getMessage());
101                 // This can happen if a chunk is being removed
102                 // between the file was discovered and an instance
103                 // was accessed, or if new file has been written yet
104                 // Just ignore, and retry later.
105             }
106             nap();
107         }
108         return !closed;
109     }
110 
111     Path nextPath(long startTimeNanos) {
112         if (closed) {
113             return null;
114         }
115         // Try to get the &#39;exact&#39; path first
116         // to avoid skipping files if repository
117         // is updated while DirectoryStream
118         // is traversing it
119         Path path = pathSet.get(startTimeNanos);
120         if (path != null) {
121             return path;
122         }
123         // Update paths
124         try {
125             updatePaths();
126         } catch (IOException e) {
127             // ignore
128         }
129         // try to get the next file
130         return path(startTimeNanos);
131     }
132 
133     private Path path(long timestamp) {
134         if (closed) {
135             return null;
136         }
137         while (true) {
138             SortedMap&lt;Long, Path&gt; after = pathSet.tailMap(timestamp);
139             if (!after.isEmpty()) {
140                 Path path = after.get(after.firstKey());
141                 if (Logger.shouldLog(LogTag.JFR_SYSTEM_STREAMING, LogLevel.TRACE)) {
142                     Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.TRACE, &quot;Return path &quot; + path + &quot; for start time nanos &quot; + timestamp);
143                 }
144                 return path;
145             }
146             if (!waitForPaths()) {
147                 return null; // closed
148             }
149         }
150     }
151 
152     private void nap() {
153         try {
154             synchronized (waitObject) {
155                 waitObject.wait(1000);
156             }
157         } catch (InterruptedException e) {
158             // ignore
159         }
160     }
161 
162     private boolean updatePaths() throws IOException {
163         boolean foundNew = false;
164         Path repoPath = repository;
165         if (repoPath == null) {
166             // Always get the latest repository if &#39;jcmd JFR.configure
167             // repositorypath=...&#39; has been executed
168             SafePath sf = Repository.getRepository().getRepositoryPath();
169             if (sf == null) {
170                 return false; // not initialized
171             }
172             repoPath = sf.toPath();
173         }
174 
175         try (DirectoryStream&lt;Path&gt; dirStream = fileAccess.newDirectoryStream(repoPath)) {
176             List&lt;Path&gt; added = new ArrayList&lt;&gt;();
177             Set&lt;Path&gt; current = new HashSet&lt;&gt;();
178             for (Path p : dirStream) {
179                 if (!pathLookup.containsKey(p)) {
180                     String s = p.toString();
181                     if (s.endsWith(&quot;.jfr&quot;)) {
182                         added.add(p);
183                         Logger.log(LogTag.JFR_SYSTEM_STREAMING, LogLevel.DEBUG, &quot;New file found: &quot; + p.toAbsolutePath());
184                     }
185                     current.add(p);
186                 }
187             }
188             List&lt;Path&gt; removed = new ArrayList&lt;&gt;();
189             for (Path p : pathLookup.keySet()) {
190                 if (!current.contains(p)) {
191                     removed.add(p);
192                 }
193             }
194 
195             for (Path remove : removed) {
196                 Long time = pathLookup.get(remove);
197                 pathSet.remove(time);
198                 pathLookup.remove(remove);
199             }
200             Collections.sort(added, (p1, p2) -&gt; p1.compareTo(p2));
201             for (Path p : added) {
202                 // Only add files that have a complete header
203                 // as the JVM may be in progress writing the file
204                 long size = fileAccess.fileSize(p);
205                 if (size &gt;= ChunkHeader.headerSize()) {
206                     long startNanos = readStartTime(p);
207                     pathSet.put(startNanos, p);
208                     pathLookup.put(p, startNanos);
209                     foundNew = true;
210                 }
211             }
212             return foundNew;
213         }
214     }
215 
216     private long readStartTime(Path p) throws IOException {
217         try (RecordingInput in = new RecordingInput(p.toFile(), fileAccess, 100)) {
218             Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Parsing header for chunk start time&quot;);
219             ChunkHeader c = new ChunkHeader(in);
220             return c.getStartNanos();
221         }
222     }
223 
224     void close() {
225         synchronized (waitObject) {
226             this.closed = true;
227             waitObject.notify();
228         }
229     }
230 
231     public boolean hasFixedPath() {
232         return repository != null;
233     }
234 }
    </pre>
  </body>
</html>
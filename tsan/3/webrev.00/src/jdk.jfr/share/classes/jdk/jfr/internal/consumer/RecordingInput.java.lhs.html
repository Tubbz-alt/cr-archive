<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RecordingInput.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.DataInput;
 29 import java.io.EOFException;
 30 import java.io.File;
 31 import java.io.IOException;
 32 import java.io.RandomAccessFile;
<a name="2" id="anc2"></a><span class="line-modified"> 33 import java.nio.charset.Charset;</span>
 34 
 35 public final class RecordingInput implements DataInput, AutoCloseable {
 36 
<a name="3" id="anc3"></a><span class="line-modified"> 37     public static final byte STRING_ENCODING_NULL = 0;</span>
<span class="line-removed"> 38     public static final byte STRING_ENCODING_EMPTY_STRING = 1;</span>
<span class="line-removed"> 39     public static final byte STRING_ENCODING_CONSTANT_POOL = 2;</span>
<span class="line-removed"> 40     public static final byte STRING_ENCODING_UTF8_BYTE_ARRAY = 3;</span>
<span class="line-removed"> 41     public static final byte STRING_ENCODING_CHAR_ARRAY = 4;</span>
<span class="line-removed"> 42     public static final byte STRING_ENCODING_LATIN1_BYTE_ARRAY = 5;</span>
<span class="line-removed"> 43 </span>
<span class="line-removed"> 44     private final static int DEFAULT_BLOCK_SIZE = 16 * 1024 * 1024;</span>
<span class="line-removed"> 45     private final static Charset UTF8 = Charset.forName(&quot;UTF-8&quot;);</span>
<span class="line-removed"> 46     private final static Charset LATIN1 = Charset.forName(&quot;ISO-8859-1&quot;);</span>
 47 
 48     private static final class Block {
 49         private byte[] bytes = new byte[0];
 50         private long blockPosition;
<a name="4" id="anc4"></a>
 51 
 52         boolean contains(long position) {
<a name="5" id="anc5"></a><span class="line-modified"> 53             return position &gt;= blockPosition &amp;&amp; position &lt; blockPosition + bytes.length;</span>
 54         }
 55 
 56         public void read(RandomAccessFile file, int amount) throws IOException {
 57             blockPosition = file.getFilePointer();
 58             // reuse byte array, if possible
<a name="6" id="anc6"></a><span class="line-modified"> 59             if (amount != bytes.length) {</span>
 60                 bytes = new byte[amount];
 61             }
<a name="7" id="anc7"></a><span class="line-modified"> 62             file.readFully(bytes);</span>

 63         }
 64 
 65         public byte get(long position) {
 66             return bytes[(int) (position - blockPosition)];
 67         }
<a name="8" id="anc8"></a><span class="line-removed"> 68     }</span>
 69 
<a name="9" id="anc9"></a><span class="line-modified"> 70     private final RandomAccessFile file;</span>
<span class="line-modified"> 71     private final long size;</span>







 72     private Block currentBlock = new Block();
 73     private Block previousBlock = new Block();
 74     private long position;
<a name="10" id="anc10"></a><span class="line-modified"> 75     private final int blockSize;</span>

 76 
<a name="11" id="anc11"></a><span class="line-modified"> 77     private RecordingInput(File f, int blockSize) throws IOException {</span>
<span class="line-removed"> 78         this.size = f.length();</span>
 79         this.blockSize = blockSize;
<a name="12" id="anc12"></a><span class="line-modified"> 80         this.file = new RandomAccessFile(f, &quot;r&quot;);</span>
<span class="line-modified"> 81         if (size &lt; 8) {</span>
<span class="line-modified"> 82             throw new IOException(&quot;Not a valid Flight Recorder file. File length is only &quot; + size + &quot; bytes.&quot;);</span>










 83         }
 84     }
 85 
<a name="13" id="anc13"></a><span class="line-modified"> 86     public RecordingInput(File f) throws IOException {</span>
<span class="line-modified"> 87         this(f, DEFAULT_BLOCK_SIZE);</span>












 88     }
 89 
 90     @Override
 91     public final byte readByte() throws IOException {
 92         if (!currentBlock.contains(position)) {
 93             position(position);
 94         }
 95         return currentBlock.get(position++);
 96     }
 97 
 98     @Override
 99     public final void readFully(byte[] dest, int offset, int length) throws IOException {
100         // TODO: Optimize, use Arrays.copy if all bytes are in current block
101         // array
102         for (int i = 0; i &lt; length; i++) {
103             dest[i + offset] = readByte();
104         }
105     }
106 
107     @Override
108     public final void readFully(byte[] dst) throws IOException {
109         readFully(dst, 0, dst.length);
110     }
111 
<a name="14" id="anc14"></a><span class="line-modified">112     public final short readRawShort() throws IOException {</span>
113         // copied from java.io.Bits
114         byte b0 = readByte();
115         byte b1 = readByte();
116         return (short) ((b1 &amp; 0xFF) + (b0 &lt;&lt; 8));
117     }
118 
119     @Override
<a name="15" id="anc15"></a><span class="line-modified">120     public final double readDouble() throws IOException {</span>
121         // copied from java.io.Bits
122         return Double.longBitsToDouble(readRawLong());
123     }
124 
125     @Override
<a name="16" id="anc16"></a><span class="line-modified">126     public final float readFloat() throws IOException {</span>
127         // copied from java.io.Bits
128         return Float.intBitsToFloat(readRawInt());
129     }
130 
<a name="17" id="anc17"></a><span class="line-modified">131     public final int readRawInt() throws IOException {</span>
132         // copied from java.io.Bits
133         byte b0 = readByte();
134         byte b1 = readByte();
135         byte b2 = readByte();
136         byte b3 = readByte();
137         return ((b3 &amp; 0xFF)) + ((b2 &amp; 0xFF) &lt;&lt; 8) + ((b1 &amp; 0xFF) &lt;&lt; 16) + ((b0) &lt;&lt; 24);
138     }
139 
<a name="18" id="anc18"></a><span class="line-modified">140     public final long readRawLong() throws IOException {</span>
141         // copied from java.io.Bits
142         byte b0 = readByte();
143         byte b1 = readByte();
144         byte b2 = readByte();
145         byte b3 = readByte();
146         byte b4 = readByte();
147         byte b5 = readByte();
148         byte b6 = readByte();
149         byte b7 = readByte();
150         return ((b7 &amp; 0xFFL)) + ((b6 &amp; 0xFFL) &lt;&lt; 8) + ((b5 &amp; 0xFFL) &lt;&lt; 16) + ((b4 &amp; 0xFFL) &lt;&lt; 24) + ((b3 &amp; 0xFFL) &lt;&lt; 32) + ((b2 &amp; 0xFFL) &lt;&lt; 40) + ((b1 &amp; 0xFFL) &lt;&lt; 48) + (((long) b0) &lt;&lt; 56);
151     }
152 
<a name="19" id="anc19"></a><span class="line-modified">153     public final long position() throws IOException {</span>
154         return position;
155     }
156 
157     public final void position(long newPosition) throws IOException {
158         if (!currentBlock.contains(newPosition)) {
159             if (!previousBlock.contains(newPosition)) {
<a name="20" id="anc20"></a><span class="line-modified">160                 if (newPosition &gt; size()) {</span>
<span class="line-modified">161                     throw new EOFException(&quot;Trying to read at &quot; + newPosition + &quot;, but file is only &quot; + size() + &quot; bytes.&quot;);</span>
162                 }
163                 long blockStart = trimToFileSize(calculateBlockStart(newPosition));
164                 file.seek(blockStart);
165                 // trim amount to file size
<a name="21" id="anc21"></a><span class="line-modified">166                 long amount = Math.min(size() - blockStart, blockSize);</span>
167                 previousBlock.read(file, (int) amount);
168             }
169             // swap previous and current
170             Block tmp = currentBlock;
171             currentBlock = previousBlock;
172             previousBlock = tmp;
173         }
174         position = newPosition;
175     }
176 
177     private final long trimToFileSize(long position) throws IOException {
178         return Math.min(size(), Math.max(0, position));
179     }
180 
181     private final long calculateBlockStart(long newPosition) {
182         // align to end of current block
183         if (currentBlock.contains(newPosition - blockSize)) {
184             return currentBlock.blockPosition + currentBlock.bytes.length;
185         }
186         // align before current block
187         if (currentBlock.contains(newPosition + blockSize)) {
188             return currentBlock.blockPosition - blockSize;
189         }
190         // not near current block, pick middle
191         return newPosition - blockSize / 2;
192     }
193 
<a name="22" id="anc22"></a><span class="line-modified">194     public final long size() throws IOException {</span>
195         return size;
196     }
197 
<a name="23" id="anc23"></a><span class="line-modified">198     public final void close() throws IOException {</span>

199         file.close();
200     }
201 
202     @Override
203     public final int skipBytes(int n) throws IOException {
204         long position = position();
205         position(position + n);
206         return (int) (position() - position);
207     }
208 
209     @Override
210     public final boolean readBoolean() throws IOException {
211         return readByte() != 0;
212     }
213 
214     @Override
215     public int readUnsignedByte() throws IOException {
216         return readByte() &amp; 0x00FF;
217     }
218 
219     @Override
220     public int readUnsignedShort() throws IOException {
221         return readShort() &amp; 0xFFFF;
222     }
223 
224     @Override
225     public final String readLine() throws IOException {
226         throw new UnsupportedOperationException();
227     }
228 
229     // NOTE, this method should really be called readString
230     // but can&#39;t be renamed without making RecordingInput a
231     // public class.
232     //
233     // This method DOES Not read as expected (s2 + utf8 encoded character)
234     // instead it read:
235     // byte encoding
236     // int size
237     // data (byte or char)
238     //
239     // where encoding
240     //
241     // 0, means null
242     // 1, means UTF8 encoded byte array
243     // 2, means char array
244     // 3, means latin-1 (ISO-8859-1) encoded byte array
245     // 4, means &quot;&quot;
246     @Override
247     public String readUTF() throws IOException {
<a name="24" id="anc24"></a><span class="line-modified">248         return readEncodedString(readByte());</span>
<span class="line-removed">249     }</span>
<span class="line-removed">250 </span>
<span class="line-removed">251     public String readEncodedString(byte encoding) throws IOException {</span>
<span class="line-removed">252         if (encoding == STRING_ENCODING_NULL) {</span>
<span class="line-removed">253             return null;</span>
<span class="line-removed">254         }</span>
<span class="line-removed">255         if (encoding == STRING_ENCODING_EMPTY_STRING) {</span>
<span class="line-removed">256             return &quot;&quot;;</span>
<span class="line-removed">257         }</span>
<span class="line-removed">258         int size = readInt();</span>
<span class="line-removed">259         if (encoding == STRING_ENCODING_CHAR_ARRAY) {</span>
<span class="line-removed">260             char[] c = new char[size];</span>
<span class="line-removed">261             for (int i = 0; i &lt; size; i++) {</span>
<span class="line-removed">262                 c[i] = readChar();</span>
<span class="line-removed">263             }</span>
<span class="line-removed">264             return new String(c);</span>
<span class="line-removed">265         }</span>
<span class="line-removed">266         byte[] bytes = new byte[size];</span>
<span class="line-removed">267         readFully(bytes); // TODO: optimize, check size, and copy only if needed</span>
<span class="line-removed">268         if (encoding == STRING_ENCODING_UTF8_BYTE_ARRAY) {</span>
<span class="line-removed">269             return new String(bytes, UTF8);</span>
<span class="line-removed">270         }</span>
<span class="line-removed">271 </span>
<span class="line-removed">272         if (encoding == STRING_ENCODING_LATIN1_BYTE_ARRAY) {</span>
<span class="line-removed">273             return new String(bytes, LATIN1);</span>
<span class="line-removed">274         }</span>
<span class="line-removed">275         throw new IOException(&quot;Unknown string encoding &quot; + encoding);</span>
276     }
277 
278     @Override
279     public char readChar() throws IOException {
280         return (char) readLong();
281     }
282 
283     @Override
284     public short readShort() throws IOException {
285         return (short) readLong();
286     }
287 
288     @Override
289     public int readInt() throws IOException {
290         return (int) readLong();
291     }
292 
293     @Override
294     public long readLong() throws IOException {
<a name="25" id="anc25"></a><span class="line-modified">295         // can be optimized by branching checks, but will do for now</span>




























































296         byte b0 = readByte();
297         long ret = (b0 &amp; 0x7FL);
298         if (b0 &gt;= 0) {
299             return ret;
300         }
<a name="26" id="anc26"></a>
301         int b1 = readByte();
302         ret += (b1 &amp; 0x7FL) &lt;&lt; 7;
303         if (b1 &gt;= 0) {
304             return ret;
305         }
<a name="27" id="anc27"></a>
306         int b2 = readByte();
307         ret += (b2 &amp; 0x7FL) &lt;&lt; 14;
308         if (b2 &gt;= 0) {
309             return ret;
310         }
<a name="28" id="anc28"></a>
311         int b3 = readByte();
312         ret += (b3 &amp; 0x7FL) &lt;&lt; 21;
313         if (b3 &gt;= 0) {
314             return ret;
315         }
<a name="29" id="anc29"></a>
316         int b4 = readByte();
317         ret += (b4 &amp; 0x7FL) &lt;&lt; 28;
318         if (b4 &gt;= 0) {
319             return ret;
320         }
<a name="30" id="anc30"></a>
321         int b5 = readByte();
322         ret += (b5 &amp; 0x7FL) &lt;&lt; 35;
323         if (b5 &gt;= 0) {
324             return ret;
325         }
<a name="31" id="anc31"></a>
326         int b6 = readByte();
327         ret += (b6 &amp; 0x7FL) &lt;&lt; 42;
328         if (b6 &gt;= 0) {
329             return ret;
330         }
<a name="32" id="anc32"></a>
331         int b7 = readByte();
332         ret += (b7 &amp; 0x7FL) &lt;&lt; 49;
333         if (b7 &gt;= 0) {
334             return ret;
<a name="33" id="anc33"></a>
335         }
<a name="34" id="anc34"></a>
336         int b8 = readByte(); // read last byte raw
337         return ret + (((long) (b8 &amp; 0XFF)) &lt;&lt; 56);
338     }
<a name="35" id="anc35"></a>


































339 }
<a name="36" id="anc36"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="36" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordedObject.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="RecordedMethod.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RecordedStackTrace.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordedObject.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.consumer;
 27 

 28 import java.io.PrintWriter;
 29 import java.io.StringWriter;
 30 import java.time.Duration;
 31 import java.time.Instant;
 32 import java.time.OffsetDateTime;

 33 import java.util.List;
 34 import java.util.Objects;
 35 
 36 import jdk.jfr.Timespan;
 37 import jdk.jfr.Timestamp;
 38 import jdk.jfr.ValueDescriptor;


 39 import jdk.jfr.internal.PrivateAccess;


 40 import jdk.jfr.internal.tool.PrettyWriter;
 41 
 42 /**
 43  * A complex data type that consists of one or more fields.
 44  * &lt;p&gt;
 45  * This class provides methods to select and query nested objects by passing a
 46  * dot {@code &quot;.&quot;} delimited {@code String} object (for instance,
 47  * {@code &quot;aaa.bbb&quot;}). A method evaluates a nested object from left to right,
 48  * and if a part is {@code null}, it throws {@code NullPointerException}.
 49  *
 50  * @since 9
 51  */
 52 public class RecordedObject {
 53 



















































































 54     private final static class UnsignedValue {
 55         private final Object o;
 56 
 57         UnsignedValue(Object o) {
 58             this.o = o;
 59         }
 60 
 61         Object value() {
 62             return o;
 63         }
 64     }
 65 
<span class="line-modified"> 66     private final Object[] objects;</span>
<span class="line-modified"> 67     private final List&lt;ValueDescriptor&gt; descriptors;</span>
<span class="line-removed"> 68     private final TimeConverter timeConverter;</span>
 69 
 70     // package private, not to be subclassed outside this package
<span class="line-modified"> 71     RecordedObject(List&lt;ValueDescriptor&gt; descriptors, Object[] objects, TimeConverter timeConverter) {</span>
<span class="line-modified"> 72         this.descriptors = descriptors;</span>
 73         this.objects = objects;
<span class="line-removed"> 74         this.timeConverter = timeConverter;</span>
 75     }
 76 
 77     // package private
 78     final &lt;T&gt; T getTyped(String name, Class&lt;T&gt; clazz, T defaultValue) {
 79         // Unnecessary to check field presence twice, but this
 80         // will do for now.
 81         if (!hasField(name)) {
 82             return defaultValue;
 83         }
 84         T object = getValue(name);
 85         if (object == null || object.getClass().isAssignableFrom(clazz)) {
 86             return object;
 87         } else {
 88             return defaultValue;
 89         }
 90     }
 91 
 92     /**
 93      * Returns {@code true} if a field with the given name exists, {@code false}
 94      * otherwise.
 95      *
 96      * @param name name of the field to get, not {@code null}
 97      *
 98      * @return {@code true} if the field exists, {@code false} otherwise.
 99      *
100      * @see #getFields()
101      */
102     public boolean hasField(String name) {
103         Objects.requireNonNull(name);
<span class="line-modified">104         for (ValueDescriptor v : descriptors) {</span>
105             if (v.getName().equals(name)) {
106                 return true;
107             }
108         }
109         int dotIndex = name.indexOf(&quot;.&quot;);
110         if (dotIndex &gt; 0) {
111             String structName = name.substring(0, dotIndex);
<span class="line-modified">112             for (ValueDescriptor v : descriptors) {</span>
113                 if (!v.getFields().isEmpty() &amp;&amp; v.getName().equals(structName)) {
114                     RecordedObject child = getValue(structName);
115                     if (child != null) {
116                         return child.hasField(name.substring(dotIndex + 1));
117                     }
118                 }
119             }
120         }
121         return false;
122     }
123 
124     /**
125      * Returns the value of the field with the given name.
126      * &lt;p&gt;
127      * The return type may be a primitive type or a subclass of
128      * {@link RecordedObject}.
129      * &lt;p&gt;
130      * It&#39;s possible to index into a nested object by using {@code &quot;.&quot;} (for
131      * instance {@code &quot;thread.group.parent.name}&quot;).
132      * &lt;p&gt;
</pre>
<hr />
<pre>
152      *   System.out.println(&quot;Sampled thread: &quot; + sampledThread.getName());
153      * }
154      * &lt;/code&gt;
155      * &lt;/pre&gt;
156      *
157      * @param &lt;T&gt; the return type
158      * @param  name of the field to get, not {@code null}
159      * @throws IllegalArgumentException if no field called {@code name} exists
160      *
161      * @return the value, can be {@code null}
162      *
163      * @see #hasField(String)
164      *
165      */
166     final public &lt;T&gt; T getValue(String name) {
167         @SuppressWarnings(&quot;unchecked&quot;)
168         T t = (T) getValue(name, false);
169         return t;
170     }
171 




172     private Object getValue(String name, boolean allowUnsigned) {
173         Objects.requireNonNull(name);
174         int index = 0;
<span class="line-modified">175         for (ValueDescriptor v : descriptors) {</span>
176             if (name.equals(v.getName())) {
<span class="line-modified">177                 Object object = objects[index];</span>
178                 if (object == null) {
179                     // error or missing
180                     return null;
181                 }
182                 if (v.getFields().isEmpty()) {
183                     if (allowUnsigned &amp;&amp; PrivateAccess.getInstance().isUnsigned(v)) {
184                         // Types that are meaningless to widen
185                         if (object instanceof Character || object instanceof Long) {
186                             return object;
187                         }
188                         return new UnsignedValue(object);
189                     }
190                     return object; // primitives and primitive arrays
191                 } else {
192                     if (object instanceof RecordedObject) {
193                         // known types from factory
194                         return object;
195                     }
196                     // must be array type
197                     Object[] array = (Object[]) object;
198                     if (v.isArray()) {
199                         // struct array
200                         return structifyArray(v, array, 0);
201                     }
202                     // struct
<span class="line-modified">203                     return new RecordedObject(v.getFields(), (Object[]) object, timeConverter);</span>
204                 }
205             }
206             index++;
207         }
208 
209         int dotIndex = name.indexOf(&quot;.&quot;);
210         if (dotIndex &gt; 0) {
211             String structName = name.substring(0, dotIndex);
<span class="line-modified">212             for (ValueDescriptor v : descriptors) {</span>
213                 if (!v.getFields().isEmpty() &amp;&amp; v.getName().equals(structName)) {
214                     RecordedObject child = getValue(structName);
215                     String subName = name.substring(dotIndex + 1);
216                     if (child != null) {
217                         return child.getValue(subName, allowUnsigned);
218                     } else {
219                         // Call getValueDescriptor to trigger IllegalArgumentException if the name is
220                         // incorrect. Type can&#39;t be validate due to type erasure
221                         getValueDescriptor(v.getFields(), subName, null);
222                         throw new NullPointerException(&quot;Field value for \&quot;&quot; + structName + &quot;\&quot; was null. Can&#39;t access nested field \&quot;&quot; + subName + &quot;\&quot;&quot;);
223                     }
224                 }
225             }
226         }
227         throw new IllegalArgumentException(&quot;Could not find field with name &quot; + name);
228     }
229 
230     // Returns the leaf value descriptor matches both name or value, or throws an
231     // IllegalArgumentException
232     private ValueDescriptor getValueDescriptor(List&lt;ValueDescriptor&gt; descriptors, String name, String leafType) {
</pre>
<hr />
<pre>
244             }
245             throw new IllegalArgumentException(&quot;Attempt to get unknown field \&quot;&quot; + first + &quot;\&quot;&quot;);
246         }
247         for (ValueDescriptor v : descriptors) {
248             if (v.getName().equals(name)) {
249                 if (leafType != null &amp;&amp; !v.getTypeName().equals(leafType)) {
250                     throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal data type conversion &quot; + leafType);
251                 }
252                 return v;
253             }
254         }
255         throw new IllegalArgumentException(&quot;\&quot;Attempt to get unknown field \&quot;&quot; + name + &quot;\&quot;&quot;);
256     }
257 
258     // Gets a value, but checks that type and name is correct first
259     // This is to prevent a call to getString on a thread field, that is
260     // null to succeed.
261     private &lt;T&gt; T getTypedValue(String name, String typeName) {
262         Objects.requireNonNull(name);
263         // Validate name and type first
<span class="line-modified">264         getValueDescriptor(descriptors, name, typeName);</span>
265         return getValue(name);
266     }
267 
268     private Object[] structifyArray(ValueDescriptor v, Object[] array, int dimension) {
269         if (array == null) {
270             return null;
271         }
272         Object[] structArray = new Object[array.length];

273         for (int i = 0; i &lt; structArray.length; i++) {
274             Object arrayElement = array[i];
275             if (dimension == 0) {
276                 // No general way to handle structarrays
277                 // without invoking ObjectFactory for every instance (which may require id)
278                 if (isStackFrameType(v.getTypeName())) {
<span class="line-modified">279                     structArray[i] = new RecordedFrame(v.getFields(), (Object[]) arrayElement, timeConverter);</span>
280                 } else {
<span class="line-modified">281                     structArray[i] = new RecordedObject(v.getFields(), (Object[]) arrayElement, timeConverter);</span>
282                 }
283             } else {
284                 structArray[i] = structifyArray(v, (Object[]) arrayElement, dimension - 1);
285             }
286         }
287         return structArray;
288     }
289 
290     private boolean isStackFrameType(String typeName) {
291         if (ObjectFactory.STACK_FRAME_VERSION_1.equals(typeName)) {
292             return true;
293         }
294         if (ObjectFactory.STACK_FRAME_VERSION_2.equals(typeName)) {
295             return true;
296         }
297         return false;
298     }
299 
300     /**
301      * Returns an immutable list of the fields for this object.
302      *
303      * @return the fields, not {@code null}
304      */
305     public List&lt;ValueDescriptor&gt; getFields() {
<span class="line-modified">306         return descriptors;</span>
307     }
308 
309     /**
310      * Returns the value of a field of type {@code boolean}.
311      * &lt;p&gt;
312      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
313      * {@code &quot;aaa.bbb&quot;}).
314      * &lt;p&gt;
315      * A field might change or be removed in a future JDK release. A best practice
316      * for callers of this method is to validate the field before attempting access.
317      *
318      * @param name name of the field to get, not {@code null}
319      *
320      * @return the value of the field, {@code true} or {@code false}
321      *
322      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field is
323      *         not of type {@code boolean}
324      *
325      * @see #hasField(String)
326      * @see #getValue(String)
</pre>
<hr />
<pre>
708         }
709         if (o instanceof Byte) {
710             return getDuration(((Byte) o).longValue(), name);
711         }
712         if (o instanceof UnsignedValue) {
713             Object u = ((UnsignedValue) o).value();
714             if (u instanceof Integer) {
715                 return getDuration(Integer.toUnsignedLong((Integer) u), name);
716             }
717             if (u instanceof Short) {
718                 return getDuration(Short.toUnsignedLong((Short) u), name);
719             }
720             if (u instanceof Byte) {
721                 return getDuration(Short.toUnsignedLong((Byte) u), name);
722             }
723         }
724         throw newIllegalArgumentException(name, &quot;java,time.Duration&quot;);
725     }
726 
727     private Duration getDuration(long timespan, String name) throws InternalError {
<span class="line-modified">728         ValueDescriptor v = getValueDescriptor(descriptors, name, null);</span>
729         if (timespan == Long.MIN_VALUE) {
730             return Duration.ofSeconds(Long.MIN_VALUE, 0);
731         }
732         Timespan ts = v.getAnnotation(Timespan.class);
733         if (ts != null) {
734             switch (ts.value()) {
735             case Timespan.MICROSECONDS:
736                 return Duration.ofNanos(1000 * timespan);
737             case Timespan.SECONDS:
738                 return Duration.ofSeconds(timespan);
739             case Timespan.MILLISECONDS:
740                 return Duration.ofMillis(timespan);
741             case Timespan.NANOSECONDS:
742                 return Duration.ofNanos(timespan);
743             case Timespan.TICKS:
<span class="line-modified">744                 return Duration.ofNanos(timeConverter.convertTimespan(timespan));</span>
745             }
746             throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal timespan unit &quot; + ts.value());
747         }
748         throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with missing @Timespan&quot;);
749     }
750 
751     /**
752      * Returns the value of a timestamp field.
753      * &lt;p&gt;
754      * This method can be used on fields annotated with {@code @Timestamp}, and of
755      * the following types: {@code long}, {@code int}, {@code short}, {@code char}
756      * and {@code byte}.
757      * &lt;p&gt;
758      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
759      * {@code &quot;aaa.bbb&quot;}).
760      * &lt;p&gt;
761      * A field might change or be removed in a future JDK release. A best practice
762      * for callers of this method is to validate the field before attempting access.
763      *
764      * @param name of the field to get, not {@code null}
</pre>
<hr />
<pre>
787         }
788         if (o instanceof Byte) {
789             return getInstant(((Byte) o).longValue(), name);
790         }
791         if (o instanceof UnsignedValue) {
792             Object u = ((UnsignedValue) o).value();
793             if (u instanceof Integer) {
794                 return getInstant(Integer.toUnsignedLong((Integer) u), name);
795             }
796             if (u instanceof Short) {
797                 return getInstant(Short.toUnsignedLong((Short) u), name);
798             }
799             if (u instanceof Byte) {
800                 return getInstant(Short.toUnsignedLong((Byte) u), name);
801             }
802         }
803         throw newIllegalArgumentException(name, &quot;java.time.Instant&quot;);
804     }
805 
806     private Instant getInstant(long timestamp, String name) {
<span class="line-modified">807         ValueDescriptor v = getValueDescriptor(descriptors, name, null);</span>
808         Timestamp ts = v.getAnnotation(Timestamp.class);
809         if (ts != null) {
810             if (timestamp == Long.MIN_VALUE) {
811                 return Instant.MIN;
812             }
813             switch (ts.value()) {
814             case Timestamp.MILLISECONDS_SINCE_EPOCH:
815                 return Instant.ofEpochMilli(timestamp);
816             case Timestamp.TICKS:
<span class="line-modified">817                 return Instant.ofEpochSecond(0, timeConverter.convertTimestamp(timestamp));</span>
818             }
819             throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal timestamp unit &quot; + ts.value());
820         }
821         throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with missing @Timestamp&quot;);
822     }
823 
824     /**
825      * Returns the value of a field of type {@code Class}.
826      * &lt;p&gt;
827      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
828      * {@code &quot;aaa.bbb&quot;}).
829      * &lt;p&gt;
830      * A field might change or be removed in a future JDK release. A best practice
831      * for callers of this method is to validate the field before attempting access.
832      *
833      * @param name of the field to get, not {@code null}
834      *
835      * @return the value of the field as a {@code RecordedClass}, can be
836      *         {@code null}
837      *
</pre>
<hr />
<pre>
872     /**
873      * Returns a textual representation of this object.
874      *
875      * @return textual description of this object
876      */
877     @Override
878     final public String toString() {
879         StringWriter s = new StringWriter();
880         PrettyWriter p = new PrettyWriter(new PrintWriter(s));
881         p.setStackDepth(5);
882         if (this instanceof RecordedEvent) {
883             p.print((RecordedEvent) this);
884         } else {
885             p.print(this, &quot;&quot;);
886         }
887         p.flush(true);
888         return s.toString();
889     }
890 
891     // package private for now. Used by EventWriter
<span class="line-modified">892     OffsetDateTime getOffsetDateTime(String name) {</span>
893         Instant instant = getInstant(name);
894         if (instant.equals(Instant.MIN)) {
895             return OffsetDateTime.MIN;
896         }
<span class="line-modified">897         return OffsetDateTime.ofInstant(getInstant(name), timeConverter.getZoneOffset());</span>
898     }
899 
900     private static IllegalArgumentException newIllegalArgumentException(String name, String typeName) {
901         return new IllegalArgumentException(&quot;Attempt to get field \&quot;&quot; + name + &quot;\&quot; with illegal data type conversion &quot; + typeName);
902     }
903 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.consumer;
 27 
<span class="line-added"> 28 import java.io.IOException;</span>
 29 import java.io.PrintWriter;
 30 import java.io.StringWriter;
 31 import java.time.Duration;
 32 import java.time.Instant;
 33 import java.time.OffsetDateTime;
<span class="line-added"> 34 import java.util.Comparator;</span>
 35 import java.util.List;
 36 import java.util.Objects;
 37 
 38 import jdk.jfr.Timespan;
 39 import jdk.jfr.Timestamp;
 40 import jdk.jfr.ValueDescriptor;
<span class="line-added"> 41 import jdk.jfr.internal.consumer.JdkJfrConsumer;</span>
<span class="line-added"> 42 import jdk.jfr.internal.consumer.ObjectFactory;</span>
 43 import jdk.jfr.internal.PrivateAccess;
<span class="line-added"> 44 import jdk.jfr.internal.Type;</span>
<span class="line-added"> 45 import jdk.jfr.internal.consumer.ObjectContext;</span>
 46 import jdk.jfr.internal.tool.PrettyWriter;
 47 
 48 /**
 49  * A complex data type that consists of one or more fields.
 50  * &lt;p&gt;
 51  * This class provides methods to select and query nested objects by passing a
 52  * dot {@code &quot;.&quot;} delimited {@code String} object (for instance,
 53  * {@code &quot;aaa.bbb&quot;}). A method evaluates a nested object from left to right,
 54  * and if a part is {@code null}, it throws {@code NullPointerException}.
 55  *
 56  * @since 9
 57  */
 58 public class RecordedObject {
 59 
<span class="line-added"> 60     static{</span>
<span class="line-added"> 61         JdkJfrConsumer access = new JdkJfrConsumer() {</span>
<span class="line-added"> 62             public List&lt;Type&gt; readTypes(RecordingFile file) throws IOException {</span>
<span class="line-added"> 63                 return file.readTypes();</span>
<span class="line-added"> 64             }</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66             public boolean isLastEventInChunk(RecordingFile file) {</span>
<span class="line-added"> 67                 return file.isLastEventInChunk();</span>
<span class="line-added"> 68             }</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70             @Override</span>
<span class="line-added"> 71             public Object getOffsetDataTime(RecordedObject event, String name) {</span>
<span class="line-added"> 72                 return event.getOffsetDateTime(name);</span>
<span class="line-added"> 73             }</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75             @Override</span>
<span class="line-added"> 76             public RecordedClass newRecordedClass(ObjectContext objectContext, long id, Object[] values) {</span>
<span class="line-added"> 77                 return new RecordedClass(objectContext, id, values);</span>
<span class="line-added"> 78             }</span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80             @Override</span>
<span class="line-added"> 81             public RecordedClassLoader newRecordedClassLoader(ObjectContext objectContext, long id, Object[] values) {</span>
<span class="line-added"> 82                 return new RecordedClassLoader(objectContext, id, values);</span>
<span class="line-added"> 83             }</span>
<span class="line-added"> 84 </span>
<span class="line-added"> 85             @Override</span>
<span class="line-added"> 86             public Comparator&lt;? super RecordedEvent&gt; eventComparator() {</span>
<span class="line-added"> 87                 return new Comparator&lt;RecordedEvent&gt;()  {</span>
<span class="line-added"> 88                     @Override</span>
<span class="line-added"> 89                     public int compare(RecordedEvent e1, RecordedEvent e2) {</span>
<span class="line-added"> 90                         return Long.compare(e1.endTimeTicks, e2.endTimeTicks);</span>
<span class="line-added"> 91                     }</span>
<span class="line-added"> 92                 };</span>
<span class="line-added"> 93             }</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95             @Override</span>
<span class="line-added"> 96             public RecordedStackTrace newRecordedStackTrace(ObjectContext objectContext, Object[] values) {</span>
<span class="line-added"> 97                 return new RecordedStackTrace(objectContext, values);</span>
<span class="line-added"> 98             }</span>
<span class="line-added"> 99 </span>
<span class="line-added">100             @Override</span>
<span class="line-added">101             public RecordedThreadGroup newRecordedThreadGroup(ObjectContext objectContext, Object[] values) {</span>
<span class="line-added">102                 return new RecordedThreadGroup(objectContext, values);</span>
<span class="line-added">103             }</span>
<span class="line-added">104 </span>
<span class="line-added">105             @Override</span>
<span class="line-added">106             public RecordedFrame newRecordedFrame(ObjectContext objectContext, Object[] values) {</span>
<span class="line-added">107                 return new RecordedFrame(objectContext, values);</span>
<span class="line-added">108             }</span>
<span class="line-added">109 </span>
<span class="line-added">110             @Override</span>
<span class="line-added">111             public RecordedThread newRecordedThread(ObjectContext objectContext, long id, Object[] values) {</span>
<span class="line-added">112                 return new RecordedThread(objectContext, id, values);</span>
<span class="line-added">113             }</span>
<span class="line-added">114 </span>
<span class="line-added">115             @Override</span>
<span class="line-added">116             public RecordedMethod newRecordedMethod(ObjectContext objectContext, Object[] values) {</span>
<span class="line-added">117                 return new RecordedMethod(objectContext, values);</span>
<span class="line-added">118             }</span>
<span class="line-added">119 </span>
<span class="line-added">120             @Override</span>
<span class="line-added">121             public RecordedEvent newRecordedEvent(ObjectContext objectContext, Object[] values, long startTimeTicks, long endTimeTicks) {</span>
<span class="line-added">122                 return new RecordedEvent(objectContext, values, startTimeTicks, endTimeTicks);</span>
<span class="line-added">123             }</span>
<span class="line-added">124 </span>
<span class="line-added">125             @Override</span>
<span class="line-added">126             public void setStartTicks(RecordedEvent event, long startTicks) {</span>
<span class="line-added">127                event.startTimeTicks = startTicks;</span>
<span class="line-added">128             }</span>
<span class="line-added">129 </span>
<span class="line-added">130             @Override</span>
<span class="line-added">131             public void setEndTicks(RecordedEvent event, long endTicks) {</span>
<span class="line-added">132                event.endTimeTicks = endTicks;</span>
<span class="line-added">133             }</span>
<span class="line-added">134 </span>
<span class="line-added">135             @Override</span>
<span class="line-added">136             public Object[] eventValues(RecordedEvent event) {</span>
<span class="line-added">137                 return event.objects;</span>
<span class="line-added">138             }</span>
<span class="line-added">139         };</span>
<span class="line-added">140         JdkJfrConsumer.setAccess(access);</span>
<span class="line-added">141     }</span>
<span class="line-added">142 </span>
143     private final static class UnsignedValue {
144         private final Object o;
145 
146         UnsignedValue(Object o) {
147             this.o = o;
148         }
149 
150         Object value() {
151             return o;
152         }
153     }
154 
<span class="line-modified">155     final Object[] objects;</span>
<span class="line-modified">156     final ObjectContext objectContext;</span>

157 
158     // package private, not to be subclassed outside this package
<span class="line-modified">159     RecordedObject(ObjectContext objectContext, Object[] objects) {</span>
<span class="line-modified">160         this.objectContext = objectContext;</span>
161         this.objects = objects;

162     }
163 
164     // package private
165     final &lt;T&gt; T getTyped(String name, Class&lt;T&gt; clazz, T defaultValue) {
166         // Unnecessary to check field presence twice, but this
167         // will do for now.
168         if (!hasField(name)) {
169             return defaultValue;
170         }
171         T object = getValue(name);
172         if (object == null || object.getClass().isAssignableFrom(clazz)) {
173             return object;
174         } else {
175             return defaultValue;
176         }
177     }
178 
179     /**
180      * Returns {@code true} if a field with the given name exists, {@code false}
181      * otherwise.
182      *
183      * @param name name of the field to get, not {@code null}
184      *
185      * @return {@code true} if the field exists, {@code false} otherwise.
186      *
187      * @see #getFields()
188      */
189     public boolean hasField(String name) {
190         Objects.requireNonNull(name);
<span class="line-modified">191         for (ValueDescriptor v : objectContext.fields) {</span>
192             if (v.getName().equals(name)) {
193                 return true;
194             }
195         }
196         int dotIndex = name.indexOf(&quot;.&quot;);
197         if (dotIndex &gt; 0) {
198             String structName = name.substring(0, dotIndex);
<span class="line-modified">199             for (ValueDescriptor v : objectContext.fields) {</span>
200                 if (!v.getFields().isEmpty() &amp;&amp; v.getName().equals(structName)) {
201                     RecordedObject child = getValue(structName);
202                     if (child != null) {
203                         return child.hasField(name.substring(dotIndex + 1));
204                     }
205                 }
206             }
207         }
208         return false;
209     }
210 
211     /**
212      * Returns the value of the field with the given name.
213      * &lt;p&gt;
214      * The return type may be a primitive type or a subclass of
215      * {@link RecordedObject}.
216      * &lt;p&gt;
217      * It&#39;s possible to index into a nested object by using {@code &quot;.&quot;} (for
218      * instance {@code &quot;thread.group.parent.name}&quot;).
219      * &lt;p&gt;
</pre>
<hr />
<pre>
239      *   System.out.println(&quot;Sampled thread: &quot; + sampledThread.getName());
240      * }
241      * &lt;/code&gt;
242      * &lt;/pre&gt;
243      *
244      * @param &lt;T&gt; the return type
245      * @param  name of the field to get, not {@code null}
246      * @throws IllegalArgumentException if no field called {@code name} exists
247      *
248      * @return the value, can be {@code null}
249      *
250      * @see #hasField(String)
251      *
252      */
253     final public &lt;T&gt; T getValue(String name) {
254         @SuppressWarnings(&quot;unchecked&quot;)
255         T t = (T) getValue(name, false);
256         return t;
257     }
258 
<span class="line-added">259     protected Object objectAt(int index) {</span>
<span class="line-added">260         return objects[index];</span>
<span class="line-added">261     }</span>
<span class="line-added">262 </span>
263     private Object getValue(String name, boolean allowUnsigned) {
264         Objects.requireNonNull(name);
265         int index = 0;
<span class="line-modified">266         for (ValueDescriptor v : objectContext.fields) {</span>
267             if (name.equals(v.getName())) {
<span class="line-modified">268                 Object object = objectAt(index);</span>
269                 if (object == null) {
270                     // error or missing
271                     return null;
272                 }
273                 if (v.getFields().isEmpty()) {
274                     if (allowUnsigned &amp;&amp; PrivateAccess.getInstance().isUnsigned(v)) {
275                         // Types that are meaningless to widen
276                         if (object instanceof Character || object instanceof Long) {
277                             return object;
278                         }
279                         return new UnsignedValue(object);
280                     }
281                     return object; // primitives and primitive arrays
282                 } else {
283                     if (object instanceof RecordedObject) {
284                         // known types from factory
285                         return object;
286                     }
287                     // must be array type
288                     Object[] array = (Object[]) object;
289                     if (v.isArray()) {
290                         // struct array
291                         return structifyArray(v, array, 0);
292                     }
293                     // struct
<span class="line-modified">294                     return new RecordedObject(objectContext.getInstance(v), (Object[]) object);</span>
295                 }
296             }
297             index++;
298         }
299 
300         int dotIndex = name.indexOf(&quot;.&quot;);
301         if (dotIndex &gt; 0) {
302             String structName = name.substring(0, dotIndex);
<span class="line-modified">303             for (ValueDescriptor v : objectContext.fields) {</span>
304                 if (!v.getFields().isEmpty() &amp;&amp; v.getName().equals(structName)) {
305                     RecordedObject child = getValue(structName);
306                     String subName = name.substring(dotIndex + 1);
307                     if (child != null) {
308                         return child.getValue(subName, allowUnsigned);
309                     } else {
310                         // Call getValueDescriptor to trigger IllegalArgumentException if the name is
311                         // incorrect. Type can&#39;t be validate due to type erasure
312                         getValueDescriptor(v.getFields(), subName, null);
313                         throw new NullPointerException(&quot;Field value for \&quot;&quot; + structName + &quot;\&quot; was null. Can&#39;t access nested field \&quot;&quot; + subName + &quot;\&quot;&quot;);
314                     }
315                 }
316             }
317         }
318         throw new IllegalArgumentException(&quot;Could not find field with name &quot; + name);
319     }
320 
321     // Returns the leaf value descriptor matches both name or value, or throws an
322     // IllegalArgumentException
323     private ValueDescriptor getValueDescriptor(List&lt;ValueDescriptor&gt; descriptors, String name, String leafType) {
</pre>
<hr />
<pre>
335             }
336             throw new IllegalArgumentException(&quot;Attempt to get unknown field \&quot;&quot; + first + &quot;\&quot;&quot;);
337         }
338         for (ValueDescriptor v : descriptors) {
339             if (v.getName().equals(name)) {
340                 if (leafType != null &amp;&amp; !v.getTypeName().equals(leafType)) {
341                     throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal data type conversion &quot; + leafType);
342                 }
343                 return v;
344             }
345         }
346         throw new IllegalArgumentException(&quot;\&quot;Attempt to get unknown field \&quot;&quot; + name + &quot;\&quot;&quot;);
347     }
348 
349     // Gets a value, but checks that type and name is correct first
350     // This is to prevent a call to getString on a thread field, that is
351     // null to succeed.
352     private &lt;T&gt; T getTypedValue(String name, String typeName) {
353         Objects.requireNonNull(name);
354         // Validate name and type first
<span class="line-modified">355         getValueDescriptor(objectContext.fields, name, typeName);</span>
356         return getValue(name);
357     }
358 
359     private Object[] structifyArray(ValueDescriptor v, Object[] array, int dimension) {
360         if (array == null) {
361             return null;
362         }
363         Object[] structArray = new Object[array.length];
<span class="line-added">364         ObjectContext objContext = objectContext.getInstance(v);</span>
365         for (int i = 0; i &lt; structArray.length; i++) {
366             Object arrayElement = array[i];
367             if (dimension == 0) {
368                 // No general way to handle structarrays
369                 // without invoking ObjectFactory for every instance (which may require id)
370                 if (isStackFrameType(v.getTypeName())) {
<span class="line-modified">371                     structArray[i] = new RecordedFrame(objContext, (Object[]) arrayElement);</span>
372                 } else {
<span class="line-modified">373                     structArray[i] = new RecordedObject(objContext, (Object[]) arrayElement);</span>
374                 }
375             } else {
376                 structArray[i] = structifyArray(v, (Object[]) arrayElement, dimension - 1);
377             }
378         }
379         return structArray;
380     }
381 
382     private boolean isStackFrameType(String typeName) {
383         if (ObjectFactory.STACK_FRAME_VERSION_1.equals(typeName)) {
384             return true;
385         }
386         if (ObjectFactory.STACK_FRAME_VERSION_2.equals(typeName)) {
387             return true;
388         }
389         return false;
390     }
391 
392     /**
393      * Returns an immutable list of the fields for this object.
394      *
395      * @return the fields, not {@code null}
396      */
397     public List&lt;ValueDescriptor&gt; getFields() {
<span class="line-modified">398         return objectContext.fields;</span>
399     }
400 
401     /**
402      * Returns the value of a field of type {@code boolean}.
403      * &lt;p&gt;
404      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
405      * {@code &quot;aaa.bbb&quot;}).
406      * &lt;p&gt;
407      * A field might change or be removed in a future JDK release. A best practice
408      * for callers of this method is to validate the field before attempting access.
409      *
410      * @param name name of the field to get, not {@code null}
411      *
412      * @return the value of the field, {@code true} or {@code false}
413      *
414      * @throws IllegalArgumentException if the field doesn&#39;t exist, or the field is
415      *         not of type {@code boolean}
416      *
417      * @see #hasField(String)
418      * @see #getValue(String)
</pre>
<hr />
<pre>
800         }
801         if (o instanceof Byte) {
802             return getDuration(((Byte) o).longValue(), name);
803         }
804         if (o instanceof UnsignedValue) {
805             Object u = ((UnsignedValue) o).value();
806             if (u instanceof Integer) {
807                 return getDuration(Integer.toUnsignedLong((Integer) u), name);
808             }
809             if (u instanceof Short) {
810                 return getDuration(Short.toUnsignedLong((Short) u), name);
811             }
812             if (u instanceof Byte) {
813                 return getDuration(Short.toUnsignedLong((Byte) u), name);
814             }
815         }
816         throw newIllegalArgumentException(name, &quot;java,time.Duration&quot;);
817     }
818 
819     private Duration getDuration(long timespan, String name) throws InternalError {
<span class="line-modified">820         ValueDescriptor v = getValueDescriptor(objectContext.fields, name, null);</span>
821         if (timespan == Long.MIN_VALUE) {
822             return Duration.ofSeconds(Long.MIN_VALUE, 0);
823         }
824         Timespan ts = v.getAnnotation(Timespan.class);
825         if (ts != null) {
826             switch (ts.value()) {
827             case Timespan.MICROSECONDS:
828                 return Duration.ofNanos(1000 * timespan);
829             case Timespan.SECONDS:
830                 return Duration.ofSeconds(timespan);
831             case Timespan.MILLISECONDS:
832                 return Duration.ofMillis(timespan);
833             case Timespan.NANOSECONDS:
834                 return Duration.ofNanos(timespan);
835             case Timespan.TICKS:
<span class="line-modified">836                 return Duration.ofNanos(objectContext.convertTimespan(timespan));</span>
837             }
838             throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal timespan unit &quot; + ts.value());
839         }
840         throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with missing @Timespan&quot;);
841     }
842 
843     /**
844      * Returns the value of a timestamp field.
845      * &lt;p&gt;
846      * This method can be used on fields annotated with {@code @Timestamp}, and of
847      * the following types: {@code long}, {@code int}, {@code short}, {@code char}
848      * and {@code byte}.
849      * &lt;p&gt;
850      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
851      * {@code &quot;aaa.bbb&quot;}).
852      * &lt;p&gt;
853      * A field might change or be removed in a future JDK release. A best practice
854      * for callers of this method is to validate the field before attempting access.
855      *
856      * @param name of the field to get, not {@code null}
</pre>
<hr />
<pre>
879         }
880         if (o instanceof Byte) {
881             return getInstant(((Byte) o).longValue(), name);
882         }
883         if (o instanceof UnsignedValue) {
884             Object u = ((UnsignedValue) o).value();
885             if (u instanceof Integer) {
886                 return getInstant(Integer.toUnsignedLong((Integer) u), name);
887             }
888             if (u instanceof Short) {
889                 return getInstant(Short.toUnsignedLong((Short) u), name);
890             }
891             if (u instanceof Byte) {
892                 return getInstant(Short.toUnsignedLong((Byte) u), name);
893             }
894         }
895         throw newIllegalArgumentException(name, &quot;java.time.Instant&quot;);
896     }
897 
898     private Instant getInstant(long timestamp, String name) {
<span class="line-modified">899         ValueDescriptor v = getValueDescriptor(objectContext.fields, name, null);</span>
900         Timestamp ts = v.getAnnotation(Timestamp.class);
901         if (ts != null) {
902             if (timestamp == Long.MIN_VALUE) {
903                 return Instant.MIN;
904             }
905             switch (ts.value()) {
906             case Timestamp.MILLISECONDS_SINCE_EPOCH:
907                 return Instant.ofEpochMilli(timestamp);
908             case Timestamp.TICKS:
<span class="line-modified">909                 return Instant.ofEpochSecond(0, objectContext.convertTimestamp(timestamp));</span>
910             }
911             throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal timestamp unit &quot; + ts.value());
912         }
913         throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with missing @Timestamp&quot;);
914     }
915 
916     /**
917      * Returns the value of a field of type {@code Class}.
918      * &lt;p&gt;
919      * It&#39;s possible to index into a nested object using {@code &quot;.&quot;} (for example,
920      * {@code &quot;aaa.bbb&quot;}).
921      * &lt;p&gt;
922      * A field might change or be removed in a future JDK release. A best practice
923      * for callers of this method is to validate the field before attempting access.
924      *
925      * @param name of the field to get, not {@code null}
926      *
927      * @return the value of the field as a {@code RecordedClass}, can be
928      *         {@code null}
929      *
</pre>
<hr />
<pre>
964     /**
965      * Returns a textual representation of this object.
966      *
967      * @return textual description of this object
968      */
969     @Override
970     final public String toString() {
971         StringWriter s = new StringWriter();
972         PrettyWriter p = new PrettyWriter(new PrintWriter(s));
973         p.setStackDepth(5);
974         if (this instanceof RecordedEvent) {
975             p.print((RecordedEvent) this);
976         } else {
977             p.print(this, &quot;&quot;);
978         }
979         p.flush(true);
980         return s.toString();
981     }
982 
983     // package private for now. Used by EventWriter
<span class="line-modified">984     private OffsetDateTime getOffsetDateTime(String name) {</span>
985         Instant instant = getInstant(name);
986         if (instant.equals(Instant.MIN)) {
987             return OffsetDateTime.MIN;
988         }
<span class="line-modified">989         return OffsetDateTime.ofInstant(getInstant(name), objectContext.getZoneOffset());</span>
990     }
991 
992     private static IllegalArgumentException newIllegalArgumentException(String name, String typeName) {
993         return new IllegalArgumentException(&quot;Attempt to get field \&quot;&quot; + name + &quot;\&quot; with illegal data type conversion &quot; + typeName);
994     }
995 }
</pre>
</td>
</tr>
</table>
<center><a href="RecordedMethod.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RecordedStackTrace.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/Recording.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FlightRecorder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="consumer/RecordedClass.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/Recording.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 76             Utils.ensureValidEventSubclass(eventClass);
 77             this.recording = r;
 78             this.identifier = String.valueOf(Type.getTypeId(eventClass));
 79         }
 80 
 81         @Override
 82         public EventSettings with(String name, String value) {
 83             Objects.requireNonNull(value);
 84             recording.setSetting(identifier + &quot;#&quot; + name, value);
 85             return this;
 86         }
 87 
 88         @Override
 89         public Map&lt;String, String&gt; toMap() {
 90             return recording.getSettings();
 91         }
 92     }
 93 
 94     private final PlatformRecording internal;
 95 

















 96     public Recording(Map&lt;String, String&gt; settings) {


 97         PlatformRecorder r = FlightRecorder.getFlightRecorder().getInternal();
 98         synchronized (r) {
<span class="line-modified"> 99             this.internal = r.newRecording(settings);</span>
100             this.internal.setRecording(this);
101             if (internal.getRecording() != this) {
102                 throw new InternalError(&quot;Internal recording not properly setup&quot;);
103             }
104         }
105     }
106 
107     /**
108      * Creates a recording without any settings.
109      * &lt;p&gt;
110      * A newly created recording is in the {@link RecordingState#NEW} state. To start
111      * the recording, invoke the {@link Recording#start()} method.
112      *
113      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
114      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
115      *         support, or if the file repository can&#39;t be created or accessed)
116      *
117      * @throws SecurityException If a security manager is used and
118      *         FlightRecorderPermission &quot;accessFlightRecorder&quot; is not set.
119      */
</pre>
<hr />
<pre>
396      * amount of data to retain can be specified. When the maximum limit is
397      * exceeded, the Java Virtual Machine (JVM) removes the oldest chunk to make
398      * room for a more recent chunk.
399      * &lt;p&gt;
400      * If neither maximum limit or the maximum age is set, the size of the
401      * recording may grow indefinitely.
402      *
403      * @param maxSize the amount of data to retain, {@code 0} if infinite
404      *
405      * @throws IllegalArgumentException if &lt;code&gt;maxSize&lt;/code&gt; is negative
406      *
407      * @throws IllegalStateException if the recording is in {@code CLOSED} state
408      */
409     public void setMaxSize(long maxSize) {
410         if (maxSize &lt; 0) {
411             throw new IllegalArgumentException(&quot;Max size of recording can&#39;t be negative&quot;);
412         }
413         internal.setMaxSize(maxSize);
414     }
415 






























416     /**
417      * Determines how far back data is kept in the disk repository.
418      * &lt;p&gt;
419      * To control the amount of recording data stored on disk, the maximum length of
420      * time to retain the data can be specified. Data stored on disk that is older
421      * than the specified length of time is removed by the Java Virtual Machine (JVM).
422      * &lt;p&gt;
423      * If neither maximum limit or the maximum age is set, the size of the
424      * recording may grow indefinitely.
425      *
426      * @param maxAge the length of time that data is kept, or {@code null} if infinite
427      *
428      * @throws IllegalArgumentException if &lt;code&gt;maxAge&lt;/code&gt; is negative
429      *
430      * @throws IllegalStateException if the recording is in the {@code CLOSED} state
431      */
432     public void setMaxAge(Duration maxAge) {
433         if (maxAge != null &amp;&amp; maxAge.isNegative()) {
434             throw new IllegalArgumentException(&quot;Max age of recording can&#39;t be negative&quot;);
435         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 76             Utils.ensureValidEventSubclass(eventClass);
 77             this.recording = r;
 78             this.identifier = String.valueOf(Type.getTypeId(eventClass));
 79         }
 80 
 81         @Override
 82         public EventSettings with(String name, String value) {
 83             Objects.requireNonNull(value);
 84             recording.setSetting(identifier + &quot;#&quot; + name, value);
 85             return this;
 86         }
 87 
 88         @Override
 89         public Map&lt;String, String&gt; toMap() {
 90             return recording.getSettings();
 91         }
 92     }
 93 
 94     private final PlatformRecording internal;
 95 
<span class="line-added"> 96     /**</span>
<span class="line-added"> 97      * Creates a recording with settings from a map of name-value pairs.</span>
<span class="line-added"> 98      * &lt;p&gt;</span>
<span class="line-added"> 99      * A newly created recording is in the {@link RecordingState#NEW} state. To start</span>
<span class="line-added">100      * the recording, invoke the {@link Recording#start()} method.</span>
<span class="line-added">101      *</span>
<span class="line-added">102      * @param settings settings as a map of name-value pairs, not {@code null}</span>
<span class="line-added">103      *</span>
<span class="line-added">104      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for</span>
<span class="line-added">105      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder</span>
<span class="line-added">106      *         support, or if the file repository can&#39;t be created or accessed)</span>
<span class="line-added">107      *</span>
<span class="line-added">108      * @throws SecurityException If a security manager is used and</span>
<span class="line-added">109      *         FlightRecorderPermission &quot;accessFlightRecorder&quot; is not set.</span>
<span class="line-added">110      *</span>
<span class="line-added">111      * @see jdk.jfr</span>
<span class="line-added">112      */</span>
113     public Recording(Map&lt;String, String&gt; settings) {
<span class="line-added">114         Objects.requireNonNull(settings);</span>
<span class="line-added">115         Map&lt;String, String&gt; sanitized = Utils.sanitizeNullFreeStringMap(settings);</span>
116         PlatformRecorder r = FlightRecorder.getFlightRecorder().getInternal();
117         synchronized (r) {
<span class="line-modified">118             this.internal = r.newRecording(sanitized);</span>
119             this.internal.setRecording(this);
120             if (internal.getRecording() != this) {
121                 throw new InternalError(&quot;Internal recording not properly setup&quot;);
122             }
123         }
124     }
125 
126     /**
127      * Creates a recording without any settings.
128      * &lt;p&gt;
129      * A newly created recording is in the {@link RecordingState#NEW} state. To start
130      * the recording, invoke the {@link Recording#start()} method.
131      *
132      * @throws IllegalStateException if Flight Recorder can&#39;t be created (for
133      *         example, if the Java Virtual Machine (JVM) lacks Flight Recorder
134      *         support, or if the file repository can&#39;t be created or accessed)
135      *
136      * @throws SecurityException If a security manager is used and
137      *         FlightRecorderPermission &quot;accessFlightRecorder&quot; is not set.
138      */
</pre>
<hr />
<pre>
415      * amount of data to retain can be specified. When the maximum limit is
416      * exceeded, the Java Virtual Machine (JVM) removes the oldest chunk to make
417      * room for a more recent chunk.
418      * &lt;p&gt;
419      * If neither maximum limit or the maximum age is set, the size of the
420      * recording may grow indefinitely.
421      *
422      * @param maxSize the amount of data to retain, {@code 0} if infinite
423      *
424      * @throws IllegalArgumentException if &lt;code&gt;maxSize&lt;/code&gt; is negative
425      *
426      * @throws IllegalStateException if the recording is in {@code CLOSED} state
427      */
428     public void setMaxSize(long maxSize) {
429         if (maxSize &lt; 0) {
430             throw new IllegalArgumentException(&quot;Max size of recording can&#39;t be negative&quot;);
431         }
432         internal.setMaxSize(maxSize);
433     }
434 
<span class="line-added">435         /**</span>
<span class="line-added">436          * Determines how often events are made available for streaming.</span>
<span class="line-added">437          *</span>
<span class="line-added">438          * @param interval the interval at which events are made available for streaming.</span>
<span class="line-added">439          *</span>
<span class="line-added">440          * @throws IllegalArgumentException if {@code interval} is negative</span>
<span class="line-added">441          *</span>
<span class="line-added">442          * @throws IllegalStateException if the recording is in the {@code CLOSED} state</span>
<span class="line-added">443          *</span>
<span class="line-added">444          * @since 14</span>
<span class="line-added">445          */</span>
<span class="line-added">446         /*package private*/ void setFlushInterval(Duration interval) {</span>
<span class="line-added">447             Objects.nonNull(interval);</span>
<span class="line-added">448             if (interval.isNegative()) {</span>
<span class="line-added">449                 throw new IllegalArgumentException(&quot;Stream interval can&#39;t be negative&quot;);</span>
<span class="line-added">450             }</span>
<span class="line-added">451             internal.setFlushInterval(interval);</span>
<span class="line-added">452         }</span>
<span class="line-added">453 </span>
<span class="line-added">454     /**</span>
<span class="line-added">455      * Returns how often events are made available for streaming purposes.</span>
<span class="line-added">456      *</span>
<span class="line-added">457      * @return the flush interval, or {@code null} if no interval has been set</span>
<span class="line-added">458      *</span>
<span class="line-added">459      * @since 14</span>
<span class="line-added">460      */</span>
<span class="line-added">461     /*package private*/ Duration getFlushInterval() {</span>
<span class="line-added">462         return internal.getFlushInterval();</span>
<span class="line-added">463     }</span>
<span class="line-added">464 </span>
465     /**
466      * Determines how far back data is kept in the disk repository.
467      * &lt;p&gt;
468      * To control the amount of recording data stored on disk, the maximum length of
469      * time to retain the data can be specified. Data stored on disk that is older
470      * than the specified length of time is removed by the Java Virtual Machine (JVM).
471      * &lt;p&gt;
472      * If neither maximum limit or the maximum age is set, the size of the
473      * recording may grow indefinitely.
474      *
475      * @param maxAge the length of time that data is kept, or {@code null} if infinite
476      *
477      * @throws IllegalArgumentException if &lt;code&gt;maxAge&lt;/code&gt; is negative
478      *
479      * @throws IllegalStateException if the recording is in the {@code CLOSED} state
480      */
481     public void setMaxAge(Duration maxAge) {
482         if (maxAge != null &amp;&amp; maxAge.isNegative()) {
483             throw new IllegalArgumentException(&quot;Max age of recording can&#39;t be negative&quot;);
484         }
</pre>
</td>
</tr>
</table>
<center><a href="FlightRecorder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="consumer/RecordedClass.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Print.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PrettyWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Summary.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Print.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 90         stream.println();
 91         stream.println(&quot; jfr print --events OldObjectSample recording.jfr&quot;);
 92         stream.println();
 93         stream.println(&quot; jfr print --events CPULoad,GarbageCollection recording.jfr&quot;);
 94         stream.println();
 95         stream.println(&quot; jfr print --categories \&quot;GC,JVM,Java*\&quot; recording.jfr&quot;);
 96         stream.println();
 97         stream.println(&quot; jfr print --events \&quot;jdk.*\&quot; --stack-depth 64 recording.jfr&quot;);
 98         stream.println();
 99         stream.println(&quot; jfr print --json --events CPULoad recording.jfr&quot;);
100     }
101 
102     @Override
103     public void execute(Deque&lt;String&gt; options) throws UserSyntaxException, UserDataException {
104         Path file = getJFRInputFile(options);
105         PrintWriter pw = new PrintWriter(System.out, false, Charset.forName(&quot;UTF-8&quot;));
106         Predicate&lt;EventType&gt; eventFilter = null;
107         int stackDepth = 5;
108         EventPrintWriter eventWriter = null;
109         int optionCount = options.size();


110         while (optionCount &gt; 0) {
111             if (acceptFilterOption(options, &quot;--events&quot;)) {




112                 String filter = options.remove();
113                 warnForWildcardExpansion(&quot;--events&quot;, filter);
114                 eventFilter = addEventFilter(filter, eventFilter);
115             }
116             if (acceptFilterOption(options, &quot;--categories&quot;)) {




117                 String filter = options.remove();
118                 warnForWildcardExpansion(&quot;--categories&quot;, filter);
119                 eventFilter = addCategoryFilter(filter, eventFilter);
120             }
121             if (acceptOption(options, &quot;--stack-depth&quot;)) {
122                 String value = options.pop();
123                 try {
124                     stackDepth = Integer.parseInt(value);
125                     if (stackDepth &lt; 0) {
126                         throw new UserSyntaxException(&quot;stack depth must be zero or a positive integer.&quot;);
127                     }
128                 } catch (NumberFormatException nfe) {
129                     throw new UserSyntaxException(&quot;not a valid value for --stack-depth&quot;);
130                 }
131             }
132             if (acceptFormatterOption(options, eventWriter, &quot;--json&quot;)) {
133                 eventWriter = new JSONWriter(pw);
134             }
135             if (acceptFormatterOption(options, eventWriter, &quot;--xml&quot;)) {
136                 eventWriter = new XMLWriter(pw);
137             }
138             if (optionCount == options.size()) {
139                 // No progress made


140                 throw new UserSyntaxException(&quot;unknown option &quot; + options.peek());
141             }
142             optionCount = options.size();
143         }
144         if (eventWriter == null) {
145             eventWriter = new PrettyWriter(pw); // default to pretty printer
146         }
147         eventWriter.setStackDepth(stackDepth);
148         if (eventFilter != null) {
149             eventFilter = addCache(eventFilter, eventType -&gt; eventType.getId());
150             eventWriter.setEventFilter(eventFilter);
151         }
152         try {
153             eventWriter.print(file);
154         } catch (IOException ioe) {
155             couldNotReadError(file, ioe);
156         }
157         pw.flush();
158     }
159 






160     private static boolean acceptFormatterOption(Deque&lt;String&gt; options, EventPrintWriter eventWriter, String expected) throws UserSyntaxException {
161         if (expected.equals(options.peek())) {
162             if (eventWriter != null) {
163                 throw new UserSyntaxException(&quot;only one format can be specified at a time&quot;);
164             }
165             options.remove();
166             return true;
167         }
168         return false;
169     }
170 
171     private static &lt;T, X&gt; Predicate&lt;T&gt; addCache(final Predicate&lt;T&gt; filter, Function&lt;T, X&gt; cacheFunction) {
172         Map&lt;X, Boolean&gt; cache = new HashMap&lt;&gt;();
173         return t -&gt; cache.computeIfAbsent(cacheFunction.apply(t), x -&gt; filter.test(t));
174     }
175 
176     private static &lt;T&gt; Predicate&lt;T&gt; recurseIfPossible(Predicate&lt;T&gt; filter) {
177         return x -&gt; filter != null &amp;&amp; filter.test(x);
178     }
179 
180     private static Predicate&lt;EventType&gt; addCategoryFilter(String filterText, Predicate&lt;EventType&gt; eventFilter) throws UserSyntaxException {
181         List&lt;String&gt; filters = explodeFilter(filterText);
<span class="line-modified">182         return recurseIfPossible(eventType -&gt; {</span>
183             for (String category : eventType.getCategoryNames()) {
184                 for (String filter : filters) {
185                     if (match(category, filter)) {
186                         return true;
187                     }
188                     if (category.contains(&quot; &quot;) &amp;&amp; acronomify(category).equals(filter)) {
189                         return true;
190                     }
191                 }
192             }
193             return false;
194         });

195     }
196 
197     private static String acronomify(String multipleWords) {
198         boolean newWord = true;
199         String acronym = &quot;&quot;;
200         for (char c : multipleWords.toCharArray()) {
201             if (newWord) {
202                 if (Character.isAlphabetic(c) &amp;&amp; Character.isUpperCase(c)) {
203                     acronym += c;
204                 }
205             }
206             newWord = Character.isWhitespace(c);
207         }
208         return acronym;
209     }
210 
211     private static Predicate&lt;EventType&gt; addEventFilter(String filterText, final Predicate&lt;EventType&gt; eventFilter) throws UserSyntaxException {
212         List&lt;String&gt; filters = explodeFilter(filterText);
<span class="line-modified">213         return recurseIfPossible(eventType -&gt; {</span>
214             for (String filter : filters) {
215                 String fullEventName = eventType.getName();
216                 if (match(fullEventName, filter)) {
217                     return true;
218                 }
219                 String eventName = fullEventName.substring(fullEventName.lastIndexOf(&quot;.&quot;) + 1);
220                 if (match(eventName, filter)) {
221                     return true;
222                 }
223             }
224             return false;
225         });

226     }
227 
228     private static boolean match(String text, String filter) {
229         if (filter.length() == 0) {
230             // empty filter string matches if string is empty
231             return text.length() == 0;
232         }
233         if (filter.charAt(0) == &#39;*&#39;) { // recursive check
234             filter = filter.substring(1);
235             for (int n = 0; n &lt;= text.length(); n++) {
236                 if (match(text.substring(n), filter))
237                     return true;
238             }
239         } else if (text.length() == 0) {
240             // empty string and non-empty filter does not match
241             return false;
242         } else if (filter.charAt(0) == &#39;?&#39;) {
243             // eat any char and move on
244             return match(text.substring(1), filter.substring(1));
245         } else if (filter.charAt(0) == text.charAt(0)) {
</pre>
</td>
<td>
<hr />
<pre>
 90         stream.println();
 91         stream.println(&quot; jfr print --events OldObjectSample recording.jfr&quot;);
 92         stream.println();
 93         stream.println(&quot; jfr print --events CPULoad,GarbageCollection recording.jfr&quot;);
 94         stream.println();
 95         stream.println(&quot; jfr print --categories \&quot;GC,JVM,Java*\&quot; recording.jfr&quot;);
 96         stream.println();
 97         stream.println(&quot; jfr print --events \&quot;jdk.*\&quot; --stack-depth 64 recording.jfr&quot;);
 98         stream.println();
 99         stream.println(&quot; jfr print --json --events CPULoad recording.jfr&quot;);
100     }
101 
102     @Override
103     public void execute(Deque&lt;String&gt; options) throws UserSyntaxException, UserDataException {
104         Path file = getJFRInputFile(options);
105         PrintWriter pw = new PrintWriter(System.out, false, Charset.forName(&quot;UTF-8&quot;));
106         Predicate&lt;EventType&gt; eventFilter = null;
107         int stackDepth = 5;
108         EventPrintWriter eventWriter = null;
109         int optionCount = options.size();
<span class="line-added">110         boolean foundEventFilter = false;</span>
<span class="line-added">111         boolean foundCategoryFilter = false;</span>
112         while (optionCount &gt; 0) {
113             if (acceptFilterOption(options, &quot;--events&quot;)) {
<span class="line-added">114                 if (foundEventFilter) {</span>
<span class="line-added">115                     throw new UserSyntaxException(&quot;use --events event1,event2,event3 to include multiple events&quot;);</span>
<span class="line-added">116                 }</span>
<span class="line-added">117                 foundEventFilter = true;</span>
118                 String filter = options.remove();
119                 warnForWildcardExpansion(&quot;--events&quot;, filter);
120                 eventFilter = addEventFilter(filter, eventFilter);
121             }
122             if (acceptFilterOption(options, &quot;--categories&quot;)) {
<span class="line-added">123                 if (foundCategoryFilter) {</span>
<span class="line-added">124                     throw new UserSyntaxException(&quot;use --categories category1,category2 to include multiple categories&quot;);</span>
<span class="line-added">125                 }</span>
<span class="line-added">126                 foundCategoryFilter = true;</span>
127                 String filter = options.remove();
128                 warnForWildcardExpansion(&quot;--categories&quot;, filter);
129                 eventFilter = addCategoryFilter(filter, eventFilter);
130             }
131             if (acceptOption(options, &quot;--stack-depth&quot;)) {
132                 String value = options.pop();
133                 try {
134                     stackDepth = Integer.parseInt(value);
135                     if (stackDepth &lt; 0) {
136                         throw new UserSyntaxException(&quot;stack depth must be zero or a positive integer.&quot;);
137                     }
138                 } catch (NumberFormatException nfe) {
139                     throw new UserSyntaxException(&quot;not a valid value for --stack-depth&quot;);
140                 }
141             }
142             if (acceptFormatterOption(options, eventWriter, &quot;--json&quot;)) {
143                 eventWriter = new JSONWriter(pw);
144             }
145             if (acceptFormatterOption(options, eventWriter, &quot;--xml&quot;)) {
146                 eventWriter = new XMLWriter(pw);
147             }
148             if (optionCount == options.size()) {
149                 // No progress made
<span class="line-added">150                 checkCommonError(options, &quot;--event&quot;, &quot;--events&quot;);</span>
<span class="line-added">151                 checkCommonError(options, &quot;--category&quot;, &quot;--categories&quot;);</span>
152                 throw new UserSyntaxException(&quot;unknown option &quot; + options.peek());
153             }
154             optionCount = options.size();
155         }
156         if (eventWriter == null) {
157             eventWriter = new PrettyWriter(pw); // default to pretty printer
158         }
159         eventWriter.setStackDepth(stackDepth);
160         if (eventFilter != null) {
161             eventFilter = addCache(eventFilter, eventType -&gt; eventType.getId());
162             eventWriter.setEventFilter(eventFilter);
163         }
164         try {
165             eventWriter.print(file);
166         } catch (IOException ioe) {
167             couldNotReadError(file, ioe);
168         }
169         pw.flush();
170     }
171 
<span class="line-added">172     private void checkCommonError(Deque&lt;String&gt; options, String typo, String correct) throws UserSyntaxException {</span>
<span class="line-added">173        if (typo.equals(options.peek())) {</span>
<span class="line-added">174            throw new UserSyntaxException(&quot;unknown option &quot; + typo + &quot;, did you mean &quot; + correct + &quot;?&quot;);</span>
<span class="line-added">175        }</span>
<span class="line-added">176     }</span>
<span class="line-added">177 </span>
178     private static boolean acceptFormatterOption(Deque&lt;String&gt; options, EventPrintWriter eventWriter, String expected) throws UserSyntaxException {
179         if (expected.equals(options.peek())) {
180             if (eventWriter != null) {
181                 throw new UserSyntaxException(&quot;only one format can be specified at a time&quot;);
182             }
183             options.remove();
184             return true;
185         }
186         return false;
187     }
188 
189     private static &lt;T, X&gt; Predicate&lt;T&gt; addCache(final Predicate&lt;T&gt; filter, Function&lt;T, X&gt; cacheFunction) {
190         Map&lt;X, Boolean&gt; cache = new HashMap&lt;&gt;();
191         return t -&gt; cache.computeIfAbsent(cacheFunction.apply(t), x -&gt; filter.test(t));
192     }
193 
194     private static &lt;T&gt; Predicate&lt;T&gt; recurseIfPossible(Predicate&lt;T&gt; filter) {
195         return x -&gt; filter != null &amp;&amp; filter.test(x);
196     }
197 
198     private static Predicate&lt;EventType&gt; addCategoryFilter(String filterText, Predicate&lt;EventType&gt; eventFilter) throws UserSyntaxException {
199         List&lt;String&gt; filters = explodeFilter(filterText);
<span class="line-modified">200         Predicate&lt;EventType&gt; newFilter = recurseIfPossible(eventType -&gt; {</span>
201             for (String category : eventType.getCategoryNames()) {
202                 for (String filter : filters) {
203                     if (match(category, filter)) {
204                         return true;
205                     }
206                     if (category.contains(&quot; &quot;) &amp;&amp; acronomify(category).equals(filter)) {
207                         return true;
208                     }
209                 }
210             }
211             return false;
212         });
<span class="line-added">213         return eventFilter == null ? newFilter : eventFilter.or(newFilter);</span>
214     }
215 
216     private static String acronomify(String multipleWords) {
217         boolean newWord = true;
218         String acronym = &quot;&quot;;
219         for (char c : multipleWords.toCharArray()) {
220             if (newWord) {
221                 if (Character.isAlphabetic(c) &amp;&amp; Character.isUpperCase(c)) {
222                     acronym += c;
223                 }
224             }
225             newWord = Character.isWhitespace(c);
226         }
227         return acronym;
228     }
229 
230     private static Predicate&lt;EventType&gt; addEventFilter(String filterText, final Predicate&lt;EventType&gt; eventFilter) throws UserSyntaxException {
231         List&lt;String&gt; filters = explodeFilter(filterText);
<span class="line-modified">232         Predicate&lt;EventType&gt; newFilter = recurseIfPossible(eventType -&gt; {</span>
233             for (String filter : filters) {
234                 String fullEventName = eventType.getName();
235                 if (match(fullEventName, filter)) {
236                     return true;
237                 }
238                 String eventName = fullEventName.substring(fullEventName.lastIndexOf(&quot;.&quot;) + 1);
239                 if (match(eventName, filter)) {
240                     return true;
241                 }
242             }
243             return false;
244         });
<span class="line-added">245         return eventFilter == null ? newFilter : eventFilter.or(newFilter);</span>
246     }
247 
248     private static boolean match(String text, String filter) {
249         if (filter.length() == 0) {
250             // empty filter string matches if string is empty
251             return text.length() == 0;
252         }
253         if (filter.charAt(0) == &#39;*&#39;) { // recursive check
254             filter = filter.substring(1);
255             for (int n = 0; n &lt;= text.length(); n++) {
256                 if (match(text.substring(n), filter))
257                     return true;
258             }
259         } else if (text.length() == 0) {
260             // empty string and non-empty filter does not match
261             return false;
262         } else if (filter.charAt(0) == &#39;?&#39;) {
263             // eat any char and move on
264             return match(text.substring(1), filter.substring(1));
265         } else if (filter.charAt(0) == text.charAt(0)) {
</pre>
</td>
</tr>
</table>
<center><a href="PrettyWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Summary.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
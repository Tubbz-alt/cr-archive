<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordedObject.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="RecordedMethod.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RecordedStackTrace.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/consumer/RecordedObject.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,22 +23,28 @@</span>
   * questions.
   */
  
  package jdk.jfr.consumer;
  
<span class="udiff-line-added">+ import java.io.IOException;</span>
  import java.io.PrintWriter;
  import java.io.StringWriter;
  import java.time.Duration;
  import java.time.Instant;
  import java.time.OffsetDateTime;
<span class="udiff-line-added">+ import java.util.Comparator;</span>
  import java.util.List;
  import java.util.Objects;
  
  import jdk.jfr.Timespan;
  import jdk.jfr.Timestamp;
  import jdk.jfr.ValueDescriptor;
<span class="udiff-line-added">+ import jdk.jfr.internal.consumer.JdkJfrConsumer;</span>
<span class="udiff-line-added">+ import jdk.jfr.internal.consumer.ObjectFactory;</span>
  import jdk.jfr.internal.PrivateAccess;
<span class="udiff-line-added">+ import jdk.jfr.internal.Type;</span>
<span class="udiff-line-added">+ import jdk.jfr.internal.consumer.ObjectContext;</span>
  import jdk.jfr.internal.tool.PrettyWriter;
  
  /**
   * A complex data type that consists of one or more fields.
   * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -49,10 +55,93 @@</span>
   *
   * @since 9
   */
  public class RecordedObject {
  
<span class="udiff-line-added">+     static{</span>
<span class="udiff-line-added">+         JdkJfrConsumer access = new JdkJfrConsumer() {</span>
<span class="udiff-line-added">+             public List&lt;Type&gt; readTypes(RecordingFile file) throws IOException {</span>
<span class="udiff-line-added">+                 return file.readTypes();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             public boolean isLastEventInChunk(RecordingFile file) {</span>
<span class="udiff-line-added">+                 return file.isLastEventInChunk();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public Object getOffsetDataTime(RecordedObject event, String name) {</span>
<span class="udiff-line-added">+                 return event.getOffsetDateTime(name);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public RecordedClass newRecordedClass(ObjectContext objectContext, long id, Object[] values) {</span>
<span class="udiff-line-added">+                 return new RecordedClass(objectContext, id, values);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public RecordedClassLoader newRecordedClassLoader(ObjectContext objectContext, long id, Object[] values) {</span>
<span class="udiff-line-added">+                 return new RecordedClassLoader(objectContext, id, values);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public Comparator&lt;? super RecordedEvent&gt; eventComparator() {</span>
<span class="udiff-line-added">+                 return new Comparator&lt;RecordedEvent&gt;()  {</span>
<span class="udiff-line-added">+                     @Override</span>
<span class="udiff-line-added">+                     public int compare(RecordedEvent e1, RecordedEvent e2) {</span>
<span class="udiff-line-added">+                         return Long.compare(e1.endTimeTicks, e2.endTimeTicks);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 };</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public RecordedStackTrace newRecordedStackTrace(ObjectContext objectContext, Object[] values) {</span>
<span class="udiff-line-added">+                 return new RecordedStackTrace(objectContext, values);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public RecordedThreadGroup newRecordedThreadGroup(ObjectContext objectContext, Object[] values) {</span>
<span class="udiff-line-added">+                 return new RecordedThreadGroup(objectContext, values);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public RecordedFrame newRecordedFrame(ObjectContext objectContext, Object[] values) {</span>
<span class="udiff-line-added">+                 return new RecordedFrame(objectContext, values);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public RecordedThread newRecordedThread(ObjectContext objectContext, long id, Object[] values) {</span>
<span class="udiff-line-added">+                 return new RecordedThread(objectContext, id, values);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public RecordedMethod newRecordedMethod(ObjectContext objectContext, Object[] values) {</span>
<span class="udiff-line-added">+                 return new RecordedMethod(objectContext, values);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public RecordedEvent newRecordedEvent(ObjectContext objectContext, Object[] values, long startTimeTicks, long endTimeTicks) {</span>
<span class="udiff-line-added">+                 return new RecordedEvent(objectContext, values, startTimeTicks, endTimeTicks);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public void setStartTicks(RecordedEvent event, long startTicks) {</span>
<span class="udiff-line-added">+                event.startTimeTicks = startTicks;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public void setEndTicks(RecordedEvent event, long endTicks) {</span>
<span class="udiff-line-added">+                event.endTimeTicks = endTicks;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             @Override</span>
<span class="udiff-line-added">+             public Object[] eventValues(RecordedEvent event) {</span>
<span class="udiff-line-added">+                 return event.objects;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         };</span>
<span class="udiff-line-added">+         JdkJfrConsumer.setAccess(access);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      private final static class UnsignedValue {
          private final Object o;
  
          UnsignedValue(Object o) {
              this.o = o;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61,19 +150,17 @@</span>
          Object value() {
              return o;
          }
      }
  
<span class="udiff-line-modified-removed">-     private final Object[] objects;</span>
<span class="udiff-line-modified-removed">-     private final List&lt;ValueDescriptor&gt; descriptors;</span>
<span class="udiff-line-removed">-     private final TimeConverter timeConverter;</span>
<span class="udiff-line-modified-added">+     final Object[] objects;</span>
<span class="udiff-line-modified-added">+     final ObjectContext objectContext;</span>
  
      // package private, not to be subclassed outside this package
<span class="udiff-line-modified-removed">-     RecordedObject(List&lt;ValueDescriptor&gt; descriptors, Object[] objects, TimeConverter timeConverter) {</span>
<span class="udiff-line-modified-removed">-         this.descriptors = descriptors;</span>
<span class="udiff-line-modified-added">+     RecordedObject(ObjectContext objectContext, Object[] objects) {</span>
<span class="udiff-line-modified-added">+         this.objectContext = objectContext;</span>
          this.objects = objects;
<span class="udiff-line-removed">-         this.timeConverter = timeConverter;</span>
      }
  
      // package private
      final &lt;T&gt; T getTyped(String name, Class&lt;T&gt; clazz, T defaultValue) {
          // Unnecessary to check field presence twice, but this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -99,19 +186,19 @@</span>
       *
       * @see #getFields()
       */
      public boolean hasField(String name) {
          Objects.requireNonNull(name);
<span class="udiff-line-modified-removed">-         for (ValueDescriptor v : descriptors) {</span>
<span class="udiff-line-modified-added">+         for (ValueDescriptor v : objectContext.fields) {</span>
              if (v.getName().equals(name)) {
                  return true;
              }
          }
          int dotIndex = name.indexOf(&quot;.&quot;);
          if (dotIndex &gt; 0) {
              String structName = name.substring(0, dotIndex);
<span class="udiff-line-modified-removed">-             for (ValueDescriptor v : descriptors) {</span>
<span class="udiff-line-modified-added">+             for (ValueDescriptor v : objectContext.fields) {</span>
                  if (!v.getFields().isEmpty() &amp;&amp; v.getName().equals(structName)) {
                      RecordedObject child = getValue(structName);
                      if (child != null) {
                          return child.hasField(name.substring(dotIndex + 1));
                      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -167,16 +254,20 @@</span>
          @SuppressWarnings(&quot;unchecked&quot;)
          T t = (T) getValue(name, false);
          return t;
      }
  
<span class="udiff-line-added">+     protected Object objectAt(int index) {</span>
<span class="udiff-line-added">+         return objects[index];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      private Object getValue(String name, boolean allowUnsigned) {
          Objects.requireNonNull(name);
          int index = 0;
<span class="udiff-line-modified-removed">-         for (ValueDescriptor v : descriptors) {</span>
<span class="udiff-line-modified-added">+         for (ValueDescriptor v : objectContext.fields) {</span>
              if (name.equals(v.getName())) {
<span class="udiff-line-modified-removed">-                 Object object = objects[index];</span>
<span class="udiff-line-modified-added">+                 Object object = objectAt(index);</span>
                  if (object == null) {
                      // error or missing
                      return null;
                  }
                  if (v.getFields().isEmpty()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -198,20 +289,20 @@</span>
                      if (v.isArray()) {
                          // struct array
                          return structifyArray(v, array, 0);
                      }
                      // struct
<span class="udiff-line-modified-removed">-                     return new RecordedObject(v.getFields(), (Object[]) object, timeConverter);</span>
<span class="udiff-line-modified-added">+                     return new RecordedObject(objectContext.getInstance(v), (Object[]) object);</span>
                  }
              }
              index++;
          }
  
          int dotIndex = name.indexOf(&quot;.&quot;);
          if (dotIndex &gt; 0) {
              String structName = name.substring(0, dotIndex);
<span class="udiff-line-modified-removed">-             for (ValueDescriptor v : descriptors) {</span>
<span class="udiff-line-modified-added">+             for (ValueDescriptor v : objectContext.fields) {</span>
                  if (!v.getFields().isEmpty() &amp;&amp; v.getName().equals(structName)) {
                      RecordedObject child = getValue(structName);
                      String subName = name.substring(dotIndex + 1);
                      if (child != null) {
                          return child.getValue(subName, allowUnsigned);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -259,28 +350,29 @@</span>
      // This is to prevent a call to getString on a thread field, that is
      // null to succeed.
      private &lt;T&gt; T getTypedValue(String name, String typeName) {
          Objects.requireNonNull(name);
          // Validate name and type first
<span class="udiff-line-modified-removed">-         getValueDescriptor(descriptors, name, typeName);</span>
<span class="udiff-line-modified-added">+         getValueDescriptor(objectContext.fields, name, typeName);</span>
          return getValue(name);
      }
  
      private Object[] structifyArray(ValueDescriptor v, Object[] array, int dimension) {
          if (array == null) {
              return null;
          }
          Object[] structArray = new Object[array.length];
<span class="udiff-line-added">+         ObjectContext objContext = objectContext.getInstance(v);</span>
          for (int i = 0; i &lt; structArray.length; i++) {
              Object arrayElement = array[i];
              if (dimension == 0) {
                  // No general way to handle structarrays
                  // without invoking ObjectFactory for every instance (which may require id)
                  if (isStackFrameType(v.getTypeName())) {
<span class="udiff-line-modified-removed">-                     structArray[i] = new RecordedFrame(v.getFields(), (Object[]) arrayElement, timeConverter);</span>
<span class="udiff-line-modified-added">+                     structArray[i] = new RecordedFrame(objContext, (Object[]) arrayElement);</span>
                  } else {
<span class="udiff-line-modified-removed">-                     structArray[i] = new RecordedObject(v.getFields(), (Object[]) arrayElement, timeConverter);</span>
<span class="udiff-line-modified-added">+                     structArray[i] = new RecordedObject(objContext, (Object[]) arrayElement);</span>
                  }
              } else {
                  structArray[i] = structifyArray(v, (Object[]) arrayElement, dimension - 1);
              }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -301,11 +393,11 @@</span>
       * Returns an immutable list of the fields for this object.
       *
       * @return the fields, not {@code null}
       */
      public List&lt;ValueDescriptor&gt; getFields() {
<span class="udiff-line-modified-removed">-         return descriptors;</span>
<span class="udiff-line-modified-added">+         return objectContext.fields;</span>
      }
  
      /**
       * Returns the value of a field of type {@code boolean}.
       * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -723,11 +815,11 @@</span>
          }
          throw newIllegalArgumentException(name, &quot;java,time.Duration&quot;);
      }
  
      private Duration getDuration(long timespan, String name) throws InternalError {
<span class="udiff-line-modified-removed">-         ValueDescriptor v = getValueDescriptor(descriptors, name, null);</span>
<span class="udiff-line-modified-added">+         ValueDescriptor v = getValueDescriptor(objectContext.fields, name, null);</span>
          if (timespan == Long.MIN_VALUE) {
              return Duration.ofSeconds(Long.MIN_VALUE, 0);
          }
          Timespan ts = v.getAnnotation(Timespan.class);
          if (ts != null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -739,11 +831,11 @@</span>
              case Timespan.MILLISECONDS:
                  return Duration.ofMillis(timespan);
              case Timespan.NANOSECONDS:
                  return Duration.ofNanos(timespan);
              case Timespan.TICKS:
<span class="udiff-line-modified-removed">-                 return Duration.ofNanos(timeConverter.convertTimespan(timespan));</span>
<span class="udiff-line-modified-added">+                 return Duration.ofNanos(objectContext.convertTimespan(timespan));</span>
              }
              throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal timespan unit &quot; + ts.value());
          }
          throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with missing @Timespan&quot;);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -802,21 +894,21 @@</span>
          }
          throw newIllegalArgumentException(name, &quot;java.time.Instant&quot;);
      }
  
      private Instant getInstant(long timestamp, String name) {
<span class="udiff-line-modified-removed">-         ValueDescriptor v = getValueDescriptor(descriptors, name, null);</span>
<span class="udiff-line-modified-added">+         ValueDescriptor v = getValueDescriptor(objectContext.fields, name, null);</span>
          Timestamp ts = v.getAnnotation(Timestamp.class);
          if (ts != null) {
              if (timestamp == Long.MIN_VALUE) {
                  return Instant.MIN;
              }
              switch (ts.value()) {
              case Timestamp.MILLISECONDS_SINCE_EPOCH:
                  return Instant.ofEpochMilli(timestamp);
              case Timestamp.TICKS:
<span class="udiff-line-modified-removed">-                 return Instant.ofEpochSecond(0, timeConverter.convertTimestamp(timestamp));</span>
<span class="udiff-line-modified-added">+                 return Instant.ofEpochSecond(0, objectContext.convertTimestamp(timestamp));</span>
              }
              throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with illegal timestamp unit &quot; + ts.value());
          }
          throw new IllegalArgumentException(&quot;Attempt to get &quot; + v.getTypeName() + &quot; field \&quot;&quot; + name + &quot;\&quot; with missing @Timestamp&quot;);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -887,16 +979,16 @@</span>
          p.flush(true);
          return s.toString();
      }
  
      // package private for now. Used by EventWriter
<span class="udiff-line-modified-removed">-     OffsetDateTime getOffsetDateTime(String name) {</span>
<span class="udiff-line-modified-added">+     private OffsetDateTime getOffsetDateTime(String name) {</span>
          Instant instant = getInstant(name);
          if (instant.equals(Instant.MIN)) {
              return OffsetDateTime.MIN;
          }
<span class="udiff-line-modified-removed">-         return OffsetDateTime.ofInstant(getInstant(name), timeConverter.getZoneOffset());</span>
<span class="udiff-line-modified-added">+         return OffsetDateTime.ofInstant(getInstant(name), objectContext.getZoneOffset());</span>
      }
  
      private static IllegalArgumentException newIllegalArgumentException(String name, String typeName) {
          return new IllegalArgumentException(&quot;Attempt to get field \&quot;&quot; + name + &quot;\&quot; with illegal data type conversion &quot; + typeName);
      }
</pre>
<center><a href="RecordedMethod.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="RecordedStackTrace.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jfr/share/classes/jdk/jfr/internal/EventControl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.lang.annotation.Annotation;
 29 import java.lang.reflect.Constructor;
 30 import java.lang.reflect.InvocationTargetException;
 31 import java.lang.reflect.Method;
 32 import java.lang.reflect.Modifier;
 33 import java.util.ArrayList;
 34 import java.util.Collections;
 35 import java.util.HashMap;
 36 import java.util.List;
 37 import java.util.Map;
 38 import java.util.Map.Entry;
 39 import java.util.Set;
 40 
 41 import jdk.internal.module.Modules;
 42 import jdk.jfr.AnnotationElement;
 43 import jdk.jfr.Enabled;
 44 import jdk.jfr.Name;
 45 import jdk.jfr.Period;
 46 import jdk.jfr.SettingControl;
 47 import jdk.jfr.SettingDefinition;
 48 import jdk.jfr.StackTrace;
 49 import jdk.jfr.Threshold;
 50 import jdk.jfr.events.ActiveSettingEvent;
 51 import jdk.jfr.internal.EventInstrumentation.SettingInfo;
 52 import jdk.jfr.internal.settings.CutoffSetting;
 53 import jdk.jfr.internal.settings.EnabledSetting;
 54 import jdk.jfr.internal.settings.PeriodSetting;
 55 import jdk.jfr.internal.settings.StackTraceSetting;
 56 import jdk.jfr.internal.settings.ThresholdSetting;
 57 
 58 // This class can&#39;t have a hard reference from PlatformEventType, since it
 59 // holds SettingControl instances that need to be released
 60 // when a class is unloaded (to avoid memory leaks).
 61 public final class EventControl {
 62 
 63     static final String FIELD_SETTING_PREFIX = &quot;setting&quot;;
 64     private static final Type TYPE_ENABLED = TypeLibrary.createType(EnabledSetting.class);
 65     private static final Type TYPE_THRESHOLD = TypeLibrary.createType(ThresholdSetting.class);
 66     private static final Type TYPE_STACK_TRACE = TypeLibrary.createType(StackTraceSetting.class);
 67     private static final Type TYPE_PERIOD = TypeLibrary.createType(PeriodSetting.class);
 68     private static final Type TYPE_CUTOFF = TypeLibrary.createType(CutoffSetting.class);
 69 
 70     private final List&lt;SettingInfo&gt; settingInfos = new ArrayList&lt;&gt;();
 71     private final Map&lt;String, Control&gt; eventControls = new HashMap&lt;&gt;(5);
 72     private final PlatformEventType type;
 73     private final String idName;
 74 
 75     EventControl(PlatformEventType eventType) {
 76         eventControls.put(Enabled.NAME, defineEnabled(eventType));
 77         if (eventType.hasDuration()) {
 78             eventControls.put(Threshold.NAME, defineThreshold(eventType));
 79         }
 80         if (eventType.hasStackTrace()) {
 81             eventControls.put(StackTrace.NAME, defineStackTrace(eventType));
 82         }
 83         if (eventType.hasPeriod()) {
 84             eventControls.put(Period.NAME, definePeriod(eventType));
 85         }
 86         if (eventType.hasCutoff()) {
 87             eventControls.put(Cutoff.NAME, defineCutoff(eventType));
 88         }
 89 
 90         ArrayList&lt;AnnotationElement&gt; aes = new ArrayList&lt;&gt;(eventType.getAnnotationElements());
 91         remove(eventType, aes, Threshold.class);
 92         remove(eventType, aes, Period.class);
 93         remove(eventType, aes, Enabled.class);
 94         remove(eventType, aes, StackTrace.class);
 95         remove(eventType, aes, Cutoff.class);
 96         aes.trimToSize();
 97         eventType.setAnnotations(aes);
 98         this.type = eventType;
 99         this.idName = String.valueOf(eventType.getId());
100     }
101 
102     static void remove(PlatformEventType type, List&lt;AnnotationElement&gt; aes, Class&lt;? extends java.lang.annotation.Annotation&gt; clazz) {
103         long id = Type.getTypeId(clazz);
104         for (AnnotationElement a : type.getAnnotationElements()) {
105             if (a.getTypeId() == id &amp;&amp; a.getTypeName().equals(clazz.getName())) {
106                 aes.remove(a);
107             }
108         }
109     }
110 
111     EventControl(PlatformEventType es, Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
112         this(es);
113         defineSettings(eventClass);
114     }
115 
116     @SuppressWarnings(&quot;unchecked&quot;)
117     private void defineSettings(Class&lt;?&gt; eventClass) {
118         // Iterate up the class hierarchy and let
119         // subclasses shadow base classes.
120         boolean allowPrivateMethod = true;
121         while (eventClass != null) {
122             for (Method m : eventClass.getDeclaredMethods()) {
123                 boolean isPrivate = Modifier.isPrivate(m.getModifiers());
124                 if (m.getReturnType() == Boolean.TYPE &amp;&amp; m.getParameterCount() == 1 &amp;&amp; (!isPrivate || allowPrivateMethod)) {
125                     SettingDefinition se = m.getDeclaredAnnotation(SettingDefinition.class);
126                     if (se != null) {
127                         Class&lt;?&gt; settingClass = m.getParameters()[0].getType();
128                         if (!Modifier.isAbstract(settingClass.getModifiers()) &amp;&amp; SettingControl.class.isAssignableFrom(settingClass)) {
129                             String name = m.getName();
130                             Name n = m.getAnnotation(Name.class);
131                             if (n != null) {
132                                 name = n.value();
133                             }
134                             if (!eventControls.containsKey(name)) {
135                                 defineSetting((Class&lt;? extends SettingControl&gt;) settingClass, m, type, name);
136                             }
137                         }
138                     }
139                 }
140             }
141             eventClass = eventClass.getSuperclass();
142             allowPrivateMethod = false;
143         }
144     }
145 
146     private void defineSetting(Class&lt;? extends SettingControl&gt; settingsClass, Method method, PlatformEventType eventType, String settingName) {
147         try {
148             Module settingModule = settingsClass.getModule();
149             Modules.addReads(settingModule, EventControl.class.getModule());
150             int index = settingInfos.size();
151             SettingInfo si = new SettingInfo(FIELD_SETTING_PREFIX + index, index);
152             si.settingControl = instantiateSettingControl(settingsClass);
153             Control c = si.settingControl;
154             c.setDefault();
155             String defaultValue = c.getValueSafe();
156             if (defaultValue != null) {
157                 Type settingType = TypeLibrary.createType(settingsClass);
158                 ArrayList&lt;AnnotationElement&gt; aes = new ArrayList&lt;&gt;();
159                 for (Annotation a : method.getDeclaredAnnotations()) {
160                     AnnotationElement ae = TypeLibrary.createAnnotation(a);
161                     if (ae != null) {
162                         aes.add(ae);
163                     }
164                 }
165                 aes.trimToSize();
166                 eventControls.put(settingName, si.settingControl);
167                 eventType.add(PrivateAccess.getInstance().newSettingDescriptor(settingType, settingName, defaultValue, aes));
168                 settingInfos.add(si);
169             }
170         } catch (InstantiationException e) {
171             // Programming error by user, fail fast
172             throw new InstantiationError(&quot;Could not instantiate setting &quot; + settingsClass.getName() + &quot; for event &quot; + eventType.getLogName() + &quot;. &quot; + e.getMessage());
173         } catch (IllegalAccessException e) {
174             // Programming error by user, fail fast
175             throw new IllegalAccessError(&quot;Could not access setting &quot; + settingsClass.getName() + &quot; for event &quot; + eventType.getLogName() + &quot;. &quot; + e.getMessage());
176         }
177     }
178 
179     private SettingControl instantiateSettingControl(Class&lt;? extends SettingControl&gt; settingControlClass) throws IllegalAccessException, InstantiationException {
180         SecuritySupport.makeVisibleToJFR(settingControlClass);
181         final Constructor&lt;?&gt; cc;
182         try {
183             cc = settingControlClass.getDeclaredConstructors()[0];
184         } catch (Exception e) {
185             throw (Error) new InternalError(&quot;Could not get constructor for &quot; + settingControlClass.getName()).initCause(e);
186         }
187         SecuritySupport.setAccessible(cc);
188         try {
189             return (SettingControl) cc.newInstance();
190         } catch (IllegalArgumentException | InvocationTargetException e) {
191             throw (Error) new InternalError(&quot;Could not instantiate setting for class &quot; + settingControlClass.getName());
192         }
193     }
194 
195     private static Control defineEnabled(PlatformEventType type) {
196         Enabled enabled = type.getAnnotation(Enabled.class);
197         // Java events are enabled by default,
198         // JVM events are not, maybe they should be? Would lower learning curve
199         // there too.
200         String def = type.isJVM() ? &quot;false&quot; : &quot;true&quot;;
201         if (enabled != null) {
202             def = Boolean.toString(enabled.value());
203         }
204         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_ENABLED, Enabled.NAME, def, Collections.emptyList()));
205         return new EnabledSetting(type, def);
206     }
207 
208     private static Control defineThreshold(PlatformEventType type) {
209         Threshold threshold = type.getAnnotation(Threshold.class);
210         String def = &quot;0 ns&quot;;
211         if (threshold != null) {
212             def = threshold.value();
213         }
214         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_THRESHOLD, Threshold.NAME, def, Collections.emptyList()));
215         return new ThresholdSetting(type, def);
216     }
217 
218     private static Control defineStackTrace(PlatformEventType type) {
219         StackTrace stackTrace = type.getAnnotation(StackTrace.class);
220         String def = &quot;true&quot;;
221         if (stackTrace != null) {
222             def = Boolean.toString(stackTrace.value());
223         }
224         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_STACK_TRACE, StackTrace.NAME, def, Collections.emptyList()));
225         return new StackTraceSetting(type, def);
226     }
227 
228     private static Control defineCutoff(PlatformEventType type) {
229         Cutoff cutoff = type.getAnnotation(Cutoff.class);
230         String def = Cutoff.INIFITY;
231         if (cutoff != null) {
232             def = cutoff.value();
233         }
234         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_CUTOFF, Cutoff.NAME, def, Collections.emptyList()));
235         return new CutoffSetting(type, def);
236     }
237 
238 
239     private static Control definePeriod(PlatformEventType type) {
240         Period period = type.getAnnotation(Period.class);
241         String def = &quot;everyChunk&quot;;
242         if (period != null) {
243             def = period.value();
244         }
245         type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_PERIOD, PeriodSetting.NAME, def, Collections.emptyList()));
246         return new PeriodSetting(type, def);
247     }
248 
249     void disable() {
250         for (Control c : eventControls.values()) {
251             if (c instanceof EnabledSetting) {
252                 c.setValueSafe(&quot;false&quot;);
253                 return;
254             }
255         }
256     }
257 
258     void writeActiveSettingEvent() {
259         if (!type.isRegistered()) {
260             return;
261         }
262         for (Map.Entry&lt;String, Control&gt; entry : eventControls.entrySet()) {
263             Control c = entry.getValue();
264             if (Utils.isSettingVisible(c, type.hasEventHook())) {
265                 String value = c.getLastValue();
266                 if (value == null) {
267                     value = c.getDefaultValue();
268                 }
269                 ActiveSettingEvent ase = new ActiveSettingEvent();
270                 ase.id = type.getId();
271                 ase.name = entry.getKey();
272                 ase.value = value;
273                 ase.commit();
274             }
275         }
276     }
277 
278     public Set&lt;Entry&lt;String, Control&gt;&gt; getEntries() {
279         return eventControls.entrySet();
280     }
281 
282     public PlatformEventType getEventType() {
283         return type;
284     }
285 
286     public String getSettingsId() {
287         return idName;
288     }
289 
290     public List&lt;SettingInfo&gt; getSettingInfos() {
291         return settingInfos;
292     }
293 }
    </pre>
  </body>
</html>
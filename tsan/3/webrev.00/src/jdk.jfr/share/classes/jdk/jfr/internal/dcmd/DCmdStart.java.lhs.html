<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/dcmd/DCmdStart.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.jfr.internal.dcmd;
 26 
<a name="2" id="anc2"></a>
 27 import java.io.IOException;
 28 import java.nio.file.Files;
 29 import java.nio.file.InvalidPathException;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.text.ParseException;
 33 import java.time.Duration;
 34 import java.util.Arrays;
 35 import java.util.HashMap;
 36 import java.util.Map;
 37 
 38 import jdk.jfr.FlightRecorder;
 39 import jdk.jfr.Recording;
 40 import jdk.jfr.internal.JVM;
 41 import jdk.jfr.internal.LogLevel;
 42 import jdk.jfr.internal.LogTag;
 43 import jdk.jfr.internal.Logger;
 44 import jdk.jfr.internal.OldObjectSample;
<a name="3" id="anc3"></a>
 45 import jdk.jfr.internal.PrivateAccess;
 46 import jdk.jfr.internal.SecuritySupport.SafePath;
 47 import jdk.jfr.internal.Type;
 48 import jdk.jfr.internal.jfc.JFC;
 49 
 50 /**
 51  * JFR.start
 52  *
 53  */
 54 //Instantiated by native
 55 final class DCmdStart extends AbstractDCmd {
 56 
 57     /**
 58      * Execute JFR.start.
 59      *
 60      * @param name optional name that can be used to identify recording.
 61      * @param settings names of settings files to use, i.e. &quot;default&quot; or
 62      *        &quot;default.jfc&quot;.
 63      * @param delay delay before recording is started, in nanoseconds. Must be
 64      *        at least 1 second.
 65      * @param duration duration of the recording, in nanoseconds. Must be at
 66      *        least 1 second.
 67      * @param disk if recording should be persisted to disk
 68      * @param path file path where recording data should be written
 69      * @param maxAge how long recording data should be kept in the disk
 70      *        repository, or &lt;code&gt;0&lt;/code&gt; if no limit should be set.
 71      *
 72      * @param maxSize the minimum amount data to keep in the disk repository
 73      *        before it is discarded, or &lt;code&gt;0&lt;/code&gt; if no limit should be
 74      *        set.
 75      *
 76      * @param dumpOnExit if recording should dump on exit
 77      *
 78      * @return result output
 79      *
 80      * @throws DCmdException if recording could not be started
 81      */
 82     @SuppressWarnings(&quot;resource&quot;)
<a name="4" id="anc4"></a><span class="line-modified"> 83     public String execute(String name, String[] settings, Long delay, Long duration, Boolean disk, String path, Long maxAge, Long maxSize, Boolean dumpOnExit, Boolean pathToGcRoots) throws DCmdException {</span>
 84         if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {
 85             Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, &quot;Executing DCmdStart: name=&quot; + name +
 86                     &quot;, settings=&quot; + Arrays.asList(settings) +
 87                     &quot;, delay=&quot; + delay +
 88                     &quot;, duration=&quot; + duration +
 89                     &quot;, disk=&quot; + disk+
 90                     &quot;, filename=&quot; + path +
 91                     &quot;, maxage=&quot; + maxAge +
<a name="5" id="anc5"></a>
 92                     &quot;, maxsize=&quot; + maxSize +
 93                     &quot;, dumponexit =&quot; + dumpOnExit +
 94                     &quot;, path-to-gc-roots=&quot; + pathToGcRoots);
 95         }
 96         if (name != null) {
 97             try {
 98                 Integer.parseInt(name);
 99                 throw new DCmdException(&quot;Name of recording can&#39;t be numeric&quot;);
100             } catch (NumberFormatException nfe) {
101                 // ok, can&#39;t be mixed up with name
102             }
103         }
104 
105         if (duration == null &amp;&amp; Boolean.FALSE.equals(dumpOnExit) &amp;&amp; path != null) {
106             throw new DCmdException(&quot;Filename can only be set for a time bound recording or if dumponexit=true. Set duration/dumponexit or omit filename.&quot;);
107         }
<a name="6" id="anc6"></a><span class="line-modified">108 </span>


109         Map&lt;String, String&gt; s = new HashMap&lt;&gt;();
110         for (String configName : settings) {
111             try {
112                 s.putAll(JFC.createKnown(configName).getSettings());
<a name="7" id="anc7"></a>

113             } catch (IOException | ParseException e) {
<a name="8" id="anc8"></a><span class="line-modified">114                 throw new DCmdException(&quot;Could not parse setting &quot; + settings[0], e);</span>
115             }
116         }
117 
118         OldObjectSample.updateSettingPathToGcRoots(s, pathToGcRoots);
119 
120         if (duration != null) {
121             if (duration &lt; 1000L * 1000L * 1000L) {
122                 // to avoid typo, duration below 1s makes no sense
123                 throw new DCmdException(&quot;Could not start recording, duration must be at least 1 second.&quot;);
124             }
125         }
126 
127         if (delay != null) {
128             if (delay &lt; 1000L * 1000L * 1000) {
129                 // to avoid typo, delay shorter than 1s makes no sense.
130                 throw new DCmdException(&quot;Could not start recording, delay must be at least 1 second.&quot;);
131             }
132         }
133 
<a name="9" id="anc9"></a>





134         if (!FlightRecorder.isInitialized() &amp;&amp; delay == null) {
135             initializeWithForcedInstrumentation(s);
136         }
137 
138         Recording recording = new Recording();
139         if (name != null) {
140             recording.setName(name);
141         }
142 
143         if (disk != null) {
144             recording.setToDisk(disk.booleanValue());
145         }
<a name="10" id="anc10"></a>
146         recording.setSettings(s);
147         SafePath safePath = null;
148 
149         if (path != null) {
150             try {
151                 if (dumpOnExit == null) {
152                     // default to dumponexit=true if user specified filename
153                     dumpOnExit = Boolean.TRUE;
154                 }
155                 Path p = Paths.get(path);
156                 if (Files.isDirectory(p) &amp;&amp; Boolean.TRUE.equals(dumpOnExit)) {
157                     // Decide destination filename at dump time
158                     // Purposely avoid generating filename in Recording#setDestination due to
159                     // security concerns
160                     PrivateAccess.getInstance().getPlatformRecording(recording).setDumpOnExitDirectory(new SafePath(p));
161                 } else {
162                     safePath = resolvePath(recording, path);
163                     recording.setDestination(safePath.toPath());
164                 }
165             } catch (IOException | InvalidPathException e) {
166                 recording.close();
167                 throw new DCmdException(&quot;Could not start recording, not able to write to file %s. %s &quot;, path, e.getMessage());
168             }
169         }
170 
171         if (maxAge != null) {
172             recording.setMaxAge(Duration.ofNanos(maxAge));
173         }
174 
<a name="11" id="anc11"></a>




175         if (maxSize != null) {
176             recording.setMaxSize(maxSize);
177         }
178 
179         if (duration != null) {
180             recording.setDuration(Duration.ofNanos(duration));
181         }
182 
183         if (dumpOnExit != null) {
184             recording.setDumpOnExit(dumpOnExit);
185         }
186 
187         if (delay != null) {
188             Duration dDelay = Duration.ofNanos(delay);
189             recording.scheduleStart(dDelay);
190             print(&quot;Recording &quot; + recording.getId() + &quot; scheduled to start in &quot;);
191             printTimespan(dDelay, &quot; &quot;);
192             print(&quot;.&quot;);
193         } else {
194             recording.start();
195             print(&quot;Started recording &quot; + recording.getId() + &quot;.&quot;);
196         }
197 
198         if (recording.isToDisk() &amp;&amp; duration == null &amp;&amp; maxAge == null &amp;&amp; maxSize == null) {
199             print(&quot; No limit specified, using maxsize=250MB as default.&quot;);
200             recording.setMaxSize(250*1024L*1024L);
201         }
202 
203         if (safePath != null &amp;&amp; duration != null) {
204             println(&quot; The result will be written to:&quot;);
205             println();
206             printPath(safePath);
207         } else {
208             println();
209             println();
210             String cmd = duration == null ? &quot;dump&quot; : &quot;stop&quot;;
211             String fileOption = path == null ? &quot;filename=FILEPATH &quot; : &quot;&quot;;
212             String recordingspecifier = &quot;name=&quot; + recording.getId();
213             // if user supplied a name, use it.
214             if (name != null) {
215                 recordingspecifier = &quot;name=&quot; + quoteIfNeeded(name);
216             }
217             print(&quot;Use jcmd &quot; + getPid() + &quot; JFR.&quot; + cmd + &quot; &quot; + recordingspecifier + &quot; &quot; + fileOption + &quot;to copy recording data to file.&quot;);
218             println();
219         }
<a name="12" id="anc12"></a>
220         return getResult();
221     }
222 
223 
224     // Instruments JDK-events on class load to reduce startup time
225     private void initializeWithForcedInstrumentation(Map&lt;String, String&gt; settings) {
226         if (!hasJDKEvents(settings)) {
227             return;
228         }
229         JVM jvm = JVM.getJVM();
230         try {
231             jvm.setForceInstrumentation(true);
232             FlightRecorder.getFlightRecorder();
233         } finally {
234             jvm.setForceInstrumentation(false);
235         }
236     }
237 
238     private boolean hasJDKEvents(Map&lt;String, String&gt; settings) {
239         String[] eventNames = new String[7];
240         eventNames[0] = &quot;FileRead&quot;;
241         eventNames[1] = &quot;FileWrite&quot;;
242         eventNames[2] = &quot;SocketRead&quot;;
243         eventNames[3] = &quot;SocketWrite&quot;;
244         eventNames[4] = &quot;JavaErrorThrow&quot;;
245         eventNames[5] = &quot;JavaExceptionThrow&quot;;
246         eventNames[6] = &quot;FileForce&quot;;
247         for (String eventName : eventNames) {
248             if (&quot;true&quot;.equals(settings.get(Type.EVENT_NAME_PREFIX + eventName + &quot;#enabled&quot;))) {
249                 return true;
250             }
251         }
252         return false;
253     }
254 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
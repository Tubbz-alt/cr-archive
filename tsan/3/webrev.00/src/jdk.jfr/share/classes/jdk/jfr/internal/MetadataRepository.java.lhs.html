<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataRepository.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import static jdk.jfr.internal.LogLevel.DEBUG;
 29 import static jdk.jfr.internal.LogTag.JFR_SYSTEM;
 30 
 31 import java.io.ByteArrayOutputStream;
 32 import java.io.DataOutputStream;
 33 import java.io.IOException;
 34 import java.util.ArrayList;
 35 import java.util.Collections;
 36 import java.util.HashMap;
 37 import java.util.HashSet;
 38 import java.util.List;
 39 import java.util.Map;
 40 
 41 import jdk.jfr.AnnotationElement;
 42 import jdk.jfr.Event;
 43 import jdk.jfr.EventType;
 44 import jdk.jfr.Period;
 45 import jdk.jfr.StackTrace;
 46 import jdk.jfr.Threshold;
 47 import jdk.jfr.ValueDescriptor;
 48 import jdk.jfr.internal.RequestEngine.RequestHook;
<a name="2" id="anc2"></a>
 49 import jdk.jfr.internal.handlers.EventHandler;
 50 
 51 public final class MetadataRepository {
 52 
 53     private static final JVM jvm = JVM.getJVM();
 54     private static final MetadataRepository instace = new MetadataRepository();
 55 
 56     private final List&lt;EventType&gt; nativeEventTypes = new ArrayList&lt;&gt;(100);
 57     private final List&lt;EventControl&gt; nativeControls = new ArrayList&lt;EventControl&gt;(100);
 58     private final TypeLibrary typeLibrary = TypeLibrary.getInstance();
 59     private final SettingsManager settingsManager = new SettingsManager();
 60     private final Map&lt;String, Class&lt;? extends Event&gt;&gt; mirrors = new HashMap&lt;&gt;();
 61     private boolean staleMetadata = true;
 62     private boolean unregistered;
 63     private long lastUnloaded = -1;
 64 
 65     public MetadataRepository() {
 66         initializeJVMEventTypes();
 67     }
 68 
 69     private void initializeJVMEventTypes() {
 70         List&lt;RequestHook&gt; requestHooks = new ArrayList&lt;&gt;();
 71         for (Type type : typeLibrary.getTypes()) {
 72             if (type instanceof PlatformEventType) {
 73                 PlatformEventType pEventType = (PlatformEventType) type;
 74                 EventType eventType = PrivateAccess.getInstance().newEventType(pEventType);
 75                 pEventType.setHasDuration(eventType.getAnnotation(Threshold.class) != null);
 76                 pEventType.setHasStackTrace(eventType.getAnnotation(StackTrace.class) != null);
 77                 pEventType.setHasCutoff(eventType.getAnnotation(Cutoff.class) != null);
 78                 pEventType.setHasPeriod(eventType.getAnnotation(Period.class) != null);
 79                 // Must add hook before EventControl is created as it removes
 80                 // annotations, such as Period and Threshold.
 81                 if (pEventType.hasPeriod()) {
 82                     pEventType.setEventHook(true);
 83                     if (!(Type.EVENT_NAME_PREFIX + &quot;ExecutionSample&quot;).equals(type.getName())) {
 84                         requestHooks.add(new RequestHook(pEventType));
 85                     }
 86                 }
 87                 nativeControls.add(new EventControl(pEventType));
 88                 nativeEventTypes.add(eventType);
 89             }
 90         }
 91         RequestEngine.addHooks(requestHooks);
 92     }
 93 
 94     public static MetadataRepository getInstance() {
 95         return instace;
 96     }
 97 
 98     public synchronized List&lt;EventType&gt; getRegisteredEventTypes() {
 99         List&lt;EventHandler&gt; handlers = getEventHandlers();
100         List&lt;EventType&gt; eventTypes = new ArrayList&lt;&gt;(handlers.size() + nativeEventTypes.size());
101         for (EventHandler h : handlers) {
102             if (h.isRegistered()) {
103                 eventTypes.add(h.getEventType());
104             }
105         }
106         eventTypes.addAll(nativeEventTypes);
107         return eventTypes;
108     }
109 
110     public synchronized EventType getEventType(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
111         EventHandler h = getHandler(eventClass);
112         if (h != null &amp;&amp; h.isRegistered()) {
113             return h.getEventType();
114         }
115         throw new IllegalStateException(&quot;Event class &quot; + eventClass.getName() + &quot; is not registered&quot;);
116     }
117 
118     public synchronized void unregister(Class&lt;? extends Event&gt; eventClass) {
119         Utils.checkRegisterPermission();
120         EventHandler handler = getHandler(eventClass);
121         if (handler != null) {
122             handler.setRegistered(false);
123         }
124         // never registered, ignore call
125     }
126     public synchronized EventType register(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
127         return register(eventClass, Collections.emptyList(), Collections.emptyList());
128     }
129 
130     public synchronized EventType register(Class&lt;? extends jdk.internal.event.Event&gt; eventClass, List&lt;AnnotationElement&gt; dynamicAnnotations, List&lt;ValueDescriptor&gt; dynamicFields) {
131         Utils.checkRegisterPermission();
132         EventHandler handler = getHandler(eventClass);
133         if (handler == null) {
134             if (eventClass.getAnnotation(MirrorEvent.class) != null) {
135                 // don&#39;t register mirrors
136                 return null;
137             }
138             PlatformEventType pe = findMirrorType(eventClass);
139             handler = makeHandler(eventClass, pe, dynamicAnnotations, dynamicFields);
140         }
141         handler.setRegistered(true);
142         typeLibrary.addType(handler.getPlatformEventType());
143         if (jvm.isRecording()) {
144             storeDescriptorInJVM(); // needed for emergency dump
145             settingsManager.setEventControl(handler.getEventControl());
146             settingsManager.updateRetransform(Collections.singletonList((eventClass)));
147         } else {
148             setStaleMetadata();
149         }
150         return handler.getEventType();
151     }
152 
153     private PlatformEventType findMirrorType(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) throws InternalError {
154         String fullName = eventClass.getModule().getName() + &quot;:&quot; + eventClass.getName();
155         Class&lt;? extends Event&gt; mirrorClass = mirrors.get(fullName);
156         if (mirrorClass == null) {
157             return null; // not a mirror
158         }
159         Utils.verifyMirror(mirrorClass, eventClass);
160         PlatformEventType et = (PlatformEventType) TypeLibrary.createType(mirrorClass);
161         typeLibrary.removeType(et.getId());
162         long id = Type.getTypeId(eventClass);
163         et.setId(id);
164         return et;
165     }
166 
167     private EventHandler getHandler(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
168         Utils.ensureValidEventSubclass(eventClass);
169         SecuritySupport.makeVisibleToJFR(eventClass);
170         Utils.ensureInitialized(eventClass);
171         return Utils.getHandler(eventClass);
172     }
173 
174     private EventHandler makeHandler(Class&lt;? extends jdk.internal.event.Event&gt; eventClass, PlatformEventType pEventType, List&lt;AnnotationElement&gt; dynamicAnnotations, List&lt;ValueDescriptor&gt; dynamicFields) throws InternalError {
175         SecuritySupport.addHandlerExport(eventClass);
176         if (pEventType == null) {
177             pEventType = (PlatformEventType) TypeLibrary.createType(eventClass, dynamicAnnotations, dynamicFields);
178         }
179         EventType eventType = PrivateAccess.getInstance().newEventType(pEventType);
180         EventControl ec = new EventControl(pEventType, eventClass);
181         Class&lt;? extends EventHandler&gt; handlerClass = null;
182         try {
183             String eventHandlerName = EventHandlerCreator.makeEventHandlerName(eventType.getId());
184             handlerClass = Class.forName(eventHandlerName, false, Event.class.getClassLoader()).asSubclass(EventHandler.class);
185             // Created eagerly on class load, tag as instrumented
186             pEventType.setInstrumented();
187             Logger.log(JFR_SYSTEM, DEBUG, &quot;Found existing event handler for &quot; + eventType.getName());
188        } catch (ClassNotFoundException cne) {
189            EventHandlerCreator ehc = new EventHandlerCreator(eventType.getId(),  ec.getSettingInfos(), eventType, eventClass);
190            handlerClass = ehc.makeEventHandlerClass();
191            Logger.log(LogTag.JFR_SYSTEM, DEBUG, &quot;Created event handler for &quot; + eventType.getName());
192        }
193         EventHandler handler = EventHandlerCreator.instantiateEventHandler(handlerClass, true, eventType, ec);
194         Utils.setHandler(eventClass, handler);
195         return handler;
196     }
197 
198 
199     public synchronized void setSettings(List&lt;Map&lt;String, String&gt;&gt; list) {
200         settingsManager.setSettings(list);
201     }
202 
203     synchronized void disableEvents() {
204         for (EventControl c : getEventControls()) {
205             c.disable();
206         }
207     }
208 
209     public synchronized List&lt;EventControl&gt; getEventControls() {
<a name="3" id="anc3"></a><span class="line-modified">210         List&lt;EventControl&gt; controls = new ArrayList&lt;&gt;();</span>

211         controls.addAll(nativeControls);
<a name="4" id="anc4"></a><span class="line-modified">212         for (EventHandler eh : getEventHandlers()) {</span>
<span class="line-modified">213             controls.add(eh.getEventControl());</span>



214         }
215         return controls;
216     }
217 
218     private void storeDescriptorInJVM() throws InternalError {
219         jvm.storeMetadataDescriptor(getBinaryRepresentation());
220         staleMetadata = false;
221     }
222 
223     private static List&lt;EventHandler&gt; getEventHandlers() {
224         List&lt;Class&lt;? extends jdk.internal.event.Event&gt;&gt; allEventClasses = jvm.getAllEventClasses();
225         List&lt;EventHandler&gt; eventHandlers = new ArrayList&lt;&gt;(allEventClasses.size());
226         for (Class&lt;? extends jdk.internal.event.Event&gt; clazz : allEventClasses) {
227             EventHandler eh = Utils.getHandler(clazz);
228             if (eh != null) {
229                 eventHandlers.add(eh);
230             }
231         }
232         return eventHandlers;
233     }
234 
235     private byte[] getBinaryRepresentation() {
236         ByteArrayOutputStream baos = new ByteArrayOutputStream(40000);
237         DataOutputStream daos = new DataOutputStream(baos);
238         try {
239             List&lt;Type&gt; types = typeLibrary.getTypes();
240             Collections.sort(types);
241             MetadataDescriptor.write(types, daos);
242             daos.flush();
243             return baos.toByteArray();
244         } catch (IOException e) {
245             // should not happen
246             throw new InternalError(e);
247         }
248     }
249 
250     synchronized boolean isEnabled(String eventName) {
251         return settingsManager.isEnabled(eventName);
252     }
253 
254     synchronized void setStaleMetadata() {
255         staleMetadata = true;
256     }
257 
<a name="5" id="anc5"></a><span class="line-modified">258     // Lock around setOutput ensures that other threads dosn&#39;t</span>
<span class="line-modified">259     // emit event after setOutput and unregister the event class, before a call</span>
260     // to storeDescriptorInJVM
261     synchronized void setOutput(String filename) {
<a name="6" id="anc6"></a>


262         jvm.setOutput(filename);
<a name="7" id="anc7"></a><span class="line-modified">263 </span>


264         unregisterUnloaded();
265         if (unregistered) {
<a name="8" id="anc8"></a><span class="line-modified">266             staleMetadata = typeLibrary.clearUnregistered();</span>


267             unregistered = false;
268         }
<a name="9" id="anc9"></a><span class="line-removed">269         if (staleMetadata) {</span>
<span class="line-removed">270             storeDescriptorInJVM();</span>
<span class="line-removed">271         }</span>
272     }
273 
274     private void unregisterUnloaded() {
275         long unloaded = jvm.getUnloadedEventClassCount();
276         if (this.lastUnloaded != unloaded) {
277             this.lastUnloaded = unloaded;
278             List&lt;Class&lt;? extends jdk.internal.event.Event&gt;&gt; eventClasses = jvm.getAllEventClasses();
279             HashSet&lt;Long&gt; knownIds = new HashSet&lt;&gt;(eventClasses.size());
280             for (Class&lt;? extends jdk.internal.event.Event&gt;  ec: eventClasses) {
281                 knownIds.add(Type.getTypeId(ec));
282             }
283             for (Type type : typeLibrary.getTypes()) {
284                 if (type instanceof PlatformEventType) {
285                     if (!knownIds.contains(type.getId())) {
286                         PlatformEventType pe = (PlatformEventType) type;
287                         if (!pe.isJVM()) {
288                             pe.setRegistered(false);
289                         }
290                     }
291                 }
292             }
293         }
294     }
295 
296     synchronized void setUnregistered() {
297        unregistered = true;
298     }
299 
300     public synchronized void registerMirror(Class&lt;? extends Event&gt; eventClass) {
301         MirrorEvent me = eventClass.getAnnotation(MirrorEvent.class);
302         if (me != null) {
303             String fullName = me.module() + &quot;:&quot; + me.className();
304             mirrors.put(fullName, eventClass);
305             return;
306         }
307         throw new InternalError(&quot;Mirror class must have annotation &quot; + MirrorEvent.class.getName());
308     }
309 
<a name="10" id="anc10"></a>






310 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
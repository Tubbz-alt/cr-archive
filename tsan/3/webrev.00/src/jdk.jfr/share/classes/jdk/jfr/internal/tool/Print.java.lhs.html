<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Print.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.tool;
 27 
 28 import java.io.IOException;
 29 import java.io.PrintStream;
 30 import java.io.PrintWriter;
 31 import java.nio.charset.Charset;
 32 import java.nio.file.Path;
 33 import java.util.ArrayList;
 34 import java.util.Deque;
 35 import java.util.HashMap;
 36 import java.util.List;
 37 import java.util.Map;
 38 import java.util.function.Function;
 39 import java.util.function.Predicate;
 40 
 41 import jdk.jfr.EventType;
 42 
 43 final class Print extends Command {
 44     @Override
 45     public String getName() {
 46         return &quot;print&quot;;
 47     }
 48 
 49     @Override
 50     public List&lt;String&gt; getOptionSyntax() {
 51         List&lt;String&gt; list = new ArrayList&lt;&gt;();
 52         list.add(&quot;[--xml|--json]&quot;);
 53         list.add(&quot;[--categories &lt;filter&gt;]&quot;);
 54         list.add(&quot;[--events &lt;filter&gt;]&quot;);
 55         list.add(&quot;[--stack-depth &lt;depth&gt;]&quot;);
 56         list.add(&quot;&lt;file&gt;&quot;);
 57         return list;
 58     }
 59 
 60     @Override
 61     protected String getTitle() {
 62         return &quot;Print contents of a recording file&quot;;
 63     }
 64 
 65     @Override
 66     public String getDescription() {
 67         return getTitle() + &quot;. See &#39;jfr help print&#39; for details.&quot;;
 68     }
 69 
 70     @Override
 71     public void displayOptionUsage(PrintStream stream) {
 72         stream.println(&quot;  --xml                   Print recording in XML format&quot;);
 73         stream.println();
 74         stream.println(&quot;  --json                  Print recording in JSON format&quot;);
 75         stream.println();
 76         stream.println(&quot;  --categories &lt;filter&gt;   Select events matching a category name.&quot;);
 77         stream.println(&quot;                          The filter is a comma-separated list of names,&quot;);
 78         stream.println(&quot;                          simple and/or qualified, and/or quoted glob patterns&quot;);
 79         stream.println();
 80         stream.println(&quot;  --events &lt;filter&gt;       Select events matching an event name.&quot;);
 81         stream.println(&quot;                          The filter is a comma-separated list of names,&quot;);
 82         stream.println(&quot;                          simple and/or qualified, and/or quoted glob patterns&quot;);
 83         stream.println();
 84         stream.println(&quot;  --stack-depth &lt;depth&gt;   Number of frames in stack traces, by default 5&quot;);
 85         stream.println();
 86         stream.println(&quot;  &lt;file&gt;                  Location of the recording file (.jfr)&quot;);
 87         stream.println();
 88         stream.println();
 89         stream.println(&quot;Example usage:&quot;);
 90         stream.println();
 91         stream.println(&quot; jfr print --events OldObjectSample recording.jfr&quot;);
 92         stream.println();
 93         stream.println(&quot; jfr print --events CPULoad,GarbageCollection recording.jfr&quot;);
 94         stream.println();
 95         stream.println(&quot; jfr print --categories \&quot;GC,JVM,Java*\&quot; recording.jfr&quot;);
 96         stream.println();
 97         stream.println(&quot; jfr print --events \&quot;jdk.*\&quot; --stack-depth 64 recording.jfr&quot;);
 98         stream.println();
 99         stream.println(&quot; jfr print --json --events CPULoad recording.jfr&quot;);
100     }
101 
102     @Override
103     public void execute(Deque&lt;String&gt; options) throws UserSyntaxException, UserDataException {
104         Path file = getJFRInputFile(options);
105         PrintWriter pw = new PrintWriter(System.out, false, Charset.forName(&quot;UTF-8&quot;));
106         Predicate&lt;EventType&gt; eventFilter = null;
107         int stackDepth = 5;
108         EventPrintWriter eventWriter = null;
109         int optionCount = options.size();
<a name="1" id="anc1"></a>

110         while (optionCount &gt; 0) {
111             if (acceptFilterOption(options, &quot;--events&quot;)) {
<a name="2" id="anc2"></a>



112                 String filter = options.remove();
113                 warnForWildcardExpansion(&quot;--events&quot;, filter);
114                 eventFilter = addEventFilter(filter, eventFilter);
115             }
116             if (acceptFilterOption(options, &quot;--categories&quot;)) {
<a name="3" id="anc3"></a>



117                 String filter = options.remove();
118                 warnForWildcardExpansion(&quot;--categories&quot;, filter);
119                 eventFilter = addCategoryFilter(filter, eventFilter);
120             }
121             if (acceptOption(options, &quot;--stack-depth&quot;)) {
122                 String value = options.pop();
123                 try {
124                     stackDepth = Integer.parseInt(value);
125                     if (stackDepth &lt; 0) {
126                         throw new UserSyntaxException(&quot;stack depth must be zero or a positive integer.&quot;);
127                     }
128                 } catch (NumberFormatException nfe) {
129                     throw new UserSyntaxException(&quot;not a valid value for --stack-depth&quot;);
130                 }
131             }
132             if (acceptFormatterOption(options, eventWriter, &quot;--json&quot;)) {
133                 eventWriter = new JSONWriter(pw);
134             }
135             if (acceptFormatterOption(options, eventWriter, &quot;--xml&quot;)) {
136                 eventWriter = new XMLWriter(pw);
137             }
138             if (optionCount == options.size()) {
139                 // No progress made
<a name="4" id="anc4"></a>

140                 throw new UserSyntaxException(&quot;unknown option &quot; + options.peek());
141             }
142             optionCount = options.size();
143         }
144         if (eventWriter == null) {
145             eventWriter = new PrettyWriter(pw); // default to pretty printer
146         }
147         eventWriter.setStackDepth(stackDepth);
148         if (eventFilter != null) {
149             eventFilter = addCache(eventFilter, eventType -&gt; eventType.getId());
150             eventWriter.setEventFilter(eventFilter);
151         }
152         try {
153             eventWriter.print(file);
154         } catch (IOException ioe) {
155             couldNotReadError(file, ioe);
156         }
157         pw.flush();
158     }
159 
<a name="5" id="anc5"></a>





160     private static boolean acceptFormatterOption(Deque&lt;String&gt; options, EventPrintWriter eventWriter, String expected) throws UserSyntaxException {
161         if (expected.equals(options.peek())) {
162             if (eventWriter != null) {
163                 throw new UserSyntaxException(&quot;only one format can be specified at a time&quot;);
164             }
165             options.remove();
166             return true;
167         }
168         return false;
169     }
170 
171     private static &lt;T, X&gt; Predicate&lt;T&gt; addCache(final Predicate&lt;T&gt; filter, Function&lt;T, X&gt; cacheFunction) {
172         Map&lt;X, Boolean&gt; cache = new HashMap&lt;&gt;();
173         return t -&gt; cache.computeIfAbsent(cacheFunction.apply(t), x -&gt; filter.test(t));
174     }
175 
176     private static &lt;T&gt; Predicate&lt;T&gt; recurseIfPossible(Predicate&lt;T&gt; filter) {
177         return x -&gt; filter != null &amp;&amp; filter.test(x);
178     }
179 
180     private static Predicate&lt;EventType&gt; addCategoryFilter(String filterText, Predicate&lt;EventType&gt; eventFilter) throws UserSyntaxException {
181         List&lt;String&gt; filters = explodeFilter(filterText);
<a name="6" id="anc6"></a><span class="line-modified">182         return recurseIfPossible(eventType -&gt; {</span>
183             for (String category : eventType.getCategoryNames()) {
184                 for (String filter : filters) {
185                     if (match(category, filter)) {
186                         return true;
187                     }
188                     if (category.contains(&quot; &quot;) &amp;&amp; acronomify(category).equals(filter)) {
189                         return true;
190                     }
191                 }
192             }
193             return false;
194         });
<a name="7" id="anc7"></a>
195     }
196 
197     private static String acronomify(String multipleWords) {
198         boolean newWord = true;
199         String acronym = &quot;&quot;;
200         for (char c : multipleWords.toCharArray()) {
201             if (newWord) {
202                 if (Character.isAlphabetic(c) &amp;&amp; Character.isUpperCase(c)) {
203                     acronym += c;
204                 }
205             }
206             newWord = Character.isWhitespace(c);
207         }
208         return acronym;
209     }
210 
211     private static Predicate&lt;EventType&gt; addEventFilter(String filterText, final Predicate&lt;EventType&gt; eventFilter) throws UserSyntaxException {
212         List&lt;String&gt; filters = explodeFilter(filterText);
<a name="8" id="anc8"></a><span class="line-modified">213         return recurseIfPossible(eventType -&gt; {</span>
214             for (String filter : filters) {
215                 String fullEventName = eventType.getName();
216                 if (match(fullEventName, filter)) {
217                     return true;
218                 }
219                 String eventName = fullEventName.substring(fullEventName.lastIndexOf(&quot;.&quot;) + 1);
220                 if (match(eventName, filter)) {
221                     return true;
222                 }
223             }
224             return false;
225         });
<a name="9" id="anc9"></a>
226     }
227 
228     private static boolean match(String text, String filter) {
229         if (filter.length() == 0) {
230             // empty filter string matches if string is empty
231             return text.length() == 0;
232         }
233         if (filter.charAt(0) == &#39;*&#39;) { // recursive check
234             filter = filter.substring(1);
235             for (int n = 0; n &lt;= text.length(); n++) {
236                 if (match(text.substring(n), filter))
237                     return true;
238             }
239         } else if (text.length() == 0) {
240             // empty string and non-empty filter does not match
241             return false;
242         } else if (filter.charAt(0) == &#39;?&#39;) {
243             // eat any char and move on
244             return match(text.substring(1), filter.substring(1));
245         } else if (filter.charAt(0) == text.charAt(0)) {
246             // eat chars and move on
247             return match(text.substring(1), filter.substring(1));
248         }
249         return false;
250     }
251 
252     private static List&lt;String&gt; explodeFilter(String filter) throws UserSyntaxException {
253         List&lt;String&gt; list = new ArrayList&lt;&gt;();
254         for (String s : filter.split(&quot;,&quot;)) {
255             s = s.trim();
256             if (!s.isEmpty()) {
257                 list.add(s);
258             }
259         }
260         return list;
261     }
262 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
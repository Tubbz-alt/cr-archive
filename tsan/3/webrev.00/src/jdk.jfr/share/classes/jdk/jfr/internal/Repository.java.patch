diff a/src/jdk.jfr/share/classes/jdk/jfr/internal/Repository.java b/src/jdk.jfr/share/classes/jdk/jfr/internal/Repository.java
--- a/src/jdk.jfr/share/classes/jdk/jfr/internal/Repository.java
+++ b/src/jdk.jfr/share/classes/jdk/jfr/internal/Repository.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,10 +41,11 @@
     private static final JVM jvm = JVM.getJVM();
     private static final Repository instance = new Repository();
 
     public final static DateTimeFormatter REPO_DATE_FORMAT = DateTimeFormatter
             .ofPattern("yyyy_MM_dd_HH_mm_ss");
+    private static final String JFR_REPOSITORY_LOCATION_PROPERTY = "jdk.jfr.repository";
 
     private final Set<SafePath> cleanupDirectories = new HashSet<>();
     private SafePath baseLocation;
     private SafePath repository;
 
@@ -53,11 +54,15 @@
 
     public static Repository getRepository() {
         return instance;
     }
 
-    public synchronized void setBasePath(SafePath baseLocation) throws Exception {
+    public synchronized void setBasePath(SafePath baseLocation) throws IOException {
+        if(baseLocation.equals(this.baseLocation)) {
+            Logger.log(LogTag.JFR, LogLevel.INFO, "Same base repository path " + baseLocation.toString() + " is set");
+            return;
+        }
         // Probe to see if repository can be created, needed for fail fast
         // during JVM startup or JFR.configure
         this.repository = createRepository(baseLocation);
         try {
             // Remove so we don't "leak" repositories, if JFR is never started
@@ -67,21 +72,22 @@
             Logger.log(LogTag.JFR, LogLevel.INFO, "Could not delete disk repository " + repository);
         }
         this.baseLocation = baseLocation;
     }
 
-    synchronized void ensureRepository() throws Exception {
+    public synchronized void ensureRepository() throws IOException {
         if (baseLocation == null) {
             setBasePath(SecuritySupport.JAVA_IO_TMPDIR);
         }
     }
 
     synchronized RepositoryChunk newChunk(Instant timestamp) {
         try {
             if (!SecuritySupport.existDirectory(repository)) {
                 this.repository = createRepository(baseLocation);
                 jvm.setRepositoryLocation(repository.toString());
+                SecuritySupport.setProperty(JFR_REPOSITORY_LOCATION_PROPERTY, repository.toString());
                 cleanupDirectories.add(repository);
             }
             return new RepositoryChunk(repository, timestamp);
         } catch (Exception e) {
             String errorMsg = String.format("Could not create chunk in repository %s, %s", repository, e.getMessage());
@@ -89,11 +95,11 @@
             jvm.abort(errorMsg);
             throw new InternalError("Could not abort after JFR disk creation error");
         }
     }
 
-    private static SafePath createRepository(SafePath basePath) throws Exception {
+    private static SafePath createRepository(SafePath basePath) throws IOException {
         SafePath canonicalBaseRepositoryPath = createRealBasePath(basePath);
         SafePath f = null;
 
         String basename = REPO_DATE_FORMAT.format(LocalDateTime.now()) + "_" + JVM.getJVM().getPid();
         String name = basename;
@@ -106,17 +112,16 @@
             }
             name = basename + "_" + i;
         }
 
         if (i == MAX_REPO_CREATION_RETRIES) {
-            throw new Exception("Unable to create JFR repository directory using base location (" + basePath + ")");
+            throw new IOException("Unable to create JFR repository directory using base location (" + basePath + ")");
         }
-        SafePath canonicalRepositoryPath = SecuritySupport.toRealPath(f);
-        return canonicalRepositoryPath;
+        return SecuritySupport.toRealPath(f);
     }
 
-    private static SafePath createRealBasePath(SafePath safePath) throws Exception {
+    private static SafePath createRealBasePath(SafePath safePath) throws IOException {
         if (SecuritySupport.exists(safePath)) {
             if (!SecuritySupport.isWritable(safePath)) {
                 throw new IOException("JFR repository directory (" + safePath.toString() + ") exists, but isn't writable");
             }
             return SecuritySupport.toRealPath(safePath);
@@ -152,14 +157,19 @@
         for (SafePath p : cleanupDirectories) {
             try {
                 SecuritySupport.clearDirectory(p);
                 Logger.log(LogTag.JFR, LogLevel.INFO, "Removed repository " + p);
             } catch (IOException e) {
-                Logger.log(LogTag.JFR, LogLevel.ERROR, "Repository " + p + " could not be removed at shutdown: " + e.getMessage());
+                Logger.log(LogTag.JFR, LogLevel.INFO, "Repository " + p + " could not be removed at shutdown: " + e.getMessage());
             }
         }
     }
 
     public synchronized SafePath getRepositoryPath() {
         return repository;
     }
+
+    public synchronized SafePath getBaseLocation() {
+        return baseLocation;
+    }
+
 }

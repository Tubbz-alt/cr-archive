<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/ObjectFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import jdk.jfr.consumer.RecordedClass;
 29 import jdk.jfr.consumer.RecordedClassLoader;
 30 import jdk.jfr.consumer.RecordedFrame;
 31 import jdk.jfr.consumer.RecordedMethod;
 32 import jdk.jfr.consumer.RecordedStackTrace;
 33 import jdk.jfr.consumer.RecordedThread;
 34 import jdk.jfr.consumer.RecordedThreadGroup;
 35 import jdk.jfr.internal.Type;
 36 
 37 /**
 38  * Abstract factory for creating specialized types
 39  */
 40 public abstract class ObjectFactory&lt;T&gt; {
 41     private static final JdkJfrConsumer PRIVATE_ACCESS = JdkJfrConsumer.instance();
 42 
 43     private final static String TYPE_PREFIX_VERSION_1 = &quot;com.oracle.jfr.types.&quot;;
 44     private final static String TYPE_PREFIX_VERSION_2 = Type.TYPES_PREFIX;
 45     public final static String STACK_FRAME_VERSION_1 = TYPE_PREFIX_VERSION_1 + &quot;StackFrame&quot;;
 46     public final static String STACK_FRAME_VERSION_2 = TYPE_PREFIX_VERSION_2 + &quot;StackFrame&quot;;
 47 
 48     static ObjectFactory&lt;?&gt; create(Type type, TimeConverter timeConverter) {
 49         switch (type.getName()) {
 50         case &quot;java.lang.Thread&quot;:
 51             return createThreadFactory(type, timeConverter);
 52         case TYPE_PREFIX_VERSION_1 + &quot;StackFrame&quot;:
 53         case TYPE_PREFIX_VERSION_2 + &quot;StackFrame&quot;:
 54             return createFrameFactory(type, timeConverter);
 55         case TYPE_PREFIX_VERSION_1 + &quot;Method&quot;:
 56         case TYPE_PREFIX_VERSION_2 + &quot;Method&quot;:
 57             return createMethodFactory(type, timeConverter);
 58         case TYPE_PREFIX_VERSION_1 + &quot;ThreadGroup&quot;:
 59         case TYPE_PREFIX_VERSION_2 + &quot;ThreadGroup&quot;:
 60             return createdThreadGroupFactory(type, timeConverter);
 61         case TYPE_PREFIX_VERSION_1 + &quot;StackTrace&quot;:
 62         case TYPE_PREFIX_VERSION_2 + &quot;StackTrace&quot;:
 63             return createStackTraceFactory(type, timeConverter);
 64         case TYPE_PREFIX_VERSION_1 + &quot;ClassLoader&quot;:
 65         case TYPE_PREFIX_VERSION_2 + &quot;ClassLoader&quot;:
 66             return createClassLoaderFactory(type, timeConverter);
 67         case &quot;java.lang.Class&quot;:
 68             return createClassFactory(type, timeConverter);
 69         }
 70         return null;
 71     }
 72 
 73     private static ObjectFactory&lt;RecordedClass&gt; createClassFactory(Type type, TimeConverter timeConverter) {
 74         return new ObjectFactory&lt;RecordedClass&gt;(type, timeConverter) {
 75             @Override
 76             RecordedClass createTyped(ObjectContext objectContext, long id, Object[] values) {
 77                 return PRIVATE_ACCESS.newRecordedClass(objectContext, id, values);
 78             }
 79         };
 80     }
 81 
 82     private static ObjectFactory&lt;?&gt; createClassLoaderFactory(Type type, TimeConverter timeConverter) {
 83         return new ObjectFactory&lt;RecordedClassLoader&gt;(type, timeConverter) {
 84             @Override
 85             RecordedClassLoader createTyped(ObjectContext objectContext, long id, Object[] values) {
 86                 return PRIVATE_ACCESS.newRecordedClassLoader(objectContext, id, values);
 87             }
 88         };
 89     }
 90 
 91     private static ObjectFactory&lt;RecordedStackTrace&gt; createStackTraceFactory(Type type, TimeConverter timeConverter) {
 92         return new ObjectFactory&lt;RecordedStackTrace&gt;(type, timeConverter) {
 93             @Override
 94             RecordedStackTrace createTyped(ObjectContext objectContext, long id, Object[] values) {
 95                 return PRIVATE_ACCESS.newRecordedStackTrace(objectContext, values);
 96             }
 97         };
 98     }
 99 
100     private static ObjectFactory&lt;RecordedThreadGroup&gt; createdThreadGroupFactory(Type type, TimeConverter timeConverter) {
101         return new ObjectFactory&lt;RecordedThreadGroup&gt;(type, timeConverter) {
102             @Override
103             RecordedThreadGroup createTyped(ObjectContext objectContext, long id, Object[] values) {
104                 return PRIVATE_ACCESS.newRecordedThreadGroup(objectContext, values);
105             }
106         };
107     }
108 
109     private static ObjectFactory&lt;RecordedMethod&gt; createMethodFactory(Type type, TimeConverter timeConverter) {
110         return new ObjectFactory&lt;RecordedMethod&gt;(type, timeConverter) {
111             @Override
112             RecordedMethod createTyped(ObjectContext objectContext, long id, Object[] values) {
113                 return PRIVATE_ACCESS.newRecordedMethod(objectContext, values);
114             }
115         };
116     }
117 
118     private static ObjectFactory&lt;RecordedFrame&gt; createFrameFactory(Type type, TimeConverter timeConverter) {
119         return new ObjectFactory&lt;RecordedFrame&gt;(type, timeConverter) {
120             @Override
121             RecordedFrame createTyped(ObjectContext objectContext, long id, Object[] values) {
122                 return PRIVATE_ACCESS.newRecordedFrame(objectContext, values);
123             }
124         };
125     }
126 
127     private static ObjectFactory&lt;RecordedThread&gt; createThreadFactory(Type type, TimeConverter timeConverter) {
128         return new ObjectFactory&lt;RecordedThread&gt;(type, timeConverter) {
129             @Override
130             RecordedThread createTyped(ObjectContext objectContext, long id, Object[] values) {
131                 return PRIVATE_ACCESS.newRecordedThread(objectContext, id, values);
132             }
133         };
134     }
135 
136     private final ObjectContext objectContext;
137 
138     private ObjectFactory(Type type, TimeConverter timeConverter) {
139         this.objectContext = new ObjectContext(null, type.getFields(), timeConverter);
140     }
141 
142     T createObject(long id, Object value) {
143         if (value == null) {
144             return null;
145         }
146         if (value instanceof Object[]) {
147             return createTyped(objectContext, id, (Object[]) value);
148         }
149         throw new InternalError(&quot;Object factory must have struct type. Type was &quot; + value.getClass().getName());
150     }
151 
152     abstract T createTyped(ObjectContext objectContextm, long id, Object[] values);
153 }
    </pre>
  </body>
</html>
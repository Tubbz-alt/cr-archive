<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jfr/share/classes/jdk/jfr/internal/SecuritySupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.io.File;
 29 import java.io.FileNotFoundException;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.RandomAccessFile;
 33 import java.io.Reader;
 34 import java.lang.invoke.MethodHandles;
 35 import java.lang.reflect.Constructor;
 36 import java.lang.reflect.Field;
 37 import java.lang.reflect.Method;
 38 import java.lang.reflect.ReflectPermission;
 39 import java.nio.channels.FileChannel;
 40 import java.nio.channels.ReadableByteChannel;
 41 import java.nio.file.FileVisitResult;
 42 import java.nio.file.Files;
 43 import java.nio.file.Path;
 44 import java.nio.file.Paths;
 45 import java.nio.file.SimpleFileVisitor;
 46 import java.nio.file.StandardOpenOption;
 47 import java.nio.file.attribute.BasicFileAttributes;
 48 import java.security.AccessControlContext;
 49 import java.security.AccessController;
 50 import java.security.Permission;
 51 import java.security.PrivilegedAction;
 52 import java.security.PrivilegedActionException;
 53 import java.security.PrivilegedExceptionAction;
 54 import java.util.ArrayList;
 55 import java.util.Iterator;
 56 import java.util.List;
 57 import java.util.Objects;
 58 import java.util.PropertyPermission;
 59 import java.util.concurrent.Callable;
 60 
 61 import jdk.internal.misc.Unsafe;
 62 import jdk.internal.module.Modules;
 63 import jdk.jfr.Event;
 64 import jdk.jfr.FlightRecorder;
 65 import jdk.jfr.FlightRecorderListener;
 66 import jdk.jfr.FlightRecorderPermission;
 67 import jdk.jfr.Recording;
 68 
 69 /**
 70  * Contains JFR code that does
 71  * {@link AccessController#doPrivileged(PrivilegedAction)}
 72  */
 73 public final class SecuritySupport {
 74     private final static Unsafe unsafe = Unsafe.getUnsafe();
 75     private final static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
 76     private final static Module JFR_MODULE = Event.class.getModule();
 77     public  final static SafePath JFC_DIRECTORY = getPathInProperty(&quot;java.home&quot;, &quot;lib/jfr&quot;);
 78 
 79     static final SafePath USER_HOME = getPathInProperty(&quot;user.home&quot;, null);
 80     static final SafePath JAVA_IO_TMPDIR = getPathInProperty(&quot;java.io.tmpdir&quot;, null);
 81 
 82     static {
 83         // ensure module java.base can read module jdk.jfr as early as possible
 84         addReadEdge(Object.class);
 85         addHandlerExport(Object.class);
 86         addEventsExport(Object.class);
 87         addInstrumentExport(Object.class);
 88     }
 89 
 90     final static class SecureRecorderListener implements FlightRecorderListener {
 91 
 92         private final AccessControlContext context;
 93         private final FlightRecorderListener changeListener;
 94 
 95         SecureRecorderListener(AccessControlContext context, FlightRecorderListener changeListener) {
 96             this.context = Objects.requireNonNull(context);
 97             this.changeListener = Objects.requireNonNull(changeListener);
 98         }
 99 
100         @Override
101         public void recordingStateChanged(Recording recording) {
102             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
103                 try {
104                     changeListener.recordingStateChanged(recording);
105                 } catch (Throwable t) {
106                     // Prevent malicious user to propagate exception callback in the wrong context
107                     Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Unexpected exception in listener &quot; + changeListener.getClass()+ &quot; at recording state change&quot;);
108                 }
109                 return null;
110             }, context);
111         }
112 
113         @Override
114         public void recorderInitialized(FlightRecorder recorder) {
115             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
116                 try  {
117                     changeListener.recorderInitialized(recorder);
118                 } catch (Throwable t) {
119                     // Prevent malicious user to propagate exception callback in the wrong context
120                     Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Unexpected exception in listener &quot; + changeListener.getClass()+ &quot; when initializing FlightRecorder&quot;);
121                 }
122                 return null;
123             }, context);
124         }
125 
126         public FlightRecorderListener getChangeListener() {
127             return changeListener;
128         }
129     }
130 
131     private static final class DirectoryCleaner extends SimpleFileVisitor&lt;Path&gt; {
132         @Override
133         public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {
134             Files.delete(path);
135             return FileVisitResult.CONTINUE;
136         }
137 
138         @Override
139         public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
140             if (exc != null) {
141                 throw exc;
142             }
143             Files.delete(dir);
144             return FileVisitResult.CONTINUE;
145         }
146     }
147 
148     /**
149      * Path created by the default file provider,and not
150      * a malicious provider.
151      *
152      */
153     public static final class SafePath {
154         private final Path path;
155         private final String text;
156 
157         public SafePath(Path p) {
158             // sanitize
159             text = p.toString();
160             path = Paths.get(text);
161         }
162 
163         public SafePath(String path) {
164             this(Paths.get(path));
165         }
166 
167         public Path toPath() {
168             return path;
169         }
170 
171         public String toString() {
172             return text;
173         }
174     }
175 
176     private interface RunnableWithCheckedException {
177         public void run() throws Exception;
178     }
179 
180     private interface CallableWithoutCheckException&lt;T&gt; {
181         public T call();
182     }
183 
184     private static &lt;U&gt; U doPrivilegedIOWithReturn(Callable&lt;U&gt; function) throws IOException {
185         try {
186             return AccessController.doPrivileged(new PrivilegedExceptionAction&lt;U&gt;() {
187                 @Override
188                 public U run() throws Exception {
189                     return function.call();
190                 }
191             }, null);
192         } catch (PrivilegedActionException e) {
193             Throwable t = e.getCause();
194             if (t instanceof IOException) {
195                 throw (IOException) t;
196             }
197             throw new IOException(&quot;Unexpected error during I/O operation. &quot; + t.getMessage(), t);
198         }
199     }
200 
201     private static void doPriviligedIO(RunnableWithCheckedException function) throws IOException {
202         doPrivilegedIOWithReturn(() -&gt; {
203             function.run();
204             return null;
205         });
206     }
207 
208     private static void doPrivileged(Runnable function, Permission... perms) {
209         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
210             @Override
211             public Void run() {
212                 function.run();
213                 return null;
214             }
215         }, null, perms);
216     }
217 
218     private static void doPrivileged(Runnable function) {
219         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
220             @Override
221             public Void run() {
222                 function.run();
223                 return null;
224             }
225         });
226     }
227 
228     private static &lt;T&gt; T doPrivilegedWithReturn(CallableWithoutCheckException&lt;T&gt; function, Permission... perms) {
229         return AccessController.doPrivileged(new PrivilegedAction&lt;T&gt;() {
230             @Override
231             public T run() {
232                 return function.call();
233             }
234         }, null, perms);
235     }
236 
237     public static List&lt;SafePath&gt; getPredefinedJFCFiles() {
238         List&lt;SafePath&gt; list = new ArrayList&lt;&gt;();
239         try {
240             Iterator&lt;Path&gt; pathIterator = doPrivilegedIOWithReturn(() -&gt; {
241                 return Files.newDirectoryStream(JFC_DIRECTORY.toPath(), &quot;*&quot;).iterator();
242             });
243             while (pathIterator.hasNext()) {
244                 Path path = pathIterator.next();
245                 if (path.toString().endsWith(&quot;.jfc&quot;)) {
246                     list.add(new SafePath(path));
247                 }
248             }
249         } catch (IOException ioe) {
250             Logger.log(LogTag.JFR, LogLevel.WARN, &quot;Could not access .jfc-files in &quot; + JFC_DIRECTORY + &quot;, &quot; + ioe.getMessage());
251         }
252         return list;
253     }
254 
255     static void makeVisibleToJFR(Class&lt;?&gt; clazz) {
256         Module classModule = clazz.getModule();
257         Modules.addReads(JFR_MODULE, classModule);
258         if (clazz.getPackage() != null) {
259             String packageName = clazz.getPackage().getName();
260             Modules.addExports(classModule, packageName, JFR_MODULE);
261             Modules.addOpens(classModule, packageName, JFR_MODULE);
262         }
263     }
264 
265     /**
266      * Adds a qualified export of the internal.jdk.jfr.internal.handlers package
267      * (for EventHandler)
268      */
269     static void addHandlerExport(Class&lt;?&gt; clazz) {
270         Modules.addExports(JFR_MODULE, Utils.HANDLERS_PACKAGE_NAME, clazz.getModule());
271     }
272 
273     static void addEventsExport(Class&lt;?&gt; clazz) {
274         Modules.addExports(JFR_MODULE, Utils.EVENTS_PACKAGE_NAME, clazz.getModule());
275     }
276 
277     static void addInstrumentExport(Class&lt;?&gt; clazz) {
278         Modules.addExports(JFR_MODULE, Utils.INSTRUMENT_PACKAGE_NAME, clazz.getModule());
279     }
280 
281     static void addReadEdge(Class&lt;?&gt; clazz) {
282         Modules.addReads(clazz.getModule(), JFR_MODULE);
283     }
284 
285     public static void registerEvent(Class&lt;? extends jdk.internal.event.Event&gt; eventClass) {
286         doPrivileged(() -&gt;  MetadataRepository.getInstance().register(eventClass), new FlightRecorderPermission(Utils.REGISTER_EVENT));
287     }
288 
289     public static void registerMirror(Class&lt;? extends Event&gt; eventClass) {
290         doPrivileged(() -&gt;  MetadataRepository.getInstance().registerMirror(eventClass), new FlightRecorderPermission(Utils.REGISTER_EVENT));
291     }
292 
293     static boolean getBooleanProperty(String propertyName) {
294         return doPrivilegedWithReturn(() -&gt; Boolean.getBoolean(propertyName), new PropertyPermission(propertyName, &quot;read&quot;));
295     }
296 
297     private static SafePath getPathInProperty(String prop, String subPath) {
298         return doPrivilegedWithReturn(() -&gt; {
299             String path = System.getProperty(prop);
300             if (path == null) {
301                 return null;
302             }
303             File file = subPath == null ? new File(path) : new File(path, subPath);
304             return new SafePath(file.getAbsolutePath());
305         }, new PropertyPermission(&quot;*&quot;, &quot;read&quot;));
306     }
307 
308     // Called by JVM during initialization of JFR
309     static Thread createRecorderThread(ThreadGroup systemThreadGroup, ClassLoader contextClassLoader) {
310         // The thread should have permission = new Permission[0], and not &quot;modifyThreadGroup&quot; and &quot;modifyThread&quot; on the stack,
311         // but it&#39;s hard circumvent if we are going to pass in system thread group in the constructor
312         Thread thread = doPrivilegedWithReturn(() -&gt; new Thread(systemThreadGroup, &quot;JFR Recorder Thread&quot;), new RuntimePermission(&quot;modifyThreadGroup&quot;), new RuntimePermission(&quot;modifyThread&quot;));
313         doPrivileged(() -&gt; thread.setContextClassLoader(contextClassLoader), new RuntimePermission(&quot;setContextClassLoader&quot;), new RuntimePermission(&quot;modifyThread&quot;));
314         return thread;
315     }
316 
317     static void registerShutdownHook(Thread shutdownHook) {
318         doPrivileged(() -&gt; Runtime.getRuntime().addShutdownHook(shutdownHook), new RuntimePermission(&quot;shutdownHooks&quot;));
319     }
320 
321     static void setUncaughtExceptionHandler(Thread thread, Thread.UncaughtExceptionHandler eh) {
322         doPrivileged(() -&gt; thread.setUncaughtExceptionHandler(eh), new RuntimePermission(&quot;modifyThread&quot;));
323     }
324 
325     static void moveReplace(SafePath from, SafePath to) throws IOException {
326         doPrivilegedIOWithReturn(() -&gt; Files.move(from.toPath(), to.toPath()));
327     }
328 
329     static void clearDirectory(SafePath safePath) throws IOException {
330         doPriviligedIO(() -&gt; Files.walkFileTree(safePath.toPath(), new DirectoryCleaner()));
331     }
332 
333     static SafePath toRealPath(SafePath safePath) throws Exception {
334         return new SafePath(doPrivilegedIOWithReturn(() -&gt; safePath.toPath().toRealPath()));
335     }
336 
337     static boolean existDirectory(SafePath directory) throws IOException {
338         return doPrivilegedIOWithReturn(() -&gt; Files.exists(directory.toPath()));
339     }
340 
341     static RandomAccessFile createRandomAccessFile(SafePath path) throws Exception {
342         return doPrivilegedIOWithReturn(() -&gt; new RandomAccessFile(path.toPath().toFile(), &quot;rw&quot;));
343     }
344 
345     public static InputStream newFileInputStream(SafePath safePath) throws IOException {
346         return doPrivilegedIOWithReturn(() -&gt; Files.newInputStream(safePath.toPath()));
347     }
348 
349     public static long getFileSize(SafePath safePath) throws IOException {
350         return doPrivilegedIOWithReturn(() -&gt; Files.size(safePath.toPath()));
351     }
352 
353     static SafePath createDirectories(SafePath safePath) throws IOException {
354         Path p = doPrivilegedIOWithReturn(() -&gt; Files.createDirectories(safePath.toPath()));
355         return new SafePath(p);
356     }
357 
358     public static boolean exists(SafePath safePath) throws IOException {
359         return doPrivilegedIOWithReturn(() -&gt; Files.exists(safePath.toPath()));
360     }
361 
362     public static boolean isDirectory(SafePath safePath) throws IOException {
363         return doPrivilegedIOWithReturn(() -&gt; Files.isDirectory(safePath.toPath()));
364     }
365 
366     static void delete(SafePath localPath) throws IOException {
367         doPriviligedIO(() -&gt; Files.delete(localPath.toPath()));
368     }
369 
370     static boolean isWritable(SafePath safePath) throws IOException {
371         return doPrivilegedIOWithReturn(() -&gt; Files.isWritable(safePath.toPath()));
372     }
373 
374     static void deleteOnExit(SafePath safePath) {
375         doPrivileged(() -&gt; safePath.toPath().toFile().deleteOnExit());
376     }
377 
378     static ReadableByteChannel newFileChannelToRead(SafePath safePath) throws IOException {
379         return doPrivilegedIOWithReturn(() -&gt; FileChannel.open(safePath.toPath(), StandardOpenOption.READ));
380     }
381 
382     public static InputStream getResourceAsStream(String name) throws IOException {
383         return doPrivilegedIOWithReturn(() -&gt; SecuritySupport.class.getResourceAsStream(name));
384     }
385 
386     public static Reader newFileReader(SafePath safePath) throws FileNotFoundException, IOException {
387         return doPrivilegedIOWithReturn(() -&gt; Files.newBufferedReader(safePath.toPath()));
388     }
389 
390     static void touch(SafePath path) throws IOException {
391         doPriviligedIO(() -&gt; new RandomAccessFile(path.toPath().toFile(), &quot;rw&quot;).close());
392     }
393 
394     static void setAccessible(Method method) {
395         doPrivileged(() -&gt; method.setAccessible(true), new ReflectPermission(&quot;suppressAccessChecks&quot;));
396     }
397 
398     static void setAccessible(Field field) {
399         doPrivileged(() -&gt; field.setAccessible(true), new ReflectPermission(&quot;suppressAccessChecks&quot;));
400     }
401 
402     static void setAccessible(Constructor&lt;?&gt; constructor) {
403         doPrivileged(() -&gt; constructor.setAccessible(true), new ReflectPermission(&quot;suppressAccessChecks&quot;));
404     }
405 
406     static void ensureClassIsInitialized(Class&lt;?&gt; clazz) {
407         unsafe.ensureClassInitialized(clazz);
408     }
409 
410     static Class&lt;?&gt; defineClass(Class&lt;?&gt; lookupClass, byte[] bytes) {
411         return AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
412             @Override
413             public Class&lt;?&gt; run() {
414                 try {
415                     return MethodHandles.privateLookupIn(lookupClass, LOOKUP).defineClass(bytes);
416                 } catch (IllegalAccessException e) {
417                     throw new InternalError(e);
418                 }
419             }
420         });
421     }
422 
423     static Thread createThreadWitNoPermissions(String threadName, Runnable runnable) {
424         return doPrivilegedWithReturn(() -&gt; new Thread(runnable, threadName), new Permission[0]);
425     }
426 
427     static void setDaemonThread(Thread t, boolean daeomn) {
428       doPrivileged(()-&gt; t.setDaemon(daeomn), new RuntimePermission(&quot;modifyThread&quot;));
429     }
430 
431     public static SafePath getAbsolutePath(SafePath path) throws IOException {
432         return new SafePath(doPrivilegedIOWithReturn((()-&gt; path.toPath().toAbsolutePath())));
433     }
434 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecorder.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlatformEventType.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PlatformRecording.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecorder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 52,15 ***</span>
<span class="line-new-header">--- 52,17 ---</span>
  import jdk.jfr.FlightRecorderListener;
  import jdk.jfr.Recording;
  import jdk.jfr.RecordingState;
  import jdk.jfr.events.ActiveRecordingEvent;
  import jdk.jfr.events.ActiveSettingEvent;
<span class="line-added">+ import jdk.jfr.internal.SecuritySupport.SafePath;</span>
  import jdk.jfr.internal.SecuritySupport.SecureRecorderListener;
  import jdk.jfr.internal.instrument.JDKEvents;
  
  public final class PlatformRecorder {
  
<span class="line-added">+ </span>
      private final List&lt;PlatformRecording&gt; recordings = new ArrayList&lt;&gt;();
      private final static List&lt;SecureRecorderListener&gt; changeListeners = new ArrayList&lt;&gt;();
      private final Repository repository;
      private final Timer timer;
      private final static JVM jvm = JVM.getJVM();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,10 ***</span>
<span class="line-new-header">--- 70,11 ---</span>
      private final EventType activeSettingEvent;
      private final Thread shutdownHook;
  
      private long recordingCounter = 0;
      private RepositoryChunk currentChunk;
<span class="line-added">+     private boolean inShutdown;</span>
  
      public PlatformRecorder() throws Exception {
          repository = Repository.getRepository();
          Logger.log(JFR_SYSTEM, INFO, &quot;Initialized disk repository&quot;);
          repository.ensureRepository();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,10 ***</span>
<span class="line-new-header">--- 97,11 ---</span>
          try {
              List&lt;Timer&gt; result = new CopyOnWriteArrayList&lt;&gt;();
              Thread t = SecuritySupport.createThreadWitNoPermissions(&quot;Permissionless thread&quot;, ()-&gt; {
                  result.add(new Timer(&quot;JFR Recording Scheduler&quot;, true));
              });
<span class="line-added">+             jvm.exclude(t);</span>
              t.start();
              t.join();
              return result.get(0);
          } catch (InterruptedException e) {
              throw new IllegalStateException(&quot;Not able to create timer task. &quot; + e.getMessage(), e);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,10 ***</span>
<span class="line-new-header">--- 177,14 ---</span>
          for (FlightRecorderListener r : getListeners()) {
              r.recorderInitialized(recorder);
          }
      }
  
<span class="line-added">+     synchronized void setInShutDown() {</span>
<span class="line-added">+         this.inShutdown = true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // called by shutdown hook
      synchronized void destroy() {
          try {
              timer.cancel();
          } catch (Exception ex) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,66 ***</span>
  
          JDKEvents.remove();
  
          if (jvm.hasNativeJFR()) {
              if (jvm.isRecording()) {
<span class="line-modified">!                 jvm.endRecording_();</span>
              }
              jvm.destroyNativeJFR();
          }
          repository.clear();
      }
  
<span class="line-modified">!     synchronized void start(PlatformRecording recording) {</span>
          // State can only be NEW or DELAYED because of previous checks
          Instant now = Instant.now();
          recording.setStartTime(now);
          recording.updateTimer();
          Duration duration = recording.getDuration();
          if (duration != null) {
              recording.setStopTime(now.plus(duration));
          }
          boolean toDisk = recording.isToDisk();
          boolean beginPhysical = true;
          for (PlatformRecording s : getRecordings()) {
              if (s.getState() == RecordingState.RUNNING) {
                  beginPhysical = false;
                  if (s.isToDisk()) {
                      toDisk = true;
                  }
              }
          }
          if (beginPhysical) {
              RepositoryChunk newChunk = null;
              if (toDisk) {
                  newChunk = repository.newChunk(now);
                  MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());
              } else {
                  MetadataRepository.getInstance().setOutput(null);
              }
              currentChunk = newChunk;
<span class="line-modified">!             jvm.beginRecording_();</span>
              recording.setState(RecordingState.RUNNING);
              updateSettings();
              writeMetaEvents();
          } else {
              RepositoryChunk newChunk = null;
              if (toDisk) {
                  newChunk = repository.newChunk(now);
                  RequestEngine.doChunkEnd();
                  MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());
              }
              recording.setState(RecordingState.RUNNING);
              updateSettings();
              writeMetaEvents();
              if (currentChunk != null) {
                  finishChunk(currentChunk, now, recording);
              }
              currentChunk = newChunk;
          }
<span class="line-modified">! </span>
          RequestEngine.doChunkBegin();
      }
  
      synchronized void stop(PlatformRecording recording) {
          RecordingState state = recording.getState();
  
<span class="line-new-header">--- 203,75 ---</span>
  
          JDKEvents.remove();
  
          if (jvm.hasNativeJFR()) {
              if (jvm.isRecording()) {
<span class="line-modified">!                 jvm.endRecording();</span>
              }
              jvm.destroyNativeJFR();
          }
          repository.clear();
      }
  
<span class="line-modified">!     synchronized long start(PlatformRecording recording) {</span>
          // State can only be NEW or DELAYED because of previous checks
          Instant now = Instant.now();
          recording.setStartTime(now);
          recording.updateTimer();
          Duration duration = recording.getDuration();
          if (duration != null) {
              recording.setStopTime(now.plus(duration));
          }
          boolean toDisk = recording.isToDisk();
          boolean beginPhysical = true;
<span class="line-added">+         long streamInterval = recording.getStreamIntervalMillis();</span>
          for (PlatformRecording s : getRecordings()) {
              if (s.getState() == RecordingState.RUNNING) {
                  beginPhysical = false;
                  if (s.isToDisk()) {
                      toDisk = true;
                  }
<span class="line-added">+                 streamInterval = Math.min(streamInterval, s.getStreamIntervalMillis());</span>
              }
          }
<span class="line-added">+         long startNanos = -1;</span>
          if (beginPhysical) {
              RepositoryChunk newChunk = null;
              if (toDisk) {
                  newChunk = repository.newChunk(now);
                  MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());
              } else {
                  MetadataRepository.getInstance().setOutput(null);
              }
              currentChunk = newChunk;
<span class="line-modified">!             jvm.beginRecording();</span>
<span class="line-added">+             startNanos = jvm.getChunkStartNanos();</span>
              recording.setState(RecordingState.RUNNING);
              updateSettings();
              writeMetaEvents();
          } else {
              RepositoryChunk newChunk = null;
              if (toDisk) {
                  newChunk = repository.newChunk(now);
                  RequestEngine.doChunkEnd();
                  MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());
<span class="line-added">+                 startNanos = jvm.getChunkStartNanos();</span>
              }
              recording.setState(RecordingState.RUNNING);
              updateSettings();
              writeMetaEvents();
              if (currentChunk != null) {
                  finishChunk(currentChunk, now, recording);
              }
              currentChunk = newChunk;
          }
<span class="line-modified">!         if (toDisk) {</span>
<span class="line-added">+             RequestEngine.setFlushInterval(streamInterval);</span>
<span class="line-added">+         }</span>
          RequestEngine.doChunkBegin();
<span class="line-added">+ </span>
<span class="line-added">+         return startNanos;</span>
      }
  
      synchronized void stop(PlatformRecording recording) {
          RecordingState state = recording.getState();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 265,34 ***</span>
              throw new IllegalStateException(&quot;Recording must be started before it can be stopped.&quot;);
          }
          Instant now = Instant.now();
          boolean toDisk = false;
          boolean endPhysical = true;
          for (PlatformRecording s : getRecordings()) {
              RecordingState rs = s.getState();
              if (s != recording &amp;&amp; RecordingState.RUNNING == rs) {
                  endPhysical = false;
                  if (s.isToDisk()) {
                      toDisk = true;
                  }
              }
          }
          OldObjectSample.emit(recording);
  
          if (endPhysical) {
              RequestEngine.doChunkEnd();
              if (recording.isToDisk()) {
                  if (currentChunk != null) {
                      MetadataRepository.getInstance().setOutput(null);
                      finishChunk(currentChunk, now, null);
                      currentChunk = null;
                  }
              } else {
                  // last memory
                  dumpMemoryToDestination(recording);
              }
<span class="line-modified">!             jvm.endRecording_();</span>
              disableEvents();
          } else {
              RepositoryChunk newChunk = null;
              RequestEngine.doChunkEnd();
              updateSettingsButIgnoreRecording(recording);
<span class="line-new-header">--- 282,40 ---</span>
              throw new IllegalStateException(&quot;Recording must be started before it can be stopped.&quot;);
          }
          Instant now = Instant.now();
          boolean toDisk = false;
          boolean endPhysical = true;
<span class="line-added">+         long streamInterval = Long.MAX_VALUE;</span>
          for (PlatformRecording s : getRecordings()) {
              RecordingState rs = s.getState();
              if (s != recording &amp;&amp; RecordingState.RUNNING == rs) {
                  endPhysical = false;
                  if (s.isToDisk()) {
                      toDisk = true;
                  }
<span class="line-added">+                 streamInterval = Math.min(streamInterval, s.getStreamIntervalMillis());</span>
              }
          }
          OldObjectSample.emit(recording);
<span class="line-added">+         recording.setFinalStartnanos(jvm.getChunkStartNanos());</span>
  
          if (endPhysical) {
              RequestEngine.doChunkEnd();
              if (recording.isToDisk()) {
                  if (currentChunk != null) {
<span class="line-added">+                     if (inShutdown) {</span>
<span class="line-added">+                         jvm.markChunkFinal();</span>
<span class="line-added">+                     }</span>
                      MetadataRepository.getInstance().setOutput(null);
                      finishChunk(currentChunk, now, null);
                      currentChunk = null;
                  }
              } else {
                  // last memory
                  dumpMemoryToDestination(recording);
              }
<span class="line-modified">!             jvm.endRecording();</span>
              disableEvents();
          } else {
              RepositoryChunk newChunk = null;
              RequestEngine.doChunkEnd();
              updateSettingsButIgnoreRecording(recording);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 307,17 ***</span>
                  finishChunk(currentChunk, now, null);
              }
              currentChunk = newChunk;
              RequestEngine.doChunkBegin();
          }
          recording.setState(RecordingState.STOPPED);
      }
  
      private void dumpMemoryToDestination(PlatformRecording recording)  {
          WriteableUserPath dest = recording.getDestination();
          if (dest != null) {
<span class="line-modified">!             MetadataRepository.getInstance().setOutput(dest.getText());</span>
              recording.clearDestination();
          }
      }
      private void disableEvents() {
          MetadataRepository.getInstance().disableEvents();
<span class="line-new-header">--- 330,23 ---</span>
                  finishChunk(currentChunk, now, null);
              }
              currentChunk = newChunk;
              RequestEngine.doChunkBegin();
          }
<span class="line-added">+ </span>
<span class="line-added">+         if (toDisk) {</span>
<span class="line-added">+             RequestEngine.setFlushInterval(streamInterval);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             RequestEngine.setFlushInterval(Long.MAX_VALUE);</span>
<span class="line-added">+         }</span>
          recording.setState(RecordingState.STOPPED);
      }
  
      private void dumpMemoryToDestination(PlatformRecording recording)  {
          WriteableUserPath dest = recording.getDestination();
          if (dest != null) {
<span class="line-modified">!             MetadataRepository.getInstance().setOutput(dest.getRealPathText());</span>
              recording.clearDestination();
          }
      }
      private void disableEvents() {
          MetadataRepository.getInstance().disableEvents();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 336,10 ***</span>
<span class="line-new-header">--- 365,12 ---</span>
              }
          }
          MetadataRepository.getInstance().setSettings(list);
      }
  
<span class="line-added">+ </span>
<span class="line-added">+ </span>
      synchronized void rotateDisk() {
          Instant now = Instant.now();
          RepositoryChunk newChunk = repository.newChunk(now);
          RequestEngine.doChunkEnd();
          MetadataRepository.getInstance().setOutput(newChunk.getUnfishedFile().toString());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 393,30 ***</span>
          for (PlatformRecording r : getRecordings()) {
              if (r != ignoreMe &amp;&amp; r.getState() == RecordingState.RUNNING) {
                  r.appendChunk(chunk);
              }
          }
      }
  
      private void writeMetaEvents() {
<span class="line-removed">- </span>
          if (activeRecordingEvent.isEnabled()) {
              for (PlatformRecording r : getRecordings()) {
                  if (r.getState() == RecordingState.RUNNING &amp;&amp; r.shouldWriteMetadataEvent()) {
<span class="line-removed">-                     ActiveRecordingEvent event = new ActiveRecordingEvent();</span>
                      event.id = r.getId();
                      event.name = r.getName();
                      WriteableUserPath p = r.getDestination();
<span class="line-modified">!                     event.destination = p == null ? null : p.getText();</span>
                      Duration d = r.getDuration();
                      event.recordingDuration = d == null ? Long.MAX_VALUE : d.toMillis();
                      Duration age = r.getMaxAge();
                      event.maxAge = age == null ? Long.MAX_VALUE : age.toMillis();
                      Long size = r.getMaxSize();
                      event.maxSize = size == null ? Long.MAX_VALUE : size;
                      Instant start = r.getStartTime();
                      event.recordingStart = start == null ? Long.MAX_VALUE : start.toEpochMilli();
                      event.commit();
                  }
              }
          }
          if (activeSettingEvent.isEnabled()) {
<span class="line-new-header">--- 424,32 ---</span>
          for (PlatformRecording r : getRecordings()) {
              if (r != ignoreMe &amp;&amp; r.getState() == RecordingState.RUNNING) {
                  r.appendChunk(chunk);
              }
          }
<span class="line-added">+         FilePurger.purge();</span>
      }
  
      private void writeMetaEvents() {
          if (activeRecordingEvent.isEnabled()) {
<span class="line-added">+             ActiveRecordingEvent event = ActiveRecordingEvent.EVENT.get();</span>
              for (PlatformRecording r : getRecordings()) {
                  if (r.getState() == RecordingState.RUNNING &amp;&amp; r.shouldWriteMetadataEvent()) {
                      event.id = r.getId();
                      event.name = r.getName();
                      WriteableUserPath p = r.getDestination();
<span class="line-modified">!                     event.destination = p == null ? null : p.getRealPathText();</span>
                      Duration d = r.getDuration();
                      event.recordingDuration = d == null ? Long.MAX_VALUE : d.toMillis();
                      Duration age = r.getMaxAge();
                      event.maxAge = age == null ? Long.MAX_VALUE : age.toMillis();
                      Long size = r.getMaxSize();
                      event.maxSize = size == null ? Long.MAX_VALUE : size;
                      Instant start = r.getStartTime();
                      event.recordingStart = start == null ? Long.MAX_VALUE : start.toEpochMilli();
<span class="line-added">+                     Duration fi = r.getFlushInterval();</span>
<span class="line-added">+                     event.flushInterval = fi == null ? Long.MAX_VALUE : fi.toMillis();</span>
                      event.commit();
                  }
              }
          }
          if (activeSettingEvent.isEnabled()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 446,11 ***</span>
          try {
              synchronized (JVM.FILE_DELTA_CHANGE) {
                  JVM.FILE_DELTA_CHANGE.wait(duration &lt; 10 ? 10 : duration);
              }
          } catch (InterruptedException e) {
<span class="line-modified">!             e.printStackTrace();</span>
          }
      }
  
      synchronized Recording newCopy(PlatformRecording r, boolean stop) {
          Recording newRec = new Recording();
<span class="line-new-header">--- 479,11 ---</span>
          try {
              synchronized (JVM.FILE_DELTA_CHANGE) {
                  JVM.FILE_DELTA_CHANGE.wait(duration &lt; 10 ? 10 : duration);
              }
          } catch (InterruptedException e) {
<span class="line-modified">!             // Ignore</span>
          }
      }
  
      synchronized Recording newCopy(PlatformRecording r, boolean stop) {
          Recording newRec = new Recording();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 548,6 ***</span>
<span class="line-new-header">--- 581,22 ---</span>
          }
          target.setStartTime(startTime);
          target.setStopTime(endTime);
          target.setInternalDuration(Duration.between(startTime, endTime));
      }
<span class="line-added">+ </span>
<span class="line-added">+     public synchronized void migrate(SafePath repo) throws IOException {</span>
<span class="line-added">+         // Must set repository while holding recorder lock so</span>
<span class="line-added">+         // the final chunk in repository gets marked correctly</span>
<span class="line-added">+         Repository.getRepository().setBasePath(repo);</span>
<span class="line-added">+         boolean disk = false;</span>
<span class="line-added">+         for (PlatformRecording s : getRecordings()) {</span>
<span class="line-added">+             if (RecordingState.RUNNING == s.getState() &amp;&amp; s.isToDisk()) {</span>
<span class="line-added">+                 disk = true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (disk) {</span>
<span class="line-added">+             jvm.markChunkFinal();</span>
<span class="line-added">+             rotateDisk();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="PlatformEventType.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PlatformRecording.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
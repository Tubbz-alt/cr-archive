<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MetadataRepository.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MirrorEvent.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/MetadataWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 36 import static jdk.jfr.internal.MetadataDescriptor.ATTRIBUTE_SUPER_TYPE;
 37 import static jdk.jfr.internal.MetadataDescriptor.ATTRIBUTE_TYPE_ID;
 38 import static jdk.jfr.internal.MetadataDescriptor.ELEMENT_ANNOTATION;
 39 import static jdk.jfr.internal.MetadataDescriptor.ELEMENT_FIELD;
 40 import static jdk.jfr.internal.MetadataDescriptor.ELEMENT_SETTING;
 41 import static jdk.jfr.internal.MetadataDescriptor.ELEMENT_TYPE;
 42 
 43 import java.io.DataOutput;
 44 import java.io.IOException;
 45 import java.util.HashMap;
 46 import java.util.HashSet;
 47 import java.util.LinkedHashMap;
 48 import java.util.List;
 49 import java.util.Set;
 50 
 51 import jdk.jfr.AnnotationElement;
 52 import jdk.jfr.SettingDescriptor;
 53 import jdk.jfr.ValueDescriptor;
 54 import jdk.jfr.internal.MetadataDescriptor.Attribute;
 55 import jdk.jfr.internal.MetadataDescriptor.Element;
<span class="line-modified"> 56 import jdk.jfr.internal.consumer.RecordingInput;</span>
 57 
 58 /**
 59  * Class responsible for converting a list of types into a format that can be
 60  * parsed by a client.
 61  *
 62  */
 63 final class MetadataWriter {
 64 
 65     private final Element metadata = new Element(&quot;metadata&quot;);
 66     private final Element root = new Element(&quot;root&quot;);
 67 
 68     public MetadataWriter(MetadataDescriptor descriptor) {
 69         descriptor.getTypes().forEach(type -&gt; makeTypeElement(metadata, type));
 70 
 71         root.add(metadata);
 72         Element region = new Element(&quot;region&quot;);
 73         region.addAttribute(ATTRIBUTE_LOCALE, descriptor.locale);
 74         region.addAttribute(ATTRIBUTE_GMT_OFFSET, descriptor.gmtOffset);
 75         root.add(region);
 76     }
 77 
 78     public void writeBinary(DataOutput output) throws IOException {
 79         Set&lt;String&gt; stringPool = new HashSet&lt;&gt;(1000);
 80         // Possible improvement, sort string by how often they occur.
 81         // and assign low number to the most frequently used.
 82         buildStringPool(root, stringPool);
 83         HashMap&lt;String, Integer&gt; lookup = new LinkedHashMap&lt;&gt;(stringPool.size());
 84         int index = 0;
 85         int poolSize = stringPool.size();
 86         writeInt(output, poolSize);
 87         for (String s : stringPool) {
 88             lookup.put(s, index);
 89             writeString(output, s);
 90             index++;
 91         }
 92         write(output, root, lookup);
 93     }
 94 
 95     private void writeString(DataOutput out, String s) throws IOException {
 96         if (s == null ) {
<span class="line-modified"> 97             out.writeByte(RecordingInput.STRING_ENCODING_NULL);</span>
 98             return;
 99         }
<span class="line-modified">100         out.writeByte(RecordingInput.STRING_ENCODING_CHAR_ARRAY); // encoding UTF-16</span>
101         int length = s.length();
102         writeInt(out, length);
103             for (int i = 0; i &lt; length; i++) {
104                 writeInt(out, s.charAt(i));
105             }
106     }
107 
108     private void writeInt(DataOutput out, int v) throws IOException {
109 
110         long s = v &amp; 0xffffffffL;
111         if (s &lt; 1 &lt;&lt; 7) {
112             out.write((byte) (s));
113             return;
114         }
115         out.write((byte) (s | 0x80)); // first byte written
116         s &gt;&gt;= 7;
117         if (s &lt; 1 &lt;&lt; 7) {
118             out.write((byte) (s));
119             return;
120         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 36 import static jdk.jfr.internal.MetadataDescriptor.ATTRIBUTE_SUPER_TYPE;
 37 import static jdk.jfr.internal.MetadataDescriptor.ATTRIBUTE_TYPE_ID;
 38 import static jdk.jfr.internal.MetadataDescriptor.ELEMENT_ANNOTATION;
 39 import static jdk.jfr.internal.MetadataDescriptor.ELEMENT_FIELD;
 40 import static jdk.jfr.internal.MetadataDescriptor.ELEMENT_SETTING;
 41 import static jdk.jfr.internal.MetadataDescriptor.ELEMENT_TYPE;
 42 
 43 import java.io.DataOutput;
 44 import java.io.IOException;
 45 import java.util.HashMap;
 46 import java.util.HashSet;
 47 import java.util.LinkedHashMap;
 48 import java.util.List;
 49 import java.util.Set;
 50 
 51 import jdk.jfr.AnnotationElement;
 52 import jdk.jfr.SettingDescriptor;
 53 import jdk.jfr.ValueDescriptor;
 54 import jdk.jfr.internal.MetadataDescriptor.Attribute;
 55 import jdk.jfr.internal.MetadataDescriptor.Element;
<span class="line-modified"> 56 import jdk.jfr.internal.consumer.StringParser;</span>
 57 
 58 /**
 59  * Class responsible for converting a list of types into a format that can be
 60  * parsed by a client.
 61  *
 62  */
 63 final class MetadataWriter {
 64 
 65     private final Element metadata = new Element(&quot;metadata&quot;);
 66     private final Element root = new Element(&quot;root&quot;);
 67 
 68     public MetadataWriter(MetadataDescriptor descriptor) {
 69         descriptor.getTypes().forEach(type -&gt; makeTypeElement(metadata, type));
 70 
 71         root.add(metadata);
 72         Element region = new Element(&quot;region&quot;);
 73         region.addAttribute(ATTRIBUTE_LOCALE, descriptor.locale);
 74         region.addAttribute(ATTRIBUTE_GMT_OFFSET, descriptor.gmtOffset);
 75         root.add(region);
 76     }
 77 
 78     public void writeBinary(DataOutput output) throws IOException {
 79         Set&lt;String&gt; stringPool = new HashSet&lt;&gt;(1000);
 80         // Possible improvement, sort string by how often they occur.
 81         // and assign low number to the most frequently used.
 82         buildStringPool(root, stringPool);
 83         HashMap&lt;String, Integer&gt; lookup = new LinkedHashMap&lt;&gt;(stringPool.size());
 84         int index = 0;
 85         int poolSize = stringPool.size();
 86         writeInt(output, poolSize);
 87         for (String s : stringPool) {
 88             lookup.put(s, index);
 89             writeString(output, s);
 90             index++;
 91         }
 92         write(output, root, lookup);
 93     }
 94 
 95     private void writeString(DataOutput out, String s) throws IOException {
 96         if (s == null ) {
<span class="line-modified"> 97             out.writeByte(StringParser.Encoding.NULL.byteValue());</span>
 98             return;
 99         }
<span class="line-modified">100         out.writeByte(StringParser.Encoding.CHAR_ARRAY.byteValue()); // encoding UTF-16</span>
101         int length = s.length();
102         writeInt(out, length);
103             for (int i = 0; i &lt; length; i++) {
104                 writeInt(out, s.charAt(i));
105             }
106     }
107 
108     private void writeInt(DataOutput out, int v) throws IOException {
109 
110         long s = v &amp; 0xffffffffL;
111         if (s &lt; 1 &lt;&lt; 7) {
112             out.write((byte) (s));
113             return;
114         }
115         out.write((byte) (s | 0x80)); // first byte written
116         s &gt;&gt;= 7;
117         if (s &lt; 1 &lt;&lt; 7) {
118             out.write((byte) (s));
119             return;
120         }
</pre>
</td>
</tr>
</table>
<center><a href="MetadataRepository.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MirrorEvent.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
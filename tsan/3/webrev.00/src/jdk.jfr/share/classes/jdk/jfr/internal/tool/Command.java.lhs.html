<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Command.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.tool;
 27 
 28 import java.io.File;
 29 import java.io.FileNotFoundException;
 30 import java.io.IOError;
 31 import java.io.IOException;
 32 import java.io.PrintStream;
 33 import java.io.RandomAccessFile;
 34 import java.nio.file.Files;
 35 import java.nio.file.InvalidPathException;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.util.ArrayList;
 39 import java.util.Collections;
 40 import java.util.Deque;
 41 import java.util.List;
 42 
 43 abstract class Command {
 44     public final static String title = &quot;Tool for working with Flight Recorder files (.jfr)&quot;;
 45     private final static Command HELP = new Help();
 46     private final static List&lt;Command&gt; COMMANDS = createCommands();
 47 
 48     private static List&lt;Command&gt; createCommands() {
 49         List&lt;Command&gt; commands = new ArrayList&lt;&gt;();
 50         commands.add(new Print());
 51         commands.add(new Metadata());
 52         commands.add(new Summary());
 53         commands.add(new Assemble());
 54         commands.add(new Disassemble());
 55         commands.add(new Version());
 56         commands.add(HELP);
 57         return Collections.unmodifiableList(commands);
 58     }
 59 
 60     static void displayHelp() {
 61         System.out.println(title);
 62         System.out.println();
 63         displayAvailableCommands(System.out);
 64     }
 65 
 66     abstract public String getName();
 67 
 68     abstract public String getDescription();
 69 
 70     abstract public void execute(Deque&lt;String&gt; argList) throws UserSyntaxException, UserDataException;
 71 
 72     protected String getTitle() {
 73         return getDescription();
 74     }
 75 
 76     static void displayAvailableCommands(PrintStream stream) {
 77         boolean first = true;
 78         for (Command c : Command.COMMANDS) {
 79             if (!first) {
 80                 System.out.println();
 81             }
 82             displayCommand(stream, c);
 83             stream.println(&quot;     &quot; + c.getDescription());
 84             first = false;
 85         }
 86     }
 87 
 88     protected static void displayCommand(PrintStream stream, Command c) {
 89         boolean firstSyntax = true;
 90         String alias = buildAlias(c);
 91         String initial = &quot; jfr &quot; + c.getName();
 92         for (String syntaxLine : c.getOptionSyntax()) {
 93             if (firstSyntax) {
 94                 if (syntaxLine.length() != 0) {
 95                    stream.println(initial + &quot; &quot; + syntaxLine + alias);
 96                 } else {
 97                    stream.println(initial + alias);
 98                 }
 99             } else {
100                 for (int i = 0; i &lt; initial.length(); i++) {
101                     stream.print(&quot; &quot;);
102                 }
103                 stream.println(&quot; &quot; + syntaxLine);
104             }
105             firstSyntax = false;
106         }
107     }
108 
109     private static String buildAlias(Command c) {
110         List&lt;String&gt; aliases = c.getAliases();
111         if (aliases.isEmpty()) {
112             return &quot;&quot;;
113         }
114         StringBuilder sb = new StringBuilder();
115         if (aliases.size() == 1) {
116             sb.append(&quot; (alias &quot;);
117             sb.append(aliases.get(0));
118             sb.append(&quot;)&quot;);
119             return sb.toString();
120          }
121          sb.append(&quot; (aliases &quot;);
122          for (int i = 0; i&lt; aliases.size(); i ++ ) {
123              sb.append(aliases.get(i));
124              if (i &lt; aliases.size() -1) {
125                  sb.append(&quot;, &quot;);
126              }
127          }
128          sb.append(&quot;)&quot;);
129          return sb.toString();
130     }
131 
132     public static List&lt;Command&gt; getCommands() {
133         return COMMANDS;
134     }
135 
136     public static Command valueOf(String commandName) {
137         for (Command command : COMMANDS) {
138             if (command.getName().equals(commandName)) {
139                 return command;
140             }
141         }
142         return null;
143     }
144 
145     public List&lt;String&gt; getOptionSyntax() {
146         return Collections.singletonList(&quot;&quot;);
147     }
148 
149     public void displayOptionUsage(PrintStream stream) {
150     }
151 
152     protected boolean acceptOption(Deque&lt;String&gt; options, String expected) throws UserSyntaxException {
153         if (expected.equals(options.peek())) {
154             if (options.size() &lt; 2) {
155                 throw new UserSyntaxException(&quot;missing value for &quot; + options.peek());
156             }
157             options.remove();
158             return true;
159         }
160         return false;
161     }
162 
163     protected void warnForWildcardExpansion(String option, String filter) throws UserDataException {
164         // Users should quote their wildcards to avoid expansion by the shell
165         try {
166             if (!filter.contains(File.pathSeparator)) {
167                 Path p = Path.of(&quot;.&quot;, filter);
168                 if (!Files.exists(p)) {
169                     return;
170                 }
171             }
172             throw new UserDataException(&quot;wildcards should be quoted, for example &quot; + option + &quot; \&quot;Foo*\&quot;&quot;);
173         } catch (InvalidPathException ipe) {
174             // ignore
175         }
176     }
177 
178     protected boolean acceptFilterOption(Deque&lt;String&gt; options, String expected) throws UserSyntaxException {
179         if (!acceptOption(options, expected)) {
180             return false;
181         }
182         if (options.isEmpty()) {
183             throw new UserSyntaxException(&quot;missing filter after &quot; + expected);
184         }
185         String filter = options.peek();
186         if (filter.startsWith(&quot;--&quot;)) {
187             throw new UserSyntaxException(&quot;missing filter after &quot; + expected);
188         }
189         return true;
190     }
191 
192     final protected void ensureMaxArgumentCount(Deque&lt;String&gt; options, int maxCount) throws UserSyntaxException {
193         if (options.size() &gt; maxCount) {
194             throw new UserSyntaxException(&quot;too many arguments&quot;);
195         }
196     }
197 
198     final protected void ensureMinArgumentCount(Deque&lt;String&gt; options, int minCount) throws UserSyntaxException {
199         if (options.size() &lt; minCount) {
200             throw new UserSyntaxException(&quot;too few arguments&quot;);
201         }
202     }
203 
204     final protected Path getDirectory(String pathText) throws UserDataException {
205         try {
206             Path path = Paths.get(pathText).toAbsolutePath();
207             if (!Files.exists((path))) {
208                 throw new UserDataException(&quot;directory does not exist, &quot; + pathText);
209             }
210             if (!Files.isDirectory(path)) {
211                 throw new UserDataException(&quot;path must be directory, &quot; + pathText);
212             }
213             return path;
214         } catch (InvalidPathException ipe) {
215             throw new UserDataException(&quot;invalid path &#39;&quot; + pathText + &quot;&#39;&quot;);
216         }
217     }
218 
219     final protected Path getJFRInputFile(Deque&lt;String&gt; options) throws UserSyntaxException, UserDataException {
220         if (options.isEmpty()) {
221             throw new UserSyntaxException(&quot;missing file&quot;);
222         }
223         String file = options.removeLast();
224         if (file.startsWith(&quot;--&quot;)) {
225             throw new UserSyntaxException(&quot;missing file&quot;);
226         }
227         try {
228             Path path = Paths.get(file).toAbsolutePath();
229             ensureAccess(path);
230             ensureJFRFile(path);
231             return path;
232         } catch (IOError ioe) {
233             throw new UserDataException(&quot;i/o error reading file &#39;&quot; + file + &quot;&#39;, &quot; + ioe.getMessage());
234         } catch (InvalidPathException ipe) {
235             throw new UserDataException(&quot;invalid path &#39;&quot; + file + &quot;&#39;&quot;);
236         }
237     }
238 
239     private void ensureAccess(Path path) throws UserDataException {
240         try (RandomAccessFile rad = new RandomAccessFile(path.toFile(), &quot;r&quot;)) {
241             if (rad.length() == 0) {
242                 throw new UserDataException(&quot;file is empty &#39;&quot; + path + &quot;&#39;&quot;);
243             }
244             rad.read(); // try to read 1 byte
245         } catch (FileNotFoundException e) {
<a name="2" id="anc2"></a><span class="line-modified">246             throw new UserDataException(&quot;could not find file &#39;&quot; + path + &quot;&#39;&quot;);</span>
247         } catch (IOException e) {
248             throw new UserDataException(&quot;i/o error reading file &#39;&quot; + path + &quot;&#39;, &quot; + e.getMessage());
249         }
250     }
251 
252     final protected void couldNotReadError(Path p, IOException e) throws UserDataException {
253         throw new UserDataException(&quot;could not read recording at &quot; + p.toAbsolutePath() + &quot;. &quot; + e.getMessage());
254     }
255 
256     final protected Path ensureFileDoesNotExist(Path file) throws UserDataException {
257         if (Files.exists(file)) {
258             throw new UserDataException(&quot;file &#39;&quot; + file + &quot;&#39; already exists&quot;);
259         }
260         return file;
261     }
262 
263     final protected void ensureJFRFile(Path path) throws UserDataException {
264         if (!path.toString().endsWith(&quot;.jfr&quot;)) {
265             throw new UserDataException(&quot;filename must end with &#39;.jfr&#39;&quot;);
266         }
267     }
268 
269     protected void displayUsage(PrintStream stream) {
270         displayCommand(stream, this);
271         stream.println();
272         displayOptionUsage(stream);
273     }
274 
275     final protected void println() {
276         System.out.println();
277     }
278 
279     final protected void print(String text) {
280         System.out.print(text);
281     }
282 
283     final protected void println(String text) {
284         System.out.println(text);
285     }
286 
287     final protected boolean matches(String command) {
288         for (String s : getNames()) {
289             if (s.equals(command)) {
290                 return true;
291             }
292         }
293         return false;
294     }
295 
296     protected List&lt;String&gt; getAliases() {
297         return Collections.emptyList();
298     }
299 
300     public List&lt;String&gt; getNames() {
301         List&lt;String&gt; names = new ArrayList&lt;&gt;();
302         names.add(getName());
303         names.addAll(getAliases());
304         return names;
305     }
306 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
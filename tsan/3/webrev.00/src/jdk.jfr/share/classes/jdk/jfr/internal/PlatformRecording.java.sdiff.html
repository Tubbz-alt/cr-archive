<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlatformRecorder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Repository.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 67 
 68     private WriteableUserPath destination;
 69 
 70     private boolean toDisk = true;
 71     private String name;
 72     private boolean dumpOnExit;
 73     private SafePath dumpOnExitDirectory = new SafePath(&quot;.&quot;);
 74     // Timestamp information
 75     private Instant stopTime;
 76     private Instant startTime;
 77 
 78     // Misc, information
 79     private RecordingState state = RecordingState.NEW;
 80     private long size;
 81     private final LinkedList&lt;RepositoryChunk&gt; chunks = new LinkedList&lt;&gt;();
 82     private volatile Recording recording;
 83     private TimerTask stopTask;
 84     private TimerTask startTask;
 85     private AccessControlContext noDestinationDumpOnExitAccessControlContext;
 86     private boolean shuoldWriteActiveRecordingEvent = true;


 87 
 88     PlatformRecording(PlatformRecorder recorder, long id) {
 89         // Typically the access control context is taken
 90         // when you call dump(Path) or setDdestination(Path),
 91         // but if no destination is set and dumponexit=true
 92         // the control context of the recording is taken when the
 93         // Recording object is constructed. This works well for
 94         // -XX:StartFlightRecording and JFR.dump
 95         this.noDestinationDumpOnExitAccessControlContext = AccessController.getContext();
 96         this.id = id;
 97         this.recorder = recorder;
 98         this.name = String.valueOf(id);
 99     }
100 
<span class="line-modified">101     public void start() {</span>
102         RecordingState oldState;
103         RecordingState newState;

104         synchronized (recorder) {
105             oldState = getState();
106             if (!Utils.isBefore(state, RecordingState.RUNNING)) {
107                 throw new IllegalStateException(&quot;Recording can only be started once.&quot;);
108             }
109             if (startTask != null) {
110                 startTask.cancel();
111                 startTask = null;
112                 startTime = null;
113             }
<span class="line-modified">114             recorder.start(this);</span>
115             Logger.log(LogTag.JFR, LogLevel.INFO, () -&gt; {
116                 // Only print non-default values so it easy to see
117                 // which options were added
118                 StringJoiner options = new StringJoiner(&quot;, &quot;);
119                 if (!toDisk) {
120                     options.add(&quot;disk=false&quot;);
121                 }
122                 if (maxAge != null) {
123                     options.add(&quot;maxage=&quot; + Utils.formatTimespan(maxAge, &quot;&quot;));
124                 }
125                 if (maxSize != 0) {
126                     options.add(&quot;maxsize=&quot; + Utils.formatBytesCompact(maxSize));
127                 }
128                 if (dumpOnExit) {
129                     options.add(&quot;dumponexit=true&quot;);
130                 }
131                 if (duration != null) {
132                     options.add(&quot;duration=&quot; + Utils.formatTimespan(duration, &quot;&quot;));
133                 }
134                 if (destination != null) {
<span class="line-modified">135                     options.add(&quot;filename=&quot; + destination.getText());</span>
136                 }
137                 String optionText = options.toString();
138                 if (optionText.length() != 0) {
139                     optionText = &quot;{&quot; + optionText + &quot;}&quot;;
140                 }
141                 return &quot;Started recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) &quot; + optionText;
142             });
143             newState = getState();
144         }
145         notifyIfStateChanged(oldState, newState);


146     }
147 
148     public boolean stop(String reason) {
149         RecordingState oldState;
150         RecordingState newState;
151         synchronized (recorder) {
152             oldState = getState();
153             if (stopTask != null) {
154                 stopTask.cancel();
155                 stopTask = null;
156             }
157             recorder.stop(this);
158             String endText = reason == null ? &quot;&quot; : &quot;. Reason \&quot;&quot; + reason + &quot;\&quot;.&quot;;
159             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Stopped recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot; + endText);
160             this.stopTime = Instant.now();
161             newState = getState();
162         }
163         WriteableUserPath dest = getDestination();
164 
165         if (dest != null) {
166             try {
167                 dumpStopped(dest);
<span class="line-modified">168                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Wrote recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) to &quot; + dest.getText());</span>
169                 notifyIfStateChanged(newState, oldState);
170                 close(); // remove if copied out
171             } catch(IOException e) {
172                 // throw e; // BUG8925030
173             }
174         } else {
175             notifyIfStateChanged(newState, oldState);
176         }
177         return true;
178     }
179 
180     public void scheduleStart(Duration delay) {
181         synchronized (recorder) {
182             ensureOkForSchedule();
183 
184             startTime = Instant.now().plus(delay);
185             LocalDateTime now = LocalDateTime.now().plus(delay);
186             setState(RecordingState.DELAYED);
187             startTask = createStartTask();
188             recorder.getTimer().schedule(startTask, delay.toMillis());
</pre>
<hr />
<pre>
301         }
302         RecordingState state = getState();
303         if (state == RecordingState.CLOSED) {
304             throw new IOException(&quot;Recording \&quot;&quot; + name + &quot;\&quot; (id=&quot; + id + &quot;) has been closed, no contents to write&quot;);
305         }
306         if (state == RecordingState.DELAYED || state == RecordingState.NEW) {
307             throw new IOException(&quot;Recording \&quot;&quot; + name + &quot;\&quot; (id=&quot; + id + &quot;) has not started, no contents to write&quot;);
308         }
309         if (state == RecordingState.STOPPED) {
310             PlatformRecording clone = recorder.newTemporaryRecording();
311             for (RepositoryChunk r : chunks) {
312                 clone.add(r);
313             }
314             return clone;
315         }
316 
317         // Recording is RUNNING, create a clone
318         PlatformRecording clone = recorder.newTemporaryRecording();
319         clone.setShouldWriteActiveRecordingEvent(false);
320         clone.setName(getName());
<span class="line-removed">321         clone.setDestination(this.destination);</span>
322         clone.setToDisk(true);
323         // We purposely don&#39;t clone settings here, since
324         // a union a == a
325         if (!isToDisk()) {
326             // force memory contents to disk
327             clone.start();
328         } else {
329             // using existing chunks on disk
330             for (RepositoryChunk c : chunks) {
331                 clone.add(c);
332             }
333             clone.setState(RecordingState.RUNNING);
334             clone.setStartTime(getStartTime());
335         }
336         if (pathToGcRoots == null) {
337             clone.setSettings(getSettings()); // needed for old object sample
338             clone.stop(reason); // dumps to destination path here
339         } else {
340             // Risk of violating lock order here, since
341             // clone.stop() will take recorder lock inside
</pre>
<hr />
<pre>
349         return clone;
350     }
351 
352     public boolean isToDisk() {
353         synchronized (recorder) {
354             return toDisk;
355         }
356     }
357 
358     public void setMaxSize(long maxSize) {
359         synchronized (recorder) {
360             if (getState() == RecordingState.CLOSED) {
361                 throw new IllegalStateException(&quot;Can&#39;t set max age when recording is closed&quot;);
362             }
363             this.maxSize = maxSize;
364             trimToSize();
365         }
366     }
367 
368     public void setDestination(WriteableUserPath userSuppliedPath) throws IOException {







369         synchronized (recorder) {
370             if (Utils.isState(getState(), RecordingState.STOPPED, RecordingState.CLOSED)) {
371                 throw new IllegalStateException(&quot;Destination can&#39;t be set on a recording that has been stopped/closed&quot;);
372             }
<span class="line-removed">373             this.destination = userSuppliedPath;</span>
374         }
375     }
376 
377     public WriteableUserPath getDestination() {
378         synchronized (recorder) {
379             return destination;
380         }
381     }
382 
383     void setState(RecordingState state) {
384         synchronized (recorder) {
385             this.state = state;
386         }
387     }
388 
389     void setStartTime(Instant startTime) {
390         synchronized (recorder) {
391             this.startTime = startTime;
392         }
393     }
</pre>
<hr />
<pre>
458             Logger.log(LogTag.JFR_SETTING, LogLevel.INFO, &quot;New settings for recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot;);
459             for (Map.Entry&lt;String, String&gt; entry : ordered.entrySet()) {
460                 String text = entry.getKey() + &quot;=\&quot;&quot; + entry.getValue() + &quot;\&quot;&quot;;
461                 Logger.log(LogTag.JFR_SETTING, LogLevel.INFO, text);
462             }
463         }
464         synchronized (recorder) {
465             this.settings = new LinkedHashMap&lt;&gt;(settings);
466             if (getState() == RecordingState.RUNNING &amp;&amp; update) {
467                 recorder.updateSettings();
468             }
469         }
470     }
471 
472     private void notifyIfStateChanged(RecordingState newState, RecordingState oldState) {
473         if (oldState == newState) {
474             return;
475         }
476         for (FlightRecorderListener cl : PlatformRecorder.getListeners()) {
477             try {
<span class="line-modified">478                 cl.recordingStateChanged(getRecording());</span>



479             } catch (RuntimeException re) {
480                 Logger.log(JFR, WARN, &quot;Error notifying recorder listener:&quot; + re.getMessage());
481             }
482         }
483     }
484 
485     public void setRecording(Recording recording) {
486         this.recording = recording;
487     }
488 
489     public Recording getRecording() {
490         return recording;
491     }
492 
493     @Override
494     public String toString() {
495         return getName() + &quot; (id=&quot; + getId() + &quot;) &quot; + getState();
496     }
497 
498     public void setConfiguration(Configuration c) {
</pre>
<hr />
<pre>
758         if (result.isEmpty()) {
759             result.add(input.get(0));
760         }
761         return result;
762     }
763 
764     private static List&lt;RepositoryChunk&gt; reduceFromEnd(Long maxSize, List&lt;RepositoryChunk&gt; input) {
765         Collections.reverse(input);
766         List&lt;RepositoryChunk&gt; result = reduceFromBeginning(maxSize, input);
767         Collections.reverse(result);
768         return result;
769     }
770 
771     public void setDumpOnExitDirectory(SafePath directory) {
772        this.dumpOnExitDirectory = directory;
773     }
774 
775     public SafePath getDumpOnExitDirectory()  {
776         return this.dumpOnExitDirectory;
777     }
































778 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 67 
 68     private WriteableUserPath destination;
 69 
 70     private boolean toDisk = true;
 71     private String name;
 72     private boolean dumpOnExit;
 73     private SafePath dumpOnExitDirectory = new SafePath(&quot;.&quot;);
 74     // Timestamp information
 75     private Instant stopTime;
 76     private Instant startTime;
 77 
 78     // Misc, information
 79     private RecordingState state = RecordingState.NEW;
 80     private long size;
 81     private final LinkedList&lt;RepositoryChunk&gt; chunks = new LinkedList&lt;&gt;();
 82     private volatile Recording recording;
 83     private TimerTask stopTask;
 84     private TimerTask startTask;
 85     private AccessControlContext noDestinationDumpOnExitAccessControlContext;
 86     private boolean shuoldWriteActiveRecordingEvent = true;
<span class="line-added"> 87     private Duration flushInterval = Duration.ofSeconds(1);</span>
<span class="line-added"> 88     private long finalStartChunkNanos = Long.MIN_VALUE;</span>
 89 
 90     PlatformRecording(PlatformRecorder recorder, long id) {
 91         // Typically the access control context is taken
 92         // when you call dump(Path) or setDdestination(Path),
 93         // but if no destination is set and dumponexit=true
 94         // the control context of the recording is taken when the
 95         // Recording object is constructed. This works well for
 96         // -XX:StartFlightRecording and JFR.dump
 97         this.noDestinationDumpOnExitAccessControlContext = AccessController.getContext();
 98         this.id = id;
 99         this.recorder = recorder;
100         this.name = String.valueOf(id);
101     }
102 
<span class="line-modified">103     public long start() {</span>
104         RecordingState oldState;
105         RecordingState newState;
<span class="line-added">106         long startNanos = -1;</span>
107         synchronized (recorder) {
108             oldState = getState();
109             if (!Utils.isBefore(state, RecordingState.RUNNING)) {
110                 throw new IllegalStateException(&quot;Recording can only be started once.&quot;);
111             }
112             if (startTask != null) {
113                 startTask.cancel();
114                 startTask = null;
115                 startTime = null;
116             }
<span class="line-modified">117             startNanos = recorder.start(this);</span>
118             Logger.log(LogTag.JFR, LogLevel.INFO, () -&gt; {
119                 // Only print non-default values so it easy to see
120                 // which options were added
121                 StringJoiner options = new StringJoiner(&quot;, &quot;);
122                 if (!toDisk) {
123                     options.add(&quot;disk=false&quot;);
124                 }
125                 if (maxAge != null) {
126                     options.add(&quot;maxage=&quot; + Utils.formatTimespan(maxAge, &quot;&quot;));
127                 }
128                 if (maxSize != 0) {
129                     options.add(&quot;maxsize=&quot; + Utils.formatBytesCompact(maxSize));
130                 }
131                 if (dumpOnExit) {
132                     options.add(&quot;dumponexit=true&quot;);
133                 }
134                 if (duration != null) {
135                     options.add(&quot;duration=&quot; + Utils.formatTimespan(duration, &quot;&quot;));
136                 }
137                 if (destination != null) {
<span class="line-modified">138                     options.add(&quot;filename=&quot; + destination.getRealPathText());</span>
139                 }
140                 String optionText = options.toString();
141                 if (optionText.length() != 0) {
142                     optionText = &quot;{&quot; + optionText + &quot;}&quot;;
143                 }
144                 return &quot;Started recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) &quot; + optionText;
145             });
146             newState = getState();
147         }
148         notifyIfStateChanged(oldState, newState);
<span class="line-added">149 </span>
<span class="line-added">150         return startNanos;</span>
151     }
152 
153     public boolean stop(String reason) {
154         RecordingState oldState;
155         RecordingState newState;
156         synchronized (recorder) {
157             oldState = getState();
158             if (stopTask != null) {
159                 stopTask.cancel();
160                 stopTask = null;
161             }
162             recorder.stop(this);
163             String endText = reason == null ? &quot;&quot; : &quot;. Reason \&quot;&quot; + reason + &quot;\&quot;.&quot;;
164             Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Stopped recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot; + endText);
165             this.stopTime = Instant.now();
166             newState = getState();
167         }
168         WriteableUserPath dest = getDestination();
169 
170         if (dest != null) {
171             try {
172                 dumpStopped(dest);
<span class="line-modified">173                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Wrote recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) to &quot; + dest.getRealPathText());</span>
174                 notifyIfStateChanged(newState, oldState);
175                 close(); // remove if copied out
176             } catch(IOException e) {
177                 // throw e; // BUG8925030
178             }
179         } else {
180             notifyIfStateChanged(newState, oldState);
181         }
182         return true;
183     }
184 
185     public void scheduleStart(Duration delay) {
186         synchronized (recorder) {
187             ensureOkForSchedule();
188 
189             startTime = Instant.now().plus(delay);
190             LocalDateTime now = LocalDateTime.now().plus(delay);
191             setState(RecordingState.DELAYED);
192             startTask = createStartTask();
193             recorder.getTimer().schedule(startTask, delay.toMillis());
</pre>
<hr />
<pre>
306         }
307         RecordingState state = getState();
308         if (state == RecordingState.CLOSED) {
309             throw new IOException(&quot;Recording \&quot;&quot; + name + &quot;\&quot; (id=&quot; + id + &quot;) has been closed, no contents to write&quot;);
310         }
311         if (state == RecordingState.DELAYED || state == RecordingState.NEW) {
312             throw new IOException(&quot;Recording \&quot;&quot; + name + &quot;\&quot; (id=&quot; + id + &quot;) has not started, no contents to write&quot;);
313         }
314         if (state == RecordingState.STOPPED) {
315             PlatformRecording clone = recorder.newTemporaryRecording();
316             for (RepositoryChunk r : chunks) {
317                 clone.add(r);
318             }
319             return clone;
320         }
321 
322         // Recording is RUNNING, create a clone
323         PlatformRecording clone = recorder.newTemporaryRecording();
324         clone.setShouldWriteActiveRecordingEvent(false);
325         clone.setName(getName());

326         clone.setToDisk(true);
327         // We purposely don&#39;t clone settings here, since
328         // a union a == a
329         if (!isToDisk()) {
330             // force memory contents to disk
331             clone.start();
332         } else {
333             // using existing chunks on disk
334             for (RepositoryChunk c : chunks) {
335                 clone.add(c);
336             }
337             clone.setState(RecordingState.RUNNING);
338             clone.setStartTime(getStartTime());
339         }
340         if (pathToGcRoots == null) {
341             clone.setSettings(getSettings()); // needed for old object sample
342             clone.stop(reason); // dumps to destination path here
343         } else {
344             // Risk of violating lock order here, since
345             // clone.stop() will take recorder lock inside
</pre>
<hr />
<pre>
353         return clone;
354     }
355 
356     public boolean isToDisk() {
357         synchronized (recorder) {
358             return toDisk;
359         }
360     }
361 
362     public void setMaxSize(long maxSize) {
363         synchronized (recorder) {
364             if (getState() == RecordingState.CLOSED) {
365                 throw new IllegalStateException(&quot;Can&#39;t set max age when recording is closed&quot;);
366             }
367             this.maxSize = maxSize;
368             trimToSize();
369         }
370     }
371 
372     public void setDestination(WriteableUserPath userSuppliedPath) throws IOException {
<span class="line-added">373         synchronized (recorder) {</span>
<span class="line-added">374             checkSetDestination(userSuppliedPath);</span>
<span class="line-added">375             this.destination = userSuppliedPath;</span>
<span class="line-added">376         }</span>
<span class="line-added">377     }</span>
<span class="line-added">378 </span>
<span class="line-added">379     public void checkSetDestination(WriteableUserPath userSuppliedPath) throws IOException {</span>
380         synchronized (recorder) {
381             if (Utils.isState(getState(), RecordingState.STOPPED, RecordingState.CLOSED)) {
382                 throw new IllegalStateException(&quot;Destination can&#39;t be set on a recording that has been stopped/closed&quot;);
383             }

384         }
385     }
386 
387     public WriteableUserPath getDestination() {
388         synchronized (recorder) {
389             return destination;
390         }
391     }
392 
393     void setState(RecordingState state) {
394         synchronized (recorder) {
395             this.state = state;
396         }
397     }
398 
399     void setStartTime(Instant startTime) {
400         synchronized (recorder) {
401             this.startTime = startTime;
402         }
403     }
</pre>
<hr />
<pre>
468             Logger.log(LogTag.JFR_SETTING, LogLevel.INFO, &quot;New settings for recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;)&quot;);
469             for (Map.Entry&lt;String, String&gt; entry : ordered.entrySet()) {
470                 String text = entry.getKey() + &quot;=\&quot;&quot; + entry.getValue() + &quot;\&quot;&quot;;
471                 Logger.log(LogTag.JFR_SETTING, LogLevel.INFO, text);
472             }
473         }
474         synchronized (recorder) {
475             this.settings = new LinkedHashMap&lt;&gt;(settings);
476             if (getState() == RecordingState.RUNNING &amp;&amp; update) {
477                 recorder.updateSettings();
478             }
479         }
480     }
481 
482     private void notifyIfStateChanged(RecordingState newState, RecordingState oldState) {
483         if (oldState == newState) {
484             return;
485         }
486         for (FlightRecorderListener cl : PlatformRecorder.getListeners()) {
487             try {
<span class="line-modified">488                 // Skip internal recordings</span>
<span class="line-added">489                 if (recording != null) {</span>
<span class="line-added">490                     cl.recordingStateChanged(recording);</span>
<span class="line-added">491                 }</span>
492             } catch (RuntimeException re) {
493                 Logger.log(JFR, WARN, &quot;Error notifying recorder listener:&quot; + re.getMessage());
494             }
495         }
496     }
497 
498     public void setRecording(Recording recording) {
499         this.recording = recording;
500     }
501 
502     public Recording getRecording() {
503         return recording;
504     }
505 
506     @Override
507     public String toString() {
508         return getName() + &quot; (id=&quot; + getId() + &quot;) &quot; + getState();
509     }
510 
511     public void setConfiguration(Configuration c) {
</pre>
<hr />
<pre>
771         if (result.isEmpty()) {
772             result.add(input.get(0));
773         }
774         return result;
775     }
776 
777     private static List&lt;RepositoryChunk&gt; reduceFromEnd(Long maxSize, List&lt;RepositoryChunk&gt; input) {
778         Collections.reverse(input);
779         List&lt;RepositoryChunk&gt; result = reduceFromBeginning(maxSize, input);
780         Collections.reverse(result);
781         return result;
782     }
783 
784     public void setDumpOnExitDirectory(SafePath directory) {
785        this.dumpOnExitDirectory = directory;
786     }
787 
788     public SafePath getDumpOnExitDirectory()  {
789         return this.dumpOnExitDirectory;
790     }
<span class="line-added">791 </span>
<span class="line-added">792     public void setFlushInterval(Duration interval) {</span>
<span class="line-added">793         synchronized (recorder) {</span>
<span class="line-added">794             if (getState() == RecordingState.CLOSED) {</span>
<span class="line-added">795                 throw new IllegalStateException(&quot;Can&#39;t set stream interval when recording is closed&quot;);</span>
<span class="line-added">796             }</span>
<span class="line-added">797             this.flushInterval = interval;</span>
<span class="line-added">798         }</span>
<span class="line-added">799     }</span>
<span class="line-added">800 </span>
<span class="line-added">801     public Duration getFlushInterval() {</span>
<span class="line-added">802         synchronized (recorder) {</span>
<span class="line-added">803             return flushInterval;</span>
<span class="line-added">804         }</span>
<span class="line-added">805     }</span>
<span class="line-added">806 </span>
<span class="line-added">807     public long getStreamIntervalMillis() {</span>
<span class="line-added">808         synchronized (recorder) {</span>
<span class="line-added">809             if (flushInterval != null) {</span>
<span class="line-added">810                 return flushInterval.toMillis();</span>
<span class="line-added">811             }</span>
<span class="line-added">812             return Long.MAX_VALUE;</span>
<span class="line-added">813         }</span>
<span class="line-added">814     }</span>
<span class="line-added">815 </span>
<span class="line-added">816     public long getFinalChunkStartNanos() {</span>
<span class="line-added">817         return finalStartChunkNanos;</span>
<span class="line-added">818     }</span>
<span class="line-added">819 </span>
<span class="line-added">820     public void setFinalStartnanos(long chunkStartNanos) {</span>
<span class="line-added">821        this.finalStartChunkNanos = chunkStartNanos;</span>
<span class="line-added">822     }</span>
823 }
</pre>
</td>
</tr>
</table>
<center><a href="PlatformRecorder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Repository.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
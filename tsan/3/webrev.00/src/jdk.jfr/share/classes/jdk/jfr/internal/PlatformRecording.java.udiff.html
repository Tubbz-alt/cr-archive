<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlatformRecorder.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Repository.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/PlatformRecording.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -82,10 +82,12 @@</span>
      private volatile Recording recording;
      private TimerTask stopTask;
      private TimerTask startTask;
      private AccessControlContext noDestinationDumpOnExitAccessControlContext;
      private boolean shuoldWriteActiveRecordingEvent = true;
<span class="udiff-line-added">+     private Duration flushInterval = Duration.ofSeconds(1);</span>
<span class="udiff-line-added">+     private long finalStartChunkNanos = Long.MIN_VALUE;</span>
  
      PlatformRecording(PlatformRecorder recorder, long id) {
          // Typically the access control context is taken
          // when you call dump(Path) or setDdestination(Path),
          // but if no destination is set and dumponexit=true
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -96,24 +98,25 @@</span>
          this.id = id;
          this.recorder = recorder;
          this.name = String.valueOf(id);
      }
  
<span class="udiff-line-modified-removed">-     public void start() {</span>
<span class="udiff-line-modified-added">+     public long start() {</span>
          RecordingState oldState;
          RecordingState newState;
<span class="udiff-line-added">+         long startNanos = -1;</span>
          synchronized (recorder) {
              oldState = getState();
              if (!Utils.isBefore(state, RecordingState.RUNNING)) {
                  throw new IllegalStateException(&quot;Recording can only be started once.&quot;);
              }
              if (startTask != null) {
                  startTask.cancel();
                  startTask = null;
                  startTime = null;
              }
<span class="udiff-line-modified-removed">-             recorder.start(this);</span>
<span class="udiff-line-modified-added">+             startNanos = recorder.start(this);</span>
              Logger.log(LogTag.JFR, LogLevel.INFO, () -&gt; {
                  // Only print non-default values so it easy to see
                  // which options were added
                  StringJoiner options = new StringJoiner(&quot;, &quot;);
                  if (!toDisk) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -130,21 +133,23 @@</span>
                  }
                  if (duration != null) {
                      options.add(&quot;duration=&quot; + Utils.formatTimespan(duration, &quot;&quot;));
                  }
                  if (destination != null) {
<span class="udiff-line-modified-removed">-                     options.add(&quot;filename=&quot; + destination.getText());</span>
<span class="udiff-line-modified-added">+                     options.add(&quot;filename=&quot; + destination.getRealPathText());</span>
                  }
                  String optionText = options.toString();
                  if (optionText.length() != 0) {
                      optionText = &quot;{&quot; + optionText + &quot;}&quot;;
                  }
                  return &quot;Started recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) &quot; + optionText;
              });
              newState = getState();
          }
          notifyIfStateChanged(oldState, newState);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return startNanos;</span>
      }
  
      public boolean stop(String reason) {
          RecordingState oldState;
          RecordingState newState;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -163,11 +168,11 @@</span>
          WriteableUserPath dest = getDestination();
  
          if (dest != null) {
              try {
                  dumpStopped(dest);
<span class="udiff-line-modified-removed">-                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Wrote recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) to &quot; + dest.getText());</span>
<span class="udiff-line-modified-added">+                 Logger.log(LogTag.JFR, LogLevel.INFO, &quot;Wrote recording \&quot;&quot; + getName() + &quot;\&quot; (&quot; + getId() + &quot;) to &quot; + dest.getRealPathText());</span>
                  notifyIfStateChanged(newState, oldState);
                  close(); // remove if copied out
              } catch(IOException e) {
                  // throw e; // BUG8925030
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -316,11 +321,10 @@</span>
  
          // Recording is RUNNING, create a clone
          PlatformRecording clone = recorder.newTemporaryRecording();
          clone.setShouldWriteActiveRecordingEvent(false);
          clone.setName(getName());
<span class="udiff-line-removed">-         clone.setDestination(this.destination);</span>
          clone.setToDisk(true);
          // We purposely don&#39;t clone settings here, since
          // a union a == a
          if (!isToDisk()) {
              // force memory contents to disk
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -364,15 +368,21 @@</span>
              trimToSize();
          }
      }
  
      public void setDestination(WriteableUserPath userSuppliedPath) throws IOException {
<span class="udiff-line-added">+         synchronized (recorder) {</span>
<span class="udiff-line-added">+             checkSetDestination(userSuppliedPath);</span>
<span class="udiff-line-added">+             this.destination = userSuppliedPath;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public void checkSetDestination(WriteableUserPath userSuppliedPath) throws IOException {</span>
          synchronized (recorder) {
              if (Utils.isState(getState(), RecordingState.STOPPED, RecordingState.CLOSED)) {
                  throw new IllegalStateException(&quot;Destination can&#39;t be set on a recording that has been stopped/closed&quot;);
              }
<span class="udiff-line-removed">-             this.destination = userSuppliedPath;</span>
          }
      }
  
      public WriteableUserPath getDestination() {
          synchronized (recorder) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -473,11 +483,14 @@</span>
          if (oldState == newState) {
              return;
          }
          for (FlightRecorderListener cl : PlatformRecorder.getListeners()) {
              try {
<span class="udiff-line-modified-removed">-                 cl.recordingStateChanged(getRecording());</span>
<span class="udiff-line-modified-added">+                 // Skip internal recordings</span>
<span class="udiff-line-added">+                 if (recording != null) {</span>
<span class="udiff-line-added">+                     cl.recordingStateChanged(recording);</span>
<span class="udiff-line-added">+                 }</span>
              } catch (RuntimeException re) {
                  Logger.log(JFR, WARN, &quot;Error notifying recorder listener:&quot; + re.getMessage());
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -773,6 +786,38 @@</span>
      }
  
      public SafePath getDumpOnExitDirectory()  {
          return this.dumpOnExitDirectory;
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public void setFlushInterval(Duration interval) {</span>
<span class="udiff-line-added">+         synchronized (recorder) {</span>
<span class="udiff-line-added">+             if (getState() == RecordingState.CLOSED) {</span>
<span class="udiff-line-added">+                 throw new IllegalStateException(&quot;Can&#39;t set stream interval when recording is closed&quot;);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             this.flushInterval = interval;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public Duration getFlushInterval() {</span>
<span class="udiff-line-added">+         synchronized (recorder) {</span>
<span class="udiff-line-added">+             return flushInterval;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public long getStreamIntervalMillis() {</span>
<span class="udiff-line-added">+         synchronized (recorder) {</span>
<span class="udiff-line-added">+             if (flushInterval != null) {</span>
<span class="udiff-line-added">+                 return flushInterval.toMillis();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return Long.MAX_VALUE;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public long getFinalChunkStartNanos() {</span>
<span class="udiff-line-added">+         return finalStartChunkNanos;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public void setFinalStartnanos(long chunkStartNanos) {</span>
<span class="udiff-line-added">+        this.finalStartChunkNanos = chunkStartNanos;</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="PlatformRecorder.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Repository.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
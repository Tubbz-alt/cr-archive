<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/ChunkHeader.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../WriteableUserPath.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RecordingInput.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/ChunkHeader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
<span class="line-removed"> 28 import java.io.DataInput;</span>
 29 import java.io.IOException;
 30 
 31 import jdk.jfr.internal.LogLevel;
 32 import jdk.jfr.internal.LogTag;
 33 import jdk.jfr.internal.Logger;
 34 import jdk.jfr.internal.MetadataDescriptor;

 35 
 36 public final class ChunkHeader {






 37     private static final long METADATA_TYPE_ID = 0;
 38     private static final byte[] FILE_MAGIC = { &#39;F&#39;, &#39;L&#39;, &#39;R&#39;, &#39;\0&#39; };

 39 
 40     private final short major;
 41     private final short minor;
<span class="line-removed"> 42     private final long chunkSize;</span>
 43     private final long chunkStartTicks;
 44     private final long ticksPerSecond;
 45     private final long chunkStartNanos;
<span class="line-removed"> 46     private final long metadataPosition;</span>
<span class="line-removed"> 47  //   private final long absoluteInitialConstantPoolPosition;</span>
<span class="line-removed"> 48     private final long absoluteChunkEnd;</span>
<span class="line-removed"> 49     private final long absoluteEventStart;</span>
 50     private final long absoluteChunkStart;
<span class="line-removed"> 51     private final boolean lastChunk;</span>
 52     private final RecordingInput input;
<span class="line-removed"> 53     private final long durationNanos;</span>
 54     private final long id;
<span class="line-modified"> 55     private long constantPoolPosition;</span>








 56 
 57     public ChunkHeader(RecordingInput input) throws IOException {
 58         this(input, 0, 0);
 59     }
 60 
 61     private ChunkHeader(RecordingInput input, long absoluteChunkStart, long id) throws IOException {






 62         input.position(absoluteChunkStart);
 63         if (input.position() &gt;= input.size()) {
<span class="line-modified"> 64             throw new IOException(&quot;Chunk contains no data&quot;);</span>
 65         }
 66         verifyMagic(input);
 67         this.input = input;
 68         this.id = id;
<span class="line-modified"> 69         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk &quot; + id);</span>

 70         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: startPosition=&quot; + absoluteChunkStart);
 71         major = input.readRawShort();
 72         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: major=&quot; + major);
 73         minor = input.readRawShort();
 74         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: minor=&quot; + minor);
 75         if (major != 1 &amp;&amp; major != 2) {
 76             throw new IOException(&quot;File version &quot; + major + &quot;.&quot; + minor + &quot;. Only Flight Recorder files of version 1.x and 2.x can be read by this JDK.&quot;);
 77         }
<span class="line-modified"> 78         chunkSize = input.readRawLong();</span>
 79         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: chunkSize=&quot; + chunkSize);
<span class="line-modified"> 80         this.constantPoolPosition = input.readRawLong();</span>
 81         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: constantPoolPosition=&quot; + constantPoolPosition);
<span class="line-modified"> 82         metadataPosition = input.readRawLong();</span>
 83         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: metadataPosition=&quot; + metadataPosition);
 84         chunkStartNanos = input.readRawLong(); // nanos since epoch
 85         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: startNanos=&quot; + chunkStartNanos);
 86         durationNanos = input.readRawLong(); // duration nanos, not used
 87         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: durationNanos=&quot; + durationNanos);
 88         chunkStartTicks = input.readRawLong();
 89         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: startTicks=&quot; + chunkStartTicks);
 90         ticksPerSecond = input.readRawLong();
 91         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: ticksPerSecond=&quot; + ticksPerSecond);
<span class="line-modified"> 92         input.readRawInt(); // features, not used</span>



 93 
<span class="line-modified"> 94         // set up boundaries</span>
<span class="line-modified"> 95         this.absoluteChunkStart = absoluteChunkStart;</span>
<span class="line-modified"> 96         absoluteChunkEnd = absoluteChunkStart + chunkSize;</span>
<span class="line-modified"> 97         lastChunk = input.size() == absoluteChunkEnd;</span>
<span class="line-modified"> 98         absoluteEventStart = input.position();</span>
















































 99 
<span class="line-modified">100         // read metadata</span>
<span class="line-modified">101         input.position(absoluteEventStart);</span>






























102     }
103 
104     public ChunkHeader nextHeader() throws IOException {
105         return new ChunkHeader(input, absoluteChunkEnd, id + 1);
106     }
<span class="line-removed">107 </span>
108     public MetadataDescriptor readMetadata() throws IOException {




109         input.position(absoluteChunkStart + metadataPosition);
110         input.readInt(); // size
111         long id = input.readLong(); // event type id
112         if (id != METADATA_TYPE_ID) {
113             throw new IOException(&quot;Expected metadata event. Type id=&quot; + id + &quot;, should have been &quot; + METADATA_TYPE_ID);
114         }
115         input.readLong(); // start time
116         input.readLong(); // duration
117         long metadataId = input.readLong();
<span class="line-modified">118         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE, &quot;Metadata id=&quot; + metadataId);</span>
<span class="line-modified">119         // No need to read if metadataId == lastMetadataId, but we</span>
<span class="line-modified">120         // do it for verification purposes.</span>
<span class="line-modified">121         return MetadataDescriptor.read(input);</span>



122     }
123 
<span class="line-removed">124     public boolean isLastChunk() {</span>
<span class="line-removed">125         return lastChunk;</span>
<span class="line-removed">126     }</span>
127 
128     public short getMajor() {
129         return major;
130     }
131 
132     public short getMinor() {
133         return minor;
134     }
135 
136     public long getAbsoluteChunkStart() {
137         return absoluteChunkStart;
138     }
139 



140     public long getConstantPoolPosition() {
141         return constantPoolPosition;
142     }
143 



144     public long getStartTicks() {
145         return chunkStartTicks;
146     }



147 
148     public double getTicksPerSecond() {
149         return ticksPerSecond;
150     }
151 
152     public long getStartNanos() {
153         return chunkStartNanos;
154     }
155 
156     public long getEnd() {
157         return absoluteChunkEnd;
158     }
159 
160     public long getSize() {
161         return chunkSize;
162     }
163 
164     public long getDurationNanos() {
165         return durationNanos;
166     }
167 
168     public RecordingInput getInput() {
169         return input;
170     }
171 
<span class="line-modified">172     private static void verifyMagic(DataInput input) throws IOException {</span>
173         for (byte c : FILE_MAGIC) {
174             if (input.readByte() != c) {
175                 throw new IOException(&quot;Not a Flight Recorder file&quot;);
176             }
177         }
178     }
179 
180     public long getEventStart() {
181         return absoluteEventStart;
182     }
183 







184 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 

 28 import java.io.IOException;
 29 
 30 import jdk.jfr.internal.LogLevel;
 31 import jdk.jfr.internal.LogTag;
 32 import jdk.jfr.internal.Logger;
 33 import jdk.jfr.internal.MetadataDescriptor;
<span class="line-added"> 34 import jdk.jfr.internal.Utils;</span>
 35 
 36 public final class ChunkHeader {
<span class="line-added"> 37     private static final long HEADER_SIZE = 68;</span>
<span class="line-added"> 38     private static final byte UPDATING_CHUNK_HEADER = (byte) 255;</span>
<span class="line-added"> 39     private static final long CHUNK_SIZE_POSITION = 8;</span>
<span class="line-added"> 40     private static final long DURATION_NANOS_POSITION = 40;</span>
<span class="line-added"> 41     private static final long FILE_STATE_POSITION = 64;</span>
<span class="line-added"> 42     private static final long FLAG_BYTE_POSITION = 67;</span>
 43     private static final long METADATA_TYPE_ID = 0;
 44     private static final byte[] FILE_MAGIC = { &#39;F&#39;, &#39;L&#39;, &#39;R&#39;, &#39;\0&#39; };
<span class="line-added"> 45     private static final int MASK_FINAL_CHUNK = 1 &lt;&lt; 1;</span>
 46 
 47     private final short major;
 48     private final short minor;

 49     private final long chunkStartTicks;
 50     private final long ticksPerSecond;
 51     private final long chunkStartNanos;




 52     private final long absoluteChunkStart;

 53     private final RecordingInput input;

 54     private final long id;
<span class="line-modified"> 55     private long absoluteEventStart;</span>
<span class="line-added"> 56     private long chunkSize = 0;</span>
<span class="line-added"> 57     private long constantPoolPosition = 0;</span>
<span class="line-added"> 58     private long metadataPosition = 0;</span>
<span class="line-added"> 59     private long durationNanos;</span>
<span class="line-added"> 60     private long absoluteChunkEnd;</span>
<span class="line-added"> 61     private boolean isFinished;</span>
<span class="line-added"> 62     private boolean finished;</span>
<span class="line-added"> 63     private boolean finalChunk;</span>
 64 
 65     public ChunkHeader(RecordingInput input) throws IOException {
 66         this(input, 0, 0);
 67     }
 68 
 69     private ChunkHeader(RecordingInput input, long absoluteChunkStart, long id) throws IOException {
<span class="line-added"> 70         this.absoluteChunkStart = absoluteChunkStart;</span>
<span class="line-added"> 71         this.absoluteEventStart = absoluteChunkStart + HEADER_SIZE;</span>
<span class="line-added"> 72         if (input.getFileSize() &lt; HEADER_SIZE) {</span>
<span class="line-added"> 73             throw new IOException(&quot;Not a complete Chunk header&quot;);</span>
<span class="line-added"> 74         }</span>
<span class="line-added"> 75         input.setValidSize(absoluteChunkStart + HEADER_SIZE);</span>
 76         input.position(absoluteChunkStart);
 77         if (input.position() &gt;= input.size()) {
<span class="line-modified"> 78            throw new IOException(&quot;Chunk contains no data&quot;);</span>
 79         }
 80         verifyMagic(input);
 81         this.input = input;
 82         this.id = id;
<span class="line-modified"> 83         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: &quot; + id);</span>
<span class="line-added"> 84         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: file=&quot; + input.getFilename());</span>
 85         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: startPosition=&quot; + absoluteChunkStart);
 86         major = input.readRawShort();
 87         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: major=&quot; + major);
 88         minor = input.readRawShort();
 89         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: minor=&quot; + minor);
 90         if (major != 1 &amp;&amp; major != 2) {
 91             throw new IOException(&quot;File version &quot; + major + &quot;.&quot; + minor + &quot;. Only Flight Recorder files of version 1.x and 2.x can be read by this JDK.&quot;);
 92         }
<span class="line-modified"> 93         input.readRawLong(); // chunk size</span>
 94         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: chunkSize=&quot; + chunkSize);
<span class="line-modified"> 95         input.readRawLong(); // constant pool position</span>
 96         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: constantPoolPosition=&quot; + constantPoolPosition);
<span class="line-modified"> 97         input.readRawLong(); // metadata position</span>
 98         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: metadataPosition=&quot; + metadataPosition);
 99         chunkStartNanos = input.readRawLong(); // nanos since epoch
100         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: startNanos=&quot; + chunkStartNanos);
101         durationNanos = input.readRawLong(); // duration nanos, not used
102         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: durationNanos=&quot; + durationNanos);
103         chunkStartTicks = input.readRawLong();
104         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: startTicks=&quot; + chunkStartTicks);
105         ticksPerSecond = input.readRawLong();
106         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: ticksPerSecond=&quot; + ticksPerSecond);
<span class="line-modified">107         input.readRawInt(); // ignore file state and flag bits</span>
<span class="line-added">108         refresh();</span>
<span class="line-added">109         input.position(absoluteEventStart);</span>
<span class="line-added">110     }</span>
111 
<span class="line-modified">112     void refresh() throws IOException {</span>
<span class="line-modified">113         while (true) {</span>
<span class="line-modified">114             byte fileState1;</span>
<span class="line-modified">115             input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);</span>
<span class="line-modified">116             while ((fileState1 = input.readPhysicalByte()) == UPDATING_CHUNK_HEADER) {</span>
<span class="line-added">117                 Utils.takeNap(1);</span>
<span class="line-added">118                 input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);</span>
<span class="line-added">119             }</span>
<span class="line-added">120             input.positionPhysical(absoluteChunkStart + CHUNK_SIZE_POSITION);</span>
<span class="line-added">121             long chunkSize = input.readPhysicalLong();</span>
<span class="line-added">122             long constantPoolPosition = input.readPhysicalLong();</span>
<span class="line-added">123             long metadataPosition = input.readPhysicalLong();</span>
<span class="line-added">124             input.positionPhysical(absoluteChunkStart + DURATION_NANOS_POSITION);</span>
<span class="line-added">125             long durationNanos = input.readPhysicalLong();</span>
<span class="line-added">126             input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);</span>
<span class="line-added">127             byte fileState2 =  input.readPhysicalByte();</span>
<span class="line-added">128             input.positionPhysical(absoluteChunkStart + FLAG_BYTE_POSITION);</span>
<span class="line-added">129             int flagByte = input.readPhysicalByte();</span>
<span class="line-added">130             if (fileState1 == fileState2) { // valid header</span>
<span class="line-added">131                 finished = fileState1 == 0;</span>
<span class="line-added">132                 if (metadataPosition != 0) {</span>
<span class="line-added">133                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Setting input size to &quot; + (absoluteChunkStart + chunkSize));</span>
<span class="line-added">134                     if (finished) {</span>
<span class="line-added">135                         // This assumes that the whole recording</span>
<span class="line-added">136                         // is finished if the first chunk is.</span>
<span class="line-added">137                         // This is a limitation we may want to</span>
<span class="line-added">138                         // remove, but greatly improves performance as</span>
<span class="line-added">139                         // data can be read across chunk boundaries</span>
<span class="line-added">140                         // of multi-chunk files and only once.</span>
<span class="line-added">141                         input.setValidSize(input.getFileSize());</span>
<span class="line-added">142                     } else {</span>
<span class="line-added">143                         input.setValidSize(absoluteChunkStart + chunkSize);</span>
<span class="line-added">144                     }</span>
<span class="line-added">145                     this.chunkSize = chunkSize;</span>
<span class="line-added">146                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: chunkSize=&quot; + chunkSize);</span>
<span class="line-added">147                     this.constantPoolPosition = constantPoolPosition;</span>
<span class="line-added">148                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: constantPoolPosition=&quot; + constantPoolPosition);</span>
<span class="line-added">149                     this.metadataPosition = metadataPosition;</span>
<span class="line-added">150                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: metadataPosition=&quot; + metadataPosition);</span>
<span class="line-added">151                     this.durationNanos = durationNanos;</span>
<span class="line-added">152                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: durationNanos =&quot; + durationNanos);</span>
<span class="line-added">153                     isFinished = fileState2 == 0;</span>
<span class="line-added">154                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: generation=&quot; + fileState2);</span>
<span class="line-added">155                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: finished=&quot; + isFinished);</span>
<span class="line-added">156                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: fileSize=&quot; + input.size());</span>
<span class="line-added">157                     this.finalChunk = (flagByte &amp; MASK_FINAL_CHUNK) != 0;</span>
<span class="line-added">158                     Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, &quot;Chunk: finalChunk=&quot; + finalChunk);</span>
<span class="line-added">159                     absoluteChunkEnd = absoluteChunkStart + chunkSize;</span>
<span class="line-added">160                     return;</span>
<span class="line-added">161                 }</span>
<span class="line-added">162             }</span>
<span class="line-added">163         }</span>
<span class="line-added">164     }</span>
165 
<span class="line-modified">166     public void awaitFinished() throws IOException {</span>
<span class="line-modified">167         if (finished) {</span>
<span class="line-added">168             return;</span>
<span class="line-added">169         }</span>
<span class="line-added">170         long pos = input.position();</span>
<span class="line-added">171         try {</span>
<span class="line-added">172             input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);</span>
<span class="line-added">173             while (true) {</span>
<span class="line-added">174                 byte filestate = input.readPhysicalByte();</span>
<span class="line-added">175                 if (filestate == 0) {</span>
<span class="line-added">176                     finished = true;</span>
<span class="line-added">177                     return;</span>
<span class="line-added">178                 }</span>
<span class="line-added">179                 Utils.takeNap(1);</span>
<span class="line-added">180             }</span>
<span class="line-added">181         } finally {</span>
<span class="line-added">182             input.position(pos);</span>
<span class="line-added">183         }</span>
<span class="line-added">184     }</span>
<span class="line-added">185 </span>
<span class="line-added">186     public boolean isLastChunk() throws IOException {</span>
<span class="line-added">187         awaitFinished();</span>
<span class="line-added">188         // streaming files only have one chunk</span>
<span class="line-added">189         return input.getFileSize() == absoluteChunkEnd;</span>
<span class="line-added">190    }</span>
<span class="line-added">191 </span>
<span class="line-added">192     public boolean isFinalChunk() {</span>
<span class="line-added">193         return finalChunk;</span>
<span class="line-added">194     }</span>
<span class="line-added">195 </span>
<span class="line-added">196     public boolean isFinished() throws IOException {</span>
<span class="line-added">197         return isFinished;</span>
198     }
199 
200     public ChunkHeader nextHeader() throws IOException {
201         return new ChunkHeader(input, absoluteChunkEnd, id + 1);
202     }

203     public MetadataDescriptor readMetadata() throws IOException {
<span class="line-added">204         return readMetadata(null);</span>
<span class="line-added">205     }</span>
<span class="line-added">206 </span>
<span class="line-added">207     public MetadataDescriptor readMetadata(MetadataDescriptor previous) throws IOException {</span>
208         input.position(absoluteChunkStart + metadataPosition);
209         input.readInt(); // size
210         long id = input.readLong(); // event type id
211         if (id != METADATA_TYPE_ID) {
212             throw new IOException(&quot;Expected metadata event. Type id=&quot; + id + &quot;, should have been &quot; + METADATA_TYPE_ID);
213         }
214         input.readLong(); // start time
215         input.readLong(); // duration
216         long metadataId = input.readLong();
<span class="line-modified">217         if (previous != null &amp;&amp; metadataId == previous.metadataId) {</span>
<span class="line-modified">218             return previous;</span>
<span class="line-modified">219         }</span>
<span class="line-modified">220         Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.TRACE, &quot;New metadata id = &quot; + metadataId);</span>
<span class="line-added">221         MetadataDescriptor m =  MetadataDescriptor.read(input);</span>
<span class="line-added">222         m.metadataId = metadataId;</span>
<span class="line-added">223         return m;</span>
224     }
225 



226 
227     public short getMajor() {
228         return major;
229     }
230 
231     public short getMinor() {
232         return minor;
233     }
234 
235     public long getAbsoluteChunkStart() {
236         return absoluteChunkStart;
237     }
238 
<span class="line-added">239     public long getAbsoluteEventStart() {</span>
<span class="line-added">240         return absoluteEventStart;</span>
<span class="line-added">241     }</span>
242     public long getConstantPoolPosition() {
243         return constantPoolPosition;
244     }
245 
<span class="line-added">246     public long getMetataPosition() {</span>
<span class="line-added">247         return metadataPosition;</span>
<span class="line-added">248     }</span>
249     public long getStartTicks() {
250         return chunkStartTicks;
251     }
<span class="line-added">252     public long getChunkSize() {</span>
<span class="line-added">253         return chunkSize;</span>
<span class="line-added">254     }</span>
255 
256     public double getTicksPerSecond() {
257         return ticksPerSecond;
258     }
259 
260     public long getStartNanos() {
261         return chunkStartNanos;
262     }
263 
264     public long getEnd() {
265         return absoluteChunkEnd;
266     }
267 
268     public long getSize() {
269         return chunkSize;
270     }
271 
272     public long getDurationNanos() {
273         return durationNanos;
274     }
275 
276     public RecordingInput getInput() {
277         return input;
278     }
279 
<span class="line-modified">280     private static void verifyMagic(RecordingInput input) throws IOException {</span>
281         for (byte c : FILE_MAGIC) {
282             if (input.readByte() != c) {
283                 throw new IOException(&quot;Not a Flight Recorder file&quot;);
284             }
285         }
286     }
287 
288     public long getEventStart() {
289         return absoluteEventStart;
290     }
291 
<span class="line-added">292     static long headerSize() {</span>
<span class="line-added">293         return HEADER_SIZE;</span>
<span class="line-added">294     }</span>
<span class="line-added">295 </span>
<span class="line-added">296     public long getLastNanos() {</span>
<span class="line-added">297         return getStartNanos() + getDurationNanos();</span>
<span class="line-added">298     }</span>
299 }
</pre>
</td>
</tr>
</table>
<center><a href="../WriteableUserPath.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RecordingInput.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
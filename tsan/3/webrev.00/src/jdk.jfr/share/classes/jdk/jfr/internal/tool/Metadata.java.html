<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Metadata.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.tool;
 27 
 28 import java.io.IOException;
 29 import java.io.PrintWriter;
 30 import java.nio.file.Path;
 31 import java.util.Collections;
 32 import java.util.Comparator;
 33 import java.util.Deque;
 34 import java.util.List;
 35 
 36 import jdk.jfr.consumer.RecordingFile;
 37 import jdk.jfr.internal.Type;
 38 import jdk.jfr.internal.consumer.JdkJfrConsumer;
 39 
 40 final class Metadata extends Command {
 41 
 42     private final static JdkJfrConsumer PRIVATE_ACCESS = JdkJfrConsumer.instance();
 43 
 44     private static class TypeComparator implements Comparator&lt;Type&gt; {
 45 
 46         @Override
 47         public int compare(Type t1, Type t2) {
 48             int g1 = groupValue(t1);
 49             int g2 = groupValue(t2);
 50             if (g1 == g2) {
 51                 String n1 = t1.getName();
 52                 String n2 = t2.getName();
 53                 String package1 = n1.substring(0, n1.lastIndexOf(&#39;.&#39;) + 1);
 54                 String package2 = n2.substring(0, n2.lastIndexOf(&#39;.&#39;) + 1);
 55 
 56                 if (package1.equals(package2)) {
 57                     return n1.compareTo(n2);
 58                 } else {
 59                     // Ensure that jdk.* are printed first
 60                     // This makes it easier to find user defined events at the end.
 61                     if (Type.SUPER_TYPE_EVENT.equals(t1.getSuperType()) &amp;&amp; !package1.equals(package2)) {
 62                         if (package1.equals(&quot;jdk.jfr&quot;)) {
 63                             return -1;
 64                         }
 65                         if (package2.equals(&quot;jdk.jfr&quot;)) {
 66                             return 1;
 67                         }
 68                     }
 69                     return package1.compareTo(package2);
 70                 }
 71             } else {
 72                 return Integer.compare(groupValue(t1), groupValue(t2));
 73             }
 74         }
 75 
 76         int groupValue(Type t) {
 77             String superType = t.getSuperType();
 78             if (superType == null) {
 79                 return 1;
 80             }
 81             if (Type.SUPER_TYPE_ANNOTATION.equals(superType)) {
 82                 return 3;
 83             }
 84             if (Type.SUPER_TYPE_SETTING.equals(superType)) {
 85                 return 4;
 86             }
 87             if (Type.SUPER_TYPE_EVENT.equals(superType)) {
 88                 return 5;
 89             }
 90             return 2; // reserved for enums in the future
 91         }
 92     }
 93 
 94 
 95     @Override
 96     public String getName() {
 97         return &quot;metadata&quot;;
 98     }
 99 
100     @Override
101     public List&lt;String&gt; getOptionSyntax() {
102         return Collections.singletonList(&quot;&lt;file&gt;&quot;);
103     }
104 
105     @Override
106     public String getDescription() {
107         return &quot;Display event metadata, such as labels, descriptions and field layout&quot;;
108     }
109 
110     @Override
111     public void execute(Deque&lt;String&gt; options) throws UserSyntaxException, UserDataException {
112         Path file = getJFRInputFile(options);
113 
114         boolean showIds = false;
115         int optionCount = options.size();
116         while (optionCount &gt; 0) {
117             if (acceptOption(options, &quot;--ids&quot;)) {
118                 showIds = true;
119             }
120             if (optionCount == options.size()) {
121                 // No progress made
122                 throw new UserSyntaxException(&quot;unknown option &quot; + options.peek());
123             }
124             optionCount = options.size();
125         }
126 
127         try (PrintWriter pw = new PrintWriter(System.out)) {
128             PrettyWriter prettyWriter = new PrettyWriter(pw);
129             prettyWriter.setShowIds(showIds);
130             try (RecordingFile rf = new RecordingFile(file)) {
131                 List&lt;Type&gt; types = PRIVATE_ACCESS.readTypes(rf);
132                 Collections.sort(types, new TypeComparator());
133                 for (Type type : types) {
134                     prettyWriter.printType(type);
135                 }
136                 prettyWriter.flush(true);
137             } catch (IOException ioe) {
138                 couldNotReadError(file, ioe);
139             }
140         }
141     }
142 }
    </pre>
  </body>
</html>
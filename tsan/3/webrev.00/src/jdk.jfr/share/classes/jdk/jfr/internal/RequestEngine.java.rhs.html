<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jfr/share/classes/jdk/jfr/internal/RequestEngine.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal;
 27 
 28 import java.security.AccessControlContext;
 29 import java.security.AccessController;
 30 import java.security.PrivilegedAction;
 31 import java.util.ArrayList;
 32 import java.util.Collection;
<a name="2" id="anc2"></a><span class="line-added"> 33 import java.util.Iterator;</span>
 34 import java.util.List;
 35 import java.util.Objects;
 36 import java.util.concurrent.CopyOnWriteArrayList;
 37 import java.util.function.Predicate;
 38 import jdk.jfr.Event;
 39 import jdk.jfr.EventType;
 40 
 41 public final class RequestEngine {
 42 
 43     private final static JVM jvm = JVM.getJVM();
 44 
 45     final static class RequestHook {
 46         private final Runnable hook;
 47         private final PlatformEventType type;
 48         private final AccessControlContext accessControllerContext;
 49         private long delta;
 50 
 51         // Java events
 52         private RequestHook(AccessControlContext acc, PlatformEventType eventType, Runnable hook) {
 53             this.hook = hook;
 54             this.type = eventType;
 55             this.accessControllerContext = acc;
 56         }
 57 
 58         // native events
 59         RequestHook(PlatformEventType eventType) {
 60             this(null, eventType, null);
 61         }
 62 
 63         private void execute() {
 64             try {
 65                 if (accessControllerContext == null) { // native
 66                     if (type.isJDK()) {
 67                         hook.run();
 68                     } else {
 69                         jvm.emitEvent(type.getId(), JVM.counterTime(), 0);
 70                     }
 71                     Logger.log(LogTag.JFR_SYSTEM_EVENT, LogLevel.DEBUG, ()-&gt; &quot;Executed periodic hook for &quot; + type.getLogName());
 72                 } else {
 73                     executeSecure();
 74                 }
 75             } catch (Throwable e) {
 76                 // Prevent malicious user to propagate exception callback in the wrong context
 77                 Logger.log(LogTag.JFR_SYSTEM_EVENT, LogLevel.WARN, &quot;Exception occured during execution of period hook for &quot; + type.getLogName());
 78             }
 79         }
 80 
 81         private void executeSecure() {
 82             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 83                 @Override
 84                 public Void run() {
 85                     try {
 86                         hook.run();
 87                         Logger.log(LogTag.JFR_EVENT, LogLevel.DEBUG, ()-&gt; &quot;Executed periodic hook for &quot; + type.getLogName());
 88                     } catch (Throwable t) {
 89                         // Prevent malicious user to propagate exception callback in the wrong context
 90                         Logger.log(LogTag.JFR_EVENT, LogLevel.WARN, &quot;Exception occured during execution of period hook for &quot; + type.getLogName());
 91                     }
 92                     return null;
 93                 }
 94             }, accessControllerContext);
 95         }
 96     }
 97 
 98     private final static List&lt;RequestHook&gt; entries = new CopyOnWriteArrayList&lt;&gt;();
 99     private static long lastTimeMillis;
<a name="3" id="anc3"></a><span class="line-added">100     private static long flushInterval = Long.MAX_VALUE;</span>
<span class="line-added">101     private static long streamDelta;</span>
102 
103     public static void addHook(AccessControlContext acc, PlatformEventType type, Runnable hook) {
104         Objects.requireNonNull(acc);
105         addHookInternal(acc, type, hook);
106     }
107 
108     private static void addHookInternal(AccessControlContext acc, PlatformEventType type, Runnable hook) {
109         RequestHook he = new RequestHook(acc, type, hook);
110         for (RequestHook e : entries) {
111             if (e.hook == hook) {
112                 throw new IllegalArgumentException(&quot;Hook has already been added&quot;);
113             }
114         }
115         he.type.setEventHook(true);
116         // Insertion takes O(2*n), could be O(1) with HashMap, but
117         // thinking is that CopyOnWriteArrayList is faster
118         // to iterate over, which will happen more over time.
119         entries.add(he);
120         logHook(&quot;Added&quot;, type);
121     }
122 
123     public static void addTrustedJDKHook(Class&lt;? extends Event&gt; eventClass, Runnable runnable) {
124         if (eventClass.getClassLoader() != null) {
125             throw new SecurityException(&quot;Hook can only be registered for event classes that are loaded by the bootstrap class loader&quot;);
126         }
127         if (runnable.getClass().getClassLoader() != null) {
128             throw new SecurityException(&quot;Runnable hook class must be loaded by the bootstrap class loader&quot;);
129         }
130         EventType eType = MetadataRepository.getInstance().getEventType(eventClass);
131         PlatformEventType pType = PrivateAccess.getInstance().getPlatformEventType(eType);
132         addHookInternal(null, pType, runnable);
133     }
134 
135     private static void logHook(String action, PlatformEventType type) {
136         if (type.isJDK() || type.isJVM()) {
137             Logger.log(LogTag.JFR_SYSTEM_EVENT, LogLevel.INFO, action + &quot; periodic hook for &quot; + type.getLogName());
138         } else {
139             Logger.log(LogTag.JFR_EVENT, LogLevel.INFO, action + &quot; periodic hook for &quot; + type.getLogName());
140         }
141     }
142 
143     // Takes O(2*n), see addHook.
144     public static boolean removeHook(Runnable hook) {
145         for (RequestHook rh : entries) {
146             if (rh.hook == hook) {
147                 entries.remove(rh);
148                 rh.type.setEventHook(false);
149                 logHook(&quot;Removed&quot;, rh.type);
150                 return true;
151             }
152         }
153         return false;
154     }
155 
156     // Only to be used for JVM events. No access control contest
157     // or check if hook already exists
158     static void addHooks(List&lt;RequestHook&gt; newEntries) {
159         List&lt;RequestHook&gt; addEntries = new ArrayList&lt;&gt;();
160         for (RequestHook rh : newEntries) {
161             rh.type.setEventHook(true);
162             addEntries.add(rh);
163             logHook(&quot;Added&quot;, rh.type);
164         }
165         entries.addAll(newEntries);
166     }
167 
168     static void doChunkEnd() {
169         doChunk(x -&gt; x.isEndChunk());
170     }
171 
172     static void doChunkBegin() {
173         doChunk(x -&gt; x.isBeginChunk());
174     }
175 
176     private static void doChunk(Predicate&lt;PlatformEventType&gt; predicate) {
177         for (RequestHook requestHook : entries) {
178             PlatformEventType s = requestHook.type;
179             if (s.isEnabled() &amp;&amp; predicate.test(s)) {
180                 requestHook.execute();
181             }
182         }
183     }
184 
185     static long doPeriodic() {
186         return run_requests(entries);
187     }
188 
189     // code copied from native impl.
190     private static long run_requests(Collection&lt;RequestHook&gt; entries) {
191         long last = lastTimeMillis;
192         // Bug 9000556 - current time millis has rather lame resolution
193         // The use of os::elapsed_counter() is deliberate here, we don&#39;t
194         // want it exchanged for os::ft_elapsed_counter().
195         // Keeping direct call os::elapsed_counter() here for reliable
196         // real time values in order to decide when registered requestable
197         // events are due.
198         long now = System.currentTimeMillis();
199         long min = 0;
200         long delta = 0;
201 
202         if (last == 0) {
203             last = now;
204         }
205 
206         // time from then to now
207         delta = now - last;
208 
209         if (delta &lt; 0) {
210             // to handle time adjustments
211             // for example Daylight Savings
212             lastTimeMillis = now;
213             return 0;
214         }
<a name="4" id="anc4"></a><span class="line-modified">215         Iterator&lt;RequestHook&gt; hookIterator = entries.iterator();</span>
<span class="line-added">216         while(hookIterator.hasNext()) {</span>
<span class="line-added">217             RequestHook he = hookIterator.next();</span>
218             long left = 0;
219             PlatformEventType es = he.type;
220             // Not enabled, skip.
221             if (!es.isEnabled() || es.isEveryChunk()) {
222                 continue;
223             }
224             long r_period = es.getPeriod();
225             long r_delta = he.delta;
226 
227             // add time elapsed.
228             r_delta += delta;
229 
230             // above threshold?
231             if (r_delta &gt;= r_period) {
232                 // Bug 9000556 - don&#39;t try to compensate
233                 // for wait &gt; period
234                 r_delta = 0;
235                 he.execute();
<a name="5" id="anc5"></a>
236             }
237 
238             // calculate time left
239             left = (r_period - r_delta);
240 
241             /**
242              * nothing outside checks that a period is &gt;= 0, so left can end up
243              * negative here. ex. (r_period =(-1)) - (r_delta = 0) if it is,
244              * handle it.
245              */
246             if (left &lt; 0) {
247                 left = 0;
248             }
249 
250             // assign delta back
251             he.delta = r_delta;
252 
253             if (min == 0 || left &lt; min) {
254                 min = left;
255             }
256         }
<a name="6" id="anc6"></a><span class="line-added">257         // Flush should happen after all periodic events has been emitted</span>
<span class="line-added">258         // Repeat of the above algorithm, but using the stream interval.</span>
<span class="line-added">259         if (flushInterval != Long.MAX_VALUE) {</span>
<span class="line-added">260             long r_period = flushInterval;</span>
<span class="line-added">261             long r_delta = streamDelta;</span>
<span class="line-added">262             r_delta += delta;</span>
<span class="line-added">263             if (r_delta &gt;= r_period) {</span>
<span class="line-added">264                 r_delta = 0;</span>
<span class="line-added">265                 MetadataRepository.getInstance().flush();</span>
<span class="line-added">266                 Utils.notifyFlush();</span>
<span class="line-added">267             }</span>
<span class="line-added">268             long left = (r_period - r_delta);</span>
<span class="line-added">269             if (left &lt; 0) {</span>
<span class="line-added">270                 left = 0;</span>
<span class="line-added">271             }</span>
<span class="line-added">272             streamDelta = r_delta;</span>
<span class="line-added">273             if (min == 0 || left &lt; min) {</span>
<span class="line-added">274                 min = left;</span>
<span class="line-added">275             }</span>
<span class="line-added">276         }</span>
<span class="line-added">277 </span>
278         lastTimeMillis = now;
279         return min;
280     }
<a name="7" id="anc7"></a><span class="line-added">281 </span>
<span class="line-added">282     static void setFlushInterval(long millis) {</span>
<span class="line-added">283         // Don&#39;t accept shorter interval than 1 s.</span>
<span class="line-added">284         long interval = millis &lt; 1000 ? 1000  : millis;</span>
<span class="line-added">285         flushInterval = interval;</span>
<span class="line-added">286         if (interval &lt; flushInterval) {</span>
<span class="line-added">287             synchronized (JVM.FILE_DELTA_CHANGE) {</span>
<span class="line-added">288                 JVM.FILE_DELTA_CHANGE.notifyAll();</span>
<span class="line-added">289             }</span>
<span class="line-added">290         }</span>
<span class="line-added">291     }</span>
292 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
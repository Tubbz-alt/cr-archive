<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jfr/share/classes/jdk/jfr/internal/tool/Summary.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.tool;
 27 
 28 import java.io.IOException;
 29 import java.io.PrintStream;
 30 import java.nio.file.Path;
 31 import java.time.Instant;
 32 import java.time.ZoneOffset;
 33 import java.time.format.DateTimeFormatter;
 34 import java.util.ArrayList;
 35 import java.util.Collections;
 36 import java.util.Deque;
 37 import java.util.HashMap;
 38 import java.util.List;
 39 import java.util.Locale;
 40 
 41 import jdk.jfr.EventType;
 42 import jdk.jfr.internal.MetadataDescriptor;
 43 import jdk.jfr.internal.Type;
 44 import jdk.jfr.internal.consumer.ChunkHeader;
 45 import jdk.jfr.internal.consumer.RecordingInput;
 46 
 47 final class Summary extends Command {
 48     private final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;).withLocale(Locale.UK).withZone(ZoneOffset.UTC);
 49 
 50     @Override
 51     public String getName() {
 52         return &quot;summary&quot;;
 53     }
 54 
 55     private static class Statistics {
 56         Statistics(String name) {
 57             this.name = name;
 58         }
 59         String name;
 60         long count;
 61         long size;
 62     }
 63 
 64     @Override
 65     public List&lt;String&gt; getOptionSyntax() {
 66         return Collections.singletonList(&quot;&lt;file&gt;&quot;);
 67     }
 68 
 69     @Override
 70     public void displayOptionUsage(PrintStream stream) {
 71         stream.println(&quot;  &lt;file&gt;   Location of the recording file (.jfr) to display information about&quot;);
 72     }
 73 
 74     @Override
 75     public String getDescription() {
 76         return &quot;Display general information about a recording file (.jfr)&quot;;
 77     }
 78 
 79     @Override
 80     public void execute(Deque&lt;String&gt; options) throws UserSyntaxException, UserDataException {
 81         ensureMaxArgumentCount(options, 1);
 82         Path p = getJFRInputFile(options);
 83         try {
 84             printInformation(p);
 85         } catch (IOException e) {
 86             couldNotReadError(p, e);
 87         }
 88     }
 89 
 90     private void printInformation(Path p) throws IOException {
 91         long totalDuration = 0;
 92         long chunks = 0;
 93 
 94         try (RecordingInput input = new RecordingInput(p.toFile())) {
 95             ChunkHeader first = new ChunkHeader(input);
 96             ChunkHeader ch = first;
 97             String eventPrefix = Type.EVENT_NAME_PREFIX;
 98             if (first.getMajor() == 1) {
 99                 eventPrefix = &quot;com.oracle.jdk.&quot;;
100             }
101             HashMap&lt;Long, Statistics&gt; stats = new HashMap&lt;&gt;();
102             stats.put(0L, new Statistics(eventPrefix + &quot;Metadata&quot;));
103             stats.put(1L, new Statistics(eventPrefix + &quot;CheckPoint&quot;));
104             int minWidth = 0;
105             while (true) {
106                 long chunkEnd = ch.getEnd();
107                 MetadataDescriptor md = ch.readMetadata();
108 
109                 for (EventType eventType : md.getEventTypes()) {
110                     stats.computeIfAbsent(eventType.getId(), (e) -&gt; new Statistics(eventType.getName()));
111                     minWidth = Math.max(minWidth, eventType.getName().length());
112                 }
113 
114                 totalDuration += ch.getDurationNanos();
115                 chunks++;
116                 input.position(ch.getEventStart());
117                 while (input.position() &lt; chunkEnd) {
118                     long pos = input.position();
119                     int size = input.readInt();
120                     long eventTypeId = input.readLong();
121                     Statistics s = stats.get(eventTypeId);
122                     if (s != null) {
123                         s.count++;
124                         s.size += size;
125                     }
126                     input.position(pos + size);
127                 }
128                 if (ch.isLastChunk()) {
129                     break;
130                 }
131                 ch = ch.nextHeader();
132             }
133             println();
134             long epochSeconds = first.getStartNanos() / 1_000_000_000L;
135             long adjustNanos = first.getStartNanos() - epochSeconds * 1_000_000_000L;
136             println(&quot; Version: &quot; + first.getMajor() + &quot;.&quot; + first.getMinor());
137             println(&quot; Chunks: &quot; + chunks);
138             println(&quot; Start: &quot; + DATE_FORMAT.format(Instant.ofEpochSecond(epochSeconds, adjustNanos)) + &quot; (UTC)&quot;);
139             println(&quot; Duration: &quot; + (totalDuration + 500_000_000) / 1_000_000_000 + &quot; s&quot;);
140 
141             List&lt;Statistics&gt; statsList = new ArrayList&lt;&gt;(stats.values());
142             Collections.sort(statsList, (u, v) -&gt; Long.compare(v.count, u.count));
143             println();
144             String header = &quot;      Count  Size (bytes) &quot;;
145             String typeHeader = &quot; Event Type&quot;;
146             minWidth = Math.max(minWidth, typeHeader.length());
147             println(typeHeader + pad(minWidth - typeHeader.length(), &#39; &#39;) + header);
148             println(pad(minWidth + header.length(), &#39;=&#39;));
149             for (Statistics s : statsList) {
150                 System.out.printf(&quot; %-&quot; + minWidth + &quot;s%10d  %12d\n&quot;, s.name, s.count, s.size);
151             }
152         }
153     }
154 
155     private String pad(int count, char c) {
156         StringBuilder sb = new StringBuilder();
157         for (int i = 0; i &lt; count; i++) {
158             sb.append(c);
159         }
160         return sb.toString();
161     }
162 }
    </pre>
  </body>
</html>
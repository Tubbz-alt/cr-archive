<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RecordingInput.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ChunkHeader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../dcmd/DCmdConfigure.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jfr/share/classes/jdk/jfr/internal/consumer/RecordingInput.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.DataInput;
 29 import java.io.EOFException;
 30 import java.io.File;
 31 import java.io.IOException;
 32 import java.io.RandomAccessFile;
<span class="line-modified"> 33 import java.nio.charset.Charset;</span>
 34 
 35 public final class RecordingInput implements DataInput, AutoCloseable {
 36 
<span class="line-modified"> 37     public static final byte STRING_ENCODING_NULL = 0;</span>
<span class="line-removed"> 38     public static final byte STRING_ENCODING_EMPTY_STRING = 1;</span>
<span class="line-removed"> 39     public static final byte STRING_ENCODING_CONSTANT_POOL = 2;</span>
<span class="line-removed"> 40     public static final byte STRING_ENCODING_UTF8_BYTE_ARRAY = 3;</span>
<span class="line-removed"> 41     public static final byte STRING_ENCODING_CHAR_ARRAY = 4;</span>
<span class="line-removed"> 42     public static final byte STRING_ENCODING_LATIN1_BYTE_ARRAY = 5;</span>
<span class="line-removed"> 43 </span>
<span class="line-removed"> 44     private final static int DEFAULT_BLOCK_SIZE = 16 * 1024 * 1024;</span>
<span class="line-removed"> 45     private final static Charset UTF8 = Charset.forName(&quot;UTF-8&quot;);</span>
<span class="line-removed"> 46     private final static Charset LATIN1 = Charset.forName(&quot;ISO-8859-1&quot;);</span>
 47 
 48     private static final class Block {
 49         private byte[] bytes = new byte[0];
 50         private long blockPosition;

 51 
 52         boolean contains(long position) {
<span class="line-modified"> 53             return position &gt;= blockPosition &amp;&amp; position &lt; blockPosition + bytes.length;</span>
 54         }
 55 
 56         public void read(RandomAccessFile file, int amount) throws IOException {
 57             blockPosition = file.getFilePointer();
 58             // reuse byte array, if possible
<span class="line-modified"> 59             if (amount != bytes.length) {</span>
 60                 bytes = new byte[amount];
 61             }
<span class="line-modified"> 62             file.readFully(bytes);</span>

 63         }
 64 
 65         public byte get(long position) {
 66             return bytes[(int) (position - blockPosition)];
 67         }
<span class="line-removed"> 68     }</span>
 69 
<span class="line-modified"> 70     private final RandomAccessFile file;</span>
<span class="line-modified"> 71     private final long size;</span>







 72     private Block currentBlock = new Block();
 73     private Block previousBlock = new Block();
 74     private long position;
<span class="line-modified"> 75     private final int blockSize;</span>

 76 
<span class="line-modified"> 77     private RecordingInput(File f, int blockSize) throws IOException {</span>
<span class="line-removed"> 78         this.size = f.length();</span>
 79         this.blockSize = blockSize;
<span class="line-modified"> 80         this.file = new RandomAccessFile(f, &quot;r&quot;);</span>
<span class="line-modified"> 81         if (size &lt; 8) {</span>
<span class="line-modified"> 82             throw new IOException(&quot;Not a valid Flight Recorder file. File length is only &quot; + size + &quot; bytes.&quot;);</span>










 83         }
 84     }
 85 
<span class="line-modified"> 86     public RecordingInput(File f) throws IOException {</span>
<span class="line-modified"> 87         this(f, DEFAULT_BLOCK_SIZE);</span>












 88     }
 89 
 90     @Override
 91     public final byte readByte() throws IOException {
 92         if (!currentBlock.contains(position)) {
 93             position(position);
 94         }
 95         return currentBlock.get(position++);
 96     }
 97 
 98     @Override
 99     public final void readFully(byte[] dest, int offset, int length) throws IOException {
100         // TODO: Optimize, use Arrays.copy if all bytes are in current block
101         // array
102         for (int i = 0; i &lt; length; i++) {
103             dest[i + offset] = readByte();
104         }
105     }
106 
107     @Override
108     public final void readFully(byte[] dst) throws IOException {
109         readFully(dst, 0, dst.length);
110     }
111 
<span class="line-modified">112     public final short readRawShort() throws IOException {</span>
113         // copied from java.io.Bits
114         byte b0 = readByte();
115         byte b1 = readByte();
116         return (short) ((b1 &amp; 0xFF) + (b0 &lt;&lt; 8));
117     }
118 
119     @Override
<span class="line-modified">120     public final double readDouble() throws IOException {</span>
121         // copied from java.io.Bits
122         return Double.longBitsToDouble(readRawLong());
123     }
124 
125     @Override
<span class="line-modified">126     public final float readFloat() throws IOException {</span>
127         // copied from java.io.Bits
128         return Float.intBitsToFloat(readRawInt());
129     }
130 
<span class="line-modified">131     public final int readRawInt() throws IOException {</span>
132         // copied from java.io.Bits
133         byte b0 = readByte();
134         byte b1 = readByte();
135         byte b2 = readByte();
136         byte b3 = readByte();
137         return ((b3 &amp; 0xFF)) + ((b2 &amp; 0xFF) &lt;&lt; 8) + ((b1 &amp; 0xFF) &lt;&lt; 16) + ((b0) &lt;&lt; 24);
138     }
139 
<span class="line-modified">140     public final long readRawLong() throws IOException {</span>
141         // copied from java.io.Bits
142         byte b0 = readByte();
143         byte b1 = readByte();
144         byte b2 = readByte();
145         byte b3 = readByte();
146         byte b4 = readByte();
147         byte b5 = readByte();
148         byte b6 = readByte();
149         byte b7 = readByte();
150         return ((b7 &amp; 0xFFL)) + ((b6 &amp; 0xFFL) &lt;&lt; 8) + ((b5 &amp; 0xFFL) &lt;&lt; 16) + ((b4 &amp; 0xFFL) &lt;&lt; 24) + ((b3 &amp; 0xFFL) &lt;&lt; 32) + ((b2 &amp; 0xFFL) &lt;&lt; 40) + ((b1 &amp; 0xFFL) &lt;&lt; 48) + (((long) b0) &lt;&lt; 56);
151     }
152 
<span class="line-modified">153     public final long position() throws IOException {</span>
154         return position;
155     }
156 
157     public final void position(long newPosition) throws IOException {
158         if (!currentBlock.contains(newPosition)) {
159             if (!previousBlock.contains(newPosition)) {
<span class="line-modified">160                 if (newPosition &gt; size()) {</span>
<span class="line-modified">161                     throw new EOFException(&quot;Trying to read at &quot; + newPosition + &quot;, but file is only &quot; + size() + &quot; bytes.&quot;);</span>
162                 }
163                 long blockStart = trimToFileSize(calculateBlockStart(newPosition));
164                 file.seek(blockStart);
165                 // trim amount to file size
<span class="line-modified">166                 long amount = Math.min(size() - blockStart, blockSize);</span>
167                 previousBlock.read(file, (int) amount);
168             }
169             // swap previous and current
170             Block tmp = currentBlock;
171             currentBlock = previousBlock;
172             previousBlock = tmp;
173         }
174         position = newPosition;
175     }
176 
177     private final long trimToFileSize(long position) throws IOException {
178         return Math.min(size(), Math.max(0, position));
179     }
180 
181     private final long calculateBlockStart(long newPosition) {
182         // align to end of current block
183         if (currentBlock.contains(newPosition - blockSize)) {
184             return currentBlock.blockPosition + currentBlock.bytes.length;
185         }
186         // align before current block
187         if (currentBlock.contains(newPosition + blockSize)) {
188             return currentBlock.blockPosition - blockSize;
189         }
190         // not near current block, pick middle
191         return newPosition - blockSize / 2;
192     }
193 
<span class="line-modified">194     public final long size() throws IOException {</span>
195         return size;
196     }
197 
<span class="line-modified">198     public final void close() throws IOException {</span>

199         file.close();
200     }
201 
202     @Override
203     public final int skipBytes(int n) throws IOException {
204         long position = position();
205         position(position + n);
206         return (int) (position() - position);
207     }
208 
209     @Override
210     public final boolean readBoolean() throws IOException {
211         return readByte() != 0;
212     }
213 
214     @Override
215     public int readUnsignedByte() throws IOException {
216         return readByte() &amp; 0x00FF;
217     }
218 
</pre>
<hr />
<pre>
228 
229     // NOTE, this method should really be called readString
230     // but can&#39;t be renamed without making RecordingInput a
231     // public class.
232     //
233     // This method DOES Not read as expected (s2 + utf8 encoded character)
234     // instead it read:
235     // byte encoding
236     // int size
237     // data (byte or char)
238     //
239     // where encoding
240     //
241     // 0, means null
242     // 1, means UTF8 encoded byte array
243     // 2, means char array
244     // 3, means latin-1 (ISO-8859-1) encoded byte array
245     // 4, means &quot;&quot;
246     @Override
247     public String readUTF() throws IOException {
<span class="line-modified">248         return readEncodedString(readByte());</span>
<span class="line-removed">249     }</span>
<span class="line-removed">250 </span>
<span class="line-removed">251     public String readEncodedString(byte encoding) throws IOException {</span>
<span class="line-removed">252         if (encoding == STRING_ENCODING_NULL) {</span>
<span class="line-removed">253             return null;</span>
<span class="line-removed">254         }</span>
<span class="line-removed">255         if (encoding == STRING_ENCODING_EMPTY_STRING) {</span>
<span class="line-removed">256             return &quot;&quot;;</span>
<span class="line-removed">257         }</span>
<span class="line-removed">258         int size = readInt();</span>
<span class="line-removed">259         if (encoding == STRING_ENCODING_CHAR_ARRAY) {</span>
<span class="line-removed">260             char[] c = new char[size];</span>
<span class="line-removed">261             for (int i = 0; i &lt; size; i++) {</span>
<span class="line-removed">262                 c[i] = readChar();</span>
<span class="line-removed">263             }</span>
<span class="line-removed">264             return new String(c);</span>
<span class="line-removed">265         }</span>
<span class="line-removed">266         byte[] bytes = new byte[size];</span>
<span class="line-removed">267         readFully(bytes); // TODO: optimize, check size, and copy only if needed</span>
<span class="line-removed">268         if (encoding == STRING_ENCODING_UTF8_BYTE_ARRAY) {</span>
<span class="line-removed">269             return new String(bytes, UTF8);</span>
<span class="line-removed">270         }</span>
<span class="line-removed">271 </span>
<span class="line-removed">272         if (encoding == STRING_ENCODING_LATIN1_BYTE_ARRAY) {</span>
<span class="line-removed">273             return new String(bytes, LATIN1);</span>
<span class="line-removed">274         }</span>
<span class="line-removed">275         throw new IOException(&quot;Unknown string encoding &quot; + encoding);</span>
276     }
277 
278     @Override
279     public char readChar() throws IOException {
280         return (char) readLong();
281     }
282 
283     @Override
284     public short readShort() throws IOException {
285         return (short) readLong();
286     }
287 
288     @Override
289     public int readInt() throws IOException {
290         return (int) readLong();
291     }
292 
293     @Override
294     public long readLong() throws IOException {
<span class="line-modified">295         // can be optimized by branching checks, but will do for now</span>




























































296         byte b0 = readByte();
297         long ret = (b0 &amp; 0x7FL);
298         if (b0 &gt;= 0) {
299             return ret;
300         }

301         int b1 = readByte();
302         ret += (b1 &amp; 0x7FL) &lt;&lt; 7;
303         if (b1 &gt;= 0) {
304             return ret;
305         }

306         int b2 = readByte();
307         ret += (b2 &amp; 0x7FL) &lt;&lt; 14;
308         if (b2 &gt;= 0) {
309             return ret;
310         }

311         int b3 = readByte();
312         ret += (b3 &amp; 0x7FL) &lt;&lt; 21;
313         if (b3 &gt;= 0) {
314             return ret;
315         }

316         int b4 = readByte();
317         ret += (b4 &amp; 0x7FL) &lt;&lt; 28;
318         if (b4 &gt;= 0) {
319             return ret;
320         }

321         int b5 = readByte();
322         ret += (b5 &amp; 0x7FL) &lt;&lt; 35;
323         if (b5 &gt;= 0) {
324             return ret;
325         }

326         int b6 = readByte();
327         ret += (b6 &amp; 0x7FL) &lt;&lt; 42;
328         if (b6 &gt;= 0) {
329             return ret;
330         }

331         int b7 = readByte();
332         ret += (b7 &amp; 0x7FL) &lt;&lt; 49;
333         if (b7 &gt;= 0) {
334             return ret;

335         }

336         int b8 = readByte(); // read last byte raw
337         return ret + (((long) (b8 &amp; 0XFF)) &lt;&lt; 56);
338     }



































339 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jfr.internal.consumer;
 27 
 28 import java.io.DataInput;
 29 import java.io.EOFException;
 30 import java.io.File;
 31 import java.io.IOException;
 32 import java.io.RandomAccessFile;
<span class="line-modified"> 33 import java.nio.file.Path;</span>
 34 
 35 public final class RecordingInput implements DataInput, AutoCloseable {
 36 
<span class="line-modified"> 37     private final static int DEFAULT_BLOCK_SIZE = 64_000;</span>









 38 
 39     private static final class Block {
 40         private byte[] bytes = new byte[0];
 41         private long blockPosition;
<span class="line-added"> 42         private long blockPositionEnd;</span>
 43 
 44         boolean contains(long position) {
<span class="line-modified"> 45             return position &gt;= blockPosition &amp;&amp; position &lt; blockPositionEnd;</span>
 46         }
 47 
 48         public void read(RandomAccessFile file, int amount) throws IOException {
 49             blockPosition = file.getFilePointer();
 50             // reuse byte array, if possible
<span class="line-modified"> 51             if (amount &gt; bytes.length) {</span>
 52                 bytes = new byte[amount];
 53             }
<span class="line-modified"> 54             this.blockPositionEnd = blockPosition + amount;</span>
<span class="line-added"> 55             file.readFully(bytes, 0, amount);</span>
 56         }
 57 
 58         public byte get(long position) {
 59             return bytes[(int) (position - blockPosition)];
 60         }

 61 
<span class="line-modified"> 62         public void reset() {</span>
<span class="line-modified"> 63             blockPosition = 0;</span>
<span class="line-added"> 64             blockPositionEnd = 0;</span>
<span class="line-added"> 65         }</span>
<span class="line-added"> 66     }</span>
<span class="line-added"> 67     private final int blockSize;</span>
<span class="line-added"> 68     private final FileAccess fileAccess;</span>
<span class="line-added"> 69     private RandomAccessFile file;</span>
<span class="line-added"> 70     private String filename;</span>
 71     private Block currentBlock = new Block();
 72     private Block previousBlock = new Block();
 73     private long position;
<span class="line-modified"> 74     private long size = -1; // Fail fast if setSize(...) has not been called</span>
<span class="line-added"> 75                             // before parsing</span>
 76 
<span class="line-modified"> 77     RecordingInput(File f, FileAccess fileAccess, int blockSize) throws IOException {</span>

 78         this.blockSize = blockSize;
<span class="line-modified"> 79         this.fileAccess = fileAccess;</span>
<span class="line-modified"> 80         initialize(f);</span>
<span class="line-modified"> 81     }</span>
<span class="line-added"> 82 </span>
<span class="line-added"> 83     private void initialize(File f) throws IOException {</span>
<span class="line-added"> 84         this.filename = fileAccess.getAbsolutePath(f);</span>
<span class="line-added"> 85         this.file = fileAccess.openRAF(f, &quot;r&quot;);</span>
<span class="line-added"> 86         this.position = 0;</span>
<span class="line-added"> 87         this.size = -1;</span>
<span class="line-added"> 88         this.currentBlock.reset();</span>
<span class="line-added"> 89         previousBlock.reset();</span>
<span class="line-added"> 90         if (fileAccess.length(f) &lt; 8) {</span>
<span class="line-added"> 91             throw new IOException(&quot;Not a valid Flight Recorder file. File length is only &quot; + fileAccess.length(f) + &quot; bytes.&quot;);</span>
 92         }
 93     }
 94 
<span class="line-modified"> 95     public RecordingInput(File f, FileAccess fileAccess) throws IOException {</span>
<span class="line-modified"> 96         this(f, fileAccess, DEFAULT_BLOCK_SIZE);</span>
<span class="line-added"> 97     }</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99     void positionPhysical(long position) throws IOException {</span>
<span class="line-added">100         file.seek(position);</span>
<span class="line-added">101     }</span>
<span class="line-added">102 </span>
<span class="line-added">103     byte readPhysicalByte() throws IOException {</span>
<span class="line-added">104         return file.readByte();</span>
<span class="line-added">105     }</span>
<span class="line-added">106 </span>
<span class="line-added">107     long readPhysicalLong() throws IOException {</span>
<span class="line-added">108         return file.readLong();</span>
109     }
110 
111     @Override
112     public final byte readByte() throws IOException {
113         if (!currentBlock.contains(position)) {
114             position(position);
115         }
116         return currentBlock.get(position++);
117     }
118 
119     @Override
120     public final void readFully(byte[] dest, int offset, int length) throws IOException {
121         // TODO: Optimize, use Arrays.copy if all bytes are in current block
122         // array
123         for (int i = 0; i &lt; length; i++) {
124             dest[i + offset] = readByte();
125         }
126     }
127 
128     @Override
129     public final void readFully(byte[] dst) throws IOException {
130         readFully(dst, 0, dst.length);
131     }
132 
<span class="line-modified">133     short readRawShort() throws IOException {</span>
134         // copied from java.io.Bits
135         byte b0 = readByte();
136         byte b1 = readByte();
137         return (short) ((b1 &amp; 0xFF) + (b0 &lt;&lt; 8));
138     }
139 
140     @Override
<span class="line-modified">141     public double readDouble() throws IOException {</span>
142         // copied from java.io.Bits
143         return Double.longBitsToDouble(readRawLong());
144     }
145 
146     @Override
<span class="line-modified">147     public float readFloat() throws IOException {</span>
148         // copied from java.io.Bits
149         return Float.intBitsToFloat(readRawInt());
150     }
151 
<span class="line-modified">152     int readRawInt() throws IOException {</span>
153         // copied from java.io.Bits
154         byte b0 = readByte();
155         byte b1 = readByte();
156         byte b2 = readByte();
157         byte b3 = readByte();
158         return ((b3 &amp; 0xFF)) + ((b2 &amp; 0xFF) &lt;&lt; 8) + ((b1 &amp; 0xFF) &lt;&lt; 16) + ((b0) &lt;&lt; 24);
159     }
160 
<span class="line-modified">161     long readRawLong() throws IOException {</span>
162         // copied from java.io.Bits
163         byte b0 = readByte();
164         byte b1 = readByte();
165         byte b2 = readByte();
166         byte b3 = readByte();
167         byte b4 = readByte();
168         byte b5 = readByte();
169         byte b6 = readByte();
170         byte b7 = readByte();
171         return ((b7 &amp; 0xFFL)) + ((b6 &amp; 0xFFL) &lt;&lt; 8) + ((b5 &amp; 0xFFL) &lt;&lt; 16) + ((b4 &amp; 0xFFL) &lt;&lt; 24) + ((b3 &amp; 0xFFL) &lt;&lt; 32) + ((b2 &amp; 0xFFL) &lt;&lt; 40) + ((b1 &amp; 0xFFL) &lt;&lt; 48) + (((long) b0) &lt;&lt; 56);
172     }
173 
<span class="line-modified">174     public final long position() {</span>
175         return position;
176     }
177 
178     public final void position(long newPosition) throws IOException {
179         if (!currentBlock.contains(newPosition)) {
180             if (!previousBlock.contains(newPosition)) {
<span class="line-modified">181                 if (newPosition &gt; size) {</span>
<span class="line-modified">182                     throw new EOFException(&quot;Trying to read at &quot; + newPosition + &quot;, but file is only &quot; + size + &quot; bytes.&quot;);</span>
183                 }
184                 long blockStart = trimToFileSize(calculateBlockStart(newPosition));
185                 file.seek(blockStart);
186                 // trim amount to file size
<span class="line-modified">187                 long amount = Math.min(size - blockStart, blockSize);</span>
188                 previousBlock.read(file, (int) amount);
189             }
190             // swap previous and current
191             Block tmp = currentBlock;
192             currentBlock = previousBlock;
193             previousBlock = tmp;
194         }
195         position = newPosition;
196     }
197 
198     private final long trimToFileSize(long position) throws IOException {
199         return Math.min(size(), Math.max(0, position));
200     }
201 
202     private final long calculateBlockStart(long newPosition) {
203         // align to end of current block
204         if (currentBlock.contains(newPosition - blockSize)) {
205             return currentBlock.blockPosition + currentBlock.bytes.length;
206         }
207         // align before current block
208         if (currentBlock.contains(newPosition + blockSize)) {
209             return currentBlock.blockPosition - blockSize;
210         }
211         // not near current block, pick middle
212         return newPosition - blockSize / 2;
213     }
214 
<span class="line-modified">215     long size() {</span>
216         return size;
217     }
218 
<span class="line-modified">219     @Override</span>
<span class="line-added">220     public void close() throws IOException {</span>
221         file.close();
222     }
223 
224     @Override
225     public final int skipBytes(int n) throws IOException {
226         long position = position();
227         position(position + n);
228         return (int) (position() - position);
229     }
230 
231     @Override
232     public final boolean readBoolean() throws IOException {
233         return readByte() != 0;
234     }
235 
236     @Override
237     public int readUnsignedByte() throws IOException {
238         return readByte() &amp; 0x00FF;
239     }
240 
</pre>
<hr />
<pre>
250 
251     // NOTE, this method should really be called readString
252     // but can&#39;t be renamed without making RecordingInput a
253     // public class.
254     //
255     // This method DOES Not read as expected (s2 + utf8 encoded character)
256     // instead it read:
257     // byte encoding
258     // int size
259     // data (byte or char)
260     //
261     // where encoding
262     //
263     // 0, means null
264     // 1, means UTF8 encoded byte array
265     // 2, means char array
266     // 3, means latin-1 (ISO-8859-1) encoded byte array
267     // 4, means &quot;&quot;
268     @Override
269     public String readUTF() throws IOException {
<span class="line-modified">270         throw new UnsupportedOperationException(&quot;Use StringParser&quot;);</span>



























271     }
272 
273     @Override
274     public char readChar() throws IOException {
275         return (char) readLong();
276     }
277 
278     @Override
279     public short readShort() throws IOException {
280         return (short) readLong();
281     }
282 
283     @Override
284     public int readInt() throws IOException {
285         return (int) readLong();
286     }
287 
288     @Override
289     public long readLong() throws IOException {
<span class="line-modified">290         final byte[] bytes = currentBlock.bytes;</span>
<span class="line-added">291         final int index = (int) (position - currentBlock.blockPosition);</span>
<span class="line-added">292 </span>
<span class="line-added">293         if (index + 8 &lt; bytes.length &amp;&amp; index &gt;= 0) {</span>
<span class="line-added">294             byte b0 = bytes[index];</span>
<span class="line-added">295             long ret = (b0 &amp; 0x7FL);</span>
<span class="line-added">296             if (b0 &gt;= 0) {</span>
<span class="line-added">297                 position += 1;</span>
<span class="line-added">298                 return ret;</span>
<span class="line-added">299             }</span>
<span class="line-added">300             int b1 = bytes[index + 1];</span>
<span class="line-added">301             ret += (b1 &amp; 0x7FL) &lt;&lt; 7;</span>
<span class="line-added">302             if (b1 &gt;= 0) {</span>
<span class="line-added">303                 position += 2;</span>
<span class="line-added">304                 return ret;</span>
<span class="line-added">305             }</span>
<span class="line-added">306             int b2 = bytes[index + 2];</span>
<span class="line-added">307             ret += (b2 &amp; 0x7FL) &lt;&lt; 14;</span>
<span class="line-added">308             if (b2 &gt;= 0) {</span>
<span class="line-added">309                 position += 3;</span>
<span class="line-added">310                 return ret;</span>
<span class="line-added">311             }</span>
<span class="line-added">312             int b3 = bytes[index + 3];</span>
<span class="line-added">313             ret += (b3 &amp; 0x7FL) &lt;&lt; 21;</span>
<span class="line-added">314             if (b3 &gt;= 0) {</span>
<span class="line-added">315                 position += 4;</span>
<span class="line-added">316                 return ret;</span>
<span class="line-added">317             }</span>
<span class="line-added">318             int b4 = bytes[index + 4];</span>
<span class="line-added">319             ret += (b4 &amp; 0x7FL) &lt;&lt; 28;</span>
<span class="line-added">320             if (b4 &gt;= 0) {</span>
<span class="line-added">321                 position += 5;</span>
<span class="line-added">322                 return ret;</span>
<span class="line-added">323             }</span>
<span class="line-added">324             int b5 = bytes[index + 5];</span>
<span class="line-added">325             ret += (b5 &amp; 0x7FL) &lt;&lt; 35;</span>
<span class="line-added">326             if (b5 &gt;= 0) {</span>
<span class="line-added">327                 position += 6;</span>
<span class="line-added">328                 return ret;</span>
<span class="line-added">329             }</span>
<span class="line-added">330             int b6 = bytes[index + 6];</span>
<span class="line-added">331             ret += (b6 &amp; 0x7FL) &lt;&lt; 42;</span>
<span class="line-added">332             if (b6 &gt;= 0) {</span>
<span class="line-added">333                 position += 7;</span>
<span class="line-added">334                 return ret;</span>
<span class="line-added">335             }</span>
<span class="line-added">336             int b7 = bytes[index + 7];</span>
<span class="line-added">337             ret += (b7 &amp; 0x7FL) &lt;&lt; 49;</span>
<span class="line-added">338             if (b7 &gt;= 0) {</span>
<span class="line-added">339                 position += 8;</span>
<span class="line-added">340                 return ret;</span>
<span class="line-added">341             }</span>
<span class="line-added">342             int b8 = bytes[index + 8];// read last byte raw</span>
<span class="line-added">343             position += 9;</span>
<span class="line-added">344             return ret + (((long) (b8 &amp; 0XFF)) &lt;&lt; 56);</span>
<span class="line-added">345         } else {</span>
<span class="line-added">346             return readLongSlow();</span>
<span class="line-added">347         }</span>
<span class="line-added">348     }</span>
<span class="line-added">349 </span>
<span class="line-added">350     private long readLongSlow() throws IOException {</span>
351         byte b0 = readByte();
352         long ret = (b0 &amp; 0x7FL);
353         if (b0 &gt;= 0) {
354             return ret;
355         }
<span class="line-added">356 </span>
357         int b1 = readByte();
358         ret += (b1 &amp; 0x7FL) &lt;&lt; 7;
359         if (b1 &gt;= 0) {
360             return ret;
361         }
<span class="line-added">362 </span>
363         int b2 = readByte();
364         ret += (b2 &amp; 0x7FL) &lt;&lt; 14;
365         if (b2 &gt;= 0) {
366             return ret;
367         }
<span class="line-added">368 </span>
369         int b3 = readByte();
370         ret += (b3 &amp; 0x7FL) &lt;&lt; 21;
371         if (b3 &gt;= 0) {
372             return ret;
373         }
<span class="line-added">374 </span>
375         int b4 = readByte();
376         ret += (b4 &amp; 0x7FL) &lt;&lt; 28;
377         if (b4 &gt;= 0) {
378             return ret;
379         }
<span class="line-added">380 </span>
381         int b5 = readByte();
382         ret += (b5 &amp; 0x7FL) &lt;&lt; 35;
383         if (b5 &gt;= 0) {
384             return ret;
385         }
<span class="line-added">386 </span>
387         int b6 = readByte();
388         ret += (b6 &amp; 0x7FL) &lt;&lt; 42;
389         if (b6 &gt;= 0) {
390             return ret;
391         }
<span class="line-added">392 </span>
393         int b7 = readByte();
394         ret += (b7 &amp; 0x7FL) &lt;&lt; 49;
395         if (b7 &gt;= 0) {
396             return ret;
<span class="line-added">397 </span>
398         }
<span class="line-added">399 </span>
400         int b8 = readByte(); // read last byte raw
401         return ret + (((long) (b8 &amp; 0XFF)) &lt;&lt; 56);
402     }
<span class="line-added">403 </span>
<span class="line-added">404     public void setValidSize(long size) {</span>
<span class="line-added">405         if (size &gt; this.size) {</span>
<span class="line-added">406             this.size = size;</span>
<span class="line-added">407         }</span>
<span class="line-added">408     }</span>
<span class="line-added">409 </span>
<span class="line-added">410     public long getFileSize() throws IOException {</span>
<span class="line-added">411         return file.length();</span>
<span class="line-added">412     }</span>
<span class="line-added">413 </span>
<span class="line-added">414     public String getFilename() {</span>
<span class="line-added">415         return filename;</span>
<span class="line-added">416     }</span>
<span class="line-added">417 </span>
<span class="line-added">418     // Purpose of this method is to reuse block cache from a</span>
<span class="line-added">419     // previous RecordingInput</span>
<span class="line-added">420     public void setFile(Path path) throws IOException {</span>
<span class="line-added">421         try {</span>
<span class="line-added">422             file.close();</span>
<span class="line-added">423         } catch (IOException e) {</span>
<span class="line-added">424             // perhaps deleted</span>
<span class="line-added">425         }</span>
<span class="line-added">426         file = null;</span>
<span class="line-added">427         initialize(path.toFile());</span>
<span class="line-added">428     }</span>
<span class="line-added">429 /*</span>
<span class="line-added">430 </span>
<span class="line-added">431 </span>
<span class="line-added">432 </span>
<span class="line-added">433 </span>
<span class="line-added">434 </span>
<span class="line-added">435  *</span>
<span class="line-added">436  *</span>
<span class="line-added">437  */</span>
438 }
</pre>
</td>
</tr>
</table>
<center><a href="ChunkHeader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../dcmd/DCmdConfigure.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
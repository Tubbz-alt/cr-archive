<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/utils/LogCompilation/src/main/java/com/sun/hotspot/tools/compiler/LogCompilation.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package com.sun.hotspot.tools.compiler;
 26 
 27 import java.io.ByteArrayOutputStream;
 28 import java.io.File;
 29 import java.io.FileNotFoundException;
 30 import java.io.FileOutputStream;
 31 import java.io.PrintStream;
 32 import java.util.*;
 33 
 34 import org.xml.sax.*;
 35 import org.xml.sax.helpers.*;
 36 
 37 /**
 38  * The LogCompilation tool parses log files generated by HotSpot using the
 39  * {@code -XX:+LogCompilation} command line flag, and outputs the data
 40  * collected therein in a nicely formatted way. There are various sorting
 41  * options available, as well as options that select specific compilation
 42  * events (such as inlining decisions) for inclusion in the output.
 43  *
 44  * The tool is also capable of fixing broken compilation logs as sometimes
 45  * generated by Java 1.5 JVMs.
 46  */
 47 public class LogCompilation extends DefaultHandler implements ErrorHandler {
 48 
 49     /**
 50      * Print usage information and terminate with a given exit code.
 51      */
 52     public static void usage(int exitcode) {
 53         System.out.println(&quot;Usage: LogCompilation [ -v ] [ -c ] [ -s ] [ -e | -n ] file1 ...&quot;);
 54         System.out.println(&quot;By default, the tool will print the logged compilations ordered by start time.&quot;);
 55         System.out.println(&quot;  -c:   clean up malformed 1.5 xml&quot;);
 56         System.out.println(&quot;  -i:   print inlining decisions&quot;);
 57         System.out.println(&quot;  -S:   print compilation statistics&quot;);
 58         System.out.println(&quot;  -U:   print uncommon trap statistics&quot;);
 59         System.out.println(&quot;  -t:   print with time stamps&quot;);
 60         System.out.println(&quot;  -s:   sort events by start time (default)&quot;);
 61         System.out.println(&quot;  -e:   sort events by elapsed time&quot;);
 62         System.out.println(&quot;  -n:   sort events by name and start&quot;);
 63         System.out.println(&quot;  -C:   compare logs (give files to compare on command line)&quot;);
 64         System.out.println(&quot;  -d:   do not print compilation IDs&quot;);
 65         System.exit(exitcode);
 66     }
 67 
 68     /**
 69      * compare controls how some output is formatted
 70      */
 71     public static boolean compare = false;
 72 
 73     /**
 74      * Process command line arguments, parse log files and trigger desired
 75      * functionality.
 76      */
 77     public static void main(String[] args) throws Exception {
 78         Comparator&lt;LogEvent&gt; sort = LogParser.sortByStart;
 79         boolean statistics = false;
 80         boolean printInlining = false;
 81         boolean cleanup = false;
 82         boolean trapHistory = false;
 83         boolean printTimeStamps = false;
 84         boolean printID = true;
 85         int index = 0;
 86 
 87         while (args.length &gt; index) {
 88             String a = args[index];
 89             if (a.equals(&quot;-e&quot;)) {
 90                 sort = LogParser.sortByElapsed;
 91                 index++;
 92             } else if (a.equals(&quot;-n&quot;)) {
 93                 sort = LogParser.sortByNameAndStart;
 94                 index++;
 95             } else if (a.equals(&quot;-s&quot;)) {
 96                 sort = LogParser.sortByStart;
 97                 index++;
 98             } else if (a.equals(&quot;-t&quot;)) {
 99                 printTimeStamps = true;
100                 index++;
101             } else if (a.equals(&quot;-c&quot;)) {
102                 cleanup = true;
103                 index++;
104             } else if (a.equals(&quot;-S&quot;)) {
105                 statistics = true;
106                 index++;
107             } else if (a.equals(&quot;-U&quot;)) {
108                 trapHistory = true;
109                 index++;
110             } else if (a.equals(&quot;-h&quot;)) {
111                 usage(0);
112             } else if (a.equals(&quot;-i&quot;)) {
113                 printInlining = true;
114                 index++;
115             } else if (a.equals(&quot;-C&quot;)) {
116                 compare = true;
117                 index++;
118             } else if (a.equals(&quot;-d&quot;)) {
119                 printID = false;
120                 index++;
121             } else {
122                 if (a.charAt(0) == &#39;-&#39;) {
123                     System.out.println(&quot;Unknown option &#39;&quot; + a + &quot;&#39;, assuming file name.&quot;);
124                 }
125                 break;
126             }
127         }
128 
129         if (index &gt;= args.length) {
130             usage(1);
131         }
132 
133         if (compare) {
134             compareLogs(index, args);
135             return;
136         }
137 
138         while (index &lt; args.length) {
139             ArrayList&lt;LogEvent&gt; events = null;
140             try {
141                 events = LogParser.parse(args[index], cleanup);
142             } catch (FileNotFoundException fnfe) {
143                 System.out.println(&quot;File not found: &quot; + args[index]);
144                 System.exit(1);
145             }
146 
147             Collections.sort(events, sort);
148 
149             if (statistics) {
150                 printStatistics(events, System.out);
151             } else if (trapHistory) {
152                 printTrapHistory(events, System.out);
153             } else {
154                 for (LogEvent c : events) {
155                     if (c instanceof NMethod) {
156                         // skip these
157                         continue;
158                     }
159                     if (printTimeStamps) {
160                         System.out.print(c.getStart() + &quot;: &quot;);
161                     }
162                     if (c instanceof Compilation) {
163                         Compilation comp = (Compilation) c;
164                         comp.print(System.out, printID, printInlining);
165                     } else {
166                         c.print(System.out, printID);
167                     }
168                 }
169             }
170             index++;
171         }
172     }
173 
174     /**
175      * Print extensive statistics from parsed log files.
176      */
177     public static void printStatistics(ArrayList&lt;LogEvent&gt; events, PrintStream out) {
178         // track code cache size
179         long cacheSize = 0;
180         long maxCacheSize = 0;
181         // track number of nmethods
182         int nmethodsCreated = 0;
183         int nmethodsLive = 0;
184         // track how many compilations were attempted multiple times
185         // (indexed by attempts, mapping to number of compilations)
186         int[] attempts = new int[32];
187         int maxattempts = 0;
188 
189         // track time spent in compiler phases
190         LinkedHashMap&lt;String, Double&gt; phaseTime = new LinkedHashMap&lt;&gt;(7);
191         // track nodes created per phase
192         LinkedHashMap&lt;String, Integer&gt; phaseNodes = new LinkedHashMap&lt;&gt;(7);
193         double elapsed = 0;
194 
195         for (LogEvent e : events) {
196             if (e instanceof Compilation) {
197                 Compilation c = (Compilation) e;
198                 c.printShort(out);
199                 out.printf(&quot; %6.4f\n&quot;, c.getElapsedTime());
200                 attempts[c.getAttempts()]++;
201                 maxattempts = Math.max(maxattempts,c.getAttempts());
202                 elapsed += c.getElapsedTime();
203                 for (Phase phase : c.getPhases()) {
204                     Double v = phaseTime.get(phase.getName());
205                     if (v == null) {
206                         v = Double.valueOf(0.0);
207                     }
208                     phaseTime.put(phase.getName(), Double.valueOf(v.doubleValue() + phase.getElapsedTime()));
209 
210                     Integer v2 = phaseNodes.get(phase.getName());
211                     if (v2 == null) {
212                         v2 = Integer.valueOf(0);
213                     }
214                     phaseNodes.put(phase.getName(), Integer.valueOf(v2.intValue() + phase.getNodes()));
215                     // Print phase name, elapsed time, nodes at the start of
216                     // the phase, nodes created in the phase, live nodes at the
217                     // start of the phase, live nodes added in the phase.
218                     out.printf(&quot;\t%s %6.4f %d %d %d %d\n&quot;, phase.getName(), phase.getElapsedTime(), phase.getStartNodes(), phase.getNodes(), phase.getStartLiveNodes(), phase.getAddedLiveNodes());
219                 }
220             } else if (e instanceof MakeNotEntrantEvent) {
221                 MakeNotEntrantEvent mne = (MakeNotEntrantEvent) e;
222                 NMethod nm = mne.getNMethod();
223                 if (mne.isZombie()) {
224                     if (nm == null) {
225                         System.err.println(&quot;zombie make not entrant event without nmethod: &quot; + mne.getId());
226                     }
227                     cacheSize -= nm.getSize();
228                     nmethodsLive--;
229                 }
230             } else if (e instanceof NMethod) {
231                 nmethodsLive++;
232                 nmethodsCreated++;
233                 NMethod nm = (NMethod) e;
234                 cacheSize += nm.getSize();
235                 maxCacheSize = Math.max(cacheSize, maxCacheSize);
236             }
237         }
238         out.printf(&quot;NMethods: %d created %d live %d bytes (%d peak) in the code cache\n&quot;, nmethodsCreated, nmethodsLive, cacheSize, maxCacheSize);
239         out.println(&quot;Phase times:&quot;);
240         for (String name : phaseTime.keySet()) {
241             Double v = phaseTime.get(name);
242             Integer v2 = phaseNodes.get(name);
243             out.printf(&quot;%20s %6.4f %d\n&quot;, name, v.doubleValue(), v2.intValue());
244         }
245         out.printf(&quot;%20s %6.4f\n&quot;, &quot;total&quot;, elapsed);
246 
247         if (maxattempts &gt; 0) {
248             out.println(&quot;Distribution of regalloc passes:&quot;);
249             for (int i = 0; i &lt;= maxattempts; i++) {
250                 out.printf(&quot;%2d %8d\n&quot;, i, attempts[i]);
251             }
252         }
253     }
254 
255     /**
256      * Container class for a pair of a method and a bytecode instruction index
257      * used by a compiler. This is used in
258      * {@linkplain #compareLogs() comparing logs}.
259      */
260     static class MethodBCIPair {
261         public MethodBCIPair(Method m, int b, String c, long l) {
262             method = m;
263             bci = b;
264             compiler = c;
265             level = l;
266         }
267 
268         Method method;
269         int bci;
270         String compiler;
271         long level;
272 
273         public boolean equals(Object other) {
274             if (!(other instanceof MethodBCIPair)) {
275                 return false;
276             }
277             MethodBCIPair otherp = (MethodBCIPair)other;
278             assert otherp.compiler != null : &quot;otherp null compiler: &quot; + otherp;
279             assert method.getCompiler() != compiler : &quot;Compiler doesnt match&quot;;
280             return (otherp.bci == bci &amp;&amp;
281                     otherp.method.equals(method) &amp;&amp;
282                     otherp.compiler.equals(compiler) &amp;&amp;
283                     otherp.level == level);
284         }
285 
286         public int hashCode() {
287             return method.hashCode() + bci;
288         }
289 
290         public String toString() {
291             if (bci != -1) {
292                 return method + &quot;@&quot; + bci + &quot; (&quot; + compiler + &quot;)&quot;;
293             } else {
294                 return method + &quot; (&quot; + compiler + &quot;(&quot; + level + &quot;))&quot;;
295             }
296         }
297     }
298 
299     /**
300      * Compare a number of compilation log files. Each of the logs is parsed,
301      * and all compilations found therein are written to a sorted file (prefix
302      * {@code sorted-}. A summary is written to a new file {@code summary.txt}.
303      *
304      * @param index the index in the command line arguments at which to start
305      *              looking for files to compare.
306      * @param args  the command line arguments with which {@link LogCompilation}
307      *              was originally invoked.
308      *
309      * @throws Exception in case any exceptions are thrown in the called
310      *         methods.
311      */
312     @SuppressWarnings(&quot;unchecked&quot;)
313     static void compareLogs(int index, String[] args) throws Exception {
314         HashMap&lt;MethodBCIPair,MethodBCIPair&gt; methods = new HashMap&lt;&gt;();
315         ArrayList&lt;HashMap&lt;MethodBCIPair,Object&gt;&gt; logs = new ArrayList&lt;&gt;();
316         PrintStream[] outs = new PrintStream[args.length - index];
317         PrintStream summary = new PrintStream(new FileOutputStream(&quot;summary.txt&quot;));
318         int o = 0;
319         // Process all logs given on the command line: collect compilation
320         // data; in particular, method/bci pairs.
321         while (index &lt; args.length) {
322             String basename = new File(args[index]).getName();
323             String outname = &quot;sorted-&quot; + basename;
324             System.out.println(&quot;Sorting &quot; + basename + &quot; to &quot; + outname);
325             outs[o] = new PrintStream(new FileOutputStream(outname));
326             o++;
327             System.out.println(&quot;Parsing &quot; + args[index]);
328             ArrayList&lt;LogEvent&gt; events = LogParser.parse(args[index], false);
329             HashMap&lt;MethodBCIPair,Object&gt; compiles = new HashMap&lt;&gt;();
330             logs.add(compiles);
331             for (LogEvent c : events) {
332                 if (c instanceof Compilation) {
333                     Compilation comp = (Compilation) c;
334                     assert (comp.getNMethod() != null  || comp.getFailureReason() != null ): &quot;NMethod is null in compare: &quot; + comp;
335                     String compiler = comp.getNMethod() != null ? comp.getNMethod().getCompiler() :
336                             (comp.getCompiler() != null ? comp.getCompiler() : &quot;&quot;);
337                     assert compiler != null : &quot;Compiler is null in compare: &quot; + comp;
338                     long level = -99;
339                     if (comp.getLevel() == 0) {
340                         if (comp.getNMethod() != null) {
341                             level = comp.getNMethod().getLevel();
342                         }
343                         if (level == 0) {
344                             level = comp.getMethod().getLevel();
345                         }
346                     } else {
347                         level = comp.getLevel();
348                     }
349                     assert level != -99 || comp.getFailureReason() != null : &quot;Failed Compile&quot;;
350                     MethodBCIPair key = new MethodBCIPair(comp.getMethod(), comp.getBCI(), compiler, level);
351                     MethodBCIPair e = methods.get(key);
352                     if (e == null) {
353                         methods.put(key, key);
354                     } else {
355                         key = e;
356                     }
357                     Object other = compiles.get(key);
358                     if (other == null) {
359                         compiles.put(key, comp);
360                     } else {
361                         if (!(other instanceof List)) {
362                             List&lt;Object&gt; l = new LinkedList&lt;&gt;();
363                             l.add(other);
364                             l.add(comp);
365                             compiles.put(key, l);
366                         } else {
367                             List&lt;Object&gt; l = (List&lt;Object&gt;) other;
368                             l.add(comp);
369                         }
370                     }
371                 }
372             }
373             index++;
374         }
375 
376         // Process the collected method/bci pairs and write the output.
377         for (MethodBCIPair pair : methods.keySet()) {
378             summary.print(pair + &quot; &quot;);
379             int base = -1;
380             String first = null;
381             boolean mismatch = false;
382             boolean different = false;
383             String[] output = new String[outs.length];
384             o = 0;
385             for (HashMap&lt;MethodBCIPair,Object&gt; set : logs) {
386                 Object e = set.get(pair);
387                 String thisone = null;
388                 Compilation lastc = null;
389                 int n;
390                 if (e == null) {
391                     n = 0;
392                 } else if (e instanceof Compilation) {
393                     n = 1;
394                     lastc = (Compilation) e;
395                 } else {
396                     // Compare the last compilation that was done for this method
397                     n = ((List&lt;Object&gt;) e).size();
398                     lastc = (Compilation) ((List&lt;Object&gt;) e).get(n - 1);
399                 }
400                 if (lastc != null) {
401                     n = 1;
402                     ByteArrayOutputStream baos = new ByteArrayOutputStream();
403                     PrintStream ps = new PrintStream(baos);
404                     lastc.print(ps, false);
405                     ps.close();
406                     thisone = new String(baos.toByteArray());
407                 }
408                 if (base == -1) {
409                     base = n;
410                 } else if (base != n) {
411                     mismatch = true;
412                 }
413                 output[o++] = thisone;
414                 if (thisone != null) {
415                     if (first == null) {
416                         first = thisone;
417                     } else {
418                         if (!first.equals(thisone)) {
419                             different = true;
420                         }
421                     }
422                 }
423                 if (different) {
424                     summary.print(n + &quot;d &quot;);
425                 } else {
426                     summary.print(n + &quot; &quot;);
427                 }
428             }
429             if (mismatch) {
430                 summary.print(&quot;mismatch&quot;);
431             }
432             summary.println();
433             if (different) {
434                 for (int i = 0; i &lt; outs.length; i++) {
435                     if (output[i] != null) {
436                         outs[i].println(output[i]);
437                     }
438                 }
439             }
440         }
441         for (int i = 0; i &lt; outs.length; i++) {
442             outs[i].close();
443         }
444         if (summary != System.out) {
445             summary.close();
446         }
447     }
448 
449     /**
450      * Print the history of uncommon trap events.
451      */
452     public static void printTrapHistory(ArrayList&lt;LogEvent&gt; events, PrintStream out) {
453         // map method names to a list of log events
454         LinkedHashMap&lt;String, ArrayList&lt;LogEvent&gt;&gt; traps = new LinkedHashMap&lt;&gt;();
455         // map compilation IDs to compilations
456         HashMap&lt;Integer, Compilation&gt; comps = new HashMap&lt;&gt;();
457 
458         // First, iterate over all logged events, collecting data about
459         // uncommon trap events.
460         for (LogEvent e : events) {
461             if (e instanceof NMethod) {
462                 // skip these
463                 continue;
464             }
465             if (e instanceof Compilation) {
466                 Compilation c = (Compilation) e;
467                 String name = c.getMethod().getFullName();
468                 ArrayList&lt;LogEvent&gt; elist = traps.get(name);
469                 if (elist != null &amp;&amp; comps.get(c.getId()) == null) {
470                     comps.put(c.getId(), c);
471                     // If there were previous events for the method
472                     // then keep track of later compiles too.
473                     elist.add(c);
474                 }
475                 continue;
476             }
477             if (e instanceof BasicLogEvent) {
478                 BasicLogEvent ble = (BasicLogEvent) e;
479                 Compilation c = ble.getCompilation();
480                 if (c == null) {
481                     if (!(ble instanceof NMethod)) {
482                         throw new InternalError(&quot;only nmethods should have a null compilation; here&#39;s a &quot; + ble.getClass());
483                     }
484                     continue;
485                 }
486                 String name = c.getMethod().getFullName();
487                 ArrayList&lt;LogEvent&gt; elist = traps.get(name);
488                 if (elist == null) {
489                     elist = new ArrayList&lt;LogEvent&gt;();
490                     traps.put(name, elist);
491                 }
492                 int bleId = Integer.parseInt(ble.getId());
493                 if (comps.get(bleId) == null) {
494                     comps.put(bleId, c);
495                     // Add the associated compile to the list.  It
496                     // will likely go at the end but we need to search
497                     // backwards for the proper insertion point.
498                     double start = c.getStart();
499                     int ipoint = 0;
500                     while (ipoint &lt; elist.size() &amp;&amp; elist.get(ipoint).getStart() &lt; start) {
501                         ipoint++;
502                     }
503                     if (ipoint == elist.size()) {
504                         elist.add(c);
505                     } else {
506                         elist.add(ipoint, c);
507                     }
508                 }
509                 elist.add(ble);
510             }
511         }
512 
513         // Second, iterate over collected traps and output information.
514         for (String c: traps.keySet()) {
515             ArrayList&lt;LogEvent&gt; elist = traps.get(c);
516             String name = ((Compilation) elist.get(0)).getMethod().getFullName();
517             System.out.println(name);
518             double start = 0;
519             for (LogEvent e: elist) {
520                 if (start &gt; e.getStart() &amp;&amp; e.getStart() != 0) {
521                     throw new InternalError(&quot;wrong sorting order for traps&quot;);
522                 }
523                 start = e.getStart();
524                 out.print(e.getStart() + &quot;: &quot;);
525                 if (e instanceof Compilation) {
526                     ((Compilation) e).print(out, true, true, true);
527                 } else {
528                     e.print(out, true);
529                 }
530             }
531             out.println();
532         }
533     }
534 
535 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/utils/LogCompilation/src/main/java/com/sun/hotspot/tools/compiler/CallSite.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2009, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package com.sun.hotspot.tools.compiler;
 26 
 27 import java.io.PrintStream;
 28 import java.util.ArrayDeque;
 29 import java.util.ArrayList;
 30 import java.util.List;
 31 
 32 /**
 33  * Representation of a compilation scope in a compilation log. This class is a
 34  * hybrid: its instances can represent original scopes of methods being
 35  * compiled, but are also used to represent call sites in given methods.
 36  */
 37 public class CallSite {
 38 
 39     /**
 40      * The index of the call in the caller. This will be 0 if this instance
 41      * represents a compilation root.
 42      */
 43     private int bci;
 44 
 45     /**
 46      * The method that is called at this call site. This will be {@code null}
 47      * if this instance represents a compilation root.
 48      */
 49     private Method method;
 50 
 51     /**
 52      * The invocation count for this call site.
 53      */
 54     private int count;
 55 
 56     /**
 57      * The receiver type of the call represented by this instance, if known.
 58      */
 59     private String receiver;
 60 
 61     /**
 62      * In case the {@linkplain receiver receiver type} of the call represented
 63      * by this instance is known, this is how often the type was encountered.
 64      */
 65     private int receiver_count;
 66 
 67     /**
 68      * The reason for a success or failure of an inlining operation at this
 69      * call site.
 70      */
 71     private String reason;
 72 
 73     /**
 74      * A list of all calls in this compilation scope.
 75      */
 76     private List&lt;CallSite&gt; calls;
 77 
 78     /**
 79      * Number of nodes in the graph at the end of parsing this compilation
 80      * scope.
 81      */
 82     private int endNodes;
 83 
 84     /**
 85      * Number of live nodes in the graph at the end of parsing this compilation
 86      * scope.
 87      */
 88     private int endLiveNodes;
 89 
 90     /**
 91      * Time in seconds since VM startup at which parsing this compilation scope
 92      * ended.
 93      */
 94     private double timeStamp;
 95 
 96     /**
 97      * The inline ID in case the call represented by this instance is inlined,
 98      * 0 otherwise.
 99      */
100     private long inlineId;
101 
102     /**
103      * List of uncommon traps in this compilation scope.
104      */
105     private List&lt;UncommonTrap&gt; traps;
106 
107     /**
108      * The name of the intrinsic at this call site.
109      */
110     private String intrinsicName;
111 
112     /**
113      * Default constructor: used to create an instance that represents the top
114      * scope of a compilation.
115      */
116     CallSite() {}
117 
118     /**
119      * Constructor to create an instance that represents an actual method call.
120      */
121     CallSite(int bci, Method m) {
122         this.bci = bci;
123         this.method = m;
124     }
125 
126     /**
127      * Add a call site to the compilation scope represented by this instance.
128      */
129     void add(CallSite site) {
130         if (getCalls() == null) {
131             calls = new ArrayList&lt;&gt;();
132         }
133         getCalls().add(site);
134     }
135 
136     /**
137      * Return the last of the {@linkplain #getCalls() call sites} in this
138      * compilation scope.
139      */
140     CallSite last() {
141         return getCalls().get(getCalls().size() - 1);
142     }
143 
144     /**
145      * Return the last-but-one of the {@linkplain #getCalls() call sites} in
146      * this compilation scope.
147      */
148     CallSite lastButOne() {
149         return getCalls().get(getCalls().size() - 2);
150     }
151 
152     public String toString() {
153         StringBuilder sb = new StringBuilder();
154         if (getReason() == null) {
155             sb.append(&quot;  @ &quot; + getBci() + &quot; &quot; + getMethod());
156         } else {
157             sb.append(&quot;- @ &quot; + getBci() + &quot; &quot; + getMethod() + &quot; &quot; + getReason());
158         }
159         sb.append(&quot;\n&quot;);
160         if (getCalls() != null) {
161             for (CallSite site : getCalls()) {
162                 sb.append(site);
163                 sb.append(&quot;\n&quot;);
164             }
165         }
166         return sb.toString();
167     }
168 
169     public void print(PrintStream stream) {
170         print(stream, 0, true, false);
171     }
172 
173     void emit(PrintStream stream, int indent) {
174         for (int i = 0; i &lt; indent; i++) {
175             stream.print(&#39; &#39;);
176         }
177     }
178 
179     public void print(PrintStream stream, int indent, boolean printInlining, boolean printUncommonTraps) {
180         emit(stream, indent);
181         String m = getMethod().getHolder() + &quot;::&quot; + getMethod().getName();
182         if (getReason() == null) {
183             stream.print(&quot;  @ &quot; + getBci() + &quot; &quot; + m + &quot; (&quot; + getMethod().getBytes() + &quot; bytes)&quot;);
184         } else {
185             stream.print(&quot;  @ &quot; + getBci() + &quot; &quot; + m + &quot; &quot; + getReason());
186         }
187         stream.print(getIntrinsicOrEmptyString());
<a name="2" id="anc2"></a><span class="line-modified">188         stream.printf(&quot; (end time: %6.4f&quot;, getTimeStamp());</span>



189         if (getEndNodes() &gt; 0) {
190             stream.printf(&quot; nodes: %d live: %d&quot;, getEndNodes(), getEndLiveNodes());
191         }
192         stream.println(&quot;)&quot;);
193 
194         if (getReceiver() != null) {
195             emit(stream, indent + 4);
196             stream.println(&quot;type profile &quot; + getMethod().getHolder() + &quot; -&gt; &quot; + getReceiver() + &quot; (&quot; +
197                     (getReceiverCount() * 100 / getCount()) + &quot;%)&quot;);
198         }
199         if (printInlining &amp;&amp; getCalls() != null) {
200             for (CallSite site : getCalls()) {
201                 site.print(stream, indent + 2, printInlining, printUncommonTraps);
202             }
203         }
204         if (printUncommonTraps &amp;&amp; getTraps() != null) {
205             for (UncommonTrap site : getTraps()) {
206                 site.print(stream, indent + 2);
207             }
208         }
209     }
210 
211     public int getBci() {
212         return bci;
213     }
214 
215     public void setBci(int bci) {
216         this.bci = bci;
217     }
218 
219     public Method getMethod() {
220         return method;
221     }
222 
223     public void setMethod(Method method) {
224         this.method = method;
225     }
226 
227     public int getCount() {
228         return count;
229     }
230 
231     public void setCount(int count) {
232         this.count = count;
233     }
234 
235     public String getReceiver() {
236         return receiver;
237     }
238 
239     public void setReceiver(String receiver) {
240         this.receiver = receiver;
241     }
242 
243     public int getReceiverCount() {
244         return receiver_count;
245     }
246 
247     public void setReceiver_count(int receiver_count) {
248         this.receiver_count = receiver_count;
249     }
250 
251     public String getReason() {
252         return reason;
253     }
254 
255     public void setReason(String reason) {
256         this.reason = reason;
257     }
258 
259     public List&lt;CallSite&gt; getCalls() {
260         return calls;
261     }
262 
263     public List&lt;UncommonTrap&gt; getTraps() {
264         return traps;
265     }
266 
267     void add(UncommonTrap e) {
268         if (traps == null) {
269             traps = new ArrayList&lt;UncommonTrap&gt;();
270         }
271         traps.add(e);
272     }
273 
274     void setEndNodes(int n) {
275         endNodes = n;
276     }
277 
278     public int getEndNodes() {
279         return endNodes;
280     }
281 
282     void setEndLiveNodes(int n) {
283         endLiveNodes = n;
284     }
285 
286     public int getEndLiveNodes() {
287         return endLiveNodes;
288     }
289 
290     void setTimeStamp(double time) {
291         timeStamp = time;
292     }
293 
294     public double getTimeStamp() {
295         return timeStamp;
296     }
297 
298     /**
299      * Check whether this call site matches another. Every late inline call
300      * site has a unique inline ID. If the call site we&#39;re looking for has one,
301      * then use it; otherwise rely on method name and byte code index.
302      */
303     private boolean matches(CallSite other) {
304         if (other.inlineId != 0) {
305             return inlineId == other.inlineId;
306         }
307         return method.equals(other.method) &amp;&amp; bci == other.bci;
308     }
309 
310     /**
311      * Locate a late inline call site: find, in this instance&#39;s
312      * {@linkplain #calls call sites}, the one furthest down the given call
313      * stack.
314      *
315      * Multiple chains of identical call sites with the same method name / bci
316      * combination are possible, so we have to try them all until we find the
317      * late inline call site that has a matching inline ID.
318      *
319      * @return a matching call site, or {@code null} if none was found.
320      */
321     public CallSite findCallSite(ArrayDeque&lt;CallSite&gt; sites) {
322         if (calls == null) {
323             return null;
324         }
325         CallSite site = sites.pop();
326         for (CallSite c : calls) {
327             if (c.matches(site)) {
328                 if (!sites.isEmpty()) {
329                     CallSite res = c.findCallSite(sites);
330                     if (res != null) {
331                         sites.push(site);
332                         return res;
333                     }
334                 } else {
335                     sites.push(site);
336                     return c;
337                 }
338             }
339         }
340         sites.push(site);
341         return null;
342     }
343 
344     /**
345      * Locate a late inline call site in the tree spanned by all this instance&#39;s
346      * {@linkplain #calls call sites}, and return the sequence of call sites
347      * (scopes) leading to that late inline call site.
348      */
349     public ArrayDeque&lt;CallSite&gt; findCallSite2(CallSite site) {
350         if (calls == null) {
351             return null;
352         }
353 
354         for (CallSite c : calls) {
355             if (c.matches(site)) {
356                 ArrayDeque&lt;CallSite&gt; stack = new ArrayDeque&lt;&gt;();
357                 stack.push(c);
358                 return stack;
359             } else {
360                 ArrayDeque&lt;CallSite&gt; stack = c.findCallSite2(site);
361                 if (stack != null) {
362                     stack.push(c);
363                     return stack;
364                 }
365             }
366         }
367         return null;
368     }
369 
370     public long getInlineId() {
371         return inlineId;
372     }
373 
374     public void setInlineId(long inlineId) {
375         this.inlineId = inlineId;
376     }
377 
378     public String getIntrinsicName() {
379         return intrinsicName;
380     }
381 
382     public void setIntrinsicName(String name) {
383         this.intrinsicName = name;
384     }
385 
386     public String getIntrinsicOrEmptyString() {
387         if (intrinsicName != null) {
388             return &quot; (intrinsic: &quot; + getIntrinsicName() + &quot;)&quot;;
389         }
390         return &quot;&quot;;
391     }
392 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
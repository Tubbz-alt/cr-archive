<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/utils/LogCompilation/src/main/java/com/sun/hotspot/tools/compiler/LogParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 /**
  26  * A SAX based parser of LogCompilation output from HotSpot.  It takes a complete
  27  */
  28 
  29 package com.sun.hotspot.tools.compiler;
  30 
  31 import java.io.FileReader;
  32 import java.io.PrintStream;
  33 import java.io.Reader;
  34 import java.util.ArrayDeque;
  35 import java.util.ArrayList;
  36 import java.util.Comparator;
  37 import java.util.Deque;
  38 import java.util.HashMap;
  39 import java.util.LinkedHashMap;
  40 import java.util.regex.Pattern;
  41 
  42 import javax.xml.parsers.SAXParser;
  43 import javax.xml.parsers.SAXParserFactory;
  44 
  45 import org.xml.sax.Attributes;
  46 import org.xml.sax.ErrorHandler;
  47 import org.xml.sax.InputSource;
  48 import org.xml.sax.Locator;
  49 import org.xml.sax.helpers.DefaultHandler;
  50 
  51 /**
  52  * A SAX parser for HotSpot compilation logs. The bulk of the parsing and event
  53  * maintenance work is done in the {@link #startElement(String,String,String,Attributes)}
  54  * and {@link #endElement(String,String,String)} methods.
  55  */
  56 public class LogParser extends DefaultHandler implements ErrorHandler {
  57 
  58     static final Pattern spacePattern = Pattern.compile(&quot; &quot;);
  59 
  60     /**
  61      * Map internal array type descriptors to Java names.
  62      */
  63     static final HashMap&lt;String, String&gt; type2printableMap;
  64 
  65     /**
  66      * Map Java primitive type names to internal type descriptors.
  67      */
  68     static final HashMap&lt;String, String&gt; type2vmtypeMap;
  69 
  70     static {
  71         type2printableMap = new HashMap&lt;&gt;();
  72         type2printableMap.put(&quot;[I&quot;, &quot;int[]&quot;);
  73         type2printableMap.put(&quot;[C&quot;, &quot;char[]&quot;);
  74         type2printableMap.put(&quot;[Z&quot;, &quot;boolean[]&quot;);
  75         type2printableMap.put(&quot;[L&quot;, &quot;Object[]&quot;);
  76         type2printableMap.put(&quot;[B&quot;, &quot;byte[]&quot;);
  77 
  78         type2vmtypeMap = new HashMap&lt;&gt;();
  79         type2vmtypeMap.put(&quot;void&quot;, &quot;V&quot;);
  80         type2vmtypeMap.put(&quot;boolean&quot;, &quot;Z&quot;);
  81         type2vmtypeMap.put(&quot;byte&quot;, &quot;B&quot;);
  82         type2vmtypeMap.put(&quot;char&quot;, &quot;C&quot;);
  83         type2vmtypeMap.put(&quot;short&quot;, &quot;S&quot;);
  84         type2vmtypeMap.put(&quot;int&quot;, &quot;I&quot;);
  85         type2vmtypeMap.put(&quot;long&quot;, &quot;J&quot;);
  86         type2vmtypeMap.put(&quot;float&quot;, &quot;F&quot;);
  87         type2vmtypeMap.put(&quot;double&quot;, &quot;D&quot;);
  88     }
  89 
  90     static String[] bytecodes = new String[] {
  91         &quot;nop&quot;,
  92         &quot;aconst_null&quot;,
  93         &quot;iconst_m1&quot;,
  94         &quot;iconst_0&quot;,
  95         &quot;iconst_1&quot;,
  96         &quot;iconst_2&quot;,
  97         &quot;iconst_3&quot;,
  98         &quot;iconst_4&quot;,
  99         &quot;iconst_5&quot;,
 100         &quot;lconst_0&quot;,
 101         &quot;lconst_1&quot;,
 102         &quot;fconst_0&quot;,
 103         &quot;fconst_1&quot;,
 104         &quot;fconst_2&quot;,
 105         &quot;dconst_0&quot;,
 106         &quot;dconst_1&quot;,
 107         &quot;bipush&quot;,
 108         &quot;sipush&quot;,
 109         &quot;ldc&quot;,
 110         &quot;ldc_w&quot;,
 111         &quot;ldc2_w&quot;,
 112         &quot;iload&quot;,
 113         &quot;lload&quot;,
 114         &quot;fload&quot;,
 115         &quot;dload&quot;,
 116         &quot;aload&quot;,
 117         &quot;iload_0&quot;,
 118         &quot;iload_1&quot;,
 119         &quot;iload_2&quot;,
 120         &quot;iload_3&quot;,
 121         &quot;lload_0&quot;,
 122         &quot;lload_1&quot;,
 123         &quot;lload_2&quot;,
 124         &quot;lload_3&quot;,
 125         &quot;fload_0&quot;,
 126         &quot;fload_1&quot;,
 127         &quot;fload_2&quot;,
 128         &quot;fload_3&quot;,
 129         &quot;dload_0&quot;,
 130         &quot;dload_1&quot;,
 131         &quot;dload_2&quot;,
 132         &quot;dload_3&quot;,
 133         &quot;aload_0&quot;,
 134         &quot;aload_1&quot;,
 135         &quot;aload_2&quot;,
 136         &quot;aload_3&quot;,
 137         &quot;iaload&quot;,
 138         &quot;laload&quot;,
 139         &quot;faload&quot;,
 140         &quot;daload&quot;,
 141         &quot;aaload&quot;,
 142         &quot;baload&quot;,
 143         &quot;caload&quot;,
 144         &quot;saload&quot;,
 145         &quot;istore&quot;,
 146         &quot;lstore&quot;,
 147         &quot;fstore&quot;,
 148         &quot;dstore&quot;,
 149         &quot;astore&quot;,
 150         &quot;istore_0&quot;,
 151         &quot;istore_1&quot;,
 152         &quot;istore_2&quot;,
 153         &quot;istore_3&quot;,
 154         &quot;lstore_0&quot;,
 155         &quot;lstore_1&quot;,
 156         &quot;lstore_2&quot;,
 157         &quot;lstore_3&quot;,
 158         &quot;fstore_0&quot;,
 159         &quot;fstore_1&quot;,
 160         &quot;fstore_2&quot;,
 161         &quot;fstore_3&quot;,
 162         &quot;dstore_0&quot;,
 163         &quot;dstore_1&quot;,
 164         &quot;dstore_2&quot;,
 165         &quot;dstore_3&quot;,
 166         &quot;astore_0&quot;,
 167         &quot;astore_1&quot;,
 168         &quot;astore_2&quot;,
 169         &quot;astore_3&quot;,
 170         &quot;iastore&quot;,
 171         &quot;lastore&quot;,
 172         &quot;fastore&quot;,
 173         &quot;dastore&quot;,
 174         &quot;aastore&quot;,
 175         &quot;bastore&quot;,
 176         &quot;castore&quot;,
 177         &quot;sastore&quot;,
 178         &quot;pop&quot;,
 179         &quot;pop2&quot;,
 180         &quot;dup&quot;,
 181         &quot;dup_x1&quot;,
 182         &quot;dup_x2&quot;,
 183         &quot;dup2&quot;,
 184         &quot;dup2_x1&quot;,
 185         &quot;dup2_x2&quot;,
 186         &quot;swap&quot;,
 187         &quot;iadd&quot;,
 188         &quot;ladd&quot;,
 189         &quot;fadd&quot;,
 190         &quot;dadd&quot;,
 191         &quot;isub&quot;,
 192         &quot;lsub&quot;,
 193         &quot;fsub&quot;,
 194         &quot;dsub&quot;,
 195         &quot;imul&quot;,
 196         &quot;lmul&quot;,
 197         &quot;fmul&quot;,
 198         &quot;dmul&quot;,
 199         &quot;idiv&quot;,
 200         &quot;ldiv&quot;,
 201         &quot;fdiv&quot;,
 202         &quot;ddiv&quot;,
 203         &quot;irem&quot;,
 204         &quot;lrem&quot;,
 205         &quot;frem&quot;,
 206         &quot;drem&quot;,
 207         &quot;ineg&quot;,
 208         &quot;lneg&quot;,
 209         &quot;fneg&quot;,
 210         &quot;dneg&quot;,
 211         &quot;ishl&quot;,
 212         &quot;lshl&quot;,
 213         &quot;ishr&quot;,
 214         &quot;lshr&quot;,
 215         &quot;iushr&quot;,
 216         &quot;lushr&quot;,
 217         &quot;iand&quot;,
 218         &quot;land&quot;,
 219         &quot;ior&quot;,
 220         &quot;lor&quot;,
 221         &quot;ixor&quot;,
 222         &quot;lxor&quot;,
 223         &quot;iinc&quot;,
 224         &quot;i2l&quot;,
 225         &quot;i2f&quot;,
 226         &quot;i2d&quot;,
 227         &quot;l2i&quot;,
 228         &quot;l2f&quot;,
 229         &quot;l2d&quot;,
 230         &quot;f2i&quot;,
 231         &quot;f2l&quot;,
 232         &quot;f2d&quot;,
 233         &quot;d2i&quot;,
 234         &quot;d2l&quot;,
 235         &quot;d2f&quot;,
 236         &quot;i2b&quot;,
 237         &quot;i2c&quot;,
 238         &quot;i2s&quot;,
 239         &quot;lcmp&quot;,
 240         &quot;fcmpl&quot;,
 241         &quot;fcmpg&quot;,
 242         &quot;dcmpl&quot;,
 243         &quot;dcmpg&quot;,
 244         &quot;ifeq&quot;,
 245         &quot;ifne&quot;,
 246         &quot;iflt&quot;,
 247         &quot;ifge&quot;,
 248         &quot;ifgt&quot;,
 249         &quot;ifle&quot;,
 250         &quot;if_icmpeq&quot;,
 251         &quot;if_icmpne&quot;,
 252         &quot;if_icmplt&quot;,
 253         &quot;if_icmpge&quot;,
 254         &quot;if_icmpgt&quot;,
 255         &quot;if_icmple&quot;,
 256         &quot;if_acmpeq&quot;,
 257         &quot;if_acmpne&quot;,
 258         &quot;goto&quot;,
 259         &quot;jsr&quot;,
 260         &quot;ret&quot;,
 261         &quot;tableswitch&quot;,
 262         &quot;lookupswitch&quot;,
 263         &quot;ireturn&quot;,
 264         &quot;lreturn&quot;,
 265         &quot;freturn&quot;,
 266         &quot;dreturn&quot;,
 267         &quot;areturn&quot;,
 268         &quot;return&quot;,
 269         &quot;getstatic&quot;,
 270         &quot;putstatic&quot;,
 271         &quot;getfield&quot;,
 272         &quot;putfield&quot;,
 273         &quot;invokevirtual&quot;,
 274         &quot;invokespecial&quot;,
 275         &quot;invokestatic&quot;,
 276         &quot;invokeinterface&quot;,
 277         &quot;invokedynamic&quot;,
 278         &quot;new&quot;,
 279         &quot;newarray&quot;,
 280         &quot;anewarray&quot;,
 281         &quot;arraylength&quot;,
 282         &quot;athrow&quot;,
 283         &quot;checkcast&quot;,
 284         &quot;instanceof&quot;,
 285         &quot;monitorenter&quot;,
 286         &quot;monitorexit&quot;,
 287         &quot;wide&quot;,
 288         &quot;multianewarray&quot;,
 289         &quot;ifnull&quot;,
 290         &quot;ifnonnull&quot;,
 291         &quot;goto_w&quot;,
 292         &quot;jsr_w&quot;,
 293         &quot;breakpoint&quot;
 294     };
 295 
 296     /**
 297      * Sort log events by start time.
 298      */
 299     static Comparator&lt;LogEvent&gt; sortByStart = new Comparator&lt;LogEvent&gt;() {
 300 
 301         public int compare(LogEvent a, LogEvent b) {
 302             double difference = (a.getStart() - b.getStart());
 303             if (difference &lt; 0) {
 304                 return -1;
 305             }
 306             if (difference &gt; 0) {
 307                 return 1;
 308             }
 309             return 0;
 310         }
 311 
 312         @Override
 313         public boolean equals(Object other) {
 314             return false;
 315         }
 316 
 317         @Override
 318         public int hashCode() {
 319             return 7;
 320         }
 321     };
 322 
 323     /**
 324      * Sort log events first by the name of the compiled method, then by start
 325      * time. In case one of the events has no associated compilation (or the
 326      * associated compilation has no method name), the event with a compilation
 327      * and/or name is considered the larger one.
 328      */
 329     static Comparator&lt;LogEvent&gt; sortByNameAndStart = new Comparator&lt;LogEvent&gt;() {
 330 
 331         public int compare(LogEvent a, LogEvent b) {
 332             Compilation c1 = a.getCompilation();
 333             Compilation c2 = b.getCompilation();
 334             if (c1 != null &amp;&amp; c1.getMethod() != null &amp;&amp; c2 != null &amp;&amp; c2.getMethod() != null) {
 335                 int result = c1.getMethod().toString().compareTo(c2.getMethod().toString());
 336                 if (result != 0) {
 337                     return result;
 338                 }
 339             } else if ((c1 == null || c1.getMethod() == null) &amp;&amp; c2 != null &amp;&amp; c2.getMethod() != null) {
 340                 return -1;
 341             } else if ((c2 == null || c2.getMethod() == null) &amp;&amp; c1 != null &amp;&amp; c1.getMethod() != null) {
 342                 return 1;
 343             }
 344             return Double.compare(a.getStart(), b.getStart());
 345         }
 346 
 347         public boolean equals(Object other) {
 348             return false;
 349         }
 350 
 351         @Override
 352         public int hashCode() {
 353             return 7;
 354         }
 355     };
 356 
 357     /**
 358      * Sort log events by duration.
 359      */
 360     static Comparator&lt;LogEvent&gt; sortByElapsed = new Comparator&lt;LogEvent&gt;() {
 361 
 362         public int compare(LogEvent a, LogEvent b) {
 363             double difference = (a.getElapsedTime() - b.getElapsedTime());
 364             if (difference &lt; 0) {
 365                 return -1;
 366             }
 367             if (difference &gt; 0) {
 368                 return 1;
 369             }
 370             return 0;
 371         }
 372 
 373         @Override
 374         public boolean equals(Object other) {
 375             return false;
 376         }
 377 
 378         @Override
 379         public int hashCode() {
 380             return 7;
 381         }
 382     };
 383 
 384     /**
 385      * Shrink-wrapped representation of a JVMState (tailored to meet this
 386      * tool&#39;s needs). It only records a method and bytecode instruction index.
 387      */
 388     class Jvms {
 389         Jvms(Method method, int bci) {
 390             this.method = method;
 391             this.bci = bci;
 392         }
 393         final public Method method;
 394         final public int bci;
 395         final public String toString() {
 396             return &quot;@&quot; + bci + &quot; &quot; + method;
 397         }
 398     }
 399 
 400     /**
 401      * Representation of a lock elimination. Locks, corresponding to
 402      * synchronized blocks and method calls, may be eliminated if the object in
 403      * question is guaranteed to be used thread-locally.
 404      */
 405     class LockElimination extends BasicLogEvent {
 406 
 407         /**
 408          * Track all locations from which this lock was eliminated.
 409          */
 410         ArrayList&lt;Jvms&gt; jvms = new ArrayList&lt;&gt;(1);
 411 
 412         /**
 413          * The kind of lock (coarsened, nested, non-escaping, unknown).
 414          */
 415         final String kind;
 416 
 417         /**
 418          * The lock class (unlock, lock, unknown).
 419          */
 420         final String classId;
 421 
 422         /**
 423          * The precise type of lock.
 424          */
 425         final String tagName;
 426 
 427         LockElimination(String tagName, double start, String id, String kind, String classId) {
 428             super(start, id);
 429             this.kind = kind;
 430             this.classId = classId;
 431             this.tagName = tagName;
 432         }
 433 
 434         @Override
 435         public void print(PrintStream stream, boolean printID) {
 436             if (printID) {
 437                 stream.printf(&quot;%s &quot;, getId());
 438             }
 439             stream.printf(&quot;%s %s %s  %.3f &quot;, tagName, kind, classId, getStart());
 440             stream.print(jvms.toString());
 441             stream.print(&quot;\n&quot;);
 442         }
 443 
 444         void addJVMS(Method method, int bci) {
 445             jvms.add(new Jvms(method, bci));
 446         }
 447 
 448     }
 449 
 450     /**
 451      * A list of log events. This is populated with the events found in the
 452      * compilation log file during parsing.
 453      */
 454     private ArrayList&lt;LogEvent&gt; events = new ArrayList&lt;&gt;();
 455 
 456     /**
 457      * Map compilation log IDs to type names.
 458      */
 459     private HashMap&lt;String, String&gt; types = new HashMap&lt;&gt;();
 460 
 461     /**
 462      * Map compilation log IDs to methods.
 463      */
 464     private HashMap&lt;String, Method&gt; methods = new HashMap&lt;&gt;();
 465 
 466     /**
 467      * Map compilation IDs ({@see #makeId()}) to newly created nmethods.
 468      */
 469     private LinkedHashMap&lt;String, NMethod&gt; nmethods = new LinkedHashMap&lt;&gt;();
 470 
 471     /**
 472      * Map compilation task IDs {@see #makeId()}) to {@link Compilation}
 473      * objects.
 474      */
 475     private HashMap&lt;String, Compilation&gt; compiles = new HashMap&lt;&gt;();
 476 
 477     /**
 478      * Track compilation failure reasons.
 479      */
 480     private String failureReason;
 481 
 482     /**
 483      * The current bytecode instruction index.
 484      */
 485     private int current_bci;
 486 
 487     /**
 488      * The current bytecode instruction.
 489      */
 490     private int current_bytecode;
 491 
 492     /**
 493      * A sequence of {@link CallSite}s representing a call stack. A scope
 494      * typically holds several {@link CallSite}s that represent calls
 495      * originating from that scope.
 496      *
 497      * New scopes are typically pushed when parse log events are encountered
 498      * ({@see #startElement()}) and popped when parsing of a given Java method
 499      * is done ({@see #endElement()}). Parsing events can be nested. Several
 500      * other events add information to scopes ({@see #startElement()}).
 501      */
 502     private Deque&lt;CallSite&gt; scopes = new ArrayDeque&lt;&gt;();
 503 
 504     /**
 505      * The current compilation.
 506      */
 507     private Compilation compile;
 508 
 509     /**
 510      * The {@linkplain CallSite compilation scope} currently in focus.
 511      */
 512     private CallSite site;
 513 
 514     /**
 515      * The {@linkplain CallSite method handle call site} currently under
 516      * observation.
 517      */
 518     private CallSite methodHandleSite;
 519 
 520     /**
 521      * Keep track of potentially nested compiler {@linkplain Phase phases}.
 522      */
 523     private Deque&lt;Phase&gt; phaseStack = new ArrayDeque&lt;&gt;();
 524 
 525     /**
 526      * The {@linkplain LockElimination lock elimination event} currently being
 527      * processed.
 528      */
 529     private LockElimination currentLockElimination;
 530 
 531     /**
 532      * The {@linkplain UncommonTrapEvent uncommon trap event} currently being
 533      * processed.
 534      */
 535     private UncommonTrapEvent currentTrap;
 536 
 537     /**
 538      * During the processing of a late inline event, this stack holds the
 539      * {@link CallSite}s that represent the inlining event&#39;s call stack.
 540      */
 541     private Deque&lt;CallSite&gt; lateInlineScope;
 542 
 543     /**
 544      * Denote whether a late inlining event is currently being processed.
 545      */
 546     private boolean lateInlining;
 547 
 548     /**
 549      * A document locator to provide better error messages: this allows the
 550      * tool to display in which line of the log file the problem occurred.
 551      */
 552     private Locator locator;
 553 
 554     /**
 555      * Callback for the SAX framework to set the document locator.
 556      */
 557     @Override
 558     public void setDocumentLocator(Locator locator) {
 559         this.locator = locator;
 560     }
 561 
 562     /**
 563      * Report an internal error explicitly raised, i.e., not derived from an
 564      * exception.
 565      *
 566      * @param msg The error message to report.
 567      */
 568     private void reportInternalError(String msg) {
 569         reportInternalError(msg, null);
 570     }
 571 
 572     /**
 573      * Report an internal error derived from an exception.
 574      *
 575      * @param msg The beginning of the error message to report. The message
 576      * from the exception will be appended to this.
 577      * @param e The exception that led to the internal error.
 578      */
 579     private void reportInternalError(String msg, Exception e) {
 580         if (locator != null) {
 581             msg += &quot; at &quot; + locator.getLineNumber() + &quot;:&quot; + locator.getColumnNumber();
 582             if (e != null) {
 583                 msg += &quot; - &quot; + e.getMessage();
 584             }
 585         }
 586         if (e != null) {
 587             throw new Error(msg, e);
 588         } else {
 589             throw new Error(msg);
 590         }
 591     }
 592 
 593     /**
 594      * Parse a long hexadecimal address into a {@code long} value. As Java only
 595      * supports positive {@code long} values, extra error handling and parsing
 596      * logic is provided.
 597      */
 598     long parseLong(String l) {
 599         try {
 600             return Long.decode(l).longValue();
 601         } catch (NumberFormatException nfe) {
 602             int split = l.length() - 8;
 603             String s1 = &quot;0x&quot; + l.substring(split);
 604             String s2 = l.substring(0, split);
 605             long v1 = Long.decode(s1).longValue() &amp; 0xffffffffL;
 606             long v2 = (Long.decode(s2).longValue() &amp; 0xffffffffL) &lt;&lt; 32;
 607             if (!l.equals(&quot;0x&quot; + Long.toHexString(v1 + v2))) {
 608                 System.out.println(l);
 609                 System.out.println(s1);
 610                 System.out.println(s2);
 611                 System.out.println(v1);
 612                 System.out.println(v2);
 613                 System.out.println(Long.toHexString(v1 + v2));
 614                 reportInternalError(&quot;bad conversion&quot;);
 615             }
 616             return v1 + v2;
 617         }
 618     }
 619 
 620     /**
 621      * Entry point for log file parsing with a file name.
 622      *
 623      * @param file The name of the log file to parse.
 624      * @param cleanup Whether to perform bad XML cleanup during parsing (this
 625      * is relevant for some log files generated by the 1.5 JVM).
 626      * @return a list of {@link LogEvent} instances describing the events found
 627      * in the log file.
 628      */
 629     public static ArrayList&lt;LogEvent&gt; parse(String file, boolean cleanup) throws Exception {
 630         return parse(new FileReader(file), cleanup);
 631     }
 632 
 633     /**
 634      * Entry point for log file parsing with a file reader.
 635      * {@link #parse(String,boolean)}
 636      */
 637     public static ArrayList&lt;LogEvent&gt; parse(Reader reader, boolean cleanup) throws Exception {
 638         // Create the XML input factory
 639         SAXParserFactory factory = SAXParserFactory.newInstance();
 640 
 641         // Create the XML LogEvent reader
 642         SAXParser p = factory.newSAXParser();
 643 
 644         if (cleanup) {
 645             // some versions of the log have slightly malformed XML, so clean it
 646             // up before passing it to SAX
 647             reader = new LogCleanupReader(reader);
 648         }
 649 
 650         LogParser log = new LogParser();
 651         try {
 652             p.parse(new InputSource(reader), log);
 653         } catch (Throwable th) {
 654             th.printStackTrace();
 655             // Carry on with what we&#39;ve got...
 656         }
 657 
 658         // Associate compilations with their NMethods and other kinds of events
 659         for (LogEvent e : log.events) {
 660             if (e instanceof BasicLogEvent) {
 661                 BasicLogEvent ble = (BasicLogEvent) e;
 662                 Compilation c = log.compiles.get(ble.getId());
 663                 if (c == null) {
 664                     if (!(ble instanceof NMethod)) {
 665                         throw new InternalError(&quot;only nmethods should have a null compilation, here&#39;s a &quot; + ble.getClass());
 666                     }
 667                     continue;
 668                 }
 669                 ble.setCompilation(c);
 670                 if (ble instanceof NMethod) {
 671                     c.setNMethod((NMethod) ble);
 672                 }
 673             }
 674         }
 675 
 676         return log.events;
 677     }
 678 
 679     /**
 680      * Retrieve a given attribute&#39;s value from a collection of XML tag
 681      * attributes. Report an error if the requested attribute is not found.
 682      *
 683      * @param attr A collection of XML tag attributes.
 684      * @param name The name of the attribute the value of which is to be found.
 685      * @return The value of the requested attribute, or {@code null} if it was
 686      * not found.
 687      */
 688     String search(Attributes attr, String name) {
 689         String result = attr.getValue(name);
 690         if (result != null) {
 691             return result;
 692         } else {
 693             reportInternalError(&quot;can&#39;t find &quot; + name);
 694             return null;
 695         }
 696     }
 697 
 698     /**
 699      * Retrieve a given attribute&#39;s value from a collection of XML tag
 700      * attributes. Return a default value if the requested attribute is not
 701      * found.
 702      *
 703      * @param attr A collection of XML tag attributes.
 704      * @param name The name of the attribute the value of which is to be found.
 705      * @param defaultValue The default value to return if the attribute is not
 706      * found.
 707      * @return The value of the requested attribute, or the default value if it
 708      * was not found.
 709      */
 710     String search(Attributes attr, String name, String defaultValue) {
 711         String result = attr.getValue(name);
 712         if (result != null) {
 713             return result;
 714         }
 715         return defaultValue;
 716     }
 717 
 718     /**
 719      * Map a type ID from the compilation log to an actual type name. In case
 720      * the type represents an internal array type descriptor, return a
 721      * Java-level name. If the type ID cannot be mapped to a name, raise an
 722      * error.
 723      */
 724     String type(String id) {
 725         String result = types.get(id);
 726         String remapped = type2printableMap.get(result);
 727         if (remapped != null) {
 728             return remapped;
 729         }
 730         return result;
 731     }
 732 
 733     /**
 734      * Register a mapping from log file type ID to type name.
 735      */
 736     void type(String id, String name) {
 737         assert type(id) == null;
 738         types.put(id, name);
 739     }
 740 
 741     /**
 742      * Map a log file type ID to an internal type declarator.
 743      */
 744     String sigtype(String id) {
 745         String result = types.get(id);
 746         String remapped = type2vmtypeMap.get(result);
 747         if (remapped != null) {
 748             return remapped;
 749         }
 750         if (result == null) {
 751             reportInternalError(id);
 752         }
 753         if (result.charAt(0) == &#39;[&#39;) {
 754             return result;
 755         }
 756         return &quot;L&quot; + result + &quot;;&quot;;
 757     }
 758 
 759     /**
 760      * Retrieve a method based on the log file ID it was registered under.
 761      * Raise an error if the ID does not map to a method.
 762      */
 763     Method method(String id) {
 764         Method result = methods.get(id);
 765         if (result == null) {
 766             reportInternalError(id);
 767         }
 768         return result;
 769     }
 770 
 771     /**
 772      * From a compilation ID and kind, assemble a compilation ID for inclusion
 773      * in the output.
 774      *
 775      * @param atts A collection of XML attributes from which the required
 776      * attributes are retrieved.
 777      */
 778     public String makeId(Attributes atts) {
 779         String id = atts.getValue(&quot;compile_id&quot;);
 780         String kind = atts.getValue(&quot;kind&quot;);
 781         if (kind != null &amp;&amp; kind.equals(&quot;osr&quot;)) {
 782             id += &quot;%&quot;;
 783         }
 784         return id;
 785     }
 786 
 787     /**
 788      * Process the start of a compilation log XML element.&lt;ul&gt;
 789      * &lt;li&gt;&lt;b&gt;phase:&lt;/b&gt; record the beginning of a compilation phase, pushing
 790      * it on the {@linkplain #phaseStack phase stack} and collecting
 791      * information about the compiler graph.&lt;/li&gt;
 792      * &lt;li&gt;&lt;b&gt;phase_done:&lt;/b&gt; record the end of a compilation phase, popping it
 793      * off the {@linkplain #phaseStack phase stack} and collecting information
 794      * about the compiler graph (number of nodes and live nodes).&lt;/li&gt;
 795      * &lt;li&gt;&lt;b&gt;task:&lt;/b&gt; register the start of a new compilation.&lt;/li&gt;
 796      * &lt;li&gt;&lt;b&gt;type:&lt;/b&gt; register a type.&lt;/li&gt;
 797      * &lt;li&gt;&lt;b&gt;bc:&lt;/b&gt; note the current bytecode index and instruction name,
 798      * updating {@link #current_bci} and {@link #current_bytecode}.&lt;/li&gt;
 799      * &lt;li&gt;&lt;b&gt;klass:&lt;/b&gt; register a type (class).&lt;/li&gt;
 800      * &lt;li&gt;&lt;b&gt;method:&lt;/b&gt; register a Java method.&lt;/li&gt;
 801      * &lt;li&gt;&lt;b&gt;call:&lt;/b&gt; process a call, populating {@link #site} with the
 802      * appropriate data.&lt;/li&gt;
 803      * &lt;li&gt;&lt;b&gt;regalloc:&lt;/b&gt; record the register allocator&#39;s trip count in the
 804      * {@linkplain #compile current compilation}.&lt;/li&gt;
 805      * &lt;li&gt;&lt;b&gt;inline_fail:&lt;/b&gt; record the reason for a failed inline
 806      * operation.&lt;/li&gt;
 807      * &lt;li&gt;&lt;b&gt;inline_success:&lt;/b&gt; record a successful inlining operation,
 808      * noting the success reason in the {@linkplain #site call site}.&lt;/li&gt;
 809      * &lt;li&gt;&lt;b&gt;failure:&lt;/b&gt; note a compilation failure, storing the reason
 810      * description in {@link #failureReason}.&lt;/li&gt;
 811      * &lt;li&gt;&lt;b&gt;task_done:&lt;/b&gt; register the end of a compilation, recording time
 812      * stamp and success information.&lt;/li&gt;
 813      * &lt;li&gt;&lt;b&gt;make_not_entrant:&lt;/b&gt; deal with making a native method
 814      * non-callable (e.g., during an OSR compilation, if there are still
 815      * activations) or a zombie (when the method can be deleted).&lt;/li&gt;
 816      * &lt;li&gt;&lt;b&gt;uncommon_trap:&lt;/b&gt; process an uncommon trap, setting the
 817      * {@link #currentTrap} field.&lt;/li&gt;
 818      * &lt;li&gt;&lt;b&gt;eliminate_lock:&lt;/b&gt; record the start of a lock elimination,
 819      * setting the {@link #currentLockElimination} event.&lt;/li&gt;
 820      * &lt;li&gt;&lt;b&gt;late_inline:&lt;/b&gt; start processing a late inline decision:
 821      * initialize the {@linkplain #lateInlineScope inline scope stack}, create
 822      * an {@linkplain #site initial scope} with a bogus bytecode index and the
 823      * right inline ID, and push the scope with the inline ID attached. Note
 824      * that most of late inlining processing happens in
 825      * {@link #endElement(String,String,String)}.&lt;/li&gt;
 826      * &lt;li&gt;&lt;b&gt;jvms:&lt;/b&gt; record a {@linkplain Jvms JVMState}. Depending on the
 827      * context in which this event is encountered, this can mean adding
 828      * information to the currently being processed trap, lock elimination, or
 829      * inlining operation.&lt;/li&gt;
 830      * &lt;li&gt;&lt;b&gt;inline_id:&lt;/b&gt; set the inline ID in the
 831      * {@linkplain #site current call site}.&lt;/li&gt;
 832      * &lt;li&gt;&lt;b&gt;nmethod:&lt;/b&gt; record the creation of a new {@link NMethod} and
 833      * store it in the {@link #nmethods} map.&lt;/li&gt;
 834      * &lt;li&gt;&lt;b&gt;parse:&lt;/b&gt; begin parsing a Java method&#39;s bytecode and
 835      * transforming it into an initial compiler IR graph.&lt;/li&gt;
 836      * &lt;li&gt;&lt;b&gt;parse_done:&lt;/b&gt; finish parsing a Java method&#39;s bytecode.&lt;/li&gt;
 837      * &lt;/ul&gt;
 838      */
 839     @Override
 840     public void startElement(String uri, String localName, String qname, Attributes atts) {
 841         if (qname.equals(&quot;phase&quot;)) {
 842             Phase p = new Phase(search(atts, &quot;name&quot;),
 843                     Double.parseDouble(search(atts, &quot;stamp&quot;)),
 844                     Integer.parseInt(search(atts, &quot;nodes&quot;, &quot;0&quot;)),
 845                     Integer.parseInt(search(atts, &quot;live&quot;, &quot;0&quot;)));
 846             phaseStack.push(p);
 847         } else if (qname.equals(&quot;phase_done&quot;)) {
 848             Phase p = phaseStack.pop();
 849             String phaseName = search(atts, &quot;name&quot;, null);
 850             if (phaseName != null &amp;&amp; !p.getId().equals(phaseName)) {
 851                 System.out.println(&quot;phase: &quot; + p.getId());
 852                 reportInternalError(&quot;phase name mismatch&quot;);
 853             }
 854             p.setEnd(Double.parseDouble(search(atts, &quot;stamp&quot;)));
 855             p.setEndNodes(Integer.parseInt(search(atts, &quot;nodes&quot;, &quot;0&quot;)));
 856             p.setEndLiveNodes(Integer.parseInt(search(atts, &quot;live&quot;, &quot;0&quot;)));
 857             compile.getPhases().add(p);
 858         } else if (qname.equals(&quot;task&quot;)) {
 859             String id = makeId(atts);
 860 
 861             // Create the new Compilation instance and populate it with readily
 862             // available data.
 863             compile = new Compilation(Integer.parseInt(search(atts, &quot;compile_id&quot;, &quot;-1&quot;)));
 864             compile.setStart(Double.parseDouble(search(atts, &quot;stamp&quot;)));
 865             compile.setICount(search(atts, &quot;count&quot;, &quot;0&quot;));
 866             compile.setBCount(search(atts, &quot;backedge_count&quot;, &quot;0&quot;));
 867             compile.setBCI(Integer.parseInt(search(atts, &quot;osr_bci&quot;, &quot;-1&quot;)));
 868             String compiler = atts.getValue(&quot;compiler&quot;);
<a name="1" id="anc1"></a><span class="line-modified"> 869             if (compiler == null) {</span>
<span class="line-modified"> 870                 compiler = &quot;&quot;;</span>


 871             }
<a name="2" id="anc2"></a><span class="line-removed"> 872             compile.setCompiler(compiler);</span>
<span class="line-removed"> 873 </span>
 874             // Extract the name of the compiled method.
 875             String[] parts = spacePattern.split(atts.getValue(&quot;method&quot;));
 876             String methodName = parts[0] + &quot;::&quot; + parts[1];
 877 
 878             // Continue collecting compilation meta-data.
 879             String kind = atts.getValue(&quot;compile_kind&quot;);
 880             if (kind == null) {
 881                 kind = &quot;normal&quot;;
 882             }
 883             if (kind.equals(&quot;osr&quot;)) {
 884                 compile.setOsr(true);
 885             } else if (kind.equals(&quot;c2i&quot;)) {
 886                 compile.setSpecial(&quot;--- adapter &quot; + methodName);
 887             } else {
 888                 compile.setSpecial(compile.getId() + &quot; &quot; + methodName + &quot; (0 bytes)&quot;);
 889             }
 890 
 891             // Build a dummy method to stuff in the Compilation at the
 892             // beginning.
 893             Method m = new Method();
 894             m.setHolder(parts[0]);
 895             m.setName(parts[1]);
 896             m.setSignature(parts[2]);
 897             m.setFlags(&quot;0&quot;);
 898             m.setBytes(search(atts, &quot;bytes&quot;, &quot;unknown&quot;));
<a name="3" id="anc3"></a>
 899             compile.setMethod(m);
 900             events.add(compile);
 901             compiles.put(id, compile);
 902             site = compile.getCall();
 903         } else if (qname.equals(&quot;type&quot;)) {
 904             type(search(atts, &quot;id&quot;), search(atts, &quot;name&quot;));
 905         } else if (qname.equals(&quot;bc&quot;)) {
 906             current_bci = Integer.parseInt(search(atts, &quot;bci&quot;));
 907             current_bytecode = Integer.parseInt(search(atts, &quot;code&quot;));
 908         } else if (qname.equals(&quot;klass&quot;)) {
 909             type(search(atts, &quot;id&quot;), search(atts, &quot;name&quot;));
 910         } else if (qname.equals(&quot;method&quot;)) {
 911             String id = search(atts, &quot;id&quot;);
 912             Method m = new Method();
 913             m.setHolder(type(search(atts, &quot;holder&quot;)));
 914             m.setName(search(atts, &quot;name&quot;));
 915             m.setReturnType(type(search(atts, &quot;return&quot;)));
 916             String arguments = atts.getValue(&quot;arguments&quot;);;
 917             if (arguments == null) {
 918                 m.setSignature(&quot;()&quot; + sigtype(atts.getValue(&quot;return&quot;)));
 919             } else {
 920                 String[] args = spacePattern.split(arguments);
 921                 StringBuilder sb = new StringBuilder(&quot;(&quot;);
 922                 for (int i = 0; i &lt; args.length; i++) {
 923                     sb.append(sigtype(args[i]));
 924                 }
 925                 sb.append(&quot;)&quot;);
 926                 sb.append(sigtype(atts.getValue(&quot;return&quot;)));
 927                 m.setSignature(sb.toString());
 928             }
 929 
 930             if (search(atts, &quot;unloaded&quot;, &quot;0&quot;).equals(&quot;0&quot;)) {
 931                m.setBytes(search(atts, &quot;bytes&quot;));
 932                m.setIICount(search(atts, &quot;iicount&quot;));
 933                m.setFlags(search(atts, &quot;flags&quot;));
 934             }
<a name="4" id="anc4"></a>





 935             methods.put(id, m);
 936         } else if (qname.equals(&quot;call&quot;)) {
 937             if (methodHandleSite != null) {
 938                 methodHandleSite = null;
 939             }
 940             Method m = method(search(atts, &quot;method&quot;));
 941             if (lateInlining &amp;&amp; scopes.size() == 0) {
 942                 // re-attempting already seen call site (late inlining for MH invokes)
 943                 if (m != site.getMethod()) {
 944                     if (current_bci != site.getBci()) {
 945                         System.err.println(m + &quot; bci: &quot; + current_bci);
 946                         System.err.println(site.getMethod() +  &quot; bci: &quot; + site.getBci());
 947                         reportInternalError(&quot;bci mismatch after late inlining&quot;);
 948                     }
 949                     site.setMethod(m);
 950                 }
 951             } else {
 952                 // We&#39;re dealing with a new call site; the called method is
 953                 // likely to be parsed next.
 954                 site = new CallSite(current_bci, m);
 955             }
 956             site.setCount(Integer.parseInt(search(atts, &quot;count&quot;, &quot;0&quot;)));
 957             String receiver = atts.getValue(&quot;receiver&quot;);
 958             if (receiver != null) {
 959                 site.setReceiver(type(receiver));
 960                 site.setReceiver_count(Integer.parseInt(search(atts, &quot;receiver_count&quot;)));
 961             }
 962             int methodHandle = Integer.parseInt(search(atts, &quot;method_handle_intrinsic&quot;, &quot;0&quot;));
 963             if (lateInlining &amp;&amp; scopes.size() == 0) {
 964                 // The call was already added before this round of late
 965                 // inlining. Ignore.
 966             } else if (methodHandle == 0) {
 967                 scopes.peek().add(site);
 968             } else {
 969                 // method handle call site can be followed by another
 970                 // call (in case it is inlined). If that happens we
 971                 // discard the method handle call site. So we keep
 972                 // track of it but don&#39;t add it to the list yet.
 973                 methodHandleSite = site;
 974             }
 975         } else if (qname.equals(&quot;intrinsic&quot;)) {
 976             String id = atts.getValue(&quot;id&quot;);
 977             assert id != null : &quot;intrinsic id is null&quot;;
 978             CallSite cs = (site != null) ? site : scopes.peek();
 979             assert cs != null : &quot;no CallSite?&quot;;
 980             cs.setIntrinsicName(id);
 981         } else if (qname.equals(&quot;regalloc&quot;)) {
 982             compile.setAttempts(Integer.parseInt(search(atts, &quot;attempts&quot;)));
 983         } else if (qname.equals(&quot;inline_fail&quot;)) {
 984             if (methodHandleSite != null) {
 985                 scopes.peek().add(methodHandleSite);
 986                 methodHandleSite = null;
 987             }
 988             if (lateInlining &amp;&amp; scopes.size() == 0) {
 989                 site.setReason(&quot;fail: &quot; + search(atts, &quot;reason&quot;));
 990                 lateInlining = false;
 991             } else {
 992                 scopes.peek().last().setReason(&quot;fail: &quot; + search(atts, &quot;reason&quot;));
 993             }
 994         } else if (qname.equals(&quot;inline_success&quot;)) {
 995             if (methodHandleSite != null) {
 996                 reportInternalError(&quot;method handle site should have been replaced&quot;);
 997             }
 998             site.setReason(&quot;succeed: &quot; + search(atts, &quot;reason&quot;));
 999         } else if (qname.equals(&quot;failure&quot;)) {
1000             failureReason = search(atts, &quot;reason&quot;);
1001         } else if (qname.equals(&quot;task_done&quot;)) {
1002             compile.setEnd(Double.parseDouble(search(atts, &quot;stamp&quot;)));
1003             if (Integer.parseInt(search(atts, &quot;success&quot;)) == 0) {
1004                 compile.setFailureReason(failureReason);
1005                 failureReason = null;
1006             }
1007         } else if (qname.equals(&quot;make_not_entrant&quot;)) {
1008             String id = makeId(atts);
1009             NMethod nm = nmethods.get(id);
1010             if (nm == null) reportInternalError(&quot;nm == null&quot;);
1011             LogEvent e = new MakeNotEntrantEvent(Double.parseDouble(search(atts, &quot;stamp&quot;)), id,
1012                                                  atts.getValue(&quot;zombie&quot;) != null, nm);
1013             events.add(e);
1014         } else if (qname.equals(&quot;uncommon_trap&quot;)) {
1015             String id = atts.getValue(&quot;compile_id&quot;);
1016             if (id != null) {
1017                 id = makeId(atts);
1018                 currentTrap = new UncommonTrapEvent(Double.parseDouble(search(atts, &quot;stamp&quot;)),
1019                         id,
1020                         atts.getValue(&quot;reason&quot;),
1021                         atts.getValue(&quot;action&quot;),
1022                         Integer.parseInt(search(atts, &quot;count&quot;, &quot;0&quot;)));
1023                 events.add(currentTrap);
1024             } else {
1025                 if (atts.getValue(&quot;method&quot;) != null) {
1026                     // These are messages from ciTypeFlow that don&#39;t
1027                     // actually correspond to generated code.
1028                     return;
1029                 }
1030                 try {
1031                     UncommonTrap unc = new UncommonTrap(Integer.parseInt(search(atts, &quot;bci&quot;)),
1032                             search(atts, &quot;reason&quot;),
1033                             search(atts, &quot;action&quot;),
1034                             bytecodes[current_bytecode]);
1035                     if (scopes.size() == 0) {
1036                         // There may be a dangling site not yet in scopes after a late_inline
1037                         if (site != null) {
1038                             site.add(unc);
1039                         } else {
1040                             reportInternalError(&quot;scope underflow&quot;);
1041                         }
1042                     } else {
1043                         scopes.peek().add(unc);
1044                     }
1045                 } catch (Error e) {
1046                     e.printStackTrace();
1047                 }
1048             }
1049         } else if (qname.startsWith(&quot;eliminate_lock&quot;)) {
1050             String id = atts.getValue(&quot;compile_id&quot;);
1051             if (id != null) {
1052                 id = makeId(atts);
1053                 String kind = atts.getValue(&quot;kind&quot;);
1054                 String classId = atts.getValue(&quot;class_id&quot;);
1055                 currentLockElimination = new LockElimination(qname, Double.parseDouble(search(atts, &quot;stamp&quot;)), id, kind, classId);
1056                 events.add(currentLockElimination);
1057             }
1058         } else if (qname.equals(&quot;late_inline&quot;)) {
1059             long inlineId = 0;
1060             try {
1061                 inlineId = Long.parseLong(search(atts, &quot;inline_id&quot;));
1062             } catch (InternalError ex) {
1063                 // Log files from older hotspots may lack inline_id,
1064                 // and zero is an acceptable substitute that allows processing to continue.
1065             }
1066             lateInlineScope = new ArrayDeque&lt;&gt;();
1067             Method m = method(search(atts, &quot;method&quot;));
1068             site = new CallSite(-999, m);
1069             site.setInlineId(inlineId);
1070             lateInlineScope.push(site);
1071         } else if (qname.equals(&quot;jvms&quot;)) {
1072             // &lt;jvms bci=&#39;4&#39; method=&#39;java/io/DataInputStream readChar ()C&#39; bytes=&#39;40&#39; count=&#39;5815&#39; iicount=&#39;20815&#39;/&gt;
1073             if (currentTrap != null) {
1074                 String[] parts = spacePattern.split(atts.getValue(&quot;method&quot;));
1075                 currentTrap.addMethodAndBCI(parts[0].replace(&#39;/&#39;, &#39;.&#39;) + &#39;.&#39; + parts[1] + parts[2], Integer.parseInt(atts.getValue(&quot;bci&quot;)));
1076             } else if (currentLockElimination != null) {
1077                   currentLockElimination.addJVMS(method(atts.getValue(&quot;method&quot;)), Integer.parseInt(atts.getValue(&quot;bci&quot;)));
1078             } else if (lateInlineScope != null) {
1079                 current_bci = Integer.parseInt(search(atts, &quot;bci&quot;));
1080                 Method m = method(search(atts, &quot;method&quot;));
1081                 site = new CallSite(current_bci, m);
1082                 lateInlineScope.push(site);
1083             } else {
1084                 // Ignore &lt;eliminate_allocation type=&#39;667&#39;&gt;,
1085                 //        &lt;replace_string_concat arguments=&#39;2&#39; string_alloc=&#39;0&#39; multiple=&#39;0&#39;&gt;
1086             }
1087         } else if (qname.equals(&quot;inline_id&quot;)) {
1088             if (methodHandleSite != null) {
1089                 reportInternalError(&quot;method handle site should have been replaced&quot;);
1090             }
1091             long id = Long.parseLong(search(atts, &quot;id&quot;));
1092             site.setInlineId(id);
1093         } else if (qname.equals(&quot;nmethod&quot;)) {
1094             String id = makeId(atts);
1095             NMethod nm = new NMethod(Double.parseDouble(search(atts, &quot;stamp&quot;)),
1096                     id,
1097                     parseLong(atts.getValue(&quot;address&quot;)),
1098                     parseLong(atts.getValue(&quot;size&quot;)));
1099             String level = atts.getValue(&quot;level&quot;);
1100             if (level != null) {
1101                 nm.setLevel(parseLong(level));
1102             }
<a name="5" id="anc5"></a>

1103             nmethods.put(id, nm);
1104             events.add(nm);
1105         } else if (qname.equals(&quot;parse&quot;)) {
1106             if (failureReason != null &amp;&amp; scopes.size() == 0 &amp;&amp; !lateInlining) {
1107                 // A compilation just failed, and we&#39;re back at a top
1108                 // compilation scope.
1109                 failureReason = null;
1110                 compile.reset();
1111                 site = compile.getCall();
1112             }
1113 
1114             // Error checking.
1115             if (methodHandleSite != null) {
1116                 reportInternalError(&quot;method handle site should have been replaced&quot;);
1117             }
1118             Method m = method(search(atts, &quot;method&quot;)); // this is the method being parsed
1119             if (lateInlining &amp;&amp; scopes.size() == 0) {
1120                 if (site.getMethod() != m) {
1121                     reportInternalError(&quot;Unexpected method mismatch during late inlining (method at call site: &quot; +
1122                         site.getMethod() + &quot;, method being parsed: &quot; + m + &quot;)&quot;);
1123                 }
1124             }
1125 
1126             if (scopes.size() == 0 &amp;&amp; !lateInlining) {
1127                 // The method being parsed is actually the method being
1128                 // compiled; i.e., we&#39;re dealing with a compilation top scope,
1129                 // which we must consequently push to the scopes stack.
1130                 compile.setMethod(m);
1131                 scopes.push(site);
1132             } else {
1133                 // The method being parsed is *not* the current compilation&#39;s
1134                 // top scope; i.e., we&#39;re dealing with an actual call site
1135                 // in the top scope or somewhere further down a call stack.
1136                 if (site.getMethod() == m) {
1137                     // We&#39;re dealing with monomorphic inlining that didn&#39;t have
1138                     // to be narrowed down, because the receiver was known
1139                     // beforehand.
1140                     scopes.push(site);
1141                 } else if (scopes.peek().getCalls().size() &gt; 2 &amp;&amp; m == scopes.peek().lastButOne().getMethod()) {
1142                     // We&#39;re dealing with an at least bimorphic call site, and
1143                     // the compiler has now decided to parse the last-but-one
1144                     // method. The last one may already have been parsed for
1145                     // inlining.
1146                     scopes.push(scopes.peek().lastButOne());
1147                 } else {
1148                     // The method has been narrowed down to the one we&#39;re now
1149                     // going to parse, which is inlined here. It&#39;s monomorphic
1150                     // inlining, but was not immediately clear as such.
1151                     //
1152                     // C1 prints multiple method tags during inlining when it
1153                     // narrows the method being inlined. Example:
1154                     //   ...
1155                     //   &lt;method id=&quot;813&quot; holder=&quot;694&quot; name=&quot;toString&quot; return=&quot;695&quot; flags=&quot;1&quot; bytes=&quot;36&quot; iicount=&quot;1&quot;/&gt;
1156                     //   &lt;call method=&quot;813&quot; instr=&quot;invokevirtual&quot;/&gt;
1157                     //   &lt;inline_success reason=&quot;receiver is statically known&quot;/&gt;
1158                     //   &lt;method id=&quot;814&quot; holder=&quot;792&quot; name=&quot;toString&quot; return=&quot;695&quot; flags=&quot;1&quot; bytes=&quot;5&quot; iicount=&quot;3&quot;/&gt;
1159                     //   &lt;parse method=&quot;814&quot;&gt;
1160                     //   ...
1161                     site.setMethod(m);
1162                     scopes.push(site);
1163                 }
1164             }
1165         } else if (qname.equals(&quot;parse_done&quot;)) {
1166             // Attach collected information about IR nodes to the current
1167             // parsing scope before it&#39;s popped off the stack in endElement()
1168             // (see where the parse tag is handled).
1169             CallSite call = scopes.peek();
1170             call.setEndNodes(Integer.parseInt(search(atts, &quot;nodes&quot;, &quot;0&quot;)));
1171             call.setEndLiveNodes(Integer.parseInt(search(atts, &quot;live&quot;, &quot;0&quot;)));
1172             call.setTimeStamp(Double.parseDouble(search(atts, &quot;stamp&quot;)));
1173         }
1174     }
1175 
1176     /**
1177      * Process the end of a compilation log XML element.&lt;ul&gt;
1178      * &lt;li&gt;&lt;b&gt;parse:&lt;/b&gt; finish transforming a Java method&#39;s bytecode
1179      * instructions to an initial compiler IR graph.&lt;/li&gt;
1180      * &lt;li&gt;&lt;b&gt;uncommon_trap:&lt;/b&gt; record the end of processing an uncommon trap,
1181      * resetting {@link #currentTrap}.&lt;/li&gt;
1182      * &lt;li&gt;&lt;b&gt;eliminate_lock:&lt;/b&gt; record the end of a lock elimination,
1183      * resetting {@link #currentLockElimination}.&lt;/li&gt;
1184      * &lt;li&gt;&lt;b&gt;late_inline:&lt;/b&gt; the closing tag for late_inline does not denote
1185      * the end of a late inlining operation, but the end of the descriptive log
1186      * data given at its beginning. That is, we&#39;re now in the position to
1187      * assemble details about the inlining chain (bytecode instruction index in
1188      * caller, called method). The {@link #lateInlining} flag is set to
1189      * {@code true} here. (It will be reset when parsing the inlined methods is
1190      * done; this happens for the successful case in this method as well, when
1191      * {@code parse} elements are processed; and for inlining failures, in
1192      * {@link #startElement(String,String,String,Attributes)}, when {@code inline_fail} elements are
1193      * processed.)&lt;/li&gt;
1194      * &lt;li&gt;&lt;b&gt;task:&lt;/b&gt; perform cleanup at the end of a compilation. Note that
1195      * the explicit {@code task_done} event is handled in
1196      * {@link #startElement(String,String,String,Attributes)}.&lt;/li&gt;
1197      * &lt;/ul&gt;
1198      */
1199     @Override
1200     public void endElement(String uri, String localName, String qname) {
1201         try {
1202             if (qname.equals(&quot;parse&quot;)) {
1203                 // Finish dealing with the current call scope. If no more are
1204                 // left, no late inlining can be going on.
1205                 scopes.pop();
1206                 if (scopes.size() == 0) {
1207                     lateInlining = false;
1208                 }
1209             } else if (qname.equals(&quot;uncommon_trap&quot;)) {
1210                 currentTrap = null;
1211             } else if (qname.startsWith(&quot;eliminate_lock&quot;)) {
1212                 currentLockElimination = null;
1213             } else if (qname.equals(&quot;late_inline&quot;)) {
1214                 // Populate late inlining info.
1215                 if (scopes.size() != 0) {
1216                     reportInternalError(&quot;scopes should be empty for late inline&quot;);
1217                 }
1218                 // late inline scopes are specified in reverse order:
1219                 // compiled method should be on top of stack.
1220                 CallSite caller = lateInlineScope.pop();
1221                 Method m = compile.getMethod();
1222                 if (!m.equals(caller.getMethod())) {
1223                     reportInternalError(String.format(&quot;call site and late_inline info don&#39;t match:\n  method %s\n  caller method %s, bci %d&quot;, m, caller.getMethod(), current_bci));
1224                 }
1225 
1226                 // Walk down the inlining chain and assemble bci+callee info.
1227                 // This needs to be converted from caller+bci info contained in
1228                 // the late_inline data.
1229                 CallSite lateInlineSite = compile.getLateInlineCall();
1230                 ArrayDeque&lt;CallSite&gt; thisCallScopes = new ArrayDeque&lt;&gt;();
1231                 do {
1232                     current_bci = caller.getBci();
1233                     // Next inlined call.
1234                     caller = lateInlineScope.pop();
1235                     CallSite callee = new CallSite(current_bci, caller.getMethod());
1236                     callee.setInlineId(caller.getInlineId());
1237                     thisCallScopes.addLast(callee);
1238                     lateInlineSite.add(callee);
1239                     lateInlineSite = callee;
1240                 } while (!lateInlineScope.isEmpty());
1241 
1242                 site = compile.getCall().findCallSite(thisCallScopes);
1243                 if (site == null) {
1244                     // Call site could not be found - report the problem in detail.
1245                     System.err.println(&quot;call scopes:&quot;);
1246                     for (CallSite c : thisCallScopes) {
1247                         System.err.println(c.getMethod() + &quot; &quot; + c.getBci() + &quot; &quot; + c.getInlineId());
1248                     }
1249                     CallSite c = thisCallScopes.getLast();
1250                     if (c.getInlineId() != 0) {
1251                         System.err.println(&quot;Looking for call site in entire tree:&quot;);
1252                         ArrayDeque&lt;CallSite&gt; stack = compile.getCall().findCallSite2(c);
1253                         for (CallSite c2 : stack) {
1254                             System.err.println(c2.getMethod() + &quot; &quot; + c2.getBci() + &quot; &quot; + c2.getInlineId());
1255                         }
1256                     }
1257                     System.err.println(caller.getMethod() + &quot; bci: &quot; + current_bci);
1258                     reportInternalError(&quot;couldn&#39;t find call site&quot;);
1259                 }
1260                 lateInlining = true;
1261 
1262                 if (caller.getBci() != -999) {
1263                     System.out.println(caller.getMethod());
1264                     reportInternalError(&quot;broken late_inline info&quot;);
1265                 }
1266                 if (site.getMethod() != caller.getMethod()) {
1267                     if (site.getInlineId() == caller.getInlineId()) {
1268                         site.setMethod(caller.getMethod());
1269                     } else {
1270                         System.out.println(site.getMethod());
1271                         System.out.println(caller.getMethod());
1272                         reportInternalError(&quot;call site and late_inline info don&#39;t match&quot;);
1273                     }
1274                 }
1275                 // late_inline is followed by parse with scopes.size() == 0,
1276                 // &#39;site&#39; will be pushed to scopes.
1277                 lateInlineScope = null;
1278             } else if (qname.equals(&quot;task&quot;)) {
1279                 types.clear();
1280                 methods.clear();
1281                 site = null;
1282                 lateInlining = false;
1283             }
1284         } catch (Exception e) {
1285             reportInternalError(&quot;exception while processing end element&quot;, e);
1286         }
1287     }
1288 
1289     //
1290     // Handlers for problems that occur in XML parsing itself.
1291     //
1292 
1293     @Override
1294     public void warning(org.xml.sax.SAXParseException e) {
1295         System.err.println(e.getMessage() + &quot; at line &quot; + e.getLineNumber() + &quot;, column &quot; + e.getColumnNumber());
1296         e.printStackTrace();
1297     }
1298 
1299     @Override
1300     public void error(org.xml.sax.SAXParseException e) {
1301         System.err.println(e.getMessage() + &quot; at line &quot; + e.getLineNumber() + &quot;, column &quot; + e.getColumnNumber());
1302         e.printStackTrace();
1303     }
1304 
1305     @Override
1306     public void fatalError(org.xml.sax.SAXParseException e) {
1307         System.err.println(e.getMessage() + &quot; at line &quot; + e.getLineNumber() + &quot;, column &quot; + e.getColumnNumber());
1308         e.printStackTrace();
1309     }
1310 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/utils/LogCompilation/src/main/java/com/sun/hotspot/tools/compiler/CallSite.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package com.sun.hotspot.tools.compiler;
 26 
 27 import java.io.PrintStream;
 28 import java.util.ArrayDeque;
 29 import java.util.ArrayList;
 30 import java.util.List;
 31 
 32 /**
 33  * Representation of a compilation scope in a compilation log. This class is a
 34  * hybrid: its instances can represent original scopes of methods being
 35  * compiled, but are also used to represent call sites in given methods.
 36  */
 37 public class CallSite {
 38 
 39     /**
 40      * The index of the call in the caller. This will be 0 if this instance
 41      * represents a compilation root.
 42      */
 43     private int bci;
 44 
 45     /**
 46      * The method that is called at this call site. This will be {@code null}
 47      * if this instance represents a compilation root.
 48      */
 49     private Method method;
 50 
 51     /**
 52      * The invocation count for this call site.
 53      */
 54     private int count;
 55 
 56     /**
 57      * The receiver type of the call represented by this instance, if known.
 58      */
 59     private String receiver;
 60 
 61     /**
 62      * In case the {@linkplain receiver receiver type} of the call represented
 63      * by this instance is known, this is how often the type was encountered.
 64      */
 65     private int receiver_count;
 66 
 67     /**
 68      * The reason for a success or failure of an inlining operation at this
 69      * call site.
 70      */
 71     private String reason;
 72 
 73     /**
 74      * A list of all calls in this compilation scope.
 75      */
 76     private List&lt;CallSite&gt; calls;
 77 
 78     /**
 79      * Number of nodes in the graph at the end of parsing this compilation
 80      * scope.
 81      */
 82     private int endNodes;
 83 
 84     /**
 85      * Number of live nodes in the graph at the end of parsing this compilation
 86      * scope.
 87      */
 88     private int endLiveNodes;
 89 
 90     /**
 91      * Time in seconds since VM startup at which parsing this compilation scope
 92      * ended.
 93      */
 94     private double timeStamp;
 95 
 96     /**
 97      * The inline ID in case the call represented by this instance is inlined,
 98      * 0 otherwise.
 99      */
100     private long inlineId;
101 
102     /**
103      * List of uncommon traps in this compilation scope.
104      */
105     private List&lt;UncommonTrap&gt; traps;
106 
107     /**
108      * The name of the intrinsic at this call site.
109      */
110     private String intrinsicName;
111 
112     /**
113      * Default constructor: used to create an instance that represents the top
114      * scope of a compilation.
115      */
116     CallSite() {}
117 
118     /**
119      * Constructor to create an instance that represents an actual method call.
120      */
121     CallSite(int bci, Method m) {
122         this.bci = bci;
123         this.method = m;
124     }
125 
126     /**
127      * Add a call site to the compilation scope represented by this instance.
128      */
129     void add(CallSite site) {
130         if (getCalls() == null) {
131             calls = new ArrayList&lt;&gt;();
132         }
133         getCalls().add(site);
134     }
135 
136     /**
137      * Return the last of the {@linkplain #getCalls() call sites} in this
138      * compilation scope.
139      */
140     CallSite last() {
141         return getCalls().get(getCalls().size() - 1);
142     }
143 
144     /**
145      * Return the last-but-one of the {@linkplain #getCalls() call sites} in
146      * this compilation scope.
147      */
148     CallSite lastButOne() {
149         return getCalls().get(getCalls().size() - 2);
150     }
151 
152     public String toString() {
153         StringBuilder sb = new StringBuilder();
154         if (getReason() == null) {
155             sb.append(&quot;  @ &quot; + getBci() + &quot; &quot; + getMethod());
156         } else {
157             sb.append(&quot;- @ &quot; + getBci() + &quot; &quot; + getMethod() + &quot; &quot; + getReason());
158         }
159         sb.append(&quot;\n&quot;);
160         if (getCalls() != null) {
161             for (CallSite site : getCalls()) {
162                 sb.append(site);
163                 sb.append(&quot;\n&quot;);
164             }
165         }
166         return sb.toString();
167     }
168 
169     public void print(PrintStream stream) {
170         print(stream, 0, true, false);
171     }
172 
173     void emit(PrintStream stream, int indent) {
174         for (int i = 0; i &lt; indent; i++) {
175             stream.print(&#39; &#39;);
176         }
177     }
178 
179     public void print(PrintStream stream, int indent, boolean printInlining, boolean printUncommonTraps) {
180         emit(stream, indent);
181         String m = getMethod().getHolder() + &quot;::&quot; + getMethod().getName();
182         if (getReason() == null) {
183             stream.print(&quot;  @ &quot; + getBci() + &quot; &quot; + m + &quot; (&quot; + getMethod().getBytes() + &quot; bytes)&quot;);
184         } else {
185             stream.print(&quot;  @ &quot; + getBci() + &quot; &quot; + m + &quot; &quot; + getReason());
186         }
187         stream.print(getIntrinsicOrEmptyString());
<a name="2" id="anc2"></a><span class="line-modified">188         if (LogCompilation.compare == false) {</span>
<span class="line-added">189             // The timestamp is not useful for log comparison</span>
<span class="line-added">190             stream.printf(&quot; (end time: %6.4f&quot;, getTimeStamp());</span>
<span class="line-added">191         }</span>
192         if (getEndNodes() &gt; 0) {
193             stream.printf(&quot; nodes: %d live: %d&quot;, getEndNodes(), getEndLiveNodes());
194         }
195         stream.println(&quot;)&quot;);
196 
197         if (getReceiver() != null) {
198             emit(stream, indent + 4);
199             stream.println(&quot;type profile &quot; + getMethod().getHolder() + &quot; -&gt; &quot; + getReceiver() + &quot; (&quot; +
200                     (getReceiverCount() * 100 / getCount()) + &quot;%)&quot;);
201         }
202         if (printInlining &amp;&amp; getCalls() != null) {
203             for (CallSite site : getCalls()) {
204                 site.print(stream, indent + 2, printInlining, printUncommonTraps);
205             }
206         }
207         if (printUncommonTraps &amp;&amp; getTraps() != null) {
208             for (UncommonTrap site : getTraps()) {
209                 site.print(stream, indent + 2);
210             }
211         }
212     }
213 
214     public int getBci() {
215         return bci;
216     }
217 
218     public void setBci(int bci) {
219         this.bci = bci;
220     }
221 
222     public Method getMethod() {
223         return method;
224     }
225 
226     public void setMethod(Method method) {
227         this.method = method;
228     }
229 
230     public int getCount() {
231         return count;
232     }
233 
234     public void setCount(int count) {
235         this.count = count;
236     }
237 
238     public String getReceiver() {
239         return receiver;
240     }
241 
242     public void setReceiver(String receiver) {
243         this.receiver = receiver;
244     }
245 
246     public int getReceiverCount() {
247         return receiver_count;
248     }
249 
250     public void setReceiver_count(int receiver_count) {
251         this.receiver_count = receiver_count;
252     }
253 
254     public String getReason() {
255         return reason;
256     }
257 
258     public void setReason(String reason) {
259         this.reason = reason;
260     }
261 
262     public List&lt;CallSite&gt; getCalls() {
263         return calls;
264     }
265 
266     public List&lt;UncommonTrap&gt; getTraps() {
267         return traps;
268     }
269 
270     void add(UncommonTrap e) {
271         if (traps == null) {
272             traps = new ArrayList&lt;UncommonTrap&gt;();
273         }
274         traps.add(e);
275     }
276 
277     void setEndNodes(int n) {
278         endNodes = n;
279     }
280 
281     public int getEndNodes() {
282         return endNodes;
283     }
284 
285     void setEndLiveNodes(int n) {
286         endLiveNodes = n;
287     }
288 
289     public int getEndLiveNodes() {
290         return endLiveNodes;
291     }
292 
293     void setTimeStamp(double time) {
294         timeStamp = time;
295     }
296 
297     public double getTimeStamp() {
298         return timeStamp;
299     }
300 
301     /**
302      * Check whether this call site matches another. Every late inline call
303      * site has a unique inline ID. If the call site we&#39;re looking for has one,
304      * then use it; otherwise rely on method name and byte code index.
305      */
306     private boolean matches(CallSite other) {
307         if (other.inlineId != 0) {
308             return inlineId == other.inlineId;
309         }
310         return method.equals(other.method) &amp;&amp; bci == other.bci;
311     }
312 
313     /**
314      * Locate a late inline call site: find, in this instance&#39;s
315      * {@linkplain #calls call sites}, the one furthest down the given call
316      * stack.
317      *
318      * Multiple chains of identical call sites with the same method name / bci
319      * combination are possible, so we have to try them all until we find the
320      * late inline call site that has a matching inline ID.
321      *
322      * @return a matching call site, or {@code null} if none was found.
323      */
324     public CallSite findCallSite(ArrayDeque&lt;CallSite&gt; sites) {
325         if (calls == null) {
326             return null;
327         }
328         CallSite site = sites.pop();
329         for (CallSite c : calls) {
330             if (c.matches(site)) {
331                 if (!sites.isEmpty()) {
332                     CallSite res = c.findCallSite(sites);
333                     if (res != null) {
334                         sites.push(site);
335                         return res;
336                     }
337                 } else {
338                     sites.push(site);
339                     return c;
340                 }
341             }
342         }
343         sites.push(site);
344         return null;
345     }
346 
347     /**
348      * Locate a late inline call site in the tree spanned by all this instance&#39;s
349      * {@linkplain #calls call sites}, and return the sequence of call sites
350      * (scopes) leading to that late inline call site.
351      */
352     public ArrayDeque&lt;CallSite&gt; findCallSite2(CallSite site) {
353         if (calls == null) {
354             return null;
355         }
356 
357         for (CallSite c : calls) {
358             if (c.matches(site)) {
359                 ArrayDeque&lt;CallSite&gt; stack = new ArrayDeque&lt;&gt;();
360                 stack.push(c);
361                 return stack;
362             } else {
363                 ArrayDeque&lt;CallSite&gt; stack = c.findCallSite2(site);
364                 if (stack != null) {
365                     stack.push(c);
366                     return stack;
367                 }
368             }
369         }
370         return null;
371     }
372 
373     public long getInlineId() {
374         return inlineId;
375     }
376 
377     public void setInlineId(long inlineId) {
378         this.inlineId = inlineId;
379     }
380 
381     public String getIntrinsicName() {
382         return intrinsicName;
383     }
384 
385     public void setIntrinsicName(String name) {
386         this.intrinsicName = name;
387     }
388 
389     public String getIntrinsicOrEmptyString() {
390         if (intrinsicName != null) {
391             return &quot; (intrinsic: &quot; + getIntrinsicName() + &quot;)&quot;;
392         }
393         return &quot;&quot;;
394     }
395 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.sctp/unix/classes/sun/nio/ch/sctp/SctpChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AssociationChange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SctpMultiChannelImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.sctp/unix/classes/sun/nio/ch/sctp/SctpChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  36 import java.nio.ByteBuffer;
  37 import java.nio.channels.SelectionKey;
  38 import java.nio.channels.ClosedChannelException;
  39 import java.nio.channels.ConnectionPendingException;
  40 import java.nio.channels.NoConnectionPendingException;
  41 import java.nio.channels.AlreadyConnectedException;
  42 import java.nio.channels.NotYetBoundException;
  43 import java.nio.channels.NotYetConnectedException;
  44 import java.nio.channels.spi.SelectorProvider;
  45 import com.sun.nio.sctp.AbstractNotificationHandler;
  46 import com.sun.nio.sctp.Association;
  47 import com.sun.nio.sctp.AssociationChangeNotification;
  48 import com.sun.nio.sctp.HandlerResult;
  49 import com.sun.nio.sctp.IllegalReceiveException;
  50 import com.sun.nio.sctp.InvalidStreamException;
  51 import com.sun.nio.sctp.IllegalUnbindException;
  52 import com.sun.nio.sctp.MessageInfo;
  53 import com.sun.nio.sctp.NotificationHandler;
  54 import com.sun.nio.sctp.SctpChannel;
  55 import com.sun.nio.sctp.SctpSocketOption;

  56 import sun.nio.ch.DirectBuffer;
  57 import sun.nio.ch.IOStatus;
  58 import sun.nio.ch.IOUtil;
  59 import sun.nio.ch.NativeThread;
  60 import sun.nio.ch.Net;
  61 import sun.nio.ch.SelChImpl;
  62 import sun.nio.ch.SelectionKeyImpl;
  63 import sun.nio.ch.Util;
  64 import static com.sun.nio.sctp.SctpStandardSocketOptions.*;
  65 import static sun.nio.ch.sctp.ResultContainer.SEND_FAILED;
  66 import static sun.nio.ch.sctp.ResultContainer.ASSOCIATION_CHANGED;
  67 import static sun.nio.ch.sctp.ResultContainer.PEER_ADDRESS_CHANGED;
  68 import static sun.nio.ch.sctp.ResultContainer.SHUTDOWN;
  69 
  70 /**
  71  * An implementation of an SctpChannel
  72  */
  73 public class SctpChannelImpl extends SctpChannel
  74     implements SelChImpl
  75 {
</pre>
<hr />
<pre>
 448 
 449     @Override
 450     public boolean isConnectionPending() {
 451         synchronized (stateLock) {
 452             return (state == ChannelState.PENDING);
 453         }
 454     }
 455 
 456     @Override
 457     public boolean finishConnect() throws IOException {
 458         synchronized (receiveLock) {
 459             synchronized (sendLock) {
 460                 synchronized (stateLock) {
 461                     if (!isOpen())
 462                         throw new ClosedChannelException();
 463                     if (isConnected())
 464                         return true;
 465                     if (state != ChannelState.PENDING)
 466                         throw new NoConnectionPendingException();
 467                 }
<span class="line-modified"> 468                 int n = 0;</span>
 469                 try {
 470                     try {
 471                         begin();
 472                         synchronized (blockingLock()) {
 473                             synchronized (stateLock) {
 474                                 if (!isOpen()) {
 475                                     return false;
 476                                 }
 477                                 receiverThread = NativeThread.current();
 478                             }
 479                             if (!isBlocking()) {
<span class="line-modified"> 480                                 for (;;) {</span>
<span class="line-removed"> 481                                     n = Net.pollConnect(fd, 0);</span>
<span class="line-removed"> 482                                     if (  (n == IOStatus.INTERRUPTED)</span>
<span class="line-removed"> 483                                           &amp;&amp; isOpen())</span>
<span class="line-removed"> 484                                         continue;</span>
<span class="line-removed"> 485                                     break;</span>
<span class="line-removed"> 486                                 }</span>
 487                             } else {
<span class="line-modified"> 488                                 for (;;) {</span>
<span class="line-modified"> 489                                     n = Net.pollConnect(fd, -1);</span>
<span class="line-modified"> 490                                     if (n == 0) {</span>
<span class="line-removed"> 491                                         // Loop in case of</span>
<span class="line-removed"> 492                                         // spurious notifications</span>
<span class="line-removed"> 493                                         continue;</span>
<span class="line-removed"> 494                                     }</span>
<span class="line-removed"> 495                                     if (  (n == IOStatus.INTERRUPTED)</span>
<span class="line-removed"> 496                                           &amp;&amp; isOpen())</span>
<span class="line-removed"> 497                                         continue;</span>
<span class="line-removed"> 498                                     break;</span>
<span class="line-removed"> 499                                 }</span>
 500                             }
 501                         }
 502                     } finally {
 503                         synchronized (stateLock) {
 504                             receiverThread = 0;
 505                             if (state == ChannelState.KILLPENDING) {
 506                                 kill();
<span class="line-modified"> 507                                 /* poll()/getsockopt() does not report</span>
<span class="line-removed"> 508                                  * error (throws exception, with n = 0)</span>
<span class="line-removed"> 509                                  * on Linux platform after dup2 and</span>
<span class="line-removed"> 510                                  * signal-wakeup. Force n to 0 so the</span>
<span class="line-removed"> 511                                  * end() can throw appropriate exception */</span>
<span class="line-removed"> 512                                 n = 0;</span>
 513                             }
 514                         }
<span class="line-modified"> 515                         end((n &gt; 0) || (n == IOStatus.UNAVAILABLE));</span>
<span class="line-removed"> 516                         assert IOStatus.check(n);</span>
 517                     }
 518                 } catch (IOException x) {
 519                     /* If an exception was thrown, close the channel after
 520                      * invoking end() so as to avoid bogus
 521                      * AsynchronousCloseExceptions */
 522                     close();
 523                     throw x;
 524                 }
 525 
<span class="line-modified"> 526                 if (n &gt; 0) {</span>
 527                     synchronized (stateLock) {
 528                         state = ChannelState.CONNECTED;
 529                         if (!isBound()) {
 530                             InetSocketAddress boundIsa =
 531                                     Net.localAddress(fd);
 532                             port = boundIsa.getPort();
 533                         }
 534 
 535                         /* Receive COMM_UP */
 536                         ByteBuffer buf = Util.getTemporaryDirectBuffer(50);
 537                         try {
 538                             receive(buf, null, null, true);
 539                         } finally {
 540                             Util.releaseTemporaryDirectBuffer(buf);
 541                         }
 542 
 543                         /* cache remote addresses */
 544                         try {
 545                             remoteAddresses = getRemoteAddresses();
 546                         } catch (IOException unused) { /* swallow exception */ }
</pre>
<hr />
<pre>
1016                 src.position(pos + n);
1017             }
1018             return n;
1019         } finally {
1020             Util.releaseTemporaryDirectBuffer(bb);
1021         }
1022     }
1023 
1024     private int sendFromNativeBuffer(int fd,
1025                                      ByteBuffer bb,
1026                                      SocketAddress target,
1027                                      int streamNumber,
1028                                      boolean unordered,
1029                                      int ppid)
1030             throws IOException {
1031         InetAddress addr = null;     // no preferred address
1032         int port = 0;
1033         if (target != null) {
1034             InetSocketAddress isa = Net.checkAddress(target);
1035             addr = isa.getAddress();



1036             port = isa.getPort();
1037         }
1038 
1039         int pos = bb.position();
1040         int lim = bb.limit();
1041         assert (pos &lt;= lim);
1042         int rem = (pos &lt;= lim ? lim - pos : 0);
1043 
1044         int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,
1045                             port, -1 /*121*/, streamNumber, unordered, ppid);
1046         if (written &gt; 0)
1047             bb.position(pos + written);
1048         return written;
1049     }
1050 
1051     @Override
1052     public SctpChannel shutdown() throws IOException {
1053         synchronized(stateLock) {
1054             if (isShutdown)
1055                 return this;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  36 import java.nio.ByteBuffer;
  37 import java.nio.channels.SelectionKey;
  38 import java.nio.channels.ClosedChannelException;
  39 import java.nio.channels.ConnectionPendingException;
  40 import java.nio.channels.NoConnectionPendingException;
  41 import java.nio.channels.AlreadyConnectedException;
  42 import java.nio.channels.NotYetBoundException;
  43 import java.nio.channels.NotYetConnectedException;
  44 import java.nio.channels.spi.SelectorProvider;
  45 import com.sun.nio.sctp.AbstractNotificationHandler;
  46 import com.sun.nio.sctp.Association;
  47 import com.sun.nio.sctp.AssociationChangeNotification;
  48 import com.sun.nio.sctp.HandlerResult;
  49 import com.sun.nio.sctp.IllegalReceiveException;
  50 import com.sun.nio.sctp.InvalidStreamException;
  51 import com.sun.nio.sctp.IllegalUnbindException;
  52 import com.sun.nio.sctp.MessageInfo;
  53 import com.sun.nio.sctp.NotificationHandler;
  54 import com.sun.nio.sctp.SctpChannel;
  55 import com.sun.nio.sctp.SctpSocketOption;
<span class="line-added">  56 import sun.net.util.IPAddressUtil;</span>
  57 import sun.nio.ch.DirectBuffer;
  58 import sun.nio.ch.IOStatus;
  59 import sun.nio.ch.IOUtil;
  60 import sun.nio.ch.NativeThread;
  61 import sun.nio.ch.Net;
  62 import sun.nio.ch.SelChImpl;
  63 import sun.nio.ch.SelectionKeyImpl;
  64 import sun.nio.ch.Util;
  65 import static com.sun.nio.sctp.SctpStandardSocketOptions.*;
  66 import static sun.nio.ch.sctp.ResultContainer.SEND_FAILED;
  67 import static sun.nio.ch.sctp.ResultContainer.ASSOCIATION_CHANGED;
  68 import static sun.nio.ch.sctp.ResultContainer.PEER_ADDRESS_CHANGED;
  69 import static sun.nio.ch.sctp.ResultContainer.SHUTDOWN;
  70 
  71 /**
  72  * An implementation of an SctpChannel
  73  */
  74 public class SctpChannelImpl extends SctpChannel
  75     implements SelChImpl
  76 {
</pre>
<hr />
<pre>
 449 
 450     @Override
 451     public boolean isConnectionPending() {
 452         synchronized (stateLock) {
 453             return (state == ChannelState.PENDING);
 454         }
 455     }
 456 
 457     @Override
 458     public boolean finishConnect() throws IOException {
 459         synchronized (receiveLock) {
 460             synchronized (sendLock) {
 461                 synchronized (stateLock) {
 462                     if (!isOpen())
 463                         throw new ClosedChannelException();
 464                     if (isConnected())
 465                         return true;
 466                     if (state != ChannelState.PENDING)
 467                         throw new NoConnectionPendingException();
 468                 }
<span class="line-modified"> 469                 boolean connected = false;</span>
 470                 try {
 471                     try {
 472                         begin();
 473                         synchronized (blockingLock()) {
 474                             synchronized (stateLock) {
 475                                 if (!isOpen()) {
 476                                     return false;
 477                                 }
 478                                 receiverThread = NativeThread.current();
 479                             }
 480                             if (!isBlocking()) {
<span class="line-modified"> 481                                 connected = Net.pollConnect(fd, 0);</span>






 482                             } else {
<span class="line-modified"> 483                                 do {</span>
<span class="line-modified"> 484                                     connected = Net.pollConnect(fd, -1);</span>
<span class="line-modified"> 485                                 } while (!connected &amp;&amp; isOpen());</span>









 486                             }
 487                         }
 488                     } finally {
 489                         synchronized (stateLock) {
 490                             receiverThread = 0;
 491                             if (state == ChannelState.KILLPENDING) {
 492                                 kill();
<span class="line-modified"> 493                                 connected = false;</span>





 494                             }
 495                         }
<span class="line-modified"> 496                         end(connected);</span>

 497                     }
 498                 } catch (IOException x) {
 499                     /* If an exception was thrown, close the channel after
 500                      * invoking end() so as to avoid bogus
 501                      * AsynchronousCloseExceptions */
 502                     close();
 503                     throw x;
 504                 }
 505 
<span class="line-modified"> 506                 if (connected) {</span>
 507                     synchronized (stateLock) {
 508                         state = ChannelState.CONNECTED;
 509                         if (!isBound()) {
 510                             InetSocketAddress boundIsa =
 511                                     Net.localAddress(fd);
 512                             port = boundIsa.getPort();
 513                         }
 514 
 515                         /* Receive COMM_UP */
 516                         ByteBuffer buf = Util.getTemporaryDirectBuffer(50);
 517                         try {
 518                             receive(buf, null, null, true);
 519                         } finally {
 520                             Util.releaseTemporaryDirectBuffer(buf);
 521                         }
 522 
 523                         /* cache remote addresses */
 524                         try {
 525                             remoteAddresses = getRemoteAddresses();
 526                         } catch (IOException unused) { /* swallow exception */ }
</pre>
<hr />
<pre>
 996                 src.position(pos + n);
 997             }
 998             return n;
 999         } finally {
1000             Util.releaseTemporaryDirectBuffer(bb);
1001         }
1002     }
1003 
1004     private int sendFromNativeBuffer(int fd,
1005                                      ByteBuffer bb,
1006                                      SocketAddress target,
1007                                      int streamNumber,
1008                                      boolean unordered,
1009                                      int ppid)
1010             throws IOException {
1011         InetAddress addr = null;     // no preferred address
1012         int port = 0;
1013         if (target != null) {
1014             InetSocketAddress isa = Net.checkAddress(target);
1015             addr = isa.getAddress();
<span class="line-added">1016             if (addr.isLinkLocalAddress()) {</span>
<span class="line-added">1017                 addr = IPAddressUtil.toScopedAddress(addr);</span>
<span class="line-added">1018             }</span>
1019             port = isa.getPort();
1020         }
1021 
1022         int pos = bb.position();
1023         int lim = bb.limit();
1024         assert (pos &lt;= lim);
1025         int rem = (pos &lt;= lim ? lim - pos : 0);
1026 
1027         int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,
1028                             port, -1 /*121*/, streamNumber, unordered, ppid);
1029         if (written &gt; 0)
1030             bb.position(pos + written);
1031         return written;
1032     }
1033 
1034     @Override
1035     public SctpChannel shutdown() throws IOException {
1036         synchronized(stateLock) {
1037             if (isShutdown)
1038                 return this;
</pre>
</td>
</tr>
</table>
<center><a href="AssociationChange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SctpMultiChannelImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.sctp/unix/classes/sun/nio/ch/sctp/SctpServerChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.nio.ch.sctp;
 26 
 27 import java.net.SocketAddress;
 28 import java.net.InetSocketAddress;
 29 import java.net.InetAddress;
 30 import java.io.FileDescriptor;
 31 import java.io.IOException;
 32 import java.util.Collections;
 33 import java.util.Set;
 34 import java.util.HashSet;
 35 import java.nio.channels.SelectionKey;
 36 import java.nio.channels.ClosedChannelException;
 37 import java.nio.channels.NotYetBoundException;
 38 import java.nio.channels.spi.SelectorProvider;
 39 import com.sun.nio.sctp.IllegalUnbindException;
 40 import com.sun.nio.sctp.SctpChannel;
 41 import com.sun.nio.sctp.SctpServerChannel;
 42 import com.sun.nio.sctp.SctpSocketOption;
 43 import com.sun.nio.sctp.SctpStandardSocketOptions;
 44 import sun.nio.ch.DirectBuffer;
 45 import sun.nio.ch.NativeThread;
 46 import sun.nio.ch.IOStatus;
 47 import sun.nio.ch.IOUtil;
 48 import sun.nio.ch.Net;
 49 import sun.nio.ch.SelChImpl;
 50 import sun.nio.ch.SelectionKeyImpl;
 51 import sun.nio.ch.Util;
 52 
 53 /**
 54  * An implementation of SctpServerChannel
 55  */
 56 public class SctpServerChannelImpl extends SctpServerChannel
 57     implements SelChImpl
 58 {
 59     private final FileDescriptor fd;
 60 
 61     private final int fdVal;
 62 
 63     /* IDs of native thread doing accept, for signalling */
 64     private volatile long thread = 0;
 65 
 66     /* Lock held by thread currently blocked in this channel */
 67     private final Object lock = new Object();
 68 
 69     /* Lock held by any thread that modifies the state fields declared below
 70      * DO NOT invoke a blocking I/O operation while holding this lock! */
 71     private final Object stateLock = new Object();
 72 
 73     private enum ChannelState {
 74         UNINITIALIZED,
 75         INUSE,
 76         KILLPENDING,
 77         KILLED,
 78     }
 79     /* -- The following fields are protected by stateLock -- */
 80     private ChannelState state = ChannelState.UNINITIALIZED;
 81 
 82     /* Binding: Once bound the port will remain constant. */
 83     int port = -1;
 84     private HashSet&lt;InetSocketAddress&gt; localAddresses = new HashSet&lt;InetSocketAddress&gt;();
 85     /* Has the channel been bound to the wildcard address */
 86     private boolean wildcard; /* false */
 87 
 88     /* -- End of fields protected by stateLock -- */
 89 
 90     /**
 91      * Initializes a new instance of this class.
 92      */
 93     public SctpServerChannelImpl(SelectorProvider provider)
 94             throws IOException {
 95         //TODO: update provider remove public modifier
 96         super(provider);
 97         this.fd = SctpNet.socket(true);
 98         this.fdVal = IOUtil.fdVal(fd);
 99         this.state = ChannelState.INUSE;
100     }
101 
102     @Override
103     public SctpServerChannel bind(SocketAddress local, int backlog)
104             throws IOException {
105         synchronized (lock) {
106             synchronized (stateLock) {
107                 if (!isOpen())
108                     throw new ClosedChannelException();
109                 if (isBound())
110                     SctpNet.throwAlreadyBoundException();
111 
112                 InetSocketAddress isa = (local == null) ?
113                     new InetSocketAddress(0) : Net.checkAddress(local);
114                 SecurityManager sm = System.getSecurityManager();
115                 if (sm != null)
116                     sm.checkListen(isa.getPort());
117                 Net.bind(fd, isa.getAddress(), isa.getPort());
118 
119                 InetSocketAddress boundIsa = Net.localAddress(fd);
120                 port = boundIsa.getPort();
121                 localAddresses.add(isa);
122                     if (isa.getAddress().isAnyLocalAddress())
123                         wildcard = true;
124 
125                 SctpNet.listen(fdVal, backlog &lt; 1 ? 50 : backlog);
126             }
127         }
128         return this;
129     }
130 
131     @Override
132     public SctpServerChannel bindAddress(InetAddress address)
133             throws IOException {
134         return bindUnbindAddress(address, true);
135     }
136 
137     @Override
138     public SctpServerChannel unbindAddress(InetAddress address)
139             throws IOException {
140         return bindUnbindAddress(address, false);
141     }
142 
143     private SctpServerChannel bindUnbindAddress(InetAddress address, boolean add)
144             throws IOException {
145         if (address == null)
146             throw new IllegalArgumentException();
147 
148         synchronized (lock) {
149             synchronized (stateLock) {
150                 if (!isOpen())
151                     throw new ClosedChannelException();
152                 if (!isBound())
153                     throw new NotYetBoundException();
154                 if (wildcard)
155                     throw new IllegalStateException(
156                             &quot;Cannot add or remove addresses from a channel that is bound to the wildcard address&quot;);
157                 if (address.isAnyLocalAddress())
158                     throw new IllegalArgumentException(
159                             &quot;Cannot add or remove the wildcard address&quot;);
160                 if (add) {
161                     for (InetSocketAddress addr : localAddresses) {
162                         if (addr.getAddress().equals(address)) {
163                             SctpNet.throwAlreadyBoundException();
164                         }
165                     }
166                 } else { /*removing */
167                     /* Verify that there is more than one address
168                      * and that address is already bound */
169                     if (localAddresses.size() &lt;= 1)
170                         throw new IllegalUnbindException(&quot;Cannot remove address from a channel with only one address bound&quot;);
171                     boolean foundAddress = false;
172                     for (InetSocketAddress addr : localAddresses) {
173                         if (addr.getAddress().equals(address)) {
174                             foundAddress = true;
175                             break;
176                         }
177                     }
178                     if (!foundAddress )
179                         throw new IllegalUnbindException(&quot;Cannot remove address from a channel that is not bound to that address&quot;);
180                 }
181 
182                 SctpNet.bindx(fdVal, new InetAddress[]{address}, port, add);
183 
184                 /* Update our internal Set to reflect the addition/removal */
185                 if (add)
186                     localAddresses.add(new InetSocketAddress(address, port));
187                 else {
188                     for (InetSocketAddress addr : localAddresses) {
189                         if (addr.getAddress().equals(address)) {
190                             localAddresses.remove(addr);
191                             break;
192                         }
193                     }
194                 }
195             }
196         }
197         return this;
198     }
199 
200     private boolean isBound() {
201         synchronized (stateLock) {
202             return port == -1 ? false : true;
203         }
204     }
205 
206     private void acceptCleanup() throws IOException {
207         synchronized (stateLock) {
208             thread = 0;
209             if (state == ChannelState.KILLPENDING)
210                 kill();
211         }
212     }
213 
214     @Override
215     public SctpChannel accept() throws IOException {
216         synchronized (lock) {
217             if (!isOpen())
218                 throw new ClosedChannelException();
219             if (!isBound())
220                 throw new NotYetBoundException();
221             SctpChannel sc = null;
222 
223             int n = 0;
224             FileDescriptor newfd = new FileDescriptor();
225             InetSocketAddress[] isaa = new InetSocketAddress[1];
226 
227             try {
228                 begin();
229                 if (!isOpen())
230                     return null;
231                 thread = NativeThread.current();
232                 for (;;) {
<a name="2" id="anc2"></a><span class="line-modified">233                     n = Net.accept(fd, newfd, isaa);</span>
234                     if ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen())
235                         continue;
236                     break;
237                 }
238             } finally {
239                 acceptCleanup();
240                 end(n &gt; 0);
241                 assert IOStatus.check(n);
242             }
243 
244             if (n &lt; 1)
245                 return null;
246 
247             IOUtil.configureBlocking(newfd, true);
248             InetSocketAddress isa = isaa[0];
249             sc = new SctpChannelImpl(provider(), newfd);
250 
251             SecurityManager sm = System.getSecurityManager();
252             if (sm != null)
253                 sm.checkAccept(isa.getAddress().getHostAddress(),
254                                isa.getPort());
255 
256             return sc;
257         }
258     }
259 
260     @Override
261     protected void implConfigureBlocking(boolean block) throws IOException {
262         IOUtil.configureBlocking(fd, block);
263     }
264 
265     @Override
266     public void implCloseSelectableChannel() throws IOException {
267         synchronized (stateLock) {
268             SctpNet.preClose(fdVal);
269             if (thread != 0)
270                 NativeThread.signal(thread);
271             if (!isRegistered())
272                 kill();
273         }
274     }
275 
276     @Override
277     public void kill() throws IOException {
278         synchronized (stateLock) {
279             if (state == ChannelState.KILLED)
280                 return;
281             if (state == ChannelState.UNINITIALIZED) {
282                 state = ChannelState.KILLED;
283                 return;
284             }
285             assert !isOpen() &amp;&amp; !isRegistered();
286 
287             // Postpone the kill if there is a thread in accept
288             if (thread == 0) {
289                 SctpNet.close(fdVal);
290                 state = ChannelState.KILLED;
291             } else {
292                 state = ChannelState.KILLPENDING;
293             }
294         }
295     }
296 
297     @Override
298     public FileDescriptor getFD() {
299         return fd;
300     }
301 
302     @Override
303     public int getFDVal() {
304         return fdVal;
305     }
306 
307     /**
308      * Translates native poll revent ops into a ready operation ops
309      */
310     private boolean translateReadyOps(int ops, int initialOps,
311                                      SelectionKeyImpl sk) {
312         int intOps = sk.nioInterestOps();
313         int oldOps = sk.nioReadyOps();
314         int newOps = initialOps;
315 
316         if ((ops &amp; Net.POLLNVAL) != 0) {
317             /* This should only happen if this channel is pre-closed while a
318              * selection operation is in progress
319              * ## Throw an error if this channel has not been pre-closed */
320             return false;
321         }
322 
323         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
324             newOps = intOps;
325             sk.nioReadyOps(newOps);
326             return (newOps &amp; ~oldOps) != 0;
327         }
328 
329         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
330             ((intOps &amp; SelectionKey.OP_ACCEPT) != 0))
331                 newOps |= SelectionKey.OP_ACCEPT;
332 
333         sk.nioReadyOps(newOps);
334         return (newOps &amp; ~oldOps) != 0;
335     }
336 
337     @Override
338     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl sk) {
339         return translateReadyOps(ops, sk.nioReadyOps(), sk);
340     }
341 
342     @Override
343     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl sk) {
344         return translateReadyOps(ops, 0, sk);
345     }
346 
347     @Override
348     public int translateInterestOps(int ops) {
349         int newOps = 0;
350         if ((ops &amp; SelectionKey.OP_ACCEPT) != 0)
351             newOps |= Net.POLLIN;
352         return newOps;
353     }
354 
355     @Override
356     public &lt;T&gt; SctpServerChannel setOption(SctpSocketOption&lt;T&gt; name, T value)
357             throws IOException {
358         if (name == null)
359             throw new NullPointerException();
360         if (!supportedOptions().contains(name))
361             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
362 
363         synchronized (stateLock) {
364             if (!isOpen())
365                 throw new ClosedChannelException();
366 
367             SctpNet.setSocketOption(fdVal, name, value, 0 /*oneToOne*/);
368             return this;
369         }
370     }
371 
372     @Override
373     @SuppressWarnings(&quot;unchecked&quot;)
374     public &lt;T&gt; T getOption(SctpSocketOption&lt;T&gt; name) throws IOException {
375         if (name == null)
376             throw new NullPointerException();
377         if (!supportedOptions().contains(name))
378             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
379 
380         synchronized (stateLock) {
381             if (!isOpen())
382                 throw new ClosedChannelException();
383 
384             return (T) SctpNet.getSocketOption(fdVal, name, 0 /*oneToOne*/);
385         }
386     }
387 
388     private static class DefaultOptionsHolder {
389         static final Set&lt;SctpSocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
390 
391         private static Set&lt;SctpSocketOption&lt;?&gt;&gt; defaultOptions() {
392             HashSet&lt;SctpSocketOption&lt;?&gt;&gt; set = new HashSet&lt;SctpSocketOption&lt;?&gt;&gt;(1);
393             set.add(SctpStandardSocketOptions.SCTP_INIT_MAXSTREAMS);
394             return Collections.unmodifiableSet(set);
395         }
396     }
397 
398     @Override
399     public final Set&lt;SctpSocketOption&lt;?&gt;&gt; supportedOptions() {
400         return DefaultOptionsHolder.defaultOptions;
401     }
402 
403     @Override
404     public Set&lt;SocketAddress&gt; getAllLocalAddresses()
405             throws IOException {
406         synchronized (stateLock) {
407             if (!isOpen())
408                 throw new ClosedChannelException();
409             if (!isBound())
410                 return Collections.emptySet();
411 
412             return SctpNet.getLocalAddresses(fdVal);
413         }
414     }
<a name="3" id="anc3"></a>

















415 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
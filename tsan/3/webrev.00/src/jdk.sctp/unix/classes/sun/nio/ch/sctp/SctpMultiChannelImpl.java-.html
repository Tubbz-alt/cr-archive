<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.sctp/unix/classes/sun/nio/ch/sctp/SctpMultiChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package sun.nio.ch.sctp;
  26 
  27 import java.net.InetAddress;
  28 import java.net.SocketAddress;
  29 import java.net.SocketException;
  30 import java.net.InetSocketAddress;
  31 import java.io.FileDescriptor;
  32 import java.io.IOException;
  33 import java.util.Collections;
  34 import java.util.Map.Entry;
  35 import java.util.Iterator;
  36 import java.util.Set;
  37 import java.util.HashSet;
  38 import java.util.HashMap;
  39 import java.nio.ByteBuffer;
  40 import java.nio.channels.SelectionKey;
  41 import java.nio.channels.ClosedChannelException;
  42 import java.nio.channels.NotYetBoundException;
  43 import java.nio.channels.spi.SelectorProvider;
  44 import com.sun.nio.sctp.AbstractNotificationHandler;
  45 import com.sun.nio.sctp.Association;
  46 import com.sun.nio.sctp.AssociationChangeNotification;
  47 import com.sun.nio.sctp.HandlerResult;
  48 import com.sun.nio.sctp.IllegalReceiveException;
  49 import com.sun.nio.sctp.InvalidStreamException;
  50 import com.sun.nio.sctp.IllegalUnbindException;
  51 import com.sun.nio.sctp.NotificationHandler;
  52 import com.sun.nio.sctp.MessageInfo;
  53 import com.sun.nio.sctp.SctpChannel;
  54 import com.sun.nio.sctp.SctpMultiChannel;
  55 import com.sun.nio.sctp.SctpSocketOption;
  56 import sun.nio.ch.DirectBuffer;
  57 import sun.nio.ch.NativeThread;
  58 import sun.nio.ch.IOStatus;
  59 import sun.nio.ch.IOUtil;
  60 import sun.nio.ch.Net;
  61 import sun.nio.ch.SelChImpl;
  62 import sun.nio.ch.SelectionKeyImpl;
  63 import sun.nio.ch.Util;
  64 import static com.sun.nio.sctp.SctpStandardSocketOptions.*;
  65 import static sun.nio.ch.sctp.ResultContainer.*;
  66 
  67 /**
  68  * An implementation of SctpMultiChannel
  69  */
  70 public class SctpMultiChannelImpl extends SctpMultiChannel
  71     implements SelChImpl
  72 {
  73     private final FileDescriptor fd;
  74 
  75     private final int fdVal;
  76 
  77     /* IDs of native threads doing send and receives, for signalling */
  78     private volatile long receiverThread = 0;
  79     private volatile long senderThread = 0;
  80 
  81     /* Lock held by current receiving thread */
  82     private final Object receiveLock = new Object();
  83 
  84     /* Lock held by current sending thread */
  85     private final Object sendLock = new Object();
  86 
  87     /* Lock held by any thread that modifies the state fields declared below
  88      * DO NOT invoke a blocking I/O operation while holding this lock! */
  89     private final Object stateLock = new Object();
  90 
  91     private enum ChannelState {
  92         UNINITIALIZED,
  93         KILLPENDING,
  94         KILLED,
  95     }
  96 
  97     /* -- The following fields are protected by stateLock -- */
  98     private ChannelState state = ChannelState.UNINITIALIZED;
  99 
 100     /* Binding: Once bound the port will remain constant. */
 101     int port = -1;
 102     private HashSet&lt;InetSocketAddress&gt; localAddresses = new HashSet&lt;InetSocketAddress&gt;();
 103     /* Has the channel been bound to the wildcard address */
 104     private boolean wildcard; /* false */
 105 
 106     /* Keeps a map of addresses to association, and visa versa */
 107     private HashMap&lt;SocketAddress, Association&gt; addressMap =
 108                          new HashMap&lt;SocketAddress, Association&gt;();
 109     private HashMap&lt;Association, Set&lt;SocketAddress&gt;&gt; associationMap =
 110                          new HashMap&lt;Association, Set&lt;SocketAddress&gt;&gt;();
 111 
 112     /* -- End of fields protected by stateLock -- */
 113 
 114     /* If an association has been shutdown mark it for removal after
 115      * the user handler has been invoked */
 116     private final ThreadLocal&lt;Association&gt; associationToRemove =
 117         new ThreadLocal&lt;Association&gt;() {
 118              @Override protected Association initialValue() {
 119                  return null;
 120             }
 121     };
 122 
 123     /* A notification handler cannot invoke receive */
 124     private final ThreadLocal&lt;Boolean&gt; receiveInvoked =
 125         new ThreadLocal&lt;Boolean&gt;() {
 126              @Override protected Boolean initialValue() {
 127                  return Boolean.FALSE;
 128             }
 129     };
 130 
 131     public SctpMultiChannelImpl(SelectorProvider provider)
 132             throws IOException {
 133         //TODO: update provider, remove public modifier
 134         super(provider);
 135         this.fd = SctpNet.socket(false /*one-to-many*/);
 136         this.fdVal = IOUtil.fdVal(fd);
 137     }
 138 
 139     @Override
 140     public SctpMultiChannel bind(SocketAddress local, int backlog)
 141             throws IOException {
 142         synchronized (receiveLock) {
 143             synchronized (sendLock) {
 144                 synchronized (stateLock) {
 145                     ensureOpen();
 146                     if (isBound())
 147                         SctpNet.throwAlreadyBoundException();
 148                     InetSocketAddress isa = (local == null) ?
 149                         new InetSocketAddress(0) : Net.checkAddress(local);
 150 
 151                     SecurityManager sm = System.getSecurityManager();
 152                     if (sm != null)
 153                         sm.checkListen(isa.getPort());
 154                     Net.bind(fd, isa.getAddress(), isa.getPort());
 155 
 156                     InetSocketAddress boundIsa = Net.localAddress(fd);
 157                     port = boundIsa.getPort();
 158                     localAddresses.add(isa);
 159                     if (isa.getAddress().isAnyLocalAddress())
 160                         wildcard = true;
 161 
 162                     SctpNet.listen(fdVal, backlog &lt; 1 ? 50 : backlog);
 163                 }
 164             }
 165         }
 166         return this;
 167     }
 168 
 169     @Override
 170     public SctpMultiChannel bindAddress(InetAddress address)
 171             throws IOException {
 172         return bindUnbindAddress(address, true);
 173     }
 174 
 175     @Override
 176     public SctpMultiChannel unbindAddress(InetAddress address)
 177             throws IOException {
 178         return bindUnbindAddress(address, false);
 179     }
 180 
 181     private SctpMultiChannel bindUnbindAddress(InetAddress address,
 182                                                boolean add)
 183             throws IOException {
 184         if (address == null)
 185             throw new IllegalArgumentException();
 186 
 187         synchronized (receiveLock) {
 188             synchronized (sendLock) {
 189                 synchronized (stateLock) {
 190                     if (!isOpen())
 191                         throw new ClosedChannelException();
 192                     if (!isBound())
 193                         throw new NotYetBoundException();
 194                     if (wildcard)
 195                         throw new IllegalStateException(
 196                                 &quot;Cannot add or remove addresses from a channel that is bound to the wildcard address&quot;);
 197                     if (address.isAnyLocalAddress())
 198                         throw new IllegalArgumentException(
 199                                 &quot;Cannot add or remove the wildcard address&quot;);
 200                     if (add) {
 201                         for (InetSocketAddress addr : localAddresses) {
 202                             if (addr.getAddress().equals(address)) {
 203                                 SctpNet.throwAlreadyBoundException();
 204                             }
 205                         }
 206                     } else { /*removing */
 207                         /* Verify that there is more than one address
 208                          * and that address is already bound */
 209                         if (localAddresses.size() &lt;= 1)
 210                             throw new IllegalUnbindException(&quot;Cannot remove address from a channel with only one address bound&quot;);
 211                         boolean foundAddress = false;
 212                         for (InetSocketAddress addr : localAddresses) {
 213                             if (addr.getAddress().equals(address)) {
 214                                 foundAddress = true;
 215                                 break;
 216                             }
 217                         }
 218                         if (!foundAddress )
 219                             throw new IllegalUnbindException(&quot;Cannot remove address from a channel that is not bound to that address&quot;);
 220                     }
 221 
 222                     SctpNet.bindx(fdVal, new InetAddress[]{address}, port, add);
 223 
 224                     /* Update our internal Set to reflect the addition/removal */
 225                     if (add)
 226                         localAddresses.add(new InetSocketAddress(address, port));
 227                     else {
 228                         for (InetSocketAddress addr : localAddresses) {
 229                             if (addr.getAddress().equals(address)) {
 230                                 localAddresses.remove(addr);
 231                                 break;
 232                             }
 233                         }
 234                     }
 235                 }
 236             }
 237         }
 238         return this;
 239     }
 240 
 241     @Override
 242     public Set&lt;Association&gt; associations()
 243             throws ClosedChannelException, NotYetBoundException {
 244         synchronized (stateLock) {
 245             if (!isOpen())
 246                 throw new ClosedChannelException();
 247             if (!isBound())
 248                 throw new NotYetBoundException();
 249 
 250             return Collections.unmodifiableSet(associationMap.keySet());
 251         }
 252     }
 253 
 254     private boolean isBound() {
 255         synchronized (stateLock) {
 256             return port == -1 ? false : true;
 257         }
 258     }
 259 
 260     private void ensureOpen() throws IOException {
 261         synchronized (stateLock) {
 262             if (!isOpen())
 263                 throw new ClosedChannelException();
 264         }
 265     }
 266 
 267     private void receiverCleanup() throws IOException {
 268         synchronized (stateLock) {
 269             receiverThread = 0;
 270             if (state == ChannelState.KILLPENDING)
 271                 kill();
 272         }
 273     }
 274 
 275     private void senderCleanup() throws IOException {
 276         synchronized (stateLock) {
 277             senderThread = 0;
 278             if (state == ChannelState.KILLPENDING)
 279                 kill();
 280         }
 281     }
 282 
 283     @Override
 284     protected void implConfigureBlocking(boolean block) throws IOException {
 285         IOUtil.configureBlocking(fd, block);
 286     }
 287 
 288     @Override
 289     public void implCloseSelectableChannel() throws IOException {
 290         synchronized (stateLock) {
 291             SctpNet.preClose(fdVal);
 292 
 293             if (receiverThread != 0)
 294                 NativeThread.signal(receiverThread);
 295 
 296             if (senderThread != 0)
 297                 NativeThread.signal(senderThread);
 298 
 299             if (!isRegistered())
 300                 kill();
 301         }
 302     }
 303 
 304     @Override
 305     public FileDescriptor getFD() {
 306         return fd;
 307     }
 308 
 309     @Override
 310     public int getFDVal() {
 311         return fdVal;
 312     }
 313 
 314     /**
 315      * Translates native poll revent ops into a ready operation ops
 316      */
 317     private boolean translateReadyOps(int ops, int initialOps,
 318                                       SelectionKeyImpl sk) {
 319         int intOps = sk.nioInterestOps();
 320         int oldOps = sk.nioReadyOps();
 321         int newOps = initialOps;
 322 
 323         if ((ops &amp; Net.POLLNVAL) != 0) {
 324             /* This should only happen if this channel is pre-closed while a
 325              * selection operation is in progress
 326              * ## Throw an error if this channel has not been pre-closed */
 327             return false;
 328         }
 329 
 330         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
 331             newOps = intOps;
 332             sk.nioReadyOps(newOps);
 333             return (newOps &amp; ~oldOps) != 0;
 334         }
 335 
 336         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
 337             ((intOps &amp; SelectionKey.OP_READ) != 0))
 338             newOps |= SelectionKey.OP_READ;
 339 
 340         if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp;
 341             ((intOps &amp; SelectionKey.OP_WRITE) != 0))
 342             newOps |= SelectionKey.OP_WRITE;
 343 
 344         sk.nioReadyOps(newOps);
 345         return (newOps &amp; ~oldOps) != 0;
 346     }
 347 
 348     @Override
 349     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl sk) {
 350         return translateReadyOps(ops, sk.nioReadyOps(), sk);
 351     }
 352 
 353     @Override
 354     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl sk) {
 355         return translateReadyOps(ops, 0, sk);
 356     }
 357 
 358     @Override
 359     public int translateInterestOps(int ops) {
 360         int newOps = 0;
 361         if ((ops &amp; SelectionKey.OP_READ) != 0)
 362             newOps |= Net.POLLIN;
 363         if ((ops &amp; SelectionKey.OP_WRITE) != 0)
 364             newOps |= Net.POLLOUT;
 365         return newOps;
 366     }
 367 
 368     @Override
 369     public void kill() throws IOException {
 370         synchronized (stateLock) {
 371             if (state == ChannelState.KILLED)
 372                 return;
 373             if (state == ChannelState.UNINITIALIZED) {
 374                 state = ChannelState.KILLED;
 375                 return;
 376             }
 377             assert !isOpen() &amp;&amp; !isRegistered();
 378 
 379             /* Postpone the kill if there is a thread sending or receiving. */
 380             if (receiverThread == 0 &amp;&amp; senderThread == 0) {
 381                 SctpNet.close(fdVal);
 382                 state = ChannelState.KILLED;
 383             } else {
 384                 state = ChannelState.KILLPENDING;
 385             }
 386         }
 387     }
 388 
 389     @Override
 390     public &lt;T&gt; SctpMultiChannel setOption(SctpSocketOption&lt;T&gt; name,
 391                                           T value,
 392                                           Association association)
 393             throws IOException {
 394         if (name == null)
 395             throw new NullPointerException();
 396         if (!(supportedOptions().contains(name)))
 397             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 398 
 399         synchronized (stateLock) {
 400             if (association != null &amp;&amp; (name.equals(SCTP_PRIMARY_ADDR) ||
 401                     name.equals(SCTP_SET_PEER_PRIMARY_ADDR))) {
 402                 checkAssociation(association);
 403             }
 404             if (!isOpen())
 405                 throw new ClosedChannelException();
 406 
 407             int assocId = association == null ? 0 : association.associationID();
 408             SctpNet.setSocketOption(fdVal, name, value, assocId);
 409         }
 410         return this;
 411     }
 412 
 413     @Override
 414     @SuppressWarnings(&quot;unchecked&quot;)
 415     public &lt;T&gt; T getOption(SctpSocketOption&lt;T&gt; name, Association association)
 416             throws IOException {
 417         if (name == null)
 418             throw new NullPointerException();
 419         if (!supportedOptions().contains(name))
 420             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 421 
 422         synchronized (stateLock) {
 423             if (association != null &amp;&amp; (name.equals(SCTP_PRIMARY_ADDR) ||
 424                     name.equals(SCTP_SET_PEER_PRIMARY_ADDR))) {
 425                 checkAssociation(association);
 426             }
 427             if (!isOpen())
 428                 throw new ClosedChannelException();
 429 
 430             int assocId = association == null ? 0 : association.associationID();
 431             return (T)SctpNet.getSocketOption(fdVal, name, assocId);
 432         }
 433     }
 434 
 435     private static class DefaultOptionsHolder {
 436         static final Set&lt;SctpSocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 437 
 438         private static Set&lt;SctpSocketOption&lt;?&gt;&gt; defaultOptions() {
 439             HashSet&lt;SctpSocketOption&lt;?&gt;&gt; set = new HashSet&lt;SctpSocketOption&lt;?&gt;&gt;(10);
 440             set.add(SCTP_DISABLE_FRAGMENTS);
 441             set.add(SCTP_EXPLICIT_COMPLETE);
 442             set.add(SCTP_FRAGMENT_INTERLEAVE);
 443             set.add(SCTP_INIT_MAXSTREAMS);
 444             set.add(SCTP_NODELAY);
 445             set.add(SCTP_PRIMARY_ADDR);
 446             set.add(SCTP_SET_PEER_PRIMARY_ADDR);
 447             set.add(SO_SNDBUF);
 448             set.add(SO_RCVBUF);
 449             set.add(SO_LINGER);
 450             return Collections.unmodifiableSet(set);
 451         }
 452     }
 453 
 454     @Override
 455     public final Set&lt;SctpSocketOption&lt;?&gt;&gt; supportedOptions() {
 456         return DefaultOptionsHolder.defaultOptions;
 457     }
 458 
 459     @Override
 460     public &lt;T&gt; MessageInfo receive(ByteBuffer buffer,
 461                                    T attachment,
 462                                    NotificationHandler&lt;T&gt; handler)
 463             throws IOException {
 464         if (buffer == null)
 465             throw new IllegalArgumentException(&quot;buffer cannot be null&quot;);
 466 
 467         if (buffer.isReadOnly())
 468             throw new IllegalArgumentException(&quot;Read-only buffer&quot;);
 469 
 470         if (receiveInvoked.get())
 471             throw new IllegalReceiveException(
 472                     &quot;cannot invoke receive from handler&quot;);
 473         receiveInvoked.set(Boolean.TRUE);
 474 
 475         try {
 476             ResultContainer resultContainer = new ResultContainer();
 477             do {
 478                 resultContainer.clear();
 479                 synchronized (receiveLock) {
 480                     ensureOpen();
 481                     if (!isBound())
 482                         throw new NotYetBoundException();
 483 
 484                     int n = 0;
 485                     try {
 486                         begin();
 487 
 488                         synchronized (stateLock) {
 489                             if(!isOpen())
 490                                 return null;
 491                             receiverThread = NativeThread.current();
 492                         }
 493 
 494                         do {
 495                             n = receive(fdVal, buffer, resultContainer);
 496                         } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 497 
 498                     } finally {
 499                         receiverCleanup();
 500                         end((n &gt; 0) || (n == IOStatus.UNAVAILABLE));
 501                         assert IOStatus.check(n);
 502                     }
 503 
 504                     if (!resultContainer.isNotification()) {
 505                         /* message or nothing */
 506                         if (resultContainer.hasSomething()) {
 507                             /* Set the association before returning */
 508                             MessageInfoImpl info =
 509                                     resultContainer.getMessageInfo();
 510                             info.setAssociation(lookupAssociation(info.
 511                                     associationID()));
 512                             SecurityManager sm = System.getSecurityManager();
 513                             if (sm != null) {
 514                                 InetSocketAddress isa  = (InetSocketAddress)info.address();
 515                                 if (!addressMap.containsKey(isa)) {
 516                                     /* must be a new association */
 517                                     try {
 518                                         sm.checkAccept(isa.getAddress().getHostAddress(),
 519                                                        isa.getPort());
 520                                     } catch (SecurityException se) {
 521                                         buffer.clear();
 522                                         throw se;
 523                                     }
 524                                 }
 525                             }
 526 
 527                             assert info.association() != null;
 528                             return info;
 529                         } else  {
 530                           /* Non-blocking may return null if nothing available*/
 531                             return null;
 532                         }
 533                     } else { /* notification */
 534                         synchronized (stateLock) {
 535                             handleNotificationInternal(
 536                                     resultContainer);
 537                         }
 538                     }
 539                 } /* receiveLock */
 540             } while (handler == null ? true :
 541                 (invokeNotificationHandler(resultContainer, handler, attachment)
 542                  == HandlerResult.CONTINUE));
 543         } finally {
 544             receiveInvoked.set(Boolean.FALSE);
 545         }
 546 
 547         return null;
 548     }
 549 
 550     private int receive(int fd,
 551                         ByteBuffer dst,
 552                         ResultContainer resultContainer)
 553             throws IOException {
 554         int pos = dst.position();
 555         int lim = dst.limit();
 556         assert (pos &lt;= lim);
 557         int rem = (pos &lt;= lim ? lim - pos : 0);
 558         if (dst instanceof DirectBuffer &amp;&amp; rem &gt; 0)
 559             return receiveIntoNativeBuffer(fd, resultContainer, dst, rem, pos);
 560 
 561         /* Substitute a native buffer. */
 562         int newSize = Math.max(rem, 1);
 563         ByteBuffer bb = Util.getTemporaryDirectBuffer(newSize);
 564         try {
 565             int n = receiveIntoNativeBuffer(fd, resultContainer, bb, newSize, 0);
 566             bb.flip();
 567             if (n &gt; 0 &amp;&amp; rem &gt; 0)
 568                 dst.put(bb);
 569             return n;
 570         } finally {
 571             Util.releaseTemporaryDirectBuffer(bb);
 572         }
 573     }
 574 
 575     private int receiveIntoNativeBuffer(int fd,
 576                                         ResultContainer resultContainer,
 577                                         ByteBuffer bb,
 578                                         int rem,
 579                                         int pos)
 580             throws IOException {
 581         int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);
 582         if (n &gt; 0)
 583             bb.position(pos + n);
 584         return n;
 585     }
 586 
 587     private InternalNotificationHandler internalNotificationHandler =
 588             new InternalNotificationHandler();
 589 
 590     private void handleNotificationInternal(ResultContainer resultContainer)
 591     {
 592         invokeNotificationHandler(resultContainer,
 593                 internalNotificationHandler, null);
 594     }
 595 
 596     private class InternalNotificationHandler
 597             extends AbstractNotificationHandler&lt;Object&gt;
 598     {
 599         @Override
 600         public HandlerResult handleNotification(
 601                 AssociationChangeNotification not, Object unused) {
 602             AssociationChange sac = (AssociationChange) not;
 603 
 604             /* Update map to reflect change in association */
 605             switch (not.event()) {
 606                 case COMM_UP :
 607                     Association newAssociation = new AssociationImpl
 608                        (sac.assocId(), sac.maxInStreams(), sac.maxOutStreams());
 609                     addAssociation(newAssociation);
 610                     break;
 611                 case SHUTDOWN :
 612                 case COMM_LOST :
 613                 //case RESTART: ???
 614                     /* mark association for removal after user handler invoked*/
 615                     associationToRemove.set(lookupAssociation(sac.assocId()));
 616             }
 617             return HandlerResult.CONTINUE;
 618         }
 619     }
 620 
 621     private &lt;T&gt; HandlerResult invokeNotificationHandler(
 622                                    ResultContainer resultContainer,
 623                                    NotificationHandler&lt;T&gt; handler,
 624                                    T attachment) {
 625         HandlerResult result;
 626         SctpNotification notification = resultContainer.notification();
 627         notification.setAssociation(lookupAssociation(notification.assocId()));
 628 
 629         if (!(handler instanceof AbstractNotificationHandler)) {
 630             result = handler.handleNotification(notification, attachment);
 631         } else { /* AbstractNotificationHandler */
 632             AbstractNotificationHandler&lt;T&gt; absHandler =
 633                     (AbstractNotificationHandler&lt;T&gt;)handler;
 634             switch(resultContainer.type()) {
 635                 case ASSOCIATION_CHANGED :
 636                     result = absHandler.handleNotification(
 637                             resultContainer.getAssociationChanged(), attachment);
 638                     break;
 639                 case PEER_ADDRESS_CHANGED :
 640                     result = absHandler.handleNotification(
 641                             resultContainer.getPeerAddressChanged(), attachment);
 642                     break;
 643                 case SEND_FAILED :
 644                     result = absHandler.handleNotification(
 645                             resultContainer.getSendFailed(), attachment);
 646                     break;
 647                 case SHUTDOWN :
 648                     result =  absHandler.handleNotification(
 649                             resultContainer.getShutdown(), attachment);
 650                     break;
 651                 default :
 652                     /* implementation specific handlers */
 653                     result =  absHandler.handleNotification(
 654                             resultContainer.notification(), attachment);
 655             }
 656         }
 657 
 658         if (!(handler instanceof InternalNotificationHandler)) {
 659             /* Only remove associations after user handler
 660              * has finished with them */
 661             Association assoc = associationToRemove.get();
 662             if (assoc != null) {
 663                 removeAssociation(assoc);
 664                 associationToRemove.set(null);
 665             }
 666 
 667         }
 668 
 669         return result;
 670     }
 671 
 672     private Association lookupAssociation(int assocId) {
 673         /* Lookup the association in our internal map */
 674         synchronized (stateLock) {
 675             Set&lt;Association&gt; assocs = associationMap.keySet();
 676             for (Association a : assocs) {
 677                 if (a.associationID() == assocId) {
 678                     return a;
 679                 }
 680             }
 681         }
 682         return null;
 683     }
 684 
 685     private void addAssociation(Association association) {
 686         synchronized (stateLock) {
 687             int assocId = association.associationID();
 688             Set&lt;SocketAddress&gt; addresses = null;
 689 
 690             try {
 691                 addresses = SctpNet.getRemoteAddresses(fdVal, assocId);
 692             } catch (IOException unused) {
 693                 /* OK, determining connected addresses may not be possible
 694                  * shutdown, connection lost, etc */
 695             }
 696 
 697             associationMap.put(association, addresses);
 698             if (addresses != null) {
 699                 for (SocketAddress addr : addresses)
 700                     addressMap.put(addr, association);
 701             }
 702         }
 703     }
 704 
 705     private void removeAssociation(Association association) {
 706         synchronized (stateLock) {
 707             int assocId = association.associationID();
 708             Set&lt;SocketAddress&gt; addresses = null;
 709 
 710              try {
 711                 addresses = SctpNet.getRemoteAddresses(fdVal, assocId);
 712             } catch (IOException unused) {
 713                 /* OK, determining connected addresses may not be possible
 714                  * shutdown, connection lost, etc */
 715             }
 716 
 717             Set&lt;Association&gt; assocs = associationMap.keySet();
 718             for (Association a : assocs) {
 719                 if (a.associationID() == assocId) {
 720                     associationMap.remove(a);
 721                     break;
 722                 }
 723             }
 724             if (addresses != null) {
 725                 for (SocketAddress addr : addresses)
 726                     addressMap.remove(addr);
 727             } else {
 728                 /* We cannot determine the connected addresses */
 729                 Set&lt;java.util.Map.Entry&lt;SocketAddress, Association&gt;&gt; addrAssocs =
 730                         addressMap.entrySet();
 731                 Iterator&lt;Entry&lt;SocketAddress, Association&gt;&gt; iterator = addrAssocs.iterator();
 732                 while (iterator.hasNext()) {
 733                     Entry&lt;SocketAddress, Association&gt; entry = iterator.next();
 734                     if (entry.getValue().equals(association)) {
 735                         iterator.remove();
 736                     }
 737                 }
 738             }
 739         }
 740     }
 741 
 742     /**
 743      * @throws  IllegalArgumentException
 744      *          If the given association is not controlled by this channel
 745      *
 746      * @return  {@code true} if, and only if, the given association is one
 747      *          of the current associations controlled by this channel
 748      */
 749     private boolean checkAssociation(Association messageAssoc) {
 750         synchronized (stateLock) {
 751             for (Association association : associationMap.keySet()) {
 752                 if (messageAssoc.equals(association)) {
 753                     return true;
 754                 }
 755             }
 756         }
 757         throw new IllegalArgumentException(
 758               &quot;Given Association is not controlled by this channel&quot;);
 759     }
 760 
 761     private void checkStreamNumber(Association assoc, int streamNumber) {
 762         synchronized (stateLock) {
 763             if (streamNumber &lt; 0 || streamNumber &gt;= assoc.maxOutboundStreams())
 764                 throw new InvalidStreamException();
 765         }
 766     }
 767 
 768     /* TODO: Add support for ttl and isComplete to both 121 12M
 769      *       SCTP_EOR not yet supported on reference platforms
 770      *       TTL support limited...
 771      */
 772     @Override
 773     public int send(ByteBuffer buffer, MessageInfo messageInfo)
 774             throws IOException {
 775         if (buffer == null)
 776             throw new IllegalArgumentException(&quot;buffer cannot be null&quot;);
 777 
 778         if (messageInfo == null)
 779             throw new IllegalArgumentException(&quot;messageInfo cannot be null&quot;);
 780 
 781         synchronized (sendLock) {
 782             ensureOpen();
 783 
 784             if (!isBound())
 785                 bind(null, 0);
 786 
 787             int n = 0;
 788             try {
 789                 int assocId = -1;
 790                 SocketAddress address = null;
 791                 begin();
 792 
 793                 synchronized (stateLock) {
 794                     if(!isOpen())
 795                         return 0;
 796                     senderThread = NativeThread.current();
 797 
 798                     /* Determine what address or association to send to */
 799                     Association assoc = messageInfo.association();
 800                     InetSocketAddress addr = (InetSocketAddress)messageInfo.address();
 801                     if (assoc != null) {
 802                         checkAssociation(assoc);
 803                         checkStreamNumber(assoc, messageInfo.streamNumber());
 804                         assocId = assoc.associationID();
 805                         /* have we also got a preferred address */
 806                         if (addr != null) {
 807                             if (!assoc.equals(addressMap.get(addr)))
 808                                 throw new IllegalArgumentException(&quot;given preferred address is not part of this association&quot;);
 809                             address = addr;
 810                         }
 811                     } else if (addr != null) {
 812                         address = addr;
 813                         Association association = addressMap.get(addr);
 814                         if (association != null) {
 815                             checkStreamNumber(association, messageInfo.streamNumber());
 816                             assocId = association.associationID();
 817 
 818                         } else { /* must be new association */
 819                             SecurityManager sm = System.getSecurityManager();
 820                             if (sm != null)
 821                                 sm.checkConnect(addr.getAddress().getHostAddress(),
 822                                                 addr.getPort());
 823                         }
 824                     } else {
 825                         throw new AssertionError(
 826                             &quot;Both association and address cannot be null&quot;);
 827                     }
 828                 }
 829 
 830                 do {
 831                     n = send(fdVal, buffer, assocId, address, messageInfo);
 832                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 833 
 834                 return IOStatus.normalize(n);
 835             } finally {
 836                 senderCleanup();
 837                 end((n &gt; 0) || (n == IOStatus.UNAVAILABLE));
 838                 assert IOStatus.check(n);
 839             }
 840         }
 841     }
 842 
 843     private int send(int fd,
 844                      ByteBuffer src,
 845                      int assocId,
 846                      SocketAddress target,
 847                      MessageInfo messageInfo)
 848             throws IOException {
 849         int streamNumber = messageInfo.streamNumber();
 850         boolean unordered = messageInfo.isUnordered();
 851         int ppid = messageInfo.payloadProtocolID();
 852 
 853         if (src instanceof DirectBuffer)
 854             return sendFromNativeBuffer(fd, src, target, assocId,
 855                     streamNumber, unordered, ppid);
 856 
 857         /* Substitute a native buffer */
 858         int pos = src.position();
 859         int lim = src.limit();
 860         assert (pos &lt;= lim &amp;&amp; streamNumber &gt;= 0);
 861 
 862         int rem = (pos &lt;= lim ? lim - pos : 0);
 863         ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);
 864         try {
 865             bb.put(src);
 866             bb.flip();
 867             /* Do not update src until we see how many bytes were written */
 868             src.position(pos);
 869 
 870             int n = sendFromNativeBuffer(fd, bb, target, assocId,
 871                     streamNumber, unordered, ppid);
 872             if (n &gt; 0) {
 873                 /* now update src */
 874                 src.position(pos + n);
 875             }
 876             return n;
 877         } finally {
 878             Util.releaseTemporaryDirectBuffer(bb);
 879         }
 880     }
 881 
 882     private int sendFromNativeBuffer(int fd,
 883                                      ByteBuffer bb,
 884                                      SocketAddress target,
 885                                      int assocId,
 886                                      int streamNumber,
 887                                      boolean unordered,
 888                                      int ppid)
 889             throws IOException {
 890         InetAddress addr = null;     // no preferred address
 891         int port = 0;
 892         if (target != null) {
 893             InetSocketAddress isa = Net.checkAddress(target);
 894             addr = isa.getAddress();
 895             port = isa.getPort();
 896         }
 897         int pos = bb.position();
 898         int lim = bb.limit();
 899         assert (pos &lt;= lim);
 900         int rem = (pos &lt;= lim ? lim - pos : 0);
 901 
 902         int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,
 903                             port, assocId, streamNumber, unordered, ppid);
 904         if (written &gt; 0)
 905             bb.position(pos + written);
 906         return written;
 907     }
 908 
 909     @Override
 910     public SctpMultiChannel shutdown(Association association)
 911             throws IOException {
 912         synchronized (stateLock) {
 913             checkAssociation(association);
 914             if (!isOpen())
 915                 throw new ClosedChannelException();
 916 
 917             SctpNet.shutdown(fdVal, association.associationID());
 918         }
 919         return this;
 920     }
 921 
 922     @Override
 923     public Set&lt;SocketAddress&gt; getAllLocalAddresses()
 924             throws IOException {
 925         synchronized (stateLock) {
 926             if (!isOpen())
 927                 throw new ClosedChannelException();
 928             if (!isBound())
 929                 return Collections.emptySet();
 930 
 931             return SctpNet.getLocalAddresses(fdVal);
 932         }
 933     }
 934 
 935     @Override
 936     public Set&lt;SocketAddress&gt; getRemoteAddresses(Association association)
 937             throws IOException {
 938         synchronized (stateLock) {
 939             checkAssociation(association);
 940             if (!isOpen())
 941                 throw new ClosedChannelException();
 942 
 943             try {
 944                 return SctpNet.getRemoteAddresses(fdVal, association.associationID());
 945             } catch (SocketException se) {
 946                 /* a valid association should always have remote addresses */
 947                 Set&lt;SocketAddress&gt; addrs = associationMap.get(association);
 948                 return addrs != null ? addrs : Collections.&lt;SocketAddress&gt;emptySet();
 949             }
 950         }
 951     }
 952 
 953     @Override
 954     public SctpChannel branch(Association association)
 955             throws IOException {
 956         synchronized (stateLock) {
 957             checkAssociation(association);
 958             if (!isOpen())
 959                 throw new ClosedChannelException();
 960 
 961             FileDescriptor bFd = SctpNet.branch(fdVal,
 962                                                 association.associationID());
 963             /* successfully branched, we can now remove it from assoc list */
 964             removeAssociation(association);
 965 
 966             return new SctpChannelImpl(provider(), bFd, association);
 967         }
 968     }
 969 
 970     /* Use common native implementation shared between
 971      * one-to-one and one-to-many */
 972     private static int receive0(int fd,
 973                                 ResultContainer resultContainer,
 974                                 long address,
 975                                 int length)
 976             throws IOException{
 977         return SctpChannelImpl.receive0(fd, resultContainer, address,
 978                 length, false /*peek */);
 979     }
 980 
 981     private static int send0(int fd,
 982                              long address,
 983                              int length,
 984                              InetAddress addr,
 985                              int port,
 986                              int assocId,
 987                              int streamNumber,
 988                              boolean unordered,
 989                              int ppid)
 990             throws IOException {
 991         return SctpChannelImpl.send0(fd, address, length, addr, port, assocId,
 992                 streamNumber, unordered, ppid);
 993     }
 994 
 995     static {
 996         IOUtil.load();   /* loads nio &amp; net native libraries */
 997         java.security.AccessController.doPrivileged(
 998             new java.security.PrivilegedAction&lt;Void&gt;() {
 999                 public Void run() {
1000                     System.loadLibrary(&quot;sctp&quot;);
1001                     return null;
1002                 }
1003             });
1004     }
1005 }
    </pre>
  </body>
</html>
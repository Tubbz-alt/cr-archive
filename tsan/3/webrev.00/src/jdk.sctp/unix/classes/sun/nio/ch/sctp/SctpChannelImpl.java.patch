diff a/src/jdk.sctp/unix/classes/sun/nio/ch/sctp/SctpChannelImpl.java b/src/jdk.sctp/unix/classes/sun/nio/ch/sctp/SctpChannelImpl.java
--- a/src/jdk.sctp/unix/classes/sun/nio/ch/sctp/SctpChannelImpl.java
+++ b/src/jdk.sctp/unix/classes/sun/nio/ch/sctp/SctpChannelImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -51,10 +51,11 @@
 import com.sun.nio.sctp.IllegalUnbindException;
 import com.sun.nio.sctp.MessageInfo;
 import com.sun.nio.sctp.NotificationHandler;
 import com.sun.nio.sctp.SctpChannel;
 import com.sun.nio.sctp.SctpSocketOption;
+import sun.net.util.IPAddressUtil;
 import sun.nio.ch.DirectBuffer;
 import sun.nio.ch.IOStatus;
 import sun.nio.ch.IOUtil;
 import sun.nio.ch.NativeThread;
 import sun.nio.ch.Net;
@@ -463,11 +464,11 @@
                     if (isConnected())
                         return true;
                     if (state != ChannelState.PENDING)
                         throw new NoConnectionPendingException();
                 }
-                int n = 0;
+                boolean connected = false;
                 try {
                     try {
                         begin();
                         synchronized (blockingLock()) {
                             synchronized (stateLock) {
@@ -475,57 +476,36 @@
                                     return false;
                                 }
                                 receiverThread = NativeThread.current();
                             }
                             if (!isBlocking()) {
-                                for (;;) {
-                                    n = Net.pollConnect(fd, 0);
-                                    if (  (n == IOStatus.INTERRUPTED)
-                                          && isOpen())
-                                        continue;
-                                    break;
-                                }
+                                connected = Net.pollConnect(fd, 0);
                             } else {
-                                for (;;) {
-                                    n = Net.pollConnect(fd, -1);
-                                    if (n == 0) {
-                                        // Loop in case of
-                                        // spurious notifications
-                                        continue;
-                                    }
-                                    if (  (n == IOStatus.INTERRUPTED)
-                                          && isOpen())
-                                        continue;
-                                    break;
-                                }
+                                do {
+                                    connected = Net.pollConnect(fd, -1);
+                                } while (!connected && isOpen());
                             }
                         }
                     } finally {
                         synchronized (stateLock) {
                             receiverThread = 0;
                             if (state == ChannelState.KILLPENDING) {
                                 kill();
-                                /* poll()/getsockopt() does not report
-                                 * error (throws exception, with n = 0)
-                                 * on Linux platform after dup2 and
-                                 * signal-wakeup. Force n to 0 so the
-                                 * end() can throw appropriate exception */
-                                n = 0;
+                                connected = false;
                             }
                         }
-                        end((n > 0) || (n == IOStatus.UNAVAILABLE));
-                        assert IOStatus.check(n);
+                        end(connected);
                     }
                 } catch (IOException x) {
                     /* If an exception was thrown, close the channel after
                      * invoking end() so as to avoid bogus
                      * AsynchronousCloseExceptions */
                     close();
                     throw x;
                 }
 
-                if (n > 0) {
+                if (connected) {
                     synchronized (stateLock) {
                         state = ChannelState.CONNECTED;
                         if (!isBound()) {
                             InetSocketAddress boundIsa =
                                     Net.localAddress(fd);
@@ -1031,10 +1011,13 @@
         InetAddress addr = null;     // no preferred address
         int port = 0;
         if (target != null) {
             InetSocketAddress isa = Net.checkAddress(target);
             addr = isa.getAddress();
+            if (addr.isLinkLocalAddress()) {
+                addr = IPAddressUtil.toScopedAddress(addr);
+            }
             port = isa.getPort();
         }
 
         int pos = bb.position();
         int lim = bb.limit();

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.sctp/unix/classes/sun/nio/ch/sctp/SctpChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package sun.nio.ch.sctp;
  26 
  27 import java.net.InetAddress;
  28 import java.net.SocketAddress;
  29 import java.net.SocketException;
  30 import java.net.InetSocketAddress;
  31 import java.io.FileDescriptor;
  32 import java.io.IOException;
  33 import java.util.Collections;
  34 import java.util.Set;
  35 import java.util.HashSet;
  36 import java.nio.ByteBuffer;
  37 import java.nio.channels.SelectionKey;
  38 import java.nio.channels.ClosedChannelException;
  39 import java.nio.channels.ConnectionPendingException;
  40 import java.nio.channels.NoConnectionPendingException;
  41 import java.nio.channels.AlreadyConnectedException;
  42 import java.nio.channels.NotYetBoundException;
  43 import java.nio.channels.NotYetConnectedException;
  44 import java.nio.channels.spi.SelectorProvider;
  45 import com.sun.nio.sctp.AbstractNotificationHandler;
  46 import com.sun.nio.sctp.Association;
  47 import com.sun.nio.sctp.AssociationChangeNotification;
  48 import com.sun.nio.sctp.HandlerResult;
  49 import com.sun.nio.sctp.IllegalReceiveException;
  50 import com.sun.nio.sctp.InvalidStreamException;
  51 import com.sun.nio.sctp.IllegalUnbindException;
  52 import com.sun.nio.sctp.MessageInfo;
  53 import com.sun.nio.sctp.NotificationHandler;
  54 import com.sun.nio.sctp.SctpChannel;
  55 import com.sun.nio.sctp.SctpSocketOption;
<a name="2" id="anc2"></a><span class="line-added">  56 import sun.net.util.IPAddressUtil;</span>
  57 import sun.nio.ch.DirectBuffer;
  58 import sun.nio.ch.IOStatus;
  59 import sun.nio.ch.IOUtil;
  60 import sun.nio.ch.NativeThread;
  61 import sun.nio.ch.Net;
  62 import sun.nio.ch.SelChImpl;
  63 import sun.nio.ch.SelectionKeyImpl;
  64 import sun.nio.ch.Util;
  65 import static com.sun.nio.sctp.SctpStandardSocketOptions.*;
  66 import static sun.nio.ch.sctp.ResultContainer.SEND_FAILED;
  67 import static sun.nio.ch.sctp.ResultContainer.ASSOCIATION_CHANGED;
  68 import static sun.nio.ch.sctp.ResultContainer.PEER_ADDRESS_CHANGED;
  69 import static sun.nio.ch.sctp.ResultContainer.SHUTDOWN;
  70 
  71 /**
  72  * An implementation of an SctpChannel
  73  */
  74 public class SctpChannelImpl extends SctpChannel
  75     implements SelChImpl
  76 {
  77     private final FileDescriptor fd;
  78 
  79     private final int fdVal;
  80 
  81     /* IDs of native threads doing send and receivess, for signalling */
  82     private volatile long receiverThread = 0;
  83     private volatile long senderThread = 0;
  84 
  85     /* Lock held by current receiving or connecting thread */
  86     private final Object receiveLock = new Object();
  87 
  88     /* Lock held by current sending or connecting thread */
  89     private final Object sendLock = new Object();
  90 
  91     private final ThreadLocal&lt;Boolean&gt; receiveInvoked =
  92         new ThreadLocal&lt;Boolean&gt;() {
  93              @Override protected Boolean initialValue() {
  94                  return Boolean.FALSE;
  95             }
  96     };
  97 
  98     /* Lock held by any thread that modifies the state fields declared below
  99        DO NOT invoke a blocking I/O operation while holding this lock! */
 100     private final Object stateLock = new Object();
 101 
 102     private enum ChannelState {
 103         UNINITIALIZED,
 104         UNCONNECTED,
 105         PENDING,
 106         CONNECTED,
 107         KILLPENDING,
 108         KILLED,
 109     }
 110     /* -- The following fields are protected by stateLock -- */
 111     private ChannelState state = ChannelState.UNINITIALIZED;
 112 
 113     /* Binding; Once bound the port will remain constant. */
 114     int port = -1;
 115     private HashSet&lt;InetSocketAddress&gt; localAddresses = new HashSet&lt;InetSocketAddress&gt;();
 116     /* Has the channel been bound to the wildcard address */
 117     private boolean wildcard; /* false */
 118     //private InetSocketAddress remoteAddress = null;
 119 
 120     /* Input/Output open */
 121     private boolean readyToConnect;
 122 
 123     /* Shutdown */
 124     private boolean isShutdown;
 125 
 126     private Association association;
 127 
 128     private Set&lt;SocketAddress&gt; remoteAddresses = Collections.emptySet();
 129 
 130     /* -- End of fields protected by stateLock -- */
 131 
 132     /**
 133      * Constructor for normal connecting sockets
 134      */
 135     public SctpChannelImpl(SelectorProvider provider) throws IOException {
 136         //TODO: update provider remove public modifier
 137         super(provider);
 138         this.fd = SctpNet.socket(true);
 139         this.fdVal = IOUtil.fdVal(fd);
 140         this.state = ChannelState.UNCONNECTED;
 141     }
 142 
 143     /**
 144      * Constructor for sockets obtained from server sockets
 145      */
 146     public SctpChannelImpl(SelectorProvider provider, FileDescriptor fd)
 147          throws IOException {
 148         this(provider, fd, null);
 149     }
 150 
 151     /**
 152      * Constructor for sockets obtained from branching
 153      */
 154     public SctpChannelImpl(SelectorProvider provider,
 155                            FileDescriptor fd,
 156                            Association association)
 157             throws IOException {
 158         super(provider);
 159         this.fd = fd;
 160         this.fdVal = IOUtil.fdVal(fd);
 161         this.state = ChannelState.CONNECTED;
 162         port = (Net.localAddress(fd)).getPort();
 163 
 164         if (association != null) { /* branched */
 165             this.association = association;
 166         } else { /* obtained from server channel */
 167             /* Receive COMM_UP */
 168             ByteBuffer buf = Util.getTemporaryDirectBuffer(50);
 169             try {
 170                 receive(buf, null, null, true);
 171             } finally {
 172                 Util.releaseTemporaryDirectBuffer(buf);
 173             }
 174         }
 175     }
 176 
 177     /**
 178      * Binds the channel&#39;s socket to a local address.
 179      */
 180     @Override
 181     public SctpChannel bind(SocketAddress local) throws IOException {
 182         synchronized (receiveLock) {
 183             synchronized (sendLock) {
 184                 synchronized (stateLock) {
 185                     ensureOpenAndUnconnected();
 186                     if (isBound())
 187                         SctpNet.throwAlreadyBoundException();
 188                     InetSocketAddress isa = (local == null) ?
 189                         new InetSocketAddress(0) : Net.checkAddress(local);
 190                     SecurityManager sm = System.getSecurityManager();
 191                     if (sm != null) {
 192                         sm.checkListen(isa.getPort());
 193                     }
 194                     Net.bind(fd, isa.getAddress(), isa.getPort());
 195                     InetSocketAddress boundIsa = Net.localAddress(fd);
 196                     port = boundIsa.getPort();
 197                     localAddresses.add(isa);
 198                     if (isa.getAddress().isAnyLocalAddress())
 199                         wildcard = true;
 200                 }
 201             }
 202         }
 203         return this;
 204     }
 205 
 206     @Override
 207     public SctpChannel bindAddress(InetAddress address)
 208             throws IOException {
 209         bindUnbindAddress(address, true);
 210         localAddresses.add(new InetSocketAddress(address, port));
 211         return this;
 212     }
 213 
 214     @Override
 215     public SctpChannel unbindAddress(InetAddress address)
 216             throws IOException {
 217         bindUnbindAddress(address, false);
 218         localAddresses.remove(new InetSocketAddress(address, port));
 219         return this;
 220     }
 221 
 222     private SctpChannel bindUnbindAddress(InetAddress address, boolean add)
 223             throws IOException {
 224         if (address == null)
 225             throw new IllegalArgumentException();
 226 
 227         synchronized (receiveLock) {
 228             synchronized (sendLock) {
 229                 synchronized (stateLock) {
 230                     if (!isOpen())
 231                         throw new ClosedChannelException();
 232                     if (!isBound())
 233                         throw new NotYetBoundException();
 234                     if (wildcard)
 235                         throw new IllegalStateException(
 236                                 &quot;Cannot add or remove addresses from a channel that is bound to the wildcard address&quot;);
 237                     if (address.isAnyLocalAddress())
 238                         throw new IllegalArgumentException(
 239                                 &quot;Cannot add or remove the wildcard address&quot;);
 240                     if (add) {
 241                         for (InetSocketAddress addr : localAddresses) {
 242                             if (addr.getAddress().equals(address)) {
 243                                 SctpNet.throwAlreadyBoundException();
 244                             }
 245                         }
 246                     } else { /*removing */
 247                         /* Verify that there is more than one address
 248                          * and that address is already bound */
 249                         if (localAddresses.size() &lt;= 1)
 250                             throw new IllegalUnbindException(&quot;Cannot remove address from a channel with only one address bound&quot;);
 251                         boolean foundAddress = false;
 252                         for (InetSocketAddress addr : localAddresses) {
 253                             if (addr.getAddress().equals(address)) {
 254                                 foundAddress = true;
 255                                 break;
 256                             }
 257                         }
 258                         if (!foundAddress )
 259                             throw new IllegalUnbindException(&quot;Cannot remove address from a channel that is not bound to that address&quot;);
 260                     }
 261 
 262                     SctpNet.bindx(fdVal, new InetAddress[]{address}, port, add);
 263 
 264                     /* Update our internal Set to reflect the addition/removal */
 265                     if (add)
 266                         localAddresses.add(new InetSocketAddress(address, port));
 267                     else {
 268                         for (InetSocketAddress addr : localAddresses) {
 269                             if (addr.getAddress().equals(address)) {
 270                                 localAddresses.remove(addr);
 271                                 break;
 272                             }
 273                         }
 274                     }
 275                 }
 276             }
 277         }
 278         return this;
 279     }
 280 
 281     private boolean isBound() {
 282         synchronized (stateLock) {
 283             return port == -1 ? false : true;
 284         }
 285     }
 286 
 287     private boolean isConnected() {
 288         synchronized (stateLock) {
 289             return (state == ChannelState.CONNECTED);
 290         }
 291     }
 292 
 293     private void ensureOpenAndUnconnected() throws IOException {
 294         synchronized (stateLock) {
 295             if (!isOpen())
 296                 throw new ClosedChannelException();
 297             if (isConnected())
 298                 throw new AlreadyConnectedException();
 299             if (state == ChannelState.PENDING)
 300                 throw new ConnectionPendingException();
 301         }
 302     }
 303 
 304     private boolean ensureReceiveOpen() throws ClosedChannelException {
 305         synchronized (stateLock) {
 306             if (!isOpen())
 307                 throw new ClosedChannelException();
 308             if (!isConnected())
 309                 throw new NotYetConnectedException();
 310             else
 311                 return true;
 312         }
 313     }
 314 
 315     private void ensureSendOpen() throws ClosedChannelException {
 316         synchronized (stateLock) {
 317             if (!isOpen())
 318                 throw new ClosedChannelException();
 319             if (isShutdown)
 320                 throw new ClosedChannelException();
 321             if (!isConnected())
 322                 throw new NotYetConnectedException();
 323         }
 324     }
 325 
 326     private void receiverCleanup() throws IOException {
 327         synchronized (stateLock) {
 328             receiverThread = 0;
 329             if (state == ChannelState.KILLPENDING)
 330                 kill();
 331         }
 332     }
 333 
 334     private void senderCleanup() throws IOException {
 335         synchronized (stateLock) {
 336             senderThread = 0;
 337             if (state == ChannelState.KILLPENDING)
 338                 kill();
 339         }
 340     }
 341 
 342     @Override
 343     public Association association() throws ClosedChannelException {
 344         synchronized (stateLock) {
 345             if (!isOpen())
 346                 throw new ClosedChannelException();
 347             if (!isConnected())
 348                 return null;
 349 
 350             return association;
 351         }
 352     }
 353 
 354     @Override
 355     public boolean connect(SocketAddress endpoint) throws IOException {
 356         synchronized (receiveLock) {
 357             synchronized (sendLock) {
 358                 ensureOpenAndUnconnected();
 359                 InetSocketAddress isa = Net.checkAddress(endpoint);
 360                 SecurityManager sm = System.getSecurityManager();
 361                 if (sm != null)
 362                     sm.checkConnect(isa.getAddress().getHostAddress(),
 363                                     isa.getPort());
 364                 synchronized (blockingLock()) {
 365                     int n = 0;
 366                     try {
 367                         try {
 368                             begin();
 369                             synchronized (stateLock) {
 370                                 if (!isOpen()) {
 371                                     return false;
 372                                 }
 373                                 receiverThread = NativeThread.current();
 374                             }
 375                             for (;;) {
 376                                 InetAddress ia = isa.getAddress();
 377                                 if (ia.isAnyLocalAddress())
 378                                     ia = InetAddress.getLocalHost();
 379                                 n = SctpNet.connect(fdVal, ia, isa.getPort());
 380                                 if (  (n == IOStatus.INTERRUPTED)
 381                                       &amp;&amp; isOpen())
 382                                     continue;
 383                                 break;
 384                             }
 385                         } finally {
 386                             receiverCleanup();
 387                             end((n &gt; 0) || (n == IOStatus.UNAVAILABLE));
 388                             assert IOStatus.check(n);
 389                         }
 390                     } catch (IOException x) {
 391                         /* If an exception was thrown, close the channel after
 392                          * invoking end() so as to avoid bogus
 393                          * AsynchronousCloseExceptions */
 394                         close();
 395                         throw x;
 396                     }
 397 
 398                     if (n &gt; 0) {
 399                         synchronized (stateLock) {
 400                             /* Connection succeeded */
 401                             state = ChannelState.CONNECTED;
 402                             if (!isBound()) {
 403                                 InetSocketAddress boundIsa =
 404                                         Net.localAddress(fd);
 405                                 port = boundIsa.getPort();
 406                             }
 407 
 408                             /* Receive COMM_UP */
 409                             ByteBuffer buf = Util.getTemporaryDirectBuffer(50);
 410                             try {
 411                                 receive(buf, null, null, true);
 412                             } finally {
 413                                 Util.releaseTemporaryDirectBuffer(buf);
 414                             }
 415 
 416                             /* cache remote addresses */
 417                             try {
 418                                 remoteAddresses = getRemoteAddresses();
 419                             } catch (IOException unused) { /* swallow exception */ }
 420 
 421                             return true;
 422                         }
 423                     } else  {
 424                         synchronized (stateLock) {
 425                             /* If nonblocking and no exception then connection
 426                              * pending; disallow another invocation */
 427                             if (!isBlocking())
 428                                 state = ChannelState.PENDING;
 429                             else
 430                                 assert false;
 431                         }
 432                     }
 433                 }
 434                 return false;
 435             }
 436         }
 437     }
 438 
 439     @Override
 440     public boolean connect(SocketAddress endpoint,
 441                            int maxOutStreams,
 442                            int maxInStreams)
 443             throws IOException {
 444         ensureOpenAndUnconnected();
 445         return setOption(SCTP_INIT_MAXSTREAMS, InitMaxStreams.
 446                 create(maxInStreams, maxOutStreams)).connect(endpoint);
 447 
 448     }
 449 
 450     @Override
 451     public boolean isConnectionPending() {
 452         synchronized (stateLock) {
 453             return (state == ChannelState.PENDING);
 454         }
 455     }
 456 
 457     @Override
 458     public boolean finishConnect() throws IOException {
 459         synchronized (receiveLock) {
 460             synchronized (sendLock) {
 461                 synchronized (stateLock) {
 462                     if (!isOpen())
 463                         throw new ClosedChannelException();
 464                     if (isConnected())
 465                         return true;
 466                     if (state != ChannelState.PENDING)
 467                         throw new NoConnectionPendingException();
 468                 }
<a name="3" id="anc3"></a><span class="line-modified"> 469                 boolean connected = false;</span>
 470                 try {
 471                     try {
 472                         begin();
 473                         synchronized (blockingLock()) {
 474                             synchronized (stateLock) {
 475                                 if (!isOpen()) {
 476                                     return false;
 477                                 }
 478                                 receiverThread = NativeThread.current();
 479                             }
 480                             if (!isBlocking()) {
<a name="4" id="anc4"></a><span class="line-modified"> 481                                 connected = Net.pollConnect(fd, 0);</span>






 482                             } else {
<a name="5" id="anc5"></a><span class="line-modified"> 483                                 do {</span>
<span class="line-modified"> 484                                     connected = Net.pollConnect(fd, -1);</span>
<span class="line-modified"> 485                                 } while (!connected &amp;&amp; isOpen());</span>









 486                             }
 487                         }
 488                     } finally {
 489                         synchronized (stateLock) {
 490                             receiverThread = 0;
 491                             if (state == ChannelState.KILLPENDING) {
 492                                 kill();
<a name="6" id="anc6"></a><span class="line-modified"> 493                                 connected = false;</span>





 494                             }
 495                         }
<a name="7" id="anc7"></a><span class="line-modified"> 496                         end(connected);</span>

 497                     }
 498                 } catch (IOException x) {
 499                     /* If an exception was thrown, close the channel after
 500                      * invoking end() so as to avoid bogus
 501                      * AsynchronousCloseExceptions */
 502                     close();
 503                     throw x;
 504                 }
 505 
<a name="8" id="anc8"></a><span class="line-modified"> 506                 if (connected) {</span>
 507                     synchronized (stateLock) {
 508                         state = ChannelState.CONNECTED;
 509                         if (!isBound()) {
 510                             InetSocketAddress boundIsa =
 511                                     Net.localAddress(fd);
 512                             port = boundIsa.getPort();
 513                         }
 514 
 515                         /* Receive COMM_UP */
 516                         ByteBuffer buf = Util.getTemporaryDirectBuffer(50);
 517                         try {
 518                             receive(buf, null, null, true);
 519                         } finally {
 520                             Util.releaseTemporaryDirectBuffer(buf);
 521                         }
 522 
 523                         /* cache remote addresses */
 524                         try {
 525                             remoteAddresses = getRemoteAddresses();
 526                         } catch (IOException unused) { /* swallow exception */ }
 527 
 528                         return true;
 529                     }
 530                 }
 531             }
 532         }
 533         return false;
 534     }
 535 
 536     @Override
 537     protected void implConfigureBlocking(boolean block) throws IOException {
 538         IOUtil.configureBlocking(fd, block);
 539     }
 540 
 541     @Override
 542     public void implCloseSelectableChannel() throws IOException {
 543         synchronized (stateLock) {
 544             SctpNet.preClose(fdVal);
 545 
 546             if (receiverThread != 0)
 547                 NativeThread.signal(receiverThread);
 548 
 549             if (senderThread != 0)
 550                 NativeThread.signal(senderThread);
 551 
 552             if (!isRegistered())
 553                 kill();
 554         }
 555     }
 556 
 557     @Override
 558     public FileDescriptor getFD() {
 559         return fd;
 560     }
 561 
 562     @Override
 563     public int getFDVal() {
 564         return fdVal;
 565     }
 566 
 567     /**
 568      * Translates native poll revent ops into a ready operation ops
 569      */
 570     private boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl sk) {
 571         int intOps = sk.nioInterestOps();
 572         int oldOps = sk.nioReadyOps();
 573         int newOps = initialOps;
 574 
 575         if ((ops &amp; Net.POLLNVAL) != 0) {
 576             /* This should only happen if this channel is pre-closed while a
 577              * selection operation is in progress
 578              * ## Throw an error if this channel has not been pre-closed */
 579             return false;
 580         }
 581 
 582         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
 583             newOps = intOps;
 584             sk.nioReadyOps(newOps);
 585             /* No need to poll again in checkConnect,
 586              * the error will be detected there */
 587             readyToConnect = true;
 588             return (newOps &amp; ~oldOps) != 0;
 589         }
 590 
 591         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
 592             ((intOps &amp; SelectionKey.OP_READ) != 0) &amp;&amp;
 593             isConnected())
 594             newOps |= SelectionKey.OP_READ;
 595 
 596         if (((ops &amp; Net.POLLCONN) != 0) &amp;&amp;
 597             ((intOps &amp; SelectionKey.OP_CONNECT) != 0) &amp;&amp;
 598             ((state == ChannelState.UNCONNECTED) || (state == ChannelState.PENDING))) {
 599             newOps |= SelectionKey.OP_CONNECT;
 600             readyToConnect = true;
 601         }
 602 
 603         if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp;
 604             ((intOps &amp; SelectionKey.OP_WRITE) != 0) &amp;&amp;
 605             isConnected())
 606             newOps |= SelectionKey.OP_WRITE;
 607 
 608         sk.nioReadyOps(newOps);
 609         return (newOps &amp; ~oldOps) != 0;
 610     }
 611 
 612     @Override
 613     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl sk) {
 614         return translateReadyOps(ops, sk.nioReadyOps(), sk);
 615     }
 616 
 617     @Override
 618     @SuppressWarnings(&quot;all&quot;)
 619     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl sk) {
 620         return translateReadyOps(ops, 0, sk);
 621     }
 622 
 623     @Override
 624     public int translateInterestOps(int ops) {
 625         int newOps = 0;
 626         if ((ops &amp; SelectionKey.OP_READ) != 0)
 627             newOps |= Net.POLLIN;
 628         if ((ops &amp; SelectionKey.OP_WRITE) != 0)
 629             newOps |= Net.POLLOUT;
 630         if ((ops &amp; SelectionKey.OP_CONNECT) != 0)
 631             newOps |= Net.POLLCONN;
 632         return newOps;
 633     }
 634 
 635     @Override
 636     public void kill() throws IOException {
 637         synchronized (stateLock) {
 638             if (state == ChannelState.KILLED)
 639                 return;
 640             if (state == ChannelState.UNINITIALIZED) {
 641                 state = ChannelState.KILLED;
 642                 return;
 643             }
 644             assert !isOpen() &amp;&amp; !isRegistered();
 645 
 646             /* Postpone the kill if there is a waiting reader
 647              * or writer thread. */
 648             if (receiverThread == 0 &amp;&amp; senderThread == 0) {
 649                 SctpNet.close(fdVal);
 650                 state = ChannelState.KILLED;
 651             } else {
 652                 state = ChannelState.KILLPENDING;
 653             }
 654         }
 655     }
 656 
 657     @Override
 658     public &lt;T&gt; SctpChannel setOption(SctpSocketOption&lt;T&gt; name, T value)
 659             throws IOException {
 660         if (name == null)
 661             throw new NullPointerException();
 662         if (!supportedOptions().contains(name))
 663             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 664 
 665         synchronized (stateLock) {
 666             if (!isOpen())
 667                 throw new ClosedChannelException();
 668 
 669             SctpNet.setSocketOption(fdVal, name, value, 0 /*oneToOne*/);
 670         }
 671         return this;
 672     }
 673 
 674     @Override
 675     @SuppressWarnings(&quot;unchecked&quot;)
 676     public &lt;T&gt; T getOption(SctpSocketOption&lt;T&gt; name) throws IOException {
 677         if (name == null)
 678             throw new NullPointerException();
 679         if (!supportedOptions().contains(name))
 680             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 681 
 682         synchronized (stateLock) {
 683             if (!isOpen())
 684                 throw new ClosedChannelException();
 685 
 686             return (T)SctpNet.getSocketOption(fdVal, name, 0 /*oneToOne*/);
 687         }
 688     }
 689 
 690     private static class DefaultOptionsHolder {
 691         static final Set&lt;SctpSocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 692 
 693         private static Set&lt;SctpSocketOption&lt;?&gt;&gt; defaultOptions() {
 694             HashSet&lt;SctpSocketOption&lt;?&gt;&gt; set = new HashSet&lt;SctpSocketOption&lt;?&gt;&gt;(10);
 695             set.add(SCTP_DISABLE_FRAGMENTS);
 696             set.add(SCTP_EXPLICIT_COMPLETE);
 697             set.add(SCTP_FRAGMENT_INTERLEAVE);
 698             set.add(SCTP_INIT_MAXSTREAMS);
 699             set.add(SCTP_NODELAY);
 700             set.add(SCTP_PRIMARY_ADDR);
 701             set.add(SCTP_SET_PEER_PRIMARY_ADDR);
 702             set.add(SO_SNDBUF);
 703             set.add(SO_RCVBUF);
 704             set.add(SO_LINGER);
 705             return Collections.unmodifiableSet(set);
 706         }
 707     }
 708 
 709     @Override
 710     public final Set&lt;SctpSocketOption&lt;?&gt;&gt; supportedOptions() {
 711         return DefaultOptionsHolder.defaultOptions;
 712     }
 713 
 714     @Override
 715     public &lt;T&gt; MessageInfo receive(ByteBuffer buffer,
 716                                    T attachment,
 717                                    NotificationHandler&lt;T&gt; handler)
 718             throws IOException {
 719         return receive(buffer, attachment, handler, false);
 720     }
 721 
 722     private &lt;T&gt; MessageInfo receive(ByteBuffer buffer,
 723                                     T attachment,
 724                                     NotificationHandler&lt;T&gt; handler,
 725                                     boolean fromConnect)
 726             throws IOException {
 727         if (buffer == null)
 728             throw new IllegalArgumentException(&quot;buffer cannot be null&quot;);
 729 
 730         if (buffer.isReadOnly())
 731             throw new IllegalArgumentException(&quot;Read-only buffer&quot;);
 732 
 733         if (receiveInvoked.get())
 734             throw new IllegalReceiveException(
 735                     &quot;cannot invoke receive from handler&quot;);
 736         receiveInvoked.set(Boolean.TRUE);
 737 
 738         try {
 739             ResultContainer resultContainer = new ResultContainer();
 740             do {
 741                 resultContainer.clear();
 742                 synchronized (receiveLock) {
 743                     if (!ensureReceiveOpen())
 744                         return null;
 745 
 746                     int n = 0;
 747                     try {
 748                         begin();
 749 
 750                         synchronized (stateLock) {
 751                             if(!isOpen())
 752                                 return null;
 753                             receiverThread = NativeThread.current();
 754                         }
 755 
 756                         do {
 757                             n = receive(fdVal, buffer, resultContainer, fromConnect);
 758                         } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 759                     } finally {
 760                         receiverCleanup();
 761                         end((n &gt; 0) || (n == IOStatus.UNAVAILABLE));
 762                         assert IOStatus.check(n);
 763                     }
 764 
 765                     if (!resultContainer.isNotification()) {
 766                         /* message or nothing */
 767                         if (resultContainer.hasSomething()) {
 768                             /* Set the association before returning */
 769                             MessageInfoImpl info =
 770                                     resultContainer.getMessageInfo();
 771                             synchronized (stateLock) {
 772                                 assert association != null;
 773                                 info.setAssociation(association);
 774                             }
 775                             return info;
 776                         } else
 777                             /* Non-blocking may return null if nothing available*/
 778                             return null;
 779                     } else { /* notification */
 780                         synchronized (stateLock) {
 781                             handleNotificationInternal(
 782                                     resultContainer);
 783                         }
 784                     }
 785 
 786                     if (fromConnect)  {
 787                         /* If we reach here, then it was connect that invoked
 788                          * receive and received the COMM_UP. We have already
 789                          * handled the COMM_UP with the internal notification
 790                          * handler. Simply return. */
 791                         return null;
 792                     }
 793                 }  /* receiveLock */
 794             } while (handler == null ? true :
 795                 (invokeNotificationHandler(resultContainer, handler, attachment)
 796                  == HandlerResult.CONTINUE));
 797 
 798             return null;
 799         } finally {
 800             receiveInvoked.set(Boolean.FALSE);
 801         }
 802     }
 803 
 804     private int receive(int fd,
 805                         ByteBuffer dst,
 806                         ResultContainer resultContainer,
 807                         boolean peek)
 808             throws IOException {
 809         int pos = dst.position();
 810         int lim = dst.limit();
 811         assert (pos &lt;= lim);
 812         int rem = (pos &lt;= lim ? lim - pos : 0);
 813         if (dst instanceof DirectBuffer &amp;&amp; rem &gt; 0)
 814             return receiveIntoNativeBuffer(fd, resultContainer, dst, rem, pos, peek);
 815 
 816         /* Substitute a native buffer */
 817         int newSize = Math.max(rem, 1);
 818         ByteBuffer bb = Util.getTemporaryDirectBuffer(newSize);
 819         try {
 820             int n = receiveIntoNativeBuffer(fd, resultContainer, bb, newSize, 0, peek);
 821             bb.flip();
 822             if (n &gt; 0 &amp;&amp; rem &gt; 0)
 823                 dst.put(bb);
 824             return n;
 825         } finally {
 826             Util.releaseTemporaryDirectBuffer(bb);
 827         }
 828     }
 829 
 830     private int receiveIntoNativeBuffer(int fd,
 831                                         ResultContainer resultContainer,
 832                                         ByteBuffer bb,
 833                                         int rem,
 834                                         int pos,
 835                                         boolean peek)
 836         throws IOException
 837     {
 838         int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);
 839 
 840         if (n &gt; 0)
 841             bb.position(pos + n);
 842         return n;
 843     }
 844 
 845     private InternalNotificationHandler internalNotificationHandler =
 846             new InternalNotificationHandler();
 847 
 848     private void handleNotificationInternal(ResultContainer resultContainer)
 849     {
 850         invokeNotificationHandler(resultContainer,
 851                 internalNotificationHandler, null);
 852     }
 853 
 854     private class InternalNotificationHandler
 855             extends AbstractNotificationHandler&lt;Object&gt;
 856     {
 857         @Override
 858         public HandlerResult handleNotification(
 859                 AssociationChangeNotification not, Object unused) {
 860             if (not.event().equals(
 861                     AssociationChangeNotification.AssocChangeEvent.COMM_UP) &amp;&amp;
 862                     association == null) {
 863                 AssociationChange sac = (AssociationChange) not;
 864                 association = new AssociationImpl
 865                        (sac.assocId(), sac.maxInStreams(), sac.maxOutStreams());
 866             }
 867             return HandlerResult.CONTINUE;
 868         }
 869     }
 870 
 871     private &lt;T&gt; HandlerResult invokeNotificationHandler
 872                                  (ResultContainer resultContainer,
 873                                   NotificationHandler&lt;T&gt; handler,
 874                                   T attachment) {
 875         SctpNotification notification = resultContainer.notification();
 876         synchronized (stateLock) {
 877             notification.setAssociation(association);
 878         }
 879 
 880         if (!(handler instanceof AbstractNotificationHandler)) {
 881             return handler.handleNotification(notification, attachment);
 882         }
 883 
 884         /* AbstractNotificationHandler */
 885         AbstractNotificationHandler&lt;T&gt; absHandler =
 886                 (AbstractNotificationHandler&lt;T&gt;)handler;
 887         switch(resultContainer.type()) {
 888             case ASSOCIATION_CHANGED :
 889                 return absHandler.handleNotification(
 890                         resultContainer.getAssociationChanged(), attachment);
 891             case PEER_ADDRESS_CHANGED :
 892                 return absHandler.handleNotification(
 893                         resultContainer.getPeerAddressChanged(), attachment);
 894             case SEND_FAILED :
 895                 return absHandler.handleNotification(
 896                         resultContainer.getSendFailed(), attachment);
 897             case SHUTDOWN :
 898                 return absHandler.handleNotification(
 899                         resultContainer.getShutdown(), attachment);
 900             default :
 901                 /* implementation specific handlers */
 902                 return absHandler.handleNotification(
 903                         resultContainer.notification(), attachment);
 904         }
 905     }
 906 
 907     private void checkAssociation(Association sendAssociation) {
 908         synchronized (stateLock) {
 909             if (sendAssociation != null &amp;&amp; !sendAssociation.equals(association)) {
 910                 throw new IllegalArgumentException(
 911                         &quot;Cannot send to another association&quot;);
 912             }
 913         }
 914     }
 915 
 916     private void checkStreamNumber(int streamNumber) {
 917         synchronized (stateLock) {
 918             if (association != null) {
 919                 if (streamNumber &lt; 0 ||
 920                       streamNumber &gt;= association.maxOutboundStreams())
 921                     throw new InvalidStreamException();
 922             }
 923         }
 924     }
 925 
 926     /* TODO: Add support for ttl and isComplete to both 121 12M
 927      *       SCTP_EOR not yet supported on reference platforms
 928      *       TTL support limited...
 929      */
 930     @Override
 931     public int send(ByteBuffer buffer, MessageInfo messageInfo)
 932             throws IOException {
 933         if (buffer == null)
 934             throw new IllegalArgumentException(&quot;buffer cannot be null&quot;);
 935 
 936         if (messageInfo == null)
 937             throw new IllegalArgumentException(&quot;messageInfo cannot be null&quot;);
 938 
 939         checkAssociation(messageInfo.association());
 940         checkStreamNumber(messageInfo.streamNumber());
 941 
 942         synchronized (sendLock) {
 943             ensureSendOpen();
 944 
 945             int n = 0;
 946             try {
 947                 begin();
 948 
 949                 synchronized (stateLock) {
 950                     if(!isOpen())
 951                         return 0;
 952                     senderThread = NativeThread.current();
 953                 }
 954 
 955                 do {
 956                     n = send(fdVal, buffer, messageInfo);
 957                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());
 958 
 959                 return IOStatus.normalize(n);
 960             } finally {
 961                 senderCleanup();
 962                 end((n &gt; 0) || (n == IOStatus.UNAVAILABLE));
 963                 assert IOStatus.check(n);
 964             }
 965         }
 966     }
 967 
 968     private int send(int fd, ByteBuffer src, MessageInfo messageInfo)
 969             throws IOException {
 970         int streamNumber = messageInfo.streamNumber();
 971         SocketAddress target = messageInfo.address();
 972         boolean unordered = messageInfo.isUnordered();
 973         int ppid = messageInfo.payloadProtocolID();
 974 
 975         if (src instanceof DirectBuffer)
 976             return sendFromNativeBuffer(fd, src, target, streamNumber,
 977                     unordered, ppid);
 978 
 979         /* Substitute a native buffer */
 980         int pos = src.position();
 981         int lim = src.limit();
 982         assert (pos &lt;= lim &amp;&amp; streamNumber &gt;= 0);
 983 
 984         int rem = (pos &lt;= lim ? lim - pos : 0);
 985         ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);
 986         try {
 987             bb.put(src);
 988             bb.flip();
 989             /* Do not update src until we see how many bytes were written */
 990             src.position(pos);
 991 
 992             int n = sendFromNativeBuffer(fd, bb, target, streamNumber,
 993                     unordered, ppid);
 994             if (n &gt; 0) {
 995                 /* now update src */
 996                 src.position(pos + n);
 997             }
 998             return n;
 999         } finally {
1000             Util.releaseTemporaryDirectBuffer(bb);
1001         }
1002     }
1003 
1004     private int sendFromNativeBuffer(int fd,
1005                                      ByteBuffer bb,
1006                                      SocketAddress target,
1007                                      int streamNumber,
1008                                      boolean unordered,
1009                                      int ppid)
1010             throws IOException {
1011         InetAddress addr = null;     // no preferred address
1012         int port = 0;
1013         if (target != null) {
1014             InetSocketAddress isa = Net.checkAddress(target);
1015             addr = isa.getAddress();
<a name="9" id="anc9"></a><span class="line-added">1016             if (addr.isLinkLocalAddress()) {</span>
<span class="line-added">1017                 addr = IPAddressUtil.toScopedAddress(addr);</span>
<span class="line-added">1018             }</span>
1019             port = isa.getPort();
1020         }
1021 
1022         int pos = bb.position();
1023         int lim = bb.limit();
1024         assert (pos &lt;= lim);
1025         int rem = (pos &lt;= lim ? lim - pos : 0);
1026 
1027         int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,
1028                             port, -1 /*121*/, streamNumber, unordered, ppid);
1029         if (written &gt; 0)
1030             bb.position(pos + written);
1031         return written;
1032     }
1033 
1034     @Override
1035     public SctpChannel shutdown() throws IOException {
1036         synchronized(stateLock) {
1037             if (isShutdown)
1038                 return this;
1039 
1040             ensureSendOpen();
1041             SctpNet.shutdown(fdVal, -1);
1042             if (senderThread != 0)
1043                 NativeThread.signal(senderThread);
1044             isShutdown = true;
1045         }
1046         return this;
1047     }
1048 
1049     @Override
1050     public Set&lt;SocketAddress&gt; getAllLocalAddresses()
1051             throws IOException {
1052         synchronized (stateLock) {
1053             if (!isOpen())
1054                 throw new ClosedChannelException();
1055             if (!isBound())
1056                 return Collections.emptySet();
1057 
1058             return SctpNet.getLocalAddresses(fdVal);
1059         }
1060     }
1061 
1062     @Override
1063     public Set&lt;SocketAddress&gt; getRemoteAddresses()
1064             throws IOException {
1065         synchronized (stateLock) {
1066             if (!isOpen())
1067                 throw new ClosedChannelException();
1068             if (!isConnected() || isShutdown)
1069                 return Collections.emptySet();
1070 
1071             try {
1072                 return SctpNet.getRemoteAddresses(fdVal, 0/*unused*/);
1073             } catch (SocketException unused) {
1074                 /* an open connected channel should always have remote addresses */
1075                 return remoteAddresses;
1076             }
1077         }
1078     }
1079 
1080     /* Native */
1081     private static native void initIDs();
1082 
1083     static native int receive0(int fd, ResultContainer resultContainer,
1084             long address, int length, boolean peek) throws IOException;
1085 
1086     static native int send0(int fd, long address, int length,
1087             InetAddress addr, int port, int assocId, int streamNumber,
1088             boolean unordered, int ppid) throws IOException;
1089 
1090     static {
1091         IOUtil.load();   /* loads nio &amp; net native libraries */
1092         java.security.AccessController.doPrivileged(
1093             new java.security.PrivilegedAction&lt;Void&gt;() {
1094                 public Void run() {
1095                     System.loadLibrary(&quot;sctp&quot;);
1096                     return null;
1097                 }
1098             });
1099         initIDs();
1100     }
1101 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.security.jgss/windows/classes/sun/security/krb5/internal/tools/Klist.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 28  *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 29  */
 30 
 31 package sun.security.krb5.internal.tools;
 32 
 33 import java.net.InetAddress;
 34 import sun.security.krb5.*;
 35 import sun.security.krb5.internal.*;
 36 import sun.security.krb5.internal.ccache.*;
 37 import sun.security.krb5.internal.ktab.*;
 38 import sun.security.krb5.internal.crypto.EType;
 39 
 40 /**
 41  * This class can execute as a command-line tool to list entries in
 42  * credential cache and key tab.
 43  *
 44  * @author Yanni Zhang
 45  * @author Ram Marti
 46  */
 47 public class Klist {
 48     Object target;
 49     // for credentials cache, options are &#39;f&#39;, &#39;e&#39;, &#39;a&#39; and &#39;n&#39;;
 50     // for  keytab, optionsare &#39;t&#39; and &#39;K&#39; and &#39;e&#39;
 51     char[] options = new char[4];
 52     String name;       // the name of credentials cache and keytable.
 53     char action;       // actions would be &#39;c&#39; for credentials cache
 54     // and &#39;k&#39; for keytable.
 55     private static boolean DEBUG = Krb5.DEBUG;
 56 
 57     /**
 58      * The main program that can be invoked at command line.
 59      * &lt;br&gt;Usage: klist
 60      * [[-c] [-f] [-e] [-a [-n]]] [-k [-t] [-K]] [name]
 61      * -c specifies that credential cache is to be listed
 62      * -k specifies that key tab is to be listed
 63      * name name of the credentials cache or keytab
 64      * &lt;br&gt;available options for credential caches:
 65      * &lt;ul&gt;
 66      * &lt;li&gt;&lt;b&gt;-f&lt;/b&gt;  shows credentials flags
 67      * &lt;li&gt;&lt;b&gt;-e&lt;/b&gt;  shows the encryption type
 68      * &lt;li&gt;&lt;b&gt;-a&lt;/b&gt;  shows addresses
 69      * &lt;li&gt;&lt;b&gt;-n&lt;/b&gt;  do not reverse-resolve addresses
 70      * &lt;/ul&gt;
 71      * available options for keytabs:
 72      * &lt;ul&gt;
 73      * &lt;li&gt;&lt;b&gt;-t&lt;/b&gt; shows keytab entry timestamps
 74      * &lt;li&gt;&lt;b&gt;-K&lt;/b&gt; shows keytab entry DES keys
 75      * &lt;/ul&gt;
 76      */
 77     public static void main(String[] args) {
 78         Klist klist = new Klist();
 79         if ((args == null) || (args.length == 0)) {
 80             klist.action = &#39;c&#39;; // default will list default credentials cache.
 81         } else {
 82             klist.processArgs(args);
 83         }
 84         switch (klist.action) {
 85         case &#39;c&#39;:
 86             if (klist.name == null) {
 87                 klist.target = CredentialsCache.getInstance();
 88                 klist.name = CredentialsCache.cacheName();
 89             } else
 90                 klist.target = CredentialsCache.getInstance(klist.name);
 91 
 92             if (klist.target != null)  {
 93                 klist.displayCache();
 94             } else {
 95                 klist.displayMessage(&quot;Credentials cache&quot;);
 96                 System.exit(-1);
 97             }
 98             break;
 99         case &#39;k&#39;:
100             KeyTab ktab = KeyTab.getInstance(klist.name);
101             if (ktab.isMissing()) {
102                 System.out.println(&quot;KeyTab &quot; + klist.name + &quot; not found.&quot;);
103                 System.exit(-1);
104             } else if (!ktab.isValid()) {
105                 System.out.println(&quot;KeyTab &quot; + klist.name
106                         + &quot; format not supported.&quot;);
107                 System.exit(-1);
108             }
109             klist.target = ktab;
110             klist.name = ktab.tabName();
111             klist.displayTab();
112             break;
113         default:
114             if (klist.name != null) {
115                 klist.printHelp();
116                 System.exit(-1);
117             } else {
118                 klist.target = CredentialsCache.getInstance();
119                 klist.name = CredentialsCache.cacheName();
120                 if (klist.target != null) {
121                     klist.displayCache();
122                 } else {
123                     klist.displayMessage(&quot;Credentials cache&quot;);
124                     System.exit(-1);
125                 }
126             }
127         }
128     }
129 
130     /**
131      * Parses the command line arguments.
132      */
133     void processArgs(String[] args) {
134         Character arg;
135         for (int i = 0; i &lt; args.length; i++) {
136             if (args[i].equals(&quot;-?&quot;) ||
137                 args[i].equals(&quot;-h&quot;) ||
138                 args[i].equals(&quot;--help&quot;)) {
139                 printHelp();
140                 System.exit(0);
141             }
142             if ((args[i].length() &gt;= 2) &amp;&amp; (args[i].startsWith(&quot;-&quot;))) {
143                 arg = Character.valueOf(args[i].charAt(1));
144                 switch (arg.charValue()) {
145                 case &#39;c&#39;:
146                     action = &#39;c&#39;;
147                     break;
148                 case &#39;k&#39;:
149                     action = &#39;k&#39;;
150                     break;
151                 case &#39;a&#39;:
152                     options[2] = &#39;a&#39;;
153                     break;
154                 case &#39;n&#39;:
155                     options[3] = &#39;n&#39;;
156                     break;
157                 case &#39;f&#39;:
158                     options[1] = &#39;f&#39;;
159                     break;
160                 case &#39;e&#39;:
161                     options[0] = &#39;e&#39;;
162                     break;
163                 case &#39;K&#39;:
164                     options[1] = &#39;K&#39;;
165                     break;
166                 case &#39;t&#39;:
167                     options[2] = &#39;t&#39;;
168                     break;
169                 default:
170                     printHelp();
171                     System.exit(-1);
172                 }
173 
174             } else {
175                 if (!args[i].startsWith(&quot;-&quot;) &amp;&amp; (i == args.length - 1)) {
176                     // the argument is the last one.
177                     name = args[i];
178                     arg = null;
179                 } else {
180                     printHelp(); // incorrect input format.
181                     System.exit(-1);
182                 }
183             }
184         }
185     }
186 
187     void displayTab() {
188         KeyTab table = (KeyTab)target;
189         KeyTabEntry[] entries = table.getEntries();
190         if (entries.length == 0) {
191             System.out.println(&quot;\nKey tab: &quot; + name +
192                                &quot;, &quot; + &quot; 0 entries found.\n&quot;);
193         } else {
194             if (entries.length == 1)
195                 System.out.println(&quot;\nKey tab: &quot; + name +
196                                    &quot;, &quot; + entries.length + &quot; entry found.\n&quot;);
197             else
198                 System.out.println(&quot;\nKey tab: &quot; + name + &quot;, &quot; +
199                                    entries.length + &quot; entries found.\n&quot;);
200             for (int i = 0; i &lt; entries.length; i++) {
201                 System.out.println(&quot;[&quot; + (i + 1) + &quot;] &quot; +
202                                    &quot;Service principal: &quot;  +
203                                    entries[i].getService().toString());
204                 System.out.println(&quot;\t KVNO: &quot; +
205                                    entries[i].getKey().getKeyVersionNumber());
206                 if (options[0] == &#39;e&#39;) {
207                     EncryptionKey key = entries[i].getKey();
208                     System.out.println(&quot;\t Key type: &quot; +
209                                        key.getEType());
210                 }
211                 if (options[1] == &#39;K&#39;) {
212                     EncryptionKey key = entries[i].getKey();
213                     System.out.println(&quot;\t Key: &quot; +
214                                        entries[i].getKeyString());
215                 }
216                 if (options[2] == &#39;t&#39;) {
217                     System.out.println(&quot;\t Time stamp: &quot; +
218                             format(entries[i].getTimeStamp()));
219                 }
220             }
221         }
222     }
223 
224     void displayCache() {
225         CredentialsCache cache = (CredentialsCache)target;
226         sun.security.krb5.internal.ccache.Credentials[] creds =
227             cache.getCredsList();
228         if (creds == null) {
229             System.out.println (&quot;No credentials available in the cache &quot; +
230                                 name);
231             System.exit(-1);
232         }
233         System.out.println(&quot;\nCredentials cache: &quot; +  name);
234         String defaultPrincipal = cache.getPrimaryPrincipal().toString();
235         int num = creds.length;
236 
237         if (num == 1)
238             System.out.println(&quot;\nDefault principal: &quot; +
239                                defaultPrincipal + &quot;, &quot; +
240                                creds.length + &quot; entry found.\n&quot;);
241         else
242             System.out.println(&quot;\nDefault principal: &quot; +
243                                defaultPrincipal + &quot;, &quot; +
244                                creds.length + &quot; entries found.\n&quot;);
245         if (creds != null) {
246             for (int i = 0; i &lt; creds.length; i++) {
247                 try {
248                     String starttime;
249                     String endtime;
250                     String renewTill;
251                     String servicePrincipal;
252                     if (creds[i].getStartTime() != null) {
253                         starttime = format(creds[i].getStartTime());
254                     } else {
255                         starttime = format(creds[i].getAuthTime());
256                     }
257                     endtime = format(creds[i].getEndTime());
258                     servicePrincipal =
259                         creds[i].getServicePrincipal().toString();
260                     System.out.println(&quot;[&quot; + (i + 1) + &quot;] &quot; +
261                                        &quot; Service Principal:  &quot; +
262                                        servicePrincipal);
263                     System.out.println(&quot;     Valid starting:     &quot; + starttime);
264                     System.out.println(&quot;     Expires:            &quot; + endtime);
265                     if (creds[i].getRenewTill() != null) {
266                         renewTill = format(creds[i].getRenewTill());
267                         System.out.println(
268                                 &quot;     Renew until:        &quot; + renewTill);
269                     }
270                     if (options[0] == &#39;e&#39;) {
271                         String eskey = EType.toString(creds[i].getEType());
272                         String etkt = EType.toString(creds[i].getTktEType());
273                         System.out.println(&quot;     EType (skey, tkt):  &quot;
274                                 + eskey + &quot;, &quot; + etkt);
275                     }
276                     if (options[1] == &#39;f&#39;) {
277                         System.out.println(&quot;     Flags:              &quot; +
278                                            creds[i].getTicketFlags().toString());
279                     }
280                     if (options[2] == &#39;a&#39;) {
281                         boolean first = true;
282                         InetAddress[] caddr
283                                 = creds[i].setKrbCreds().getClientAddresses();
284                         if (caddr != null) {
285                             for (InetAddress ia: caddr) {
286                                 String out;
287                                 if (options[3] == &#39;n&#39;) {
288                                     out = ia.getHostAddress();
289                                 } else {
290                                     out = ia.getCanonicalHostName();
291                                 }
292                                 System.out.println(&quot;     &quot; +
293                                         (first?&quot;Addresses:&quot;:&quot;          &quot;) +
294                                         &quot;       &quot; + out);
295                                 first = false;
296                             }
297                         } else {
298                             System.out.println(&quot;     [No host addresses info]&quot;);
299                         }
300                     }
301                 } catch (RealmException e) {
302                     System.out.println(&quot;Error reading principal from &quot;+
303                                        &quot;the entry.&quot;);
304                     if (DEBUG) {
305                         e.printStackTrace();
306                     }
307                     System.exit(-1);
308                 }
309             }
310         } else {
311             System.out.println(&quot;\nNo entries found.&quot;);
312         }
313     }
314 
315     void displayMessage(String target) {
316         if (name == null) {
317             System.out.println(&quot;Default &quot; + target + &quot; not found.&quot;);
318         } else {
319             System.out.println(target + &quot; &quot; + name + &quot; not found.&quot;);
320         }
321     }
322     /**
323      * Reformats the date from the form -
324      *     dow mon dd hh:mm:ss zzz yyyy to mon/dd/yyyy hh:mm
325      * where dow is the day of the week, mon is the month,
326      * dd is the day of the month, hh is the hour of
327      * the day, mm is the minute within the hour,
328      * ss is the second within the minute, zzz is the time zone,
329      * and yyyy is the year.
330      * @param date the string form of Date object.
331      */
332     private String format(KerberosTime kt) {
333         String date = kt.toDate().toString();
334         return (date.substring(4, 7) + &quot; &quot; + date.substring(8, 10) +
335                 &quot;, &quot; + date.substring(24)
336                 + &quot; &quot; + date.substring(11, 19));
337     }
338     /**
339      * Prints out the help information.
340      */
341     void printHelp() {
342         System.out.println(&quot;\nUsage: klist &quot; +
343                            &quot;[[-c] [-f] [-e] [-a [-n]]] [-k [-t] [-K]] [name]&quot;);
344         System.out.println(&quot;   name\t name of credentials cache or &quot; +
345                            &quot; keytab with the prefix. File-based cache or &quot;
346                            + &quot;keytab&#39;s prefix is FILE:.&quot;);
347         System.out.println(&quot;   -c specifies that credential cache is to be &quot; +
348                            &quot;listed&quot;);
349         System.out.println(&quot;   -k specifies that key tab is to be listed&quot;);
350         System.out.println(&quot;   options for credentials caches:&quot;);
351         System.out.println(&quot;\t-f \t shows credentials flags&quot;);
352         System.out.println(&quot;\t-e \t shows the encryption type&quot;);
353         System.out.println(&quot;\t-a \t shows addresses&quot;);
354         System.out.println(&quot;\t  -n \t   do not reverse-resolve addresses&quot;);
355         System.out.println(&quot;   options for keytabs:&quot;);
356         System.out.println(&quot;\t-t \t shows keytab entry timestamps&quot;);
357         System.out.println(&quot;\t-K \t shows keytab entry key value&quot;);
358         System.out.println(&quot;\t-e \t shows keytab entry key type&quot;);
359     }
360 }
    </pre>
  </body>
</html>
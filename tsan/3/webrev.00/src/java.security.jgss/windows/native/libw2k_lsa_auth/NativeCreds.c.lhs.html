<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.security.jgss/windows/native/libw2k_lsa_auth/NativeCreds.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * ===========================================================================
  28  * (C) Copyright IBM Corp. 2000 All Rights Reserved.
  29  * ===========================================================================
  30  */
  31 
  32 #define UNICODE
  33 #define _UNICODE
  34 
  35 #include &lt;windows.h&gt;
  36 #include &lt;stdio.h&gt;
  37 #include &lt;string.h&gt;
  38 #define SECURITY_WIN32
  39 #include &lt;security.h&gt;
  40 #include &lt;ntsecapi.h&gt;
  41 #include &lt;dsgetdc.h&gt;
  42 #include &lt;lmcons.h&gt;
  43 #include &lt;lmapibuf.h&gt;
  44 #include &lt;jni.h&gt;
  45 #include &quot;jni_util.h&quot;
  46 #include &lt;winsock.h&gt;
  47 #include &quot;sun_security_krb5_Credentials.h&quot;
  48 
  49 #undef LSA_SUCCESS
  50 #define LSA_SUCCESS(Status) ((Status) &gt;= 0)
  51 #define EXIT_FAILURE -1 // mdu
  52 
  53 /*
  54  * Library-wide static references
  55  */
  56 
<a name="2" id="anc2"></a><span class="line-removed">  57 jclass derValueClass = NULL;</span>
  58 jclass ticketClass = NULL;
  59 jclass principalNameClass = NULL;
  60 jclass encryptionKeyClass = NULL;
  61 jclass ticketFlagsClass = NULL;
  62 jclass kerberosTimeClass = NULL;
  63 jclass javaLangStringClass = NULL;
  64 
<a name="3" id="anc3"></a><span class="line-removed">  65 jmethodID derValueConstructor = 0;</span>
  66 jmethodID ticketConstructor = 0;
  67 jmethodID principalNameConstructor = 0;
  68 jmethodID encryptionKeyConstructor = 0;
  69 jmethodID ticketFlagsConstructor = 0;
  70 jmethodID kerberosTimeConstructor = 0;
  71 jmethodID krbcredsConstructor = 0;
  72 
  73 /*
  74  * Function prototypes for internal routines
  75  *
  76  */
  77 BOOL native_debug = 0;
  78 
  79 BOOL PackageConnectLookup(PHANDLE,PULONG);
  80 
  81 NTSTATUS ConstructTicketRequest(JNIEnv *env,
  82                                 UNICODE_STRING DomainName,
  83                                 PKERB_RETRIEVE_TKT_REQUEST *outRequest,
  84                                 ULONG *outSize);
  85 
  86 DWORD ConcatenateUnicodeStrings(UNICODE_STRING *pTarget,
  87                                 UNICODE_STRING Source1,
  88                                 UNICODE_STRING Source2);
  89 
  90 VOID ShowNTError(LPSTR,NTSTATUS);
  91 
  92 VOID
  93 InitUnicodeString(
  94     PUNICODE_STRING DestinationString,
  95     PCWSTR SourceString OPTIONAL
  96 );
  97 
  98 jobject BuildTicket(JNIEnv *env, PUCHAR encodedTicket, ULONG encodedTicketSize);
  99 
 100 //mdu
 101 jobject BuildPrincipal(JNIEnv *env, PKERB_EXTERNAL_NAME principalName,
 102                                 UNICODE_STRING domainName);
 103 
 104 jobject BuildEncryptionKey(JNIEnv *env, PKERB_CRYPTO_KEY cryptoKey);
 105 jobject BuildTicketFlags(JNIEnv *env, PULONG flags);
 106 jobject BuildKerberosTime(JNIEnv *env, PLARGE_INTEGER kerbtime);
 107 
 108 void ThrowOOME(JNIEnv *env, const char *szMessage);
 109 
 110 /*
 111  * Class:     sun_security_krb5_KrbCreds
 112  * Method:    JNI_OnLoad
 113  */
 114 
 115 JNIEXPORT jint JNICALL DEF_JNI_OnLoad(
 116         JavaVM  *jvm,
 117         void    *reserved) {
 118 
 119     jclass cls;
 120     JNIEnv *env;
 121     jfieldID fldDEBUG;
 122 
 123     if ((*jvm)-&gt;GetEnv(jvm, (void **)&amp;env, JNI_VERSION_1_2)) {
 124         return JNI_EVERSION; /* JNI version not supported */
 125     }
 126 
 127     cls = (*env)-&gt;FindClass(env,&quot;sun/security/krb5/internal/Krb5&quot;);
 128     if (cls == NULL) {
 129         printf(&quot;LSA: Couldn&#39;t find Krb5\n&quot;);
 130         return JNI_ERR;
 131     }
 132     fldDEBUG = (*env)-&gt;GetStaticFieldID(env, cls, &quot;DEBUG&quot;, &quot;Z&quot;);
 133     if (fldDEBUG == NULL) {
 134         printf(&quot;LSA: Krb5 has no DEBUG field\n&quot;);
 135         return JNI_ERR;
 136     }
 137     native_debug = (*env)-&gt;GetStaticBooleanField(env, cls, fldDEBUG);
 138 
 139     cls = (*env)-&gt;FindClass(env,&quot;sun/security/krb5/internal/Ticket&quot;);
 140 
 141     if (cls == NULL) {
 142         printf(&quot;LSA: Couldn&#39;t find Ticket\n&quot;);
 143         return JNI_ERR;
 144     }
 145     if (native_debug) {
 146         printf(&quot;LSA: Found Ticket\n&quot;);
 147     }
 148 
 149     ticketClass = (*env)-&gt;NewWeakGlobalRef(env,cls);
 150     if (ticketClass == NULL) {
 151         return JNI_ERR;
 152     }
 153     if (native_debug) {
 154         printf(&quot;LSA: Made NewWeakGlobalRef\n&quot;);
 155     }
 156 
 157     cls = (*env)-&gt;FindClass(env, &quot;sun/security/krb5/PrincipalName&quot;);
 158 
 159     if (cls == NULL) {
 160         printf(&quot;LSA: Couldn&#39;t find PrincipalName\n&quot;);
 161         return JNI_ERR;
 162     }
 163     if (native_debug) {
 164         printf(&quot;LSA: Found PrincipalName\n&quot;);
 165     }
 166 
 167     principalNameClass = (*env)-&gt;NewWeakGlobalRef(env,cls);
 168     if (principalNameClass == NULL) {
 169         return JNI_ERR;
 170     }
 171     if (native_debug) {
 172         printf(&quot;LSA: Made NewWeakGlobalRef\n&quot;);
 173     }
 174 
<a name="4" id="anc4"></a><span class="line-removed"> 175     cls = (*env)-&gt;FindClass(env,&quot;sun/security/util/DerValue&quot;);</span>
<span class="line-removed"> 176 </span>
<span class="line-removed"> 177     if (cls == NULL) {</span>
<span class="line-removed"> 178         printf(&quot;LSA: Couldn&#39;t find DerValue\n&quot;);</span>
<span class="line-removed"> 179         return JNI_ERR;</span>
<span class="line-removed"> 180     }</span>
<span class="line-removed"> 181     if (native_debug) {</span>
<span class="line-removed"> 182         printf(&quot;LSA: Found DerValue\n&quot;);</span>
<span class="line-removed"> 183     }</span>
<span class="line-removed"> 184 </span>
<span class="line-removed"> 185     derValueClass = (*env)-&gt;NewWeakGlobalRef(env,cls);</span>
<span class="line-removed"> 186     if (derValueClass == NULL) {</span>
<span class="line-removed"> 187         return JNI_ERR;</span>
<span class="line-removed"> 188     }</span>
<span class="line-removed"> 189     if (native_debug) {</span>
<span class="line-removed"> 190         printf(&quot;LSA: Made NewWeakGlobalRef\n&quot;);</span>
<span class="line-removed"> 191     }</span>
<span class="line-removed"> 192 </span>
 193     cls = (*env)-&gt;FindClass(env,&quot;sun/security/krb5/EncryptionKey&quot;);
 194 
 195     if (cls == NULL) {
 196         printf(&quot;LSA: Couldn&#39;t find EncryptionKey\n&quot;);
 197         return JNI_ERR;
 198     }
 199     if (native_debug) {
 200         printf(&quot;LSA: Found EncryptionKey\n&quot;);
 201     }
 202 
 203     encryptionKeyClass = (*env)-&gt;NewWeakGlobalRef(env,cls);
 204     if (encryptionKeyClass == NULL) {
 205         return JNI_ERR;
 206     }
 207     if (native_debug) {
 208         printf(&quot;LSA: Made NewWeakGlobalRef\n&quot;);
 209     }
 210 
 211     cls = (*env)-&gt;FindClass(env,&quot;sun/security/krb5/internal/TicketFlags&quot;);
 212 
 213     if (cls == NULL) {
 214         printf(&quot;LSA: Couldn&#39;t find TicketFlags\n&quot;);
 215         return JNI_ERR;
 216     }
 217     if (native_debug) {
 218         printf(&quot;LSA: Found TicketFlags\n&quot;);
 219     }
 220 
 221     ticketFlagsClass = (*env)-&gt;NewWeakGlobalRef(env,cls);
 222     if (ticketFlagsClass == NULL) {
 223         return JNI_ERR;
 224     }
 225     if (native_debug) {
 226         printf(&quot;LSA: Made NewWeakGlobalRef\n&quot;);
 227     }
 228 
 229     cls = (*env)-&gt;FindClass(env,&quot;sun/security/krb5/internal/KerberosTime&quot;);
 230 
 231     if (cls == NULL) {
 232         printf(&quot;LSA: Couldn&#39;t find KerberosTime\n&quot;);
 233         return JNI_ERR;
 234     }
 235     if (native_debug) {
 236         printf(&quot;LSA: Found KerberosTime\n&quot;);
 237     }
 238 
 239     kerberosTimeClass = (*env)-&gt;NewWeakGlobalRef(env,cls);
 240     if (kerberosTimeClass == NULL) {
 241         return JNI_ERR;
 242     }
 243     if (native_debug) {
 244         printf(&quot;LSA: Made NewWeakGlobalRef\n&quot;);
 245     }
 246 
 247     cls = (*env)-&gt;FindClass(env,&quot;java/lang/String&quot;);
 248 
 249     if (cls == NULL) {
 250         printf(&quot;LSA: Couldn&#39;t find String\n&quot;);
 251         return JNI_ERR;
 252     }
 253     if (native_debug) {
 254         printf(&quot;LSA: Found String\n&quot;);
 255     }
 256 
 257     javaLangStringClass = (*env)-&gt;NewWeakGlobalRef(env,cls);
 258     if (javaLangStringClass == NULL) {
 259         return JNI_ERR;
 260     }
 261     if (native_debug) {
 262         printf(&quot;LSA: Made NewWeakGlobalRef\n&quot;);
 263     }
 264 
<a name="5" id="anc5"></a><span class="line-removed"> 265     derValueConstructor = (*env)-&gt;GetMethodID(env, derValueClass,</span>
<span class="line-removed"> 266                                             &quot;&lt;init&gt;&quot;, &quot;([B)V&quot;);</span>
<span class="line-removed"> 267     if (derValueConstructor == 0) {</span>
<span class="line-removed"> 268         printf(&quot;LSA: Couldn&#39;t find DerValue constructor\n&quot;);</span>
<span class="line-removed"> 269         return JNI_ERR;</span>
<span class="line-removed"> 270     }</span>
<span class="line-removed"> 271     if (native_debug) {</span>
<span class="line-removed"> 272         printf(&quot;LSA: Found DerValue constructor\n&quot;);</span>
<span class="line-removed"> 273     }</span>
<span class="line-removed"> 274 </span>
 275     ticketConstructor = (*env)-&gt;GetMethodID(env, ticketClass,
<a name="6" id="anc6"></a><span class="line-modified"> 276                             &quot;&lt;init&gt;&quot;, &quot;(Lsun/security/util/DerValue;)V&quot;);</span>
 277     if (ticketConstructor == 0) {
 278         printf(&quot;LSA: Couldn&#39;t find Ticket constructor\n&quot;);
 279         return JNI_ERR;
 280     }
 281     if (native_debug) {
 282         printf(&quot;LSA: Found Ticket constructor\n&quot;);
 283     }
 284 
 285     principalNameConstructor = (*env)-&gt;GetMethodID(env, principalNameClass,
 286                         &quot;&lt;init&gt;&quot;, &quot;([Ljava/lang/String;Ljava/lang/String;)V&quot;);
 287     if (principalNameConstructor == 0) {
 288         printf(&quot;LSA: Couldn&#39;t find PrincipalName constructor\n&quot;);
 289         return JNI_ERR;
 290     }
 291     if (native_debug) {
 292         printf(&quot;LSA: Found PrincipalName constructor\n&quot;);
 293     }
 294 
 295     encryptionKeyConstructor = (*env)-&gt;GetMethodID(env, encryptionKeyClass,
 296                                             &quot;&lt;init&gt;&quot;, &quot;(I[B)V&quot;);
 297     if (encryptionKeyConstructor == 0) {
 298         printf(&quot;LSA: Couldn&#39;t find EncryptionKey constructor\n&quot;);
 299         return JNI_ERR;
 300     }
 301     if (native_debug) {
 302         printf(&quot;LSA: Found EncryptionKey constructor\n&quot;);
 303     }
 304 
 305     ticketFlagsConstructor = (*env)-&gt;GetMethodID(env, ticketFlagsClass,
 306                                             &quot;&lt;init&gt;&quot;, &quot;(I[B)V&quot;);
 307     if (ticketFlagsConstructor == 0) {
 308         printf(&quot;LSA: Couldn&#39;t find TicketFlags constructor\n&quot;);
 309         return JNI_ERR;
 310     }
 311     if (native_debug) {
 312         printf(&quot;LSA: Found TicketFlags constructor\n&quot;);
 313     }
 314 
 315     kerberosTimeConstructor = (*env)-&gt;GetMethodID(env, kerberosTimeClass,
 316                                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;);
 317     if (kerberosTimeConstructor == 0) {
 318         printf(&quot;LSA: Couldn&#39;t find KerberosTime constructor\n&quot;);
 319         return JNI_ERR;
 320     }
 321     if (native_debug) {
 322         printf(&quot;LSA: Found KerberosTime constructor\n&quot;);
 323     }
 324 
 325     if (native_debug) {
 326         printf(&quot;LSA: Finished OnLoad processing\n&quot;);
 327     }
 328 
 329     return JNI_VERSION_1_2;
 330 }
 331 
 332 /*
 333  * Class:     sun_security_jgss_KrbCreds
 334  * Method:    JNI_OnUnload
 335  */
 336 
 337 JNIEXPORT void JNICALL DEF_JNI_OnUnload(
 338         JavaVM  *jvm,
 339         void    *reserved) {
 340 
 341     JNIEnv *env;
 342 
 343     if ((*jvm)-&gt;GetEnv(jvm, (void **)&amp;env, JNI_VERSION_1_2)) {
 344         return; /* Nothing else we can do */
 345     }
 346 
 347     if (ticketClass != NULL) {
 348         (*env)-&gt;DeleteWeakGlobalRef(env,ticketClass);
 349     }
<a name="7" id="anc7"></a><span class="line-removed"> 350     if (derValueClass != NULL) {</span>
<span class="line-removed"> 351         (*env)-&gt;DeleteWeakGlobalRef(env,derValueClass);</span>
<span class="line-removed"> 352     }</span>
 353     if (principalNameClass != NULL) {
 354         (*env)-&gt;DeleteWeakGlobalRef(env,principalNameClass);
 355     }
 356     if (encryptionKeyClass != NULL) {
 357         (*env)-&gt;DeleteWeakGlobalRef(env,encryptionKeyClass);
 358     }
 359     if (ticketFlagsClass != NULL) {
 360         (*env)-&gt;DeleteWeakGlobalRef(env,ticketFlagsClass);
 361     }
 362     if (kerberosTimeClass != NULL) {
 363         (*env)-&gt;DeleteWeakGlobalRef(env,kerberosTimeClass);
 364     }
 365     if (javaLangStringClass != NULL) {
 366         (*env)-&gt;DeleteWeakGlobalRef(env,javaLangStringClass);
 367     }
 368 
 369     return;
 370 }
 371 
 372 /*
 373  * Class:     sun_security_krb5_Credentials
 374  * Method:    acquireDefaultNativeCreds
 375  * Signature: ([I])Lsun/security/krb5/Credentials;
 376  */
 377 JNIEXPORT jobject JNICALL Java_sun_security_krb5_Credentials_acquireDefaultNativeCreds(
 378         JNIEnv *env,
 379         jclass krbcredsClass,
 380         jintArray jetypes) {
 381 
 382     KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
 383     PKERB_RETRIEVE_TKT_RESPONSE TktCacheResponse = NULL;
 384     PKERB_RETRIEVE_TKT_REQUEST pTicketRequest = NULL;
 385     PKERB_RETRIEVE_TKT_RESPONSE pTicketResponse = NULL;
 386     NTSTATUS Status, SubStatus;
 387     ULONG requestSize = 0;
 388     ULONG responseSize = 0;
 389     ULONG rspSize = 0;
 390     HANDLE LogonHandle = NULL;
 391     ULONG PackageId;
 392     jobject ticket, clientPrincipal, targetPrincipal, encryptionKey;
 393     jobject ticketFlags, startTime, endTime, krbCreds = NULL;
 394     jobject authTime, renewTillTime, hostAddresses = NULL;
 395     KERB_EXTERNAL_TICKET *msticket;
 396     int found = 0;
 397     FILETIME Now, EndTime;
 398 
 399     int i, netypes;
 400     jint *etypes = NULL;
 401 
 402     while (TRUE) {
 403 
 404         if (krbcredsConstructor == 0) {
 405             krbcredsConstructor = (*env)-&gt;GetMethodID(env, krbcredsClass, &quot;&lt;init&gt;&quot;,
 406                     &quot;(Lsun/security/krb5/internal/Ticket;&quot;
 407                     &quot;Lsun/security/krb5/PrincipalName;&quot;
 408                     &quot;Lsun/security/krb5/PrincipalName;&quot;
<a name="8" id="anc8"></a>

 409                     &quot;Lsun/security/krb5/EncryptionKey;&quot;
 410                     &quot;Lsun/security/krb5/internal/TicketFlags;&quot;
 411                     &quot;Lsun/security/krb5/internal/KerberosTime;&quot;
 412                     &quot;Lsun/security/krb5/internal/KerberosTime;&quot;
 413                     &quot;Lsun/security/krb5/internal/KerberosTime;&quot;
 414                     &quot;Lsun/security/krb5/internal/KerberosTime;&quot;
 415                     &quot;Lsun/security/krb5/internal/HostAddresses;)V&quot;);
 416             if (krbcredsConstructor == 0) {
 417                 printf(&quot;LSA: Couldn&#39;t find sun.security.krb5.Credentials constructor\n&quot;);
 418                 break;
 419             }
 420         }
 421 
 422         if (native_debug) {
 423             printf(&quot;LSA: Found KrbCreds constructor\n&quot;);
 424         }
 425 
 426         //
 427         // Get the logon handle and package ID from the
 428         // Kerberos package
 429         //
 430         if (!PackageConnectLookup(&amp;LogonHandle, &amp;PackageId))
 431             break;
 432 
 433         if (native_debug) {
 434             printf(&quot;LSA: Got handle to Kerberos package\n&quot;);
 435         }
 436 
 437         // Get the MS TGT from cache
 438         CacheRequest.MessageType = KerbRetrieveTicketMessage;
 439         CacheRequest.LogonId.LowPart = 0;
 440         CacheRequest.LogonId.HighPart = 0;
 441 
 442         Status = LsaCallAuthenticationPackage(
 443                         LogonHandle,
 444                         PackageId,
 445                         &amp;CacheRequest,
 446                         sizeof(CacheRequest),
 447                         &amp;TktCacheResponse,
 448                         &amp;rspSize,
 449                         &amp;SubStatus
 450                         );
 451 
 452         if (native_debug) {
 453             printf(&quot;LSA: Response size is %d\n&quot;, rspSize);
 454         }
 455 
 456         if (!LSA_SUCCESS(Status) || !LSA_SUCCESS(SubStatus)) {
 457             if (!LSA_SUCCESS(Status)) {
 458                 ShowNTError(&quot;LsaCallAuthenticationPackage&quot;, Status);
 459             } else {
 460                 ShowNTError(&quot;Protocol status&quot;, SubStatus);
 461             }
 462             break;
 463         }
 464 
 465         // got the native MS TGT
 466         msticket = &amp;(TktCacheResponse-&gt;Ticket);
 467 
 468         netypes = (*env)-&gt;GetArrayLength(env, jetypes);
 469         etypes = (jint *) (*env)-&gt;GetIntArrayElements(env, jetypes, NULL);
 470 
 471         if (etypes == NULL) {
 472             break;
 473         }
 474 
 475         // check TGT validity
 476         if (native_debug) {
 477             printf(&quot;LSA: TICKET SessionKey KeyType is %d\n&quot;, msticket-&gt;SessionKey.KeyType);
 478         }
 479 
 480         if ((msticket-&gt;TicketFlags &amp; KERB_TICKET_FLAGS_invalid) == 0) {
 481             GetSystemTimeAsFileTime(&amp;Now);
 482             EndTime.dwLowDateTime = msticket-&gt;EndTime.LowPart;
 483             EndTime.dwHighDateTime = msticket-&gt;EndTime.HighPart;
 484             if (CompareFileTime(&amp;Now, &amp;EndTime) &lt; 0) {
 485                 for (i=0; i&lt;netypes; i++) {
 486                     if (etypes[i] == msticket-&gt;SessionKey.KeyType) {
 487                         found = 1;
 488                         if (native_debug) {
 489                             printf(&quot;LSA: Valid etype found: %d\n&quot;, etypes[i]);
 490                         }
 491                         break;
 492                     }
 493                 }
 494             }
 495         }
 496 
 497         if (!found) {
 498             if (native_debug) {
 499                 printf(&quot;LSA: MS TGT in cache is invalid/not supported; request new ticket\n&quot;);
 500             }
 501 
 502             // use domain to request Ticket
 503             Status = ConstructTicketRequest(env, msticket-&gt;TargetDomainName,
 504                                 &amp;pTicketRequest, &amp;requestSize);
 505             if (!LSA_SUCCESS(Status)) {
 506                 ShowNTError(&quot;ConstructTicketRequest status&quot;, Status);
 507                 break;
 508             }
 509 
 510             pTicketRequest-&gt;MessageType = KerbRetrieveEncodedTicketMessage;
 511             pTicketRequest-&gt;CacheOptions = KERB_RETRIEVE_TICKET_DONT_USE_CACHE;
 512 
 513             for (i=0; i&lt;netypes; i++) {
 514                 pTicketRequest-&gt;EncryptionType = etypes[i];
 515                 Status = LsaCallAuthenticationPackage(
 516                             LogonHandle,
 517                             PackageId,
 518                             pTicketRequest,
 519                             requestSize,
 520                             &amp;pTicketResponse,
 521                             &amp;responseSize,
 522                             &amp;SubStatus
 523                             );
 524 
 525                 if (native_debug) {
 526                     printf(&quot;LSA: Response size is %d for %d\n&quot;, responseSize, etypes[i]);
 527                 }
 528 
 529                 if (!LSA_SUCCESS(Status) || !LSA_SUCCESS(SubStatus)) {
 530                     if (!LSA_SUCCESS(Status)) {
 531                         ShowNTError(&quot;LsaCallAuthenticationPackage&quot;, Status);
 532                     } else {
 533                         ShowNTError(&quot;Protocol status&quot;, SubStatus);
 534                     }
 535                     continue;
 536                 }
 537 
 538                 // got the native MS Kerberos TGT
 539                 msticket = &amp;(pTicketResponse-&gt;Ticket);
 540 
 541                 if (msticket-&gt;SessionKey.KeyType != etypes[i]) {
 542                     if (native_debug) {
 543                         printf(&quot;LSA: Response etype is %d for %d. Retry.\n&quot;, msticket-&gt;SessionKey.KeyType, etypes[i]);
 544                     }
 545                     continue;
 546                 }
 547                 found = 1;
 548                 break;
 549             }
 550         }
 551 
 552         if (etypes != NULL) {
 553             (*env)-&gt;ReleaseIntArrayElements(env, jetypes, etypes, 0);
 554         }
 555 
 556         /*
 557 
 558         typedef struct _KERB_RETRIEVE_TKT_RESPONSE {
 559             KERB_EXTERNAL_TICKET Ticket;
 560         } KERB_RETRIEVE_TKT_RESPONSE, *PKERB_RETRIEVE_TKT_RESPONSE;
 561 
 562         typedef struct _KERB_EXTERNAL_TICKET {
 563             PKERB_EXTERNAL_NAME ServiceName;
 564             PKERB_EXTERNAL_NAME TargetName;
 565             PKERB_EXTERNAL_NAME ClientName;
 566             UNICODE_STRING DomainName;
 567             UNICODE_STRING TargetDomainName;
 568             UNICODE_STRING AltTargetDomainName;
 569             KERB_CRYPTO_KEY SessionKey;
 570             ULONG TicketFlags;
 571             ULONG Flags;
 572             LARGE_INTEGER KeyExpirationTime;
 573             LARGE_INTEGER StartTime;
 574             LARGE_INTEGER EndTime;
 575             LARGE_INTEGER RenewUntil;
 576             LARGE_INTEGER TimeSkew;
 577             ULONG EncodedTicketSize;
 578             PUCHAR EncodedTicket; &lt;========== Here&#39;s the good stuff
 579         } KERB_EXTERNAL_TICKET, *PKERB_EXTERNAL_TICKET;
 580 
 581         typedef struct _KERB_EXTERNAL_NAME {
 582             SHORT NameType;
 583             USHORT NameCount;
 584             UNICODE_STRING Names[ANYSIZE_ARRAY];
 585         } KERB_EXTERNAL_NAME, *PKERB_EXTERNAL_NAME;
 586 
 587         typedef struct _LSA_UNICODE_STRING {
 588             USHORT Length;
 589             USHORT MaximumLength;
 590             PWSTR  Buffer;
 591         } LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;
 592 
 593         typedef LSA_UNICODE_STRING UNICODE_STRING, *PUNICODE_STRING;
 594 
 595         typedef struct KERB_CRYPTO_KEY {
 596             LONG KeyType;
 597             ULONG Length;
 598             PUCHAR Value;
 599         } KERB_CRYPTO_KEY, *PKERB_CRYPTO_KEY;
 600 
 601         */
 602         if (!found) {
 603             break;
 604         }
 605 
 606         // Build a com.sun.security.krb5.Ticket
 607         ticket = BuildTicket(env, msticket-&gt;EncodedTicket,
 608                                 msticket-&gt;EncodedTicketSize);
 609         if (ticket == NULL) {
 610             break;
 611         }
 612         // OK, have a Ticket, now need to get the client name
 613         clientPrincipal = BuildPrincipal(env, msticket-&gt;ClientName,
 614                                 msticket-&gt;TargetDomainName); // mdu
 615         if (clientPrincipal == NULL) {
 616             break;
 617         }
 618 
 619         // and the &quot;name&quot; of tgt
 620         targetPrincipal = BuildPrincipal(env, msticket-&gt;ServiceName,
 621                         msticket-&gt;DomainName);
 622         if (targetPrincipal == NULL) {
 623             break;
 624         }
 625 
 626         // Get the encryption key
 627         encryptionKey = BuildEncryptionKey(env, &amp;(msticket-&gt;SessionKey));
 628         if (encryptionKey == NULL) {
 629             break;
 630         }
 631 
 632         // and the ticket flags
 633         ticketFlags = BuildTicketFlags(env, &amp;(msticket-&gt;TicketFlags));
 634         if (ticketFlags == NULL) {
 635             break;
 636         }
 637 
 638         // Get the start time
 639         startTime = BuildKerberosTime(env, &amp;(msticket-&gt;StartTime));
 640         if (startTime == NULL) {
 641             break;
 642         }
 643 
 644         /*
 645          * mdu: No point storing the eky expiration time in the auth
 646          * time field. Set it to be same as startTime. Looks like
 647          * windows does not have post-dated tickets.
 648          */
 649         authTime = startTime;
 650 
 651         // and the end time
 652         endTime = BuildKerberosTime(env, &amp;(msticket-&gt;EndTime));
 653         if (endTime == NULL) {
 654             break;
 655         }
 656 
 657         // Get the renew till time
 658         renewTillTime = BuildKerberosTime(env, &amp;(msticket-&gt;RenewUntil));
 659         if (renewTillTime == NULL) {
 660             break;
 661         }
 662 
 663         // and now go build a KrbCreds object
 664         krbCreds = (*env)-&gt;NewObject(
 665                 env,
 666                 krbcredsClass,
 667                 krbcredsConstructor,
 668                 ticket,
 669                 clientPrincipal,
<a name="9" id="anc9"></a>
 670                 targetPrincipal,
<a name="10" id="anc10"></a>
 671                 encryptionKey,
 672                 ticketFlags,
 673                 authTime, // mdu
 674                 startTime,
 675                 endTime,
 676                 renewTillTime, //mdu
 677                 hostAddresses);
 678 
 679         break;
 680     } // end of WHILE. This WHILE will never loop.
 681 
 682     // clean up resources
 683     if (TktCacheResponse != NULL) {
 684         LsaFreeReturnBuffer(TktCacheResponse);
 685     }
 686     if (pTicketRequest) {
 687         LocalFree(pTicketRequest);
 688     }
 689     if (pTicketResponse != NULL) {
 690         LsaFreeReturnBuffer(pTicketResponse);
 691     }
 692 
 693     return krbCreds;
 694 }
 695 
 696 static NTSTATUS
 697 ConstructTicketRequest(JNIEnv *env, UNICODE_STRING DomainName,
 698                 PKERB_RETRIEVE_TKT_REQUEST *outRequest, ULONG *outSize)
 699 {
 700     NTSTATUS Status;
 701     UNICODE_STRING TargetPrefix;
 702     USHORT TargetSize;
 703     ULONG RequestSize;
 704     ULONG Length;
 705     PKERB_RETRIEVE_TKT_REQUEST pTicketRequest = NULL;
 706 
 707     *outRequest = NULL;
 708     *outSize = 0;
 709 
 710     //
 711     // Set up the &quot;krbtgt/&quot; target prefix into a UNICODE_STRING so we
 712     // can easily concatenate it later.
 713     //
 714 
 715     TargetPrefix.Buffer = L&quot;krbtgt/&quot;;
 716     Length = (ULONG)wcslen(TargetPrefix.Buffer) * sizeof(WCHAR);
 717     TargetPrefix.Length = (USHORT)Length;
 718     TargetPrefix.MaximumLength = TargetPrefix.Length;
 719 
 720     //
 721     // We will need to concatenate the &quot;krbtgt/&quot; prefix and the
 722     // Logon Session&#39;s DnsDomainName into our request&#39;s target name.
 723     //
 724     // Therefore, first compute the necessary buffer size for that.
 725     //
 726     // Note that we might theoretically have integer overflow.
 727     //
 728 
 729     TargetSize = TargetPrefix.Length + DomainName.Length;
 730 
 731     //
 732     // The ticket request buffer needs to be a single buffer.  That buffer
 733     // needs to include the buffer for the target name.
 734     //
 735 
 736     RequestSize = sizeof (*pTicketRequest) + TargetSize;
 737 
 738     //
 739     // Allocate the request buffer and make sure it&#39;s zero-filled.
 740     //
 741 
 742     pTicketRequest = (PKERB_RETRIEVE_TKT_REQUEST)
 743                     LocalAlloc(LMEM_ZEROINIT, RequestSize);
 744     if (!pTicketRequest) {
 745         ThrowOOME(env, &quot;Can&#39;t allocate memory for ticket&quot;);
 746         return GetLastError();
 747     }
 748 
 749     //
 750     // Concatenate the target prefix with the previous response&#39;s
 751     // target domain.
 752     //
 753 
 754     pTicketRequest-&gt;TargetName.Length = 0;
 755     pTicketRequest-&gt;TargetName.MaximumLength = TargetSize;
 756     pTicketRequest-&gt;TargetName.Buffer = (PWSTR) (pTicketRequest + 1);
 757     Status = ConcatenateUnicodeStrings(&amp;(pTicketRequest-&gt;TargetName),
 758                                     TargetPrefix,
 759                                     DomainName);
 760     *outRequest = pTicketRequest;
 761     *outSize    = RequestSize;
 762     return Status;
 763 }
 764 
 765 DWORD
 766 ConcatenateUnicodeStrings(
 767     UNICODE_STRING *pTarget,
 768     UNICODE_STRING Source1,
 769     UNICODE_STRING Source2
 770     )
 771 {
 772     //
 773     // The buffers for Source1 and Source2 cannot overlap pTarget&#39;s
 774     // buffer.  Source1.Length + Source2.Length must be &lt;= 0xFFFF,
 775     // otherwise we overflow...
 776     //
 777 
 778     USHORT TotalSize = Source1.Length + Source2.Length;
 779     PBYTE buffer = (PBYTE) pTarget-&gt;Buffer;
 780 
 781     if (TotalSize &gt; pTarget-&gt;MaximumLength)
 782         return ERROR_INSUFFICIENT_BUFFER;
 783 
 784     pTarget-&gt;Length = TotalSize;
 785     memcpy(buffer, Source1.Buffer, Source1.Length);
 786     memcpy(buffer + Source1.Length, Source2.Buffer, Source2.Length);
 787     return ERROR_SUCCESS;
 788 }
 789 
 790 BOOL
 791 PackageConnectLookup(
 792     HANDLE *pLogonHandle,
 793     ULONG *pPackageId
 794     )
 795 {
 796     LSA_STRING Name;
 797     NTSTATUS Status;
 798 
 799     Status = LsaConnectUntrusted(
 800                 pLogonHandle
 801                 );
 802 
 803     if (!LSA_SUCCESS(Status))
 804     {
 805         ShowNTError(&quot;LsaConnectUntrusted&quot;, Status);
 806         return FALSE;
 807     }
 808 
 809     Name.Buffer = MICROSOFT_KERBEROS_NAME_A;
 810     Name.Length = (USHORT)strlen(Name.Buffer);
 811     Name.MaximumLength = Name.Length + 1;
 812 
 813     Status = LsaLookupAuthenticationPackage(
 814                 *pLogonHandle,
 815                 &amp;Name,
 816                 pPackageId
 817                 );
 818 
 819     if (!LSA_SUCCESS(Status))
 820     {
 821         ShowNTError(&quot;LsaLookupAuthenticationPackage&quot;, Status);
 822         return FALSE;
 823     }
 824 
 825     return TRUE;
 826 
 827 }
 828 
 829 VOID
 830 ShowLastError(
 831         LPSTR szAPI,
 832         DWORD dwError
 833         )
 834 {
 835     #define MAX_MSG_SIZE 256
 836 
 837     static WCHAR szMsgBuf[MAX_MSG_SIZE];
 838     DWORD dwRes;
 839 
 840     if (native_debug) {
 841         printf(&quot;LSA: Error calling function %s: %lu\n&quot;, szAPI, dwError);
 842     }
 843 
 844     dwRes = FormatMessage (
 845             FORMAT_MESSAGE_FROM_SYSTEM,
 846             NULL,
 847             dwError,
 848             0,
 849             szMsgBuf,
 850             MAX_MSG_SIZE,
 851             NULL);
 852     if (native_debug) {
 853         if (0 == dwRes) {
 854             printf(&quot;LSA: FormatMessage failed with %d\n&quot;, GetLastError());
 855             // ExitProcess(EXIT_FAILURE);
 856         } else {
 857             printf(&quot;LSA: %S&quot;,szMsgBuf);
 858         }
 859     }
 860 }
 861 
 862 VOID
 863 ShowNTError(
 864         LPSTR szAPI,
 865         NTSTATUS Status
 866         )
 867 {
 868     //
 869     // Convert the NTSTATUS to Winerror. Then call ShowLastError().
 870     //
 871     ShowLastError(szAPI, LsaNtStatusToWinError(Status));
 872 }
 873 
 874 VOID
 875 InitUnicodeString(
 876         PUNICODE_STRING DestinationString,
 877     PCWSTR SourceString OPTIONAL
 878     )
 879 {
 880     ULONG Length;
 881 
 882     DestinationString-&gt;Buffer = (PWSTR)SourceString;
 883     if (SourceString != NULL) {
 884         Length = (ULONG)wcslen( SourceString ) * sizeof( WCHAR );
 885         DestinationString-&gt;Length = (USHORT)Length;
 886         DestinationString-&gt;MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
 887     }
 888     else {
 889         DestinationString-&gt;MaximumLength = 0;
 890         DestinationString-&gt;Length = 0;
 891     }
 892 }
 893 
 894 jobject BuildTicket(JNIEnv *env, PUCHAR encodedTicket, ULONG encodedTicketSize) {
 895 
<a name="11" id="anc11"></a><span class="line-modified"> 896     /* To build a Ticket, we first need to build a DerValue out of the EncodedTicket.</span>
<span class="line-removed"> 897      * But before we can do that, we need to make a byte array out of the ET.</span>
<span class="line-removed"> 898      */</span>
 899 
<a name="12" id="anc12"></a><span class="line-modified"> 900     jobject derValue, ticket;</span>
 901     jbyteArray ary;
 902 
 903     ary = (*env)-&gt;NewByteArray(env,encodedTicketSize);
 904     if (ary == NULL) {
 905         return (jobject) NULL;
 906     }
 907 
 908     (*env)-&gt;SetByteArrayRegion(env, ary, (jsize) 0, encodedTicketSize,
 909                                     (jbyte *)encodedTicket);
 910     if ((*env)-&gt;ExceptionOccurred(env)) {
 911         (*env)-&gt;DeleteLocalRef(env, ary);
 912         return (jobject) NULL;
 913     }
 914 
<a name="13" id="anc13"></a><span class="line-modified"> 915     derValue = (*env)-&gt;NewObject(env, derValueClass, derValueConstructor, ary);</span>
 916     if ((*env)-&gt;ExceptionOccurred(env)) {
 917         (*env)-&gt;DeleteLocalRef(env, ary);
 918         return (jobject) NULL;
 919     }
<a name="14" id="anc14"></a><span class="line-removed"> 920 </span>
 921     (*env)-&gt;DeleteLocalRef(env, ary);
<a name="15" id="anc15"></a><span class="line-removed"> 922     ticket = (*env)-&gt;NewObject(env, ticketClass, ticketConstructor, derValue);</span>
<span class="line-removed"> 923     if ((*env)-&gt;ExceptionOccurred(env)) {</span>
<span class="line-removed"> 924         (*env)-&gt;DeleteLocalRef(env, derValue);</span>
<span class="line-removed"> 925         return (jobject) NULL;</span>
<span class="line-removed"> 926     }</span>
<span class="line-removed"> 927     (*env)-&gt;DeleteLocalRef(env, derValue);</span>
 928     return ticket;
 929 }
 930 
 931 // mdu
 932 jobject BuildPrincipal(JNIEnv *env, PKERB_EXTERNAL_NAME principalName,
 933                                 UNICODE_STRING domainName) {
 934 
 935     /*
 936      * To build the Principal, we need to get the names out of
 937      * this goofy MS structure
 938      */
 939     jobject principal = NULL;
 940     jobject realmStr = NULL;
 941     jobjectArray stringArray;
 942     jstring tempString;
 943     int nameCount,i;
 944     PUNICODE_STRING scanner;
 945     WCHAR *realm;
 946     ULONG realmLen;
 947 
 948     realm = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
 949             ((domainName.Length)*sizeof(WCHAR) + sizeof(UNICODE_NULL)));
 950     if (realm == NULL) {
 951         ThrowOOME(env, &quot;Can&#39;t allocate memory for realm&quot;);
 952         return NULL;
 953     }
 954     wcsncpy(realm, domainName.Buffer, domainName.Length/sizeof(WCHAR));
 955 
 956     if (native_debug) {
 957         printf(&quot;LSA: Principal domain is %S\n&quot;, realm);
 958         printf(&quot;LSA: Name type is %x\n&quot;, principalName-&gt;NameType);
 959         printf(&quot;LSA: Name count is %x\n&quot;, principalName-&gt;NameCount);
 960     }
 961 
 962     nameCount = principalName-&gt;NameCount;
 963     stringArray = (*env)-&gt;NewObjectArray(env, nameCount,
 964                             javaLangStringClass, NULL);
 965     if (stringArray == NULL) {
 966         if (native_debug) {
 967             printf(&quot;LSA: Can&#39;t allocate String array for Principal\n&quot;);
 968         }
 969         goto cleanup;
 970     }
 971 
 972     for (i=0; i&lt;nameCount; i++) {
 973         // get the principal name
 974         scanner = &amp;(principalName-&gt;Names[i]);
 975 
 976         // OK, got a Char array, so construct a String
 977         tempString = (*env)-&gt;NewString(env, (const jchar*)scanner-&gt;Buffer,
 978                             scanner-&gt;Length/sizeof(WCHAR));
 979 
 980         if (tempString == NULL) {
 981             goto cleanup;
 982         }
 983 
 984         // Set the String into the StringArray
 985         (*env)-&gt;SetObjectArrayElement(env, stringArray, i, tempString);
 986 
 987         if ((*env)-&gt;ExceptionCheck(env)) {
 988             goto cleanup;
 989         }
 990 
 991         // Do I have to worry about storage reclamation here?
 992     }
 993     // now set the realm in the principal
 994     realmLen = (ULONG)wcslen((PWCHAR)realm);
 995     realmStr = (*env)-&gt;NewString(env, (PWCHAR)realm, (USHORT)realmLen);
 996 
 997     if (realmStr == NULL) {
 998         goto cleanup;
 999     }
1000 
1001     principal = (*env)-&gt;NewObject(env, principalNameClass,
1002                     principalNameConstructor, stringArray, realmStr);
1003 
1004 cleanup:
1005     // free local resources
1006     LocalFree(realm);
1007 
1008     return principal;
1009 }
1010 
1011 jobject BuildEncryptionKey(JNIEnv *env, PKERB_CRYPTO_KEY cryptoKey) {
1012     // First, need to build a byte array
1013     jbyteArray ary;
1014     jobject encryptionKey = NULL;
1015     unsigned int i;
1016 
1017     for (i=0; i&lt;cryptoKey-&gt;Length; i++) {
1018         if (cryptoKey-&gt;Value[i]) break;
1019     }
1020     if (i == cryptoKey-&gt;Length) {
1021         if (native_debug) {
1022             printf(&quot;LSA: Session key all zero. Stop.\n&quot;);
1023         }
1024         return NULL;
1025     }
1026 
1027     ary = (*env)-&gt;NewByteArray(env,cryptoKey-&gt;Length);
1028     if (ary == NULL) {
1029         return (jobject) NULL;
1030     }
1031     (*env)-&gt;SetByteArrayRegion(env, ary, (jsize) 0, cryptoKey-&gt;Length,
1032                                     (jbyte *)cryptoKey-&gt;Value);
1033     if ((*env)-&gt;ExceptionOccurred(env)) {
1034         (*env)-&gt;DeleteLocalRef(env, ary);
1035     } else {
1036         encryptionKey = (*env)-&gt;NewObject(env, encryptionKeyClass,
1037                 encryptionKeyConstructor, cryptoKey-&gt;KeyType, ary);
1038     }
1039 
1040     return encryptionKey;
1041 }
1042 
1043 jobject BuildTicketFlags(JNIEnv *env, PULONG flags) {
1044     jobject ticketFlags = NULL;
1045     jbyteArray ary;
1046     /*
1047      * mdu: Convert the bytes to nework byte order before copying
1048      * them to a Java byte array.
1049      */
1050     ULONG nlflags = htonl(*flags);
1051 
1052     ary = (*env)-&gt;NewByteArray(env, sizeof(*flags));
1053     if (ary == NULL) {
1054         return (jobject) NULL;
1055     }
1056     (*env)-&gt;SetByteArrayRegion(env, ary, (jsize) 0, sizeof(*flags),
1057                                     (jbyte *)&amp;nlflags);
1058     if ((*env)-&gt;ExceptionOccurred(env)) {
1059         (*env)-&gt;DeleteLocalRef(env, ary);
1060     } else {
1061         ticketFlags = (*env)-&gt;NewObject(env, ticketFlagsClass,
1062                 ticketFlagsConstructor, sizeof(*flags)*8, ary);
1063     }
1064 
1065     return ticketFlags;
1066 }
1067 
1068 jobject BuildKerberosTime(JNIEnv *env, PLARGE_INTEGER kerbtime) {
1069     jobject kerberosTime = NULL;
1070     jstring stringTime = NULL;
1071     SYSTEMTIME systemTime;
1072     WCHAR timeString[16];
1073     WCHAR month[3];
1074     WCHAR day[3];
1075     WCHAR hour[3];
1076     WCHAR minute[3];
1077     WCHAR second[3];
1078 
1079     if (FileTimeToSystemTime((FILETIME *)kerbtime, &amp;systemTime)) {
1080         // XXX Cannot use %02.2ld, because the leading 0 is ignored for integers.
1081         // So, print them to strings, and then print them to the master string with a
1082         // format pattern that makes it two digits and prefix with a 0 if necessary.
1083         swprintf( (wchar_t *)month, 3, L&quot;%2.2d&quot;, systemTime.wMonth);
1084         swprintf( (wchar_t *)day, 3, L&quot;%2.2d&quot;, systemTime.wDay);
1085         swprintf( (wchar_t *)hour, 3, L&quot;%2.2d&quot;, systemTime.wHour);
1086         swprintf( (wchar_t *)minute, 3, L&quot;%2.2d&quot;, systemTime.wMinute);
1087         swprintf( (wchar_t *)second, 3, L&quot;%2.2d&quot;, systemTime.wSecond);
1088         swprintf( (wchar_t *)timeString, 16,
1089                 L&quot;%ld%02.2s%02.2s%02.2s%02.2s%02.2sZ&quot;,
1090                 systemTime.wYear,
1091                 month,
1092                 day,
1093                 hour,
1094                 minute,
1095                 second );
1096         if (native_debug) {
1097             printf(&quot;LSA: %S\n&quot;, (wchar_t *)timeString);
1098         }
1099         stringTime = (*env)-&gt;NewString(env, timeString,
1100                 (sizeof(timeString)/sizeof(WCHAR))-1);
1101         if (stringTime != NULL) { // everything&#39;s OK so far
1102             kerberosTime = (*env)-&gt;NewObject(env, kerberosTimeClass,
1103                     kerberosTimeConstructor, stringTime);
1104         }
1105     }
1106     return kerberosTime;
1107 }
1108 
1109 void ThrowOOME(JNIEnv *env, const char *szMessage) {
1110     jclass exceptionClazz = (*env)-&gt;FindClass(env, &quot;java/lang/OutOfMemoryError&quot;);
1111     if (exceptionClazz != NULL) {
1112         (*env)-&gt;ThrowNew(env, exceptionClazz, szMessage);
1113     }
1114 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.security.jgss/windows/native/libsspi_bridge/sspi.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 // This library is client-side only, and only supports the default credentials.
  27 // It speaks krb5 and SPNEGO. NTLM is excluded from SPNEGO negotiation.
  28 //
  29 // This library can be built directly with the following command:
  30 //   cl -I %OPENJDK%\src\java.security.jgss\share\native\libj2gss\ sspi.cpp \
  31 //      -link -dll -out:sspi_bridge.dll
  32 
  33 #define UNICODE
  34 #define _UNICODE
  35 
  36 #include &lt;windows.h&gt;
  37 #include &lt;stdlib.h&gt;
  38 #include &lt;stdio.h&gt;
  39 #include &lt;string.h&gt;
  40 #include &lt;Strsafe.h&gt;
  41 #include &lt;ntsecapi.h&gt;
  42 #include &lt;new&gt;
  43 
  44 #define GSS_DLL_FILE
  45 #include &lt;gssapi.h&gt;
  46 
  47 #define SECURITY_WIN32
  48 #include &lt;sspi.h&gt;
  49 
  50 #pragma comment(lib, &quot;secur32.lib&quot;)
  51 
  52 // Otherwise an exception will be thrown
  53 #define new new (std::nothrow)
  54 
  55 // A debugging macro
  56 #define PP(fmt, ...) \
  57         if (trace) { \
  58             fprintf(stderr, &quot;[SSPI:%ld] &quot;fmt&quot;\n&quot;, __LINE__, ##__VA_ARGS__); \
  59             fflush(stderr); \
  60         }
  61 #define SEC_SUCCESS(status) ((*minor_status = (status)), (status) &gt;= SEC_E_OK)
  62 
  63 #ifdef __cplusplus
  64 extern &quot;C&quot; {
  65 #endif /* __cplusplus */
  66 
  67 // When SSPI_BRIDGE_TRACE is set, debug info goes to stderr. The value is ignored.
  68 char* trace = getenv(&quot;SSPI_BRIDGE_TRACE&quot;);
  69 
  70 void
  71 dump(const char* title, PBYTE data, size_t len)
  72 {
  73     if (trace) {
  74         fprintf(stderr, &quot;==== %s ====\n&quot;, title);
  75         for (size_t i = 0; i &lt; len; i++) {
  76             if (i != 0 &amp;&amp; i % 16 == 0) {
  77                 fprintf(stderr, &quot;\n&quot;);
  78             }
  79             fprintf(stderr, &quot;%02X &quot;, *(data + i) &amp; 0xff);
  80         }
  81         fprintf(stderr, &quot;\n&quot;);
  82     }
  83 }
  84 
  85 gss_OID_desc KRB5_OID = {9, (void*)&quot;\x2a\x86\x48\x86\xf7\x12\x01\x02\x02&quot;};
  86 gss_OID_desc SPNEGO_OID = {6, (void*)&quot;\x2b\x06\x01\x05\x05\x02&quot;};
  87 gss_OID_desc USER_NAME_OID = {10, (void*)&quot;\x2a\x86\x48\x86\xf7\x12\x01\x02\x01\x01&quot;};
  88 gss_OID_desc KRB5_NAME_OID = {10, (void*)&quot;\x2a\x86\x48\x86\xf7\x12\x01\x02\x02\x01&quot;};
  89 gss_OID_desc HOST_SERVICE_NAME_OID = {10, (void*)&quot;\x2a\x86\x48\x86\xf7\x12\x01\x02\x01\x04&quot;};
  90 gss_OID_desc EXPORT_NAME_OID = {6, (void*)&quot;\x2b\x06\x01\x05\x06\x04&quot;};
  91 
  92 struct gss_name_struct {
  93     SEC_WCHAR* name;
  94 };
  95 
  96 struct gss_ctx_id_struct {
  97     CredHandle* phCred;
  98     CtxtHandle hCtxt;
  99     SecPkgContext_Sizes SecPkgContextSizes;
 100     SecPkgContext_NativeNames nnames;
 101     BOOLEAN established;
 102     BOOLEAN isSPNEGO;
 103     BOOLEAN isLocalCred;
 104     OM_uint32 flags;
 105 };
 106 
 107 struct gss_cred_id_struct {
 108     CredHandle* phCredK;
 109     CredHandle* phCredS;
 110     long time;
 111 };
 112 
 113 /* This section holds supporting functions that are not exported */
 114 
 115 static OM_uint32
 116 seconds_until(int inputIsUTC, TimeStamp *time)
 117 {
 118     // time is local time
 119     LARGE_INTEGER uiLocal;
 120     FILETIME now;
 121     GetSystemTimeAsFileTime(&amp;now);
 122     if (!inputIsUTC) {
 123         FILETIME nowLocal;
 124         if (FileTimeToLocalFileTime(&amp;now, &amp;nowLocal) == 0) {
 125             return -1;
 126         }
 127         now = nowLocal;
 128     }
 129     uiLocal.HighPart = now.dwHighDateTime;
 130     uiLocal.LowPart = now.dwLowDateTime;
 131     if (time-&gt;QuadPart &lt; uiLocal.QuadPart) {
 132         return 0;
 133     }
 134     ULONGLONG diff = (time-&gt;QuadPart - uiLocal.QuadPart) / 10000000;
 135     if (diff &gt; (ULONGLONG)~(OM_uint32)0) {
 136         return GSS_C_INDEFINITE;
 137     }
 138     return (OM_uint32)diff;
 139 }
 140 
 141 static void
 142 show_time(char* label, TimeStamp* ts)
 143 {
 144     if (trace) {
 145         SYSTEMTIME stLocal;
 146         FileTimeToSystemTime((FILETIME*)ts, &amp;stLocal);
 147 
 148         // Build a string showing the date and time.
 149         PP(&quot;%s: %02d/%02d/%d  %02d:%02d %uld&quot;, label,
 150             stLocal.wMonth, stLocal.wDay, stLocal.wYear,
 151             stLocal.wHour, stLocal.wMinute,
 152             seconds_until(1, ts));
 153     }
 154 }
 155 
 156 // isSPNEGO: true, SPNEGO. false, Kerberos.
 157 static gss_ctx_id_t
 158 new_context(BOOLEAN isSPNEGO)
 159 {
 160     gss_ctx_id_t out = new gss_ctx_id_struct;
 161     if (out == NULL) {
 162         return NULL;
 163     }
 164     out-&gt;phCred = NULL;
 165     out-&gt;hCtxt.dwLower = out-&gt;hCtxt.dwUpper = NULL;
 166     out-&gt;established = FALSE;
 167     out-&gt;SecPkgContextSizes.cbMaxSignature
 168             = out-&gt;SecPkgContextSizes.cbBlockSize
 169             = out-&gt;SecPkgContextSizes.cbSecurityTrailer
 170             = 0;
 171     out-&gt;nnames.sClientName = out-&gt;nnames.sServerName = NULL;
 172     out-&gt;isSPNEGO = isSPNEGO;
 173     out-&gt;isLocalCred = FALSE;
 174     return out;
 175 }
 176 
 177 static gss_cred_id_t
 178 new_cred()
 179 {
 180     gss_cred_id_t out = new gss_cred_id_struct;
 181     if (out) {
 182         out-&gt;phCredK = out-&gt;phCredS = NULL;
 183         out-&gt;time = 0L;
 184     }
 185     return out;
 186 }
 187 
 188 static int
 189 flag_sspi_to_gss(int fin)
 190 {
 191     int fout = 0;
 192     if (fin &amp; ISC_REQ_MUTUAL_AUTH) fout |= GSS_C_MUTUAL_FLAG;
 193     if (fin &amp; ISC_REQ_CONFIDENTIALITY) fout |= GSS_C_CONF_FLAG;
 194     if (fin &amp; ISC_REQ_DELEGATE) fout |= GSS_C_DELEG_FLAG;
 195     if (fin &amp; ISC_REQ_INTEGRITY) fout |= GSS_C_INTEG_FLAG;
 196     if (fin &amp; ISC_REQ_REPLAY_DETECT) fout |= GSS_C_REPLAY_FLAG;
 197     if (fin &amp; ISC_REQ_SEQUENCE_DETECT) fout |= GSS_C_SEQUENCE_FLAG;
 198     return fout;
 199 }
 200 
 201 static int
 202 flag_gss_to_sspi(int fin)
 203 {
 204     int fout = 0;
 205     if (fin &amp; GSS_C_MUTUAL_FLAG) fout |= ISC_RET_MUTUAL_AUTH;
 206     if (fin &amp; GSS_C_CONF_FLAG) fout |= ISC_RET_CONFIDENTIALITY;
 207     if (fin &amp; GSS_C_DELEG_FLAG) fout |= ISC_RET_DELEGATE;
 208     if (fin &amp; GSS_C_INTEG_FLAG) fout |= ISC_RET_INTEGRITY;
 209     if (fin &amp; GSS_C_REPLAY_FLAG) fout |= ISC_RET_REPLAY_DETECT;
 210     if (fin &amp; GSS_C_SEQUENCE_FLAG) fout |= ISC_RET_SEQUENCE_DETECT;
 211     return fout;
 212 }
 213 
 214 static BOOLEAN
 215 is_same_oid(gss_const_OID o2, gss_const_OID o1)
 216 {
 217     return o1 &amp;&amp; o2 &amp;&amp; o1-&gt;length == o2-&gt;length
 218             &amp;&amp; !memcmp(o1-&gt;elements, o2-&gt;elements, o2-&gt;length);
 219 }
 220 
 221 static BOOLEAN
 222 has_oid(gss_const_OID_set set, gss_const_OID oid)
 223 {
 224     for (size_t i = 0; i &lt; set-&gt;count; i++) {
 225         if (is_same_oid(&amp;set-&gt;elements[i], oid)) {
 226             return TRUE;
 227         }
 228     }
 229     return FALSE;
 230 }
 231 
 232 static void
 233 show_oid(gss_const_OID mech)
 234 {
 235     if (trace) {
 236         if (is_same_oid(mech, &amp;KRB5_OID)) {
 237             PP(&quot;Kerberos mech&quot;);
 238         } else if (is_same_oid(mech, &amp;SPNEGO_OID)) {
 239             PP(&quot;SPNEGO mech&quot;);
 240         } else if (is_same_oid(mech, &amp;USER_NAME_OID)) {
 241             PP(&quot;NT_USER_NAME name-type&quot;);
 242         } else if (is_same_oid(mech, &amp;KRB5_NAME_OID)) {
 243             PP(&quot;KRB5_NAME name-type&quot;);
 244         } else if (is_same_oid(mech, &amp;HOST_SERVICE_NAME_OID)) {
 245             PP(&quot;NT_HOSTBASED_SERVICE name-type&quot;);
 246         } else if (is_same_oid(mech, &amp;EXPORT_NAME_OID)) {
 247             PP(&quot;NT_EXPORT_NAME name-type&quot;);
 248         } else {
 249             dump(&quot;UNKNOWN OID&quot;, (PBYTE)mech-&gt;elements, mech-&gt;length);
 250         }
 251     }
 252 }
 253 
 254 static void
 255 show_oid_set(gss_const_OID_set mechs)
 256 {
 257     if (trace) {
 258         if (mechs == NULL) {
 259             PP(&quot;OID set is NULL&quot;);
 260             return;
 261         }
 262         PP(&quot;gss_OID_set.count is %d&quot;, (int)mechs-&gt;count);
 263         for (size_t i = 0; i &lt; mechs-&gt;count; i++) {
 264             show_oid(&amp;mechs-&gt;elements[i]);
 265         }
 266     }
 267 }
 268 
 269 // Add realm to a name if there was none.
 270 // Returns a newly allocated name.
 271 static WCHAR*
 272 get_full_name(WCHAR* input)
 273 {
 274     // input has realm, no need to add one
 275     for (int i = 0;; i++) {
 276         if (!input[i]) { // the end
 277             break;
 278         }
 279         if (input[i] == L&#39;\\&#39;) { // escaped
 280             i++;
 281             continue;
 282         }
 283         if (input[i] == L&#39;@&#39;) {
 284             return _wcsdup(input);
 285         }
 286     }
 287 
 288     // Always use the default domain
 289     WCHAR* realm = _wgetenv(L&quot;USERDNSDOMAIN&quot;);
 290     if (realm == NULL) {
 291         realm = L&quot;&quot;;
 292     }
 293 
 294     size_t oldlen = wcslen(input);
 295     size_t newlen = oldlen + 1 + wcslen(realm) + 1;
 296 
 297     WCHAR* fullname = new WCHAR[newlen];
 298     if (!fullname) {
 299         return NULL;
 300     }
 301     wcscpy_s(fullname, newlen, input);
 302     wcscat_s(fullname, newlen, L&quot;@&quot;);
 303     wcscat_s(fullname, newlen, realm);
 304 
 305     PP(&quot;get_full_name returns %ls&quot;, fullname);
 306     return fullname;
 307 }
 308 
 309 /* End support section */
 310 
 311 /* This section holds GSS-API exported functions */
 312 
 313 #define CHECK_OUTPUT(x)  if (!x) return GSS_S_CALL_INACCESSIBLE_WRITE;
 314 #define CHECK_BUFFER(b)  if (!b || !b-&gt;value) return GSS_S_CALL_INACCESSIBLE_READ;
 315 #define CHECK_OID(o)     if (!o || !o-&gt;elements) return GSS_S_CALL_INACCESSIBLE_READ;
 316 #define CHECK_NAME(n)    if (!n || !(n-&gt;name)) return GSS_S_BAD_NAME;
 317 #define CHECK_CONTEXT(c) if (!c) return GSS_S_NO_CONTEXT;
 318 #define CHECK_CRED(c)    if (!c || (!(cred_handle-&gt;phCredK) &amp;&amp; !(cred_handle-&gt;phCredS))) \
 319                                 return GSS_S_NO_CRED;
 320 
 321 __declspec(dllexport) OM_uint32
 322 gss_release_name(OM_uint32 *minor_status,
 323                  gss_name_t *name)
 324 {
 325     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_release_name %p...&quot;, *name);
 326     if (name != NULL &amp;&amp; *name != GSS_C_NO_NAME) {
 327         if ((*name)-&gt;name != NULL) {
 328             delete[] (*name)-&gt;name;
 329         }
 330         delete *name;
 331         *name = GSS_C_NO_NAME;
 332     }
 333     return GSS_S_COMPLETE;
 334 }
 335 
 336 __declspec(dllexport) OM_uint32
 337 gss_import_name(OM_uint32 *minor_status,
 338                 gss_const_buffer_t input_name_buffer,
 339                 gss_const_OID input_name_type,
 340                 gss_name_t *output_name)
 341 {
 342     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_import_name...&quot;);
 343     CHECK_BUFFER(input_name_buffer)
 344     CHECK_OUTPUT(output_name)
 345 
 346     int len = (int)input_name_buffer-&gt;length;
 347     LPSTR input = (LPSTR)input_name_buffer-&gt;value;
 348     if (input_name_type != NULL
 349             &amp;&amp; is_same_oid(input_name_type, &amp;EXPORT_NAME_OID)) {
 350         if (len &lt; 4 || input[0] != 4 || input[1] != 1 || input[2] != 0) {
 351             return GSS_S_FAILURE;
 352         }
 353         int mechLen = (int)input[3]; /* including 06 len */
 354         len -= mechLen + 8; /* 4 header bytes, and an int32 length after OID */
 355         if (len &lt;= 0) {
 356             return GSS_S_FAILURE;
 357         }
 358         // Reject if mech is not krb5
 359         if (mechLen - 2!= KRB5_OID.length ||
 360                 memcmp(input + 6, KRB5_OID.elements, mechLen - 2)) {
 361             return GSS_S_FAILURE;;
 362         }
 363         input = input + mechLen + 8;
 364     }
 365 
 366     SEC_WCHAR* value = new SEC_WCHAR[len + 1];
 367     if (value == NULL) {
 368         goto err;
 369     }
 370 
 371     len = MultiByteToWideChar(CP_UTF8, 0, input, len, value, len+1);
 372     if (len == 0) {
 373         goto err;
 374     }
 375     value[len] = 0;
 376 
 377     PP(&quot;import_name from %ls&quot;, value);
 378 
 379     if (len &gt; 33 &amp;&amp; !wcscmp(value+len-33, L&quot;@WELLKNOWN:ORG.H5L.REFERALS-REALM&quot;)) {
 380         // Remove the wellknown referrals realms
 381         value[len-33] = 0;
 382         len -= 33;
 383     } else if (value[len-1] == L&#39;@&#39;) {
 384         // Remove the empty realm. It might come from an NT_EXPORT_NAME.
 385         value[len-1] = 0;
 386         len--;
 387     }
 388     if (len == 0) {
 389         goto err;
 390     }
 391 
 392     if (input_name_type != NULL
 393             &amp;&amp; is_same_oid(input_name_type, &amp;HOST_SERVICE_NAME_OID)) {
 394         // HOST_SERVICE_NAME_OID takes the form of service@host.
 395         for (int i = 0; i &lt; len; i++) {
 396             if (value[i] == L&#39;\\&#39;) {
 397                 i++;
 398                 continue;
 399             }
 400             if (value[i] == L&#39;@&#39;) {
 401                 value[i] = L&#39;/&#39;;
 402                 break;
 403             }
 404         }
 405         PP(&quot;Host-based service now %ls&quot;, value);
 406     }
 407     PP(&quot;import_name to %ls&quot;, value);
 408     gss_name_struct* name = new gss_name_struct;
 409     if (name == NULL) {
 410         goto err;
 411     }
 412     name-&gt;name = value;
 413     *output_name = (gss_name_t) name;
 414     return GSS_S_COMPLETE;
 415 err:
 416     if (value != NULL) {
 417         delete[] value;
 418     }
 419     return GSS_S_FAILURE;
 420 }
 421 
 422 __declspec(dllexport) OM_uint32
 423 gss_compare_name(OM_uint32 *minor_status,
 424                  gss_const_name_t name1,
 425                  gss_const_name_t name2,
 426                  int *name_equal)
 427 {
 428     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_compare_name...&quot;);
 429     CHECK_NAME(name1)
 430     CHECK_NAME(name2)
 431     CHECK_OUTPUT(name_equal)
 432 
 433     *name_equal = 0;
 434 
 435     SEC_WCHAR* n1 = name1-&gt;name;
 436     SEC_WCHAR* n2 = name2-&gt;name;
 437     PP(&quot;Comparing %ls and %ls&quot;, n1, n2);
 438 
 439     int l1 = lstrlen(n1);
 440     int l2 = lstrlen(n2);
 441     int r1 = l1; // position of @ or the end if none
 442     int r2 = l2;
 443     int i;
 444 
 445     for (i = 0; i &lt; l1; i++) {
 446         if (n1[i] == L&#39;\\&#39;) {
 447             i++;
 448             continue;
 449         }
 450         if (n1[i] == L&#39;@&#39;) {
 451             r1 = i;
 452             break;
 453         }
 454     }
 455 
 456     for (i = 0; i &lt; l2; i++) {
 457         if (n2[i] == L&#39;\\&#39;) {
 458             i++;
 459             continue;
 460         }
 461         if (n2[i] == L&#39;@&#39;) {
 462             r2 = i;
 463             break;
 464         }
 465     }
 466 
 467     if (l1 &lt; l2 &amp;&amp; l1 != r2
 468             || l2 &lt; l1 &amp;&amp; l2 != l1) {
 469         return GSS_S_COMPLETE; // different
 470     }
 471 
 472     if (l1 &gt; l2) {
 473         l1 = l2; // choose the smaller one. longer=smaller @ ...
 474     }
 475 
 476     // Two names are equal if they are the same or one has no realm and
 477     // one has realm but they have the same name. If both have realm but
 478     // different, they are treated different even if the names are the same.
 479     // Note: the default name concept is not used here.
 480     // Principal names on Windows are case-insensitive, both user name
 481     // and service principal name.
 482     if (CompareStringEx(LOCALE_NAME_SYSTEM_DEFAULT, NORM_IGNORECASE,
 483             n1, l1, n2, l1, NULL, NULL, 0) == CSTR_EQUAL) {
 484         *name_equal = 1;
 485     }
 486     return GSS_S_COMPLETE;
 487 }
 488 
 489 __declspec(dllexport) OM_uint32
 490 gss_canonicalize_name(OM_uint32 *minor_status,
 491                       gss_const_name_t input_name,
 492                       gss_const_OID mech_type,
 493                       gss_name_t *output_name)
 494 {
 495     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_canonicalize_name...&quot;);
 496     CHECK_NAME(input_name)
 497     CHECK_OID(mech_type)
 498     CHECK_OUTPUT(output_name)
 499 
 500     if (!is_same_oid(mech_type, &amp;KRB5_OID)) {
 501         PP(&quot;Cannot canonicalize to non-krb5 OID&quot;);
 502         return GSS_S_BAD_MECH;
 503     }
 504     gss_name_t names2 = new gss_name_struct;
 505     if (names2 == NULL) {
 506         return GSS_S_FAILURE;
 507     }
 508     names2-&gt;name = get_full_name(input_name-&gt;name);
 509     if (names2-&gt;name == NULL) {
 510         delete names2;
 511         return GSS_S_FAILURE;
 512     }
 513     *output_name = names2;
 514     return GSS_S_COMPLETE;
 515 }
 516 
 517 __declspec(dllexport) OM_uint32
 518 gss_export_name(OM_uint32 *minor_status,
 519                 gss_const_name_t input_name,
 520                 gss_buffer_t exported_name)
 521 {
 522     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_export_name...&quot;);
 523     CHECK_NAME(input_name)
 524     CHECK_OUTPUT(exported_name)
 525 
 526     OM_uint32 result = GSS_S_FAILURE;
 527     SEC_WCHAR* name = input_name-&gt;name;
 528     SEC_WCHAR* fullname = get_full_name(name);
 529     if (!fullname) {
 530         goto err;
 531     }
 532     PP(&quot;Make fullname: %ls -&gt; %ls&quot;, name, fullname);
 533     int len;
 534     size_t namelen = wcslen(fullname);
 535     if (namelen &gt; 255) {
 536         goto err;
 537     }
 538     len = (int)namelen;
 539     // We only deal with not-so-long names.
 540     // 04 01 00 ** 06 ** OID len:int32 name
 541     int mechLen = KRB5_OID.length;
 542     char* buffer = new char[10 + mechLen + len];
 543     if (buffer == NULL) {
 544         goto err;
 545     }
 546     buffer[0] = 4;
 547     buffer[1] = 1;
 548     buffer[2] = 0;
 549     buffer[3] = 2 + mechLen;
 550     buffer[4] = 6;
 551     buffer[5] = mechLen;
 552     memcpy_s(buffer + 6, mechLen, KRB5_OID.elements, mechLen);
 553     buffer[6 + mechLen] = buffer[7 + mechLen] = buffer[8 + mechLen] = 0;
 554     buffer[9 + mechLen] = (char)len;
 555     len = WideCharToMultiByte(CP_UTF8, 0, fullname, len,
 556                 buffer+10+mechLen, len, NULL, NULL);
 557     if (len == 0) {
 558         delete[] buffer;
 559         goto err;
 560     }
 561     exported_name-&gt;length = 10 + mechLen + len;
 562     exported_name-&gt;value = buffer;
 563     result = GSS_S_COMPLETE;
 564 err:
 565     if (fullname != name) {
 566         delete[] fullname;
 567     }
 568     return result;
 569 }
 570 
 571 __declspec(dllexport) OM_uint32
 572 gss_display_name(OM_uint32 *minor_status,
 573                  gss_const_name_t input_name,
 574                  gss_buffer_t output_name_buffer,
 575                  gss_OID *output_name_type)
 576 {
 577     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_display_name...&quot;);
 578     CHECK_NAME(input_name)
 579     CHECK_OUTPUT(output_name_buffer)
 580 
 581     SEC_WCHAR* names = input_name-&gt;name;
 582     int len = (int)wcslen(names);
 583     char* buffer = new char[4*len+1];
 584     if (buffer == NULL) {
 585         return GSS_S_FAILURE;
 586     }
 587     len = WideCharToMultiByte(CP_UTF8, 0, names, len, buffer, 4*len, NULL, NULL);
 588     if (len == 0) {
 589         delete[] buffer;
 590         return GSS_S_FAILURE;
 591     }
 592     buffer[len] = 0;
 593     output_name_buffer-&gt;length = len;
 594     output_name_buffer-&gt;value = buffer;
 595     PP(&quot;Name found: %ls -&gt; %d [%s]&quot;, names, len, buffer);
 596     if (output_name_type != NULL) {
 597         *output_name_type = &amp;KRB5_NAME_OID;
 598     }
 599     return GSS_S_COMPLETE;
 600 }
 601 
 602 __declspec(dllexport) OM_uint32
 603 gss_acquire_cred(OM_uint32 *minor_status,
 604                  gss_const_name_t desired_name,
 605                  OM_uint32 time_req,
 606                  gss_const_OID_set desired_mechs,
 607                  gss_cred_usage_t cred_usage,
 608                  gss_cred_id_t *output_cred_handle,
 609                  gss_OID_set *actual_mechs,
 610                  OM_uint32 *time_rec)
 611 {
 612     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_acquire_cred...&quot;);
 613     CHECK_OUTPUT(output_cred_handle)
 614 
 615     SECURITY_STATUS ss;
 616     TimeStamp ts;
 617     ts.QuadPart = 0;
 618     cred_usage = 0;
 619     PP(&quot;AcquireCredentialsHandle with %d %p&quot;, cred_usage, desired_mechs);
 620     show_oid_set(desired_mechs);
 621 
 622     BOOLEAN reqKerberos, reqSPNEGO;
 623 
 624     if (!desired_mechs) {
 625         reqKerberos = reqSPNEGO = TRUE;
 626     } else {
 627         if (has_oid(desired_mechs, &amp;KRB5_OID)) {
 628             PP(&quot;reqKerberos&quot;);
 629             reqKerberos = TRUE;
 630         }
 631         if (has_oid(desired_mechs, &amp;SPNEGO_OID)) {
 632             PP(&quot;reqSPNEGO&quot;);
 633             reqSPNEGO = TRUE;
 634         }
 635         if (!reqSPNEGO &amp;&amp; !reqKerberos) {
 636             return GSS_S_BAD_MECH;
 637         }
 638     }
 639 
 640     if (actual_mechs) {
 641         *actual_mechs = GSS_C_NO_OID_SET;
 642     }
 643 
 644     gss_cred_id_t cred = new_cred();
 645     if (cred == NULL) {
 646         goto err;
 647     }
 648 
 649     if (reqKerberos) {
 650         cred-&gt;phCredK = new CredHandle;
 651         if (cred-&gt;phCredK == NULL) {
 652             goto err;
 653         }
 654         ss = AcquireCredentialsHandle(
 655                 NULL,
 656                 L&quot;Kerberos&quot;,
 657                 cred_usage == 0 ? SECPKG_CRED_BOTH :
 658                     (cred_usage == 1 ? SECPKG_CRED_OUTBOUND : SECPKG_CRED_INBOUND),
 659                 NULL,
 660                 NULL,
 661                 NULL,
 662                 NULL,
 663                 cred-&gt;phCredK,
 664                 &amp;ts);
 665         if (!(SEC_SUCCESS(ss))) {
 666             delete cred-&gt;phCredK;
 667             cred-&gt;phCredK = NULL;
 668             goto err;
 669         }
 670     }
 671 
 672     if (reqSPNEGO) {
 673         cred-&gt;phCredS = new CredHandle;
 674         if (cred-&gt;phCredS == NULL) {
 675             goto err;
 676         }
 677         SEC_WINNT_AUTH_IDENTITY_EX auth;
 678         ZeroMemory(&amp;auth, sizeof(auth));
 679         auth.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
 680         auth.Length = sizeof(auth);
 681         auth.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
 682         auth.PackageList = (unsigned short*)L&quot;Kerberos&quot;;
 683         auth.PackageListLength = 8;
 684         ss = AcquireCredentialsHandle(
 685                 NULL,
 686                 L&quot;Negotiate&quot;,
 687                 cred_usage == 0 ? SECPKG_CRED_BOTH :
 688                     (cred_usage == 1 ? SECPKG_CRED_OUTBOUND : SECPKG_CRED_INBOUND),
 689                 NULL,
 690                 &amp;auth,
 691                 NULL,
 692                 NULL,
 693                 cred-&gt;phCredS,
 694                 &amp;ts);
 695         if (!(SEC_SUCCESS(ss))) {
 696             delete cred-&gt;phCredS;
 697             cred-&gt;phCredS = NULL;
 698             goto err;
 699         }
 700     }
 701 
 702     if (actual_mechs) {
 703         if (gss_create_empty_oid_set(minor_status, actual_mechs)) {
 704             goto err;
 705         }
 706         if (reqKerberos) {
 707             if (gss_add_oid_set_member(minor_status, &amp;KRB5_OID, actual_mechs)) {
 708                 goto err;
 709             }
 710         }
 711         if (reqSPNEGO) {
 712             if (gss_add_oid_set_member(minor_status, &amp;SPNEGO_OID, actual_mechs)) {
 713                 goto err;
 714             }
 715         }
 716     }
 717 
 718     *output_cred_handle = (gss_cred_id_t)cred;
 719 
 720     // Note: ts here is weirdly huge, maybe because LSA retains the
 721     // password and can re-acquire a TGT at anytime. It will be
 722     // GSSCredential.INDEFINITE_LIFETIME.
 723     show_time(&quot;cred expiration&quot;, &amp;ts);
 724     cred-&gt;time = seconds_until(1, &amp;ts);
 725     if (time_rec != NULL) {
 726         *time_rec = cred-&gt;time;
 727     }
 728 
 729     // Since only default cred is supported, if there is a desired_name,
 730     // we must make sure it is the same as the realname of the default cred.
 731     if (desired_name != NULL) {
 732         PP(&quot;Acquiring cred with a name. Check if it&#39;s me.&quot;);
 733         gss_name_t realname;
 734         if (gss_inquire_cred(minor_status, *output_cred_handle, &amp;realname,
 735                 NULL, NULL, NULL) != GSS_S_COMPLETE) {
 736             PP(&quot;Cannot get owner name of default creds&quot;);
 737             goto err;
 738         }
 739         SEC_WCHAR* rnames = realname-&gt;name;
 740         SEC_WCHAR* dnames = desired_name-&gt;name;
 741         int equals = 0;
 742         gss_compare_name(minor_status, realname, desired_name, &amp;equals);
 743         gss_release_name(minor_status, &amp;realname);
 744         PP(&quot;Comparing result: %d&quot;, equals);
 745         if (!equals) {
 746             goto err;
 747         }
 748     }
 749 
 750     return GSS_S_COMPLETE;
 751 err:
 752     if (cred) {
 753         OM_uint32 dummy;
 754         gss_release_cred(&amp;dummy, &amp;cred);
 755     }
 756     if (actual_mechs) {
 757         OM_uint32 dummy;
 758         gss_release_oid_set(&amp;dummy, actual_mechs);
 759     }
 760     return GSS_S_FAILURE;
 761 }
 762 
 763 __declspec(dllexport) OM_uint32
 764 gss_release_cred(OM_uint32 *minor_status,
 765                  gss_cred_id_t *cred_handle)
 766 {
 767     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_release_cred...&quot;);
 768     if (cred_handle &amp;&amp; *cred_handle) {
 769         if ((*cred_handle)-&gt;phCredK) {
 770             FreeCredentialsHandle((*cred_handle)-&gt;phCredK);
 771             delete (*cred_handle)-&gt;phCredK;
 772         }
 773         if ((*cred_handle)-&gt;phCredS) {
 774             FreeCredentialsHandle((*cred_handle)-&gt;phCredS);
 775             delete (*cred_handle)-&gt;phCredS;
 776         }
 777         delete *cred_handle;
 778         *cred_handle = GSS_C_NO_CREDENTIAL;
 779     }
 780     return GSS_S_COMPLETE;
 781 }
 782 
 783 __declspec(dllexport) OM_uint32
 784 gss_inquire_cred(OM_uint32 *minor_status,
 785                  gss_const_cred_id_t cred_handle,
 786                  gss_name_t *name,
 787                  OM_uint32 *lifetime,
 788                  gss_cred_usage_t *cred_usage,
 789                  gss_OID_set *mechanisms)
 790 {
 791     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_inquire_cred...&quot;);
 792     CHECK_CRED(cred_handle)
 793 
 794     CredHandle* cred = cred_handle-&gt;phCredK
 795             ? cred_handle-&gt;phCredK
 796             : cred_handle-&gt;phCredS;
 797     SECURITY_STATUS ss;
 798     if (name) {
 799         *name = GSS_C_NO_NAME;
 800         SecPkgCredentials_Names snames;
 801         ss = QueryCredentialsAttributes(cred, SECPKG_CRED_ATTR_NAMES, &amp;snames);
 802         if (!SEC_SUCCESS(ss)) {
 803             return GSS_S_FAILURE;
 804         }
 805         SEC_WCHAR* names = new SEC_WCHAR[lstrlen(snames.sUserName) + 1];
 806         if (names == NULL) {
 807             return GSS_S_FAILURE;
 808         }
 809         StringCchCopy(names, lstrlen(snames.sUserName) + 1, snames.sUserName);
 810         FreeContextBuffer(snames.sUserName);
 811         PP(&quot;Allocate new name at %p&quot;, names);
 812         gss_name_t name1 = new gss_name_struct;
 813         if (name1 == NULL) {
 814             delete[] names;
 815             return GSS_S_FAILURE;
 816         }
 817         name1-&gt;name = names;
 818         *name = (gss_name_t) name1;
 819     }
 820     if (lifetime) {
 821         *lifetime = cred_handle-&gt;time;
 822     }
 823     if (cred_usage) {
 824         *cred_usage = 1; // We only support INITIATE_ONLY now
 825     }
 826     if (mechanisms) {
 827         // Useless for Java
 828     }
 829     // Others inquiries not supported yet
 830     return GSS_S_COMPLETE;
 831 }
 832 
 833 __declspec(dllexport) OM_uint32
 834 gss_import_sec_context(OM_uint32 *minor_status,
 835                        gss_const_buffer_t interprocess_token,
 836                        gss_ctx_id_t *context_handle)
 837 {
 838     // Not transferable, return FAILURE
 839     PP(&quot;&gt;&gt;&gt;&gt; Calling UNIMPLEMENTED gss_import_sec_context...&quot;);
 840     *minor_status = 0;
 841     return GSS_S_FAILURE;
 842 }
 843 
 844 __declspec(dllexport) OM_uint32
 845 gss_init_sec_context(OM_uint32 *minor_status,
 846                      gss_const_cred_id_t initiator_cred_handle,
 847                      gss_ctx_id_t *context_handle,
 848                      gss_const_name_t target_name,
 849                      gss_const_OID mech_type,
 850                      OM_uint32 req_flags,
 851                      OM_uint32 time_req,
 852                      gss_const_channel_bindings_t input_chan_bindings,
 853                      gss_const_buffer_t input_token,
 854                      gss_OID *actual_mech_type,
 855                      gss_buffer_t output_token,
 856                      OM_uint32 *ret_flags,
 857                      OM_uint32 *time_rec)
 858 {
 859     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_init_sec_context...&quot;);
 860     CHECK_NAME(target_name)
 861     CHECK_OUTPUT(output_token)
 862 
 863     SECURITY_STATUS ss;
 864     TimeStamp lifeTime;
 865     SecBufferDesc inBuffDesc;
 866     SecBuffer inSecBuff;
 867     SecBufferDesc outBuffDesc;
 868     SecBuffer outSecBuff;
 869     BOOLEAN isSPNEGO = is_same_oid(mech_type, &amp;SPNEGO_OID);
 870     CredHandle* newCred = NULL;
 871 
 872     gss_ctx_id_t pc;
 873 
 874     output_token-&gt;length = 0;
 875     output_token-&gt;value = NULL;
 876 
 877     BOOLEAN firstTime = (*context_handle == GSS_C_NO_CONTEXT);
 878     PP(&quot;First time? %d&quot;, firstTime);
 879     if (firstTime) {
 880         pc = new_context(isSPNEGO);
 881         if (pc == NULL) {
 882             return GSS_S_FAILURE;
 883         }
 884         *context_handle = (gss_ctx_id_t) pc;
 885     } else {
 886         pc = *context_handle;
 887     }
 888 
 889     if (pc == NULL) {
 890         return GSS_S_NO_CONTEXT;
 891     }
 892 
 893     DWORD outFlag;
 894     TCHAR outName[100];
 895 
 896     OM_uint32 minor;
 897     gss_buffer_desc tn;
 898     gss_display_name(&amp;minor, target_name, &amp;tn, NULL);
 899     int len = MultiByteToWideChar(CP_UTF8, 0, (LPCCH)tn.value, (int)tn.length,
 900             outName, sizeof(outName) - 1);
 901     if (len == 0) {
 902         goto err;
 903     }
 904     outName[len] = 0;
 905 
 906     int flag = flag_gss_to_sspi(req_flags) | ISC_REQ_ALLOCATE_MEMORY;
 907 
 908     outBuffDesc.ulVersion = SECBUFFER_VERSION;
 909     outBuffDesc.cBuffers = 1;
 910     outBuffDesc.pBuffers = &amp;outSecBuff;
 911 
 912     outSecBuff.BufferType = SECBUFFER_TOKEN;
 913 
 914     if (!firstTime) {
 915         inBuffDesc.ulVersion = SECBUFFER_VERSION;
 916         inBuffDesc.cBuffers = 1;
 917         inBuffDesc.pBuffers = &amp;inSecBuff;
 918 
 919         inSecBuff.BufferType = SECBUFFER_TOKEN;
 920         inSecBuff.cbBuffer = (ULONG)input_token-&gt;length;
 921         inSecBuff.pvBuffer = input_token-&gt;value;
 922     } else if (!pc-&gt;phCred) {
 923         if (isSPNEGO &amp;&amp; initiator_cred_handle
 924                 &amp;&amp; initiator_cred_handle-&gt;phCredS) {
 925             PP(&quot;Find SPNEGO credentials&quot;);
 926             pc-&gt;phCred = initiator_cred_handle-&gt;phCredS;
 927             pc-&gt;isLocalCred = FALSE;
 928         } else if (!isSPNEGO &amp;&amp; initiator_cred_handle
 929                 &amp;&amp; initiator_cred_handle-&gt;phCredK) {
 930             PP(&quot;Find Kerberos credentials&quot;);
 931             pc-&gt;phCred = initiator_cred_handle-&gt;phCredK;
 932             pc-&gt;isLocalCred = FALSE;
 933         } else {
 934             PP(&quot;No credentials provided, acquire myself&quot;);
 935             newCred = new CredHandle;
 936             if (!newCred) {
 937                 goto err;
 938             }
 939             SEC_WINNT_AUTH_IDENTITY_EX auth;
 940             ZeroMemory(&amp;auth, sizeof(auth));
 941             auth.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
 942             auth.Length = sizeof(auth);
 943             auth.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
 944             auth.PackageList = (unsigned short*)L&quot;Kerberos&quot;;
 945             auth.PackageListLength = 8;
 946             ss = AcquireCredentialsHandle(
 947                     NULL,
 948                     isSPNEGO ? L&quot;Negotiate&quot; : L&quot;Kerberos&quot;,
 949                     SECPKG_CRED_OUTBOUND,
 950                     NULL,
 951                     isSPNEGO ? &amp;auth : NULL,
 952                     NULL,
 953                     NULL,
 954                     newCred,
 955                     &amp;lifeTime);
 956             if (!(SEC_SUCCESS(ss))) {
 957                 goto err;
 958             }
 959             pc-&gt;phCred = newCred;
 960             pc-&gt;isLocalCred = TRUE;
 961         }
 962     }
 963     ss = InitializeSecurityContext(
 964             pc-&gt;phCred,
 965             firstTime ? NULL : &amp;pc-&gt;hCtxt,
 966             outName,
 967             flag,
 968             0,
 969             SECURITY_NATIVE_DREP,
 970             firstTime ? NULL : &amp;inBuffDesc,
 971             0,
 972             &amp;pc-&gt;hCtxt,
 973             &amp;outBuffDesc,
 974             &amp;outFlag,
 975             &amp;lifeTime);
 976 
 977     if (!SEC_SUCCESS(ss)) {
 978         PP(&quot;InitializeSecurityContext failed&quot;);
 979         goto err;
 980     }
 981 
 982     pc-&gt;flags = *ret_flags = flag_sspi_to_gss(outFlag);
 983 
 984     // Ignore the result of the next call. Might fail before context established.
 985     QueryContextAttributes(
 986             &amp;pc-&gt;hCtxt, SECPKG_ATTR_SIZES, &amp;pc-&gt;SecPkgContextSizes);
 987     PP(&quot;cbMaxSignature: %ld. cbBlockSize: %ld. cbSecurityTrailer: %ld&quot;,
 988             pc-&gt;SecPkgContextSizes.cbMaxSignature,
 989             pc-&gt;SecPkgContextSizes.cbBlockSize,
 990             pc-&gt;SecPkgContextSizes.cbSecurityTrailer);
 991 
 992     output_token-&gt;length = outSecBuff.cbBuffer;
 993     if (outSecBuff.cbBuffer) {
 994         // No idea how user would free the data. Let&#39;s duplicate one.
 995         output_token-&gt;value = new char[outSecBuff.cbBuffer];
 996         if (!output_token-&gt;value) {
 997             FreeContextBuffer(outSecBuff.pvBuffer);
 998             goto err;
 999         }
1000         memcpy(output_token-&gt;value, outSecBuff.pvBuffer, outSecBuff.cbBuffer);
1001         FreeContextBuffer(outSecBuff.pvBuffer);
1002     }
1003 
1004     if (ss == SEC_I_CONTINUE_NEEDED) {
1005         return GSS_S_CONTINUE_NEEDED;
1006     } else {
1007         pc-&gt;established = true;
1008         ss = QueryContextAttributes(&amp;pc-&gt;hCtxt, SECPKG_ATTR_NATIVE_NAMES, &amp;pc-&gt;nnames);
1009         if (!SEC_SUCCESS(ss)) {
1010             goto err;
1011         }
1012         PP(&quot;Names. %ls %ls&quot;, pc-&gt;nnames.sClientName, pc-&gt;nnames.sServerName);
1013         *ret_flags |= GSS_C_PROT_READY_FLAG;
1014         return GSS_S_COMPLETE;
1015     }
1016 err:
1017     if (newCred) {
1018         delete newCred;
1019     }
1020     if (firstTime) {
1021         OM_uint32 dummy;
1022         gss_delete_sec_context(&amp;dummy, context_handle, GSS_C_NO_BUFFER);
1023     }
1024     if (output_token-&gt;value) {
1025         gss_release_buffer(NULL, output_token);
1026     }
1027     output_token = GSS_C_NO_BUFFER;
1028     return GSS_S_FAILURE;
1029 }
1030 
1031 __declspec(dllexport) OM_uint32
1032 gss_accept_sec_context(OM_uint32 *minor_status,
1033                        gss_ctx_id_t *context_handle,
1034                        gss_const_cred_id_t acceptor_cred_handle,
1035                        gss_const_buffer_t input_token,
1036                        gss_const_channel_bindings_t input_chan_bindings,
1037                        gss_name_t *src_name,
1038                        gss_OID *mech_type,
1039                        gss_buffer_t output_token,
1040                        OM_uint32 *ret_flags,
1041                        OM_uint32 *time_rec,
1042                        gss_cred_id_t *delegated_cred_handle)
1043 {
1044     PP(&quot;&gt;&gt;&gt;&gt; Calling UNIMPLEMENTED gss_accept_sec_context...&quot;);
1045     PP(&quot;gss_accept_sec_context is not supported in this initiator-only library&quot;);
1046     return GSS_S_FAILURE;
1047 }
1048 
1049 __declspec(dllexport) OM_uint32
1050 gss_inquire_context(OM_uint32 *minor_status,
1051                     gss_const_ctx_id_t context_handle,
1052                     gss_name_t *src_name,
1053                     gss_name_t *targ_name,
1054                     OM_uint32 *lifetime_rec,
1055                     gss_OID *mech_type,
1056                     OM_uint32 *ctx_flags,
1057                     int *locally_initiated,
1058                     int *open)
1059 {
1060     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_inquire_context...&quot;);
1061     CHECK_CONTEXT(context_handle)
1062 
1063     gss_name_t n1 = NULL;
1064     gss_name_t n2 = NULL;
1065     if (!context_handle-&gt;established) {
1066         return GSS_S_NO_CONTEXT;
1067     }
1068     if (src_name != NULL) {
1069         n1 = new gss_name_struct;
1070         if (n1 == NULL) {
1071             goto err;
1072         }
1073         n1-&gt;name = new SEC_WCHAR[lstrlen(context_handle-&gt;nnames.sClientName) + 1];
1074         if (n1-&gt;name == NULL) {
1075             goto err;
1076         }
1077         PP(&quot;Allocate new name at %p&quot;, n1-&gt;name);
1078         StringCchCopy(n1-&gt;name, lstrlen(context_handle-&gt;nnames.sClientName) + 1,
1079                 context_handle-&gt;nnames.sClientName);
1080         *src_name = (gss_name_t) n1;
1081     }
1082     if (targ_name != NULL) {
1083         n2 = new gss_name_struct;
1084         if (n2 == NULL) {
1085             goto err;
1086         }
1087         n2-&gt;name = new SEC_WCHAR[lstrlen(context_handle-&gt;nnames.sServerName) + 1];
1088         if (n2-&gt;name == NULL) {
1089             goto err;
1090         }
1091         PP(&quot;Allocate new name at %p&quot;, n2-&gt;name);
1092         StringCchCopy(n2-&gt;name, lstrlen(context_handle-&gt;nnames.sServerName) + 1,
1093                 context_handle-&gt;nnames.sServerName);
1094         *targ_name = (gss_name_t) n2;
1095     }
1096     if (lifetime_rec != NULL) {
1097         SecPkgContext_Lifespan ls;
1098         SECURITY_STATUS ss;
1099         ss = QueryContextAttributes(
1100                 (PCtxtHandle)&amp;context_handle-&gt;hCtxt,
1101                 SECPKG_ATTR_LIFESPAN,
1102                 &amp;ls);
1103         if (!SEC_SUCCESS(ss)) {
1104             goto err;
1105         }
1106         *lifetime_rec = seconds_until(0, &amp;ls.tsExpiry);
1107     }
1108     if (mech_type != NULL) {
1109         *mech_type = context_handle-&gt;isSPNEGO
1110                 ? &amp;SPNEGO_OID : &amp;KRB5_OID;
1111     }
1112     if (ctx_flags != NULL) {
1113         *ctx_flags = context_handle-&gt;flags;
1114     }
1115     if (locally_initiated != NULL) {
1116         // We are always initiator
1117         *locally_initiated = 1;
1118     }
1119     return GSS_S_COMPLETE;
1120 err:
1121     if (n1 != NULL) {
1122         if (n1-&gt;name != NULL) {
1123             delete[] n1-&gt;name;
1124         }
1125         delete n1;
1126         n1 = NULL;
1127     }
1128     if (n2 != NULL) {
1129         if (n2-&gt;name != NULL) {
1130             delete[] n2-&gt;name;
1131         }
1132         delete n2;
1133         n2 = NULL;
1134     }
1135     return GSS_S_FAILURE;
1136 }
1137 
1138 __declspec(dllexport) OM_uint32
1139 gss_delete_sec_context(OM_uint32 *minor_status,
1140                        gss_ctx_id_t *context_handle,
1141                        gss_buffer_t output_token)
1142 {
1143     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_delete_sec_context...&quot;);
1144     CHECK_CONTEXT(context_handle)
1145 
1146     DeleteSecurityContext(&amp;(*context_handle)-&gt;hCtxt);
1147     if ((*context_handle)-&gt;isLocalCred &amp;&amp; (*context_handle)-&gt;phCred != NULL) {
1148         FreeCredentialsHandle((*context_handle)-&gt;phCred);
1149         (*context_handle)-&gt;phCred = NULL;
1150     }
1151     if ((*context_handle)-&gt;nnames.sClientName != NULL) {
1152         FreeContextBuffer((*context_handle)-&gt;nnames.sClientName);
1153         (*context_handle)-&gt;nnames.sClientName = NULL;
1154     }
1155     if ((*context_handle)-&gt;nnames.sServerName != NULL) {
1156         FreeContextBuffer((*context_handle)-&gt;nnames.sServerName);
1157         (*context_handle)-&gt;nnames.sServerName = NULL;
1158     }
1159     delete (*context_handle);
1160     *context_handle = GSS_C_NO_CONTEXT;
1161     return GSS_S_COMPLETE;
1162 }
1163 
1164 __declspec(dllexport) OM_uint32
1165 gss_context_time(OM_uint32 *minor_status,
1166                  gss_const_ctx_id_t context_handle,
1167                  OM_uint32 *time_rec)
1168 {
1169     PP(&quot;&gt;&gt;&gt;&gt; Calling IMPLEMENTED gss_context_time...&quot;);
1170     CHECK_CONTEXT(context_handle)
1171     CHECK_OUTPUT(time_rec)
1172 
1173     SECURITY_STATUS ss;
1174     SecPkgContext_Lifespan ls;
1175     ss = QueryContextAttributes(
1176             (PCtxtHandle)&amp;context_handle-&gt;hCtxt,
1177             SECPKG_ATTR_LIFESPAN,
1178             &amp;ls);
1179     if (ss == SEC_E_OK) {
1180         *time_rec = seconds_until(0, &amp;ls.tsExpiry);
1181         show_time(&quot;context start&quot;, &amp;ls.tsStart);
1182         show_time(&quot;context expiry&quot;, &amp;ls.tsExpiry);
1183         return *time_rec == 0 ? GSS_S_CONTEXT_EXPIRED : GSS_S_COMPLETE;
1184     } else {
1185         return GSS_S_FAILURE;
1186     }
1187 }
1188 
1189 __declspec(dllexport) OM_uint32
1190 gss_wrap_size_limit(OM_uint32 *minor_status,
1191                     gss_const_ctx_id_t context_handle,
1192                     int conf_req_flag,
1193                     gss_qop_t qop_req,
1194                     OM_uint32 req_output_size,
1195                     OM_uint32 *max_input_size)
1196 {
1197     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_wrap_size_limit...&quot;);
1198     CHECK_CONTEXT(context_handle)
1199     CHECK_OUTPUT(max_input_size)
1200 
1201     *max_input_size = req_output_size
1202             - context_handle-&gt;SecPkgContextSizes.cbSecurityTrailer
1203             - context_handle-&gt;SecPkgContextSizes.cbBlockSize;
1204     return GSS_S_COMPLETE;
1205 }
1206 
1207 __declspec(dllexport) OM_uint32
1208 gss_export_sec_context(OM_uint32 *minor_status,
1209                        gss_ctx_id_t *context_handle,
1210                        gss_buffer_t interprocess_token)
1211 {
1212     PP(&quot;&gt;&gt;&gt;&gt; Calling UNIMPLEMENTED gss_export_sec_context...&quot;);
1213     return GSS_S_FAILURE;
1214 }
1215 
1216 __declspec(dllexport) OM_uint32
1217 gss_get_mic(OM_uint32 *minor_status,
1218             gss_const_ctx_id_t context_handle,
1219             gss_qop_t qop_req,
1220             gss_const_buffer_t message_buffer,
1221             gss_buffer_t msg_token)
1222 {
1223     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_get_mic...&quot;);
1224     CHECK_CONTEXT(context_handle)
1225     CHECK_BUFFER(message_buffer)
1226     CHECK_OUTPUT(msg_token)
1227 
1228     SECURITY_STATUS ss;
1229     SecBufferDesc buffDesc;
1230     SecBuffer secBuff[2];
1231 
1232     buffDesc.cBuffers = 2;
1233     buffDesc.pBuffers = secBuff;
1234     buffDesc.ulVersion = SECBUFFER_VERSION;
1235 
1236     secBuff[0].BufferType = SECBUFFER_DATA;
1237     secBuff[0].cbBuffer = (ULONG)message_buffer-&gt;length;
1238     secBuff[0].pvBuffer = message_buffer-&gt;value;
1239 
1240     secBuff[1].BufferType = SECBUFFER_TOKEN;
1241     secBuff[1].cbBuffer = context_handle-&gt;SecPkgContextSizes.cbMaxSignature;
1242     secBuff[1].pvBuffer = msg_token-&gt;value = new char[secBuff[1].cbBuffer];
1243 
1244     if (!secBuff[1].pvBuffer) {
1245         goto err;
1246     }
1247 
1248     ss = MakeSignature((PCtxtHandle)&amp;context_handle-&gt;hCtxt, 0, &amp;buffDesc, 0);
1249 
1250     if (!SEC_SUCCESS(ss)) {
1251         goto err;
1252     }
1253 
1254     msg_token-&gt;length = secBuff[1].cbBuffer;
1255     return GSS_S_COMPLETE;
1256 
1257 err:
1258     msg_token-&gt;length = 0;
1259     msg_token-&gt;value = NULL;
1260     if (secBuff[1].pvBuffer) {
1261         delete[] secBuff[1].pvBuffer;
1262     }
1263     return GSS_S_FAILURE;
1264 }
1265 
1266 __declspec(dllexport) OM_uint32
1267 gss_verify_mic(OM_uint32 *minor_status,
1268                gss_const_ctx_id_t context_handle,
1269                gss_const_buffer_t message_buffer,
1270                gss_const_buffer_t token_buffer,
1271                gss_qop_t *qop_state)
1272 {
1273     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_verify_mic...&quot;);
1274     CHECK_CONTEXT(context_handle)
1275     CHECK_BUFFER(message_buffer)
1276     CHECK_BUFFER(token_buffer)
1277 
1278     SECURITY_STATUS ss;
1279     SecBufferDesc buffDesc;
1280     SecBuffer secBuff[2];
1281     ULONG qop;
1282 
1283     buffDesc.ulVersion = SECBUFFER_VERSION;
1284     buffDesc.cBuffers = 2;
1285     buffDesc.pBuffers = secBuff;
1286 
1287     secBuff[0].BufferType = SECBUFFER_TOKEN;
1288     secBuff[0].cbBuffer = (ULONG)token_buffer-&gt;length;
1289     secBuff[0].pvBuffer = token_buffer-&gt;value;
1290 
1291     secBuff[1].BufferType = SECBUFFER_DATA;
1292     secBuff[1].cbBuffer = (ULONG)message_buffer-&gt;length;
1293     secBuff[1].pvBuffer = message_buffer-&gt;value;
1294 
1295     ss = VerifySignature((PCtxtHandle)&amp;context_handle-&gt;hCtxt, &amp;buffDesc, 0, &amp;qop);
1296     if (qop_state) {
1297         *qop_state = qop;
1298     }
1299 
1300     if (ss == SEC_E_OK) {
1301         return GSS_S_COMPLETE;
1302     } else if (ss == SEC_E_OUT_OF_SEQUENCE) {
1303         return GSS_S_UNSEQ_TOKEN;
1304     } else {
1305         return GSS_S_BAD_SIG;
1306     }
1307 }
1308 
1309 __declspec(dllexport) OM_uint32
1310 gss_wrap(OM_uint32 *minor_status,
1311          gss_const_ctx_id_t context_handle,
1312          int conf_req_flag,
1313          gss_qop_t qop_req,
1314          gss_const_buffer_t input_message_buffer,
1315          int *conf_state,
1316          gss_buffer_t output_message_buffer)
1317 {
1318     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_wrap...&quot;);
1319     CHECK_CONTEXT(context_handle)
1320     CHECK_BUFFER(input_message_buffer)
1321     CHECK_OUTPUT(output_message_buffer)
1322 
1323     SECURITY_STATUS ss;
1324     SecBufferDesc buffDesc;
1325     SecBuffer secBuff[3];
1326 
1327     buffDesc.ulVersion = SECBUFFER_VERSION;
1328     buffDesc.cBuffers = 3;
1329     buffDesc.pBuffers = secBuff;
1330 
1331     secBuff[0].BufferType = SECBUFFER_TOKEN;
1332     secBuff[0].cbBuffer = context_handle-&gt;SecPkgContextSizes.cbSecurityTrailer;
1333     output_message_buffer-&gt;value = secBuff[0].pvBuffer = malloc(
1334             context_handle-&gt;SecPkgContextSizes.cbSecurityTrailer
1335                     + input_message_buffer-&gt;length
1336                     + context_handle-&gt;SecPkgContextSizes.cbBlockSize);;
1337     if (!output_message_buffer-&gt;value) {
1338         goto err;
1339     }
1340 
1341     secBuff[1].BufferType = SECBUFFER_DATA;
1342     secBuff[1].cbBuffer = (ULONG)input_message_buffer-&gt;length;
1343     secBuff[1].pvBuffer = malloc(secBuff[1].cbBuffer);
1344     if (!secBuff[1].pvBuffer) {
1345         goto err;
1346     }
1347     memcpy_s(secBuff[1].pvBuffer, secBuff[1].cbBuffer,
1348             input_message_buffer-&gt;value, input_message_buffer-&gt;length);
1349 
1350     secBuff[2].BufferType = SECBUFFER_PADDING;
1351     secBuff[2].cbBuffer = context_handle-&gt;SecPkgContextSizes.cbBlockSize;
1352     secBuff[2].pvBuffer = malloc(secBuff[2].cbBuffer);
1353     if (!secBuff[2].pvBuffer) {
1354         goto err;
1355     }
1356 
1357     ss = EncryptMessage((PCtxtHandle)&amp;context_handle-&gt;hCtxt,
1358             conf_req_flag ? 0 : SECQOP_WRAP_NO_ENCRYPT,
1359             &amp;buffDesc, 0);
1360     if (conf_state) {
1361         *conf_state = conf_req_flag;
1362     }
1363 
1364     if (!SEC_SUCCESS(ss)) {
1365         goto err;
1366     }
1367 
1368     memcpy_s((PBYTE)secBuff[0].pvBuffer + secBuff[0].cbBuffer,
1369             input_message_buffer-&gt;length + context_handle-&gt;SecPkgContextSizes.cbBlockSize,
1370             secBuff[1].pvBuffer,
1371             secBuff[1].cbBuffer);
1372     memcpy_s((PBYTE)secBuff[0].pvBuffer + secBuff[0].cbBuffer + secBuff[1].cbBuffer,
1373             context_handle-&gt;SecPkgContextSizes.cbBlockSize,
1374             secBuff[2].pvBuffer,
1375             secBuff[2].cbBuffer);
1376 
1377     output_message_buffer-&gt;length = secBuff[0].cbBuffer + secBuff[1].cbBuffer
1378             + secBuff[2].cbBuffer;
1379     free(secBuff[1].pvBuffer);
1380     free(secBuff[2].pvBuffer);
1381 
1382     return GSS_S_COMPLETE;
1383 
1384 err:
1385     if (secBuff[0].pvBuffer) {
1386         free(secBuff[0].pvBuffer);
1387     }
1388     if (secBuff[1].pvBuffer) {
1389         free(secBuff[1].pvBuffer);
1390     }
1391     if (secBuff[2].pvBuffer) {
1392         free(secBuff[2].pvBuffer);
1393     }
1394     output_message_buffer-&gt;length = 0;
1395     output_message_buffer-&gt;value = NULL;
1396     return GSS_S_FAILURE;
1397 }
1398 
1399 __declspec(dllexport) OM_uint32
1400 gss_unwrap(OM_uint32 *minor_status,
1401            gss_const_ctx_id_t context_handle,
1402            gss_const_buffer_t input_message_buffer,
1403            gss_buffer_t output_message_buffer,
1404            int *conf_state,
1405            gss_qop_t *qop_state)
1406 {
1407     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_unwrap...&quot;);
1408     CHECK_CONTEXT(context_handle)
1409     CHECK_BUFFER(input_message_buffer)
1410     CHECK_OUTPUT(output_message_buffer)
1411 
1412     SECURITY_STATUS ss;
1413     SecBufferDesc buffDesc;
1414     SecBuffer secBuff[2];
1415     ULONG ulQop = 0;
1416 
1417     buffDesc.cBuffers = 2;
1418     buffDesc.pBuffers = secBuff;
1419     buffDesc.ulVersion = SECBUFFER_VERSION;
1420 
1421     secBuff[0].BufferType = SECBUFFER_STREAM;
1422     secBuff[0].cbBuffer = (ULONG)input_message_buffer-&gt;length;
1423     secBuff[0].pvBuffer = malloc(input_message_buffer-&gt;length);
1424 
1425     if (!secBuff[0].pvBuffer) {
1426         goto err;
1427     }
1428 
1429     memcpy_s(secBuff[0].pvBuffer, input_message_buffer-&gt;length,
1430             input_message_buffer-&gt;value, input_message_buffer-&gt;length);
1431 
1432     secBuff[1].BufferType = SECBUFFER_DATA;
1433     secBuff[1].cbBuffer = 0;
1434     secBuff[1].pvBuffer = NULL;
1435 
1436     ss = DecryptMessage((PCtxtHandle)&amp;context_handle-&gt;hCtxt, &amp;buffDesc, 0, &amp;ulQop);
1437     if (qop_state) {
1438         *qop_state = ulQop;
1439     }
1440     if (!SEC_SUCCESS(ss)) {
1441         goto err;
1442     }
1443 
1444     // Must allocate a new memory block so client can release it correctly
1445     output_message_buffer-&gt;length = secBuff[1].cbBuffer;
1446     output_message_buffer-&gt;value = new char[secBuff[1].cbBuffer];
1447 
1448     if (!output_message_buffer-&gt;value) {
1449         goto err;
1450     }
1451 
1452     memcpy_s(output_message_buffer-&gt;value, secBuff[1].cbBuffer,
1453             secBuff[1].pvBuffer, secBuff[1].cbBuffer);
1454     *conf_state = ulQop == SECQOP_WRAP_NO_ENCRYPT ? 0 : 1;
1455 
1456     free(secBuff[0].pvBuffer);
1457     return GSS_S_COMPLETE;
1458 
1459 err:
1460     if (secBuff[0].pvBuffer) {
1461         free(secBuff[0].pvBuffer);
1462     }
1463     output_message_buffer-&gt;length = 0;
1464     output_message_buffer-&gt;value = NULL;
1465     return GSS_S_FAILURE;
1466 }
1467 
1468 __declspec(dllexport) OM_uint32
1469 gss_indicate_mechs(OM_uint32 *minor_status,
1470                    gss_OID_set *mech_set)
1471 {
1472     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_indicate_mechs...&quot;);
1473     OM_uint32 major = GSS_S_COMPLETE;
1474 
1475     ULONG ccPackages;
1476     PSecPkgInfo packages;
1477     EnumerateSecurityPackages(&amp;ccPackages, &amp;packages);
1478     PP(&quot;EnumerateSecurityPackages returns %ld&quot;, ccPackages);
1479     for (unsigned int i = 0; i &lt; ccPackages; i++) {
1480         PP(&quot;#%d: %ls, %ls\n&quot;, i, packages[i].Name, packages[i].Comment);
1481     }
1482     FreeContextBuffer(packages);
1483 
1484     // Hardcode kerberos and SPNEGO support
1485     major = gss_create_empty_oid_set(minor_status, mech_set);
1486     if (major != GSS_S_COMPLETE) {
1487         goto done;
1488     }
1489 
1490     major = gss_add_oid_set_member(minor_status, &amp;KRB5_OID, mech_set);
1491     if (major != GSS_S_COMPLETE) {
1492         goto done;
1493     }
1494 
1495     major = gss_add_oid_set_member(minor_status, &amp;SPNEGO_OID, mech_set);
1496     if (major != GSS_S_COMPLETE) {
1497         goto done;
1498     }
1499 
1500 done:
1501 
1502     if (major != GSS_S_COMPLETE) {
1503         gss_release_oid_set(minor_status, mech_set);
1504     }
1505 
1506     return major;
1507 }
1508 
1509 __declspec(dllexport) OM_uint32
1510 gss_inquire_names_for_mech(OM_uint32 *minor_status,
1511                            gss_const_OID mechanism,
1512                            gss_OID_set *name_types)
1513 {
1514     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_inquire_names_for_mech...&quot;);
1515     CHECK_OID(mechanism)
1516 
1517     if (gss_create_empty_oid_set(minor_status, name_types)) {
1518         return GSS_S_FAILURE;
1519     }
1520     if (gss_add_oid_set_member(minor_status, &amp;USER_NAME_OID, name_types)) {
1521         goto err;
1522     }
1523     if (gss_add_oid_set_member(minor_status, &amp;HOST_SERVICE_NAME_OID, name_types)) {
1524         goto err;
1525     }
1526     if (!is_same_oid(mechanism, &amp;SPNEGO_OID)) {
1527         if (gss_add_oid_set_member(minor_status, &amp;EXPORT_NAME_OID, name_types)) {
1528             goto err;
1529         }
1530     }
1531     return GSS_S_COMPLETE;
1532 err:
1533     gss_release_oid_set(minor_status, name_types);
1534     return GSS_S_FAILURE;
1535 }
1536 
1537 __declspec(dllexport) OM_uint32
1538 gss_add_oid_set_member(OM_uint32 *minor_status,
1539                        gss_const_OID member_oid,
1540                        gss_OID_set *oid_set)
1541 {
1542     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_add_oid_set_member...&quot;);
1543     CHECK_OID(member_oid)
1544     CHECK_OUTPUT(oid_set)
1545 
1546 
1547     int count = (int)(*oid_set)-&gt;count;
1548     for (int i = 0; i &lt; count; i++) {
1549         if (is_same_oid(&amp;(*oid_set)-&gt;elements[i], member_oid)) {
1550             // already there
1551             return GSS_S_COMPLETE;
1552         }
1553     }
1554     gss_OID existing = (*oid_set)-&gt;elements;
1555     gss_OID newcopy = new gss_OID_desc[count + 1];
1556     if (newcopy == NULL) {
1557         return GSS_S_FAILURE;
1558     }
1559     if (existing) {
1560         memcpy_s(newcopy, (count + 1) * sizeof(gss_OID_desc),
1561                 existing, count * sizeof(gss_OID_desc));
1562     }
1563     newcopy[count].length = member_oid-&gt;length;
1564     newcopy[count].elements = new char[member_oid-&gt;length];
1565     if (newcopy[count].elements == NULL) {
1566         delete[] newcopy;
1567         return GSS_S_FAILURE;
1568     }
1569     memcpy_s(newcopy[count].elements, member_oid-&gt;length,
1570             member_oid-&gt;elements, member_oid-&gt;length);
1571     (*oid_set)-&gt;elements = newcopy;
1572     (*oid_set)-&gt;count++;
1573     if (existing) {
1574         delete[] existing;
1575     }
1576 
1577     return GSS_S_COMPLETE;
1578 }
1579 
1580 __declspec(dllexport) OM_uint32
1581 gss_display_status(OM_uint32 *minor_status,
1582                    OM_uint32 status_value,
1583                    int status_type,
1584                    gss_const_OID mech_type,
1585                    OM_uint32 *message_context,
1586                    gss_buffer_t status_string)
1587 {
1588     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_display_status...&quot;);
1589     TCHAR msg[256];
1590     int len = FormatMessage(
1591             FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
1592             0, status_value,
1593             MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
1594             msg, 256, 0);
1595     if (len &gt; 0) {
1596         status_string-&gt;value = new char[len + 20];
1597         if (!status_string-&gt;value) {
1598             status_string = GSS_C_NO_BUFFER;
1599             return GSS_S_FAILURE;
1600         }
1601         status_string-&gt;length = sprintf_s(
1602                 (LPSTR)status_string-&gt;value, len + 19,
1603                 &quot;(%lx) %ls&quot;, status_value, msg);
1604     } else {
1605         status_string-&gt;value = new char[33];
1606         if (!status_string-&gt;value) {
1607             status_string = GSS_C_NO_BUFFER;
1608             return GSS_S_FAILURE;
1609         }
1610         status_string-&gt;length = sprintf_s(
1611                 (LPSTR)status_string-&gt;value, 32,
1612                 &quot;status is %lx&quot;, status_value);
1613     }
1614     if (status_string-&gt;length &lt;= 0) {
1615         gss_release_buffer(NULL, status_string);
1616         status_string = GSS_C_NO_BUFFER;
1617         return GSS_S_FAILURE;
1618     } else {
1619         return GSS_S_COMPLETE;
1620     }
1621 }
1622 
1623 __declspec(dllexport) OM_uint32
1624 gss_create_empty_oid_set(OM_uint32 *minor_status,
1625                          gss_OID_set *oid_set)
1626 {
1627     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_create_empty_oid_set...&quot;);
1628     CHECK_OUTPUT(oid_set)
1629 
1630     if (*oid_set = new gss_OID_set_desc) {
1631         memset(*oid_set, 0, sizeof(gss_OID_set_desc));
1632         return GSS_S_COMPLETE;
1633     }
1634     return GSS_S_FAILURE;
1635 }
1636 
1637 __declspec(dllexport) OM_uint32
1638 gss_release_oid_set(OM_uint32 *minor_status,
1639                     gss_OID_set *set)
1640 {
1641     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_release_oid_set...&quot;);
1642     if (set == NULL || *set == GSS_C_NO_OID_SET) {
1643         return GSS_S_COMPLETE;
1644     }
1645     for (size_t i = 0; i &lt; (*set)-&gt;count; i++) {
1646         delete[] (*set)-&gt;elements[i].elements;
1647     }
1648     delete[] (*set)-&gt;elements;
1649     delete *set;
1650     *set = GSS_C_NO_OID_SET;
1651     return GSS_S_COMPLETE;
1652 }
1653 
1654 __declspec(dllexport) OM_uint32
1655 gss_release_buffer(OM_uint32 *minor_status,
1656                    gss_buffer_t buffer)
1657 {
1658     PP(&quot;&gt;&gt;&gt;&gt; Calling gss_release_buffer...&quot;);
1659     if (buffer == NULL || buffer == GSS_C_NO_BUFFER) {
1660         return GSS_S_COMPLETE;
1661     }
1662     if (buffer-&gt;value) {
1663         delete[] buffer-&gt;value;
1664         buffer-&gt;value = NULL;
1665     }
1666     buffer-&gt;length = 0;
1667     return GSS_S_COMPLETE;
1668 }
1669 
1670 /* End implemented section */
1671 
1672 #ifdef __cplusplus
1673 }
1674 #endif
    </pre>
  </body>
</html>
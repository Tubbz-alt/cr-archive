<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.security.jgss/share/classes/org/ietf/jgss/GSSContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package org.ietf.jgss;
  27 
  28 import java.io.InputStream;
  29 import java.io.OutputStream;
  30 
  31 /**
  32  * This interface encapsulates the GSS-API security context and provides
  33  * the security services that are available over the context.  Security
  34  * contexts are established between peers using locally acquired
  35  * credentials.  Multiple contexts may exist simultaneously between a pair
  36  * of peers, using the same or different set of credentials.  GSS-API
  37  * functions in a manner independent of the underlying transport protocol
  38  * and depends on its calling application to transport the tokens that are
  39  * generated by the security context between the peers.&lt;p&gt;
  40  *
  41  * If the caller instantiates the context using the default
  42  * &lt;code&gt;GSSManager&lt;/code&gt; instance, then the Kerberos v5 GSS-API mechanism
  43  * is guaranteed to be available for context establishment. This mechanism
  44  * is identified by the Oid &quot;1.2.840.113554.1.2.2&quot; and is defined in RFC
  45  * 1964.&lt;p&gt;
  46  *
  47  * Before the context establishment phase is initiated, the context
  48  * initiator may request specific characteristics desired of the
  49  * established context. Not all underlying mechanisms support all
  50  * characteristics that a caller might desire. After the context is
  51  * established, the caller can check the actual characteristics and services
  52  * offered by that context by means of various query methods. When using
  53  * the Kerberos v5 GSS-API mechanism offered by the default
  54  * &lt;code&gt;GSSManager&lt;/code&gt; instance, all optional services will be
  55  * available locally. They are mutual authentication, credential
  56  * delegation, confidentiality and integrity protection, and per-message
  57  * replay detection and sequencing. Note that in the GSS-API, message integrity
  58  * is a prerequisite for message confidentiality.&lt;p&gt;
  59  *
  60  * The context establishment occurs in a loop where the
  61  * initiator calls {@link #initSecContext(byte[], int, int) initSecContext}
  62  * and the acceptor calls {@link #acceptSecContext(byte[], int, int)
  63  * acceptSecContext} until the context is established. While in this loop
  64  * the &lt;code&gt;initSecContext&lt;/code&gt; and &lt;code&gt;acceptSecContext&lt;/code&gt;
  65  * methods produce tokens that the application sends over to the peer. The
  66  * peer passes any such token as input to its &lt;code&gt;acceptSecContext&lt;/code&gt;
  67  * or &lt;code&gt;initSecContext&lt;/code&gt; as the case may be.&lt;p&gt;
  68  *
  69  * During the context establishment phase, the {@link
  70  * #isProtReady() isProtReady} method may be called to determine if the
  71  * context can be used for the per-message operations of {@link
  72  * #wrap(byte[], int, int, MessageProp) wrap} and {@link #getMIC(byte[],
  73  * int, int, MessageProp) getMIC}.  This allows applications to use
  74  * per-message operations on contexts which aren&#39;t yet fully
  75  * established.&lt;p&gt;
  76  *
  77  * After the context has been established or the &lt;code&gt;isProtReady&lt;/code&gt;
  78  * method returns &lt;code&gt;true&lt;/code&gt;, the query routines can be invoked to
  79  * determine the actual characteristics and services of the established
  80  * context.  The application can also start using the per-message methods
  81  * of {@link #wrap(byte[], int, int, MessageProp) wrap} and
  82  * {@link #getMIC(byte[], int, int, MessageProp) getMIC} to obtain
  83  * cryptographic operations on application supplied data.&lt;p&gt;
  84  *
  85  * When the context is no longer needed, the application should call
  86  * {@link #dispose() dispose} to release any system resources the context
  87  * may be using.&lt;p&gt;
  88  *
  89  * A security context typically maintains sequencing and replay detection
  90  * information about the tokens it processes. Therefore, the sequence in
  91  * which any tokens are presented to this context for processing can be
  92  * important. Also note that none of the methods in this interface are
  93  * synchronized. Therefore, it is not advisable to share a
  94  * &lt;code&gt;GSSContext&lt;/code&gt; among several threads unless some application
  95  * level synchronization is in place.&lt;p&gt;
  96  *
  97  * Finally, different mechanism providers might place different security
  98  * restrictions on using GSS-API contexts. These will be documented by the
  99  * mechanism provider. The application will need to ensure that it has the
 100  * appropriate permissions if such checks are made in the mechanism layer.&lt;p&gt;
 101  *
 102  * The stream-based methods of {@code GSSContext} have been deprecated in
 103  * Java SE 11. These methods have also been removed from
 104  * &lt;a href=&quot;http://tools.ietf.org/html/rfc8353&quot;&gt;
 105  * RFC 8353: Generic Security Service API Version 2: Java Bindings Update&lt;/a&gt;
 106  * for the following reasons (see section 11): &quot;The overloaded methods of
 107  * GSSContext that use input and output streams as the means to convey
 108  * authentication and per-message GSS-API tokens as described in Section 5.15
 109  * of RFC 5653 are removed in this update as the wire protocol
 110  * should be defined by an application and not a library. It&#39;s also impossible
 111  * to implement these methods correctly when the token has no self-framing
 112  * (where the end cannot be determined), or the library has no knowledge of
 113  * the token format (for example, as a bridge talking to another GSS library)&quot;.
 114  * These methods include {@link #initSecContext(InputStream, OutputStream)},
 115  * {@link #acceptSecContext(InputStream, OutputStream)},
 116  * {@link #wrap(InputStream, OutputStream, MessageProp)},
 117  * {@link #unwrap(InputStream, OutputStream, MessageProp)},
 118  * {@link #getMIC(InputStream, OutputStream, MessageProp)},
 119  * and {@link #verifyMIC(InputStream, InputStream, MessageProp)}.&lt;p&gt;
 120  *
 121  * The example code presented below demonstrates the usage of the
 122  * &lt;code&gt;GSSContext&lt;/code&gt; interface for the initiating peer.  Different
 123  * operations on the &lt;code&gt;GSSContext&lt;/code&gt; object are presented,
 124  * including: object instantiation, setting of desired flags, context
 125  * establishment, query of actual context flags, per-message operations on
 126  * application data, and finally context deletion.
 127  *
 128  * &lt;pre&gt;
 129  *    // Create a context using default credentials
 130  *    // and the implementation specific default mechanism
<a name="1" id="anc1"></a><span class="line-modified"> 131  *    GSSManager manager = ...</span>
<span class="line-modified"> 132  *    GSSName targetName = ...</span>
 133  *    GSSContext context = manager.createContext(targetName, null, null,
 134  *                                           GSSContext.INDEFINITE_LIFETIME);
 135  *
 136  *    // set desired context options prior to context establishment
 137  *    context.requestConf(true);
 138  *    context.requestMutualAuth(true);
 139  *    context.requestReplayDet(true);
 140  *    context.requestSequenceDet(true);
 141  *
 142  *    // establish a context between peers
 143  *
<a name="2" id="anc2"></a><span class="line-modified"> 144  *    byte[] inToken = new byte[0];</span>
<span class="line-added"> 145  *    byte[] outToken;</span>
 146  *
 147  *    // Loop while there still is a token to be processed
 148  *
 149  *    while (!context.isEstablished()) {
 150  *
<a name="3" id="anc3"></a><span class="line-modified"> 151  *        outToken = context.initSecContext(inToken, 0, inToken.length);</span>

 152  *
 153  *        // send the output token if generated
<a name="4" id="anc4"></a><span class="line-modified"> 154  *        if (outToken != null) {</span>
 155  *            sendToken(outToken);
<a name="5" id="anc5"></a><span class="line-added"> 156  *        }</span>
 157  *
 158  *        if (!context.isEstablished()) {
 159  *            inToken = readToken();
<a name="6" id="anc6"></a><span class="line-added"> 160  *        }</span>
 161  *    }
 162  *
 163  *     // display context information
 164  *     System.out.println(&quot;Remaining lifetime in seconds = &quot;
 165  *                                          + context.getLifetime());
 166  *     System.out.println(&quot;Context mechanism = &quot; + context.getMech());
 167  *     System.out.println(&quot;Initiator = &quot; + context.getSrcName());
 168  *     System.out.println(&quot;Acceptor = &quot; + context.getTargName());
 169  *
<a name="7" id="anc7"></a><span class="line-modified"> 170  *     if (context.getConfState()) {</span>
<span class="line-modified"> 171  *         System.out.println(&quot;Confidentiality (i.e., privacy) is available&quot;);</span>
<span class="line-added"> 172  *     }</span>
 173  *
<a name="8" id="anc8"></a><span class="line-modified"> 174  *     if (context.getIntegState()) {</span>
<span class="line-modified"> 175  *         System.out.println(&quot;Integrity is available&quot;);</span>
<span class="line-added"> 176  *     }</span>
 177  *
 178  *     // perform wrap on an application supplied message, appMsg,
 179  *     // using QOP = 0, and requesting privacy service
<a name="9" id="anc9"></a><span class="line-modified"> 180  *     byte[] appMsg = ...</span>
 181  *
 182  *     MessageProp mProp = new MessageProp(0, true);
 183  *
<a name="10" id="anc10"></a><span class="line-modified"> 184  *     outToken = context.wrap(appMsg, 0, appMsg.length, mProp);</span>
 185  *
<a name="11" id="anc11"></a><span class="line-modified"> 186  *     sendToken(outToken);</span>
<span class="line-added"> 187  *</span>
<span class="line-added"> 188  *     // perform unwrap on an incoming application message, and check</span>
<span class="line-added"> 189  *     // its privacy state and supplementary information</span>
<span class="line-added"> 190  *     inToken = readToken();</span>
<span class="line-added"> 191  *</span>
<span class="line-added"> 192  *     mProp = new MessageProp(0, true);</span>
<span class="line-added"> 193  *</span>
<span class="line-added"> 194  *     appMsg = context.unwrap(inToken, 0, inToken.length, mProp);</span>
<span class="line-added"> 195  *</span>
<span class="line-added"> 196  *     System.out.println(&quot;Was it encrypted? &quot; + mProp.getPrivacy());</span>
<span class="line-added"> 197  *     System.out.println(&quot;Duplicate Token? &quot; + mProp.isDuplicateToken());</span>
<span class="line-added"> 198  *     System.out.println(&quot;Old Token? &quot; + mProp.isOldToken());</span>
<span class="line-added"> 199  *     System.out.println(&quot;Unsequenced Token? &quot; + mProp.isUnseqToken());</span>
<span class="line-added"> 200  *     System.out.println(&quot;Gap Token? &quot; + mProp.isGapToken());</span>
<span class="line-added"> 201  *</span>
<span class="line-added"> 202  *     // the application determines if the privacy state and supplementary</span>
<span class="line-added"> 203  *     // information are acceptable</span>
 204  *
 205  *     // release the local-end of the context
 206  *     context.dispose();
 207  *
 208  * &lt;/pre&gt;
 209  *
 210  * @author Mayank Upadhyay
 211  * @since 1.4
 212  */
 213 public interface GSSContext {
 214 
 215     /**
 216      * A lifetime constant representing the default context lifetime.  This
 217      * value is set to 0.
 218      */
 219     public static final int DEFAULT_LIFETIME = 0;
 220 
 221     /**
 222      * A lifetime constant representing indefinite context lifetime.
 223      * This value must is set to the maximum integer value in Java -
 224      * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.
 225      */
 226     public static final int INDEFINITE_LIFETIME = Integer.MAX_VALUE;
 227 
 228     /**
 229      * Called by the context initiator to start the context creation
 230      * phase and process any tokens generated
 231      * by the peer&#39;s &lt;code&gt;acceptSecContext&lt;/code&gt; method.
 232      * This method may return an output token which the application will need
 233      * to send to the peer for processing by its &lt;code&gt;acceptSecContext&lt;/code&gt;
 234      * method. The application can call {@link #isEstablished()
 235      * isEstablished} to determine if the context establishment phase is
 236      * complete on this side of the context.  A return value of
 237      * &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;isEstablished&lt;/code&gt; indicates that
 238      * more tokens are expected to be supplied to
 239      * &lt;code&gt;initSecContext&lt;/code&gt;.  Upon completion of the context
 240      * establishment, the available context options may be queried through
 241      * the get methods.&lt;p&gt;
 242      *
 243      * Note that it is possible that the &lt;code&gt;initSecContext&lt;/code&gt; method
 244      * return a token for the peer, and &lt;code&gt;isEstablished&lt;/code&gt; return
 245      * &lt;code&gt;true&lt;/code&gt; also. This indicates that the token needs to be sent
 246      * to the peer, but the local end of the context is now fully
 247      * established.&lt;p&gt;
 248      *
 249      * Some mechanism providers might require that the caller be granted
 250      * permission to initiate a security context. A failed permission check
 251      * might cause a {@link java.lang.SecurityException SecurityException}
 252      * to be thrown from this method.
 253      *
 254      * @return a byte[] containing the token to be sent to the
 255      * peer. &lt;code&gt;null&lt;/code&gt; indicates that no token is generated.
 256      * @param inputBuf token generated by the peer. This parameter is ignored
 257      * on the first call since no token has been received from the peer.
 258      * @param offset the offset within the inputBuf where the token begins.
 259      * @param len the length of the token.
 260      *
 261      * @throws GSSException containing the following
 262      * major error codes:
 263      *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},
 264      *   {@link GSSException#BAD_MIC GSSException.BAD_MIC},
 265      *   {@link GSSException#NO_CRED GSSException.NO_CRED},
 266      *   {@link GSSException#CREDENTIALS_EXPIRED
 267      *                                  GSSException.CREDENTIALS_EXPIRED},
 268      *   {@link GSSException#BAD_BINDINGS GSSException.BAD_BINDINGS},
 269      *   {@link GSSException#OLD_TOKEN GSSException.OLD_TOKEN},
 270      *   {@link GSSException#DUPLICATE_TOKEN GSSException.DUPLICATE_TOKEN},
 271      *   {@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},
 272      *   {@link GSSException#BAD_MECH GSSException.BAD_MECH},
 273      *   {@link GSSException#FAILURE GSSException.FAILURE}
 274      */
 275     public byte[] initSecContext(byte inputBuf[], int offset, int len)
 276         throws GSSException;
 277 
 278     /**
 279      * Called by the context initiator to start the context creation
 280      * phase and process any tokens generated
 281      * by the peer&#39;s &lt;code&gt;acceptSecContext&lt;/code&gt; method using
 282      * streams. This method may write an output token to the
 283      * &lt;code&gt;OutpuStream&lt;/code&gt;, which the application will
 284      * need to send to the peer for processing by its
 285      * &lt;code&gt;acceptSecContext&lt;/code&gt; call. Typically, the application would
 286      * ensure this by calling the  {@link java.io.OutputStream#flush() flush}
 287      * method on an &lt;code&gt;OutputStream&lt;/code&gt; that encapsulates the
 288      * connection between the two peers. The application can
 289      * determine if a token is written to the OutputStream from the return
 290      * value of this method. A return value of &lt;code&gt;0&lt;/code&gt; indicates that
 291      * no token was written. The application can call
 292      * {@link #isEstablished() isEstablished} to determine if the context
 293      * establishment phase is complete on this side of the context. A
 294      * return  value of &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;isEstablished&lt;/code&gt;
 295      * indicates that more tokens are expected to be supplied to
 296      * &lt;code&gt;initSecContext&lt;/code&gt;.
 297      * Upon completion of the context establishment, the available context
 298      * options may be queried through the get methods.&lt;p&gt;
 299      *
 300      * Note that it is possible that the &lt;code&gt;initSecContext&lt;/code&gt; method
 301      * return a token for the peer, and &lt;code&gt;isEstablished&lt;/code&gt; return
 302      * &lt;code&gt;true&lt;/code&gt; also. This indicates that the token needs to be sent
 303      * to the peer, but the local end of the context is now fully
 304      * established.&lt;p&gt;
 305      *
 306      * The GSS-API authentication tokens contain a definitive start and
 307      * end. This method will attempt to read one of these tokens per
 308      * invocation, and may block on the stream if only part of the token is
 309      * available.  In all other respects this method is equivalent to the
 310      * byte array based {@link #initSecContext(byte[], int, int)
 311      * initSecContext}.&lt;p&gt;
 312      *
 313      * Some mechanism providers might require that the caller be granted
 314      * permission to initiate a security context. A failed permission check
 315      * might cause a {@link java.lang.SecurityException SecurityException}
 316      * to be thrown from this method.&lt;p&gt;
 317      *
 318      * The following example code demonstrates how this method might be
 319      * used:
 320      * &lt;pre&gt;
 321      *     InputStream is ...
 322      *     OutputStream os ...
 323      *     GSSContext context ...
 324      *
 325      *     // Loop while there is still a token to be processed
 326      *
 327      *     while (!context.isEstablished()) {
 328      *
 329      *         context.initSecContext(is, os);
 330      *
 331      *         // send output token if generated
 332      *         os.flush();
 333      *     }
 334      * &lt;/pre&gt;
 335      *
 336      *
 337      * @return the number of bytes written to the OutputStream as part of the
 338      * token to be sent to the peer. A value of 0 indicates that no token
 339      * needs to be sent.
 340      * @param inStream an InputStream that contains the token generated by
 341      * the peer. This parameter is ignored on the first call since no token
 342      * has been or will be received from the peer at that point.
 343      * @param outStream an OutputStream where the output token will be
 344      * written. During the final stage of context establishment, there may be
 345      * no bytes written.
 346      *
 347      * @throws GSSException containing the following
 348      * major error codes:
 349      *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},
 350      *   {@link GSSException#BAD_MIC GSSException.BAD_MIC},
 351      *   {@link GSSException#NO_CRED GSSException.NO_CRED},
 352      *   {@link GSSException#CREDENTIALS_EXPIRED GSSException.CREDENTIALS_EXPIRED},
 353      *   {@link GSSException#BAD_BINDINGS GSSException.BAD_BINDINGS},
 354      *   {@link GSSException#OLD_TOKEN GSSException.OLD_TOKEN},
 355      *   {@link GSSException#DUPLICATE_TOKEN GSSException.DUPLICATE_TOKEN},
 356      *   {@link GSSException#BAD_NAMETYPE GSSException.BAD_NAMETYPE},
 357      *   {@link GSSException#BAD_MECH GSSException.BAD_MECH},
 358      *   {@link GSSException#FAILURE GSSException.FAILURE}
 359      * @deprecated The stream-based methods have been removed from RFC 8353.
 360      * Use {@link #initSecContext(byte[], int, int)} instead.
 361      */
 362     @Deprecated(since=&quot;11&quot;)
 363     public int initSecContext(InputStream inStream,
 364                               OutputStream outStream) throws GSSException;
 365 
 366     /**
 367      * Called by the context acceptor upon receiving a token from the
 368      * peer. This method may return an output token which the application
 369      * will need to send to the peer for further processing by its
 370      * &lt;code&gt;initSecContext&lt;/code&gt; call.&lt;p&gt;
 371      *
 372      * The application can call {@link #isEstablished() isEstablished} to
 373      * determine if the context establishment phase is complete for this
 374      * peer.  A return value of &lt;code&gt;false&lt;/code&gt; from
 375      * &lt;code&gt;isEstablished&lt;/code&gt; indicates that more tokens are expected to
 376      * be supplied to this method.    Upon completion of the context
 377      * establishment, the available context options may be queried through
 378      * the get methods.&lt;p&gt;
 379      *
 380      * Note that it is possible that &lt;code&gt;acceptSecContext&lt;/code&gt; return a
 381      * token for the peer, and &lt;code&gt;isEstablished&lt;/code&gt; return
 382      * &lt;code&gt;true&lt;/code&gt; also.  This indicates that the token needs to be
 383      * sent to the peer, but the local end of the context is now fully
 384      * established.&lt;p&gt;
 385      *
 386      * Some mechanism providers might require that the caller be granted
 387      * permission to accept a security context. A failed permission check
 388      * might cause a {@link java.lang.SecurityException SecurityException}
 389      * to be thrown from this method.&lt;p&gt;
 390      *
 391      * The following example code demonstrates how this method might be
 392      * used:
 393      * &lt;pre&gt;
 394      *     byte[] inToken;
 395      *     byte[] outToken;
 396      *     GSSContext context ...
 397      *
 398      *     // Loop while there is still a token to be processed
 399      *
 400      *     while (!context.isEstablished()) {
 401      *         inToken = readToken();
 402      *         outToken = context.acceptSecContext(inToken, 0,
 403      *                                             inToken.length);
 404      *         // send output token if generated
 405      *         if (outToken != null)
 406      *             sendToken(outToken);
 407      *     }
 408      * &lt;/pre&gt;
 409      *
 410      *
 411      * @return a byte[] containing the token to be sent to the
 412      * peer. &lt;code&gt;null&lt;/code&gt; indicates that no token is generated.
 413      * @param inToken token generated by the peer.
 414      * @param offset the offset within the inToken where the token begins.
 415      * @param len the length of the token.
 416      *
 417      * @throws GSSException containing the following
 418      * major error codes:
 419      *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},
 420      *   {@link GSSException#BAD_MIC GSSException.BAD_MIC},
 421      *   {@link GSSException#NO_CRED GSSException.NO_CRED},
 422      *   {@link GSSException#CREDENTIALS_EXPIRED
 423      *                               GSSException.CREDENTIALS_EXPIRED},
 424      *   {@link GSSException#BAD_BINDINGS GSSException.BAD_BINDINGS},
 425      *   {@link GSSException#OLD_TOKEN GSSException.OLD_TOKEN},
 426      *   {@link GSSException#DUPLICATE_TOKEN GSSException.DUPLICATE_TOKEN},
 427      *   {@link GSSException#BAD_MECH GSSException.BAD_MECH},
 428      *   {@link GSSException#FAILURE GSSException.FAILURE}
 429      */
 430     public byte[] acceptSecContext(byte inToken[], int offset, int len)
 431         throws GSSException;
 432 
 433     /**
 434      * Called by the context acceptor to process a token from the peer using
 435      * streams.   It may write an output token to the
 436      * &lt;code&gt;OutputStream&lt;/code&gt;, which the application
 437      * will need to send to the peer for processing by its
 438      * &lt;code&gt;initSecContext&lt;/code&gt; method.  Typically, the application would
 439      * ensure this by calling the  {@link java.io.OutputStream#flush() flush}
 440      * method on an &lt;code&gt;OutputStream&lt;/code&gt; that encapsulates the
 441      * connection between the two peers. The application can call
 442      * {@link #isEstablished() isEstablished} to determine if the context
 443      * establishment phase is complete on this side of the context. A
 444      * return  value of &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;isEstablished&lt;/code&gt;
 445      * indicates that more tokens are expected to be supplied to
 446      * &lt;code&gt;acceptSecContext&lt;/code&gt;.
 447      * Upon completion of the context establishment, the available context
 448      * options may be queried through the get methods.&lt;p&gt;
 449      *
 450      * Note that it is possible that &lt;code&gt;acceptSecContext&lt;/code&gt; return a
 451      * token for the peer, and &lt;code&gt;isEstablished&lt;/code&gt; return
 452      * &lt;code&gt;true&lt;/code&gt; also.  This indicates that the token needs to be
 453      * sent to the peer, but the local end of the context is now fully
 454      * established.&lt;p&gt;
 455      *
 456      * The GSS-API authentication tokens contain a definitive start and
 457      * end. This method will attempt to read one of these tokens per
 458      * invocation, and may block on the stream if only part of the token is
 459      * available. In all other respects this method is equivalent to the byte
 460      * array based {@link #acceptSecContext(byte[], int, int)
 461      * acceptSecContext}.&lt;p&gt;
 462      *
 463      * Some mechanism providers might require that the caller be granted
 464      * permission to accept a security context. A failed permission check
 465      * might cause a {@link java.lang.SecurityException SecurityException}
 466      * to be thrown from this method.&lt;p&gt;
 467      *
 468      * The following example code demonstrates how this method might be
 469      * used:
 470      * &lt;pre&gt;
 471      *     InputStream is ...
 472      *     OutputStream os ...
 473      *     GSSContext context ...
 474      *
 475      *     // Loop while there is still a token to be processed
 476      *
 477      *     while (!context.isEstablished()) {
 478      *
 479      *         context.acceptSecContext(is, os);
 480      *
 481      *         // send output token if generated
 482      *         os.flush();
 483      *     }
 484      * &lt;/pre&gt;
 485      *
 486      *
 487      * @param inStream an InputStream that contains the token generated by
 488      * the peer.
 489      * @param outStream an OutputStream where the output token will be
 490      * written. During the final stage of context establishment, there may be
 491      * no bytes written.
 492      *
 493      * @throws GSSException containing the following
 494      * major error codes:
 495      *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},
 496      *   {@link GSSException#BAD_MIC GSSException.BAD_MIC},
 497      *   {@link GSSException#NO_CRED GSSException.NO_CRED},
 498      *   {@link GSSException#CREDENTIALS_EXPIRED
 499      *                           GSSException.CREDENTIALS_EXPIRED},
 500      *   {@link GSSException#BAD_BINDINGS GSSException.BAD_BINDINGS},
 501      *   {@link GSSException#OLD_TOKEN GSSException.OLD_TOKEN},
 502      *   {@link GSSException#DUPLICATE_TOKEN GSSException.DUPLICATE_TOKEN},
 503      *   {@link GSSException#BAD_MECH GSSException.BAD_MECH},
 504      *   {@link GSSException#FAILURE GSSException.FAILURE}
 505      *
 506      * @deprecated The stream-based methods have been removed from RFC 8353.
 507      * Use {@link #acceptSecContext(byte[], int, int)} instead.
 508      */
 509     /* Missing return value in RFC. int should have been returned.
 510      * -----------------------------------------------------------
 511      *
 512      * The application can determine if a token is written to the
 513      * OutputStream from the return value of this method. A return value of
 514      * &lt;code&gt;0&lt;/code&gt; indicates that no token was written.
 515      *
 516      * @return &lt;strong&gt;the number of bytes written to the
 517      * OutputStream as part of the token to be sent to the peer. A value of
 518      * 0 indicates that no token  needs to be
 519      * sent.&lt;/strong&gt;
 520      */
 521     @Deprecated(since=&quot;11&quot;)
 522     public void acceptSecContext(InputStream inStream,
 523                                  OutputStream outStream) throws GSSException;
 524 
 525     /**
 526      * Used during context establishment to determine the state of the
 527      * context.
 528      *
 529      * @return &lt;code&gt;true&lt;/code&gt; if this is a fully established context on
 530      * the caller&#39;s side and no more tokens are needed from the peer.
 531      */
 532     public boolean isEstablished();
 533 
 534     /**
 535      * Releases any system resources and cryptographic information stored in
 536      * the context object and invalidates the context.
 537      *
 538      *
 539      * @throws GSSException containing the following
 540      * major error codes:
 541      *   {@link GSSException#FAILURE GSSException.FAILURE}
 542      */
 543     public void dispose() throws GSSException;
 544 
 545     /**
 546      * Used to determine limits on the size of the message
 547      * that can be passed to &lt;code&gt;wrap&lt;/code&gt;. Returns the maximum
 548      * message size that, if presented to the &lt;code&gt;wrap&lt;/code&gt; method with
 549      * the same &lt;code&gt;confReq&lt;/code&gt; and &lt;code&gt;qop&lt;/code&gt; parameters, will
 550      * result in an output token containing no more
 551      * than &lt;code&gt;maxTokenSize&lt;/code&gt; bytes.&lt;p&gt;
 552      *
 553      * This call is intended for use by applications that communicate over
 554      * protocols that impose a maximum message size.  It enables the
 555      * application to fragment messages prior to applying protection.&lt;p&gt;
 556      *
 557      * GSS-API implementations are recommended but not required to detect
 558      * invalid QOP values when &lt;code&gt;getWrapSizeLimit&lt;/code&gt; is called.
 559      * This routine guarantees only a maximum message size, not the
 560      * availability of specific QOP values for message protection.
 561      *
 562      * @param qop the level of protection wrap will be asked to provide.
 563      * @param confReq &lt;code&gt;true&lt;/code&gt; if wrap will be asked to provide
 564      * privacy, &lt;code&gt;false&lt;/code&gt;  otherwise.
 565      * @param maxTokenSize the desired maximum size of the token emitted by
 566      * wrap.
 567      * @return the maximum size of the input token for the given output
 568      * token size
 569      *
 570      * @throws GSSException containing the following
 571      * major error codes:
 572      *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},
 573      *   {@link GSSException#BAD_QOP GSSException.BAD_QOP},
 574      *   {@link GSSException#FAILURE GSSException.FAILURE}
 575      */
 576     public int getWrapSizeLimit(int qop, boolean confReq,
 577                                 int maxTokenSize) throws GSSException;
 578 
 579     /**
 580      * Applies per-message security services over the established security
 581      * context. The method will return a token with the
 582      * application supplied data and a cryptographic MIC over it.
 583      * The data may be encrypted if confidentiality (privacy) was
 584      * requested.&lt;p&gt;
 585      *
 586      * The MessageProp object is instantiated by the application and used
 587      * to specify a QOP value which selects cryptographic algorithms, and a
 588      * privacy service to optionally encrypt the message.  The underlying
 589      * mechanism that is used in the call may not be able to provide the
 590      * privacy service.  It sets the actual privacy service that it does
 591      * provide in this MessageProp object which the caller should then
 592      * query upon return.  If the mechanism is not able to provide the
 593      * requested QOP, it throws a GSSException with the BAD_QOP code.&lt;p&gt;
 594      *
 595      * Since some application-level protocols may wish to use tokens
 596      * emitted by wrap to provide &quot;secure framing&quot;, implementations should
 597      * support the wrapping of zero-length messages.&lt;p&gt;
 598      *
 599      * The application will be responsible for sending the token to the
 600      * peer.
 601      *
 602      * @param inBuf application data to be protected.
 603      * @param offset the offset within the inBuf where the data begins.
 604      * @param len the length of the data
 605      * @param msgProp instance of MessageProp that is used by the
 606      * application to set the desired QOP and privacy state. Set the
 607      * desired QOP to 0 to request the default QOP. Upon return from this
 608      * method, this object will contain the actual privacy state that
 609      * was applied to the message by the underlying mechanism.
 610      * @return a byte[] containing the token to be sent to the peer.
 611      *
 612      * @throws GSSException containing the following major error codes:
 613      *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},
 614      *   {@link GSSException#BAD_QOP GSSException.BAD_QOP},
 615      *   {@link GSSException#FAILURE GSSException.FAILURE}
 616      */
 617     public byte[] wrap(byte inBuf[], int offset, int len,
 618                        MessageProp msgProp) throws GSSException;
 619 
 620     /**
 621      * Applies per-message security services over the established security
 622      * context using streams. The method will return a
 623      * token with the application supplied data and a cryptographic MIC over it.
 624      * The data may be encrypted if confidentiality
 625      * (privacy) was requested. This method is equivalent to the byte array
 626      * based {@link #wrap(byte[], int, int, MessageProp) wrap} method.&lt;p&gt;
 627      *
 628      * The application will be responsible for sending the token to the
 629      * peer.  Typically, the application would
 630      * ensure this by calling the  {@link java.io.OutputStream#flush() flush}
 631      * method on an &lt;code&gt;OutputStream&lt;/code&gt; that encapsulates the
 632      * connection between the two peers.&lt;p&gt;
 633      *
 634      * The MessageProp object is instantiated by the application and used
 635      * to specify a QOP value which selects cryptographic algorithms, and a
 636      * privacy service to optionally encrypt the message.  The underlying
 637      * mechanism that is used in the call may not be able to provide the
 638      * privacy service.  It sets the actual privacy service that it does
 639      * provide in this MessageProp object which the caller should then
 640      * query upon return.  If the mechanism is not able to provide the
 641      * requested QOP, it throws a GSSException with the BAD_QOP code.&lt;p&gt;
 642      *
 643      * Since some application-level protocols may wish to use tokens
 644      * emitted by wrap to provide &quot;secure framing&quot;, implementations should
 645      * support the wrapping of zero-length messages.
 646      *
 647      * @param inStream an InputStream containing the application data to be
 648      * protected. All of the data that is available in
 649      * inStream is used.
 650      * @param outStream an OutputStream to write the protected message
 651      * to.
 652      * @param msgProp instance of MessageProp that is used by the
 653      * application to set the desired QOP and privacy state. Set the
 654      * desired QOP to 0 to request the default QOP. Upon return from this
 655      * method, this object will contain the actual privacy state that
 656      * was applied to the message by the underlying mechanism.
 657      *
 658      * @throws GSSException containing the following
 659      * major error codes:
 660      *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},
 661      *   {@link GSSException#BAD_QOP GSSException.BAD_QOP},
 662      *   {@link GSSException#FAILURE GSSException.FAILURE}
 663      *
 664      * @deprecated The stream-based methods have been removed from RFC 8353.
 665      * Use {@link #wrap(byte[], int, int, MessageProp)} instead.
 666      */
 667     @Deprecated(since=&quot;11&quot;)
 668     public void wrap(InputStream inStream, OutputStream outStream,
 669                      MessageProp msgProp) throws GSSException;
 670 
 671     /**
 672      * Used to process tokens generated by the &lt;code&gt;wrap&lt;/code&gt; method on
 673      * the other side of the context. The method will return the message
 674      * supplied by the peer application to its wrap call, while at the same
 675      * time verifying the embedded MIC for that message.&lt;p&gt;
 676      *
 677      * The MessageProp object is instantiated by the application and is
 678      * used by the underlying mechanism to return information to the caller
 679      * such as the QOP, whether confidentiality was applied to the message,
 680      * and other supplementary message state information.&lt;p&gt;
 681      *
 682      * Since some application-level protocols may wish to use tokens
 683      * emitted by wrap to provide &quot;secure framing&quot;, implementations should
 684      * support the wrapping and unwrapping of zero-length messages.
 685      *
 686      * @param inBuf a byte array containing the wrap token received from
 687      * peer.
 688      * @param offset the offset where the token begins.
 689      * @param len the length of the token
 690      * @param msgProp upon return from the method, this object will contain
 691      * the applied QOP, the privacy state of the message, and supplementary
 692      * information stating if the token was a duplicate, old, out of
 693      * sequence or arriving after a gap.
 694      * @return a byte[] containing the message unwrapped from the input
 695      * token.
 696      *
 697      * @throws GSSException containing the following
 698      * major error codes:
 699      *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},
 700      *   {@link GSSException#BAD_MIC GSSException.BAD_MIC},
 701      *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},
 702      *   {@link GSSException#FAILURE GSSException.FAILURE}
 703      */
 704     public byte [] unwrap(byte[] inBuf, int offset, int len,
 705                           MessageProp msgProp) throws GSSException;
 706 
 707     /**
 708      * Uses streams to process tokens generated by the &lt;code&gt;wrap&lt;/code&gt;
 709      * method on the other side of the context. The method will return the
 710      * message supplied by the peer application to its wrap call, while at
 711      * the same time verifying the embedded MIC for that message.&lt;p&gt;
 712      *
 713      * The MessageProp object is instantiated by the application and is
 714      * used by the underlying mechanism to return information to the caller
 715      * such as the QOP, whether confidentiality was applied to the message,
 716      * and other supplementary message state information.&lt;p&gt;
 717      *
 718      * Since some application-level protocols may wish to use tokens
 719      * emitted by wrap to provide &quot;secure framing&quot;, implementations should
 720      * support the wrapping and unwrapping of zero-length messages.&lt;p&gt;
 721      *
 722      * The format of the input token that this method
 723      * reads is defined in the specification for the underlying mechanism that
 724      * will be used. This method will attempt to read one of these tokens per
 725      * invocation. If the mechanism token contains a definitive start and
 726      * end this method may block on the &lt;code&gt;InputStream&lt;/code&gt; if only
 727      * part of the token is available. If the start and end of the token
 728      * are not definitive then the method will attempt to treat all
 729      * available bytes as part of the token.&lt;p&gt;
 730      *
 731      * Other than the possible blocking behavior described above, this
 732      * method is equivalent to the byte array based {@link #unwrap(byte[],
 733      * int, int, MessageProp) unwrap} method.
 734      *
 735      * @param inStream an InputStream that contains the wrap token generated
 736      * by the peer.
 737      * @param outStream an OutputStream to write the application message
 738      * to.
 739      * @param msgProp upon return from the method, this object will contain
 740      * the applied QOP, the privacy state of the message, and supplementary
 741      * information stating if the token was a duplicate, old, out of
 742      * sequence or arriving after a gap.
 743      *
 744      * @throws GSSException containing the following
 745      * major error codes:
 746      *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN},
 747      *   {@link GSSException#BAD_MIC GSSException.BAD_MIC},
 748      *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},
 749      *   {@link GSSException#FAILURE GSSException.FAILURE}
 750      *
 751      * @deprecated The stream-based methods have been removed from RFC 8353.
 752      * Use {@link #unwrap(byte[], int, int, MessageProp)} instead.
 753      */
 754     @Deprecated(since=&quot;11&quot;)
 755     public void unwrap(InputStream inStream, OutputStream outStream,
 756                        MessageProp msgProp) throws GSSException;
 757 
 758     /**
 759      * Returns a token containing a cryptographic Message Integrity Code
 760      * (MIC) for the supplied message,  for transfer to the peer
 761      * application.  Unlike wrap, which encapsulates the user message in the
 762      * returned token, only the message MIC is returned in the output
 763      * token.&lt;p&gt;
 764      *
 765      * Note that privacy can only be applied through the wrap call.&lt;p&gt;
 766      *
 767      * Since some application-level protocols may wish to use tokens emitted
 768      * by getMIC to provide &quot;secure framing&quot;, implementations should support
 769      * derivation of MICs from zero-length messages.
 770      *
 771      * @param inMsg the message to generate the MIC over.
 772      * @param offset offset within the inMsg where the message begins.
 773      * @param len the length of the message
 774      * @param msgProp an instance of &lt;code&gt;MessageProp&lt;/code&gt; that is used
 775      * by the application to set the desired QOP.  Set the desired QOP to
 776      * &lt;code&gt;0&lt;/code&gt; in &lt;code&gt;msgProp&lt;/code&gt; to request the default
 777      * QOP. Alternatively pass in &lt;code&gt;null&lt;/code&gt; for &lt;code&gt;msgProp&lt;/code&gt;
 778      * to request the default QOP.
 779      * @return a byte[] containing the token to be sent to the peer.
 780      *
 781      * @throws GSSException containing the following
 782      * major error codes:
 783      *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},
 784      *   {@link GSSException#BAD_QOP GSSException.BAD_QOP},
 785      *   {@link GSSException#FAILURE GSSException.FAILURE}
 786      */
 787     public byte[] getMIC(byte []inMsg, int offset, int len,
 788                          MessageProp msgProp) throws GSSException;
 789 
 790     /**
 791      * Uses streams to produce a token containing a cryptographic MIC for
 792      * the supplied message, for transfer to the peer application.
 793      * Unlike wrap, which encapsulates the user message in the returned
 794      * token, only the message MIC is produced in the output token. This
 795      * method is equivalent to the byte array based {@link #getMIC(byte[],
 796      * int, int, MessageProp) getMIC} method.
 797      *
 798      * Note that privacy can only be applied through the wrap call.&lt;p&gt;
 799      *
 800      * Since some application-level protocols may wish to use tokens emitted
 801      * by getMIC to provide &quot;secure framing&quot;, implementations should support
 802      * derivation of MICs from zero-length messages.
 803      *
 804      * @param inStream an InputStream containing the message to generate the
 805      * MIC over. All of the data that is available in
 806      * inStream is used.
 807      * @param outStream an OutputStream to write the output token to.
 808      * @param msgProp an instance of &lt;code&gt;MessageProp&lt;/code&gt; that is used
 809      * by the application to set the desired QOP.  Set the desired QOP to
 810      * &lt;code&gt;0&lt;/code&gt; in &lt;code&gt;msgProp&lt;/code&gt; to request the default
 811      * QOP. Alternatively pass in &lt;code&gt;null&lt;/code&gt; for &lt;code&gt;msgProp&lt;/code&gt;
 812      * to request the default QOP.
 813      *
 814      * @throws GSSException containing the following
 815      * major error codes:
 816      *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},
 817      *   {@link GSSException#BAD_QOP GSSException.BAD_QOP},
 818      *   {@link GSSException#FAILURE GSSException.FAILURE}
 819      *
 820      * @deprecated The stream-based methods have been removed from RFC 8353.
 821      * Use {@link #getMIC(byte[], int, int, MessageProp)} instead.
 822      */
 823     @Deprecated(since=&quot;11&quot;)
 824     public void getMIC(InputStream inStream, OutputStream outStream,
 825                        MessageProp msgProp) throws GSSException;
 826 
 827     /**
 828      * Verifies the cryptographic MIC, contained in the token parameter,
 829      * over the supplied message.&lt;p&gt;
 830      *
 831      * The MessageProp object is instantiated by the application and is used
 832      * by the underlying mechanism to return information to the caller such
 833      * as the QOP indicating the strength of protection that was applied to
 834      * the message and other supplementary message state information.&lt;p&gt;
 835      *
 836      * Since some application-level protocols may wish to use tokens emitted
 837      * by getMIC to provide &quot;secure framing&quot;, implementations should support
 838      * the calculation and verification of MICs over zero-length messages.
 839      *
 840      * @param inToken the token generated by peer&#39;s getMIC method.
 841      * @param tokOffset the offset within the inToken where the token
 842      * begins.
 843      * @param tokLen the length of the token.
 844      * @param inMsg the application message to verify the cryptographic MIC
 845      * over.
 846      * @param msgOffset the offset in inMsg where the message begins.
 847      * @param msgLen the length of the message.
 848      * @param msgProp upon return from the method, this object will contain
 849      * the applied QOP and supplementary information stating if the token
 850      * was a duplicate, old, out of sequence or arriving after a gap.
 851      *
 852      * @throws GSSException containing the following
 853      * major error codes:
 854      *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN}
 855      *   {@link GSSException#BAD_MIC GSSException.BAD_MIC}
 856      *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED}
 857      *   {@link GSSException#FAILURE GSSException.FAILURE}
 858      */
 859     public void verifyMIC(byte[] inToken, int tokOffset, int tokLen,
 860                           byte[] inMsg, int msgOffset, int msgLen,
 861                           MessageProp msgProp) throws GSSException;
 862 
 863     /**
 864      * Uses streams to verify the cryptographic MIC, contained in the token
 865      * parameter, over the supplied message.  This method is equivalent to
 866      * the byte array based {@link #verifyMIC(byte[], int, int, byte[], int,
 867      * int, MessageProp) verifyMIC} method.
 868      *
 869      * The MessageProp object is instantiated by the application and is used
 870      * by the underlying mechanism to return information to the caller such
 871      * as the QOP indicating the strength of protection that was applied to
 872      * the message and other supplementary message state information.&lt;p&gt;
 873      *
 874      * Since some application-level protocols may wish to use tokens emitted
 875      * by getMIC to provide &quot;secure framing&quot;, implementations should support
 876      * the calculation and verification of MICs over zero-length messages.&lt;p&gt;
 877      *
 878      * The format of the input token that this method
 879      * reads is defined in the specification for the underlying mechanism that
 880      * will be used. This method will attempt to read one of these tokens per
 881      * invocation. If the mechanism token contains a definitive start and
 882      * end this method may block on the &lt;code&gt;InputStream&lt;/code&gt; if only
 883      * part of the token is available. If the start and end of the token
 884      * are not definitive then the method will attempt to treat all
 885      * available bytes as part of the token.&lt;p&gt;
 886      *
 887      * Other than the possible blocking behavior described above, this
 888      * method is equivalent to the byte array based {@link #verifyMIC(byte[],
 889      * int, int, byte[], int, int, MessageProp) verifyMIC} method.
 890      *
 891      * @param tokStream an InputStream containing the token generated by the
 892      * peer&#39;s getMIC method.
 893      * @param msgStream an InputStream containing the application message to
 894      * verify the cryptographic MIC over. All of the data
 895      * that is available in msgStream is used.
 896      * @param msgProp upon return from the method, this object will contain
 897      * the applied QOP and supplementary information stating if the token
 898      * was a duplicate, old, out of sequence or arriving after a gap.
 899      *
 900      * @throws GSSException containing the following
 901      * major error codes:
 902      *   {@link GSSException#DEFECTIVE_TOKEN GSSException.DEFECTIVE_TOKEN}
 903      *   {@link GSSException#BAD_MIC GSSException.BAD_MIC}
 904      *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED}
 905      *   {@link GSSException#FAILURE GSSException.FAILURE}
 906      *
 907      * @deprecated The stream-based methods have been removed from RFC 8353.
 908      * Use {@link #verifyMIC(byte[], int, int, byte[], int, int, MessageProp)}
 909      * instead.
 910      */
 911     @Deprecated(since=&quot;11&quot;)
 912     public void verifyMIC(InputStream tokStream, InputStream msgStream,
 913                           MessageProp msgProp) throws GSSException;
 914 
 915     /**
 916      * Exports this context so that another process may
 917      * import it.. Provided to support the sharing of work between
 918      * multiple processes. This routine will typically be used by the
 919      * context-acceptor, in an application where a single process receives
 920      * incoming connection requests and accepts security contexts over
 921      * them, then passes the established context to one or more other
 922      * processes for message exchange.&lt;p&gt;
 923      *
 924      * This method deactivates the security context and creates an
 925      * interprocess token which, when passed to {@link
 926      * GSSManager#createContext(byte[]) GSSManager.createContext} in
 927      * another process, will re-activate the context in the second process.
 928      * Only a single instantiation of a given context may be active at any
 929      * one time; a subsequent attempt by a context exporter to access the
 930      * exported security context will fail.&lt;p&gt;
 931      *
 932      * The implementation may constrain the set of processes by which the
 933      * interprocess token may be imported, either as a function of local
 934      * security policy, or as a result of implementation decisions.  For
 935      * example, some implementations may constrain contexts to be passed
 936      * only between processes that run under the same account, or which are
 937      * part of the same process group.&lt;p&gt;
 938      *
 939      * The interprocess token may contain security-sensitive information
 940      * (for example cryptographic keys).  While mechanisms are encouraged
 941      * to either avoid placing such sensitive information within
 942      * interprocess tokens, or to encrypt the token before returning it to
 943      * the application, in a typical GSS-API implementation this may not be
 944      * possible.  Thus the application must take care to protect the
 945      * interprocess token, and ensure that any process to which the token
 946      * is transferred is trustworthy. &lt;p&gt;
 947      *
 948      * Implementations are not required to support the inter-process
 949      * transfer of security contexts.  Calling the {@link #isTransferable()
 950      * isTransferable} method will indicate if the context object is
 951      * transferable.&lt;p&gt;
 952      *
 953      * Calling this method on a context that
 954      * is not exportable will result in this exception being thrown with
 955      * the error code {@link GSSException#UNAVAILABLE
 956      * GSSException.UNAVAILABLE}.
 957      *
 958      * @return a byte[] containing the exported context
 959      * @see GSSManager#createContext(byte[])
 960      *
 961      * @throws GSSException containing the following
 962      * major error codes:
 963      *   {@link GSSException#UNAVAILABLE GSSException.UNAVAILABLE},
 964      *   {@link GSSException#CONTEXT_EXPIRED GSSException.CONTEXT_EXPIRED},
 965      *   {@link GSSException#NO_CONTEXT GSSException.NO_CONTEXT},
 966      *   {@link GSSException#FAILURE GSSException.FAILURE}
 967      */
 968     public byte [] export() throws GSSException;
 969 
 970     /**
 971      * Requests that mutual authentication be done during
 972      * context establishment. This request can only be made on the context
 973      * initiator&#39;s side and it has to be done prior to the first call to
 974      * &lt;code&gt;initSecContext&lt;/code&gt;.&lt;p&gt;
 975      *
 976      * Not all mechanisms support mutual authentication and some mechanisms
 977      * might require mutual authentication even if the application
 978      * doesn&#39;t. Therefore, the application should check to see if the
 979      * request was honored with the {@link #getMutualAuthState()
 980      * getMutualAuthState} method.
 981      *
 982      * @param state a boolean value indicating whether mutual
 983      * authentication should be used or not.
 984      * @see #getMutualAuthState()
 985      *
 986      * @throws GSSException containing the following
 987      * major error codes:
 988      *   {@link GSSException#FAILURE GSSException.FAILURE}
 989      */
 990     public void requestMutualAuth(boolean state) throws GSSException;
 991 
 992     /**
 993      * Requests that replay detection be enabled for the
 994      * per-message security services after context establishment. This
 995      * request can only be made on the context initiator&#39;s side and it has
 996      * to be done prior to the first call to
 997      * &lt;code&gt;initSecContext&lt;/code&gt;. During context establishment replay
 998      * detection is not an option and is a function of the underlying
 999      * mechanism&#39;s capabilities.&lt;p&gt;
1000      *
1001      * Not all mechanisms support replay detection and some mechanisms
1002      * might require replay detection even if the application
1003      * doesn&#39;t. Therefore, the application should check to see if the
1004      * request was honored with the {@link #getReplayDetState()
1005      * getReplayDetState} method. If replay detection is enabled then the
1006      * {@link MessageProp#isDuplicateToken() MessageProp.isDuplicateToken} and {@link
1007      * MessageProp#isOldToken() MessageProp.isOldToken} methods will return
1008      * valid results for the &lt;code&gt;MessageProp&lt;/code&gt; object that is passed
1009      * in to the &lt;code&gt;unwrap&lt;/code&gt; method or the &lt;code&gt;verifyMIC&lt;/code&gt;
1010      * method.
1011      *
1012      * @param state a boolean value indicating whether replay detection
1013      * should be enabled over the established context or not.
1014      * @see #getReplayDetState()
1015      *
1016      * @throws GSSException containing the following
1017      * major error codes:
1018      *   {@link GSSException#FAILURE GSSException.FAILURE}
1019      */
1020     public void requestReplayDet(boolean state) throws GSSException;
1021 
1022     /**
1023      * Requests that sequence checking be enabled for the
1024      * per-message security services after context establishment. This
1025      * request can only be made on the context initiator&#39;s side and it has
1026      * to be done prior to the first call to
1027      * &lt;code&gt;initSecContext&lt;/code&gt;. During context establishment sequence
1028      * checking is not an option and is a function of the underlying
1029      * mechanism&#39;s capabilities.&lt;p&gt;
1030      *
1031      * Not all mechanisms support sequence checking and some mechanisms
1032      * might require sequence checking even if the application
1033      * doesn&#39;t. Therefore, the application should check to see if the
1034      * request was honored with the {@link #getSequenceDetState()
1035      * getSequenceDetState} method. If sequence checking is enabled then the
1036      * {@link MessageProp#isDuplicateToken() MessageProp.isDuplicateToken},
1037      * {@link MessageProp#isOldToken() MessageProp.isOldToken},
1038      * {@link MessageProp#isUnseqToken() MessageProp.isUnseqToken}, and
1039      * {@link MessageProp#isGapToken() MessageProp.isGapToken} methods will return
1040      * valid results for the &lt;code&gt;MessageProp&lt;/code&gt; object that is passed
1041      * in to the &lt;code&gt;unwrap&lt;/code&gt; method or the &lt;code&gt;verifyMIC&lt;/code&gt;
1042      * method.
1043      *
1044      * @param state a boolean value indicating whether sequence checking
1045      * should be enabled over the established context or not.
1046      * @see #getSequenceDetState()
1047      *
1048      * @throws GSSException containing the following
1049      * major error codes:
1050      *   {@link GSSException#FAILURE GSSException.FAILURE}
1051      */
1052     public void requestSequenceDet(boolean state) throws GSSException;
1053 
1054     /**
1055      * Requests that the initiator&#39;s credentials be
1056      * delegated to the acceptor during context establishment. This
1057      * request can only be made on the context initiator&#39;s side and it has
1058      * to be done prior to the first call to
1059      * &lt;code&gt;initSecContext&lt;/code&gt;.
1060      *
1061      * Not all mechanisms support credential delegation. Therefore, an
1062      * application that desires delegation should check to see if the
1063      * request was honored with the {@link #getCredDelegState()
1064      * getCredDelegState} method. If the application indicates that
1065      * delegation must not be used, then the mechanism will honor the
1066      * request and delegation will not occur. This is an exception
1067      * to the general rule that a mechanism may enable a service even if it
1068      * is not requested.
1069      *
1070      * @param state a boolean value indicating whether the credentials
1071      * should be delegated or not.
1072      * @see #getCredDelegState()
1073      *
1074      * @throws GSSException containing the following
1075      * major error codes:
1076      *   {@link GSSException#FAILURE GSSException.FAILURE}
1077      */
1078     public void requestCredDeleg(boolean state) throws GSSException;
1079 
1080     /**
1081      * Requests that the initiator&#39;s identity not be
1082      * disclosed to the acceptor. This request can only be made on the
1083      * context initiator&#39;s side and it has to be done prior to the first
1084      * call to &lt;code&gt;initSecContext&lt;/code&gt;.
1085      *
1086      * Not all mechanisms support anonymity for the initiator. Therefore, the
1087      * application should check to see if the request was honored with the
1088      * {@link #getAnonymityState() getAnonymityState} method.
1089      *
1090      * @param state a boolean value indicating if the initiator should
1091      * be authenticated to the acceptor as an anonymous principal.
1092      * @see #getAnonymityState
1093      *
1094      * @throws GSSException containing the following
1095      * major error codes:
1096      *   {@link GSSException#FAILURE GSSException.FAILURE}
1097      */
1098     public void requestAnonymity(boolean state) throws GSSException;
1099 
1100     /**
1101      * Requests that data confidentiality be enabled
1102      * for the &lt;code&gt;wrap&lt;/code&gt; method. This request can only be made on
1103      * the context initiator&#39;s side and it has to be done prior to the
1104      * first call to &lt;code&gt;initSecContext&lt;/code&gt;.
1105      *
1106      * Not all mechanisms support confidentiality and other mechanisms
1107      * might enable it even if the application doesn&#39;t request
1108      * it. The application may check to see if the request was honored with
1109      * the {@link #getConfState() getConfState} method. If confidentiality
1110      * is enabled, only then will the mechanism honor a request for privacy
1111      * in the {@link MessageProp#MessageProp(int, boolean) MessageProp}
1112      * object that is passed in to the &lt;code&gt;wrap&lt;/code&gt; method.&lt;p&gt;
1113      *
1114      * Enabling confidentiality will also automatically enable
1115      * integrity.
1116      *
1117      * @param state a boolean value indicating whether confidentiality
1118      * should be enabled or not.
1119      * @see #getConfState()
1120      * @see #getIntegState()
1121      * @see #requestInteg(boolean)
1122      * @see MessageProp
1123      *
1124      * @throws GSSException containing the following
1125      * major error codes:
1126      *   {@link GSSException#FAILURE GSSException.FAILURE}
1127      */
1128     public void requestConf(boolean state) throws GSSException;
1129 
1130     /**
1131      * Requests that data integrity be enabled
1132      * for the &lt;code&gt;wrap&lt;/code&gt; and &lt;code&gt;getMIC&lt;/code&gt;methods. This
1133      * request can only be made on the context initiator&#39;s side and it has
1134      * to be done prior to the first call to &lt;code&gt;initSecContext&lt;/code&gt;.
1135      *
1136      * Not all mechanisms support integrity and other mechanisms
1137      * might enable it even if the application doesn&#39;t request
1138      * it. The application may check to see if the request was honored with
1139      * the {@link #getIntegState() getIntegState} method.&lt;p&gt;
1140      *
1141      * Disabling integrity will also automatically disable
1142      * confidentiality.
1143      *
1144      * @param state a boolean value indicating whether integrity
1145      * should be enabled or not.
1146      * @see #getIntegState()
1147      *
1148      * @throws GSSException containing the following
1149      * major error codes:
1150      *   {@link GSSException#FAILURE GSSException.FAILURE}
1151      */
1152     public void requestInteg(boolean state) throws GSSException;
1153 
1154     /**
1155      * Requests a lifetime in seconds for the
1156      * context. This method can only be called on the context initiator&#39;s
1157      * side  and it has to be done prior to the first call to
1158      * &lt;code&gt;initSecContext&lt;/code&gt;.&lt;p&gt;
1159      *
1160      * The actual lifetime of the context will depend on the capabilities of
1161      * the underlying mechanism and the application should call the {@link
1162      * #getLifetime() getLifetime} method to determine this.
1163      *
1164      * @param lifetime the desired context lifetime in seconds. Use
1165      * &lt;code&gt;INDEFINITE_LIFETIME&lt;/code&gt; to request an indefinite lifetime
1166      * and &lt;code&gt;DEFAULT_LIFETIME&lt;/code&gt; to request a default lifetime.
1167      * @see #getLifetime()
1168      *
1169      * @throws GSSException containing the following
1170      * major error codes:
1171      *   {@link GSSException#FAILURE GSSException.FAILURE}
1172      */
1173     public void requestLifetime(int lifetime) throws GSSException;
1174 
1175     /**
1176      * Sets the channel bindings to be used during context
1177      * establishment. This method can be called on both
1178      * the context initiator&#39;s and the context acceptor&#39;s side, but it must
1179      * be called before context establishment begins. This means that an
1180      * initiator must call it before the first call to
1181      * &lt;code&gt;initSecContext&lt;/code&gt; and the acceptor must call it before the
1182      * first call to &lt;code&gt;acceptSecContext&lt;/code&gt;.
1183      *
1184      * @param cb the channel bindings to use.
1185      *
1186      * @throws GSSException containing the following
1187      * major error codes:
1188      *   {@link GSSException#FAILURE GSSException.FAILURE}
1189      */
1190     public void setChannelBinding(ChannelBinding cb) throws GSSException;
1191 
1192     /**
1193      * Determines if credential delegation is enabled on
1194      * this context. It can be called by both the context initiator and the
1195      * context acceptor. For a definitive answer this method must be
1196      * called only after context establishment is complete. Note that if an
1197      * initiator requests that delegation not be allowed the {@link
1198      * #requestCredDeleg(boolean) requestCredDeleg} method will honor that
1199      * request and this method will return &lt;code&gt;false&lt;/code&gt; on the
1200      * initiator&#39;s side from that point onwards.
1201      *
1202      * @return true if delegation is enabled, false otherwise.
1203      * @see #requestCredDeleg(boolean)
1204      */
1205     public boolean getCredDelegState();
1206 
1207     /**
1208      * Determines if mutual authentication is enabled on
1209      * this context. It can be called by both the context initiator and the
1210      * context acceptor. For a definitive answer this method must be
1211      * called only after context establishment is complete. An initiator
1212      * that requests mutual authentication can call this method after
1213      * context completion and dispose the context if its request was not
1214      * honored.
1215      *
1216      * @return true if mutual authentication is enabled, false otherwise.
1217      * @see #requestMutualAuth(boolean)
1218      */
1219     public boolean getMutualAuthState();
1220 
1221     /**
1222      * Determines if replay detection is enabled for the
1223      * per-message security services from this context. It can be called by
1224      * both the context initiator and the context acceptor. For a
1225      * definitive answer this method must be called only after context
1226      * establishment is complete. An initiator that requests replay
1227      * detection can call this method after context completion and
1228      * dispose the context if its request was not honored.
1229      *
1230      * @return true if replay detection is enabled, false otherwise.
1231      * @see #requestReplayDet(boolean)
1232      */
1233     public boolean getReplayDetState();
1234 
1235     /**
1236      * Determines if sequence checking is enabled for the
1237      * per-message security services from this context. It can be called by
1238      * both the context initiator and the context acceptor. For a
1239      * definitive answer this method must be called only after context
1240      * establishment is complete. An initiator that requests sequence
1241      * checking can call this method after context completion and
1242      * dispose the context if its request was not honored.
1243      *
1244      * @return true if sequence checking is enabled, false otherwise.
1245      * @see #requestSequenceDet(boolean)
1246      */
1247     public boolean getSequenceDetState();
1248 
1249     /**
1250      * Determines if the context initiator is
1251      * anonymously authenticated to the context acceptor. It can be called by
1252      * both the context initiator and the context acceptor, and at any
1253      * time. &lt;strong&gt;On the initiator side, a call to this method determines
1254      * if the identity of the initiator has been disclosed in any of the
1255      * context establishment tokens that might have been generated thus far
1256      * by &lt;code&gt;initSecContext&lt;/code&gt;. An initiator that absolutely must be
1257      * authenticated anonymously should call this method after each call to
1258      * &lt;code&gt;initSecContext&lt;/code&gt; to determine if the generated token
1259      * should be sent to the peer or the context aborted.&lt;/strong&gt; On the
1260      * acceptor side, a call to this method determines if any of the tokens
1261      * processed by &lt;code&gt;acceptSecContext&lt;/code&gt; thus far have divulged
1262      * the identity of the initiator.
1263      *
1264      * @return true if the context initiator is still anonymous, false
1265      * otherwise.
1266      * @see #requestAnonymity(boolean)
1267      */
1268     public boolean getAnonymityState();
1269 
1270     /**
1271      * Determines if the context is transferable to other processes
1272      * through the use of the {@link #export() export} method.  This call
1273      * is only valid on fully established contexts.
1274      *
1275      * @return true if this context can be exported, false otherwise.
1276      *
1277      * @throws GSSException containing the following
1278      * major error codes:
1279      *   {@link GSSException#FAILURE GSSException.FAILURE}
1280      */
1281     public boolean isTransferable() throws GSSException;
1282 
1283     /**
1284      * Determines if the context is ready for per message operations to be
1285      * used over it.  Some mechanisms may allow the usage of the
1286      * per-message operations before the context is fully established.
1287      *
1288      * @return true if methods like &lt;code&gt;wrap&lt;/code&gt;, &lt;code&gt;unwrap&lt;/code&gt;,
1289      * &lt;code&gt;getMIC&lt;/code&gt;, and &lt;code&gt;verifyMIC&lt;/code&gt; can be used with
1290      * this context at the current stage of context establishment, false
1291      * otherwise.
1292      */
1293     public boolean isProtReady();
1294 
1295     /**
1296      * Determines if data confidentiality is available
1297      * over the context. This method can be called by both the context
1298      * initiator and the context acceptor, but only after one of {@link
1299      * #isProtReady() isProtReady} or {@link #isEstablished()
1300      * isEstablished} return &lt;code&gt;true&lt;/code&gt;. If this method returns
1301      * &lt;code&gt;true&lt;/code&gt;, so will {@link #getIntegState()
1302      * getIntegState}
1303      *
1304      * @return true if confidentiality services are available, false
1305      * otherwise.
1306      * @see #requestConf(boolean)
1307      */
1308     public boolean getConfState();
1309 
1310     /**
1311      * Determines if data integrity is available
1312      * over the context. This method can be called by both the context
1313      * initiator and the context acceptor, but only after one of {@link
1314      * #isProtReady() isProtReady} or {@link #isEstablished()
1315      * isEstablished} return &lt;code&gt;true&lt;/code&gt;. This method will always
1316      * return &lt;code&gt;true&lt;/code&gt; if {@link #getConfState() getConfState}
1317      * returns true.
1318      *
1319      * @return true if integrity services are available, false otherwise.
1320      * @see #requestInteg(boolean)
1321      */
1322     public boolean getIntegState();
1323 
1324     /**
1325      * Determines what the remaining lifetime for this
1326      * context is. It can be called by both the context initiator and the
1327      * context acceptor, but for a definitive answer it should be called
1328      * only after {@link #isEstablished() isEstablished} returns
1329      * true.
1330      *
1331      * @return the remaining lifetime in seconds
1332      * @see #requestLifetime(int)
1333      */
1334     public int getLifetime();
1335 
1336     /**
1337      * Returns the name of the context initiator. This call is valid only
1338      * after one of {@link #isProtReady() isProtReady} or {@link
1339      * #isEstablished() isEstablished} return &lt;code&gt;true&lt;/code&gt;.
1340      *
1341      * @return a GSSName that is an MN containing the name of the context
1342      * initiator.
1343      * @see GSSName
1344      *
1345      * @throws GSSException containing the following
1346      * major error codes:
1347      *   {@link GSSException#FAILURE GSSException.FAILURE}
1348      */
1349     public GSSName getSrcName() throws GSSException;
1350 
1351     /**
1352      * Returns the name of the context acceptor. This call is valid only
1353      * after one of {@link #isProtReady() isProtReady} or {@link
1354      * #isEstablished() isEstablished} return &lt;code&gt;true&lt;/code&gt;.
1355      *
1356      * @return a GSSName that is an MN containing the name of the context
1357      * acceptor.
1358      *
1359      * @throws GSSException containing the following
1360      * major error codes:
1361      *   {@link GSSException#FAILURE GSSException.FAILURE}
1362      */
1363     public GSSName getTargName() throws GSSException;
1364 
1365     /**
1366      * Determines what mechanism is being used for this
1367      * context. This method may be called before the context is fully
1368      * established, but the mechanism returned may change on successive
1369      * calls in the negotiated mechanism case.
1370      *
1371      * @return the Oid of the mechanism being used
1372      *
1373      * @throws GSSException containing the following
1374      * major error codes:
1375      *   {@link GSSException#FAILURE GSSException.FAILURE}
1376      */
1377     public Oid getMech() throws GSSException;
1378 
1379     /**
1380      * Obtains the credentials delegated by the context
1381      * initiator to the context acceptor. It should be called only on the
1382      * context acceptor&#39;s side, and once the context is fully
1383      * established. The caller can use the method {@link
1384      * #getCredDelegState() getCredDelegState} to determine if there are
1385      * any delegated credentials.
1386      *
1387      * @return a GSSCredential containing the initiator&#39;s delegated
1388      * credentials, or &lt;code&gt;null&lt;/code&gt; is no credentials
1389      * were delegated.
1390      *
1391      * @throws GSSException containing the following
1392      * major error codes:
1393      *   {@link GSSException#FAILURE GSSException.FAILURE}
1394      */
1395     public GSSCredential getDelegCred() throws GSSException;
1396 
1397     /**
1398      * Determines if this is the context initiator. This
1399      * can be called on both the context initiator&#39;s and context acceptor&#39;s
1400      * side.
1401      *
1402      * @return true if this is the context initiator, false if it is the
1403      * context acceptor.
1404      *
1405      * @throws GSSException containing the following
1406      * major error codes:
1407      *   {@link GSSException#FAILURE GSSException.FAILURE}
1408      */
1409     public boolean isInitiator() throws GSSException;
1410 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.security.jgss/share/classes/org/ietf/jgss/GSSContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../javax/security/auth/kerberos/ServicePermission.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="package-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.security.jgss/share/classes/org/ietf/jgss/GSSContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 111  * to implement these methods correctly when the token has no self-framing
 112  * (where the end cannot be determined), or the library has no knowledge of
 113  * the token format (for example, as a bridge talking to another GSS library)&quot;.
 114  * These methods include {@link #initSecContext(InputStream, OutputStream)},
 115  * {@link #acceptSecContext(InputStream, OutputStream)},
 116  * {@link #wrap(InputStream, OutputStream, MessageProp)},
 117  * {@link #unwrap(InputStream, OutputStream, MessageProp)},
 118  * {@link #getMIC(InputStream, OutputStream, MessageProp)},
 119  * and {@link #verifyMIC(InputStream, InputStream, MessageProp)}.&lt;p&gt;
 120  *
 121  * The example code presented below demonstrates the usage of the
 122  * &lt;code&gt;GSSContext&lt;/code&gt; interface for the initiating peer.  Different
 123  * operations on the &lt;code&gt;GSSContext&lt;/code&gt; object are presented,
 124  * including: object instantiation, setting of desired flags, context
 125  * establishment, query of actual context flags, per-message operations on
 126  * application data, and finally context deletion.
 127  *
 128  * &lt;pre&gt;
 129  *    // Create a context using default credentials
 130  *    // and the implementation specific default mechanism
<span class="line-modified"> 131  *    GSSManager manager ...</span>
<span class="line-modified"> 132  *    GSSName targetName ...</span>
 133  *    GSSContext context = manager.createContext(targetName, null, null,
 134  *                                           GSSContext.INDEFINITE_LIFETIME);
 135  *
 136  *    // set desired context options prior to context establishment
 137  *    context.requestConf(true);
 138  *    context.requestMutualAuth(true);
 139  *    context.requestReplayDet(true);
 140  *    context.requestSequenceDet(true);
 141  *
 142  *    // establish a context between peers
 143  *
<span class="line-modified"> 144  *    byte []inToken = new byte[0];</span>

 145  *
 146  *    // Loop while there still is a token to be processed
 147  *
 148  *    while (!context.isEstablished()) {
 149  *
<span class="line-modified"> 150  *        byte[] outToken</span>
<span class="line-removed"> 151  *            = context.initSecContext(inToken, 0, inToken.length);</span>
 152  *
 153  *        // send the output token if generated
<span class="line-modified"> 154  *        if (outToken != null)</span>
 155  *            sendToken(outToken);

 156  *
 157  *        if (!context.isEstablished()) {
 158  *            inToken = readToken();

 159  *    }
 160  *
 161  *     // display context information
 162  *     System.out.println(&quot;Remaining lifetime in seconds = &quot;
 163  *                                          + context.getLifetime());
 164  *     System.out.println(&quot;Context mechanism = &quot; + context.getMech());
 165  *     System.out.println(&quot;Initiator = &quot; + context.getSrcName());
 166  *     System.out.println(&quot;Acceptor = &quot; + context.getTargName());
 167  *
<span class="line-modified"> 168  *     if (context.getConfState())</span>
<span class="line-modified"> 169  *             System.out.println(&quot;Confidentiality (i.e., privacy) is available&quot;);</span>

 170  *
<span class="line-modified"> 171  *     if (context.getIntegState())</span>
<span class="line-modified"> 172  *             System.out.println(&quot;Integrity is available&quot;);</span>

 173  *
 174  *     // perform wrap on an application supplied message, appMsg,
 175  *     // using QOP = 0, and requesting privacy service
<span class="line-modified"> 176  *     byte [] appMsg ...</span>
 177  *
 178  *     MessageProp mProp = new MessageProp(0, true);
 179  *
<span class="line-modified"> 180  *     byte []tok = context.wrap(appMsg, 0, appMsg.length, mProp);</span>
 181  *
<span class="line-modified"> 182  *     sendToken(tok);</span>

















 183  *
 184  *     // release the local-end of the context
 185  *     context.dispose();
 186  *
 187  * &lt;/pre&gt;
 188  *
 189  * @author Mayank Upadhyay
 190  * @since 1.4
 191  */
 192 public interface GSSContext {
 193 
 194     /**
 195      * A lifetime constant representing the default context lifetime.  This
 196      * value is set to 0.
 197      */
 198     public static final int DEFAULT_LIFETIME = 0;
 199 
 200     /**
 201      * A lifetime constant representing indefinite context lifetime.
 202      * This value must is set to the maximum integer value in Java -
</pre>
</td>
<td>
<hr />
<pre>
 111  * to implement these methods correctly when the token has no self-framing
 112  * (where the end cannot be determined), or the library has no knowledge of
 113  * the token format (for example, as a bridge talking to another GSS library)&quot;.
 114  * These methods include {@link #initSecContext(InputStream, OutputStream)},
 115  * {@link #acceptSecContext(InputStream, OutputStream)},
 116  * {@link #wrap(InputStream, OutputStream, MessageProp)},
 117  * {@link #unwrap(InputStream, OutputStream, MessageProp)},
 118  * {@link #getMIC(InputStream, OutputStream, MessageProp)},
 119  * and {@link #verifyMIC(InputStream, InputStream, MessageProp)}.&lt;p&gt;
 120  *
 121  * The example code presented below demonstrates the usage of the
 122  * &lt;code&gt;GSSContext&lt;/code&gt; interface for the initiating peer.  Different
 123  * operations on the &lt;code&gt;GSSContext&lt;/code&gt; object are presented,
 124  * including: object instantiation, setting of desired flags, context
 125  * establishment, query of actual context flags, per-message operations on
 126  * application data, and finally context deletion.
 127  *
 128  * &lt;pre&gt;
 129  *    // Create a context using default credentials
 130  *    // and the implementation specific default mechanism
<span class="line-modified"> 131  *    GSSManager manager = ...</span>
<span class="line-modified"> 132  *    GSSName targetName = ...</span>
 133  *    GSSContext context = manager.createContext(targetName, null, null,
 134  *                                           GSSContext.INDEFINITE_LIFETIME);
 135  *
 136  *    // set desired context options prior to context establishment
 137  *    context.requestConf(true);
 138  *    context.requestMutualAuth(true);
 139  *    context.requestReplayDet(true);
 140  *    context.requestSequenceDet(true);
 141  *
 142  *    // establish a context between peers
 143  *
<span class="line-modified"> 144  *    byte[] inToken = new byte[0];</span>
<span class="line-added"> 145  *    byte[] outToken;</span>
 146  *
 147  *    // Loop while there still is a token to be processed
 148  *
 149  *    while (!context.isEstablished()) {
 150  *
<span class="line-modified"> 151  *        outToken = context.initSecContext(inToken, 0, inToken.length);</span>

 152  *
 153  *        // send the output token if generated
<span class="line-modified"> 154  *        if (outToken != null) {</span>
 155  *            sendToken(outToken);
<span class="line-added"> 156  *        }</span>
 157  *
 158  *        if (!context.isEstablished()) {
 159  *            inToken = readToken();
<span class="line-added"> 160  *        }</span>
 161  *    }
 162  *
 163  *     // display context information
 164  *     System.out.println(&quot;Remaining lifetime in seconds = &quot;
 165  *                                          + context.getLifetime());
 166  *     System.out.println(&quot;Context mechanism = &quot; + context.getMech());
 167  *     System.out.println(&quot;Initiator = &quot; + context.getSrcName());
 168  *     System.out.println(&quot;Acceptor = &quot; + context.getTargName());
 169  *
<span class="line-modified"> 170  *     if (context.getConfState()) {</span>
<span class="line-modified"> 171  *         System.out.println(&quot;Confidentiality (i.e., privacy) is available&quot;);</span>
<span class="line-added"> 172  *     }</span>
 173  *
<span class="line-modified"> 174  *     if (context.getIntegState()) {</span>
<span class="line-modified"> 175  *         System.out.println(&quot;Integrity is available&quot;);</span>
<span class="line-added"> 176  *     }</span>
 177  *
 178  *     // perform wrap on an application supplied message, appMsg,
 179  *     // using QOP = 0, and requesting privacy service
<span class="line-modified"> 180  *     byte[] appMsg = ...</span>
 181  *
 182  *     MessageProp mProp = new MessageProp(0, true);
 183  *
<span class="line-modified"> 184  *     outToken = context.wrap(appMsg, 0, appMsg.length, mProp);</span>
 185  *
<span class="line-modified"> 186  *     sendToken(outToken);</span>
<span class="line-added"> 187  *</span>
<span class="line-added"> 188  *     // perform unwrap on an incoming application message, and check</span>
<span class="line-added"> 189  *     // its privacy state and supplementary information</span>
<span class="line-added"> 190  *     inToken = readToken();</span>
<span class="line-added"> 191  *</span>
<span class="line-added"> 192  *     mProp = new MessageProp(0, true);</span>
<span class="line-added"> 193  *</span>
<span class="line-added"> 194  *     appMsg = context.unwrap(inToken, 0, inToken.length, mProp);</span>
<span class="line-added"> 195  *</span>
<span class="line-added"> 196  *     System.out.println(&quot;Was it encrypted? &quot; + mProp.getPrivacy());</span>
<span class="line-added"> 197  *     System.out.println(&quot;Duplicate Token? &quot; + mProp.isDuplicateToken());</span>
<span class="line-added"> 198  *     System.out.println(&quot;Old Token? &quot; + mProp.isOldToken());</span>
<span class="line-added"> 199  *     System.out.println(&quot;Unsequenced Token? &quot; + mProp.isUnseqToken());</span>
<span class="line-added"> 200  *     System.out.println(&quot;Gap Token? &quot; + mProp.isGapToken());</span>
<span class="line-added"> 201  *</span>
<span class="line-added"> 202  *     // the application determines if the privacy state and supplementary</span>
<span class="line-added"> 203  *     // information are acceptable</span>
 204  *
 205  *     // release the local-end of the context
 206  *     context.dispose();
 207  *
 208  * &lt;/pre&gt;
 209  *
 210  * @author Mayank Upadhyay
 211  * @since 1.4
 212  */
 213 public interface GSSContext {
 214 
 215     /**
 216      * A lifetime constant representing the default context lifetime.  This
 217      * value is set to 0.
 218      */
 219     public static final int DEFAULT_LIFETIME = 0;
 220 
 221     /**
 222      * A lifetime constant representing indefinite context lifetime.
 223      * This value must is set to the maximum integer value in Java -
</pre>
</td>
</tr>
</table>
<center><a href="../../../javax/security/auth/kerberos/ServicePermission.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="package-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
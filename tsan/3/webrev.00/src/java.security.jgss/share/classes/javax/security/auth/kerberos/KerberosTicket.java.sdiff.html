<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.security.jgss/share/classes/javax/security/auth/kerberos/KerberosTicket.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="KerberosPrincipal.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyTab.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.security.jgss/share/classes/javax/security/auth/kerberos/KerberosTicket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.security.auth.kerberos;
 27 
 28 import java.io.*;
 29 import java.util.Date;
 30 import java.util.Arrays;
 31 import java.net.InetAddress;

 32 import javax.crypto.SecretKey;
 33 import javax.security.auth.Refreshable;
 34 import javax.security.auth.Destroyable;
 35 import javax.security.auth.RefreshFailedException;
 36 import javax.security.auth.DestroyFailedException;

 37 import sun.security.util.HexDumpEncoder;
 38 
 39 /**
 40  * This class encapsulates a Kerberos ticket and associated
 41  * information as viewed from the client&#39;s point of view. It captures all
 42  * information that the Key Distribution Center (KDC) sends to the client
 43  * in the reply message KDC-REP defined in the Kerberos Protocol
 44  * Specification (&lt;a href=http://www.ietf.org/rfc/rfc4120.txt&gt;RFC 4120&lt;/a&gt;).
 45  * &lt;p&gt;
 46  * All Kerberos JAAS login modules that authenticate a user to a KDC should
 47  * use this class. Where available, the login module might even read this
 48  * information from a ticket cache in the operating system instead of
 49  * directly communicating with the KDC. During the commit phase of the JAAS
 50  * authentication process, the JAAS login module should instantiate this
 51  * class and store the instance in the private credential set of a
 52  * {@link javax.security.auth.Subject Subject}.&lt;p&gt;
 53  *
 54  * It might be necessary for the application to be granted a
 55  * {@link javax.security.auth.PrivateCredentialPermission
 56  * PrivateCredentialPermission} if it needs to access a {@code KerberosTicket}
</pre>
<hr />
<pre>
173 
174     private KerberosPrincipal client;
175 
176     /**
177      *
178      * The service for which the ticket was issued.
179      *
180      * @serial
181      */
182 
183     private KerberosPrincipal server;
184 
185     /**
186      *
187      * The addresses from where the ticket may be used by the client.
188      * This field may be null when the ticket is usable from any address.
189      *
190      * @serial
191      */
192 
<span class="line-removed">193 </span>
194     private InetAddress[] clientAddresses;
195 






196     private transient boolean destroyed = false;
197 




198     /**
199      * Constructs a {@code KerberosTicket} using credentials information that a
200      * client either receives from a KDC or reads from a cache.
201      *
202      * @param asn1Encoding the ASN.1 encoding of the ticket as defined by
203      * the Kerberos protocol specification.
204      * @param client the client that owns this service
205      * ticket
206      * @param server the service that this ticket is for
207      * @param sessionKey the raw bytes for the session key that must be
208      * used to encrypt the authenticator that will be sent to the server
209      * @param keyType the key type for the session key as defined by the
210      * Kerberos protocol specification.
211      * @param flags the ticket flags. Each element in this array indicates
212      * the value for the corresponding bit in the ASN.1 BitString that
213      * represents the ticket flags. If the number of elements in this array
214      * is less than the number of flags used by the Kerberos protocol,
215      * then the missing flags will be filled in with false.
216      * @param authTime the time of initial authentication for the client
217      * @param startTime the time after which the ticket will be valid. This
</pre>
<hr />
<pre>
574         }
575         if (!isRenewable()) {
576             throw new RefreshFailedException(&quot;This ticket is not renewable&quot;);
577         }
578 
579         if (getRenewTill() == null) {
580             // Renewable ticket without renew-till. Illegal and ignored.
581             return;
582         }
583 
584         if (System.currentTimeMillis() &gt; getRenewTill().getTime()) {
585             throw new RefreshFailedException(&quot;This ticket is past &quot;
586                                            + &quot;its last renewal time.&quot;);
587         }
588         Throwable e = null;
589         sun.security.krb5.Credentials krb5Creds = null;
590 
591         try {
592             krb5Creds = new sun.security.krb5.Credentials(asn1Encoding,
593                                                     client.getName(),


594                                                     server.getName(),


595                                                     sessionKey.getEncoded(),
596                                                     sessionKey.getKeyType(),
597                                                     flags,
598                                                     authTime,
599                                                     startTime,
600                                                     endTime,
601                                                     renewTill,
602                                                     clientAddresses);
603             krb5Creds = krb5Creds.renew();
604         } catch (sun.security.krb5.KrbException krbException) {
605             e = krbException;
606         } catch (java.io.IOException ioException) {
607             e = ioException;
608         }
609 
610         if (e != null) {
611             RefreshFailedException rfException
612                 = new RefreshFailedException(&quot;Failed to renew Kerberos Ticket &quot;
613                                              + &quot;for client &quot; + client
614                                              + &quot; and server &quot; + server
</pre>
<hr />
<pre>
686             }
687         }
688         return (&quot;Ticket (hex) = &quot; + &quot;\n&quot; +
689                  (new HexDumpEncoder()).encodeBuffer(asn1Encoding) + &quot;\n&quot; +
690                 &quot;Client Principal = &quot; + client.toString() + &quot;\n&quot; +
691                 &quot;Server Principal = &quot; + server.toString() + &quot;\n&quot; +
692                 &quot;Session Key = &quot; + sessionKey.toString() + &quot;\n&quot; +
693                 &quot;Forwardable Ticket &quot; + flags[FORWARDABLE_TICKET_FLAG] + &quot;\n&quot; +
694                 &quot;Forwarded Ticket &quot; + flags[FORWARDED_TICKET_FLAG] + &quot;\n&quot; +
695                 &quot;Proxiable Ticket &quot; + flags[PROXIABLE_TICKET_FLAG] + &quot;\n&quot; +
696                 &quot;Proxy Ticket &quot; + flags[PROXY_TICKET_FLAG] + &quot;\n&quot; +
697                 &quot;Postdated Ticket &quot; + flags[POSTDATED_TICKET_FLAG] + &quot;\n&quot; +
698                 &quot;Renewable Ticket &quot; + flags[RENEWABLE_TICKET_FLAG] + &quot;\n&quot; +
699                 &quot;Initial Ticket &quot; + flags[INITIAL_TICKET_FLAG] + &quot;\n&quot; +
700                 &quot;Auth Time = &quot; + String.valueOf(authTime) + &quot;\n&quot; +
701                 &quot;Start Time = &quot; + String.valueOf(startTime) + &quot;\n&quot; +
702                 &quot;End Time = &quot; + endTime.toString() + &quot;\n&quot; +
703                 &quot;Renew Till = &quot; + String.valueOf(renewTill) + &quot;\n&quot; +
704                 &quot;Client Addresses &quot; +
705                 (clientAddresses == null ? &quot; Null &quot; : caddrString.toString() +

706                 &quot;\n&quot;));
707     }
708 
709     /**
710      * Returns a hash code for this {@code KerberosTicket}.
711      *
712      * @return a hash code for this {@code KerberosTicket}.
713      * @since 1.6
714      */
715     public int hashCode() {
716         int result = 17;
717         if (isDestroyed()) {
718             return result;
719         }
720         result = result * 37 + Arrays.hashCode(getEncoded());
721         result = result * 37 + endTime.hashCode();
722         result = result * 37 + client.hashCode();
723         result = result * 37 + server.hashCode();
724         result = result * 37 + sessionKey.hashCode();
725 
726         // authTime may be null
727         if (authTime != null) {
728             result = result * 37 + authTime.hashCode();
729         }
730 
731         // startTime may be null
732         if (startTime != null) {
733             result = result * 37 + startTime.hashCode();
734         }
735 
736         // renewTill may be null
737         if (renewTill != null) {
738             result = result * 37 + renewTill.hashCode();
739         }
740 
741         // clientAddress may be null, the array&#39;s hashCode is 0
742         result = result * 37 + Arrays.hashCode(clientAddresses);




743         return result * 37 + Arrays.hashCode(flags);
744     }
745 
746     /**
747      * Compares the specified object with this {@code KerberosTicket} for equality.
748      * Returns true if the given object is also a
749      * {@code KerberosTicket} and the two
750      * {@code KerberosTicket} instances are equivalent.
751      * A destroyed {@code KerberosTicket} object is only equal to itself.
752      *
753      * @param other the object to compare to
754      * @return true if the specified object is equal to this {@code KerberosTicket},
755      * false otherwise.
756      * @since 1.6
757      */
758     public boolean equals(Object other) {
759 
760         if (other == this) {
761             return true;
762         }
</pre>
<hr />
<pre>
795         if (startTime == null) {
796             if (otherTicket.getStartTime() != null) {
797                 return false;
798             }
799         } else {
800             if (!startTime.equals(otherTicket.getStartTime())) {
801                 return false;
802             }
803         }
804 
805         if (renewTill == null) {
806             if (otherTicket.getRenewTill() != null) {
807                 return false;
808             }
809         } else {
810             if (!renewTill.equals(otherTicket.getRenewTill())) {
811                 return false;
812             }
813         }
814 




815         return true;
816     }
817 
818     private void readObject(ObjectInputStream s)
819             throws IOException, ClassNotFoundException {
820         s.defaultReadObject();
821         if (sessionKey == null) {
822            throw new InvalidObjectException(&quot;Session key cannot be null&quot;);
823         }
824         try {
825             init(asn1Encoding, client, server, sessionKey,
826                  flags, authTime, startTime, endTime,
827                  renewTill, clientAddresses);
828         } catch (IllegalArgumentException iae) {
829             throw (InvalidObjectException)
830                 new InvalidObjectException(iae.getMessage()).initCause(iae);
831         }
832     }
833 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.security.auth.kerberos;
 27 
 28 import java.io.*;
 29 import java.util.Date;
 30 import java.util.Arrays;
 31 import java.net.InetAddress;
<span class="line-added"> 32 import java.util.Objects;</span>
 33 import javax.crypto.SecretKey;
 34 import javax.security.auth.Refreshable;
 35 import javax.security.auth.Destroyable;
 36 import javax.security.auth.RefreshFailedException;
 37 import javax.security.auth.DestroyFailedException;
<span class="line-added"> 38 </span>
 39 import sun.security.util.HexDumpEncoder;
 40 
 41 /**
 42  * This class encapsulates a Kerberos ticket and associated
 43  * information as viewed from the client&#39;s point of view. It captures all
 44  * information that the Key Distribution Center (KDC) sends to the client
 45  * in the reply message KDC-REP defined in the Kerberos Protocol
 46  * Specification (&lt;a href=http://www.ietf.org/rfc/rfc4120.txt&gt;RFC 4120&lt;/a&gt;).
 47  * &lt;p&gt;
 48  * All Kerberos JAAS login modules that authenticate a user to a KDC should
 49  * use this class. Where available, the login module might even read this
 50  * information from a ticket cache in the operating system instead of
 51  * directly communicating with the KDC. During the commit phase of the JAAS
 52  * authentication process, the JAAS login module should instantiate this
 53  * class and store the instance in the private credential set of a
 54  * {@link javax.security.auth.Subject Subject}.&lt;p&gt;
 55  *
 56  * It might be necessary for the application to be granted a
 57  * {@link javax.security.auth.PrivateCredentialPermission
 58  * PrivateCredentialPermission} if it needs to access a {@code KerberosTicket}
</pre>
<hr />
<pre>
175 
176     private KerberosPrincipal client;
177 
178     /**
179      *
180      * The service for which the ticket was issued.
181      *
182      * @serial
183      */
184 
185     private KerberosPrincipal server;
186 
187     /**
188      *
189      * The addresses from where the ticket may be used by the client.
190      * This field may be null when the ticket is usable from any address.
191      *
192      * @serial
193      */
194 

195     private InetAddress[] clientAddresses;
196 
<span class="line-added">197     /**</span>
<span class="line-added">198      * Evidence ticket if proxy_impersonator. This field can be accessed</span>
<span class="line-added">199      * by KerberosSecrets. It&#39;s serialized.</span>
<span class="line-added">200      */</span>
<span class="line-added">201     KerberosTicket proxy = null;</span>
<span class="line-added">202 </span>
203     private transient boolean destroyed = false;
204 
<span class="line-added">205     transient KerberosPrincipal clientAlias = null;</span>
<span class="line-added">206 </span>
<span class="line-added">207     transient KerberosPrincipal serverAlias = null;</span>
<span class="line-added">208 </span>
209     /**
210      * Constructs a {@code KerberosTicket} using credentials information that a
211      * client either receives from a KDC or reads from a cache.
212      *
213      * @param asn1Encoding the ASN.1 encoding of the ticket as defined by
214      * the Kerberos protocol specification.
215      * @param client the client that owns this service
216      * ticket
217      * @param server the service that this ticket is for
218      * @param sessionKey the raw bytes for the session key that must be
219      * used to encrypt the authenticator that will be sent to the server
220      * @param keyType the key type for the session key as defined by the
221      * Kerberos protocol specification.
222      * @param flags the ticket flags. Each element in this array indicates
223      * the value for the corresponding bit in the ASN.1 BitString that
224      * represents the ticket flags. If the number of elements in this array
225      * is less than the number of flags used by the Kerberos protocol,
226      * then the missing flags will be filled in with false.
227      * @param authTime the time of initial authentication for the client
228      * @param startTime the time after which the ticket will be valid. This
</pre>
<hr />
<pre>
585         }
586         if (!isRenewable()) {
587             throw new RefreshFailedException(&quot;This ticket is not renewable&quot;);
588         }
589 
590         if (getRenewTill() == null) {
591             // Renewable ticket without renew-till. Illegal and ignored.
592             return;
593         }
594 
595         if (System.currentTimeMillis() &gt; getRenewTill().getTime()) {
596             throw new RefreshFailedException(&quot;This ticket is past &quot;
597                                            + &quot;its last renewal time.&quot;);
598         }
599         Throwable e = null;
600         sun.security.krb5.Credentials krb5Creds = null;
601 
602         try {
603             krb5Creds = new sun.security.krb5.Credentials(asn1Encoding,
604                                                     client.getName(),
<span class="line-added">605                                                     (clientAlias != null ?</span>
<span class="line-added">606                                                             clientAlias.getName() : null),</span>
607                                                     server.getName(),
<span class="line-added">608                                                     (serverAlias != null ?</span>
<span class="line-added">609                                                             serverAlias.getName() : null),</span>
610                                                     sessionKey.getEncoded(),
611                                                     sessionKey.getKeyType(),
612                                                     flags,
613                                                     authTime,
614                                                     startTime,
615                                                     endTime,
616                                                     renewTill,
617                                                     clientAddresses);
618             krb5Creds = krb5Creds.renew();
619         } catch (sun.security.krb5.KrbException krbException) {
620             e = krbException;
621         } catch (java.io.IOException ioException) {
622             e = ioException;
623         }
624 
625         if (e != null) {
626             RefreshFailedException rfException
627                 = new RefreshFailedException(&quot;Failed to renew Kerberos Ticket &quot;
628                                              + &quot;for client &quot; + client
629                                              + &quot; and server &quot; + server
</pre>
<hr />
<pre>
701             }
702         }
703         return (&quot;Ticket (hex) = &quot; + &quot;\n&quot; +
704                  (new HexDumpEncoder()).encodeBuffer(asn1Encoding) + &quot;\n&quot; +
705                 &quot;Client Principal = &quot; + client.toString() + &quot;\n&quot; +
706                 &quot;Server Principal = &quot; + server.toString() + &quot;\n&quot; +
707                 &quot;Session Key = &quot; + sessionKey.toString() + &quot;\n&quot; +
708                 &quot;Forwardable Ticket &quot; + flags[FORWARDABLE_TICKET_FLAG] + &quot;\n&quot; +
709                 &quot;Forwarded Ticket &quot; + flags[FORWARDED_TICKET_FLAG] + &quot;\n&quot; +
710                 &quot;Proxiable Ticket &quot; + flags[PROXIABLE_TICKET_FLAG] + &quot;\n&quot; +
711                 &quot;Proxy Ticket &quot; + flags[PROXY_TICKET_FLAG] + &quot;\n&quot; +
712                 &quot;Postdated Ticket &quot; + flags[POSTDATED_TICKET_FLAG] + &quot;\n&quot; +
713                 &quot;Renewable Ticket &quot; + flags[RENEWABLE_TICKET_FLAG] + &quot;\n&quot; +
714                 &quot;Initial Ticket &quot; + flags[INITIAL_TICKET_FLAG] + &quot;\n&quot; +
715                 &quot;Auth Time = &quot; + String.valueOf(authTime) + &quot;\n&quot; +
716                 &quot;Start Time = &quot; + String.valueOf(startTime) + &quot;\n&quot; +
717                 &quot;End Time = &quot; + endTime.toString() + &quot;\n&quot; +
718                 &quot;Renew Till = &quot; + String.valueOf(renewTill) + &quot;\n&quot; +
719                 &quot;Client Addresses &quot; +
720                 (clientAddresses == null ? &quot; Null &quot; : caddrString.toString() +
<span class="line-added">721                 (proxy == null ? &quot;&quot; : &quot;\nwith a proxy ticket&quot;) +</span>
722                 &quot;\n&quot;));
723     }
724 
725     /**
726      * Returns a hash code for this {@code KerberosTicket}.
727      *
728      * @return a hash code for this {@code KerberosTicket}.
729      * @since 1.6
730      */
731     public int hashCode() {
732         int result = 17;
733         if (isDestroyed()) {
734             return result;
735         }
736         result = result * 37 + Arrays.hashCode(getEncoded());
737         result = result * 37 + endTime.hashCode();
738         result = result * 37 + client.hashCode();
739         result = result * 37 + server.hashCode();
740         result = result * 37 + sessionKey.hashCode();
741 
742         // authTime may be null
743         if (authTime != null) {
744             result = result * 37 + authTime.hashCode();
745         }
746 
747         // startTime may be null
748         if (startTime != null) {
749             result = result * 37 + startTime.hashCode();
750         }
751 
752         // renewTill may be null
753         if (renewTill != null) {
754             result = result * 37 + renewTill.hashCode();
755         }
756 
757         // clientAddress may be null, the array&#39;s hashCode is 0
758         result = result * 37 + Arrays.hashCode(clientAddresses);
<span class="line-added">759 </span>
<span class="line-added">760         if (proxy != null) {</span>
<span class="line-added">761             result = result * 37 + proxy.hashCode();</span>
<span class="line-added">762         }</span>
763         return result * 37 + Arrays.hashCode(flags);
764     }
765 
766     /**
767      * Compares the specified object with this {@code KerberosTicket} for equality.
768      * Returns true if the given object is also a
769      * {@code KerberosTicket} and the two
770      * {@code KerberosTicket} instances are equivalent.
771      * A destroyed {@code KerberosTicket} object is only equal to itself.
772      *
773      * @param other the object to compare to
774      * @return true if the specified object is equal to this {@code KerberosTicket},
775      * false otherwise.
776      * @since 1.6
777      */
778     public boolean equals(Object other) {
779 
780         if (other == this) {
781             return true;
782         }
</pre>
<hr />
<pre>
815         if (startTime == null) {
816             if (otherTicket.getStartTime() != null) {
817                 return false;
818             }
819         } else {
820             if (!startTime.equals(otherTicket.getStartTime())) {
821                 return false;
822             }
823         }
824 
825         if (renewTill == null) {
826             if (otherTicket.getRenewTill() != null) {
827                 return false;
828             }
829         } else {
830             if (!renewTill.equals(otherTicket.getRenewTill())) {
831                 return false;
832             }
833         }
834 
<span class="line-added">835         if (!Objects.equals(proxy, otherTicket.proxy)) {</span>
<span class="line-added">836             return false;</span>
<span class="line-added">837         }</span>
<span class="line-added">838 </span>
839         return true;
840     }
841 
842     private void readObject(ObjectInputStream s)
843             throws IOException, ClassNotFoundException {
844         s.defaultReadObject();
845         if (sessionKey == null) {
846            throw new InvalidObjectException(&quot;Session key cannot be null&quot;);
847         }
848         try {
849             init(asn1Encoding, client, server, sessionKey,
850                  flags, authTime, startTime, endTime,
851                  renewTill, clientAddresses);
852         } catch (IllegalArgumentException iae) {
853             throw (InvalidObjectException)
854                 new InvalidObjectException(iae.getMessage()).initCause(iae);
855         }
856     }
857 }
</pre>
</td>
</tr>
</table>
<center><a href="KerberosPrincipal.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyTab.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
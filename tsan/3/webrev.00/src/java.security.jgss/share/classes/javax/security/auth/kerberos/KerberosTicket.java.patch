diff a/src/java.security.jgss/share/classes/javax/security/auth/kerberos/KerberosTicket.java b/src/java.security.jgss/share/classes/javax/security/auth/kerberos/KerberosTicket.java
--- a/src/java.security.jgss/share/classes/javax/security/auth/kerberos/KerberosTicket.java
+++ b/src/java.security.jgss/share/classes/javax/security/auth/kerberos/KerberosTicket.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,15 +27,17 @@
 
 import java.io.*;
 import java.util.Date;
 import java.util.Arrays;
 import java.net.InetAddress;
+import java.util.Objects;
 import javax.crypto.SecretKey;
 import javax.security.auth.Refreshable;
 import javax.security.auth.Destroyable;
 import javax.security.auth.RefreshFailedException;
 import javax.security.auth.DestroyFailedException;
+
 import sun.security.util.HexDumpEncoder;
 
 /**
  * This class encapsulates a Kerberos ticket and associated
  * information as viewed from the client's point of view. It captures all
@@ -188,15 +190,24 @@
      * This field may be null when the ticket is usable from any address.
      *
      * @serial
      */
 
-
     private InetAddress[] clientAddresses;
 
+    /**
+     * Evidence ticket if proxy_impersonator. This field can be accessed
+     * by KerberosSecrets. It's serialized.
+     */
+    KerberosTicket proxy = null;
+
     private transient boolean destroyed = false;
 
+    transient KerberosPrincipal clientAlias = null;
+
+    transient KerberosPrincipal serverAlias = null;
+
     /**
      * Constructs a {@code KerberosTicket} using credentials information that a
      * client either receives from a KDC or reads from a cache.
      *
      * @param asn1Encoding the ASN.1 encoding of the ticket as defined by
@@ -589,11 +600,15 @@
         sun.security.krb5.Credentials krb5Creds = null;
 
         try {
             krb5Creds = new sun.security.krb5.Credentials(asn1Encoding,
                                                     client.getName(),
+                                                    (clientAlias != null ?
+                                                            clientAlias.getName() : null),
                                                     server.getName(),
+                                                    (serverAlias != null ?
+                                                            serverAlias.getName() : null),
                                                     sessionKey.getEncoded(),
                                                     sessionKey.getKeyType(),
                                                     flags,
                                                     authTime,
                                                     startTime,
@@ -701,10 +716,11 @@
                 "Start Time = " + String.valueOf(startTime) + "\n" +
                 "End Time = " + endTime.toString() + "\n" +
                 "Renew Till = " + String.valueOf(renewTill) + "\n" +
                 "Client Addresses " +
                 (clientAddresses == null ? " Null " : caddrString.toString() +
+                (proxy == null ? "" : "\nwith a proxy ticket") +
                 "\n"));
     }
 
     /**
      * Returns a hash code for this {@code KerberosTicket}.
@@ -738,10 +754,14 @@
             result = result * 37 + renewTill.hashCode();
         }
 
         // clientAddress may be null, the array's hashCode is 0
         result = result * 37 + Arrays.hashCode(clientAddresses);
+
+        if (proxy != null) {
+            result = result * 37 + proxy.hashCode();
+        }
         return result * 37 + Arrays.hashCode(flags);
     }
 
     /**
      * Compares the specified object with this {@code KerberosTicket} for equality.
@@ -810,10 +830,14 @@
             if (!renewTill.equals(otherTicket.getRenewTill())) {
                 return false;
             }
         }
 
+        if (!Objects.equals(proxy, otherTicket.proxy)) {
+            return false;
+        }
+
         return true;
     }
 
     private void readObject(ObjectInputStream s)
             throws IOException, ClassNotFoundException {

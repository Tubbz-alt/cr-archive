<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.security.jgss/share/classes/javax/security/auth/kerberos/KerberosTicket.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.security.auth.kerberos;
 27 
 28 import java.io.*;
 29 import java.util.Date;
 30 import java.util.Arrays;
 31 import java.net.InetAddress;
<a name="2" id="anc2"></a>
 32 import javax.crypto.SecretKey;
 33 import javax.security.auth.Refreshable;
 34 import javax.security.auth.Destroyable;
 35 import javax.security.auth.RefreshFailedException;
 36 import javax.security.auth.DestroyFailedException;
<a name="3" id="anc3"></a>
 37 import sun.security.util.HexDumpEncoder;
 38 
 39 /**
 40  * This class encapsulates a Kerberos ticket and associated
 41  * information as viewed from the client&#39;s point of view. It captures all
 42  * information that the Key Distribution Center (KDC) sends to the client
 43  * in the reply message KDC-REP defined in the Kerberos Protocol
 44  * Specification (&lt;a href=http://www.ietf.org/rfc/rfc4120.txt&gt;RFC 4120&lt;/a&gt;).
 45  * &lt;p&gt;
 46  * All Kerberos JAAS login modules that authenticate a user to a KDC should
 47  * use this class. Where available, the login module might even read this
 48  * information from a ticket cache in the operating system instead of
 49  * directly communicating with the KDC. During the commit phase of the JAAS
 50  * authentication process, the JAAS login module should instantiate this
 51  * class and store the instance in the private credential set of a
 52  * {@link javax.security.auth.Subject Subject}.&lt;p&gt;
 53  *
 54  * It might be necessary for the application to be granted a
 55  * {@link javax.security.auth.PrivateCredentialPermission
 56  * PrivateCredentialPermission} if it needs to access a {@code KerberosTicket}
 57  * instance from a {@code Subject}. This permission is not needed when the
 58  * application depends on the default JGSS Kerberos mechanism to access the
 59  * {@code KerberosTicket}. In that case, however, the application will need an
 60  * appropriate
 61  * {@link javax.security.auth.kerberos.ServicePermission ServicePermission}.
 62  * &lt;p&gt;
 63  * Note that this class is applicable to both ticket granting tickets and
 64  * other regular service tickets. A ticket granting ticket is just a
 65  * special case of a more generalized service ticket.
 66  *
 67  * @implNote The JAAS login module in the JDK reference implementation destroys
 68  * all tickets after logout.
 69  *
 70  * @see javax.security.auth.Subject
 71  * @see javax.security.auth.PrivateCredentialPermission
 72  * @see javax.security.auth.login.LoginContext
 73  * @see org.ietf.jgss.GSSCredential
 74  * @see org.ietf.jgss.GSSManager
 75  *
 76  * @author Mayank Upadhyay
 77  * @since 1.4
 78  */
 79 public class KerberosTicket implements Destroyable, Refreshable,
 80          java.io.Serializable {
 81 
 82     private static final long serialVersionUID = 7395334370157380539L;
 83 
 84     // XXX Make these flag indices public
 85     private static final int FORWARDABLE_TICKET_FLAG = 1;
 86     private static final int FORWARDED_TICKET_FLAG   = 2;
 87     private static final int PROXIABLE_TICKET_FLAG   = 3;
 88     private static final int PROXY_TICKET_FLAG       = 4;
 89     private static final int POSTDATED_TICKET_FLAG   = 6;
 90     private static final int RENEWABLE_TICKET_FLAG   = 8;
 91     private static final int INITIAL_TICKET_FLAG     = 9;
 92 
 93     private static final int NUM_FLAGS = 32;
 94 
 95     /**
 96      *
 97      * ASN.1 DER Encoding of the Ticket as defined in the
 98      * Kerberos Protocol Specification RFC4120.
 99      *
100      * @serial
101      */
102 
103     private byte[] asn1Encoding;
104 
105     /**
106      *{@code KeyImpl} is serialized by writing out the ASN1 Encoded bytes
107      * of the encryption key. The ASN1 encoding is defined in RFC4120 and as
108      * follows:
109      * &lt;pre&gt;
110      * EncryptionKey   ::= SEQUENCE {
111      *          keytype    [0] Int32 -- actually encryption type --,
112      *          keyvalue   [1] OCTET STRING
113      * }
114      * &lt;/pre&gt;
115      *
116      * @serial
117      */
118 
119     private KeyImpl sessionKey;
120 
121     /**
122      *
123      * Ticket Flags as defined in the Kerberos Protocol Specification RFC4120.
124      *
125      * @serial
126      */
127 
128     private boolean[] flags;
129 
130     /**
131      *
132      * Time of initial authentication
133      *
134      * @serial
135      */
136 
137     private Date authTime;
138 
139     /**
140      *
141      * Time after which the ticket is valid.
142      * @serial
143      */
144     private Date startTime;
145 
146     /**
147      *
148      * Time after which the ticket will not be honored. (its expiration time).
149      *
150      * @serial
151      */
152 
153     private Date endTime;
154 
155     /**
156      *
157      * For renewable Tickets it indicates the maximum endtime that may be
158      * included in a renewal. It can be thought of as the absolute expiration
159      * time for the ticket, including all renewals. This field may be null
160      * for tickets that are not renewable.
161      *
162      * @serial
163      */
164 
165     private Date renewTill;
166 
167     /**
168      *
169      * Client that owns the service ticket
170      *
171      * @serial
172      */
173 
174     private KerberosPrincipal client;
175 
176     /**
177      *
178      * The service for which the ticket was issued.
179      *
180      * @serial
181      */
182 
183     private KerberosPrincipal server;
184 
185     /**
186      *
187      * The addresses from where the ticket may be used by the client.
188      * This field may be null when the ticket is usable from any address.
189      *
190      * @serial
191      */
192 
<a name="4" id="anc4"></a><span class="line-removed">193 </span>
194     private InetAddress[] clientAddresses;
195 
<a name="5" id="anc5"></a>





196     private transient boolean destroyed = false;
197 
<a name="6" id="anc6"></a>



198     /**
199      * Constructs a {@code KerberosTicket} using credentials information that a
200      * client either receives from a KDC or reads from a cache.
201      *
202      * @param asn1Encoding the ASN.1 encoding of the ticket as defined by
203      * the Kerberos protocol specification.
204      * @param client the client that owns this service
205      * ticket
206      * @param server the service that this ticket is for
207      * @param sessionKey the raw bytes for the session key that must be
208      * used to encrypt the authenticator that will be sent to the server
209      * @param keyType the key type for the session key as defined by the
210      * Kerberos protocol specification.
211      * @param flags the ticket flags. Each element in this array indicates
212      * the value for the corresponding bit in the ASN.1 BitString that
213      * represents the ticket flags. If the number of elements in this array
214      * is less than the number of flags used by the Kerberos protocol,
215      * then the missing flags will be filled in with false.
216      * @param authTime the time of initial authentication for the client
217      * @param startTime the time after which the ticket will be valid. This
218      * may be null in which case the value of authTime is treated as the
219      * startTime.
220      * @param endTime the time after which the ticket will no longer be
221      * valid
222      * @param renewTill an absolute expiration time for the ticket,
223      * including all renewal that might be possible. This field may be null
224      * for tickets that are not renewable.
225      * @param clientAddresses the addresses from where the ticket may be
226      * used by the client. This field may be null when the ticket is usable
227      * from any address.
228      */
229     public KerberosTicket(byte[] asn1Encoding,
230                          KerberosPrincipal client,
231                          KerberosPrincipal server,
232                          byte[] sessionKey,
233                          int keyType,
234                          boolean[] flags,
235                          Date authTime,
236                          Date startTime,
237                          Date endTime,
238                          Date renewTill,
239                          InetAddress[] clientAddresses) {
240 
241         init(asn1Encoding, client, server, sessionKey, keyType, flags,
242             authTime, startTime, endTime, renewTill, clientAddresses);
243     }
244 
245     private void init(byte[] asn1Encoding,
246                          KerberosPrincipal client,
247                          KerberosPrincipal server,
248                          byte[] sessionKey,
249                          int keyType,
250                          boolean[] flags,
251                          Date authTime,
252                          Date startTime,
253                          Date endTime,
254                          Date renewTill,
255                          InetAddress[] clientAddresses) {
256         if (sessionKey == null) {
257             throw new IllegalArgumentException(&quot;Session key for ticket&quot;
258                     + &quot; cannot be null&quot;);
259         }
260         init(asn1Encoding, client, server,
261              new KeyImpl(sessionKey, keyType), flags, authTime,
262              startTime, endTime, renewTill, clientAddresses);
263     }
264 
265     private void init(byte[] asn1Encoding,
266                          KerberosPrincipal client,
267                          KerberosPrincipal server,
268                          KeyImpl sessionKey,
269                          boolean[] flags,
270                          Date authTime,
271                          Date startTime,
272                          Date endTime,
273                          Date renewTill,
274                          InetAddress[] clientAddresses) {
275         if (asn1Encoding == null) {
276             throw new IllegalArgumentException(&quot;ASN.1 encoding of ticket&quot;
277                     + &quot; cannot be null&quot;);
278         }
279         this.asn1Encoding = asn1Encoding.clone();
280 
281         if (client == null) {
282             throw new IllegalArgumentException(&quot;Client name in ticket&quot;
283                     + &quot; cannot be null&quot;);
284         }
285         this.client = client;
286 
287         if (server == null) {
288             throw new IllegalArgumentException(&quot;Server name in ticket&quot;
289                     + &quot; cannot be null&quot;);
290         }
291         this.server = server;
292 
293         // Caller needs to make sure `sessionKey` will not be null
294         this.sessionKey = sessionKey;
295 
296         if (flags != null) {
297            if (flags.length &gt;= NUM_FLAGS) {
298                this.flags = flags.clone();
299            } else {
300                 this.flags = new boolean[NUM_FLAGS];
301                 // Fill in whatever we have
302                 for (int i = 0; i &lt; flags.length; i++) {
303                     this.flags[i] = flags[i];
304                 }
305            }
306         } else {
307             this.flags = new boolean[NUM_FLAGS];
308         }
309 
310         if (this.flags[RENEWABLE_TICKET_FLAG] &amp;&amp; renewTill != null) {
311            this.renewTill = new Date(renewTill.getTime());
312         }
313 
314         if (authTime != null) {
315             this.authTime = new Date(authTime.getTime());
316         }
317         if (startTime != null) {
318             this.startTime = new Date(startTime.getTime());
319         } else {
320             this.startTime = this.authTime;
321         }
322 
323         if (endTime == null) {
324             throw new IllegalArgumentException(&quot;End time for ticket validity&quot;
325                     + &quot; cannot be null&quot;);
326         }
327         this.endTime = new Date(endTime.getTime());
328 
329         if (clientAddresses != null) {
330             this.clientAddresses = clientAddresses.clone();
331         }
332     }
333 
334     /**
335      * Returns the client principal associated with this ticket.
336      *
337      * @return the client principal, or {@code null} if destroyed.
338      */
339     public final KerberosPrincipal getClient() {
340         return client;
341     }
342 
343     /**
344      * Returns the service principal associated with this ticket.
345      *
346      * @return the service principal, or {@code null} if destroyed.
347      */
348     public final KerberosPrincipal getServer() {
349         return server;
350     }
351 
352     /**
353      * Returns the session key associated with this ticket. The return value
354      * is always a {@link EncryptionKey} object.
355      *
356      * @return the session key.
357      * @throws IllegalStateException if this ticket is destroyed
358      */
359     public final SecretKey getSessionKey() {
360         if (destroyed) {
361             throw new IllegalStateException(&quot;This ticket is no longer valid&quot;);
362         }
363         return new EncryptionKey(
364                 sessionKey.getEncoded(), sessionKey.getKeyType());
365     }
366 
367     /**
368      * Returns the key type of the session key associated with this
369      * ticket as defined by the Kerberos Protocol Specification.
370      *
371      * @return the key type of the session key associated with this
372      * ticket.
373      * @throws IllegalStateException if this ticket is destroyed
374      *
375      * @see #getSessionKey()
376      */
377     public final int getSessionKeyType() {
378         if (destroyed) {
379             throw new IllegalStateException(&quot;This ticket is no longer valid&quot;);
380         }
381         return sessionKey.getKeyType();
382     }
383 
384     /**
385      * Determines if this ticket is forwardable.
386      *
387      * @return true if this ticket is forwardable, or false if not forwardable
388      * or destroyed.
389      */
390     public final boolean isForwardable() {
391         return flags == null? false: flags[FORWARDABLE_TICKET_FLAG];
392     }
393 
394     /**
395      * Determines if this ticket had been forwarded or was issued based on
396      * authentication involving a forwarded ticket-granting ticket.
397      *
398      * @return true if this ticket had been forwarded or was issued based on
399      * authentication involving a forwarded ticket-granting ticket,
400      * or false otherwise or destroyed.
401      */
402     public final boolean isForwarded() {
403         return flags == null? false: flags[FORWARDED_TICKET_FLAG];
404     }
405 
406     /**
407      * Determines if this ticket is proxiable.
408      *
409      * @return true if this ticket is proxiable, or false if not proxiable
410      * or destroyed.
411      */
412     public final boolean isProxiable() {
413         return flags == null? false: flags[PROXIABLE_TICKET_FLAG];
414     }
415 
416     /**
417      * Determines is this ticket is a proxy-ticket.
418      *
419      * @return true if this ticket is a proxy-ticket, or false if not
420      * a proxy-ticket or destroyed.
421      */
422     public final boolean isProxy() {
423         return flags == null? false: flags[PROXY_TICKET_FLAG];
424     }
425 
426 
427     /**
428      * Determines is this ticket is post-dated.
429      *
430      * @return true if this ticket is post-dated, or false if not post-dated
431      * or destroyed.
432      */
433     public final boolean isPostdated() {
434         return flags == null? false: flags[POSTDATED_TICKET_FLAG];
435     }
436 
437     /**
438      * Determines is this ticket is renewable. If so, the {@link #refresh()
439      * refresh} method can be called, assuming the validity period for
440      * renewing is not already over.
441      *
442      * @return true if this ticket is renewable, or false if not renewable
443      * or destroyed.
444      */
445     public final boolean isRenewable() {
446         return flags == null? false: flags[RENEWABLE_TICKET_FLAG];
447     }
448 
449     /**
450      * Determines if this ticket was issued using the Kerberos AS-Exchange
451      * protocol, and not issued based on some ticket-granting ticket.
452      *
453      * @return true if this ticket was issued using the Kerberos AS-Exchange
454      * protocol, or false if not issued this way or destroyed.
455      */
456     public final boolean isInitial() {
457         return flags == null? false: flags[INITIAL_TICKET_FLAG];
458     }
459 
460     /**
461      * Returns the flags associated with this ticket. Each element in the
462      * returned array indicates the value for the corresponding bit in the
463      * ASN.1 BitString that represents the ticket flags.
464      *
465      * @return the flags associated with this ticket, or {@code null}
466      * if destroyed.
467      */
468     public final boolean[]  getFlags() {
469         return (flags == null? null: flags.clone());
470     }
471 
472     /**
473      * Returns the time that the client was authenticated.
474      *
475      * @return the time that the client was authenticated
476      *         or {@code null} if the field is not set or
477      *         this ticket is destroyed.
478      */
479     public final java.util.Date getAuthTime() {
480         return (authTime == null) ? null : (Date)authTime.clone();
481     }
482 
483     /**
484      * Returns the start time for this ticket&#39;s validity period.
485      *
486      * @return the start time for this ticket&#39;s validity period
487      *         or {@code null} if the field is not set or
488      *         this ticket is destroyed.
489      */
490     public final java.util.Date getStartTime() {
491         return (startTime == null) ? null : (Date)startTime.clone();
492     }
493 
494     /**
495      * Returns the expiration time for this ticket&#39;s validity period.
496      *
497      * @return the expiration time for this ticket&#39;s validity period,
498      * or {@code null} if destroyed.
499      */
500     public final java.util.Date getEndTime() {
501         return (endTime == null) ? null : (Date) endTime.clone();
502     }
503 
504     /**
505      * Returns the latest expiration time for this ticket, including all
506      * renewals. This will return a null value for non-renewable tickets.
507      *
508      * @return the latest expiration time for this ticket, or {@code null}
509      * if destroyed.
510      */
511     public final java.util.Date getRenewTill() {
512         return (renewTill == null) ? null: (Date)renewTill.clone();
513     }
514 
515     /**
516      * Returns a list of addresses from where the ticket can be used.
517      *
518      * @return the list of addresses, or {@code null} if the field was not
519      * provided or this ticket is destroyed.
520      */
521     public final java.net.InetAddress[] getClientAddresses() {
522         return (clientAddresses == null) ? null: clientAddresses.clone();
523     }
524 
525     /**
526      * Returns an ASN.1 encoding of the entire ticket.
527      *
528      * @return an ASN.1 encoding of the entire ticket. A new byte
529      * array is returned each time this method is called.
530      * @throws IllegalStateException if this ticket is destroyed
531      */
532     public final byte[] getEncoded() {
533         if (destroyed) {
534             throw new IllegalStateException(&quot;This ticket is no longer valid&quot;);
535         }
536         return asn1Encoding.clone();
537     }
538 
539     /**
540      * Determines if this ticket is still current.
541      *
542      * @return true if this ticket is still current, or false if not current
543      * or destroyed.
544      */
545     public boolean isCurrent() {
546         return endTime == null? false: (System.currentTimeMillis() &lt;= endTime.getTime());
547     }
548 
549     /**
550      * Extends the validity period of this ticket. The ticket will contain
551      * a new session key if the refresh operation succeeds. The refresh
552      * operation will fail if the ticket is not renewable or the latest
553      * allowable renew time has passed. Any other error returned by the
554      * KDC will also cause this method to fail.
555      *
556      * Note: This method is not synchronized with the accessor
557      * methods of this object. Hence callers need to be aware of multiple
558      * threads that might access this and try to renew it at the same
559      * time.
560      *
561      * @throws IllegalStateException if this ticket is destroyed
562      * @throws RefreshFailedException if the ticket is not renewable, or
563      * the latest allowable renew time has passed, or the KDC returns some
564      * error.
565      *
566      * @see #isRenewable()
567      * @see #getRenewTill()
568      */
569     public void refresh() throws RefreshFailedException {
570 
571         if (destroyed) {
572             throw new RefreshFailedException(&quot;A destroyed ticket &quot;
573                     + &quot;cannot be renewd.&quot;);
574         }
575         if (!isRenewable()) {
576             throw new RefreshFailedException(&quot;This ticket is not renewable&quot;);
577         }
578 
579         if (getRenewTill() == null) {
580             // Renewable ticket without renew-till. Illegal and ignored.
581             return;
582         }
583 
584         if (System.currentTimeMillis() &gt; getRenewTill().getTime()) {
585             throw new RefreshFailedException(&quot;This ticket is past &quot;
586                                            + &quot;its last renewal time.&quot;);
587         }
588         Throwable e = null;
589         sun.security.krb5.Credentials krb5Creds = null;
590 
591         try {
592             krb5Creds = new sun.security.krb5.Credentials(asn1Encoding,
593                                                     client.getName(),
<a name="7" id="anc7"></a>

594                                                     server.getName(),
<a name="8" id="anc8"></a>

595                                                     sessionKey.getEncoded(),
596                                                     sessionKey.getKeyType(),
597                                                     flags,
598                                                     authTime,
599                                                     startTime,
600                                                     endTime,
601                                                     renewTill,
602                                                     clientAddresses);
603             krb5Creds = krb5Creds.renew();
604         } catch (sun.security.krb5.KrbException krbException) {
605             e = krbException;
606         } catch (java.io.IOException ioException) {
607             e = ioException;
608         }
609 
610         if (e != null) {
611             RefreshFailedException rfException
612                 = new RefreshFailedException(&quot;Failed to renew Kerberos Ticket &quot;
613                                              + &quot;for client &quot; + client
614                                              + &quot; and server &quot; + server
615                                              + &quot; - &quot; + e.getMessage());
616             rfException.initCause(e);
617             throw rfException;
618         }
619 
620         /*
621          * In case multiple threads try to refresh it at the same time.
622          */
623         synchronized (this) {
624             try {
625                 this.destroy();
626             } catch (DestroyFailedException dfException) {
627                 // Squelch it since we don&#39;t care about the old ticket.
628             }
629             init(krb5Creds.getEncoded(),
630                  new KerberosPrincipal(krb5Creds.getClient().getName()),
631                  new KerberosPrincipal(krb5Creds.getServer().getName(),
632                                         KerberosPrincipal.KRB_NT_SRV_INST),
633                  krb5Creds.getSessionKey().getBytes(),
634                  krb5Creds.getSessionKey().getEType(),
635                  krb5Creds.getFlags(),
636                  krb5Creds.getAuthTime(),
637                  krb5Creds.getStartTime(),
638                  krb5Creds.getEndTime(),
639                  krb5Creds.getRenewTill(),
640                  krb5Creds.getClientAddresses());
641             destroyed = false;
642         }
643     }
644 
645     /**
646      * Destroys the ticket and destroys any sensitive information stored in
647      * it.
648      */
649     public void destroy() throws DestroyFailedException {
650         if (!destroyed) {
651             Arrays.fill(asn1Encoding, (byte) 0);
652             client = null;
653             server = null;
654             sessionKey.destroy();
655             flags = null;
656             authTime = null;
657             startTime = null;
658             endTime = null;
659             renewTill = null;
660             clientAddresses = null;
661             destroyed = true;
662         }
663     }
664 
665     /**
666      * Determines if this ticket has been destroyed.
667      */
668     public boolean isDestroyed() {
669         return destroyed;
670     }
671 
672     /**
673      * Returns an informative textual representation of this {@code KerberosTicket}.
674      *
675      * @return an informative textual representation of this {@code KerberosTicket}.
676      */
677     public String toString() {
678         if (destroyed) {
679             return &quot;Destroyed KerberosTicket&quot;;
680         }
681         StringBuilder caddrString = new StringBuilder();
682         if (clientAddresses != null) {
683             for (int i = 0; i &lt; clientAddresses.length; i++) {
684                 caddrString.append(&quot;clientAddresses[&quot; + i + &quot;] = &quot; +
685                         clientAddresses[i].toString());
686             }
687         }
688         return (&quot;Ticket (hex) = &quot; + &quot;\n&quot; +
689                  (new HexDumpEncoder()).encodeBuffer(asn1Encoding) + &quot;\n&quot; +
690                 &quot;Client Principal = &quot; + client.toString() + &quot;\n&quot; +
691                 &quot;Server Principal = &quot; + server.toString() + &quot;\n&quot; +
692                 &quot;Session Key = &quot; + sessionKey.toString() + &quot;\n&quot; +
693                 &quot;Forwardable Ticket &quot; + flags[FORWARDABLE_TICKET_FLAG] + &quot;\n&quot; +
694                 &quot;Forwarded Ticket &quot; + flags[FORWARDED_TICKET_FLAG] + &quot;\n&quot; +
695                 &quot;Proxiable Ticket &quot; + flags[PROXIABLE_TICKET_FLAG] + &quot;\n&quot; +
696                 &quot;Proxy Ticket &quot; + flags[PROXY_TICKET_FLAG] + &quot;\n&quot; +
697                 &quot;Postdated Ticket &quot; + flags[POSTDATED_TICKET_FLAG] + &quot;\n&quot; +
698                 &quot;Renewable Ticket &quot; + flags[RENEWABLE_TICKET_FLAG] + &quot;\n&quot; +
699                 &quot;Initial Ticket &quot; + flags[INITIAL_TICKET_FLAG] + &quot;\n&quot; +
700                 &quot;Auth Time = &quot; + String.valueOf(authTime) + &quot;\n&quot; +
701                 &quot;Start Time = &quot; + String.valueOf(startTime) + &quot;\n&quot; +
702                 &quot;End Time = &quot; + endTime.toString() + &quot;\n&quot; +
703                 &quot;Renew Till = &quot; + String.valueOf(renewTill) + &quot;\n&quot; +
704                 &quot;Client Addresses &quot; +
705                 (clientAddresses == null ? &quot; Null &quot; : caddrString.toString() +
<a name="9" id="anc9"></a>
706                 &quot;\n&quot;));
707     }
708 
709     /**
710      * Returns a hash code for this {@code KerberosTicket}.
711      *
712      * @return a hash code for this {@code KerberosTicket}.
713      * @since 1.6
714      */
715     public int hashCode() {
716         int result = 17;
717         if (isDestroyed()) {
718             return result;
719         }
720         result = result * 37 + Arrays.hashCode(getEncoded());
721         result = result * 37 + endTime.hashCode();
722         result = result * 37 + client.hashCode();
723         result = result * 37 + server.hashCode();
724         result = result * 37 + sessionKey.hashCode();
725 
726         // authTime may be null
727         if (authTime != null) {
728             result = result * 37 + authTime.hashCode();
729         }
730 
731         // startTime may be null
732         if (startTime != null) {
733             result = result * 37 + startTime.hashCode();
734         }
735 
736         // renewTill may be null
737         if (renewTill != null) {
738             result = result * 37 + renewTill.hashCode();
739         }
740 
741         // clientAddress may be null, the array&#39;s hashCode is 0
742         result = result * 37 + Arrays.hashCode(clientAddresses);
<a name="10" id="anc10"></a>



743         return result * 37 + Arrays.hashCode(flags);
744     }
745 
746     /**
747      * Compares the specified object with this {@code KerberosTicket} for equality.
748      * Returns true if the given object is also a
749      * {@code KerberosTicket} and the two
750      * {@code KerberosTicket} instances are equivalent.
751      * A destroyed {@code KerberosTicket} object is only equal to itself.
752      *
753      * @param other the object to compare to
754      * @return true if the specified object is equal to this {@code KerberosTicket},
755      * false otherwise.
756      * @since 1.6
757      */
758     public boolean equals(Object other) {
759 
760         if (other == this) {
761             return true;
762         }
763 
764         if (! (other instanceof KerberosTicket)) {
765             return false;
766         }
767 
768         KerberosTicket otherTicket = ((KerberosTicket) other);
769         if (isDestroyed() || otherTicket.isDestroyed()) {
770             return false;
771         }
772 
773         if (!Arrays.equals(getEncoded(), otherTicket.getEncoded()) ||
774                 !endTime.equals(otherTicket.getEndTime()) ||
775                 !server.equals(otherTicket.getServer()) ||
776                 !client.equals(otherTicket.getClient()) ||
777                 !sessionKey.equals(otherTicket.sessionKey) ||
778                 !Arrays.equals(clientAddresses, otherTicket.getClientAddresses()) ||
779                 !Arrays.equals(flags, otherTicket.getFlags())) {
780             return false;
781         }
782 
783         // authTime may be null
784         if (authTime == null) {
785             if (otherTicket.getAuthTime() != null) {
786                 return false;
787             }
788         } else {
789             if (!authTime.equals(otherTicket.getAuthTime())) {
790                 return false;
791             }
792         }
793 
794         // startTime may be null
795         if (startTime == null) {
796             if (otherTicket.getStartTime() != null) {
797                 return false;
798             }
799         } else {
800             if (!startTime.equals(otherTicket.getStartTime())) {
801                 return false;
802             }
803         }
804 
805         if (renewTill == null) {
806             if (otherTicket.getRenewTill() != null) {
807                 return false;
808             }
809         } else {
810             if (!renewTill.equals(otherTicket.getRenewTill())) {
811                 return false;
812             }
813         }
814 
<a name="11" id="anc11"></a>



815         return true;
816     }
817 
818     private void readObject(ObjectInputStream s)
819             throws IOException, ClassNotFoundException {
820         s.defaultReadObject();
821         if (sessionKey == null) {
822            throw new InvalidObjectException(&quot;Session key cannot be null&quot;);
823         }
824         try {
825             init(asn1Encoding, client, server, sessionKey,
826                  flags, authTime, startTime, endTime,
827                  renewTill, clientAddresses);
828         } catch (IllegalArgumentException iae) {
829             throw (InvalidObjectException)
830                 new InvalidObjectException(iae.getMessage()).initCause(iae);
831         }
832     }
833 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.security.jgss/share/classes/sun/security/krb5/internal/ccache/CCacheInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../TicketFlags.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CCacheOutputStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.security.jgss/share/classes/sun/security/krb5/internal/ccache/CCacheInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
111     public PrincipalName readPrincipal(int version) throws IOException, RealmException {
112         int type, length, namelength, kret;
113         String[] pname = null;
114         String realm;
115         /* Read principal type */
116         if (version == KRB5_FCC_FVNO_1) {
117             type = KRB5_NT_UNKNOWN;
118         } else {
119             type = read(4);
120         }
121         length = readLength4();
122         List&lt;String&gt; result = new ArrayList&lt;String&gt;();
123         /*
124          * DCE includes the principal&#39;s realm in the count; the new format
125          * does not.
126          */
127         if (version == KRB5_FCC_FVNO_1)
128             length--;
129         for (int i = 0; i &lt;= length; i++) {
130             namelength = readLength4();
<span class="line-modified">131             byte[] bytes = IOUtils.readFully(this, namelength, true);</span>
132             result.add(new String(bytes));
133         }
134         if (result.isEmpty()) {
135             throw new IOException(&quot;No realm or principal&quot;);
136         }
137         if (isRealm(result.get(0))) {
138             realm = result.remove(0);
139             if (result.isEmpty()) {
140                 throw new IOException(&quot;No principal name components&quot;);
141             }
142             return new PrincipalName(
143                     type,
144                     result.toArray(new String[result.size()]),
145                     new Realm(realm));
146         }
147         try {
148             return new PrincipalName(
149                     type,
150                     result.toArray(new String[result.size()]),
151                     Realm.getDefault());
</pre>
<hr />
<pre>
169         }
170         StringTokenizer st = new StringTokenizer(str, &quot;.&quot;);
171         String s;
172         while (st.hasMoreTokens()) {
173             s = st.nextToken();
174             for (int i = 0; i &lt; s.length(); i++) {
175                 if (s.charAt(i) &gt;= 141) {
176                     return false;
177                 }
178             }
179         }
180         return true;
181     }
182 
183     EncryptionKey readKey(int version) throws IOException {
184         int keyType, keyLen;
185         keyType = read(2);
186         if (version == KRB5_FCC_FVNO_3)
187             read(2); /* keytype recorded twice in fvno 3 */
188         keyLen = readLength4();
<span class="line-modified">189         byte[] bytes = IOUtils.readFully(this, keyLen, true);</span>
190         return new EncryptionKey(bytes, keyType, version);
191     }
192 
193     long[] readTimes() throws IOException {
194         long[] times = new long[4];
195         times[0] = (long)read(4) * 1000;
196         times[1] = (long)read(4) * 1000;
197         times[2] = (long)read(4) * 1000;
198         times[3] = (long)read(4) * 1000;
199         return times;
200     }
201 
202     boolean readskey() throws IOException {
203         if (read() == 0) {
204             return false;
205         }
206         else return true;
207     }
208 
209     HostAddress[] readAddr() throws IOException, KrbApErrException {
</pre>
<hr />
<pre>
222                 }
223                 byte[] result = new byte[addrLength];
224                 for (int j = 0; j &lt; addrLength; j++)
225                     result[j] = (byte)read(1);
226                 addrs.add(new HostAddress(addrType, result));
227             }
228             return addrs.toArray(new HostAddress[addrs.size()]);
229         }
230         return null;
231     }
232 
233     AuthorizationDataEntry[] readAuth() throws IOException {
234         int num, adtype, adlength;
235         num = readLength4();
236         if (num &gt; 0) {
237             List&lt;AuthorizationDataEntry&gt; auData = new ArrayList&lt;&gt;();
238             byte[] data = null;
239             for (int i = 0; i &lt; num; i++) {
240                 adtype = read(2);
241                 adlength = readLength4();
<span class="line-modified">242                 data = IOUtils.readFully(this, adlength, true);</span>
243                 auData.add(new AuthorizationDataEntry(adtype, data));
244             }
245             return auData.toArray(new AuthorizationDataEntry[auData.size()]);
246         }
247         else return null;
248     }
249 
250     byte[] readData() throws IOException {
251         int length;
252         length = readLength4();
253         if (length == 0) {
254             return null;
255         } else {
<span class="line-modified">256             return IOUtils.readFully(this, length, true);</span>
257         }
258     }
259 
260     boolean[] readFlags() throws IOException {
261         boolean[] flags = new boolean[Krb5.TKT_OPTS_MAX+1];
262         int ticketFlags;
263         ticketFlags = read(4);
264         if ((ticketFlags &amp; 0x40000000) == TKT_FLG_FORWARDABLE)
265         flags[1] = true;
266         if ((ticketFlags &amp; 0x20000000) == TKT_FLG_FORWARDED)
267         flags[2] = true;
268         if ((ticketFlags &amp; 0x10000000) == TKT_FLG_PROXIABLE)
269         flags[3] = true;
270         if ((ticketFlags &amp; 0x08000000) == TKT_FLG_PROXY)
271         flags[4] = true;
272         if ((ticketFlags &amp; 0x04000000) == TKT_FLG_MAY_POSTDATE)
273         flags[5] = true;
274         if ((ticketFlags &amp; 0x02000000) == TKT_FLG_POSTDATED)
275         flags[6] = true;
276         if ((ticketFlags &amp; 0x01000000) == TKT_FLG_INVALID)
</pre>
<hr />
<pre>
308             }
309             if (flags[8] == true) {
310                 msg += &quot; RENEWABLE;&quot;;
311             }
312 
313             if (flags[9] == true) {
314                 msg += &quot; INITIAL;&quot;;
315             }
316             if (flags[10] == true) {
317                 msg += &quot; PRE_AUTH;&quot;;
318             }
319             if (flags[11] == true) {
320                 msg += &quot; HW_AUTH;&quot;;
321             }
322             System.out.println(msg);
323         }
324         return flags;
325     }
326 
327     /**
<span class="line-modified">328      * Reads the next cred in stream.</span>
<span class="line-modified">329      * @return the next cred, null if ticket or second_ticket unparseable.</span>
330      *
<span class="line-modified">331      * Note: MIT krb5 1.8.1 might generate a config entry with server principal</span>
<span class="line-modified">332      * X-CACHECONF:/krb5_ccache_conf_data/fast_avail/krbtgt/REALM@REALM. The</span>
<span class="line-removed">333      * entry is used by KDC to inform the client that it support certain</span>
<span class="line-removed">334      * features. Its ticket is not a valid krb5 ticket and thus this method</span>
<span class="line-removed">335      * returns null.</span>
336      */
<span class="line-modified">337     Credentials readCred(int version) throws IOException,RealmException, KrbApErrException, Asn1Exception {</span>
338         PrincipalName cpname = null;
339         try {
340             cpname = readPrincipal(version);
341         } catch (Exception e) {
342             // Do not return here. All data for this cred should be fully
343             // consumed so that we can read the next one.
344         }
345         if (DEBUG) {
346             System.out.println(&quot;&gt;&gt;&gt;DEBUG &lt;CCacheInputStream&gt;  client principal is &quot; + cpname);
347         }
348         PrincipalName spname = null;
349         try {
350             spname = readPrincipal(version);
351         } catch (Exception e) {
352             // same as above
353         }
354         if (DEBUG) {
355             System.out.println(&quot;&gt;&gt;&gt;DEBUG &lt;CCacheInputStream&gt; server principal is &quot; + spname);
356         }
357         EncryptionKey key = readKey(version);
</pre>
<hr />
<pre>
379         TicketFlags tFlags = new TicketFlags(flags);
380         HostAddress[] addr = readAddr();
381         HostAddresses addrs = null;
382         if (addr != null) {
383             addrs = new HostAddresses(addr);
384         }
385         AuthorizationDataEntry[] auDataEntry = readAuth();
386         AuthorizationData auData = null;
387         if (auDataEntry != null) {
388             auData = new AuthorizationData(auDataEntry);
389         }
390         byte[] ticketData = readData();
391         byte[] ticketData2 = readData();
392 
393         // Skip this cred if either cpname or spname isn&#39;t created.
394         if (cpname == null || spname == null) {
395             return null;
396         }
397 
398         try {








399             return new Credentials(cpname, spname, key, authtime, starttime,
<span class="line-modified">400                 endtime, renewTill, skey, tFlags,</span>
<span class="line-modified">401                 addrs, auData,</span>
<span class="line-modified">402                 ticketData != null ? new Ticket(ticketData) : null,</span>
<span class="line-modified">403                 ticketData2 != null ? new Ticket(ticketData2) : null);</span>
404         } catch (Exception e) {     // If any of new Ticket(*) fails.



405             return null;
406         }
407     }
408 }
</pre>
</td>
<td>
<hr />
<pre>
111     public PrincipalName readPrincipal(int version) throws IOException, RealmException {
112         int type, length, namelength, kret;
113         String[] pname = null;
114         String realm;
115         /* Read principal type */
116         if (version == KRB5_FCC_FVNO_1) {
117             type = KRB5_NT_UNKNOWN;
118         } else {
119             type = read(4);
120         }
121         length = readLength4();
122         List&lt;String&gt; result = new ArrayList&lt;String&gt;();
123         /*
124          * DCE includes the principal&#39;s realm in the count; the new format
125          * does not.
126          */
127         if (version == KRB5_FCC_FVNO_1)
128             length--;
129         for (int i = 0; i &lt;= length; i++) {
130             namelength = readLength4();
<span class="line-modified">131             byte[] bytes = IOUtils.readExactlyNBytes(this, namelength);</span>
132             result.add(new String(bytes));
133         }
134         if (result.isEmpty()) {
135             throw new IOException(&quot;No realm or principal&quot;);
136         }
137         if (isRealm(result.get(0))) {
138             realm = result.remove(0);
139             if (result.isEmpty()) {
140                 throw new IOException(&quot;No principal name components&quot;);
141             }
142             return new PrincipalName(
143                     type,
144                     result.toArray(new String[result.size()]),
145                     new Realm(realm));
146         }
147         try {
148             return new PrincipalName(
149                     type,
150                     result.toArray(new String[result.size()]),
151                     Realm.getDefault());
</pre>
<hr />
<pre>
169         }
170         StringTokenizer st = new StringTokenizer(str, &quot;.&quot;);
171         String s;
172         while (st.hasMoreTokens()) {
173             s = st.nextToken();
174             for (int i = 0; i &lt; s.length(); i++) {
175                 if (s.charAt(i) &gt;= 141) {
176                     return false;
177                 }
178             }
179         }
180         return true;
181     }
182 
183     EncryptionKey readKey(int version) throws IOException {
184         int keyType, keyLen;
185         keyType = read(2);
186         if (version == KRB5_FCC_FVNO_3)
187             read(2); /* keytype recorded twice in fvno 3 */
188         keyLen = readLength4();
<span class="line-modified">189         byte[] bytes = IOUtils.readExactlyNBytes(this, keyLen);</span>
190         return new EncryptionKey(bytes, keyType, version);
191     }
192 
193     long[] readTimes() throws IOException {
194         long[] times = new long[4];
195         times[0] = (long)read(4) * 1000;
196         times[1] = (long)read(4) * 1000;
197         times[2] = (long)read(4) * 1000;
198         times[3] = (long)read(4) * 1000;
199         return times;
200     }
201 
202     boolean readskey() throws IOException {
203         if (read() == 0) {
204             return false;
205         }
206         else return true;
207     }
208 
209     HostAddress[] readAddr() throws IOException, KrbApErrException {
</pre>
<hr />
<pre>
222                 }
223                 byte[] result = new byte[addrLength];
224                 for (int j = 0; j &lt; addrLength; j++)
225                     result[j] = (byte)read(1);
226                 addrs.add(new HostAddress(addrType, result));
227             }
228             return addrs.toArray(new HostAddress[addrs.size()]);
229         }
230         return null;
231     }
232 
233     AuthorizationDataEntry[] readAuth() throws IOException {
234         int num, adtype, adlength;
235         num = readLength4();
236         if (num &gt; 0) {
237             List&lt;AuthorizationDataEntry&gt; auData = new ArrayList&lt;&gt;();
238             byte[] data = null;
239             for (int i = 0; i &lt; num; i++) {
240                 adtype = read(2);
241                 adlength = readLength4();
<span class="line-modified">242                 data = IOUtils.readExactlyNBytes(this, adlength);</span>
243                 auData.add(new AuthorizationDataEntry(adtype, data));
244             }
245             return auData.toArray(new AuthorizationDataEntry[auData.size()]);
246         }
247         else return null;
248     }
249 
250     byte[] readData() throws IOException {
251         int length;
252         length = readLength4();
253         if (length == 0) {
254             return null;
255         } else {
<span class="line-modified">256             return IOUtils.readExactlyNBytes(this, length);</span>
257         }
258     }
259 
260     boolean[] readFlags() throws IOException {
261         boolean[] flags = new boolean[Krb5.TKT_OPTS_MAX+1];
262         int ticketFlags;
263         ticketFlags = read(4);
264         if ((ticketFlags &amp; 0x40000000) == TKT_FLG_FORWARDABLE)
265         flags[1] = true;
266         if ((ticketFlags &amp; 0x20000000) == TKT_FLG_FORWARDED)
267         flags[2] = true;
268         if ((ticketFlags &amp; 0x10000000) == TKT_FLG_PROXIABLE)
269         flags[3] = true;
270         if ((ticketFlags &amp; 0x08000000) == TKT_FLG_PROXY)
271         flags[4] = true;
272         if ((ticketFlags &amp; 0x04000000) == TKT_FLG_MAY_POSTDATE)
273         flags[5] = true;
274         if ((ticketFlags &amp; 0x02000000) == TKT_FLG_POSTDATED)
275         flags[6] = true;
276         if ((ticketFlags &amp; 0x01000000) == TKT_FLG_INVALID)
</pre>
<hr />
<pre>
308             }
309             if (flags[8] == true) {
310                 msg += &quot; RENEWABLE;&quot;;
311             }
312 
313             if (flags[9] == true) {
314                 msg += &quot; INITIAL;&quot;;
315             }
316             if (flags[10] == true) {
317                 msg += &quot; PRE_AUTH;&quot;;
318             }
319             if (flags[11] == true) {
320                 msg += &quot; HW_AUTH;&quot;;
321             }
322             System.out.println(msg);
323         }
324         return flags;
325     }
326 
327     /**
<span class="line-modified">328      * Reads the next cred or config entry in stream.</span>
<span class="line-modified">329      * @return the next cred or config entry, null if data unparseable.</span>
330      *
<span class="line-modified">331      * When data is unparseable, this method makes sure the correct number of</span>
<span class="line-modified">332      * bytes are consumed so it&#39;s safe to start reading the next element.</span>



333      */
<span class="line-modified">334     Object readCred(int version) throws IOException,RealmException, KrbApErrException, Asn1Exception {</span>
335         PrincipalName cpname = null;
336         try {
337             cpname = readPrincipal(version);
338         } catch (Exception e) {
339             // Do not return here. All data for this cred should be fully
340             // consumed so that we can read the next one.
341         }
342         if (DEBUG) {
343             System.out.println(&quot;&gt;&gt;&gt;DEBUG &lt;CCacheInputStream&gt;  client principal is &quot; + cpname);
344         }
345         PrincipalName spname = null;
346         try {
347             spname = readPrincipal(version);
348         } catch (Exception e) {
349             // same as above
350         }
351         if (DEBUG) {
352             System.out.println(&quot;&gt;&gt;&gt;DEBUG &lt;CCacheInputStream&gt; server principal is &quot; + spname);
353         }
354         EncryptionKey key = readKey(version);
</pre>
<hr />
<pre>
376         TicketFlags tFlags = new TicketFlags(flags);
377         HostAddress[] addr = readAddr();
378         HostAddresses addrs = null;
379         if (addr != null) {
380             addrs = new HostAddresses(addr);
381         }
382         AuthorizationDataEntry[] auDataEntry = readAuth();
383         AuthorizationData auData = null;
384         if (auDataEntry != null) {
385             auData = new AuthorizationData(auDataEntry);
386         }
387         byte[] ticketData = readData();
388         byte[] ticketData2 = readData();
389 
390         // Skip this cred if either cpname or spname isn&#39;t created.
391         if (cpname == null || spname == null) {
392             return null;
393         }
394 
395         try {
<span class="line-added">396             if (spname.getRealmString().equals(&quot;X-CACHECONF:&quot;)) {</span>
<span class="line-added">397                 String[] nameParts = spname.getNameStrings();</span>
<span class="line-added">398                 if (nameParts[0].equals(&quot;krb5_ccache_conf_data&quot;)) {</span>
<span class="line-added">399                     return new CredentialsCache.ConfigEntry(nameParts[1],</span>
<span class="line-added">400                             nameParts.length &gt; 2 ? new PrincipalName(nameParts[2]) : null,</span>
<span class="line-added">401                             ticketData);</span>
<span class="line-added">402                 }</span>
<span class="line-added">403             }</span>
404             return new Credentials(cpname, spname, key, authtime, starttime,
<span class="line-modified">405                     endtime, renewTill, skey, tFlags,</span>
<span class="line-modified">406                     addrs, auData,</span>
<span class="line-modified">407                     ticketData != null ? new Ticket(ticketData) : null,</span>
<span class="line-modified">408                     ticketData2 != null ? new Ticket(ticketData2) : null);</span>
409         } catch (Exception e) {     // If any of new Ticket(*) fails.
<span class="line-added">410             if (DEBUG) {</span>
<span class="line-added">411                 e.printStackTrace(System.out);</span>
<span class="line-added">412             }</span>
413             return null;
414         }
415     }
416 }
</pre>
</td>
</tr>
</table>
<center><a href="../TicketFlags.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CCacheOutputStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
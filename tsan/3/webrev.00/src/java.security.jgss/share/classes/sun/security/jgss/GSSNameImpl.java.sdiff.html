<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../org/ietf/jgss/package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="krb5/Krb5Context.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.security.jgss/share/classes/sun/security/jgss/GSSNameImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.jgss;
 27 
 28 import org.ietf.jgss.*;
 29 import sun.security.jgss.spi.*;
 30 import java.util.Set;
 31 import java.util.HashMap;
 32 import java.util.HashSet;
 33 import java.util.Arrays;
 34 import java.io.IOException;
<span class="line-removed"> 35 import java.io.UnsupportedEncodingException;</span>
 36 import sun.security.util.ObjectIdentifier;
 37 import sun.security.util.DerInputStream;
 38 import sun.security.util.DerOutputStream;
 39 


 40 /**
 41  * This is the implementation class for GSSName. Conceptually the
 42  * GSSName is a container with mechanism specific name elements. Each
 43  * name element is a representation of how that particular mechanism
 44  * would canonicalize this principal.
 45  *
 46  * Generally a GSSName is created by an application when it supplies
 47  * a sequence of bytes and a nametype that helps each mechanism
 48  * decide how to interpret those bytes.
 49  *
 50  * It is not necessary to create name elements for each available
 51  * mechanism at the time the application creates the GSSName. This
 52  * implementation does this lazily, as and when name elements for
 53  * mechanisms are required to be handed out. (Generally, other GSS
 54  * classes like GSSContext and GSSCredential request specific
 55  * elements depending on the mechanisms that they are dealing with.)
 56  * Assume that getting a mechanism to parse the applciation specified
 57  * bytes is an expensive call.
 58  *
 59  * When a GSSName is canonicalized wrt some mechanism, it is supposed
</pre>
<hr />
<pre>
210         }
211 
212         /*
213          *  At this point the GSSNameImpl has the following set:
214          *   appNameStr or appNameBytes
215          *   appNameType (could be null)
216          *   printableName
217          *   printableNameType
218          *   mechElement (which also exists in the hashmap of elements)
219          */
220     }
221 
222     private void importName(GSSManagerImpl gssManager,
223                             Object appName)
224         throws GSSException {
225 
226         int pos = 0;
227         byte[] bytes = null;
228 
229         if (appName instanceof String) {
<span class="line-modified">230             try {</span>
<span class="line-modified">231                 bytes = ((String) appName).getBytes(&quot;UTF-8&quot;);</span>
<span class="line-removed">232             } catch (UnsupportedEncodingException e) {</span>
<span class="line-removed">233                 // Won&#39;t happen</span>
<span class="line-removed">234             }</span>
<span class="line-removed">235         } else</span>
236             bytes = (byte[]) appName;

237 
238         if ((bytes[pos++] != 0x04) ||
239             (bytes[pos++] != 0x01))
240             throw new GSSExceptionImpl(GSSException.BAD_NAME,
241                                    &quot;Exported name token id is corrupted!&quot;);
242 
243         int oidLen  = (((0xFF &amp; bytes[pos++]) &lt;&lt; 8) |
244                        (0xFF &amp; bytes[pos++]));
245         ObjectIdentifier temp = null;
246         try {
247             DerInputStream din = new DerInputStream(bytes, pos,
248                                                     oidLen);
249             temp = new ObjectIdentifier(din);
250         } catch (IOException e) {
251             throw new GSSExceptionImpl(GSSException.BAD_NAME,
252                        &quot;Exported name Object identifier is corrupted!&quot;);
253         }
254         Oid oid = new Oid(temp.toString());
255         pos += oidLen;
256         int mechPortionLen = (((0xFF &amp; bytes[pos++]) &lt;&lt; 24) |
</pre>
<hr />
<pre>
303 
304         /*
305          * XXX If they are not of the same mechanism type, convert both to
306          * Kerberos since it is guaranteed to be present.
307          */
308         if ((myElement == null) &amp;&amp; (element != null)) {
309             myElement = this.getElement(element.getMechanism());
310         } else if ((myElement != null) &amp;&amp; (element == null)) {
311             element = that.getElement(myElement.getMechanism());
312         }
313 
314         if (myElement != null &amp;&amp; element != null) {
315             return myElement.equals(element);
316         }
317 
318         if ((this.appNameType != null) &amp;&amp;
319             (that.appNameType != null)) {
320             if (!this.appNameType.equals(that.appNameType)) {
321                 return false;
322             }
<span class="line-modified">323             byte[] myBytes = null;</span>
<span class="line-removed">324             byte[] bytes = null;</span>
<span class="line-removed">325             try {</span>
<span class="line-removed">326                 myBytes =</span>
327                     (this.appNameStr != null ?
<span class="line-modified">328                      this.appNameStr.getBytes(&quot;UTF-8&quot;) :</span>
329                      this.appNameBytes);
<span class="line-modified">330                 bytes =</span>
331                     (that.appNameStr != null ?
<span class="line-modified">332                      that.appNameStr.getBytes(&quot;UTF-8&quot;) :</span>
333                      that.appNameBytes);
<span class="line-removed">334             } catch (UnsupportedEncodingException e) {</span>
<span class="line-removed">335                 // Won&#39;t happen</span>
<span class="line-removed">336             }</span>
<span class="line-removed">337 </span>
338             return Arrays.equals(myBytes, bytes);
339         }
340 
341         return false;
342 
343     }
344 
345     /**
346      * Returns a hashcode value for this GSSName.
347      *
348      * @return a hashCode value
349      */
350     public int hashCode() {
351         /*
352          * XXX
353          * In order to get this to work reliably and properly(!), obtain a
354          * Kerberos name element for the name and then call hashCode on its
355          * string representation. But this cannot be done if the nametype
356          * is not one of those supported by the Kerberos provider and hence
357          * this name cannot be imported by Kerberos. In that case return a
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.jgss;
 27 
 28 import org.ietf.jgss.*;
 29 import sun.security.jgss.spi.*;
 30 import java.util.Set;
 31 import java.util.HashMap;
 32 import java.util.HashSet;
 33 import java.util.Arrays;
 34 import java.io.IOException;

 35 import sun.security.util.ObjectIdentifier;
 36 import sun.security.util.DerInputStream;
 37 import sun.security.util.DerOutputStream;
 38 
<span class="line-added"> 39 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added"> 40 </span>
 41 /**
 42  * This is the implementation class for GSSName. Conceptually the
 43  * GSSName is a container with mechanism specific name elements. Each
 44  * name element is a representation of how that particular mechanism
 45  * would canonicalize this principal.
 46  *
 47  * Generally a GSSName is created by an application when it supplies
 48  * a sequence of bytes and a nametype that helps each mechanism
 49  * decide how to interpret those bytes.
 50  *
 51  * It is not necessary to create name elements for each available
 52  * mechanism at the time the application creates the GSSName. This
 53  * implementation does this lazily, as and when name elements for
 54  * mechanisms are required to be handed out. (Generally, other GSS
 55  * classes like GSSContext and GSSCredential request specific
 56  * elements depending on the mechanisms that they are dealing with.)
 57  * Assume that getting a mechanism to parse the applciation specified
 58  * bytes is an expensive call.
 59  *
 60  * When a GSSName is canonicalized wrt some mechanism, it is supposed
</pre>
<hr />
<pre>
211         }
212 
213         /*
214          *  At this point the GSSNameImpl has the following set:
215          *   appNameStr or appNameBytes
216          *   appNameType (could be null)
217          *   printableName
218          *   printableNameType
219          *   mechElement (which also exists in the hashmap of elements)
220          */
221     }
222 
223     private void importName(GSSManagerImpl gssManager,
224                             Object appName)
225         throws GSSException {
226 
227         int pos = 0;
228         byte[] bytes = null;
229 
230         if (appName instanceof String) {
<span class="line-modified">231             bytes = ((String) appName).getBytes(UTF_8);</span>
<span class="line-modified">232         } else {</span>




233             bytes = (byte[]) appName;
<span class="line-added">234         }</span>
235 
236         if ((bytes[pos++] != 0x04) ||
237             (bytes[pos++] != 0x01))
238             throw new GSSExceptionImpl(GSSException.BAD_NAME,
239                                    &quot;Exported name token id is corrupted!&quot;);
240 
241         int oidLen  = (((0xFF &amp; bytes[pos++]) &lt;&lt; 8) |
242                        (0xFF &amp; bytes[pos++]));
243         ObjectIdentifier temp = null;
244         try {
245             DerInputStream din = new DerInputStream(bytes, pos,
246                                                     oidLen);
247             temp = new ObjectIdentifier(din);
248         } catch (IOException e) {
249             throw new GSSExceptionImpl(GSSException.BAD_NAME,
250                        &quot;Exported name Object identifier is corrupted!&quot;);
251         }
252         Oid oid = new Oid(temp.toString());
253         pos += oidLen;
254         int mechPortionLen = (((0xFF &amp; bytes[pos++]) &lt;&lt; 24) |
</pre>
<hr />
<pre>
301 
302         /*
303          * XXX If they are not of the same mechanism type, convert both to
304          * Kerberos since it is guaranteed to be present.
305          */
306         if ((myElement == null) &amp;&amp; (element != null)) {
307             myElement = this.getElement(element.getMechanism());
308         } else if ((myElement != null) &amp;&amp; (element == null)) {
309             element = that.getElement(myElement.getMechanism());
310         }
311 
312         if (myElement != null &amp;&amp; element != null) {
313             return myElement.equals(element);
314         }
315 
316         if ((this.appNameType != null) &amp;&amp;
317             (that.appNameType != null)) {
318             if (!this.appNameType.equals(that.appNameType)) {
319                 return false;
320             }
<span class="line-modified">321             byte[] myBytes =</span>



322                     (this.appNameStr != null ?
<span class="line-modified">323                      this.appNameStr.getBytes(UTF_8) :</span>
324                      this.appNameBytes);
<span class="line-modified">325             byte[] bytes =</span>
326                     (that.appNameStr != null ?
<span class="line-modified">327                      that.appNameStr.getBytes(UTF_8) :</span>
328                      that.appNameBytes);




329             return Arrays.equals(myBytes, bytes);
330         }
331 
332         return false;
333 
334     }
335 
336     /**
337      * Returns a hashcode value for this GSSName.
338      *
339      * @return a hashCode value
340      */
341     public int hashCode() {
342         /*
343          * XXX
344          * In order to get this to work reliably and properly(!), obtain a
345          * Kerberos name element for the name and then call hashCode on its
346          * string representation. But this cannot be done if the nametype
347          * is not one of those supported by the Kerberos provider and hence
348          * this name cannot be imported by Kerberos. In that case return a
</pre>
</td>
</tr>
</table>
<center><a href="../../../org/ietf/jgss/package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="krb5/Krb5Context.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
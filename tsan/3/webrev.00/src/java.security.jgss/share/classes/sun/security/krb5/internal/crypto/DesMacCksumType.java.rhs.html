<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.security.jgss/share/classes/sun/security/krb5/internal/crypto/DesMacCksumType.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 27  *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 28  */
 29 
 30 package sun.security.krb5.internal.crypto;
 31 
 32 import sun.security.krb5.Checksum;
 33 import sun.security.krb5.Confounder;
 34 import sun.security.krb5.KrbCryptoException;
 35 import sun.security.krb5.internal.*;
 36 import javax.crypto.spec.DESKeySpec;
 37 import java.security.InvalidKeyException;
 38 
 39 public class DesMacCksumType extends CksumType {
 40 
 41     public DesMacCksumType() {
 42     }
 43 
 44     public int confounderSize() {
 45         return 8;
 46     }
 47 
 48     public int cksumType() {
 49         return Checksum.CKSUMTYPE_DES_MAC;
 50     }
 51 
<a name="1" id="anc1"></a><span class="line-modified"> 52     public boolean isKeyed() {</span>
 53         return true;
 54     }
 55 
 56     public int cksumSize() {
 57         return 16;
 58     }
 59 
 60     public int keyType() {
 61         return Krb5.KEYTYPE_DES;
 62     }
 63 
 64     public int keySize() {
 65         return 8;
 66     }
 67 
<a name="2" id="anc2"></a>



 68     /**
 69      * Calculates keyed checksum.
 70      * @param data the data used to generate the checksum.
 71      * @param size length of the data.
 72      * @param key the key used to encrypt the checksum.
 73      * @return keyed checksum.
 74      *
 75      * @modified by Yanni Zhang, 12/08/99.
 76      */
<a name="3" id="anc3"></a><span class="line-modified"> 77     public byte[] calculateChecksum(byte[] data, int size, byte[] key,</span>
 78         int usage) throws KrbCryptoException {
 79         byte[] new_data = new byte[size + confounderSize()];
 80         byte[] conf = Confounder.bytes(confounderSize());
 81         System.arraycopy(conf, 0, new_data, 0, confounderSize());
 82         System.arraycopy(data, 0, new_data, confounderSize(), size);
 83 
 84         //check for weak keys
 85         try {
 86             if (DESKeySpec.isWeak(key, 0)) {
 87                 key[7] = (byte)(key[7] ^ 0xF0);
 88             }
 89         } catch (InvalidKeyException ex) {
 90             // swallow, since it should never happen
 91         }
 92         byte[] residue_ivec = new byte[key.length];
 93         byte[] residue = Des.des_cksum(residue_ivec, new_data, key);
 94         byte[] cksum = new byte[cksumSize()];
 95         System.arraycopy(conf, 0, cksum, 0, confounderSize());
 96         System.arraycopy(residue, 0, cksum, confounderSize(),
 97                          cksumSize() - confounderSize());
 98 
 99         byte[] new_key = new byte[keySize()];
100         System.arraycopy(key, 0, new_key, 0, key.length);
101         for (int i = 0; i &lt; new_key.length; i++)
102         new_key[i] = (byte)(new_key[i] ^ 0xf0);
103         //check for weak keys
104         try {
105             if (DESKeySpec.isWeak(new_key, 0)) {
106                 new_key[7] = (byte)(new_key[7] ^ 0xF0);
107             }
108         } catch (InvalidKeyException ex) {
109             // swallow, since it should never happen
110         }
111         byte[] ivec = new byte[new_key.length];
112 
113         //des-cbc encrypt
114         byte[] enc_cksum = new byte[cksum.length];
115         Des.cbc_encrypt(cksum, enc_cksum, new_key, ivec, true);
116         return enc_cksum;
117     }
118 
119     /**
120      * Verifies keyed checksum.
121      * @param data the data.
122      * @param size the length of data.
123      * @param key the key used to encrypt the checksum.
124      * @param checksum the checksum.
125      * @return true if verification is successful.
126      *
127      * @modified by Yanni Zhang, 12/08/99.
128      */
<a name="4" id="anc4"></a><span class="line-modified">129     public boolean verifyChecksum(byte[] data, int size,</span>
130         byte[] key, byte[] checksum, int usage) throws KrbCryptoException {
131         byte[] cksum = decryptKeyedChecksum(checksum, key);
132 
133         byte[] new_data = new byte[size + confounderSize()];
134         System.arraycopy(cksum, 0, new_data, 0, confounderSize());
135         System.arraycopy(data, 0, new_data, confounderSize(), size);
136 
137         //check for weak keys
138         try {
139             if (DESKeySpec.isWeak(key, 0)) {
140                 key[7] = (byte)(key[7] ^ 0xF0);
141             }
142         } catch (InvalidKeyException ex) {
143             // swallow, since it should never happen
144         }
145         byte[] ivec = new byte[key.length];
146         byte[] new_cksum = Des.des_cksum(ivec, new_data, key);
147         byte[] orig_cksum = new byte[cksumSize() - confounderSize()];
148         System.arraycopy(cksum,  confounderSize(), orig_cksum, 0,
149                          cksumSize() - confounderSize());
150         return isChecksumEqual(orig_cksum, new_cksum);
151     }
152 
153     /**
154      * Decrypts keyed checksum.
155      * @param enc_cksum the buffer for encrypted checksum.
156      * @param key the key.
157      * @return the checksum.
158      *
159      * @modified by Yanni Zhang, 12/08/99.
160      */
161     private byte[] decryptKeyedChecksum(byte[] enc_cksum, byte[] key) throws KrbCryptoException {
162         byte[] new_key = new byte[keySize()];
163         System.arraycopy(key, 0, new_key, 0, key.length);
164         for (int i = 0; i &lt; new_key.length; i++)
165         new_key[i] = (byte)(new_key[i] ^ 0xf0);
166         //check for weak keys
167         try {
168             if (DESKeySpec.isWeak(new_key, 0)) {
169                 new_key[7] = (byte)(new_key[7] ^ 0xF0);
170             }
171         } catch (InvalidKeyException ex) {
172             // swallow, since it should never happen
173         }
174         byte[] ivec = new byte[new_key.length];
175         byte[] cksum = new byte[enc_cksum.length];
176         Des.cbc_encrypt(enc_cksum, cksum, new_key, ivec, false);
177         return cksum;
178     }
179 
180 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
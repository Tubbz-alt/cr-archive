<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.security.jgss/share/classes/sun/security/krb5/internal/crypto/dk/AesSha2DkCrypto.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  */
 28 
 29 package sun.security.krb5.internal.crypto.dk;
 30 
 31 import javax.crypto.Cipher;
 32 import javax.crypto.Mac;
 33 import javax.crypto.SecretKeyFactory;
 34 import javax.crypto.SecretKey;
 35 import javax.crypto.spec.SecretKeySpec;
 36 import javax.crypto.spec.IvParameterSpec;
 37 import javax.crypto.spec.PBEKeySpec;
 38 import java.security.GeneralSecurityException;
 39 import sun.security.krb5.KrbCryptoException;
 40 import sun.security.krb5.Confounder;
 41 import sun.security.krb5.internal.crypto.KeyUsage;
 42 import java.util.Arrays;
 43 
 44 /**
 45  * This class provides the implementation of AES Encryption with
 46  * HMAC-SHA2 for Kerberos 5
 47  * https://tools.ietf.org/html/rfc8009
 48  *
 49  * Algorithm profile described in [KCRYPTO]:
 50  * +--------------------------------------------------------------------+
 51  * |               protocol key format          128- or 256-bit string  |
 52  * |                                                                    |
 53  * |            string-to-key function          PBKDF2+DK with variable |
 54  * |                                          iteration count (see      |
 55  * |                                          above)                    |
 56  * |                                                                    |
 57  * |  default string-to-key parameters          00 00 80 00             |
 58  * |                                                                    |
 59  * |        key-generation seed length          key size                |
 60  * |                                                                    |
 61  * |            random-to-key function          identity function       |
 62  * |                                                                    |
 63  * |                  hash function, H          SHA-256 / SHA-384       |
 64  * |                                                                    |
 65  * |               HMAC output size, h          16/24 octets            |
 66  * |                                                                    |
 67  * |             message block size, m          1 octet                 |
 68  * |                                                                    |
 69  * |  encryption/decryption functions,          AES in CBC-CTS mode     |
 70  * |  E and D                                 (cipher block size 16     |
 71  * |                                          octets), with next to     |
 72  * |                                          last block as CBC-style   |
 73  * |                                          ivec                      |
 74  * +--------------------------------------------------------------------+
 75  *
 76  * Supports aes128-cts-hmac-sha256-128 and aes256-cts-hmac-sha384-192
 77  */
 78 
 79 public class AesSha2DkCrypto extends DkCrypto {
 80 
 81     private static final boolean debug = false;
 82 
 83     private static final int BLOCK_SIZE = 16;
 84     private static final int DEFAULT_ITERATION_COUNT = 32768;
 85     private static final byte[] ZERO_IV = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0,
 86                                                        0, 0, 0, 0, 0, 0, 0, 0 };
 87 
 88     private static final byte[] ETYPE_NAME_128 =
 89             &quot;aes128-cts-hmac-sha256-128&quot;.getBytes();
 90     private static final byte[] ETYPE_NAME_256 =
 91             &quot;aes256-cts-hmac-sha384-192&quot;.getBytes();
 92 
 93     private final int hashSize;
 94     private final int keyLength;
 95 
 96     public AesSha2DkCrypto(int length) {
 97         keyLength = length;
 98         hashSize = (length == 128?128:192)/8;
 99     }
100 
101     protected int getKeySeedLength() {
102         return keyLength;   // bits; AES key material
103     }
104 
105     public byte[] stringToKey(char[] password, String salt, byte[] s2kparams)
106         throws GeneralSecurityException {
107 
108         byte[] saltUtf8 = null;
109         try {
110             saltUtf8 = salt.getBytes(&quot;UTF-8&quot;);
111             return stringToKey(password, saltUtf8, s2kparams);
112         } catch (Exception e) {
113             return null;
114         } finally {
115             if (saltUtf8 != null) {
116                 Arrays.fill(saltUtf8, (byte)0);
117             }
118         }
119     }
120 
121     // https://tools.ietf.org/html/rfc8009#section-4
122     private byte[] stringToKey(char[] secret, byte[] salt, byte[] params)
123         throws GeneralSecurityException {
124 
125         int iter_count = DEFAULT_ITERATION_COUNT;
126         if (params != null) {
127             if (params.length != 4) {
128                 throw new RuntimeException(&quot;Invalid parameter to stringToKey&quot;);
129             }
130             iter_count = readBigEndian(params, 0, 4);
131         }
132 
133         byte[] saltp = new byte[26 + 1 + salt.length];
134         if (keyLength == 128) {
135             System.arraycopy(ETYPE_NAME_128, 0, saltp, 0, 26);
136         } else {
137             System.arraycopy(ETYPE_NAME_256, 0, saltp, 0, 26);
138         }
139         System.arraycopy(salt, 0, saltp, 27, salt.length);
140         byte[] tmpKey = randomToKey(PBKDF2(secret, saltp, iter_count,
141                                         getKeySeedLength()));
142         byte[] result = dk(tmpKey, KERBEROS_CONSTANT);
143         return result;
144     }
145 
146     protected byte[] randomToKey(byte[] in) {
147         // simple identity operation
148         return in;
149     }
150 
151     /*
152      * https://tools.ietf.org/html/rfc8009#section-3 defines
153      * a new key derivation function:
154      *
155      * KDF-HMAC-SHA2(key, label, k) = k-truncate(K1)
156      * K1 = HMAC-SHA-256(key, 0x00000001 | label | 0x00 | k) or
157      * K1 = HMAC-SHA-384(key, 0x00000001 | label | 0x00 | k)
158      *
159      * where label is constant below.
160      */
161     protected byte[] dr(byte[] key, byte[] constant)
162             throws GeneralSecurityException {
163         byte[] result;
164         byte[] input = new byte[constant.length + 9];
165         // 0x00000001 at the beginning
166         input[3] = 1;
167         // label follows
168         System.arraycopy(constant, 0, input, 4, constant.length);
169         SecretKeySpec tkey = new SecretKeySpec(key, &quot;HMAC&quot;);
170         Mac mac = Mac.getInstance(
171                 keyLength == 128? &quot;HmacSHA256&quot;: &quot;HmacSHA384&quot;);
172         mac.init(tkey);
173 
174         int k;
175         if (keyLength == 128) {
176             // key length for enc and hmac both 128
177             k = 128;
178         } else {
179             byte last = constant[constant.length-1];
180             if (last == (byte)0x99 || last == (byte)0x55) {
181                 // 192 for hmac
182                 k = 192;
183             } else {
184                 // 256 for enc
185                 k = 256;
186             }
187         }
188         // 0x00 and k at the end
189         input[input.length - 1] = (byte)(k);
190         input[input.length - 2] = (byte)(k / 256);
191 
192         result = mac.doFinal(input);
193         return Arrays.copyOf(result, k / 8);
194     }
195 
196     protected Cipher getCipher(byte[] key, byte[] ivec, int mode)
197         throws GeneralSecurityException {
198 
199         // IV
200         if (ivec == null) {
201            ivec = ZERO_IV;
202         }
203         SecretKeySpec secretKey = new SecretKeySpec(key, &quot;AES&quot;);
204         Cipher cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);
205         IvParameterSpec encIv = new IvParameterSpec(ivec, 0, ivec.length);
206         cipher.init(mode, secretKey, encIv);
207         return cipher;
208     }
209 
210     // get an instance of the AES Cipher in CTS mode
211     public int getChecksumLength() {
212         return hashSize;  // bytes
213     }
214 
215     /**
216      * Get the truncated HMAC
217      */
218     protected byte[] getHmac(byte[] key, byte[] msg)
219         throws GeneralSecurityException {
220 
221         SecretKey keyKi = new SecretKeySpec(key, &quot;HMAC&quot;);
222         Mac m = Mac.getInstance(keyLength == 128 ? &quot;HmacSHA256&quot; : &quot;HmacSHA384&quot;);
223         m.init(keyKi);
224 
225         // generate hash
226         byte[] hash = m.doFinal(msg);
227 
228         // truncate hash
229         byte[] output = new byte[hashSize];
230         System.arraycopy(hash, 0, output, 0, hashSize);
231         return output;
232     }
233 
234     private byte[] deriveKey(byte[] baseKey, int usage, byte type)
235             throws GeneralSecurityException {
236         byte[] constant = new byte[5];
237         constant[0] = (byte) ((usage&gt;&gt;24)&amp;0xff);
238         constant[1] = (byte) ((usage&gt;&gt;16)&amp;0xff);
239         constant[2] = (byte) ((usage&gt;&gt;8)&amp;0xff);
240         constant[3] = (byte) (usage&amp;0xff);
241         constant[4] = type;
242         return dk(baseKey, constant);
243     }
244 
245     /**
246      * Calculate the checksum
247      */
248     public byte[] calculateChecksum(byte[] baseKey, int usage, byte[] input,
249         int start, int len) throws GeneralSecurityException {
250 
251         if (!KeyUsage.isValid(usage)) {
252             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
253                                                 + usage);
254         }
255 
256         byte[] Kc = deriveKey(baseKey, usage, (byte) 0x99);  // Checksum key
257         if (debug) {
258             System.err.println(&quot;usage: &quot; + usage);
259             traceOutput(&quot;input&quot;, input, start, Math.min(len, 32));
260             traceOutput(&quot;baseKey&quot;, baseKey, 0, baseKey.length);
261             traceOutput(&quot;Kc&quot;, Kc, 0, Kc.length);
262         }
263 
264         try {
265             // Generate checksum
266             // H1 = HMAC(Kc, input)
267             byte[] hmac = getHmac(Kc, input);
268             if (debug) {
269                 traceOutput(&quot;hmac&quot;, hmac, 0, hmac.length);
270             }
271             if (hmac.length == getChecksumLength()) {
272                 return hmac;
273             } else if (hmac.length &gt; getChecksumLength()) {
274                 byte[] buf = new byte[getChecksumLength()];
275                 System.arraycopy(hmac, 0, buf, 0, buf.length);
276                 return buf;
277             } else {
278                 throw new GeneralSecurityException(&quot;checksum size too short: &quot; +
279                         hmac.length + &quot;; expecting : &quot; + getChecksumLength());
280             }
281         } finally {
282             Arrays.fill(Kc, 0, Kc.length, (byte)0);
283         }
284     }
285 
286     /**
287      * Performs encryption using derived key; adds confounder.
288      */
289     public byte[] encrypt(byte[] baseKey, int usage,
290         byte[] ivec, byte[] new_ivec, byte[] plaintext, int start, int len)
291         throws GeneralSecurityException, KrbCryptoException {
292 
293         if (!KeyUsage.isValid(usage)) {
294             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
295                                                  + usage);
296         }
297         byte[] output = encryptCTS(baseKey, usage, ivec, new_ivec, plaintext,
298                                         start, len, true);
299         return output;
300     }
301 
302     /**
303      * Performs encryption using derived key; does not add confounder.
304      */
305     public byte[] encryptRaw(byte[] baseKey, int usage,
306         byte[] ivec, byte[] plaintext, int start, int len)
307         throws GeneralSecurityException, KrbCryptoException {
308 
309         if (!KeyUsage.isValid(usage)) {
310             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
311                                                 + usage);
312         }
313         byte[] output = encryptCTS(baseKey, usage, ivec, null, plaintext,
314                                         start, len, false);
315         return output;
316     }
317 
318     /**
319      * @param baseKey key from which keys are to be derived using usage
320      * @param ciphertext  E(Ke, conf | plaintext | padding, ivec) | H1[1..h]
321      */
322     public byte[] decrypt(byte[] baseKey, int usage, byte[] ivec,
323         byte[] ciphertext, int start, int len) throws GeneralSecurityException {
324 
325         if (!KeyUsage.isValid(usage)) {
326             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
327                                                 + usage);
328         }
329         byte[] output = decryptCTS(baseKey, usage, ivec, ciphertext,
330                                         start, len, true);
331         return output;
332     }
333 
334     /**
335      * Decrypts data using specified key and initial vector.
336      * @param baseKey encryption key to use
337      * @param ciphertext  encrypted data to be decrypted
338      * @param usage ignored
339      */
340     public byte[] decryptRaw(byte[] baseKey, int usage, byte[] ivec,
341         byte[] ciphertext, int start, int len)
342         throws GeneralSecurityException {
343 
344         if (!KeyUsage.isValid(usage)) {
345             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
346                                                 + usage);
347         }
348         byte[] output = decryptCTS(baseKey, usage, ivec, ciphertext,
349                                         start, len, false);
350         return output;
351     }
352 
353     /**
354      * Encrypt AES in CBC-CTS mode using derived keys.
355      */
356     private byte[] encryptCTS(byte[] baseKey, int usage, byte[] ivec,
357         byte[] new_ivec, byte[] plaintext, int start, int len,
358         boolean confounder_exists)
359         throws GeneralSecurityException, KrbCryptoException {
360 
361         byte[] Ke = null;
362         byte[] Ki = null;
363 
364         if (debug) {
365             System.err.println(&quot;usage: &quot; + usage);
366             if (ivec != null) {
367                 traceOutput(&quot;old_state.ivec&quot;, ivec, 0, ivec.length);
368             }
369             traceOutput(&quot;plaintext&quot;, plaintext, start, Math.min(len, 32));
370             traceOutput(&quot;baseKey&quot;, baseKey, 0, baseKey.length);
371         }
372 
373         try {
374             Ke = deriveKey(baseKey, usage, (byte) 0xaa);  // Encryption key
375 
376             byte[] toBeEncrypted = null;
377             if (confounder_exists) {
378                 byte[] confounder = Confounder.bytes(BLOCK_SIZE);
379                 toBeEncrypted = new byte[confounder.length + len];
380                 System.arraycopy(confounder, 0, toBeEncrypted,
381                                         0, confounder.length);
382                 System.arraycopy(plaintext, start, toBeEncrypted,
383                                         confounder.length, len);
384             } else {
385                 toBeEncrypted = new byte[len];
386                 System.arraycopy(plaintext, start, toBeEncrypted, 0, len);
387             }
388 
389             // encryptedData + HMAC
390             byte[] output = new byte[toBeEncrypted.length + hashSize];
391 
392             // AES in JCE
393             Cipher cipher = Cipher.getInstance(&quot;AES/CTS/NoPadding&quot;);
394             SecretKeySpec secretKey = new SecretKeySpec(Ke, &quot;AES&quot;);
395             IvParameterSpec encIv = new IvParameterSpec(ivec, 0, ivec.length);
396             cipher.init(Cipher.ENCRYPT_MODE, secretKey, encIv);
397             cipher.doFinal(toBeEncrypted, 0, toBeEncrypted.length, output);
398 
399             Ki = deriveKey(baseKey, usage, (byte) 0x55);
400             if (debug) {
401                 traceOutput(&quot;Ki&quot;, Ki, 0, Ke.length);
402             }
403 
404             // Generate checksum
405             // H = HMAC(Ki, IV | C)
406             byte[] msg = Arrays.copyOf(ivec, ivec.length + toBeEncrypted.length);
407             System.arraycopy(output, 0, msg, ivec.length, toBeEncrypted.length);
408             byte[] hmac = getHmac(Ki, msg);
409 
410             // encryptedData + HMAC
411             System.arraycopy(hmac, 0, output, toBeEncrypted.length,
412                                 hmac.length);
413             return output;
414         } finally {
415             if (Ke != null) {
416                 Arrays.fill(Ke, 0, Ke.length, (byte) 0);
417             }
418             if (Ki != null) {
419                 Arrays.fill(Ki, 0, Ki.length, (byte) 0);
420             }
421         }
422     }
423 
424     /**
425      * Decrypt AES in CBC-CTS mode using derived keys.
426      */
427     private byte[] decryptCTS(byte[] baseKey, int usage, byte[] ivec,
428         byte[] ciphertext, int start, int len, boolean confounder_exists)
429         throws GeneralSecurityException {
430 
431         byte[] Ke = null;
432         byte[] Ki = null;
433 
434         try {
435             Ke = deriveKey(baseKey, usage, (byte) 0xaa);  // Encryption key
436 
437             if (debug) {
438                 System.err.println(&quot;usage: &quot; + usage);
439                 if (ivec != null) {
440                     traceOutput(&quot;old_state.ivec&quot;, ivec, 0, ivec.length);
441                 }
442                 traceOutput(&quot;ciphertext&quot;, ciphertext, start, Math.min(len, 32));
443                 traceOutput(&quot;baseKey&quot;, baseKey, 0, baseKey.length);
444                 traceOutput(&quot;Ke&quot;, Ke, 0, Ke.length);
445             }
446 
447             // Decrypt [confounder | plaintext ] (without checksum)
448 
449             // AES in JCE
450             Cipher cipher = Cipher.getInstance(&quot;AES/CTS/NoPadding&quot;);
451             SecretKeySpec secretKey = new SecretKeySpec(Ke, &quot;AES&quot;);
452             IvParameterSpec encIv = new IvParameterSpec(ivec, 0, ivec.length);
453             cipher.init(Cipher.DECRYPT_MODE, secretKey, encIv);
454             byte[] plaintext = cipher.doFinal(ciphertext, start, len-hashSize);
455 
456             if (debug) {
457                 traceOutput(&quot;AES PlainText&quot;, plaintext, 0,
458                                 Math.min(plaintext.length, 32));
459             }
460 
461             Ki = deriveKey(baseKey, usage, (byte) 0x55);  // Integrity key
462             if (debug) {
463                 traceOutput(&quot;Ki&quot;, Ki, 0, Ke.length);
464             }
465 
466             // Verify checksum
467             // H = HMAC(Ki, IV | C)
468             byte[] msg = Arrays.copyOf(ivec, ivec.length + len-hashSize);
469             System.arraycopy(ciphertext, start, msg, ivec.length, len-hashSize);
470             byte[] calculatedHmac = getHmac(Ki, msg);
471             int hmacOffset = start + len - hashSize;
472             if (debug) {
473                 traceOutput(&quot;calculated Hmac&quot;, calculatedHmac,
474                                 0, calculatedHmac.length);
475                 traceOutput(&quot;message Hmac&quot;, ciphertext, hmacOffset, hashSize);
476             }
477             boolean cksumFailed = false;
478             if (calculatedHmac.length &gt;= hashSize) {
479                 for (int i = 0; i &lt; hashSize; i++) {
480                     if (calculatedHmac[i] != ciphertext[hmacOffset+i]) {
481                         cksumFailed = true;
482                         if (debug) {
483                             System.err.println(&quot;Checksum failed !&quot;);
484                         }
485                         break;
486                     }
487                 }
488             }
489             if (cksumFailed) {
490                 throw new GeneralSecurityException(&quot;Checksum failed&quot;);
491             }
492 
493             if (confounder_exists) {
494                 // Get rid of confounder
495                 // [ confounder | plaintext ]
496                 byte[] output = new byte[plaintext.length - BLOCK_SIZE];
497                 System.arraycopy(plaintext, BLOCK_SIZE, output,
498                                         0, output.length);
499                 return output;
500             } else {
501                 return plaintext;
502             }
503         } finally {
504             if (Ke != null) {
505                 Arrays.fill(Ke, 0, Ke.length, (byte) 0);
506             }
507             if (Ki != null) {
508                 Arrays.fill(Ki, 0, Ki.length, (byte) 0);
509             }
510         }
511     }
512 
513     /*
514      * Invoke the PKCS#5 PBKDF2 algorithm
515      */
516     private static byte[] PBKDF2(char[] secret, byte[] salt,
517         int count, int keyLength) throws GeneralSecurityException {
518 
519         PBEKeySpec keySpec = new PBEKeySpec(secret, salt, count, keyLength);
520         SecretKeyFactory skf =
521                 SecretKeyFactory.getInstance(keyLength == 128 ?
522                         &quot;PBKDF2WithHmacSHA256&quot; : &quot;PBKDF2WithHmacSHA384&quot;);
523         SecretKey key = skf.generateSecret(keySpec);
524         byte[] result = key.getEncoded();
525 
526         return result;
527     }
528 
529     public static final int readBigEndian(byte[] data, int pos, int size) {
530         int retVal = 0;
531         int shifter = (size-1)*8;
532         while (size &gt; 0) {
533             retVal += (data[pos] &amp; 0xff) &lt;&lt; shifter;
534             shifter -= 8;
535             pos++;
536             size--;
537         }
538         return retVal;
539     }
540 
541 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.security.jgss/share/classes/sun/security/krb5/internal/ktab/KeyTab.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  *
 28  *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 29  *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 30  */
 31 
 32 package sun.security.krb5.internal.ktab;
 33 
 34 import sun.security.action.GetPropertyAction;
 35 import sun.security.krb5.*;
 36 import sun.security.krb5.internal.*;
 37 import sun.security.krb5.internal.crypto.*;
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.io.IOException;
 41 import java.io.FileInputStream;
 42 import java.io.FileOutputStream;
 43 import java.io.File;
 44 import java.io.FileNotFoundException;
 45 import java.util.Comparator;
 46 import java.util.HashMap;
 47 import java.util.Map;
 48 import java.util.StringTokenizer;
 49 import java.util.Vector;
 50 import sun.security.jgss.krb5.ServiceCreds;
 51 
 52 /**
 53  * This class represents key table. The key table functions deal with storing
 54  * and retrieving service keys for use in authentication exchanges.
 55  *
 56  * A KeyTab object is always constructed, if the file specified does not
 57  * exist, it&#39;s still valid but empty. If there is an I/O error or file format
 58  * error, it&#39;s invalid.
 59  *
 60  * The class is immutable on the read side (the write side is only used by
 61  * the ktab tool).
 62  *
 63  * @author Yanni Zhang
 64  */
 65 public class KeyTab implements KeyTabConstants {
 66 
 67     private static final boolean DEBUG = Krb5.DEBUG;
 68     private static String defaultTabName = null;
 69 
 70     // Attention: Currently there is no way to remove a keytab from this map,
 71     // this might lead to a memory leak.
 72     private static Map&lt;String,KeyTab&gt; map = new HashMap&lt;&gt;();
 73 
 74     // KeyTab file does not exist. Note: a missing keytab is still valid
 75     private boolean isMissing = false;
 76 
 77     // KeyTab file is invalid, possibly an I/O error or a file format error.
 78     private boolean isValid = true;
 79 
 80     private final String tabName;
 81     private long lastModified;
 82     private int kt_vno = KRB5_KT_VNO;
 83 
 84     private Vector&lt;KeyTabEntry&gt; entries = new Vector&lt;&gt;();
 85 
 86     /**
 87      * Constructs a KeyTab object.
 88      *
 89      * If there is any I/O error or format errot during the loading, the
 90      * isValid flag is set to false, and all half-read entries are dismissed.
 91      * @param filename path name for the keytab file, must not be null
 92      */
 93     private KeyTab(String filename) {
 94         tabName = filename;
 95         try {
 96             lastModified = new File(tabName).lastModified();
 97             try (KeyTabInputStream kis =
 98                     new KeyTabInputStream(new FileInputStream(filename))) {
 99                 load(kis);
100             }
101         } catch (FileNotFoundException e) {
102             entries.clear();
103             isMissing = true;
104         } catch (Exception ioe) {
105             entries.clear();
106             isValid = false;
107         }
108     }
109 
110     /**
111      * Read a keytab file. Returns a new object and save it into cache when
112      * new content (modified since last read) is available. If keytab file is
113      * invalid, the old object will be returned. This is a safeguard for
114      * partial-written keytab files or non-stable network. Please note that
115      * a missing keytab is valid, which is equivalent to an empty keytab.
116      *
117      * @param s file name of keytab, must not be null
118      * @return the keytab object, can be invalid, but never null.
119      */
120     private synchronized static KeyTab getInstance0(String s) {
121         long lm = new File(s).lastModified();
122         KeyTab old = map.get(s);
123         if (old != null &amp;&amp; old.isValid() &amp;&amp; old.lastModified == lm) {
124             return old;
125         }
126         KeyTab ktab = new KeyTab(s);
127         if (ktab.isValid()) {               // A valid new keytab
128             map.put(s, ktab);
129             return ktab;
130         } else if (old != null) {           // An existing old one
131             return old;
132         } else {
133             return ktab;                    // first read is invalid
134         }
135     }
136 
137     /**
138      * Gets a KeyTab object.
139      * @param s the key tab file name.
140      * @return the KeyTab object, never null.
141      */
142     public static KeyTab getInstance(String s) {
143         if (s == null) {
144             return getInstance();
145         } else {
146             return getInstance0(normalize(s));
147         }
148     }
149 
150     /**
151      * Gets a KeyTab object.
152      * @param file the key tab file.
153      * @return the KeyTab object, never null.
154      */
155     public static KeyTab getInstance(File file) {
156         if (file == null) {
157             return getInstance();
158         } else {
159             return getInstance0(file.getPath());
160         }
161     }
162 
163     /**
164      * Gets the default KeyTab object.
165      * @return the KeyTab object, never null.
166      */
167     public static KeyTab getInstance() {
168         return getInstance(getDefaultTabName());
169     }
170 
171     public boolean isMissing() {
172         return isMissing;
173     }
174 
175     public boolean isValid() {
176         return isValid;
177     }
178 
179     /**
180      * The location of keytab file will be read from the configuration file
181      * If it is not specified, consider user.home as the keytab file&#39;s
182      * default location.
183      * @return never null
184      */
185     private static String getDefaultTabName() {
186         if (defaultTabName != null) {
187             return defaultTabName;
188         } else {
189             String kname = null;
190             try {
191                 String keytab_names = Config.getInstance().get
192                         (&quot;libdefaults&quot;, &quot;default_keytab_name&quot;);
193                 if (keytab_names != null) {
194                     StringTokenizer st = new StringTokenizer(keytab_names, &quot; &quot;);
195                     while (st.hasMoreTokens()) {
196                         kname = normalize(st.nextToken());
197                         if (new File(kname).exists()) {
198                             break;
199                         }
200                     }
201                 }
202             } catch (KrbException e) {
203                 kname = null;
204             }
205 
206             if (kname == null) {
207                 String user_home = GetPropertyAction
208                         .privilegedGetProperty(&quot;user.home&quot;);
209 
210                 if (user_home == null) {
211                     user_home = GetPropertyAction
212                             .privilegedGetProperty(&quot;user.dir&quot;);
213                 }
214 
215                 kname = user_home + File.separator  + &quot;krb5.keytab&quot;;
216             }
217             defaultTabName = kname;
218             return kname;
219         }
220     }
221 
222     /**
223      * Normalizes some common keytab name formats into the bare file name.
224      * For example, FILE:/etc/krb5.keytab to /etc/krb5.keytab
225      * @param name never null
226      * @return never null
227      */
228     // This method is used in this class and Krb5LoginModule
229     public static String normalize(String name) {
230         String kname;
231         if ((name.length() &gt;= 5) &amp;&amp;
232             (name.substring(0, 5).equalsIgnoreCase(&quot;FILE:&quot;))) {
233             kname = name.substring(5);
234         } else if ((name.length() &gt;= 9) &amp;&amp;
235                 (name.substring(0, 9).equalsIgnoreCase(&quot;ANY:FILE:&quot;))) {
236             // this format found in MIT&#39;s krb5.ini.
237             kname = name.substring(9);
238         } else if ((name.length() &gt;= 7) &amp;&amp;
239                 (name.substring(0, 7).equalsIgnoreCase(&quot;SRVTAB:&quot;))) {
240             // this format found in MIT&#39;s krb5.ini.
241             kname = name.substring(7);
242         } else
243             kname = name;
244         return kname;
245     }
246 
247     private void load(KeyTabInputStream kis)
248         throws IOException, RealmException {
249 
250         entries.clear();
251         kt_vno = kis.readVersion();
252         if (kt_vno == KRB5_KT_VNO_1) {
253             kis.setNativeByteOrder();
254         }
255         int entryLength = 0;
256         KeyTabEntry entry;
257         while (kis.available() &gt; 0) {
258             entryLength = kis.readEntryLength();
259             entry = kis.readEntry(entryLength, kt_vno);
260             if (DEBUG) {
261                 System.out.println(&quot;&gt;&gt;&gt; KeyTab: load() entry length: &quot; +
262                         entryLength + &quot;; type: &quot; +
263                         (entry != null? entry.keyType : 0));
264             }
265             if (entry != null)
266                 entries.addElement(entry);
267         }
268     }
269 
270     /**
271      * Returns a principal name in this keytab. Used by
272      * {@link ServiceCreds#getKKeys()}.
273      */
274     public PrincipalName getOneName() {
275         int size = entries.size();
276         return size &gt; 0 ? entries.elementAt(size-1).service : null;
277     }
278 
279     /**
280      * Reads all keys for a service from the keytab file that have
281      * etypes that have been configured for use.
282      * @param service the PrincipalName of the requested service
283      * @return an array containing all the service keys, never null
284      */
285     public EncryptionKey[] readServiceKeys(PrincipalName service) {
286         KeyTabEntry entry;
287         EncryptionKey key;
288         int size = entries.size();
289         ArrayList&lt;EncryptionKey&gt; keys = new ArrayList&lt;&gt;(size);
290         if (DEBUG) {
291             System.out.println(&quot;Looking for keys for: &quot; + service);
292         }
293         for (int i = size-1; i &gt;= 0; i--) {
294             entry = entries.elementAt(i);
295             if (entry.service.match(service)) {
296                 if (EType.isSupported(entry.keyType)) {
297                     key = new EncryptionKey(entry.keyblock,
298                                         entry.keyType,
299                                         entry.keyVersion);
300                     keys.add(key);
301                     if (DEBUG) {
302                         System.out.println(&quot;Added key: &quot; + entry.keyType +
303                             &quot;version: &quot; + entry.keyVersion);
304                     }
305                 } else if (DEBUG) {
306                     System.out.println(&quot;Found unsupported keytype (&quot; +
307                         entry.keyType + &quot;) for &quot; + service);
308                 }
309             }
310         }
311         size = keys.size();
312         EncryptionKey[] retVal = keys.toArray(new EncryptionKey[size]);
313 
314         // Sort the keys by kvno. Sometimes we must choose a single key (say,
315         // generate encrypted timestamp in AS-REQ). A key with a higher KVNO
316         // sounds like a newer one.
317         Arrays.sort(retVal, new Comparator&lt;EncryptionKey&gt;() {
318             @Override
319             public int compare(EncryptionKey o1, EncryptionKey o2) {
320                 return o2.getKeyVersionNumber().intValue()
321                         - o1.getKeyVersionNumber().intValue();
322             }
323         });
324 
325         return retVal;
326     }
327 
328 
329 
330     /**
331      * Searches for the service entry in the keytab file.
332      * The etype of the key must be one that has been configured
333      * to be used.
334      * @param service the PrincipalName of the requested service.
335      * @return true if the entry is found, otherwise, return false.
336      */
337     public boolean findServiceEntry(PrincipalName service) {
338         KeyTabEntry entry;
339         for (int i = 0; i &lt; entries.size(); i++) {
340             entry = entries.elementAt(i);
341             if (entry.service.match(service)) {
342                 if (EType.isSupported(entry.keyType)) {
343                     return true;
344                 } else if (DEBUG) {
345                     System.out.println(&quot;Found unsupported keytype (&quot; +
346                         entry.keyType + &quot;) for &quot; + service);
347                 }
348             }
349         }
350         return false;
351     }
352 
353     public String tabName() {
354         return tabName;
355     }
356 
357     /////////////////// THE WRITE SIDE ///////////////////////
358     /////////////// only used by ktab tool //////////////////
359 
360     /**
361      * Adds a new entry in the key table.
362      * @param service the service which will have a new entry in the key table.
363      * @param psswd the password which generates the key.
364      * @param kvno the kvno to use, -1 means automatic increasing
365      * @param append false if entries with old kvno would be removed.
366      * Note: if kvno is not -1, entries with the same kvno are always removed
367      */
368     public void addEntry(PrincipalName service, char[] psswd,
369             int kvno, boolean append) throws KrbException {
370         addEntry(service, service.getSalt(), psswd, kvno, append);
371     }
372 
373     // Called by KDC test
374     public void addEntry(PrincipalName service, String salt, char[] psswd,
375             int kvno, boolean append) throws KrbException {
376 
377         EncryptionKey[] encKeys = EncryptionKey.acquireSecretKeys(
378             psswd, salt);
379 
380         // There should be only one maximum KVNO value for all etypes, so that
381         // all added keys can have the same KVNO.
382 
383         int maxKvno = 0;    // only useful when kvno == -1
384         for (int i = entries.size()-1; i &gt;= 0; i--) {
385             KeyTabEntry e = entries.get(i);
386             if (e.service.match(service)) {
387                 if (e.keyVersion &gt; maxKvno) {
388                     maxKvno = e.keyVersion;
389                 }
390                 if (!append || e.keyVersion == kvno) {
391                     entries.removeElementAt(i);
392                 }
393             }
394         }
395         if (kvno == -1) {
396             kvno = maxKvno + 1;
397         }
398 
399         for (int i = 0; encKeys != null &amp;&amp; i &lt; encKeys.length; i++) {
400             int keyType = encKeys[i].getEType();
401             byte[] keyValue = encKeys[i].getBytes();
402 
403             KeyTabEntry newEntry = new KeyTabEntry(service,
404                             service.getRealm(),
405                             new KerberosTime(System.currentTimeMillis()),
406                                                kvno, keyType, keyValue);
407             entries.addElement(newEntry);
408         }
409     }
410 
411     /**
412      * Gets the list of service entries in key table.
413      * @return array of &lt;code&gt;KeyTabEntry&lt;/code&gt;.
414      */
415     public KeyTabEntry[] getEntries() {
416         KeyTabEntry[] kentries = new KeyTabEntry[entries.size()];
417         for (int i = 0; i &lt; kentries.length; i++) {
418             kentries[i] = entries.elementAt(i);
419         }
420         return kentries;
421     }
422 
423     /**
424      * Creates a new default key table.
425      */
426     public synchronized static KeyTab create()
427         throws IOException, RealmException {
428         String dname = getDefaultTabName();
429         return create(dname);
430     }
431 
432     /**
433      * Creates a new default key table.
434      */
435     public synchronized static KeyTab create(String name)
436         throws IOException, RealmException {
437 
438         try (KeyTabOutputStream kos =
439                 new KeyTabOutputStream(new FileOutputStream(name))) {
440             kos.writeVersion(KRB5_KT_VNO);
441         }
442         return new KeyTab(name);
443     }
444 
445     /**
446      * Saves the file at the directory.
447      */
448     public synchronized void save() throws IOException {
449         try (KeyTabOutputStream kos =
450                 new KeyTabOutputStream(new FileOutputStream(tabName))) {
451             kos.writeVersion(kt_vno);
452             for (int i = 0; i &lt; entries.size(); i++) {
453                 kos.writeEntry(entries.elementAt(i));
454             }
455         }
456     }
457 
458     /**
459      * Removes entries from the key table.
460      * @param service the service &lt;code&gt;PrincipalName&lt;/code&gt;.
461      * @param etype the etype to match, remove all if -1
462      * @param kvno what kvno to remove, -1 for all, -2 for old
463      * @return the number of entries deleted
464      */
465     public int deleteEntries(PrincipalName service, int etype, int kvno) {
466         int count = 0;
467 
468         // Remember the highest KVNO for each etype. Used for kvno == -2
469         Map&lt;Integer,Integer&gt; highest = new HashMap&lt;&gt;();
470 
471         for (int i = entries.size()-1; i &gt;= 0; i--) {
472             KeyTabEntry e = entries.get(i);
473             if (service.match(e.getService())) {
474                 if (etype == -1 || e.keyType == etype) {
475                     if (kvno == -2) {
476                         // Two rounds for kvno == -2. In the first round (here),
477                         // only find out highest KVNO for each etype
478                         if (highest.containsKey(e.keyType)) {
479                             int n = highest.get(e.keyType);
480                             if (e.keyVersion &gt; n) {
481                                 highest.put(e.keyType, e.keyVersion);
482                             }
483                         } else {
484                             highest.put(e.keyType, e.keyVersion);
485                         }
486                     } else if (kvno == -1 || e.keyVersion == kvno) {
487                         entries.removeElementAt(i);
488                         count++;
489                     }
490                 }
491             }
492         }
493 
494         // Second round for kvno == -2, remove old entries
495         if (kvno == -2) {
496             for (int i = entries.size()-1; i &gt;= 0; i--) {
497                 KeyTabEntry e = entries.get(i);
498                 if (service.match(e.getService())) {
499                     if (etype == -1 || e.keyType == etype) {
500                         int n = highest.get(e.keyType);
501                         if (e.keyVersion != n) {
502                             entries.removeElementAt(i);
503                             count++;
504                         }
505                     }
506                 }
507             }
508         }
509         return count;
510     }
511 
512     /**
513      * Creates key table file version.
514      * @param file the key table file.
515      * @exception IOException
516      */
517     public synchronized void createVersion(File file) throws IOException {
518         try (KeyTabOutputStream kos =
519                 new KeyTabOutputStream(new FileOutputStream(file))) {
520             kos.write16(KRB5_KT_VNO);
521         }
522     }
523 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.security.jgss/share/classes/sun/security/krb5/Credentials.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Config.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="EncryptionKey.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.security.jgss/share/classes/sun/security/krb5/Credentials.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 32 package sun.security.krb5;
 33 
 34 import sun.security.action.GetPropertyAction;
 35 import sun.security.krb5.internal.*;
 36 import sun.security.krb5.internal.ccache.CredentialsCache;
 37 import sun.security.krb5.internal.crypto.EType;
 38 import java.io.IOException;
 39 import java.util.Date;
 40 import java.util.Locale;
 41 import java.net.InetAddress;
 42 
 43 /**
 44  * This class encapsulates the concept of a Kerberos service
 45  * credential. That includes a Kerberos ticket and an associated
 46  * session key.
 47  */
 48 public class Credentials {
 49 
 50     Ticket ticket;
 51     PrincipalName client;

 52     PrincipalName server;

 53     EncryptionKey key;
 54     TicketFlags flags;
 55     KerberosTime authTime;
 56     KerberosTime startTime;
 57     KerberosTime endTime;
 58     KerberosTime renewTill;
 59     HostAddresses cAddr;
<span class="line-removed"> 60     EncryptionKey serviceKey;</span>
 61     AuthorizationData authzData;
 62     private static boolean DEBUG = Krb5.DEBUG;
 63     private static CredentialsCache cache;
 64     static boolean alreadyLoaded = false;
 65     private static boolean alreadyTried = false;
 66 











 67     // Read native ticket with session key type in the given list
 68     private static native Credentials acquireDefaultNativeCreds(int[] eTypes);
 69 
 70     public Credentials(Ticket new_ticket,
 71                        PrincipalName new_client,

 72                        PrincipalName new_server,

 73                        EncryptionKey new_key,
 74                        TicketFlags new_flags,
 75                        KerberosTime authTime,
 76                        KerberosTime new_startTime,
 77                        KerberosTime new_endTime,
 78                        KerberosTime renewTill,
 79                        HostAddresses cAddr,
 80                        AuthorizationData authzData) {
<span class="line-modified"> 81         this(new_ticket, new_client, new_server, new_key, new_flags,</span>
<span class="line-modified"> 82                 authTime, new_startTime, new_endTime, renewTill, cAddr);</span>

 83         this.authzData = authzData;
 84     }
 85 

 86     public Credentials(Ticket new_ticket,
 87                        PrincipalName new_client,

 88                        PrincipalName new_server,

 89                        EncryptionKey new_key,
 90                        TicketFlags new_flags,
 91                        KerberosTime authTime,
 92                        KerberosTime new_startTime,
 93                        KerberosTime new_endTime,
 94                        KerberosTime renewTill,
 95                        HostAddresses cAddr) {
 96         ticket = new_ticket;
 97         client = new_client;

 98         server = new_server;

 99         key = new_key;
100         flags = new_flags;
101         this.authTime = authTime;
102         startTime = new_startTime;
103         endTime = new_endTime;
104         this.renewTill = renewTill;
105         this.cAddr = cAddr;
106     }
107 
108     public Credentials(byte[] encoding,
109                        String client,

110                        String server,

111                        byte[] keyBytes,
112                        int keyType,
113                        boolean[] flags,
114                        Date authTime,
115                        Date startTime,
116                        Date endTime,
117                        Date renewTill,
118                        InetAddress[] cAddrs) throws KrbException, IOException {
119         this(new Ticket(encoding),
120              new PrincipalName(client, PrincipalName.KRB_NT_PRINCIPAL),


121              new PrincipalName(server, PrincipalName.KRB_NT_SRV_INST),


122              new EncryptionKey(keyType, keyBytes),
123              (flags == null? null: new TicketFlags(flags)),
124              (authTime == null? null: new KerberosTime(authTime)),
125              (startTime == null? null: new KerberosTime(startTime)),
126              (endTime == null? null: new KerberosTime(endTime)),
127              (renewTill == null? null: new KerberosTime(renewTill)),
128              null); // caddrs are in the encoding at this point
129     }
130 
131     /**
132      * Acquires a service ticket for the specified service
133      * principal. If the service ticket is not already available, it
134      * obtains a new one from the KDC.
135      */
136     /*
137     public Credentials(Credentials tgt, PrincipalName service)
138         throws KrbException {
139     }
140     */
141 
142     public final PrincipalName getClient() {
143         return client;
144     }
145 




146     public final PrincipalName getServer() {
147         return server;
148     }
149 




150     public final EncryptionKey getSessionKey() {
151         return key;
152     }
153 
154     public final Date getAuthTime() {
155         if (authTime != null) {
156             return authTime.toDate();
157         } else {
158             return null;
159         }
160     }
161 
162     public final Date getStartTime() {
163         if (startTime != null)
164             {
165                 return startTime.toDate();
166             }
167         return null;
168     }
169 
</pre>
<hr />
<pre>
185 
186     public final boolean[] getFlags() {
187         if (flags == null) // Can be in a KRB-CRED
188         return null;
189         return flags.toBooleanArray();
190     }
191 
192     public final InetAddress[] getClientAddresses() {
193 
194         if (cAddr == null)
195         return null;
196 
197         return cAddr.getInetAddresses();
198     }
199 
200     public final byte[] getEncoded() {
201         byte[] retVal = null;
202         try {
203             retVal = ticket.asn1Encode();
204         } catch (Asn1Exception e) {
<span class="line-modified">205             if (DEBUG)</span>
<span class="line-modified">206             System.out.println(e);</span>

207         } catch (IOException ioe) {
<span class="line-modified">208             if (DEBUG)</span>
<span class="line-modified">209             System.out.println(ioe);</span>

210         }
211         return retVal;
212     }
213 
214     public boolean isForwardable() {
215         return flags.get(Krb5.TKT_OPTS_FORWARDABLE);
216     }
217 
218     public boolean isRenewable() {
219         return flags.get(Krb5.TKT_OPTS_RENEWABLE);
220     }
221 
222     public Ticket getTicket() {
223         return ticket;
224     }
225 
226     public TicketFlags getTicketFlags() {
227         return flags;
228     }
229 
</pre>
<hr />
<pre>
245      * flag set. This info must be preservable and restorable through
246      * the Krb5Util.credsToTicket/ticketToCreds() methods so that even if
247      * the service ticket is cached it still remembers the cross-realm
248      * authentication result.
249      */
250     public void resetDelegate() {
251         flags.set(Krb5.TKT_OPTS_DELEGATE, false);
252     }
253 
254     public Credentials renew() throws KrbException, IOException {
255         KDCOptions options = new KDCOptions();
256         options.set(KDCOptions.RENEW, true);
257         /*
258          * Added here to pass KrbKdcRep.check:73
259          */
260         options.set(KDCOptions.RENEWABLE, true);
261 
262         return new KrbTgsReq(options,
263                              this,
264                              server,

265                              null, // from
266                              null, // till
267                              null, // rtime
268                              null, // eTypes
269                              cAddr,
270                              null,
271                              null,
272                              null).sendAndGetCreds();
273     }
274 
275     /**
276      * Returns a TGT for the given client principal from a ticket cache.
277      *
278      * @param princ the client principal. A value of null means that the
279      * default principal name in the credentials cache will be used.
280      * @param ticketCache the path to the tickets file. A value
281      * of null will be accepted to indicate that the default
282      * path should be searched
283      * @return the TGT credentials or null if none were found. If the tgt
284      * expired, it is the responsibility of the caller to determine this.
285      */
286     public static Credentials acquireTGTFromCache(PrincipalName princ,
287                                                   String ticketCache)
288         throws KrbException, IOException {
289 
290         if (ticketCache == null) {
291             // The default ticket cache on Windows and Mac is not a file.
292             String os = GetPropertyAction.privilegedGetProperty(&quot;os.name&quot;);
293             if (os.toUpperCase(Locale.ENGLISH).startsWith(&quot;WINDOWS&quot;) ||
294                     os.toUpperCase(Locale.ENGLISH).contains(&quot;OS X&quot;)) {
295                 Credentials creds = acquireDefaultCreds();
296                 if (creds == null) {
297                     if (DEBUG) {
<span class="line-modified">298                         System.out.println(&quot;&gt;&gt;&gt; Found no TGT&#39;s in LSA&quot;);</span>
299                     }
300                     return null;
301                 }
302                 if (princ != null) {
303                     if (creds.getClient().equals(princ)) {
304                         if (DEBUG) {
<span class="line-modified">305                             System.out.println(&quot;&gt;&gt;&gt; Obtained TGT from LSA: &quot;</span>
306                                                + creds);
307                         }
308                         return creds;
309                     } else {
310                         if (DEBUG) {
<span class="line-modified">311                             System.out.println(&quot;&gt;&gt;&gt; LSA contains TGT for &quot;</span>
312                                                + creds.getClient()
313                                                + &quot; not &quot;
314                                                + princ);
315                         }
316                         return null;
317                     }
318                 } else {
319                     if (DEBUG) {
<span class="line-modified">320                         System.out.println(&quot;&gt;&gt;&gt; Obtained TGT from LSA: &quot;</span>
321                                            + creds);
322                     }
323                     return creds;
324                 }
325             }
326         }
327 
328         /*
329          * Returns the appropriate cache. If ticketCache is null, it is the
330          * default cache otherwise it is the cache filename contained in it.
331          */
332         CredentialsCache ccache =
333             CredentialsCache.getInstance(princ, ticketCache);
334 
335         if (ccache == null) {
336             return null;
337         }
338 
<span class="line-modified">339         sun.security.krb5.internal.ccache.Credentials tgtCred  =</span>
<span class="line-removed">340             ccache.getDefaultCreds();</span>
341 
342         if (tgtCred == null) {
343             return null;
344         }
345 
<span class="line-modified">346         if (EType.isSupported(tgtCred.getEType())) {</span>
<span class="line-modified">347             return tgtCred.setKrbCreds();</span>
348         } else {
349             if (DEBUG) {
350                 System.out.println(
351                     &quot;&gt;&gt;&gt; unsupported key type found the default TGT: &quot; +
<span class="line-modified">352                     tgtCred.getEType());</span>
353             }
354             return null;
355         }
356     }
357 
358     /**
359      * Acquires default credentials.
360      * &lt;br&gt;The possible locations for default credentials cache is searched in
361      * the following order:
362      * &lt;ol&gt;
363      * &lt;li&gt; The directory and cache file name specified by &quot;KRB5CCNAME&quot; system.
364      * property.
365      * &lt;li&gt; The directory and cache file name specified by &quot;KRB5CCNAME&quot;
366      * environment variable.
367      * &lt;li&gt; A cache file named krb5cc_{user.name} at {user.home} directory.
368      * &lt;/ol&gt;
369      * @return a &lt;code&gt;KrbCreds&lt;/code&gt; object if the credential is found,
370      * otherwise return null.
371      */
372 
373     // this method is intentionally changed to not check if the caller&#39;s
374     // principal name matches cache file&#39;s principal name.
375     // It assumes that the GSS call has
376     // the privilege to access the default cache file.
377 
378     // This method is only called on Windows and Mac OS X, the native
379     // acquireDefaultNativeCreds is also available on these platforms.
380     public static synchronized Credentials acquireDefaultCreds() {
381         Credentials result = null;
382 
383         if (cache == null) {
384             cache = CredentialsCache.getInstance();
385         }
386         if (cache != null) {
<span class="line-modified">387             sun.security.krb5.internal.ccache.Credentials temp =</span>
<span class="line-removed">388                 cache.getDefaultCreds();</span>
389             if (temp != null) {
390                 if (DEBUG) {
391                     System.out.println(&quot;&gt;&gt;&gt; KrbCreds found the default ticket&quot;
392                             + &quot; granting ticket in credential cache.&quot;);
393                 }
<span class="line-modified">394                 if (EType.isSupported(temp.getEType())) {</span>
<span class="line-modified">395                     result = temp.setKrbCreds();</span>
396                 } else {
397                     if (DEBUG) {
398                         System.out.println(
399                             &quot;&gt;&gt;&gt; unsupported key type found the default TGT: &quot; +
<span class="line-modified">400                             temp.getEType());</span>
401                     }
402                 }
403             }
404         }
405         if (result == null) {
406             // Doesn&#39;t seem to be a default cache on this system or
407             // TGT has unsupported encryption type
408 
409             if (!alreadyTried) {
410                 // See if there&#39;s any native code to load
411                 try {
412                     ensureLoaded();
413                 } catch (Exception e) {
414                     if (DEBUG) {
<span class="line-modified">415                         System.out.println(&quot;Can not load credentials cache&quot;);</span>
416                         e.printStackTrace();
417                     }
418                     alreadyTried = true;
419                 }
420             }
421             if (alreadyLoaded) {
422                 // There is some native code
423                 if (DEBUG) {
424                     System.out.println(&quot;&gt;&gt; Acquire default native Credentials&quot;);
425                 }
426                 try {
427                     result = acquireDefaultNativeCreds(
428                             EType.getDefaults(&quot;default_tkt_enctypes&quot;));
429                 } catch (KrbException ke) {
430                     // when there is no default_tkt_enctypes.
431                 }
432             }
433         }
434         return result;
435     }
</pre>
<hr />
<pre>
457         throws KrbException, IOException {
458         return CredentialsUtil.acquireServiceCreds(service, ccreds);
459     }
460 
461     public static Credentials acquireS4U2selfCreds(PrincipalName user,
462             Credentials ccreds) throws KrbException, IOException {
463         return CredentialsUtil.acquireS4U2selfCreds(user, ccreds);
464     }
465 
466     public static Credentials acquireS4U2proxyCreds(String service,
467             Ticket second, PrincipalName client, Credentials ccreds)
468         throws KrbException, IOException {
469         return CredentialsUtil.acquireS4U2proxyCreds(
470                 service, second, client, ccreds);
471     }
472 
473     public CredentialsCache getCache() {
474         return cache;
475     }
476 
<span class="line-removed">477     public EncryptionKey getServiceKey() {</span>
<span class="line-removed">478         return serviceKey;</span>
<span class="line-removed">479     }</span>
<span class="line-removed">480 </span>
481     /*
482      * Prints out debug info.
483      */
484     public static void printDebug(Credentials c) {
485         System.out.println(&quot;&gt;&gt;&gt; DEBUG: ----Credentials----&quot;);
486         System.out.println(&quot;\tclient: &quot; + c.client.toString());


487         System.out.println(&quot;\tserver: &quot; + c.server.toString());


488         System.out.println(&quot;\tticket: sname: &quot; + c.ticket.sname.toString());
489         if (c.startTime != null) {
490             System.out.println(&quot;\tstartTime: &quot; + c.startTime.getTime());
491         }
492         System.out.println(&quot;\tendTime: &quot; + c.endTime.getTime());
493         System.out.println(&quot;        ----Credentials end----&quot;);
494     }
495 
496 
497     static void ensureLoaded() {
498         java.security.AccessController.doPrivileged(
499                 new java.security.PrivilegedAction&lt;Void&gt; () {
500                         public Void run() {
501                                 if (System.getProperty(&quot;os.name&quot;).contains(&quot;OS X&quot;)) {
502                                     System.loadLibrary(&quot;osxkrb5&quot;);
503                                 } else {
504                                     System.loadLibrary(&quot;w2k_lsa_auth&quot;);
505                                 }
506                                 return null;
507                         }
508                 });
509         alreadyLoaded = true;
510     }
511 
512     public String toString() {
513         StringBuilder sb = new StringBuilder(&quot;Credentials:&quot;);
514         sb.append(    &quot;\n      client=&quot;).append(client);


515         sb.append(    &quot;\n      server=&quot;).append(server);


516         if (authTime != null) {
517             sb.append(&quot;\n    authTime=&quot;).append(authTime);
518         }
519         if (startTime != null) {
520             sb.append(&quot;\n   startTime=&quot;).append(startTime);
521         }
522         sb.append(    &quot;\n     endTime=&quot;).append(endTime);
523         sb.append(    &quot;\n   renewTill=&quot;).append(renewTill);
524         sb.append(    &quot;\n       flags=&quot;).append(flags);
525         sb.append(    &quot;\nEType (skey)=&quot;).append(key.getEType());
526         sb.append(    &quot;\n   (tkt key)=&quot;).append(ticket.encPart.eType);
527         return sb.toString();
528     }
529 
530     public sun.security.krb5.internal.ccache.Credentials toCCacheCreds() {
531         return new sun.security.krb5.internal.ccache.Credentials(
532                 getClient(), getServer(),
533                 getSessionKey(),
534                 date2kt(getAuthTime()),
535                 date2kt(getStartTime()),
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 32 package sun.security.krb5;
 33 
 34 import sun.security.action.GetPropertyAction;
 35 import sun.security.krb5.internal.*;
 36 import sun.security.krb5.internal.ccache.CredentialsCache;
 37 import sun.security.krb5.internal.crypto.EType;
 38 import java.io.IOException;
 39 import java.util.Date;
 40 import java.util.Locale;
 41 import java.net.InetAddress;
 42 
 43 /**
 44  * This class encapsulates the concept of a Kerberos service
 45  * credential. That includes a Kerberos ticket and an associated
 46  * session key.
 47  */
 48 public class Credentials {
 49 
 50     Ticket ticket;
 51     PrincipalName client;
<span class="line-added"> 52     PrincipalName clientAlias;</span>
 53     PrincipalName server;
<span class="line-added"> 54     PrincipalName serverAlias;</span>
 55     EncryptionKey key;
 56     TicketFlags flags;
 57     KerberosTime authTime;
 58     KerberosTime startTime;
 59     KerberosTime endTime;
 60     KerberosTime renewTill;
 61     HostAddresses cAddr;

 62     AuthorizationData authzData;
 63     private static boolean DEBUG = Krb5.DEBUG;
 64     private static CredentialsCache cache;
 65     static boolean alreadyLoaded = false;
 66     private static boolean alreadyTried = false;
 67 
<span class="line-added"> 68     private Credentials proxy = null;</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70     public Credentials getProxy() {</span>
<span class="line-added"> 71         return proxy;</span>
<span class="line-added"> 72     }</span>
<span class="line-added"> 73 </span>
<span class="line-added"> 74     public Credentials setProxy(Credentials proxy) {</span>
<span class="line-added"> 75         this.proxy = proxy;</span>
<span class="line-added"> 76         return this;</span>
<span class="line-added"> 77     }</span>
<span class="line-added"> 78 </span>
 79     // Read native ticket with session key type in the given list
 80     private static native Credentials acquireDefaultNativeCreds(int[] eTypes);
 81 
 82     public Credentials(Ticket new_ticket,
 83                        PrincipalName new_client,
<span class="line-added"> 84                        PrincipalName new_client_alias,</span>
 85                        PrincipalName new_server,
<span class="line-added"> 86                        PrincipalName new_server_alias,</span>
 87                        EncryptionKey new_key,
 88                        TicketFlags new_flags,
 89                        KerberosTime authTime,
 90                        KerberosTime new_startTime,
 91                        KerberosTime new_endTime,
 92                        KerberosTime renewTill,
 93                        HostAddresses cAddr,
 94                        AuthorizationData authzData) {
<span class="line-modified"> 95         this(new_ticket, new_client, new_client_alias, new_server,</span>
<span class="line-modified"> 96                 new_server_alias, new_key, new_flags, authTime,</span>
<span class="line-added"> 97                 new_startTime, new_endTime, renewTill, cAddr);</span>
 98         this.authzData = authzData;
 99     }
100 
<span class="line-added">101     // Warning: called by NativeCreds.c and nativeccache.c</span>
102     public Credentials(Ticket new_ticket,
103                        PrincipalName new_client,
<span class="line-added">104                        PrincipalName new_client_alias,</span>
105                        PrincipalName new_server,
<span class="line-added">106                        PrincipalName new_server_alias,</span>
107                        EncryptionKey new_key,
108                        TicketFlags new_flags,
109                        KerberosTime authTime,
110                        KerberosTime new_startTime,
111                        KerberosTime new_endTime,
112                        KerberosTime renewTill,
113                        HostAddresses cAddr) {
114         ticket = new_ticket;
115         client = new_client;
<span class="line-added">116         clientAlias = new_client_alias;</span>
117         server = new_server;
<span class="line-added">118         serverAlias = new_server_alias;</span>
119         key = new_key;
120         flags = new_flags;
121         this.authTime = authTime;
122         startTime = new_startTime;
123         endTime = new_endTime;
124         this.renewTill = renewTill;
125         this.cAddr = cAddr;
126     }
127 
128     public Credentials(byte[] encoding,
129                        String client,
<span class="line-added">130                        String clientAlias,</span>
131                        String server,
<span class="line-added">132                        String serverAlias,</span>
133                        byte[] keyBytes,
134                        int keyType,
135                        boolean[] flags,
136                        Date authTime,
137                        Date startTime,
138                        Date endTime,
139                        Date renewTill,
140                        InetAddress[] cAddrs) throws KrbException, IOException {
141         this(new Ticket(encoding),
142              new PrincipalName(client, PrincipalName.KRB_NT_PRINCIPAL),
<span class="line-added">143              (clientAlias == null? null : new PrincipalName(clientAlias,</span>
<span class="line-added">144                      PrincipalName.KRB_NT_PRINCIPAL)),</span>
145              new PrincipalName(server, PrincipalName.KRB_NT_SRV_INST),
<span class="line-added">146              (serverAlias == null? null : new PrincipalName(serverAlias,</span>
<span class="line-added">147                      PrincipalName.KRB_NT_SRV_INST)),</span>
148              new EncryptionKey(keyType, keyBytes),
149              (flags == null? null: new TicketFlags(flags)),
150              (authTime == null? null: new KerberosTime(authTime)),
151              (startTime == null? null: new KerberosTime(startTime)),
152              (endTime == null? null: new KerberosTime(endTime)),
153              (renewTill == null? null: new KerberosTime(renewTill)),
154              null); // caddrs are in the encoding at this point
155     }
156 
157     /**
158      * Acquires a service ticket for the specified service
159      * principal. If the service ticket is not already available, it
160      * obtains a new one from the KDC.
161      */
162     /*
163     public Credentials(Credentials tgt, PrincipalName service)
164         throws KrbException {
165     }
166     */
167 
168     public final PrincipalName getClient() {
169         return client;
170     }
171 
<span class="line-added">172     public final PrincipalName getClientAlias() {</span>
<span class="line-added">173         return clientAlias;</span>
<span class="line-added">174     }</span>
<span class="line-added">175 </span>
176     public final PrincipalName getServer() {
177         return server;
178     }
179 
<span class="line-added">180     public final PrincipalName getServerAlias() {</span>
<span class="line-added">181         return serverAlias;</span>
<span class="line-added">182     }</span>
<span class="line-added">183 </span>
184     public final EncryptionKey getSessionKey() {
185         return key;
186     }
187 
188     public final Date getAuthTime() {
189         if (authTime != null) {
190             return authTime.toDate();
191         } else {
192             return null;
193         }
194     }
195 
196     public final Date getStartTime() {
197         if (startTime != null)
198             {
199                 return startTime.toDate();
200             }
201         return null;
202     }
203 
</pre>
<hr />
<pre>
219 
220     public final boolean[] getFlags() {
221         if (flags == null) // Can be in a KRB-CRED
222         return null;
223         return flags.toBooleanArray();
224     }
225 
226     public final InetAddress[] getClientAddresses() {
227 
228         if (cAddr == null)
229         return null;
230 
231         return cAddr.getInetAddresses();
232     }
233 
234     public final byte[] getEncoded() {
235         byte[] retVal = null;
236         try {
237             retVal = ticket.asn1Encode();
238         } catch (Asn1Exception e) {
<span class="line-modified">239             if (DEBUG) {</span>
<span class="line-modified">240                 System.out.println(e);</span>
<span class="line-added">241             }</span>
242         } catch (IOException ioe) {
<span class="line-modified">243             if (DEBUG) {</span>
<span class="line-modified">244                 System.out.println(ioe);</span>
<span class="line-added">245             }</span>
246         }
247         return retVal;
248     }
249 
250     public boolean isForwardable() {
251         return flags.get(Krb5.TKT_OPTS_FORWARDABLE);
252     }
253 
254     public boolean isRenewable() {
255         return flags.get(Krb5.TKT_OPTS_RENEWABLE);
256     }
257 
258     public Ticket getTicket() {
259         return ticket;
260     }
261 
262     public TicketFlags getTicketFlags() {
263         return flags;
264     }
265 
</pre>
<hr />
<pre>
281      * flag set. This info must be preservable and restorable through
282      * the Krb5Util.credsToTicket/ticketToCreds() methods so that even if
283      * the service ticket is cached it still remembers the cross-realm
284      * authentication result.
285      */
286     public void resetDelegate() {
287         flags.set(Krb5.TKT_OPTS_DELEGATE, false);
288     }
289 
290     public Credentials renew() throws KrbException, IOException {
291         KDCOptions options = new KDCOptions();
292         options.set(KDCOptions.RENEW, true);
293         /*
294          * Added here to pass KrbKdcRep.check:73
295          */
296         options.set(KDCOptions.RENEWABLE, true);
297 
298         return new KrbTgsReq(options,
299                              this,
300                              server,
<span class="line-added">301                              serverAlias,</span>
302                              null, // from
303                              null, // till
304                              null, // rtime
305                              null, // eTypes
306                              cAddr,
307                              null,
308                              null,
309                              null).sendAndGetCreds();
310     }
311 
312     /**
313      * Returns a TGT for the given client principal from a ticket cache.
314      *
315      * @param princ the client principal. A value of null means that the
316      * default principal name in the credentials cache will be used.
317      * @param ticketCache the path to the tickets file. A value
318      * of null will be accepted to indicate that the default
319      * path should be searched
320      * @return the TGT credentials or null if none were found. If the tgt
321      * expired, it is the responsibility of the caller to determine this.
322      */
323     public static Credentials acquireTGTFromCache(PrincipalName princ,
324                                                   String ticketCache)
325         throws KrbException, IOException {
326 
327         if (ticketCache == null) {
328             // The default ticket cache on Windows and Mac is not a file.
329             String os = GetPropertyAction.privilegedGetProperty(&quot;os.name&quot;);
330             if (os.toUpperCase(Locale.ENGLISH).startsWith(&quot;WINDOWS&quot;) ||
331                     os.toUpperCase(Locale.ENGLISH).contains(&quot;OS X&quot;)) {
332                 Credentials creds = acquireDefaultCreds();
333                 if (creds == null) {
334                     if (DEBUG) {
<span class="line-modified">335                         System.out.println(&quot;&gt;&gt;&gt; Found no TGT&#39;s in native ccache&quot;);</span>
336                     }
337                     return null;
338                 }
339                 if (princ != null) {
340                     if (creds.getClient().equals(princ)) {
341                         if (DEBUG) {
<span class="line-modified">342                             System.out.println(&quot;&gt;&gt;&gt; Obtained TGT from native ccache: &quot;</span>
343                                                + creds);
344                         }
345                         return creds;
346                     } else {
347                         if (DEBUG) {
<span class="line-modified">348                             System.out.println(&quot;&gt;&gt;&gt; native ccache contains TGT for &quot;</span>
349                                                + creds.getClient()
350                                                + &quot; not &quot;
351                                                + princ);
352                         }
353                         return null;
354                     }
355                 } else {
356                     if (DEBUG) {
<span class="line-modified">357                         System.out.println(&quot;&gt;&gt;&gt; Obtained TGT from native ccache: &quot;</span>
358                                            + creds);
359                     }
360                     return creds;
361                 }
362             }
363         }
364 
365         /*
366          * Returns the appropriate cache. If ticketCache is null, it is the
367          * default cache otherwise it is the cache filename contained in it.
368          */
369         CredentialsCache ccache =
370             CredentialsCache.getInstance(princ, ticketCache);
371 
372         if (ccache == null) {
373             return null;
374         }
375 
<span class="line-modified">376         Credentials tgtCred = ccache.getInitialCreds();</span>

377 
378         if (tgtCred == null) {
379             return null;
380         }
381 
<span class="line-modified">382         if (EType.isSupported(tgtCred.key.getEType())) {</span>
<span class="line-modified">383             return tgtCred;</span>
384         } else {
385             if (DEBUG) {
386                 System.out.println(
387                     &quot;&gt;&gt;&gt; unsupported key type found the default TGT: &quot; +
<span class="line-modified">388                     tgtCred.key.getEType());</span>
389             }
390             return null;
391         }
392     }
393 
394     /**
395      * Acquires default credentials.
396      * &lt;br&gt;The possible locations for default credentials cache is searched in
397      * the following order:
398      * &lt;ol&gt;
399      * &lt;li&gt; The directory and cache file name specified by &quot;KRB5CCNAME&quot; system.
400      * property.
401      * &lt;li&gt; The directory and cache file name specified by &quot;KRB5CCNAME&quot;
402      * environment variable.
403      * &lt;li&gt; A cache file named krb5cc_{user.name} at {user.home} directory.
404      * &lt;/ol&gt;
405      * @return a &lt;code&gt;KrbCreds&lt;/code&gt; object if the credential is found,
406      * otherwise return null.
407      */
408 
409     // this method is intentionally changed to not check if the caller&#39;s
410     // principal name matches cache file&#39;s principal name.
411     // It assumes that the GSS call has
412     // the privilege to access the default cache file.
413 
414     // This method is only called on Windows and Mac OS X, the native
415     // acquireDefaultNativeCreds is also available on these platforms.
416     public static synchronized Credentials acquireDefaultCreds() {
417         Credentials result = null;
418 
419         if (cache == null) {
420             cache = CredentialsCache.getInstance();
421         }
422         if (cache != null) {
<span class="line-modified">423             Credentials temp = cache.getInitialCreds();</span>

424             if (temp != null) {
425                 if (DEBUG) {
426                     System.out.println(&quot;&gt;&gt;&gt; KrbCreds found the default ticket&quot;
427                             + &quot; granting ticket in credential cache.&quot;);
428                 }
<span class="line-modified">429                 if (EType.isSupported(temp.key.getEType())) {</span>
<span class="line-modified">430                     result = temp;</span>
431                 } else {
432                     if (DEBUG) {
433                         System.out.println(
434                             &quot;&gt;&gt;&gt; unsupported key type found the default TGT: &quot; +
<span class="line-modified">435                             temp.key.getEType());</span>
436                     }
437                 }
438             }
439         }
440         if (result == null) {
441             // Doesn&#39;t seem to be a default cache on this system or
442             // TGT has unsupported encryption type
443 
444             if (!alreadyTried) {
445                 // See if there&#39;s any native code to load
446                 try {
447                     ensureLoaded();
448                 } catch (Exception e) {
449                     if (DEBUG) {
<span class="line-modified">450                         System.out.println(&quot;Can not load native ccache library&quot;);</span>
451                         e.printStackTrace();
452                     }
453                     alreadyTried = true;
454                 }
455             }
456             if (alreadyLoaded) {
457                 // There is some native code
458                 if (DEBUG) {
459                     System.out.println(&quot;&gt;&gt; Acquire default native Credentials&quot;);
460                 }
461                 try {
462                     result = acquireDefaultNativeCreds(
463                             EType.getDefaults(&quot;default_tkt_enctypes&quot;));
464                 } catch (KrbException ke) {
465                     // when there is no default_tkt_enctypes.
466                 }
467             }
468         }
469         return result;
470     }
</pre>
<hr />
<pre>
492         throws KrbException, IOException {
493         return CredentialsUtil.acquireServiceCreds(service, ccreds);
494     }
495 
496     public static Credentials acquireS4U2selfCreds(PrincipalName user,
497             Credentials ccreds) throws KrbException, IOException {
498         return CredentialsUtil.acquireS4U2selfCreds(user, ccreds);
499     }
500 
501     public static Credentials acquireS4U2proxyCreds(String service,
502             Ticket second, PrincipalName client, Credentials ccreds)
503         throws KrbException, IOException {
504         return CredentialsUtil.acquireS4U2proxyCreds(
505                 service, second, client, ccreds);
506     }
507 
508     public CredentialsCache getCache() {
509         return cache;
510     }
511 




512     /*
513      * Prints out debug info.
514      */
515     public static void printDebug(Credentials c) {
516         System.out.println(&quot;&gt;&gt;&gt; DEBUG: ----Credentials----&quot;);
517         System.out.println(&quot;\tclient: &quot; + c.client.toString());
<span class="line-added">518         if (c.clientAlias != null)</span>
<span class="line-added">519             System.out.println(&quot;\tclient alias: &quot; + c.clientAlias.toString());</span>
520         System.out.println(&quot;\tserver: &quot; + c.server.toString());
<span class="line-added">521         if (c.serverAlias != null)</span>
<span class="line-added">522             System.out.println(&quot;\tserver alias: &quot; + c.serverAlias.toString());</span>
523         System.out.println(&quot;\tticket: sname: &quot; + c.ticket.sname.toString());
524         if (c.startTime != null) {
525             System.out.println(&quot;\tstartTime: &quot; + c.startTime.getTime());
526         }
527         System.out.println(&quot;\tendTime: &quot; + c.endTime.getTime());
528         System.out.println(&quot;        ----Credentials end----&quot;);
529     }
530 
531 
532     static void ensureLoaded() {
533         java.security.AccessController.doPrivileged(
534                 new java.security.PrivilegedAction&lt;Void&gt; () {
535                         public Void run() {
536                                 if (System.getProperty(&quot;os.name&quot;).contains(&quot;OS X&quot;)) {
537                                     System.loadLibrary(&quot;osxkrb5&quot;);
538                                 } else {
539                                     System.loadLibrary(&quot;w2k_lsa_auth&quot;);
540                                 }
541                                 return null;
542                         }
543                 });
544         alreadyLoaded = true;
545     }
546 
547     public String toString() {
548         StringBuilder sb = new StringBuilder(&quot;Credentials:&quot;);
549         sb.append(    &quot;\n      client=&quot;).append(client);
<span class="line-added">550         if (clientAlias != null)</span>
<span class="line-added">551             sb.append(    &quot;\n      clientAlias=&quot;).append(clientAlias);</span>
552         sb.append(    &quot;\n      server=&quot;).append(server);
<span class="line-added">553         if (serverAlias != null)</span>
<span class="line-added">554             sb.append(    &quot;\n      serverAlias=&quot;).append(serverAlias);</span>
555         if (authTime != null) {
556             sb.append(&quot;\n    authTime=&quot;).append(authTime);
557         }
558         if (startTime != null) {
559             sb.append(&quot;\n   startTime=&quot;).append(startTime);
560         }
561         sb.append(    &quot;\n     endTime=&quot;).append(endTime);
562         sb.append(    &quot;\n   renewTill=&quot;).append(renewTill);
563         sb.append(    &quot;\n       flags=&quot;).append(flags);
564         sb.append(    &quot;\nEType (skey)=&quot;).append(key.getEType());
565         sb.append(    &quot;\n   (tkt key)=&quot;).append(ticket.encPart.eType);
566         return sb.toString();
567     }
568 
569     public sun.security.krb5.internal.ccache.Credentials toCCacheCreds() {
570         return new sun.security.krb5.internal.ccache.Credentials(
571                 getClient(), getServer(),
572                 getSessionKey(),
573                 date2kt(getAuthTime()),
574                 date2kt(getStartTime()),
</pre>
</td>
</tr>
</table>
<center><a href="Config.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="EncryptionKey.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
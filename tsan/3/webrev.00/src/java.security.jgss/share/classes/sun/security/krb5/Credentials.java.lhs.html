<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.security.jgss/share/classes/sun/security/krb5/Credentials.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  *
 28  *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 29  *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 30  */
 31 
 32 package sun.security.krb5;
 33 
 34 import sun.security.action.GetPropertyAction;
 35 import sun.security.krb5.internal.*;
 36 import sun.security.krb5.internal.ccache.CredentialsCache;
 37 import sun.security.krb5.internal.crypto.EType;
 38 import java.io.IOException;
 39 import java.util.Date;
 40 import java.util.Locale;
 41 import java.net.InetAddress;
 42 
 43 /**
 44  * This class encapsulates the concept of a Kerberos service
 45  * credential. That includes a Kerberos ticket and an associated
 46  * session key.
 47  */
 48 public class Credentials {
 49 
 50     Ticket ticket;
 51     PrincipalName client;
<a name="2" id="anc2"></a>
 52     PrincipalName server;
<a name="3" id="anc3"></a>
 53     EncryptionKey key;
 54     TicketFlags flags;
 55     KerberosTime authTime;
 56     KerberosTime startTime;
 57     KerberosTime endTime;
 58     KerberosTime renewTill;
 59     HostAddresses cAddr;
<a name="4" id="anc4"></a><span class="line-removed"> 60     EncryptionKey serviceKey;</span>
 61     AuthorizationData authzData;
 62     private static boolean DEBUG = Krb5.DEBUG;
 63     private static CredentialsCache cache;
 64     static boolean alreadyLoaded = false;
 65     private static boolean alreadyTried = false;
 66 
<a name="5" id="anc5"></a>










 67     // Read native ticket with session key type in the given list
 68     private static native Credentials acquireDefaultNativeCreds(int[] eTypes);
 69 
 70     public Credentials(Ticket new_ticket,
 71                        PrincipalName new_client,
<a name="6" id="anc6"></a>
 72                        PrincipalName new_server,
<a name="7" id="anc7"></a>
 73                        EncryptionKey new_key,
 74                        TicketFlags new_flags,
 75                        KerberosTime authTime,
 76                        KerberosTime new_startTime,
 77                        KerberosTime new_endTime,
 78                        KerberosTime renewTill,
 79                        HostAddresses cAddr,
 80                        AuthorizationData authzData) {
<a name="8" id="anc8"></a><span class="line-modified"> 81         this(new_ticket, new_client, new_server, new_key, new_flags,</span>
<span class="line-modified"> 82                 authTime, new_startTime, new_endTime, renewTill, cAddr);</span>

 83         this.authzData = authzData;
 84     }
 85 
<a name="9" id="anc9"></a>
 86     public Credentials(Ticket new_ticket,
 87                        PrincipalName new_client,
<a name="10" id="anc10"></a>
 88                        PrincipalName new_server,
<a name="11" id="anc11"></a>
 89                        EncryptionKey new_key,
 90                        TicketFlags new_flags,
 91                        KerberosTime authTime,
 92                        KerberosTime new_startTime,
 93                        KerberosTime new_endTime,
 94                        KerberosTime renewTill,
 95                        HostAddresses cAddr) {
 96         ticket = new_ticket;
 97         client = new_client;
<a name="12" id="anc12"></a>
 98         server = new_server;
<a name="13" id="anc13"></a>
 99         key = new_key;
100         flags = new_flags;
101         this.authTime = authTime;
102         startTime = new_startTime;
103         endTime = new_endTime;
104         this.renewTill = renewTill;
105         this.cAddr = cAddr;
106     }
107 
108     public Credentials(byte[] encoding,
109                        String client,
<a name="14" id="anc14"></a>
110                        String server,
<a name="15" id="anc15"></a>
111                        byte[] keyBytes,
112                        int keyType,
113                        boolean[] flags,
114                        Date authTime,
115                        Date startTime,
116                        Date endTime,
117                        Date renewTill,
118                        InetAddress[] cAddrs) throws KrbException, IOException {
119         this(new Ticket(encoding),
120              new PrincipalName(client, PrincipalName.KRB_NT_PRINCIPAL),
<a name="16" id="anc16"></a>

121              new PrincipalName(server, PrincipalName.KRB_NT_SRV_INST),
<a name="17" id="anc17"></a>

122              new EncryptionKey(keyType, keyBytes),
123              (flags == null? null: new TicketFlags(flags)),
124              (authTime == null? null: new KerberosTime(authTime)),
125              (startTime == null? null: new KerberosTime(startTime)),
126              (endTime == null? null: new KerberosTime(endTime)),
127              (renewTill == null? null: new KerberosTime(renewTill)),
128              null); // caddrs are in the encoding at this point
129     }
130 
131     /**
132      * Acquires a service ticket for the specified service
133      * principal. If the service ticket is not already available, it
134      * obtains a new one from the KDC.
135      */
136     /*
137     public Credentials(Credentials tgt, PrincipalName service)
138         throws KrbException {
139     }
140     */
141 
142     public final PrincipalName getClient() {
143         return client;
144     }
145 
<a name="18" id="anc18"></a>



146     public final PrincipalName getServer() {
147         return server;
148     }
149 
<a name="19" id="anc19"></a>



150     public final EncryptionKey getSessionKey() {
151         return key;
152     }
153 
154     public final Date getAuthTime() {
155         if (authTime != null) {
156             return authTime.toDate();
157         } else {
158             return null;
159         }
160     }
161 
162     public final Date getStartTime() {
163         if (startTime != null)
164             {
165                 return startTime.toDate();
166             }
167         return null;
168     }
169 
170     public final Date getEndTime() {
171         if (endTime != null)
172             {
173                 return endTime.toDate();
174             }
175         return null;
176     }
177 
178     public final Date getRenewTill() {
179         if (renewTill != null)
180             {
181                 return renewTill.toDate();
182             }
183         return null;
184     }
185 
186     public final boolean[] getFlags() {
187         if (flags == null) // Can be in a KRB-CRED
188         return null;
189         return flags.toBooleanArray();
190     }
191 
192     public final InetAddress[] getClientAddresses() {
193 
194         if (cAddr == null)
195         return null;
196 
197         return cAddr.getInetAddresses();
198     }
199 
200     public final byte[] getEncoded() {
201         byte[] retVal = null;
202         try {
203             retVal = ticket.asn1Encode();
204         } catch (Asn1Exception e) {
<a name="20" id="anc20"></a><span class="line-modified">205             if (DEBUG)</span>
<span class="line-modified">206             System.out.println(e);</span>

207         } catch (IOException ioe) {
<a name="21" id="anc21"></a><span class="line-modified">208             if (DEBUG)</span>
<span class="line-modified">209             System.out.println(ioe);</span>

210         }
211         return retVal;
212     }
213 
214     public boolean isForwardable() {
215         return flags.get(Krb5.TKT_OPTS_FORWARDABLE);
216     }
217 
218     public boolean isRenewable() {
219         return flags.get(Krb5.TKT_OPTS_RENEWABLE);
220     }
221 
222     public Ticket getTicket() {
223         return ticket;
224     }
225 
226     public TicketFlags getTicketFlags() {
227         return flags;
228     }
229 
230     public AuthorizationData getAuthzData() {
231         return authzData;
232     }
233     /**
234      * Checks if the service ticket returned by the KDC has the OK-AS-DELEGATE
235      * flag set
236      * @return true if OK-AS_DELEGATE flag is set, otherwise, return false.
237      */
238     public boolean checkDelegate() {
239         return flags.get(Krb5.TKT_OPTS_DELEGATE);
240     }
241 
242     /**
243      * Reset TKT_OPTS_DELEGATE to false, called at credentials acquirement
244      * when one of the cross-realm TGTs does not have the OK-AS-DELEGATE
245      * flag set. This info must be preservable and restorable through
246      * the Krb5Util.credsToTicket/ticketToCreds() methods so that even if
247      * the service ticket is cached it still remembers the cross-realm
248      * authentication result.
249      */
250     public void resetDelegate() {
251         flags.set(Krb5.TKT_OPTS_DELEGATE, false);
252     }
253 
254     public Credentials renew() throws KrbException, IOException {
255         KDCOptions options = new KDCOptions();
256         options.set(KDCOptions.RENEW, true);
257         /*
258          * Added here to pass KrbKdcRep.check:73
259          */
260         options.set(KDCOptions.RENEWABLE, true);
261 
262         return new KrbTgsReq(options,
263                              this,
264                              server,
<a name="22" id="anc22"></a>
265                              null, // from
266                              null, // till
267                              null, // rtime
268                              null, // eTypes
269                              cAddr,
270                              null,
271                              null,
272                              null).sendAndGetCreds();
273     }
274 
275     /**
276      * Returns a TGT for the given client principal from a ticket cache.
277      *
278      * @param princ the client principal. A value of null means that the
279      * default principal name in the credentials cache will be used.
280      * @param ticketCache the path to the tickets file. A value
281      * of null will be accepted to indicate that the default
282      * path should be searched
283      * @return the TGT credentials or null if none were found. If the tgt
284      * expired, it is the responsibility of the caller to determine this.
285      */
286     public static Credentials acquireTGTFromCache(PrincipalName princ,
287                                                   String ticketCache)
288         throws KrbException, IOException {
289 
290         if (ticketCache == null) {
291             // The default ticket cache on Windows and Mac is not a file.
292             String os = GetPropertyAction.privilegedGetProperty(&quot;os.name&quot;);
293             if (os.toUpperCase(Locale.ENGLISH).startsWith(&quot;WINDOWS&quot;) ||
294                     os.toUpperCase(Locale.ENGLISH).contains(&quot;OS X&quot;)) {
295                 Credentials creds = acquireDefaultCreds();
296                 if (creds == null) {
297                     if (DEBUG) {
<a name="23" id="anc23"></a><span class="line-modified">298                         System.out.println(&quot;&gt;&gt;&gt; Found no TGT&#39;s in LSA&quot;);</span>
299                     }
300                     return null;
301                 }
302                 if (princ != null) {
303                     if (creds.getClient().equals(princ)) {
304                         if (DEBUG) {
<a name="24" id="anc24"></a><span class="line-modified">305                             System.out.println(&quot;&gt;&gt;&gt; Obtained TGT from LSA: &quot;</span>
306                                                + creds);
307                         }
308                         return creds;
309                     } else {
310                         if (DEBUG) {
<a name="25" id="anc25"></a><span class="line-modified">311                             System.out.println(&quot;&gt;&gt;&gt; LSA contains TGT for &quot;</span>
312                                                + creds.getClient()
313                                                + &quot; not &quot;
314                                                + princ);
315                         }
316                         return null;
317                     }
318                 } else {
319                     if (DEBUG) {
<a name="26" id="anc26"></a><span class="line-modified">320                         System.out.println(&quot;&gt;&gt;&gt; Obtained TGT from LSA: &quot;</span>
321                                            + creds);
322                     }
323                     return creds;
324                 }
325             }
326         }
327 
328         /*
329          * Returns the appropriate cache. If ticketCache is null, it is the
330          * default cache otherwise it is the cache filename contained in it.
331          */
332         CredentialsCache ccache =
333             CredentialsCache.getInstance(princ, ticketCache);
334 
335         if (ccache == null) {
336             return null;
337         }
338 
<a name="27" id="anc27"></a><span class="line-modified">339         sun.security.krb5.internal.ccache.Credentials tgtCred  =</span>
<span class="line-removed">340             ccache.getDefaultCreds();</span>
341 
342         if (tgtCred == null) {
343             return null;
344         }
345 
<a name="28" id="anc28"></a><span class="line-modified">346         if (EType.isSupported(tgtCred.getEType())) {</span>
<span class="line-modified">347             return tgtCred.setKrbCreds();</span>
348         } else {
349             if (DEBUG) {
350                 System.out.println(
351                     &quot;&gt;&gt;&gt; unsupported key type found the default TGT: &quot; +
<a name="29" id="anc29"></a><span class="line-modified">352                     tgtCred.getEType());</span>
353             }
354             return null;
355         }
356     }
357 
358     /**
359      * Acquires default credentials.
360      * &lt;br&gt;The possible locations for default credentials cache is searched in
361      * the following order:
362      * &lt;ol&gt;
363      * &lt;li&gt; The directory and cache file name specified by &quot;KRB5CCNAME&quot; system.
364      * property.
365      * &lt;li&gt; The directory and cache file name specified by &quot;KRB5CCNAME&quot;
366      * environment variable.
367      * &lt;li&gt; A cache file named krb5cc_{user.name} at {user.home} directory.
368      * &lt;/ol&gt;
369      * @return a &lt;code&gt;KrbCreds&lt;/code&gt; object if the credential is found,
370      * otherwise return null.
371      */
372 
373     // this method is intentionally changed to not check if the caller&#39;s
374     // principal name matches cache file&#39;s principal name.
375     // It assumes that the GSS call has
376     // the privilege to access the default cache file.
377 
378     // This method is only called on Windows and Mac OS X, the native
379     // acquireDefaultNativeCreds is also available on these platforms.
380     public static synchronized Credentials acquireDefaultCreds() {
381         Credentials result = null;
382 
383         if (cache == null) {
384             cache = CredentialsCache.getInstance();
385         }
386         if (cache != null) {
<a name="30" id="anc30"></a><span class="line-modified">387             sun.security.krb5.internal.ccache.Credentials temp =</span>
<span class="line-removed">388                 cache.getDefaultCreds();</span>
389             if (temp != null) {
390                 if (DEBUG) {
391                     System.out.println(&quot;&gt;&gt;&gt; KrbCreds found the default ticket&quot;
392                             + &quot; granting ticket in credential cache.&quot;);
393                 }
<a name="31" id="anc31"></a><span class="line-modified">394                 if (EType.isSupported(temp.getEType())) {</span>
<span class="line-modified">395                     result = temp.setKrbCreds();</span>
396                 } else {
397                     if (DEBUG) {
398                         System.out.println(
399                             &quot;&gt;&gt;&gt; unsupported key type found the default TGT: &quot; +
<a name="32" id="anc32"></a><span class="line-modified">400                             temp.getEType());</span>
401                     }
402                 }
403             }
404         }
405         if (result == null) {
406             // Doesn&#39;t seem to be a default cache on this system or
407             // TGT has unsupported encryption type
408 
409             if (!alreadyTried) {
410                 // See if there&#39;s any native code to load
411                 try {
412                     ensureLoaded();
413                 } catch (Exception e) {
414                     if (DEBUG) {
<a name="33" id="anc33"></a><span class="line-modified">415                         System.out.println(&quot;Can not load credentials cache&quot;);</span>
416                         e.printStackTrace();
417                     }
418                     alreadyTried = true;
419                 }
420             }
421             if (alreadyLoaded) {
422                 // There is some native code
423                 if (DEBUG) {
424                     System.out.println(&quot;&gt;&gt; Acquire default native Credentials&quot;);
425                 }
426                 try {
427                     result = acquireDefaultNativeCreds(
428                             EType.getDefaults(&quot;default_tkt_enctypes&quot;));
429                 } catch (KrbException ke) {
430                     // when there is no default_tkt_enctypes.
431                 }
432             }
433         }
434         return result;
435     }
436 
437     /**
438      * Acquires credentials for a specified service using initial credential.
439      * When the service has a different realm
440      * from the initial credential, we do cross-realm authentication
441      * - first, we use the current credential to get
442      * a cross-realm credential from the local KDC, then use that
443      * cross-realm credential to request service credential
444      * from the foreigh KDC.
445      *
446      * @param service the name of service principal using format
447      * components@realm
448      * @param ccreds client&#39;s initial credential.
449      * @exception IOException if an error occurs in reading the credentials
450      * cache
451      * @exception KrbException if an error occurs specific to Kerberos
452      * @return a &lt;code&gt;Credentials&lt;/code&gt; object.
453      */
454 
455     public static Credentials acquireServiceCreds(String service,
456                                                   Credentials ccreds)
457         throws KrbException, IOException {
458         return CredentialsUtil.acquireServiceCreds(service, ccreds);
459     }
460 
461     public static Credentials acquireS4U2selfCreds(PrincipalName user,
462             Credentials ccreds) throws KrbException, IOException {
463         return CredentialsUtil.acquireS4U2selfCreds(user, ccreds);
464     }
465 
466     public static Credentials acquireS4U2proxyCreds(String service,
467             Ticket second, PrincipalName client, Credentials ccreds)
468         throws KrbException, IOException {
469         return CredentialsUtil.acquireS4U2proxyCreds(
470                 service, second, client, ccreds);
471     }
472 
473     public CredentialsCache getCache() {
474         return cache;
475     }
476 
<a name="34" id="anc34"></a><span class="line-removed">477     public EncryptionKey getServiceKey() {</span>
<span class="line-removed">478         return serviceKey;</span>
<span class="line-removed">479     }</span>
<span class="line-removed">480 </span>
481     /*
482      * Prints out debug info.
483      */
484     public static void printDebug(Credentials c) {
485         System.out.println(&quot;&gt;&gt;&gt; DEBUG: ----Credentials----&quot;);
486         System.out.println(&quot;\tclient: &quot; + c.client.toString());
<a name="35" id="anc35"></a>

487         System.out.println(&quot;\tserver: &quot; + c.server.toString());
<a name="36" id="anc36"></a>

488         System.out.println(&quot;\tticket: sname: &quot; + c.ticket.sname.toString());
489         if (c.startTime != null) {
490             System.out.println(&quot;\tstartTime: &quot; + c.startTime.getTime());
491         }
492         System.out.println(&quot;\tendTime: &quot; + c.endTime.getTime());
493         System.out.println(&quot;        ----Credentials end----&quot;);
494     }
495 
496 
497     static void ensureLoaded() {
498         java.security.AccessController.doPrivileged(
499                 new java.security.PrivilegedAction&lt;Void&gt; () {
500                         public Void run() {
501                                 if (System.getProperty(&quot;os.name&quot;).contains(&quot;OS X&quot;)) {
502                                     System.loadLibrary(&quot;osxkrb5&quot;);
503                                 } else {
504                                     System.loadLibrary(&quot;w2k_lsa_auth&quot;);
505                                 }
506                                 return null;
507                         }
508                 });
509         alreadyLoaded = true;
510     }
511 
512     public String toString() {
513         StringBuilder sb = new StringBuilder(&quot;Credentials:&quot;);
514         sb.append(    &quot;\n      client=&quot;).append(client);
<a name="37" id="anc37"></a>

515         sb.append(    &quot;\n      server=&quot;).append(server);
<a name="38" id="anc38"></a>

516         if (authTime != null) {
517             sb.append(&quot;\n    authTime=&quot;).append(authTime);
518         }
519         if (startTime != null) {
520             sb.append(&quot;\n   startTime=&quot;).append(startTime);
521         }
522         sb.append(    &quot;\n     endTime=&quot;).append(endTime);
523         sb.append(    &quot;\n   renewTill=&quot;).append(renewTill);
524         sb.append(    &quot;\n       flags=&quot;).append(flags);
525         sb.append(    &quot;\nEType (skey)=&quot;).append(key.getEType());
526         sb.append(    &quot;\n   (tkt key)=&quot;).append(ticket.encPart.eType);
527         return sb.toString();
528     }
529 
530     public sun.security.krb5.internal.ccache.Credentials toCCacheCreds() {
531         return new sun.security.krb5.internal.ccache.Credentials(
532                 getClient(), getServer(),
533                 getSessionKey(),
534                 date2kt(getAuthTime()),
535                 date2kt(getStartTime()),
536                 date2kt(getEndTime()),
537                 date2kt(getRenewTill()),
538                 false,
539                 flags,
540                 new HostAddresses(getClientAddresses()),
541                 getAuthzData(),
542                 getTicket(),
543                 null);
544     }
545 
546     private static KerberosTime date2kt(Date d) {
547         return d == null ? null : new KerberosTime(d);
548     }
549 }
<a name="39" id="anc39"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="39" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.security.jgss/share/classes/sun/security/krb5/internal/crypto/dk/DkCrypto.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 
  5 /*
  6  * Copyright (C) 1998 by the FundsXpress, INC.
  7  *
  8  * All rights reserved.
  9  *
 10  * Export of this software from the United States of America may require
 11  * a specific license from the United States Government.  It is the
 12  * responsibility of any person or organization contemplating export to
 13  * obtain such a license before exporting.
 14  *
 15  * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 16  * distribute this software and its documentation for any purpose and
 17  * without fee is hereby granted, provided that the above copyright
 18  * notice appear in all copies and that both that copyright notice and
 19  * this permission notice appear in supporting documentation, and that
 20  * the name of FundsXpress. not be used in advertising or publicity pertaining
 21  * to distribution of the software without specific, written prior
 22  * permission.  FundsXpress makes no representations about the suitability of
 23  * this software for any purpose.  It is provided &quot;as is&quot; without express
 24  * or implied warranty.
 25  *
 26  * THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR
 27  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 28  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 29  */
 30 
 31 package sun.security.krb5.internal.crypto.dk;
 32 
 33 import javax.crypto.Cipher;
 34 import javax.crypto.Mac;
 35 import java.security.GeneralSecurityException;
<a name="2" id="anc2"></a>
 36 import java.util.Arrays;
 37 import java.io.ByteArrayInputStream;
 38 import java.io.ByteArrayOutputStream;
 39 import java.nio.charset.Charset;
 40 import java.nio.CharBuffer;
 41 import java.nio.ByteBuffer;
 42 import sun.security.util.HexDumpEncoder;
 43 import sun.security.krb5.Confounder;
 44 import sun.security.krb5.internal.crypto.KeyUsage;
 45 import sun.security.krb5.KrbCryptoException;
 46 
<a name="3" id="anc3"></a><span class="line-added"> 47 import static java.nio.charset.StandardCharsets.*;</span>
<span class="line-added"> 48 </span>
 49 /**
 50  * Implements Derive Key cryptography functionality as defined in RFC 3961.
 51  * http://www.ietf.org/rfc/rfc3961.txt
 52  *
 53  * This is an abstract class. Concrete subclasses need to implement
 54  * the abstract methods.
 55  */
 56 
 57 public abstract class DkCrypto {
 58 
 59     protected static final boolean debug = false;
 60 
 61     // These values correspond to the ASCII encoding for the string &quot;kerberos&quot;
 62     static final byte[] KERBEROS_CONSTANT =
 63         {0x6b, 0x65, 0x72, 0x62, 0x65, 0x72, 0x6f, 0x73};
 64 
 65     protected abstract int getKeySeedLength();  // in bits
 66 
 67     protected abstract byte[] randomToKey(byte[] in);
 68 
 69     protected abstract Cipher getCipher(byte[] key, byte[] ivec, int mode)
 70         throws GeneralSecurityException;
 71 
 72     public abstract int getChecksumLength();  // in bytes
 73 
 74     protected abstract byte[] getHmac(byte[] key, byte[] plaintext)
 75         throws GeneralSecurityException;
 76 
 77     /**
 78      * From RFC 3961.
 79      *
 80      * encryption function       conf = random string of length c
 81      *                     pad = shortest string to bring confounder
 82      *                           and plaintext to a length that&#39;s a
 83      *                           multiple of m
 84      *                     (C1, newIV) = E(Ke, conf | plaintext | pad,
 85      *                                     oldstate.ivec)
 86      *                    H1 = HMAC(Ki, conf | plaintext | pad)
 87      *                     ciphertext =  C1 | H1[1..h]
 88      *                     newstate.ivec = newIV
 89      *
 90      * @param ivec initial vector to use when initializing the cipher; if null,
 91      *     then blocksize number of zeros are used,
 92      * @param new_ivec if non-null, it is updated upon return to be the
 93      *       new ivec to use when calling encrypt next time
 94      */
 95     public byte[] encrypt(byte[] baseKey, int usage,
 96         byte[] ivec, byte[] new_ivec, byte[] plaintext, int start, int len)
 97         throws GeneralSecurityException, KrbCryptoException {
 98 
 99         if (!KeyUsage.isValid(usage)) {
100             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
101                                                 + usage);
102         }
103 
104         byte[] Ke = null;
105         byte[] Ki = null;
106 
107         try {
108             // Derive encryption key
109 
110             byte[] constant = new byte[5];
111             constant[0] = (byte) ((usage&gt;&gt;24)&amp;0xff);
112             constant[1] = (byte) ((usage&gt;&gt;16)&amp;0xff);
113             constant[2] = (byte) ((usage&gt;&gt;8)&amp;0xff);
114             constant[3] = (byte) (usage&amp;0xff);
115 
116             constant[4] = (byte) 0xaa;
117 
118             Ke = dk(baseKey, constant);
119             if (debug) {
120                 System.err.println(&quot;usage: &quot; + usage);
121                 if (ivec != null) {
122                     traceOutput(&quot;old_state.ivec&quot;, ivec, 0, ivec.length);
123                 }
124                 traceOutput(&quot;plaintext&quot;, plaintext, start, Math.min(len, 32));
125                 traceOutput(&quot;constant&quot;, constant, 0, constant.length);
126                 traceOutput(&quot;baseKey&quot;, baseKey, 0, baseKey.length);
127                 traceOutput(&quot;Ke&quot;, Ke, 0, Ke.length);
128             }
129 
130             // Encrypt
131             // C1 = E(Ke, conf | plaintext | pad, oldivec)
132             Cipher encCipher = getCipher(Ke, ivec, Cipher.ENCRYPT_MODE);
133             int blockSize = encCipher.getBlockSize();
134             byte[] confounder = Confounder.bytes(blockSize);
135 
136             int plainSize = roundup(confounder.length + len, blockSize);
137             if (debug) {
138                 System.err.println(&quot;confounder = &quot; + confounder.length +
139                     &quot;; plaintext = &quot; + len + &quot;; padding = &quot; +
140                     (plainSize - confounder.length - len) + &quot;; total = &quot; +
141                         plainSize);
142                 traceOutput(&quot;confounder&quot;, confounder, 0, confounder.length);
143             }
144 
145             byte[] toBeEncrypted = new byte[plainSize];
146             System.arraycopy(confounder, 0, toBeEncrypted,
147                                 0, confounder.length);
148             System.arraycopy(plaintext, start, toBeEncrypted,
149                                 confounder.length, len);
150 
151             // Set padding bytes to zero
152             Arrays.fill(toBeEncrypted, confounder.length + len, plainSize,
153                         (byte)0);
154 
155             int cipherSize = encCipher.getOutputSize(plainSize);
156             int ccSize =  cipherSize + getChecksumLength();  // cipher | hmac
157 
158             byte[] ciphertext = new byte[ccSize];
159 
160             encCipher.doFinal(toBeEncrypted, 0, plainSize, ciphertext, 0);
161 
162             // Update ivec for next operation
163             // (last blockSize bytes of ciphertext)
164             // newstate.ivec = newIV
165             if (new_ivec != null &amp;&amp; new_ivec.length == blockSize) {
166                 System.arraycopy(ciphertext,  cipherSize - blockSize,
167                     new_ivec, 0, blockSize);
168                 if (debug) {
169                     traceOutput(&quot;new_ivec&quot;, new_ivec, 0, new_ivec.length);
170                 }
171             }
172 
173             // Derive integrity key
174             constant[4] = (byte) 0x55;
175             Ki = dk(baseKey, constant);
176             if (debug) {
177                 traceOutput(&quot;constant&quot;, constant, 0, constant.length);
178                 traceOutput(&quot;Ki&quot;, Ki, 0, Ke.length);
179             }
180 
181             // Generate checksum
182             // H1 = HMAC(Ki, conf | plaintext | pad)
183             byte[] hmac = getHmac(Ki, toBeEncrypted);
184 
185             if (debug) {
186                 traceOutput(&quot;hmac&quot;, hmac, 0, hmac.length);
187                 traceOutput(&quot;ciphertext&quot;, ciphertext, 0,
188                                 Math.min(ciphertext.length, 32));
189             }
190 
191             // C1 | H1[1..h]
192             System.arraycopy(hmac, 0, ciphertext, cipherSize,
193                                 getChecksumLength());
194             return ciphertext;
195         } finally {
196             if (Ke != null) {
197                 Arrays.fill(Ke, 0, Ke.length, (byte) 0);
198             }
199             if (Ki != null) {
200                 Arrays.fill(Ki, 0, Ki.length, (byte) 0);
201             }
202         }
203     }
204 
205     /**
206      * Performs encryption using given key only; does not add
207      * confounder, padding, or checksum. Incoming data to be encrypted
208      * assumed to have the correct blocksize.
209      * Ignore key usage.
210      */
211     public byte[] encryptRaw(byte[] baseKey, int usage,
212         byte[] ivec, byte[] plaintext, int start, int len)
213         throws GeneralSecurityException, KrbCryptoException {
214 
215         if (debug) {
216             System.err.println(&quot;usage: &quot; + usage);
217             if (ivec != null) {
218                 traceOutput(&quot;old_state.ivec&quot;, ivec, 0, ivec.length);
219             }
220             traceOutput(&quot;plaintext&quot;, plaintext, start, Math.min(len, 32));
221             traceOutput(&quot;baseKey&quot;, baseKey, 0, baseKey.length);
222         }
223 
224         // Encrypt
225         Cipher encCipher = getCipher(baseKey, ivec, Cipher.ENCRYPT_MODE);
226         int blockSize = encCipher.getBlockSize();
227 
228         if ((len % blockSize) != 0) {
229             throw new GeneralSecurityException(
230                 &quot;length of data to be encrypted (&quot; + len +
231                 &quot;) is not a multiple of the blocksize (&quot; + blockSize + &quot;)&quot;);
232         }
233 
234         int cipherSize = encCipher.getOutputSize(len);
235         byte[] ciphertext = new byte[cipherSize];
236 
237         encCipher.doFinal(plaintext, 0, len, ciphertext, 0);
238         return ciphertext;
239     }
240 
241     /**
242      * Decrypts data using specified key and initial vector.
243      * @param baseKey encryption key to use
244      * @param ciphertext  encrypted data to be decrypted
245      * @param usage ignored
246      */
247     public byte[] decryptRaw(byte[] baseKey, int usage, byte[] ivec,
248         byte[] ciphertext, int start, int len)
249         throws GeneralSecurityException {
250 
251         if (debug) {
252             System.err.println(&quot;usage: &quot; + usage);
253             if (ivec != null) {
254                 traceOutput(&quot;old_state.ivec&quot;, ivec, 0, ivec.length);
255             }
256             traceOutput(&quot;ciphertext&quot;, ciphertext, start, Math.min(len, 32));
257             traceOutput(&quot;baseKey&quot;, baseKey, 0, baseKey.length);
258         }
259 
260         Cipher decCipher = getCipher(baseKey, ivec, Cipher.DECRYPT_MODE);
261 
262         int blockSize = decCipher.getBlockSize();
263 
264         if ((len % blockSize) != 0) {
265             throw new GeneralSecurityException(
266                 &quot;length of data to be decrypted (&quot; + len +
267                 &quot;) is not a multiple of the blocksize (&quot; + blockSize + &quot;)&quot;);
268         }
269 
270         byte[] decrypted = decCipher.doFinal(ciphertext, start, len);
271 
272         if (debug) {
273             traceOutput(&quot;decrypted&quot;, decrypted, 0,
274                 Math.min(decrypted.length, 32));
275         }
276 
277         return decrypted;
278     }
279 
280     /**
281      * @param baseKey key from which keys are to be derived using usage
282      * @param ciphertext  E(Ke, conf | plaintext | padding, ivec) | H1[1..h]
283      */
284     public byte[] decrypt(byte[] baseKey, int usage, byte[] ivec,
285         byte[] ciphertext, int start, int len) throws GeneralSecurityException {
286 
287         if (!KeyUsage.isValid(usage)) {
288             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
289                                                 + usage);
290         }
291 
292         byte[] Ke = null;
293         byte[] Ki = null;
294 
295         try {
296             // Derive encryption key
297             byte[] constant = new byte[5];
298             constant[0] = (byte) ((usage&gt;&gt;24)&amp;0xff);
299             constant[1] = (byte) ((usage&gt;&gt;16)&amp;0xff);
300             constant[2] = (byte) ((usage&gt;&gt;8)&amp;0xff);
301             constant[3] = (byte) (usage&amp;0xff);
302 
303             constant[4] = (byte) 0xaa;
304 
305             Ke = dk(baseKey, constant);  // Encryption key
306 
307             if (debug) {
308                 System.err.println(&quot;usage: &quot; + usage);
309                 if (ivec != null) {
310                     traceOutput(&quot;old_state.ivec&quot;, ivec, 0, ivec.length);
311                 }
312                 traceOutput(&quot;ciphertext&quot;, ciphertext, start, Math.min(len, 32));
313                 traceOutput(&quot;constant&quot;, constant, 0, constant.length);
314                 traceOutput(&quot;baseKey&quot;, baseKey, 0, baseKey.length);
315                 traceOutput(&quot;Ke&quot;, Ke, 0, Ke.length);
316             }
317 
318             Cipher decCipher = getCipher(Ke, ivec, Cipher.DECRYPT_MODE);
319             int blockSize = decCipher.getBlockSize();
320 
321             // Decrypt [confounder | plaintext | padding] (without checksum)
322             int cksumSize = getChecksumLength();
323             int cipherSize = len - cksumSize;
324             byte[] decrypted = decCipher.doFinal(ciphertext, start, cipherSize);
325 
326             if (debug) {
327                 traceOutput(&quot;decrypted&quot;, decrypted, 0,
328                                 Math.min(decrypted.length, 32));
329             }
330 
331             // decrypted = [confounder | plaintext | padding]
332 
333             // Derive integrity key
334             constant[4] = (byte) 0x55;
335             Ki = dk(baseKey, constant);  // Integrity key
336             if (debug) {
337                 traceOutput(&quot;constant&quot;, constant, 0, constant.length);
338                 traceOutput(&quot;Ki&quot;, Ki, 0, Ke.length);
339             }
340 
341             // Verify checksum
342             // H1 = HMAC(Ki, conf | plaintext | pad)
343             byte[] calculatedHmac = getHmac(Ki, decrypted);
344 
345             if (debug) {
346                 traceOutput(&quot;calculated Hmac&quot;, calculatedHmac, 0,
347                     calculatedHmac.length);
348                 traceOutput(&quot;message Hmac&quot;, ciphertext, cipherSize,
349                     cksumSize);
350             }
351 
352             boolean cksumFailed = false;
353             if (calculatedHmac.length &gt;= cksumSize) {
354                 for (int i = 0; i &lt; cksumSize; i++) {
355                     if (calculatedHmac[i] != ciphertext[cipherSize+i]) {
356                         cksumFailed = true;
357                         break;
358                     }
359                 }
360             }
361 
362             if (cksumFailed) {
363                 throw new GeneralSecurityException(&quot;Checksum failed&quot;);
364             }
365 
366             // Prepare decrypted msg and ivec to be returned
367             // Last blockSize bytes of ciphertext without checksum
368             if (ivec != null &amp;&amp; ivec.length == blockSize) {
369                 System.arraycopy(ciphertext,  start + cipherSize - blockSize,
370                     ivec, 0, blockSize);
371                 if (debug) {
372                     traceOutput(&quot;new_state.ivec&quot;, ivec, 0, ivec.length);
373                 }
374             }
375 
376             // Get rid of confounder
377             // [plaintext | padding]
378             byte[] plaintext = new byte[decrypted.length - blockSize];
379             System.arraycopy(decrypted, blockSize, plaintext,
380                                 0, plaintext.length);
381             return plaintext; // padding still there
382         } finally {
383             if (Ke != null) {
384                 Arrays.fill(Ke, 0, Ke.length, (byte) 0);
385             }
386             if (Ki != null) {
387                 Arrays.fill(Ki, 0, Ki.length, (byte) 0);
388             }
389         }
390     }
391 
392     // Round up to the next blocksize
393     int roundup(int n, int blocksize) {
394         return (((n + blocksize - 1) / blocksize) * blocksize);
395     }
396 
397     public byte[] calculateChecksum(byte[] baseKey, int usage, byte[] input,
398         int start, int len) throws GeneralSecurityException {
399 
400         if (!KeyUsage.isValid(usage)) {
401             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
402                                                 + usage);
403         }
404 
405         // Derive keys
406         byte[] constant = new byte[5];
407         constant[0] = (byte) ((usage&gt;&gt;24)&amp;0xff);
408         constant[1] = (byte) ((usage&gt;&gt;16)&amp;0xff);
409         constant[2] = (byte) ((usage&gt;&gt;8)&amp;0xff);
410         constant[3] = (byte) (usage&amp;0xff);
411 
412         constant[4] = (byte) 0x99;
413 
414         byte[] Kc = dk(baseKey, constant);  // Checksum key
415         if (debug) {
416             System.err.println(&quot;usage: &quot; + usage);
417             traceOutput(&quot;input&quot;, input, start, Math.min(len, 32));
418             traceOutput(&quot;constant&quot;, constant, 0, constant.length);
419             traceOutput(&quot;baseKey&quot;, baseKey, 0, baseKey.length);
420             traceOutput(&quot;Kc&quot;, Kc, 0, Kc.length);
421         }
422 
423         try {
424             // Generate checksum
425             // H1 = HMAC(Kc, input)
426             byte[] hmac = getHmac(Kc, input);
427             if (debug) {
428                 traceOutput(&quot;hmac&quot;, hmac, 0, hmac.length);
429             }
430             if (hmac.length == getChecksumLength()) {
431                 return hmac;
432             } else if (hmac.length &gt; getChecksumLength()) {
433                 byte[] buf = new byte[getChecksumLength()];
434                 System.arraycopy(hmac, 0, buf, 0, buf.length);
435                 return buf;
436             } else {
437                 throw new GeneralSecurityException(&quot;checksum size too short: &quot; +
438                     hmac.length + &quot;; expecting : &quot; + getChecksumLength());
439             }
440         } finally {
441             Arrays.fill(Kc, 0, Kc.length, (byte)0);
442         }
443     }
444 
445     // DK(Key, Constant) = random-to-key(DR(Key, Constant))
446     byte[] dk(byte[] key, byte[] constant)
447         throws GeneralSecurityException {
448         return randomToKey(dr(key, constant));
449     }
450 
451     /*
452      * From RFC 3961.
453      *
454      * DR(Key, Constant) = k-truncate(E(Key, Constant,
455      *                                  initial-cipher-state))
456      *
457      * Here DR is the random-octet generation function described below, and
458      * DK is the key-derivation function produced from it.  In this
459      * construction, E(Key, Plaintext, CipherState) is a cipher, Constant is
460      * a well-known constant determined by the specific usage of this
461      * function, and k-truncate truncates its argument by taking the first k
462      * bits.  Here, k is the key generation seed length needed for the
463      * encryption system.
464      *
465      * The output of the DR function is a string of bits; the actual key is
466      * produced by applying the cryptosystem&#39;s random-to-key operation on
467      * this bitstring.
468      *
469      * If the Constant is smaller than the cipher block size of E, then it
470      * must be expanded with n-fold() so it can be encrypted.  If the output
471      * of E is shorter than k bits it is fed back into the encryption as
472      * many times as necessary.  The construct is as follows (where |
473      * indicates concatentation):
474      *
475      * K1 = E(Key, n-fold(Constant), initial-cipher-state)
476      * K2 = E(Key, K1, initial-cipher-state)
477      * K3 = E(Key, K2, initial-cipher-state)
478      * K4 = ...
479      *
480      * DR(Key, Constant) = k-truncate(K1 | K2 | K3 | K4 ...)
481      */
482     protected byte[] dr(byte[] key, byte[] constant)
483         throws GeneralSecurityException {
484 
485         Cipher encCipher = getCipher(key, null, Cipher.ENCRYPT_MODE);
486         int blocksize = encCipher.getBlockSize();
487 
488         if (constant.length != blocksize) {
489             constant = nfold(constant, blocksize * 8);
490         }
491         byte[] toBeEncrypted = constant;
492 
493         int keybytes = (getKeySeedLength()&gt;&gt;3);  // from bits to bytes
494         byte[] rawkey = new byte[keybytes];
495         int posn = 0;
496 
497         /* loop encrypting the blocks until enough key bytes are generated */
498         int n = 0, len;
499         while (n &lt; keybytes) {
500             if (debug) {
501                 System.err.println(&quot;Encrypting: &quot; +
502                     bytesToString(toBeEncrypted));
503             }
504 
505             byte[] cipherBlock = encCipher.doFinal(toBeEncrypted);
506             if (debug) {
507                 System.err.println(&quot;K: &quot; + ++posn + &quot; = &quot; +
508                     bytesToString(cipherBlock));
509             }
510 
511             len = (keybytes - n &lt;= cipherBlock.length ? (keybytes - n) :
512                 cipherBlock.length);
513             if (debug) {
514                 System.err.println(&quot;copying &quot; + len + &quot; key bytes&quot;);
515             }
516             System.arraycopy(cipherBlock, 0, rawkey, n, len);
517             n += len;
518             toBeEncrypted = cipherBlock;
519         }
520         return rawkey;
521     }
522 
523 // ---------------------------------
524 
525     // From MIT-1.3.1 distribution
526     /*
527      * n-fold(k-bits):
528      *   l = lcm(n,k)
529      *   r = l/k
530      * s = k-bits | k-bits rot 13 | k-bits rot 13*2 | ... | k-bits rot 13*(r-1)
531      * compute the 1&#39;s complement sum:
532      * n-fold = s[0..n-1]+s[n..2n-1]+s[2n..3n-1]+..+s[(k-1)*n..k*n-1]
533      */
534 
535     /*
536      * representation: msb first, assume n and k are multiples of 8, and
537      *  that k&gt;=16.  this is the case of all the cryptosystems which are
538      *  likely to be used.  this function can be replaced if that
539      *  assumption ever fails.
540      */
541 
542     /* input length is in bits */
543     static byte[] nfold(byte[] in, int outbits) {
544 
545         int inbits = in.length;
546         outbits &gt;&gt;= 3;    // count in bytes
547 
548         /* first compute lcm(n,k) */
549         int a, b, c, lcm;
550         a = outbits;  // n
551         b = inbits;   // k
552 
553         while (b != 0) {
554             c = b;
555             b = a % b;
556             a = c;
557         }
558         lcm = outbits*inbits/a;
559 
560         if (debug) {
561             System.err.println(&quot;k: &quot; + inbits);
562             System.err.println(&quot;n: &quot; + outbits);
563             System.err.println(&quot;lcm: &quot; + lcm);
564         }
565 
566         /* now do the real work */
567         byte[] out = new byte[outbits];
568         Arrays.fill(out, (byte)0);
569 
570         int thisbyte = 0;
571         int msbit, i, bval, oval;
572 
573         // this will end up cycling through k lcm(k,n)/k times, which
574         // is correct
575         for (i = lcm-1; i &gt;= 0; i--) {
576             /* compute the msbit in k which gets added into this byte */
577             msbit = (/* first, start with msbit in the first, unrotated byte */
578                 ((inbits&lt;&lt;3)-1)
579                 /* then, for each byte, shift to right for each repetition */
580                 + (((inbits&lt;&lt;3)+13)*(i/inbits))
581                 /* last, pick out correct byte within that shifted repetition */
582                 + ((inbits-(i%inbits)) &lt;&lt; 3)) % (inbits &lt;&lt; 3);
583 
584             /* pull out the byte value itself */
585             // Mask off values using &amp;0xff to get only the lower byte
586             // Use &gt;&gt;&gt; to avoid sign extension
587             bval =  ((((in[((inbits-1)-(msbit&gt;&gt;&gt;3))%inbits]&amp;0xff)&lt;&lt;8)|
588                 (in[((inbits)-(msbit&gt;&gt;&gt;3))%inbits]&amp;0xff))
589                 &gt;&gt;&gt;((msbit&amp;7)+1))&amp;0xff;
590 
591             /*
592             System.err.println(&quot;((&quot; +
593                 ((in[((inbits-1)-(msbit&gt;&gt;&gt;3))%inbits]&amp;0xff)&lt;&lt;8)
594                 + &quot;|&quot; + (in[((inbits)-(msbit&gt;&gt;&gt;3))%inbits]&amp;0xff) + &quot;)&quot;
595                 + &quot;&gt;&gt;&gt;&quot; + ((msbit&amp;7)+1) + &quot;)&amp;0xff = &quot; + bval);
596             */
597 
598             thisbyte += bval;
599 
600             /* do the addition */
601             // Mask off values using &amp;0xff to get only the lower byte
602             oval = (out[i%outbits]&amp;0xff);
603             thisbyte += oval;
604             out[i%outbits] = (byte) (thisbyte&amp;0xff);
605 
606             if (debug) {
607                 System.err.println(&quot;msbit[&quot; + i + &quot;] = &quot; +  msbit + &quot;\tbval=&quot; +
608                     Integer.toHexString(bval) + &quot;\toval=&quot; +
609                     Integer.toHexString(oval)
610                     + &quot;\tsum = &quot; + Integer.toHexString(thisbyte));
611             }
612 
613 
614             /* keep around the carry bit, if any */
615             thisbyte &gt;&gt;&gt;= 8;
616 
617             if (debug) {
618                 System.err.println(&quot;carry=&quot; + thisbyte);
619             }
620         }
621 
622         /* if there&#39;s a carry bit left over, add it back in */
623         if (thisbyte != 0) {
624             for (i = outbits-1; i &gt;= 0; i--) {
625                 /* do the addition */
626                 thisbyte += (out[i]&amp;0xff);
627                 out[i] = (byte) (thisbyte&amp;0xff);
628 
629                 /* keep around the carry bit, if any */
630                 thisbyte &gt;&gt;&gt;= 8;
631             }
632         }
633 
634         return out;
635     }
636 
637     // Routines used for debugging
638     static String bytesToString(byte[] digest) {
639         // Get character representation of digest
640         StringBuilder digestString = new StringBuilder();
641 
642         for (int i = 0; i &lt; digest.length; i++) {
643             if ((digest[i] &amp; 0x000000ff) &lt; 0x10) {
644                 digestString.append(&#39;0&#39;).append(Integer.toHexString(digest[i] &amp; 0x000000ff));
645             } else {
646                 digestString.append(
647                     Integer.toHexString(digest[i] &amp; 0x000000ff));
648             }
649         }
650         return digestString.toString();
651     }
652 
653     private static byte[] binaryStringToBytes(String str) {
654         char[] usageStr = str.toCharArray();
655         byte[] usage = new byte[usageStr.length/2];
656         for (int i = 0; i &lt; usage.length; i++) {
657             byte a = Byte.parseByte(new String(usageStr, i*2, 1), 16);
658             byte b = Byte.parseByte(new String(usageStr, i*2 + 1, 1), 16);
659             usage[i] = (byte) ((a&lt;&lt;4)|b);
660         }
661         return usage;
662     }
663 
664     static void traceOutput(String traceTag, byte[] output, int offset,
665         int len) {
666         try {
667             ByteArrayOutputStream out = new ByteArrayOutputStream(len);
668             new HexDumpEncoder().encodeBuffer(
669                 new ByteArrayInputStream(output, offset, len), out);
670 
671             System.err.println(traceTag + &quot;:\n&quot; + out.toString());
672         } catch (Exception e) {
673         }
674     }
675 
<a name="4" id="anc4"></a><span class="line-modified">676 // String.getBytes(UTF_8);</span>
677 // Do this instead of using String to avoid making password immutable
678     static byte[] charToUtf8(char[] chars) {
<a name="5" id="anc5"></a>

679         CharBuffer cb = CharBuffer.wrap(chars);
<a name="6" id="anc6"></a><span class="line-modified">680         ByteBuffer bb = UTF_8.encode(cb);</span>
681         int len = bb.limit();
682         byte[] answer = new byte[len];
683         bb.get(answer, 0, len);
684         return answer;
685     }
686 
687     static byte[] charToUtf16(char[] chars) {
<a name="7" id="anc7"></a>

688         CharBuffer cb = CharBuffer.wrap(chars);
<a name="8" id="anc8"></a><span class="line-modified">689         ByteBuffer bb = UTF_16LE.encode(cb);</span>
690         int len = bb.limit();
691         byte[] answer = new byte[len];
692         bb.get(answer, 0, len);
693         return answer;
694     }
695 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
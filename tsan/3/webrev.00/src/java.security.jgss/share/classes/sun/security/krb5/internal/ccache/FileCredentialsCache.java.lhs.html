<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.security.jgss/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * ===========================================================================
 28  *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 29  *
 30  *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 31  * ===========================================================================
 32  *
 33  */
 34 package sun.security.krb5.internal.ccache;
 35 
 36 import sun.security.action.GetPropertyAction;
 37 import sun.security.krb5.*;
 38 import sun.security.krb5.internal.*;
<a name="2" id="anc2"></a>





 39 import java.util.StringTokenizer;
 40 import java.util.Vector;
 41 import java.io.IOException;
 42 import java.io.File;
 43 import java.io.FileInputStream;
 44 import java.io.FileOutputStream;
 45 import java.io.BufferedReader;
 46 import java.io.InputStreamReader;
 47 
<a name="3" id="anc3"></a>

 48 /**
 49  * CredentialsCache stores credentials(tickets, session keys, etc) in a
 50  * semi-permanent store
 51  * for later use by different program.
 52  *
 53  * @author Yanni Zhang
 54  * @author Ram Marti
 55  */
 56 
 57 public class FileCredentialsCache extends CredentialsCache
 58     implements FileCCacheConstants {
 59     public int version;
 60     public Tag tag; // optional
 61     public PrincipalName primaryPrincipal;
 62     private Vector&lt;Credentials&gt; credentialsList;
 63     private static String dir;
 64     private static boolean DEBUG = Krb5.DEBUG;
 65 
 66     public static synchronized FileCredentialsCache acquireInstance(
 67                 PrincipalName principal, String cache) {
 68         try {
 69             FileCredentialsCache fcc = new FileCredentialsCache();
 70             if (cache == null) {
 71                 cacheName = FileCredentialsCache.getDefaultCacheName();
 72             } else {
 73                 cacheName = FileCredentialsCache.checkValidation(cache);
 74             }
 75             if ((cacheName == null) || !(new File(cacheName)).exists()) {
 76                 // invalid cache name or the file doesn&#39;t exist
 77                 return null;
 78             }
 79             if (principal != null) {
 80                 fcc.primaryPrincipal = principal;
 81             }
 82             fcc.load(cacheName);
 83             return fcc;
 84         } catch (IOException e) {
 85             // we don&#39;t handle it now, instead we return a null at the end.
 86             if (DEBUG) {
 87                 e.printStackTrace();
 88             }
 89         } catch (KrbException e) {
 90             // we don&#39;t handle it now, instead we return a null at the end.
 91             if (DEBUG) {
 92                 e.printStackTrace();
 93             }
 94         }
 95         return null;
 96     }
 97 
 98     public static FileCredentialsCache acquireInstance() {
 99         return acquireInstance(null, null);
100     }
101 
102     static synchronized FileCredentialsCache New(PrincipalName principal,
103                                                 String name) {
104         try {
105             FileCredentialsCache fcc = new FileCredentialsCache();
106             cacheName = FileCredentialsCache.checkValidation(name);
107             if (cacheName == null) {
108                 // invalid cache name or the file doesn&#39;t exist
109                 return null;
110             }
111             fcc.init(principal, cacheName);
112             return fcc;
113         }
114         catch (IOException e) {
115         }
116         catch (KrbException e) {
117         }
118         return null;
119     }
120 
121     static synchronized FileCredentialsCache New(PrincipalName principal) {
122         try {
123             FileCredentialsCache fcc = new FileCredentialsCache();
124             cacheName = FileCredentialsCache.getDefaultCacheName();
125             fcc.init(principal, cacheName);
126             return fcc;
127         }
128         catch (IOException e) {
129             if (DEBUG) {
130                 e.printStackTrace();
131             }
132         } catch (KrbException e) {
133             if (DEBUG) {
134                 e.printStackTrace();
135             }
136 
137         }
138         return null;
139     }
140 
141     private FileCredentialsCache() {
142     }
143 
144     boolean exists(String cache) {
145         File file = new File(cache);
146         if (file.exists()) {
147             return true;
148         } else return false;
149     }
150 
151     synchronized void init(PrincipalName principal, String name)
152         throws IOException, KrbException {
153         primaryPrincipal = principal;
154         try (FileOutputStream fos = new FileOutputStream(name);
155              CCacheOutputStream cos = new CCacheOutputStream(fos)) {
156             version = KRB5_FCC_FVNO_3;
157             cos.writeHeader(primaryPrincipal, version);
158         }
159         load(name);
160     }
161 
162     synchronized void load(String name) throws IOException, KrbException {
163         PrincipalName p;
164         try (FileInputStream fis = new FileInputStream(name);
165              CCacheInputStream cis = new CCacheInputStream(fis)) {
166             version = cis.readVersion();
167             if (version == KRB5_FCC_FVNO_4) {
168                 tag = cis.readTag();
169             } else {
170                 tag = null;
171                 if (version == KRB5_FCC_FVNO_1 || version == KRB5_FCC_FVNO_2) {
172                     cis.setNativeByteOrder();
173                 }
174             }
175             p = cis.readPrincipal(version);
176 
177             if (primaryPrincipal != null) {
178                 if (!(primaryPrincipal.match(p))) {
179                     throw new IOException(&quot;Primary principals don&#39;t match.&quot;);
180                 }
181             } else
182                 primaryPrincipal = p;
183             credentialsList = new Vector&lt;Credentials&gt;();
184             while (cis.available() &gt; 0) {
<a name="4" id="anc4"></a><span class="line-modified">185                 Credentials cred = cis.readCred(version);</span>
186                 if (cred != null) {
<a name="5" id="anc5"></a><span class="line-modified">187                     credentialsList.addElement(cred);</span>




188                 }
189             }
190         }
191     }
192 
193 
194     /**
195      * Updates the credentials list. If the specified credentials for the
196      * service is new, add it to the list. If there is an entry in the list,
197      * replace the old credentials with the new one.
198      * @param c the credentials.
199      */
200 
201     public synchronized void update(Credentials c) {
202         if (credentialsList != null) {
203             if (credentialsList.isEmpty()) {
204                 credentialsList.addElement(c);
205             } else {
206                 Credentials tmp = null;
207                 boolean matched = false;
208 
209                 for (int i = 0; i &lt; credentialsList.size(); i++) {
210                     tmp = credentialsList.elementAt(i);
211                     if (match(c.sname.getNameStrings(),
212                               tmp.sname.getNameStrings()) &amp;&amp;
213                         ((c.sname.getRealmString()).equalsIgnoreCase(
214                                      tmp.sname.getRealmString()))) {
215                         matched = true;
216                         if (c.endtime.getTime() &gt;= tmp.endtime.getTime()) {
217                             if (DEBUG) {
218                                 System.out.println(&quot; &gt;&gt;&gt; FileCredentialsCache &quot;
219                                          +  &quot;Ticket matched, overwrite &quot;
220                                          +  &quot;the old one.&quot;);
221                             }
222                             credentialsList.removeElementAt(i);
223                             credentialsList.addElement(c);
224                         }
225                     }
226                 }
227                 if (matched == false) {
228                     if (DEBUG) {
229                         System.out.println(&quot; &gt;&gt;&gt; FileCredentialsCache Ticket &quot;
230                                         +   &quot;not exactly matched, &quot;
231                                         +   &quot;add new one into cache.&quot;);
232                     }
233 
234                     credentialsList.addElement(c);
235                 }
236             }
237         }
238     }
239 
240     public synchronized PrincipalName getPrimaryPrincipal() {
241         return primaryPrincipal;
242     }
243 
244 
245     /**
246      * Saves the credentials cache file to the disk.
247      */
248     public synchronized void save() throws IOException, Asn1Exception {
249         try (FileOutputStream fos = new FileOutputStream(cacheName);
250              CCacheOutputStream cos = new CCacheOutputStream(fos)) {
251             cos.writeHeader(primaryPrincipal, version);
252             Credentials[] tmp = null;
253             if ((tmp = getCredsList()) != null) {
254                 for (int i = 0; i &lt; tmp.length; i++) {
255                     cos.addCreds(tmp[i]);
256                 }
257             }
<a name="6" id="anc6"></a>


258         }
259     }
260 
261     boolean match(String[] s1, String[] s2) {
262         if (s1.length != s2.length) {
263             return false;
264         } else {
265             for (int i = 0; i &lt; s1.length; i++) {
266                 if (!(s1[i].equalsIgnoreCase(s2[i]))) {
267                     return false;
268                 }
269             }
270         }
271         return true;
272     }
273 
274     /**
275      * Returns the list of credentials entries in the cache file.
276      */
277     public synchronized Credentials[] getCredsList() {
278         if ((credentialsList == null) || (credentialsList.isEmpty())) {
279             return null;
280         } else {
281             Credentials[] tmp = new Credentials[credentialsList.size()];
282             for (int i = 0; i &lt; credentialsList.size(); i++) {
283                 tmp[i] = credentialsList.elementAt(i);
284             }
285             return tmp;
286         }
287 
288     }
289 
290     public Credentials getCreds(LoginOptions options, PrincipalName sname) {
291         if (options == null) {
292             return getCreds(sname);
293         } else {
294             Credentials[] list = getCredsList();
295             if (list == null) {
296                 return null;
297             } else {
298                 for (int i = 0; i &lt; list.length; i++) {
299                     if (sname.match(list[i].sname)) {
300                         if (list[i].flags.match(options)) {
301                             return list[i];
302                         }
303                     }
304                 }
305             }
306             return null;
307         }
308     }
309 
<a name="7" id="anc7"></a>










310 
311     /**
312      * Gets a credentials for a specified service.
313      * @param sname service principal name.
314      */
315     public Credentials getCreds(PrincipalName sname) {
316         Credentials[] list = getCredsList();
317         if (list == null) {
318             return null;
319         } else {
320             for (int i = 0; i &lt; list.length; i++) {
321                 if (sname.match(list[i].sname)) {
322                     return list[i];
323                 }
324             }
325         }
326         return null;
327     }
328 
<a name="8" id="anc8"></a>










































































329     public Credentials getDefaultCreds() {
330         Credentials[] list = getCredsList();
331         if (list == null) {
332             return null;
333         } else {
334             for (int i = list.length-1; i &gt;= 0; i--) {
335                 if (list[i].sname.toString().startsWith(&quot;krbtgt&quot;)) {
336                     String[] nameStrings = list[i].sname.getNameStrings();
337                     // find the TGT for the current realm krbtgt/realm@realm
338                     if (nameStrings[1].equals(list[i].sname.getRealm().toString())) {
339                        return list[i];
340                     }
341                 }
342             }
343         }
344         return null;
345     }
346 
347     /*
348      * Returns path name of the credentials cache file.
349      * The path name is searched in the following order:
350      *
351      * 1. KRB5CCNAME (bare file name without FILE:)
352      * 2. /tmp/krb5cc_&lt;uid&gt; on unix systems
353      * 3. &lt;user.home&gt;/krb5cc_&lt;user.name&gt;
354      * 4. &lt;user.home&gt;/krb5cc (if can&#39;t get &lt;user.name&gt;)
355      */
356 
357     public static String getDefaultCacheName() {
358 
359         String stdCacheNameComponent = &quot;krb5cc&quot;;
360         String name;
361 
362         // The env var can start with TYPE:, we only support FILE: here.
363         // http://docs.oracle.com/cd/E19082-01/819-2252/6n4i8rtr3/index.html
364         name = java.security.AccessController.doPrivileged(
365                 new java.security.PrivilegedAction&lt;String&gt;() {
366             @Override
367             public String run() {
368                 String cache = System.getenv(&quot;KRB5CCNAME&quot;);
369                 if (cache != null &amp;&amp;
370                         (cache.length() &gt;= 5) &amp;&amp;
371                         cache.regionMatches(true, 0, &quot;FILE:&quot;, 0, 5)) {
372                     cache = cache.substring(5);
373                 }
374                 return cache;
375             }
376         });
377         if (name != null) {
378             if (DEBUG) {
379                 System.out.println(&quot;&gt;&gt;&gt;KinitOptions cache name is &quot; + name);
380             }
381             return name;
382         }
383 
384         // get cache name from system.property
385         String osname = GetPropertyAction.privilegedGetProperty(&quot;os.name&quot;);
386 
387         /*
388          * For Unix platforms we use the default cache name to be
389          * /tmp/krb5cc_uid ; for all other platforms  we use
390          * {user_home}/krb5cc_{user_name}
391          * Please note that for Windows we will use LSA to get
392          * the TGT from the default cache even before we come here;
393          * however when we create cache we will create a cache under
394          * {user_home}/krb5cc_{user_name} for non-Unix platforms including
395          * Windows.
396          */
397 
398         if (osname != null &amp;&amp; !osname.startsWith(&quot;Windows&quot;)) {
399             long uid = jdk.internal.misc.VM.getuid();
400             if (uid != -1) {
401                 name = File.separator + &quot;tmp&quot; +
402                         File.separator + stdCacheNameComponent + &quot;_&quot; + uid;
403                 if (DEBUG) {
404                     System.out.println(&quot;&gt;&gt;&gt;KinitOptions cache name is &quot; +
405                             name);
406                 }
407                 return name;
408             } else {
409                 if (DEBUG) {
410                     System.out.println(&quot;Error in obtaining uid &quot; +
411                                         &quot;for Unix platforms &quot; +
412                                         &quot;Using user&#39;s home directory&quot;);
413                 }
414             }
415         }
416 
417         // we did not get the uid;
418 
419         String user_name = GetPropertyAction.privilegedGetProperty(&quot;user.name&quot;);
420 
421         String user_home = GetPropertyAction.privilegedGetProperty(&quot;user.home&quot;);
422 
423         if (user_home == null) {
424             user_home = GetPropertyAction.privilegedGetProperty(&quot;user.dir&quot;);
425         }
426 
427         if (user_name != null) {
428             name = user_home + File.separator  +
429                 stdCacheNameComponent + &quot;_&quot; + user_name;
430         } else {
431             name = user_home + File.separator + stdCacheNameComponent;
432         }
433 
434         if (DEBUG) {
435             System.out.println(&quot;&gt;&gt;&gt;KinitOptions cache name is &quot; + name);
436         }
437 
438         return name;
439     }
440 
441     public static String checkValidation(String name) {
442         String fullname = null;
443         if (name == null) {
444             return null;
445         }
446         try {
447             // get full path name
448             fullname = (new File(name)).getCanonicalPath();
449             File fCheck = new File(fullname);
450             if (!(fCheck.exists())) {
451                 // get absolute directory
452                 File temp = new File(fCheck.getParent());
453                 // test if the directory exists
454                 if (!(temp.isDirectory()))
455                     fullname = null;
456                 temp = null;
457             }
458             fCheck = null;
459 
460         } catch (IOException e) {
461             fullname = null; // invalid name
462         }
463         return fullname;
464     }
465 
466 
467     private static String exec(String c) {
468         StringTokenizer st = new StringTokenizer(c);
469         Vector&lt;String&gt; v = new Vector&lt;&gt;();
470         while (st.hasMoreTokens()) {
471             v.addElement(st.nextToken());
472         }
473         final String[] command = new String[v.size()];
474         v.copyInto(command);
475         try {
476 
477             Process p =
478                 java.security.AccessController.doPrivileged
479                 (new java.security.PrivilegedAction&lt;Process&gt; () {
480                         public Process run() {
481                             try {
482                                 return (Runtime.getRuntime().exec(command));
483                             } catch (java.io.IOException e) {
484                                 if (DEBUG) {
485                                     e.printStackTrace();
486                                 }
487                                 return null;
488                             }
489                         }
490                     });
491             if (p == null) {
492                 // exception occurred during executing the command
493                 return null;
494             }
495 
496             BufferedReader commandResult =
497                 new BufferedReader
<a name="9" id="anc9"></a><span class="line-modified">498                     (new InputStreamReader(p.getInputStream(), &quot;8859_1&quot;));</span>
499             String s1 = null;
500             if ((command.length == 1) &amp;&amp;
501                 (command[0].equals(&quot;/usr/bin/env&quot;))) {
502                 while ((s1 = commandResult.readLine()) != null) {
503                     if (s1.length() &gt;= 11) {
504                         if ((s1.substring(0, 11)).equalsIgnoreCase
505                             (&quot;KRB5CCNAME=&quot;)) {
506                             s1 = s1.substring(11);
507                             break;
508                         }
509                     }
510                 }
511             } else     s1 = commandResult.readLine();
512             commandResult.close();
513             return s1;
514         } catch (Exception e) {
515             if (DEBUG) {
516                 e.printStackTrace();
517             }
518         }
519         return null;
520     }
521 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
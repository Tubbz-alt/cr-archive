<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.security.jgss/share/classes/sun/security/krb5/internal/Ticket.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  *
 27  *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 28  *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 29  */
 30 
 31 package sun.security.krb5.internal;
 32 
 33 import sun.security.krb5.PrincipalName;
 34 import sun.security.krb5.EncryptedData;
 35 import sun.security.krb5.Asn1Exception;
 36 import sun.security.krb5.Realm;
 37 import sun.security.krb5.RealmException;
 38 import sun.security.util.*;
 39 import java.io.IOException;
 40 import java.math.BigInteger;
 41 
 42 /**
 43  * Implements the ASN.1 Ticket type.
 44  *
 45  * &lt;pre&gt;{@code
 46  * Ticket               ::= [APPLICATION 1] SEQUENCE {
 47  *      tkt-vno         [0] INTEGER (5),
 48  *      realm           [1] Realm,
 49  *      sname           [2] PrincipalName,
 50  *      enc-part        [3] EncryptedData -- EncTicketPart
 51  * }
 52  * }&lt;/pre&gt;
 53  *
 54  * &lt;p&gt;
 55  * This definition reflects the Network Working Group RFC 4120
 56  * specification available at
 57  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;
 58  * http://www.ietf.org/rfc/rfc4120.txt&lt;/a&gt;.
 59  */
 60 
 61 public class Ticket implements Cloneable {
 62     public int tkt_vno;
 63     public PrincipalName sname;
 64     public EncryptedData encPart;
 65 
 66     private Ticket() {
 67     }
 68 
 69     public Object clone() {
 70         Ticket new_ticket = new Ticket();
 71         new_ticket.sname = (PrincipalName)sname.clone();
 72         new_ticket.encPart = (EncryptedData)encPart.clone();
 73         new_ticket.tkt_vno = tkt_vno;
 74         return new_ticket;
 75     }
 76 
 77     public Ticket(
 78                   PrincipalName new_sname,
 79                   EncryptedData new_encPart
 80                       ) {
 81         tkt_vno = Krb5.TICKET_VNO;
 82         sname = new_sname;
 83         encPart = new_encPart;
 84     }
 85 
 86     public Ticket(byte[] data) throws Asn1Exception,
 87     RealmException, KrbApErrException, IOException {
 88         init(new DerValue(data));
 89     }
 90 
 91     public Ticket(DerValue encoding) throws Asn1Exception,
 92     RealmException, KrbApErrException, IOException {
 93         init(encoding);
 94     }
 95 
 96     /**
 97      * Initializes a Ticket object.
 98      * @param encoding a single DER-encoded value.
 99      * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
100      * @exception IOException if an I/O error occurs while reading encoded data.
101      * @exception KrbApErrException if the value read from the DER-encoded data stream does not match the pre-defined value.
102      * @exception RealmException if an error occurs while parsing a Realm object.
103      */
104 
105     private void init(DerValue encoding) throws Asn1Exception,
106     RealmException, KrbApErrException, IOException {
107         DerValue der;
108         DerValue subDer;
109         if (((encoding.getTag() &amp; (byte)0x1F) != Krb5.KRB_TKT)
110             || (encoding.isApplication() != true)
111             || (encoding.isConstructed() != true))
112             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
113         der = encoding.getData().getDerValue();
114         if (der.getTag() != DerValue.tag_Sequence)
115             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
116         subDer = der.getData().getDerValue();
117         if ((subDer.getTag() &amp; (byte)0x1F) != (byte)0x00)
118             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
119         tkt_vno = subDer.getData().getBigInteger().intValue();
120         if (tkt_vno != Krb5.TICKET_VNO)
121             throw new KrbApErrException(Krb5.KRB_AP_ERR_BADVERSION);
122         Realm srealm = Realm.parse(der.getData(), (byte)0x01, false);
123         sname = PrincipalName.parse(der.getData(), (byte)0x02, false, srealm);
124         encPart = EncryptedData.parse(der.getData(), (byte)0x03, false);
125         if (der.getData().available() &gt; 0)
126             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
127     }
128 
129     /**
130      * Encodes a Ticket object.
131      * @return byte array of encoded ticket object.
132      * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
133      * @exception IOException if an I/O error occurs while reading encoded data.
134      */
135     public byte[] asn1Encode() throws Asn1Exception, IOException {
136         DerOutputStream bytes = new DerOutputStream();
137         DerOutputStream temp = new DerOutputStream();
138         DerValue[] der = new DerValue[4];
139         temp.putInteger(BigInteger.valueOf(tkt_vno));
140         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0x00), temp);
141         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0x01), sname.getRealm().asn1Encode());
142         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0x02), sname.asn1Encode());
143         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0x03), encPart.asn1Encode());
144         temp = new DerOutputStream();
145         temp.write(DerValue.tag_Sequence, bytes);
146         DerOutputStream ticket = new DerOutputStream();
147         ticket.write(DerValue.createTag(DerValue.TAG_APPLICATION, true, (byte)0x01), temp);
148         return ticket.toByteArray();
149     }
150 
151     /**
152      * Parse (unmarshal) a Ticket from a DER input stream.  This form
153      * parsing might be used when expanding a value which is part of
154      * a constructed sequence and uses explicitly tagged type.
155      *
156      * @exception Asn1Exception on error.
157      * @param data the Der input stream value, which contains one or more marshaled value.
158      * @param explicitTag tag number.
159      * @param optional indicate if this data field is optional
160      * @return an instance of Ticket.
161      */
162     public static Ticket parse(DerInputStream data, byte explicitTag, boolean optional) throws Asn1Exception, IOException, RealmException, KrbApErrException {
163         if ((optional) &amp;&amp; (((byte)data.peekByte() &amp; (byte)0x1F)!= explicitTag))
164             return null;
165         DerValue der = data.getDerValue();
166         if (explicitTag != (der.getTag() &amp; (byte)0x1F))  {
167             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
168         }
169         else {
170             DerValue subDer = der.getData().getDerValue();
171             return new Ticket(subDer);
172         }
173     }
174 
175 
176 }
    </pre>
  </body>
</html>
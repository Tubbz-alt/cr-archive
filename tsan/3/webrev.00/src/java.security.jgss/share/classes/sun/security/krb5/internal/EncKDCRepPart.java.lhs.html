<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.security.jgss/share/classes/sun/security/krb5/internal/EncKDCRepPart.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  *
 27  *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 28  *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 29  */
 30 
 31 package sun.security.krb5.internal;
 32 
 33 import sun.security.krb5.*;
<a name="1" id="anc1"></a><span class="line-removed"> 34 import sun.security.krb5.EncryptionKey;</span>
 35 import sun.security.util.*;
 36 import java.util.Vector;
 37 import java.io.IOException;
 38 import java.math.BigInteger;
 39 
 40 /**
 41  * Implements the ASN.1 EncKDCRepPart type.
 42  *
 43  * &lt;pre&gt;{@code
<a name="2" id="anc2"></a><span class="line-modified"> 44  * EncKDCRepPart        ::= SEQUENCE {</span>
<span class="line-modified"> 45  *      key             [0] EncryptionKey,</span>
<span class="line-modified"> 46  *      last-req        [1] LastReq,</span>
<span class="line-modified"> 47  *      nonce           [2] UInt32,</span>
<span class="line-modified"> 48  *      key-expiration  [3] KerberosTime OPTIONAL,</span>
<span class="line-modified"> 49  *      flags           [4] TicketFlags,</span>
<span class="line-modified"> 50  *      authtime        [5] KerberosTime,</span>
<span class="line-modified"> 51  *      starttime       [6] KerberosTime OPTIONAL,</span>
<span class="line-modified"> 52  *      endtime         [7] KerberosTime,</span>
<span class="line-modified"> 53  *      renew-till      [8] KerberosTime OPTIONAL,</span>
<span class="line-modified"> 54  *      srealm          [9] Realm,</span>
<span class="line-modified"> 55  *      sname           [10] PrincipalName,</span>
<span class="line-modified"> 56  *      caddr           [11] HostAddresses OPTIONAL</span>

 57  * }
 58  * }&lt;/pre&gt;
 59  *
 60  * &lt;p&gt;
 61  * This definition reflects the Network Working Group RFC 4120
 62  * specification available at
 63  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;
 64  * http://www.ietf.org/rfc/rfc4120.txt&lt;/a&gt;.
 65  */
 66 public class EncKDCRepPart {
 67 
 68     public EncryptionKey key;
 69     public LastReq lastReq;
 70     public int nonce;
 71     public KerberosTime keyExpiration; //optional
 72     public TicketFlags flags;
 73     public KerberosTime authtime;
 74     public KerberosTime starttime; //optional
 75     public KerberosTime endtime;
 76     public KerberosTime renewTill; //optional
 77     public PrincipalName sname;
 78     public HostAddresses caddr; //optional
<a name="3" id="anc3"></a>
 79     public int msgType; //not included in sequence
 80 
 81     public EncKDCRepPart(
 82             EncryptionKey new_key,
 83             LastReq new_lastReq,
 84             int new_nonce,
 85             KerberosTime new_keyExpiration,
 86             TicketFlags new_flags,
 87             KerberosTime new_authtime,
 88             KerberosTime new_starttime,
 89             KerberosTime new_endtime,
 90             KerberosTime new_renewTill,
 91             PrincipalName new_sname,
 92             HostAddresses new_caddr,
<a name="4" id="anc4"></a>
 93             int new_msgType) {
 94         key = new_key;
 95         lastReq = new_lastReq;
 96         nonce = new_nonce;
 97         keyExpiration = new_keyExpiration;
 98         flags = new_flags;
 99         authtime = new_authtime;
100         starttime = new_starttime;
101         endtime = new_endtime;
102         renewTill = new_renewTill;
103         sname = new_sname;
104         caddr = new_caddr;
<a name="5" id="anc5"></a>
105         msgType = new_msgType;
106     }
107 
108     public EncKDCRepPart() {
109     }
110 
111     public EncKDCRepPart(byte[] data, int rep_type)
112             throws Asn1Exception, IOException, RealmException {
113         init(new DerValue(data), rep_type);
114     }
115 
116     public EncKDCRepPart(DerValue encoding, int rep_type)
117             throws Asn1Exception, IOException, RealmException {
118         init(encoding, rep_type);
119     }
120 
121     /**
122      * Initializes an EncKDCRepPart object.
123      *
124      * @param encoding a single DER-encoded value.
125      * @param rep_type type of the encrypted reply message.
126      * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
127      * @exception IOException if an I/O error occurs while reading encoded data.
128      * @exception RealmException if an error occurs while decoding an Realm object.
129      */
130     protected void init(DerValue encoding, int rep_type)
131             throws Asn1Exception, IOException, RealmException {
132         DerValue der, subDer;
133         //implementations return the incorrect tag value, so
134         //we don&#39;t use the above line; instead we use the following
135         msgType = (encoding.getTag() &amp; (byte) 0x1F);
136         if (msgType != Krb5.KRB_ENC_AS_REP_PART &amp;&amp;
137                 msgType != Krb5.KRB_ENC_TGS_REP_PART) {
138             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
139         }
140         der = encoding.getData().getDerValue();
141         if (der.getTag() != DerValue.tag_Sequence) {
142             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
143         }
144         key = EncryptionKey.parse(der.getData(), (byte) 0x00, false);
145         lastReq = LastReq.parse(der.getData(), (byte) 0x01, false);
146         subDer = der.getData().getDerValue();
147         if ((subDer.getTag() &amp; (byte) 0x1F) == (byte) 0x02) {
148             nonce = subDer.getData().getBigInteger().intValue();
149         } else {
150             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
151         }
152         keyExpiration = KerberosTime.parse(der.getData(), (byte) 0x03, true);
153         flags = TicketFlags.parse(der.getData(), (byte) 0x04, false);
154         authtime = KerberosTime.parse(der.getData(), (byte) 0x05, false);
155         starttime = KerberosTime.parse(der.getData(), (byte) 0x06, true);
156         endtime = KerberosTime.parse(der.getData(), (byte) 0x07, false);
157         renewTill = KerberosTime.parse(der.getData(), (byte) 0x08, true);
158         Realm srealm = Realm.parse(der.getData(), (byte) 0x09, false);
159         sname = PrincipalName.parse(der.getData(), (byte) 0x0A, false, srealm);
160         if (der.getData().available() &gt; 0) {
161             caddr = HostAddresses.parse(der.getData(), (byte) 0x0B, true);
162         }
<a name="6" id="anc6"></a>


163         // We observe extra data from MSAD
164         /*if (der.getData().available() &gt; 0) {
165             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
166         }*/
167     }
168 
169     /**
170      * Encodes an EncKDCRepPart object.
171      * @param rep_type type of encrypted reply message.
172      * @return byte array of encoded EncKDCRepPart object.
173      * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
174      * @exception IOException if an I/O error occurs while reading encoded data.
175      */
176     public byte[] asn1Encode(int rep_type) throws Asn1Exception,
177             IOException {
<a name="7" id="anc7"></a>
178         DerOutputStream temp = new DerOutputStream();
<a name="8" id="anc8"></a><span class="line-modified">179         DerOutputStream bytes = new DerOutputStream();</span>
<span class="line-modified">180         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
181                 true, (byte) 0x00), key.asn1Encode());
<a name="9" id="anc9"></a><span class="line-modified">182         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
183                 true, (byte) 0x01), lastReq.asn1Encode());
184         temp.putInteger(BigInteger.valueOf(nonce));
<a name="10" id="anc10"></a><span class="line-modified">185         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
186                 true, (byte) 0x02), temp);
187 
188         if (keyExpiration != null) {
<a name="11" id="anc11"></a><span class="line-modified">189             bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
190                     true, (byte) 0x03), keyExpiration.asn1Encode());
191         }
<a name="12" id="anc12"></a><span class="line-modified">192         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
193                 true, (byte) 0x04), flags.asn1Encode());
<a name="13" id="anc13"></a><span class="line-modified">194         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
195                 true, (byte) 0x05), authtime.asn1Encode());
196         if (starttime != null) {
<a name="14" id="anc14"></a><span class="line-modified">197             bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
198                     true, (byte) 0x06), starttime.asn1Encode());
199         }
<a name="15" id="anc15"></a><span class="line-modified">200         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
201                 true, (byte) 0x07), endtime.asn1Encode());
202         if (renewTill != null) {
<a name="16" id="anc16"></a><span class="line-modified">203             bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
204                     true, (byte) 0x08), renewTill.asn1Encode());
205         }
<a name="17" id="anc17"></a><span class="line-modified">206         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
207                 true, (byte) 0x09), sname.getRealm().asn1Encode());
<a name="18" id="anc18"></a><span class="line-modified">208         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
209                 true, (byte) 0x0A), sname.asn1Encode());
210         if (caddr != null) {
<a name="19" id="anc19"></a><span class="line-modified">211             bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
212                     true, (byte) 0x0B), caddr.asn1Encode());
213         }
<a name="20" id="anc20"></a>









214         //should use the rep_type to build the encoding
215         //but other implementations do not; it is ignored and
216         //the cached msgType is used instead
217         temp = new DerOutputStream();
<a name="21" id="anc21"></a><span class="line-modified">218         temp.write(DerValue.tag_Sequence, bytes);</span>
219         bytes = new DerOutputStream();
220         bytes.write(DerValue.createTag(DerValue.TAG_APPLICATION,
221                 true, (byte) msgType), temp);
222         return bytes.toByteArray();
223     }
224 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
diff a/src/java.security.jgss/share/classes/sun/security/krb5/internal/CredentialsUtil.java b/src/java.security.jgss/share/classes/sun/security/krb5/internal/CredentialsUtil.java
--- a/src/java.security.jgss/share/classes/sun/security/krb5/internal/CredentialsUtil.java
+++ b/src/java.security.jgss/share/classes/sun/security/krb5/internal/CredentialsUtil.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -30,46 +30,76 @@
  */
 
 package sun.security.krb5.internal;
 
 import sun.security.krb5.*;
+import sun.security.util.DerValue;
+
 import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
 
 /**
  * This class is a utility that contains much of the TGS-Exchange
  * protocol. It is used by ../Credentials.java for service ticket
  * acquisition in both the normal and the x-realm case.
  */
 public class CredentialsUtil {
 
     private static boolean DEBUG = sun.security.krb5.internal.Krb5.DEBUG;
 
+    private static enum S4U2Type {
+        NONE, SELF, PROXY
+    }
+
     /**
      * Used by a middle server to acquire credentials on behalf of a
      * client to itself using the S4U2self extension.
      * @param client the client to impersonate
      * @param ccreds the TGT of the middle service
      * @return the new creds (cname=client, sname=middle)
      */
     public static Credentials acquireS4U2selfCreds(PrincipalName client,
             Credentials ccreds) throws KrbException, IOException {
+        if (!ccreds.isForwardable()) {
+            throw new KrbException("S4U2self needs a FORWARDABLE ticket");
+        }
+        PrincipalName sname = ccreds.getClient();
         String uRealm = client.getRealmString();
         String localRealm = ccreds.getClient().getRealmString();
         if (!uRealm.equals(localRealm)) {
-            // TODO: we do not support kerberos referral now
-            throw new KrbException("Cross realm impersonation not supported");
-        }
-        if (!ccreds.isForwardable()) {
-            throw new KrbException("S4U2self needs a FORWARDABLE ticket");
+            // Referrals will be required because the middle service
+            // and the client impersonated are on different realms.
+            if (Config.DISABLE_REFERRALS) {
+                throw new KrbException("Cross-realm S4U2Self request not" +
+                        " possible when referrals are disabled.");
+            }
+            if (ccreds.getClientAlias() != null) {
+                // If the name was canonicalized, the user pick
+                // has preference. This gives the possibility of
+                // using FQDNs that KDCs may use to return referrals.
+                // I.e.: a SVC/host.realm-2.com@REALM-1.COM name
+                // may be used by REALM-1.COM KDC to return a
+                // referral to REALM-2.COM.
+                sname = ccreds.getClientAlias();
+            }
+            sname = new PrincipalName(sname.getNameType(),
+                    sname.getNameStrings(), new Realm(uRealm));
         }
-        KrbTgsReq req = new KrbTgsReq(
-                ccreds,
-                ccreds.getClient(),
-                new PAData(Krb5.PA_FOR_USER,
-                    new PAForUserEnc(client,
-                        ccreds.getSessionKey()).asn1Encode()));
-        Credentials creds = req.sendAndGetCreds();
+        Credentials creds = serviceCreds(
+                KDCOptions.with(KDCOptions.FORWARDABLE),
+                ccreds, ccreds.getClient(), sname, null,
+                new PAData[] {
+                        new PAData(Krb5.PA_FOR_USER,
+                                new PAForUserEnc(client,
+                                        ccreds.getSessionKey()).asn1Encode()),
+                        new PAData(Krb5.PA_PAC_OPTIONS,
+                                new PaPacOptions()
+                                        .setResourceBasedConstrainedDelegation(true)
+                                        .setClaims(true)
+                                        .asn1Encode())
+                        }, S4U2Type.SELF);
         if (!creds.getClient().equals(client)) {
             throw new KrbException("S4U2self request not honored by KDC");
         }
         if (!creds.isForwardable()) {
             throw new KrbException("S4U2self ticket must be FORWARDABLE");
@@ -87,15 +117,35 @@
      */
     public static Credentials acquireS4U2proxyCreds(
                 String backend, Ticket second,
                 PrincipalName client, Credentials ccreds)
             throws KrbException, IOException {
-        KrbTgsReq req = new KrbTgsReq(
-                ccreds,
-                second,
-                new PrincipalName(backend));
-        Credentials creds = req.sendAndGetCreds();
+        PrincipalName backendPrincipal = new PrincipalName(backend);
+        String backendRealm = backendPrincipal.getRealmString();
+        String localRealm = ccreds.getClient().getRealmString();
+        if (!backendRealm.equals(localRealm)) {
+            // The middle service and the backend service are on
+            // different realms, so referrals will be required.
+            if (Config.DISABLE_REFERRALS) {
+                throw new KrbException("Cross-realm S4U2Proxy request not" +
+                        " possible when referrals are disabled.");
+            }
+            backendPrincipal = new PrincipalName(
+                    backendPrincipal.getNameType(),
+                    backendPrincipal.getNameStrings(),
+                    new Realm(localRealm));
+        }
+        Credentials creds = serviceCreds(KDCOptions.with(
+                KDCOptions.CNAME_IN_ADDL_TKT, KDCOptions.FORWARDABLE),
+                ccreds, ccreds.getClient(), backendPrincipal,
+                new Ticket[] {second}, new PAData[] {
+                        new PAData(Krb5.PA_PAC_OPTIONS,
+                                new PaPacOptions()
+                                        .setResourceBasedConstrainedDelegation(true)
+                                        .setClaims(true)
+                                        .asn1Encode())
+                        }, S4U2Type.PROXY);
         if (!creds.getClient().equals(client)) {
             throw new KrbException("S4U2proxy request not honored by KDC");
         }
         return creds;
     }
@@ -112,57 +162,13 @@
      * @param ccreds client's initial credential
      */
     public static Credentials acquireServiceCreds(
                 String service, Credentials ccreds)
             throws KrbException, IOException {
-        PrincipalName sname = new PrincipalName(service);
-        String serviceRealm = sname.getRealmString();
-        String localRealm = ccreds.getClient().getRealmString();
-
-        if (localRealm.equals(serviceRealm)) {
-            if (DEBUG) {
-                System.out.println(
-                        ">>> Credentials acquireServiceCreds: same realm");
-            }
-            return serviceCreds(sname, ccreds);
-        }
-        Credentials theCreds = null;
-
-        boolean[] okAsDelegate = new boolean[1];
-        Credentials theTgt = getTGTforRealm(localRealm, serviceRealm,
-                ccreds, okAsDelegate);
-        if (theTgt != null) {
-            if (DEBUG) {
-                System.out.println(">>> Credentials acquireServiceCreds: "
-                        + "got right tgt");
-                System.out.println(">>> Credentials acquireServiceCreds: "
-                        + "obtaining service creds for " + sname);
-            }
-
-            try {
-                theCreds = serviceCreds(sname, theTgt);
-            } catch (Exception exc) {
-                if (DEBUG) {
-                    System.out.println(exc);
-                }
-                theCreds = null;
-            }
-        }
-
-        if (theCreds != null) {
-            if (DEBUG) {
-                System.out.println(">>> Credentials acquireServiceCreds: "
-                        + "returning creds:");
-                Credentials.printDebug(theCreds);
-            }
-            if (!okAsDelegate[0]) {
-                theCreds.resetDelegate();
-            }
-            return theCreds;
-        }
-        throw new KrbApErrException(Krb5.KRB_AP_ERR_GEN_CRED,
-                                    "No service creds");
+        PrincipalName sname = new PrincipalName(service,
+                PrincipalName.KRB_NT_SRV_HST);
+        return serviceCreds(sname, ccreds);
     }
 
     /**
      * Gets a TGT to another realm
      * @param localRealm this realm
@@ -303,8 +309,261 @@
     * This method does the real job to request the service credential.
     */
     private static Credentials serviceCreds(
             PrincipalName service, Credentials ccreds)
             throws KrbException, IOException {
-        return new KrbTgsReq(ccreds, service).sendAndGetCreds();
+        return serviceCreds(new KDCOptions(), ccreds,
+                ccreds.getClient(), service, null, null,
+                S4U2Type.NONE);
+    }
+
+    /*
+     * Obtains credentials for a service (TGS).
+     * Cross-realm referrals are handled if enabled. A fallback scheme
+     * without cross-realm referrals supports is used in case of server
+     * error to maintain backward compatibility.
+     */
+    private static Credentials serviceCreds(
+            KDCOptions options, Credentials asCreds,
+            PrincipalName cname, PrincipalName sname,
+            Ticket[] additionalTickets, PAData[] extraPAs,
+            S4U2Type s4u2Type)
+            throws KrbException, IOException {
+        if (!Config.DISABLE_REFERRALS) {
+            try {
+                return serviceCredsReferrals(options, asCreds, cname, sname,
+                        s4u2Type, additionalTickets, extraPAs);
+            } catch (KrbException e) {
+                // Server may raise an error if CANONICALIZE is true.
+                // Try CANONICALIZE false.
+            }
+        }
+        return serviceCredsSingle(options, asCreds, cname,
+                asCreds.getClientAlias(), sname, sname, s4u2Type,
+                additionalTickets, extraPAs);
+    }
+
+    /*
+     * Obtains credentials for a service (TGS).
+     * May handle and follow cross-realm referrals as defined by RFC 6806.
+     */
+    private static Credentials serviceCredsReferrals(
+            KDCOptions options, Credentials asCreds,
+            PrincipalName cname, PrincipalName sname,
+            S4U2Type s4u2Type, Ticket[] additionalTickets,
+            PAData[] extraPAs)
+                    throws KrbException, IOException {
+        options = new KDCOptions(options.toBooleanArray());
+        options.set(KDCOptions.CANONICALIZE, true);
+        PrincipalName cSname = sname;
+        PrincipalName refSname = sname; // May change with referrals
+        Credentials creds = null;
+        boolean isReferral = false;
+        List<String> referrals = new LinkedList<>();
+        PrincipalName clientAlias = asCreds.getClientAlias();
+        while (referrals.size() <= Config.MAX_REFERRALS) {
+            ReferralsCache.ReferralCacheEntry ref =
+                    ReferralsCache.get(cname, sname, refSname.getRealmString());
+            String toRealm = null;
+            if (ref == null) {
+                creds = serviceCredsSingle(options, asCreds, cname,
+                        clientAlias, refSname, cSname, s4u2Type,
+                        additionalTickets, extraPAs);
+                PrincipalName server = creds.getServer();
+                if (!refSname.equals(server)) {
+                    String[] serverNameStrings = server.getNameStrings();
+                    if (serverNameStrings.length == 2 &&
+                        serverNameStrings[0].equals(
+                                PrincipalName.TGS_DEFAULT_SRV_NAME) &&
+                        !refSname.getRealmAsString().equals(
+                                serverNameStrings[1])) {
+                        // Server Name (sname) has the following format:
+                        //      krbtgt/TO-REALM.COM@FROM-REALM.COM
+                        if (s4u2Type == S4U2Type.NONE) {
+                            // Do not store S4U2Self or S4U2Proxy referral
+                            // TGTs in the cache. Caching such tickets is not
+                            // defined in MS-SFU and may cause unexpected
+                            // results when using them in a different context.
+                            ReferralsCache.put(cname, sname,
+                                    server.getRealmString(),
+                                    serverNameStrings[1], creds);
+                        }
+                        toRealm = serverNameStrings[1];
+                        isReferral = true;
+                    }
+                }
+            } else {
+                creds = ref.getCreds();
+                toRealm = ref.getToRealm();
+                isReferral = true;
+            }
+            if (isReferral) {
+                if (s4u2Type == S4U2Type.PROXY) {
+                    Credentials[] credsInOut =
+                            new Credentials[] {creds, null};
+                    toRealm = handleS4U2ProxyReferral(asCreds,
+                            credsInOut, sname);
+                    creds = credsInOut[0];
+                    if (additionalTickets == null ||
+                            additionalTickets.length == 0 ||
+                            credsInOut[1] == null) {
+                        throw new KrbException("Additional tickets expected" +
+                                " for S4U2Proxy.");
+                    }
+                    additionalTickets[0] = credsInOut[1].getTicket();
+                } else if (s4u2Type == S4U2Type.SELF) {
+                    handleS4U2SelfReferral(extraPAs, asCreds, creds);
+                }
+                if (referrals.contains(toRealm)) {
+                    // Referrals loop detected
+                    return null;
+                }
+                asCreds = creds;
+                refSname = new PrincipalName(refSname.getNameString(),
+                        refSname.getNameType(), toRealm);
+                referrals.add(toRealm);
+                isReferral = false;
+                continue;
+            }
+            break;
+        }
+        return creds;
+    }
+
+    /*
+     * Obtains credentials for a service (TGS).
+     * If the service realm is different than the one in the TGT, a new TGT for
+     * the service realm is obtained first (see getTGTforRealm call). This is
+     * not expected when following cross-realm referrals because the referral
+     * TGT realm matches the service realm.
+     */
+    private static Credentials serviceCredsSingle(
+            KDCOptions options, Credentials asCreds,
+            PrincipalName cname, PrincipalName clientAlias,
+            PrincipalName refSname, PrincipalName sname,
+            S4U2Type s4u2Type, Ticket[] additionalTickets,
+            PAData[] extraPAs)
+                    throws KrbException, IOException {
+        Credentials theCreds = null;
+        boolean[] okAsDelegate = new boolean[]{true};
+        String[] serverAsCredsNames = asCreds.getServer().getNameStrings();
+        String tgtRealm = serverAsCredsNames[1];
+        String serviceRealm = refSname.getRealmString();
+        if (!serviceRealm.equals(tgtRealm)) {
+            // This is a cross-realm service request
+            if (DEBUG) {
+                System.out.println(">>> serviceCredsSingle:" +
+                        " cross-realm authentication");
+                System.out.println(">>> serviceCredsSingle:" +
+                        " obtaining credentials from " + tgtRealm +
+                        " to " + serviceRealm);
+            }
+            Credentials newTgt = getTGTforRealm(tgtRealm, serviceRealm,
+                    asCreds, okAsDelegate);
+            if (newTgt == null) {
+                throw new KrbApErrException(Krb5.KRB_AP_ERR_GEN_CRED,
+                        "No service creds");
+            }
+            if (DEBUG) {
+                System.out.println(">>> Cross-realm TGT Credentials" +
+                        " serviceCredsSingle: ");
+                Credentials.printDebug(newTgt);
+            }
+            if (s4u2Type == S4U2Type.SELF) {
+                handleS4U2SelfReferral(extraPAs, asCreds, newTgt);
+            }
+            asCreds = newTgt;
+            cname = asCreds.getClient();
+        } else if (DEBUG) {
+            System.out.println(">>> Credentials serviceCredsSingle:" +
+                    " same realm");
+        }
+        KrbTgsReq req = new KrbTgsReq(options, asCreds, cname, clientAlias,
+                refSname, sname, additionalTickets, extraPAs);
+        theCreds = req.sendAndGetCreds();
+        if (theCreds != null) {
+            if (DEBUG) {
+                System.out.println(">>> TGS credentials serviceCredsSingle:");
+                Credentials.printDebug(theCreds);
+            }
+            if (!okAsDelegate[0]) {
+                theCreds.resetDelegate();
+            }
+        }
+        return theCreds;
+    }
+
+    /**
+     * PA-FOR-USER may need to be regenerated if credentials
+     * change. This may happen when obtaining a TGT for a
+     * different realm or when using a referral TGT.
+     */
+    private static void handleS4U2SelfReferral(PAData[] pas,
+            Credentials oldCeds, Credentials newCreds)
+                    throws Asn1Exception, KrbException, IOException {
+        if (DEBUG) {
+            System.out.println(">>> Handling S4U2Self referral");
+        }
+        for (int i = 0; i < pas.length; i++) {
+            PAData pa = pas[i];
+            if (pa.getType() == Krb5.PA_FOR_USER) {
+                PAForUserEnc paForUser = new PAForUserEnc(
+                        new DerValue(pa.getValue()),
+                        oldCeds.getSessionKey());
+                pas[i] = new PAData(Krb5.PA_FOR_USER,
+                        new PAForUserEnc(paForUser.getName(),
+                                newCreds.getSessionKey()).asn1Encode());
+                break;
+            }
+        }
+    }
+
+    /**
+     * This method is called after receiving the first realm referral for
+     * a S4U2Proxy request. The credentials and tickets needed for the
+     * final S4U2Proxy request (in the referrals chain) are returned.
+     *
+     * Referrals are handled as described by MS-SFU (section 3.1.5.2.2
+     * Receives Referral).
+     *
+     * @param asCreds middle service credentials used for the first S4U2Proxy
+     *        request
+     * @param credsInOut (in/out parameter):
+     *         * input: first S4U2Proxy referral TGT received, null
+     *         * output: referral TGT for final S4U2Proxy service request,
+     *                   client referral TGT for final S4U2Proxy service request
+     *                   (to be sent as additional-ticket)
+     * @param sname the backend service name
+     * @param additionalTickets (out parameter): the additional ticket for the
+     *        last S4U2Proxy request is returned
+     * @return the backend realm for the last S4U2Proxy request
+     */
+    private static String handleS4U2ProxyReferral(Credentials asCreds,
+            Credentials[] credsInOut, PrincipalName sname)
+                    throws KrbException, IOException {
+        if (DEBUG) {
+            System.out.println(">>> Handling S4U2Proxy referral");
+        }
+        Credentials refTGT = null;
+        // Get a credential for the middle service to the backend so we know
+        // the backend realm, as described in MS-SFU (section 3.1.5.2.2).
+        Credentials middleSvcCredsInBackendRealm =
+                serviceCreds(sname, asCreds);
+        String backendRealm =
+                middleSvcCredsInBackendRealm.getServer().getRealmString();
+        String toRealm = credsInOut[0].getServer().getNameStrings()[1];
+        if (!toRealm.equals(backendRealm)) {
+            // More than 1 hop. Follow the referrals chain and obtain a
+            // TGT for the backend realm.
+            refTGT = getTGTforRealm(toRealm, backendRealm, credsInOut[0],
+                    new boolean[1]);
+        } else {
+            // There was only 1 hop. The referral TGT received is already
+            // for the backend realm.
+            refTGT = credsInOut[0];
+        }
+        credsInOut[0] = getTGTforRealm(asCreds.getClient().getRealmString(),
+                backendRealm, asCreds, new boolean[1]);
+        credsInOut[1] = refTGT;
+        return backendRealm;
     }
 }

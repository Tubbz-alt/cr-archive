<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.security.jgss/share/classes/sun/security/krb5/Realm.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  *
 28  *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 29  *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 30  */
 31 
 32 package sun.security.krb5;
 33 
 34 import sun.security.action.GetBooleanAction;
 35 import sun.security.krb5.internal.Krb5;
 36 import sun.security.util.*;
 37 import java.io.IOException;
 38 import java.util.*;
 39 
 40 import sun.security.krb5.internal.util.KerberosString;
 41 
 42 /**
 43  * Implements the ASN.1 Realm type.
 44  *
 45  * {@code Realm ::= GeneralString}
 46  *
 47  * This class is immutable.
 48  */
 49 public class Realm implements Cloneable {
 50 
 51     public static final boolean AUTODEDUCEREALM = GetBooleanAction
 52             .privilegedGetProperty(&quot;sun.security.krb5.autodeducerealm&quot;);
 53 
 54     private final String realm; // not null nor empty
 55 
 56     public Realm(String name) throws RealmException {
 57         realm = parseRealm(name);
 58     }
 59 
 60     public static Realm getDefault() throws RealmException {
 61         try {
 62             return new Realm(Config.getInstance().getDefaultRealm());
 63         } catch (RealmException re) {
 64             throw re;
 65         } catch (KrbException ke) {
 66             throw new RealmException(ke);
 67         }
 68     }
 69 
 70     // Immutable class, no need to clone
 71     public Object clone() {
 72         return this;
 73     }
 74 
 75     public boolean equals(Object obj) {
 76         if (this == obj) {
 77             return true;
 78         }
 79 
 80         if (!(obj instanceof Realm)) {
 81             return false;
 82         }
 83 
 84         Realm that = (Realm)obj;
 85         return this.realm.equals(that.realm);
 86     }
 87 
 88     public int hashCode() {
 89         return realm.hashCode();
 90     }
 91 
 92     /**
 93      * Constructs a Realm object.
 94      * @param encoding a Der-encoded data.
 95      * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
 96      * @exception IOException if an I/O error occurs while reading encoded data.
 97      * @exception RealmException if an error occurs while parsing a Realm object.
 98      */
 99     public Realm(DerValue encoding)
100         throws Asn1Exception, RealmException, IOException {
101         if (encoding == null) {
102             throw new IllegalArgumentException(&quot;encoding can not be null&quot;);
103         }
104         realm = new KerberosString(encoding).toString();
105         if (realm == null || realm.length() == 0)
106             throw new RealmException(Krb5.REALM_NULL);
107         if (!isValidRealmString(realm))
108             throw new RealmException(Krb5.REALM_ILLCHAR);
109     }
110 
111     public String toString() {
112         return realm;
113     }
114 
115     // Extract realm from a string like dummy@REALM
116     public static String parseRealmAtSeparator(String name)
117         throws RealmException {
118         if (name == null) {
119             throw new IllegalArgumentException
120                 (&quot;null input name is not allowed&quot;);
121         }
122         String temp = new String(name);
123         String result = null;
124         int i = 0;
125         while (i &lt; temp.length()) {
126             if (temp.charAt(i) == PrincipalName.NAME_REALM_SEPARATOR) {
127                 if (i == 0 || temp.charAt(i - 1) != &#39;\\&#39;) {
128                     if (i + 1 &lt; temp.length()) {
129                         result = temp.substring(i + 1, temp.length());
130                     } else {
131                         throw new IllegalArgumentException
132                                 (&quot;empty realm part not allowed&quot;);
133                     }
134                     break;
135                 }
136             }
137             i++;
138         }
139         if (result != null) {
140             if (result.length() == 0)
141                 throw new RealmException(Krb5.REALM_NULL);
142             if (!isValidRealmString(result))
143                 throw new RealmException(Krb5.REALM_ILLCHAR);
144         }
145         return result;
146     }
147 
148     public static String parseRealmComponent(String name) {
149         if (name == null) {
150             throw new IllegalArgumentException
151                 (&quot;null input name is not allowed&quot;);
152         }
153         String temp = new String(name);
154         String result = null;
155         int i = 0;
156         while (i &lt; temp.length()) {
157             if (temp.charAt(i) == PrincipalName.REALM_COMPONENT_SEPARATOR) {
158                 if (i == 0 || temp.charAt(i - 1) != &#39;\\&#39;) {
159                     if (i + 1 &lt; temp.length())
160                         result = temp.substring(i + 1, temp.length());
161                     break;
162                 }
163             }
164             i++;
165         }
166         return result;
167     }
168 
169     protected static String parseRealm(String name) throws RealmException {
170         String result = parseRealmAtSeparator(name);
171         if (result == null)
172             result = name;
173         if (result == null || result.length() == 0)
174             throw new RealmException(Krb5.REALM_NULL);
175         if (!isValidRealmString(result))
176             throw new RealmException(Krb5.REALM_ILLCHAR);
177         return result;
178     }
179 
180     // This is protected because the definition of a realm
181     // string is fixed
182     protected static boolean isValidRealmString(String name) {
183         if (name == null)
184             return false;
185         if (name.length() == 0)
186             return false;
187         for (int i = 0; i &lt; name.length(); i++) {
188             if (name.charAt(i) == &#39;/&#39; ||
189                 name.charAt(i) == &#39;:&#39; ||
190                 name.charAt(i) == &#39;\0&#39;) {
191                 return false;
192             }
193         }
194         return true;
195     }
196 
197     /**
198      * Encodes a Realm object.
199      * @return the byte array of encoded KrbCredInfo object.
200      * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
201      * @exception IOException if an I/O error occurs while reading encoded data.
202      *
203      */
204     public byte[] asn1Encode() throws Asn1Exception, IOException {
205         DerOutputStream out = new DerOutputStream();
206         out.putDerValue(new KerberosString(this.realm).toDerValue());
207         return out.toByteArray();
208     }
209 
210 
211     /**
212      * Parse (unmarshal) a realm from a DER input stream.  This form
213      * parsing might be used when expanding a value which is part of
214      * a constructed sequence and uses explicitly tagged type.
215      *
216      * @exception Asn1Exception on error.
217      * @param data the Der input stream value, which contains one or more marshaled value.
218      * @param explicitTag tag number.
219      * @param optional indicate if this data field is optional
220      * @return an instance of Realm.
221      *
222      */
223     public static Realm parse(DerInputStream data, byte explicitTag, boolean optional)
224             throws Asn1Exception, IOException, RealmException {
225         if ((optional) &amp;&amp; (((byte)data.peekByte() &amp; (byte)0x1F) != explicitTag)) {
226             return null;
227         }
228         DerValue der = data.getDerValue();
229         if (explicitTag != (der.getTag() &amp; (byte)0x1F))  {
230             throw new Asn1Exception(Krb5.ASN1_BAD_ID);
231         } else {
232             DerValue subDer = der.getData().getDerValue();
233             return new Realm(subDer);
234         }
235     }
236 
237     /**
238      * Returns an array of realms that may be traversed to obtain
239      * a TGT from the initiating realm cRealm to the target realm
240      * sRealm.
241      * &lt;br&gt;
242      * This method would read [capaths] to create a path, or generate a
243      * hierarchical path if [capaths] does not contain a sub-stanza for cRealm
244      * or the sub-stanza does not contain a tag for sRealm.
245      * &lt;br&gt;
246      * The returned list would never be null, and it always contains
247      * cRealm as the head entry. sRealm is not included as the tail.
248      *
249      * @param cRealm the initiating realm, not null
250      * @param sRealm the target realm, not null, not equals to cRealm
251      * @return array of realms including at least cRealm as the first
252      *         element
253      */
254     public static String[] getRealmsList(String cRealm, String sRealm) {
255         try {
256             // Try [capaths]
257             return parseCapaths(cRealm, sRealm);
258         } catch (KrbException ke) {
259             // Now assume the realms are organized hierarchically.
260             return parseHierarchy(cRealm, sRealm);
261         }
262     }
263 
264     /**
265      * Parses the [capaths] stanza of the configuration file for a
266      * list of realms to traverse to obtain credentials from the
267      * initiating realm cRealm to the target realm sRealm.
268      *
269      * For a given client realm C there is a tag C in [capaths] whose
270      * subtag S has a value which is a (possibly partial) path from C
271      * to S. When the path is partial, it contains only the tail of the
272      * full path. Values of other subtags will be used to build the full
273      * path. The value &quot;.&quot; means a direct path from C to S. If realm S
274      * does not appear as a subtag, there is no path defined here.
275      *
276      * The implementation ignores all values which equals to C or S, or
277      * a &quot;.&quot; in multiple values, or any duplicated realm names.
278      *
279      * When a path value has more than two realms, they can be specified
280      * with multiple key-value pairs each having a single value, but the
281      * order must not change.
282      *
283      * For example:
284      *
285      * [capaths]
286      *    TIVOLI.COM = {
287      *        IBM.COM = IBM_LDAPCENTRAL.COM MOONLITE.ORG
288      *        IBM_LDAPCENTRAL.COM = LDAPCENTRAL.NET
289      *        LDAPCENTRAL.NET = .
290      *    }
291      *
292      * TIVOLI.COM has a direct path to LDAPCENTRAL.NET, which has a direct
293      * path to IBM_LDAPCENTRAL.COM. It also has a partial path to IBM.COM
294      * being &quot;IBM_LDAPCENTRAL.COM MOONLITE.ORG&quot;. Merging these info together,
295      * a full path from TIVOLI.COM to IBM.COM will be
296      *
297      *   TIVOLI.COM -&gt; LDAPCENTRAL.NET -&gt; IBM_LDAPCENTRAL.COM
298      *              -&gt; IBM_LDAPCENTRAL.COM -&gt; MOONLITE.ORG
299      *
300      * Please note the sRealm IBM.COM does not appear in the path.
301      *
302      * @param cRealm the initiating realm
303      * @param sRealm the target realm, not the same as cRealm
304      * @return array of realms including at least cRealm as the first
305      *          element
306      * @throws KrbException if the config does not contain a sub-stanza
307      *          for cRealm in [capaths] or the sub-stanza does not contain
308      *          sRealm as a tag
309      */
310     private static String[] parseCapaths(String cRealm, String sRealm)
311             throws KrbException {
312 
313         // This line could throw a KrbException
314         Config cfg = Config.getInstance();
315 
316         if (!cfg.exists(&quot;capaths&quot;, cRealm, sRealm)) {
317             throw new KrbException(&quot;No conf&quot;);
318         }
319 
320         LinkedList&lt;String&gt; path = new LinkedList&lt;&gt;();
321 
322         String head = sRealm;
323         while (true) {
324             String value = cfg.getAll(&quot;capaths&quot;, cRealm, head);
325             if (value == null) {
326                 break;
327             }
328             String[] more = value.split(&quot;\\s+&quot;);
329             boolean changed = false;
330             for (int i=more.length-1; i&gt;=0; i--) {
331                 if (path.contains(more[i])
332                         || more[i].equals(&quot;.&quot;)
333                         || more[i].equals(cRealm)
334                         || more[i].equals(sRealm)
335                         || more[i].equals(head)) {
336                     // Ignore invalid values
337                     continue;
338                 }
339                 changed = true;
340                 path.addFirst(more[i]);
341             }
342             if (!changed) break;
343             head = path.getFirst();
344         }
345         path.addFirst(cRealm);
346         return path.toArray(new String[path.size()]);
347    }
348 
349     /**
350      * Build a list of realm that can be traversed
351      * to obtain credentials from the initiating realm cRealm
352      * for a service in the target realm sRealm.
353      * @param cRealm the initiating realm
354      * @param sRealm the target realm, not the same as cRealm
355      * @return array of realms including cRealm as the first element
356      */
357     private static String[] parseHierarchy(String cRealm, String sRealm) {
358 
359         String[] cComponents = cRealm.split(&quot;\\.&quot;);
360         String[] sComponents = sRealm.split(&quot;\\.&quot;);
361 
362         int cPos = cComponents.length;
363         int sPos = sComponents.length;
364 
365         boolean hasCommon = false;
366         for (sPos--, cPos--; sPos &gt;=0 &amp;&amp; cPos &gt;= 0 &amp;&amp;
367                 sComponents[sPos].equals(cComponents[cPos]);
368                 sPos--, cPos--) {
369             hasCommon = true;
370         }
371 
372         // For those with common components:
373         //                            length  pos
374         // SITES1.SALES.EXAMPLE.COM   4       1
375         //   EVERYWHERE.EXAMPLE.COM   3       0
376 
377         // For those without common components:
378         //                     length  pos
379         // DEVEL.EXAMPLE.COM   3       2
380         // PROD.EXAMPLE.ORG    3       2
381 
382         LinkedList&lt;String&gt; path = new LinkedList&lt;&gt;();
383 
384         // Un-common ones for client side
385         for (int i=0; i&lt;=cPos; i++) {
386             path.addLast(subStringFrom(cComponents, i));
387         }
388 
389         // Common one
390         if (hasCommon) {
391             path.addLast(subStringFrom(cComponents, cPos+1));
392         }
393 
394         // Un-common ones for server side
395         for (int i=sPos; i&gt;=0; i--) {
396             path.addLast(subStringFrom(sComponents, i));
397         }
398 
399         // Remove sRealm from path. Note that it might be added at last loop
400         // or as a common component, if sRealm is a parent of cRealm
401         path.removeLast();
402 
403         return path.toArray(new String[path.size()]);
404     }
405 
406     /**
407      * Creates a realm name using components from the given position.
408      * For example, subStringFrom({&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}, 1) is &quot;B.C&quot;.
409      */
410     private static String subStringFrom(String[] components, int from) {
411         StringBuilder sb = new StringBuilder();
412         for (int i=from; i&lt;components.length; i++) {
413             if (sb.length() != 0) sb.append(&#39;.&#39;);
414             sb.append(components[i]);
415         }
416         return sb.toString();
417     }
418 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.security.jgss/share/classes/sun/security/jgss/krb5/Krb5NameElement.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.jgss.krb5;
 27 
 28 import org.ietf.jgss.*;
 29 import sun.security.jgss.spi.*;
 30 import sun.security.krb5.PrincipalName;
 31 import sun.security.krb5.Realm;
 32 import sun.security.krb5.KrbException;
 33 
 34 import javax.security.auth.kerberos.ServicePermission;
 35 import java.net.InetAddress;
 36 import java.net.UnknownHostException;
 37 import java.security.Provider;
 38 import java.util.Locale;
 39 
 40 import static java.nio.charset.StandardCharsets.UTF_8;
 41 
 42 /**
 43  * Implements the GSSNameSpi for the krb5 mechanism.
 44  *
 45  * @author Mayank Upadhyay
 46  */
 47 public class Krb5NameElement
 48     implements GSSNameSpi {
 49 
 50     private PrincipalName krb5PrincipalName;
 51 
 52     private String gssNameStr = null;
 53     private Oid gssNameType = null;
 54 
 55     private Krb5NameElement(PrincipalName principalName,
 56                             String gssNameStr,
 57                             Oid gssNameType) {
 58         this.krb5PrincipalName = principalName;
 59         this.gssNameStr = gssNameStr;
 60         this.gssNameType = gssNameType;
 61     }
 62 
 63     /**
 64      * Instantiates a new Krb5NameElement object. Internally it stores the
 65      * information provided by the input parameters so that they may later
 66      * be used for output when a printable representaion of this name is
 67      * needed in GSS-API format rather than in Kerberos format.
 68      *
 69      */
 70     static Krb5NameElement getInstance(String gssNameStr, Oid gssNameType)
 71         throws GSSException {
 72 
 73         /*
 74          * A null gssNameType implies that the mechanism default
 75          * Krb5MechFactory.NT_GSS_KRB5_PRINCIPAL be used.
 76          */
 77         if (gssNameType == null)
 78             gssNameType = Krb5MechFactory.NT_GSS_KRB5_PRINCIPAL;
 79         else
 80             if (!gssNameType.equals(GSSName.NT_USER_NAME) &amp;&amp;
 81                 !gssNameType.equals(GSSName.NT_HOSTBASED_SERVICE) &amp;&amp;
 82                 !gssNameType.equals(Krb5MechFactory.NT_GSS_KRB5_PRINCIPAL) &amp;&amp;
 83                 !gssNameType.equals(GSSName.NT_EXPORT_NAME))
 84                 throw new GSSException(GSSException.BAD_NAMETYPE, -1,
 85                                        gssNameType.toString()
 86                                        +&quot; is an unsupported nametype&quot;);
 87 
 88         PrincipalName principalName;
 89         try {
 90 
 91             if (gssNameType.equals(GSSName.NT_EXPORT_NAME) ||
 92                 gssNameType.equals(Krb5MechFactory.NT_GSS_KRB5_PRINCIPAL)) {
 93                 principalName = new PrincipalName(gssNameStr,
 94                                   PrincipalName.KRB_NT_PRINCIPAL);
 95             } else {
 96 
 97                 String[] components = getComponents(gssNameStr);
 98 
 99                 /*
100                  * We have forms of GSS name strings that can come in:
101                  *
102                  * 1. names of the form &quot;foo&quot; with just one
103                  * component. (This might include a &quot;@&quot; but only in escaped
104                  * form like &quot;\@&quot;)
105                  * 2. names of the form &quot;foo@bar&quot; with two components
106                  *
107                  * The nametypes that are accepted are NT_USER_NAME, and
108                  * NT_HOSTBASED_SERVICE.
109                  */
110 
111                 if (gssNameType.equals(GSSName.NT_USER_NAME))
112                     principalName = new PrincipalName(gssNameStr,
113                                     PrincipalName.KRB_NT_PRINCIPAL);
114                 else {
115                     String hostName = null;
116                     String service = components[0];
117                     if (components.length &gt;= 2)
118                         hostName = components[1];
119 
120                     String principal = getHostBasedInstance(service, hostName);
121                     principalName = new PrincipalName(principal,
122                             PrincipalName.KRB_NT_SRV_HST);
123                 }
124             }
125 
126         } catch (KrbException e) {
127             throw new GSSException(GSSException.BAD_NAME, -1, e.getMessage());
128         }
129 
130         if (principalName.isRealmDeduced() &amp;&amp; !Realm.AUTODEDUCEREALM) {
131             SecurityManager sm = System.getSecurityManager();
132             if (sm != null) {
133                 try {
134                     sm.checkPermission(new ServicePermission(
135                             &quot;@&quot; + principalName.getRealmAsString(), &quot;-&quot;));
136                 } catch (SecurityException se) {
137                     // Do not chain the actual exception to hide info
138                     throw new GSSException(GSSException.FAILURE);
139                 }
140             }
141         }
142         return new Krb5NameElement(principalName, gssNameStr, gssNameType);
143     }
144 
145     public static Krb5NameElement getInstance(PrincipalName principalName) {
146         return new Krb5NameElement(principalName,
147                                    principalName.getName(),
148                                    Krb5MechFactory.NT_GSS_KRB5_PRINCIPAL);
149     }
150 
151     private static String[] getComponents(String gssNameStr)
152         throws GSSException {
153 
154         String[] retVal;
155 
156         // XXX Perhaps provide this parsing code in PrincipalName
157 
158         // Look for @ as in service@host
159         // Assumes host name will not have an escaped &#39;@&#39;
160         int separatorPos = gssNameStr.lastIndexOf(&#39;@&#39;, gssNameStr.length());
161 
162         // Not really a separator if it is escaped. Then this is just part
163         // of the principal name or service name
164         if ((separatorPos &gt; 0) &amp;&amp;
165                 (gssNameStr.charAt(separatorPos-1) == &#39;\\&#39;)) {
166             // Is the `\` character escaped itself?
167             if ((separatorPos - 2 &lt; 0) ||
168                 (gssNameStr.charAt(separatorPos-2) != &#39;\\&#39;))
169                 separatorPos = -1;
170         }
171 
172         if (separatorPos &gt; 0) {
173             String serviceName = gssNameStr.substring(0, separatorPos);
174             String hostName = gssNameStr.substring(separatorPos+1);
175             retVal = new String[] { serviceName, hostName};
176         } else {
177             retVal = new String[] {gssNameStr};
178         }
179 
180         return retVal;
181 
182     }
183 
184     private static String getHostBasedInstance(String serviceName,
185                                                String hostName)
186         throws GSSException {
187             StringBuffer temp = new StringBuffer(serviceName);
188 
189             try {
190                 // A lack of &quot;@&quot; defaults to the service being on the local
191                 // host as per RFC 2743
192                 // XXX Move this part into JGSS framework
193                 if (hostName == null)
194                     hostName = InetAddress.getLocalHost().getHostName();
195 
196             } catch (UnknownHostException e) {
197                 // use hostname as it is
198             }
199             hostName = hostName.toLowerCase(Locale.ENGLISH);
200 
201             temp = temp.append(&#39;/&#39;).append(hostName);
202             return temp.toString();
203     }
204 
205     public final PrincipalName getKrb5PrincipalName() {
206         return krb5PrincipalName;
207     }
208 
209     /**
210      * Equal method for the GSSNameSpi objects.
211      * If either name denotes an anonymous principal, the call should
212      * return false.
213      *
214      * @param other to be compared with
215      * @return true if they both refer to the same entity, else false
216      * @exception GSSException with major codes of BAD_NAMETYPE,
217      *  BAD_NAME, FAILURE
218      */
219     public boolean equals(GSSNameSpi other) throws GSSException {
220 
221         if (other == this)
222             return true;
223 
224         if (other instanceof Krb5NameElement) {
225                 Krb5NameElement that = (Krb5NameElement) other;
226                 return (this.krb5PrincipalName.getName().equals(
227                             that.krb5PrincipalName.getName()));
228         }
229         return false;
230     }
231 
232     /**
233      * Compares this &lt;code&gt;GSSNameSpi&lt;/code&gt; object to another Object
234      * that might be a &lt;code&gt;GSSNameSpi&lt;/code&gt;. The behaviour is exactly
235      * the same as in {@link #equals(GSSNameSpi) equals} except that
236      * no GSSException is thrown; instead, false will be returned in the
237      * situation where an error occurs.
238      *
239      * @param another the object to be compared to
240      * @return true if they both refer to the same entity, else false
241      * @see #equals(GSSNameSpi)
242      */
243     public boolean equals(Object another) {
244         if (this == another) {
245             return true;
246         }
247 
248         try {
249             if (another instanceof Krb5NameElement)
250                  return equals((Krb5NameElement) another);
251         } catch (GSSException e) {
252             // ignore exception
253         }
254         return false;
255     }
256 
257     /**
258      * Returns a hashcode value for this GSSNameSpi.
259      *
260      * @return a hashCode value
261      */
262     public int hashCode() {
263         return 37 * 17 + krb5PrincipalName.getName().hashCode();
264     }
265 
266 
267     /**
268      * Returns the principal name in the form user@REALM or
269      * host/service@REALM but with the following constraints that are
270      * imposed by RFC 1964:
271      * &lt;pre&gt;
272      *  (1) all occurrences of the characters `@`,  `/`, and `\` within
273      *   principal components or realm names shall be quoted with an
274      *   immediately-preceding `\`.
275      *
276      *   (2) all occurrences of the null, backspace, tab, or newline
277      *   characters within principal components or realm names will be
278      *   represented, respectively, with `\0`, `\b`, `\t`, or `\n`.
279      *
280      *   (3) the `\` quoting character shall not be emitted within an
281      *   exported name except to accommodate cases (1) and (2).
282      * &lt;/pre&gt;
283      */
284     public byte[] export() throws GSSException {
285         // XXX Apply the above constraints.
286         return krb5PrincipalName.getName().getBytes(UTF_8);
287     }
288 
289     /**
290      * Get the mechanism type that this NameElement corresponds to.
291      *
292      * @return the Oid of the mechanism type
293      */
294     public Oid getMechanism() {
295         return (Krb5MechFactory.GSS_KRB5_MECH_OID);
296     }
297 
298     /**
299      * Returns a string representation for this name. The printed
300      * name type can be obtained by calling getStringNameType().
301      *
302      * @return string form of this name
303      * @see #getStringNameType()
304      * @overrides Object#toString
305      */
306     public String toString() {
307         return (gssNameStr);
308         // For testing: return (super.toString());
309     }
310 
311     /**
312      * Returns the name type oid.
313      */
314     public Oid getGSSNameType() {
315         return (gssNameType);
316     }
317 
318     /**
319      * Returns the oid describing the format of the printable name.
320      *
321      * @return the Oid for the format of the printed name
322      */
323     public Oid getStringNameType() {
324         // XXX For NT_EXPORT_NAME return a different name type. Infact,
325         // don&#39;t even store NT_EXPORT_NAME in the cons.
326         return (gssNameType);
327     }
328 
329     /**
330      * Indicates if this name object represents an Anonymous name.
331      */
332     public boolean isAnonymousName() {
333         return (gssNameType.equals(GSSName.NT_ANONYMOUS));
334     }
335 
336     public Provider getProvider() {
337         return Krb5MechFactory.PROVIDER;
338     }
339 
340 }
    </pre>
  </body>
</html>
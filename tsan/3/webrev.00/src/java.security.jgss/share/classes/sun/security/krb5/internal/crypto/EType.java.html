<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.security.jgss/share/classes/sun/security/krb5/internal/crypto/EType.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  *
 28  *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 29  *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 30  */
 31 
 32 package sun.security.krb5.internal.crypto;
 33 
 34 import sun.security.krb5.internal.*;
 35 import sun.security.krb5.Config;
 36 import sun.security.krb5.EncryptedData;
 37 import sun.security.krb5.EncryptionKey;
 38 import sun.security.krb5.KrbException;
 39 import sun.security.krb5.KrbCryptoException;
 40 import javax.crypto.*;
 41 import java.util.Arrays;
 42 import java.util.List;
 43 import java.util.ArrayList;
 44 
 45 //only needed if dataSize() implementation changes back to spec;
 46 //see dataSize() below
 47 
 48 public abstract class EType {
 49 
 50     private static final boolean DEBUG = Krb5.DEBUG;
 51     private static boolean allowWeakCrypto;
 52 
 53     static {
 54         initStatic();
 55     }
 56 
 57     public static void initStatic() {
 58         boolean allowed = false;
 59         try {
 60             Config cfg = Config.getInstance();
 61             allowed = cfg.getBooleanObject(&quot;libdefaults&quot;, &quot;allow_weak_crypto&quot;)
 62                     == Boolean.TRUE;
 63         } catch (Exception exc) {
 64             if (DEBUG) {
 65                 System.out.println (&quot;Exception in getting allow_weak_crypto, &quot; +
 66                                     &quot;using default value: &quot; +
 67                                     exc.getMessage());
 68             }
 69         }
 70         allowWeakCrypto = allowed;
 71     }
 72 
 73     public static EType getInstance  (int eTypeConst)
 74         throws KdcErrException {
 75         EType eType = null;
 76         String eTypeName = null;
 77         switch (eTypeConst) {
 78         case EncryptedData.ETYPE_NULL:
 79             eType = new NullEType();
 80             eTypeName = &quot;sun.security.krb5.internal.crypto.NullEType&quot;;
 81             break;
 82         case EncryptedData.ETYPE_DES_CBC_CRC:
 83             eType = new DesCbcCrcEType();
 84             eTypeName = &quot;sun.security.krb5.internal.crypto.DesCbcCrcEType&quot;;
 85             break;
 86         case EncryptedData.ETYPE_DES_CBC_MD5:
 87             eType = new DesCbcMd5EType();
 88             eTypeName = &quot;sun.security.krb5.internal.crypto.DesCbcMd5EType&quot;;
 89             break;
 90 
 91         case EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD:
 92             eType = new Des3CbcHmacSha1KdEType();
 93             eTypeName =
 94                 &quot;sun.security.krb5.internal.crypto.Des3CbcHmacSha1KdEType&quot;;
 95             break;
 96 
 97         case EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96:
 98             eType = new Aes128CtsHmacSha1EType();
 99             eTypeName =
100                 &quot;sun.security.krb5.internal.crypto.Aes128CtsHmacSha1EType&quot;;
101             break;
102 
103         case EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96:
104             eType = new Aes256CtsHmacSha1EType();
105             eTypeName =
106                 &quot;sun.security.krb5.internal.crypto.Aes256CtsHmacSha1EType&quot;;
107             break;
108 
109         case EncryptedData.ETYPE_AES128_CTS_HMAC_SHA256_128:
110             eType = new Aes128CtsHmacSha2EType();
111             eTypeName =
112                     &quot;sun.security.krb5.internal.crypto.Aes128CtsHmacSha2EType&quot;;
113             break;
114 
115         case EncryptedData.ETYPE_AES256_CTS_HMAC_SHA384_192:
116             eType = new Aes256CtsHmacSha2EType();
117             eTypeName =
118                     &quot;sun.security.krb5.internal.crypto.Aes256CtsHmacSha2EType&quot;;
119             break;
120 
121             case EncryptedData.ETYPE_ARCFOUR_HMAC:
122             eType = new ArcFourHmacEType();
123             eTypeName = &quot;sun.security.krb5.internal.crypto.ArcFourHmacEType&quot;;
124             break;
125 
126         default:
127             String msg = &quot;encryption type = &quot; + toString(eTypeConst)
128                 + &quot; (&quot;  + eTypeConst + &quot;)&quot;;
129             throw new KdcErrException(Krb5.KDC_ERR_ETYPE_NOSUPP, msg);
130         }
131         if (DEBUG) {
132             System.out.println(&quot;&gt;&gt;&gt; EType: &quot; + eTypeName);
133         }
134         return eType;
135     }
136 
137     public abstract int eType();
138 
139     public abstract int minimumPadSize();
140 
141     public abstract int confounderSize();
142 
143     public abstract int checksumType();
144 
145     public abstract int checksumSize();
146 
147     public abstract int blockSize();
148 
149     public abstract int keyType();
150 
151     public abstract int keySize();
152 
153     public abstract byte[] encrypt(byte[] data, byte[] key, int usage)
154         throws KrbCryptoException;
155 
156     public abstract byte[] encrypt(byte[] data, byte[] key, byte[] ivec,
157         int usage) throws KrbCryptoException;
158 
159     public abstract byte[] decrypt(byte[] cipher, byte[] key, int usage)
160         throws KrbApErrException, KrbCryptoException;
161 
162     public abstract byte[] decrypt(byte[] cipher, byte[] key, byte[] ivec,
163         int usage) throws KrbApErrException, KrbCryptoException;
164 
165     public int dataSize(byte[] data)
166     // throws Asn1Exception
167     {
168         // EncodeRef ref = new EncodeRef(data, startOfData());
169         // return ref.end - startOfData();
170         // should be the above according to spec, but in fact
171         // implementations include the pad bytes in the data size
172         return data.length - startOfData();
173     }
174 
175     public int padSize(byte[] data) {
176         return data.length - confounderSize() - checksumSize() -
177             dataSize(data);
178     }
179 
180     public int startOfChecksum() {
181         return confounderSize();
182     }
183 
184     public int startOfData() {
185         return confounderSize() + checksumSize();
186     }
187 
188     public int startOfPad(byte[] data) {
189         return confounderSize() + checksumSize() + dataSize(data);
190     }
191 
192     public byte[] decryptedData(byte[] data) {
193         int tempSize = dataSize(data);
194         byte[] result = new byte[tempSize];
195         System.arraycopy(data, startOfData(), result, 0, tempSize);
196         return result;
197     }
198 
199     // Note: the first 2 entries of BUILTIN_ETYPES and BUILTIN_ETYPES_NOAES256
200     // should be kept DES-related. They will be removed when allow_weak_crypto
201     // is set to false.
202 
203     private static final int[] BUILTIN_ETYPES = new int[] {
204             EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96,
205             EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96,
206             EncryptedData.ETYPE_AES256_CTS_HMAC_SHA384_192,
207             EncryptedData.ETYPE_AES128_CTS_HMAC_SHA256_128,
208             EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD,
209             EncryptedData.ETYPE_ARCFOUR_HMAC,
210             EncryptedData.ETYPE_DES_CBC_CRC,
211             EncryptedData.ETYPE_DES_CBC_MD5,
212     };
213 
214     private static final int[] BUILTIN_ETYPES_NOAES256 = new int[] {
215             EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96,
216             EncryptedData.ETYPE_AES128_CTS_HMAC_SHA256_128,
217             EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD,
218             EncryptedData.ETYPE_ARCFOUR_HMAC,
219             EncryptedData.ETYPE_DES_CBC_CRC,
220             EncryptedData.ETYPE_DES_CBC_MD5,
221     };
222 
223 
224     // used in Config
225     public static int[] getBuiltInDefaults() {
226         int allowed = 0;
227         try {
228             allowed = Cipher.getMaxAllowedKeyLength(&quot;AES&quot;);
229         } catch (Exception e) {
230             // should not happen
231         }
232         int[] result;
233         if (allowed &lt; 256) {
234             result = BUILTIN_ETYPES_NOAES256;
235         } else {
236             result = BUILTIN_ETYPES;
237         }
238         if (!allowWeakCrypto) {
239             // The last 2 etypes are now weak ones
240             return Arrays.copyOfRange(result, 0, result.length - 2);
241         }
242         return result;
243     }
244 
245     /**
246      * Retrieves the default etypes from the configuration file, or
247      * if that&#39;s not available, return the built-in list of default etypes.
248      * This result is always non-empty. If no etypes are found,
249      * an exception is thrown.
250      */
251     public static int[] getDefaults(String configName)
252             throws KrbException {
253         Config config = null;
254         try {
255             config = Config.getInstance();
256         } catch (KrbException exc) {
257             if (DEBUG) {
258                 System.out.println(&quot;Exception while getting &quot; +
259                     configName + &quot;: &quot; + exc.getMessage());
260                 System.out.println(&quot;Using default builtin etypes&quot;);
261             }
262             return getBuiltInDefaults();
263         }
264         return config.defaultEtype(configName);
265     }
266 
267     /**
268      * Retrieve the default etypes from the configuration file for
269      * those etypes for which there are corresponding keys.
270      * Used in scenario we have some keys from a keytab with etypes
271      * different from those named in configName. Then, in order
272      * to decrypt an AS-REP, we should only ask for etypes for which
273      * we have keys.
274      */
275     public static int[] getDefaults(String configName, EncryptionKey[] keys)
276             throws KrbException {
277         int[] answer = getDefaults(configName);
278 
279         List&lt;Integer&gt; list = new ArrayList&lt;&gt;(answer.length);
280         for (int i = 0; i &lt; answer.length; i++) {
281             if (EncryptionKey.findKey(answer[i], keys) != null) {
282                 list.add(answer[i]);
283             }
284         }
285         int len = list.size();
286         if (len &lt;= 0) {
287             StringBuilder keystr = new StringBuilder();
288             for (int i = 0; i &lt; keys.length; i++) {
289                 keystr.append(toString(keys[i].getEType()));
290                 keystr.append(&quot; &quot;);
291             }
292             throw new KrbException(
293                 &quot;Do not have keys of types listed in &quot; + configName +
294                 &quot; available; only have keys of following type: &quot; +
295                 keystr.toString());
296         } else {
297             answer = new int[len];
298             for (int i = 0; i &lt; len; i++) {
299                 answer[i] = list.get(i);
300             }
301             return answer;
302         }
303     }
304 
305     public static boolean isSupported(int eTypeConst, int[] config) {
306         for (int i = 0; i &lt; config.length; i++) {
307             if (eTypeConst == config[i]) {
308                 return true;
309             }
310         }
311         return false;
312     }
313 
314     public static boolean isSupported(int eTypeConst) {
315         int[] enabledETypes = getBuiltInDefaults();
316         return isSupported(eTypeConst, enabledETypes);
317     }
318 
319     /**
320      * https://tools.ietf.org/html/rfc4120#section-3.1.3:
321      *
322      *                 A &quot;newer&quot; enctype is any enctype first officially
323      * specified concurrently with or subsequent to the issue of this RFC.
324      * The enctypes DES, 3DES, or RC4 and any defined in [RFC1510] are not
325      * &quot;newer&quot; enctypes.
326      *
327      * @param eTypeConst the encryption type
328      * @return true if &quot;newer&quot;
329      */
330     public static boolean isNewer(int eTypeConst) {
331         return eTypeConst != EncryptedData.ETYPE_DES_CBC_CRC &amp;&amp;
332                 eTypeConst != EncryptedData.ETYPE_DES_CBC_MD4 &amp;&amp;
333                 eTypeConst != EncryptedData.ETYPE_DES_CBC_MD5 &amp;&amp;
334                 eTypeConst != EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD &amp;&amp;
335                 eTypeConst != EncryptedData.ETYPE_ARCFOUR_HMAC &amp;&amp;
336                 eTypeConst != EncryptedData.ETYPE_ARCFOUR_HMAC_EXP;
337     }
338 
339     public static String toString(int type) {
340         switch (type) {
341         case 0:
342             return &quot;NULL&quot;;
343         case 1:
344             return &quot;DES CBC mode with CRC-32&quot;;
345         case 2:
346             return &quot;DES CBC mode with MD4&quot;;
347         case 3:
348             return &quot;DES CBC mode with MD5&quot;;
349         case 4:
350             return &quot;reserved&quot;;
351         case 5:
352             return &quot;DES3 CBC mode with MD5&quot;;
353         case 6:
354             return &quot;reserved&quot;;
355         case 7:
356             return &quot;DES3 CBC mode with SHA1&quot;;
357         case 9:
358             return &quot;DSA with SHA1- Cms0ID&quot;;
359         case 10:
360             return &quot;MD5 with RSA encryption - Cms0ID&quot;;
361         case 11:
362             return &quot;SHA1 with RSA encryption - Cms0ID&quot;;
363         case 12:
364             return &quot;RC2 CBC mode with Env0ID&quot;;
365         case 13:
366             return &quot;RSA encryption with Env0ID&quot;;
367         case 14:
368             return &quot;RSAES-0AEP-ENV-0ID&quot;;
369         case 15:
370             return &quot;DES-EDE3-CBC-ENV-0ID&quot;;
371         case 16:
372             return &quot;DES3 CBC mode with SHA1-KD&quot;;
373         case 17:
374             return &quot;AES128 CTS mode with HMAC SHA1-96&quot;;
375         case 18:
376             return &quot;AES256 CTS mode with HMAC SHA1-96&quot;;
377         case 23:
378             return &quot;RC4 with HMAC&quot;;
379         case 24:
380             return &quot;RC4 with HMAC EXP&quot;;
381         case EncryptedData.ETYPE_AES128_CTS_HMAC_SHA256_128:
382             return &quot;AES128 CTS mode with HMAC SHA256-128&quot;;
383         case EncryptedData.ETYPE_AES256_CTS_HMAC_SHA384_192:
384             return &quot;AES256 CTS mode with HMAC SHA384-192&quot;;
385         }
386         return &quot;Unknown (&quot; + type + &quot;)&quot;;
387     }
388 }
    </pre>
  </body>
</html>
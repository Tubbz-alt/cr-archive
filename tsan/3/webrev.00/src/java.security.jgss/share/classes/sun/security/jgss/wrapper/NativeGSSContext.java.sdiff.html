<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GSSNameElement.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NativeGSSFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.security.jgss/share/classes/sun/security/jgss/wrapper/NativeGSSContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 42 /**
 43  * This class is essentially a wrapper class for the gss_ctx_id_t
 44  * structure of the native GSS library.
 45  * @author Valerie Peng
 46  * @since 1.6
 47  */
 48 class NativeGSSContext implements GSSContextSpi {
 49 
 50     private static final int GSS_C_DELEG_FLAG = 1;
 51     private static final int GSS_C_MUTUAL_FLAG = 2;
 52     private static final int GSS_C_REPLAY_FLAG = 4;
 53     private static final int GSS_C_SEQUENCE_FLAG = 8;
 54     private static final int GSS_C_CONF_FLAG = 16;
 55     private static final int GSS_C_INTEG_FLAG = 32;
 56     private static final int GSS_C_ANON_FLAG = 64;
 57     private static final int GSS_C_PROT_READY_FLAG = 128;
 58     private static final int GSS_C_TRANS_FLAG = 256;
 59 
 60     private static final int NUM_OF_INQUIRE_VALUES = 6;
 61 

 62     private long pContext = 0; // Pointer to the gss_ctx_id_t structure
 63     private GSSNameElement srcName;
 64     private GSSNameElement targetName;
<span class="line-removed"> 65     private GSSCredElement cred;</span>
<span class="line-removed"> 66     private GSSCredElement disposeCred;</span>
 67     private boolean isInitiator;
 68     private boolean isEstablished;



 69     private Oid actualMech; // Assigned during context establishment
 70 



 71     private ChannelBinding cb;
<span class="line-removed"> 72     private GSSCredElement delegatedCred;</span>
 73     private GSSCredElement disposeDelegatedCred;
<span class="line-removed"> 74     private int flags;</span>
<span class="line-removed"> 75     private int lifetime = GSSCredential.DEFAULT_LIFETIME;</span>
 76     private final GSSLibStub cStub;
 77 
 78     private boolean skipDelegPermCheck;
 79     private boolean skipServicePermCheck;
 80 
 81     // Retrieve the (preferred) mech out of SPNEGO tokens, i.e.
 82     // NegTokenInit &amp; NegTokenTarg
 83     private static Oid getMechFromSpNegoToken(byte[] token,
 84                                               boolean isInitiator)
 85         throws GSSException {
 86         Oid mech = null;
 87         if (isInitiator) {
 88             GSSHeader header = null;
 89             try {
 90                 header = new GSSHeader(new ByteArrayInputStream(token));
 91             } catch (IOException ioe) {
 92                 throw new GSSExceptionImpl(GSSException.FAILURE, ioe);
 93             }
 94             int negTokenLen = header.getMechTokenLength();
 95             byte[] negToken = new byte[negTokenLen];
</pre>
<hr />
<pre>
214     NativeGSSContext(GSSCredElement myCred, GSSLibStub stub)
215         throws GSSException {
216         cStub = stub;
217         cred = myCred;
218         disposeCred = null;
219 
220         if (cred != null) targetName = cred.getName();
221 
222         isInitiator = false;
223         // Defer Service permission check for default acceptor cred
224         // to acceptSecContext()
225         if (GSSUtil.isKerberosMech(cStub.getMech()) &amp;&amp; targetName != null) {
226             doServicePermCheck();
227         }
228 
229         // srcName and potentially targetName (when myCred is null)
230         // will be set in GSSLibStub.acceptContext(...)
231     }
232 
233     // Constructor for imported context

234     NativeGSSContext(long pCtxt, GSSLibStub stub) throws GSSException {
235         assert(pContext != 0);
236         pContext = pCtxt;
237         cStub = stub;
238 
239         // Set everything except cred, cb, delegatedCred
240         long[] info = cStub.inquireContext(pContext);
241         if (info.length != NUM_OF_INQUIRE_VALUES) {
242             throw new RuntimeException(&quot;Bug w/ GSSLibStub.inquireContext()&quot;);
243         }
244         srcName = new GSSNameElement(info[0], cStub);
245         targetName = new GSSNameElement(info[1], cStub);
246         isInitiator = (info[2] != 0);
247         isEstablished = (info[3] != 0);
248         flags = (int) info[4];
249         lifetime = (int) info[5];
250 
251         // Do Service Permission check when importing SPNEGO context
252         // just to be safe
253         Oid mech = cStub.getMech();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 42 /**
 43  * This class is essentially a wrapper class for the gss_ctx_id_t
 44  * structure of the native GSS library.
 45  * @author Valerie Peng
 46  * @since 1.6
 47  */
 48 class NativeGSSContext implements GSSContextSpi {
 49 
 50     private static final int GSS_C_DELEG_FLAG = 1;
 51     private static final int GSS_C_MUTUAL_FLAG = 2;
 52     private static final int GSS_C_REPLAY_FLAG = 4;
 53     private static final int GSS_C_SEQUENCE_FLAG = 8;
 54     private static final int GSS_C_CONF_FLAG = 16;
 55     private static final int GSS_C_INTEG_FLAG = 32;
 56     private static final int GSS_C_ANON_FLAG = 64;
 57     private static final int GSS_C_PROT_READY_FLAG = 128;
 58     private static final int GSS_C_TRANS_FLAG = 256;
 59 
 60     private static final int NUM_OF_INQUIRE_VALUES = 6;
 61 
<span class="line-added"> 62     // Warning: The following 9 fields are used by NativeUtil.c</span>
 63     private long pContext = 0; // Pointer to the gss_ctx_id_t structure
 64     private GSSNameElement srcName;
 65     private GSSNameElement targetName;


 66     private boolean isInitiator;
 67     private boolean isEstablished;
<span class="line-added"> 68     private GSSCredElement delegatedCred;</span>
<span class="line-added"> 69     private int flags;</span>
<span class="line-added"> 70     private int lifetime = GSSCredential.DEFAULT_LIFETIME;</span>
 71     private Oid actualMech; // Assigned during context establishment
 72 
<span class="line-added"> 73     private GSSCredElement cred;</span>
<span class="line-added"> 74     private GSSCredElement disposeCred;</span>
<span class="line-added"> 75 </span>
 76     private ChannelBinding cb;

 77     private GSSCredElement disposeDelegatedCred;


 78     private final GSSLibStub cStub;
 79 
 80     private boolean skipDelegPermCheck;
 81     private boolean skipServicePermCheck;
 82 
 83     // Retrieve the (preferred) mech out of SPNEGO tokens, i.e.
 84     // NegTokenInit &amp; NegTokenTarg
 85     private static Oid getMechFromSpNegoToken(byte[] token,
 86                                               boolean isInitiator)
 87         throws GSSException {
 88         Oid mech = null;
 89         if (isInitiator) {
 90             GSSHeader header = null;
 91             try {
 92                 header = new GSSHeader(new ByteArrayInputStream(token));
 93             } catch (IOException ioe) {
 94                 throw new GSSExceptionImpl(GSSException.FAILURE, ioe);
 95             }
 96             int negTokenLen = header.getMechTokenLength();
 97             byte[] negToken = new byte[negTokenLen];
</pre>
<hr />
<pre>
216     NativeGSSContext(GSSCredElement myCred, GSSLibStub stub)
217         throws GSSException {
218         cStub = stub;
219         cred = myCred;
220         disposeCred = null;
221 
222         if (cred != null) targetName = cred.getName();
223 
224         isInitiator = false;
225         // Defer Service permission check for default acceptor cred
226         // to acceptSecContext()
227         if (GSSUtil.isKerberosMech(cStub.getMech()) &amp;&amp; targetName != null) {
228             doServicePermCheck();
229         }
230 
231         // srcName and potentially targetName (when myCred is null)
232         // will be set in GSSLibStub.acceptContext(...)
233     }
234 
235     // Constructor for imported context
<span class="line-added">236     // Warning: called by NativeUtil.c</span>
237     NativeGSSContext(long pCtxt, GSSLibStub stub) throws GSSException {
238         assert(pContext != 0);
239         pContext = pCtxt;
240         cStub = stub;
241 
242         // Set everything except cred, cb, delegatedCred
243         long[] info = cStub.inquireContext(pContext);
244         if (info.length != NUM_OF_INQUIRE_VALUES) {
245             throw new RuntimeException(&quot;Bug w/ GSSLibStub.inquireContext()&quot;);
246         }
247         srcName = new GSSNameElement(info[0], cStub);
248         targetName = new GSSNameElement(info[1], cStub);
249         isInitiator = (info[2] != 0);
250         isEstablished = (info[3] != 0);
251         flags = (int) info[4];
252         lifetime = (int) info[5];
253 
254         // Do Service Permission check when importing SPNEGO context
255         // just to be safe
256         Oid mech = cStub.getMech();
</pre>
</td>
</tr>
</table>
<center><a href="GSSNameElement.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NativeGSSFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
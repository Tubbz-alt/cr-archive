<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.security.jgss/share/classes/sun/security/krb5/internal/ccache/FileCredentialsCache.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * ===========================================================================
 28  *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 29  *
 30  *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 31  * ===========================================================================
 32  *
 33  */
 34 package sun.security.krb5.internal.ccache;
 35 
 36 import sun.security.action.GetPropertyAction;
 37 import sun.security.krb5.*;
 38 import sun.security.krb5.internal.*;
 39 import sun.security.util.SecurityProperties;
 40 
 41 import java.nio.charset.StandardCharsets;
 42 import java.util.ArrayList;
 43 import java.util.Collections;
 44 import java.util.List;
 45 import java.util.StringTokenizer;
 46 import java.util.Vector;
 47 import java.io.IOException;
 48 import java.io.File;
 49 import java.io.FileInputStream;
 50 import java.io.FileOutputStream;
 51 import java.io.BufferedReader;
 52 import java.io.InputStreamReader;
 53 
 54 import static java.nio.charset.StandardCharsets.ISO_8859_1;
 55 
 56 /**
 57  * CredentialsCache stores credentials(tickets, session keys, etc) in a
 58  * semi-permanent store
 59  * for later use by different program.
 60  *
 61  * @author Yanni Zhang
 62  * @author Ram Marti
 63  */
 64 
 65 public class FileCredentialsCache extends CredentialsCache
 66     implements FileCCacheConstants {
 67     public int version;
 68     public Tag tag; // optional
 69     public PrincipalName primaryPrincipal;
 70     private Vector&lt;Credentials&gt; credentialsList;
 71     private static String dir;
 72     private static boolean DEBUG = Krb5.DEBUG;
 73 
 74     public static synchronized FileCredentialsCache acquireInstance(
 75                 PrincipalName principal, String cache) {
 76         try {
 77             FileCredentialsCache fcc = new FileCredentialsCache();
 78             if (cache == null) {
 79                 cacheName = FileCredentialsCache.getDefaultCacheName();
 80             } else {
 81                 cacheName = FileCredentialsCache.checkValidation(cache);
 82             }
 83             if ((cacheName == null) || !(new File(cacheName)).exists()) {
 84                 // invalid cache name or the file doesn&#39;t exist
 85                 return null;
 86             }
 87             if (principal != null) {
 88                 fcc.primaryPrincipal = principal;
 89             }
 90             fcc.load(cacheName);
 91             return fcc;
 92         } catch (IOException e) {
 93             // we don&#39;t handle it now, instead we return a null at the end.
 94             if (DEBUG) {
 95                 e.printStackTrace();
 96             }
 97         } catch (KrbException e) {
 98             // we don&#39;t handle it now, instead we return a null at the end.
 99             if (DEBUG) {
100                 e.printStackTrace();
101             }
102         }
103         return null;
104     }
105 
106     public static FileCredentialsCache acquireInstance() {
107         return acquireInstance(null, null);
108     }
109 
110     static synchronized FileCredentialsCache New(PrincipalName principal,
111                                                 String name) {
112         try {
113             FileCredentialsCache fcc = new FileCredentialsCache();
114             cacheName = FileCredentialsCache.checkValidation(name);
115             if (cacheName == null) {
116                 // invalid cache name or the file doesn&#39;t exist
117                 return null;
118             }
119             fcc.init(principal, cacheName);
120             return fcc;
121         }
122         catch (IOException e) {
123         }
124         catch (KrbException e) {
125         }
126         return null;
127     }
128 
129     static synchronized FileCredentialsCache New(PrincipalName principal) {
130         try {
131             FileCredentialsCache fcc = new FileCredentialsCache();
132             cacheName = FileCredentialsCache.getDefaultCacheName();
133             fcc.init(principal, cacheName);
134             return fcc;
135         }
136         catch (IOException e) {
137             if (DEBUG) {
138                 e.printStackTrace();
139             }
140         } catch (KrbException e) {
141             if (DEBUG) {
142                 e.printStackTrace();
143             }
144 
145         }
146         return null;
147     }
148 
149     private FileCredentialsCache() {
150     }
151 
152     boolean exists(String cache) {
153         File file = new File(cache);
154         if (file.exists()) {
155             return true;
156         } else return false;
157     }
158 
159     synchronized void init(PrincipalName principal, String name)
160         throws IOException, KrbException {
161         primaryPrincipal = principal;
162         try (FileOutputStream fos = new FileOutputStream(name);
163              CCacheOutputStream cos = new CCacheOutputStream(fos)) {
164             version = KRB5_FCC_FVNO_3;
165             cos.writeHeader(primaryPrincipal, version);
166         }
167         load(name);
168     }
169 
170     synchronized void load(String name) throws IOException, KrbException {
171         PrincipalName p;
172         try (FileInputStream fis = new FileInputStream(name);
173              CCacheInputStream cis = new CCacheInputStream(fis)) {
174             version = cis.readVersion();
175             if (version == KRB5_FCC_FVNO_4) {
176                 tag = cis.readTag();
177             } else {
178                 tag = null;
179                 if (version == KRB5_FCC_FVNO_1 || version == KRB5_FCC_FVNO_2) {
180                     cis.setNativeByteOrder();
181                 }
182             }
183             p = cis.readPrincipal(version);
184 
185             if (primaryPrincipal != null) {
186                 if (!(primaryPrincipal.match(p))) {
187                     throw new IOException(&quot;Primary principals don&#39;t match.&quot;);
188                 }
189             } else
190                 primaryPrincipal = p;
191             credentialsList = new Vector&lt;Credentials&gt;();
192             while (cis.available() &gt; 0) {
193                 Object cred = cis.readCred(version);
194                 if (cred != null) {
195                     if (cred instanceof Credentials) {
196                         credentialsList.addElement((Credentials)cred);
197                     } else {
198                         addConfigEntry((CredentialsCache.ConfigEntry)cred);
199                     }
200                 }
201             }
202         }
203     }
204 
205 
206     /**
207      * Updates the credentials list. If the specified credentials for the
208      * service is new, add it to the list. If there is an entry in the list,
209      * replace the old credentials with the new one.
210      * @param c the credentials.
211      */
212 
213     public synchronized void update(Credentials c) {
214         if (credentialsList != null) {
215             if (credentialsList.isEmpty()) {
216                 credentialsList.addElement(c);
217             } else {
218                 Credentials tmp = null;
219                 boolean matched = false;
220 
221                 for (int i = 0; i &lt; credentialsList.size(); i++) {
222                     tmp = credentialsList.elementAt(i);
223                     if (match(c.sname.getNameStrings(),
224                               tmp.sname.getNameStrings()) &amp;&amp;
225                         ((c.sname.getRealmString()).equalsIgnoreCase(
226                                      tmp.sname.getRealmString()))) {
227                         matched = true;
228                         if (c.endtime.getTime() &gt;= tmp.endtime.getTime()) {
229                             if (DEBUG) {
230                                 System.out.println(&quot; &gt;&gt;&gt; FileCredentialsCache &quot;
231                                          +  &quot;Ticket matched, overwrite &quot;
232                                          +  &quot;the old one.&quot;);
233                             }
234                             credentialsList.removeElementAt(i);
235                             credentialsList.addElement(c);
236                         }
237                     }
238                 }
239                 if (matched == false) {
240                     if (DEBUG) {
241                         System.out.println(&quot; &gt;&gt;&gt; FileCredentialsCache Ticket &quot;
242                                         +   &quot;not exactly matched, &quot;
243                                         +   &quot;add new one into cache.&quot;);
244                     }
245 
246                     credentialsList.addElement(c);
247                 }
248             }
249         }
250     }
251 
252     public synchronized PrincipalName getPrimaryPrincipal() {
253         return primaryPrincipal;
254     }
255 
256 
257     /**
258      * Saves the credentials cache file to the disk.
259      */
260     public synchronized void save() throws IOException, Asn1Exception {
261         try (FileOutputStream fos = new FileOutputStream(cacheName);
262              CCacheOutputStream cos = new CCacheOutputStream(fos)) {
263             cos.writeHeader(primaryPrincipal, version);
264             Credentials[] tmp = null;
265             if ((tmp = getCredsList()) != null) {
266                 for (int i = 0; i &lt; tmp.length; i++) {
267                     cos.addCreds(tmp[i]);
268                 }
269             }
270             for (ConfigEntry e : getConfigEntries()) {
271                 cos.addConfigEntry(primaryPrincipal, e);
272             }
273         }
274     }
275 
276     boolean match(String[] s1, String[] s2) {
277         if (s1.length != s2.length) {
278             return false;
279         } else {
280             for (int i = 0; i &lt; s1.length; i++) {
281                 if (!(s1[i].equalsIgnoreCase(s2[i]))) {
282                     return false;
283                 }
284             }
285         }
286         return true;
287     }
288 
289     /**
290      * Returns the list of credentials entries in the cache file.
291      */
292     public synchronized Credentials[] getCredsList() {
293         if ((credentialsList == null) || (credentialsList.isEmpty())) {
294             return null;
295         } else {
296             Credentials[] tmp = new Credentials[credentialsList.size()];
297             for (int i = 0; i &lt; credentialsList.size(); i++) {
298                 tmp[i] = credentialsList.elementAt(i);
299             }
300             return tmp;
301         }
302 
303     }
304 
305     public Credentials getCreds(LoginOptions options, PrincipalName sname) {
306         if (options == null) {
307             return getCreds(sname);
308         } else {
309             Credentials[] list = getCredsList();
310             if (list == null) {
311                 return null;
312             } else {
313                 for (int i = 0; i &lt; list.length; i++) {
314                     if (sname.match(list[i].sname)) {
315                         if (list[i].flags.match(options)) {
316                             return list[i];
317                         }
318                     }
319                 }
320             }
321             return null;
322         }
323     }
324 
325     private List&lt;ConfigEntry&gt; configEntries = new ArrayList&lt;&gt;();
326 
327     @Override
328     public void addConfigEntry(ConfigEntry e) {
329         configEntries.add(e);
330     }
331 
332     @Override
333     public List&lt;ConfigEntry&gt; getConfigEntries() {
334         return Collections.unmodifiableList(configEntries);
335     }
336 
337     /**
338      * Gets a credentials for a specified service.
339      * @param sname service principal name.
340      */
341     public Credentials getCreds(PrincipalName sname) {
342         Credentials[] list = getCredsList();
343         if (list == null) {
344             return null;
345         } else {
346             for (int i = 0; i &lt; list.length; i++) {
347                 if (sname.match(list[i].sname)) {
348                     return list[i];
349                 }
350             }
351         }
352         return null;
353     }
354 
355     public sun.security.krb5.Credentials getInitialCreds() {
356 
357         Credentials defaultCreds = getDefaultCreds();
358         if (defaultCreds == null) {
359             return null;
360         }
361         sun.security.krb5.Credentials tgt = defaultCreds.setKrbCreds();
362 
363         CredentialsCache.ConfigEntry entry = getConfigEntry(&quot;proxy_impersonator&quot;);
364         if (entry == null) {
365             if (DEBUG) {
366                 System.out.println(&quot;get normal credential&quot;);
367             }
368             return tgt;
369         }
370 
371         boolean force;
372         String prop = SecurityProperties.privilegedGetOverridable(
373                 &quot;jdk.security.krb5.default.initiate.credential&quot;);
374         if (prop == null) {
375             prop = &quot;always-impersonate&quot;;
376         }
377         switch (prop) {
378             case &quot;no-impersonate&quot;: // never try impersonation
379                 if (DEBUG) {
380                     System.out.println(&quot;get normal credential&quot;);
381                 }
382                 return tgt;
383             case &quot;try-impersonate&quot;:
384                 force = false;
385                 break;
386             case &quot;always-impersonate&quot;:
387                 force = true;
388                 break;
389             default:
390                 throw new RuntimeException(
391                         &quot;Invalid jdk.security.krb5.default.initiate.credential&quot;);
392         }
393 
394         try {
395             PrincipalName service = new PrincipalName(
396                     new String(entry.getData(), StandardCharsets.UTF_8));
397             if (!tgt.getClient().equals(service)) {
398                 if (DEBUG) {
399                     System.out.println(&quot;proxy_impersonator does not match service name&quot;);
400                 }
401                 return force ? null : tgt;
402             }
403             PrincipalName client = getPrimaryPrincipal();
404             Credentials proxy = null;
405             for (Credentials c : getCredsList()) {
406                 if (c.getClientPrincipal().equals(client)
407                         &amp;&amp; c.getServicePrincipal().equals(service)) {
408                     proxy = c;
409                     break;
410                 }
411             }
412             if (proxy == null) {
413                 if (DEBUG) {
414                     System.out.println(&quot;Cannot find evidence ticket in ccache&quot;);
415                 }
416                 return force ? null : tgt;
417             }
418             if (DEBUG) {
419                 System.out.println(&quot;Get proxied credential&quot;);
420             }
421             return tgt.setProxy(proxy.setKrbCreds());
422         } catch (KrbException e) {
423             if (DEBUG) {
424                 System.out.println(&quot;Impersonation with ccache failed&quot;);
425             }
426             return force ? null : tgt;
427         }
428     }
429 
430     public Credentials getDefaultCreds() {
431         Credentials[] list = getCredsList();
432         if (list == null) {
433             return null;
434         } else {
435             for (int i = list.length-1; i &gt;= 0; i--) {
436                 if (list[i].sname.toString().startsWith(&quot;krbtgt&quot;)) {
437                     String[] nameStrings = list[i].sname.getNameStrings();
438                     // find the TGT for the current realm krbtgt/realm@realm
439                     if (nameStrings[1].equals(list[i].sname.getRealm().toString())) {
440                        return list[i];
441                     }
442                 }
443             }
444         }
445         return null;
446     }
447 
448     /*
449      * Returns path name of the credentials cache file.
450      * The path name is searched in the following order:
451      *
452      * 1. KRB5CCNAME (bare file name without FILE:)
453      * 2. /tmp/krb5cc_&lt;uid&gt; on unix systems
454      * 3. &lt;user.home&gt;/krb5cc_&lt;user.name&gt;
455      * 4. &lt;user.home&gt;/krb5cc (if can&#39;t get &lt;user.name&gt;)
456      */
457 
458     public static String getDefaultCacheName() {
459 
460         String stdCacheNameComponent = &quot;krb5cc&quot;;
461         String name;
462 
463         // The env var can start with TYPE:, we only support FILE: here.
464         // http://docs.oracle.com/cd/E19082-01/819-2252/6n4i8rtr3/index.html
465         name = java.security.AccessController.doPrivileged(
466                 new java.security.PrivilegedAction&lt;String&gt;() {
467             @Override
468             public String run() {
469                 String cache = System.getenv(&quot;KRB5CCNAME&quot;);
470                 if (cache != null &amp;&amp;
471                         (cache.length() &gt;= 5) &amp;&amp;
472                         cache.regionMatches(true, 0, &quot;FILE:&quot;, 0, 5)) {
473                     cache = cache.substring(5);
474                 }
475                 return cache;
476             }
477         });
478         if (name != null) {
479             if (DEBUG) {
480                 System.out.println(&quot;&gt;&gt;&gt;KinitOptions cache name is &quot; + name);
481             }
482             return name;
483         }
484 
485         // get cache name from system.property
486         String osname = GetPropertyAction.privilegedGetProperty(&quot;os.name&quot;);
487 
488         /*
489          * For Unix platforms we use the default cache name to be
490          * /tmp/krb5cc_uid ; for all other platforms  we use
491          * {user_home}/krb5cc_{user_name}
492          * Please note that for Windows we will use LSA to get
493          * the TGT from the default cache even before we come here;
494          * however when we create cache we will create a cache under
495          * {user_home}/krb5cc_{user_name} for non-Unix platforms including
496          * Windows.
497          */
498 
499         if (osname != null &amp;&amp; !osname.startsWith(&quot;Windows&quot;)) {
500             long uid = jdk.internal.misc.VM.getuid();
501             if (uid != -1) {
502                 name = File.separator + &quot;tmp&quot; +
503                         File.separator + stdCacheNameComponent + &quot;_&quot; + uid;
504                 if (DEBUG) {
505                     System.out.println(&quot;&gt;&gt;&gt;KinitOptions cache name is &quot; +
506                             name);
507                 }
508                 return name;
509             } else {
510                 if (DEBUG) {
511                     System.out.println(&quot;Error in obtaining uid &quot; +
512                                         &quot;for Unix platforms &quot; +
513                                         &quot;Using user&#39;s home directory&quot;);
514                 }
515             }
516         }
517 
518         // we did not get the uid;
519 
520         String user_name = GetPropertyAction.privilegedGetProperty(&quot;user.name&quot;);
521 
522         String user_home = GetPropertyAction.privilegedGetProperty(&quot;user.home&quot;);
523 
524         if (user_home == null) {
525             user_home = GetPropertyAction.privilegedGetProperty(&quot;user.dir&quot;);
526         }
527 
528         if (user_name != null) {
529             name = user_home + File.separator  +
530                 stdCacheNameComponent + &quot;_&quot; + user_name;
531         } else {
532             name = user_home + File.separator + stdCacheNameComponent;
533         }
534 
535         if (DEBUG) {
536             System.out.println(&quot;&gt;&gt;&gt;KinitOptions cache name is &quot; + name);
537         }
538 
539         return name;
540     }
541 
542     public static String checkValidation(String name) {
543         String fullname = null;
544         if (name == null) {
545             return null;
546         }
547         try {
548             // get full path name
549             fullname = (new File(name)).getCanonicalPath();
550             File fCheck = new File(fullname);
551             if (!(fCheck.exists())) {
552                 // get absolute directory
553                 File temp = new File(fCheck.getParent());
554                 // test if the directory exists
555                 if (!(temp.isDirectory()))
556                     fullname = null;
557                 temp = null;
558             }
559             fCheck = null;
560 
561         } catch (IOException e) {
562             fullname = null; // invalid name
563         }
564         return fullname;
565     }
566 
567 
568     private static String exec(String c) {
569         StringTokenizer st = new StringTokenizer(c);
570         Vector&lt;String&gt; v = new Vector&lt;&gt;();
571         while (st.hasMoreTokens()) {
572             v.addElement(st.nextToken());
573         }
574         final String[] command = new String[v.size()];
575         v.copyInto(command);
576         try {
577 
578             Process p =
579                 java.security.AccessController.doPrivileged
580                 (new java.security.PrivilegedAction&lt;Process&gt; () {
581                         public Process run() {
582                             try {
583                                 return (Runtime.getRuntime().exec(command));
584                             } catch (java.io.IOException e) {
585                                 if (DEBUG) {
586                                     e.printStackTrace();
587                                 }
588                                 return null;
589                             }
590                         }
591                     });
592             if (p == null) {
593                 // exception occurred during executing the command
594                 return null;
595             }
596 
597             BufferedReader commandResult =
598                 new BufferedReader
599                     (new InputStreamReader(p.getInputStream(), ISO_8859_1));
600             String s1 = null;
601             if ((command.length == 1) &amp;&amp;
602                 (command[0].equals(&quot;/usr/bin/env&quot;))) {
603                 while ((s1 = commandResult.readLine()) != null) {
604                     if (s1.length() &gt;= 11) {
605                         if ((s1.substring(0, 11)).equalsIgnoreCase
606                             (&quot;KRB5CCNAME=&quot;)) {
607                             s1 = s1.substring(11);
608                             break;
609                         }
610                     }
611                 }
612             } else     s1 = commandResult.readLine();
613             commandResult.close();
614             return s1;
615         } catch (Exception e) {
616             if (DEBUG) {
617                 e.printStackTrace();
618             }
619         }
620         return null;
621     }
622 }
    </pre>
  </body>
</html>
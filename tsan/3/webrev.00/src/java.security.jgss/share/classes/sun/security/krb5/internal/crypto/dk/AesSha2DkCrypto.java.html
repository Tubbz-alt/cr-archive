<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.security.jgss/share/classes/sun/security/krb5/internal/crypto/dk/AesSha2DkCrypto.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  */
 28 
 29 package sun.security.krb5.internal.crypto.dk;
 30 
 31 import javax.crypto.Cipher;
 32 import javax.crypto.Mac;
 33 import javax.crypto.SecretKeyFactory;
 34 import javax.crypto.SecretKey;
 35 import javax.crypto.spec.SecretKeySpec;
 36 import javax.crypto.spec.IvParameterSpec;
 37 import javax.crypto.spec.PBEKeySpec;
 38 import java.security.GeneralSecurityException;
 39 import sun.security.krb5.KrbCryptoException;
 40 import sun.security.krb5.Confounder;
 41 import sun.security.krb5.internal.crypto.KeyUsage;
 42 import java.util.Arrays;
 43 
 44 import static java.nio.charset.StandardCharsets.UTF_8;
 45 
 46 /**
 47  * This class provides the implementation of AES Encryption with
 48  * HMAC-SHA2 for Kerberos 5
 49  * https://tools.ietf.org/html/rfc8009
 50  *
 51  * Algorithm profile described in [KCRYPTO]:
 52  * +--------------------------------------------------------------------+
 53  * |               protocol key format          128- or 256-bit string  |
 54  * |                                                                    |
 55  * |            string-to-key function          PBKDF2+DK with variable |
 56  * |                                          iteration count (see      |
 57  * |                                          above)                    |
 58  * |                                                                    |
 59  * |  default string-to-key parameters          00 00 80 00             |
 60  * |                                                                    |
 61  * |        key-generation seed length          key size                |
 62  * |                                                                    |
 63  * |            random-to-key function          identity function       |
 64  * |                                                                    |
 65  * |                  hash function, H          SHA-256 / SHA-384       |
 66  * |                                                                    |
 67  * |               HMAC output size, h          16/24 octets            |
 68  * |                                                                    |
 69  * |             message block size, m          1 octet                 |
 70  * |                                                                    |
 71  * |  encryption/decryption functions,          AES in CBC-CTS mode     |
 72  * |  E and D                                 (cipher block size 16     |
 73  * |                                          octets), with next to     |
 74  * |                                          last block as CBC-style   |
 75  * |                                          ivec                      |
 76  * +--------------------------------------------------------------------+
 77  *
 78  * Supports aes128-cts-hmac-sha256-128 and aes256-cts-hmac-sha384-192
 79  */
 80 
 81 public class AesSha2DkCrypto extends DkCrypto {
 82 
 83     private static final boolean debug = false;
 84 
 85     private static final int BLOCK_SIZE = 16;
 86     private static final int DEFAULT_ITERATION_COUNT = 32768;
 87     private static final byte[] ZERO_IV = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0,
 88                                                        0, 0, 0, 0, 0, 0, 0, 0 };
 89 
 90     private static final byte[] ETYPE_NAME_128 =
 91             &quot;aes128-cts-hmac-sha256-128&quot;.getBytes();
 92     private static final byte[] ETYPE_NAME_256 =
 93             &quot;aes256-cts-hmac-sha384-192&quot;.getBytes();
 94 
 95     private final int hashSize;
 96     private final int keyLength;
 97 
 98     public AesSha2DkCrypto(int length) {
 99         keyLength = length;
100         hashSize = (length == 128?128:192)/8;
101     }
102 
103     protected int getKeySeedLength() {
104         return keyLength;   // bits; AES key material
105     }
106 
107     public byte[] stringToKey(char[] password, String salt, byte[] s2kparams)
108         throws GeneralSecurityException {
109 
110         byte[] saltUtf8 = null;
111         try {
112             saltUtf8 = salt.getBytes(UTF_8);
113             return stringToKey(password, saltUtf8, s2kparams);
114         } catch (Exception e) {
115             return null;
116         } finally {
117             if (saltUtf8 != null) {
118                 Arrays.fill(saltUtf8, (byte)0);
119             }
120         }
121     }
122 
123     // https://tools.ietf.org/html/rfc8009#section-4
124     private byte[] stringToKey(char[] secret, byte[] salt, byte[] params)
125         throws GeneralSecurityException {
126 
127         int iter_count = DEFAULT_ITERATION_COUNT;
128         if (params != null) {
129             if (params.length != 4) {
130                 throw new RuntimeException(&quot;Invalid parameter to stringToKey&quot;);
131             }
132             iter_count = readBigEndian(params, 0, 4);
133         }
134 
135         byte[] saltp = new byte[26 + 1 + salt.length];
136         if (keyLength == 128) {
137             System.arraycopy(ETYPE_NAME_128, 0, saltp, 0, 26);
138         } else {
139             System.arraycopy(ETYPE_NAME_256, 0, saltp, 0, 26);
140         }
141         System.arraycopy(salt, 0, saltp, 27, salt.length);
142         byte[] tmpKey = randomToKey(PBKDF2(secret, saltp, iter_count,
143                                         getKeySeedLength()));
144         byte[] result = dk(tmpKey, KERBEROS_CONSTANT);
145         return result;
146     }
147 
148     protected byte[] randomToKey(byte[] in) {
149         // simple identity operation
150         return in;
151     }
152 
153     /*
154      * https://tools.ietf.org/html/rfc8009#section-3 defines
155      * a new key derivation function:
156      *
157      * KDF-HMAC-SHA2(key, label, k) = k-truncate(K1)
158      * K1 = HMAC-SHA-256(key, 0x00000001 | label | 0x00 | k) or
159      * K1 = HMAC-SHA-384(key, 0x00000001 | label | 0x00 | k)
160      *
161      * where label is constant below.
162      */
163     protected byte[] dr(byte[] key, byte[] constant)
164             throws GeneralSecurityException {
165         byte[] result;
166         byte[] input = new byte[constant.length + 9];
167         // 0x00000001 at the beginning
168         input[3] = 1;
169         // label follows
170         System.arraycopy(constant, 0, input, 4, constant.length);
171         SecretKeySpec tkey = new SecretKeySpec(key, &quot;HMAC&quot;);
172         Mac mac = Mac.getInstance(
173                 keyLength == 128? &quot;HmacSHA256&quot;: &quot;HmacSHA384&quot;);
174         mac.init(tkey);
175 
176         int k;
177         if (keyLength == 128) {
178             // key length for enc and hmac both 128
179             k = 128;
180         } else {
181             byte last = constant[constant.length-1];
182             if (last == (byte)0x99 || last == (byte)0x55) {
183                 // 192 for hmac
184                 k = 192;
185             } else {
186                 // 256 for enc
187                 k = 256;
188             }
189         }
190         // 0x00 and k at the end
191         input[input.length - 1] = (byte)(k);
192         input[input.length - 2] = (byte)(k / 256);
193 
194         result = mac.doFinal(input);
195         return Arrays.copyOf(result, k / 8);
196     }
197 
198     protected Cipher getCipher(byte[] key, byte[] ivec, int mode)
199         throws GeneralSecurityException {
200 
201         // IV
202         if (ivec == null) {
203            ivec = ZERO_IV;
204         }
205         SecretKeySpec secretKey = new SecretKeySpec(key, &quot;AES&quot;);
206         Cipher cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);
207         IvParameterSpec encIv = new IvParameterSpec(ivec, 0, ivec.length);
208         cipher.init(mode, secretKey, encIv);
209         return cipher;
210     }
211 
212     // get an instance of the AES Cipher in CTS mode
213     public int getChecksumLength() {
214         return hashSize;  // bytes
215     }
216 
217     /**
218      * Get the truncated HMAC
219      */
220     protected byte[] getHmac(byte[] key, byte[] msg)
221         throws GeneralSecurityException {
222 
223         SecretKey keyKi = new SecretKeySpec(key, &quot;HMAC&quot;);
224         Mac m = Mac.getInstance(keyLength == 128 ? &quot;HmacSHA256&quot; : &quot;HmacSHA384&quot;);
225         m.init(keyKi);
226 
227         // generate hash
228         byte[] hash = m.doFinal(msg);
229 
230         // truncate hash
231         byte[] output = new byte[hashSize];
232         System.arraycopy(hash, 0, output, 0, hashSize);
233         return output;
234     }
235 
236     private byte[] deriveKey(byte[] baseKey, int usage, byte type)
237             throws GeneralSecurityException {
238         byte[] constant = new byte[5];
239         constant[0] = (byte) ((usage&gt;&gt;24)&amp;0xff);
240         constant[1] = (byte) ((usage&gt;&gt;16)&amp;0xff);
241         constant[2] = (byte) ((usage&gt;&gt;8)&amp;0xff);
242         constant[3] = (byte) (usage&amp;0xff);
243         constant[4] = type;
244         return dk(baseKey, constant);
245     }
246 
247     /**
248      * Calculate the checksum
249      */
250     public byte[] calculateChecksum(byte[] baseKey, int usage, byte[] input,
251         int start, int len) throws GeneralSecurityException {
252 
253         if (!KeyUsage.isValid(usage)) {
254             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
255                                                 + usage);
256         }
257 
258         byte[] Kc = deriveKey(baseKey, usage, (byte) 0x99);  // Checksum key
259         if (debug) {
260             System.err.println(&quot;usage: &quot; + usage);
261             traceOutput(&quot;input&quot;, input, start, Math.min(len, 32));
262             traceOutput(&quot;baseKey&quot;, baseKey, 0, baseKey.length);
263             traceOutput(&quot;Kc&quot;, Kc, 0, Kc.length);
264         }
265 
266         try {
267             // Generate checksum
268             // H1 = HMAC(Kc, input)
269             byte[] hmac = getHmac(Kc, input);
270             if (debug) {
271                 traceOutput(&quot;hmac&quot;, hmac, 0, hmac.length);
272             }
273             if (hmac.length == getChecksumLength()) {
274                 return hmac;
275             } else if (hmac.length &gt; getChecksumLength()) {
276                 byte[] buf = new byte[getChecksumLength()];
277                 System.arraycopy(hmac, 0, buf, 0, buf.length);
278                 return buf;
279             } else {
280                 throw new GeneralSecurityException(&quot;checksum size too short: &quot; +
281                         hmac.length + &quot;; expecting : &quot; + getChecksumLength());
282             }
283         } finally {
284             Arrays.fill(Kc, 0, Kc.length, (byte)0);
285         }
286     }
287 
288     /**
289      * Performs encryption using derived key; adds confounder.
290      */
291     public byte[] encrypt(byte[] baseKey, int usage,
292         byte[] ivec, byte[] new_ivec, byte[] plaintext, int start, int len)
293         throws GeneralSecurityException, KrbCryptoException {
294 
295         if (!KeyUsage.isValid(usage)) {
296             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
297                                                  + usage);
298         }
299         byte[] output = encryptCTS(baseKey, usage, ivec, new_ivec, plaintext,
300                                         start, len, true);
301         return output;
302     }
303 
304     /**
305      * Performs encryption using derived key; does not add confounder.
306      */
307     public byte[] encryptRaw(byte[] baseKey, int usage,
308         byte[] ivec, byte[] plaintext, int start, int len)
309         throws GeneralSecurityException, KrbCryptoException {
310 
311         if (!KeyUsage.isValid(usage)) {
312             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
313                                                 + usage);
314         }
315         byte[] output = encryptCTS(baseKey, usage, ivec, null, plaintext,
316                                         start, len, false);
317         return output;
318     }
319 
320     /**
321      * @param baseKey key from which keys are to be derived using usage
322      * @param ciphertext  E(Ke, conf | plaintext | padding, ivec) | H1[1..h]
323      */
324     public byte[] decrypt(byte[] baseKey, int usage, byte[] ivec,
325         byte[] ciphertext, int start, int len) throws GeneralSecurityException {
326 
327         if (!KeyUsage.isValid(usage)) {
328             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
329                                                 + usage);
330         }
331         byte[] output = decryptCTS(baseKey, usage, ivec, ciphertext,
332                                         start, len, true);
333         return output;
334     }
335 
336     /**
337      * Decrypts data using specified key and initial vector.
338      * @param baseKey encryption key to use
339      * @param ciphertext  encrypted data to be decrypted
340      * @param usage ignored
341      */
342     public byte[] decryptRaw(byte[] baseKey, int usage, byte[] ivec,
343         byte[] ciphertext, int start, int len)
344         throws GeneralSecurityException {
345 
346         if (!KeyUsage.isValid(usage)) {
347             throw new GeneralSecurityException(&quot;Invalid key usage number: &quot;
348                                                 + usage);
349         }
350         byte[] output = decryptCTS(baseKey, usage, ivec, ciphertext,
351                                         start, len, false);
352         return output;
353     }
354 
355     /**
356      * Encrypt AES in CBC-CTS mode using derived keys.
357      */
358     private byte[] encryptCTS(byte[] baseKey, int usage, byte[] ivec,
359         byte[] new_ivec, byte[] plaintext, int start, int len,
360         boolean confounder_exists)
361         throws GeneralSecurityException, KrbCryptoException {
362 
363         byte[] Ke = null;
364         byte[] Ki = null;
365 
366         if (debug) {
367             System.err.println(&quot;usage: &quot; + usage);
368             if (ivec != null) {
369                 traceOutput(&quot;old_state.ivec&quot;, ivec, 0, ivec.length);
370             }
371             traceOutput(&quot;plaintext&quot;, plaintext, start, Math.min(len, 32));
372             traceOutput(&quot;baseKey&quot;, baseKey, 0, baseKey.length);
373         }
374 
375         try {
376             Ke = deriveKey(baseKey, usage, (byte) 0xaa);  // Encryption key
377 
378             byte[] toBeEncrypted = null;
379             if (confounder_exists) {
380                 byte[] confounder = Confounder.bytes(BLOCK_SIZE);
381                 toBeEncrypted = new byte[confounder.length + len];
382                 System.arraycopy(confounder, 0, toBeEncrypted,
383                                         0, confounder.length);
384                 System.arraycopy(plaintext, start, toBeEncrypted,
385                                         confounder.length, len);
386             } else {
387                 toBeEncrypted = new byte[len];
388                 System.arraycopy(plaintext, start, toBeEncrypted, 0, len);
389             }
390 
391             // encryptedData + HMAC
392             byte[] output = new byte[toBeEncrypted.length + hashSize];
393 
394             // AES in JCE
395             Cipher cipher = Cipher.getInstance(&quot;AES/CTS/NoPadding&quot;);
396             SecretKeySpec secretKey = new SecretKeySpec(Ke, &quot;AES&quot;);
397             IvParameterSpec encIv = new IvParameterSpec(ivec, 0, ivec.length);
398             cipher.init(Cipher.ENCRYPT_MODE, secretKey, encIv);
399             cipher.doFinal(toBeEncrypted, 0, toBeEncrypted.length, output);
400 
401             Ki = deriveKey(baseKey, usage, (byte) 0x55);
402             if (debug) {
403                 traceOutput(&quot;Ki&quot;, Ki, 0, Ke.length);
404             }
405 
406             // Generate checksum
407             // H = HMAC(Ki, IV | C)
408             byte[] msg = Arrays.copyOf(ivec, ivec.length + toBeEncrypted.length);
409             System.arraycopy(output, 0, msg, ivec.length, toBeEncrypted.length);
410             byte[] hmac = getHmac(Ki, msg);
411 
412             // encryptedData + HMAC
413             System.arraycopy(hmac, 0, output, toBeEncrypted.length,
414                                 hmac.length);
415             return output;
416         } finally {
417             if (Ke != null) {
418                 Arrays.fill(Ke, 0, Ke.length, (byte) 0);
419             }
420             if (Ki != null) {
421                 Arrays.fill(Ki, 0, Ki.length, (byte) 0);
422             }
423         }
424     }
425 
426     /**
427      * Decrypt AES in CBC-CTS mode using derived keys.
428      */
429     private byte[] decryptCTS(byte[] baseKey, int usage, byte[] ivec,
430         byte[] ciphertext, int start, int len, boolean confounder_exists)
431         throws GeneralSecurityException {
432 
433         byte[] Ke = null;
434         byte[] Ki = null;
435 
436         try {
437             Ke = deriveKey(baseKey, usage, (byte) 0xaa);  // Encryption key
438 
439             if (debug) {
440                 System.err.println(&quot;usage: &quot; + usage);
441                 if (ivec != null) {
442                     traceOutput(&quot;old_state.ivec&quot;, ivec, 0, ivec.length);
443                 }
444                 traceOutput(&quot;ciphertext&quot;, ciphertext, start, Math.min(len, 32));
445                 traceOutput(&quot;baseKey&quot;, baseKey, 0, baseKey.length);
446                 traceOutput(&quot;Ke&quot;, Ke, 0, Ke.length);
447             }
448 
449             // Decrypt [confounder | plaintext ] (without checksum)
450 
451             // AES in JCE
452             Cipher cipher = Cipher.getInstance(&quot;AES/CTS/NoPadding&quot;);
453             SecretKeySpec secretKey = new SecretKeySpec(Ke, &quot;AES&quot;);
454             IvParameterSpec encIv = new IvParameterSpec(ivec, 0, ivec.length);
455             cipher.init(Cipher.DECRYPT_MODE, secretKey, encIv);
456             byte[] plaintext = cipher.doFinal(ciphertext, start, len-hashSize);
457 
458             if (debug) {
459                 traceOutput(&quot;AES PlainText&quot;, plaintext, 0,
460                                 Math.min(plaintext.length, 32));
461             }
462 
463             Ki = deriveKey(baseKey, usage, (byte) 0x55);  // Integrity key
464             if (debug) {
465                 traceOutput(&quot;Ki&quot;, Ki, 0, Ke.length);
466             }
467 
468             // Verify checksum
469             // H = HMAC(Ki, IV | C)
470             byte[] msg = Arrays.copyOf(ivec, ivec.length + len-hashSize);
471             System.arraycopy(ciphertext, start, msg, ivec.length, len-hashSize);
472             byte[] calculatedHmac = getHmac(Ki, msg);
473             int hmacOffset = start + len - hashSize;
474             if (debug) {
475                 traceOutput(&quot;calculated Hmac&quot;, calculatedHmac,
476                                 0, calculatedHmac.length);
477                 traceOutput(&quot;message Hmac&quot;, ciphertext, hmacOffset, hashSize);
478             }
479             boolean cksumFailed = false;
480             if (calculatedHmac.length &gt;= hashSize) {
481                 for (int i = 0; i &lt; hashSize; i++) {
482                     if (calculatedHmac[i] != ciphertext[hmacOffset+i]) {
483                         cksumFailed = true;
484                         if (debug) {
485                             System.err.println(&quot;Checksum failed !&quot;);
486                         }
487                         break;
488                     }
489                 }
490             }
491             if (cksumFailed) {
492                 throw new GeneralSecurityException(&quot;Checksum failed&quot;);
493             }
494 
495             if (confounder_exists) {
496                 // Get rid of confounder
497                 // [ confounder | plaintext ]
498                 byte[] output = new byte[plaintext.length - BLOCK_SIZE];
499                 System.arraycopy(plaintext, BLOCK_SIZE, output,
500                                         0, output.length);
501                 return output;
502             } else {
503                 return plaintext;
504             }
505         } finally {
506             if (Ke != null) {
507                 Arrays.fill(Ke, 0, Ke.length, (byte) 0);
508             }
509             if (Ki != null) {
510                 Arrays.fill(Ki, 0, Ki.length, (byte) 0);
511             }
512         }
513     }
514 
515     /*
516      * Invoke the PKCS#5 PBKDF2 algorithm
517      */
518     private static byte[] PBKDF2(char[] secret, byte[] salt,
519         int count, int keyLength) throws GeneralSecurityException {
520 
521         PBEKeySpec keySpec = new PBEKeySpec(secret, salt, count, keyLength);
522         SecretKeyFactory skf =
523                 SecretKeyFactory.getInstance(keyLength == 128 ?
524                         &quot;PBKDF2WithHmacSHA256&quot; : &quot;PBKDF2WithHmacSHA384&quot;);
525         SecretKey key = skf.generateSecret(keySpec);
526         byte[] result = key.getEncoded();
527 
528         return result;
529     }
530 
531     public static final int readBigEndian(byte[] data, int pos, int size) {
532         int retVal = 0;
533         int shifter = (size-1)*8;
534         while (size &gt; 0) {
535             retVal += (data[pos] &amp; 0xff) &lt;&lt; shifter;
536             shifter -= 8;
537             pos++;
538             size--;
539         }
540         return retVal;
541     }
542 
543 }
    </pre>
  </body>
</html>
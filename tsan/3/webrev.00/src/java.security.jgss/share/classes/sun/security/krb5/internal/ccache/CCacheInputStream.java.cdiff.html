<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.security.jgss/share/classes/sun/security/krb5/internal/ccache/CCacheInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../TicketFlags.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CCacheOutputStream.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.security.jgss/share/classes/sun/security/krb5/internal/ccache/CCacheInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 126,11 ***</span>
           */
          if (version == KRB5_FCC_FVNO_1)
              length--;
          for (int i = 0; i &lt;= length; i++) {
              namelength = readLength4();
<span class="line-modified">!             byte[] bytes = IOUtils.readFully(this, namelength, true);</span>
              result.add(new String(bytes));
          }
          if (result.isEmpty()) {
              throw new IOException(&quot;No realm or principal&quot;);
          }
<span class="line-new-header">--- 126,11 ---</span>
           */
          if (version == KRB5_FCC_FVNO_1)
              length--;
          for (int i = 0; i &lt;= length; i++) {
              namelength = readLength4();
<span class="line-modified">!             byte[] bytes = IOUtils.readExactlyNBytes(this, namelength);</span>
              result.add(new String(bytes));
          }
          if (result.isEmpty()) {
              throw new IOException(&quot;No realm or principal&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,11 ***</span>
          int keyType, keyLen;
          keyType = read(2);
          if (version == KRB5_FCC_FVNO_3)
              read(2); /* keytype recorded twice in fvno 3 */
          keyLen = readLength4();
<span class="line-modified">!         byte[] bytes = IOUtils.readFully(this, keyLen, true);</span>
          return new EncryptionKey(bytes, keyType, version);
      }
  
      long[] readTimes() throws IOException {
          long[] times = new long[4];
<span class="line-new-header">--- 184,11 ---</span>
          int keyType, keyLen;
          keyType = read(2);
          if (version == KRB5_FCC_FVNO_3)
              read(2); /* keytype recorded twice in fvno 3 */
          keyLen = readLength4();
<span class="line-modified">!         byte[] bytes = IOUtils.readExactlyNBytes(this, keyLen);</span>
          return new EncryptionKey(bytes, keyType, version);
      }
  
      long[] readTimes() throws IOException {
          long[] times = new long[4];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,11 ***</span>
              List&lt;AuthorizationDataEntry&gt; auData = new ArrayList&lt;&gt;();
              byte[] data = null;
              for (int i = 0; i &lt; num; i++) {
                  adtype = read(2);
                  adlength = readLength4();
<span class="line-modified">!                 data = IOUtils.readFully(this, adlength, true);</span>
                  auData.add(new AuthorizationDataEntry(adtype, data));
              }
              return auData.toArray(new AuthorizationDataEntry[auData.size()]);
          }
          else return null;
<span class="line-new-header">--- 237,11 ---</span>
              List&lt;AuthorizationDataEntry&gt; auData = new ArrayList&lt;&gt;();
              byte[] data = null;
              for (int i = 0; i &lt; num; i++) {
                  adtype = read(2);
                  adlength = readLength4();
<span class="line-modified">!                 data = IOUtils.readExactlyNBytes(this, adlength);</span>
                  auData.add(new AuthorizationDataEntry(adtype, data));
              }
              return auData.toArray(new AuthorizationDataEntry[auData.size()]);
          }
          else return null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 251,11 ***</span>
          int length;
          length = readLength4();
          if (length == 0) {
              return null;
          } else {
<span class="line-modified">!             return IOUtils.readFully(this, length, true);</span>
          }
      }
  
      boolean[] readFlags() throws IOException {
          boolean[] flags = new boolean[Krb5.TKT_OPTS_MAX+1];
<span class="line-new-header">--- 251,11 ---</span>
          int length;
          length = readLength4();
          if (length == 0) {
              return null;
          } else {
<span class="line-modified">!             return IOUtils.readExactlyNBytes(this, length);</span>
          }
      }
  
      boolean[] readFlags() throws IOException {
          boolean[] flags = new boolean[Krb5.TKT_OPTS_MAX+1];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 323,20 ***</span>
          }
          return flags;
      }
  
      /**
<span class="line-modified">!      * Reads the next cred in stream.</span>
<span class="line-modified">!      * @return the next cred, null if ticket or second_ticket unparseable.</span>
       *
<span class="line-modified">!      * Note: MIT krb5 1.8.1 might generate a config entry with server principal</span>
<span class="line-modified">!      * X-CACHECONF:/krb5_ccache_conf_data/fast_avail/krbtgt/REALM@REALM. The</span>
<span class="line-removed">-      * entry is used by KDC to inform the client that it support certain</span>
<span class="line-removed">-      * features. Its ticket is not a valid krb5 ticket and thus this method</span>
<span class="line-removed">-      * returns null.</span>
       */
<span class="line-modified">!     Credentials readCred(int version) throws IOException,RealmException, KrbApErrException, Asn1Exception {</span>
          PrincipalName cpname = null;
          try {
              cpname = readPrincipal(version);
          } catch (Exception e) {
              // Do not return here. All data for this cred should be fully
<span class="line-new-header">--- 323,17 ---</span>
          }
          return flags;
      }
  
      /**
<span class="line-modified">!      * Reads the next cred or config entry in stream.</span>
<span class="line-modified">!      * @return the next cred or config entry, null if data unparseable.</span>
       *
<span class="line-modified">!      * When data is unparseable, this method makes sure the correct number of</span>
<span class="line-modified">!      * bytes are consumed so it&#39;s safe to start reading the next element.</span>
       */
<span class="line-modified">!     Object readCred(int version) throws IOException,RealmException, KrbApErrException, Asn1Exception {</span>
          PrincipalName cpname = null;
          try {
              cpname = readPrincipal(version);
          } catch (Exception e) {
              // Do not return here. All data for this cred should be fully
</pre>
<hr />
<pre>
<span class="line-old-header">*** 394,15 ***</span>
          if (cpname == null || spname == null) {
              return null;
          }
  
          try {
              return new Credentials(cpname, spname, key, authtime, starttime,
<span class="line-modified">!                 endtime, renewTill, skey, tFlags,</span>
<span class="line-modified">!                 addrs, auData,</span>
<span class="line-modified">!                 ticketData != null ? new Ticket(ticketData) : null,</span>
<span class="line-modified">!                 ticketData2 != null ? new Ticket(ticketData2) : null);</span>
          } catch (Exception e) {     // If any of new Ticket(*) fails.
              return null;
          }
      }
  }
<span class="line-new-header">--- 391,26 ---</span>
          if (cpname == null || spname == null) {
              return null;
          }
  
          try {
<span class="line-added">+             if (spname.getRealmString().equals(&quot;X-CACHECONF:&quot;)) {</span>
<span class="line-added">+                 String[] nameParts = spname.getNameStrings();</span>
<span class="line-added">+                 if (nameParts[0].equals(&quot;krb5_ccache_conf_data&quot;)) {</span>
<span class="line-added">+                     return new CredentialsCache.ConfigEntry(nameParts[1],</span>
<span class="line-added">+                             nameParts.length &gt; 2 ? new PrincipalName(nameParts[2]) : null,</span>
<span class="line-added">+                             ticketData);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
              return new Credentials(cpname, spname, key, authtime, starttime,
<span class="line-modified">!                     endtime, renewTill, skey, tFlags,</span>
<span class="line-modified">!                     addrs, auData,</span>
<span class="line-modified">!                     ticketData != null ? new Ticket(ticketData) : null,</span>
<span class="line-modified">!                     ticketData2 != null ? new Ticket(ticketData2) : null);</span>
          } catch (Exception e) {     // If any of new Ticket(*) fails.
<span class="line-added">+             if (DEBUG) {</span>
<span class="line-added">+                 e.printStackTrace(System.out);</span>
<span class="line-added">+             }</span>
              return null;
          }
      }
  }
</pre>
<center><a href="../TicketFlags.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CCacheOutputStream.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
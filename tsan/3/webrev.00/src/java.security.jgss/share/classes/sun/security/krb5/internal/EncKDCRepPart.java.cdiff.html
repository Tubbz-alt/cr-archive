<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.security.jgss/share/classes/sun/security/krb5/internal/EncKDCRepPart.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EncASRepPart.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EncTGSRepPart.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.security.jgss/share/classes/sun/security/krb5/internal/EncKDCRepPart.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,33 ***</span>
   */
  
  package sun.security.krb5.internal;
  
  import sun.security.krb5.*;
<span class="line-removed">- import sun.security.krb5.EncryptionKey;</span>
  import sun.security.util.*;
  import java.util.Vector;
  import java.io.IOException;
  import java.math.BigInteger;
  
  /**
   * Implements the ASN.1 EncKDCRepPart type.
   *
   * &lt;pre&gt;{@code
<span class="line-modified">!  * EncKDCRepPart        ::= SEQUENCE {</span>
<span class="line-modified">!  *      key             [0] EncryptionKey,</span>
<span class="line-modified">!  *      last-req        [1] LastReq,</span>
<span class="line-modified">!  *      nonce           [2] UInt32,</span>
<span class="line-modified">!  *      key-expiration  [3] KerberosTime OPTIONAL,</span>
<span class="line-modified">!  *      flags           [4] TicketFlags,</span>
<span class="line-modified">!  *      authtime        [5] KerberosTime,</span>
<span class="line-modified">!  *      starttime       [6] KerberosTime OPTIONAL,</span>
<span class="line-modified">!  *      endtime         [7] KerberosTime,</span>
<span class="line-modified">!  *      renew-till      [8] KerberosTime OPTIONAL,</span>
<span class="line-modified">!  *      srealm          [9] Realm,</span>
<span class="line-modified">!  *      sname           [10] PrincipalName,</span>
<span class="line-modified">!  *      caddr           [11] HostAddresses OPTIONAL</span>
   * }
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;
   * This definition reflects the Network Working Group RFC 4120
<span class="line-new-header">--- 29,33 ---</span>
   */
  
  package sun.security.krb5.internal;
  
  import sun.security.krb5.*;
  import sun.security.util.*;
  import java.util.Vector;
  import java.io.IOException;
  import java.math.BigInteger;
  
  /**
   * Implements the ASN.1 EncKDCRepPart type.
   *
   * &lt;pre&gt;{@code
<span class="line-modified">!  * EncKDCRepPart          ::= SEQUENCE {</span>
<span class="line-modified">!  *      key               [0] EncryptionKey,</span>
<span class="line-modified">!  *      last-req          [1] LastReq,</span>
<span class="line-modified">!  *      nonce             [2] UInt32,</span>
<span class="line-modified">!  *      key-expiration    [3] KerberosTime OPTIONAL,</span>
<span class="line-modified">!  *      flags             [4] TicketFlags,</span>
<span class="line-modified">!  *      authtime          [5] KerberosTime,</span>
<span class="line-modified">!  *      starttime         [6] KerberosTime OPTIONAL,</span>
<span class="line-modified">!  *      endtime           [7] KerberosTime,</span>
<span class="line-modified">!  *      renew-till        [8] KerberosTime OPTIONAL,</span>
<span class="line-modified">!  *      srealm            [9] Realm,</span>
<span class="line-modified">!  *      sname             [10] PrincipalName,</span>
<span class="line-modified">!  *      caddr             [11] HostAddresses OPTIONAL,</span>
<span class="line-added">+  *      encrypted-pa-data [12] SEQUENCE OF PA-DATA OPTIONAL</span>
   * }
   * }&lt;/pre&gt;
   *
   * &lt;p&gt;
   * This definition reflects the Network Working Group RFC 4120
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,10 ***</span>
<span class="line-new-header">--- 74,11 ---</span>
      public KerberosTime starttime; //optional
      public KerberosTime endtime;
      public KerberosTime renewTill; //optional
      public PrincipalName sname;
      public HostAddresses caddr; //optional
<span class="line-added">+     public PAData[] pAData; //optional</span>
      public int msgType; //not included in sequence
  
      public EncKDCRepPart(
              EncryptionKey new_key,
              LastReq new_lastReq,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,10 ***</span>
<span class="line-new-header">--- 89,11 ---</span>
              KerberosTime new_starttime,
              KerberosTime new_endtime,
              KerberosTime new_renewTill,
              PrincipalName new_sname,
              HostAddresses new_caddr,
<span class="line-added">+             PAData[] new_pAData,</span>
              int new_msgType) {
          key = new_key;
          lastReq = new_lastReq;
          nonce = new_nonce;
          keyExpiration = new_keyExpiration;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,10 ***</span>
<span class="line-new-header">--- 102,11 ---</span>
          starttime = new_starttime;
          endtime = new_endtime;
          renewTill = new_renewTill;
          sname = new_sname;
          caddr = new_caddr;
<span class="line-added">+         pAData = new_pAData;</span>
          msgType = new_msgType;
      }
  
      public EncKDCRepPart() {
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,10 ***</span>
<span class="line-new-header">--- 161,13 ---</span>
          Realm srealm = Realm.parse(der.getData(), (byte) 0x09, false);
          sname = PrincipalName.parse(der.getData(), (byte) 0x0A, false, srealm);
          if (der.getData().available() &gt; 0) {
              caddr = HostAddresses.parse(der.getData(), (byte) 0x0B, true);
          }
<span class="line-added">+         if (der.getData().available() &gt; 0) {</span>
<span class="line-added">+             pAData = PAData.parseSequence(der.getData(), (byte) 0x0C, true);</span>
<span class="line-added">+         }</span>
          // We observe extra data from MSAD
          /*if (der.getData().available() &gt; 0) {
              throw new Asn1Exception(Krb5.ASN1_BAD_ID);
          }*/
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,51 ***</span>
       * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
       * @exception IOException if an I/O error occurs while reading encoded data.
       */
      public byte[] asn1Encode(int rep_type) throws Asn1Exception,
              IOException {
          DerOutputStream temp = new DerOutputStream();
<span class="line-modified">!         DerOutputStream bytes = new DerOutputStream();</span>
<span class="line-modified">!         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x00), key.asn1Encode());
<span class="line-modified">!         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x01), lastReq.asn1Encode());
          temp.putInteger(BigInteger.valueOf(nonce));
<span class="line-modified">!         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x02), temp);
  
          if (keyExpiration != null) {
<span class="line-modified">!             bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                      true, (byte) 0x03), keyExpiration.asn1Encode());
          }
<span class="line-modified">!         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x04), flags.asn1Encode());
<span class="line-modified">!         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x05), authtime.asn1Encode());
          if (starttime != null) {
<span class="line-modified">!             bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                      true, (byte) 0x06), starttime.asn1Encode());
          }
<span class="line-modified">!         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x07), endtime.asn1Encode());
          if (renewTill != null) {
<span class="line-modified">!             bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                      true, (byte) 0x08), renewTill.asn1Encode());
          }
<span class="line-modified">!         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x09), sname.getRealm().asn1Encode());
<span class="line-modified">!         bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x0A), sname.asn1Encode());
          if (caddr != null) {
<span class="line-modified">!             bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                      true, (byte) 0x0B), caddr.asn1Encode());
          }
          //should use the rep_type to build the encoding
          //but other implementations do not; it is ignored and
          //the cached msgType is used instead
          temp = new DerOutputStream();
<span class="line-modified">!         temp.write(DerValue.tag_Sequence, bytes);</span>
          bytes = new DerOutputStream();
          bytes.write(DerValue.createTag(DerValue.TAG_APPLICATION,
                  true, (byte) msgType), temp);
          return bytes.toByteArray();
      }
<span class="line-new-header">--- 179,62 ---</span>
       * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
       * @exception IOException if an I/O error occurs while reading encoded data.
       */
      public byte[] asn1Encode(int rep_type) throws Asn1Exception,
              IOException {
<span class="line-added">+         DerOutputStream bytes;</span>
          DerOutputStream temp = new DerOutputStream();
<span class="line-modified">!         DerOutputStream out = new DerOutputStream();</span>
<span class="line-modified">!         out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x00), key.asn1Encode());
<span class="line-modified">!         out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x01), lastReq.asn1Encode());
          temp.putInteger(BigInteger.valueOf(nonce));
<span class="line-modified">!         out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x02), temp);
  
          if (keyExpiration != null) {
<span class="line-modified">!             out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                      true, (byte) 0x03), keyExpiration.asn1Encode());
          }
<span class="line-modified">!         out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x04), flags.asn1Encode());
<span class="line-modified">!         out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x05), authtime.asn1Encode());
          if (starttime != null) {
<span class="line-modified">!             out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                      true, (byte) 0x06), starttime.asn1Encode());
          }
<span class="line-modified">!         out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x07), endtime.asn1Encode());
          if (renewTill != null) {
<span class="line-modified">!             out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                      true, (byte) 0x08), renewTill.asn1Encode());
          }
<span class="line-modified">!         out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x09), sname.getRealm().asn1Encode());
<span class="line-modified">!         out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                  true, (byte) 0x0A), sname.asn1Encode());
          if (caddr != null) {
<span class="line-modified">!             out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                      true, (byte) 0x0B), caddr.asn1Encode());
          }
<span class="line-added">+         if (pAData != null &amp;&amp; pAData.length &gt; 0) {</span>
<span class="line-added">+             temp = new DerOutputStream();</span>
<span class="line-added">+             for (int i = 0; i &lt; pAData.length; i++) {</span>
<span class="line-added">+                 temp.write(pAData[i].asn1Encode());</span>
<span class="line-added">+             }</span>
<span class="line-added">+             bytes = new DerOutputStream();</span>
<span class="line-added">+             bytes.write(DerValue.tag_SequenceOf, temp);</span>
<span class="line-added">+             out.write(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
<span class="line-added">+                     true, (byte) 0x0C), bytes);</span>
<span class="line-added">+         }</span>
          //should use the rep_type to build the encoding
          //but other implementations do not; it is ignored and
          //the cached msgType is used instead
          temp = new DerOutputStream();
<span class="line-modified">!         temp.write(DerValue.tag_Sequence, out);</span>
          bytes = new DerOutputStream();
          bytes.write(DerValue.createTag(DerValue.TAG_APPLICATION,
                  true, (byte) msgType), temp);
          return bytes.toByteArray();
      }
</pre>
<center><a href="EncASRepPart.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EncTGSRepPart.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
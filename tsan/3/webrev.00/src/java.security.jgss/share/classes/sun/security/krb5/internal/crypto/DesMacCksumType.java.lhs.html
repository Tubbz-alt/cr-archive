<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.security.jgss/share/classes/sun/security/krb5/internal/crypto/DesMacCksumType.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 27  *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 28  */
 29 
 30 package sun.security.krb5.internal.crypto;
 31 
 32 import sun.security.krb5.Checksum;
 33 import sun.security.krb5.Confounder;
 34 import sun.security.krb5.KrbCryptoException;
 35 import sun.security.krb5.internal.*;
 36 import javax.crypto.spec.DESKeySpec;
 37 import java.security.InvalidKeyException;
 38 
 39 public class DesMacCksumType extends CksumType {
 40 
 41     public DesMacCksumType() {
 42     }
 43 
 44     public int confounderSize() {
 45         return 8;
 46     }
 47 
 48     public int cksumType() {
 49         return Checksum.CKSUMTYPE_DES_MAC;
 50     }
 51 
<a name="1" id="anc1"></a><span class="line-modified"> 52     public boolean isSafe() {</span>
 53         return true;
 54     }
 55 
 56     public int cksumSize() {
 57         return 16;
 58     }
 59 
 60     public int keyType() {
 61         return Krb5.KEYTYPE_DES;
 62     }
 63 
 64     public int keySize() {
 65         return 8;
 66     }
 67 
<a name="2" id="anc2"></a><span class="line-removed"> 68     public byte[] calculateChecksum(byte[] data, int size) {</span>
<span class="line-removed"> 69         return null;</span>
<span class="line-removed"> 70     }</span>
<span class="line-removed"> 71 </span>
 72     /**
 73      * Calculates keyed checksum.
 74      * @param data the data used to generate the checksum.
 75      * @param size length of the data.
 76      * @param key the key used to encrypt the checksum.
 77      * @return keyed checksum.
 78      *
 79      * @modified by Yanni Zhang, 12/08/99.
 80      */
<a name="3" id="anc3"></a><span class="line-modified"> 81     public byte[] calculateKeyedChecksum(byte[] data, int size, byte[] key,</span>
 82         int usage) throws KrbCryptoException {
 83         byte[] new_data = new byte[size + confounderSize()];
 84         byte[] conf = Confounder.bytes(confounderSize());
 85         System.arraycopy(conf, 0, new_data, 0, confounderSize());
 86         System.arraycopy(data, 0, new_data, confounderSize(), size);
 87 
 88         //check for weak keys
 89         try {
 90             if (DESKeySpec.isWeak(key, 0)) {
 91                 key[7] = (byte)(key[7] ^ 0xF0);
 92             }
 93         } catch (InvalidKeyException ex) {
 94             // swallow, since it should never happen
 95         }
 96         byte[] residue_ivec = new byte[key.length];
 97         byte[] residue = Des.des_cksum(residue_ivec, new_data, key);
 98         byte[] cksum = new byte[cksumSize()];
 99         System.arraycopy(conf, 0, cksum, 0, confounderSize());
100         System.arraycopy(residue, 0, cksum, confounderSize(),
101                          cksumSize() - confounderSize());
102 
103         byte[] new_key = new byte[keySize()];
104         System.arraycopy(key, 0, new_key, 0, key.length);
105         for (int i = 0; i &lt; new_key.length; i++)
106         new_key[i] = (byte)(new_key[i] ^ 0xf0);
107         //check for weak keys
108         try {
109             if (DESKeySpec.isWeak(new_key, 0)) {
110                 new_key[7] = (byte)(new_key[7] ^ 0xF0);
111             }
112         } catch (InvalidKeyException ex) {
113             // swallow, since it should never happen
114         }
115         byte[] ivec = new byte[new_key.length];
116 
117         //des-cbc encrypt
118         byte[] enc_cksum = new byte[cksum.length];
119         Des.cbc_encrypt(cksum, enc_cksum, new_key, ivec, true);
120         return enc_cksum;
121     }
122 
123     /**
124      * Verifies keyed checksum.
125      * @param data the data.
126      * @param size the length of data.
127      * @param key the key used to encrypt the checksum.
128      * @param checksum the checksum.
129      * @return true if verification is successful.
130      *
131      * @modified by Yanni Zhang, 12/08/99.
132      */
<a name="4" id="anc4"></a><span class="line-modified">133     public boolean verifyKeyedChecksum(byte[] data, int size,</span>
134         byte[] key, byte[] checksum, int usage) throws KrbCryptoException {
135         byte[] cksum = decryptKeyedChecksum(checksum, key);
136 
137         byte[] new_data = new byte[size + confounderSize()];
138         System.arraycopy(cksum, 0, new_data, 0, confounderSize());
139         System.arraycopy(data, 0, new_data, confounderSize(), size);
140 
141         //check for weak keys
142         try {
143             if (DESKeySpec.isWeak(key, 0)) {
144                 key[7] = (byte)(key[7] ^ 0xF0);
145             }
146         } catch (InvalidKeyException ex) {
147             // swallow, since it should never happen
148         }
149         byte[] ivec = new byte[key.length];
150         byte[] new_cksum = Des.des_cksum(ivec, new_data, key);
151         byte[] orig_cksum = new byte[cksumSize() - confounderSize()];
152         System.arraycopy(cksum,  confounderSize(), orig_cksum, 0,
153                          cksumSize() - confounderSize());
154         return isChecksumEqual(orig_cksum, new_cksum);
155     }
156 
157     /**
158      * Decrypts keyed checksum.
159      * @param enc_cksum the buffer for encrypted checksum.
160      * @param key the key.
161      * @return the checksum.
162      *
163      * @modified by Yanni Zhang, 12/08/99.
164      */
165     private byte[] decryptKeyedChecksum(byte[] enc_cksum, byte[] key) throws KrbCryptoException {
166         byte[] new_key = new byte[keySize()];
167         System.arraycopy(key, 0, new_key, 0, key.length);
168         for (int i = 0; i &lt; new_key.length; i++)
169         new_key[i] = (byte)(new_key[i] ^ 0xf0);
170         //check for weak keys
171         try {
172             if (DESKeySpec.isWeak(new_key, 0)) {
173                 new_key[7] = (byte)(new_key[7] ^ 0xF0);
174             }
175         } catch (InvalidKeyException ex) {
176             // swallow, since it should never happen
177         }
178         byte[] ivec = new byte[new_key.length];
179         byte[] cksum = new byte[enc_cksum.length];
180         Des.cbc_encrypt(enc_cksum, cksum, new_key, ivec, false);
181         return cksum;
182     }
183 
184 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
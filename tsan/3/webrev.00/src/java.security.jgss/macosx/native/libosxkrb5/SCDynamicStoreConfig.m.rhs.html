<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.security.jgss/macosx/native/libosxkrb5/SCDynamicStoreConfig.m</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #import &lt;Cocoa/Cocoa.h&gt;
 27 #import &lt;JavaNativeFoundation/JavaNativeFoundation.h&gt;
 28 #import &lt;SystemConfiguration/SystemConfiguration.h&gt;
 29 
 30 
 31 @interface JNFVectorCoercion : NSObject &lt;JNFTypeCoercion&gt; { }
 32 @end
 33 
 34 @implementation JNFVectorCoercion
 35 
 36 - (jobject) coerceNSObject:(id)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer {
 37     static JNF_CLASS_CACHE(jc_Vector, &quot;java/util/Vector&quot;);
 38     static JNF_CTOR_CACHE(jm_Vector_ctor, jc_Vector, &quot;(I)V&quot;);
 39     static JNF_MEMBER_CACHE(jm_Vector_add, jc_Vector, &quot;add&quot;, &quot;(Ljava/lang/Object;)Z&quot;);
 40 
 41     NSArray *nsArray = (NSArray *)obj;
 42     jobject javaArray = JNFNewObject(env, jm_Vector_ctor, (jint)[nsArray count]);
 43 
 44     for (id obj in nsArray) {
 45         jobject jobj = [coercer coerceNSObject:obj withEnv:env usingCoercer:coercer];
 46         JNFCallBooleanMethod(env, javaArray, jm_Vector_add, jobj);
 47         if (jobj != NULL) (*env)-&gt;DeleteLocalRef(env, jobj);
 48     }
 49 
 50     return javaArray;
 51 }
 52 
 53 - (id) coerceJavaObject:(jobject)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer {
 54     return nil;
 55 }
 56 
 57 @end
 58 
 59 
 60 @interface JNFHashtableCoercion : NSObject &lt;JNFTypeCoercion&gt; { }
 61 @end
 62 
 63 @implementation JNFHashtableCoercion
 64 
 65 - (jobject) coerceNSObject:(id)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer {
 66     static JNF_CLASS_CACHE(jc_Hashtable, &quot;java/util/Hashtable&quot;);
 67     static JNF_CTOR_CACHE(jm_Hashtable_ctor, jc_Hashtable, &quot;()V&quot;);
 68     static JNF_MEMBER_CACHE(jm_Hashtable_put, jc_Hashtable, &quot;put&quot;, &quot;(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&quot;);
 69 
 70     NSDictionary *nsDict = (NSDictionary *)obj;
 71     NSEnumerator *keyEnum = [nsDict keyEnumerator];
 72 
 73     jobject jHashTable = JNFNewObject(env, jm_Hashtable_ctor);
 74 
 75     id key = nil;
 76     while ((key = [keyEnum nextObject]) != nil) {
 77         jobject jkey = [coercer coerceNSObject:key withEnv:env usingCoercer:coercer];
 78 
 79         id value = [nsDict objectForKey:key];
 80         jobject jvalue = [coercer coerceNSObject:value withEnv:env usingCoercer:coercer];
 81 
 82         JNFCallObjectMethod(env, jHashTable, jm_Hashtable_put, jkey, jvalue);
 83 
 84         if (jkey != NULL) (*env)-&gt;DeleteLocalRef(env, jkey);
 85         if (jvalue != NULL) (*env)-&gt;DeleteLocalRef(env, jvalue);
 86     }
 87 
 88     return jHashTable;
 89 }
 90 
 91 - (id) coerceJavaObject:(jobject)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer {
 92     return nil;
 93 }
 94 
 95 @end
 96 
 97 
 98 
 99 NSDictionary *realmConfigsForRealms(SCDynamicStoreRef store, NSArray *realms) {
100     NSMutableDictionary *dict = [NSMutableDictionary dictionary];
101 
102     for (NSString *realm in realms) {
103         CFTypeRef realmInfo = SCDynamicStoreCopyValue(store, (CFStringRef) [NSString stringWithFormat:@&quot;Kerberos:%@&quot;, realm]);
104 
<a name="2" id="anc2"></a><span class="line-modified">105         if (realmInfo == NULL || CFGetTypeID(realmInfo) != CFDictionaryGetTypeID()) {</span>
<span class="line-added">106             if (realmInfo) CFRelease(realmInfo);</span>
107             return nil;
108         }
109 
110         [dict setObject:(NSArray *)realmInfo forKey:realm];
111         CFRelease(realmInfo);
112     }
113 
114     return dict;
115 }
116 
117 
118 #define KERBEROS_DEFAULT_REALMS @&quot;Kerberos-Default-Realms&quot;
119 #define KERBEROS_DEFAULT_REALM_MAPPINGS @&quot;Kerberos-Domain-Realm-Mappings&quot;
120 
121 void _SCDynamicStoreCallBack(SCDynamicStoreRef store, CFArrayRef changedKeys, void *info) {
122    NSArray *keys = (NSArray *)changedKeys;
123     if ([keys count] == 0) return;
124     if (![keys containsObject:KERBEROS_DEFAULT_REALMS] &amp;&amp; ![keys containsObject:KERBEROS_DEFAULT_REALM_MAPPINGS]) return;
125 
126     JNFPerformEnvBlock(JNFThreadDetachOnThreadDeath | JNFThreadSetSystemClassLoaderOnAttach | JNFThreadAttachAsDaemon, ^(JNIEnv *env) {
127         static JNF_CLASS_CACHE(jc_Config, &quot;sun/security/krb5/Config&quot;);
128         static JNF_STATIC_MEMBER_CACHE(jm_Config_refresh, jc_Config, &quot;refresh&quot;, &quot;()V&quot;);
129         JNFCallStaticVoidMethod(env, jm_Config_refresh);
130     });
131 }
132 
133 /*
134  * Class:     sun_security_krb5_SCDynamicStoreConfig
135  * Method:    installNotificationCallback
136  */
137 JNIEXPORT void JNICALL Java_sun_security_krb5_SCDynamicStoreConfig_installNotificationCallback(JNIEnv *env, jclass klass) {
138 
139 JNF_COCOA_ENTER(env);
140 
141     SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(&quot;java&quot;), _SCDynamicStoreCallBack, NULL);
142     if (store == NULL) {
143         return;
144     }
145 
146     NSArray *keys = [NSArray arrayWithObjects:KERBEROS_DEFAULT_REALMS, KERBEROS_DEFAULT_REALM_MAPPINGS, nil];
147     SCDynamicStoreSetNotificationKeys(store, (CFArrayRef) keys, NULL);
148 
149     CFRunLoopSourceRef rls = SCDynamicStoreCreateRunLoopSource(NULL, store, 0);
150     if (rls != NULL) {
151         CFRunLoopAddSource(CFRunLoopGetMain(), rls, kCFRunLoopDefaultMode);
152         CFRelease(rls);
153     }
154 
155     CFRelease(store);
156 
157 JNF_COCOA_EXIT(env);
158 
159 }
160 
161 /*
162  * Class:     sun_security_krb5_SCDynamicStoreConfig
163  * Method:    getKerberosConfig
164  * Signature: ()Ljava/util/Hashtable;
165  */
166 JNIEXPORT jobject JNICALL Java_sun_security_krb5_SCDynamicStoreConfig_getKerberosConfig(JNIEnv *env, jclass klass) {
167     jobject jHashTable = NULL;
168 
169 JNF_COCOA_ENTER(env);
170 
171     SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(&quot;java-kerberos&quot;), NULL, NULL);
172     if (store == NULL) {
173         return NULL;
174     }
175 
176     CFTypeRef realms = SCDynamicStoreCopyValue(store, (CFStringRef) KERBEROS_DEFAULT_REALMS);
177     if (realms == NULL || CFGetTypeID(realms) != CFArrayGetTypeID()) {
178         if (realms) CFRelease(realms);
179         CFRelease(store);
180         return NULL;
181     }
182 
183     CFTypeRef realmMappings = SCDynamicStoreCopyValue(store, (CFStringRef) KERBEROS_DEFAULT_REALM_MAPPINGS);
184 
185     if (realmMappings == NULL || CFGetTypeID(realmMappings) != CFArrayGetTypeID()) {
186         if (realmMappings) CFRelease(realmMappings);
187         CFRelease(realms);
188         CFRelease(store);
189         return NULL;
190     }
191 
192     NSMutableDictionary *dict = [NSMutableDictionary dictionary];
193 
194     if (CFArrayGetCount(realms) &gt; 0) {
195         NSDictionary *defaultRealmsDict = [NSDictionary dictionaryWithObject:[(NSArray *)realms objectAtIndex:0] forKey:@&quot;default_realm&quot;];
196         [dict setObject:defaultRealmsDict forKey:@&quot;libdefaults&quot;];
197 
198         NSDictionary *realmConfigs = realmConfigsForRealms(store, (NSArray *)realms);
199         [dict setObject:realmConfigs forKey:@&quot;realms&quot;];
200     }
201     CFRelease(realms);
202     CFRelease(store);
203 
204     if (CFArrayGetCount(realmMappings) &gt; 0) {
205         [dict setObject:[(NSArray *)realmMappings objectAtIndex:0] forKey:@&quot;domain_realm&quot;];
206     }
207     CFRelease(realmMappings);
208 
209 
210     // create and load a coercer with all of the different coercions to convert each type of object
211     JNFTypeCoercer *coercer = [[[JNFTypeCoercer alloc] init] autorelease];
212     [JNFDefaultCoercions addStringCoercionTo:coercer];
213     [JNFDefaultCoercions addNumberCoercionTo:coercer];
214     [coercer addCoercion:[[[JNFHashtableCoercion alloc] init] autorelease] forNSClass:[NSDictionary class] javaClass:@&quot;java/util/Map&quot;];
215     [coercer addCoercion:[[[JNFVectorCoercion alloc] init] autorelease] forNSClass:[NSArray class] javaClass:@&quot;java/util/List&quot;];
216 
217     // convert Cocoa graph to Java graph
218     jHashTable = [coercer coerceNSObject:dict withEnv:env];
219 
220 JNF_COCOA_EXIT(env);
221 
222     return jHashTable;
223 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
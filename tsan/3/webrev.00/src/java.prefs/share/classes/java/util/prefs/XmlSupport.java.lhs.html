<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.prefs/share/classes/java/util/prefs/XmlSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.prefs;
 27 
 28 import java.util.*;
 29 import java.io.*;
 30 import javax.xml.parsers.*;
 31 import javax.xml.transform.*;
 32 import javax.xml.transform.dom.*;
 33 import javax.xml.transform.stream.*;
 34 import org.xml.sax.*;
 35 import org.w3c.dom.*;
 36 
<a name="2" id="anc2"></a>

 37 /**
 38  * XML Support for java.util.prefs. Methods to import and export preference
 39  * nodes and subtrees.
 40  *
 41  * @author  Josh Bloch and Mark Reinhold
 42  * @see     Preferences
 43  * @since   1.4
 44  */
 45 class XmlSupport {
 46     // The required DTD URI for exported preferences
 47     private static final String PREFS_DTD_URI =
 48         &quot;http://java.sun.com/dtd/preferences.dtd&quot;;
 49 
 50     // The actual DTD corresponding to the URI
 51     private static final String PREFS_DTD =
 52         &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;&quot; +
 53 
 54         &quot;&lt;!-- DTD for preferences --&gt;&quot;               +
 55 
 56         &quot;&lt;!ELEMENT preferences (root) &gt;&quot;             +
 57         &quot;&lt;!ATTLIST preferences&quot;                      +
 58         &quot; EXTERNAL_XML_VERSION CDATA \&quot;0.0\&quot;  &gt;&quot;     +
 59 
 60         &quot;&lt;!ELEMENT root (map, node*) &gt;&quot;              +
 61         &quot;&lt;!ATTLIST root&quot;                             +
 62         &quot;          type (system|user) #REQUIRED &gt;&quot;   +
 63 
 64         &quot;&lt;!ELEMENT node (map, node*) &gt;&quot;              +
 65         &quot;&lt;!ATTLIST node&quot;                             +
 66         &quot;          name CDATA #REQUIRED &gt;&quot;           +
 67 
 68         &quot;&lt;!ELEMENT map (entry*) &gt;&quot;                   +
 69         &quot;&lt;!ATTLIST map&quot;                              +
 70         &quot;  MAP_XML_VERSION CDATA \&quot;0.0\&quot;  &gt;&quot;         +
 71         &quot;&lt;!ELEMENT entry EMPTY &gt;&quot;                    +
 72         &quot;&lt;!ATTLIST entry&quot;                            +
 73         &quot;          key CDATA #REQUIRED&quot;              +
 74         &quot;          value CDATA #REQUIRED &gt;&quot;          ;
 75     /**
 76      * Version number for the format exported preferences files.
 77      */
 78     private static final String EXTERNAL_XML_VERSION = &quot;1.0&quot;;
 79 
 80     /*
 81      * Version number for the internal map files.
 82      */
 83     private static final String MAP_XML_VERSION = &quot;1.0&quot;;
 84 
 85     /**
 86      * Export the specified preferences node and, if subTree is true, all
 87      * subnodes, to the specified output stream.  Preferences are exported as
 88      * an XML document conforming to the definition in the Preferences spec.
 89      *
 90      * @throws IOException if writing to the specified output stream
 91      *         results in an {@code IOException}.
 92      * @throws BackingStoreException if preference data cannot be read from
 93      *         backing store.
 94      * @throws IllegalStateException if this node (or an ancestor) has been
 95      *         removed with the {@link Preferences#removeNode()} method.
 96      */
 97     static void export(OutputStream os, final Preferences p, boolean subTree)
 98         throws IOException, BackingStoreException {
 99         if (((AbstractPreferences)p).isRemoved())
100             throw new IllegalStateException(&quot;Node has been removed&quot;);
101         Document doc = createPrefsDoc(&quot;preferences&quot;);
102         Element preferences =  doc.getDocumentElement() ;
103         preferences.setAttribute(&quot;EXTERNAL_XML_VERSION&quot;, EXTERNAL_XML_VERSION);
104         Element xmlRoot =  (Element)
105         preferences.appendChild(doc.createElement(&quot;root&quot;));
106         xmlRoot.setAttribute(&quot;type&quot;, (p.isUserNode() ? &quot;user&quot; : &quot;system&quot;));
107 
108         // Get bottom-up list of nodes from p to root, excluding root
109         List&lt;Preferences&gt; ancestors = new ArrayList&lt;&gt;();
110 
111         for (Preferences kid = p, dad = kid.parent(); dad != null;
112                                    kid = dad, dad = kid.parent()) {
113             ancestors.add(kid);
114         }
115         Element e = xmlRoot;
116         for (int i=ancestors.size()-1; i &gt;= 0; i--) {
117             e.appendChild(doc.createElement(&quot;map&quot;));
118             e = (Element) e.appendChild(doc.createElement(&quot;node&quot;));
119             e.setAttribute(&quot;name&quot;, ancestors.get(i).name());
120         }
121         putPreferencesInXml(e, doc, p, subTree);
122 
123         writeDoc(doc, os);
124     }
125 
126     /**
127      * Put the preferences in the specified Preferences node into the
128      * specified XML element which is assumed to represent a node
129      * in the specified XML document which is assumed to conform to
130      * PREFS_DTD.  If subTree is true, create children of the specified
131      * XML node conforming to all of the children of the specified
132      * Preferences node and recurse.
133      *
134      * @throws BackingStoreException if it is not possible to read
135      *         the preferences or children out of the specified
136      *         preferences node.
137      */
138     private static void putPreferencesInXml(Element elt, Document doc,
139                Preferences prefs, boolean subTree) throws BackingStoreException
140     {
141         Preferences[] kidsCopy = null;
142         String[] kidNames = null;
143 
144         // Node is locked to export its contents and get a
145         // copy of children, then lock is released,
146         // and, if subTree = true, recursive calls are made on children
147         synchronized (((AbstractPreferences)prefs).lock) {
148             // Check if this node was concurrently removed. If yes
149             // remove it from XML Document and return.
150             if (((AbstractPreferences)prefs).isRemoved()) {
151                 elt.getParentNode().removeChild(elt);
152                 return;
153             }
154             // Put map in xml element
155             String[] keys = prefs.keys();
156             Element map = (Element) elt.appendChild(doc.createElement(&quot;map&quot;));
157             for (String key : keys) {
158                 Element entry = (Element)
159                     map.appendChild(doc.createElement(&quot;entry&quot;));
160                 entry.setAttribute(&quot;key&quot;, key);
161                 // NEXT STATEMENT THROWS NULL PTR EXC INSTEAD OF ASSERT FAIL
162                 entry.setAttribute(&quot;value&quot;, prefs.get(key, null));
163             }
164             // Recurse if appropriate
165             if (subTree) {
166                 /* Get a copy of kids while lock is held */
167                 kidNames = prefs.childrenNames();
168                 kidsCopy = new Preferences[kidNames.length];
169                 for (int i = 0; i &lt;  kidNames.length; i++)
170                     kidsCopy[i] = prefs.node(kidNames[i]);
171             }
172             // release lock
173         }
174 
175         if (subTree) {
176             for (int i=0; i &lt; kidNames.length; i++) {
177                 Element xmlKid = (Element)
178                     elt.appendChild(doc.createElement(&quot;node&quot;));
179                 xmlKid.setAttribute(&quot;name&quot;, kidNames[i]);
180                 putPreferencesInXml(xmlKid, doc, kidsCopy[i], subTree);
181             }
182         }
183     }
184 
185     /**
186      * Import preferences from the specified input stream, which is assumed
187      * to contain an XML document in the format described in the Preferences
188      * spec.
189      *
190      * @throws IOException if reading from the specified output stream
191      *         results in an {@code IOException}.
192      * @throws InvalidPreferencesFormatException Data on input stream does not
193      *         constitute a valid XML document with the mandated document type.
194      */
195     static void importPreferences(InputStream is)
196         throws IOException, InvalidPreferencesFormatException
197     {
198         try {
199             Document doc = loadPrefsDoc(is);
200             String xmlVersion =
201                 doc.getDocumentElement().getAttribute(&quot;EXTERNAL_XML_VERSION&quot;);
202             if (xmlVersion.compareTo(EXTERNAL_XML_VERSION) &gt; 0)
203                 throw new InvalidPreferencesFormatException(
204                 &quot;Exported preferences file format version &quot; + xmlVersion +
205                 &quot; is not supported. This java installation can read&quot; +
206                 &quot; versions &quot; + EXTERNAL_XML_VERSION + &quot; or older. You may need&quot; +
207                 &quot; to install a newer version of JDK.&quot;);
208 
209             Element xmlRoot = (Element) doc.getDocumentElement().
210                                                getChildNodes().item(0);
211             Preferences prefsRoot =
212                 (xmlRoot.getAttribute(&quot;type&quot;).equals(&quot;user&quot;) ?
213                             Preferences.userRoot() : Preferences.systemRoot());
214             ImportSubtree(prefsRoot, xmlRoot);
215         } catch(SAXException e) {
216             throw new InvalidPreferencesFormatException(e);
217         }
218     }
219 
220     /**
221      * Create a new prefs XML document.
222      */
223     private static Document createPrefsDoc( String qname ) {
224         try {
225             DOMImplementation di = DocumentBuilderFactory.newInstance().
226                 newDocumentBuilder().getDOMImplementation();
227             DocumentType dt = di.createDocumentType(qname, null, PREFS_DTD_URI);
228             return di.createDocument(null, qname, dt);
229         } catch(ParserConfigurationException e) {
230             throw new AssertionError(e);
231         }
232     }
233 
234     /**
235      * Load an XML document from specified input stream, which must
236      * have the requisite DTD URI.
237      */
238     private static Document loadPrefsDoc(InputStream in)
239         throws SAXException, IOException
240     {
241         DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
242         dbf.setIgnoringElementContentWhitespace(true);
243         dbf.setValidating(true);
244         dbf.setCoalescing(true);
245         dbf.setIgnoringComments(true);
246         try {
247             DocumentBuilder db = dbf.newDocumentBuilder();
248             db.setEntityResolver(new Resolver());
249             db.setErrorHandler(new EH());
250             return db.parse(new InputSource(in));
251         } catch (ParserConfigurationException e) {
252             throw new AssertionError(e);
253         }
254     }
255 
256     /**
257      * Write XML document to the specified output stream.
258      */
259     private static final void writeDoc(Document doc, OutputStream out)
260         throws IOException
261     {
262         try {
263             TransformerFactory tf = TransformerFactory.newInstance();
264             try {
265                 tf.setAttribute(&quot;indent-number&quot;, 2);
266             } catch (IllegalArgumentException iae) {
267                 //Ignore the IAE. Should not fail the writeout even the
268                 //transformer provider does not support &quot;indent-number&quot;.
269             }
270             Transformer t = tf.newTransformer();
271             t.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doc.getDoctype().getSystemId());
272             t.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);
273             //Transformer resets the &quot;indent&quot; info if the &quot;result&quot; is a StreamResult with
274             //an OutputStream object embedded, creating a Writer object on top of that
275             //OutputStream object however works.
276             t.transform(new DOMSource(doc),
<a name="3" id="anc3"></a><span class="line-modified">277                         new StreamResult(new BufferedWriter(new OutputStreamWriter(out, &quot;UTF-8&quot;))));</span>
278         } catch(TransformerException e) {
279             throw new AssertionError(e);
280         }
281     }
282 
283     /**
284      * Recursively traverse the specified preferences node and store
285      * the described preferences into the system or current user
286      * preferences tree, as appropriate.
287      */
288     private static void ImportSubtree(Preferences prefsNode, Element xmlNode) {
289         NodeList xmlKids = xmlNode.getChildNodes();
290         int numXmlKids = xmlKids.getLength();
291         /*
292          * We first lock the node, import its contents and get
293          * child nodes. Then we unlock the node and go to children
294          * Since some of the children might have been concurrently
295          * deleted we check for this.
296          */
297         Preferences[] prefsKids;
298         /* Lock the node */
299         synchronized (((AbstractPreferences)prefsNode).lock) {
300             //If removed, return silently
301             if (((AbstractPreferences)prefsNode).isRemoved())
302                 return;
303 
304             // Import any preferences at this node
305             Element firstXmlKid = (Element) xmlKids.item(0);
306             ImportPrefs(prefsNode, firstXmlKid);
307             prefsKids = new Preferences[numXmlKids - 1];
308 
309             // Get involved children
310             for (int i=1; i &lt; numXmlKids; i++) {
311                 Element xmlKid = (Element) xmlKids.item(i);
312                 prefsKids[i-1] = prefsNode.node(xmlKid.getAttribute(&quot;name&quot;));
313             }
314         } // unlocked the node
315         // import children
316         for (int i=1; i &lt; numXmlKids; i++)
317             ImportSubtree(prefsKids[i-1], (Element)xmlKids.item(i));
318     }
319 
320     /**
321      * Import the preferences described by the specified XML element
322      * (a map from a preferences document) into the specified
323      * preferences node.
324      */
325     private static void ImportPrefs(Preferences prefsNode, Element map) {
326         NodeList entries = map.getChildNodes();
327         for (int i=0, numEntries = entries.getLength(); i &lt; numEntries; i++) {
328             Element entry = (Element) entries.item(i);
329             prefsNode.put(entry.getAttribute(&quot;key&quot;),
330                           entry.getAttribute(&quot;value&quot;));
331         }
332     }
333 
334     /**
335      * Export the specified Map&lt;String,String&gt; to a map document on
336      * the specified OutputStream as per the prefs DTD.  This is used
337      * as the internal (undocumented) format for FileSystemPrefs.
338      *
339      * @throws IOException if writing to the specified output stream
340      *         results in an {@code IOException}.
341      */
342     static void exportMap(OutputStream os, Map&lt;String, String&gt; map) throws IOException {
343         Document doc = createPrefsDoc(&quot;map&quot;);
344         Element xmlMap = doc.getDocumentElement( ) ;
345         xmlMap.setAttribute(&quot;MAP_XML_VERSION&quot;, MAP_XML_VERSION);
346 
347         for (Map.Entry&lt;String, String&gt; e : map.entrySet()) {
348             Element xe = (Element)
349                 xmlMap.appendChild(doc.createElement(&quot;entry&quot;));
350             xe.setAttribute(&quot;key&quot;,   e.getKey());
351             xe.setAttribute(&quot;value&quot;, e.getValue());
352         }
353 
354         writeDoc(doc, os);
355     }
356 
357     /**
358      * Import Map from the specified input stream, which is assumed
359      * to contain a map document as per the prefs DTD.  This is used
360      * as the internal (undocumented) format for FileSystemPrefs.  The
361      * key-value pairs specified in the XML document will be put into
362      * the specified Map.  (If this Map is empty, it will contain exactly
363      * the key-value pairs int the XML-document when this method returns.)
364      *
365      * @throws IOException if reading from the specified output stream
366      *         results in an {@code IOException}.
367      * @throws InvalidPreferencesFormatException Data on input stream does not
368      *         constitute a valid XML document with the mandated document type.
369      */
370     static void importMap(InputStream is, Map&lt;String, String&gt; m)
371         throws IOException, InvalidPreferencesFormatException
372     {
373         try {
374             Document doc = loadPrefsDoc(is);
375             Element xmlMap = doc.getDocumentElement();
376             // check version
377             String mapVersion = xmlMap.getAttribute(&quot;MAP_XML_VERSION&quot;);
378             if (mapVersion.compareTo(MAP_XML_VERSION) &gt; 0)
379                 throw new InvalidPreferencesFormatException(
380                 &quot;Preferences map file format version &quot; + mapVersion +
381                 &quot; is not supported. This java installation can read&quot; +
382                 &quot; versions &quot; + MAP_XML_VERSION + &quot; or older. You may need&quot; +
383                 &quot; to install a newer version of JDK.&quot;);
384 
385             NodeList entries = xmlMap.getChildNodes();
386             for (int i=0, numEntries=entries.getLength(); i&lt;numEntries; i++) {
387                 Element entry = (Element) entries.item(i);
388                 m.put(entry.getAttribute(&quot;key&quot;), entry.getAttribute(&quot;value&quot;));
389             }
390         } catch(SAXException e) {
391             throw new InvalidPreferencesFormatException(e);
392         }
393     }
394 
395     private static class Resolver implements EntityResolver {
396         public InputSource resolveEntity(String pid, String sid)
397             throws SAXException
398         {
399             if (sid.equals(PREFS_DTD_URI)) {
400                 InputSource is;
401                 is = new InputSource(new StringReader(PREFS_DTD));
402                 is.setSystemId(PREFS_DTD_URI);
403                 return is;
404             }
405             throw new SAXException(&quot;Invalid system identifier: &quot; + sid);
406         }
407     }
408 
409     private static class EH implements ErrorHandler {
410         public void error(SAXParseException x) throws SAXException {
411             throw x;
412         }
413         public void fatalError(SAXParseException x) throws SAXException {
414             throw x;
415         }
416         public void warning(SAXParseException x) throws SAXException {
417             throw x;
418         }
419     }
420 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
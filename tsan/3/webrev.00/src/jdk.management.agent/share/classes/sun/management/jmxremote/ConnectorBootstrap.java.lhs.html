<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.management.agent/share/classes/sun/management/jmxremote/ConnectorBootstrap.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.management.jmxremote;
  27 
  28 import java.lang.System.Logger;
  29 import java.lang.System.Logger.Level;
  30 import java.io.BufferedInputStream;
  31 import java.io.File;
  32 import java.io.FileInputStream;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.ObjectInputFilter;
  36 import java.lang.management.ManagementFactory;
  37 import java.net.InetAddress;
  38 import java.net.MalformedURLException;
  39 import java.net.Socket;
  40 import java.net.ServerSocket;
  41 import java.net.UnknownHostException;
  42 import java.rmi.NoSuchObjectException;
  43 import java.rmi.Remote;
  44 import java.rmi.RemoteException;
  45 import java.rmi.registry.Registry;
  46 import java.rmi.server.RMIClientSocketFactory;
  47 import java.rmi.server.RMIServerSocketFactory;
  48 import java.rmi.server.RemoteObject;
  49 import java.rmi.server.UnicastRemoteObject;
  50 import java.security.KeyStore;
  51 import java.security.Principal;
  52 import java.util.HashMap;
  53 import java.util.HashSet;
  54 import java.util.Map;
  55 import java.util.Properties;
  56 import java.util.Set;
  57 import java.util.StringTokenizer;
  58 
  59 import javax.management.MBeanServer;
  60 import javax.management.remote.JMXAuthenticator;
  61 import javax.management.remote.JMXConnectorServer;
  62 import javax.management.remote.JMXConnectorServerFactory;
  63 import javax.management.remote.JMXServiceURL;
  64 import javax.management.remote.rmi.RMIConnectorServer;
  65 import javax.net.ssl.KeyManagerFactory;
  66 import javax.net.ssl.SSLContext;
  67 import javax.net.ssl.SSLSocket;
  68 import javax.net.ssl.SSLSocketFactory;
  69 import javax.net.ssl.TrustManagerFactory;
  70 import javax.rmi.ssl.SslRMIClientSocketFactory;
  71 import javax.rmi.ssl.SslRMIServerSocketFactory;
  72 import javax.security.auth.Subject;
  73 import com.sun.jmx.remote.internal.rmi.RMIExporter;
  74 import com.sun.jmx.remote.security.JMXPluggableAuthenticator;
  75 import jdk.internal.agent.Agent;
  76 import jdk.internal.agent.AgentConfigurationError;
  77 import static jdk.internal.agent.AgentConfigurationError.*;
  78 import jdk.internal.agent.ConnectorAddressLink;
  79 import jdk.internal.agent.FileSystem;
  80 import sun.rmi.server.UnicastRef;
  81 import sun.rmi.server.UnicastServerRef;
  82 import sun.rmi.server.UnicastServerRef2;
  83 import sun.rmi.transport.LiveRef;
  84 
  85 /**
  86  * This class initializes and starts the RMIConnectorServer for JSR 163
  87  * JMX Monitoring.
  88  **/
  89 public final class ConnectorBootstrap {
  90 
  91     /**
  92      * Default values for JMX configuration properties.
  93      **/
  94     public static interface DefaultValues {
  95 
  96         public static final String PORT = &quot;0&quot;;
  97         public static final String CONFIG_FILE_NAME = &quot;management.properties&quot;;
  98         public static final String USE_SSL = &quot;true&quot;;
  99         public static final String USE_LOCAL_ONLY = &quot;true&quot;;
 100         public static final String USE_REGISTRY_SSL = &quot;false&quot;;
 101         public static final String USE_AUTHENTICATION = &quot;true&quot;;
 102         public static final String PASSWORD_FILE_NAME = &quot;jmxremote.password&quot;;
 103         public static final String HASH_PASSWORDS = &quot;true&quot;;
 104         public static final String ACCESS_FILE_NAME = &quot;jmxremote.access&quot;;
 105         public static final String SSL_NEED_CLIENT_AUTH = &quot;false&quot;;
 106     }
 107 
 108     /**
 109      * Names of JMX configuration properties.
 110      **/
 111     public static interface PropertyNames {
 112 
 113         public static final String PORT =
 114                 &quot;com.sun.management.jmxremote.port&quot;;
 115         public static final String HOST =
 116                 &quot;com.sun.management.jmxremote.host&quot;;
 117         public static final String RMI_PORT =
 118                 &quot;com.sun.management.jmxremote.rmi.port&quot;;
<a name="2" id="anc2"></a>

 119         public static final String CONFIG_FILE_NAME =
 120                 &quot;com.sun.management.config.file&quot;;
 121         public static final String USE_LOCAL_ONLY =
 122                 &quot;com.sun.management.jmxremote.local.only&quot;;
 123         public static final String USE_SSL =
 124                 &quot;com.sun.management.jmxremote.ssl&quot;;
 125         public static final String USE_REGISTRY_SSL =
 126                 &quot;com.sun.management.jmxremote.registry.ssl&quot;;
 127         public static final String USE_AUTHENTICATION =
 128                 &quot;com.sun.management.jmxremote.authenticate&quot;;
 129         public static final String PASSWORD_FILE_NAME =
 130                 &quot;com.sun.management.jmxremote.password.file&quot;;
 131         public static final String HASH_PASSWORDS
 132                 = &quot;com.sun.management.jmxremote.password.toHashes&quot;;
 133         public static final String ACCESS_FILE_NAME =
 134                 &quot;com.sun.management.jmxremote.access.file&quot;;
 135         public static final String LOGIN_CONFIG_NAME =
 136                 &quot;com.sun.management.jmxremote.login.config&quot;;
 137         public static final String SSL_ENABLED_CIPHER_SUITES =
 138                 &quot;com.sun.management.jmxremote.ssl.enabled.cipher.suites&quot;;
 139         public static final String SSL_ENABLED_PROTOCOLS =
 140                 &quot;com.sun.management.jmxremote.ssl.enabled.protocols&quot;;
 141         public static final String SSL_NEED_CLIENT_AUTH =
 142                 &quot;com.sun.management.jmxremote.ssl.need.client.auth&quot;;
 143         public static final String SSL_CONFIG_FILE_NAME =
 144                 &quot;com.sun.management.jmxremote.ssl.config.file&quot;;
 145         public static final String SERIAL_FILTER_PATTERN =
 146                 &quot;com.sun.management.jmxremote.serial.filter.pattern&quot;;
 147     }
 148 
 149     /**
 150      * JMXConnectorServer associated data.
 151      */
 152     private static class JMXConnectorServerData {
 153 
 154         public JMXConnectorServerData(
 155                 JMXConnectorServer jmxConnectorServer,
 156                 JMXServiceURL jmxRemoteURL) {
 157             this.jmxConnectorServer = jmxConnectorServer;
 158             this.jmxRemoteURL = jmxRemoteURL;
 159         }
 160         JMXConnectorServer jmxConnectorServer;
 161         JMXServiceURL jmxRemoteURL;
 162     }
 163 
 164     /**
 165      * &lt;p&gt;Prevents our RMI server objects from keeping the JVM alive.&lt;/p&gt;
 166      *
 167      * &lt;p&gt;We use a private interface in Sun&#39;s JMX Remote API implementation
 168      * that allows us to specify how to export RMI objects.  We do so using
 169      * UnicastServerRef, a class in Sun&#39;s RMI implementation.  This is all
 170      * non-portable, of course, so this is only valid because we are inside
 171      * Sun&#39;s JRE.&lt;/p&gt;
 172      *
 173      * &lt;p&gt;Objects are exported using {@link
 174      * UnicastServerRef#exportObject(Remote, Object, boolean)}.  The
 175      * boolean parameter is called &lt;code&gt;permanent&lt;/code&gt; and means
 176      * both that the object is not eligible for Distributed Garbage
 177      * Collection, and that its continued existence will not prevent
 178      * the JVM from exiting.  It is the latter semantics we want (we
 179      * already have the former because of the way the JMX Remote API
 180      * works).  Hence the somewhat misleading name of this class.&lt;/p&gt;
 181      */
 182     private static class PermanentExporter implements RMIExporter {
 183 
 184         public Remote exportObject(Remote obj,
 185                 int port,
 186                 RMIClientSocketFactory csf,
 187                 RMIServerSocketFactory ssf,
 188                 ObjectInputFilter filter)
 189                 throws RemoteException {
 190 
 191             synchronized (this) {
 192                 if (firstExported == null) {
 193                     firstExported = obj;
 194                 }
 195             }
 196 
 197             final UnicastServerRef ref;
 198             if (csf == null &amp;&amp; ssf == null) {
 199                 ref = new UnicastServerRef(new LiveRef(port), filter);
 200             } else {
 201                 ref = new UnicastServerRef2(port, csf, ssf, filter);
 202             }
 203             return ref.exportObject(obj, null, true);
 204         }
 205 
 206         // Nothing special to be done for this case
 207         public boolean unexportObject(Remote obj, boolean force)
 208                 throws NoSuchObjectException {
 209             return UnicastRemoteObject.unexportObject(obj, force);
 210         }
 211         Remote firstExported;
 212     }
 213 
 214     /**
 215      * This JMXAuthenticator wraps the JMXPluggableAuthenticator and verifies
 216      * that at least one of the principal names contained in the authenticated
 217      * Subject is present in the access file.
 218      */
 219     private static class AccessFileCheckerAuthenticator
 220             implements JMXAuthenticator {
 221 
 222         public AccessFileCheckerAuthenticator(Map&lt;String, Object&gt; env) throws IOException {
 223             environment = env;
 224             accessFile = (String) env.get(&quot;jmx.remote.x.access.file&quot;);
 225             properties = propertiesFromFile(accessFile);
 226         }
 227 
 228         public Subject authenticate(Object credentials) {
 229             final JMXAuthenticator authenticator =
 230                     new JMXPluggableAuthenticator(environment);
 231             final Subject subject = authenticator.authenticate(credentials);
 232             checkAccessFileEntries(subject);
 233             return subject;
 234         }
 235 
 236         private void checkAccessFileEntries(Subject subject) {
 237             if (subject == null) {
 238                 throw new SecurityException(
 239                         &quot;Access denied! No matching entries found in &quot; +
 240                         &quot;the access file [&quot; + accessFile + &quot;] as the &quot; +
 241                         &quot;authenticated Subject is null&quot;);
 242             }
 243             final Set&lt;Principal&gt; principals = subject.getPrincipals();
 244             for (Principal p1: principals) {
 245                 if (properties.containsKey(p1.getName())) {
 246                     return;
 247                 }
 248             }
 249 
 250             final Set&lt;String&gt; principalsStr = new HashSet&lt;&gt;();
 251             for (Principal p2: principals) {
 252                 principalsStr.add(p2.getName());
 253             }
 254             throw new SecurityException(
 255                     &quot;Access denied! No entries found in the access file [&quot; +
 256                     accessFile + &quot;] for any of the authenticated identities &quot; +
 257                     principalsStr);
 258         }
 259 
 260         private static Properties propertiesFromFile(String fname)
 261                 throws IOException {
 262             Properties p = new Properties();
 263             if (fname == null) {
 264                 return p;
 265             }
 266             try (FileInputStream fin = new FileInputStream(fname)) {
 267                 p.load(fin);
 268             }
 269             return p;
 270         }
 271         private final Map&lt;String, Object&gt; environment;
 272         private final Properties properties;
 273         private final String accessFile;
 274     }
 275 
 276     // The variable below is here to support stop functionality
 277     // It would be overriten if you call startRemoteCommectionServer second
 278     // time. It&#39;s OK for now as logic in Agent.java forbids mutiple agents
 279     private static Registry registry = null;
 280 
 281     public static void unexportRegistry() {
 282         // Remove the entry from registry
 283         try {
 284             if (registry != null) {
 285                 UnicastRemoteObject.unexportObject(registry, true);
 286                 registry = null;
 287             }
 288         } catch(NoSuchObjectException ex) {
 289             // This exception can appears only if we attempt
 290             // to unexportRegistry second time. So it&#39;s safe
 291             // to ignore it without additional messages.
 292         }
 293     }
 294 
 295      /**
 296       * Initializes and starts the JMX Connector Server.
 297       * If the com.sun.management.jmxremote.port property is not defined,
 298       * simply return. Otherwise, attempts to load the config file, and
 299       * then calls {@link #startRemoteConnectorServer
 300       *                            (java.lang.String, java.util.Properties)}.
 301       *
 302       * This method is used by some jtreg tests.
 303       **/
 304       public static synchronized JMXConnectorServer initialize() {
 305 
 306          // Load a new management properties
 307          final Properties props = Agent.loadManagementProperties();
 308          if (props == null) {
 309               return null;
 310          }
 311 
 312          final String portStr = props.getProperty(PropertyNames.PORT);
 313          return startRemoteConnectorServer(portStr, props);
 314      }
 315 
 316     /**
 317      * This method is used by some jtreg tests.
 318      *
 319      * @see #startRemoteConnectorServer
 320      *             (String portStr, Properties props)
 321      */
 322     public static synchronized JMXConnectorServer initialize(String portStr, Properties props)  {
 323          return startRemoteConnectorServer(portStr, props);
 324     }
 325 
 326     /**
 327      * Initializes and starts a JMX Connector Server for remote
 328      * monitoring and management.
 329      **/
 330     public static synchronized JMXConnectorServer startRemoteConnectorServer(String portStr, Properties props) {
 331 
 332         // Get port number
 333         final int port;
 334         try {
 335             port = Integer.parseInt(portStr);
 336         } catch (NumberFormatException x) {
 337             throw new AgentConfigurationError(INVALID_JMXREMOTE_PORT, x, portStr);
 338         }
 339         if (port &lt; 0) {
 340             throw new AgentConfigurationError(INVALID_JMXREMOTE_PORT, portStr);
 341         }
 342 
 343         // User can specify a port to be used to export rmi object,
 344         // in order to simplify firewall rules
 345         // if port is not specified random one will be allocated.
 346         int rmiPort = 0;
 347         String rmiPortStr = props.getProperty(PropertyNames.RMI_PORT);
 348         try {
 349             if (rmiPortStr != null) {
 350                rmiPort = Integer.parseInt(rmiPortStr);
 351             }
 352         } catch (NumberFormatException x) {
 353             throw new AgentConfigurationError(INVALID_JMXREMOTE_RMI_PORT, x, rmiPortStr);
 354         }
 355         if (rmiPort &lt; 0) {
 356             throw new AgentConfigurationError(INVALID_JMXREMOTE_RMI_PORT, rmiPortStr);
 357         }
 358 
 359         // Do we use authentication?
 360         final String useAuthenticationStr =
 361                 props.getProperty(PropertyNames.USE_AUTHENTICATION,
 362                 DefaultValues.USE_AUTHENTICATION);
 363         final boolean useAuthentication =
 364                 Boolean.valueOf(useAuthenticationStr).booleanValue();
 365 
 366         // Do we use SSL?
 367         final String useSslStr =
 368                 props.getProperty(PropertyNames.USE_SSL,
 369                 DefaultValues.USE_SSL);
 370         final boolean useSsl =
 371                 Boolean.valueOf(useSslStr).booleanValue();
 372 
 373         // Do we use RMI Registry SSL?
 374         final String useRegistrySslStr =
 375                 props.getProperty(PropertyNames.USE_REGISTRY_SSL,
 376                 DefaultValues.USE_REGISTRY_SSL);
 377         final boolean useRegistrySsl =
 378                 Boolean.valueOf(useRegistrySslStr).booleanValue();
 379 
 380         final String enabledCipherSuites =
 381                 props.getProperty(PropertyNames.SSL_ENABLED_CIPHER_SUITES);
 382         String enabledCipherSuitesList[] = null;
 383         if (enabledCipherSuites != null) {
 384             StringTokenizer st = new StringTokenizer(enabledCipherSuites, &quot;,&quot;);
 385             int tokens = st.countTokens();
 386             enabledCipherSuitesList = new String[tokens];
 387             for (int i = 0; i &lt; tokens; i++) {
 388                 enabledCipherSuitesList[i] = st.nextToken();
 389             }
 390         }
 391 
 392         final String enabledProtocols =
 393                 props.getProperty(PropertyNames.SSL_ENABLED_PROTOCOLS);
 394         String enabledProtocolsList[] = null;
 395         if (enabledProtocols != null) {
 396             StringTokenizer st = new StringTokenizer(enabledProtocols, &quot;,&quot;);
 397             int tokens = st.countTokens();
 398             enabledProtocolsList = new String[tokens];
 399             for (int i = 0; i &lt; tokens; i++) {
 400                 enabledProtocolsList[i] = st.nextToken();
 401             }
 402         }
 403 
 404         final String sslNeedClientAuthStr =
 405                 props.getProperty(PropertyNames.SSL_NEED_CLIENT_AUTH,
 406                 DefaultValues.SSL_NEED_CLIENT_AUTH);
 407         final boolean sslNeedClientAuth =
 408                 Boolean.valueOf(sslNeedClientAuthStr).booleanValue();
 409 
 410         // Read SSL config file name
 411         final String sslConfigFileName =
 412                 props.getProperty(PropertyNames.SSL_CONFIG_FILE_NAME);
 413 
 414         String loginConfigName = null;
 415         String passwordFileName = null;
 416         boolean shouldHashPasswords = true;
 417         String accessFileName = null;
 418 
 419         // Initialize settings when authentication is active
 420         if (useAuthentication) {
 421 
 422             // Get non-default login configuration
 423             loginConfigName =
 424                     props.getProperty(PropertyNames.LOGIN_CONFIG_NAME);
 425 
 426             if (loginConfigName == null) {
 427                 // Get password file
 428                 passwordFileName =
 429                         props.getProperty(PropertyNames.PASSWORD_FILE_NAME,
 430                         getDefaultFileName(DefaultValues.PASSWORD_FILE_NAME));
 431                 String hashPasswords
 432                         = props.getProperty(PropertyNames.HASH_PASSWORDS,
 433                                 DefaultValues.HASH_PASSWORDS);
 434                 shouldHashPasswords = Boolean.parseBoolean(hashPasswords);
 435 
 436                 checkPasswordFile(passwordFileName);
 437             }
 438 
 439             // Get access file
 440             accessFileName = props.getProperty(PropertyNames.ACCESS_FILE_NAME,
 441                     getDefaultFileName(DefaultValues.ACCESS_FILE_NAME));
 442             checkAccessFile(accessFileName);
 443         }
 444 
 445         final String bindAddress =
 446                 props.getProperty(PropertyNames.HOST);
 447         final String jmxRmiFilter = props.getProperty(PropertyNames.SERIAL_FILTER_PATTERN);
 448 
 449         if (logger.isLoggable(Level.DEBUG)) {
 450             logger.log(Level.DEBUG, &quot;startRemoteConnectorServer&quot;,
 451                     Agent.getText(&quot;jmxremote.ConnectorBootstrap.starting&quot;) +
 452                     &quot;\n\t&quot; + PropertyNames.PORT + &quot;=&quot; + port +
 453                     (bindAddress == null ? &quot;&quot; : &quot;\n\t&quot; + PropertyNames.HOST + &quot;=&quot; + bindAddress) +
 454                     &quot;\n\t&quot; + PropertyNames.RMI_PORT + &quot;=&quot; + rmiPort +
 455                     &quot;\n\t&quot; + PropertyNames.USE_SSL + &quot;=&quot; + useSsl +
 456                     &quot;\n\t&quot; + PropertyNames.USE_REGISTRY_SSL + &quot;=&quot; + useRegistrySsl +
 457                     &quot;\n\t&quot; + PropertyNames.SSL_CONFIG_FILE_NAME + &quot;=&quot; + sslConfigFileName +
 458                     &quot;\n\t&quot; + PropertyNames.SSL_ENABLED_CIPHER_SUITES + &quot;=&quot; +
 459                     enabledCipherSuites +
 460                     &quot;\n\t&quot; + PropertyNames.SSL_ENABLED_PROTOCOLS + &quot;=&quot; +
 461                     enabledProtocols +
 462                     &quot;\n\t&quot; + PropertyNames.SSL_NEED_CLIENT_AUTH + &quot;=&quot; +
 463                     sslNeedClientAuth +
 464                     &quot;\n\t&quot; + PropertyNames.USE_AUTHENTICATION + &quot;=&quot; +
 465                     useAuthentication +
 466                     (useAuthentication ? (loginConfigName == null ? (&quot;\n\t&quot; + PropertyNames.PASSWORD_FILE_NAME + &quot;=&quot; +
 467                     passwordFileName) : (&quot;\n\t&quot; + PropertyNames.LOGIN_CONFIG_NAME + &quot;=&quot; +
 468                     loginConfigName)) : &quot;\n\t&quot; +
 469                     Agent.getText(&quot;jmxremote.ConnectorBootstrap.noAuthentication&quot;)) +
 470                     (useAuthentication ? (&quot;\n\t&quot; + PropertyNames.ACCESS_FILE_NAME + &quot;=&quot; +
 471                     accessFileName) : &quot;&quot;) +
 472                     &quot;&quot;);
 473         }
 474 
 475         final MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
 476         JMXConnectorServer cs = null;
 477         JMXServiceURL url = null;
 478         try {
 479             final JMXConnectorServerData data = exportMBeanServer(
 480                     mbs, port, rmiPort, useSsl, useRegistrySsl,
 481                     sslConfigFileName, enabledCipherSuitesList,
 482                     enabledProtocolsList, sslNeedClientAuth,
 483                     useAuthentication, loginConfigName,
 484                     passwordFileName, shouldHashPasswords, accessFileName, bindAddress, jmxRmiFilter);
 485             cs = data.jmxConnectorServer;
 486             url = data.jmxRemoteURL;
 487             config(&quot;startRemoteConnectorServer&quot;,
 488                    Agent.getText(&quot;jmxremote.ConnectorBootstrap.ready&quot;,
 489                    url.toString()));
 490         } catch (Exception e) {
 491             throw new AgentConfigurationError(AGENT_EXCEPTION, e, e.toString());
 492         }
 493         try {
 494             // Export remote connector address and associated configuration
 495             // properties to the instrumentation buffer.
 496             Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();
 497             properties.put(&quot;remoteAddress&quot;, url.toString());
 498             properties.put(&quot;authenticate&quot;, useAuthenticationStr);
 499             properties.put(&quot;ssl&quot;, useSslStr);
 500             properties.put(&quot;sslRegistry&quot;, useRegistrySslStr);
 501             properties.put(&quot;sslNeedClientAuth&quot;, sslNeedClientAuthStr);
 502             ConnectorAddressLink.exportRemote(properties);
 503         } catch (Exception e) {
 504             // Remote connector server started but unable to export remote
 505             // connector address and associated configuration properties to
 506             // the instrumentation buffer - non-fatal error.
 507             config(&quot;startRemoteConnectorServer&quot;, e);
 508         }
 509         return cs;
 510     }
 511 
 512     /*
 513      * Creates and starts a RMI Connector Server for &quot;local&quot; monitoring
 514      * and management.
 515      */
 516     public static JMXConnectorServer startLocalConnectorServer() {
 517         // Ensure cryptographically strong random number generater used
 518         // to choose the object number - see java.rmi.server.ObjID
 519         System.setProperty(&quot;java.rmi.server.randomIDs&quot;, &quot;true&quot;);
 520 
 521         // This RMI server should not keep the VM alive
 522         Map&lt;String, Object&gt; env = new HashMap&lt;&gt;();
 523         env.put(RMIExporter.EXPORTER_ATTRIBUTE, new PermanentExporter());
 524         env.put(RMIConnectorServer.CREDENTIALS_FILTER_PATTERN, String.class.getName() + &quot;;!*&quot;);
 525 
 526         // The local connector server need only be available via the
 527         // loopback connection.
 528         String localhost = &quot;localhost&quot;;
 529         InetAddress lh = null;
 530         try {
 531             lh = InetAddress.getByName(localhost);
 532             localhost = lh.getHostAddress();
 533         } catch (UnknownHostException x) {
 534         }
 535 
 536         // localhost unknown or (somehow) didn&#39;t resolve to
 537         // a loopback address.
 538         if (lh == null || !lh.isLoopbackAddress()) {
 539             localhost = &quot;127.0.0.1&quot;;
 540         }
 541 
 542         MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
<a name="3" id="anc3"></a>

 543         try {
<a name="4" id="anc4"></a><span class="line-modified"> 544             JMXServiceURL url = new JMXServiceURL(&quot;rmi&quot;, localhost, 0);</span>
<span class="line-modified"> 545             // Do we accept connections from local interfaces only?</span>
<span class="line-removed"> 546             Properties props = Agent.getManagementProperties();</span>
<span class="line-removed"> 547             if (props ==  null) {</span>
 548                 props = new Properties();
 549             }
<a name="5" id="anc5"></a>





















 550             String useLocalOnlyStr = props.getProperty(
 551                     PropertyNames.USE_LOCAL_ONLY, DefaultValues.USE_LOCAL_ONLY);
 552             boolean useLocalOnly = Boolean.valueOf(useLocalOnlyStr).booleanValue();
 553             if (useLocalOnly) {
 554                 env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,
 555                         new LocalRMIServerSocketFactory());
 556             }
 557             JMXConnectorServer server =
 558                     JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
 559             server.start();
 560             return server;
 561         } catch (Exception e) {
 562             throw new AgentConfigurationError(AGENT_EXCEPTION, e, e.toString());
 563         }
 564     }
 565 
 566     private static void checkPasswordFile(String passwordFileName) {
 567         if (passwordFileName == null || passwordFileName.length() == 0) {
 568             throw new AgentConfigurationError(PASSWORD_FILE_NOT_SET);
 569         }
 570         File file = new File(passwordFileName);
 571         if (!file.exists()) {
 572             throw new AgentConfigurationError(PASSWORD_FILE_NOT_FOUND, passwordFileName);
 573         }
 574 
 575         if (!file.canRead()) {
 576             throw new AgentConfigurationError(PASSWORD_FILE_NOT_READABLE, passwordFileName);
 577         }
 578 
 579         if(!file.canWrite() &amp;&amp; PropertyNames.HASH_PASSWORDS.equalsIgnoreCase(&quot;true&quot;)) {
 580             logger.log(Level.WARNING, &quot;&quot;);
 581         }
 582 
 583         FileSystem fs = FileSystem.open();
 584         try {
 585             if (fs.supportsFileSecurity(file)) {
 586                 if (!fs.isAccessUserOnly(file)) {
 587                     final String msg = Agent.getText(&quot;jmxremote.ConnectorBootstrap.password.readonly&quot;,
 588                             passwordFileName);
 589                     config(&quot;startRemoteConnectorServer&quot;, msg);
 590                     throw new AgentConfigurationError(PASSWORD_FILE_ACCESS_NOT_RESTRICTED,
 591                             passwordFileName);
 592                 }
 593             }
 594         } catch (IOException e) {
 595             throw new AgentConfigurationError(PASSWORD_FILE_READ_FAILED,
 596                     e, passwordFileName);
 597         }
 598     }
 599 
 600     private static void checkAccessFile(String accessFileName) {
 601         if (accessFileName == null || accessFileName.length() == 0) {
 602             throw new AgentConfigurationError(ACCESS_FILE_NOT_SET);
 603         }
 604         File file = new File(accessFileName);
 605         if (!file.exists()) {
 606             throw new AgentConfigurationError(ACCESS_FILE_NOT_FOUND, accessFileName);
 607         }
 608 
 609         if (!file.canRead()) {
 610             throw new AgentConfigurationError(ACCESS_FILE_NOT_READABLE, accessFileName);
 611         }
 612     }
 613 
 614     private static void checkRestrictedFile(String restrictedFileName) {
 615         if (restrictedFileName == null || restrictedFileName.length() == 0) {
 616             throw new AgentConfigurationError(FILE_NOT_SET);
 617         }
 618         File file = new File(restrictedFileName);
 619         if (!file.exists()) {
 620             throw new AgentConfigurationError(FILE_NOT_FOUND, restrictedFileName);
 621         }
 622         if (!file.canRead()) {
 623             throw new AgentConfigurationError(FILE_NOT_READABLE, restrictedFileName);
 624         }
 625         FileSystem fs = FileSystem.open();
 626         try {
 627             if (fs.supportsFileSecurity(file)) {
 628                 if (!fs.isAccessUserOnly(file)) {
 629                     final String msg = Agent.getText(
 630                             &quot;jmxremote.ConnectorBootstrap.file.readonly&quot;,
 631                             restrictedFileName);
 632                     config(&quot;startRemoteConnectorServer&quot;, msg);
 633                     throw new AgentConfigurationError(
 634                             FILE_ACCESS_NOT_RESTRICTED, restrictedFileName);
 635                 }
 636             }
 637         } catch (IOException e) {
 638             throw new AgentConfigurationError(
 639                     FILE_READ_FAILED, e, restrictedFileName);
 640         }
 641     }
 642 
 643     /**
 644      * Compute the full path name for a default file.
 645      * @param basename basename (with extension) of the default file.
 646      * @return ${JRE}/conf/management/${basename}
 647      **/
 648     private static String getDefaultFileName(String basename) {
 649         final String fileSeparator = File.separator;
 650         return System.getProperty(&quot;java.home&quot;) + fileSeparator + &quot;conf&quot; +
 651                 fileSeparator + &quot;management&quot; + fileSeparator +
 652                 basename;
 653     }
 654 
 655     private static SslRMIServerSocketFactory createSslRMIServerSocketFactory(
 656             String sslConfigFileName,
 657             String[] enabledCipherSuites,
 658             String[] enabledProtocols,
 659             boolean sslNeedClientAuth,
 660             String bindAddress) {
 661         if (sslConfigFileName == null) {
 662             return new HostAwareSslSocketFactory(
 663                     enabledCipherSuites,
 664                     enabledProtocols,
 665                     sslNeedClientAuth, bindAddress);
 666         } else {
 667             checkRestrictedFile(sslConfigFileName);
 668             try {
 669                 // Load the SSL keystore properties from the config file
 670                 Properties p = new Properties();
 671                 try (InputStream in = new FileInputStream(sslConfigFileName)) {
 672                     BufferedInputStream bin = new BufferedInputStream(in);
 673                     p.load(bin);
 674                 }
 675                 String keyStore =
 676                         p.getProperty(&quot;javax.net.ssl.keyStore&quot;);
 677                 String keyStorePassword =
 678                         p.getProperty(&quot;javax.net.ssl.keyStorePassword&quot;, &quot;&quot;);
 679                 String trustStore =
 680                         p.getProperty(&quot;javax.net.ssl.trustStore&quot;);
 681                 String trustStorePassword =
 682                         p.getProperty(&quot;javax.net.ssl.trustStorePassword&quot;, &quot;&quot;);
 683 
 684                 char[] keyStorePasswd = null;
 685                 if (keyStorePassword.length() != 0) {
 686                     keyStorePasswd = keyStorePassword.toCharArray();
 687                 }
 688 
 689                 char[] trustStorePasswd = null;
 690                 if (trustStorePassword.length() != 0) {
 691                     trustStorePasswd = trustStorePassword.toCharArray();
 692                 }
 693 
 694                 KeyStore ks = null;
 695                 if (keyStore != null) {
 696                     ks = KeyStore.getInstance(KeyStore.getDefaultType());
 697                     try (FileInputStream ksfis = new FileInputStream(keyStore)) {
 698                         ks.load(ksfis, keyStorePasswd);
 699                     }
 700                 }
 701                 KeyManagerFactory kmf = KeyManagerFactory.getInstance(
 702                         KeyManagerFactory.getDefaultAlgorithm());
 703                 kmf.init(ks, keyStorePasswd);
 704 
 705                 KeyStore ts = null;
 706                 if (trustStore != null) {
 707                     ts = KeyStore.getInstance(KeyStore.getDefaultType());
 708                     try (FileInputStream tsfis = new FileInputStream(trustStore)) {
 709                         ts.load(tsfis, trustStorePasswd);
 710                     }
 711                 }
 712                 TrustManagerFactory tmf = TrustManagerFactory.getInstance(
 713                         TrustManagerFactory.getDefaultAlgorithm());
 714                 tmf.init(ts);
 715 
 716                 SSLContext ctx = SSLContext.getInstance(&quot;SSL&quot;);
 717                 ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
 718 
 719                 return new HostAwareSslSocketFactory(
 720                         ctx,
 721                         enabledCipherSuites,
 722                         enabledProtocols,
 723                         sslNeedClientAuth, bindAddress);
 724             } catch (Exception e) {
 725                 throw new AgentConfigurationError(AGENT_EXCEPTION, e, e.toString());
 726             }
 727         }
 728     }
 729 
 730     private static JMXConnectorServerData exportMBeanServer(
 731             MBeanServer mbs,
 732             int port,
 733             int rmiPort,
 734             boolean useSsl,
 735             boolean useRegistrySsl,
 736             String sslConfigFileName,
 737             String[] enabledCipherSuites,
 738             String[] enabledProtocols,
 739             boolean sslNeedClientAuth,
 740             boolean useAuthentication,
 741             String loginConfigName,
 742             String passwordFileName,
 743             boolean shouldHashPasswords,
 744             String accessFileName,
 745             String bindAddress,
 746             String jmxRmiFilter)
 747             throws IOException, MalformedURLException {
 748 
 749         /* Make sure we use non-guessable RMI object IDs.  Otherwise
 750          * attackers could hijack open connections by guessing their
 751          * IDs.  */
 752         System.setProperty(&quot;java.rmi.server.randomIDs&quot;, &quot;true&quot;);
 753 
 754         JMXServiceURL url = new JMXServiceURL(&quot;rmi&quot;, bindAddress, rmiPort);
 755 
 756         Map&lt;String, Object&gt; env = new HashMap&lt;&gt;();
 757 
 758         PermanentExporter exporter = new PermanentExporter();
 759 
 760         env.put(RMIExporter.EXPORTER_ATTRIBUTE, exporter);
 761         env.put(RMIConnectorServer.CREDENTIALS_FILTER_PATTERN, String.class.getName() + &quot;;!*&quot;);
 762 
 763         if(jmxRmiFilter != null &amp;&amp; !jmxRmiFilter.isEmpty()) {
 764             env.put(RMIConnectorServer.SERIAL_FILTER_PATTERN, jmxRmiFilter);
 765         }
 766 
 767         boolean useSocketFactory = bindAddress != null &amp;&amp; !useSsl;
 768 
 769         if (useAuthentication) {
 770             if (loginConfigName != null) {
 771                 env.put(&quot;jmx.remote.x.login.config&quot;, loginConfigName);
 772             }
 773             if (passwordFileName != null) {
 774                 env.put(&quot;jmx.remote.x.password.file&quot;, passwordFileName);
 775             }
 776             if (shouldHashPasswords) {
 777                 env.put(&quot;jmx.remote.x.password.toHashes&quot;, &quot;true&quot;);
 778             }
 779 
 780             env.put(&quot;jmx.remote.x.access.file&quot;, accessFileName);
 781 
 782             if (env.get(&quot;jmx.remote.x.password.file&quot;) != null ||
 783                     env.get(&quot;jmx.remote.x.login.config&quot;) != null) {
 784                 env.put(JMXConnectorServer.AUTHENTICATOR,
 785                         new AccessFileCheckerAuthenticator(env));
 786             }
 787         }
 788 
 789         RMIClientSocketFactory csf = null;
 790         RMIServerSocketFactory ssf = null;
 791 
 792         if (useSsl || useRegistrySsl) {
 793             csf = new SslRMIClientSocketFactory();
 794             ssf = createSslRMIServerSocketFactory(
 795                     sslConfigFileName, enabledCipherSuites,
 796                     enabledProtocols, sslNeedClientAuth, bindAddress);
 797         }
 798 
 799         if (useSsl) {
 800             env.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE,
 801                     csf);
 802             env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,
 803                     ssf);
 804         }
 805 
 806         if (useSocketFactory) {
 807             ssf = new HostAwareSocketFactory(bindAddress);
 808             env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,
 809                     ssf);
 810         }
 811 
 812         JMXConnectorServer connServer = null;
 813         try {
 814             connServer =
 815                     JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
 816             connServer.start();
 817         } catch (IOException e) {
 818             if (connServer == null || connServer.getAddress() == null) {
 819                 throw new AgentConfigurationError(CONNECTOR_SERVER_IO_ERROR,
 820                         e, url.toString());
 821             } else {
 822                 throw new AgentConfigurationError(CONNECTOR_SERVER_IO_ERROR,
 823                         e, connServer.getAddress().toString());
 824             }
 825         }
 826 
 827         if (useRegistrySsl) {
 828             registry =
 829                     new SingleEntryRegistry(port, csf, ssf,
 830                     &quot;jmxrmi&quot;, exporter.firstExported);
 831         } else if (useSocketFactory) {
 832             registry =
 833                     new SingleEntryRegistry(port, csf, ssf,
 834                     &quot;jmxrmi&quot;, exporter.firstExported);
 835         } else {
 836             registry =
 837                     new SingleEntryRegistry(port,
 838                     &quot;jmxrmi&quot;, exporter.firstExported);
 839         }
 840 
 841 
 842         int registryPort =
 843             ((UnicastRef) ((RemoteObject) registry).getRef()).getLiveRef().getPort();
 844         String jmxUrlStr =  String.format(&quot;service:jmx:rmi:///jndi/rmi://%s:%d/jmxrmi&quot;,
 845                                            url.getHost(), registryPort);
 846         JMXServiceURL remoteURL = new JMXServiceURL(jmxUrlStr);
 847 
 848         /* Our exporter remembers the first object it was asked to
 849         export, which will be an RMIServerImpl appropriate for
 850         publication in our special registry.  We could
 851         alternatively have constructed the RMIServerImpl explicitly
 852         and then constructed an RMIConnectorServer passing it as a
 853         parameter, but that&#39;s quite a bit more verbose and pulls in
 854         lots of knowledge of the RMI connector.  */
 855 
 856         return new JMXConnectorServerData(connServer, remoteURL);
 857     }
 858 
 859     /**
 860      * This class cannot be instantiated.
 861      **/
 862     private ConnectorBootstrap() {
 863     }
 864 
 865     private static final Logger logger =
 866         System.getLogger(ConnectorBootstrap.class.getPackageName());
 867     private static void config(String func, String msg) {
 868         logger.log(Level.DEBUG, msg);
 869     }
 870 
 871     private static void config(String func, Throwable t) {
 872         logger.log(Level.DEBUG, &quot;ConnectorBootstrap::&quot; + func, t);
 873     }
 874 
 875     private static void config(String func, String msg, Throwable t) {
 876         logger.log(Level.DEBUG, msg, t);
 877     }
 878 
 879     private static class HostAwareSocketFactory implements RMIServerSocketFactory {
 880 
 881         private final String bindAddress;
 882 
 883         private HostAwareSocketFactory(String bindAddress) {
 884              this.bindAddress = bindAddress;
 885         }
 886 
 887         @Override
 888         public ServerSocket createServerSocket(int port) throws IOException {
 889             if (bindAddress == null) {
 890                 return new ServerSocket(port);
 891             } else {
 892                 try {
 893                     InetAddress addr = InetAddress.getByName(bindAddress);
 894                     return new ServerSocket(port, 0, addr);
 895                 } catch (UnknownHostException e) {
 896                     return new ServerSocket(port);
 897                 }
 898             }
 899         }
 900     }
 901 
 902     private static class HostAwareSslSocketFactory extends SslRMIServerSocketFactory {
 903 
 904         private final String bindAddress;
 905         private final String[] enabledCipherSuites;
 906         private final String[] enabledProtocols;
 907         private final boolean needClientAuth;
 908         private final SSLContext context;
 909 
 910         private HostAwareSslSocketFactory(String[] enabledCipherSuites,
 911                                           String[] enabledProtocols,
 912                                           boolean sslNeedClientAuth,
 913                                           String bindAddress) throws IllegalArgumentException {
 914             this(null, enabledCipherSuites, enabledProtocols, sslNeedClientAuth, bindAddress);
 915         }
 916 
 917         private HostAwareSslSocketFactory(SSLContext ctx,
 918                                           String[] enabledCipherSuites,
 919                                           String[] enabledProtocols,
 920                                           boolean sslNeedClientAuth,
 921                                           String bindAddress) throws IllegalArgumentException {
 922             this.context = ctx;
 923             this.bindAddress = bindAddress;
 924             this.enabledProtocols = enabledProtocols;
 925             this.enabledCipherSuites = enabledCipherSuites;
 926             this.needClientAuth = sslNeedClientAuth;
 927             checkValues(ctx, enabledCipherSuites, enabledProtocols);
 928         }
 929 
 930         @Override
 931         public ServerSocket createServerSocket(int port) throws IOException {
 932             if (bindAddress != null) {
 933                 try {
 934                     InetAddress addr = InetAddress.getByName(bindAddress);
 935                     return new SslServerSocket(port, 0, addr, context,
 936                                                enabledCipherSuites, enabledProtocols, needClientAuth);
 937                 } catch (UnknownHostException e) {
 938                     return new SslServerSocket(port, context,
 939                                                enabledCipherSuites, enabledProtocols, needClientAuth);
 940                 }
 941             } else {
 942                 return new SslServerSocket(port, context,
 943                                            enabledCipherSuites, enabledProtocols, needClientAuth);
 944             }
 945         }
 946 
 947         private static void checkValues(SSLContext context,
 948                                         String[] enabledCipherSuites,
 949                                         String[] enabledProtocols) throws IllegalArgumentException {
 950             // Force the initialization of the default at construction time,
 951             // rather than delaying it to the first time createServerSocket()
 952             // is called.
 953             //
 954             final SSLSocketFactory sslSocketFactory =
 955                     context == null ?
 956                         (SSLSocketFactory)SSLSocketFactory.getDefault() : context.getSocketFactory();
 957             SSLSocket sslSocket = null;
 958             if (enabledCipherSuites != null || enabledProtocols != null) {
 959                 try {
 960                     sslSocket = (SSLSocket) sslSocketFactory.createSocket();
 961                 } catch (Exception e) {
 962                     final String msg = &quot;Unable to check if the cipher suites &quot; +
 963                             &quot;and protocols to enable are supported&quot;;
 964                     throw (IllegalArgumentException)
 965                     new IllegalArgumentException(msg).initCause(e);
 966                 }
 967             }
 968 
 969             // Check if all the cipher suites and protocol versions to enable
 970             // are supported by the underlying SSL/TLS implementation and if
 971             // true create lists from arrays.
 972             //
 973             if (enabledCipherSuites != null) {
 974                 sslSocket.setEnabledCipherSuites(enabledCipherSuites);
 975             }
 976             if (enabledProtocols != null) {
 977                 sslSocket.setEnabledProtocols(enabledProtocols);
 978             }
 979         }
 980     }
 981 
 982     private static class SslServerSocket extends ServerSocket {
 983 
 984         private static SSLSocketFactory defaultSSLSocketFactory;
 985         private final String[] enabledCipherSuites;
 986         private final String[] enabledProtocols;
 987         private final boolean needClientAuth;
 988         private final SSLContext context;
 989 
 990         private SslServerSocket(int port,
 991                                 SSLContext ctx,
 992                                 String[] enabledCipherSuites,
 993                                 String[] enabledProtocols,
 994                                 boolean needClientAuth) throws IOException {
 995             super(port);
 996             this.enabledProtocols = enabledProtocols;
 997             this.enabledCipherSuites = enabledCipherSuites;
 998             this.needClientAuth = needClientAuth;
 999             this.context = ctx;
1000         }
1001 
1002         private SslServerSocket(int port,
1003                                 int backlog,
1004                                 InetAddress bindAddr,
1005                                 SSLContext ctx,
1006                                 String[] enabledCipherSuites,
1007                                 String[] enabledProtocols,
1008                                 boolean needClientAuth) throws IOException {
1009             super(port, backlog, bindAddr);
1010             this.enabledProtocols = enabledProtocols;
1011             this.enabledCipherSuites = enabledCipherSuites;
1012             this.needClientAuth = needClientAuth;
1013             this.context = ctx;
1014         }
1015 
1016         @Override
1017         public Socket accept() throws IOException {
1018             final SSLSocketFactory sslSocketFactory =
1019                     context == null ?
1020                         getDefaultSSLSocketFactory() : context.getSocketFactory();
1021             Socket socket = super.accept();
1022             SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
1023                     socket, socket.getInetAddress().getHostName(),
1024                     socket.getPort(), true);
1025             sslSocket.setUseClientMode(false);
1026             if (enabledCipherSuites != null) {
1027                 sslSocket.setEnabledCipherSuites(enabledCipherSuites);
1028             }
1029             if (enabledProtocols != null) {
1030                 sslSocket.setEnabledProtocols(enabledProtocols);
1031             }
1032             sslSocket.setNeedClientAuth(needClientAuth);
1033             return sslSocket;
1034         }
1035 
1036         private static synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
1037             if (defaultSSLSocketFactory == null) {
1038                 defaultSSLSocketFactory = (SSLSocketFactory)SSLSocketFactory.getDefault();
1039                 return defaultSSLSocketFactory;
1040             } else {
1041                 return defaultSSLSocketFactory;
1042             }
1043         }
1044 
1045     }
1046 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
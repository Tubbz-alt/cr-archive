<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.management.agent/share/classes/sun/management/jmxremote/ConnectorBootstrap.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.management.jmxremote;
  27 
  28 import java.lang.System.Logger;
  29 import java.lang.System.Logger.Level;
  30 import java.io.BufferedInputStream;
  31 import java.io.File;
  32 import java.io.FileInputStream;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.ObjectInputFilter;
  36 import java.lang.management.ManagementFactory;
  37 import java.net.InetAddress;
  38 import java.net.MalformedURLException;
  39 import java.net.Socket;
  40 import java.net.ServerSocket;
  41 import java.net.UnknownHostException;
  42 import java.rmi.NoSuchObjectException;
  43 import java.rmi.Remote;
  44 import java.rmi.RemoteException;
  45 import java.rmi.registry.Registry;
  46 import java.rmi.server.RMIClientSocketFactory;
  47 import java.rmi.server.RMIServerSocketFactory;
  48 import java.rmi.server.RemoteObject;
  49 import java.rmi.server.UnicastRemoteObject;
  50 import java.security.KeyStore;
  51 import java.security.Principal;
  52 import java.util.HashMap;
  53 import java.util.HashSet;
  54 import java.util.Map;
  55 import java.util.Properties;
  56 import java.util.Set;
  57 import java.util.StringTokenizer;
  58 
  59 import javax.management.MBeanServer;
  60 import javax.management.remote.JMXAuthenticator;
  61 import javax.management.remote.JMXConnectorServer;
  62 import javax.management.remote.JMXConnectorServerFactory;
  63 import javax.management.remote.JMXServiceURL;
  64 import javax.management.remote.rmi.RMIConnectorServer;
  65 import javax.net.ssl.KeyManagerFactory;
  66 import javax.net.ssl.SSLContext;
  67 import javax.net.ssl.SSLSocket;
  68 import javax.net.ssl.SSLSocketFactory;
  69 import javax.net.ssl.TrustManagerFactory;
  70 import javax.rmi.ssl.SslRMIClientSocketFactory;
  71 import javax.rmi.ssl.SslRMIServerSocketFactory;
  72 import javax.security.auth.Subject;
  73 import com.sun.jmx.remote.internal.rmi.RMIExporter;
  74 import com.sun.jmx.remote.security.JMXPluggableAuthenticator;
  75 import jdk.internal.agent.Agent;
  76 import jdk.internal.agent.AgentConfigurationError;
  77 import static jdk.internal.agent.AgentConfigurationError.*;
  78 import jdk.internal.agent.ConnectorAddressLink;
  79 import jdk.internal.agent.FileSystem;
  80 import sun.rmi.server.UnicastRef;
  81 import sun.rmi.server.UnicastServerRef;
  82 import sun.rmi.server.UnicastServerRef2;
  83 import sun.rmi.transport.LiveRef;
  84 
  85 /**
  86  * This class initializes and starts the RMIConnectorServer for JSR 163
  87  * JMX Monitoring.
  88  **/
  89 public final class ConnectorBootstrap {
  90 
  91     /**
  92      * Default values for JMX configuration properties.
  93      **/
  94     public static interface DefaultValues {
  95 
  96         public static final String PORT = &quot;0&quot;;
  97         public static final String CONFIG_FILE_NAME = &quot;management.properties&quot;;
  98         public static final String USE_SSL = &quot;true&quot;;
  99         public static final String USE_LOCAL_ONLY = &quot;true&quot;;
 100         public static final String USE_REGISTRY_SSL = &quot;false&quot;;
 101         public static final String USE_AUTHENTICATION = &quot;true&quot;;
 102         public static final String PASSWORD_FILE_NAME = &quot;jmxremote.password&quot;;
 103         public static final String HASH_PASSWORDS = &quot;true&quot;;
 104         public static final String ACCESS_FILE_NAME = &quot;jmxremote.access&quot;;
 105         public static final String SSL_NEED_CLIENT_AUTH = &quot;false&quot;;
 106     }
 107 
 108     /**
 109      * Names of JMX configuration properties.
 110      **/
 111     public static interface PropertyNames {
 112 
 113         public static final String PORT =
 114                 &quot;com.sun.management.jmxremote.port&quot;;
 115         public static final String HOST =
 116                 &quot;com.sun.management.jmxremote.host&quot;;
 117         public static final String RMI_PORT =
 118                 &quot;com.sun.management.jmxremote.rmi.port&quot;;
<a name="2" id="anc2"></a><span class="line-added"> 119         public static final String LOCAL_PORT =</span>
<span class="line-added"> 120                 &quot;com.sun.management.jmxremote.local.port&quot;;</span>
 121         public static final String CONFIG_FILE_NAME =
 122                 &quot;com.sun.management.config.file&quot;;
 123         public static final String USE_LOCAL_ONLY =
 124                 &quot;com.sun.management.jmxremote.local.only&quot;;
 125         public static final String USE_SSL =
 126                 &quot;com.sun.management.jmxremote.ssl&quot;;
 127         public static final String USE_REGISTRY_SSL =
 128                 &quot;com.sun.management.jmxremote.registry.ssl&quot;;
 129         public static final String USE_AUTHENTICATION =
 130                 &quot;com.sun.management.jmxremote.authenticate&quot;;
 131         public static final String PASSWORD_FILE_NAME =
 132                 &quot;com.sun.management.jmxremote.password.file&quot;;
 133         public static final String HASH_PASSWORDS
 134                 = &quot;com.sun.management.jmxremote.password.toHashes&quot;;
 135         public static final String ACCESS_FILE_NAME =
 136                 &quot;com.sun.management.jmxremote.access.file&quot;;
 137         public static final String LOGIN_CONFIG_NAME =
 138                 &quot;com.sun.management.jmxremote.login.config&quot;;
 139         public static final String SSL_ENABLED_CIPHER_SUITES =
 140                 &quot;com.sun.management.jmxremote.ssl.enabled.cipher.suites&quot;;
 141         public static final String SSL_ENABLED_PROTOCOLS =
 142                 &quot;com.sun.management.jmxremote.ssl.enabled.protocols&quot;;
 143         public static final String SSL_NEED_CLIENT_AUTH =
 144                 &quot;com.sun.management.jmxremote.ssl.need.client.auth&quot;;
 145         public static final String SSL_CONFIG_FILE_NAME =
 146                 &quot;com.sun.management.jmxremote.ssl.config.file&quot;;
 147         public static final String SERIAL_FILTER_PATTERN =
 148                 &quot;com.sun.management.jmxremote.serial.filter.pattern&quot;;
 149     }
 150 
 151     /**
 152      * JMXConnectorServer associated data.
 153      */
 154     private static class JMXConnectorServerData {
 155 
 156         public JMXConnectorServerData(
 157                 JMXConnectorServer jmxConnectorServer,
 158                 JMXServiceURL jmxRemoteURL) {
 159             this.jmxConnectorServer = jmxConnectorServer;
 160             this.jmxRemoteURL = jmxRemoteURL;
 161         }
 162         JMXConnectorServer jmxConnectorServer;
 163         JMXServiceURL jmxRemoteURL;
 164     }
 165 
 166     /**
 167      * &lt;p&gt;Prevents our RMI server objects from keeping the JVM alive.&lt;/p&gt;
 168      *
 169      * &lt;p&gt;We use a private interface in Sun&#39;s JMX Remote API implementation
 170      * that allows us to specify how to export RMI objects.  We do so using
 171      * UnicastServerRef, a class in Sun&#39;s RMI implementation.  This is all
 172      * non-portable, of course, so this is only valid because we are inside
 173      * Sun&#39;s JRE.&lt;/p&gt;
 174      *
 175      * &lt;p&gt;Objects are exported using {@link
 176      * UnicastServerRef#exportObject(Remote, Object, boolean)}.  The
 177      * boolean parameter is called &lt;code&gt;permanent&lt;/code&gt; and means
 178      * both that the object is not eligible for Distributed Garbage
 179      * Collection, and that its continued existence will not prevent
 180      * the JVM from exiting.  It is the latter semantics we want (we
 181      * already have the former because of the way the JMX Remote API
 182      * works).  Hence the somewhat misleading name of this class.&lt;/p&gt;
 183      */
 184     private static class PermanentExporter implements RMIExporter {
 185 
 186         public Remote exportObject(Remote obj,
 187                 int port,
 188                 RMIClientSocketFactory csf,
 189                 RMIServerSocketFactory ssf,
 190                 ObjectInputFilter filter)
 191                 throws RemoteException {
 192 
 193             synchronized (this) {
 194                 if (firstExported == null) {
 195                     firstExported = obj;
 196                 }
 197             }
 198 
 199             final UnicastServerRef ref;
 200             if (csf == null &amp;&amp; ssf == null) {
 201                 ref = new UnicastServerRef(new LiveRef(port), filter);
 202             } else {
 203                 ref = new UnicastServerRef2(port, csf, ssf, filter);
 204             }
 205             return ref.exportObject(obj, null, true);
 206         }
 207 
 208         // Nothing special to be done for this case
 209         public boolean unexportObject(Remote obj, boolean force)
 210                 throws NoSuchObjectException {
 211             return UnicastRemoteObject.unexportObject(obj, force);
 212         }
 213         Remote firstExported;
 214     }
 215 
 216     /**
 217      * This JMXAuthenticator wraps the JMXPluggableAuthenticator and verifies
 218      * that at least one of the principal names contained in the authenticated
 219      * Subject is present in the access file.
 220      */
 221     private static class AccessFileCheckerAuthenticator
 222             implements JMXAuthenticator {
 223 
 224         public AccessFileCheckerAuthenticator(Map&lt;String, Object&gt; env) throws IOException {
 225             environment = env;
 226             accessFile = (String) env.get(&quot;jmx.remote.x.access.file&quot;);
 227             properties = propertiesFromFile(accessFile);
 228         }
 229 
 230         public Subject authenticate(Object credentials) {
 231             final JMXAuthenticator authenticator =
 232                     new JMXPluggableAuthenticator(environment);
 233             final Subject subject = authenticator.authenticate(credentials);
 234             checkAccessFileEntries(subject);
 235             return subject;
 236         }
 237 
 238         private void checkAccessFileEntries(Subject subject) {
 239             if (subject == null) {
 240                 throw new SecurityException(
 241                         &quot;Access denied! No matching entries found in &quot; +
 242                         &quot;the access file [&quot; + accessFile + &quot;] as the &quot; +
 243                         &quot;authenticated Subject is null&quot;);
 244             }
 245             final Set&lt;Principal&gt; principals = subject.getPrincipals();
 246             for (Principal p1: principals) {
 247                 if (properties.containsKey(p1.getName())) {
 248                     return;
 249                 }
 250             }
 251 
 252             final Set&lt;String&gt; principalsStr = new HashSet&lt;&gt;();
 253             for (Principal p2: principals) {
 254                 principalsStr.add(p2.getName());
 255             }
 256             throw new SecurityException(
 257                     &quot;Access denied! No entries found in the access file [&quot; +
 258                     accessFile + &quot;] for any of the authenticated identities &quot; +
 259                     principalsStr);
 260         }
 261 
 262         private static Properties propertiesFromFile(String fname)
 263                 throws IOException {
 264             Properties p = new Properties();
 265             if (fname == null) {
 266                 return p;
 267             }
 268             try (FileInputStream fin = new FileInputStream(fname)) {
 269                 p.load(fin);
 270             }
 271             return p;
 272         }
 273         private final Map&lt;String, Object&gt; environment;
 274         private final Properties properties;
 275         private final String accessFile;
 276     }
 277 
 278     // The variable below is here to support stop functionality
 279     // It would be overriten if you call startRemoteCommectionServer second
 280     // time. It&#39;s OK for now as logic in Agent.java forbids mutiple agents
 281     private static Registry registry = null;
 282 
 283     public static void unexportRegistry() {
 284         // Remove the entry from registry
 285         try {
 286             if (registry != null) {
 287                 UnicastRemoteObject.unexportObject(registry, true);
 288                 registry = null;
 289             }
 290         } catch(NoSuchObjectException ex) {
 291             // This exception can appears only if we attempt
 292             // to unexportRegistry second time. So it&#39;s safe
 293             // to ignore it without additional messages.
 294         }
 295     }
 296 
 297      /**
 298       * Initializes and starts the JMX Connector Server.
 299       * If the com.sun.management.jmxremote.port property is not defined,
 300       * simply return. Otherwise, attempts to load the config file, and
 301       * then calls {@link #startRemoteConnectorServer
 302       *                            (java.lang.String, java.util.Properties)}.
 303       *
 304       * This method is used by some jtreg tests.
 305       **/
 306       public static synchronized JMXConnectorServer initialize() {
 307 
 308          // Load a new management properties
 309          final Properties props = Agent.loadManagementProperties();
 310          if (props == null) {
 311               return null;
 312          }
 313 
 314          final String portStr = props.getProperty(PropertyNames.PORT);
 315          return startRemoteConnectorServer(portStr, props);
 316      }
 317 
 318     /**
 319      * This method is used by some jtreg tests.
 320      *
 321      * @see #startRemoteConnectorServer
 322      *             (String portStr, Properties props)
 323      */
 324     public static synchronized JMXConnectorServer initialize(String portStr, Properties props)  {
 325          return startRemoteConnectorServer(portStr, props);
 326     }
 327 
 328     /**
 329      * Initializes and starts a JMX Connector Server for remote
 330      * monitoring and management.
 331      **/
 332     public static synchronized JMXConnectorServer startRemoteConnectorServer(String portStr, Properties props) {
 333 
 334         // Get port number
 335         final int port;
 336         try {
 337             port = Integer.parseInt(portStr);
 338         } catch (NumberFormatException x) {
 339             throw new AgentConfigurationError(INVALID_JMXREMOTE_PORT, x, portStr);
 340         }
 341         if (port &lt; 0) {
 342             throw new AgentConfigurationError(INVALID_JMXREMOTE_PORT, portStr);
 343         }
 344 
 345         // User can specify a port to be used to export rmi object,
 346         // in order to simplify firewall rules
 347         // if port is not specified random one will be allocated.
 348         int rmiPort = 0;
 349         String rmiPortStr = props.getProperty(PropertyNames.RMI_PORT);
 350         try {
 351             if (rmiPortStr != null) {
 352                rmiPort = Integer.parseInt(rmiPortStr);
 353             }
 354         } catch (NumberFormatException x) {
 355             throw new AgentConfigurationError(INVALID_JMXREMOTE_RMI_PORT, x, rmiPortStr);
 356         }
 357         if (rmiPort &lt; 0) {
 358             throw new AgentConfigurationError(INVALID_JMXREMOTE_RMI_PORT, rmiPortStr);
 359         }
 360 
 361         // Do we use authentication?
 362         final String useAuthenticationStr =
 363                 props.getProperty(PropertyNames.USE_AUTHENTICATION,
 364                 DefaultValues.USE_AUTHENTICATION);
 365         final boolean useAuthentication =
 366                 Boolean.valueOf(useAuthenticationStr).booleanValue();
 367 
 368         // Do we use SSL?
 369         final String useSslStr =
 370                 props.getProperty(PropertyNames.USE_SSL,
 371                 DefaultValues.USE_SSL);
 372         final boolean useSsl =
 373                 Boolean.valueOf(useSslStr).booleanValue();
 374 
 375         // Do we use RMI Registry SSL?
 376         final String useRegistrySslStr =
 377                 props.getProperty(PropertyNames.USE_REGISTRY_SSL,
 378                 DefaultValues.USE_REGISTRY_SSL);
 379         final boolean useRegistrySsl =
 380                 Boolean.valueOf(useRegistrySslStr).booleanValue();
 381 
 382         final String enabledCipherSuites =
 383                 props.getProperty(PropertyNames.SSL_ENABLED_CIPHER_SUITES);
 384         String enabledCipherSuitesList[] = null;
 385         if (enabledCipherSuites != null) {
 386             StringTokenizer st = new StringTokenizer(enabledCipherSuites, &quot;,&quot;);
 387             int tokens = st.countTokens();
 388             enabledCipherSuitesList = new String[tokens];
 389             for (int i = 0; i &lt; tokens; i++) {
 390                 enabledCipherSuitesList[i] = st.nextToken();
 391             }
 392         }
 393 
 394         final String enabledProtocols =
 395                 props.getProperty(PropertyNames.SSL_ENABLED_PROTOCOLS);
 396         String enabledProtocolsList[] = null;
 397         if (enabledProtocols != null) {
 398             StringTokenizer st = new StringTokenizer(enabledProtocols, &quot;,&quot;);
 399             int tokens = st.countTokens();
 400             enabledProtocolsList = new String[tokens];
 401             for (int i = 0; i &lt; tokens; i++) {
 402                 enabledProtocolsList[i] = st.nextToken();
 403             }
 404         }
 405 
 406         final String sslNeedClientAuthStr =
 407                 props.getProperty(PropertyNames.SSL_NEED_CLIENT_AUTH,
 408                 DefaultValues.SSL_NEED_CLIENT_AUTH);
 409         final boolean sslNeedClientAuth =
 410                 Boolean.valueOf(sslNeedClientAuthStr).booleanValue();
 411 
 412         // Read SSL config file name
 413         final String sslConfigFileName =
 414                 props.getProperty(PropertyNames.SSL_CONFIG_FILE_NAME);
 415 
 416         String loginConfigName = null;
 417         String passwordFileName = null;
 418         boolean shouldHashPasswords = true;
 419         String accessFileName = null;
 420 
 421         // Initialize settings when authentication is active
 422         if (useAuthentication) {
 423 
 424             // Get non-default login configuration
 425             loginConfigName =
 426                     props.getProperty(PropertyNames.LOGIN_CONFIG_NAME);
 427 
 428             if (loginConfigName == null) {
 429                 // Get password file
 430                 passwordFileName =
 431                         props.getProperty(PropertyNames.PASSWORD_FILE_NAME,
 432                         getDefaultFileName(DefaultValues.PASSWORD_FILE_NAME));
 433                 String hashPasswords
 434                         = props.getProperty(PropertyNames.HASH_PASSWORDS,
 435                                 DefaultValues.HASH_PASSWORDS);
 436                 shouldHashPasswords = Boolean.parseBoolean(hashPasswords);
 437 
 438                 checkPasswordFile(passwordFileName);
 439             }
 440 
 441             // Get access file
 442             accessFileName = props.getProperty(PropertyNames.ACCESS_FILE_NAME,
 443                     getDefaultFileName(DefaultValues.ACCESS_FILE_NAME));
 444             checkAccessFile(accessFileName);
 445         }
 446 
 447         final String bindAddress =
 448                 props.getProperty(PropertyNames.HOST);
 449         final String jmxRmiFilter = props.getProperty(PropertyNames.SERIAL_FILTER_PATTERN);
 450 
 451         if (logger.isLoggable(Level.DEBUG)) {
 452             logger.log(Level.DEBUG, &quot;startRemoteConnectorServer&quot;,
 453                     Agent.getText(&quot;jmxremote.ConnectorBootstrap.starting&quot;) +
 454                     &quot;\n\t&quot; + PropertyNames.PORT + &quot;=&quot; + port +
 455                     (bindAddress == null ? &quot;&quot; : &quot;\n\t&quot; + PropertyNames.HOST + &quot;=&quot; + bindAddress) +
 456                     &quot;\n\t&quot; + PropertyNames.RMI_PORT + &quot;=&quot; + rmiPort +
 457                     &quot;\n\t&quot; + PropertyNames.USE_SSL + &quot;=&quot; + useSsl +
 458                     &quot;\n\t&quot; + PropertyNames.USE_REGISTRY_SSL + &quot;=&quot; + useRegistrySsl +
 459                     &quot;\n\t&quot; + PropertyNames.SSL_CONFIG_FILE_NAME + &quot;=&quot; + sslConfigFileName +
 460                     &quot;\n\t&quot; + PropertyNames.SSL_ENABLED_CIPHER_SUITES + &quot;=&quot; +
 461                     enabledCipherSuites +
 462                     &quot;\n\t&quot; + PropertyNames.SSL_ENABLED_PROTOCOLS + &quot;=&quot; +
 463                     enabledProtocols +
 464                     &quot;\n\t&quot; + PropertyNames.SSL_NEED_CLIENT_AUTH + &quot;=&quot; +
 465                     sslNeedClientAuth +
 466                     &quot;\n\t&quot; + PropertyNames.USE_AUTHENTICATION + &quot;=&quot; +
 467                     useAuthentication +
 468                     (useAuthentication ? (loginConfigName == null ? (&quot;\n\t&quot; + PropertyNames.PASSWORD_FILE_NAME + &quot;=&quot; +
 469                     passwordFileName) : (&quot;\n\t&quot; + PropertyNames.LOGIN_CONFIG_NAME + &quot;=&quot; +
 470                     loginConfigName)) : &quot;\n\t&quot; +
 471                     Agent.getText(&quot;jmxremote.ConnectorBootstrap.noAuthentication&quot;)) +
 472                     (useAuthentication ? (&quot;\n\t&quot; + PropertyNames.ACCESS_FILE_NAME + &quot;=&quot; +
 473                     accessFileName) : &quot;&quot;) +
 474                     &quot;&quot;);
 475         }
 476 
 477         final MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
 478         JMXConnectorServer cs = null;
 479         JMXServiceURL url = null;
 480         try {
 481             final JMXConnectorServerData data = exportMBeanServer(
 482                     mbs, port, rmiPort, useSsl, useRegistrySsl,
 483                     sslConfigFileName, enabledCipherSuitesList,
 484                     enabledProtocolsList, sslNeedClientAuth,
 485                     useAuthentication, loginConfigName,
 486                     passwordFileName, shouldHashPasswords, accessFileName, bindAddress, jmxRmiFilter);
 487             cs = data.jmxConnectorServer;
 488             url = data.jmxRemoteURL;
 489             config(&quot;startRemoteConnectorServer&quot;,
 490                    Agent.getText(&quot;jmxremote.ConnectorBootstrap.ready&quot;,
 491                    url.toString()));
 492         } catch (Exception e) {
 493             throw new AgentConfigurationError(AGENT_EXCEPTION, e, e.toString());
 494         }
 495         try {
 496             // Export remote connector address and associated configuration
 497             // properties to the instrumentation buffer.
 498             Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();
 499             properties.put(&quot;remoteAddress&quot;, url.toString());
 500             properties.put(&quot;authenticate&quot;, useAuthenticationStr);
 501             properties.put(&quot;ssl&quot;, useSslStr);
 502             properties.put(&quot;sslRegistry&quot;, useRegistrySslStr);
 503             properties.put(&quot;sslNeedClientAuth&quot;, sslNeedClientAuthStr);
 504             ConnectorAddressLink.exportRemote(properties);
 505         } catch (Exception e) {
 506             // Remote connector server started but unable to export remote
 507             // connector address and associated configuration properties to
 508             // the instrumentation buffer - non-fatal error.
 509             config(&quot;startRemoteConnectorServer&quot;, e);
 510         }
 511         return cs;
 512     }
 513 
 514     /*
 515      * Creates and starts a RMI Connector Server for &quot;local&quot; monitoring
 516      * and management.
 517      */
 518     public static JMXConnectorServer startLocalConnectorServer() {
 519         // Ensure cryptographically strong random number generater used
 520         // to choose the object number - see java.rmi.server.ObjID
 521         System.setProperty(&quot;java.rmi.server.randomIDs&quot;, &quot;true&quot;);
 522 
 523         // This RMI server should not keep the VM alive
 524         Map&lt;String, Object&gt; env = new HashMap&lt;&gt;();
 525         env.put(RMIExporter.EXPORTER_ATTRIBUTE, new PermanentExporter());
 526         env.put(RMIConnectorServer.CREDENTIALS_FILTER_PATTERN, String.class.getName() + &quot;;!*&quot;);
 527 
 528         // The local connector server need only be available via the
 529         // loopback connection.
 530         String localhost = &quot;localhost&quot;;
 531         InetAddress lh = null;
 532         try {
 533             lh = InetAddress.getByName(localhost);
 534             localhost = lh.getHostAddress();
 535         } catch (UnknownHostException x) {
 536         }
 537 
 538         // localhost unknown or (somehow) didn&#39;t resolve to
 539         // a loopback address.
 540         if (lh == null || !lh.isLoopbackAddress()) {
 541             localhost = &quot;127.0.0.1&quot;;
 542         }
 543 
 544         MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
<a name="3" id="anc3"></a><span class="line-added"> 545 </span>
<span class="line-added"> 546         Properties props = null;</span>
 547         try {
<a name="4" id="anc4"></a><span class="line-modified"> 548             props = Agent.getManagementProperties();</span>
<span class="line-modified"> 549             if (props == null) {</span>


 550                 props = new Properties();
 551             }
<a name="5" id="anc5"></a><span class="line-added"> 552         } catch (Exception e) {</span>
<span class="line-added"> 553             throw new AgentConfigurationError(AGENT_EXCEPTION, e, e.toString());</span>
<span class="line-added"> 554         }</span>
<span class="line-added"> 555 </span>
<span class="line-added"> 556         // User can specify a port to be used to start local connector server.</span>
<span class="line-added"> 557         // Random one will be allocated if port is not specified.</span>
<span class="line-added"> 558         int localPort = 0;</span>
<span class="line-added"> 559         String localPortStr = props.getProperty(PropertyNames.LOCAL_PORT);</span>
<span class="line-added"> 560         try {</span>
<span class="line-added"> 561             if (localPortStr != null) {</span>
<span class="line-added"> 562                 localPort = Integer.parseInt(localPortStr);</span>
<span class="line-added"> 563             }</span>
<span class="line-added"> 564         } catch (NumberFormatException x) {</span>
<span class="line-added"> 565             throw new AgentConfigurationError(INVALID_JMXREMOTE_LOCAL_PORT, x, localPortStr);</span>
<span class="line-added"> 566         }</span>
<span class="line-added"> 567         if (localPort &lt; 0) {</span>
<span class="line-added"> 568             throw new AgentConfigurationError(INVALID_JMXREMOTE_LOCAL_PORT, localPortStr);</span>
<span class="line-added"> 569         }</span>
<span class="line-added"> 570 </span>
<span class="line-added"> 571         try {</span>
<span class="line-added"> 572             JMXServiceURL url = new JMXServiceURL(&quot;rmi&quot;, localhost, localPort);</span>
<span class="line-added"> 573             // Do we accept connections from local interfaces only?</span>
 574             String useLocalOnlyStr = props.getProperty(
 575                     PropertyNames.USE_LOCAL_ONLY, DefaultValues.USE_LOCAL_ONLY);
 576             boolean useLocalOnly = Boolean.valueOf(useLocalOnlyStr).booleanValue();
 577             if (useLocalOnly) {
 578                 env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,
 579                         new LocalRMIServerSocketFactory());
 580             }
 581             JMXConnectorServer server =
 582                     JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
 583             server.start();
 584             return server;
 585         } catch (Exception e) {
 586             throw new AgentConfigurationError(AGENT_EXCEPTION, e, e.toString());
 587         }
 588     }
 589 
 590     private static void checkPasswordFile(String passwordFileName) {
 591         if (passwordFileName == null || passwordFileName.length() == 0) {
 592             throw new AgentConfigurationError(PASSWORD_FILE_NOT_SET);
 593         }
 594         File file = new File(passwordFileName);
 595         if (!file.exists()) {
 596             throw new AgentConfigurationError(PASSWORD_FILE_NOT_FOUND, passwordFileName);
 597         }
 598 
 599         if (!file.canRead()) {
 600             throw new AgentConfigurationError(PASSWORD_FILE_NOT_READABLE, passwordFileName);
 601         }
 602 
 603         if(!file.canWrite() &amp;&amp; PropertyNames.HASH_PASSWORDS.equalsIgnoreCase(&quot;true&quot;)) {
 604             logger.log(Level.WARNING, &quot;&quot;);
 605         }
 606 
 607         FileSystem fs = FileSystem.open();
 608         try {
 609             if (fs.supportsFileSecurity(file)) {
 610                 if (!fs.isAccessUserOnly(file)) {
 611                     final String msg = Agent.getText(&quot;jmxremote.ConnectorBootstrap.password.readonly&quot;,
 612                             passwordFileName);
 613                     config(&quot;startRemoteConnectorServer&quot;, msg);
 614                     throw new AgentConfigurationError(PASSWORD_FILE_ACCESS_NOT_RESTRICTED,
 615                             passwordFileName);
 616                 }
 617             }
 618         } catch (IOException e) {
 619             throw new AgentConfigurationError(PASSWORD_FILE_READ_FAILED,
 620                     e, passwordFileName);
 621         }
 622     }
 623 
 624     private static void checkAccessFile(String accessFileName) {
 625         if (accessFileName == null || accessFileName.length() == 0) {
 626             throw new AgentConfigurationError(ACCESS_FILE_NOT_SET);
 627         }
 628         File file = new File(accessFileName);
 629         if (!file.exists()) {
 630             throw new AgentConfigurationError(ACCESS_FILE_NOT_FOUND, accessFileName);
 631         }
 632 
 633         if (!file.canRead()) {
 634             throw new AgentConfigurationError(ACCESS_FILE_NOT_READABLE, accessFileName);
 635         }
 636     }
 637 
 638     private static void checkRestrictedFile(String restrictedFileName) {
 639         if (restrictedFileName == null || restrictedFileName.length() == 0) {
 640             throw new AgentConfigurationError(FILE_NOT_SET);
 641         }
 642         File file = new File(restrictedFileName);
 643         if (!file.exists()) {
 644             throw new AgentConfigurationError(FILE_NOT_FOUND, restrictedFileName);
 645         }
 646         if (!file.canRead()) {
 647             throw new AgentConfigurationError(FILE_NOT_READABLE, restrictedFileName);
 648         }
 649         FileSystem fs = FileSystem.open();
 650         try {
 651             if (fs.supportsFileSecurity(file)) {
 652                 if (!fs.isAccessUserOnly(file)) {
 653                     final String msg = Agent.getText(
 654                             &quot;jmxremote.ConnectorBootstrap.file.readonly&quot;,
 655                             restrictedFileName);
 656                     config(&quot;startRemoteConnectorServer&quot;, msg);
 657                     throw new AgentConfigurationError(
 658                             FILE_ACCESS_NOT_RESTRICTED, restrictedFileName);
 659                 }
 660             }
 661         } catch (IOException e) {
 662             throw new AgentConfigurationError(
 663                     FILE_READ_FAILED, e, restrictedFileName);
 664         }
 665     }
 666 
 667     /**
 668      * Compute the full path name for a default file.
 669      * @param basename basename (with extension) of the default file.
 670      * @return ${JRE}/conf/management/${basename}
 671      **/
 672     private static String getDefaultFileName(String basename) {
 673         final String fileSeparator = File.separator;
 674         return System.getProperty(&quot;java.home&quot;) + fileSeparator + &quot;conf&quot; +
 675                 fileSeparator + &quot;management&quot; + fileSeparator +
 676                 basename;
 677     }
 678 
 679     private static SslRMIServerSocketFactory createSslRMIServerSocketFactory(
 680             String sslConfigFileName,
 681             String[] enabledCipherSuites,
 682             String[] enabledProtocols,
 683             boolean sslNeedClientAuth,
 684             String bindAddress) {
 685         if (sslConfigFileName == null) {
 686             return new HostAwareSslSocketFactory(
 687                     enabledCipherSuites,
 688                     enabledProtocols,
 689                     sslNeedClientAuth, bindAddress);
 690         } else {
 691             checkRestrictedFile(sslConfigFileName);
 692             try {
 693                 // Load the SSL keystore properties from the config file
 694                 Properties p = new Properties();
 695                 try (InputStream in = new FileInputStream(sslConfigFileName)) {
 696                     BufferedInputStream bin = new BufferedInputStream(in);
 697                     p.load(bin);
 698                 }
 699                 String keyStore =
 700                         p.getProperty(&quot;javax.net.ssl.keyStore&quot;);
 701                 String keyStorePassword =
 702                         p.getProperty(&quot;javax.net.ssl.keyStorePassword&quot;, &quot;&quot;);
 703                 String trustStore =
 704                         p.getProperty(&quot;javax.net.ssl.trustStore&quot;);
 705                 String trustStorePassword =
 706                         p.getProperty(&quot;javax.net.ssl.trustStorePassword&quot;, &quot;&quot;);
 707 
 708                 char[] keyStorePasswd = null;
 709                 if (keyStorePassword.length() != 0) {
 710                     keyStorePasswd = keyStorePassword.toCharArray();
 711                 }
 712 
 713                 char[] trustStorePasswd = null;
 714                 if (trustStorePassword.length() != 0) {
 715                     trustStorePasswd = trustStorePassword.toCharArray();
 716                 }
 717 
 718                 KeyStore ks = null;
 719                 if (keyStore != null) {
 720                     ks = KeyStore.getInstance(KeyStore.getDefaultType());
 721                     try (FileInputStream ksfis = new FileInputStream(keyStore)) {
 722                         ks.load(ksfis, keyStorePasswd);
 723                     }
 724                 }
 725                 KeyManagerFactory kmf = KeyManagerFactory.getInstance(
 726                         KeyManagerFactory.getDefaultAlgorithm());
 727                 kmf.init(ks, keyStorePasswd);
 728 
 729                 KeyStore ts = null;
 730                 if (trustStore != null) {
 731                     ts = KeyStore.getInstance(KeyStore.getDefaultType());
 732                     try (FileInputStream tsfis = new FileInputStream(trustStore)) {
 733                         ts.load(tsfis, trustStorePasswd);
 734                     }
 735                 }
 736                 TrustManagerFactory tmf = TrustManagerFactory.getInstance(
 737                         TrustManagerFactory.getDefaultAlgorithm());
 738                 tmf.init(ts);
 739 
 740                 SSLContext ctx = SSLContext.getInstance(&quot;SSL&quot;);
 741                 ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
 742 
 743                 return new HostAwareSslSocketFactory(
 744                         ctx,
 745                         enabledCipherSuites,
 746                         enabledProtocols,
 747                         sslNeedClientAuth, bindAddress);
 748             } catch (Exception e) {
 749                 throw new AgentConfigurationError(AGENT_EXCEPTION, e, e.toString());
 750             }
 751         }
 752     }
 753 
 754     private static JMXConnectorServerData exportMBeanServer(
 755             MBeanServer mbs,
 756             int port,
 757             int rmiPort,
 758             boolean useSsl,
 759             boolean useRegistrySsl,
 760             String sslConfigFileName,
 761             String[] enabledCipherSuites,
 762             String[] enabledProtocols,
 763             boolean sslNeedClientAuth,
 764             boolean useAuthentication,
 765             String loginConfigName,
 766             String passwordFileName,
 767             boolean shouldHashPasswords,
 768             String accessFileName,
 769             String bindAddress,
 770             String jmxRmiFilter)
 771             throws IOException, MalformedURLException {
 772 
 773         /* Make sure we use non-guessable RMI object IDs.  Otherwise
 774          * attackers could hijack open connections by guessing their
 775          * IDs.  */
 776         System.setProperty(&quot;java.rmi.server.randomIDs&quot;, &quot;true&quot;);
 777 
 778         JMXServiceURL url = new JMXServiceURL(&quot;rmi&quot;, bindAddress, rmiPort);
 779 
 780         Map&lt;String, Object&gt; env = new HashMap&lt;&gt;();
 781 
 782         PermanentExporter exporter = new PermanentExporter();
 783 
 784         env.put(RMIExporter.EXPORTER_ATTRIBUTE, exporter);
 785         env.put(RMIConnectorServer.CREDENTIALS_FILTER_PATTERN, String.class.getName() + &quot;;!*&quot;);
 786 
 787         if(jmxRmiFilter != null &amp;&amp; !jmxRmiFilter.isEmpty()) {
 788             env.put(RMIConnectorServer.SERIAL_FILTER_PATTERN, jmxRmiFilter);
 789         }
 790 
 791         boolean useSocketFactory = bindAddress != null &amp;&amp; !useSsl;
 792 
 793         if (useAuthentication) {
 794             if (loginConfigName != null) {
 795                 env.put(&quot;jmx.remote.x.login.config&quot;, loginConfigName);
 796             }
 797             if (passwordFileName != null) {
 798                 env.put(&quot;jmx.remote.x.password.file&quot;, passwordFileName);
 799             }
 800             if (shouldHashPasswords) {
 801                 env.put(&quot;jmx.remote.x.password.toHashes&quot;, &quot;true&quot;);
 802             }
 803 
 804             env.put(&quot;jmx.remote.x.access.file&quot;, accessFileName);
 805 
 806             if (env.get(&quot;jmx.remote.x.password.file&quot;) != null ||
 807                     env.get(&quot;jmx.remote.x.login.config&quot;) != null) {
 808                 env.put(JMXConnectorServer.AUTHENTICATOR,
 809                         new AccessFileCheckerAuthenticator(env));
 810             }
 811         }
 812 
 813         RMIClientSocketFactory csf = null;
 814         RMIServerSocketFactory ssf = null;
 815 
 816         if (useSsl || useRegistrySsl) {
 817             csf = new SslRMIClientSocketFactory();
 818             ssf = createSslRMIServerSocketFactory(
 819                     sslConfigFileName, enabledCipherSuites,
 820                     enabledProtocols, sslNeedClientAuth, bindAddress);
 821         }
 822 
 823         if (useSsl) {
 824             env.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE,
 825                     csf);
 826             env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,
 827                     ssf);
 828         }
 829 
 830         if (useSocketFactory) {
 831             ssf = new HostAwareSocketFactory(bindAddress);
 832             env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,
 833                     ssf);
 834         }
 835 
 836         JMXConnectorServer connServer = null;
 837         try {
 838             connServer =
 839                     JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
 840             connServer.start();
 841         } catch (IOException e) {
 842             if (connServer == null || connServer.getAddress() == null) {
 843                 throw new AgentConfigurationError(CONNECTOR_SERVER_IO_ERROR,
 844                         e, url.toString());
 845             } else {
 846                 throw new AgentConfigurationError(CONNECTOR_SERVER_IO_ERROR,
 847                         e, connServer.getAddress().toString());
 848             }
 849         }
 850 
 851         if (useRegistrySsl) {
 852             registry =
 853                     new SingleEntryRegistry(port, csf, ssf,
 854                     &quot;jmxrmi&quot;, exporter.firstExported);
 855         } else if (useSocketFactory) {
 856             registry =
 857                     new SingleEntryRegistry(port, csf, ssf,
 858                     &quot;jmxrmi&quot;, exporter.firstExported);
 859         } else {
 860             registry =
 861                     new SingleEntryRegistry(port,
 862                     &quot;jmxrmi&quot;, exporter.firstExported);
 863         }
 864 
 865 
 866         int registryPort =
 867             ((UnicastRef) ((RemoteObject) registry).getRef()).getLiveRef().getPort();
 868         String jmxUrlStr =  String.format(&quot;service:jmx:rmi:///jndi/rmi://%s:%d/jmxrmi&quot;,
 869                                            url.getHost(), registryPort);
 870         JMXServiceURL remoteURL = new JMXServiceURL(jmxUrlStr);
 871 
 872         /* Our exporter remembers the first object it was asked to
 873         export, which will be an RMIServerImpl appropriate for
 874         publication in our special registry.  We could
 875         alternatively have constructed the RMIServerImpl explicitly
 876         and then constructed an RMIConnectorServer passing it as a
 877         parameter, but that&#39;s quite a bit more verbose and pulls in
 878         lots of knowledge of the RMI connector.  */
 879 
 880         return new JMXConnectorServerData(connServer, remoteURL);
 881     }
 882 
 883     /**
 884      * This class cannot be instantiated.
 885      **/
 886     private ConnectorBootstrap() {
 887     }
 888 
 889     private static final Logger logger =
 890         System.getLogger(ConnectorBootstrap.class.getPackageName());
 891     private static void config(String func, String msg) {
 892         logger.log(Level.DEBUG, msg);
 893     }
 894 
 895     private static void config(String func, Throwable t) {
 896         logger.log(Level.DEBUG, &quot;ConnectorBootstrap::&quot; + func, t);
 897     }
 898 
 899     private static void config(String func, String msg, Throwable t) {
 900         logger.log(Level.DEBUG, msg, t);
 901     }
 902 
 903     private static class HostAwareSocketFactory implements RMIServerSocketFactory {
 904 
 905         private final String bindAddress;
 906 
 907         private HostAwareSocketFactory(String bindAddress) {
 908              this.bindAddress = bindAddress;
 909         }
 910 
 911         @Override
 912         public ServerSocket createServerSocket(int port) throws IOException {
 913             if (bindAddress == null) {
 914                 return new ServerSocket(port);
 915             } else {
 916                 try {
 917                     InetAddress addr = InetAddress.getByName(bindAddress);
 918                     return new ServerSocket(port, 0, addr);
 919                 } catch (UnknownHostException e) {
 920                     return new ServerSocket(port);
 921                 }
 922             }
 923         }
 924     }
 925 
 926     private static class HostAwareSslSocketFactory extends SslRMIServerSocketFactory {
 927 
 928         private final String bindAddress;
 929         private final String[] enabledCipherSuites;
 930         private final String[] enabledProtocols;
 931         private final boolean needClientAuth;
 932         private final SSLContext context;
 933 
 934         private HostAwareSslSocketFactory(String[] enabledCipherSuites,
 935                                           String[] enabledProtocols,
 936                                           boolean sslNeedClientAuth,
 937                                           String bindAddress) throws IllegalArgumentException {
 938             this(null, enabledCipherSuites, enabledProtocols, sslNeedClientAuth, bindAddress);
 939         }
 940 
 941         private HostAwareSslSocketFactory(SSLContext ctx,
 942                                           String[] enabledCipherSuites,
 943                                           String[] enabledProtocols,
 944                                           boolean sslNeedClientAuth,
 945                                           String bindAddress) throws IllegalArgumentException {
 946             this.context = ctx;
 947             this.bindAddress = bindAddress;
 948             this.enabledProtocols = enabledProtocols;
 949             this.enabledCipherSuites = enabledCipherSuites;
 950             this.needClientAuth = sslNeedClientAuth;
 951             checkValues(ctx, enabledCipherSuites, enabledProtocols);
 952         }
 953 
 954         @Override
 955         public ServerSocket createServerSocket(int port) throws IOException {
 956             if (bindAddress != null) {
 957                 try {
 958                     InetAddress addr = InetAddress.getByName(bindAddress);
 959                     return new SslServerSocket(port, 0, addr, context,
 960                                                enabledCipherSuites, enabledProtocols, needClientAuth);
 961                 } catch (UnknownHostException e) {
 962                     return new SslServerSocket(port, context,
 963                                                enabledCipherSuites, enabledProtocols, needClientAuth);
 964                 }
 965             } else {
 966                 return new SslServerSocket(port, context,
 967                                            enabledCipherSuites, enabledProtocols, needClientAuth);
 968             }
 969         }
 970 
 971         private static void checkValues(SSLContext context,
 972                                         String[] enabledCipherSuites,
 973                                         String[] enabledProtocols) throws IllegalArgumentException {
 974             // Force the initialization of the default at construction time,
 975             // rather than delaying it to the first time createServerSocket()
 976             // is called.
 977             //
 978             final SSLSocketFactory sslSocketFactory =
 979                     context == null ?
 980                         (SSLSocketFactory)SSLSocketFactory.getDefault() : context.getSocketFactory();
 981             SSLSocket sslSocket = null;
 982             if (enabledCipherSuites != null || enabledProtocols != null) {
 983                 try {
 984                     sslSocket = (SSLSocket) sslSocketFactory.createSocket();
 985                 } catch (Exception e) {
 986                     final String msg = &quot;Unable to check if the cipher suites &quot; +
 987                             &quot;and protocols to enable are supported&quot;;
 988                     throw (IllegalArgumentException)
 989                     new IllegalArgumentException(msg).initCause(e);
 990                 }
 991             }
 992 
 993             // Check if all the cipher suites and protocol versions to enable
 994             // are supported by the underlying SSL/TLS implementation and if
 995             // true create lists from arrays.
 996             //
 997             if (enabledCipherSuites != null) {
 998                 sslSocket.setEnabledCipherSuites(enabledCipherSuites);
 999             }
1000             if (enabledProtocols != null) {
1001                 sslSocket.setEnabledProtocols(enabledProtocols);
1002             }
1003         }
1004     }
1005 
1006     private static class SslServerSocket extends ServerSocket {
1007 
1008         private static SSLSocketFactory defaultSSLSocketFactory;
1009         private final String[] enabledCipherSuites;
1010         private final String[] enabledProtocols;
1011         private final boolean needClientAuth;
1012         private final SSLContext context;
1013 
1014         private SslServerSocket(int port,
1015                                 SSLContext ctx,
1016                                 String[] enabledCipherSuites,
1017                                 String[] enabledProtocols,
1018                                 boolean needClientAuth) throws IOException {
1019             super(port);
1020             this.enabledProtocols = enabledProtocols;
1021             this.enabledCipherSuites = enabledCipherSuites;
1022             this.needClientAuth = needClientAuth;
1023             this.context = ctx;
1024         }
1025 
1026         private SslServerSocket(int port,
1027                                 int backlog,
1028                                 InetAddress bindAddr,
1029                                 SSLContext ctx,
1030                                 String[] enabledCipherSuites,
1031                                 String[] enabledProtocols,
1032                                 boolean needClientAuth) throws IOException {
1033             super(port, backlog, bindAddr);
1034             this.enabledProtocols = enabledProtocols;
1035             this.enabledCipherSuites = enabledCipherSuites;
1036             this.needClientAuth = needClientAuth;
1037             this.context = ctx;
1038         }
1039 
1040         @Override
1041         public Socket accept() throws IOException {
1042             final SSLSocketFactory sslSocketFactory =
1043                     context == null ?
1044                         getDefaultSSLSocketFactory() : context.getSocketFactory();
1045             Socket socket = super.accept();
1046             SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
1047                     socket, socket.getInetAddress().getHostName(),
1048                     socket.getPort(), true);
1049             sslSocket.setUseClientMode(false);
1050             if (enabledCipherSuites != null) {
1051                 sslSocket.setEnabledCipherSuites(enabledCipherSuites);
1052             }
1053             if (enabledProtocols != null) {
1054                 sslSocket.setEnabledProtocols(enabledProtocols);
1055             }
1056             sslSocket.setNeedClientAuth(needClientAuth);
1057             return sslSocket;
1058         }
1059 
1060         private static synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
1061             if (defaultSSLSocketFactory == null) {
1062                 defaultSSLSocketFactory = (SSLSocketFactory)SSLSocketFactory.getDefault();
1063                 return defaultSSLSocketFactory;
1064             } else {
1065                 return defaultSSLSocketFactory;
1066             }
1067         }
1068 
1069     }
1070 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
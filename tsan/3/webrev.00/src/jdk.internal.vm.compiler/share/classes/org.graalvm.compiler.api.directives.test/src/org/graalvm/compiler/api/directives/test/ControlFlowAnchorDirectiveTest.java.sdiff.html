<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.api.directives.test/src/org/graalvm/compiler/api/directives/test/ControlFlowAnchorDirectiveTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BlackholeDirectiveTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="IterationDirectiveTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.api.directives.test/src/org/graalvm/compiler/api/directives/test/ControlFlowAnchorDirectiveTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.api.directives.test;
 26 
 27 import java.lang.annotation.ElementType;
 28 import java.lang.annotation.Repeatable;
 29 import java.lang.annotation.Retention;
 30 import java.lang.annotation.RetentionPolicy;
 31 import java.lang.annotation.Target;
 32 import java.util.Arrays;
 33 import java.util.Collections;
 34 import java.util.List;
 35 
<span class="line-removed"> 36 import org.junit.Assert;</span>
<span class="line-removed"> 37 import org.junit.Test;</span>
<span class="line-removed"> 38 </span>
 39 import org.graalvm.compiler.api.directives.GraalDirectives;
 40 import org.graalvm.compiler.core.test.GraalCompilerTest;
 41 import org.graalvm.compiler.graph.Node;
 42 import org.graalvm.compiler.graph.iterators.NodeIterable;
 43 import org.graalvm.compiler.nodes.IfNode;
 44 import org.graalvm.compiler.nodes.LoopBeginNode;
 45 import org.graalvm.compiler.nodes.ReturnNode;
 46 import org.graalvm.compiler.nodes.StructuredGraph;
 47 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 48 import org.graalvm.compiler.nodes.debug.ControlFlowAnchorNode;



 49 
 50 import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="line-removed"> 51 import org.graalvm.compiler.phases.OptimisticOptimizations;</span>
<span class="line-removed"> 52 import org.graalvm.compiler.phases.OptimisticOptimizations.Optimization;</span>
<span class="line-removed"> 53 import org.graalvm.compiler.phases.tiers.HighTierContext;</span>
 54 
 55 public class ControlFlowAnchorDirectiveTest extends GraalCompilerTest {
 56 
 57     @Retention(RetentionPolicy.RUNTIME)
 58     @Target(ElementType.METHOD)
 59     @Repeatable(AnchorSnippet.class)
 60     private @interface NodeCount {
 61 
 62         Class&lt;? extends Node&gt; nodeClass();
 63 
 64         int expectedCount();
 65     }
 66 
 67     @Retention(RetentionPolicy.RUNTIME)
 68     @Target(ElementType.METHOD)
 69     private @interface AnchorSnippet {
 70         NodeCount[] value();
 71     }
 72 
 73     @NodeCount(nodeClass = ReturnNode.class, expectedCount = 1)
</pre>
<hr />
<pre>
227         StructuredGraph g = parseEager(&quot;preventPeelSnippet&quot;, AllowAssumptions.NO);
228         g.copy(g.getDebug());
229     }
230 
231     private static List&lt;NodeCount&gt; getNodeCountAnnotations(StructuredGraph graph) {
232         ResolvedJavaMethod method = graph.method();
233         AnchorSnippet snippet = method.getAnnotation(AnchorSnippet.class);
234         if (snippet != null) {
235             return Arrays.asList(snippet.value());
236         }
237 
238         NodeCount single = method.getAnnotation(NodeCount.class);
239         if (single != null) {
240             return Collections.singletonList(single);
241         }
242 
243         return Collections.emptyList();
244     }
245 
246     @Override
<span class="line-modified">247     protected HighTierContext getDefaultHighTierContext() {</span>
<span class="line-modified">248         return new HighTierContext(getProviders(), getDefaultGraphBuilderSuite(), OptimisticOptimizations.ALL.remove(Optimization.RemoveNeverExecutedCode));</span>
249     }
250 
251     @Override
<span class="line-modified">252     protected boolean checkLowTierGraph(StructuredGraph graph) {</span>
253         List&lt;ControlFlowAnchorNode&gt; anchors = graph.getNodes().filter(ControlFlowAnchorNode.class).snapshot();
254         for (int i = 0; i &lt; anchors.size(); i++) {
255             ControlFlowAnchorNode a = anchors.get(i);
256             for (int j = i + 1; j &lt; anchors.size(); j++) {
257                 ControlFlowAnchorNode b = anchors.get(j);
258                 if (a.valueEquals(b)) {
259                     Assert.fail(&quot;found duplicated control flow anchors (&quot; + a + &quot; and &quot; + b + &quot;)&quot;);
260                 }
261             }
262         }
263 
264         for (NodeCount nodeCount : getNodeCountAnnotations(graph)) {
265             NodeIterable&lt;? extends Node&gt; nodes = graph.getNodes().filter(nodeCount.nodeClass());
266             Assert.assertEquals(nodeCount.nodeClass().getSimpleName(), nodeCount.expectedCount(), nodes.count());
267         }
<span class="line-removed">268         return true;</span>
269     }
270 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.api.directives.test;
 26 
 27 import java.lang.annotation.ElementType;
 28 import java.lang.annotation.Repeatable;
 29 import java.lang.annotation.Retention;
 30 import java.lang.annotation.RetentionPolicy;
 31 import java.lang.annotation.Target;
 32 import java.util.Arrays;
 33 import java.util.Collections;
 34 import java.util.List;
 35 



 36 import org.graalvm.compiler.api.directives.GraalDirectives;
 37 import org.graalvm.compiler.core.test.GraalCompilerTest;
 38 import org.graalvm.compiler.graph.Node;
 39 import org.graalvm.compiler.graph.iterators.NodeIterable;
 40 import org.graalvm.compiler.nodes.IfNode;
 41 import org.graalvm.compiler.nodes.LoopBeginNode;
 42 import org.graalvm.compiler.nodes.ReturnNode;
 43 import org.graalvm.compiler.nodes.StructuredGraph;
 44 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 45 import org.graalvm.compiler.nodes.debug.ControlFlowAnchorNode;
<span class="line-added"> 46 import org.graalvm.compiler.phases.OptimisticOptimizations;</span>
<span class="line-added"> 47 import org.junit.Assert;</span>
<span class="line-added"> 48 import org.junit.Test;</span>
 49 
 50 import jdk.vm.ci.meta.ResolvedJavaMethod;



 51 
 52 public class ControlFlowAnchorDirectiveTest extends GraalCompilerTest {
 53 
 54     @Retention(RetentionPolicy.RUNTIME)
 55     @Target(ElementType.METHOD)
 56     @Repeatable(AnchorSnippet.class)
 57     private @interface NodeCount {
 58 
 59         Class&lt;? extends Node&gt; nodeClass();
 60 
 61         int expectedCount();
 62     }
 63 
 64     @Retention(RetentionPolicy.RUNTIME)
 65     @Target(ElementType.METHOD)
 66     private @interface AnchorSnippet {
 67         NodeCount[] value();
 68     }
 69 
 70     @NodeCount(nodeClass = ReturnNode.class, expectedCount = 1)
</pre>
<hr />
<pre>
224         StructuredGraph g = parseEager(&quot;preventPeelSnippet&quot;, AllowAssumptions.NO);
225         g.copy(g.getDebug());
226     }
227 
228     private static List&lt;NodeCount&gt; getNodeCountAnnotations(StructuredGraph graph) {
229         ResolvedJavaMethod method = graph.method();
230         AnchorSnippet snippet = method.getAnnotation(AnchorSnippet.class);
231         if (snippet != null) {
232             return Arrays.asList(snippet.value());
233         }
234 
235         NodeCount single = method.getAnnotation(NodeCount.class);
236         if (single != null) {
237             return Collections.singletonList(single);
238         }
239 
240         return Collections.emptyList();
241     }
242 
243     @Override
<span class="line-modified">244     protected OptimisticOptimizations getOptimisticOptimizations() {</span>
<span class="line-modified">245         return OptimisticOptimizations.ALL.remove(OptimisticOptimizations.Optimization.RemoveNeverExecutedCode);</span>
246     }
247 
248     @Override
<span class="line-modified">249     protected void checkLowTierGraph(StructuredGraph graph) {</span>
250         List&lt;ControlFlowAnchorNode&gt; anchors = graph.getNodes().filter(ControlFlowAnchorNode.class).snapshot();
251         for (int i = 0; i &lt; anchors.size(); i++) {
252             ControlFlowAnchorNode a = anchors.get(i);
253             for (int j = i + 1; j &lt; anchors.size(); j++) {
254                 ControlFlowAnchorNode b = anchors.get(j);
255                 if (a.valueEquals(b)) {
256                     Assert.fail(&quot;found duplicated control flow anchors (&quot; + a + &quot; and &quot; + b + &quot;)&quot;);
257                 }
258             }
259         }
260 
261         for (NodeCount nodeCount : getNodeCountAnnotations(graph)) {
262             NodeIterable&lt;? extends Node&gt; nodes = graph.getNodes().filter(nodeCount.nodeClass());
263             Assert.assertEquals(nodeCount.nodeClass().getSimpleName(), nodeCount.expectedCount(), nodes.count());
264         }

265     }
266 }
</pre>
</td>
</tr>
</table>
<center><a href="BlackholeDirectiveTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="IterationDirectiveTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
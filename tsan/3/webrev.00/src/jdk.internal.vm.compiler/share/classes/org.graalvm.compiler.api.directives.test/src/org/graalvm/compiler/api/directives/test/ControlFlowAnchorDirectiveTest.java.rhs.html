<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.api.directives.test/src/org/graalvm/compiler/api/directives/test/ControlFlowAnchorDirectiveTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.api.directives.test;
 26 
 27 import java.lang.annotation.ElementType;
 28 import java.lang.annotation.Repeatable;
 29 import java.lang.annotation.Retention;
 30 import java.lang.annotation.RetentionPolicy;
 31 import java.lang.annotation.Target;
 32 import java.util.Arrays;
 33 import java.util.Collections;
 34 import java.util.List;
 35 
<a name="2" id="anc2"></a>


 36 import org.graalvm.compiler.api.directives.GraalDirectives;
 37 import org.graalvm.compiler.core.test.GraalCompilerTest;
 38 import org.graalvm.compiler.graph.Node;
 39 import org.graalvm.compiler.graph.iterators.NodeIterable;
 40 import org.graalvm.compiler.nodes.IfNode;
 41 import org.graalvm.compiler.nodes.LoopBeginNode;
 42 import org.graalvm.compiler.nodes.ReturnNode;
 43 import org.graalvm.compiler.nodes.StructuredGraph;
 44 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 45 import org.graalvm.compiler.nodes.debug.ControlFlowAnchorNode;
<a name="3" id="anc3"></a><span class="line-added"> 46 import org.graalvm.compiler.phases.OptimisticOptimizations;</span>
<span class="line-added"> 47 import org.junit.Assert;</span>
<span class="line-added"> 48 import org.junit.Test;</span>
 49 
 50 import jdk.vm.ci.meta.ResolvedJavaMethod;
<a name="4" id="anc4"></a>


 51 
 52 public class ControlFlowAnchorDirectiveTest extends GraalCompilerTest {
 53 
 54     @Retention(RetentionPolicy.RUNTIME)
 55     @Target(ElementType.METHOD)
 56     @Repeatable(AnchorSnippet.class)
 57     private @interface NodeCount {
 58 
 59         Class&lt;? extends Node&gt; nodeClass();
 60 
 61         int expectedCount();
 62     }
 63 
 64     @Retention(RetentionPolicy.RUNTIME)
 65     @Target(ElementType.METHOD)
 66     private @interface AnchorSnippet {
 67         NodeCount[] value();
 68     }
 69 
 70     @NodeCount(nodeClass = ReturnNode.class, expectedCount = 1)
 71     public static int verifyMergeSnippet(int arg) {
 72         if (arg &gt; 5) {
 73             return 1;
 74         } else {
 75             return 2;
 76         }
 77     }
 78 
 79     @NodeCount(nodeClass = ControlFlowAnchorNode.class, expectedCount = 2)
 80     @NodeCount(nodeClass = ReturnNode.class, expectedCount = 2)
 81     public static int preventMergeSnippet(int arg) {
 82         if (arg &gt; 5) {
 83             GraalDirectives.controlFlowAnchor();
 84             return 1;
 85         } else {
 86             GraalDirectives.controlFlowAnchor();
 87             return 2;
 88         }
 89     }
 90 
 91     @Test
 92     public void testMerge() {
 93         test(&quot;verifyMergeSnippet&quot;, 42);
 94         test(&quot;preventMergeSnippet&quot;, 42);
 95     }
 96 
 97     @NodeCount(nodeClass = ReturnNode.class, expectedCount = 2)
 98     public static int verifyDuplicateSnippet(int arg) {
 99         int ret;
100         if (arg &gt; 5) {
101             ret = 17;
102         } else {
103             ret = arg;
104         }
105         return 42 / ret;
106     }
107 
108     @NodeCount(nodeClass = ControlFlowAnchorNode.class, expectedCount = 1)
109     @NodeCount(nodeClass = ReturnNode.class, expectedCount = 1)
110     public static int preventDuplicateSnippet(int arg) {
111         int ret;
112         if (arg &gt; 5) {
113             ret = 17;
114         } else {
115             ret = arg;
116         }
117         GraalDirectives.controlFlowAnchor();
118         return 42 / ret;
119     }
120 
121     @Test
122     public void testDuplicate() {
123         // test(&quot;verifyDuplicateSnippet&quot;, 42);
124         test(&quot;preventDuplicateSnippet&quot;, 42);
125     }
126 
127     @NodeCount(nodeClass = LoopBeginNode.class, expectedCount = 0)
128     public static int verifyFullUnrollSnippet(int arg) {
129         int ret = arg;
130         for (int i = 0; i &lt; 5; i++) {
131             ret = ret * 3 + 1;
132         }
133         return ret;
134     }
135 
136     @NodeCount(nodeClass = LoopBeginNode.class, expectedCount = 1)
137     @NodeCount(nodeClass = ControlFlowAnchorNode.class, expectedCount = 1)
138     public static int preventFullUnrollSnippet(int arg) {
139         int ret = arg;
140         for (int i = 0; i &lt; 5; i++) {
141             GraalDirectives.controlFlowAnchor();
142             ret = ret * 3 + 1;
143         }
144         return ret;
145     }
146 
147     @Test
148     public void testFullUnroll() {
149         test(&quot;verifyFullUnrollSnippet&quot;, 42);
150         test(&quot;preventFullUnrollSnippet&quot;, 42);
151     }
152 
153     @NodeCount(nodeClass = LoopBeginNode.class, expectedCount = 1)
154     @NodeCount(nodeClass = IfNode.class, expectedCount = 4)
155     public static void verifyPeelSnippet(int arg) {
156         int ret = arg;
157         while (ret &gt; 1) {
158             if (ret % 2 == 0) {
159                 ret /= 2;
160             } else {
161                 ret = 3 * ret + 1;
162             }
163         }
164     }
165 
166     @NodeCount(nodeClass = LoopBeginNode.class, expectedCount = 1)
167     @NodeCount(nodeClass = IfNode.class, expectedCount = 2)
168     public static void preventPeelSnippet(int arg) {
169         int ret = arg;
170         while (ret &gt; 1) {
171             GraalDirectives.controlFlowAnchor();
172             if (ret % 2 == 0) {
173                 GraalDirectives.controlFlowAnchor();
174                 ret /= 2;
175             } else {
176                 ret = 3 * ret + 1;
177             }
178         }
179     }
180 
181     @Test
182     public void testPeel() {
183         test(&quot;preventPeelSnippet&quot;, 42);
184     }
185 
186     @NodeCount(nodeClass = LoopBeginNode.class, expectedCount = 2)
187     public static void verifyUnswitchSnippet(int arg, boolean flag) {
188         int ret = arg;
189         while (GraalDirectives.injectBranchProbability(0.9999, ret &lt; 1000)) {
190             if (flag) {
191                 ret = ret * 2 + 1;
192             } else {
193                 ret = ret * 3 + 1;
194             }
195         }
196     }
197 
198     @NodeCount(nodeClass = LoopBeginNode.class, expectedCount = 1)
199     @NodeCount(nodeClass = IfNode.class, expectedCount = 2)
200     public static void preventUnswitchSnippet(int arg, boolean flag) {
201         int ret = arg;
202         while (GraalDirectives.injectBranchProbability(0.9999, ret &lt; 1000)) {
203             if (flag) {
204                 GraalDirectives.controlFlowAnchor();
205                 ret++;
206             } else {
207                 ret += 2;
208             }
209         }
210     }
211 
212     @Test
213     public void testUnswitch() {
214         test(&quot;verifyUnswitchSnippet&quot;, 0, false);
215         test(&quot;preventUnswitchSnippet&quot;, 0, false);
216     }
217 
218     /**
219      * Cloning a ControlFlowAnchorNode is not allowed but cloning a whole graph containing one is
220      * ok.
221      */
222     @Test
223     public void testClone() {
224         StructuredGraph g = parseEager(&quot;preventPeelSnippet&quot;, AllowAssumptions.NO);
225         g.copy(g.getDebug());
226     }
227 
228     private static List&lt;NodeCount&gt; getNodeCountAnnotations(StructuredGraph graph) {
229         ResolvedJavaMethod method = graph.method();
230         AnchorSnippet snippet = method.getAnnotation(AnchorSnippet.class);
231         if (snippet != null) {
232             return Arrays.asList(snippet.value());
233         }
234 
235         NodeCount single = method.getAnnotation(NodeCount.class);
236         if (single != null) {
237             return Collections.singletonList(single);
238         }
239 
240         return Collections.emptyList();
241     }
242 
243     @Override
<a name="5" id="anc5"></a><span class="line-modified">244     protected OptimisticOptimizations getOptimisticOptimizations() {</span>
<span class="line-modified">245         return OptimisticOptimizations.ALL.remove(OptimisticOptimizations.Optimization.RemoveNeverExecutedCode);</span>
246     }
247 
248     @Override
<a name="6" id="anc6"></a><span class="line-modified">249     protected void checkLowTierGraph(StructuredGraph graph) {</span>
250         List&lt;ControlFlowAnchorNode&gt; anchors = graph.getNodes().filter(ControlFlowAnchorNode.class).snapshot();
251         for (int i = 0; i &lt; anchors.size(); i++) {
252             ControlFlowAnchorNode a = anchors.get(i);
253             for (int j = i + 1; j &lt; anchors.size(); j++) {
254                 ControlFlowAnchorNode b = anchors.get(j);
255                 if (a.valueEquals(b)) {
256                     Assert.fail(&quot;found duplicated control flow anchors (&quot; + a + &quot; and &quot; + b + &quot;)&quot;);
257                 }
258             }
259         }
260 
261         for (NodeCount nodeCount : getNodeCountAnnotations(graph)) {
262             NodeIterable&lt;? extends Node&gt; nodes = graph.getNodes().filter(nodeCount.nodeClass());
263             Assert.assertEquals(nodeCount.nodeClass().getSimpleName(), nodeCount.expectedCount(), nodes.count());
264         }
<a name="7" id="anc7"></a>
265     }
266 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
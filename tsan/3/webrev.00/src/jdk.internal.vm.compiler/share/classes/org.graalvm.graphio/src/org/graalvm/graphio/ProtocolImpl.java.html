<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.graphio/src/org/graalvm/graphio/ProtocolImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.graphio;
 26 
 27 import java.io.File;
 28 import java.io.IOException;
 29 import java.net.URI;
 30 import java.net.URISyntaxException;
 31 import java.nio.channels.WritableByteChannel;
 32 import java.util.Collection;
 33 import java.util.Map;
 34 
 35 final class ProtocolImpl&lt;Graph, Node, NodeClass, Port, Block, ResolvedJavaMethod, ResolvedJavaField, Signature, NodeSourcePosition, Location&gt;
 36                 extends GraphProtocol&lt;Graph, Node, NodeClass, Port, Block, ResolvedJavaMethod, ResolvedJavaField, Signature, NodeSourcePosition, Location&gt; {
 37     private final GraphStructure&lt;Graph, Node, NodeClass, Port&gt; structure;
 38     private final GraphTypes types;
 39     private final GraphBlocks&lt;Graph, Block, Node&gt; blocks;
 40     private final GraphElements&lt;ResolvedJavaMethod, ResolvedJavaField, Signature, NodeSourcePosition&gt; elements;
 41     private final GraphLocations&lt;ResolvedJavaMethod, NodeSourcePosition, Location&gt; locations;
 42 
 43     ProtocolImpl(int major, int minor, boolean embedded, GraphStructure&lt;Graph, Node, NodeClass, Port&gt; structure, GraphTypes enums, GraphBlocks&lt;Graph, Block, Node&gt; blocks,
 44                     GraphElements&lt;ResolvedJavaMethod, ResolvedJavaField, Signature, NodeSourcePosition&gt; elements,
 45                     GraphLocations&lt;ResolvedJavaMethod, NodeSourcePosition, Location&gt; locs,
 46                     WritableByteChannel channel) throws IOException {
 47         super(channel, major, minor, embedded);
 48         this.structure = structure;
 49         this.types = enums;
 50         this.blocks = blocks;
 51         this.elements = elements;
 52         this.locations = locs;
 53     }
 54 
 55     ProtocolImpl(GraphProtocol&lt;?, ?, ?, ?, ?, ?, ?, ?, ?, ?&gt; parent, GraphStructure&lt;Graph, Node, NodeClass, Port&gt; structure, GraphTypes enums, GraphBlocks&lt;Graph, Block, Node&gt; blocks,
 56                     GraphElements&lt;ResolvedJavaMethod, ResolvedJavaField, Signature, NodeSourcePosition&gt; elements,
 57                     GraphLocations&lt;ResolvedJavaMethod, NodeSourcePosition, Location&gt; locs) {
 58         super(parent);
 59         this.structure = structure;
 60         this.types = enums;
 61         this.blocks = blocks;
 62         this.elements = elements;
 63         this.locations = locs;
 64     }
 65 
 66     @Override
 67     protected Graph findGraph(Graph current, Object obj) {
 68         return structure.graph(current, obj);
 69     }
 70 
 71     @Override
 72     protected Node findNode(Object obj) {
 73         return structure.node(obj);
 74     }
 75 
 76     @Override
 77     protected NodeClass findNodeClass(Object obj) {
 78         return structure.nodeClass(obj);
 79     }
 80 
 81     @Override
 82     protected NodeClass findClassForNode(Node obj) {
 83         NodeClass clazz = structure.classForNode(obj);
 84         if (clazz != null &amp;&amp; (findNodeClass(clazz) == null || findNode(clazz) != null)) {
 85             throw new IllegalStateException(&quot;classForNode method shall return node class representation rather than node: &quot; + clazz);
 86         }
 87         return clazz;
 88     }
 89 
 90     @Override
 91     protected String findNameTemplate(NodeClass clazz) {
 92         return structure.nameTemplate(clazz);
 93     }
 94 
 95     @Override
 96     protected int findNodeId(Node n) {
 97         return structure.nodeId(n);
 98     }
 99 
100     @Override
101     protected boolean hasPredecessor(Node node) {
102         return structure.nodeHasPredecessor(node);
103     }
104 
105     @Override
106     protected int findNodesCount(Graph info) {
107         return structure.nodesCount(info);
108     }
109 
110     @Override
111     protected Iterable&lt;? extends Node&gt; findNodes(Graph info) {
112         return structure.nodes(info);
113     }
114 
115     @Override
116     protected void findNodeProperties(Node node, Map&lt;String, Object&gt; props, Graph info) {
117         structure.nodeProperties(info, node, props);
118     }
119 
120     @Override
121     protected Port findClassEdges(NodeClass nodeClass, boolean dumpInputs) {
122         if (dumpInputs) {
123             return structure.portInputs(nodeClass);
124         } else {
125             return structure.portOutputs(nodeClass);
126         }
127     }
128 
129     @Override
130     protected int findSize(Port edges) {
131         return structure.portSize(edges);
132     }
133 
134     @Override
135     protected boolean isDirect(Port edges, int i) {
136         return structure.edgeDirect(edges, i);
137     }
138 
139     @Override
140     protected String findName(Port edges, int i) {
141         return structure.edgeName(edges, i);
142     }
143 
144     @Override
145     protected Object findType(Port edges, int i) {
146         Object type = structure.edgeType(edges, i);
147         if (findEnumOrdinal(type) &lt; 0) {
148             throw new IllegalStateException(&quot;edgeType method shall return an enum! Was: &quot; + type);
149         }
150         return type;
151     }
152 
153     @Override
154     protected Collection&lt;? extends Node&gt; findNodes(Graph graph, Node node, Port port, int i) {
155         return structure.edgeNodes(graph, node, port, i);
156     }
157 
158     @Override
159     protected Object findJavaClass(NodeClass clazz) {
160         final Object type = structure.nodeClassType(clazz);
161         if (!(type instanceof Class&lt;?&gt;) &amp;&amp; findJavaTypeName(type) == null) {
162             throw new IllegalStateException(&quot;nodeClassType method shall return a Java class (instance of Class)! Was: &quot; + type);
163         }
164         return type;
165     }
166 
167     @Override
168     protected Object findEnumClass(Object enumValue) {
169         return types.enumClass(enumValue);
170     }
171 
172     @Override
173     protected int findEnumOrdinal(Object obj) {
174         return types.enumOrdinal(obj);
175     }
176 
177     @Override
178     protected String[] findEnumTypeValues(Object clazz) {
179         return types.enumTypeValues(clazz);
180     }
181 
182     @Override
183     protected String findJavaTypeName(Object obj) {
184         return types.typeName(obj);
185     }
186 
187     @Override
188     protected Collection&lt;? extends Node&gt; findBlockNodes(Graph info, Block block) {
189         return blocks.blockNodes(info, block);
190     }
191 
192     @Override
193     protected int findBlockId(Block block) {
194         return blocks.blockId(block);
195     }
196 
197     @Override
198     protected Collection&lt;? extends Block&gt; findBlocks(Graph graph) {
199         return blocks.blocks(graph);
200     }
201 
202     @Override
203     protected Collection&lt;? extends Block&gt; findBlockSuccessors(Block block) {
204         return blocks.blockSuccessors(block);
205     }
206 
207     @Override
208     protected ResolvedJavaMethod findMethod(Object obj) {
209         return elements == null ? null : elements.method(obj);
210     }
211 
212     @Override
213     protected byte[] findMethodCode(ResolvedJavaMethod method) {
214         return elements.methodCode(method);
215     }
216 
217     @Override
218     protected int findMethodModifiers(ResolvedJavaMethod method) {
219         return elements.methodModifiers(method);
220     }
221 
222     @Override
223     protected Signature findMethodSignature(ResolvedJavaMethod method) {
224         return elements.methodSignature(method);
225     }
226 
227     @Override
228     protected String findMethodName(ResolvedJavaMethod method) {
229         return elements.methodName(method);
230     }
231 
232     @Override
233     protected Object findMethodDeclaringClass(ResolvedJavaMethod method) {
234         return elements.methodDeclaringClass(method);
235     }
236 
237     @Override
238     protected int findFieldModifiers(ResolvedJavaField field) {
239         return elements.fieldModifiers(field);
240     }
241 
242     @Override
243     protected String findFieldTypeName(ResolvedJavaField field) {
244         return elements.fieldTypeName(field);
245     }
246 
247     @Override
248     protected String findFieldName(ResolvedJavaField field) {
249         return elements.fieldName(field);
250     }
251 
252     @Override
253     protected Object findFieldDeclaringClass(ResolvedJavaField field) {
254         return elements.fieldDeclaringClass(field);
255     }
256 
257     @Override
258     protected ResolvedJavaField findJavaField(Object object) {
259         return elements == null ? null : elements.field(object);
260     }
261 
262     @Override
263     protected Signature findSignature(Object object) {
264         return elements == null ? null : elements.signature(object);
265     }
266 
267     @Override
268     protected int findSignatureParameterCount(Signature signature) {
269         return elements.signatureParameterCount(signature);
270     }
271 
272     @Override
273     protected String findSignatureParameterTypeName(Signature signature, int index) {
274         return elements.signatureParameterTypeName(signature, index);
275     }
276 
277     @Override
278     protected String findSignatureReturnTypeName(Signature signature) {
279         return elements.signatureReturnTypeName(signature);
280     }
281 
282     @Override
283     protected NodeSourcePosition findNodeSourcePosition(Object object) {
284         return elements == null ? null : elements.nodeSourcePosition(object);
285     }
286 
287     @Override
288     protected ResolvedJavaMethod findNodeSourcePositionMethod(NodeSourcePosition pos) {
289         return elements.nodeSourcePositionMethod(pos);
290     }
291 
292     @Override
293     protected NodeSourcePosition findNodeSourcePositionCaller(NodeSourcePosition pos) {
294         return elements.nodeSourcePositionCaller(pos);
295     }
296 
297     @Override
298     protected int findNodeSourcePositionBCI(NodeSourcePosition pos) {
299         return elements.nodeSourcePositionBCI(pos);
300     }
301 
302     @Override
303     protected Iterable&lt;Location&gt; findLocation(ResolvedJavaMethod method, int bci, NodeSourcePosition pos) {
304         return locations.methodLocation(method, bci, pos);
305     }
306 
307     @Override
308     protected String findLocationFile(Location loc) throws IOException {
309         if (loc == null) {
310             return null;
311         }
312         URI u;
313         try {
314             u = locations.locationURI(loc);
315         } catch (URISyntaxException ex) {
316             throw new IOException(ex);
317         }
318         if (u == null) {
319             return null;
320         }
321         if (u.getScheme() == null) {
322             return u.getPath();
323         }
324         if (&quot;file&quot;.equals(u.getScheme())) {
325             return new File(u).getPath();
326         }
327         return null;
328     }
329 
330     @Override
331     protected int findLocationLine(Location loc) {
332         return locations.locationLineNumber(loc);
333     }
334 
335     @Override
336     protected URI findLocationURI(Location loc) throws URISyntaxException {
337         return locations.locationURI(loc);
338     }
339 
340     @Override
341     protected String findLocationLanguage(Location loc) {
342         return locations.locationLanguage(loc);
343     }
344 
345     @Override
346     protected int findLocationStart(Location loc) {
347         return locations.locationOffsetStart(loc);
348     }
349 
350     @Override
351     protected int findLocationEnd(Location loc) {
352         return locations.locationOffsetEnd(loc);
353     }
354 
355     @Override
356     protected void findExtraNodes(Node node, Collection&lt;? super Node&gt; extraNodes) {
357     }
358 
359     @Override
360     protected String formatTitle(Graph graph, int id, String format, Object... args) {
361         return String.format(format, args) + &quot; [&quot; + id + &quot;]&quot;;
362     }
363 }
    </pre>
  </body>
</html>
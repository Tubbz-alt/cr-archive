<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.graphio/src/org/graalvm/graphio/GraphProtocol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraphOutput.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ProtocolImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.graphio/src/org/graalvm/graphio/GraphProtocol.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.graphio;
 26 
 27 import java.io.Closeable;
 28 import java.io.IOException;
 29 import java.net.URI;
 30 import java.net.URISyntaxException;

 31 import java.nio.ByteBuffer;
 32 import java.nio.channels.WritableByteChannel;
 33 import java.nio.charset.Charset;
 34 import java.util.Collection;
 35 import java.util.HashMap;
 36 import java.util.Iterator;
 37 import java.util.LinkedHashMap;
 38 import java.util.LinkedList;
 39 import java.util.Map;
 40 import java.util.Objects;
 41 
 42 abstract class GraphProtocol&lt;Graph, Node, NodeClass, Edges, Block, ResolvedJavaMethod, ResolvedJavaField, Signature, NodeSourcePosition, Location&gt; implements Closeable {
 43     private static final Charset UTF8 = Charset.forName(&quot;UTF-8&quot;);
 44 
 45     private static final int CONSTANT_POOL_MAX_SIZE = 8000;
 46 
 47     private static final int BEGIN_GROUP = 0x00;
 48     private static final int BEGIN_GRAPH = 0x01;
 49     private static final int CLOSE_GROUP = 0x02;
 50 
</pre>
<hr />
<pre>
 58     private static final int POOL_FIELD = 0x07;
 59     private static final int POOL_SIGNATURE = 0x08;
 60     private static final int POOL_NODE_SOURCE_POSITION = 0x09;
 61     private static final int POOL_NODE = 0x0a;
 62 
 63     private static final int PROPERTY_POOL = 0x00;
 64     private static final int PROPERTY_INT = 0x01;
 65     private static final int PROPERTY_LONG = 0x02;
 66     private static final int PROPERTY_DOUBLE = 0x03;
 67     private static final int PROPERTY_FLOAT = 0x04;
 68     private static final int PROPERTY_TRUE = 0x05;
 69     private static final int PROPERTY_FALSE = 0x06;
 70     private static final int PROPERTY_ARRAY = 0x07;
 71     private static final int PROPERTY_SUBGRAPH = 0x08;
 72 
 73     private static final int KLASS = 0x00;
 74     private static final int ENUM_KLASS = 0x01;
 75 
 76     private static final byte[] MAGIC_BYTES = {&#39;B&#39;, &#39;I&#39;, &#39;G&#39;, &#39;V&#39;};
 77 



 78     private final ConstantPool constantPool;
 79     private final ByteBuffer buffer;
 80     private final WritableByteChannel channel;
 81     private final boolean embedded;
 82     final int versionMajor;
 83     final int versionMinor;
 84     private boolean printing;
 85 







 86     GraphProtocol(WritableByteChannel channel, int major, int minor, boolean embedded) throws IOException {
<span class="line-modified"> 87         if (major &gt; 6 || (major == 6 &amp;&amp; minor &gt; 0)) {</span>
 88             throw new IllegalArgumentException(&quot;Unrecognized version &quot; + major + &quot;.&quot; + minor);
 89         }
 90         this.versionMajor = major;
 91         this.versionMinor = minor;
 92         this.constantPool = new ConstantPool();
 93         this.buffer = ByteBuffer.allocateDirect(256 * 1024);
 94         this.channel = channel;
 95         this.embedded = embedded;
 96         if (!embedded) {
 97             writeVersion();
 98             flushEmbedded();
 99         }
100     }
101 
102     GraphProtocol(GraphProtocol&lt;?, ?, ?, ?, ?, ?, ?, ?, ?, ?&gt; parent) {
103         this.versionMajor = parent.versionMajor;
104         this.versionMinor = parent.versionMinor;
105         this.constantPool = parent.constantPool;
106         this.buffer = parent.buffer;
107         this.channel = parent.channel;
</pre>
<hr />
<pre>
308     protected abstract String findLocationLanguage(Location loc);
309 
310     protected abstract int findLocationStart(Location loc);
311 
312     protected abstract int findLocationEnd(Location loc);
313 
314     private void writeVersion() throws IOException {
315         writeBytesRaw(MAGIC_BYTES);
316         writeByte(versionMajor);
317         writeByte(versionMinor);
318     }
319 
320     private void flushEmbedded() throws IOException {
321         if (embedded) {
322             flush();
323             constantPool.reset();
324         }
325     }
326 
327     private void flush() throws IOException {
<span class="line-modified">328         buffer.flip();</span>
329         /*
330          * Try not to let interrupted threads abort the write. There&#39;s still a race here but an
331          * interrupt that&#39;s been pending for a long time shouldn&#39;t stop this writing.
332          */
333         boolean interrupted = Thread.interrupted();
334         try {
335             channel.write(buffer);
336         } finally {
337             if (interrupted) {
338                 Thread.currentThread().interrupt();
339             }
340         }
341         buffer.compact();
342     }
343 
344     private void ensureAvailable(int i) throws IOException {
345         assert buffer.capacity() &gt;= i : &quot;Can not make &quot; + i + &quot; bytes available, buffer is too small&quot;;
346         while (buffer.remaining() &lt; i) {
347             flush();
348         }
</pre>
<hr />
<pre>
391             writeBytesRaw(b);
392         }
393     }
394 
395     private void writeBytesRaw(byte[] b) throws IOException {
396         int bytesWritten = 0;
397         while (bytesWritten &lt; b.length) {
398             int toWrite = Math.min(b.length - bytesWritten, buffer.capacity());
399             ensureAvailable(toWrite);
400             buffer.put(b, bytesWritten, toWrite);
401             bytesWritten += toWrite;
402         }
403     }
404 
405     private int writeBytesRaw(ByteBuffer b) throws IOException {
406         int limit = b.limit();
407         int written = 0;
408         while (b.position() &lt; limit) {
409             int toWrite = Math.min(limit - b.position(), buffer.capacity());
410             ensureAvailable(toWrite);
<span class="line-modified">411             b.limit(b.position() + toWrite);</span>
412             try {
413                 buffer.put(b);
414                 written += toWrite;
415             } finally {
<span class="line-modified">416                 b.limit(limit);</span>
417             }
418         }
419         return written;
420     }
421 
422     private void writeInts(int[] b) throws IOException {
423         if (b == null) {
424             writeInt(-1);
425         } else {
426             writeInt(b.length);
427             int sizeInBytes = b.length * 4;
428             ensureAvailable(sizeInBytes);
429             buffer.asIntBuffer().put(b);
<span class="line-modified">430             buffer.position(buffer.position() + sizeInBytes);</span>
431         }
432     }
433 
434     private void writeDoubles(double[] b) throws IOException {
435         if (b == null) {
436             writeInt(-1);
437         } else {
438             writeInt(b.length);
439             int sizeInBytes = b.length * 8;
440             ensureAvailable(sizeInBytes);
441             buffer.asDoubleBuffer().put(b);
<span class="line-modified">442             buffer.position(buffer.position() + sizeInBytes);</span>
443         }
444     }
445 
446     private void writePoolObject(Object obj) throws IOException {
447         Object object = obj;
448         if (object == null) {
449             writeByte(POOL_NULL);
450             return;
451         }
452         Character id = constantPool.get(object);
453         if (id == null) {
454             addPoolEntry(object);
455         } else {
456             int type = findPoolType(object, null);
457             writeByte(type);
458             writeShort(id.charValue());
459         }
460     }
461 
462     private int findPoolType(Object obj, Object[] found) throws IOException {
</pre>
<hr />
<pre>
617             writePoolObject(findName(edges, i));
618             if (dumpInputs) {
619                 writePoolObject(findType(edges, i));
620             }
621         }
622     }
623 
624     @SuppressWarnings(&quot;unchecked&quot;)
625     private void addPoolEntry(Object obj) throws IOException {
626         Object object = obj;
627         char index = constantPool.add(object);
628         writeByte(POOL_NEW);
629         writeShort(index);
630 
631         Object[] found = {null};
632         int type = findPoolType(object, found);
633         writeByte(type);
634         switch (type) {
635             case POOL_FIELD: {
636                 ResolvedJavaField field = (ResolvedJavaField) found[0];
<span class="line-modified">637                 Objects.nonNull(field);</span>
638                 writePoolObject(findFieldDeclaringClass(field));
639                 writePoolObject(findFieldName(field));
640                 writePoolObject(findFieldTypeName(field));
641                 writeInt(findFieldModifiers(field));
642                 break;
643             }
644             case POOL_SIGNATURE: {
645                 Signature signature = (Signature) found[0];
646                 int args = findSignatureParameterCount(signature);
647                 writeShort((char) args);
648                 for (int i = 0; i &lt; args; i++) {
649                     writePoolObject(findSignatureParameterTypeName(signature, i));
650                 }
651                 writePoolObject(findSignatureReturnTypeName(signature));
652                 break;
653             }
654             case POOL_NODE_SOURCE_POSITION: {
655                 NodeSourcePosition pos = (NodeSourcePosition) found[0];
<span class="line-modified">656                 Objects.nonNull(pos);</span>
657                 ResolvedJavaMethod method = findNodeSourcePositionMethod(pos);
658                 writePoolObject(method);
659                 final int bci = findNodeSourcePositionBCI(pos);
660                 writeInt(bci);
661                 Iterator&lt;Location&gt; ste = findLocation(method, bci, pos).iterator();
662                 if (versionMajor &gt;= 6) {
663                     while (ste.hasNext()) {
664                         Location loc = ste.next();
665                         URI uri;
666                         try {
667                             uri = findLocationURI(loc);
668                         } catch (URISyntaxException ex) {
669                             throw new IOException(ex);
670                         }
671                         if (uri == null) {
672                             continue;
673                         }
674                         String l = findLocationLanguage(loc);
675                         if (l == null) {
676                             continue;
</pre>
<hr />
<pre>
680                         writeInt(findLocationLine(loc));
681                         writeInt(findLocationStart(loc));
682                         writeInt(findLocationEnd(loc));
683                     }
684                     writePoolObject(null);
685                 } else {
686                     Location first = ste.hasNext() ? ste.next() : null;
687                     String fileName = first != null ? findLocationFile(first) : null;
688                     if (fileName != null) {
689                         writePoolObject(fileName);
690                         writeInt(findLocationLine(first));
691                     } else {
692                         writePoolObject(null);
693                     }
694                 }
695                 writePoolObject(findNodeSourcePositionCaller(pos));
696                 break;
697             }
698             case POOL_NODE: {
699                 Node node = (Node) found[0];
<span class="line-modified">700                 Objects.nonNull(node);</span>
701                 writeInt(findNodeId(node));
702                 writePoolObject(classForNode(node));
703                 break;
704             }
705             case POOL_NODE_CLASS: {
706                 NodeClass nodeClass = (NodeClass) found[0];
707                 final Object clazz = findJavaClass(nodeClass);
708                 if (versionMajor &gt;= 3) {
709                     writePoolObject(clazz);
710                     writeString(findNameTemplate(nodeClass));
711                 } else {
712                     writeString(((Class&lt;?&gt;) clazz).getSimpleName());
713                     String nameTemplate = findNameTemplate(nodeClass);
714                     writeString(nameTemplate);
715                 }
716                 writeEdgesInfo(nodeClass, true);
717                 writeEdgesInfo(nodeClass, false);
718                 break;
719             }
720             case POOL_CLASS: {
721                 String typeName = (String) found[0];
<span class="line-modified">722                 Objects.nonNull(typeName);</span>
723                 writeString(typeName);
724                 String[] enumValueNames = findEnumTypeValues(object);
725                 if (enumValueNames != null) {
726                     writeByte(ENUM_KLASS);
727                     writeInt(enumValueNames.length);
728                     for (String o : enumValueNames) {
729                         writePoolObject(o);
730                     }
731                 } else {
732                     writeByte(KLASS);
733                 }
734                 break;
735             }
736             case POOL_METHOD: {
737                 ResolvedJavaMethod method = (ResolvedJavaMethod) found[0];
<span class="line-modified">738                 Objects.nonNull(method);</span>
739                 writePoolObject(findMethodDeclaringClass(method));
740                 writePoolObject(findMethodName(method));
741                 final Signature methodSignature = findMethodSignature(method);
742                 if (findSignature(methodSignature) == null) {
743                     throw new IOException(&quot;Should be recognized as signature: &quot; + methodSignature + &quot; for &quot; + method);
744                 }
745                 writePoolObject(methodSignature);
746                 writeInt(findMethodModifiers(method));
747                 writeBytes(findMethodCode(method));
748                 break;
749             }
750             case POOL_ENUM: {
751                 int enumOrdinal = (int) found[0];
752                 writePoolObject(findEnumClass(object));
753                 writeInt(enumOrdinal);
754                 break;
755             }
756             case POOL_STRING: {
757                 writeString(object.toString());
758                 break;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.graphio;
 26 
 27 import java.io.Closeable;
 28 import java.io.IOException;
 29 import java.net.URI;
 30 import java.net.URISyntaxException;
<span class="line-added"> 31 import java.nio.Buffer;</span>
 32 import java.nio.ByteBuffer;
 33 import java.nio.channels.WritableByteChannel;
 34 import java.nio.charset.Charset;
 35 import java.util.Collection;
 36 import java.util.HashMap;
 37 import java.util.Iterator;
 38 import java.util.LinkedHashMap;
 39 import java.util.LinkedList;
 40 import java.util.Map;
 41 import java.util.Objects;
 42 
 43 abstract class GraphProtocol&lt;Graph, Node, NodeClass, Edges, Block, ResolvedJavaMethod, ResolvedJavaField, Signature, NodeSourcePosition, Location&gt; implements Closeable {
 44     private static final Charset UTF8 = Charset.forName(&quot;UTF-8&quot;);
 45 
 46     private static final int CONSTANT_POOL_MAX_SIZE = 8000;
 47 
 48     private static final int BEGIN_GROUP = 0x00;
 49     private static final int BEGIN_GRAPH = 0x01;
 50     private static final int CLOSE_GROUP = 0x02;
 51 
</pre>
<hr />
<pre>
 59     private static final int POOL_FIELD = 0x07;
 60     private static final int POOL_SIGNATURE = 0x08;
 61     private static final int POOL_NODE_SOURCE_POSITION = 0x09;
 62     private static final int POOL_NODE = 0x0a;
 63 
 64     private static final int PROPERTY_POOL = 0x00;
 65     private static final int PROPERTY_INT = 0x01;
 66     private static final int PROPERTY_LONG = 0x02;
 67     private static final int PROPERTY_DOUBLE = 0x03;
 68     private static final int PROPERTY_FLOAT = 0x04;
 69     private static final int PROPERTY_TRUE = 0x05;
 70     private static final int PROPERTY_FALSE = 0x06;
 71     private static final int PROPERTY_ARRAY = 0x07;
 72     private static final int PROPERTY_SUBGRAPH = 0x08;
 73 
 74     private static final int KLASS = 0x00;
 75     private static final int ENUM_KLASS = 0x01;
 76 
 77     private static final byte[] MAGIC_BYTES = {&#39;B&#39;, &#39;I&#39;, &#39;G&#39;, &#39;V&#39;};
 78 
<span class="line-added"> 79     private static final int MAJOR_VERSION = 6;</span>
<span class="line-added"> 80     private static final int MINOR_VERSION = 1;</span>
<span class="line-added"> 81 </span>
 82     private final ConstantPool constantPool;
 83     private final ByteBuffer buffer;
 84     private final WritableByteChannel channel;
 85     private final boolean embedded;
 86     final int versionMajor;
 87     final int versionMinor;
 88     private boolean printing;
 89 
<span class="line-added"> 90     /**</span>
<span class="line-added"> 91      * See {@code org.graalvm.compiler.serviceprovider.BufferUtil}.</span>
<span class="line-added"> 92      */</span>
<span class="line-added"> 93     private static Buffer asBaseBuffer(Buffer obj) {</span>
<span class="line-added"> 94         return obj;</span>
<span class="line-added"> 95     }</span>
<span class="line-added"> 96 </span>
 97     GraphProtocol(WritableByteChannel channel, int major, int minor, boolean embedded) throws IOException {
<span class="line-modified"> 98         if (major &gt; MAJOR_VERSION || (major == MAJOR_VERSION &amp;&amp; minor &gt; MINOR_VERSION)) {</span>
 99             throw new IllegalArgumentException(&quot;Unrecognized version &quot; + major + &quot;.&quot; + minor);
100         }
101         this.versionMajor = major;
102         this.versionMinor = minor;
103         this.constantPool = new ConstantPool();
104         this.buffer = ByteBuffer.allocateDirect(256 * 1024);
105         this.channel = channel;
106         this.embedded = embedded;
107         if (!embedded) {
108             writeVersion();
109             flushEmbedded();
110         }
111     }
112 
113     GraphProtocol(GraphProtocol&lt;?, ?, ?, ?, ?, ?, ?, ?, ?, ?&gt; parent) {
114         this.versionMajor = parent.versionMajor;
115         this.versionMinor = parent.versionMinor;
116         this.constantPool = parent.constantPool;
117         this.buffer = parent.buffer;
118         this.channel = parent.channel;
</pre>
<hr />
<pre>
319     protected abstract String findLocationLanguage(Location loc);
320 
321     protected abstract int findLocationStart(Location loc);
322 
323     protected abstract int findLocationEnd(Location loc);
324 
325     private void writeVersion() throws IOException {
326         writeBytesRaw(MAGIC_BYTES);
327         writeByte(versionMajor);
328         writeByte(versionMinor);
329     }
330 
331     private void flushEmbedded() throws IOException {
332         if (embedded) {
333             flush();
334             constantPool.reset();
335         }
336     }
337 
338     private void flush() throws IOException {
<span class="line-modified">339         asBaseBuffer(buffer).flip();</span>
340         /*
341          * Try not to let interrupted threads abort the write. There&#39;s still a race here but an
342          * interrupt that&#39;s been pending for a long time shouldn&#39;t stop this writing.
343          */
344         boolean interrupted = Thread.interrupted();
345         try {
346             channel.write(buffer);
347         } finally {
348             if (interrupted) {
349                 Thread.currentThread().interrupt();
350             }
351         }
352         buffer.compact();
353     }
354 
355     private void ensureAvailable(int i) throws IOException {
356         assert buffer.capacity() &gt;= i : &quot;Can not make &quot; + i + &quot; bytes available, buffer is too small&quot;;
357         while (buffer.remaining() &lt; i) {
358             flush();
359         }
</pre>
<hr />
<pre>
402             writeBytesRaw(b);
403         }
404     }
405 
406     private void writeBytesRaw(byte[] b) throws IOException {
407         int bytesWritten = 0;
408         while (bytesWritten &lt; b.length) {
409             int toWrite = Math.min(b.length - bytesWritten, buffer.capacity());
410             ensureAvailable(toWrite);
411             buffer.put(b, bytesWritten, toWrite);
412             bytesWritten += toWrite;
413         }
414     }
415 
416     private int writeBytesRaw(ByteBuffer b) throws IOException {
417         int limit = b.limit();
418         int written = 0;
419         while (b.position() &lt; limit) {
420             int toWrite = Math.min(limit - b.position(), buffer.capacity());
421             ensureAvailable(toWrite);
<span class="line-modified">422             asBaseBuffer(b).limit(b.position() + toWrite);</span>
423             try {
424                 buffer.put(b);
425                 written += toWrite;
426             } finally {
<span class="line-modified">427                 asBaseBuffer(b).limit(limit);</span>
428             }
429         }
430         return written;
431     }
432 
433     private void writeInts(int[] b) throws IOException {
434         if (b == null) {
435             writeInt(-1);
436         } else {
437             writeInt(b.length);
438             int sizeInBytes = b.length * 4;
439             ensureAvailable(sizeInBytes);
440             buffer.asIntBuffer().put(b);
<span class="line-modified">441             asBaseBuffer(buffer).position(buffer.position() + sizeInBytes);</span>
442         }
443     }
444 
445     private void writeDoubles(double[] b) throws IOException {
446         if (b == null) {
447             writeInt(-1);
448         } else {
449             writeInt(b.length);
450             int sizeInBytes = b.length * 8;
451             ensureAvailable(sizeInBytes);
452             buffer.asDoubleBuffer().put(b);
<span class="line-modified">453             asBaseBuffer(buffer).position(buffer.position() + sizeInBytes);</span>
454         }
455     }
456 
457     private void writePoolObject(Object obj) throws IOException {
458         Object object = obj;
459         if (object == null) {
460             writeByte(POOL_NULL);
461             return;
462         }
463         Character id = constantPool.get(object);
464         if (id == null) {
465             addPoolEntry(object);
466         } else {
467             int type = findPoolType(object, null);
468             writeByte(type);
469             writeShort(id.charValue());
470         }
471     }
472 
473     private int findPoolType(Object obj, Object[] found) throws IOException {
</pre>
<hr />
<pre>
628             writePoolObject(findName(edges, i));
629             if (dumpInputs) {
630                 writePoolObject(findType(edges, i));
631             }
632         }
633     }
634 
635     @SuppressWarnings(&quot;unchecked&quot;)
636     private void addPoolEntry(Object obj) throws IOException {
637         Object object = obj;
638         char index = constantPool.add(object);
639         writeByte(POOL_NEW);
640         writeShort(index);
641 
642         Object[] found = {null};
643         int type = findPoolType(object, found);
644         writeByte(type);
645         switch (type) {
646             case POOL_FIELD: {
647                 ResolvedJavaField field = (ResolvedJavaField) found[0];
<span class="line-modified">648                 Objects.requireNonNull(field);</span>
649                 writePoolObject(findFieldDeclaringClass(field));
650                 writePoolObject(findFieldName(field));
651                 writePoolObject(findFieldTypeName(field));
652                 writeInt(findFieldModifiers(field));
653                 break;
654             }
655             case POOL_SIGNATURE: {
656                 Signature signature = (Signature) found[0];
657                 int args = findSignatureParameterCount(signature);
658                 writeShort((char) args);
659                 for (int i = 0; i &lt; args; i++) {
660                     writePoolObject(findSignatureParameterTypeName(signature, i));
661                 }
662                 writePoolObject(findSignatureReturnTypeName(signature));
663                 break;
664             }
665             case POOL_NODE_SOURCE_POSITION: {
666                 NodeSourcePosition pos = (NodeSourcePosition) found[0];
<span class="line-modified">667                 Objects.requireNonNull(pos);</span>
668                 ResolvedJavaMethod method = findNodeSourcePositionMethod(pos);
669                 writePoolObject(method);
670                 final int bci = findNodeSourcePositionBCI(pos);
671                 writeInt(bci);
672                 Iterator&lt;Location&gt; ste = findLocation(method, bci, pos).iterator();
673                 if (versionMajor &gt;= 6) {
674                     while (ste.hasNext()) {
675                         Location loc = ste.next();
676                         URI uri;
677                         try {
678                             uri = findLocationURI(loc);
679                         } catch (URISyntaxException ex) {
680                             throw new IOException(ex);
681                         }
682                         if (uri == null) {
683                             continue;
684                         }
685                         String l = findLocationLanguage(loc);
686                         if (l == null) {
687                             continue;
</pre>
<hr />
<pre>
691                         writeInt(findLocationLine(loc));
692                         writeInt(findLocationStart(loc));
693                         writeInt(findLocationEnd(loc));
694                     }
695                     writePoolObject(null);
696                 } else {
697                     Location first = ste.hasNext() ? ste.next() : null;
698                     String fileName = first != null ? findLocationFile(first) : null;
699                     if (fileName != null) {
700                         writePoolObject(fileName);
701                         writeInt(findLocationLine(first));
702                     } else {
703                         writePoolObject(null);
704                     }
705                 }
706                 writePoolObject(findNodeSourcePositionCaller(pos));
707                 break;
708             }
709             case POOL_NODE: {
710                 Node node = (Node) found[0];
<span class="line-modified">711                 Objects.requireNonNull(node);</span>
712                 writeInt(findNodeId(node));
713                 writePoolObject(classForNode(node));
714                 break;
715             }
716             case POOL_NODE_CLASS: {
717                 NodeClass nodeClass = (NodeClass) found[0];
718                 final Object clazz = findJavaClass(nodeClass);
719                 if (versionMajor &gt;= 3) {
720                     writePoolObject(clazz);
721                     writeString(findNameTemplate(nodeClass));
722                 } else {
723                     writeString(((Class&lt;?&gt;) clazz).getSimpleName());
724                     String nameTemplate = findNameTemplate(nodeClass);
725                     writeString(nameTemplate);
726                 }
727                 writeEdgesInfo(nodeClass, true);
728                 writeEdgesInfo(nodeClass, false);
729                 break;
730             }
731             case POOL_CLASS: {
732                 String typeName = (String) found[0];
<span class="line-modified">733                 Objects.requireNonNull(typeName);</span>
734                 writeString(typeName);
735                 String[] enumValueNames = findEnumTypeValues(object);
736                 if (enumValueNames != null) {
737                     writeByte(ENUM_KLASS);
738                     writeInt(enumValueNames.length);
739                     for (String o : enumValueNames) {
740                         writePoolObject(o);
741                     }
742                 } else {
743                     writeByte(KLASS);
744                 }
745                 break;
746             }
747             case POOL_METHOD: {
748                 ResolvedJavaMethod method = (ResolvedJavaMethod) found[0];
<span class="line-modified">749                 Objects.requireNonNull(method);</span>
750                 writePoolObject(findMethodDeclaringClass(method));
751                 writePoolObject(findMethodName(method));
752                 final Signature methodSignature = findMethodSignature(method);
753                 if (findSignature(methodSignature) == null) {
754                     throw new IOException(&quot;Should be recognized as signature: &quot; + methodSignature + &quot; for &quot; + method);
755                 }
756                 writePoolObject(methodSignature);
757                 writeInt(findMethodModifiers(method));
758                 writeBytes(findMethodCode(method));
759                 break;
760             }
761             case POOL_ENUM: {
762                 int enumOrdinal = (int) found[0];
763                 writePoolObject(findEnumClass(object));
764                 writeInt(enumOrdinal);
765                 break;
766             }
767             case POOL_STRING: {
768                 writeString(object.toString());
769                 break;
</pre>
</td>
</tr>
</table>
<center><a href="GraphOutput.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ProtocolImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.graphio/src/org/graalvm/graphio/GraphProtocol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraphOutput.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ProtocolImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.graphio/src/org/graalvm/graphio/GraphProtocol.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  
  import java.io.Closeable;
  import java.io.IOException;
  import java.net.URI;
  import java.net.URISyntaxException;
<span class="line-added">+ import java.nio.Buffer;</span>
  import java.nio.ByteBuffer;
  import java.nio.channels.WritableByteChannel;
  import java.nio.charset.Charset;
  import java.util.Collection;
  import java.util.HashMap;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,20 ***</span>
      private static final int KLASS = 0x00;
      private static final int ENUM_KLASS = 0x01;
  
      private static final byte[] MAGIC_BYTES = {&#39;B&#39;, &#39;I&#39;, &#39;G&#39;, &#39;V&#39;};
  
      private final ConstantPool constantPool;
      private final ByteBuffer buffer;
      private final WritableByteChannel channel;
      private final boolean embedded;
      final int versionMajor;
      final int versionMinor;
      private boolean printing;
  
      GraphProtocol(WritableByteChannel channel, int major, int minor, boolean embedded) throws IOException {
<span class="line-modified">!         if (major &gt; 6 || (major == 6 &amp;&amp; minor &gt; 0)) {</span>
              throw new IllegalArgumentException(&quot;Unrecognized version &quot; + major + &quot;.&quot; + minor);
          }
          this.versionMajor = major;
          this.versionMinor = minor;
          this.constantPool = new ConstantPool();
<span class="line-new-header">--- 74,30 ---</span>
      private static final int KLASS = 0x00;
      private static final int ENUM_KLASS = 0x01;
  
      private static final byte[] MAGIC_BYTES = {&#39;B&#39;, &#39;I&#39;, &#39;G&#39;, &#39;V&#39;};
  
<span class="line-added">+     private static final int MAJOR_VERSION = 6;</span>
<span class="line-added">+     private static final int MINOR_VERSION = 1;</span>
<span class="line-added">+ </span>
      private final ConstantPool constantPool;
      private final ByteBuffer buffer;
      private final WritableByteChannel channel;
      private final boolean embedded;
      final int versionMajor;
      final int versionMinor;
      private boolean printing;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * See {@code org.graalvm.compiler.serviceprovider.BufferUtil}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static Buffer asBaseBuffer(Buffer obj) {</span>
<span class="line-added">+         return obj;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      GraphProtocol(WritableByteChannel channel, int major, int minor, boolean embedded) throws IOException {
<span class="line-modified">!         if (major &gt; MAJOR_VERSION || (major == MAJOR_VERSION &amp;&amp; minor &gt; MINOR_VERSION)) {</span>
              throw new IllegalArgumentException(&quot;Unrecognized version &quot; + major + &quot;.&quot; + minor);
          }
          this.versionMajor = major;
          this.versionMinor = minor;
          this.constantPool = new ConstantPool();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 323,11 ***</span>
              constantPool.reset();
          }
      }
  
      private void flush() throws IOException {
<span class="line-modified">!         buffer.flip();</span>
          /*
           * Try not to let interrupted threads abort the write. There&#39;s still a race here but an
           * interrupt that&#39;s been pending for a long time shouldn&#39;t stop this writing.
           */
          boolean interrupted = Thread.interrupted();
<span class="line-new-header">--- 334,11 ---</span>
              constantPool.reset();
          }
      }
  
      private void flush() throws IOException {
<span class="line-modified">!         asBaseBuffer(buffer).flip();</span>
          /*
           * Try not to let interrupted threads abort the write. There&#39;s still a race here but an
           * interrupt that&#39;s been pending for a long time shouldn&#39;t stop this writing.
           */
          boolean interrupted = Thread.interrupted();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 406,16 ***</span>
          int limit = b.limit();
          int written = 0;
          while (b.position() &lt; limit) {
              int toWrite = Math.min(limit - b.position(), buffer.capacity());
              ensureAvailable(toWrite);
<span class="line-modified">!             b.limit(b.position() + toWrite);</span>
              try {
                  buffer.put(b);
                  written += toWrite;
              } finally {
<span class="line-modified">!                 b.limit(limit);</span>
              }
          }
          return written;
      }
  
<span class="line-new-header">--- 417,16 ---</span>
          int limit = b.limit();
          int written = 0;
          while (b.position() &lt; limit) {
              int toWrite = Math.min(limit - b.position(), buffer.capacity());
              ensureAvailable(toWrite);
<span class="line-modified">!             asBaseBuffer(b).limit(b.position() + toWrite);</span>
              try {
                  buffer.put(b);
                  written += toWrite;
              } finally {
<span class="line-modified">!                 asBaseBuffer(b).limit(limit);</span>
              }
          }
          return written;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 425,11 ***</span>
          } else {
              writeInt(b.length);
              int sizeInBytes = b.length * 4;
              ensureAvailable(sizeInBytes);
              buffer.asIntBuffer().put(b);
<span class="line-modified">!             buffer.position(buffer.position() + sizeInBytes);</span>
          }
      }
  
      private void writeDoubles(double[] b) throws IOException {
          if (b == null) {
<span class="line-new-header">--- 436,11 ---</span>
          } else {
              writeInt(b.length);
              int sizeInBytes = b.length * 4;
              ensureAvailable(sizeInBytes);
              buffer.asIntBuffer().put(b);
<span class="line-modified">!             asBaseBuffer(buffer).position(buffer.position() + sizeInBytes);</span>
          }
      }
  
      private void writeDoubles(double[] b) throws IOException {
          if (b == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 437,11 ***</span>
          } else {
              writeInt(b.length);
              int sizeInBytes = b.length * 8;
              ensureAvailable(sizeInBytes);
              buffer.asDoubleBuffer().put(b);
<span class="line-modified">!             buffer.position(buffer.position() + sizeInBytes);</span>
          }
      }
  
      private void writePoolObject(Object obj) throws IOException {
          Object object = obj;
<span class="line-new-header">--- 448,11 ---</span>
          } else {
              writeInt(b.length);
              int sizeInBytes = b.length * 8;
              ensureAvailable(sizeInBytes);
              buffer.asDoubleBuffer().put(b);
<span class="line-modified">!             asBaseBuffer(buffer).position(buffer.position() + sizeInBytes);</span>
          }
      }
  
      private void writePoolObject(Object obj) throws IOException {
          Object object = obj;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 632,11 ***</span>
          int type = findPoolType(object, found);
          writeByte(type);
          switch (type) {
              case POOL_FIELD: {
                  ResolvedJavaField field = (ResolvedJavaField) found[0];
<span class="line-modified">!                 Objects.nonNull(field);</span>
                  writePoolObject(findFieldDeclaringClass(field));
                  writePoolObject(findFieldName(field));
                  writePoolObject(findFieldTypeName(field));
                  writeInt(findFieldModifiers(field));
                  break;
<span class="line-new-header">--- 643,11 ---</span>
          int type = findPoolType(object, found);
          writeByte(type);
          switch (type) {
              case POOL_FIELD: {
                  ResolvedJavaField field = (ResolvedJavaField) found[0];
<span class="line-modified">!                 Objects.requireNonNull(field);</span>
                  writePoolObject(findFieldDeclaringClass(field));
                  writePoolObject(findFieldName(field));
                  writePoolObject(findFieldTypeName(field));
                  writeInt(findFieldModifiers(field));
                  break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 651,11 ***</span>
                  writePoolObject(findSignatureReturnTypeName(signature));
                  break;
              }
              case POOL_NODE_SOURCE_POSITION: {
                  NodeSourcePosition pos = (NodeSourcePosition) found[0];
<span class="line-modified">!                 Objects.nonNull(pos);</span>
                  ResolvedJavaMethod method = findNodeSourcePositionMethod(pos);
                  writePoolObject(method);
                  final int bci = findNodeSourcePositionBCI(pos);
                  writeInt(bci);
                  Iterator&lt;Location&gt; ste = findLocation(method, bci, pos).iterator();
<span class="line-new-header">--- 662,11 ---</span>
                  writePoolObject(findSignatureReturnTypeName(signature));
                  break;
              }
              case POOL_NODE_SOURCE_POSITION: {
                  NodeSourcePosition pos = (NodeSourcePosition) found[0];
<span class="line-modified">!                 Objects.requireNonNull(pos);</span>
                  ResolvedJavaMethod method = findNodeSourcePositionMethod(pos);
                  writePoolObject(method);
                  final int bci = findNodeSourcePositionBCI(pos);
                  writeInt(bci);
                  Iterator&lt;Location&gt; ste = findLocation(method, bci, pos).iterator();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 695,11 ***</span>
                  writePoolObject(findNodeSourcePositionCaller(pos));
                  break;
              }
              case POOL_NODE: {
                  Node node = (Node) found[0];
<span class="line-modified">!                 Objects.nonNull(node);</span>
                  writeInt(findNodeId(node));
                  writePoolObject(classForNode(node));
                  break;
              }
              case POOL_NODE_CLASS: {
<span class="line-new-header">--- 706,11 ---</span>
                  writePoolObject(findNodeSourcePositionCaller(pos));
                  break;
              }
              case POOL_NODE: {
                  Node node = (Node) found[0];
<span class="line-modified">!                 Objects.requireNonNull(node);</span>
                  writeInt(findNodeId(node));
                  writePoolObject(classForNode(node));
                  break;
              }
              case POOL_NODE_CLASS: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 717,11 ***</span>
                  writeEdgesInfo(nodeClass, false);
                  break;
              }
              case POOL_CLASS: {
                  String typeName = (String) found[0];
<span class="line-modified">!                 Objects.nonNull(typeName);</span>
                  writeString(typeName);
                  String[] enumValueNames = findEnumTypeValues(object);
                  if (enumValueNames != null) {
                      writeByte(ENUM_KLASS);
                      writeInt(enumValueNames.length);
<span class="line-new-header">--- 728,11 ---</span>
                  writeEdgesInfo(nodeClass, false);
                  break;
              }
              case POOL_CLASS: {
                  String typeName = (String) found[0];
<span class="line-modified">!                 Objects.requireNonNull(typeName);</span>
                  writeString(typeName);
                  String[] enumValueNames = findEnumTypeValues(object);
                  if (enumValueNames != null) {
                      writeByte(ENUM_KLASS);
                      writeInt(enumValueNames.length);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 733,11 ***</span>
                  }
                  break;
              }
              case POOL_METHOD: {
                  ResolvedJavaMethod method = (ResolvedJavaMethod) found[0];
<span class="line-modified">!                 Objects.nonNull(method);</span>
                  writePoolObject(findMethodDeclaringClass(method));
                  writePoolObject(findMethodName(method));
                  final Signature methodSignature = findMethodSignature(method);
                  if (findSignature(methodSignature) == null) {
                      throw new IOException(&quot;Should be recognized as signature: &quot; + methodSignature + &quot; for &quot; + method);
<span class="line-new-header">--- 744,11 ---</span>
                  }
                  break;
              }
              case POOL_METHOD: {
                  ResolvedJavaMethod method = (ResolvedJavaMethod) found[0];
<span class="line-modified">!                 Objects.requireNonNull(method);</span>
                  writePoolObject(findMethodDeclaringClass(method));
                  writePoolObject(findMethodName(method));
                  final Signature methodSignature = findMethodSignature(method);
                  if (findSignature(methodSignature) == null) {
                      throw new IOException(&quot;Should be recognized as signature: &quot; + methodSignature + &quot; for &quot; + method);
</pre>
<center><a href="GraphOutput.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ProtocolImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
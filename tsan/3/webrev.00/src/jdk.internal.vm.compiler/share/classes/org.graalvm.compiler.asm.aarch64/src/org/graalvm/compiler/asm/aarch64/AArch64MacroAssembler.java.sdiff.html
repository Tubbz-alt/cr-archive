<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64Assembler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64AsmOptions.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 
  26 package org.graalvm.compiler.asm.aarch64;
  27 





  28 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.BASE_REGISTER_ONLY;
  29 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.EXTENDED_REGISTER_OFFSET;
  30 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.IMMEDIATE_SCALED;
  31 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.IMMEDIATE_UNSCALED;
  32 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.REGISTER_OFFSET;


  33 import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.ADD_TO_BASE;
  34 import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.ADD_TO_INDEX;
  35 import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.NO_WORK;
  36 
  37 import org.graalvm.compiler.asm.BranchTargetOutOfBoundsException;
<span class="line-removed">  38 </span>
<span class="line-removed">  39 import static jdk.vm.ci.aarch64.AArch64.CPU;</span>
<span class="line-removed">  40 import static jdk.vm.ci.aarch64.AArch64.r8;</span>
<span class="line-removed">  41 import static jdk.vm.ci.aarch64.AArch64.r9;</span>
<span class="line-removed">  42 import static jdk.vm.ci.aarch64.AArch64.sp;</span>
<span class="line-removed">  43 import static jdk.vm.ci.aarch64.AArch64.zr;</span>
<span class="line-removed">  44 </span>
  45 import org.graalvm.compiler.asm.Label;
  46 import org.graalvm.compiler.core.common.NumUtil;
  47 import org.graalvm.compiler.debug.GraalError;
  48 
  49 import jdk.vm.ci.aarch64.AArch64;
  50 import jdk.vm.ci.code.Register;
  51 import jdk.vm.ci.code.TargetDescription;
  52 
  53 public class AArch64MacroAssembler extends AArch64Assembler {
  54 
<span class="line-modified">  55     private final ScratchRegister[] scratchRegister = new ScratchRegister[]{new ScratchRegister(r8), new ScratchRegister(r9)};</span>
  56 
  57     // Points to the next free scratch register
  58     private int nextFreeScratchRegister = 0;
  59 




  60     public AArch64MacroAssembler(TargetDescription target) {
  61         super(target);
  62     }
  63 
  64     public class ScratchRegister implements AutoCloseable {
  65         private final Register register;
  66 
  67         public ScratchRegister(Register register) {
  68             this.register = register;
  69         }
  70 
  71         public Register getRegister() {
  72             return register;
  73         }
  74 
  75         @Override
  76         public void close() {
  77             assert nextFreeScratchRegister &gt; 0 : &quot;Close called too often&quot;;
  78             nextFreeScratchRegister--;
  79         }
  80     }
  81 
  82     public ScratchRegister getScratchRegister() {
  83         return scratchRegister[nextFreeScratchRegister++];
  84     }
  85 





































  86     /**
  87      * Specifies what actions have to be taken to turn an arbitrary address of the form
  88      * {@code base + displacement [+ index [&lt;&lt; scale]]} into a valid AArch64Address.
  89      */
  90     public static class AddressGenerationPlan {
  91         public final WorkPlan workPlan;
  92         public final AArch64Address.AddressingMode addressingMode;
  93         public final boolean needsScratch;
  94 
  95         public enum WorkPlan {
  96             /**
  97              * Can be used as-is without extra work.
  98              */
  99             NO_WORK,
 100             /**
 101              * Add scaled displacement to index register.
 102              */
 103             ADD_TO_INDEX,
 104             /**
 105              * Add unscaled displacement to base register.
</pre>
<hr />
<pre>
 249      * @param allowOverwrite if true allows to change value of base or index register to generate
 250      *            address.
 251      * @return AArch64Address pointing to memory at {@code base + displacement}.
 252      */
 253     public AArch64Address makeAddress(Register base, long displacement, Register additionalReg, int transferSize, boolean allowOverwrite) {
 254         assert additionalReg.getRegisterCategory().equals(CPU);
 255         return makeAddress(base, displacement, zr, /* sign-extend */false, transferSize, additionalReg, allowOverwrite);
 256     }
 257 
 258     /**
 259      * Returns an AArch64Address pointing to {@code base + displacement}. Fails if address cannot be
 260      * represented without overwriting base register or using a scratch register.
 261      *
 262      * @param base general purpose register. May not be null or the zero register.
 263      * @param displacement arbitrary displacement added to base.
 264      * @param transferSize the memory transfer size in bytes. The log2 of this specifies how much
 265      *            the index register is scaled. If 0 no scaling is assumed. Can be 0, 1, 2, 4 or 8.
 266      * @return AArch64Address pointing to memory at {@code base + displacement}.
 267      */
 268     public AArch64Address makeAddress(Register base, long displacement, int transferSize) {
<span class="line-modified"> 269         return makeAddress(base, displacement, zr, /* signExtend */false, transferSize, zr, /* allowOverwrite */false);</span>

 270     }
 271 
 272     /**
 273      * Loads memory address into register.
 274      *
 275      * @param dst general purpose register. May not be null, zero-register or stackpointer.
 276      * @param address address whose value is loaded into dst. May not be null,
 277      *            {@link org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode#IMMEDIATE_POST_INDEXED
 278      *            POST_INDEXED} or
 279      *            {@link org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode#IMMEDIATE_PRE_INDEXED
 280      *            IMMEDIATE_PRE_INDEXED}
 281      * @param transferSize the memory transfer size in bytes. The log2 of this specifies how much
 282      *            the index register is scaled. Can be 1, 2, 4 or 8.
 283      */
 284     public void loadAddress(Register dst, AArch64Address address, int transferSize) {
 285         assert transferSize == 1 || transferSize == 2 || transferSize == 4 || transferSize == 8;
 286         assert dst.getRegisterCategory().equals(CPU);
 287         int shiftAmt = NumUtil.log2Ceil(transferSize);
 288         switch (address.getAddressingMode()) {
 289             case IMMEDIATE_SCALED:
</pre>
<hr />
<pre>
 305                 add(64, dst, address.getBase(), immediate);
 306                 break;
 307             case REGISTER_OFFSET:
 308                 add(64, dst, address.getBase(), address.getOffset(), ShiftType.LSL, address.isScaled() ? shiftAmt : 0);
 309                 break;
 310             case EXTENDED_REGISTER_OFFSET:
 311                 add(64, dst, address.getBase(), address.getOffset(), address.getExtendType(), address.isScaled() ? shiftAmt : 0);
 312                 break;
 313             case PC_LITERAL: {
 314                 addressOf(dst);
 315                 break;
 316             }
 317             case BASE_REGISTER_ONLY:
 318                 movx(dst, address.getBase());
 319                 break;
 320             default:
 321                 throw GraalError.shouldNotReachHere();
 322         }
 323     }
 324 






























































































































 325     public void movx(Register dst, Register src) {
 326         mov(64, dst, src);
 327     }
 328 
 329     public void mov(int size, Register dst, Register src) {
 330         if (dst.equals(sp) || src.equals(sp)) {
 331             add(size, dst, src, 0);
 332         } else {
 333             or(size, dst, zr, src);
 334         }
 335     }
 336 
 337     /**
 338      * Generates a 64-bit immediate move code sequence.
 339      *
 340      * @param dst general purpose register. May not be null, stackpointer or zero-register.
<span class="line-modified"> 341      * @param imm</span>

 342      */
<span class="line-modified"> 343     private void mov64(Register dst, long imm) {</span>
 344         // We have to move all non zero parts of the immediate in 16-bit chunks


 345         boolean firstMove = true;
 346         for (int offset = 0; offset &lt; 64; offset += 16) {
 347             int chunk = (int) (imm &gt;&gt; offset) &amp; NumUtil.getNbitNumberInt(16);
 348             if (chunk == 0) {
 349                 continue;
 350             }
 351             if (firstMove) {
 352                 movz(64, dst, chunk, offset);
 353                 firstMove = false;
 354             } else {
 355                 movk(64, dst, chunk, offset);
 356             }

 357         }
 358         assert !firstMove;



 359     }
 360 
 361     /**
 362      * Loads immediate into register.
 363      *
 364      * @param dst general purpose register. May not be null, zero-register or stackpointer.
 365      * @param imm immediate loaded into register.
 366      */
 367     public void mov(Register dst, long imm) {











 368         assert dst.getRegisterCategory().equals(CPU);
 369         if (imm == 0L) {
 370             movx(dst, zr);
 371         } else if (LogicalImmediateTable.isRepresentable(true, imm) != LogicalImmediateTable.Representable.NO) {
 372             or(64, dst, zr, imm);
 373         } else if (imm &gt;&gt; 32 == -1L &amp;&amp; (int) imm &lt; 0 &amp;&amp; LogicalImmediateTable.isRepresentable((int) imm) != LogicalImmediateTable.Representable.NO) {
 374             // If the higher 32-bit are 1s and the sign bit of the lower 32-bits is set *and* we can
 375             // represent the lower 32 bits as a logical immediate we can create the lower 32-bit and
 376             // then sign extend
 377             // them. This allows us to cover immediates like ~1L with 2 instructions.
 378             mov(dst, (int) imm);
 379             sxt(64, 32, dst, dst);
 380         } else {
<span class="line-modified"> 381             mov64(dst, imm);</span>
 382         }
 383     }
 384 
 385     /**
 386      * Loads immediate into register.
 387      *
 388      * @param dst general purpose register. May not be null, zero-register or stackpointer.
 389      * @param imm immediate loaded into register.
 390      */
 391     public void mov(Register dst, int imm) {
 392         mov(dst, imm &amp; 0xFFFF_FFFFL);
 393     }
 394 
 395     /**
 396      * Generates a 48-bit immediate move code sequence. The immediate may later be updated by
 397      * HotSpot.
 398      *
 399      * In AArch64 mode the virtual address space is 48-bits in size, so we only need three
 400      * instructions to create a patchable instruction sequence that can reach anywhere.
 401      *
 402      * @param dst general purpose register. May not be null, stackpointer or zero-register.
 403      * @param imm
 404      */
 405     public void movNativeAddress(Register dst, long imm) {















 406         assert (imm &amp; 0xFFFF_0000_0000_0000L) == 0;
 407         // We have to move all non zero parts of the immediate in 16-bit chunks
 408         boolean firstMove = true;

 409         for (int offset = 0; offset &lt; 48; offset += 16) {
 410             int chunk = (int) (imm &gt;&gt; offset) &amp; NumUtil.getNbitNumberInt(16);
 411             if (firstMove) {
 412                 movz(64, dst, chunk, offset);
 413                 firstMove = false;
 414             } else {
 415                 movk(64, dst, chunk, offset);
 416             }
 417         }



 418         assert !firstMove;
 419     }
 420 
 421     /**
 422      * Generates a 32-bit immediate move code sequence. The immediate may later be updated by
 423      * HotSpot.
 424      *
 425      * @param dst general purpose register. May not be null, stackpointer or zero-register.
 426      * @param imm
 427      */
 428     public void movNarrowAddress(Register dst, long imm) {
 429         assert (imm &amp; 0xFFFF_FFFF_0000_0000L) == 0;
 430         movz(64, dst, (int) (imm &gt;&gt;&gt; 16), 16);
 431         movk(64, dst, (int) (imm &amp; 0xffff), 0);
 432     }
 433 
 434     /**
 435      * @return Number of instructions necessary to load immediate into register.
 436      */
 437     public static int nrInstructionsToMoveImmediate(long imm) {
</pre>
<hr />
<pre>
 452                 nrInstructions++;
 453             }
 454         }
 455         return nrInstructions;
 456     }
 457 
 458     /**
 459      * Loads a srcSize value from address into rt sign-extending it if necessary.
 460      *
 461      * @param targetSize size of target register in bits. Must be 32 or 64.
 462      * @param srcSize size of memory read in bits. Must be 8, 16 or 32 and smaller or equal to
 463      *            targetSize.
 464      * @param rt general purpose register. May not be null or stackpointer.
 465      * @param address all addressing modes allowed. May not be null.
 466      */
 467     @Override
 468     public void ldrs(int targetSize, int srcSize, Register rt, AArch64Address address) {
 469         assert targetSize == 32 || targetSize == 64;
 470         assert srcSize &lt;= targetSize;
 471         if (targetSize == srcSize) {
<span class="line-modified"> 472             super.ldr(srcSize, rt, address);</span>
 473         } else {
 474             super.ldrs(targetSize, srcSize, rt, address);
 475         }
 476     }
 477 
 478     /**
 479      * Loads a srcSize value from address into rt zero-extending it if necessary.
 480      *
 481      * @param srcSize size of memory read in bits. Must be 8, 16 or 32 and smaller or equal to
 482      *            targetSize.
 483      * @param rt general purpose register. May not be null or stackpointer.
 484      * @param address all addressing modes allowed. May not be null.
 485      */
 486     @Override
 487     public void ldr(int srcSize, Register rt, AArch64Address address) {
<span class="line-modified"> 488         super.ldr(srcSize, rt, address);</span>


















 489     }
 490 
 491     /**
 492      * Conditional move. dst = src1 if condition else src2.
 493      *
 494      * @param size register size. Has to be 32 or 64.
 495      * @param result general purpose register. May not be null or the stackpointer.
 496      * @param trueValue general purpose register. May not be null or the stackpointer.
 497      * @param falseValue general purpose register. May not be null or the stackpointer.
 498      * @param cond any condition flag. May not be null.
 499      */
 500     public void cmov(int size, Register result, Register trueValue, Register falseValue, ConditionFlag cond) {
 501         super.csel(size, result, trueValue, falseValue, cond);
 502     }
 503 
 504     /**
 505      * Conditional set. dst = 1 if condition else 0.
 506      *
 507      * @param dst general purpose register. May not be null or stackpointer.
 508      * @param condition any condition. May not be null.
</pre>
<hr />
<pre>
 764      * @param src3 general purpose register. May not be null or the stackpointer.
 765      */
 766     @Override
 767     public void msub(int size, Register dst, Register src1, Register src2, Register src3) {
 768         super.msub(size, dst, src1, src2, src3);
 769     }
 770 
 771     /**
 772      * dst = 0 - src1 * src2.
 773      *
 774      * @param size register size. Has to be 32 or 64.
 775      * @param dst general purpose register. May not be null or the stackpointer.
 776      * @param src1 general purpose register. May not be null or the stackpointer.
 777      * @param src2 general purpose register. May not be null or the stackpointer.
 778      */
 779     public void mneg(int size, Register dst, Register src1, Register src2) {
 780         super.msub(size, dst, src1, src2, zr);
 781     }
 782 
 783     /**
<span class="line-modified"> 784      * unsigned multiply high. dst = (src1 * src2) &gt;&gt; size</span>
 785      *
 786      * @param size register size. Has to be 32 or 64.
 787      * @param dst general purpose register. May not be null or the stackpointer.
 788      * @param src1 general purpose register. May not be null or the stackpointer.
 789      * @param src2 general purpose register. May not be null or the stackpointer.
 790      */
 791     public void umulh(int size, Register dst, Register src1, Register src2) {
 792         assert (!dst.equals(sp) &amp;&amp; !src1.equals(sp) &amp;&amp; !src2.equals(sp));
 793         assert size == 32 || size == 64;
 794         if (size == 64) {
 795             super.umulh(dst, src1, src2);
 796         } else {
 797             // xDst = wSrc1 * wSrc2
 798             super.umaddl(dst, src1, src2, zr);
 799             // xDst = xDst &gt;&gt; 32
 800             lshr(64, dst, dst, 32);
 801         }
 802     }
 803 
 804     /**
<span class="line-modified"> 805      * signed multiply high. dst = (src1 * src2) &gt;&gt; size</span>
 806      *
 807      * @param size register size. Has to be 32 or 64.
 808      * @param dst general purpose register. May not be null or the stackpointer.
 809      * @param src1 general purpose register. May not be null or the stackpointer.
 810      * @param src2 general purpose register. May not be null or the stackpointer.
 811      */
 812     public void smulh(int size, Register dst, Register src1, Register src2) {
 813         assert (!dst.equals(sp) &amp;&amp; !src1.equals(sp) &amp;&amp; !src2.equals(sp));
 814         assert size == 32 || size == 64;
 815         if (size == 64) {
 816             super.smulh(dst, src1, src2);
 817         } else {
 818             // xDst = wSrc1 * wSrc2
 819             super.smaddl(dst, src1, src2, zr);
 820             // xDst = xDst &gt;&gt; 32
 821             lshr(64, dst, dst, 32);
 822         }
 823     }
 824 






















































 825     /**
 826      * dst = src1 % src2. Signed.
 827      *
 828      * @param size register size. Has to be 32 or 64.
 829      * @param dst general purpose register. May not be null or the stackpointer.
 830      * @param n numerator. General purpose register. May not be null or the stackpointer.
 831      * @param d denominator. General purpose register. Divisor May not be null or the stackpointer.
 832      */
 833     public void rem(int size, Register dst, Register n, Register d) {
 834         assert (!dst.equals(sp) &amp;&amp; !n.equals(sp) &amp;&amp; !d.equals(sp));
 835         // There is no irem or similar instruction. Instead we use the relation:
 836         // n % d = n - Floor(n / d) * d if nd &gt;= 0
 837         // n % d = n - Ceil(n / d) * d else
 838         // Which is equivalent to n - TruncatingDivision(n, d) * d
 839         super.sdiv(size, dst, n, d);
 840         super.msub(size, dst, dst, d, n);
 841     }
 842 
 843     /**
 844      * dst = src1 % src2. Unsigned.
</pre>
<hr />
<pre>
1255     public void fcmov(int size, Register result, Register trueValue, Register falseValue, ConditionFlag condition) {
1256         super.fcsel(size, result, trueValue, falseValue, condition);
1257     }
1258 
1259     /**
1260      * dst = src1 % src2.
1261      *
1262      * @param size register size. Has to be 32 or 64.
1263      * @param dst floating-point register. May not be null.
1264      * @param n numerator. Floating-point register. May not be null.
1265      * @param d denominator. Floating-point register. May not be null.
1266      */
1267     public void frem(int size, Register dst, Register n, Register d) {
1268         // There is no frem instruction, instead we compute the remainder using the relation:
1269         // rem = n - Truncating(n / d) * d
1270         super.fdiv(size, dst, n, d);
1271         super.frintz(size, dst, dst);
1272         super.fmsub(size, dst, dst, d, n);
1273     }
1274 














1275     /* Branches */
1276 
1277     /**
1278      * Compares x and y and sets condition flags.
1279      *
1280      * @param size register size. Has to be 32 or 64.
1281      * @param x general purpose register. May not be null or stackpointer.
1282      * @param y general purpose register. May not be null or stackpointer.
1283      */
1284     public void cmp(int size, Register x, Register y) {
1285         assert size == 32 || size == 64;
1286         super.subs(size, zr, x, y, ShiftType.LSL, 0);
1287     }
1288 
1289     /**
1290      * Compares x to y and sets condition flags.
1291      *
1292      * @param size register size. Has to be 32 or 64.
1293      * @param x general purpose register. May not be null or stackpointer.
1294      * @param y comparison immediate, {@link #isComparisonImmediate(long)} has to be true for it.
</pre>
<hr />
<pre>
1312      */
1313     public void ands(int size, Register dst, Register x, Register y) {
1314         super.ands(size, dst, x, y, ShiftType.LSL, 0);
1315     }
1316 
1317     /**
1318      * Sets overflow flag according to result of x * y.
1319      *
1320      * @param size register size. Has to be 32 or 64.
1321      * @param dst general purpose register. May not be null or stack-pointer.
1322      * @param x general purpose register. May not be null or stackpointer.
1323      * @param y general purpose register. May not be null or stackpointer.
1324      */
1325     public void mulvs(int size, Register dst, Register x, Register y) {
1326         try (ScratchRegister sc1 = getScratchRegister();
1327                         ScratchRegister sc2 = getScratchRegister()) {
1328             switch (size) {
1329                 case 64: {
1330                     // Be careful with registers: it&#39;s possible that x, y, and dst are the same
1331                     // register.
<span class="line-modified">1332                     Register rscratch1 = sc1.getRegister();</span>
<span class="line-modified">1333                     Register rscratch2 = sc2.getRegister();</span>
<span class="line-modified">1334                     mul(64, rscratch1, x, y);     // Result bits 0..63</span>
<span class="line-modified">1335                     smulh(64, rscratch2, x, y);  // Result bits 64..127</span>
1336                     // Top is pure sign ext
<span class="line-modified">1337                     subs(64, zr, rscratch2, rscratch1, ShiftType.ASR, 63);</span>
1338                     // Copy all 64 bits of the result into dst
<span class="line-modified">1339                     mov(64, dst, rscratch1);</span>
<span class="line-modified">1340                     mov(rscratch1, 0x80000000);</span>
1341                     // Develop 0 (EQ), or 0x80000000 (NE)
<span class="line-modified">1342                     cmov(32, rscratch1, rscratch1, zr, ConditionFlag.NE);</span>
<span class="line-modified">1343                     cmp(32, rscratch1, 1);</span>
1344                     // 0x80000000 - 1 =&gt; VS
1345                     break;
1346                 }
1347                 case 32: {
<span class="line-modified">1348                     Register rscratch1 = sc1.getRegister();</span>
<span class="line-modified">1349                     smaddl(rscratch1, x, y, zr);</span>
1350                     // Copy the low 32 bits of the result into dst
<span class="line-modified">1351                     mov(32, dst, rscratch1);</span>
<span class="line-modified">1352                     subs(64, zr, rscratch1, rscratch1, ExtendType.SXTW, 0);</span>
1353                     // NE =&gt; overflow
<span class="line-modified">1354                     mov(rscratch1, 0x80000000);</span>
1355                     // Develop 0 (EQ), or 0x80000000 (NE)
<span class="line-modified">1356                     cmov(32, rscratch1, rscratch1, zr, ConditionFlag.NE);</span>
<span class="line-modified">1357                     cmp(32, rscratch1, 1);</span>
1358                     // 0x80000000 - 1 =&gt; VS
1359                     break;
1360                 }
1361             }
1362         }
1363     }
1364 
1365     /**
1366      * When patching up Labels we have to know what kind of code to generate.
1367      */
1368     public enum PatchLabelKind {
1369         BRANCH_CONDITIONALLY(0x0),
1370         BRANCH_UNCONDITIONALLY(0x1),
1371         BRANCH_NONZERO(0x2),
1372         BRANCH_ZERO(0x3),
1373         BRANCH_BIT_NONZERO(0x4),
1374         BRANCH_BIT_ZERO(0x5),
1375         JUMP_ADDRESS(0x6),
1376         ADR(0x7);
1377 
</pre>
<hr />
<pre>
1385 
1386         PatchLabelKind(int encoding) {
1387             this.encoding = encoding;
1388         }
1389 
1390         /**
1391          * @return PatchLabelKind with given encoding.
1392          */
1393         private static PatchLabelKind fromEncoding(int encoding) {
1394             return values()[encoding &amp; NumUtil.getNbitNumberInt(INFORMATION_OFFSET)];
1395         }
1396 
1397     }
1398 
1399     public void adr(Register dst, Label label) {
1400         // TODO Handle case where offset is too large for a single jump instruction
1401         if (label.isBound()) {
1402             int offset = label.position() - position();
1403             super.adr(dst, offset);
1404         } else {
<span class="line-modified">1405             label.addPatchAt(position());</span>
1406             // Encode condition flag so that we know how to patch the instruction later
1407             emitInt(PatchLabelKind.ADR.encoding | dst.encoding &lt;&lt; PatchLabelKind.INFORMATION_OFFSET);
1408         }
1409     }
1410 
1411     /**
1412      * Compare register and branch if non-zero.
1413      *
1414      * @param size Instruction size in bits. Should be either 32 or 64.
1415      * @param cmp general purpose register. May not be null, zero-register or stackpointer.
1416      * @param label Can only handle 21-bit word-aligned offsets for now. May be unbound. Non null.
1417      */
1418     public void cbnz(int size, Register cmp, Label label) {
1419         // TODO Handle case where offset is too large for a single jump instruction
1420         if (label.isBound()) {
1421             int offset = label.position() - position();
1422             super.cbnz(size, cmp, offset);
1423         } else {
<span class="line-modified">1424             label.addPatchAt(position());</span>
1425             int regEncoding = cmp.encoding &lt;&lt; (PatchLabelKind.INFORMATION_OFFSET + 1);
1426             int sizeEncoding = (size == 64 ? 1 : 0) &lt;&lt; PatchLabelKind.INFORMATION_OFFSET;
1427             // Encode condition flag so that we know how to patch the instruction later
1428             emitInt(PatchLabelKind.BRANCH_NONZERO.encoding | regEncoding | sizeEncoding);
1429         }
1430     }
1431 
1432     /**
1433      * Compare register and branch if zero.
1434      *
1435      * @param size Instruction size in bits. Should be either 32 or 64.
1436      * @param cmp general purpose register. May not be null, zero-register or stackpointer.
1437      * @param label Can only handle 21-bit word-aligned offsets for now. May be unbound. Non null.
1438      */
1439     public void cbz(int size, Register cmp, Label label) {
1440         // TODO Handle case where offset is too large for a single jump instruction
1441         if (label.isBound()) {
1442             int offset = label.position() - position();
1443             super.cbz(size, cmp, offset);
1444         } else {
<span class="line-modified">1445             label.addPatchAt(position());</span>
1446             int regEncoding = cmp.encoding &lt;&lt; (PatchLabelKind.INFORMATION_OFFSET + 1);
1447             int sizeEncoding = (size == 64 ? 1 : 0) &lt;&lt; PatchLabelKind.INFORMATION_OFFSET;
1448             // Encode condition flag so that we know how to patch the instruction later
1449             emitInt(PatchLabelKind.BRANCH_ZERO.encoding | regEncoding | sizeEncoding);
1450         }
1451     }
1452 
1453     /**
1454      * Test a single bit and branch if the bit is nonzero.
1455      *
1456      * @param cmp general purpose register. May not be null, zero-register or stackpointer.
1457      * @param uimm6 Unsigned 6-bit bit index.
1458      * @param label Can only handle 16-bit word-aligned offsets for now. May be unbound. Non null.
1459      */
1460     public void tbnz(Register cmp, int uimm6, Label label) {
1461         assert NumUtil.isUnsignedNbit(6, uimm6);
1462         if (label.isBound()) {
1463             int offset = label.position() - position();
1464             super.tbnz(cmp, uimm6, offset);
1465         } else {
<span class="line-modified">1466             label.addPatchAt(position());</span>
1467             int indexEncoding = uimm6 &lt;&lt; PatchLabelKind.INFORMATION_OFFSET;
1468             int regEncoding = cmp.encoding &lt;&lt; (PatchLabelKind.INFORMATION_OFFSET + 6);
1469             emitInt(PatchLabelKind.BRANCH_BIT_NONZERO.encoding | indexEncoding | regEncoding);
1470         }
1471     }
1472 
1473     /**
1474      * Test a single bit and branch if the bit is zero.
1475      *
1476      * @param cmp general purpose register. May not be null, zero-register or stackpointer.
1477      * @param uimm6 Unsigned 6-bit bit index.
1478      * @param label Can only handle 16-bit word-aligned offsets for now. May be unbound. Non null.
1479      */
1480     public void tbz(Register cmp, int uimm6, Label label) {
1481         assert NumUtil.isUnsignedNbit(6, uimm6);
1482         if (label.isBound()) {
1483             int offset = label.position() - position();
1484             super.tbz(cmp, uimm6, offset);
1485         } else {
<span class="line-modified">1486             label.addPatchAt(position());</span>
1487             int indexEncoding = uimm6 &lt;&lt; PatchLabelKind.INFORMATION_OFFSET;
1488             int regEncoding = cmp.encoding &lt;&lt; (PatchLabelKind.INFORMATION_OFFSET + 6);
1489             emitInt(PatchLabelKind.BRANCH_BIT_ZERO.encoding | indexEncoding | regEncoding);
1490         }
1491     }
1492 
1493     /**
1494      * Branches to label if condition is true.
1495      *
1496      * @param condition any condition value allowed. Non null.
1497      * @param label Can only handle 21-bit word-aligned offsets for now. May be unbound. Non null.
1498      */
1499     public void branchConditionally(ConditionFlag condition, Label label) {
1500         // TODO Handle case where offset is too large for a single jump instruction
1501         if (label.isBound()) {
1502             int offset = label.position() - position();
1503             super.b(condition, offset);
1504         } else {
<span class="line-modified">1505             label.addPatchAt(position());</span>
1506             // Encode condition flag so that we know how to patch the instruction later
1507             emitInt(PatchLabelKind.BRANCH_CONDITIONALLY.encoding | condition.encoding &lt;&lt; PatchLabelKind.INFORMATION_OFFSET);
1508         }
1509     }
1510 
1511     /**
1512      * Branches if condition is true. Address of jump is patched up by HotSpot c++ code.
1513      *
1514      * @param condition any condition value allowed. Non null.
1515      */
1516     public void branchConditionally(ConditionFlag condition) {
1517         // Correct offset is fixed up by HotSpot later.
1518         super.b(condition, 0);
1519     }
1520 
1521     /**
1522      * Jumps to label.
1523      *
1524      * param label Can only handle signed 28-bit offsets. May be unbound. Non null.
1525      */
1526     @Override
1527     public void jmp(Label label) {
1528         // TODO Handle case where offset is too large for a single jump instruction
1529         if (label.isBound()) {
1530             int offset = label.position() - position();
1531             super.b(offset);
1532         } else {
<span class="line-modified">1533             label.addPatchAt(position());</span>
1534             emitInt(PatchLabelKind.BRANCH_UNCONDITIONALLY.encoding);
1535         }
1536     }
1537 
1538     /**
1539      * Jump to address in dest.
1540      *
1541      * @param dest General purpose register. May not be null, zero-register or stackpointer.
1542      */
1543     public void jmp(Register dest) {
1544         super.br(dest);
1545     }
1546 
1547     /**
1548      * Immediate jump instruction fixed up by HotSpot c++ code.
1549      */
1550     public void jmp() {
1551         // Offset has to be fixed up by c++ code.
1552         super.b(0);
1553     }
</pre>
<hr />
<pre>
1580      * Halting mode software breakpoint: Enters halting mode debug state if enabled, else treated as
1581      * UNALLOCATED instruction.
1582      *
1583      * @param exceptionCode exception code specifying why halt was called. Non null.
1584      */
1585     public void hlt(AArch64ExceptionCode exceptionCode) {
1586         super.hlt(exceptionCode.encoding);
1587     }
1588 
1589     /**
1590      * Monitor mode software breakpoint: exception routed to a debug monitor executing in a higher
1591      * exception level.
1592      *
1593      * @param exceptionCode exception code specifying why break was called. Non null.
1594      */
1595     public void brk(AArch64ExceptionCode exceptionCode) {
1596         super.brk(exceptionCode.encoding);
1597     }
1598 
1599     public void pause() {
<span class="line-modified">1600         throw GraalError.unimplemented();</span>
1601     }
1602 
1603     /**
1604      * Executes no-op instruction. No registers or flags are updated, except for PC.
1605      */
1606     public void nop() {
1607         super.hint(SystemHint.NOP);
1608     }
1609 
1610     /**
1611      * Consumption of Speculative Data Barrier. This is a memory barrier that controls speculative
1612      * execution and data value prediction.
1613      */
1614     public void csdb() {
1615         super.hint(SystemHint.CSDB);
1616     }
1617 
1618     /**
1619      * Same as {@link #nop()}.
1620      */
</pre>
<hr />
<pre>
1651         switch (type) {
1652             case BRANCH_CONDITIONALLY:
1653                 ConditionFlag cf = ConditionFlag.fromEncoding(instruction &gt;&gt;&gt; PatchLabelKind.INFORMATION_OFFSET);
1654                 super.b(cf, branchOffset, branch);
1655                 break;
1656             case BRANCH_UNCONDITIONALLY:
1657                 super.b(branchOffset, branch);
1658                 break;
1659             case JUMP_ADDRESS:
1660                 int offset = instruction &gt;&gt;&gt; PatchLabelKind.INFORMATION_OFFSET;
1661                 emitInt(jumpTarget - offset, branch);
1662                 break;
1663             case BRANCH_NONZERO:
1664             case BRANCH_ZERO: {
1665                 int information = instruction &gt;&gt;&gt; PatchLabelKind.INFORMATION_OFFSET;
1666                 int sizeEncoding = information &amp; 1;
1667                 int regEncoding = information &gt;&gt;&gt; 1;
1668                 Register reg = AArch64.cpuRegisters.get(regEncoding);
1669                 // 1 =&gt; 64; 0 =&gt; 32
1670                 int size = sizeEncoding * 32 + 32;



1671                 switch (type) {
1672                     case BRANCH_NONZERO:
1673                         super.cbnz(size, reg, branchOffset, branch);
1674                         break;
1675                     case BRANCH_ZERO:
1676                         super.cbz(size, reg, branchOffset, branch);
1677                         break;
1678                 }
1679                 break;
1680             }
1681             case BRANCH_BIT_NONZERO:
1682             case BRANCH_BIT_ZERO: {
1683                 int information = instruction &gt;&gt;&gt; PatchLabelKind.INFORMATION_OFFSET;
1684                 int sizeEncoding = information &amp; NumUtil.getNbitNumberInt(6);
1685                 int regEncoding = information &gt;&gt;&gt; 6;
1686                 Register reg = AArch64.cpuRegisters.get(regEncoding);
1687                 if (!NumUtil.isSignedNbit(16, branchOffset)) {
1688                     throw new BranchTargetOutOfBoundsException(true, &quot;Branch target %d out of bounds&quot;, branchOffset);
1689                 }
1690                 switch (type) {
</pre>
<hr />
<pre>
1704                 super.adr(reg, branchOffset, branch);
1705                 break;
1706             }
1707             default:
1708                 throw GraalError.shouldNotReachHere();
1709         }
1710     }
1711 
1712     /**
1713      * Generates an address of the form {@code base + displacement}.
1714      *
1715      * Does not change base register to fulfill this requirement. Will fail if displacement cannot
1716      * be represented directly as address.
1717      *
1718      * @param base general purpose register. May not be null or the zero register.
1719      * @param displacement arbitrary displacement added to base.
1720      * @return AArch64Address referencing memory at {@code base + displacement}.
1721      */
1722     @Override
1723     public AArch64Address makeAddress(Register base, int displacement) {
<span class="line-modified">1724         return makeAddress(base, displacement, zr, /* signExtend */false, /* transferSize */0, zr, /* allowOverwrite */false);</span>

1725     }
1726 
1727     @Override
1728     public AArch64Address getPlaceholder(int instructionStartPosition) {
1729         return AArch64Address.PLACEHOLDER;
1730     }
1731 
1732     public void addressOf(Register dst) {
<span class="line-modified">1733         // This will be fixed up later.</span>


1734         super.adrp(dst);
1735         super.add(64, dst, dst, 0);
1736     }
1737 
1738     /**
1739      * Loads an address into Register d.
1740      *
1741      * @param d general purpose register. May not be null.
1742      * @param a AArch64Address the address of an operand.
1743      */
1744     public void lea(Register d, AArch64Address a) {
1745         a.lea(this, d);
1746     }
































































1747 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 
  26 package org.graalvm.compiler.asm.aarch64;
  27 
<span class="line-added">  28 import static jdk.vm.ci.aarch64.AArch64.CPU;</span>
<span class="line-added">  29 import static jdk.vm.ci.aarch64.AArch64.rscratch1;</span>
<span class="line-added">  30 import static jdk.vm.ci.aarch64.AArch64.rscratch2;</span>
<span class="line-added">  31 import static jdk.vm.ci.aarch64.AArch64.sp;</span>
<span class="line-added">  32 import static jdk.vm.ci.aarch64.AArch64.zr;</span>
  33 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.BASE_REGISTER_ONLY;
  34 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.EXTENDED_REGISTER_OFFSET;
  35 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.IMMEDIATE_SCALED;
  36 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.IMMEDIATE_UNSCALED;
  37 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.REGISTER_OFFSET;
<span class="line-added">  38 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDP;</span>
<span class="line-added">  39 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STP;</span>
  40 import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.ADD_TO_BASE;
  41 import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.ADD_TO_INDEX;
  42 import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.NO_WORK;
  43 
  44 import org.graalvm.compiler.asm.BranchTargetOutOfBoundsException;







  45 import org.graalvm.compiler.asm.Label;
  46 import org.graalvm.compiler.core.common.NumUtil;
  47 import org.graalvm.compiler.debug.GraalError;
  48 
  49 import jdk.vm.ci.aarch64.AArch64;
  50 import jdk.vm.ci.code.Register;
  51 import jdk.vm.ci.code.TargetDescription;
  52 
  53 public class AArch64MacroAssembler extends AArch64Assembler {
  54 
<span class="line-modified">  55     private final ScratchRegister[] scratchRegister = new ScratchRegister[]{new ScratchRegister(rscratch1), new ScratchRegister(rscratch2)};</span>
  56 
  57     // Points to the next free scratch register
  58     private int nextFreeScratchRegister = 0;
  59 
<span class="line-added">  60     // Last immediate ldr/str instruction, which is a candidate to be merged.</span>
<span class="line-added">  61     private AArch64MemoryEncoding lastImmLoadStoreEncoding;</span>
<span class="line-added">  62     private boolean isImmLoadStoreMerged = false;</span>
<span class="line-added">  63 </span>
  64     public AArch64MacroAssembler(TargetDescription target) {
  65         super(target);
  66     }
  67 
  68     public class ScratchRegister implements AutoCloseable {
  69         private final Register register;
  70 
  71         public ScratchRegister(Register register) {
  72             this.register = register;
  73         }
  74 
  75         public Register getRegister() {
  76             return register;
  77         }
  78 
  79         @Override
  80         public void close() {
  81             assert nextFreeScratchRegister &gt; 0 : &quot;Close called too often&quot;;
  82             nextFreeScratchRegister--;
  83         }
  84     }
  85 
  86     public ScratchRegister getScratchRegister() {
  87         return scratchRegister[nextFreeScratchRegister++];
  88     }
  89 
<span class="line-added">  90     @Override</span>
<span class="line-added">  91     public void bind(Label l) {</span>
<span class="line-added">  92         super.bind(l);</span>
<span class="line-added">  93         // Clear last ldr/str instruction to prevent the labeled ldr/str being merged.</span>
<span class="line-added">  94         lastImmLoadStoreEncoding = null;</span>
<span class="line-added">  95     }</span>
<span class="line-added">  96 </span>
<span class="line-added">  97     private static class AArch64MemoryEncoding {</span>
<span class="line-added">  98         private AArch64Address address;</span>
<span class="line-added">  99         private Register result;</span>
<span class="line-added"> 100         private int sizeInBytes;</span>
<span class="line-added"> 101         private int position;</span>
<span class="line-added"> 102         private boolean isStore;</span>
<span class="line-added"> 103 </span>
<span class="line-added"> 104         AArch64MemoryEncoding(int sizeInBytes, Register result, AArch64Address address, boolean isStore, int position) {</span>
<span class="line-added"> 105             this.sizeInBytes = sizeInBytes;</span>
<span class="line-added"> 106             this.result = result;</span>
<span class="line-added"> 107             this.address = address;</span>
<span class="line-added"> 108             this.isStore = isStore;</span>
<span class="line-added"> 109             this.position = position;</span>
<span class="line-added"> 110             AArch64Address.AddressingMode addressingMode = address.getAddressingMode();</span>
<span class="line-added"> 111             assert addressingMode == IMMEDIATE_SCALED || addressingMode == IMMEDIATE_UNSCALED : &quot;Invalid address mode&quot; +</span>
<span class="line-added"> 112                             &quot;to merge: &quot; + addressingMode;</span>
<span class="line-added"> 113         }</span>
<span class="line-added"> 114 </span>
<span class="line-added"> 115         Register getBase() {</span>
<span class="line-added"> 116             return address.getBase();</span>
<span class="line-added"> 117         }</span>
<span class="line-added"> 118 </span>
<span class="line-added"> 119         int getOffset() {</span>
<span class="line-added"> 120             if (address.getAddressingMode() == IMMEDIATE_UNSCALED) {</span>
<span class="line-added"> 121                 return address.getImmediateRaw();</span>
<span class="line-added"> 122             }</span>
<span class="line-added"> 123             return address.getImmediate() * sizeInBytes;</span>
<span class="line-added"> 124         }</span>
<span class="line-added"> 125     }</span>
<span class="line-added"> 126 </span>
 127     /**
 128      * Specifies what actions have to be taken to turn an arbitrary address of the form
 129      * {@code base + displacement [+ index [&lt;&lt; scale]]} into a valid AArch64Address.
 130      */
 131     public static class AddressGenerationPlan {
 132         public final WorkPlan workPlan;
 133         public final AArch64Address.AddressingMode addressingMode;
 134         public final boolean needsScratch;
 135 
 136         public enum WorkPlan {
 137             /**
 138              * Can be used as-is without extra work.
 139              */
 140             NO_WORK,
 141             /**
 142              * Add scaled displacement to index register.
 143              */
 144             ADD_TO_INDEX,
 145             /**
 146              * Add unscaled displacement to base register.
</pre>
<hr />
<pre>
 290      * @param allowOverwrite if true allows to change value of base or index register to generate
 291      *            address.
 292      * @return AArch64Address pointing to memory at {@code base + displacement}.
 293      */
 294     public AArch64Address makeAddress(Register base, long displacement, Register additionalReg, int transferSize, boolean allowOverwrite) {
 295         assert additionalReg.getRegisterCategory().equals(CPU);
 296         return makeAddress(base, displacement, zr, /* sign-extend */false, transferSize, additionalReg, allowOverwrite);
 297     }
 298 
 299     /**
 300      * Returns an AArch64Address pointing to {@code base + displacement}. Fails if address cannot be
 301      * represented without overwriting base register or using a scratch register.
 302      *
 303      * @param base general purpose register. May not be null or the zero register.
 304      * @param displacement arbitrary displacement added to base.
 305      * @param transferSize the memory transfer size in bytes. The log2 of this specifies how much
 306      *            the index register is scaled. If 0 no scaling is assumed. Can be 0, 1, 2, 4 or 8.
 307      * @return AArch64Address pointing to memory at {@code base + displacement}.
 308      */
 309     public AArch64Address makeAddress(Register base, long displacement, int transferSize) {
<span class="line-modified"> 310         return makeAddress(base, displacement, zr, /* signExtend */false, //</span>
<span class="line-added"> 311                         transferSize, zr, /* allowOverwrite */false);</span>
 312     }
 313 
 314     /**
 315      * Loads memory address into register.
 316      *
 317      * @param dst general purpose register. May not be null, zero-register or stackpointer.
 318      * @param address address whose value is loaded into dst. May not be null,
 319      *            {@link org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode#IMMEDIATE_POST_INDEXED
 320      *            POST_INDEXED} or
 321      *            {@link org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode#IMMEDIATE_PRE_INDEXED
 322      *            IMMEDIATE_PRE_INDEXED}
 323      * @param transferSize the memory transfer size in bytes. The log2 of this specifies how much
 324      *            the index register is scaled. Can be 1, 2, 4 or 8.
 325      */
 326     public void loadAddress(Register dst, AArch64Address address, int transferSize) {
 327         assert transferSize == 1 || transferSize == 2 || transferSize == 4 || transferSize == 8;
 328         assert dst.getRegisterCategory().equals(CPU);
 329         int shiftAmt = NumUtil.log2Ceil(transferSize);
 330         switch (address.getAddressingMode()) {
 331             case IMMEDIATE_SCALED:
</pre>
<hr />
<pre>
 347                 add(64, dst, address.getBase(), immediate);
 348                 break;
 349             case REGISTER_OFFSET:
 350                 add(64, dst, address.getBase(), address.getOffset(), ShiftType.LSL, address.isScaled() ? shiftAmt : 0);
 351                 break;
 352             case EXTENDED_REGISTER_OFFSET:
 353                 add(64, dst, address.getBase(), address.getOffset(), address.getExtendType(), address.isScaled() ? shiftAmt : 0);
 354                 break;
 355             case PC_LITERAL: {
 356                 addressOf(dst);
 357                 break;
 358             }
 359             case BASE_REGISTER_ONLY:
 360                 movx(dst, address.getBase());
 361                 break;
 362             default:
 363                 throw GraalError.shouldNotReachHere();
 364         }
 365     }
 366 
<span class="line-added"> 367     private boolean tryMerge(int sizeInBytes, Register rt, AArch64Address address, boolean isStore) {</span>
<span class="line-added"> 368         isImmLoadStoreMerged = false;</span>
<span class="line-added"> 369         if (lastImmLoadStoreEncoding == null) {</span>
<span class="line-added"> 370             return false;</span>
<span class="line-added"> 371         }</span>
<span class="line-added"> 372 </span>
<span class="line-added"> 373         // Only immediate scaled/unscaled address can be merged.</span>
<span class="line-added"> 374         // Pre-index and post-index mode can&#39;t be merged.</span>
<span class="line-added"> 375         AArch64Address.AddressingMode addressMode = address.getAddressingMode();</span>
<span class="line-added"> 376         if (addressMode != IMMEDIATE_SCALED &amp;&amp; addressMode != IMMEDIATE_UNSCALED) {</span>
<span class="line-added"> 377             return false;</span>
<span class="line-added"> 378         }</span>
<span class="line-added"> 379 </span>
<span class="line-added"> 380         // Only the two adjacent ldrs/strs can be merged.</span>
<span class="line-added"> 381         int lastPosition = position() - 4;</span>
<span class="line-added"> 382         if (lastPosition &lt; 0 || lastPosition != lastImmLoadStoreEncoding.position) {</span>
<span class="line-added"> 383             return false;</span>
<span class="line-added"> 384         }</span>
<span class="line-added"> 385 </span>
<span class="line-added"> 386         if (isStore != lastImmLoadStoreEncoding.isStore) {</span>
<span class="line-added"> 387             return false;</span>
<span class="line-added"> 388         }</span>
<span class="line-added"> 389 </span>
<span class="line-added"> 390         // Only merge ldr/str with the same size of 32bits or 64bits.</span>
<span class="line-added"> 391         if (sizeInBytes != lastImmLoadStoreEncoding.sizeInBytes || (sizeInBytes != 4 &amp;&amp; sizeInBytes != 8)) {</span>
<span class="line-added"> 392             return false;</span>
<span class="line-added"> 393         }</span>
<span class="line-added"> 394 </span>
<span class="line-added"> 395         // Base register must be the same one.</span>
<span class="line-added"> 396         Register curBase = address.getBase();</span>
<span class="line-added"> 397         Register preBase = lastImmLoadStoreEncoding.getBase();</span>
<span class="line-added"> 398         if (!curBase.equals(preBase)) {</span>
<span class="line-added"> 399             return false;</span>
<span class="line-added"> 400         }</span>
<span class="line-added"> 401 </span>
<span class="line-added"> 402         // If the two ldrs have the same rt register, they can&#39;t be merged.</span>
<span class="line-added"> 403         // If the two ldrs have dependence, they can&#39;t be merged.</span>
<span class="line-added"> 404         Register curRt = rt;</span>
<span class="line-added"> 405         Register preRt = lastImmLoadStoreEncoding.result;</span>
<span class="line-added"> 406         if (!isStore &amp;&amp; (curRt.equals(preRt) || preRt.equals(curBase))) {</span>
<span class="line-added"> 407             return false;</span>
<span class="line-added"> 408         }</span>
<span class="line-added"> 409 </span>
<span class="line-added"> 410         // Offset checking. Offsets of the two ldrs/strs must be continuous.</span>
<span class="line-added"> 411         int curOffset = address.getImmediateRaw();</span>
<span class="line-added"> 412         if (addressMode == IMMEDIATE_SCALED) {</span>
<span class="line-added"> 413             curOffset = curOffset * sizeInBytes;</span>
<span class="line-added"> 414         }</span>
<span class="line-added"> 415         int preOffset = lastImmLoadStoreEncoding.getOffset();</span>
<span class="line-added"> 416         if (Math.abs(curOffset - preOffset) != sizeInBytes) {</span>
<span class="line-added"> 417             return false;</span>
<span class="line-added"> 418         }</span>
<span class="line-added"> 419 </span>
<span class="line-added"> 420         // Offset must be in ldp/stp instruction&#39;s range.</span>
<span class="line-added"> 421         int offset = curOffset &gt; preOffset ? preOffset : curOffset;</span>
<span class="line-added"> 422         int minOffset = -64 * sizeInBytes;</span>
<span class="line-added"> 423         int maxOffset = 63 * sizeInBytes;</span>
<span class="line-added"> 424         if (offset &lt; minOffset || offset &gt; maxOffset) {</span>
<span class="line-added"> 425             return false;</span>
<span class="line-added"> 426         }</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428         // Alignment checking.</span>
<span class="line-added"> 429         if (isFlagSet(AArch64.Flag.AvoidUnalignedAccesses)) {</span>
<span class="line-added"> 430             // AArch64 sp is 16-bytes aligned.</span>
<span class="line-added"> 431             if (curBase.equals(sp)) {</span>
<span class="line-added"> 432                 long pairMask = sizeInBytes * 2 - 1;</span>
<span class="line-added"> 433                 if ((offset &amp; pairMask) != 0) {</span>
<span class="line-added"> 434                     return false;</span>
<span class="line-added"> 435                 }</span>
<span class="line-added"> 436             } else {</span>
<span class="line-added"> 437                 // If base is not sp, we can&#39;t guarantee the access is aligned.</span>
<span class="line-added"> 438                 return false;</span>
<span class="line-added"> 439             }</span>
<span class="line-added"> 440         } else {</span>
<span class="line-added"> 441             // ldp/stp only supports sizeInBytes aligned offset.</span>
<span class="line-added"> 442             long mask = sizeInBytes - 1;</span>
<span class="line-added"> 443             if ((curOffset &amp; mask) != 0 || (preOffset &amp; mask) != 0) {</span>
<span class="line-added"> 444                 return false;</span>
<span class="line-added"> 445             }</span>
<span class="line-added"> 446         }</span>
<span class="line-added"> 447 </span>
<span class="line-added"> 448         // Merge two ldrs/strs to ldp/stp.</span>
<span class="line-added"> 449         Register rt1 = preRt;</span>
<span class="line-added"> 450         Register rt2 = curRt;</span>
<span class="line-added"> 451         if (curOffset &lt; preOffset) {</span>
<span class="line-added"> 452             rt1 = curRt;</span>
<span class="line-added"> 453             rt2 = preRt;</span>
<span class="line-added"> 454         }</span>
<span class="line-added"> 455         int immediate = offset / sizeInBytes;</span>
<span class="line-added"> 456         Instruction instruction = isStore ? STP : LDP;</span>
<span class="line-added"> 457         int size = sizeInBytes * Byte.SIZE;</span>
<span class="line-added"> 458         insertLdpStp(size, instruction, rt1, rt2, curBase, immediate, lastPosition);</span>
<span class="line-added"> 459         lastImmLoadStoreEncoding = null;</span>
<span class="line-added"> 460         isImmLoadStoreMerged = true;</span>
<span class="line-added"> 461         return true;</span>
<span class="line-added"> 462     }</span>
<span class="line-added"> 463 </span>
<span class="line-added"> 464     /**</span>
<span class="line-added"> 465      * Try to merge two continuous ldr/str to one ldp/stp. If this current ldr/str is not merged,</span>
<span class="line-added"> 466      * save it as the last ldr/str.</span>
<span class="line-added"> 467      */</span>
<span class="line-added"> 468     private boolean tryMergeLoadStore(int srcSize, Register rt, AArch64Address address, boolean isStore) {</span>
<span class="line-added"> 469         int sizeInBytes = srcSize / Byte.SIZE;</span>
<span class="line-added"> 470         if (tryMerge(sizeInBytes, rt, address, isStore)) {</span>
<span class="line-added"> 471             return true;</span>
<span class="line-added"> 472         }</span>
<span class="line-added"> 473 </span>
<span class="line-added"> 474         // Save last ldr/str if it is not merged.</span>
<span class="line-added"> 475         AArch64Address.AddressingMode addressMode = address.getAddressingMode();</span>
<span class="line-added"> 476         if (addressMode == IMMEDIATE_SCALED || addressMode == IMMEDIATE_UNSCALED) {</span>
<span class="line-added"> 477             if (addressMode == IMMEDIATE_UNSCALED) {</span>
<span class="line-added"> 478                 long mask = sizeInBytes - 1;</span>
<span class="line-added"> 479                 int offset = address.getImmediateRaw();</span>
<span class="line-added"> 480                 if ((offset &amp; mask) != 0) {</span>
<span class="line-added"> 481                     return false;</span>
<span class="line-added"> 482                 }</span>
<span class="line-added"> 483             }</span>
<span class="line-added"> 484             lastImmLoadStoreEncoding = new AArch64MemoryEncoding(sizeInBytes, rt, address, isStore, position());</span>
<span class="line-added"> 485         }</span>
<span class="line-added"> 486         return false;</span>
<span class="line-added"> 487     }</span>
<span class="line-added"> 488 </span>
<span class="line-added"> 489     public boolean isImmLoadStoreMerged() {</span>
<span class="line-added"> 490         return isImmLoadStoreMerged;</span>
<span class="line-added"> 491     }</span>
<span class="line-added"> 492 </span>
 493     public void movx(Register dst, Register src) {
 494         mov(64, dst, src);
 495     }
 496 
 497     public void mov(int size, Register dst, Register src) {
 498         if (dst.equals(sp) || src.equals(sp)) {
 499             add(size, dst, src, 0);
 500         } else {
 501             or(size, dst, zr, src);
 502         }
 503     }
 504 
 505     /**
 506      * Generates a 64-bit immediate move code sequence.
 507      *
 508      * @param dst general purpose register. May not be null, stackpointer or zero-register.
<span class="line-modified"> 509      * @param imm the value to move into the register</span>
<span class="line-added"> 510      * @param annotateImm Flag denoting if annotation should be added.</span>
 511      */
<span class="line-modified"> 512     private void mov64(Register dst, long imm, boolean annotateImm) {</span>
 513         // We have to move all non zero parts of the immediate in 16-bit chunks
<span class="line-added"> 514         int numMovs = 0;</span>
<span class="line-added"> 515         int pos = position();</span>
 516         boolean firstMove = true;
 517         for (int offset = 0; offset &lt; 64; offset += 16) {
 518             int chunk = (int) (imm &gt;&gt; offset) &amp; NumUtil.getNbitNumberInt(16);
 519             if (chunk == 0) {
 520                 continue;
 521             }
 522             if (firstMove) {
 523                 movz(64, dst, chunk, offset);
 524                 firstMove = false;
 525             } else {
 526                 movk(64, dst, chunk, offset);
 527             }
<span class="line-added"> 528             ++numMovs;</span>
 529         }
 530         assert !firstMove;
<span class="line-added"> 531         if (annotateImm) {</span>
<span class="line-added"> 532             annotateImmediateMovSequence(pos, numMovs);</span>
<span class="line-added"> 533         }</span>
 534     }
 535 
 536     /**
 537      * Loads immediate into register.
 538      *
 539      * @param dst general purpose register. May not be null, zero-register or stackpointer.
 540      * @param imm immediate loaded into register.
 541      */
 542     public void mov(Register dst, long imm) {
<span class="line-added"> 543         mov(dst, imm, false);</span>
<span class="line-added"> 544     }</span>
<span class="line-added"> 545 </span>
<span class="line-added"> 546     /**</span>
<span class="line-added"> 547      * Loads immediate into register.</span>
<span class="line-added"> 548      *</span>
<span class="line-added"> 549      * @param dst general purpose register. May not be null, zero-register or stackpointer.</span>
<span class="line-added"> 550      * @param imm immediate loaded into register.</span>
<span class="line-added"> 551      * @param annotateImm Flag to signal of the immediate value should be annotated.</span>
<span class="line-added"> 552      */</span>
<span class="line-added"> 553     public void mov(Register dst, long imm, boolean annotateImm) {</span>
 554         assert dst.getRegisterCategory().equals(CPU);
 555         if (imm == 0L) {
 556             movx(dst, zr);
 557         } else if (LogicalImmediateTable.isRepresentable(true, imm) != LogicalImmediateTable.Representable.NO) {
 558             or(64, dst, zr, imm);
 559         } else if (imm &gt;&gt; 32 == -1L &amp;&amp; (int) imm &lt; 0 &amp;&amp; LogicalImmediateTable.isRepresentable((int) imm) != LogicalImmediateTable.Representable.NO) {
 560             // If the higher 32-bit are 1s and the sign bit of the lower 32-bits is set *and* we can
 561             // represent the lower 32 bits as a logical immediate we can create the lower 32-bit and
 562             // then sign extend
 563             // them. This allows us to cover immediates like ~1L with 2 instructions.
 564             mov(dst, (int) imm);
 565             sxt(64, 32, dst, dst);
 566         } else {
<span class="line-modified"> 567             mov64(dst, imm, annotateImm);</span>
 568         }
 569     }
 570 
 571     /**
 572      * Loads immediate into register.
 573      *
 574      * @param dst general purpose register. May not be null, zero-register or stackpointer.
 575      * @param imm immediate loaded into register.
 576      */
 577     public void mov(Register dst, int imm) {
 578         mov(dst, imm &amp; 0xFFFF_FFFFL);
 579     }
 580 
 581     /**
 582      * Generates a 48-bit immediate move code sequence. The immediate may later be updated by
 583      * HotSpot.
 584      *
 585      * In AArch64 mode the virtual address space is 48-bits in size, so we only need three
 586      * instructions to create a patchable instruction sequence that can reach anywhere.
 587      *
 588      * @param dst general purpose register. May not be null, stackpointer or zero-register.
 589      * @param imm
 590      */
 591     public void movNativeAddress(Register dst, long imm) {
<span class="line-added"> 592         movNativeAddress(dst, imm, false);</span>
<span class="line-added"> 593     }</span>
<span class="line-added"> 594 </span>
<span class="line-added"> 595     /**</span>
<span class="line-added"> 596      * Generates a 48-bit immediate move code sequence. The immediate may later be updated by</span>
<span class="line-added"> 597      * HotSpot.</span>
<span class="line-added"> 598      *</span>
<span class="line-added"> 599      * In AArch64 mode the virtual address space is 48-bits in size, so we only need three</span>
<span class="line-added"> 600      * instructions to create a patchable instruction sequence that can reach anywhere.</span>
<span class="line-added"> 601      *</span>
<span class="line-added"> 602      * @param dst general purpose register. May not be null, stackpointer or zero-register.</span>
<span class="line-added"> 603      * @param imm The immediate address</span>
<span class="line-added"> 604      * @param annotateImm Flag to signal of the immediate value should be annotated.</span>
<span class="line-added"> 605      */</span>
<span class="line-added"> 606     public void movNativeAddress(Register dst, long imm, boolean annotateImm) {</span>
 607         assert (imm &amp; 0xFFFF_0000_0000_0000L) == 0;
 608         // We have to move all non zero parts of the immediate in 16-bit chunks
 609         boolean firstMove = true;
<span class="line-added"> 610         int pos = position();</span>
 611         for (int offset = 0; offset &lt; 48; offset += 16) {
 612             int chunk = (int) (imm &gt;&gt; offset) &amp; NumUtil.getNbitNumberInt(16);
 613             if (firstMove) {
 614                 movz(64, dst, chunk, offset);
 615                 firstMove = false;
 616             } else {
 617                 movk(64, dst, chunk, offset);
 618             }
 619         }
<span class="line-added"> 620         if (annotateImm) {</span>
<span class="line-added"> 621             annotateImmediateMovSequence(pos, 3);</span>
<span class="line-added"> 622         }</span>
 623         assert !firstMove;
 624     }
 625 
 626     /**
 627      * Generates a 32-bit immediate move code sequence. The immediate may later be updated by
 628      * HotSpot.
 629      *
 630      * @param dst general purpose register. May not be null, stackpointer or zero-register.
 631      * @param imm
 632      */
 633     public void movNarrowAddress(Register dst, long imm) {
 634         assert (imm &amp; 0xFFFF_FFFF_0000_0000L) == 0;
 635         movz(64, dst, (int) (imm &gt;&gt;&gt; 16), 16);
 636         movk(64, dst, (int) (imm &amp; 0xffff), 0);
 637     }
 638 
 639     /**
 640      * @return Number of instructions necessary to load immediate into register.
 641      */
 642     public static int nrInstructionsToMoveImmediate(long imm) {
</pre>
<hr />
<pre>
 657                 nrInstructions++;
 658             }
 659         }
 660         return nrInstructions;
 661     }
 662 
 663     /**
 664      * Loads a srcSize value from address into rt sign-extending it if necessary.
 665      *
 666      * @param targetSize size of target register in bits. Must be 32 or 64.
 667      * @param srcSize size of memory read in bits. Must be 8, 16 or 32 and smaller or equal to
 668      *            targetSize.
 669      * @param rt general purpose register. May not be null or stackpointer.
 670      * @param address all addressing modes allowed. May not be null.
 671      */
 672     @Override
 673     public void ldrs(int targetSize, int srcSize, Register rt, AArch64Address address) {
 674         assert targetSize == 32 || targetSize == 64;
 675         assert srcSize &lt;= targetSize;
 676         if (targetSize == srcSize) {
<span class="line-modified"> 677             ldr(srcSize, rt, address);</span>
 678         } else {
 679             super.ldrs(targetSize, srcSize, rt, address);
 680         }
 681     }
 682 
 683     /**
 684      * Loads a srcSize value from address into rt zero-extending it if necessary.
 685      *
 686      * @param srcSize size of memory read in bits. Must be 8, 16 or 32 and smaller or equal to
 687      *            targetSize.
 688      * @param rt general purpose register. May not be null or stackpointer.
 689      * @param address all addressing modes allowed. May not be null.
 690      */
 691     @Override
 692     public void ldr(int srcSize, Register rt, AArch64Address address) {
<span class="line-modified"> 693         // Try to merge two adjacent loads into one ldp.</span>
<span class="line-added"> 694         if (!tryMergeLoadStore(srcSize, rt, address, false)) {</span>
<span class="line-added"> 695             super.ldr(srcSize, rt, address);</span>
<span class="line-added"> 696         }</span>
<span class="line-added"> 697     }</span>
<span class="line-added"> 698 </span>
<span class="line-added"> 699     /**</span>
<span class="line-added"> 700      * Stores register rt into memory pointed by address.</span>
<span class="line-added"> 701      *</span>
<span class="line-added"> 702      * @param destSize number of bits written to memory. Must be 8, 16, 32 or 64.</span>
<span class="line-added"> 703      * @param rt general purpose register. May not be null or stackpointer.</span>
<span class="line-added"> 704      * @param address all addressing modes allowed. May not be null.</span>
<span class="line-added"> 705      */</span>
<span class="line-added"> 706     @Override</span>
<span class="line-added"> 707     public void str(int destSize, Register rt, AArch64Address address) {</span>
<span class="line-added"> 708         // Try to merge two adjacent stores into one stp.</span>
<span class="line-added"> 709         if (!tryMergeLoadStore(destSize, rt, address, true)) {</span>
<span class="line-added"> 710             super.str(destSize, rt, address);</span>
<span class="line-added"> 711         }</span>
 712     }
 713 
 714     /**
 715      * Conditional move. dst = src1 if condition else src2.
 716      *
 717      * @param size register size. Has to be 32 or 64.
 718      * @param result general purpose register. May not be null or the stackpointer.
 719      * @param trueValue general purpose register. May not be null or the stackpointer.
 720      * @param falseValue general purpose register. May not be null or the stackpointer.
 721      * @param cond any condition flag. May not be null.
 722      */
 723     public void cmov(int size, Register result, Register trueValue, Register falseValue, ConditionFlag cond) {
 724         super.csel(size, result, trueValue, falseValue, cond);
 725     }
 726 
 727     /**
 728      * Conditional set. dst = 1 if condition else 0.
 729      *
 730      * @param dst general purpose register. May not be null or stackpointer.
 731      * @param condition any condition. May not be null.
</pre>
<hr />
<pre>
 987      * @param src3 general purpose register. May not be null or the stackpointer.
 988      */
 989     @Override
 990     public void msub(int size, Register dst, Register src1, Register src2, Register src3) {
 991         super.msub(size, dst, src1, src2, src3);
 992     }
 993 
 994     /**
 995      * dst = 0 - src1 * src2.
 996      *
 997      * @param size register size. Has to be 32 or 64.
 998      * @param dst general purpose register. May not be null or the stackpointer.
 999      * @param src1 general purpose register. May not be null or the stackpointer.
1000      * @param src2 general purpose register. May not be null or the stackpointer.
1001      */
1002     public void mneg(int size, Register dst, Register src1, Register src2) {
1003         super.msub(size, dst, src1, src2, zr);
1004     }
1005 
1006     /**
<span class="line-modified">1007      * Unsigned multiply high. dst = (src1 * src2) &gt;&gt; size</span>
1008      *
1009      * @param size register size. Has to be 32 or 64.
1010      * @param dst general purpose register. May not be null or the stackpointer.
1011      * @param src1 general purpose register. May not be null or the stackpointer.
1012      * @param src2 general purpose register. May not be null or the stackpointer.
1013      */
1014     public void umulh(int size, Register dst, Register src1, Register src2) {
1015         assert (!dst.equals(sp) &amp;&amp; !src1.equals(sp) &amp;&amp; !src2.equals(sp));
1016         assert size == 32 || size == 64;
1017         if (size == 64) {
1018             super.umulh(dst, src1, src2);
1019         } else {
1020             // xDst = wSrc1 * wSrc2
1021             super.umaddl(dst, src1, src2, zr);
1022             // xDst = xDst &gt;&gt; 32
1023             lshr(64, dst, dst, 32);
1024         }
1025     }
1026 
1027     /**
<span class="line-modified">1028      * Signed multiply high. dst = (src1 * src2) &gt;&gt; size</span>
1029      *
1030      * @param size register size. Has to be 32 or 64.
1031      * @param dst general purpose register. May not be null or the stackpointer.
1032      * @param src1 general purpose register. May not be null or the stackpointer.
1033      * @param src2 general purpose register. May not be null or the stackpointer.
1034      */
1035     public void smulh(int size, Register dst, Register src1, Register src2) {
1036         assert (!dst.equals(sp) &amp;&amp; !src1.equals(sp) &amp;&amp; !src2.equals(sp));
1037         assert size == 32 || size == 64;
1038         if (size == 64) {
1039             super.smulh(dst, src1, src2);
1040         } else {
1041             // xDst = wSrc1 * wSrc2
1042             super.smaddl(dst, src1, src2, zr);
1043             // xDst = xDst &gt;&gt; 32
1044             lshr(64, dst, dst, 32);
1045         }
1046     }
1047 
<span class="line-added">1048     /**</span>
<span class="line-added">1049      * Signed multiply long. xDst = wSrc1 * wSrc2</span>
<span class="line-added">1050      *</span>
<span class="line-added">1051      * @param size destination register size. Has to be 64.</span>
<span class="line-added">1052      * @param dst 64-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1053      * @param src1 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1054      * @param src2 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1055      */</span>
<span class="line-added">1056     public void smull(int size, Register dst, Register src1, Register src2) {</span>
<span class="line-added">1057         this.smaddl(size, dst, src1, src2, zr);</span>
<span class="line-added">1058     }</span>
<span class="line-added">1059 </span>
<span class="line-added">1060     /**</span>
<span class="line-added">1061      * Signed multiply-negate long. xDst = -(wSrc1 * wSrc2)</span>
<span class="line-added">1062      *</span>
<span class="line-added">1063      * @param size destination register size. Has to be 64.</span>
<span class="line-added">1064      * @param dst 64-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1065      * @param src1 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1066      * @param src2 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1067      */</span>
<span class="line-added">1068     public void smnegl(int size, Register dst, Register src1, Register src2) {</span>
<span class="line-added">1069         this.smsubl(size, dst, src1, src2, zr);</span>
<span class="line-added">1070     }</span>
<span class="line-added">1071 </span>
<span class="line-added">1072     /**</span>
<span class="line-added">1073      * Signed multiply-add long. xDst = xSrc3 + (wSrc1 * wSrc2)</span>
<span class="line-added">1074      *</span>
<span class="line-added">1075      * @param size destination register size. Has to be 64.</span>
<span class="line-added">1076      * @param dst 64-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1077      * @param src1 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1078      * @param src2 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1079      * @param src3 64-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1080      */</span>
<span class="line-added">1081     public void smaddl(int size, Register dst, Register src1, Register src2, Register src3) {</span>
<span class="line-added">1082         assert (!dst.equals(sp) &amp;&amp; !src1.equals(sp) &amp;&amp; !src2.equals(sp) &amp;&amp; !src3.equals(sp));</span>
<span class="line-added">1083         assert size == 64;</span>
<span class="line-added">1084         super.smaddl(dst, src1, src2, src3);</span>
<span class="line-added">1085     }</span>
<span class="line-added">1086 </span>
<span class="line-added">1087     /**</span>
<span class="line-added">1088      * Signed multiply-sub long. xDst = xSrc3 - (wSrc1 * wSrc2)</span>
<span class="line-added">1089      *</span>
<span class="line-added">1090      * @param size destination register size. Has to be 64.</span>
<span class="line-added">1091      * @param dst 64-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1092      * @param src1 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1093      * @param src2 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1094      * @param src3 64-bit general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">1095      */</span>
<span class="line-added">1096     public void smsubl(int size, Register dst, Register src1, Register src2, Register src3) {</span>
<span class="line-added">1097         assert (!dst.equals(sp) &amp;&amp; !src1.equals(sp) &amp;&amp; !src2.equals(sp) &amp;&amp; !src3.equals(sp));</span>
<span class="line-added">1098         assert size == 64;</span>
<span class="line-added">1099         super.smsubl(dst, src1, src2, src3);</span>
<span class="line-added">1100     }</span>
<span class="line-added">1101 </span>
1102     /**
1103      * dst = src1 % src2. Signed.
1104      *
1105      * @param size register size. Has to be 32 or 64.
1106      * @param dst general purpose register. May not be null or the stackpointer.
1107      * @param n numerator. General purpose register. May not be null or the stackpointer.
1108      * @param d denominator. General purpose register. Divisor May not be null or the stackpointer.
1109      */
1110     public void rem(int size, Register dst, Register n, Register d) {
1111         assert (!dst.equals(sp) &amp;&amp; !n.equals(sp) &amp;&amp; !d.equals(sp));
1112         // There is no irem or similar instruction. Instead we use the relation:
1113         // n % d = n - Floor(n / d) * d if nd &gt;= 0
1114         // n % d = n - Ceil(n / d) * d else
1115         // Which is equivalent to n - TruncatingDivision(n, d) * d
1116         super.sdiv(size, dst, n, d);
1117         super.msub(size, dst, dst, d, n);
1118     }
1119 
1120     /**
1121      * dst = src1 % src2. Unsigned.
</pre>
<hr />
<pre>
1532     public void fcmov(int size, Register result, Register trueValue, Register falseValue, ConditionFlag condition) {
1533         super.fcsel(size, result, trueValue, falseValue, condition);
1534     }
1535 
1536     /**
1537      * dst = src1 % src2.
1538      *
1539      * @param size register size. Has to be 32 or 64.
1540      * @param dst floating-point register. May not be null.
1541      * @param n numerator. Floating-point register. May not be null.
1542      * @param d denominator. Floating-point register. May not be null.
1543      */
1544     public void frem(int size, Register dst, Register n, Register d) {
1545         // There is no frem instruction, instead we compute the remainder using the relation:
1546         // rem = n - Truncating(n / d) * d
1547         super.fdiv(size, dst, n, d);
1548         super.frintz(size, dst, dst);
1549         super.fmsub(size, dst, dst, d, n);
1550     }
1551 
<span class="line-added">1552     /**</span>
<span class="line-added">1553      * dst = src1 * src2 + src3.</span>
<span class="line-added">1554      *</span>
<span class="line-added">1555      * @param size register size.</span>
<span class="line-added">1556      * @param dst floating point register. May not be null.</span>
<span class="line-added">1557      * @param src1 floating point register. May not be null.</span>
<span class="line-added">1558      * @param src2 floating point register. May not be null.</span>
<span class="line-added">1559      * @param src3 floating point register. May not be null.</span>
<span class="line-added">1560      */</span>
<span class="line-added">1561     @Override</span>
<span class="line-added">1562     public void fmadd(int size, Register dst, Register src1, Register src2, Register src3) {</span>
<span class="line-added">1563         super.fmadd(size, dst, src1, src2, src3);</span>
<span class="line-added">1564     }</span>
<span class="line-added">1565 </span>
1566     /* Branches */
1567 
1568     /**
1569      * Compares x and y and sets condition flags.
1570      *
1571      * @param size register size. Has to be 32 or 64.
1572      * @param x general purpose register. May not be null or stackpointer.
1573      * @param y general purpose register. May not be null or stackpointer.
1574      */
1575     public void cmp(int size, Register x, Register y) {
1576         assert size == 32 || size == 64;
1577         super.subs(size, zr, x, y, ShiftType.LSL, 0);
1578     }
1579 
1580     /**
1581      * Compares x to y and sets condition flags.
1582      *
1583      * @param size register size. Has to be 32 or 64.
1584      * @param x general purpose register. May not be null or stackpointer.
1585      * @param y comparison immediate, {@link #isComparisonImmediate(long)} has to be true for it.
</pre>
<hr />
<pre>
1603      */
1604     public void ands(int size, Register dst, Register x, Register y) {
1605         super.ands(size, dst, x, y, ShiftType.LSL, 0);
1606     }
1607 
1608     /**
1609      * Sets overflow flag according to result of x * y.
1610      *
1611      * @param size register size. Has to be 32 or 64.
1612      * @param dst general purpose register. May not be null or stack-pointer.
1613      * @param x general purpose register. May not be null or stackpointer.
1614      * @param y general purpose register. May not be null or stackpointer.
1615      */
1616     public void mulvs(int size, Register dst, Register x, Register y) {
1617         try (ScratchRegister sc1 = getScratchRegister();
1618                         ScratchRegister sc2 = getScratchRegister()) {
1619             switch (size) {
1620                 case 64: {
1621                     // Be careful with registers: it&#39;s possible that x, y, and dst are the same
1622                     // register.
<span class="line-modified">1623                     Register temp1 = sc1.getRegister();</span>
<span class="line-modified">1624                     Register temp2 = sc2.getRegister();</span>
<span class="line-modified">1625                     mul(64, temp1, x, y);     // Result bits 0..63</span>
<span class="line-modified">1626                     smulh(64, temp2, x, y);  // Result bits 64..127</span>
1627                     // Top is pure sign ext
<span class="line-modified">1628                     subs(64, zr, temp2, temp1, ShiftType.ASR, 63);</span>
1629                     // Copy all 64 bits of the result into dst
<span class="line-modified">1630                     mov(64, dst, temp1);</span>
<span class="line-modified">1631                     mov(temp1, 0x80000000);</span>
1632                     // Develop 0 (EQ), or 0x80000000 (NE)
<span class="line-modified">1633                     cmov(32, temp1, temp1, zr, ConditionFlag.NE);</span>
<span class="line-modified">1634                     cmp(32, temp1, 1);</span>
1635                     // 0x80000000 - 1 =&gt; VS
1636                     break;
1637                 }
1638                 case 32: {
<span class="line-modified">1639                     Register temp1 = sc1.getRegister();</span>
<span class="line-modified">1640                     smaddl(temp1, x, y, zr);</span>
1641                     // Copy the low 32 bits of the result into dst
<span class="line-modified">1642                     mov(32, dst, temp1);</span>
<span class="line-modified">1643                     subs(64, zr, temp1, temp1, ExtendType.SXTW, 0);</span>
1644                     // NE =&gt; overflow
<span class="line-modified">1645                     mov(temp1, 0x80000000);</span>
1646                     // Develop 0 (EQ), or 0x80000000 (NE)
<span class="line-modified">1647                     cmov(32, temp1, temp1, zr, ConditionFlag.NE);</span>
<span class="line-modified">1648                     cmp(32, temp1, 1);</span>
1649                     // 0x80000000 - 1 =&gt; VS
1650                     break;
1651                 }
1652             }
1653         }
1654     }
1655 
1656     /**
1657      * When patching up Labels we have to know what kind of code to generate.
1658      */
1659     public enum PatchLabelKind {
1660         BRANCH_CONDITIONALLY(0x0),
1661         BRANCH_UNCONDITIONALLY(0x1),
1662         BRANCH_NONZERO(0x2),
1663         BRANCH_ZERO(0x3),
1664         BRANCH_BIT_NONZERO(0x4),
1665         BRANCH_BIT_ZERO(0x5),
1666         JUMP_ADDRESS(0x6),
1667         ADR(0x7);
1668 
</pre>
<hr />
<pre>
1676 
1677         PatchLabelKind(int encoding) {
1678             this.encoding = encoding;
1679         }
1680 
1681         /**
1682          * @return PatchLabelKind with given encoding.
1683          */
1684         private static PatchLabelKind fromEncoding(int encoding) {
1685             return values()[encoding &amp; NumUtil.getNbitNumberInt(INFORMATION_OFFSET)];
1686         }
1687 
1688     }
1689 
1690     public void adr(Register dst, Label label) {
1691         // TODO Handle case where offset is too large for a single jump instruction
1692         if (label.isBound()) {
1693             int offset = label.position() - position();
1694             super.adr(dst, offset);
1695         } else {
<span class="line-modified">1696             label.addPatchAt(position(), this);</span>
1697             // Encode condition flag so that we know how to patch the instruction later
1698             emitInt(PatchLabelKind.ADR.encoding | dst.encoding &lt;&lt; PatchLabelKind.INFORMATION_OFFSET);
1699         }
1700     }
1701 
1702     /**
1703      * Compare register and branch if non-zero.
1704      *
1705      * @param size Instruction size in bits. Should be either 32 or 64.
1706      * @param cmp general purpose register. May not be null, zero-register or stackpointer.
1707      * @param label Can only handle 21-bit word-aligned offsets for now. May be unbound. Non null.
1708      */
1709     public void cbnz(int size, Register cmp, Label label) {
1710         // TODO Handle case where offset is too large for a single jump instruction
1711         if (label.isBound()) {
1712             int offset = label.position() - position();
1713             super.cbnz(size, cmp, offset);
1714         } else {
<span class="line-modified">1715             label.addPatchAt(position(), this);</span>
1716             int regEncoding = cmp.encoding &lt;&lt; (PatchLabelKind.INFORMATION_OFFSET + 1);
1717             int sizeEncoding = (size == 64 ? 1 : 0) &lt;&lt; PatchLabelKind.INFORMATION_OFFSET;
1718             // Encode condition flag so that we know how to patch the instruction later
1719             emitInt(PatchLabelKind.BRANCH_NONZERO.encoding | regEncoding | sizeEncoding);
1720         }
1721     }
1722 
1723     /**
1724      * Compare register and branch if zero.
1725      *
1726      * @param size Instruction size in bits. Should be either 32 or 64.
1727      * @param cmp general purpose register. May not be null, zero-register or stackpointer.
1728      * @param label Can only handle 21-bit word-aligned offsets for now. May be unbound. Non null.
1729      */
1730     public void cbz(int size, Register cmp, Label label) {
1731         // TODO Handle case where offset is too large for a single jump instruction
1732         if (label.isBound()) {
1733             int offset = label.position() - position();
1734             super.cbz(size, cmp, offset);
1735         } else {
<span class="line-modified">1736             label.addPatchAt(position(), this);</span>
1737             int regEncoding = cmp.encoding &lt;&lt; (PatchLabelKind.INFORMATION_OFFSET + 1);
1738             int sizeEncoding = (size == 64 ? 1 : 0) &lt;&lt; PatchLabelKind.INFORMATION_OFFSET;
1739             // Encode condition flag so that we know how to patch the instruction later
1740             emitInt(PatchLabelKind.BRANCH_ZERO.encoding | regEncoding | sizeEncoding);
1741         }
1742     }
1743 
1744     /**
1745      * Test a single bit and branch if the bit is nonzero.
1746      *
1747      * @param cmp general purpose register. May not be null, zero-register or stackpointer.
1748      * @param uimm6 Unsigned 6-bit bit index.
1749      * @param label Can only handle 16-bit word-aligned offsets for now. May be unbound. Non null.
1750      */
1751     public void tbnz(Register cmp, int uimm6, Label label) {
1752         assert NumUtil.isUnsignedNbit(6, uimm6);
1753         if (label.isBound()) {
1754             int offset = label.position() - position();
1755             super.tbnz(cmp, uimm6, offset);
1756         } else {
<span class="line-modified">1757             label.addPatchAt(position(), this);</span>
1758             int indexEncoding = uimm6 &lt;&lt; PatchLabelKind.INFORMATION_OFFSET;
1759             int regEncoding = cmp.encoding &lt;&lt; (PatchLabelKind.INFORMATION_OFFSET + 6);
1760             emitInt(PatchLabelKind.BRANCH_BIT_NONZERO.encoding | indexEncoding | regEncoding);
1761         }
1762     }
1763 
1764     /**
1765      * Test a single bit and branch if the bit is zero.
1766      *
1767      * @param cmp general purpose register. May not be null, zero-register or stackpointer.
1768      * @param uimm6 Unsigned 6-bit bit index.
1769      * @param label Can only handle 16-bit word-aligned offsets for now. May be unbound. Non null.
1770      */
1771     public void tbz(Register cmp, int uimm6, Label label) {
1772         assert NumUtil.isUnsignedNbit(6, uimm6);
1773         if (label.isBound()) {
1774             int offset = label.position() - position();
1775             super.tbz(cmp, uimm6, offset);
1776         } else {
<span class="line-modified">1777             label.addPatchAt(position(), this);</span>
1778             int indexEncoding = uimm6 &lt;&lt; PatchLabelKind.INFORMATION_OFFSET;
1779             int regEncoding = cmp.encoding &lt;&lt; (PatchLabelKind.INFORMATION_OFFSET + 6);
1780             emitInt(PatchLabelKind.BRANCH_BIT_ZERO.encoding | indexEncoding | regEncoding);
1781         }
1782     }
1783 
1784     /**
1785      * Branches to label if condition is true.
1786      *
1787      * @param condition any condition value allowed. Non null.
1788      * @param label Can only handle 21-bit word-aligned offsets for now. May be unbound. Non null.
1789      */
1790     public void branchConditionally(ConditionFlag condition, Label label) {
1791         // TODO Handle case where offset is too large for a single jump instruction
1792         if (label.isBound()) {
1793             int offset = label.position() - position();
1794             super.b(condition, offset);
1795         } else {
<span class="line-modified">1796             label.addPatchAt(position(), this);</span>
1797             // Encode condition flag so that we know how to patch the instruction later
1798             emitInt(PatchLabelKind.BRANCH_CONDITIONALLY.encoding | condition.encoding &lt;&lt; PatchLabelKind.INFORMATION_OFFSET);
1799         }
1800     }
1801 
1802     /**
1803      * Branches if condition is true. Address of jump is patched up by HotSpot c++ code.
1804      *
1805      * @param condition any condition value allowed. Non null.
1806      */
1807     public void branchConditionally(ConditionFlag condition) {
1808         // Correct offset is fixed up by HotSpot later.
1809         super.b(condition, 0);
1810     }
1811 
1812     /**
1813      * Jumps to label.
1814      *
1815      * param label Can only handle signed 28-bit offsets. May be unbound. Non null.
1816      */
1817     @Override
1818     public void jmp(Label label) {
1819         // TODO Handle case where offset is too large for a single jump instruction
1820         if (label.isBound()) {
1821             int offset = label.position() - position();
1822             super.b(offset);
1823         } else {
<span class="line-modified">1824             label.addPatchAt(position(), this);</span>
1825             emitInt(PatchLabelKind.BRANCH_UNCONDITIONALLY.encoding);
1826         }
1827     }
1828 
1829     /**
1830      * Jump to address in dest.
1831      *
1832      * @param dest General purpose register. May not be null, zero-register or stackpointer.
1833      */
1834     public void jmp(Register dest) {
1835         super.br(dest);
1836     }
1837 
1838     /**
1839      * Immediate jump instruction fixed up by HotSpot c++ code.
1840      */
1841     public void jmp() {
1842         // Offset has to be fixed up by c++ code.
1843         super.b(0);
1844     }
</pre>
<hr />
<pre>
1871      * Halting mode software breakpoint: Enters halting mode debug state if enabled, else treated as
1872      * UNALLOCATED instruction.
1873      *
1874      * @param exceptionCode exception code specifying why halt was called. Non null.
1875      */
1876     public void hlt(AArch64ExceptionCode exceptionCode) {
1877         super.hlt(exceptionCode.encoding);
1878     }
1879 
1880     /**
1881      * Monitor mode software breakpoint: exception routed to a debug monitor executing in a higher
1882      * exception level.
1883      *
1884      * @param exceptionCode exception code specifying why break was called. Non null.
1885      */
1886     public void brk(AArch64ExceptionCode exceptionCode) {
1887         super.brk(exceptionCode.encoding);
1888     }
1889 
1890     public void pause() {
<span class="line-modified">1891         super.hint(SystemHint.YIELD);</span>
1892     }
1893 
1894     /**
1895      * Executes no-op instruction. No registers or flags are updated, except for PC.
1896      */
1897     public void nop() {
1898         super.hint(SystemHint.NOP);
1899     }
1900 
1901     /**
1902      * Consumption of Speculative Data Barrier. This is a memory barrier that controls speculative
1903      * execution and data value prediction.
1904      */
1905     public void csdb() {
1906         super.hint(SystemHint.CSDB);
1907     }
1908 
1909     /**
1910      * Same as {@link #nop()}.
1911      */
</pre>
<hr />
<pre>
1942         switch (type) {
1943             case BRANCH_CONDITIONALLY:
1944                 ConditionFlag cf = ConditionFlag.fromEncoding(instruction &gt;&gt;&gt; PatchLabelKind.INFORMATION_OFFSET);
1945                 super.b(cf, branchOffset, branch);
1946                 break;
1947             case BRANCH_UNCONDITIONALLY:
1948                 super.b(branchOffset, branch);
1949                 break;
1950             case JUMP_ADDRESS:
1951                 int offset = instruction &gt;&gt;&gt; PatchLabelKind.INFORMATION_OFFSET;
1952                 emitInt(jumpTarget - offset, branch);
1953                 break;
1954             case BRANCH_NONZERO:
1955             case BRANCH_ZERO: {
1956                 int information = instruction &gt;&gt;&gt; PatchLabelKind.INFORMATION_OFFSET;
1957                 int sizeEncoding = information &amp; 1;
1958                 int regEncoding = information &gt;&gt;&gt; 1;
1959                 Register reg = AArch64.cpuRegisters.get(regEncoding);
1960                 // 1 =&gt; 64; 0 =&gt; 32
1961                 int size = sizeEncoding * 32 + 32;
<span class="line-added">1962                 if (!NumUtil.isSignedNbit(21, branchOffset)) {</span>
<span class="line-added">1963                     throw new BranchTargetOutOfBoundsException(true, &quot;Branch target %d out of bounds&quot;, branchOffset);</span>
<span class="line-added">1964                 }</span>
1965                 switch (type) {
1966                     case BRANCH_NONZERO:
1967                         super.cbnz(size, reg, branchOffset, branch);
1968                         break;
1969                     case BRANCH_ZERO:
1970                         super.cbz(size, reg, branchOffset, branch);
1971                         break;
1972                 }
1973                 break;
1974             }
1975             case BRANCH_BIT_NONZERO:
1976             case BRANCH_BIT_ZERO: {
1977                 int information = instruction &gt;&gt;&gt; PatchLabelKind.INFORMATION_OFFSET;
1978                 int sizeEncoding = information &amp; NumUtil.getNbitNumberInt(6);
1979                 int regEncoding = information &gt;&gt;&gt; 6;
1980                 Register reg = AArch64.cpuRegisters.get(regEncoding);
1981                 if (!NumUtil.isSignedNbit(16, branchOffset)) {
1982                     throw new BranchTargetOutOfBoundsException(true, &quot;Branch target %d out of bounds&quot;, branchOffset);
1983                 }
1984                 switch (type) {
</pre>
<hr />
<pre>
1998                 super.adr(reg, branchOffset, branch);
1999                 break;
2000             }
2001             default:
2002                 throw GraalError.shouldNotReachHere();
2003         }
2004     }
2005 
2006     /**
2007      * Generates an address of the form {@code base + displacement}.
2008      *
2009      * Does not change base register to fulfill this requirement. Will fail if displacement cannot
2010      * be represented directly as address.
2011      *
2012      * @param base general purpose register. May not be null or the zero register.
2013      * @param displacement arbitrary displacement added to base.
2014      * @return AArch64Address referencing memory at {@code base + displacement}.
2015      */
2016     @Override
2017     public AArch64Address makeAddress(Register base, int displacement) {
<span class="line-modified">2018         return makeAddress(base, displacement, zr, /* signExtend */false, /* transferSize */0, //</span>
<span class="line-added">2019                         zr, /* allowOverwrite */false);</span>
2020     }
2021 
2022     @Override
2023     public AArch64Address getPlaceholder(int instructionStartPosition) {
2024         return AArch64Address.PLACEHOLDER;
2025     }
2026 
2027     public void addressOf(Register dst) {
<span class="line-modified">2028         if (codePatchingAnnotationConsumer != null) {</span>
<span class="line-added">2029             codePatchingAnnotationConsumer.accept(new AdrpAddMacroInstruction(position()));</span>
<span class="line-added">2030         }</span>
2031         super.adrp(dst);
2032         super.add(64, dst, dst, 0);
2033     }
2034 
2035     /**
2036      * Loads an address into Register d.
2037      *
2038      * @param d general purpose register. May not be null.
2039      * @param a AArch64Address the address of an operand.
2040      */
2041     public void lea(Register d, AArch64Address a) {
2042         a.lea(this, d);
2043     }
<span class="line-added">2044 </span>
<span class="line-added">2045     /**</span>
<span class="line-added">2046      * Count the set bits of src register.</span>
<span class="line-added">2047      *</span>
<span class="line-added">2048      * @param size src register size. Has to be 32 or 64.</span>
<span class="line-added">2049      * @param dst general purpose register. Should not be null or zero-register.</span>
<span class="line-added">2050      * @param src general purpose register. Should not be null.</span>
<span class="line-added">2051      * @param vreg SIMD register. Should not be null.</span>
<span class="line-added">2052      */</span>
<span class="line-added">2053     public void popcnt(int size, Register dst, Register src, Register vreg) {</span>
<span class="line-added">2054         assert 32 == size || 64 == size : &quot;Invalid data size&quot;;</span>
<span class="line-added">2055         fmov(size, vreg, src);</span>
<span class="line-added">2056         final int fixedSize = 64;</span>
<span class="line-added">2057         cnt(fixedSize, vreg, vreg);</span>
<span class="line-added">2058         addv(fixedSize, SIMDElementSize.Byte, vreg, vreg);</span>
<span class="line-added">2059         umov(fixedSize, dst, 0, vreg);</span>
<span class="line-added">2060     }</span>
<span class="line-added">2061 </span>
<span class="line-added">2062     public interface MacroInstruction {</span>
<span class="line-added">2063         void patch(int codePos, int relative, byte[] code);</span>
<span class="line-added">2064     }</span>
<span class="line-added">2065 </span>
<span class="line-added">2066     /**</span>
<span class="line-added">2067      * Emits elf patchable adrp ldr sequence.</span>
<span class="line-added">2068      */</span>
<span class="line-added">2069     public void adrpLdr(int srcSize, Register result, AArch64Address a) {</span>
<span class="line-added">2070         if (codePatchingAnnotationConsumer != null) {</span>
<span class="line-added">2071             codePatchingAnnotationConsumer.accept(new AdrpLdrMacroInstruction(position()));</span>
<span class="line-added">2072         }</span>
<span class="line-added">2073         super.adrp(a.getBase());</span>
<span class="line-added">2074         this.ldr(srcSize, result, a);</span>
<span class="line-added">2075     }</span>
<span class="line-added">2076 </span>
<span class="line-added">2077     public static class AdrpLdrMacroInstruction extends CodeAnnotation implements MacroInstruction {</span>
<span class="line-added">2078         public AdrpLdrMacroInstruction(int position) {</span>
<span class="line-added">2079             super(position);</span>
<span class="line-added">2080         }</span>
<span class="line-added">2081 </span>
<span class="line-added">2082         @Override</span>
<span class="line-added">2083         public String toString() {</span>
<span class="line-added">2084             return &quot;ADRP_LDR&quot;;</span>
<span class="line-added">2085         }</span>
<span class="line-added">2086 </span>
<span class="line-added">2087         @Override</span>
<span class="line-added">2088         public void patch(int codePos, int relative, byte[] code) {</span>
<span class="line-added">2089             throw GraalError.unimplemented();</span>
<span class="line-added">2090         }</span>
<span class="line-added">2091     }</span>
<span class="line-added">2092 </span>
<span class="line-added">2093     public static class AdrpAddMacroInstruction extends CodeAnnotation implements MacroInstruction {</span>
<span class="line-added">2094         public AdrpAddMacroInstruction(int position) {</span>
<span class="line-added">2095             super(position);</span>
<span class="line-added">2096         }</span>
<span class="line-added">2097 </span>
<span class="line-added">2098         @Override</span>
<span class="line-added">2099         public String toString() {</span>
<span class="line-added">2100             return &quot;ADRP_ADD&quot;;</span>
<span class="line-added">2101         }</span>
<span class="line-added">2102 </span>
<span class="line-added">2103         @Override</span>
<span class="line-added">2104         public void patch(int codePos, int relative, byte[] code) {</span>
<span class="line-added">2105             throw GraalError.unimplemented();</span>
<span class="line-added">2106         }</span>
<span class="line-added">2107     }</span>
2108 }
</pre>
</td>
</tr>
</table>
<center><a href="AArch64Assembler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64AsmOptions.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64Assembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.asm.aarch64.test/src/org/graalvm/compiler/asm/aarch64/test/TestProtectedAssembler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64MacroAssembler.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64Assembler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2018, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 
  26 package org.graalvm.compiler.asm.aarch64;
  27 


  28 import static jdk.vm.ci.aarch64.AArch64.cpuRegisters;



  29 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADD;
  30 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADDS;

  31 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADR;
  32 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADRP;
  33 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.AND;
  34 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ANDS;
  35 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ASRV;
  36 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BFM;
  37 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BIC;
  38 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BICS;
  39 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BLR;
  40 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BR;
  41 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BRK;
  42 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CAS;

  43 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLREX;
  44 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLS;
  45 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLZ;

  46 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSEL;
  47 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSINC;
  48 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSNEG;

  49 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.DMB;
  50 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EON;
  51 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EOR;
  52 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EXTR;
  53 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FABS;
  54 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FADD;
  55 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCCMP;
  56 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCMP;
  57 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCMPZERO;
  58 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCSEL;
  59 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCVTDS;
  60 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCVTSD;
  61 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCVTZS;
  62 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FDIV;
  63 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMADD;
  64 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMOV;
  65 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMSUB;
  66 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMUL;
  67 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FNEG;
  68 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTM;
  69 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTN;
  70 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTP;
  71 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTZ;
  72 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FSQRT;
  73 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FSUB;
  74 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.HINT;
  75 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.HLT;
  76 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDADD;
  77 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDAR;
  78 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDAXR;
  79 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDP;
  80 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDR;
  81 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDRS;
  82 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDXR;
  83 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LSLV;
  84 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LSRV;
  85 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MADD;
  86 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVK;
  87 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVN;
  88 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVZ;

  89 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MSUB;
  90 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ORN;
  91 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ORR;
  92 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RBIT;
  93 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RET;
  94 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.REVW;
  95 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.REVX;
  96 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RORV;
  97 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SBFM;
  98 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SCVTF;
  99 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SDIV;
 100 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STLR;
 101 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STLXR;
 102 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STP;
 103 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STR;
 104 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STXR;
 105 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SUB;
 106 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SUBS;
 107 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SWP;
<span class="line-removed"> 108 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.TBZ;</span>
 109 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.TBNZ;

 110 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UBFM;
 111 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UDIV;

 112 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.FP32;
 113 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.FP64;
 114 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.General32;
 115 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.General64;
 116 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.floatFromSize;
 117 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.generalFromSize;
<span class="line-modified"> 118 import static jdk.vm.ci.aarch64.AArch64.CPU;</span>
<span class="line-removed"> 119 import static jdk.vm.ci.aarch64.AArch64.SIMD;</span>
<span class="line-removed"> 120 import static jdk.vm.ci.aarch64.AArch64.r0;</span>
<span class="line-removed"> 121 import static jdk.vm.ci.aarch64.AArch64.sp;</span>
<span class="line-removed"> 122 import static jdk.vm.ci.aarch64.AArch64.zr;</span>
 123 
 124 import java.util.Arrays;
 125 
 126 import org.graalvm.compiler.asm.Assembler;
<span class="line-removed"> 127 import org.graalvm.compiler.core.common.NumUtil;</span>
 128 import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;

 129 import org.graalvm.compiler.debug.GraalError;
 130 
 131 import jdk.vm.ci.aarch64.AArch64;
 132 import jdk.vm.ci.aarch64.AArch64.CPUFeature;
 133 import jdk.vm.ci.aarch64.AArch64.Flag;
 134 import jdk.vm.ci.code.Register;
 135 import jdk.vm.ci.code.TargetDescription;
 136 
 137 public abstract class AArch64Assembler extends Assembler {
 138 
 139     public static class LogicalImmediateTable {
 140 
 141         private static final Immediate[] IMMEDIATE_TABLE = buildImmediateTable();
 142 
 143         private static final int ImmediateOffset = 10;
 144         private static final int ImmediateRotateOffset = 16;
 145         private static final int ImmediateSizeOffset = 22;
 146 
 147         /**
 148          * Specifies whether immediate can be represented in all cases (YES), as a 64bit instruction
</pre>
<hr />
<pre>
 351         return reg.encoding &lt;&lt; Rs3Offset;
 352     }
 353 
 354     private static int rt(Register reg) {
 355         return reg.encoding &lt;&lt; RtOffset;
 356     }
 357 
 358     private static int rt2(Register reg) {
 359         return reg.encoding &lt;&lt; Rt2Offset;
 360     }
 361 
 362     private static int rn(Register reg) {
 363         return reg.encoding &lt;&lt; RnOffset;
 364     }
 365 
 366     private static int maskField(int sizeInBits, int n) {
 367         assert NumUtil.isSignedNbit(sizeInBits, n);
 368         return n &amp; NumUtil.getNbitNumberInt(sizeInBits);
 369     }
 370 




















 371     /**
 372      * Enumeration of all different instruction kinds: General32/64 are the general instructions
 373      * (integer, branch, etc.), for 32-, respectively 64-bit operands. FP32/64 is the encoding for
<span class="line-modified"> 374      * the 32/64bit float operations</span>

 375      */
 376     protected enum InstructionType {
 377         General32(0b00 &lt;&lt; 30, 32, true),
 378         General64(0b10 &lt;&lt; 30, 64, true),
 379         FP32(0x00000000, 32, false),
<span class="line-modified"> 380         FP64(0x00400000, 64, false);</span>





 381 
 382         public final int encoding;
 383         public final int width;
 384         public final boolean isGeneral;
 385 
 386         InstructionType(int encoding, int width, boolean isGeneral) {
 387             this.encoding = encoding;
 388             this.width = width;
 389             this.isGeneral = isGeneral;
 390         }
 391 
 392         public static InstructionType generalFromSize(int size) {
 393             assert size == 32 || size == 64;
 394             return size == 32 ? General32 : General64;
 395         }
 396 
 397         public static InstructionType floatFromSize(int size) {
 398             assert size == 32 || size == 64;
 399             return size == 32 ? FP32 : FP64;
 400         }
 401 














 402     }
 403 
 404     private static final int ImmediateOffset = 10;
 405     private static final int ImmediateRotateOffset = 16;
 406     private static final int ImmediateSizeOffset = 22;
 407     private static final int ExtendTypeOffset = 13;
 408 
 409     private static final int AddSubImmOp = 0x11000000;
 410     private static final int AddSubShift12 = 0b01 &lt;&lt; 22;
 411     private static final int AddSubSetFlag = 0x20000000;
 412 
 413     private static final int LogicalImmOp = 0x12000000;
 414 
 415     private static final int MoveWideImmOp = 0x12800000;
 416     private static final int MoveWideImmOffset = 5;
 417     private static final int MoveWideShiftOffset = 21;
 418 
 419     private static final int BitfieldImmOp = 0x13000000;
 420 
 421     private static final int AddSubShiftedOp = 0x0B000000;
 422     private static final int ShiftTypeOffset = 22;
 423 
 424     private static final int AddSubExtendedOp = 0x0B200000;
 425 
 426     private static final int MulOp = 0x1B000000;

 427     private static final int DataProcessing1SourceOp = 0x5AC00000;
 428     private static final int DataProcessing2SourceOp = 0x1AC00000;
 429 
 430     private static final int Fp1SourceOp = 0x1E204000;
 431     private static final int Fp2SourceOp = 0x1E200800;
 432     private static final int Fp3SourceOp = 0x1F000000;
 433 
 434     private static final int FpConvertOp = 0x1E200000;
 435     private static final int FpImmOp = 0x1E201000;
 436     private static final int FpImmOffset = 13;
 437 
 438     private static final int FpCmpOp = 0x1E202000;

 439 
 440     private static final int PcRelImmHiOffset = 5;
 441     private static final int PcRelImmLoOffset = 29;
 442 
 443     private static final int PcRelImmOp = 0x10000000;
 444 
 445     private static final int UnconditionalBranchImmOp = 0x14000000;
 446     private static final int UnconditionalBranchRegOp = 0xD6000000;
 447     private static final int CompareBranchOp = 0x34000000;
 448 
 449     private static final int ConditionalBranchImmOffset = 5;
 450 
 451     private static final int ConditionalSelectOp = 0x1A800000;
 452     private static final int ConditionalConditionOffset = 12;
 453 
 454     private static final int LoadStoreScaledOp = 0b111_0_01_00 &lt;&lt; 22;
 455     private static final int LoadStoreUnscaledOp = 0b111_0_00_00 &lt;&lt; 22;
 456 
 457     private static final int LoadStoreRegisterOp = 0b111_0_00_00_1 &lt;&lt; 21 | 0b10 &lt;&lt; 10;
 458 
</pre>
<hr />
<pre>
 473     @SuppressWarnings(&quot;unused&quot;) private static final int LoadStorePairPostIndexOp = 0b101_0_001 &lt;&lt; 23;
 474     @SuppressWarnings(&quot;unused&quot;) private static final int LoadStorePairPreIndexOp = 0b101_0_011 &lt;&lt; 23;
 475     private static final int LoadStorePairImm7Offset = 15;
 476 
 477     private static final int LogicalShiftOp = 0x0A000000;
 478 
 479     private static final int ExceptionOp = 0xD4000000;
 480     private static final int SystemImmediateOffset = 5;
 481 
 482     @SuppressWarnings(&quot;unused&quot;) private static final int SimdImmediateOffset = 16;
 483 
 484     private static final int BarrierOp = 0xD503301F;
 485     private static final int BarrierKindOffset = 8;
 486 
 487     private static final int CASAcquireOffset = 22;
 488     private static final int CASReleaseOffset = 15;
 489 
 490     private static final int LDADDAcquireOffset = 23;
 491     private static final int LDADDReleaseOffset = 22;
 492 




 493     /**
 494      * Encoding for all instructions.
 495      */
 496     public enum Instruction {
 497         BCOND(0x54000000),
 498         CBNZ(0x01000000),
 499         CBZ(0x00000000),
 500         TBZ(0x36000000),
 501         TBNZ(0x37000000),
 502 
 503         B(0x00000000),
 504         BL(0x80000000),
 505         BR(0x001F0000),
 506         BLR(0x003F0000),
 507         RET(0x005F0000),
 508 
 509         LDR(0x00000000),
 510         LDRS(0x00800000),
 511         LDXR(0x081f7c00),
 512         LDAR(0x8dffc00),
</pre>
<hr />
<pre>
 515         STR(0x00000000),
 516         STXR(0x08007c00),
 517         STLR(0x089ffc00),
 518         STLXR(0x0800fc00),
 519 
 520         LDP(0b1 &lt;&lt; 22),
 521         STP(0b0 &lt;&lt; 22),
 522 
 523         CAS(0x08A07C00),
 524         LDADD(0x38200000),
 525         SWP(0x38208000),
 526 
 527         ADR(0x00000000),
 528         ADRP(0x80000000),
 529 
 530         ADD(0x00000000),
 531         ADDS(ADD.encoding | AddSubSetFlag),
 532         SUB(0x40000000),
 533         SUBS(SUB.encoding | AddSubSetFlag),
 534 


 535         NOT(0x00200000),
 536         AND(0x00000000),
 537         BIC(AND.encoding | NOT.encoding),
 538         ORR(0x20000000),
 539         ORN(ORR.encoding | NOT.encoding),
 540         EOR(0x40000000),
 541         EON(EOR.encoding | NOT.encoding),
 542         ANDS(0x60000000),
 543         BICS(ANDS.encoding | NOT.encoding),
 544 
 545         ASRV(0x00002800),
 546         RORV(0x00002C00),
 547         LSRV(0x00002400),
 548         LSLV(0x00002000),
 549 
 550         CLS(0x00001400),
 551         CLZ(0x00001000),
 552         RBIT(0x00000000),
 553         REVX(0x00000C00),
 554         REVW(0x00000800),
</pre>
<hr />
<pre>
 589         FRINTN(0x00040000),
 590         FRINTP(0x00048000),
 591         FRINTZ(0x00058000),
 592 
 593         FADD(0x00002000),
 594         FSUB(0x00003000),
 595         FMUL(0x00000000),
 596         FDIV(0x00001000),
 597         FMAX(0x00004000),
 598         FMIN(0x00005000),
 599 
 600         FMADD(0x00000000),
 601         FMSUB(0x00008000),
 602 
 603         FCMP(0x00000000),
 604         FCMPZERO(0x00000008),
 605         FCCMP(0x1E200400),
 606         FCSEL(0x1E200C00),
 607 
 608         INS(0x4e081c00),
<span class="line-modified"> 609         UMOV(0x4e083c00),</span>
 610 
 611         CNT(0xe205800),
 612         USRA(0x6f001400),
 613 
 614         HLT(0x00400000),
 615         BRK(0x00200000),
 616 
 617         CLREX(0xd5033f5f),
 618         HINT(0xD503201F),
 619         DMB(0x000000A0),
 620 
<span class="line-modified"> 621         BLR_NATIVE(0xc0000000);</span>






 622 
 623         public final int encoding;
 624 
 625         Instruction(int encoding) {
 626             this.encoding = encoding;
 627         }
 628 
 629     }
 630 









































 631     public enum ShiftType {
 632         LSL(0),
 633         LSR(1),
 634         ASR(2),
 635         ROR(3);
 636 
 637         public final int encoding;
 638 
 639         ShiftType(int encoding) {
 640             this.encoding = encoding;
 641         }
 642     }
 643 
 644     public enum ExtendType {
 645         UXTB(0),
 646         UXTH(1),
 647         UXTW(2),
 648         UXTX(3),
 649         SXTB(4),
 650         SXTH(5),
</pre>
<hr />
<pre>
 917         InstructionType type = generalFromSize(size);
 918         int encoding = type.encoding | TBZ.encoding | (uimm5 &lt;&lt; 19) | (imm14 &lt;&lt; 5) | rd(reg);
 919         if (pos == -1) {
 920             emitInt(encoding);
 921         } else {
 922             emitInt(encoding, pos);
 923         }
 924     }
 925 
 926     private void conditionalBranchInstruction(Register reg, int imm21, InstructionType type, Instruction instr, int pos) {
 927         assert reg.getRegisterCategory().equals(CPU);
 928         int instrEncoding = instr.encoding | CompareBranchOp;
 929         if (pos == -1) {
 930             emitInt(type.encoding | instrEncoding | getConditionalBranchImm(imm21) | rd(reg));
 931         } else {
 932             emitInt(type.encoding | instrEncoding | getConditionalBranchImm(imm21) | rd(reg), pos);
 933         }
 934     }
 935 
 936     private static int getConditionalBranchImm(int imm21) {
<span class="line-modified"> 937         assert NumUtil.isSignedNbit(21, imm21) &amp;&amp; (imm21 &amp; 0x3) == 0 : &quot;Immediate has to be 21bit signed number and word aligned&quot;;</span>
 938         int imm = (imm21 &amp; NumUtil.getNbitNumberInt(21)) &gt;&gt; 2;
 939         return imm &lt;&lt; ConditionalBranchImmOffset;
 940     }
 941 
 942     /* Unconditional Branch (immediate) (5.2.2) */
 943 
 944     /**
 945      * @param imm28 Signed 28-bit offset, has to be word aligned.
 946      */
 947     protected void b(int imm28) {
 948         unconditionalBranchImmInstruction(imm28, Instruction.B, -1);
 949     }
 950 
 951     /**
 952      *
 953      * @param imm28 Signed 28-bit offset, has to be word aligned.
 954      * @param pos Position where instruction is inserted into code buffer.
 955      */
 956     protected void b(int imm28, int pos) {
 957         unconditionalBranchImmInstruction(imm28, Instruction.B, pos);
 958     }
 959 
 960     /**
 961      * Branch and link return address to register X30.
 962      *
 963      * @param imm28 Signed 28-bit offset, has to be word aligned.
 964      */
 965     public void bl(int imm28) {
 966         unconditionalBranchImmInstruction(imm28, Instruction.BL, -1);
 967     }
 968 
 969     private void unconditionalBranchImmInstruction(int imm28, Instruction instr, int pos) {
 970         assert NumUtil.isSignedNbit(28, imm28) &amp;&amp; (imm28 &amp; 0x3) == 0 : &quot;Immediate has to be 28bit signed number and word aligned&quot;;
 971         int imm = (imm28 &amp; NumUtil.getNbitNumberInt(28)) &gt;&gt; 2;
 972         int instrEncoding = instr.encoding | UnconditionalBranchImmOp;
 973         if (pos == -1) {

 974             emitInt(instrEncoding | imm);
 975         } else {

 976             emitInt(instrEncoding | imm, pos);
 977         }
 978     }
 979 
 980     /* Unconditional Branch (register) (5.2.3) */
 981 
 982     /**
 983      * Branches to address in register and writes return address into register X30.
 984      *
 985      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 986      */
 987     public void blr(Register reg) {
 988         unconditionalBranchRegInstruction(BLR, reg);
 989     }
 990 
 991     /**
 992      * Branches to address in register.
 993      *
 994      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 995      */
 996     protected void br(Register reg) {
 997         unconditionalBranchRegInstruction(BR, reg);
 998     }
 999 
1000     /**
1001      * Return to address in register.
1002      *
1003      * @param reg general purpose register. May not be null, zero-register or stackpointer.
1004      */
1005     public void ret(Register reg) {
1006         unconditionalBranchRegInstruction(RET, reg);
1007     }
1008 
1009     private void unconditionalBranchRegInstruction(Instruction instr, Register reg) {
1010         assert reg.getRegisterCategory().equals(CPU);
1011         assert !reg.equals(zr);
1012         assert !reg.equals(sp);
1013         emitInt(instr.encoding | UnconditionalBranchRegOp | rs1(reg));

1014     }
1015 
1016     /* Load-Store Single Register (5.3.1) */
1017 
1018     /**
1019      * Loads a srcSize value from address into rt zero-extending it.
1020      *
1021      * @param srcSize size of memory read in bits. Must be 8, 16, 32 or 64.
1022      * @param rt general purpose register. May not be null or stackpointer.
1023      * @param address all addressing modes allowed. May not be null.
1024      */
1025     public void ldr(int srcSize, Register rt, AArch64Address address) {
1026         assert rt.getRegisterCategory().equals(CPU);
1027         assert srcSize == 8 || srcSize == 16 || srcSize == 32 || srcSize == 64;
1028         int transferSize = NumUtil.log2Ceil(srcSize / 8);
1029         loadStoreInstruction(LDR, rt, address, General32, transferSize);
1030     }
1031 
1032     /**
1033      * Loads a srcSize value from address into rt sign-extending it.
</pre>
<hr />
<pre>
1130         final Register rt = mode.toRegister();
1131         // this looks weird but that&#39;s because loadStoreInstruction is weird
1132         // instruction select fields are size [31:30], v [26] and opc [25:24]
1133         // prfm requires size == 0b11, v == 0b0 and opc == 0b11
1134         // passing LDRS ensures opc[1] == 0b1
1135         // (n.b. passing LDR/STR makes no difference to opc[1:0]!!)
1136         // passing General64 ensures opc[0] == 0b1 and v = 0b0
1137         // (n.b. passing General32 ensures opc[0] == 0b0 and v = 0b0)
1138         // srcSize 64 ensures size == 0b11
1139         loadStoreInstruction(LDRS, rt, address, General64, transferSize);
1140     }
1141 
1142     /**
1143      * Stores register rt into memory pointed by address.
1144      *
1145      * @param destSize number of bits written to memory. Must be 8, 16, 32 or 64.
1146      * @param rt general purpose register. May not be null or stackpointer.
1147      * @param address all addressing modes allowed. May not be null.
1148      */
1149     public void str(int destSize, Register rt, AArch64Address address) {
<span class="line-modified">1150         assert rt.getRegisterCategory().equals(CPU);</span>
1151         assert destSize == 8 || destSize == 16 || destSize == 32 || destSize == 64;
1152         int transferSize = NumUtil.log2Ceil(destSize / 8);
1153         loadStoreInstruction(STR, rt, address, General64, transferSize);
1154     }
1155 
1156     private void loadStoreInstruction(Instruction instr, Register reg, AArch64Address address, InstructionType type, int log2TransferSize) {
1157         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1158         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1159         int is32Bit = type.width == 32 ? 1 &lt;&lt; ImmediateSizeOffset : 0;
1160         int isFloat = !type.isGeneral ? 1 &lt;&lt; LoadStoreFpFlagOffset : 0;
1161         int memop = instr.encoding | transferSizeEncoding | is32Bit | isFloat | rt(reg);
1162         switch (address.getAddressingMode()) {
1163             case IMMEDIATE_SCALED:

1164                 emitInt(memop | LoadStoreScaledOp | address.getImmediate() &lt;&lt; LoadStoreScaledImmOffset | rs1(address.getBase()));
1165                 break;
1166             case IMMEDIATE_UNSCALED:

1167                 emitInt(memop | LoadStoreUnscaledOp | address.getImmediate() &lt;&lt; LoadStoreUnscaledImmOffset | rs1(address.getBase()));
1168                 break;
1169             case BASE_REGISTER_ONLY:
1170                 emitInt(memop | LoadStoreScaledOp | rs1(address.getBase()));
1171                 break;
1172             case EXTENDED_REGISTER_OFFSET:
1173             case REGISTER_OFFSET:
1174                 ExtendType extendType = address.getAddressingMode() == AddressingMode.EXTENDED_REGISTER_OFFSET ? address.getExtendType() : ExtendType.UXTX;
1175                 boolean shouldScale = address.isScaled() &amp;&amp; log2TransferSize != 0;
1176                 emitInt(memop | LoadStoreRegisterOp | rs2(address.getOffset()) | extendType.encoding &lt;&lt; ExtendTypeOffset | (shouldScale ? 1 : 0) &lt;&lt; LoadStoreScaledRegOffset | rs1(address.getBase()));
1177                 break;
1178             case PC_LITERAL:
1179                 assert log2TransferSize &gt;= 2 : &quot;PC literal loads only works for load/stores of 32-bit and larger&quot;;
1180                 transferSizeEncoding = (log2TransferSize - 2) &lt;&lt; LoadStoreTransferSizeOffset;

1181                 emitInt(transferSizeEncoding | isFloat | LoadLiteralOp | rd(reg) | address.getImmediate() &lt;&lt; LoadLiteralImmeOffset);
1182                 break;
1183             case IMMEDIATE_POST_INDEXED:

1184                 emitInt(memop | LoadStorePostIndexedOp | rs1(address.getBase()) | address.getImmediate() &lt;&lt; LoadStoreIndexedImmOffset);
1185                 break;
1186             case IMMEDIATE_PRE_INDEXED:

1187                 emitInt(memop | LoadStorePreIndexedOp | rs1(address.getBase()) | address.getImmediate() &lt;&lt; LoadStoreIndexedImmOffset);
1188                 break;
1189             default:
1190                 throw GraalError.shouldNotReachHere(&quot;Unhandled addressing mode: &quot; + address.getAddressingMode());
1191         }
1192     }
1193 










1194     /**
1195      * Load Pair of Registers calculates an address from a base register value and an immediate
1196      * offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from
1197      * two registers.
1198      */
1199     public void ldp(int size, Register rt, Register rt2, AArch64Address address) {
1200         assert size == 32 || size == 64;
<span class="line-modified">1201         loadStorePairInstruction(LDP, rt, rt2, address, generalFromSize(size));</span>
1202     }
1203 
1204     /**
1205      * Store Pair of Registers calculates an address from a base register value and an immediate
1206      * offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from
1207      * two registers.
1208      */
1209     public void stp(int size, Register rt, Register rt2, AArch64Address address) {
1210         assert size == 32 || size == 64;
<span class="line-modified">1211         loadStorePairInstruction(STP, rt, rt2, address, generalFromSize(size));</span>
1212     }
1213 
<span class="line-modified">1214     private void loadStorePairInstruction(Instruction instr, Register rt, Register rt2, AArch64Address address, InstructionType type) {</span>
<span class="line-modified">1215         int scaledOffset = maskField(7, address.getImmediateRaw());  // LDP/STP use a 7-bit scaled</span>
<span class="line-modified">1216                                                                      // offset</span>








1217         int memop = type.encoding | instr.encoding | scaledOffset &lt;&lt; LoadStorePairImm7Offset | rt2(rt2) | rn(address.getBase()) | rt(rt);
1218         switch (address.getAddressingMode()) {
1219             case IMMEDIATE_SCALED:

1220                 emitInt(memop | LoadStorePairOp | (0b010 &lt;&lt; 23));
1221                 break;
1222             case IMMEDIATE_POST_INDEXED:
1223                 emitInt(memop | LoadStorePairOp | (0b001 &lt;&lt; 23));
1224                 break;
1225             case IMMEDIATE_PRE_INDEXED:
1226                 emitInt(memop | LoadStorePairOp | (0b011 &lt;&lt; 23));
1227                 break;
1228             default:
1229                 throw GraalError.shouldNotReachHere(&quot;Unhandled addressing mode: &quot; + address.getAddressingMode());
1230         }
1231     }
1232 
1233     /* Load-Store Exclusive (5.3.6) */
1234 
1235     /**
1236      * Load address exclusive. Natural alignment of address is required.
1237      *
1238      * @param size size of memory read in bits. Must be 8, 16, 32 or 64.
1239      * @param rt general purpose register. May not be null or stackpointer.
</pre>
<hr />
<pre>
1512 
1513     /**
1514      * dst = src - aimm and sets condition flags.
1515      *
1516      * @param size register size. Has to be 32 or 64.
1517      * @param dst general purpose register. May not be null or stackpointer.
1518      * @param src general purpose register. May not be null or zero-register.
1519      * @param aimm arithmetic immediate. Either unsigned 12-bit value or unsigned 24-bit value with
1520      *            the lower 12-bit cleared.
1521      */
1522     protected void subs(int size, Register dst, Register src, int aimm) {
1523         assert !dst.equals(sp);
1524         assert !src.equals(zr);
1525         addSubImmInstruction(SUBS, dst, src, aimm, generalFromSize(size));
1526     }
1527 
1528     private void addSubImmInstruction(Instruction instr, Register dst, Register src, int aimm, InstructionType type) {
1529         emitInt(type.encoding | instr.encoding | AddSubImmOp | encodeAimm(aimm) | rd(dst) | rs1(src));
1530     }
1531 




1532     /**
1533      * Encodes arithmetic immediate.
1534      *
1535      * @param imm Immediate has to be either an unsigned 12-bit value or an unsigned 24-bit value
1536      *            with the lower 12 bits zero.
1537      * @return Representation of immediate for use with arithmetic instructions.
1538      */
1539     private static int encodeAimm(int imm) {
1540         assert isAimm(imm) : &quot;Immediate has to be legal arithmetic immediate value &quot; + imm;
1541         if (NumUtil.isUnsignedNbit(12, imm)) {
1542             return imm &lt;&lt; ImmediateOffset;
1543         } else {
1544             // First 12-bit are zero, so shift immediate 12-bit and set flag to indicate
1545             // shifted immediate value.
1546             return (imm &gt;&gt;&gt; 12 &lt;&lt; ImmediateOffset) | AddSubShift12;
1547         }
1548     }
1549 
1550     /**
1551      * Checks whether immediate can be encoded as an arithmetic immediate.
</pre>
<hr />
<pre>
2183      */
2184     protected void msub(int size, Register dst, Register src1, Register src2, Register src3) {
2185         mulInstruction(MSUB, dst, src1, src2, src3, generalFromSize(size));
2186     }
2187 
2188     /**
2189      * Signed multiply high. dst = (src1 * src2)[127:64]
2190      *
2191      * @param dst general purpose register. May not be null or the stackpointer.
2192      * @param src1 general purpose register. May not be null or the stackpointer.
2193      * @param src2 general purpose register. May not be null or the stackpointer.
2194      */
2195     protected void smulh(Register dst, Register src1, Register src2) {
2196         assert !dst.equals(sp);
2197         assert !src1.equals(sp);
2198         assert !src2.equals(sp);
2199         emitInt(0b10011011010 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
2200     }
2201 
2202     /**
<span class="line-modified">2203      * unsigned multiply high. dst = (src1 * src2)[127:64]</span>
2204      *
2205      * @param dst general purpose register. May not be null or the stackpointer.
2206      * @param src1 general purpose register. May not be null or the stackpointer.
2207      * @param src2 general purpose register. May not be null or the stackpointer.
2208      */
2209     protected void umulh(Register dst, Register src1, Register src2) {
2210         assert !dst.equals(sp);
2211         assert !src1.equals(sp);
2212         assert !src2.equals(sp);
2213         emitInt(0b10011011110 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
2214     }
2215 
2216     /**
<span class="line-modified">2217      * unsigned multiply add-long. xDst = xSrc3 + (wSrc1 * wSrc2)</span>
2218      *
2219      * @param dst general purpose register. May not be null or the stackpointer.
2220      * @param src1 general purpose register. May not be null or the stackpointer.
2221      * @param src2 general purpose register. May not be null or the stackpointer.
2222      * @param src3 general purpose register. May not be null or the stackpointer.
2223      */
2224     protected void umaddl(Register dst, Register src1, Register src2, Register src3) {
2225         assert !dst.equals(sp);
2226         assert !src1.equals(sp);
2227         assert !src2.equals(sp);
2228         assert !src3.equals(sp);
2229         emitInt(0b10011011101 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
2230     }
2231 
2232     /**
<span class="line-modified">2233      * signed multiply add-long. xDst = xSrc3 + (wSrc1 * wSrc2)</span>
2234      *
2235      * @param dst general purpose register. May not be null or the stackpointer.
2236      * @param src1 general purpose register. May not be null or the stackpointer.
2237      * @param src2 general purpose register. May not be null or the stackpointer.
2238      * @param src3 general purpose register. May not be null or the stackpointer.
2239      */
2240     public void smaddl(Register dst, Register src1, Register src2, Register src3) {
















2241         assert !dst.equals(sp);
2242         assert !src1.equals(sp);
2243         assert !src2.equals(sp);
2244         assert !src3.equals(sp);
<span class="line-modified">2245         emitInt(0b10011011001 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | rs3(src3));</span>
2246     }
2247 
<span class="line-modified">2248     private void mulInstruction(Instruction instr, Register dst, Register src1, Register src2, Register src3, InstructionType type) {</span>
2249         assert !dst.equals(sp);
2250         assert !src1.equals(sp);
2251         assert !src2.equals(sp);
2252         assert !src3.equals(sp);
<span class="line-modified">2253         emitInt(type.encoding | instr.encoding | MulOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));</span>
2254     }
2255 
2256     /**
2257      * Signed divide. dst = src1 / src2.
2258      *
2259      * @param size register size. Has to be 32 or 64.
2260      * @param dst general purpose register. May not be null or the stackpointer.
2261      * @param src1 general purpose register. May not be null or the stackpointer.
2262      * @param src2 general purpose register. May not be null or the stackpointer.
2263      */
2264     public void sdiv(int size, Register dst, Register src1, Register src2) {
2265         dataProcessing2SourceOp(SDIV, dst, src1, src2, generalFromSize(size));
2266     }
2267 
2268     /**
2269      * Unsigned divide. dst = src1 / src2.
2270      *
2271      * @param size register size. Has to be 32 or 64.
2272      * @param dst general purpose register. May not be null or the stackpointer.
2273      * @param src1 general purpose register. May not be null or the stackpointer.
</pre>
<hr />
<pre>
2397         int b = (int) ((repr &gt;&gt;&gt; 61) &amp; 0x1) &lt;&lt; 6;
2398         int cToH = (int) (repr &gt;&gt;&gt; 48) &amp; 0x3f;
2399         return (a | b | cToH) &lt;&lt; FpImmOffset;
2400     }
2401 
2402     protected static boolean isDoubleImmediate(double imm) {
2403         // Valid values will have the form:
2404         // aBbb.bbbb.bbcd.efgh.0000.0000.0000.0000
2405         // 0000.0000.0000.0000.0000.0000.0000.0000
2406         long bits = Double.doubleToRawLongBits(imm);
2407         // lower 48 bits are cleared
2408         if ((bits &amp; NumUtil.getNbitNumberLong(48)) != 0) {
2409             return false;
2410         }
2411         // bits[61..54] are all set or all cleared.
2412         long pattern = (bits &gt;&gt; 54) &amp; NumUtil.getNbitNumberLong(7);
2413         if (pattern != 0 &amp;&amp; pattern != NumUtil.getNbitNumberLong(7)) {
2414             return false;
2415         }
2416         // bits[62] and bits[61] are opposites.
<span class="line-modified">2417         return ((bits ^ (bits &lt;&lt; 1)) &amp; (1L &lt;&lt; 62)) != 0;</span>

2418     }
2419 
2420     private static int getFloatImmediate(float imm) {
2421         assert isFloatImmediate(imm);
2422         // bits: aBbb.bbbc.defg.h000.0000.0000.0000.0000
2423         int repr = Float.floatToRawIntBits(imm);
2424         int a = (repr &gt;&gt;&gt; 31) &lt;&lt; 7;
2425         int b = ((repr &gt;&gt;&gt; 29) &amp; 0x1) &lt;&lt; 6;
2426         int cToH = (repr &gt;&gt;&gt; 19) &amp; NumUtil.getNbitNumberInt(6);
2427         return (a | b | cToH) &lt;&lt; FpImmOffset;
2428     }
2429 
2430     protected static boolean isFloatImmediate(float imm) {
2431         // Valid values will have the form:
2432         // aBbb.bbbc.defg.h000.0000.0000.0000.0000
2433         int bits = Float.floatToRawIntBits(imm);
2434         // lower 20 bits are cleared.
2435         if ((bits &amp; NumUtil.getNbitNumberInt(19)) != 0) {
2436             return false;
2437         }
</pre>
<hr />
<pre>
2676         assert src3.getRegisterCategory().equals(SIMD);
2677         emitInt(type.encoding | instr.encoding | Fp3SourceOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));
2678     }
2679 
2680     /* Floating-point Comparison (5.7.10) */
2681 
2682     /**
2683      * Compares src1 to src2.
2684      *
2685      * @param size register size.
2686      * @param src1 floating point register. May not be null.
2687      * @param src2 floating point register. May not be null.
2688      */
2689     public void fcmp(int size, Register src1, Register src2) {
2690         assert src1.getRegisterCategory().equals(SIMD);
2691         assert src2.getRegisterCategory().equals(SIMD);
2692         InstructionType type = floatFromSize(size);
2693         emitInt(type.encoding | FCMP.encoding | FpCmpOp | rs1(src1) | rs2(src2));
2694     }
2695 














2696     /**
2697      * Conditional compare. NZCV = fcmp(src1, src2) if condition else uimm4.
2698      *
2699      * @param size register size.
2700      * @param src1 floating point register. May not be null.
2701      * @param src2 floating point register. May not be null.
2702      * @param uimm4 condition flags that are used if condition is false.
2703      * @param condition every condition allowed. May not be null.
2704      */
2705     public void fccmp(int size, Register src1, Register src2, int uimm4, ConditionFlag condition) {
2706         assert NumUtil.isUnsignedNbit(4, uimm4);
2707         assert src1.getRegisterCategory().equals(SIMD);
2708         assert src2.getRegisterCategory().equals(SIMD);
2709         InstructionType type = floatFromSize(size);
2710         emitInt(type.encoding | FCCMP.encoding | uimm4 | condition.encoding &lt;&lt; ConditionalConditionOffset | rs1(src1) | rs2(src2));
2711     }
2712 
2713     /**
2714      * Compare register to 0.0 .
2715      *
2716      * @param size register size.
2717      * @param src floating point register. May not be null.
2718      */
2719     public void fcmpZero(int size, Register src) {
2720         assert src.getRegisterCategory().equals(SIMD);
2721         InstructionType type = floatFromSize(size);
2722         emitInt(type.encoding | FCMPZERO.encoding | FpCmpOp | rs1(src));
2723     }
2724 












2725     /* Floating-point Conditional Select (5.7.11) */
2726 
2727     /**
2728      * Conditional select. dst = src1 if condition else src2.
2729      *
2730      * @param size register size.
2731      * @param dst floating point register. May not be null.
2732      * @param src1 floating point register. May not be null.
2733      * @param src2 floating point register. May not be null.
2734      * @param condition every condition allowed. May not be null.
2735      */
2736     protected void fcsel(int size, Register dst, Register src1, Register src2, ConditionFlag condition) {
2737         assert dst.getRegisterCategory().equals(SIMD);
2738         assert src1.getRegisterCategory().equals(SIMD);
2739         assert src2.getRegisterCategory().equals(SIMD);
2740         InstructionType type = floatFromSize(size);
2741         emitInt(type.encoding | FCSEL.encoding | rd(dst) | rs1(src1) | rs2(src2) | condition.encoding &lt;&lt; ConditionalConditionOffset);
2742     }
2743 
2744     /* Debug exceptions (5.9.1.2) */
</pre>
<hr />
<pre>
2816         ANY_ANY(0xB, &quot;ISH&quot;);
2817 
2818         public final int encoding;
2819         public final String optionName;
2820 
2821         BarrierKind(int encoding, String optionName) {
2822             this.encoding = encoding;
2823             this.optionName = optionName;
2824         }
2825     }
2826 
2827     /**
2828      * Data Memory Barrier.
2829      *
2830      * @param barrierKind barrier that is issued. May not be null.
2831      */
2832     public void dmb(BarrierKind barrierKind) {
2833         emitInt(DMB.encoding | BarrierOp | barrierKind.encoding &lt;&lt; BarrierKindOffset);
2834     }
2835 

































































































2836 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2018, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 
  26 package org.graalvm.compiler.asm.aarch64;
  27 
<span class="line-added">  28 import static jdk.vm.ci.aarch64.AArch64.CPU;</span>
<span class="line-added">  29 import static jdk.vm.ci.aarch64.AArch64.SIMD;</span>
  30 import static jdk.vm.ci.aarch64.AArch64.cpuRegisters;
<span class="line-added">  31 import static jdk.vm.ci.aarch64.AArch64.r0;</span>
<span class="line-added">  32 import static jdk.vm.ci.aarch64.AArch64.sp;</span>
<span class="line-added">  33 import static jdk.vm.ci.aarch64.AArch64.zr;</span>
  34 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADD;
  35 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADDS;
<span class="line-added">  36 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADDV;</span>
  37 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADR;
  38 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADRP;
  39 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.AND;
  40 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ANDS;
  41 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ASRV;
  42 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BFM;
  43 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BIC;
  44 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BICS;
  45 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BLR;
  46 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BR;
  47 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BRK;
  48 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CAS;
<span class="line-added">  49 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CCMP;</span>
  50 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLREX;
  51 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLS;
  52 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLZ;
<span class="line-added">  53 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CNT;</span>
  54 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSEL;
  55 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSINC;
  56 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSNEG;
<span class="line-added">  57 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.DC;</span>
  58 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.DMB;
  59 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EON;
  60 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EOR;
  61 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EXTR;
  62 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FABS;
  63 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FADD;
  64 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCCMP;
  65 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCMP;
  66 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCMPZERO;
  67 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCSEL;
  68 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCVTDS;
  69 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCVTSD;
  70 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCVTZS;
  71 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FDIV;
  72 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMADD;
  73 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMOV;
  74 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMSUB;
  75 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMUL;
  76 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FNEG;
  77 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTM;
  78 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTN;
  79 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTP;
  80 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTZ;
  81 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FSQRT;
  82 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FSUB;
  83 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.HINT;
  84 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.HLT;
  85 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDADD;
  86 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDAR;
  87 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDAXR;
  88 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDP;
  89 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDR;
  90 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDRS;
  91 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDXR;
  92 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LSLV;
  93 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LSRV;
  94 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MADD;
  95 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVK;
  96 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVN;
  97 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVZ;
<span class="line-added">  98 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MRS;</span>
  99 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MSUB;
 100 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ORN;
 101 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ORR;
 102 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RBIT;
 103 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RET;
 104 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.REVW;
 105 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.REVX;
 106 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RORV;
 107 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SBFM;
 108 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SCVTF;
 109 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SDIV;
 110 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STLR;
 111 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STLXR;
 112 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STP;
 113 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STR;
 114 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STXR;
 115 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SUB;
 116 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SUBS;
 117 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SWP;

 118 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.TBNZ;
<span class="line-added"> 119 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.TBZ;</span>
 120 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UBFM;
 121 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UDIV;
<span class="line-added"> 122 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UMOV;</span>
 123 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.FP32;
 124 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.FP64;
 125 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.General32;
 126 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.General64;
 127 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.floatFromSize;
 128 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.generalFromSize;
<span class="line-modified"> 129 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.simdFromSize;</span>




 130 
 131 import java.util.Arrays;
 132 
 133 import org.graalvm.compiler.asm.Assembler;

 134 import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;
<span class="line-added"> 135 import org.graalvm.compiler.core.common.NumUtil;</span>
 136 import org.graalvm.compiler.debug.GraalError;
 137 
 138 import jdk.vm.ci.aarch64.AArch64;
 139 import jdk.vm.ci.aarch64.AArch64.CPUFeature;
 140 import jdk.vm.ci.aarch64.AArch64.Flag;
 141 import jdk.vm.ci.code.Register;
 142 import jdk.vm.ci.code.TargetDescription;
 143 
 144 public abstract class AArch64Assembler extends Assembler {
 145 
 146     public static class LogicalImmediateTable {
 147 
 148         private static final Immediate[] IMMEDIATE_TABLE = buildImmediateTable();
 149 
 150         private static final int ImmediateOffset = 10;
 151         private static final int ImmediateRotateOffset = 16;
 152         private static final int ImmediateSizeOffset = 22;
 153 
 154         /**
 155          * Specifies whether immediate can be represented in all cases (YES), as a 64bit instruction
</pre>
<hr />
<pre>
 358         return reg.encoding &lt;&lt; Rs3Offset;
 359     }
 360 
 361     private static int rt(Register reg) {
 362         return reg.encoding &lt;&lt; RtOffset;
 363     }
 364 
 365     private static int rt2(Register reg) {
 366         return reg.encoding &lt;&lt; Rt2Offset;
 367     }
 368 
 369     private static int rn(Register reg) {
 370         return reg.encoding &lt;&lt; RnOffset;
 371     }
 372 
 373     private static int maskField(int sizeInBits, int n) {
 374         assert NumUtil.isSignedNbit(sizeInBits, n);
 375         return n &amp; NumUtil.getNbitNumberInt(sizeInBits);
 376     }
 377 
<span class="line-added"> 378     /**</span>
<span class="line-added"> 379      * Enumeration of all different lane types of SIMD register.</span>
<span class="line-added"> 380      *</span>
<span class="line-added"> 381      * Byte(B):8b/lane; HalfWord(H):16b/lane; Word(S):32b/lane; DoubleWord(D):64b/lane.</span>
<span class="line-added"> 382      */</span>
<span class="line-added"> 383     public enum SIMDElementSize {</span>
<span class="line-added"> 384         Byte(0, 8),</span>
<span class="line-added"> 385         HalfWord(1, 16),</span>
<span class="line-added"> 386         Word(2, 32),</span>
<span class="line-added"> 387         DoubleWord(3, 64);</span>
<span class="line-added"> 388 </span>
<span class="line-added"> 389         public final int encoding;</span>
<span class="line-added"> 390         public final int nbits;</span>
<span class="line-added"> 391 </span>
<span class="line-added"> 392         SIMDElementSize(int encoding, int nbits) {</span>
<span class="line-added"> 393             this.encoding = encoding;</span>
<span class="line-added"> 394             this.nbits = nbits;</span>
<span class="line-added"> 395         }</span>
<span class="line-added"> 396     }</span>
<span class="line-added"> 397 </span>
 398     /**
 399      * Enumeration of all different instruction kinds: General32/64 are the general instructions
 400      * (integer, branch, etc.), for 32-, respectively 64-bit operands. FP32/64 is the encoding for
<span class="line-modified"> 401      * the 32/64bit float operations. SIMDByte/HalfWord/Word/DoubleWord is the encoding for SIMD</span>
<span class="line-added"> 402      * instructions</span>
 403      */
 404     protected enum InstructionType {
 405         General32(0b00 &lt;&lt; 30, 32, true),
 406         General64(0b10 &lt;&lt; 30, 64, true),
 407         FP32(0x00000000, 32, false),
<span class="line-modified"> 408         FP64(0x00400000, 64, false),</span>
<span class="line-added"> 409 </span>
<span class="line-added"> 410         SIMDByte(0x01, 8, false),</span>
<span class="line-added"> 411         SIMDHalfWord(0x02, 16, false),</span>
<span class="line-added"> 412         SIMDWord(0x04, 32, false),</span>
<span class="line-added"> 413         SIMDDoubleWord(0x08, 64, false);</span>
 414 
 415         public final int encoding;
 416         public final int width;
 417         public final boolean isGeneral;
 418 
 419         InstructionType(int encoding, int width, boolean isGeneral) {
 420             this.encoding = encoding;
 421             this.width = width;
 422             this.isGeneral = isGeneral;
 423         }
 424 
 425         public static InstructionType generalFromSize(int size) {
 426             assert size == 32 || size == 64;
 427             return size == 32 ? General32 : General64;
 428         }
 429 
 430         public static InstructionType floatFromSize(int size) {
 431             assert size == 32 || size == 64;
 432             return size == 32 ? FP32 : FP64;
 433         }
 434 
<span class="line-added"> 435         public static InstructionType simdFromSize(int size) {</span>
<span class="line-added"> 436             switch (size) {</span>
<span class="line-added"> 437                 case 8:</span>
<span class="line-added"> 438                     return SIMDByte;</span>
<span class="line-added"> 439                 case 16:</span>
<span class="line-added"> 440                     return SIMDHalfWord;</span>
<span class="line-added"> 441                 case 32:</span>
<span class="line-added"> 442                     return SIMDWord;</span>
<span class="line-added"> 443                 case 64:</span>
<span class="line-added"> 444                     return SIMDDoubleWord;</span>
<span class="line-added"> 445                 default:</span>
<span class="line-added"> 446                     throw GraalError.shouldNotReachHere();</span>
<span class="line-added"> 447             }</span>
<span class="line-added"> 448         }</span>
 449     }
 450 
 451     private static final int ImmediateOffset = 10;
 452     private static final int ImmediateRotateOffset = 16;
 453     private static final int ImmediateSizeOffset = 22;
 454     private static final int ExtendTypeOffset = 13;
 455 
 456     private static final int AddSubImmOp = 0x11000000;
 457     private static final int AddSubShift12 = 0b01 &lt;&lt; 22;
 458     private static final int AddSubSetFlag = 0x20000000;
 459 
 460     private static final int LogicalImmOp = 0x12000000;
 461 
 462     private static final int MoveWideImmOp = 0x12800000;
 463     private static final int MoveWideImmOffset = 5;
 464     private static final int MoveWideShiftOffset = 21;
 465 
 466     private static final int BitfieldImmOp = 0x13000000;
 467 
 468     private static final int AddSubShiftedOp = 0x0B000000;
 469     private static final int ShiftTypeOffset = 22;
 470 
 471     private static final int AddSubExtendedOp = 0x0B200000;
 472 
 473     private static final int MulOp = 0x1B000000;
<span class="line-added"> 474     private static final int SignedMulLongOp = 0x9B200000;</span>
 475     private static final int DataProcessing1SourceOp = 0x5AC00000;
 476     private static final int DataProcessing2SourceOp = 0x1AC00000;
 477 
 478     private static final int Fp1SourceOp = 0x1E204000;
 479     private static final int Fp2SourceOp = 0x1E200800;
 480     private static final int Fp3SourceOp = 0x1F000000;
 481 
 482     private static final int FpConvertOp = 0x1E200000;
 483     private static final int FpImmOp = 0x1E201000;
 484     private static final int FpImmOffset = 13;
 485 
 486     private static final int FpCmpOp = 0x1E202000;
<span class="line-added"> 487     private static final int FpCmpeOp = 0x1E202010;</span>
 488 
 489     private static final int PcRelImmHiOffset = 5;
 490     private static final int PcRelImmLoOffset = 29;
 491 
 492     private static final int PcRelImmOp = 0x10000000;
 493 
 494     private static final int UnconditionalBranchImmOp = 0x14000000;
 495     private static final int UnconditionalBranchRegOp = 0xD6000000;
 496     private static final int CompareBranchOp = 0x34000000;
 497 
 498     private static final int ConditionalBranchImmOffset = 5;
 499 
 500     private static final int ConditionalSelectOp = 0x1A800000;
 501     private static final int ConditionalConditionOffset = 12;
 502 
 503     private static final int LoadStoreScaledOp = 0b111_0_01_00 &lt;&lt; 22;
 504     private static final int LoadStoreUnscaledOp = 0b111_0_00_00 &lt;&lt; 22;
 505 
 506     private static final int LoadStoreRegisterOp = 0b111_0_00_00_1 &lt;&lt; 21 | 0b10 &lt;&lt; 10;
 507 
</pre>
<hr />
<pre>
 522     @SuppressWarnings(&quot;unused&quot;) private static final int LoadStorePairPostIndexOp = 0b101_0_001 &lt;&lt; 23;
 523     @SuppressWarnings(&quot;unused&quot;) private static final int LoadStorePairPreIndexOp = 0b101_0_011 &lt;&lt; 23;
 524     private static final int LoadStorePairImm7Offset = 15;
 525 
 526     private static final int LogicalShiftOp = 0x0A000000;
 527 
 528     private static final int ExceptionOp = 0xD4000000;
 529     private static final int SystemImmediateOffset = 5;
 530 
 531     @SuppressWarnings(&quot;unused&quot;) private static final int SimdImmediateOffset = 16;
 532 
 533     private static final int BarrierOp = 0xD503301F;
 534     private static final int BarrierKindOffset = 8;
 535 
 536     private static final int CASAcquireOffset = 22;
 537     private static final int CASReleaseOffset = 15;
 538 
 539     private static final int LDADDAcquireOffset = 23;
 540     private static final int LDADDReleaseOffset = 22;
 541 
<span class="line-added"> 542     private static final int SIMDImm5Offset = 16;</span>
<span class="line-added"> 543     private static final int SIMDQBitOffset = 30;</span>
<span class="line-added"> 544     private static final int SIMDSizeOffset = 22;</span>
<span class="line-added"> 545 </span>
 546     /**
 547      * Encoding for all instructions.
 548      */
 549     public enum Instruction {
 550         BCOND(0x54000000),
 551         CBNZ(0x01000000),
 552         CBZ(0x00000000),
 553         TBZ(0x36000000),
 554         TBNZ(0x37000000),
 555 
 556         B(0x00000000),
 557         BL(0x80000000),
 558         BR(0x001F0000),
 559         BLR(0x003F0000),
 560         RET(0x005F0000),
 561 
 562         LDR(0x00000000),
 563         LDRS(0x00800000),
 564         LDXR(0x081f7c00),
 565         LDAR(0x8dffc00),
</pre>
<hr />
<pre>
 568         STR(0x00000000),
 569         STXR(0x08007c00),
 570         STLR(0x089ffc00),
 571         STLXR(0x0800fc00),
 572 
 573         LDP(0b1 &lt;&lt; 22),
 574         STP(0b0 &lt;&lt; 22),
 575 
 576         CAS(0x08A07C00),
 577         LDADD(0x38200000),
 578         SWP(0x38208000),
 579 
 580         ADR(0x00000000),
 581         ADRP(0x80000000),
 582 
 583         ADD(0x00000000),
 584         ADDS(ADD.encoding | AddSubSetFlag),
 585         SUB(0x40000000),
 586         SUBS(SUB.encoding | AddSubSetFlag),
 587 
<span class="line-added"> 588         CCMP(0x7A400000),</span>
<span class="line-added"> 589 </span>
 590         NOT(0x00200000),
 591         AND(0x00000000),
 592         BIC(AND.encoding | NOT.encoding),
 593         ORR(0x20000000),
 594         ORN(ORR.encoding | NOT.encoding),
 595         EOR(0x40000000),
 596         EON(EOR.encoding | NOT.encoding),
 597         ANDS(0x60000000),
 598         BICS(ANDS.encoding | NOT.encoding),
 599 
 600         ASRV(0x00002800),
 601         RORV(0x00002C00),
 602         LSRV(0x00002400),
 603         LSLV(0x00002000),
 604 
 605         CLS(0x00001400),
 606         CLZ(0x00001000),
 607         RBIT(0x00000000),
 608         REVX(0x00000C00),
 609         REVW(0x00000800),
</pre>
<hr />
<pre>
 644         FRINTN(0x00040000),
 645         FRINTP(0x00048000),
 646         FRINTZ(0x00058000),
 647 
 648         FADD(0x00002000),
 649         FSUB(0x00003000),
 650         FMUL(0x00000000),
 651         FDIV(0x00001000),
 652         FMAX(0x00004000),
 653         FMIN(0x00005000),
 654 
 655         FMADD(0x00000000),
 656         FMSUB(0x00008000),
 657 
 658         FCMP(0x00000000),
 659         FCMPZERO(0x00000008),
 660         FCCMP(0x1E200400),
 661         FCSEL(0x1E200C00),
 662 
 663         INS(0x4e081c00),
<span class="line-modified"> 664         UMOV(0x0e003c00),</span>
 665 
 666         CNT(0xe205800),
 667         USRA(0x6f001400),
 668 
 669         HLT(0x00400000),
 670         BRK(0x00200000),
 671 
 672         CLREX(0xd5033f5f),
 673         HINT(0xD503201F),
 674         DMB(0x000000A0),
 675 
<span class="line-modified"> 676         MRS(0xD5300000),</span>
<span class="line-added"> 677         MSR(0xD5100000),</span>
<span class="line-added"> 678         DC(0xD5087000),</span>
<span class="line-added"> 679 </span>
<span class="line-added"> 680         BLR_NATIVE(0xc0000000),</span>
<span class="line-added"> 681 </span>
<span class="line-added"> 682         ADDV(0x0e31b800);</span>
 683 
 684         public final int encoding;
 685 
 686         Instruction(int encoding) {
 687             this.encoding = encoding;
 688         }
 689 
 690     }
 691 
<span class="line-added"> 692     public enum SystemRegister {</span>
<span class="line-added"> 693         FPCR(0b11, 0b011, 0b0100, 0b0100, 0b000),</span>
<span class="line-added"> 694         FPSR(0b11, 0b011, 0b0100, 0b0100, 0b001);</span>
<span class="line-added"> 695 </span>
<span class="line-added"> 696         SystemRegister(int op0, int op1, int crn, int crm, int op2) {</span>
<span class="line-added"> 697             this.op0 = op0;</span>
<span class="line-added"> 698             this.op1 = op1;</span>
<span class="line-added"> 699             this.crn = crn;</span>
<span class="line-added"> 700             this.crm = crm;</span>
<span class="line-added"> 701             this.op2 = op2;</span>
<span class="line-added"> 702         }</span>
<span class="line-added"> 703 </span>
<span class="line-added"> 704         public int encoding() {</span>
<span class="line-added"> 705             return op0 &lt;&lt; 19 | op1 &lt;&lt; 16 | crn &lt;&lt; 12 | crm &lt;&lt; 8 | op2 &lt;&lt; 5;</span>
<span class="line-added"> 706         }</span>
<span class="line-added"> 707 </span>
<span class="line-added"> 708         private final int op0;</span>
<span class="line-added"> 709         private final int op1;</span>
<span class="line-added"> 710         private final int crn;</span>
<span class="line-added"> 711         private final int crm;</span>
<span class="line-added"> 712         private final int op2;</span>
<span class="line-added"> 713     }</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715     public enum DataCacheOperationType {</span>
<span class="line-added"> 716         ZVA(0b011, 0b0100, 0b001);</span>
<span class="line-added"> 717 </span>
<span class="line-added"> 718         DataCacheOperationType(int op1, int crm, int op2) {</span>
<span class="line-added"> 719             this.op1 = op1;</span>
<span class="line-added"> 720             this.crm = crm;</span>
<span class="line-added"> 721             this.op2 = op2;</span>
<span class="line-added"> 722         }</span>
<span class="line-added"> 723 </span>
<span class="line-added"> 724         public int encoding() {</span>
<span class="line-added"> 725             return op1 &lt;&lt; 16 | crm &lt;&lt; 8 | op2 &lt;&lt; 5;</span>
<span class="line-added"> 726         }</span>
<span class="line-added"> 727 </span>
<span class="line-added"> 728         private final int op1;</span>
<span class="line-added"> 729         private final int crm;</span>
<span class="line-added"> 730         private final int op2;</span>
<span class="line-added"> 731     }</span>
<span class="line-added"> 732 </span>
 733     public enum ShiftType {
 734         LSL(0),
 735         LSR(1),
 736         ASR(2),
 737         ROR(3);
 738 
 739         public final int encoding;
 740 
 741         ShiftType(int encoding) {
 742             this.encoding = encoding;
 743         }
 744     }
 745 
 746     public enum ExtendType {
 747         UXTB(0),
 748         UXTH(1),
 749         UXTW(2),
 750         UXTX(3),
 751         SXTB(4),
 752         SXTH(5),
</pre>
<hr />
<pre>
1019         InstructionType type = generalFromSize(size);
1020         int encoding = type.encoding | TBZ.encoding | (uimm5 &lt;&lt; 19) | (imm14 &lt;&lt; 5) | rd(reg);
1021         if (pos == -1) {
1022             emitInt(encoding);
1023         } else {
1024             emitInt(encoding, pos);
1025         }
1026     }
1027 
1028     private void conditionalBranchInstruction(Register reg, int imm21, InstructionType type, Instruction instr, int pos) {
1029         assert reg.getRegisterCategory().equals(CPU);
1030         int instrEncoding = instr.encoding | CompareBranchOp;
1031         if (pos == -1) {
1032             emitInt(type.encoding | instrEncoding | getConditionalBranchImm(imm21) | rd(reg));
1033         } else {
1034             emitInt(type.encoding | instrEncoding | getConditionalBranchImm(imm21) | rd(reg), pos);
1035         }
1036     }
1037 
1038     private static int getConditionalBranchImm(int imm21) {
<span class="line-modified">1039         assert NumUtil.isSignedNbit(21, imm21) &amp;&amp; (imm21 &amp; 0x3) == 0 : String.format(&quot;Immediate has to be 21bit signed number and word aligned got value 0x%x&quot;, imm21);</span>
1040         int imm = (imm21 &amp; NumUtil.getNbitNumberInt(21)) &gt;&gt; 2;
1041         return imm &lt;&lt; ConditionalBranchImmOffset;
1042     }
1043 
1044     /* Unconditional Branch (immediate) (5.2.2) */
1045 
1046     /**
1047      * @param imm28 Signed 28-bit offset, has to be word aligned.
1048      */
1049     protected void b(int imm28) {
1050         unconditionalBranchImmInstruction(imm28, Instruction.B, -1);
1051     }
1052 
1053     /**
1054      *
1055      * @param imm28 Signed 28-bit offset, has to be word aligned.
1056      * @param pos Position where instruction is inserted into code buffer.
1057      */
1058     protected void b(int imm28, int pos) {
1059         unconditionalBranchImmInstruction(imm28, Instruction.B, pos);
1060     }
1061 
1062     /**
1063      * Branch and link return address to register X30.
1064      *
1065      * @param imm28 Signed 28-bit offset, has to be word aligned.
1066      */
1067     public void bl(int imm28) {
1068         unconditionalBranchImmInstruction(imm28, Instruction.BL, -1);
1069     }
1070 
1071     private void unconditionalBranchImmInstruction(int imm28, Instruction instr, int pos) {
1072         assert NumUtil.isSignedNbit(28, imm28) &amp;&amp; (imm28 &amp; 0x3) == 0 : &quot;Immediate has to be 28bit signed number and word aligned&quot;;
1073         int imm = (imm28 &amp; NumUtil.getNbitNumberInt(28)) &gt;&gt; 2;
1074         int instrEncoding = instr.encoding | UnconditionalBranchImmOp;
1075         if (pos == -1) {
<span class="line-added">1076             annotatePatchingImmediate(position(), instr, 26, 0, 2);</span>
1077             emitInt(instrEncoding | imm);
1078         } else {
<span class="line-added">1079             annotatePatchingImmediate(pos, instr, 26, 0, 2);</span>
1080             emitInt(instrEncoding | imm, pos);
1081         }
1082     }
1083 
1084     /* Unconditional Branch (register) (5.2.3) */
1085 
1086     /**
1087      * Branches to address in register and writes return address into register X30.
1088      *
1089      * @param reg general purpose register. May not be null, zero-register or stackpointer.
1090      */
1091     public void blr(Register reg) {
1092         unconditionalBranchRegInstruction(BLR, reg);
1093     }
1094 
1095     /**
1096      * Branches to address in register.
1097      *
1098      * @param reg general purpose register. May not be null, zero-register or stackpointer.
1099      */
1100     protected void br(Register reg) {
1101         unconditionalBranchRegInstruction(BR, reg);
1102     }
1103 
1104     /**
1105      * Return to address in register.
1106      *
1107      * @param reg general purpose register. May not be null, zero-register or stackpointer.
1108      */
1109     public void ret(Register reg) {
1110         unconditionalBranchRegInstruction(RET, reg);
1111     }
1112 
1113     private void unconditionalBranchRegInstruction(Instruction instr, Register reg) {
1114         assert reg.getRegisterCategory().equals(CPU);
1115         assert !reg.equals(zr);
1116         assert !reg.equals(sp);
1117         emitInt(instr.encoding | UnconditionalBranchRegOp | rs1(reg));
<span class="line-added">1118 </span>
1119     }
1120 
1121     /* Load-Store Single Register (5.3.1) */
1122 
1123     /**
1124      * Loads a srcSize value from address into rt zero-extending it.
1125      *
1126      * @param srcSize size of memory read in bits. Must be 8, 16, 32 or 64.
1127      * @param rt general purpose register. May not be null or stackpointer.
1128      * @param address all addressing modes allowed. May not be null.
1129      */
1130     public void ldr(int srcSize, Register rt, AArch64Address address) {
1131         assert rt.getRegisterCategory().equals(CPU);
1132         assert srcSize == 8 || srcSize == 16 || srcSize == 32 || srcSize == 64;
1133         int transferSize = NumUtil.log2Ceil(srcSize / 8);
1134         loadStoreInstruction(LDR, rt, address, General32, transferSize);
1135     }
1136 
1137     /**
1138      * Loads a srcSize value from address into rt sign-extending it.
</pre>
<hr />
<pre>
1235         final Register rt = mode.toRegister();
1236         // this looks weird but that&#39;s because loadStoreInstruction is weird
1237         // instruction select fields are size [31:30], v [26] and opc [25:24]
1238         // prfm requires size == 0b11, v == 0b0 and opc == 0b11
1239         // passing LDRS ensures opc[1] == 0b1
1240         // (n.b. passing LDR/STR makes no difference to opc[1:0]!!)
1241         // passing General64 ensures opc[0] == 0b1 and v = 0b0
1242         // (n.b. passing General32 ensures opc[0] == 0b0 and v = 0b0)
1243         // srcSize 64 ensures size == 0b11
1244         loadStoreInstruction(LDRS, rt, address, General64, transferSize);
1245     }
1246 
1247     /**
1248      * Stores register rt into memory pointed by address.
1249      *
1250      * @param destSize number of bits written to memory. Must be 8, 16, 32 or 64.
1251      * @param rt general purpose register. May not be null or stackpointer.
1252      * @param address all addressing modes allowed. May not be null.
1253      */
1254     public void str(int destSize, Register rt, AArch64Address address) {
<span class="line-modified">1255         assert rt.getRegisterCategory().equals(CPU) : rt;</span>
1256         assert destSize == 8 || destSize == 16 || destSize == 32 || destSize == 64;
1257         int transferSize = NumUtil.log2Ceil(destSize / 8);
1258         loadStoreInstruction(STR, rt, address, General64, transferSize);
1259     }
1260 
1261     private void loadStoreInstruction(Instruction instr, Register reg, AArch64Address address, InstructionType type, int log2TransferSize) {
1262         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1263         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1264         int is32Bit = type.width == 32 ? 1 &lt;&lt; ImmediateSizeOffset : 0;
1265         int isFloat = !type.isGeneral ? 1 &lt;&lt; LoadStoreFpFlagOffset : 0;
1266         int memop = instr.encoding | transferSizeEncoding | is32Bit | isFloat | rt(reg);
1267         switch (address.getAddressingMode()) {
1268             case IMMEDIATE_SCALED:
<span class="line-added">1269                 annotatePatchingImmediate(position(), instr, 12, LoadStoreScaledImmOffset, log2TransferSize);</span>
1270                 emitInt(memop | LoadStoreScaledOp | address.getImmediate() &lt;&lt; LoadStoreScaledImmOffset | rs1(address.getBase()));
1271                 break;
1272             case IMMEDIATE_UNSCALED:
<span class="line-added">1273                 annotatePatchingImmediate(position(), instr, 9, LoadStoreUnscaledImmOffset, 0);</span>
1274                 emitInt(memop | LoadStoreUnscaledOp | address.getImmediate() &lt;&lt; LoadStoreUnscaledImmOffset | rs1(address.getBase()));
1275                 break;
1276             case BASE_REGISTER_ONLY:
1277                 emitInt(memop | LoadStoreScaledOp | rs1(address.getBase()));
1278                 break;
1279             case EXTENDED_REGISTER_OFFSET:
1280             case REGISTER_OFFSET:
1281                 ExtendType extendType = address.getAddressingMode() == AddressingMode.EXTENDED_REGISTER_OFFSET ? address.getExtendType() : ExtendType.UXTX;
1282                 boolean shouldScale = address.isScaled() &amp;&amp; log2TransferSize != 0;
1283                 emitInt(memop | LoadStoreRegisterOp | rs2(address.getOffset()) | extendType.encoding &lt;&lt; ExtendTypeOffset | (shouldScale ? 1 : 0) &lt;&lt; LoadStoreScaledRegOffset | rs1(address.getBase()));
1284                 break;
1285             case PC_LITERAL:
1286                 assert log2TransferSize &gt;= 2 : &quot;PC literal loads only works for load/stores of 32-bit and larger&quot;;
1287                 transferSizeEncoding = (log2TransferSize - 2) &lt;&lt; LoadStoreTransferSizeOffset;
<span class="line-added">1288                 annotatePatchingImmediate(position(), instr, 21, LoadLiteralImmeOffset, 2);</span>
1289                 emitInt(transferSizeEncoding | isFloat | LoadLiteralOp | rd(reg) | address.getImmediate() &lt;&lt; LoadLiteralImmeOffset);
1290                 break;
1291             case IMMEDIATE_POST_INDEXED:
<span class="line-added">1292                 annotatePatchingImmediate(position(), instr, 9, LoadStoreIndexedImmOffset, 0);</span>
1293                 emitInt(memop | LoadStorePostIndexedOp | rs1(address.getBase()) | address.getImmediate() &lt;&lt; LoadStoreIndexedImmOffset);
1294                 break;
1295             case IMMEDIATE_PRE_INDEXED:
<span class="line-added">1296                 annotatePatchingImmediate(position(), instr, 9, LoadStoreIndexedImmOffset, 0);</span>
1297                 emitInt(memop | LoadStorePreIndexedOp | rs1(address.getBase()) | address.getImmediate() &lt;&lt; LoadStoreIndexedImmOffset);
1298                 break;
1299             default:
1300                 throw GraalError.shouldNotReachHere(&quot;Unhandled addressing mode: &quot; + address.getAddressingMode());
1301         }
1302     }
1303 
<span class="line-added">1304     /**</span>
<span class="line-added">1305      * Insert ldp/stp at the specified position.</span>
<span class="line-added">1306      */</span>
<span class="line-added">1307     protected void insertLdpStp(int size, Instruction instr, Register rt, Register rt2, Register base, int offset, int position) {</span>
<span class="line-added">1308         InstructionType type = generalFromSize(size);</span>
<span class="line-added">1309         int scaledOffset = maskField(7, offset);</span>
<span class="line-added">1310         int memop = type.encoding | instr.encoding | scaledOffset &lt;&lt; LoadStorePairImm7Offset | rt2(rt2) | rn(base) | rt(rt);</span>
<span class="line-added">1311         emitInt(memop | LoadStorePairOp | (0b010 &lt;&lt; 23), position);</span>
<span class="line-added">1312     }</span>
<span class="line-added">1313 </span>
1314     /**
1315      * Load Pair of Registers calculates an address from a base register value and an immediate
1316      * offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from
1317      * two registers.
1318      */
1319     public void ldp(int size, Register rt, Register rt2, AArch64Address address) {
1320         assert size == 32 || size == 64;
<span class="line-modified">1321         loadStorePairInstruction(size, LDP, rt, rt2, address);</span>
1322     }
1323 
1324     /**
1325      * Store Pair of Registers calculates an address from a base register value and an immediate
1326      * offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from
1327      * two registers.
1328      */
1329     public void stp(int size, Register rt, Register rt2, AArch64Address address) {
1330         assert size == 32 || size == 64;
<span class="line-modified">1331         loadStorePairInstruction(size, STP, rt, rt2, address);</span>
1332     }
1333 
<span class="line-modified">1334     private void loadStorePairInstruction(int size, Instruction instr, Register rt, Register rt2, AArch64Address address) {</span>
<span class="line-modified">1335         InstructionType type = generalFromSize(size);</span>
<span class="line-modified">1336         // LDP/STP uses a 7-bit scaled offset</span>
<span class="line-added">1337         int offset = address.getImmediateRaw();</span>
<span class="line-added">1338         if (address.getAddressingMode() == AddressingMode.IMMEDIATE_UNSCALED) {</span>
<span class="line-added">1339             int sizeInBytes = size / Byte.SIZE;</span>
<span class="line-added">1340             long mask = sizeInBytes - 1;</span>
<span class="line-added">1341             assert (offset &amp; mask) == 0 : &quot;LDP/STP only supports aligned offset.&quot;;</span>
<span class="line-added">1342             offset = offset / sizeInBytes;</span>
<span class="line-added">1343         }</span>
<span class="line-added">1344         int scaledOffset = maskField(7, offset);</span>
1345         int memop = type.encoding | instr.encoding | scaledOffset &lt;&lt; LoadStorePairImm7Offset | rt2(rt2) | rn(address.getBase()) | rt(rt);
1346         switch (address.getAddressingMode()) {
1347             case IMMEDIATE_SCALED:
<span class="line-added">1348             case IMMEDIATE_UNSCALED:</span>
1349                 emitInt(memop | LoadStorePairOp | (0b010 &lt;&lt; 23));
1350                 break;
1351             case IMMEDIATE_POST_INDEXED:
1352                 emitInt(memop | LoadStorePairOp | (0b001 &lt;&lt; 23));
1353                 break;
1354             case IMMEDIATE_PRE_INDEXED:
1355                 emitInt(memop | LoadStorePairOp | (0b011 &lt;&lt; 23));
1356                 break;
1357             default:
1358                 throw GraalError.shouldNotReachHere(&quot;Unhandled addressing mode: &quot; + address.getAddressingMode());
1359         }
1360     }
1361 
1362     /* Load-Store Exclusive (5.3.6) */
1363 
1364     /**
1365      * Load address exclusive. Natural alignment of address is required.
1366      *
1367      * @param size size of memory read in bits. Must be 8, 16, 32 or 64.
1368      * @param rt general purpose register. May not be null or stackpointer.
</pre>
<hr />
<pre>
1641 
1642     /**
1643      * dst = src - aimm and sets condition flags.
1644      *
1645      * @param size register size. Has to be 32 or 64.
1646      * @param dst general purpose register. May not be null or stackpointer.
1647      * @param src general purpose register. May not be null or zero-register.
1648      * @param aimm arithmetic immediate. Either unsigned 12-bit value or unsigned 24-bit value with
1649      *            the lower 12-bit cleared.
1650      */
1651     protected void subs(int size, Register dst, Register src, int aimm) {
1652         assert !dst.equals(sp);
1653         assert !src.equals(zr);
1654         addSubImmInstruction(SUBS, dst, src, aimm, generalFromSize(size));
1655     }
1656 
1657     private void addSubImmInstruction(Instruction instr, Register dst, Register src, int aimm, InstructionType type) {
1658         emitInt(type.encoding | instr.encoding | AddSubImmOp | encodeAimm(aimm) | rd(dst) | rs1(src));
1659     }
1660 
<span class="line-added">1661     public void ccmp(int size, Register x, Register y, int aimm, ConditionFlag condition) {</span>
<span class="line-added">1662         emitInt(generalFromSize(size).encoding | CCMP.encoding | rs1(x) | rs2(y) | encodeAimm(aimm) | condition.encoding &lt;&lt; ConditionalConditionOffset);</span>
<span class="line-added">1663     }</span>
<span class="line-added">1664 </span>
1665     /**
1666      * Encodes arithmetic immediate.
1667      *
1668      * @param imm Immediate has to be either an unsigned 12-bit value or an unsigned 24-bit value
1669      *            with the lower 12 bits zero.
1670      * @return Representation of immediate for use with arithmetic instructions.
1671      */
1672     private static int encodeAimm(int imm) {
1673         assert isAimm(imm) : &quot;Immediate has to be legal arithmetic immediate value &quot; + imm;
1674         if (NumUtil.isUnsignedNbit(12, imm)) {
1675             return imm &lt;&lt; ImmediateOffset;
1676         } else {
1677             // First 12-bit are zero, so shift immediate 12-bit and set flag to indicate
1678             // shifted immediate value.
1679             return (imm &gt;&gt;&gt; 12 &lt;&lt; ImmediateOffset) | AddSubShift12;
1680         }
1681     }
1682 
1683     /**
1684      * Checks whether immediate can be encoded as an arithmetic immediate.
</pre>
<hr />
<pre>
2316      */
2317     protected void msub(int size, Register dst, Register src1, Register src2, Register src3) {
2318         mulInstruction(MSUB, dst, src1, src2, src3, generalFromSize(size));
2319     }
2320 
2321     /**
2322      * Signed multiply high. dst = (src1 * src2)[127:64]
2323      *
2324      * @param dst general purpose register. May not be null or the stackpointer.
2325      * @param src1 general purpose register. May not be null or the stackpointer.
2326      * @param src2 general purpose register. May not be null or the stackpointer.
2327      */
2328     protected void smulh(Register dst, Register src1, Register src2) {
2329         assert !dst.equals(sp);
2330         assert !src1.equals(sp);
2331         assert !src2.equals(sp);
2332         emitInt(0b10011011010 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
2333     }
2334 
2335     /**
<span class="line-modified">2336      * Unsigned multiply high. dst = (src1 * src2)[127:64]</span>
2337      *
2338      * @param dst general purpose register. May not be null or the stackpointer.
2339      * @param src1 general purpose register. May not be null or the stackpointer.
2340      * @param src2 general purpose register. May not be null or the stackpointer.
2341      */
2342     protected void umulh(Register dst, Register src1, Register src2) {
2343         assert !dst.equals(sp);
2344         assert !src1.equals(sp);
2345         assert !src2.equals(sp);
2346         emitInt(0b10011011110 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
2347     }
2348 
2349     /**
<span class="line-modified">2350      * Unsigned multiply add-long. xDst = xSrc3 + (wSrc1 * wSrc2)</span>
2351      *
2352      * @param dst general purpose register. May not be null or the stackpointer.
2353      * @param src1 general purpose register. May not be null or the stackpointer.
2354      * @param src2 general purpose register. May not be null or the stackpointer.
2355      * @param src3 general purpose register. May not be null or the stackpointer.
2356      */
2357     protected void umaddl(Register dst, Register src1, Register src2, Register src3) {
2358         assert !dst.equals(sp);
2359         assert !src1.equals(sp);
2360         assert !src2.equals(sp);
2361         assert !src3.equals(sp);
2362         emitInt(0b10011011101 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
2363     }
2364 
2365     /**
<span class="line-modified">2366      * Signed multiply-add long. xDst = xSrc3 + (wSrc1 * wSrc2)</span>
2367      *
2368      * @param dst general purpose register. May not be null or the stackpointer.
2369      * @param src1 general purpose register. May not be null or the stackpointer.
2370      * @param src2 general purpose register. May not be null or the stackpointer.
2371      * @param src3 general purpose register. May not be null or the stackpointer.
2372      */
2373     public void smaddl(Register dst, Register src1, Register src2, Register src3) {
<span class="line-added">2374         smullInstruction(MADD, dst, src1, src2, src3);</span>
<span class="line-added">2375     }</span>
<span class="line-added">2376 </span>
<span class="line-added">2377     /**</span>
<span class="line-added">2378      * Signed multiply-sub long. xDst = xSrc3 - (wSrc1 * wSrc2)</span>
<span class="line-added">2379      *</span>
<span class="line-added">2380      * @param dst general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">2381      * @param src1 general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">2382      * @param src2 general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">2383      * @param src3 general purpose register. May not be null or the stackpointer.</span>
<span class="line-added">2384      */</span>
<span class="line-added">2385     public void smsubl(Register dst, Register src1, Register src2, Register src3) {</span>
<span class="line-added">2386         smullInstruction(MSUB, dst, src1, src2, src3);</span>
<span class="line-added">2387     }</span>
<span class="line-added">2388 </span>
<span class="line-added">2389     private void mulInstruction(Instruction instr, Register dst, Register src1, Register src2, Register src3, InstructionType type) {</span>
2390         assert !dst.equals(sp);
2391         assert !src1.equals(sp);
2392         assert !src2.equals(sp);
2393         assert !src3.equals(sp);
<span class="line-modified">2394         emitInt(type.encoding | instr.encoding | MulOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));</span>
2395     }
2396 
<span class="line-modified">2397     private void smullInstruction(Instruction instr, Register dst, Register src1, Register src2, Register src3) {</span>
2398         assert !dst.equals(sp);
2399         assert !src1.equals(sp);
2400         assert !src2.equals(sp);
2401         assert !src3.equals(sp);
<span class="line-modified">2402         emitInt(instr.encoding | SignedMulLongOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));</span>
2403     }
2404 
2405     /**
2406      * Signed divide. dst = src1 / src2.
2407      *
2408      * @param size register size. Has to be 32 or 64.
2409      * @param dst general purpose register. May not be null or the stackpointer.
2410      * @param src1 general purpose register. May not be null or the stackpointer.
2411      * @param src2 general purpose register. May not be null or the stackpointer.
2412      */
2413     public void sdiv(int size, Register dst, Register src1, Register src2) {
2414         dataProcessing2SourceOp(SDIV, dst, src1, src2, generalFromSize(size));
2415     }
2416 
2417     /**
2418      * Unsigned divide. dst = src1 / src2.
2419      *
2420      * @param size register size. Has to be 32 or 64.
2421      * @param dst general purpose register. May not be null or the stackpointer.
2422      * @param src1 general purpose register. May not be null or the stackpointer.
</pre>
<hr />
<pre>
2546         int b = (int) ((repr &gt;&gt;&gt; 61) &amp; 0x1) &lt;&lt; 6;
2547         int cToH = (int) (repr &gt;&gt;&gt; 48) &amp; 0x3f;
2548         return (a | b | cToH) &lt;&lt; FpImmOffset;
2549     }
2550 
2551     protected static boolean isDoubleImmediate(double imm) {
2552         // Valid values will have the form:
2553         // aBbb.bbbb.bbcd.efgh.0000.0000.0000.0000
2554         // 0000.0000.0000.0000.0000.0000.0000.0000
2555         long bits = Double.doubleToRawLongBits(imm);
2556         // lower 48 bits are cleared
2557         if ((bits &amp; NumUtil.getNbitNumberLong(48)) != 0) {
2558             return false;
2559         }
2560         // bits[61..54] are all set or all cleared.
2561         long pattern = (bits &gt;&gt; 54) &amp; NumUtil.getNbitNumberLong(7);
2562         if (pattern != 0 &amp;&amp; pattern != NumUtil.getNbitNumberLong(7)) {
2563             return false;
2564         }
2565         // bits[62] and bits[61] are opposites.
<span class="line-modified">2566         boolean result = ((bits ^ (bits &lt;&lt; 1)) &amp; (1L &lt;&lt; 62)) != 0;</span>
<span class="line-added">2567         return result;</span>
2568     }
2569 
2570     private static int getFloatImmediate(float imm) {
2571         assert isFloatImmediate(imm);
2572         // bits: aBbb.bbbc.defg.h000.0000.0000.0000.0000
2573         int repr = Float.floatToRawIntBits(imm);
2574         int a = (repr &gt;&gt;&gt; 31) &lt;&lt; 7;
2575         int b = ((repr &gt;&gt;&gt; 29) &amp; 0x1) &lt;&lt; 6;
2576         int cToH = (repr &gt;&gt;&gt; 19) &amp; NumUtil.getNbitNumberInt(6);
2577         return (a | b | cToH) &lt;&lt; FpImmOffset;
2578     }
2579 
2580     protected static boolean isFloatImmediate(float imm) {
2581         // Valid values will have the form:
2582         // aBbb.bbbc.defg.h000.0000.0000.0000.0000
2583         int bits = Float.floatToRawIntBits(imm);
2584         // lower 20 bits are cleared.
2585         if ((bits &amp; NumUtil.getNbitNumberInt(19)) != 0) {
2586             return false;
2587         }
</pre>
<hr />
<pre>
2826         assert src3.getRegisterCategory().equals(SIMD);
2827         emitInt(type.encoding | instr.encoding | Fp3SourceOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));
2828     }
2829 
2830     /* Floating-point Comparison (5.7.10) */
2831 
2832     /**
2833      * Compares src1 to src2.
2834      *
2835      * @param size register size.
2836      * @param src1 floating point register. May not be null.
2837      * @param src2 floating point register. May not be null.
2838      */
2839     public void fcmp(int size, Register src1, Register src2) {
2840         assert src1.getRegisterCategory().equals(SIMD);
2841         assert src2.getRegisterCategory().equals(SIMD);
2842         InstructionType type = floatFromSize(size);
2843         emitInt(type.encoding | FCMP.encoding | FpCmpOp | rs1(src1) | rs2(src2));
2844     }
2845 
<span class="line-added">2846     /**</span>
<span class="line-added">2847      * Signalling compares src1 to src2.</span>
<span class="line-added">2848      *</span>
<span class="line-added">2849      * @param size register size.</span>
<span class="line-added">2850      * @param src1 floating point register. May not be null.</span>
<span class="line-added">2851      * @param src2 floating point register. May not be null.</span>
<span class="line-added">2852      */</span>
<span class="line-added">2853     public void fcmpe(int size, Register src1, Register src2) {</span>
<span class="line-added">2854         assert src1.getRegisterCategory().equals(SIMD);</span>
<span class="line-added">2855         assert src2.getRegisterCategory().equals(SIMD);</span>
<span class="line-added">2856         InstructionType type = floatFromSize(size);</span>
<span class="line-added">2857         emitInt(type.encoding | FCMP.encoding | FpCmpeOp | rs1(src1) | rs2(src2));</span>
<span class="line-added">2858     }</span>
<span class="line-added">2859 </span>
2860     /**
2861      * Conditional compare. NZCV = fcmp(src1, src2) if condition else uimm4.
2862      *
2863      * @param size register size.
2864      * @param src1 floating point register. May not be null.
2865      * @param src2 floating point register. May not be null.
2866      * @param uimm4 condition flags that are used if condition is false.
2867      * @param condition every condition allowed. May not be null.
2868      */
2869     public void fccmp(int size, Register src1, Register src2, int uimm4, ConditionFlag condition) {
2870         assert NumUtil.isUnsignedNbit(4, uimm4);
2871         assert src1.getRegisterCategory().equals(SIMD);
2872         assert src2.getRegisterCategory().equals(SIMD);
2873         InstructionType type = floatFromSize(size);
2874         emitInt(type.encoding | FCCMP.encoding | uimm4 | condition.encoding &lt;&lt; ConditionalConditionOffset | rs1(src1) | rs2(src2));
2875     }
2876 
2877     /**
2878      * Compare register to 0.0 .
2879      *
2880      * @param size register size.
2881      * @param src floating point register. May not be null.
2882      */
2883     public void fcmpZero(int size, Register src) {
2884         assert src.getRegisterCategory().equals(SIMD);
2885         InstructionType type = floatFromSize(size);
2886         emitInt(type.encoding | FCMPZERO.encoding | FpCmpOp | rs1(src));
2887     }
2888 
<span class="line-added">2889     /**</span>
<span class="line-added">2890      * Signalling compare register to 0.0 .</span>
<span class="line-added">2891      *</span>
<span class="line-added">2892      * @param size register size.</span>
<span class="line-added">2893      * @param src floating point register. May not be null.</span>
<span class="line-added">2894      */</span>
<span class="line-added">2895     public void fcmpeZero(int size, Register src) {</span>
<span class="line-added">2896         assert src.getRegisterCategory().equals(SIMD);</span>
<span class="line-added">2897         InstructionType type = floatFromSize(size);</span>
<span class="line-added">2898         emitInt(type.encoding | FCMPZERO.encoding | FpCmpeOp | rs1(src));</span>
<span class="line-added">2899     }</span>
<span class="line-added">2900 </span>
2901     /* Floating-point Conditional Select (5.7.11) */
2902 
2903     /**
2904      * Conditional select. dst = src1 if condition else src2.
2905      *
2906      * @param size register size.
2907      * @param dst floating point register. May not be null.
2908      * @param src1 floating point register. May not be null.
2909      * @param src2 floating point register. May not be null.
2910      * @param condition every condition allowed. May not be null.
2911      */
2912     protected void fcsel(int size, Register dst, Register src1, Register src2, ConditionFlag condition) {
2913         assert dst.getRegisterCategory().equals(SIMD);
2914         assert src1.getRegisterCategory().equals(SIMD);
2915         assert src2.getRegisterCategory().equals(SIMD);
2916         InstructionType type = floatFromSize(size);
2917         emitInt(type.encoding | FCSEL.encoding | rd(dst) | rs1(src1) | rs2(src2) | condition.encoding &lt;&lt; ConditionalConditionOffset);
2918     }
2919 
2920     /* Debug exceptions (5.9.1.2) */
</pre>
<hr />
<pre>
2992         ANY_ANY(0xB, &quot;ISH&quot;);
2993 
2994         public final int encoding;
2995         public final String optionName;
2996 
2997         BarrierKind(int encoding, String optionName) {
2998             this.encoding = encoding;
2999             this.optionName = optionName;
3000         }
3001     }
3002 
3003     /**
3004      * Data Memory Barrier.
3005      *
3006      * @param barrierKind barrier that is issued. May not be null.
3007      */
3008     public void dmb(BarrierKind barrierKind) {
3009         emitInt(DMB.encoding | BarrierOp | barrierKind.encoding &lt;&lt; BarrierKindOffset);
3010     }
3011 
<span class="line-added">3012     public void mrs(Register dst, SystemRegister systemRegister) {</span>
<span class="line-added">3013         emitInt(MRS.encoding | systemRegister.encoding() | rt(dst));</span>
<span class="line-added">3014     }</span>
<span class="line-added">3015 </span>
<span class="line-added">3016     public void msr(SystemRegister systemRegister, Register src) {</span>
<span class="line-added">3017         emitInt(MRS.encoding | systemRegister.encoding() | rt(src));</span>
<span class="line-added">3018     }</span>
<span class="line-added">3019 </span>
<span class="line-added">3020     public void dc(DataCacheOperationType type, Register src) {</span>
<span class="line-added">3021         emitInt(DC.encoding | type.encoding() | rt(src));</span>
<span class="line-added">3022     }</span>
<span class="line-added">3023 </span>
<span class="line-added">3024     public void annotatePatchingImmediate(int pos, Instruction instruction, int operandSizeBits, int offsetBits, int shift) {</span>
<span class="line-added">3025         if (codePatchingAnnotationConsumer != null) {</span>
<span class="line-added">3026             codePatchingAnnotationConsumer.accept(new SingleInstructionAnnotation(pos, instruction, operandSizeBits, offsetBits, shift));</span>
<span class="line-added">3027         }</span>
<span class="line-added">3028     }</span>
<span class="line-added">3029 </span>
<span class="line-added">3030     void annotateImmediateMovSequence(int pos, int numInstrs) {</span>
<span class="line-added">3031         if (codePatchingAnnotationConsumer != null) {</span>
<span class="line-added">3032             codePatchingAnnotationConsumer.accept(new MovSequenceAnnotation(pos, numInstrs));</span>
<span class="line-added">3033         }</span>
<span class="line-added">3034     }</span>
<span class="line-added">3035 </span>
<span class="line-added">3036     public static class SingleInstructionAnnotation extends CodeAnnotation {</span>
<span class="line-added">3037 </span>
<span class="line-added">3038         /**</span>
<span class="line-added">3039          * The size of the operand, in bytes.</span>
<span class="line-added">3040          */</span>
<span class="line-added">3041         public final int operandSizeBits;</span>
<span class="line-added">3042         public final int offsetBits;</span>
<span class="line-added">3043         public final Instruction instruction;</span>
<span class="line-added">3044         public final int shift;</span>
<span class="line-added">3045 </span>
<span class="line-added">3046         SingleInstructionAnnotation(int instructionPosition, Instruction instruction, int operandSizeBits, int offsetBits, int shift) {</span>
<span class="line-added">3047             super(instructionPosition);</span>
<span class="line-added">3048             this.operandSizeBits = operandSizeBits;</span>
<span class="line-added">3049             this.offsetBits = offsetBits;</span>
<span class="line-added">3050             this.shift = shift;</span>
<span class="line-added">3051             this.instruction = instruction;</span>
<span class="line-added">3052         }</span>
<span class="line-added">3053     }</span>
<span class="line-added">3054 </span>
<span class="line-added">3055     public static class MovSequenceAnnotation extends CodeAnnotation {</span>
<span class="line-added">3056 </span>
<span class="line-added">3057         /**</span>
<span class="line-added">3058          * The size of the operand, in bytes.</span>
<span class="line-added">3059          */</span>
<span class="line-added">3060         public final int numInstrs;</span>
<span class="line-added">3061 </span>
<span class="line-added">3062         MovSequenceAnnotation(int instructionPosition, int numInstrs) {</span>
<span class="line-added">3063             super(instructionPosition);</span>
<span class="line-added">3064             this.numInstrs = numInstrs;</span>
<span class="line-added">3065         }</span>
<span class="line-added">3066     }</span>
<span class="line-added">3067 </span>
<span class="line-added">3068     /**</span>
<span class="line-added">3069      * dst[0...n] = countBitCountOfEachByte(src[0...n]), n = size/8.</span>
<span class="line-added">3070      *</span>
<span class="line-added">3071      * @param size register size. Has to be 64 or 128.</span>
<span class="line-added">3072      * @param dst SIMD register. Should not be null.</span>
<span class="line-added">3073      * @param src SIMD register. Should not be null.</span>
<span class="line-added">3074      */</span>
<span class="line-added">3075     public void cnt(int size, Register dst, Register src) {</span>
<span class="line-added">3076         assert 64 == size || 128 == size : &quot;Invalid size for cnt&quot;;</span>
<span class="line-added">3077         emitInt((size &gt;&gt; 7) &lt;&lt; SIMDQBitOffset | CNT.encoding | rd(dst) | rs1(src));</span>
<span class="line-added">3078     }</span>
<span class="line-added">3079 </span>
<span class="line-added">3080     /**</span>
<span class="line-added">3081      * dst = src[0] + ....+ src[n].</span>
<span class="line-added">3082      *</span>
<span class="line-added">3083      * @param size register size. Has to be 64 or 128.</span>
<span class="line-added">3084      * @param laneWidth the width that SIMD register is treated as different lanes with.</span>
<span class="line-added">3085      * @param dst SIMD register. Should not be null.</span>
<span class="line-added">3086      * @param src SIMD register. Should not be null.</span>
<span class="line-added">3087      */</span>
<span class="line-added">3088     public void addv(int size, SIMDElementSize laneWidth, Register dst, Register src) {</span>
<span class="line-added">3089         assert 64 == size || 128 == size : &quot;Invalid size for addv&quot;;</span>
<span class="line-added">3090         assert SIMDElementSize.DoubleWord != laneWidth : &quot;Invalid lane width for addv&quot;;</span>
<span class="line-added">3091         assert 64 != size || SIMDElementSize.Word != laneWidth : &quot;Invalid size and lane combination for addv&quot;;</span>
<span class="line-added">3092         emitInt((size &gt;&gt; 7) &lt;&lt; SIMDQBitOffset | laneWidth.encoding &lt;&lt; SIMDSizeOffset | ADDV.encoding | rd(dst) | rs1(src));</span>
<span class="line-added">3093     }</span>
<span class="line-added">3094 </span>
<span class="line-added">3095     /**</span>
<span class="line-added">3096      * dst = src[srcIdx].</span>
<span class="line-added">3097      *</span>
<span class="line-added">3098      * @param size register size. Can be 8, 16, 32 or 64.</span>
<span class="line-added">3099      * @param dst general purpose register. Should not be null or zero-register.</span>
<span class="line-added">3100      * @param srcIdx lane index of source register that dest data is from.</span>
<span class="line-added">3101      * @param src SIMD register. Should not be null.</span>
<span class="line-added">3102      */</span>
<span class="line-added">3103     public void umov(int size, Register dst, int srcIdx, Register src) {</span>
<span class="line-added">3104         assert (srcIdx + 1) * size &lt;= 128 : &quot;Invalid src vectRegister index&quot;;</span>
<span class="line-added">3105         InstructionType simdDataType = simdFromSize(size);</span>
<span class="line-added">3106         int imm5 = simdDataType.encoding | srcIdx &lt;&lt; Integer.numberOfTrailingZeros(simdDataType.encoding) + 1;</span>
<span class="line-added">3107         emitInt((size &gt;&gt; 6) &lt;&lt; SIMDQBitOffset | imm5 &lt;&lt; SIMDImm5Offset | UMOV.encoding | rd(dst) | rs1(src));</span>
<span class="line-added">3108     }</span>
3109 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../org.graalvm.compiler.asm.aarch64.test/src/org/graalvm/compiler/asm/aarch64/test/TestProtectedAssembler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64MacroAssembler.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
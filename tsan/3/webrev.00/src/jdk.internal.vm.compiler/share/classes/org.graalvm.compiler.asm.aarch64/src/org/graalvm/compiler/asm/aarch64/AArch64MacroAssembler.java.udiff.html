<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64Assembler.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64AsmOptions.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,42 +23,46 @@</span>
  
  
  
  package org.graalvm.compiler.asm.aarch64;
  
<span class="udiff-line-added">+ import static jdk.vm.ci.aarch64.AArch64.CPU;</span>
<span class="udiff-line-added">+ import static jdk.vm.ci.aarch64.AArch64.rscratch1;</span>
<span class="udiff-line-added">+ import static jdk.vm.ci.aarch64.AArch64.rscratch2;</span>
<span class="udiff-line-added">+ import static jdk.vm.ci.aarch64.AArch64.sp;</span>
<span class="udiff-line-added">+ import static jdk.vm.ci.aarch64.AArch64.zr;</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.BASE_REGISTER_ONLY;
  import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.EXTENDED_REGISTER_OFFSET;
  import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.IMMEDIATE_SCALED;
  import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.IMMEDIATE_UNSCALED;
  import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.REGISTER_OFFSET;
<span class="udiff-line-added">+ import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDP;</span>
<span class="udiff-line-added">+ import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STP;</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.ADD_TO_BASE;
  import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.ADD_TO_INDEX;
  import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.NO_WORK;
  
  import org.graalvm.compiler.asm.BranchTargetOutOfBoundsException;
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- import static jdk.vm.ci.aarch64.AArch64.CPU;</span>
<span class="udiff-line-removed">- import static jdk.vm.ci.aarch64.AArch64.r8;</span>
<span class="udiff-line-removed">- import static jdk.vm.ci.aarch64.AArch64.r9;</span>
<span class="udiff-line-removed">- import static jdk.vm.ci.aarch64.AArch64.sp;</span>
<span class="udiff-line-removed">- import static jdk.vm.ci.aarch64.AArch64.zr;</span>
<span class="udiff-line-removed">- </span>
  import org.graalvm.compiler.asm.Label;
  import org.graalvm.compiler.core.common.NumUtil;
  import org.graalvm.compiler.debug.GraalError;
  
  import jdk.vm.ci.aarch64.AArch64;
  import jdk.vm.ci.code.Register;
  import jdk.vm.ci.code.TargetDescription;
  
  public class AArch64MacroAssembler extends AArch64Assembler {
  
<span class="udiff-line-modified-removed">-     private final ScratchRegister[] scratchRegister = new ScratchRegister[]{new ScratchRegister(r8), new ScratchRegister(r9)};</span>
<span class="udiff-line-modified-added">+     private final ScratchRegister[] scratchRegister = new ScratchRegister[]{new ScratchRegister(rscratch1), new ScratchRegister(rscratch2)};</span>
  
      // Points to the next free scratch register
      private int nextFreeScratchRegister = 0;
  
<span class="udiff-line-added">+     // Last immediate ldr/str instruction, which is a candidate to be merged.</span>
<span class="udiff-line-added">+     private AArch64MemoryEncoding lastImmLoadStoreEncoding;</span>
<span class="udiff-line-added">+     private boolean isImmLoadStoreMerged = false;</span>
<span class="udiff-line-added">+ </span>
      public AArch64MacroAssembler(TargetDescription target) {
          super(target);
      }
  
      public class ScratchRegister implements AutoCloseable {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -81,10 +85,47 @@</span>
  
      public ScratchRegister getScratchRegister() {
          return scratchRegister[nextFreeScratchRegister++];
      }
  
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public void bind(Label l) {</span>
<span class="udiff-line-added">+         super.bind(l);</span>
<span class="udiff-line-added">+         // Clear last ldr/str instruction to prevent the labeled ldr/str being merged.</span>
<span class="udiff-line-added">+         lastImmLoadStoreEncoding = null;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static class AArch64MemoryEncoding {</span>
<span class="udiff-line-added">+         private AArch64Address address;</span>
<span class="udiff-line-added">+         private Register result;</span>
<span class="udiff-line-added">+         private int sizeInBytes;</span>
<span class="udiff-line-added">+         private int position;</span>
<span class="udiff-line-added">+         private boolean isStore;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         AArch64MemoryEncoding(int sizeInBytes, Register result, AArch64Address address, boolean isStore, int position) {</span>
<span class="udiff-line-added">+             this.sizeInBytes = sizeInBytes;</span>
<span class="udiff-line-added">+             this.result = result;</span>
<span class="udiff-line-added">+             this.address = address;</span>
<span class="udiff-line-added">+             this.isStore = isStore;</span>
<span class="udiff-line-added">+             this.position = position;</span>
<span class="udiff-line-added">+             AArch64Address.AddressingMode addressingMode = address.getAddressingMode();</span>
<span class="udiff-line-added">+             assert addressingMode == IMMEDIATE_SCALED || addressingMode == IMMEDIATE_UNSCALED : &quot;Invalid address mode&quot; +</span>
<span class="udiff-line-added">+                             &quot;to merge: &quot; + addressingMode;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Register getBase() {</span>
<span class="udiff-line-added">+             return address.getBase();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         int getOffset() {</span>
<span class="udiff-line-added">+             if (address.getAddressingMode() == IMMEDIATE_UNSCALED) {</span>
<span class="udiff-line-added">+                 return address.getImmediateRaw();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return address.getImmediate() * sizeInBytes;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Specifies what actions have to be taken to turn an arbitrary address of the form
       * {@code base + displacement [+ index [&lt;&lt; scale]]} into a valid AArch64Address.
       */
      public static class AddressGenerationPlan {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -264,11 +305,12 @@</span>
       * @param transferSize the memory transfer size in bytes. The log2 of this specifies how much
       *            the index register is scaled. If 0 no scaling is assumed. Can be 0, 1, 2, 4 or 8.
       * @return AArch64Address pointing to memory at {@code base + displacement}.
       */
      public AArch64Address makeAddress(Register base, long displacement, int transferSize) {
<span class="udiff-line-modified-removed">-         return makeAddress(base, displacement, zr, /* signExtend */false, transferSize, zr, /* allowOverwrite */false);</span>
<span class="udiff-line-modified-added">+         return makeAddress(base, displacement, zr, /* signExtend */false, //</span>
<span class="udiff-line-added">+                         transferSize, zr, /* allowOverwrite */false);</span>
      }
  
      /**
       * Loads memory address into register.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -320,10 +362,136 @@</span>
              default:
                  throw GraalError.shouldNotReachHere();
          }
      }
  
<span class="udiff-line-added">+     private boolean tryMerge(int sizeInBytes, Register rt, AArch64Address address, boolean isStore) {</span>
<span class="udiff-line-added">+         isImmLoadStoreMerged = false;</span>
<span class="udiff-line-added">+         if (lastImmLoadStoreEncoding == null) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Only immediate scaled/unscaled address can be merged.</span>
<span class="udiff-line-added">+         // Pre-index and post-index mode can&#39;t be merged.</span>
<span class="udiff-line-added">+         AArch64Address.AddressingMode addressMode = address.getAddressingMode();</span>
<span class="udiff-line-added">+         if (addressMode != IMMEDIATE_SCALED &amp;&amp; addressMode != IMMEDIATE_UNSCALED) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Only the two adjacent ldrs/strs can be merged.</span>
<span class="udiff-line-added">+         int lastPosition = position() - 4;</span>
<span class="udiff-line-added">+         if (lastPosition &lt; 0 || lastPosition != lastImmLoadStoreEncoding.position) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (isStore != lastImmLoadStoreEncoding.isStore) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Only merge ldr/str with the same size of 32bits or 64bits.</span>
<span class="udiff-line-added">+         if (sizeInBytes != lastImmLoadStoreEncoding.sizeInBytes || (sizeInBytes != 4 &amp;&amp; sizeInBytes != 8)) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Base register must be the same one.</span>
<span class="udiff-line-added">+         Register curBase = address.getBase();</span>
<span class="udiff-line-added">+         Register preBase = lastImmLoadStoreEncoding.getBase();</span>
<span class="udiff-line-added">+         if (!curBase.equals(preBase)) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // If the two ldrs have the same rt register, they can&#39;t be merged.</span>
<span class="udiff-line-added">+         // If the two ldrs have dependence, they can&#39;t be merged.</span>
<span class="udiff-line-added">+         Register curRt = rt;</span>
<span class="udiff-line-added">+         Register preRt = lastImmLoadStoreEncoding.result;</span>
<span class="udiff-line-added">+         if (!isStore &amp;&amp; (curRt.equals(preRt) || preRt.equals(curBase))) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Offset checking. Offsets of the two ldrs/strs must be continuous.</span>
<span class="udiff-line-added">+         int curOffset = address.getImmediateRaw();</span>
<span class="udiff-line-added">+         if (addressMode == IMMEDIATE_SCALED) {</span>
<span class="udiff-line-added">+             curOffset = curOffset * sizeInBytes;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         int preOffset = lastImmLoadStoreEncoding.getOffset();</span>
<span class="udiff-line-added">+         if (Math.abs(curOffset - preOffset) != sizeInBytes) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Offset must be in ldp/stp instruction&#39;s range.</span>
<span class="udiff-line-added">+         int offset = curOffset &gt; preOffset ? preOffset : curOffset;</span>
<span class="udiff-line-added">+         int minOffset = -64 * sizeInBytes;</span>
<span class="udiff-line-added">+         int maxOffset = 63 * sizeInBytes;</span>
<span class="udiff-line-added">+         if (offset &lt; minOffset || offset &gt; maxOffset) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Alignment checking.</span>
<span class="udiff-line-added">+         if (isFlagSet(AArch64.Flag.AvoidUnalignedAccesses)) {</span>
<span class="udiff-line-added">+             // AArch64 sp is 16-bytes aligned.</span>
<span class="udiff-line-added">+             if (curBase.equals(sp)) {</span>
<span class="udiff-line-added">+                 long pairMask = sizeInBytes * 2 - 1;</span>
<span class="udiff-line-added">+                 if ((offset &amp; pairMask) != 0) {</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 // If base is not sp, we can&#39;t guarantee the access is aligned.</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             // ldp/stp only supports sizeInBytes aligned offset.</span>
<span class="udiff-line-added">+             long mask = sizeInBytes - 1;</span>
<span class="udiff-line-added">+             if ((curOffset &amp; mask) != 0 || (preOffset &amp; mask) != 0) {</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Merge two ldrs/strs to ldp/stp.</span>
<span class="udiff-line-added">+         Register rt1 = preRt;</span>
<span class="udiff-line-added">+         Register rt2 = curRt;</span>
<span class="udiff-line-added">+         if (curOffset &lt; preOffset) {</span>
<span class="udiff-line-added">+             rt1 = curRt;</span>
<span class="udiff-line-added">+             rt2 = preRt;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         int immediate = offset / sizeInBytes;</span>
<span class="udiff-line-added">+         Instruction instruction = isStore ? STP : LDP;</span>
<span class="udiff-line-added">+         int size = sizeInBytes * Byte.SIZE;</span>
<span class="udiff-line-added">+         insertLdpStp(size, instruction, rt1, rt2, curBase, immediate, lastPosition);</span>
<span class="udiff-line-added">+         lastImmLoadStoreEncoding = null;</span>
<span class="udiff-line-added">+         isImmLoadStoreMerged = true;</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Try to merge two continuous ldr/str to one ldp/stp. If this current ldr/str is not merged,</span>
<span class="udiff-line-added">+      * save it as the last ldr/str.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private boolean tryMergeLoadStore(int srcSize, Register rt, AArch64Address address, boolean isStore) {</span>
<span class="udiff-line-added">+         int sizeInBytes = srcSize / Byte.SIZE;</span>
<span class="udiff-line-added">+         if (tryMerge(sizeInBytes, rt, address, isStore)) {</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Save last ldr/str if it is not merged.</span>
<span class="udiff-line-added">+         AArch64Address.AddressingMode addressMode = address.getAddressingMode();</span>
<span class="udiff-line-added">+         if (addressMode == IMMEDIATE_SCALED || addressMode == IMMEDIATE_UNSCALED) {</span>
<span class="udiff-line-added">+             if (addressMode == IMMEDIATE_UNSCALED) {</span>
<span class="udiff-line-added">+                 long mask = sizeInBytes - 1;</span>
<span class="udiff-line-added">+                 int offset = address.getImmediateRaw();</span>
<span class="udiff-line-added">+                 if ((offset &amp; mask) != 0) {</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             lastImmLoadStoreEncoding = new AArch64MemoryEncoding(sizeInBytes, rt, address, isStore, position());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public boolean isImmLoadStoreMerged() {</span>
<span class="udiff-line-added">+         return isImmLoadStoreMerged;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      public void movx(Register dst, Register src) {
          mov(64, dst, src);
      }
  
      public void mov(int size, Register dst, Register src) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -336,14 +504,17 @@</span>
  
      /**
       * Generates a 64-bit immediate move code sequence.
       *
       * @param dst general purpose register. May not be null, stackpointer or zero-register.
<span class="udiff-line-modified-removed">-      * @param imm</span>
<span class="udiff-line-modified-added">+      * @param imm the value to move into the register</span>
<span class="udiff-line-added">+      * @param annotateImm Flag denoting if annotation should be added.</span>
       */
<span class="udiff-line-modified-removed">-     private void mov64(Register dst, long imm) {</span>
<span class="udiff-line-modified-added">+     private void mov64(Register dst, long imm, boolean annotateImm) {</span>
          // We have to move all non zero parts of the immediate in 16-bit chunks
<span class="udiff-line-added">+         int numMovs = 0;</span>
<span class="udiff-line-added">+         int pos = position();</span>
          boolean firstMove = true;
          for (int offset = 0; offset &lt; 64; offset += 16) {
              int chunk = (int) (imm &gt;&gt; offset) &amp; NumUtil.getNbitNumberInt(16);
              if (chunk == 0) {
                  continue;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -352,21 +523,36 @@</span>
                  movz(64, dst, chunk, offset);
                  firstMove = false;
              } else {
                  movk(64, dst, chunk, offset);
              }
<span class="udiff-line-added">+             ++numMovs;</span>
          }
          assert !firstMove;
<span class="udiff-line-added">+         if (annotateImm) {</span>
<span class="udiff-line-added">+             annotateImmediateMovSequence(pos, numMovs);</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /**
       * Loads immediate into register.
       *
       * @param dst general purpose register. May not be null, zero-register or stackpointer.
       * @param imm immediate loaded into register.
       */
      public void mov(Register dst, long imm) {
<span class="udiff-line-added">+         mov(dst, imm, false);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Loads immediate into register.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param dst general purpose register. May not be null, zero-register or stackpointer.</span>
<span class="udiff-line-added">+      * @param imm immediate loaded into register.</span>
<span class="udiff-line-added">+      * @param annotateImm Flag to signal of the immediate value should be annotated.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void mov(Register dst, long imm, boolean annotateImm) {</span>
          assert dst.getRegisterCategory().equals(CPU);
          if (imm == 0L) {
              movx(dst, zr);
          } else if (LogicalImmediateTable.isRepresentable(true, imm) != LogicalImmediateTable.Representable.NO) {
              or(64, dst, zr, imm);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -376,11 +562,11 @@</span>
              // then sign extend
              // them. This allows us to cover immediates like ~1L with 2 instructions.
              mov(dst, (int) imm);
              sxt(64, 32, dst, dst);
          } else {
<span class="udiff-line-modified-removed">-             mov64(dst, imm);</span>
<span class="udiff-line-modified-added">+             mov64(dst, imm, annotateImm);</span>
          }
      }
  
      /**
       * Loads immediate into register.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -401,22 +587,41 @@</span>
       *
       * @param dst general purpose register. May not be null, stackpointer or zero-register.
       * @param imm
       */
      public void movNativeAddress(Register dst, long imm) {
<span class="udiff-line-added">+         movNativeAddress(dst, imm, false);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Generates a 48-bit immediate move code sequence. The immediate may later be updated by</span>
<span class="udiff-line-added">+      * HotSpot.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * In AArch64 mode the virtual address space is 48-bits in size, so we only need three</span>
<span class="udiff-line-added">+      * instructions to create a patchable instruction sequence that can reach anywhere.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param dst general purpose register. May not be null, stackpointer or zero-register.</span>
<span class="udiff-line-added">+      * @param imm The immediate address</span>
<span class="udiff-line-added">+      * @param annotateImm Flag to signal of the immediate value should be annotated.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void movNativeAddress(Register dst, long imm, boolean annotateImm) {</span>
          assert (imm &amp; 0xFFFF_0000_0000_0000L) == 0;
          // We have to move all non zero parts of the immediate in 16-bit chunks
          boolean firstMove = true;
<span class="udiff-line-added">+         int pos = position();</span>
          for (int offset = 0; offset &lt; 48; offset += 16) {
              int chunk = (int) (imm &gt;&gt; offset) &amp; NumUtil.getNbitNumberInt(16);
              if (firstMove) {
                  movz(64, dst, chunk, offset);
                  firstMove = false;
              } else {
                  movk(64, dst, chunk, offset);
              }
          }
<span class="udiff-line-added">+         if (annotateImm) {</span>
<span class="udiff-line-added">+             annotateImmediateMovSequence(pos, 3);</span>
<span class="udiff-line-added">+         }</span>
          assert !firstMove;
      }
  
      /**
       * Generates a 32-bit immediate move code sequence. The immediate may later be updated by
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -467,11 +672,11 @@</span>
      @Override
      public void ldrs(int targetSize, int srcSize, Register rt, AArch64Address address) {
          assert targetSize == 32 || targetSize == 64;
          assert srcSize &lt;= targetSize;
          if (targetSize == srcSize) {
<span class="udiff-line-modified-removed">-             super.ldr(srcSize, rt, address);</span>
<span class="udiff-line-modified-added">+             ldr(srcSize, rt, address);</span>
          } else {
              super.ldrs(targetSize, srcSize, rt, address);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -483,11 +688,29 @@</span>
       * @param rt general purpose register. May not be null or stackpointer.
       * @param address all addressing modes allowed. May not be null.
       */
      @Override
      public void ldr(int srcSize, Register rt, AArch64Address address) {
<span class="udiff-line-modified-removed">-         super.ldr(srcSize, rt, address);</span>
<span class="udiff-line-modified-added">+         // Try to merge two adjacent loads into one ldp.</span>
<span class="udiff-line-added">+         if (!tryMergeLoadStore(srcSize, rt, address, false)) {</span>
<span class="udiff-line-added">+             super.ldr(srcSize, rt, address);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Stores register rt into memory pointed by address.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param destSize number of bits written to memory. Must be 8, 16, 32 or 64.</span>
<span class="udiff-line-added">+      * @param rt general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      * @param address all addressing modes allowed. May not be null.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public void str(int destSize, Register rt, AArch64Address address) {</span>
<span class="udiff-line-added">+         // Try to merge two adjacent stores into one stp.</span>
<span class="udiff-line-added">+         if (!tryMergeLoadStore(destSize, rt, address, true)) {</span>
<span class="udiff-line-added">+             super.str(destSize, rt, address);</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /**
       * Conditional move. dst = src1 if condition else src2.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -779,11 +1002,11 @@</span>
      public void mneg(int size, Register dst, Register src1, Register src2) {
          super.msub(size, dst, src1, src2, zr);
      }
  
      /**
<span class="udiff-line-modified-removed">-      * unsigned multiply high. dst = (src1 * src2) &gt;&gt; size</span>
<span class="udiff-line-modified-added">+      * Unsigned multiply high. dst = (src1 * src2) &gt;&gt; size</span>
       *
       * @param size register size. Has to be 32 or 64.
       * @param dst general purpose register. May not be null or the stackpointer.
       * @param src1 general purpose register. May not be null or the stackpointer.
       * @param src2 general purpose register. May not be null or the stackpointer.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -800,11 +1023,11 @@</span>
              lshr(64, dst, dst, 32);
          }
      }
  
      /**
<span class="udiff-line-modified-removed">-      * signed multiply high. dst = (src1 * src2) &gt;&gt; size</span>
<span class="udiff-line-modified-added">+      * Signed multiply high. dst = (src1 * src2) &gt;&gt; size</span>
       *
       * @param size register size. Has to be 32 or 64.
       * @param dst general purpose register. May not be null or the stackpointer.
       * @param src1 general purpose register. May not be null or the stackpointer.
       * @param src2 general purpose register. May not be null or the stackpointer.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -820,10 +1043,64 @@</span>
              // xDst = xDst &gt;&gt; 32
              lshr(64, dst, dst, 32);
          }
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Signed multiply long. xDst = wSrc1 * wSrc2</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size destination register size. Has to be 64.</span>
<span class="udiff-line-added">+      * @param dst 64-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src1 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src2 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void smull(int size, Register dst, Register src1, Register src2) {</span>
<span class="udiff-line-added">+         this.smaddl(size, dst, src1, src2, zr);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Signed multiply-negate long. xDst = -(wSrc1 * wSrc2)</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size destination register size. Has to be 64.</span>
<span class="udiff-line-added">+      * @param dst 64-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src1 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src2 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void smnegl(int size, Register dst, Register src1, Register src2) {</span>
<span class="udiff-line-added">+         this.smsubl(size, dst, src1, src2, zr);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Signed multiply-add long. xDst = xSrc3 + (wSrc1 * wSrc2)</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size destination register size. Has to be 64.</span>
<span class="udiff-line-added">+      * @param dst 64-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src1 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src2 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src3 64-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void smaddl(int size, Register dst, Register src1, Register src2, Register src3) {</span>
<span class="udiff-line-added">+         assert (!dst.equals(sp) &amp;&amp; !src1.equals(sp) &amp;&amp; !src2.equals(sp) &amp;&amp; !src3.equals(sp));</span>
<span class="udiff-line-added">+         assert size == 64;</span>
<span class="udiff-line-added">+         super.smaddl(dst, src1, src2, src3);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Signed multiply-sub long. xDst = xSrc3 - (wSrc1 * wSrc2)</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size destination register size. Has to be 64.</span>
<span class="udiff-line-added">+      * @param dst 64-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src1 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src2 32-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src3 64-bit general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void smsubl(int size, Register dst, Register src1, Register src2, Register src3) {</span>
<span class="udiff-line-added">+         assert (!dst.equals(sp) &amp;&amp; !src1.equals(sp) &amp;&amp; !src2.equals(sp) &amp;&amp; !src3.equals(sp));</span>
<span class="udiff-line-added">+         assert size == 64;</span>
<span class="udiff-line-added">+         super.smsubl(dst, src1, src2, src3);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * dst = src1 % src2. Signed.
       *
       * @param size register size. Has to be 32 or 64.
       * @param dst general purpose register. May not be null or the stackpointer.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1270,10 +1547,24 @@</span>
          super.fdiv(size, dst, n, d);
          super.frintz(size, dst, dst);
          super.fmsub(size, dst, dst, d, n);
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * dst = src1 * src2 + src3.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size register size.</span>
<span class="udiff-line-added">+      * @param dst floating point register. May not be null.</span>
<span class="udiff-line-added">+      * @param src1 floating point register. May not be null.</span>
<span class="udiff-line-added">+      * @param src2 floating point register. May not be null.</span>
<span class="udiff-line-added">+      * @param src3 floating point register. May not be null.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public void fmadd(int size, Register dst, Register src1, Register src2, Register src3) {</span>
<span class="udiff-line-added">+         super.fmadd(size, dst, src1, src2, src3);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /* Branches */
  
      /**
       * Compares x and y and sets condition flags.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1327,36 +1618,36 @@</span>
                          ScratchRegister sc2 = getScratchRegister()) {
              switch (size) {
                  case 64: {
                      // Be careful with registers: it&#39;s possible that x, y, and dst are the same
                      // register.
<span class="udiff-line-modified-removed">-                     Register rscratch1 = sc1.getRegister();</span>
<span class="udiff-line-modified-removed">-                     Register rscratch2 = sc2.getRegister();</span>
<span class="udiff-line-modified-removed">-                     mul(64, rscratch1, x, y);     // Result bits 0..63</span>
<span class="udiff-line-modified-removed">-                     smulh(64, rscratch2, x, y);  // Result bits 64..127</span>
<span class="udiff-line-modified-added">+                     Register temp1 = sc1.getRegister();</span>
<span class="udiff-line-modified-added">+                     Register temp2 = sc2.getRegister();</span>
<span class="udiff-line-modified-added">+                     mul(64, temp1, x, y);     // Result bits 0..63</span>
<span class="udiff-line-modified-added">+                     smulh(64, temp2, x, y);  // Result bits 64..127</span>
                      // Top is pure sign ext
<span class="udiff-line-modified-removed">-                     subs(64, zr, rscratch2, rscratch1, ShiftType.ASR, 63);</span>
<span class="udiff-line-modified-added">+                     subs(64, zr, temp2, temp1, ShiftType.ASR, 63);</span>
                      // Copy all 64 bits of the result into dst
<span class="udiff-line-modified-removed">-                     mov(64, dst, rscratch1);</span>
<span class="udiff-line-modified-removed">-                     mov(rscratch1, 0x80000000);</span>
<span class="udiff-line-modified-added">+                     mov(64, dst, temp1);</span>
<span class="udiff-line-modified-added">+                     mov(temp1, 0x80000000);</span>
                      // Develop 0 (EQ), or 0x80000000 (NE)
<span class="udiff-line-modified-removed">-                     cmov(32, rscratch1, rscratch1, zr, ConditionFlag.NE);</span>
<span class="udiff-line-modified-removed">-                     cmp(32, rscratch1, 1);</span>
<span class="udiff-line-modified-added">+                     cmov(32, temp1, temp1, zr, ConditionFlag.NE);</span>
<span class="udiff-line-modified-added">+                     cmp(32, temp1, 1);</span>
                      // 0x80000000 - 1 =&gt; VS
                      break;
                  }
                  case 32: {
<span class="udiff-line-modified-removed">-                     Register rscratch1 = sc1.getRegister();</span>
<span class="udiff-line-modified-removed">-                     smaddl(rscratch1, x, y, zr);</span>
<span class="udiff-line-modified-added">+                     Register temp1 = sc1.getRegister();</span>
<span class="udiff-line-modified-added">+                     smaddl(temp1, x, y, zr);</span>
                      // Copy the low 32 bits of the result into dst
<span class="udiff-line-modified-removed">-                     mov(32, dst, rscratch1);</span>
<span class="udiff-line-modified-removed">-                     subs(64, zr, rscratch1, rscratch1, ExtendType.SXTW, 0);</span>
<span class="udiff-line-modified-added">+                     mov(32, dst, temp1);</span>
<span class="udiff-line-modified-added">+                     subs(64, zr, temp1, temp1, ExtendType.SXTW, 0);</span>
                      // NE =&gt; overflow
<span class="udiff-line-modified-removed">-                     mov(rscratch1, 0x80000000);</span>
<span class="udiff-line-modified-added">+                     mov(temp1, 0x80000000);</span>
                      // Develop 0 (EQ), or 0x80000000 (NE)
<span class="udiff-line-modified-removed">-                     cmov(32, rscratch1, rscratch1, zr, ConditionFlag.NE);</span>
<span class="udiff-line-modified-removed">-                     cmp(32, rscratch1, 1);</span>
<span class="udiff-line-modified-added">+                     cmov(32, temp1, temp1, zr, ConditionFlag.NE);</span>
<span class="udiff-line-modified-added">+                     cmp(32, temp1, 1);</span>
                      // 0x80000000 - 1 =&gt; VS
                      break;
                  }
              }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1400,11 +1691,11 @@</span>
          // TODO Handle case where offset is too large for a single jump instruction
          if (label.isBound()) {
              int offset = label.position() - position();
              super.adr(dst, offset);
          } else {
<span class="udiff-line-modified-removed">-             label.addPatchAt(position());</span>
<span class="udiff-line-modified-added">+             label.addPatchAt(position(), this);</span>
              // Encode condition flag so that we know how to patch the instruction later
              emitInt(PatchLabelKind.ADR.encoding | dst.encoding &lt;&lt; PatchLabelKind.INFORMATION_OFFSET);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1419,11 +1710,11 @@</span>
          // TODO Handle case where offset is too large for a single jump instruction
          if (label.isBound()) {
              int offset = label.position() - position();
              super.cbnz(size, cmp, offset);
          } else {
<span class="udiff-line-modified-removed">-             label.addPatchAt(position());</span>
<span class="udiff-line-modified-added">+             label.addPatchAt(position(), this);</span>
              int regEncoding = cmp.encoding &lt;&lt; (PatchLabelKind.INFORMATION_OFFSET + 1);
              int sizeEncoding = (size == 64 ? 1 : 0) &lt;&lt; PatchLabelKind.INFORMATION_OFFSET;
              // Encode condition flag so that we know how to patch the instruction later
              emitInt(PatchLabelKind.BRANCH_NONZERO.encoding | regEncoding | sizeEncoding);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1440,11 +1731,11 @@</span>
          // TODO Handle case where offset is too large for a single jump instruction
          if (label.isBound()) {
              int offset = label.position() - position();
              super.cbz(size, cmp, offset);
          } else {
<span class="udiff-line-modified-removed">-             label.addPatchAt(position());</span>
<span class="udiff-line-modified-added">+             label.addPatchAt(position(), this);</span>
              int regEncoding = cmp.encoding &lt;&lt; (PatchLabelKind.INFORMATION_OFFSET + 1);
              int sizeEncoding = (size == 64 ? 1 : 0) &lt;&lt; PatchLabelKind.INFORMATION_OFFSET;
              // Encode condition flag so that we know how to patch the instruction later
              emitInt(PatchLabelKind.BRANCH_ZERO.encoding | regEncoding | sizeEncoding);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1461,11 +1752,11 @@</span>
          assert NumUtil.isUnsignedNbit(6, uimm6);
          if (label.isBound()) {
              int offset = label.position() - position();
              super.tbnz(cmp, uimm6, offset);
          } else {
<span class="udiff-line-modified-removed">-             label.addPatchAt(position());</span>
<span class="udiff-line-modified-added">+             label.addPatchAt(position(), this);</span>
              int indexEncoding = uimm6 &lt;&lt; PatchLabelKind.INFORMATION_OFFSET;
              int regEncoding = cmp.encoding &lt;&lt; (PatchLabelKind.INFORMATION_OFFSET + 6);
              emitInt(PatchLabelKind.BRANCH_BIT_NONZERO.encoding | indexEncoding | regEncoding);
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1481,11 +1772,11 @@</span>
          assert NumUtil.isUnsignedNbit(6, uimm6);
          if (label.isBound()) {
              int offset = label.position() - position();
              super.tbz(cmp, uimm6, offset);
          } else {
<span class="udiff-line-modified-removed">-             label.addPatchAt(position());</span>
<span class="udiff-line-modified-added">+             label.addPatchAt(position(), this);</span>
              int indexEncoding = uimm6 &lt;&lt; PatchLabelKind.INFORMATION_OFFSET;
              int regEncoding = cmp.encoding &lt;&lt; (PatchLabelKind.INFORMATION_OFFSET + 6);
              emitInt(PatchLabelKind.BRANCH_BIT_ZERO.encoding | indexEncoding | regEncoding);
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1500,11 +1791,11 @@</span>
          // TODO Handle case where offset is too large for a single jump instruction
          if (label.isBound()) {
              int offset = label.position() - position();
              super.b(condition, offset);
          } else {
<span class="udiff-line-modified-removed">-             label.addPatchAt(position());</span>
<span class="udiff-line-modified-added">+             label.addPatchAt(position(), this);</span>
              // Encode condition flag so that we know how to patch the instruction later
              emitInt(PatchLabelKind.BRANCH_CONDITIONALLY.encoding | condition.encoding &lt;&lt; PatchLabelKind.INFORMATION_OFFSET);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1528,11 +1819,11 @@</span>
          // TODO Handle case where offset is too large for a single jump instruction
          if (label.isBound()) {
              int offset = label.position() - position();
              super.b(offset);
          } else {
<span class="udiff-line-modified-removed">-             label.addPatchAt(position());</span>
<span class="udiff-line-modified-added">+             label.addPatchAt(position(), this);</span>
              emitInt(PatchLabelKind.BRANCH_UNCONDITIONALLY.encoding);
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1595,11 +1886,11 @@</span>
      public void brk(AArch64ExceptionCode exceptionCode) {
          super.brk(exceptionCode.encoding);
      }
  
      public void pause() {
<span class="udiff-line-modified-removed">-         throw GraalError.unimplemented();</span>
<span class="udiff-line-modified-added">+         super.hint(SystemHint.YIELD);</span>
      }
  
      /**
       * Executes no-op instruction. No registers or flags are updated, except for PC.
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1666,10 +1957,13 @@</span>
                  int sizeEncoding = information &amp; 1;
                  int regEncoding = information &gt;&gt;&gt; 1;
                  Register reg = AArch64.cpuRegisters.get(regEncoding);
                  // 1 =&gt; 64; 0 =&gt; 32
                  int size = sizeEncoding * 32 + 32;
<span class="udiff-line-added">+                 if (!NumUtil.isSignedNbit(21, branchOffset)) {</span>
<span class="udiff-line-added">+                     throw new BranchTargetOutOfBoundsException(true, &quot;Branch target %d out of bounds&quot;, branchOffset);</span>
<span class="udiff-line-added">+                 }</span>
                  switch (type) {
                      case BRANCH_NONZERO:
                          super.cbnz(size, reg, branchOffset, branch);
                          break;
                      case BRANCH_ZERO:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1719,20 +2013,23 @@</span>
       * @param displacement arbitrary displacement added to base.
       * @return AArch64Address referencing memory at {@code base + displacement}.
       */
      @Override
      public AArch64Address makeAddress(Register base, int displacement) {
<span class="udiff-line-modified-removed">-         return makeAddress(base, displacement, zr, /* signExtend */false, /* transferSize */0, zr, /* allowOverwrite */false);</span>
<span class="udiff-line-modified-added">+         return makeAddress(base, displacement, zr, /* signExtend */false, /* transferSize */0, //</span>
<span class="udiff-line-added">+                         zr, /* allowOverwrite */false);</span>
      }
  
      @Override
      public AArch64Address getPlaceholder(int instructionStartPosition) {
          return AArch64Address.PLACEHOLDER;
      }
  
      public void addressOf(Register dst) {
<span class="udiff-line-modified-removed">-         // This will be fixed up later.</span>
<span class="udiff-line-modified-added">+         if (codePatchingAnnotationConsumer != null) {</span>
<span class="udiff-line-added">+             codePatchingAnnotationConsumer.accept(new AdrpAddMacroInstruction(position()));</span>
<span class="udiff-line-added">+         }</span>
          super.adrp(dst);
          super.add(64, dst, dst, 0);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1742,6 +2039,70 @@</span>
       * @param a AArch64Address the address of an operand.
       */
      public void lea(Register d, AArch64Address a) {
          a.lea(this, d);
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Count the set bits of src register.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size src register size. Has to be 32 or 64.</span>
<span class="udiff-line-added">+      * @param dst general purpose register. Should not be null or zero-register.</span>
<span class="udiff-line-added">+      * @param src general purpose register. Should not be null.</span>
<span class="udiff-line-added">+      * @param vreg SIMD register. Should not be null.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void popcnt(int size, Register dst, Register src, Register vreg) {</span>
<span class="udiff-line-added">+         assert 32 == size || 64 == size : &quot;Invalid data size&quot;;</span>
<span class="udiff-line-added">+         fmov(size, vreg, src);</span>
<span class="udiff-line-added">+         final int fixedSize = 64;</span>
<span class="udiff-line-added">+         cnt(fixedSize, vreg, vreg);</span>
<span class="udiff-line-added">+         addv(fixedSize, SIMDElementSize.Byte, vreg, vreg);</span>
<span class="udiff-line-added">+         umov(fixedSize, dst, 0, vreg);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public interface MacroInstruction {</span>
<span class="udiff-line-added">+         void patch(int codePos, int relative, byte[] code);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Emits elf patchable adrp ldr sequence.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void adrpLdr(int srcSize, Register result, AArch64Address a) {</span>
<span class="udiff-line-added">+         if (codePatchingAnnotationConsumer != null) {</span>
<span class="udiff-line-added">+             codePatchingAnnotationConsumer.accept(new AdrpLdrMacroInstruction(position()));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         super.adrp(a.getBase());</span>
<span class="udiff-line-added">+         this.ldr(srcSize, result, a);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static class AdrpLdrMacroInstruction extends CodeAnnotation implements MacroInstruction {</span>
<span class="udiff-line-added">+         public AdrpLdrMacroInstruction(int position) {</span>
<span class="udiff-line-added">+             super(position);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public String toString() {</span>
<span class="udiff-line-added">+             return &quot;ADRP_LDR&quot;;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public void patch(int codePos, int relative, byte[] code) {</span>
<span class="udiff-line-added">+             throw GraalError.unimplemented();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static class AdrpAddMacroInstruction extends CodeAnnotation implements MacroInstruction {</span>
<span class="udiff-line-added">+         public AdrpAddMacroInstruction(int position) {</span>
<span class="udiff-line-added">+             super(position);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public String toString() {</span>
<span class="udiff-line-added">+             return &quot;ADRP_ADD&quot;;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public void patch(int codePos, int relative, byte[] code) {</span>
<span class="udiff-line-added">+             throw GraalError.unimplemented();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="AArch64Assembler.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64AsmOptions.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
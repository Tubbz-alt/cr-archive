<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64Assembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.asm.aarch64.test/src/org/graalvm/compiler/asm/aarch64/test/TestProtectedAssembler.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64MacroAssembler.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64Assembler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2018, Red Hat Inc. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,13 +23,19 @@</span>
   */
  
  
  package org.graalvm.compiler.asm.aarch64;
  
<span class="udiff-line-added">+ import static jdk.vm.ci.aarch64.AArch64.CPU;</span>
<span class="udiff-line-added">+ import static jdk.vm.ci.aarch64.AArch64.SIMD;</span>
  import static jdk.vm.ci.aarch64.AArch64.cpuRegisters;
<span class="udiff-line-added">+ import static jdk.vm.ci.aarch64.AArch64.r0;</span>
<span class="udiff-line-added">+ import static jdk.vm.ci.aarch64.AArch64.sp;</span>
<span class="udiff-line-added">+ import static jdk.vm.ci.aarch64.AArch64.zr;</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADD;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADDS;
<span class="udiff-line-added">+ import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADDV;</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADR;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADRP;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.AND;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ANDS;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ASRV;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -38,16 +44,19 @@</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BICS;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BLR;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BR;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BRK;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CAS;
<span class="udiff-line-added">+ import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CCMP;</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLREX;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLS;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLZ;
<span class="udiff-line-added">+ import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CNT;</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSEL;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSINC;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSNEG;
<span class="udiff-line-added">+ import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.DC;</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.DMB;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EON;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EOR;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EXTR;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FABS;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -84,10 +93,11 @@</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LSRV;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MADD;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVK;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVN;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVZ;
<span class="udiff-line-added">+ import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MRS;</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MSUB;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ORN;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ORR;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RBIT;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RET;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103,31 +113,28 @@</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STR;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STXR;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SUB;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SUBS;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SWP;
<span class="udiff-line-removed">- import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.TBZ;</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.TBNZ;
<span class="udiff-line-added">+ import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.TBZ;</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UBFM;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UDIV;
<span class="udiff-line-added">+ import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UMOV;</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.FP32;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.FP64;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.General32;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.General64;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.floatFromSize;
  import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.generalFromSize;
<span class="udiff-line-modified-removed">- import static jdk.vm.ci.aarch64.AArch64.CPU;</span>
<span class="udiff-line-removed">- import static jdk.vm.ci.aarch64.AArch64.SIMD;</span>
<span class="udiff-line-removed">- import static jdk.vm.ci.aarch64.AArch64.r0;</span>
<span class="udiff-line-removed">- import static jdk.vm.ci.aarch64.AArch64.sp;</span>
<span class="udiff-line-removed">- import static jdk.vm.ci.aarch64.AArch64.zr;</span>
<span class="udiff-line-modified-added">+ import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.simdFromSize;</span>
  
  import java.util.Arrays;
  
  import org.graalvm.compiler.asm.Assembler;
<span class="udiff-line-removed">- import org.graalvm.compiler.core.common.NumUtil;</span>
  import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;
<span class="udiff-line-added">+ import org.graalvm.compiler.core.common.NumUtil;</span>
  import org.graalvm.compiler.debug.GraalError;
  
  import jdk.vm.ci.aarch64.AArch64;
  import jdk.vm.ci.aarch64.AArch64.CPUFeature;
  import jdk.vm.ci.aarch64.AArch64.Flag;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -366,20 +373,46 @@</span>
      private static int maskField(int sizeInBits, int n) {
          assert NumUtil.isSignedNbit(sizeInBits, n);
          return n &amp; NumUtil.getNbitNumberInt(sizeInBits);
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Enumeration of all different lane types of SIMD register.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Byte(B):8b/lane; HalfWord(H):16b/lane; Word(S):32b/lane; DoubleWord(D):64b/lane.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public enum SIMDElementSize {</span>
<span class="udiff-line-added">+         Byte(0, 8),</span>
<span class="udiff-line-added">+         HalfWord(1, 16),</span>
<span class="udiff-line-added">+         Word(2, 32),</span>
<span class="udiff-line-added">+         DoubleWord(3, 64);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public final int encoding;</span>
<span class="udiff-line-added">+         public final int nbits;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         SIMDElementSize(int encoding, int nbits) {</span>
<span class="udiff-line-added">+             this.encoding = encoding;</span>
<span class="udiff-line-added">+             this.nbits = nbits;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Enumeration of all different instruction kinds: General32/64 are the general instructions
       * (integer, branch, etc.), for 32-, respectively 64-bit operands. FP32/64 is the encoding for
<span class="udiff-line-modified-removed">-      * the 32/64bit float operations</span>
<span class="udiff-line-modified-added">+      * the 32/64bit float operations. SIMDByte/HalfWord/Word/DoubleWord is the encoding for SIMD</span>
<span class="udiff-line-added">+      * instructions</span>
       */
      protected enum InstructionType {
          General32(0b00 &lt;&lt; 30, 32, true),
          General64(0b10 &lt;&lt; 30, 64, true),
          FP32(0x00000000, 32, false),
<span class="udiff-line-modified-removed">-         FP64(0x00400000, 64, false);</span>
<span class="udiff-line-modified-added">+         FP64(0x00400000, 64, false),</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         SIMDByte(0x01, 8, false),</span>
<span class="udiff-line-added">+         SIMDHalfWord(0x02, 16, false),</span>
<span class="udiff-line-added">+         SIMDWord(0x04, 32, false),</span>
<span class="udiff-line-added">+         SIMDDoubleWord(0x08, 64, false);</span>
  
          public final int encoding;
          public final int width;
          public final boolean isGeneral;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -397,10 +430,24 @@</span>
          public static InstructionType floatFromSize(int size) {
              assert size == 32 || size == 64;
              return size == 32 ? FP32 : FP64;
          }
  
<span class="udiff-line-added">+         public static InstructionType simdFromSize(int size) {</span>
<span class="udiff-line-added">+             switch (size) {</span>
<span class="udiff-line-added">+                 case 8:</span>
<span class="udiff-line-added">+                     return SIMDByte;</span>
<span class="udiff-line-added">+                 case 16:</span>
<span class="udiff-line-added">+                     return SIMDHalfWord;</span>
<span class="udiff-line-added">+                 case 32:</span>
<span class="udiff-line-added">+                     return SIMDWord;</span>
<span class="udiff-line-added">+                 case 64:</span>
<span class="udiff-line-added">+                     return SIMDDoubleWord;</span>
<span class="udiff-line-added">+                 default:</span>
<span class="udiff-line-added">+                     throw GraalError.shouldNotReachHere();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
      }
  
      private static final int ImmediateOffset = 10;
      private static final int ImmediateRotateOffset = 16;
      private static final int ImmediateSizeOffset = 22;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -422,10 +469,11 @@</span>
      private static final int ShiftTypeOffset = 22;
  
      private static final int AddSubExtendedOp = 0x0B200000;
  
      private static final int MulOp = 0x1B000000;
<span class="udiff-line-added">+     private static final int SignedMulLongOp = 0x9B200000;</span>
      private static final int DataProcessing1SourceOp = 0x5AC00000;
      private static final int DataProcessing2SourceOp = 0x1AC00000;
  
      private static final int Fp1SourceOp = 0x1E204000;
      private static final int Fp2SourceOp = 0x1E200800;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -434,10 +482,11 @@</span>
      private static final int FpConvertOp = 0x1E200000;
      private static final int FpImmOp = 0x1E201000;
      private static final int FpImmOffset = 13;
  
      private static final int FpCmpOp = 0x1E202000;
<span class="udiff-line-added">+     private static final int FpCmpeOp = 0x1E202010;</span>
  
      private static final int PcRelImmHiOffset = 5;
      private static final int PcRelImmLoOffset = 29;
  
      private static final int PcRelImmOp = 0x10000000;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -488,10 +537,14 @@</span>
      private static final int CASReleaseOffset = 15;
  
      private static final int LDADDAcquireOffset = 23;
      private static final int LDADDReleaseOffset = 22;
  
<span class="udiff-line-added">+     private static final int SIMDImm5Offset = 16;</span>
<span class="udiff-line-added">+     private static final int SIMDQBitOffset = 30;</span>
<span class="udiff-line-added">+     private static final int SIMDSizeOffset = 22;</span>
<span class="udiff-line-added">+ </span>
      /**
       * Encoding for all instructions.
       */
      public enum Instruction {
          BCOND(0x54000000),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -530,10 +583,12 @@</span>
          ADD(0x00000000),
          ADDS(ADD.encoding | AddSubSetFlag),
          SUB(0x40000000),
          SUBS(SUB.encoding | AddSubSetFlag),
  
<span class="udiff-line-added">+         CCMP(0x7A400000),</span>
<span class="udiff-line-added">+ </span>
          NOT(0x00200000),
          AND(0x00000000),
          BIC(AND.encoding | NOT.encoding),
          ORR(0x20000000),
          ORN(ORR.encoding | NOT.encoding),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -604,11 +659,11 @@</span>
          FCMPZERO(0x00000008),
          FCCMP(0x1E200400),
          FCSEL(0x1E200C00),
  
          INS(0x4e081c00),
<span class="udiff-line-modified-removed">-         UMOV(0x4e083c00),</span>
<span class="udiff-line-modified-added">+         UMOV(0x0e003c00),</span>
  
          CNT(0xe205800),
          USRA(0x6f001400),
  
          HLT(0x00400000),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -616,20 +671,67 @@</span>
  
          CLREX(0xd5033f5f),
          HINT(0xD503201F),
          DMB(0x000000A0),
  
<span class="udiff-line-modified-removed">-         BLR_NATIVE(0xc0000000);</span>
<span class="udiff-line-modified-added">+         MRS(0xD5300000),</span>
<span class="udiff-line-added">+         MSR(0xD5100000),</span>
<span class="udiff-line-added">+         DC(0xD5087000),</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         BLR_NATIVE(0xc0000000),</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ADDV(0x0e31b800);</span>
  
          public final int encoding;
  
          Instruction(int encoding) {
              this.encoding = encoding;
          }
  
      }
  
<span class="udiff-line-added">+     public enum SystemRegister {</span>
<span class="udiff-line-added">+         FPCR(0b11, 0b011, 0b0100, 0b0100, 0b000),</span>
<span class="udiff-line-added">+         FPSR(0b11, 0b011, 0b0100, 0b0100, 0b001);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         SystemRegister(int op0, int op1, int crn, int crm, int op2) {</span>
<span class="udiff-line-added">+             this.op0 = op0;</span>
<span class="udiff-line-added">+             this.op1 = op1;</span>
<span class="udiff-line-added">+             this.crn = crn;</span>
<span class="udiff-line-added">+             this.crm = crm;</span>
<span class="udiff-line-added">+             this.op2 = op2;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public int encoding() {</span>
<span class="udiff-line-added">+             return op0 &lt;&lt; 19 | op1 &lt;&lt; 16 | crn &lt;&lt; 12 | crm &lt;&lt; 8 | op2 &lt;&lt; 5;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private final int op0;</span>
<span class="udiff-line-added">+         private final int op1;</span>
<span class="udiff-line-added">+         private final int crn;</span>
<span class="udiff-line-added">+         private final int crm;</span>
<span class="udiff-line-added">+         private final int op2;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public enum DataCacheOperationType {</span>
<span class="udiff-line-added">+         ZVA(0b011, 0b0100, 0b001);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         DataCacheOperationType(int op1, int crm, int op2) {</span>
<span class="udiff-line-added">+             this.op1 = op1;</span>
<span class="udiff-line-added">+             this.crm = crm;</span>
<span class="udiff-line-added">+             this.op2 = op2;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public int encoding() {</span>
<span class="udiff-line-added">+             return op1 &lt;&lt; 16 | crm &lt;&lt; 8 | op2 &lt;&lt; 5;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private final int op1;</span>
<span class="udiff-line-added">+         private final int crm;</span>
<span class="udiff-line-added">+         private final int op2;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      public enum ShiftType {
          LSL(0),
          LSR(1),
          ASR(2),
          ROR(3);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -932,11 +1034,11 @@</span>
              emitInt(type.encoding | instrEncoding | getConditionalBranchImm(imm21) | rd(reg), pos);
          }
      }
  
      private static int getConditionalBranchImm(int imm21) {
<span class="udiff-line-modified-removed">-         assert NumUtil.isSignedNbit(21, imm21) &amp;&amp; (imm21 &amp; 0x3) == 0 : &quot;Immediate has to be 21bit signed number and word aligned&quot;;</span>
<span class="udiff-line-modified-added">+         assert NumUtil.isSignedNbit(21, imm21) &amp;&amp; (imm21 &amp; 0x3) == 0 : String.format(&quot;Immediate has to be 21bit signed number and word aligned got value 0x%x&quot;, imm21);</span>
          int imm = (imm21 &amp; NumUtil.getNbitNumberInt(21)) &gt;&gt; 2;
          return imm &lt;&lt; ConditionalBranchImmOffset;
      }
  
      /* Unconditional Branch (immediate) (5.2.2) */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -969,12 +1071,14 @@</span>
      private void unconditionalBranchImmInstruction(int imm28, Instruction instr, int pos) {
          assert NumUtil.isSignedNbit(28, imm28) &amp;&amp; (imm28 &amp; 0x3) == 0 : &quot;Immediate has to be 28bit signed number and word aligned&quot;;
          int imm = (imm28 &amp; NumUtil.getNbitNumberInt(28)) &gt;&gt; 2;
          int instrEncoding = instr.encoding | UnconditionalBranchImmOp;
          if (pos == -1) {
<span class="udiff-line-added">+             annotatePatchingImmediate(position(), instr, 26, 0, 2);</span>
              emitInt(instrEncoding | imm);
          } else {
<span class="udiff-line-added">+             annotatePatchingImmediate(pos, instr, 26, 0, 2);</span>
              emitInt(instrEncoding | imm, pos);
          }
      }
  
      /* Unconditional Branch (register) (5.2.3) */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1009,10 +1113,11 @@</span>
      private void unconditionalBranchRegInstruction(Instruction instr, Register reg) {
          assert reg.getRegisterCategory().equals(CPU);
          assert !reg.equals(zr);
          assert !reg.equals(sp);
          emitInt(instr.encoding | UnconditionalBranchRegOp | rs1(reg));
<span class="udiff-line-added">+ </span>
      }
  
      /* Load-Store Single Register (5.3.1) */
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1145,11 +1250,11 @@</span>
       * @param destSize number of bits written to memory. Must be 8, 16, 32 or 64.
       * @param rt general purpose register. May not be null or stackpointer.
       * @param address all addressing modes allowed. May not be null.
       */
      public void str(int destSize, Register rt, AArch64Address address) {
<span class="udiff-line-modified-removed">-         assert rt.getRegisterCategory().equals(CPU);</span>
<span class="udiff-line-modified-added">+         assert rt.getRegisterCategory().equals(CPU) : rt;</span>
          assert destSize == 8 || destSize == 16 || destSize == 32 || destSize == 64;
          int transferSize = NumUtil.log2Ceil(destSize / 8);
          loadStoreInstruction(STR, rt, address, General64, transferSize);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1159,13 +1264,15 @@</span>
          int is32Bit = type.width == 32 ? 1 &lt;&lt; ImmediateSizeOffset : 0;
          int isFloat = !type.isGeneral ? 1 &lt;&lt; LoadStoreFpFlagOffset : 0;
          int memop = instr.encoding | transferSizeEncoding | is32Bit | isFloat | rt(reg);
          switch (address.getAddressingMode()) {
              case IMMEDIATE_SCALED:
<span class="udiff-line-added">+                 annotatePatchingImmediate(position(), instr, 12, LoadStoreScaledImmOffset, log2TransferSize);</span>
                  emitInt(memop | LoadStoreScaledOp | address.getImmediate() &lt;&lt; LoadStoreScaledImmOffset | rs1(address.getBase()));
                  break;
              case IMMEDIATE_UNSCALED:
<span class="udiff-line-added">+                 annotatePatchingImmediate(position(), instr, 9, LoadStoreUnscaledImmOffset, 0);</span>
                  emitInt(memop | LoadStoreUnscaledOp | address.getImmediate() &lt;&lt; LoadStoreUnscaledImmOffset | rs1(address.getBase()));
                  break;
              case BASE_REGISTER_ONLY:
                  emitInt(memop | LoadStoreScaledOp | rs1(address.getBase()));
                  break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1176,49 +1283,71 @@</span>
                  emitInt(memop | LoadStoreRegisterOp | rs2(address.getOffset()) | extendType.encoding &lt;&lt; ExtendTypeOffset | (shouldScale ? 1 : 0) &lt;&lt; LoadStoreScaledRegOffset | rs1(address.getBase()));
                  break;
              case PC_LITERAL:
                  assert log2TransferSize &gt;= 2 : &quot;PC literal loads only works for load/stores of 32-bit and larger&quot;;
                  transferSizeEncoding = (log2TransferSize - 2) &lt;&lt; LoadStoreTransferSizeOffset;
<span class="udiff-line-added">+                 annotatePatchingImmediate(position(), instr, 21, LoadLiteralImmeOffset, 2);</span>
                  emitInt(transferSizeEncoding | isFloat | LoadLiteralOp | rd(reg) | address.getImmediate() &lt;&lt; LoadLiteralImmeOffset);
                  break;
              case IMMEDIATE_POST_INDEXED:
<span class="udiff-line-added">+                 annotatePatchingImmediate(position(), instr, 9, LoadStoreIndexedImmOffset, 0);</span>
                  emitInt(memop | LoadStorePostIndexedOp | rs1(address.getBase()) | address.getImmediate() &lt;&lt; LoadStoreIndexedImmOffset);
                  break;
              case IMMEDIATE_PRE_INDEXED:
<span class="udiff-line-added">+                 annotatePatchingImmediate(position(), instr, 9, LoadStoreIndexedImmOffset, 0);</span>
                  emitInt(memop | LoadStorePreIndexedOp | rs1(address.getBase()) | address.getImmediate() &lt;&lt; LoadStoreIndexedImmOffset);
                  break;
              default:
                  throw GraalError.shouldNotReachHere(&quot;Unhandled addressing mode: &quot; + address.getAddressingMode());
          }
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Insert ldp/stp at the specified position.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     protected void insertLdpStp(int size, Instruction instr, Register rt, Register rt2, Register base, int offset, int position) {</span>
<span class="udiff-line-added">+         InstructionType type = generalFromSize(size);</span>
<span class="udiff-line-added">+         int scaledOffset = maskField(7, offset);</span>
<span class="udiff-line-added">+         int memop = type.encoding | instr.encoding | scaledOffset &lt;&lt; LoadStorePairImm7Offset | rt2(rt2) | rn(base) | rt(rt);</span>
<span class="udiff-line-added">+         emitInt(memop | LoadStorePairOp | (0b010 &lt;&lt; 23), position);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Load Pair of Registers calculates an address from a base register value and an immediate
       * offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from
       * two registers.
       */
      public void ldp(int size, Register rt, Register rt2, AArch64Address address) {
          assert size == 32 || size == 64;
<span class="udiff-line-modified-removed">-         loadStorePairInstruction(LDP, rt, rt2, address, generalFromSize(size));</span>
<span class="udiff-line-modified-added">+         loadStorePairInstruction(size, LDP, rt, rt2, address);</span>
      }
  
      /**
       * Store Pair of Registers calculates an address from a base register value and an immediate
       * offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from
       * two registers.
       */
      public void stp(int size, Register rt, Register rt2, AArch64Address address) {
          assert size == 32 || size == 64;
<span class="udiff-line-modified-removed">-         loadStorePairInstruction(STP, rt, rt2, address, generalFromSize(size));</span>
<span class="udiff-line-modified-added">+         loadStorePairInstruction(size, STP, rt, rt2, address);</span>
      }
  
<span class="udiff-line-modified-removed">-     private void loadStorePairInstruction(Instruction instr, Register rt, Register rt2, AArch64Address address, InstructionType type) {</span>
<span class="udiff-line-modified-removed">-         int scaledOffset = maskField(7, address.getImmediateRaw());  // LDP/STP use a 7-bit scaled</span>
<span class="udiff-line-modified-removed">-                                                                      // offset</span>
<span class="udiff-line-modified-added">+     private void loadStorePairInstruction(int size, Instruction instr, Register rt, Register rt2, AArch64Address address) {</span>
<span class="udiff-line-modified-added">+         InstructionType type = generalFromSize(size);</span>
<span class="udiff-line-modified-added">+         // LDP/STP uses a 7-bit scaled offset</span>
<span class="udiff-line-added">+         int offset = address.getImmediateRaw();</span>
<span class="udiff-line-added">+         if (address.getAddressingMode() == AddressingMode.IMMEDIATE_UNSCALED) {</span>
<span class="udiff-line-added">+             int sizeInBytes = size / Byte.SIZE;</span>
<span class="udiff-line-added">+             long mask = sizeInBytes - 1;</span>
<span class="udiff-line-added">+             assert (offset &amp; mask) == 0 : &quot;LDP/STP only supports aligned offset.&quot;;</span>
<span class="udiff-line-added">+             offset = offset / sizeInBytes;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         int scaledOffset = maskField(7, offset);</span>
          int memop = type.encoding | instr.encoding | scaledOffset &lt;&lt; LoadStorePairImm7Offset | rt2(rt2) | rn(address.getBase()) | rt(rt);
          switch (address.getAddressingMode()) {
              case IMMEDIATE_SCALED:
<span class="udiff-line-added">+             case IMMEDIATE_UNSCALED:</span>
                  emitInt(memop | LoadStorePairOp | (0b010 &lt;&lt; 23));
                  break;
              case IMMEDIATE_POST_INDEXED:
                  emitInt(memop | LoadStorePairOp | (0b001 &lt;&lt; 23));
                  break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1527,10 +1656,14 @@</span>
  
      private void addSubImmInstruction(Instruction instr, Register dst, Register src, int aimm, InstructionType type) {
          emitInt(type.encoding | instr.encoding | AddSubImmOp | encodeAimm(aimm) | rd(dst) | rs1(src));
      }
  
<span class="udiff-line-added">+     public void ccmp(int size, Register x, Register y, int aimm, ConditionFlag condition) {</span>
<span class="udiff-line-added">+         emitInt(generalFromSize(size).encoding | CCMP.encoding | rs1(x) | rs2(y) | encodeAimm(aimm) | condition.encoding &lt;&lt; ConditionalConditionOffset);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Encodes arithmetic immediate.
       *
       * @param imm Immediate has to be either an unsigned 12-bit value or an unsigned 24-bit value
       *            with the lower 12 bits zero.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2198,11 +2331,11 @@</span>
          assert !src2.equals(sp);
          emitInt(0b10011011010 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
      }
  
      /**
<span class="udiff-line-modified-removed">-      * unsigned multiply high. dst = (src1 * src2)[127:64]</span>
<span class="udiff-line-modified-added">+      * Unsigned multiply high. dst = (src1 * src2)[127:64]</span>
       *
       * @param dst general purpose register. May not be null or the stackpointer.
       * @param src1 general purpose register. May not be null or the stackpointer.
       * @param src2 general purpose register. May not be null or the stackpointer.
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2212,11 +2345,11 @@</span>
          assert !src2.equals(sp);
          emitInt(0b10011011110 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
      }
  
      /**
<span class="udiff-line-modified-removed">-      * unsigned multiply add-long. xDst = xSrc3 + (wSrc1 * wSrc2)</span>
<span class="udiff-line-modified-added">+      * Unsigned multiply add-long. xDst = xSrc3 + (wSrc1 * wSrc2)</span>
       *
       * @param dst general purpose register. May not be null or the stackpointer.
       * @param src1 general purpose register. May not be null or the stackpointer.
       * @param src2 general purpose register. May not be null or the stackpointer.
       * @param src3 general purpose register. May not be null or the stackpointer.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2228,31 +2361,47 @@</span>
          assert !src3.equals(sp);
          emitInt(0b10011011101 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
      }
  
      /**
<span class="udiff-line-modified-removed">-      * signed multiply add-long. xDst = xSrc3 + (wSrc1 * wSrc2)</span>
<span class="udiff-line-modified-added">+      * Signed multiply-add long. xDst = xSrc3 + (wSrc1 * wSrc2)</span>
       *
       * @param dst general purpose register. May not be null or the stackpointer.
       * @param src1 general purpose register. May not be null or the stackpointer.
       * @param src2 general purpose register. May not be null or the stackpointer.
       * @param src3 general purpose register. May not be null or the stackpointer.
       */
      public void smaddl(Register dst, Register src1, Register src2, Register src3) {
<span class="udiff-line-added">+         smullInstruction(MADD, dst, src1, src2, src3);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Signed multiply-sub long. xDst = xSrc3 - (wSrc1 * wSrc2)</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param dst general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src1 general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src2 general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      * @param src3 general purpose register. May not be null or the stackpointer.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void smsubl(Register dst, Register src1, Register src2, Register src3) {</span>
<span class="udiff-line-added">+         smullInstruction(MSUB, dst, src1, src2, src3);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private void mulInstruction(Instruction instr, Register dst, Register src1, Register src2, Register src3, InstructionType type) {</span>
          assert !dst.equals(sp);
          assert !src1.equals(sp);
          assert !src2.equals(sp);
          assert !src3.equals(sp);
<span class="udiff-line-modified-removed">-         emitInt(0b10011011001 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | rs3(src3));</span>
<span class="udiff-line-modified-added">+         emitInt(type.encoding | instr.encoding | MulOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));</span>
      }
  
<span class="udiff-line-modified-removed">-     private void mulInstruction(Instruction instr, Register dst, Register src1, Register src2, Register src3, InstructionType type) {</span>
<span class="udiff-line-modified-added">+     private void smullInstruction(Instruction instr, Register dst, Register src1, Register src2, Register src3) {</span>
          assert !dst.equals(sp);
          assert !src1.equals(sp);
          assert !src2.equals(sp);
          assert !src3.equals(sp);
<span class="udiff-line-modified-removed">-         emitInt(type.encoding | instr.encoding | MulOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));</span>
<span class="udiff-line-modified-added">+         emitInt(instr.encoding | SignedMulLongOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));</span>
      }
  
      /**
       * Signed divide. dst = src1 / src2.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2412,11 +2561,12 @@</span>
          long pattern = (bits &gt;&gt; 54) &amp; NumUtil.getNbitNumberLong(7);
          if (pattern != 0 &amp;&amp; pattern != NumUtil.getNbitNumberLong(7)) {
              return false;
          }
          // bits[62] and bits[61] are opposites.
<span class="udiff-line-modified-removed">-         return ((bits ^ (bits &lt;&lt; 1)) &amp; (1L &lt;&lt; 62)) != 0;</span>
<span class="udiff-line-modified-added">+         boolean result = ((bits ^ (bits &lt;&lt; 1)) &amp; (1L &lt;&lt; 62)) != 0;</span>
<span class="udiff-line-added">+         return result;</span>
      }
  
      private static int getFloatImmediate(float imm) {
          assert isFloatImmediate(imm);
          // bits: aBbb.bbbc.defg.h000.0000.0000.0000.0000
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2691,10 +2841,24 @@</span>
          assert src2.getRegisterCategory().equals(SIMD);
          InstructionType type = floatFromSize(size);
          emitInt(type.encoding | FCMP.encoding | FpCmpOp | rs1(src1) | rs2(src2));
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Signalling compares src1 to src2.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size register size.</span>
<span class="udiff-line-added">+      * @param src1 floating point register. May not be null.</span>
<span class="udiff-line-added">+      * @param src2 floating point register. May not be null.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void fcmpe(int size, Register src1, Register src2) {</span>
<span class="udiff-line-added">+         assert src1.getRegisterCategory().equals(SIMD);</span>
<span class="udiff-line-added">+         assert src2.getRegisterCategory().equals(SIMD);</span>
<span class="udiff-line-added">+         InstructionType type = floatFromSize(size);</span>
<span class="udiff-line-added">+         emitInt(type.encoding | FCMP.encoding | FpCmpeOp | rs1(src1) | rs2(src2));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Conditional compare. NZCV = fcmp(src1, src2) if condition else uimm4.
       *
       * @param size register size.
       * @param src1 floating point register. May not be null.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2720,10 +2884,22 @@</span>
          assert src.getRegisterCategory().equals(SIMD);
          InstructionType type = floatFromSize(size);
          emitInt(type.encoding | FCMPZERO.encoding | FpCmpOp | rs1(src));
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Signalling compare register to 0.0 .</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size register size.</span>
<span class="udiff-line-added">+      * @param src floating point register. May not be null.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void fcmpeZero(int size, Register src) {</span>
<span class="udiff-line-added">+         assert src.getRegisterCategory().equals(SIMD);</span>
<span class="udiff-line-added">+         InstructionType type = floatFromSize(size);</span>
<span class="udiff-line-added">+         emitInt(type.encoding | FCMPZERO.encoding | FpCmpeOp | rs1(src));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /* Floating-point Conditional Select (5.7.11) */
  
      /**
       * Conditional select. dst = src1 if condition else src2.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2831,6 +3007,103 @@</span>
       */
      public void dmb(BarrierKind barrierKind) {
          emitInt(DMB.encoding | BarrierOp | barrierKind.encoding &lt;&lt; BarrierKindOffset);
      }
  
<span class="udiff-line-added">+     public void mrs(Register dst, SystemRegister systemRegister) {</span>
<span class="udiff-line-added">+         emitInt(MRS.encoding | systemRegister.encoding() | rt(dst));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public void msr(SystemRegister systemRegister, Register src) {</span>
<span class="udiff-line-added">+         emitInt(MRS.encoding | systemRegister.encoding() | rt(src));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public void dc(DataCacheOperationType type, Register src) {</span>
<span class="udiff-line-added">+         emitInt(DC.encoding | type.encoding() | rt(src));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public void annotatePatchingImmediate(int pos, Instruction instruction, int operandSizeBits, int offsetBits, int shift) {</span>
<span class="udiff-line-added">+         if (codePatchingAnnotationConsumer != null) {</span>
<span class="udiff-line-added">+             codePatchingAnnotationConsumer.accept(new SingleInstructionAnnotation(pos, instruction, operandSizeBits, offsetBits, shift));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void annotateImmediateMovSequence(int pos, int numInstrs) {</span>
<span class="udiff-line-added">+         if (codePatchingAnnotationConsumer != null) {</span>
<span class="udiff-line-added">+             codePatchingAnnotationConsumer.accept(new MovSequenceAnnotation(pos, numInstrs));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static class SingleInstructionAnnotation extends CodeAnnotation {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * The size of the operand, in bytes.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public final int operandSizeBits;</span>
<span class="udiff-line-added">+         public final int offsetBits;</span>
<span class="udiff-line-added">+         public final Instruction instruction;</span>
<span class="udiff-line-added">+         public final int shift;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         SingleInstructionAnnotation(int instructionPosition, Instruction instruction, int operandSizeBits, int offsetBits, int shift) {</span>
<span class="udiff-line-added">+             super(instructionPosition);</span>
<span class="udiff-line-added">+             this.operandSizeBits = operandSizeBits;</span>
<span class="udiff-line-added">+             this.offsetBits = offsetBits;</span>
<span class="udiff-line-added">+             this.shift = shift;</span>
<span class="udiff-line-added">+             this.instruction = instruction;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static class MovSequenceAnnotation extends CodeAnnotation {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * The size of the operand, in bytes.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public final int numInstrs;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         MovSequenceAnnotation(int instructionPosition, int numInstrs) {</span>
<span class="udiff-line-added">+             super(instructionPosition);</span>
<span class="udiff-line-added">+             this.numInstrs = numInstrs;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * dst[0...n] = countBitCountOfEachByte(src[0...n]), n = size/8.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size register size. Has to be 64 or 128.</span>
<span class="udiff-line-added">+      * @param dst SIMD register. Should not be null.</span>
<span class="udiff-line-added">+      * @param src SIMD register. Should not be null.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void cnt(int size, Register dst, Register src) {</span>
<span class="udiff-line-added">+         assert 64 == size || 128 == size : &quot;Invalid size for cnt&quot;;</span>
<span class="udiff-line-added">+         emitInt((size &gt;&gt; 7) &lt;&lt; SIMDQBitOffset | CNT.encoding | rd(dst) | rs1(src));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * dst = src[0] + ....+ src[n].</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size register size. Has to be 64 or 128.</span>
<span class="udiff-line-added">+      * @param laneWidth the width that SIMD register is treated as different lanes with.</span>
<span class="udiff-line-added">+      * @param dst SIMD register. Should not be null.</span>
<span class="udiff-line-added">+      * @param src SIMD register. Should not be null.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void addv(int size, SIMDElementSize laneWidth, Register dst, Register src) {</span>
<span class="udiff-line-added">+         assert 64 == size || 128 == size : &quot;Invalid size for addv&quot;;</span>
<span class="udiff-line-added">+         assert SIMDElementSize.DoubleWord != laneWidth : &quot;Invalid lane width for addv&quot;;</span>
<span class="udiff-line-added">+         assert 64 != size || SIMDElementSize.Word != laneWidth : &quot;Invalid size and lane combination for addv&quot;;</span>
<span class="udiff-line-added">+         emitInt((size &gt;&gt; 7) &lt;&lt; SIMDQBitOffset | laneWidth.encoding &lt;&lt; SIMDSizeOffset | ADDV.encoding | rd(dst) | rs1(src));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * dst = src[srcIdx].</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size register size. Can be 8, 16, 32 or 64.</span>
<span class="udiff-line-added">+      * @param dst general purpose register. Should not be null or zero-register.</span>
<span class="udiff-line-added">+      * @param srcIdx lane index of source register that dest data is from.</span>
<span class="udiff-line-added">+      * @param src SIMD register. Should not be null.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void umov(int size, Register dst, int srcIdx, Register src) {</span>
<span class="udiff-line-added">+         assert (srcIdx + 1) * size &lt;= 128 : &quot;Invalid src vectRegister index&quot;;</span>
<span class="udiff-line-added">+         InstructionType simdDataType = simdFromSize(size);</span>
<span class="udiff-line-added">+         int imm5 = simdDataType.encoding | srcIdx &lt;&lt; Integer.numberOfTrailingZeros(simdDataType.encoding) + 1;</span>
<span class="udiff-line-added">+         emitInt((size &gt;&gt; 6) &lt;&lt; SIMDQBitOffset | imm5 &lt;&lt; SIMDImm5Offset | UMOV.encoding | rd(dst) | rs1(src));</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="../../../../../../../org.graalvm.compiler.asm.aarch64.test/src/org/graalvm/compiler/asm/aarch64/test/TestProtectedAssembler.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64MacroAssembler.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
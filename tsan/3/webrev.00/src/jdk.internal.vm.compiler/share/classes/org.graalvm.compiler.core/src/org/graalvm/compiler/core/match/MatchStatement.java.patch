diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/match/MatchStatement.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/match/MatchStatement.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/match/MatchStatement.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/match/MatchStatement.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,22 +24,22 @@
 
 package org.graalvm.compiler.core.match;
 
 import static org.graalvm.compiler.debug.DebugOptions.LogVerbose;
 
-import java.util.List;
-
 import org.graalvm.compiler.core.gen.NodeLIRBuilder;
 import org.graalvm.compiler.core.match.MatchPattern.MatchResultCode;
 import org.graalvm.compiler.core.match.MatchPattern.Result;
 import org.graalvm.compiler.debug.CounterKey;
 import org.graalvm.compiler.debug.DebugContext;
 import org.graalvm.compiler.graph.GraalGraphError;
 import org.graalvm.compiler.graph.Node;
 import org.graalvm.compiler.nodeinfo.Verbosity;
 
 import jdk.vm.ci.meta.Value;
+import org.graalvm.compiler.nodes.StructuredGraph;
+import org.graalvm.compiler.nodes.cfg.Block;
 
 /**
  * A named {@link MatchPattern} along with a {@link MatchGenerator} that can be evaluated to replace
  * one or more {@link Node}s with a single {@link Value}.
  */
@@ -78,24 +78,25 @@
     /**
      * Attempt to match the current statement against a Node.
      *
      * @param builder the current builder instance.
      * @param node the node to be matched
-     * @param nodes the nodes in the current block
+     * @param block the current block
+     * @param schedule the schedule that's being used
      * @return true if the statement matched something and set a {@link ComplexMatchResult} to be
      *         evaluated by the NodeLIRBuilder.
      */
-    public boolean generate(NodeLIRBuilder builder, int index, Node node, List<Node> nodes) {
+    public boolean generate(NodeLIRBuilder builder, int index, Node node, Block block, StructuredGraph.ScheduleResult schedule) {
         DebugContext debug = node.getDebug();
-        assert index == nodes.indexOf(node);
+        assert index == schedule.getBlockToNodesMap().get(block).indexOf(node);
         // Check that the basic shape matches
         Result result = pattern.matchShape(node, this);
         if (result != Result.OK) {
             return false;
         }
         // Now ensure that the other safety constraints are matched.
-        MatchContext context = new MatchContext(builder, this, index, node, nodes);
+        MatchContext context = new MatchContext(builder, this, index, node, block, schedule);
         result = pattern.matchUsage(node, context);
         if (result == Result.OK) {
             // Invoke the generator method and set the result if it's non null.
             ComplexMatchResult value = generatorMethod.match(builder.getNodeMatchRules(), buildArgList(context));
             if (value != null) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/match/MatchPattern.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MatchContext.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MatchStatement.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/match/MatchPattern.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.Position;
  import org.graalvm.compiler.nodeinfo.InputType;
  import org.graalvm.compiler.nodeinfo.Verbosity;
<span class="line-added">+ import org.graalvm.compiler.nodes.calc.FloatingNode;</span>
  
  /**
   * A simple recursive pattern matcher for a DAG of nodes.
   */
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,10 ***</span>
<span class="line-new-header">--- 44,11 ---</span>
          NAMED_VALUE_MISMATCH,
          TOO_MANY_USERS,
          NOT_IN_BLOCK,
          NOT_SAFE,
          ALREADY_USED,
<span class="line-added">+         TOO_LATE,</span>
      }
  
      /**
       * A descriptive result for match failures. This can be helpful for debugging why a match
       * doesn&#39;t work as expected.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,18 ***</span>
<span class="line-new-header">--- 70,20 ---</span>
          private static final CounterKey MatchResult_NAMED_VALUE_MISMATCH = DebugContext.counter(&quot;MatchResult_NAMED_VALUE_MISMATCH&quot;);
          private static final CounterKey MatchResult_TOO_MANY_USERS = DebugContext.counter(&quot;MatchResult_TOO_MANY_USERS&quot;);
          private static final CounterKey MatchResult_NOT_IN_BLOCK = DebugContext.counter(&quot;MatchResult_NOT_IN_BLOCK&quot;);
          private static final CounterKey MatchResult_NOT_SAFE = DebugContext.counter(&quot;MatchResult_NOT_SAFE&quot;);
          private static final CounterKey MatchResult_ALREADY_USED = DebugContext.counter(&quot;MatchResult_ALREADY_USED&quot;);
<span class="line-added">+         private static final CounterKey MatchResult_TOO_LATE = DebugContext.counter(&quot;MatchResult_TOO_LATE&quot;);</span>
  
          static final Result OK = new Result(MatchResultCode.OK, null, null);
          private static final Result CACHED_WRONG_CLASS = new Result(MatchResultCode.WRONG_CLASS, null, null);
          private static final Result CACHED_NAMED_VALUE_MISMATCH = new Result(MatchResultCode.NAMED_VALUE_MISMATCH, null, null);
          private static final Result CACHED_TOO_MANY_USERS = new Result(MatchResultCode.TOO_MANY_USERS, null, null);
          private static final Result CACHED_NOT_IN_BLOCK = new Result(MatchResultCode.NOT_IN_BLOCK, null, null);
          private static final Result CACHED_NOT_SAFE = new Result(MatchResultCode.NOT_SAFE, null, null);
          private static final Result CACHED_ALREADY_USED = new Result(MatchResultCode.ALREADY_USED, null, null);
<span class="line-added">+         private static final Result CACHED_TOO_LATE = new Result(MatchResultCode.TOO_LATE, null, null);</span>
  
          static Result wrongClass(Node node, MatchPattern matcher) {
              MatchResult_WRONG_CLASS.increment(node.getDebug());
              return node.getDebug().isLogEnabled() ? new Result(MatchResultCode.WRONG_CLASS, node, matcher) : CACHED_WRONG_CLASS;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,10 ***</span>
<span class="line-new-header">--- 111,15 ---</span>
          static Result alreadyUsed(Node node, MatchPattern matcher) {
              MatchResult_ALREADY_USED.increment(node.getDebug());
              return node.getDebug().isLogEnabled() ? new Result(MatchResultCode.ALREADY_USED, node, matcher) : CACHED_ALREADY_USED;
          }
  
<span class="line-added">+         static Result tooLate(Node node, MatchPattern matcher) {</span>
<span class="line-added">+             MatchResult_TOO_LATE.increment(node.getDebug());</span>
<span class="line-added">+             return node.getDebug().isLogEnabled() ? new Result(MatchResultCode.TOO_LATE, node, matcher) : CACHED_TOO_LATE;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          @Override
          public String toString() {
              if (code == MatchResultCode.OK) {
                  return &quot;OK&quot;;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 147,43 ***</span>
       * Can there only be one user of the node. Constant nodes can be matched even if there are other
       * users.
       */
      private final boolean singleUser;
  
      private static final MatchPattern[] EMPTY_PATTERNS = new MatchPattern[0];
  
<span class="line-modified">!     public MatchPattern(String name, boolean singleUser) {</span>
<span class="line-modified">!         this(null, name, singleUser);</span>
      }
  
<span class="line-modified">!     public MatchPattern(Class&lt;? extends Node&gt; nodeClass, String name, boolean singleUser) {</span>
          this.nodeClass = nodeClass;
          this.name = name;
          this.singleUser = singleUser;
          this.patterns = EMPTY_PATTERNS;
          this.inputs = null;
      }
  
<span class="line-modified">!     private MatchPattern(Class&lt;? extends Node&gt; nodeClass, String name, boolean singleUser, MatchPattern[] patterns, Position[] inputs) {</span>
          assert inputs == null || inputs.length == patterns.length;
          this.nodeClass = nodeClass;
          this.name = name;
          this.singleUser = singleUser;
          this.patterns = patterns;
          this.inputs = inputs;
      }
  
<span class="line-modified">!     public MatchPattern(Class&lt;? extends Node&gt; nodeClass, String name, MatchPattern first, Position[] inputs, boolean singleUser) {</span>
<span class="line-modified">!         this(nodeClass, name, singleUser, new MatchPattern[]{first}, inputs);</span>
      }
  
<span class="line-modified">!     public MatchPattern(Class&lt;? extends Node&gt; nodeClass, String name, MatchPattern first, MatchPattern second, Position[] inputs, boolean singleUser) {</span>
<span class="line-modified">!         this(nodeClass, name, singleUser, new MatchPattern[]{first, second}, inputs);</span>
      }
  
<span class="line-modified">!     public MatchPattern(Class&lt;? extends Node&gt; nodeClass, String name, MatchPattern first, MatchPattern second, MatchPattern third, Position[] inputs, boolean singleUser) {</span>
<span class="line-modified">!         this(nodeClass, name, singleUser, new MatchPattern[]{first, second, third}, inputs);</span>
      }
  
      Class&lt;? extends Node&gt; nodeClass() {
          return nodeClass;
      }
<span class="line-new-header">--- 156,53 ---</span>
       * Can there only be one user of the node. Constant nodes can be matched even if there are other
       * users.
       */
      private final boolean singleUser;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Can this node be subsumed into a match even if there are side effecting nodes between this</span>
<span class="line-added">+      * node and the match.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final boolean ignoresSideEffects;</span>
<span class="line-added">+ </span>
      private static final MatchPattern[] EMPTY_PATTERNS = new MatchPattern[0];
  
<span class="line-modified">!     public MatchPattern(String name, boolean singleUser, boolean ignoresSideEffects) {</span>
<span class="line-modified">!         this(null, name, singleUser, ignoresSideEffects);</span>
      }
  
<span class="line-modified">!     public MatchPattern(Class&lt;? extends Node&gt; nodeClass, String name, boolean singleUser, boolean ignoresSideEffects) {</span>
          this.nodeClass = nodeClass;
          this.name = name;
          this.singleUser = singleUser;
<span class="line-added">+         this.ignoresSideEffects = ignoresSideEffects;</span>
          this.patterns = EMPTY_PATTERNS;
          this.inputs = null;
<span class="line-added">+         assert !ignoresSideEffects || FloatingNode.class.isAssignableFrom(nodeClass);</span>
      }
  
<span class="line-modified">!     private MatchPattern(Class&lt;? extends Node&gt; nodeClass, String name, boolean singleUser, boolean ignoresSideEffects, MatchPattern[] patterns, Position[] inputs) {</span>
          assert inputs == null || inputs.length == patterns.length;
          this.nodeClass = nodeClass;
          this.name = name;
          this.singleUser = singleUser;
<span class="line-added">+         this.ignoresSideEffects = ignoresSideEffects;</span>
          this.patterns = patterns;
          this.inputs = inputs;
<span class="line-added">+         assert !ignoresSideEffects || FloatingNode.class.isAssignableFrom(nodeClass);</span>
      }
  
<span class="line-modified">!     public MatchPattern(Class&lt;? extends Node&gt; nodeClass, String name, MatchPattern first, Position[] inputs, boolean singleUser, boolean ignoresSideEffects) {</span>
<span class="line-modified">!         this(nodeClass, name, singleUser, ignoresSideEffects, new MatchPattern[]{first}, inputs);</span>
      }
  
<span class="line-modified">!     public MatchPattern(Class&lt;? extends Node&gt; nodeClass, String name, MatchPattern first, MatchPattern second, Position[] inputs, boolean singleUser, boolean ignoresSideEffects) {</span>
<span class="line-modified">!         this(nodeClass, name, singleUser, ignoresSideEffects, new MatchPattern[]{first, second}, inputs);</span>
      }
  
<span class="line-modified">!     public MatchPattern(Class&lt;? extends Node&gt; nodeClass, String name, MatchPattern first, MatchPattern second, MatchPattern third, Position[] inputs, boolean singleUser, boolean ignoresSideEffects) {</span>
<span class="line-modified">!         this(nodeClass, name, singleUser, ignoresSideEffects, new MatchPattern[]{first, second, third}, inputs);</span>
      }
  
      Class&lt;? extends Node&gt; nodeClass() {
          return nodeClass;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 213,12 ***</span>
      private Result matchUsage(Node node, MatchContext context, boolean atRoot) {
          Result result = matchType(node);
          if (result != Result.OK) {
              return result;
          }
<span class="line-modified">!         if (singleUser &amp;&amp; !atRoot) {</span>
<span class="line-modified">!             result = context.consume(node);</span>
              if (result != Result.OK) {
                  return result;
              }
          }
  
<span class="line-new-header">--- 232,12 ---</span>
      private Result matchUsage(Node node, MatchContext context, boolean atRoot) {
          Result result = matchType(node);
          if (result != Result.OK) {
              return result;
          }
<span class="line-modified">!         if (singleUser) {</span>
<span class="line-modified">!             result = context.consume(node, ignoresSideEffects, atRoot);</span>
              if (result != Result.OK) {
                  return result;
              }
          }
  
</pre>
<center><a href="MatchContext.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MatchStatement.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
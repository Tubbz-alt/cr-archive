<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/CompilationWrapper.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompilationPrinter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraalCompilerOptions.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/CompilationWrapper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core;
 26 
 27 import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.ExitVM;
<span class="line-modified"> 28 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAction;</span>
 29 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
 30 import static org.graalvm.compiler.core.GraalCompilerOptions.ExitVMOnException;
 31 import static org.graalvm.compiler.core.GraalCompilerOptions.MaxCompilationProblemsPerAction;

 32 import static org.graalvm.compiler.debug.DebugContext.VERBOSE_LEVEL;
 33 import static org.graalvm.compiler.debug.DebugOptions.Dump;
 34 import static org.graalvm.compiler.debug.DebugOptions.DumpPath;
 35 import static org.graalvm.compiler.debug.DebugOptions.MethodFilter;
 36 
 37 import java.io.ByteArrayOutputStream;
 38 import java.io.File;
 39 import java.io.FileOutputStream;
 40 import java.io.IOException;
 41 import java.io.PrintStream;
 42 import java.util.Map;
 43 
 44 import org.graalvm.compiler.debug.DebugContext;
 45 import org.graalvm.compiler.debug.DiagnosticsOutputDirectory;
 46 import org.graalvm.compiler.debug.PathUtilities;
 47 import org.graalvm.compiler.debug.TTY;
<span class="line-removed"> 48 import org.graalvm.compiler.options.EnumOptionKey;</span>
 49 import org.graalvm.compiler.options.OptionValues;
 50 
 51 import jdk.vm.ci.code.BailoutException;
 52 
 53 /**
 54  * Wrapper for a compilation that centralizes what action to take based on
<span class="line-modified"> 55  * {@link GraalCompilerOptions#CompilationBailoutAction} and</span>
 56  * {@link GraalCompilerOptions#CompilationFailureAction} when an uncaught exception occurs during
 57  * compilation.
 58  */
 59 public abstract class CompilationWrapper&lt;T&gt; {
 60 
 61     /**
 62      * Actions to take upon an exception being raised during compilation performed via
 63      * {@link CompilationWrapper}. The actions are with respect to what the user sees on the
 64      * console. The compilation requester determines what ultimate action is taken in
 65      * {@link CompilationWrapper#handleException(Throwable)}.
 66      *
 67      * The actions are in ascending order of verbosity.
 68      */
 69     public enum ExceptionAction {
 70         /**
 71          * Print nothing to the console.
 72          */
 73         Silent,

 74         /**
 75          * Print a stack trace to the console.
 76          */
 77         Print,

 78         /**
 79          * An exception causes the compilation to be retried with extra diagnostics enabled.
 80          */
 81         Diagnose,

 82         /**
 83          * Same as {@link #Diagnose} except that the VM process is exited after retrying.
 84          */
 85         ExitVM;
 86 
 87         private static final ExceptionAction[] VALUES = values();
 88 
 89         /**
 90          * Gets the action that is one level less verbose than this action, bottoming out at the
 91          * least verbose action.
 92          */
 93         ExceptionAction quieter() {
 94             assert ExceptionAction.Silent.ordinal() == 0;
 95             int index = Math.max(ordinal() - 1, 0);
 96             return VALUES[index];
 97         }
 98     }
 99 
100     private final DiagnosticsOutputDirectory outputDirectory;
101 
</pre>
<hr />
<pre>
105      * @param outputDirectory object used to access a directory for dumping if the compilation is
106      *            re-executed
107      * @param problemsHandledPerAction map used to count the number of compilation failures or
108      *            bailouts handled by each action. This is provided by the caller as it is expected
109      *            to be shared between instances of {@link CompilationWrapper}.
110      */
111     public CompilationWrapper(DiagnosticsOutputDirectory outputDirectory, Map&lt;ExceptionAction, Integer&gt; problemsHandledPerAction) {
112         this.outputDirectory = outputDirectory;
113         this.problemsHandledPerAction = problemsHandledPerAction;
114     }
115 
116     /**
117      * Handles an uncaught exception.
118      *
119      * @param t an exception thrown during {@link #run(DebugContext)}
120      * @return a value representing the result of a failed compilation (may be {@code null})
121      */
122     protected abstract T handleException(Throwable t);
123 
124     /**
<span class="line-modified">125      * Gets the action to take based on the value of {@code actionKey} in {@code options}.</span>



126      *
<span class="line-modified">127      * Subclasses can override this to choose a different action based on factors such as whether</span>
<span class="line-removed">128      * {@code actionKey} has been explicitly set in {@code options} for example.</span>
129      *
130      * @param cause the cause of the bailout or failure
131      */
<span class="line-modified">132     protected ExceptionAction lookupAction(OptionValues options, EnumOptionKey&lt;ExceptionAction&gt; actionKey, Throwable cause) {</span>
<span class="line-modified">133         if (actionKey == CompilationFailureAction) {</span>
<span class="line-modified">134             if (ExitVMOnException.getValue(options)) {</span>
<span class="line-modified">135                 assert CompilationFailureAction.getDefaultValue() != ExceptionAction.ExitVM;</span>
<span class="line-modified">136                 assert ExitVMOnException.getDefaultValue() != true;</span>
<span class="line-modified">137                 if (CompilationFailureAction.hasBeenSet(options) &amp;&amp; CompilationFailureAction.getValue(options) != ExceptionAction.ExitVM) {</span>
<span class="line-modified">138                     TTY.printf(&quot;WARNING: Ignoring %s=%s since %s=true has been explicitly specified.%n&quot;,</span>
<span class="line-modified">139                                     CompilationFailureAction.getName(), CompilationFailureAction.getValue(options),</span>
<span class="line-modified">140                                     ExitVMOnException.getName());</span>
<span class="line-modified">141                 }</span>
<span class="line-modified">142                 return ExceptionAction.ExitVM;</span>
143             }

144         }
<span class="line-modified">145         return actionKey.getValue(options);</span>
146     }
147 
148     /**
149      * Perform the compilation wrapped by this object.
150      *
151      * @param debug the debug context to use for the compilation
152      */
153     protected abstract T performCompilation(DebugContext debug);
154 
155     /**
156      * Gets a value that represents the input to the compilation.
157      */
158     @Override
159     public abstract String toString();
160 
161     /**
162      * Creates the {@link DebugContext} to use when retrying a compilation.
163      *

164      * @param options the options for configuring the debug context
165      * @param logStream the log stream to use in the debug context
166      */
<span class="line-modified">167     protected abstract DebugContext createRetryDebugContext(OptionValues options, PrintStream logStream);</span>
168 
169     @SuppressWarnings(&quot;try&quot;)
170     public final T run(DebugContext initialDebug) {
171         try {
172             return performCompilation(initialDebug);
173         } catch (Throwable cause) {
174             OptionValues initialOptions = initialDebug.getOptions();
175 
<span class="line-removed">176             String causeType = &quot;failure&quot;;</span>
<span class="line-removed">177             EnumOptionKey&lt;ExceptionAction&gt; actionKey;</span>
<span class="line-removed">178             if (cause instanceof BailoutException) {</span>
<span class="line-removed">179                 actionKey = CompilationBailoutAction;</span>
<span class="line-removed">180                 causeType = &quot;bailout&quot;;</span>
<span class="line-removed">181             } else {</span>
<span class="line-removed">182                 actionKey = CompilationFailureAction;</span>
<span class="line-removed">183                 causeType = &quot;failure&quot;;</span>
<span class="line-removed">184             }</span>
185             synchronized (CompilationFailureAction) {
186                 // Serialize all compilation failure handling.
187                 // This prevents retry compilation storms and interleaving
188                 // of compilation exception messages.
189                 // It also allows for reliable testing of CompilationWrapper
190                 // by avoiding a race whereby retry compilation output from a
191                 // forced crash (i.e., use of GraalCompilerOptions.CrashAt)
192                 // is truncated.
193 
<span class="line-modified">194                 ExceptionAction action = lookupAction(initialOptions, actionKey, cause);</span>
195 
<span class="line-modified">196                 action = adjustAction(initialOptions, actionKey, action);</span>
197 
198                 if (action == ExceptionAction.Silent) {
199                     return handleException(cause);
200                 }
201 
202                 if (action == ExceptionAction.Print) {
203                     ByteArrayOutputStream baos = new ByteArrayOutputStream();
204                     try (PrintStream ps = new PrintStream(baos)) {
205                         ps.printf(&quot;%s: Compilation of %s failed: &quot;, Thread.currentThread(), this);
206                         cause.printStackTrace(ps);
<span class="line-modified">207                         ps.printf(&quot;To disable compilation %s notifications, set %s to %s (e.g., -Dgraal.%s=%s).%n&quot;,</span>
<span class="line-modified">208                                         causeType,</span>
<span class="line-modified">209                                         actionKey.getName(), ExceptionAction.Silent,</span>
<span class="line-modified">210                                         actionKey.getName(), ExceptionAction.Silent);</span>
<span class="line-removed">211                         ps.printf(&quot;To capture more information for diagnosing or reporting a compilation %s, &quot; +</span>
212                                         &quot;set %s to %s or %s (e.g., -Dgraal.%s=%s).%n&quot;,
<span class="line-modified">213                                         causeType,</span>
<span class="line-removed">214                                         actionKey.getName(), ExceptionAction.Diagnose,</span>
215                                         ExceptionAction.ExitVM,
<span class="line-modified">216                                         actionKey.getName(), ExceptionAction.Diagnose);</span>
217                     }
218                     TTY.print(baos.toString());
219                     return handleException(cause);
220                 }
221 
222                 // action is Diagnose or ExitVM
223 
224                 if (Dump.hasBeenSet(initialOptions)) {
225                     // If dumping is explicitly enabled, Graal is being debugged
226                     // so don&#39;t interfere with what the user is expecting to see.
227                     return handleException(cause);
228                 }
229 
230                 File dumpPath = null;
231                 try {
232                     String dir = this.outputDirectory.getPath();
233                     if (dir != null) {
234                         String dumpName = PathUtilities.sanitizeFileName(toString());
235                         dumpPath = new File(dir, dumpName);
236                         dumpPath.mkdirs();
237                         if (!dumpPath.exists()) {
238                             TTY.println(&quot;Warning: could not create diagnostics directory &quot; + dumpPath);
239                             dumpPath = null;
240                         }
241                     }
242                 } catch (Throwable t) {
243                     TTY.println(&quot;Warning: could not create Graal diagnostic directory&quot;);
244                     t.printStackTrace(TTY.out);
245                 }
246 
247                 String message;
248                 ByteArrayOutputStream baos = new ByteArrayOutputStream();
249                 try (PrintStream ps = new PrintStream(baos)) {



250                     ps.printf(&quot;%s: Compilation of %s failed:%n&quot;, Thread.currentThread(), this);
251                     cause.printStackTrace(ps);
<span class="line-modified">252                     ps.printf(&quot;To disable compilation %s notifications, set %s to %s (e.g., -Dgraal.%s=%s).%n&quot;,</span>
<span class="line-modified">253                                     causeType,</span>
<span class="line-modified">254                                     actionKey.getName(), ExceptionAction.Silent,</span>
<span class="line-modified">255                                     actionKey.getName(), ExceptionAction.Silent);</span>
<span class="line-removed">256                     ps.printf(&quot;To print a message for a compilation %s without retrying the compilation, &quot; +</span>
257                                     &quot;set %s to %s (e.g., -Dgraal.%s=%s).%n&quot;,
<span class="line-modified">258                                     causeType,</span>
<span class="line-modified">259                                     actionKey.getName(), ExceptionAction.Print,</span>
<span class="line-removed">260                                     actionKey.getName(), ExceptionAction.Print);</span>
261                     if (dumpPath != null) {
262                         ps.println(&quot;Retrying compilation of &quot; + this);
263                     } else {
264                         ps.println(&quot;Not retrying compilation of &quot; + this + &quot; as the dump path could not be created.&quot;);
265                     }
266                     message = baos.toString();
267                 }
268 
269                 TTY.print(message);
270                 if (dumpPath == null) {
271                     return handleException(cause);
272                 }
273 
274                 File retryLogFile = new File(dumpPath, &quot;retry.log&quot;);
275                 try (PrintStream ps = new PrintStream(new FileOutputStream(retryLogFile))) {
276                     ps.print(message);
277                 } catch (IOException ioe) {
278                     TTY.printf(&quot;Error writing to %s: %s%n&quot;, retryLogFile, ioe);
279                 }
280 
281                 OptionValues retryOptions = new OptionValues(initialOptions,
282                                 Dump, &quot;:&quot; + VERBOSE_LEVEL,
283                                 MethodFilter, null,
<span class="line-modified">284                                 DumpPath, dumpPath.getPath());</span>

285 
286                 ByteArrayOutputStream logBaos = new ByteArrayOutputStream();
287                 PrintStream ps = new PrintStream(logBaos);
<span class="line-modified">288                 try (DebugContext retryDebug = createRetryDebugContext(retryOptions, ps)) {</span>
289                     T res = performCompilation(retryDebug);
290                     ps.println(&quot;There was no exception during retry.&quot;);
291                     maybeExitVM(action);
292                     return res;
293                 } catch (Throwable e) {
294                     ps.println(&quot;Exception during retry:&quot;);
295                     e.printStackTrace(ps);
296                     // Failures during retry are silent
297                     T res = handleException(cause);
298                     maybeExitVM(action);
299                     return res;
300                 } finally {
301                     ps.close();
302                     try (FileOutputStream fos = new FileOutputStream(retryLogFile, true)) {
303                         fos.write(logBaos.toByteArray());
304                     } catch (Throwable e) {
305                         TTY.printf(&quot;Error writing to %s: %s%n&quot;, retryLogFile, e);
306                     }
307                 }
308             }
309         }
310     }
311 






312     private void maybeExitVM(ExceptionAction action) {
313         if (action == ExitVM) {
314             TTY.println(&quot;Exiting VM after retry compilation of &quot; + this);
<span class="line-modified">315             System.exit(-1);</span>
316         }
317     }
318 
319     /**
320      * Adjusts {@code initialAction} if necessary based on
321      * {@link GraalCompilerOptions#MaxCompilationProblemsPerAction}.
322      */
<span class="line-modified">323     private ExceptionAction adjustAction(OptionValues initialOptions, EnumOptionKey&lt;ExceptionAction&gt; actionKey, ExceptionAction initialAction) {</span>
324         ExceptionAction action = initialAction;
325         int maxProblems = MaxCompilationProblemsPerAction.getValue(initialOptions);
326         if (action != ExceptionAction.ExitVM) {
327             synchronized (problemsHandledPerAction) {
328                 while (action != ExceptionAction.Silent) {
329                     int problems = problemsHandledPerAction.getOrDefault(action, 0);
330                     if (problems &gt;= maxProblems) {
331                         if (problems == maxProblems) {
<span class="line-modified">332                             TTY.printf(&quot;Warning: adjusting %s from %s to %s after %s (%d) failed compilations%n&quot;, actionKey, action, action.quieter(),</span>
333                                             MaxCompilationProblemsPerAction, maxProblems);
334                             // Ensure that the message above is only printed once
335                             problemsHandledPerAction.put(action, problems + 1);
336                         }
337                         action = action.quieter();
338                     } else {
339                         break;
340                     }
341                 }
342                 problemsHandledPerAction.put(action, problemsHandledPerAction.getOrDefault(action, 0) + 1);
343             }
344         }
345         return action;
346     }
347 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core;
 26 
 27 import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.ExitVM;
<span class="line-modified"> 28 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAsFailure;</span>
 29 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
 30 import static org.graalvm.compiler.core.GraalCompilerOptions.ExitVMOnException;
 31 import static org.graalvm.compiler.core.GraalCompilerOptions.MaxCompilationProblemsPerAction;
<span class="line-added"> 32 import static org.graalvm.compiler.core.common.GraalOptions.TrackNodeSourcePosition;</span>
 33 import static org.graalvm.compiler.debug.DebugContext.VERBOSE_LEVEL;
 34 import static org.graalvm.compiler.debug.DebugOptions.Dump;
 35 import static org.graalvm.compiler.debug.DebugOptions.DumpPath;
 36 import static org.graalvm.compiler.debug.DebugOptions.MethodFilter;
 37 
 38 import java.io.ByteArrayOutputStream;
 39 import java.io.File;
 40 import java.io.FileOutputStream;
 41 import java.io.IOException;
 42 import java.io.PrintStream;
 43 import java.util.Map;
 44 
 45 import org.graalvm.compiler.debug.DebugContext;
 46 import org.graalvm.compiler.debug.DiagnosticsOutputDirectory;
 47 import org.graalvm.compiler.debug.PathUtilities;
 48 import org.graalvm.compiler.debug.TTY;

 49 import org.graalvm.compiler.options.OptionValues;
 50 
 51 import jdk.vm.ci.code.BailoutException;
 52 
 53 /**
 54  * Wrapper for a compilation that centralizes what action to take based on
<span class="line-modified"> 55  * {@link GraalCompilerOptions#CompilationBailoutAsFailure} and</span>
 56  * {@link GraalCompilerOptions#CompilationFailureAction} when an uncaught exception occurs during
 57  * compilation.
 58  */
 59 public abstract class CompilationWrapper&lt;T&gt; {
 60 
 61     /**
 62      * Actions to take upon an exception being raised during compilation performed via
 63      * {@link CompilationWrapper}. The actions are with respect to what the user sees on the
 64      * console. The compilation requester determines what ultimate action is taken in
 65      * {@link CompilationWrapper#handleException(Throwable)}.
 66      *
 67      * The actions are in ascending order of verbosity.
 68      */
 69     public enum ExceptionAction {
 70         /**
 71          * Print nothing to the console.
 72          */
 73         Silent,
<span class="line-added"> 74 </span>
 75         /**
 76          * Print a stack trace to the console.
 77          */
 78         Print,
<span class="line-added"> 79 </span>
 80         /**
 81          * An exception causes the compilation to be retried with extra diagnostics enabled.
 82          */
 83         Diagnose,
<span class="line-added"> 84 </span>
 85         /**
 86          * Same as {@link #Diagnose} except that the VM process is exited after retrying.
 87          */
 88         ExitVM;
 89 
 90         private static final ExceptionAction[] VALUES = values();
 91 
 92         /**
 93          * Gets the action that is one level less verbose than this action, bottoming out at the
 94          * least verbose action.
 95          */
 96         ExceptionAction quieter() {
 97             assert ExceptionAction.Silent.ordinal() == 0;
 98             int index = Math.max(ordinal() - 1, 0);
 99             return VALUES[index];
100         }
101     }
102 
103     private final DiagnosticsOutputDirectory outputDirectory;
104 
</pre>
<hr />
<pre>
108      * @param outputDirectory object used to access a directory for dumping if the compilation is
109      *            re-executed
110      * @param problemsHandledPerAction map used to count the number of compilation failures or
111      *            bailouts handled by each action. This is provided by the caller as it is expected
112      *            to be shared between instances of {@link CompilationWrapper}.
113      */
114     public CompilationWrapper(DiagnosticsOutputDirectory outputDirectory, Map&lt;ExceptionAction, Integer&gt; problemsHandledPerAction) {
115         this.outputDirectory = outputDirectory;
116         this.problemsHandledPerAction = problemsHandledPerAction;
117     }
118 
119     /**
120      * Handles an uncaught exception.
121      *
122      * @param t an exception thrown during {@link #run(DebugContext)}
123      * @return a value representing the result of a failed compilation (may be {@code null})
124      */
125     protected abstract T handleException(Throwable t);
126 
127     /**
<span class="line-modified">128      * Gets the action to take based on the value of</span>
<span class="line-added">129      * {@link GraalCompilerOptions#CompilationBailoutAsFailure},</span>
<span class="line-added">130      * {@link GraalCompilerOptions#CompilationFailureAction} and</span>
<span class="line-added">131      * {@link GraalCompilerOptions#ExitVMOnException} in {@code options}.</span>
132      *
<span class="line-modified">133      * Subclasses can override this to choose a different action.</span>

134      *
135      * @param cause the cause of the bailout or failure
136      */
<span class="line-modified">137     protected ExceptionAction lookupAction(OptionValues options, Throwable cause) {</span>
<span class="line-modified">138         if (cause instanceof BailoutException &amp;&amp; !CompilationBailoutAsFailure.getValue(options)) {</span>
<span class="line-modified">139             return ExceptionAction.Silent;</span>
<span class="line-modified">140         }</span>
<span class="line-modified">141         if (ExitVMOnException.getValue(options)) {</span>
<span class="line-modified">142             assert CompilationFailureAction.getDefaultValue() != ExceptionAction.ExitVM;</span>
<span class="line-modified">143             assert ExitVMOnException.getDefaultValue() != true;</span>
<span class="line-modified">144             if (CompilationFailureAction.hasBeenSet(options) &amp;&amp; CompilationFailureAction.getValue(options) != ExceptionAction.ExitVM) {</span>
<span class="line-modified">145                 TTY.printf(&quot;WARNING: Ignoring %s=%s since %s=true has been explicitly specified.%n&quot;,</span>
<span class="line-modified">146                                 CompilationFailureAction.getName(), CompilationFailureAction.getValue(options),</span>
<span class="line-modified">147                                 ExitVMOnException.getName());</span>
148             }
<span class="line-added">149             return ExceptionAction.ExitVM;</span>
150         }
<span class="line-modified">151         return CompilationFailureAction.getValue(options);</span>
152     }
153 
154     /**
155      * Perform the compilation wrapped by this object.
156      *
157      * @param debug the debug context to use for the compilation
158      */
159     protected abstract T performCompilation(DebugContext debug);
160 
161     /**
162      * Gets a value that represents the input to the compilation.
163      */
164     @Override
165     public abstract String toString();
166 
167     /**
168      * Creates the {@link DebugContext} to use when retrying a compilation.
169      *
<span class="line-added">170      * @param initialDebug the debug context used in the failing compilation</span>
171      * @param options the options for configuring the debug context
172      * @param logStream the log stream to use in the debug context
173      */
<span class="line-modified">174     protected abstract DebugContext createRetryDebugContext(DebugContext initialDebug, OptionValues options, PrintStream logStream);</span>
175 
176     @SuppressWarnings(&quot;try&quot;)
177     public final T run(DebugContext initialDebug) {
178         try {
179             return performCompilation(initialDebug);
180         } catch (Throwable cause) {
181             OptionValues initialOptions = initialDebug.getOptions();
182 









183             synchronized (CompilationFailureAction) {
184                 // Serialize all compilation failure handling.
185                 // This prevents retry compilation storms and interleaving
186                 // of compilation exception messages.
187                 // It also allows for reliable testing of CompilationWrapper
188                 // by avoiding a race whereby retry compilation output from a
189                 // forced crash (i.e., use of GraalCompilerOptions.CrashAt)
190                 // is truncated.
191 
<span class="line-modified">192                 ExceptionAction action = lookupAction(initialOptions, cause);</span>
193 
<span class="line-modified">194                 action = adjustAction(initialOptions, action);</span>
195 
196                 if (action == ExceptionAction.Silent) {
197                     return handleException(cause);
198                 }
199 
200                 if (action == ExceptionAction.Print) {
201                     ByteArrayOutputStream baos = new ByteArrayOutputStream();
202                     try (PrintStream ps = new PrintStream(baos)) {
203                         ps.printf(&quot;%s: Compilation of %s failed: &quot;, Thread.currentThread(), this);
204                         cause.printStackTrace(ps);
<span class="line-modified">205                         ps.printf(&quot;To disable compilation failure notifications, set %s to %s (e.g., -Dgraal.%s=%s).%n&quot;,</span>
<span class="line-modified">206                                         CompilationFailureAction.getName(), ExceptionAction.Silent,</span>
<span class="line-modified">207                                         CompilationFailureAction.getName(), ExceptionAction.Silent);</span>
<span class="line-modified">208                         ps.printf(&quot;To capture more information for diagnosing or reporting a compilation failure, &quot; +</span>

209                                         &quot;set %s to %s or %s (e.g., -Dgraal.%s=%s).%n&quot;,
<span class="line-modified">210                                         CompilationFailureAction.getName(), ExceptionAction.Diagnose,</span>

211                                         ExceptionAction.ExitVM,
<span class="line-modified">212                                         CompilationFailureAction.getName(), ExceptionAction.Diagnose);</span>
213                     }
214                     TTY.print(baos.toString());
215                     return handleException(cause);
216                 }
217 
218                 // action is Diagnose or ExitVM
219 
220                 if (Dump.hasBeenSet(initialOptions)) {
221                     // If dumping is explicitly enabled, Graal is being debugged
222                     // so don&#39;t interfere with what the user is expecting to see.
223                     return handleException(cause);
224                 }
225 
226                 File dumpPath = null;
227                 try {
228                     String dir = this.outputDirectory.getPath();
229                     if (dir != null) {
230                         String dumpName = PathUtilities.sanitizeFileName(toString());
231                         dumpPath = new File(dir, dumpName);
232                         dumpPath.mkdirs();
233                         if (!dumpPath.exists()) {
234                             TTY.println(&quot;Warning: could not create diagnostics directory &quot; + dumpPath);
235                             dumpPath = null;
236                         }
237                     }
238                 } catch (Throwable t) {
239                     TTY.println(&quot;Warning: could not create Graal diagnostic directory&quot;);
240                     t.printStackTrace(TTY.out);
241                 }
242 
243                 String message;
244                 ByteArrayOutputStream baos = new ByteArrayOutputStream();
245                 try (PrintStream ps = new PrintStream(baos)) {
<span class="line-added">246                     // This output is used by external tools to detect compilation failures.</span>
<span class="line-added">247                     ps.println(&quot;[[[Graal compilation failure]]]&quot;);</span>
<span class="line-added">248 </span>
249                     ps.printf(&quot;%s: Compilation of %s failed:%n&quot;, Thread.currentThread(), this);
250                     cause.printStackTrace(ps);
<span class="line-modified">251                     ps.printf(&quot;To disable compilation failure notifications, set %s to %s (e.g., -Dgraal.%s=%s).%n&quot;,</span>
<span class="line-modified">252                                     CompilationFailureAction.getName(), ExceptionAction.Silent,</span>
<span class="line-modified">253                                     CompilationFailureAction.getName(), ExceptionAction.Silent);</span>
<span class="line-modified">254                     ps.printf(&quot;To print a message for a compilation failure without retrying the compilation, &quot; +</span>

255                                     &quot;set %s to %s (e.g., -Dgraal.%s=%s).%n&quot;,
<span class="line-modified">256                                     CompilationFailureAction.getName(), ExceptionAction.Print,</span>
<span class="line-modified">257                                     CompilationFailureAction.getName(), ExceptionAction.Print);</span>

258                     if (dumpPath != null) {
259                         ps.println(&quot;Retrying compilation of &quot; + this);
260                     } else {
261                         ps.println(&quot;Not retrying compilation of &quot; + this + &quot; as the dump path could not be created.&quot;);
262                     }
263                     message = baos.toString();
264                 }
265 
266                 TTY.print(message);
267                 if (dumpPath == null) {
268                     return handleException(cause);
269                 }
270 
271                 File retryLogFile = new File(dumpPath, &quot;retry.log&quot;);
272                 try (PrintStream ps = new PrintStream(new FileOutputStream(retryLogFile))) {
273                     ps.print(message);
274                 } catch (IOException ioe) {
275                     TTY.printf(&quot;Error writing to %s: %s%n&quot;, retryLogFile, ioe);
276                 }
277 
278                 OptionValues retryOptions = new OptionValues(initialOptions,
279                                 Dump, &quot;:&quot; + VERBOSE_LEVEL,
280                                 MethodFilter, null,
<span class="line-modified">281                                 DumpPath, dumpPath.getPath(),</span>
<span class="line-added">282                                 TrackNodeSourcePosition, true);</span>
283 
284                 ByteArrayOutputStream logBaos = new ByteArrayOutputStream();
285                 PrintStream ps = new PrintStream(logBaos);
<span class="line-modified">286                 try (DebugContext retryDebug = createRetryDebugContext(initialDebug, retryOptions, ps)) {</span>
287                     T res = performCompilation(retryDebug);
288                     ps.println(&quot;There was no exception during retry.&quot;);
289                     maybeExitVM(action);
290                     return res;
291                 } catch (Throwable e) {
292                     ps.println(&quot;Exception during retry:&quot;);
293                     e.printStackTrace(ps);
294                     // Failures during retry are silent
295                     T res = handleException(cause);
296                     maybeExitVM(action);
297                     return res;
298                 } finally {
299                     ps.close();
300                     try (FileOutputStream fos = new FileOutputStream(retryLogFile, true)) {
301                         fos.write(logBaos.toByteArray());
302                     } catch (Throwable e) {
303                         TTY.printf(&quot;Error writing to %s: %s%n&quot;, retryLogFile, e);
304                     }
305                 }
306             }
307         }
308     }
309 
<span class="line-added">310     /**</span>
<span class="line-added">311      * Calls {@link System#exit(int)} in the runtime embedding the Graal compiler. This will be a</span>
<span class="line-added">312      * different runtime than Graal&#39;s runtime in the case of libgraal.</span>
<span class="line-added">313      */</span>
<span class="line-added">314     protected abstract void exitHostVM(int status);</span>
<span class="line-added">315 </span>
316     private void maybeExitVM(ExceptionAction action) {
317         if (action == ExitVM) {
318             TTY.println(&quot;Exiting VM after retry compilation of &quot; + this);
<span class="line-modified">319             exitHostVM(-1);</span>
320         }
321     }
322 
323     /**
324      * Adjusts {@code initialAction} if necessary based on
325      * {@link GraalCompilerOptions#MaxCompilationProblemsPerAction}.
326      */
<span class="line-modified">327     private ExceptionAction adjustAction(OptionValues initialOptions, ExceptionAction initialAction) {</span>
328         ExceptionAction action = initialAction;
329         int maxProblems = MaxCompilationProblemsPerAction.getValue(initialOptions);
330         if (action != ExceptionAction.ExitVM) {
331             synchronized (problemsHandledPerAction) {
332                 while (action != ExceptionAction.Silent) {
333                     int problems = problemsHandledPerAction.getOrDefault(action, 0);
334                     if (problems &gt;= maxProblems) {
335                         if (problems == maxProblems) {
<span class="line-modified">336                             TTY.printf(&quot;Warning: adjusting %s from %s to %s after %s (%d) failed compilations%n&quot;, CompilationFailureAction, action, action.quieter(),</span>
337                                             MaxCompilationProblemsPerAction, maxProblems);
338                             // Ensure that the message above is only printed once
339                             problemsHandledPerAction.put(action, problems + 1);
340                         }
341                         action = action.quieter();
342                     } else {
343                         break;
344                     }
345                 }
346                 problemsHandledPerAction.put(action, problemsHandledPerAction.getOrDefault(action, 0) + 1);
347             }
348         }
349         return action;
350     }
351 }
</pre>
</td>
</tr>
</table>
<center><a href="CompilationPrinter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraalCompilerOptions.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
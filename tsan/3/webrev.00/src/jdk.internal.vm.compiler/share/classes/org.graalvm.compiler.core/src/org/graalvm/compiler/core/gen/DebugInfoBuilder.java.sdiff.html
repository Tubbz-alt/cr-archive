<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/DebugInfoBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../LIRGenerationPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LIRCompilerBackend.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/DebugInfoBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 24 
 25 package org.graalvm.compiler.core.gen;
 26 
 27 import java.util.ArrayDeque;
 28 import java.util.Arrays;
 29 import java.util.Queue;
 30 
 31 import jdk.internal.vm.compiler.collections.EconomicMap;
 32 import jdk.internal.vm.compiler.collections.Equivalence;
 33 import org.graalvm.compiler.debug.CounterKey;
 34 import org.graalvm.compiler.debug.DebugContext;
 35 import org.graalvm.compiler.debug.GraalError;
 36 import org.graalvm.compiler.lir.ConstantValue;
 37 import org.graalvm.compiler.lir.LIRFrameState;
 38 import org.graalvm.compiler.lir.LabelRef;
 39 import org.graalvm.compiler.lir.Variable;
 40 import org.graalvm.compiler.nodes.ConstantNode;
 41 import org.graalvm.compiler.nodes.FrameState;
 42 import org.graalvm.compiler.nodes.ValueNode;
 43 import org.graalvm.compiler.nodes.spi.NodeValueMap;

 44 import org.graalvm.compiler.nodes.util.GraphUtil;
 45 import org.graalvm.compiler.nodes.virtual.EscapeObjectState;

 46 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;

 47 import org.graalvm.compiler.virtual.nodes.MaterializedObjectState;
 48 import org.graalvm.compiler.virtual.nodes.VirtualObjectState;
 49 
 50 import jdk.vm.ci.code.BytecodeFrame;
 51 import jdk.vm.ci.code.VirtualObject;
 52 import jdk.vm.ci.meta.JavaConstant;
 53 import jdk.vm.ci.meta.JavaKind;
 54 import jdk.vm.ci.meta.JavaType;
 55 import jdk.vm.ci.meta.JavaValue;
 56 import jdk.vm.ci.meta.ResolvedJavaField;
 57 import jdk.vm.ci.meta.ResolvedJavaType;
 58 import jdk.vm.ci.meta.Value;
 59 
 60 /**
 61  * Builds {@link LIRFrameState}s from {@link FrameState}s.
 62  */
 63 public class DebugInfoBuilder {
 64 
 65     protected final NodeValueMap nodeValueMap;
 66     protected final DebugContext debug;
 67 
 68     public DebugInfoBuilder(NodeValueMap nodeValueMap, DebugContext debug) {
 69         this.nodeValueMap = nodeValueMap;
 70         this.debug = debug;
 71     }
 72 
 73     private static final JavaValue[] NO_JAVA_VALUES = {};
 74     private static final JavaKind[] NO_JAVA_KINDS = {};
 75 
 76     protected final EconomicMap&lt;VirtualObjectNode, VirtualObject&gt; virtualObjects = EconomicMap.create(Equivalence.IDENTITY);
 77     protected final EconomicMap&lt;VirtualObjectNode, EscapeObjectState&gt; objectStates = EconomicMap.create(Equivalence.IDENTITY);
 78 
 79     protected final Queue&lt;VirtualObjectNode&gt; pendingVirtualObjects = new ArrayDeque&lt;&gt;();
 80 
<span class="line-modified"> 81     public LIRFrameState build(FrameState topState, LabelRef exceptionEdge) {</span>
 82         assert virtualObjects.size() == 0;
 83         assert objectStates.size() == 0;
 84         assert pendingVirtualObjects.size() == 0;
 85 
 86         // collect all VirtualObjectField instances:
 87         FrameState current = topState;
 88         do {
 89             if (current.virtualObjectMappingCount() &gt; 0) {
 90                 for (EscapeObjectState state : current.virtualObjectMappings()) {
 91                     if (!objectStates.containsKey(state.object())) {
 92                         if (!(state instanceof MaterializedObjectState) || ((MaterializedObjectState) state).materializedValue() != state.object()) {
 93                             objectStates.put(state.object(), state);
 94                         }
 95                     }
 96                 }
 97             }
 98             current = current.outerFrameState();
 99         } while (current != null);
100 
<span class="line-modified">101         BytecodeFrame frame = computeFrameForState(topState);</span>

102 
103         VirtualObject[] virtualObjectsArray = null;
104         if (virtualObjects.size() != 0) {
105             // fill in the VirtualObject values
106             VirtualObjectNode vobjNode;
107             while ((vobjNode = pendingVirtualObjects.poll()) != null) {
108                 VirtualObject vobjValue = virtualObjects.get(vobjNode);
109                 assert vobjValue.getValues() == null;
110 
111                 JavaValue[] values;
112                 JavaKind[] slotKinds;
113                 int entryCount = vobjNode.entryCount();
114                 if (entryCount == 0) {
115                     values = NO_JAVA_VALUES;
116                     slotKinds = NO_JAVA_KINDS;
117                 } else {
118                     values = new JavaValue[entryCount];
119                     slotKinds = new JavaKind[entryCount];
120                 }
121                 if (values.length &gt; 0) {
</pre>
<hr />
<pre>
204                     }
205                 }
206             }
207         }
208         return true;
209     }
210 
211     /*
212      * Customization point for subclasses. For example, Word types have a kind Object, but are
213      * internally stored as a primitive value. We do not know about Word types here, but subclasses
214      * do know.
215      */
216     protected JavaKind storageKind(JavaType type) {
217         return type.getJavaKind();
218     }
219 
220     protected LIRFrameState newLIRFrameState(LabelRef exceptionEdge, BytecodeFrame frame, VirtualObject[] virtualObjectsArray) {
221         return new LIRFrameState(frame, virtualObjectsArray, exceptionEdge);
222     }
223 
<span class="line-modified">224     protected BytecodeFrame computeFrameForState(FrameState state) {</span>











225         try {
226             assert state.bci != BytecodeFrame.INVALID_FRAMESTATE_BCI;
227             assert state.bci != BytecodeFrame.UNKNOWN_BCI;
228             assert state.bci != BytecodeFrame.BEFORE_BCI || state.locksSize() == 0;
229             assert state.bci != BytecodeFrame.AFTER_BCI || state.locksSize() == 0;
230             assert state.bci != BytecodeFrame.AFTER_EXCEPTION_BCI || state.locksSize() == 0;
231             assert !(state.getMethod().isSynchronized() &amp;&amp; state.bci != BytecodeFrame.BEFORE_BCI &amp;&amp; state.bci != BytecodeFrame.AFTER_BCI &amp;&amp; state.bci != BytecodeFrame.AFTER_EXCEPTION_BCI) ||
232                             state.locksSize() &gt; 0;
233             assert state.verify();
234 
235             int numLocals = state.localsSize();
236             int numStack = state.stackSize();
237             int numLocks = state.locksSize();
238 
239             int numValues = numLocals + numStack + numLocks;
240             int numKinds = numLocals + numStack;
241 
242             JavaValue[] values = numValues == 0 ? NO_JAVA_VALUES : new JavaValue[numValues];
243             JavaKind[] slotKinds = numKinds == 0 ? NO_JAVA_KINDS : new JavaKind[numKinds];
244             computeLocals(state, numLocals, values, slotKinds);
245             computeStack(state, numLocals, numStack, values, slotKinds);
246             computeLocks(state, values);
247 
248             BytecodeFrame caller = null;
249             if (state.outerFrameState() != null) {
<span class="line-modified">250                 caller = computeFrameForState(state.outerFrameState());</span>
251             }
252 
253             if (!state.canProduceBytecodeFrame()) {
254                 // This typically means a snippet or intrinsic frame state made it to the backend
<span class="line-modified">255                 StackTraceElement ste = state.getCode().asStackTraceElement(state.bci);</span>
256                 throw new GraalError(&quot;Frame state for %s cannot be converted to a BytecodeFrame since the frame state&#39;s code is &quot; +
257                                 &quot;not the same as the frame state method&#39;s code&quot;, ste);
258             }
259 
260             return new BytecodeFrame(caller, state.getMethod(), state.bci, state.rethrowException(), state.duringCall(), values, slotKinds, numLocals, numStack, numLocks);
261         } catch (GraalError e) {
262             throw e.addContext(&quot;FrameState: &quot;, state);
263         }
264     }
265 
266     protected void computeLocals(FrameState state, int numLocals, JavaValue[] values, JavaKind[] slotKinds) {
267         for (int i = 0; i &lt; numLocals; i++) {
268             ValueNode local = state.localAt(i);
269             values[i] = toJavaValue(local);
270             slotKinds[i] = toSlotKind(local);
271         }
272     }
273 
274     protected void computeStack(FrameState state, int numLocals, int numStack, JavaValue[] values, JavaKind[] slotKinds) {
275         for (int i = 0; i &lt; numStack; i++) {
</pre>
<hr />
<pre>
300         } else {
301             return value.getStackKind();
302         }
303     }
304 
305     protected JavaValue toJavaValue(ValueNode value) {
306         try {
307             if (value instanceof VirtualObjectNode) {
308                 VirtualObjectNode obj = (VirtualObjectNode) value;
309                 EscapeObjectState state = objectStates.get(obj);
310                 if (state == null &amp;&amp; obj.entryCount() &gt; 0) {
311                     // null states occur for objects with 0 fields
312                     throw new GraalError(&quot;no mapping found for virtual object %s&quot;, obj);
313                 }
314                 if (state instanceof MaterializedObjectState) {
315                     return toJavaValue(((MaterializedObjectState) state).materializedValue());
316                 } else {
317                     assert obj.entryCount() == 0 || state instanceof VirtualObjectState;
318                     VirtualObject vobject = virtualObjects.get(obj);
319                     if (vobject == null) {
<span class="line-modified">320                         vobject = VirtualObject.get(obj.type(), virtualObjects.size());</span>

321                         virtualObjects.put(obj, vobject);
322                         pendingVirtualObjects.add(obj);
323                     }
324                     STATE_VIRTUAL_OBJECTS.increment(debug);
325                     return vobject;
326                 }
327             } else {
328                 // Remove proxies from constants so the constant can be directly embedded.
329                 ValueNode unproxied = GraphUtil.unproxify(value);
330                 if (unproxied instanceof ConstantNode) {
331                     STATE_CONSTANTS.increment(debug);
332                     return unproxied.asJavaConstant();
333 
334                 } else if (value != null) {
335                     STATE_VARIABLES.increment(debug);
336                     Value operand = nodeValueMap.operand(value);
337                     if (operand instanceof ConstantValue &amp;&amp; ((ConstantValue) operand).isJavaConstant()) {
338                         return ((ConstantValue) operand).getJavaConstant();
339                     } else {
340                         assert operand instanceof Variable : operand + &quot; for &quot; + value;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 24 
 25 package org.graalvm.compiler.core.gen;
 26 
 27 import java.util.ArrayDeque;
 28 import java.util.Arrays;
 29 import java.util.Queue;
 30 
 31 import jdk.internal.vm.compiler.collections.EconomicMap;
 32 import jdk.internal.vm.compiler.collections.Equivalence;
 33 import org.graalvm.compiler.debug.CounterKey;
 34 import org.graalvm.compiler.debug.DebugContext;
 35 import org.graalvm.compiler.debug.GraalError;
 36 import org.graalvm.compiler.lir.ConstantValue;
 37 import org.graalvm.compiler.lir.LIRFrameState;
 38 import org.graalvm.compiler.lir.LabelRef;
 39 import org.graalvm.compiler.lir.Variable;
 40 import org.graalvm.compiler.nodes.ConstantNode;
 41 import org.graalvm.compiler.nodes.FrameState;
 42 import org.graalvm.compiler.nodes.ValueNode;
 43 import org.graalvm.compiler.nodes.spi.NodeValueMap;
<span class="line-added"> 44 import org.graalvm.compiler.nodes.spi.NodeWithState;</span>
 45 import org.graalvm.compiler.nodes.util.GraphUtil;
 46 import org.graalvm.compiler.nodes.virtual.EscapeObjectState;
<span class="line-added"> 47 import org.graalvm.compiler.nodes.virtual.VirtualBoxingNode;</span>
 48 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
<span class="line-added"> 49 import org.graalvm.compiler.serviceprovider.GraalServices;</span>
 50 import org.graalvm.compiler.virtual.nodes.MaterializedObjectState;
 51 import org.graalvm.compiler.virtual.nodes.VirtualObjectState;
 52 
 53 import jdk.vm.ci.code.BytecodeFrame;
 54 import jdk.vm.ci.code.VirtualObject;
 55 import jdk.vm.ci.meta.JavaConstant;
 56 import jdk.vm.ci.meta.JavaKind;
 57 import jdk.vm.ci.meta.JavaType;
 58 import jdk.vm.ci.meta.JavaValue;
 59 import jdk.vm.ci.meta.ResolvedJavaField;
 60 import jdk.vm.ci.meta.ResolvedJavaType;
 61 import jdk.vm.ci.meta.Value;
 62 
 63 /**
 64  * Builds {@link LIRFrameState}s from {@link FrameState}s.
 65  */
 66 public class DebugInfoBuilder {
 67 
 68     protected final NodeValueMap nodeValueMap;
 69     protected final DebugContext debug;
 70 
 71     public DebugInfoBuilder(NodeValueMap nodeValueMap, DebugContext debug) {
 72         this.nodeValueMap = nodeValueMap;
 73         this.debug = debug;
 74     }
 75 
 76     private static final JavaValue[] NO_JAVA_VALUES = {};
 77     private static final JavaKind[] NO_JAVA_KINDS = {};
 78 
 79     protected final EconomicMap&lt;VirtualObjectNode, VirtualObject&gt; virtualObjects = EconomicMap.create(Equivalence.IDENTITY);
 80     protected final EconomicMap&lt;VirtualObjectNode, EscapeObjectState&gt; objectStates = EconomicMap.create(Equivalence.IDENTITY);
 81 
 82     protected final Queue&lt;VirtualObjectNode&gt; pendingVirtualObjects = new ArrayDeque&lt;&gt;();
 83 
<span class="line-modified"> 84     public LIRFrameState build(NodeWithState node, FrameState topState, LabelRef exceptionEdge) {</span>
 85         assert virtualObjects.size() == 0;
 86         assert objectStates.size() == 0;
 87         assert pendingVirtualObjects.size() == 0;
 88 
 89         // collect all VirtualObjectField instances:
 90         FrameState current = topState;
 91         do {
 92             if (current.virtualObjectMappingCount() &gt; 0) {
 93                 for (EscapeObjectState state : current.virtualObjectMappings()) {
 94                     if (!objectStates.containsKey(state.object())) {
 95                         if (!(state instanceof MaterializedObjectState) || ((MaterializedObjectState) state).materializedValue() != state.object()) {
 96                             objectStates.put(state.object(), state);
 97                         }
 98                     }
 99                 }
100             }
101             current = current.outerFrameState();
102         } while (current != null);
103 
<span class="line-modified">104         assert verifyFrameState(node, topState);</span>
<span class="line-added">105         BytecodeFrame frame = computeFrameForState(node, topState);</span>
106 
107         VirtualObject[] virtualObjectsArray = null;
108         if (virtualObjects.size() != 0) {
109             // fill in the VirtualObject values
110             VirtualObjectNode vobjNode;
111             while ((vobjNode = pendingVirtualObjects.poll()) != null) {
112                 VirtualObject vobjValue = virtualObjects.get(vobjNode);
113                 assert vobjValue.getValues() == null;
114 
115                 JavaValue[] values;
116                 JavaKind[] slotKinds;
117                 int entryCount = vobjNode.entryCount();
118                 if (entryCount == 0) {
119                     values = NO_JAVA_VALUES;
120                     slotKinds = NO_JAVA_KINDS;
121                 } else {
122                     values = new JavaValue[entryCount];
123                     slotKinds = new JavaKind[entryCount];
124                 }
125                 if (values.length &gt; 0) {
</pre>
<hr />
<pre>
208                     }
209                 }
210             }
211         }
212         return true;
213     }
214 
215     /*
216      * Customization point for subclasses. For example, Word types have a kind Object, but are
217      * internally stored as a primitive value. We do not know about Word types here, but subclasses
218      * do know.
219      */
220     protected JavaKind storageKind(JavaType type) {
221         return type.getJavaKind();
222     }
223 
224     protected LIRFrameState newLIRFrameState(LabelRef exceptionEdge, BytecodeFrame frame, VirtualObject[] virtualObjectsArray) {
225         return new LIRFrameState(frame, virtualObjectsArray, exceptionEdge);
226     }
227 
<span class="line-modified">228     /**</span>
<span class="line-added">229      * Perform platform dependent verification of the FrameState.</span>
<span class="line-added">230      *</span>
<span class="line-added">231      * @param node the node using the state</span>
<span class="line-added">232      * @param topState the state</span>
<span class="line-added">233      * @return true if the validation succeeded</span>
<span class="line-added">234      */</span>
<span class="line-added">235     protected boolean verifyFrameState(NodeWithState node, FrameState topState) {</span>
<span class="line-added">236         return true;</span>
<span class="line-added">237     }</span>
<span class="line-added">238 </span>
<span class="line-added">239     protected BytecodeFrame computeFrameForState(NodeWithState node, FrameState state) {</span>
240         try {
241             assert state.bci != BytecodeFrame.INVALID_FRAMESTATE_BCI;
242             assert state.bci != BytecodeFrame.UNKNOWN_BCI;
243             assert state.bci != BytecodeFrame.BEFORE_BCI || state.locksSize() == 0;
244             assert state.bci != BytecodeFrame.AFTER_BCI || state.locksSize() == 0;
245             assert state.bci != BytecodeFrame.AFTER_EXCEPTION_BCI || state.locksSize() == 0;
246             assert !(state.getMethod().isSynchronized() &amp;&amp; state.bci != BytecodeFrame.BEFORE_BCI &amp;&amp; state.bci != BytecodeFrame.AFTER_BCI &amp;&amp; state.bci != BytecodeFrame.AFTER_EXCEPTION_BCI) ||
247                             state.locksSize() &gt; 0;
248             assert state.verify();
249 
250             int numLocals = state.localsSize();
251             int numStack = state.stackSize();
252             int numLocks = state.locksSize();
253 
254             int numValues = numLocals + numStack + numLocks;
255             int numKinds = numLocals + numStack;
256 
257             JavaValue[] values = numValues == 0 ? NO_JAVA_VALUES : new JavaValue[numValues];
258             JavaKind[] slotKinds = numKinds == 0 ? NO_JAVA_KINDS : new JavaKind[numKinds];
259             computeLocals(state, numLocals, values, slotKinds);
260             computeStack(state, numLocals, numStack, values, slotKinds);
261             computeLocks(state, values);
262 
263             BytecodeFrame caller = null;
264             if (state.outerFrameState() != null) {
<span class="line-modified">265                 caller = computeFrameForState(node, state.outerFrameState());</span>
266             }
267 
268             if (!state.canProduceBytecodeFrame()) {
269                 // This typically means a snippet or intrinsic frame state made it to the backend
<span class="line-modified">270                 String ste = state.getCode() != null ? state.getCode().asStackTraceElement(state.bci).toString() : state.toString();</span>
271                 throw new GraalError(&quot;Frame state for %s cannot be converted to a BytecodeFrame since the frame state&#39;s code is &quot; +
272                                 &quot;not the same as the frame state method&#39;s code&quot;, ste);
273             }
274 
275             return new BytecodeFrame(caller, state.getMethod(), state.bci, state.rethrowException(), state.duringCall(), values, slotKinds, numLocals, numStack, numLocks);
276         } catch (GraalError e) {
277             throw e.addContext(&quot;FrameState: &quot;, state);
278         }
279     }
280 
281     protected void computeLocals(FrameState state, int numLocals, JavaValue[] values, JavaKind[] slotKinds) {
282         for (int i = 0; i &lt; numLocals; i++) {
283             ValueNode local = state.localAt(i);
284             values[i] = toJavaValue(local);
285             slotKinds[i] = toSlotKind(local);
286         }
287     }
288 
289     protected void computeStack(FrameState state, int numLocals, int numStack, JavaValue[] values, JavaKind[] slotKinds) {
290         for (int i = 0; i &lt; numStack; i++) {
</pre>
<hr />
<pre>
315         } else {
316             return value.getStackKind();
317         }
318     }
319 
320     protected JavaValue toJavaValue(ValueNode value) {
321         try {
322             if (value instanceof VirtualObjectNode) {
323                 VirtualObjectNode obj = (VirtualObjectNode) value;
324                 EscapeObjectState state = objectStates.get(obj);
325                 if (state == null &amp;&amp; obj.entryCount() &gt; 0) {
326                     // null states occur for objects with 0 fields
327                     throw new GraalError(&quot;no mapping found for virtual object %s&quot;, obj);
328                 }
329                 if (state instanceof MaterializedObjectState) {
330                     return toJavaValue(((MaterializedObjectState) state).materializedValue());
331                 } else {
332                     assert obj.entryCount() == 0 || state instanceof VirtualObjectState;
333                     VirtualObject vobject = virtualObjects.get(obj);
334                     if (vobject == null) {
<span class="line-modified">335                         boolean isAutoBox = obj instanceof VirtualBoxingNode;</span>
<span class="line-added">336                         vobject = GraalServices.createVirtualObject(obj.type(), virtualObjects.size(), isAutoBox);</span>
337                         virtualObjects.put(obj, vobject);
338                         pendingVirtualObjects.add(obj);
339                     }
340                     STATE_VIRTUAL_OBJECTS.increment(debug);
341                     return vobject;
342                 }
343             } else {
344                 // Remove proxies from constants so the constant can be directly embedded.
345                 ValueNode unproxied = GraphUtil.unproxify(value);
346                 if (unproxied instanceof ConstantNode) {
347                     STATE_CONSTANTS.increment(debug);
348                     return unproxied.asJavaConstant();
349 
350                 } else if (value != null) {
351                     STATE_VARIABLES.increment(debug);
352                     Value operand = nodeValueMap.operand(value);
353                     if (operand instanceof ConstantValue &amp;&amp; ((ConstantValue) operand).isJavaConstant()) {
354                         return ((ConstantValue) operand).getJavaConstant();
355                     } else {
356                         assert operand instanceof Variable : operand + &quot; for &quot; + value;
</pre>
</td>
</tr>
</table>
<center><a href="../LIRGenerationPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LIRCompilerBackend.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/DebugInfoBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../LIRGenerationPhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LIRCompilerBackend.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/DebugInfoBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 39,13 ***</span>
<span class="line-new-header">--- 39,16 ---</span>
  import org.graalvm.compiler.lir.Variable;
  import org.graalvm.compiler.nodes.ConstantNode;
  import org.graalvm.compiler.nodes.FrameState;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.spi.NodeValueMap;
<span class="line-added">+ import org.graalvm.compiler.nodes.spi.NodeWithState;</span>
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.nodes.virtual.EscapeObjectState;
<span class="line-added">+ import org.graalvm.compiler.nodes.virtual.VirtualBoxingNode;</span>
  import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
<span class="line-added">+ import org.graalvm.compiler.serviceprovider.GraalServices;</span>
  import org.graalvm.compiler.virtual.nodes.MaterializedObjectState;
  import org.graalvm.compiler.virtual.nodes.VirtualObjectState;
  
  import jdk.vm.ci.code.BytecodeFrame;
  import jdk.vm.ci.code.VirtualObject;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 76,11 ***</span>
      protected final EconomicMap&lt;VirtualObjectNode, VirtualObject&gt; virtualObjects = EconomicMap.create(Equivalence.IDENTITY);
      protected final EconomicMap&lt;VirtualObjectNode, EscapeObjectState&gt; objectStates = EconomicMap.create(Equivalence.IDENTITY);
  
      protected final Queue&lt;VirtualObjectNode&gt; pendingVirtualObjects = new ArrayDeque&lt;&gt;();
  
<span class="line-modified">!     public LIRFrameState build(FrameState topState, LabelRef exceptionEdge) {</span>
          assert virtualObjects.size() == 0;
          assert objectStates.size() == 0;
          assert pendingVirtualObjects.size() == 0;
  
          // collect all VirtualObjectField instances:
<span class="line-new-header">--- 79,11 ---</span>
      protected final EconomicMap&lt;VirtualObjectNode, VirtualObject&gt; virtualObjects = EconomicMap.create(Equivalence.IDENTITY);
      protected final EconomicMap&lt;VirtualObjectNode, EscapeObjectState&gt; objectStates = EconomicMap.create(Equivalence.IDENTITY);
  
      protected final Queue&lt;VirtualObjectNode&gt; pendingVirtualObjects = new ArrayDeque&lt;&gt;();
  
<span class="line-modified">!     public LIRFrameState build(NodeWithState node, FrameState topState, LabelRef exceptionEdge) {</span>
          assert virtualObjects.size() == 0;
          assert objectStates.size() == 0;
          assert pendingVirtualObjects.size() == 0;
  
          // collect all VirtualObjectField instances:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,11 ***</span>
                  }
              }
              current = current.outerFrameState();
          } while (current != null);
  
<span class="line-modified">!         BytecodeFrame frame = computeFrameForState(topState);</span>
  
          VirtualObject[] virtualObjectsArray = null;
          if (virtualObjects.size() != 0) {
              // fill in the VirtualObject values
              VirtualObjectNode vobjNode;
<span class="line-new-header">--- 99,12 ---</span>
                  }
              }
              current = current.outerFrameState();
          } while (current != null);
  
<span class="line-modified">!         assert verifyFrameState(node, topState);</span>
<span class="line-added">+         BytecodeFrame frame = computeFrameForState(node, topState);</span>
  
          VirtualObject[] virtualObjectsArray = null;
          if (virtualObjects.size() != 0) {
              // fill in the VirtualObject values
              VirtualObjectNode vobjNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 219,11 ***</span>
  
      protected LIRFrameState newLIRFrameState(LabelRef exceptionEdge, BytecodeFrame frame, VirtualObject[] virtualObjectsArray) {
          return new LIRFrameState(frame, virtualObjectsArray, exceptionEdge);
      }
  
<span class="line-modified">!     protected BytecodeFrame computeFrameForState(FrameState state) {</span>
          try {
              assert state.bci != BytecodeFrame.INVALID_FRAMESTATE_BCI;
              assert state.bci != BytecodeFrame.UNKNOWN_BCI;
              assert state.bci != BytecodeFrame.BEFORE_BCI || state.locksSize() == 0;
              assert state.bci != BytecodeFrame.AFTER_BCI || state.locksSize() == 0;
<span class="line-new-header">--- 223,22 ---</span>
  
      protected LIRFrameState newLIRFrameState(LabelRef exceptionEdge, BytecodeFrame frame, VirtualObject[] virtualObjectsArray) {
          return new LIRFrameState(frame, virtualObjectsArray, exceptionEdge);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Perform platform dependent verification of the FrameState.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param node the node using the state</span>
<span class="line-added">+      * @param topState the state</span>
<span class="line-added">+      * @return true if the validation succeeded</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected boolean verifyFrameState(NodeWithState node, FrameState topState) {</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     protected BytecodeFrame computeFrameForState(NodeWithState node, FrameState state) {</span>
          try {
              assert state.bci != BytecodeFrame.INVALID_FRAMESTATE_BCI;
              assert state.bci != BytecodeFrame.UNKNOWN_BCI;
              assert state.bci != BytecodeFrame.BEFORE_BCI || state.locksSize() == 0;
              assert state.bci != BytecodeFrame.AFTER_BCI || state.locksSize() == 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,16 ***</span>
              computeStack(state, numLocals, numStack, values, slotKinds);
              computeLocks(state, values);
  
              BytecodeFrame caller = null;
              if (state.outerFrameState() != null) {
<span class="line-modified">!                 caller = computeFrameForState(state.outerFrameState());</span>
              }
  
              if (!state.canProduceBytecodeFrame()) {
                  // This typically means a snippet or intrinsic frame state made it to the backend
<span class="line-modified">!                 StackTraceElement ste = state.getCode().asStackTraceElement(state.bci);</span>
                  throw new GraalError(&quot;Frame state for %s cannot be converted to a BytecodeFrame since the frame state&#39;s code is &quot; +
                                  &quot;not the same as the frame state method&#39;s code&quot;, ste);
              }
  
              return new BytecodeFrame(caller, state.getMethod(), state.bci, state.rethrowException(), state.duringCall(), values, slotKinds, numLocals, numStack, numLocks);
<span class="line-new-header">--- 260,16 ---</span>
              computeStack(state, numLocals, numStack, values, slotKinds);
              computeLocks(state, values);
  
              BytecodeFrame caller = null;
              if (state.outerFrameState() != null) {
<span class="line-modified">!                 caller = computeFrameForState(node, state.outerFrameState());</span>
              }
  
              if (!state.canProduceBytecodeFrame()) {
                  // This typically means a snippet or intrinsic frame state made it to the backend
<span class="line-modified">!                 String ste = state.getCode() != null ? state.getCode().asStackTraceElement(state.bci).toString() : state.toString();</span>
                  throw new GraalError(&quot;Frame state for %s cannot be converted to a BytecodeFrame since the frame state&#39;s code is &quot; +
                                  &quot;not the same as the frame state method&#39;s code&quot;, ste);
              }
  
              return new BytecodeFrame(caller, state.getMethod(), state.bci, state.rethrowException(), state.duringCall(), values, slotKinds, numLocals, numStack, numLocks);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 315,11 ***</span>
                      return toJavaValue(((MaterializedObjectState) state).materializedValue());
                  } else {
                      assert obj.entryCount() == 0 || state instanceof VirtualObjectState;
                      VirtualObject vobject = virtualObjects.get(obj);
                      if (vobject == null) {
<span class="line-modified">!                         vobject = VirtualObject.get(obj.type(), virtualObjects.size());</span>
                          virtualObjects.put(obj, vobject);
                          pendingVirtualObjects.add(obj);
                      }
                      STATE_VIRTUAL_OBJECTS.increment(debug);
                      return vobject;
<span class="line-new-header">--- 330,12 ---</span>
                      return toJavaValue(((MaterializedObjectState) state).materializedValue());
                  } else {
                      assert obj.entryCount() == 0 || state instanceof VirtualObjectState;
                      VirtualObject vobject = virtualObjects.get(obj);
                      if (vobject == null) {
<span class="line-modified">!                         boolean isAutoBox = obj instanceof VirtualBoxingNode;</span>
<span class="line-added">+                         vobject = GraalServices.createVirtualObject(obj.type(), virtualObjects.size(), isAutoBox);</span>
                          virtualObjects.put(obj, vobject);
                          pendingVirtualObjects.add(obj);
                      }
                      STATE_VIRTUAL_OBJECTS.increment(debug);
                      return vobject;
</pre>
<center><a href="../LIRGenerationPhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LIRCompilerBackend.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
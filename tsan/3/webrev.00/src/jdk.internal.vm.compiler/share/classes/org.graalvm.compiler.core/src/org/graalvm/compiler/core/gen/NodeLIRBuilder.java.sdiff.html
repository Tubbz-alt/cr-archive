<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LIRGenerationProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeMatchRules.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 31 import static org.graalvm.compiler.core.common.SpeculativeExecutionAttacksMitigations.Options.MitigateSpeculativeExecutionAttacks;
 32 import static org.graalvm.compiler.core.common.GraalOptions.MatchExpressions;
 33 import static org.graalvm.compiler.debug.DebugOptions.LogVerbose;
 34 import static org.graalvm.compiler.lir.LIR.verifyBlock;
 35 
 36 import java.util.ArrayList;
 37 import java.util.Collection;
 38 import java.util.List;
 39 
 40 import jdk.internal.vm.compiler.collections.EconomicMap;
 41 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
 42 import org.graalvm.compiler.core.common.LIRKind;
 43 import org.graalvm.compiler.core.common.calc.Condition;
 44 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 45 import org.graalvm.compiler.core.common.cfg.BlockMap;
 46 import org.graalvm.compiler.core.common.type.Stamp;
 47 import org.graalvm.compiler.core.match.ComplexMatchValue;
 48 import org.graalvm.compiler.core.match.MatchPattern;
 49 import org.graalvm.compiler.core.match.MatchRuleRegistry;
 50 import org.graalvm.compiler.core.match.MatchStatement;

 51 import org.graalvm.compiler.debug.DebugContext;
 52 import org.graalvm.compiler.debug.GraalError;
 53 import org.graalvm.compiler.debug.TTY;
 54 import org.graalvm.compiler.graph.GraalGraphError;
 55 import org.graalvm.compiler.graph.Node;
 56 import org.graalvm.compiler.graph.NodeMap;
 57 import org.graalvm.compiler.graph.NodeSourcePosition;
 58 import org.graalvm.compiler.graph.iterators.NodeIterable;
 59 import org.graalvm.compiler.lir.FullInfopointOp;
 60 import org.graalvm.compiler.lir.LIRFrameState;
 61 import org.graalvm.compiler.lir.LIRInstruction;
 62 import org.graalvm.compiler.lir.LabelRef;
 63 import org.graalvm.compiler.lir.StandardOp.JumpOp;
 64 import org.graalvm.compiler.lir.StandardOp.LabelOp;
 65 import org.graalvm.compiler.lir.SwitchStrategy;
 66 import org.graalvm.compiler.lir.Variable;
 67 import org.graalvm.compiler.lir.debug.LIRGenerationDebugContext;
 68 import org.graalvm.compiler.lir.framemap.FrameMapBuilder;
 69 import org.graalvm.compiler.lir.gen.LIRGenerator;
 70 import org.graalvm.compiler.lir.gen.LIRGenerator.Options;
</pre>
<hr />
<pre>
 86 import org.graalvm.compiler.nodes.LogicNode;
 87 import org.graalvm.compiler.nodes.LoopEndNode;
 88 import org.graalvm.compiler.nodes.LoweredCallTargetNode;
 89 import org.graalvm.compiler.nodes.NodeView;
 90 import org.graalvm.compiler.nodes.ParameterNode;
 91 import org.graalvm.compiler.nodes.PhiNode;
 92 import org.graalvm.compiler.nodes.StructuredGraph;
 93 import org.graalvm.compiler.nodes.ValueNode;
 94 import org.graalvm.compiler.nodes.ValuePhiNode;
 95 import org.graalvm.compiler.nodes.calc.CompareNode;
 96 import org.graalvm.compiler.nodes.calc.ConditionalNode;
 97 import org.graalvm.compiler.nodes.calc.IntegerTestNode;
 98 import org.graalvm.compiler.nodes.calc.IsNullNode;
 99 import org.graalvm.compiler.nodes.cfg.Block;
100 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
101 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
102 import org.graalvm.compiler.nodes.extended.SwitchNode;
103 import org.graalvm.compiler.nodes.spi.LIRLowerable;
104 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
105 import org.graalvm.compiler.nodes.spi.NodeValueMap;

106 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
107 import org.graalvm.compiler.options.OptionValues;
108 
109 import jdk.vm.ci.code.CallingConvention;
110 import jdk.vm.ci.code.StackSlot;
111 import jdk.vm.ci.code.ValueUtil;
112 import jdk.vm.ci.meta.AllocatableValue;
113 import jdk.vm.ci.meta.Constant;
114 import jdk.vm.ci.meta.JavaConstant;
115 import jdk.vm.ci.meta.JavaKind;
116 import jdk.vm.ci.meta.PlatformKind;
117 import jdk.vm.ci.meta.Value;
118 
119 /**
120  * This class traverses the HIR instructions and generates LIR instructions from them.
121  */
122 public abstract class NodeLIRBuilder implements NodeLIRBuilderTool, LIRGenerationDebugContext {
123 
124     private final NodeMap&lt;Value&gt; nodeOperands;
125     private final DebugInfoBuilder debugInfoBuilder;
</pre>
<hr />
<pre>
238     public final void append(LIRInstruction op) {
239         if (Options.PrintIRWithLIR.getValue(nodeOperands.graph().getOptions()) &amp;&amp; !TTY.isSuppressed()) {
240             if (currentInstruction != null &amp;&amp; lastInstructionPrinted != currentInstruction) {
241                 lastInstructionPrinted = currentInstruction;
242                 InstructionPrinter ip = new InstructionPrinter(TTY.out());
243                 ip.printInstructionListing(currentInstruction);
244             }
245         }
246         gen.append(op);
247     }
248 
249     protected LIRKind getExactPhiKind(PhiNode phi) {
250         LIRKind derivedKind = gen.toRegisterKind(gen.getLIRKind(phi.stamp(NodeView.DEFAULT)));
251         /* Collect reference information. */
252         for (int i = 0; i &lt; phi.valueCount() &amp;&amp; !derivedKind.isUnknownReference(); i++) {
253             ValueNode node = phi.valueAt(i);
254             Value value = getOperand(node);
255 
256             // get ValueKind for input
257             final LIRKind valueKind;
<span class="line-modified">258             if (value != null) {</span>
259                 valueKind = value.getValueKind(LIRKind.class);
260             } else {
261                 assert isPhiInputFromBackedge(phi, i) : String.format(&quot;Input %s to phi node %s is not yet available although it is not coming from a loop back edge&quot;, node, phi);
262                 LIRKind kind = gen.getLIRKind(node.stamp(NodeView.DEFAULT));
263                 valueKind = gen.toRegisterKind(kind);
264             }
265             /* Merge the reference information of the derived kind and the input. */
266             derivedKind = LIRKind.mergeReferenceInformation(derivedKind, valueKind);
267         }
268         return derivedKind;
269     }
270 
271     private static boolean isPhiInputFromBackedge(PhiNode phi, int index) {
272         AbstractMergeNode merge = phi.merge();
273         AbstractEndNode end = merge.phiPredecessorAt(index);
274         return end instanceof LoopEndNode &amp;&amp; ((LoopEndNode) end).loopBegin().equals(merge);
275     }
276 
277     private Value[] createPhiIn(AbstractMergeNode merge) {
278         List&lt;Value&gt; values = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
341                 assert block.getPredecessorCount() == 0;
342                 emitPrologue(graph);
343             } else {
344                 assert block.getPredecessorCount() &gt; 0;
345                 // create phi-in value array
346                 AbstractBeginNode begin = block.getBeginNode();
347                 if (begin instanceof AbstractMergeNode) {
348                     AbstractMergeNode merge = (AbstractMergeNode) begin;
349                     LabelOp label = (LabelOp) gen.getResult().getLIR().getLIRforBlock(block).get(0);
350                     label.setPhiValues(createPhiIn(merge));
351                     if (Options.PrintIRWithLIR.getValue(options) &amp;&amp; !TTY.isSuppressed()) {
352                         TTY.println(&quot;Created PhiIn: &quot; + label);
353 
354                     }
355                 }
356             }
357             doBlockPrologue(block, options);
358 
359             List&lt;Node&gt; nodes = blockMap.get(block);
360 
<span class="line-removed">361             // Allow NodeLIRBuilder subclass to specialize code generation of any interesting groups</span>
<span class="line-removed">362             // of instructions</span>
<span class="line-removed">363             matchComplexExpressions(nodes);</span>
<span class="line-removed">364 </span>
365             boolean trace = traceLIRGeneratorLevel &gt;= 3;
366             for (int i = 0; i &lt; nodes.size(); i++) {
367                 Node node = nodes.get(i);
368                 if (node instanceof ValueNode) {
369                     setSourcePosition(node.getNodeSourcePosition());
370                     DebugContext debug = node.getDebug();
371                     ValueNode valueNode = (ValueNode) node;
372                     if (trace) {
373                         TTY.println(&quot;LIRGen for &quot; + valueNode);
374                     }
375                     Value operand = getOperand(valueNode);
376                     if (operand == null) {
377                         if (!peephole(valueNode)) {
378                             try {
379                                 doRoot(valueNode);
380                             } catch (GraalError e) {
381                                 throw GraalGraphError.transformAndAddContext(e, valueNode);
382                             } catch (Throwable e) {
383                                 throw new GraalGraphError(e).addContext(valueNode);
384                             }
</pre>
<hr />
<pre>
402                 }
403             }
404 
405             if (!gen.hasBlockEnd(block)) {
406                 NodeIterable&lt;Node&gt; successors = block.getEndNode().successors();
407                 assert successors.count() == block.getSuccessorCount();
408                 if (block.getSuccessorCount() != 1) {
409                     /*
410                      * If we have more than one successor, we cannot just use the first one. Since
411                      * successors are unordered, this would be a random choice.
412                      */
413                     throw new GraalError(&quot;Block without BlockEndOp: &quot; + block.getEndNode());
414                 }
415                 gen.emitJump(getLIRBlock((FixedNode) successors.first()));
416             }
417 
418             assert verifyBlock(gen.getResult().getLIR(), block);
419         }
420     }
421 

422     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">423     protected void matchComplexExpressions(List&lt;Node&gt; nodes) {</span>










424         if (matchRules != null) {
425             DebugContext debug = gen.getResult().getLIR().getDebug();
426             try (DebugContext.Scope s = debug.scope(&quot;MatchComplexExpressions&quot;)) {

427                 if (LogVerbose.getValue(nodeOperands.graph().getOptions())) {
428                     int i = 0;
429                     for (Node node : nodes) {
430                         debug.log(&quot;%d: (%s) %1S&quot;, i++, node.getUsageCount(), node);
431                     }
432                 }
433 
434                 // Match the nodes in backwards order to encourage longer matches.
435                 for (int index = nodes.size() - 1; index &gt;= 0; index--) {
436                     Node node = nodes.get(index);
437                     if (getOperand(node) != null) {
438                         continue;
439                     }
440                     // See if this node is the root of any MatchStatements
441                     List&lt;MatchStatement&gt; statements = matchRules.get(node.getClass());
442                     if (statements != null) {
443                         for (MatchStatement statement : statements) {
<span class="line-modified">444                             if (statement.generate(this, index, node, nodes)) {</span>
445                                 // Found a match so skip to the next
446                                 break;
447                             }
448                         }
449                     }
450                 }
451             }
452         }
453     }
454 
455     protected abstract boolean peephole(ValueNode valueNode);
456 
457     private void doRoot(ValueNode instr) {
458         if (traceLIRGeneratorLevel &gt;= 2) {
459             TTY.println(&quot;Emitting LIR for instruction &quot; + instr);
460         }
461         currentInstruction = instr;
462         DebugContext debug = instr.getDebug();
463         debug.log(&quot;Visiting %s&quot;, instr);
464         emitNode(instr);
</pre>
<hr />
<pre>
709     }
710 
711     private static FrameState getFrameState(DeoptimizingNode deopt) {
712         if (deopt instanceof DeoptimizingNode.DeoptBefore) {
713             assert !(deopt instanceof DeoptimizingNode.DeoptDuring || deopt instanceof DeoptimizingNode.DeoptAfter);
714             return ((DeoptimizingNode.DeoptBefore) deopt).stateBefore();
715         } else if (deopt instanceof DeoptimizingNode.DeoptDuring) {
716             assert !(deopt instanceof DeoptimizingNode.DeoptAfter);
717             return ((DeoptimizingNode.DeoptDuring) deopt).stateDuring();
718         } else {
719             assert deopt instanceof DeoptimizingNode.DeoptAfter;
720             return ((DeoptimizingNode.DeoptAfter) deopt).stateAfter();
721         }
722     }
723 
724     @Override
725     public LIRFrameState state(DeoptimizingNode deopt) {
726         if (!deopt.canDeoptimize()) {
727             return null;
728         }
<span class="line-modified">729         return stateFor(getFrameState(deopt));</span>
730     }
731 
732     public LIRFrameState stateWithExceptionEdge(DeoptimizingNode deopt, LabelRef exceptionEdge) {
733         if (!deopt.canDeoptimize()) {
734             return null;
735         }
<span class="line-modified">736         return stateForWithExceptionEdge(getFrameState(deopt), exceptionEdge);</span>
737     }
738 
<span class="line-modified">739     public LIRFrameState stateFor(FrameState state) {</span>
<span class="line-modified">740         return stateForWithExceptionEdge(state, null);</span>
741     }
742 
<span class="line-modified">743     public LIRFrameState stateForWithExceptionEdge(FrameState state, LabelRef exceptionEdge) {</span>
744         if (gen.needOnlyOopMaps()) {
745             return new LIRFrameState(null, null, null);
746         }
<span class="line-modified">747         assert state != null;</span>
<span class="line-modified">748         return getDebugInfoBuilder().build(state, exceptionEdge);</span>
749     }
750 
751     @Override
752     public void emitOverflowCheckBranch(AbstractBeginNode overflowSuccessor, AbstractBeginNode next, Stamp stamp, double probability) {
753         LIRKind cmpKind = getLIRGeneratorTool().getLIRKind(stamp);
754         gen.emitOverflowCheckBranch(getLIRBlock(overflowSuccessor), getLIRBlock(next), cmpKind, probability);
755     }
756 
757     @Override
758     public void visitFullInfopointNode(FullInfopointNode i) {
<span class="line-modified">759         append(new FullInfopointOp(stateFor(i.getState()), i.getReason()));</span>
760     }
761 
762     @Override
763     public void setSourcePosition(NodeSourcePosition position) {
764         gen.setSourcePosition(position);
765     }
766 
767     @Override
768     public LIRGeneratorTool getLIRGeneratorTool() {
769         return gen;
770     }
771 
772     @Override
773     public void emitReadExceptionObject(ValueNode node) {
774         LIRGeneratorTool lirGenTool = getLIRGeneratorTool();
775         Value returnRegister = lirGenTool.getRegisterConfig().getReturnRegister(node.getStackKind()).asValue(
776                         LIRKind.fromJavaKind(lirGenTool.target().arch, node.getStackKind()));
777         lirGenTool.emitIncomingValues(new Value[]{returnRegister});
778         setResult(node, lirGenTool.emitMove(returnRegister));
779     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 31 import static org.graalvm.compiler.core.common.SpeculativeExecutionAttacksMitigations.Options.MitigateSpeculativeExecutionAttacks;
 32 import static org.graalvm.compiler.core.common.GraalOptions.MatchExpressions;
 33 import static org.graalvm.compiler.debug.DebugOptions.LogVerbose;
 34 import static org.graalvm.compiler.lir.LIR.verifyBlock;
 35 
 36 import java.util.ArrayList;
 37 import java.util.Collection;
 38 import java.util.List;
 39 
 40 import jdk.internal.vm.compiler.collections.EconomicMap;
 41 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
 42 import org.graalvm.compiler.core.common.LIRKind;
 43 import org.graalvm.compiler.core.common.calc.Condition;
 44 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 45 import org.graalvm.compiler.core.common.cfg.BlockMap;
 46 import org.graalvm.compiler.core.common.type.Stamp;
 47 import org.graalvm.compiler.core.match.ComplexMatchValue;
 48 import org.graalvm.compiler.core.match.MatchPattern;
 49 import org.graalvm.compiler.core.match.MatchRuleRegistry;
 50 import org.graalvm.compiler.core.match.MatchStatement;
<span class="line-added"> 51 import org.graalvm.compiler.debug.DebugCloseable;</span>
 52 import org.graalvm.compiler.debug.DebugContext;
 53 import org.graalvm.compiler.debug.GraalError;
 54 import org.graalvm.compiler.debug.TTY;
 55 import org.graalvm.compiler.graph.GraalGraphError;
 56 import org.graalvm.compiler.graph.Node;
 57 import org.graalvm.compiler.graph.NodeMap;
 58 import org.graalvm.compiler.graph.NodeSourcePosition;
 59 import org.graalvm.compiler.graph.iterators.NodeIterable;
 60 import org.graalvm.compiler.lir.FullInfopointOp;
 61 import org.graalvm.compiler.lir.LIRFrameState;
 62 import org.graalvm.compiler.lir.LIRInstruction;
 63 import org.graalvm.compiler.lir.LabelRef;
 64 import org.graalvm.compiler.lir.StandardOp.JumpOp;
 65 import org.graalvm.compiler.lir.StandardOp.LabelOp;
 66 import org.graalvm.compiler.lir.SwitchStrategy;
 67 import org.graalvm.compiler.lir.Variable;
 68 import org.graalvm.compiler.lir.debug.LIRGenerationDebugContext;
 69 import org.graalvm.compiler.lir.framemap.FrameMapBuilder;
 70 import org.graalvm.compiler.lir.gen.LIRGenerator;
 71 import org.graalvm.compiler.lir.gen.LIRGenerator.Options;
</pre>
<hr />
<pre>
 87 import org.graalvm.compiler.nodes.LogicNode;
 88 import org.graalvm.compiler.nodes.LoopEndNode;
 89 import org.graalvm.compiler.nodes.LoweredCallTargetNode;
 90 import org.graalvm.compiler.nodes.NodeView;
 91 import org.graalvm.compiler.nodes.ParameterNode;
 92 import org.graalvm.compiler.nodes.PhiNode;
 93 import org.graalvm.compiler.nodes.StructuredGraph;
 94 import org.graalvm.compiler.nodes.ValueNode;
 95 import org.graalvm.compiler.nodes.ValuePhiNode;
 96 import org.graalvm.compiler.nodes.calc.CompareNode;
 97 import org.graalvm.compiler.nodes.calc.ConditionalNode;
 98 import org.graalvm.compiler.nodes.calc.IntegerTestNode;
 99 import org.graalvm.compiler.nodes.calc.IsNullNode;
100 import org.graalvm.compiler.nodes.cfg.Block;
101 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
102 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
103 import org.graalvm.compiler.nodes.extended.SwitchNode;
104 import org.graalvm.compiler.nodes.spi.LIRLowerable;
105 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
106 import org.graalvm.compiler.nodes.spi.NodeValueMap;
<span class="line-added">107 import org.graalvm.compiler.nodes.spi.NodeWithState;</span>
108 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
109 import org.graalvm.compiler.options.OptionValues;
110 
111 import jdk.vm.ci.code.CallingConvention;
112 import jdk.vm.ci.code.StackSlot;
113 import jdk.vm.ci.code.ValueUtil;
114 import jdk.vm.ci.meta.AllocatableValue;
115 import jdk.vm.ci.meta.Constant;
116 import jdk.vm.ci.meta.JavaConstant;
117 import jdk.vm.ci.meta.JavaKind;
118 import jdk.vm.ci.meta.PlatformKind;
119 import jdk.vm.ci.meta.Value;
120 
121 /**
122  * This class traverses the HIR instructions and generates LIR instructions from them.
123  */
124 public abstract class NodeLIRBuilder implements NodeLIRBuilderTool, LIRGenerationDebugContext {
125 
126     private final NodeMap&lt;Value&gt; nodeOperands;
127     private final DebugInfoBuilder debugInfoBuilder;
</pre>
<hr />
<pre>
240     public final void append(LIRInstruction op) {
241         if (Options.PrintIRWithLIR.getValue(nodeOperands.graph().getOptions()) &amp;&amp; !TTY.isSuppressed()) {
242             if (currentInstruction != null &amp;&amp; lastInstructionPrinted != currentInstruction) {
243                 lastInstructionPrinted = currentInstruction;
244                 InstructionPrinter ip = new InstructionPrinter(TTY.out());
245                 ip.printInstructionListing(currentInstruction);
246             }
247         }
248         gen.append(op);
249     }
250 
251     protected LIRKind getExactPhiKind(PhiNode phi) {
252         LIRKind derivedKind = gen.toRegisterKind(gen.getLIRKind(phi.stamp(NodeView.DEFAULT)));
253         /* Collect reference information. */
254         for (int i = 0; i &lt; phi.valueCount() &amp;&amp; !derivedKind.isUnknownReference(); i++) {
255             ValueNode node = phi.valueAt(i);
256             Value value = getOperand(node);
257 
258             // get ValueKind for input
259             final LIRKind valueKind;
<span class="line-modified">260             if (value != null &amp;&amp; !(value instanceof ComplexMatchValue)) {</span>
261                 valueKind = value.getValueKind(LIRKind.class);
262             } else {
263                 assert isPhiInputFromBackedge(phi, i) : String.format(&quot;Input %s to phi node %s is not yet available although it is not coming from a loop back edge&quot;, node, phi);
264                 LIRKind kind = gen.getLIRKind(node.stamp(NodeView.DEFAULT));
265                 valueKind = gen.toRegisterKind(kind);
266             }
267             /* Merge the reference information of the derived kind and the input. */
268             derivedKind = LIRKind.mergeReferenceInformation(derivedKind, valueKind);
269         }
270         return derivedKind;
271     }
272 
273     private static boolean isPhiInputFromBackedge(PhiNode phi, int index) {
274         AbstractMergeNode merge = phi.merge();
275         AbstractEndNode end = merge.phiPredecessorAt(index);
276         return end instanceof LoopEndNode &amp;&amp; ((LoopEndNode) end).loopBegin().equals(merge);
277     }
278 
279     private Value[] createPhiIn(AbstractMergeNode merge) {
280         List&lt;Value&gt; values = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
343                 assert block.getPredecessorCount() == 0;
344                 emitPrologue(graph);
345             } else {
346                 assert block.getPredecessorCount() &gt; 0;
347                 // create phi-in value array
348                 AbstractBeginNode begin = block.getBeginNode();
349                 if (begin instanceof AbstractMergeNode) {
350                     AbstractMergeNode merge = (AbstractMergeNode) begin;
351                     LabelOp label = (LabelOp) gen.getResult().getLIR().getLIRforBlock(block).get(0);
352                     label.setPhiValues(createPhiIn(merge));
353                     if (Options.PrintIRWithLIR.getValue(options) &amp;&amp; !TTY.isSuppressed()) {
354                         TTY.println(&quot;Created PhiIn: &quot; + label);
355 
356                     }
357                 }
358             }
359             doBlockPrologue(block, options);
360 
361             List&lt;Node&gt; nodes = blockMap.get(block);
362 




363             boolean trace = traceLIRGeneratorLevel &gt;= 3;
364             for (int i = 0; i &lt; nodes.size(); i++) {
365                 Node node = nodes.get(i);
366                 if (node instanceof ValueNode) {
367                     setSourcePosition(node.getNodeSourcePosition());
368                     DebugContext debug = node.getDebug();
369                     ValueNode valueNode = (ValueNode) node;
370                     if (trace) {
371                         TTY.println(&quot;LIRGen for &quot; + valueNode);
372                     }
373                     Value operand = getOperand(valueNode);
374                     if (operand == null) {
375                         if (!peephole(valueNode)) {
376                             try {
377                                 doRoot(valueNode);
378                             } catch (GraalError e) {
379                                 throw GraalGraphError.transformAndAddContext(e, valueNode);
380                             } catch (Throwable e) {
381                                 throw new GraalGraphError(e).addContext(valueNode);
382                             }
</pre>
<hr />
<pre>
400                 }
401             }
402 
403             if (!gen.hasBlockEnd(block)) {
404                 NodeIterable&lt;Node&gt; successors = block.getEndNode().successors();
405                 assert successors.count() == block.getSuccessorCount();
406                 if (block.getSuccessorCount() != 1) {
407                     /*
408                      * If we have more than one successor, we cannot just use the first one. Since
409                      * successors are unordered, this would be a random choice.
410                      */
411                     throw new GraalError(&quot;Block without BlockEndOp: &quot; + block.getEndNode());
412                 }
413                 gen.emitJump(getLIRBlock((FixedNode) successors.first()));
414             }
415 
416             assert verifyBlock(gen.getResult().getLIR(), block);
417         }
418     }
419 
<span class="line-added">420     @Override</span>
421     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">422     public void matchBlock(Block block, StructuredGraph graph, StructuredGraph.ScheduleResult schedule) {</span>
<span class="line-added">423         try (DebugCloseable matchScope = gen.getMatchScope(block)) {</span>
<span class="line-added">424             // Allow NodeLIRBuilder subclass to specialize code generation of any interesting groups</span>
<span class="line-added">425             // of instructions</span>
<span class="line-added">426             matchComplexExpressions(block, schedule);</span>
<span class="line-added">427         }</span>
<span class="line-added">428     }</span>
<span class="line-added">429 </span>
<span class="line-added">430     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-added">431     protected void matchComplexExpressions(Block block, StructuredGraph.ScheduleResult schedule) {</span>
<span class="line-added">432 </span>
433         if (matchRules != null) {
434             DebugContext debug = gen.getResult().getLIR().getDebug();
435             try (DebugContext.Scope s = debug.scope(&quot;MatchComplexExpressions&quot;)) {
<span class="line-added">436                 List&lt;Node&gt; nodes = schedule.getBlockToNodesMap().get(block);</span>
437                 if (LogVerbose.getValue(nodeOperands.graph().getOptions())) {
438                     int i = 0;
439                     for (Node node : nodes) {
440                         debug.log(&quot;%d: (%s) %1S&quot;, i++, node.getUsageCount(), node);
441                     }
442                 }
443 
444                 // Match the nodes in backwards order to encourage longer matches.
445                 for (int index = nodes.size() - 1; index &gt;= 0; index--) {
446                     Node node = nodes.get(index);
447                     if (getOperand(node) != null) {
448                         continue;
449                     }
450                     // See if this node is the root of any MatchStatements
451                     List&lt;MatchStatement&gt; statements = matchRules.get(node.getClass());
452                     if (statements != null) {
453                         for (MatchStatement statement : statements) {
<span class="line-modified">454                             if (statement.generate(this, index, node, block, schedule)) {</span>
455                                 // Found a match so skip to the next
456                                 break;
457                             }
458                         }
459                     }
460                 }
461             }
462         }
463     }
464 
465     protected abstract boolean peephole(ValueNode valueNode);
466 
467     private void doRoot(ValueNode instr) {
468         if (traceLIRGeneratorLevel &gt;= 2) {
469             TTY.println(&quot;Emitting LIR for instruction &quot; + instr);
470         }
471         currentInstruction = instr;
472         DebugContext debug = instr.getDebug();
473         debug.log(&quot;Visiting %s&quot;, instr);
474         emitNode(instr);
</pre>
<hr />
<pre>
719     }
720 
721     private static FrameState getFrameState(DeoptimizingNode deopt) {
722         if (deopt instanceof DeoptimizingNode.DeoptBefore) {
723             assert !(deopt instanceof DeoptimizingNode.DeoptDuring || deopt instanceof DeoptimizingNode.DeoptAfter);
724             return ((DeoptimizingNode.DeoptBefore) deopt).stateBefore();
725         } else if (deopt instanceof DeoptimizingNode.DeoptDuring) {
726             assert !(deopt instanceof DeoptimizingNode.DeoptAfter);
727             return ((DeoptimizingNode.DeoptDuring) deopt).stateDuring();
728         } else {
729             assert deopt instanceof DeoptimizingNode.DeoptAfter;
730             return ((DeoptimizingNode.DeoptAfter) deopt).stateAfter();
731         }
732     }
733 
734     @Override
735     public LIRFrameState state(DeoptimizingNode deopt) {
736         if (!deopt.canDeoptimize()) {
737             return null;
738         }
<span class="line-modified">739         return stateFor(deopt, getFrameState(deopt));</span>
740     }
741 
742     public LIRFrameState stateWithExceptionEdge(DeoptimizingNode deopt, LabelRef exceptionEdge) {
743         if (!deopt.canDeoptimize()) {
744             return null;
745         }
<span class="line-modified">746         return stateForWithExceptionEdge(deopt, getFrameState(deopt), exceptionEdge);</span>
747     }
748 
<span class="line-modified">749     public LIRFrameState stateFor(NodeWithState deopt, FrameState state) {</span>
<span class="line-modified">750         return stateForWithExceptionEdge(deopt, state, null);</span>
751     }
752 
<span class="line-modified">753     public LIRFrameState stateForWithExceptionEdge(NodeWithState deopt, FrameState state, LabelRef exceptionEdge) {</span>
754         if (gen.needOnlyOopMaps()) {
755             return new LIRFrameState(null, null, null);
756         }
<span class="line-modified">757         assert state != null : deopt;</span>
<span class="line-modified">758         return getDebugInfoBuilder().build(deopt, state, exceptionEdge);</span>
759     }
760 
761     @Override
762     public void emitOverflowCheckBranch(AbstractBeginNode overflowSuccessor, AbstractBeginNode next, Stamp stamp, double probability) {
763         LIRKind cmpKind = getLIRGeneratorTool().getLIRKind(stamp);
764         gen.emitOverflowCheckBranch(getLIRBlock(overflowSuccessor), getLIRBlock(next), cmpKind, probability);
765     }
766 
767     @Override
768     public void visitFullInfopointNode(FullInfopointNode i) {
<span class="line-modified">769         append(new FullInfopointOp(stateFor(i, i.getState()), i.getReason()));</span>
770     }
771 
772     @Override
773     public void setSourcePosition(NodeSourcePosition position) {
774         gen.setSourcePosition(position);
775     }
776 
777     @Override
778     public LIRGeneratorTool getLIRGeneratorTool() {
779         return gen;
780     }
781 
782     @Override
783     public void emitReadExceptionObject(ValueNode node) {
784         LIRGeneratorTool lirGenTool = getLIRGeneratorTool();
785         Value returnRegister = lirGenTool.getRegisterConfig().getReturnRegister(node.getStackKind()).asValue(
786                         LIRKind.fromJavaKind(lirGenTool.target().arch, node.getStackKind()));
787         lirGenTool.emitIncomingValues(new Value[]{returnRegister});
788         setResult(node, lirGenTool.emitMove(returnRegister));
789     }
</pre>
</td>
</tr>
</table>
<center><a href="LIRGenerationProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeMatchRules.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/LIRCompilerBackend.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.gen;
 26 
 27 import java.util.Collection;
 28 import java.util.List;
 29 
 30 import jdk.internal.vm.compiler.collections.EconomicSet;
 31 import org.graalvm.compiler.code.CompilationResult;
 32 import org.graalvm.compiler.core.LIRGenerationPhase;
 33 import org.graalvm.compiler.core.LIRGenerationPhase.LIRGenerationContext;
 34 import org.graalvm.compiler.core.common.GraalOptions;
 35 import org.graalvm.compiler.core.common.alloc.ComputeBlockOrder;
 36 import org.graalvm.compiler.core.common.alloc.RegisterAllocationConfig;
 37 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 38 import org.graalvm.compiler.core.target.Backend;
 39 import org.graalvm.compiler.debug.CounterKey;
 40 import org.graalvm.compiler.debug.DebugCloseable;
 41 import org.graalvm.compiler.debug.DebugContext;
 42 import org.graalvm.compiler.debug.GraalError;
 43 import org.graalvm.compiler.debug.TimerKey;
 44 import org.graalvm.compiler.lir.LIR;
 45 import org.graalvm.compiler.lir.alloc.OutOfRegistersException;
 46 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 47 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
 48 import org.graalvm.compiler.lir.framemap.FrameMap;
 49 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 50 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 51 import org.graalvm.compiler.lir.phases.AllocationPhase.AllocationContext;
 52 import org.graalvm.compiler.lir.phases.LIRSuites;
 53 import org.graalvm.compiler.lir.phases.PostAllocationOptimizationPhase.PostAllocationOptimizationContext;
 54 import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase.PreAllocationOptimizationContext;
 55 import org.graalvm.compiler.nodes.StructuredGraph;
 56 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 57 import org.graalvm.compiler.nodes.cfg.Block;
 58 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
 59 
 60 import jdk.vm.ci.code.RegisterConfig;
 61 import jdk.vm.ci.code.TargetDescription;
 62 import jdk.vm.ci.code.site.ConstantReference;
 63 import jdk.vm.ci.code.site.DataPatch;
 64 import jdk.vm.ci.meta.Assumptions;
 65 import jdk.vm.ci.meta.JavaConstant;
 66 import jdk.vm.ci.meta.JavaKind;
 67 import jdk.vm.ci.meta.ResolvedJavaField;
 68 import jdk.vm.ci.meta.ResolvedJavaMethod;
 69 import jdk.vm.ci.meta.SpeculationLog;
 70 import jdk.vm.ci.meta.VMConstant;
 71 
 72 public class LIRCompilerBackend {
 73     private static final TimerKey EmitLIR = DebugContext.timer(&quot;EmitLIR&quot;).doc(&quot;Time spent generating LIR from HIR.&quot;);
 74     private static final TimerKey EmitCode = DebugContext.timer(&quot;EmitCode&quot;).doc(&quot;Time spent generating machine code from LIR.&quot;);
 75     private static final TimerKey BackEnd = DebugContext.timer(&quot;BackEnd&quot;).doc(&quot;Time spent in EmitLIR and EmitCode.&quot;);
 76 
 77     @SuppressWarnings(&quot;try&quot;)
 78     public static &lt;T extends CompilationResult&gt; void emitBackEnd(StructuredGraph graph, Object stub, ResolvedJavaMethod installedCodeOwner, Backend backend, T compilationResult,
 79                     CompilationResultBuilderFactory factory, RegisterConfig registerConfig, LIRSuites lirSuites) {
 80         DebugContext debug = graph.getDebug();
 81         try (DebugContext.Scope s = debug.scope(&quot;BackEnd&quot;, graph.getLastSchedule()); DebugCloseable a = BackEnd.start(debug)) {
 82             LIRGenerationResult lirGen = null;
 83             lirGen = emitLIR(backend, graph, stub, registerConfig, lirSuites);
 84             try (DebugContext.Scope s2 = debug.scope(&quot;CodeGen&quot;, lirGen, lirGen.getLIR())) {
 85                 int bytecodeSize = graph.method() == null ? 0 : graph.getBytecodeSize();
 86                 compilationResult.setHasUnsafeAccess(graph.hasUnsafeAccess());
 87                 emitCode(backend,
 88                                 graph.getAssumptions(),
 89                                 graph.method(),
 90                                 graph.getMethods(),
 91                                 graph.getFields(),
 92                                 graph.getSpeculationLog(),
 93                                 bytecodeSize,
 94                                 lirGen,
 95                                 compilationResult,
 96                                 installedCodeOwner,
 97                                 factory);
 98             } catch (Throwable e) {
 99                 throw debug.handle(e);
100             }
101         } catch (Throwable e) {
102             throw debug.handle(e);
103         } finally {
104             graph.checkCancellation();
105         }
106     }
107 
108     @SuppressWarnings(&quot;try&quot;)
109     public static LIRGenerationResult emitLIR(Backend backend, StructuredGraph graph, Object stub, RegisterConfig registerConfig, LIRSuites lirSuites) {
110         String registerPressure = GraalOptions.RegisterPressure.getValue(graph.getOptions());
111         String[] allocationRestrictedTo = registerPressure == null ? null : registerPressure.split(&quot;,&quot;);
112         try {
113             return emitLIR0(backend, graph, stub, registerConfig, lirSuites, allocationRestrictedTo);
114         } catch (OutOfRegistersException e) {
115             if (allocationRestrictedTo != null) {
116                 allocationRestrictedTo = null;
117                 return emitLIR0(backend, graph, stub, registerConfig, lirSuites, allocationRestrictedTo);
118             }
119             /* If the re-execution fails we convert the exception into a &quot;hard&quot; failure */
120             throw new GraalError(e);
121         } finally {
122             graph.checkCancellation();
123         }
124     }
125 
126     @SuppressWarnings(&quot;try&quot;)
<a name="2" id="anc2"></a><span class="line-modified">127     private static LIRGenerationResult emitLIR0(Backend backend,</span>
<span class="line-added">128                     StructuredGraph graph,</span>
<span class="line-added">129                     Object stub,</span>
<span class="line-added">130                     RegisterConfig registerConfig,</span>
<span class="line-added">131                     LIRSuites lirSuites,</span>
132                     String[] allocationRestrictedTo) {
133         DebugContext debug = graph.getDebug();
134         try (DebugContext.Scope ds = debug.scope(&quot;EmitLIR&quot;); DebugCloseable a = EmitLIR.start(debug)) {
135             assert !graph.hasValueProxies();
136 
137             ScheduleResult schedule = graph.getLastSchedule();
138             Block[] blocks = schedule.getCFG().getBlocks();
139             Block startBlock = schedule.getCFG().getStartBlock();
140             assert startBlock != null;
141             assert startBlock.getPredecessorCount() == 0;
142 
143             AbstractBlockBase&lt;?&gt;[] codeEmittingOrder = ComputeBlockOrder.computeCodeEmittingOrder(blocks.length, startBlock);
144             AbstractBlockBase&lt;?&gt;[] linearScanOrder = ComputeBlockOrder.computeLinearScanOrder(blocks.length, startBlock);
145             LIR lir = new LIR(schedule.getCFG(), linearScanOrder, codeEmittingOrder, graph.getOptions(), graph.getDebug());
146 
147             LIRGenerationProvider lirBackend = (LIRGenerationProvider) backend;
<a name="3" id="anc3"></a><span class="line-modified">148             RegisterAllocationConfig registerAllocationConfig = backend.newRegisterAllocationConfig(registerConfig, allocationRestrictedTo);</span>
<span class="line-added">149             LIRGenerationResult lirGenRes = lirBackend.newLIRGenerationResult(graph.compilationId(), lir, registerAllocationConfig, graph, stub);</span>
150             LIRGeneratorTool lirGen = lirBackend.newLIRGenerator(lirGenRes);
151             NodeLIRBuilderTool nodeLirGen = lirBackend.newNodeLIRBuilder(graph, lirGen);
152 
153             // LIR generation
154             LIRGenerationContext context = new LIRGenerationContext(lirGen, nodeLirGen, graph, schedule);
155             new LIRGenerationPhase().apply(backend.getTarget(), lirGenRes, context);
156 
157             try (DebugContext.Scope s = debug.scope(&quot;LIRStages&quot;, nodeLirGen, lirGenRes, lir)) {
158                 // Dump LIR along with HIR (the LIR is looked up from context)
159                 debug.dump(DebugContext.BASIC_LEVEL, graph.getLastSchedule(), &quot;After LIR generation&quot;);
<a name="4" id="anc4"></a><span class="line-modified">160                 LIRGenerationResult result = emitLowLevel(backend.getTarget(), lirGenRes, lirGen, lirSuites, registerAllocationConfig);</span>
161                 return result;
162             } catch (Throwable e) {
163                 throw debug.handle(e);
164             }
165         } catch (Throwable e) {
166             throw debug.handle(e);
167         } finally {
168             graph.checkCancellation();
169         }
170     }
171 
172     private static LIRGenerationResult emitLowLevel(TargetDescription target, LIRGenerationResult lirGenRes, LIRGeneratorTool lirGen, LIRSuites lirSuites,
173                     RegisterAllocationConfig registerAllocationConfig) {
174         DebugContext debug = lirGenRes.getLIR().getDebug();
175         PreAllocationOptimizationContext preAllocOptContext = new PreAllocationOptimizationContext(lirGen);
176         lirSuites.getPreAllocationOptimizationStage().apply(target, lirGenRes, preAllocOptContext);
177         debug.dump(DebugContext.BASIC_LEVEL, lirGenRes.getLIR(), &quot;After PreAllocationOptimizationStage&quot;);
178 
179         AllocationContext allocContext = new AllocationContext(lirGen.getSpillMoveFactory(), registerAllocationConfig);
180         lirSuites.getAllocationStage().apply(target, lirGenRes, allocContext);
181         debug.dump(DebugContext.BASIC_LEVEL, lirGenRes.getLIR(), &quot;After AllocationStage&quot;);
182 
183         PostAllocationOptimizationContext postAllocOptContext = new PostAllocationOptimizationContext(lirGen);
184         lirSuites.getPostAllocationOptimizationStage().apply(target, lirGenRes, postAllocOptContext);
185         debug.dump(DebugContext.BASIC_LEVEL, lirGenRes.getLIR(), &quot;After PostAllocationOptimizationStage&quot;);
186 
187         return lirGenRes;
188     }
189 
190     @SuppressWarnings(&quot;try&quot;)
191     public static void emitCode(Backend backend,
192                     Assumptions assumptions,
193                     ResolvedJavaMethod rootMethod,
194                     Collection&lt;ResolvedJavaMethod&gt; inlinedMethods,
195                     EconomicSet&lt;ResolvedJavaField&gt; accessedFields,
196                     SpeculationLog speculationLog,
197                     int bytecodeSize,
198                     LIRGenerationResult lirGenRes,
199                     CompilationResult compilationResult,
200                     ResolvedJavaMethod installedCodeOwner,
201                     CompilationResultBuilderFactory factory) {
202         DebugContext debug = lirGenRes.getLIR().getDebug();
203         try (DebugCloseable a = EmitCode.start(debug)) {
204             LIRGenerationProvider lirBackend = (LIRGenerationProvider) backend;
205 
206             FrameMap frameMap = lirGenRes.getFrameMap();
207             CompilationResultBuilder crb = lirBackend.newCompilationResultBuilder(lirGenRes, frameMap, compilationResult, factory);
208             lirBackend.emitCode(crb, lirGenRes.getLIR(), installedCodeOwner);
209             if (assumptions != null &amp;&amp; !assumptions.isEmpty()) {
210                 compilationResult.setAssumptions(assumptions.toArray());
211             }
212             if (rootMethod != null) {
213                 compilationResult.setMethods(rootMethod, inlinedMethods);
214                 compilationResult.setFields(accessedFields);
215                 compilationResult.setBytecodeSize(bytecodeSize);
216             }
217             if (speculationLog != null) {
218                 compilationResult.setSpeculationLog(speculationLog);
219             }
220             crb.finish();
221             if (debug.isCountEnabled()) {
222                 List&lt;DataPatch&gt; ldp = compilationResult.getDataPatches();
223                 JavaKind[] kindValues = JavaKind.values();
224                 CounterKey[] dms = new CounterKey[kindValues.length];
225                 for (int i = 0; i &lt; dms.length; i++) {
226                     dms[i] = DebugContext.counter(&quot;DataPatches-%s&quot;, kindValues[i]);
227                 }
228 
229                 for (DataPatch dp : ldp) {
230                     JavaKind kind = JavaKind.Illegal;
231                     if (dp.reference instanceof ConstantReference) {
232                         VMConstant constant = ((ConstantReference) dp.reference).getConstant();
233                         if (constant instanceof JavaConstant) {
234                             kind = ((JavaConstant) constant).getJavaKind();
235                         }
236                     }
237                     dms[kind.ordinal()].add(debug, 1);
238                 }
239 
240                 DebugContext.counter(&quot;CompilationResults&quot;).increment(debug);
241                 DebugContext.counter(&quot;CodeBytesEmitted&quot;).add(debug, compilationResult.getTargetCodeSize());
242                 DebugContext.counter(&quot;InfopointsEmitted&quot;).add(debug, compilationResult.getInfopoints().size());
243                 DebugContext.counter(&quot;DataPatches&quot;).add(debug, ldp.size());
244                 DebugContext.counter(&quot;ExceptionHandlersEmitted&quot;).add(debug, compilationResult.getExceptionHandlers().size());
245             }
246 
247             debug.dump(DebugContext.BASIC_LEVEL, compilationResult, &quot;After code generation&quot;);
248         }
249     }
250 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
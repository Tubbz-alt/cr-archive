<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/match/MatchContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.match;
 26 
<a name="2" id="anc2"></a><span class="line-added"> 27 import static org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph.dominates;</span>
<span class="line-added"> 28 import static org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph.strictlyDominates;</span>
 29 import static org.graalvm.compiler.debug.DebugOptions.LogVerbose;
 30 
 31 import java.util.ArrayList;
 32 import java.util.Arrays;
<a name="3" id="anc3"></a><span class="line-added"> 33 import java.util.Iterator;</span>
 34 import java.util.List;
 35 
 36 import jdk.internal.vm.compiler.collections.EconomicMap;
 37 import jdk.internal.vm.compiler.collections.Equivalence;
<a name="4" id="anc4"></a><span class="line-added"> 38 import org.graalvm.compiler.core.common.cfg.BlockMap;</span>
 39 import org.graalvm.compiler.core.gen.NodeLIRBuilder;
 40 import org.graalvm.compiler.core.match.MatchPattern.Result;
<a name="5" id="anc5"></a><span class="line-added"> 41 import org.graalvm.compiler.debug.CounterKey;</span>
 42 import org.graalvm.compiler.debug.DebugContext;
 43 import org.graalvm.compiler.debug.GraalError;
 44 import org.graalvm.compiler.graph.Node;
<a name="6" id="anc6"></a><span class="line-added"> 45 import org.graalvm.compiler.graph.NodeMap;</span>
<span class="line-added"> 46 import org.graalvm.compiler.nodes.PhiNode;</span>
<span class="line-added"> 47 import org.graalvm.compiler.nodes.StructuredGraph;</span>
 48 import org.graalvm.compiler.nodes.calc.FloatingNode;
<a name="7" id="anc7"></a><span class="line-added"> 49 import org.graalvm.compiler.nodes.cfg.Block;</span>
 50 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 51 
 52 /**
 53  * Container for state captured during a match.
 54  */
 55 public class MatchContext {
<a name="8" id="anc8"></a><span class="line-added"> 56     private static final CounterKey MatchContextSuccessDifferentBlocks = DebugContext.counter(&quot;MatchContextSuccessDifferentBlocks&quot;);</span>
 57 
 58     private final Node root;
 59 
<a name="9" id="anc9"></a>

 60     private final MatchStatement rule;
<a name="10" id="anc10"></a><span class="line-added"> 61     private final StructuredGraph.ScheduleResult schedule;</span>
 62 
 63     private EconomicMap&lt;String, NamedNode&gt; namedNodes;
 64 
<a name="11" id="anc11"></a><span class="line-modified"> 65     /**</span>
<span class="line-added"> 66      * A node consumed by a match. Keeps track of whether side effects can be ignored.</span>
<span class="line-added"> 67      */</span>
<span class="line-added"> 68     static final class ConsumedNode {</span>
<span class="line-added"> 69         final Node node;</span>
<span class="line-added"> 70         final boolean ignoresSideEffects;</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72         ConsumedNode(Node node, boolean ignoresSideEffects) {</span>
<span class="line-added"> 73             this.node = node;</span>
<span class="line-added"> 74             this.ignoresSideEffects = ignoresSideEffects;</span>
<span class="line-added"> 75         }</span>
<span class="line-added"> 76     }</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78     /**</span>
<span class="line-added"> 79      * The collection of nodes consumed by this match.</span>
<span class="line-added"> 80      */</span>
<span class="line-added"> 81     static final class ConsumedNodes implements Iterable&lt;ConsumedNode&gt; {</span>
<span class="line-added"> 82         private ArrayList&lt;ConsumedNode&gt; nodes;</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84         ConsumedNodes() {</span>
<span class="line-added"> 85             this.nodes = null;</span>
<span class="line-added"> 86         }</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88         public void add(Node node, boolean ignoresSideEffects) {</span>
<span class="line-added"> 89             if (nodes == null) {</span>
<span class="line-added"> 90                 nodes = new ArrayList&lt;&gt;(2);</span>
<span class="line-added"> 91             }</span>
<span class="line-added"> 92             nodes.add(new ConsumedNode(node, ignoresSideEffects));</span>
<span class="line-added"> 93         }</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95         public boolean contains(Node node) {</span>
<span class="line-added"> 96             for (ConsumedNode c : nodes) {</span>
<span class="line-added"> 97                 if (c.node == node) {</span>
<span class="line-added"> 98                     return true;</span>
<span class="line-added"> 99                 }</span>
<span class="line-added">100             }</span>
<span class="line-added">101             return false;</span>
<span class="line-added">102         }</span>
<span class="line-added">103 </span>
<span class="line-added">104         public ConsumedNode find(Node node) {</span>
<span class="line-added">105             for (ConsumedNode c : nodes) {</span>
<span class="line-added">106                 if (c.node == node) {</span>
<span class="line-added">107                     return c;</span>
<span class="line-added">108                 }</span>
<span class="line-added">109             }</span>
<span class="line-added">110             return null;</span>
<span class="line-added">111         }</span>
<span class="line-added">112 </span>
<span class="line-added">113         @Override</span>
<span class="line-added">114         public String toString() {</span>
<span class="line-added">115             Node[] arr = new Node[nodes.size()];</span>
<span class="line-added">116             int i = 0;</span>
<span class="line-added">117             for (ConsumedNode c : nodes) {</span>
<span class="line-added">118                 arr[i++] = c.node;</span>
<span class="line-added">119             }</span>
<span class="line-added">120             return Arrays.toString(arr);</span>
<span class="line-added">121         }</span>
<span class="line-added">122 </span>
<span class="line-added">123         @Override</span>
<span class="line-added">124         public Iterator&lt;ConsumedNode&gt; iterator() {</span>
<span class="line-added">125             return nodes.iterator();</span>
<span class="line-added">126         }</span>
<span class="line-added">127     }</span>
128 
<a name="12" id="anc12"></a><span class="line-modified">129     private ConsumedNodes consumed = new ConsumedNodes();</span>
130 
<a name="13" id="anc13"></a><span class="line-modified">131     private Block rootBlock;</span>
<span class="line-added">132     private int rootIndex;</span>
<span class="line-added">133 </span>
<span class="line-added">134     /**</span>
<span class="line-added">135      * Block and index in the block at which the match should be emitted. Differs from</span>
<span class="line-added">136      * rootBlock/rootIndex for (ZeroExtend Read=access) for instance: match should be emitted where</span>
<span class="line-added">137      * the Read is.</span>
<span class="line-added">138      */</span>
<span class="line-added">139     private int emitIndex;</span>
<span class="line-added">140     private Block emitBlock;</span>
141 
142     private final NodeLIRBuilder builder;
143 
144     private static class NamedNode {
145         final Class&lt;? extends Node&gt; type;
146         final Node value;
147 
148         NamedNode(Class&lt;? extends Node&gt; type, Node value) {
149             this.type = type;
150             this.value = value;
151         }
152     }
153 
<a name="14" id="anc14"></a><span class="line-modified">154     public MatchContext(NodeLIRBuilder builder, MatchStatement rule, int index, Node node, Block rootBlock, StructuredGraph.ScheduleResult schedule) {</span>
155         this.builder = builder;
156         this.rule = rule;
157         this.root = node;
<a name="15" id="anc15"></a><span class="line-modified">158         assert index == schedule.getBlockToNodesMap().get(rootBlock).indexOf(node);</span>
<span class="line-modified">159         this.schedule = schedule;</span>
160         // The root should be the last index since all the inputs must be scheduled before it.
<a name="16" id="anc16"></a><span class="line-modified">161         this.rootBlock = rootBlock;</span>
<span class="line-added">162         rootIndex = index;</span>
163     }
164 
165     public Node getRoot() {
166         return root;
167     }
168 
169     public Result captureNamedValue(String name, Class&lt;? extends Node&gt; type, Node value) {
170         if (namedNodes == null) {
171             namedNodes = EconomicMap.create(Equivalence.DEFAULT);
172         }
173         NamedNode current = namedNodes.get(name);
174         if (current == null) {
175             current = new NamedNode(type, value);
176             namedNodes.put(name, current);
177             return Result.OK;
178         } else {
179             if (current.value != value || current.type != type) {
180                 return Result.namedValueMismatch(value, rule.getPattern());
181             }
182             return Result.OK;
183         }
184     }
185 
186     public Result validate() {
<a name="17" id="anc17"></a><span class="line-modified">187         Result result = findEarlyPosition();</span>
<span class="line-modified">188         if (result != Result.OK) {</span>
<span class="line-added">189             return result;</span>
<span class="line-added">190         }</span>
<span class="line-added">191         findLatePosition();</span>
<span class="line-added">192         assert emitIndex == rootIndex || consumed.find(root).ignoresSideEffects;</span>
<span class="line-added">193         return verifyInputs();</span>
<span class="line-added">194     }</span>
<span class="line-added">195 </span>
<span class="line-added">196     private Result findEarlyPosition() {</span>
<span class="line-added">197         int startIndexSideEffect = -1;</span>
<span class="line-added">198         int endIndexSideEffect = -1;</span>
<span class="line-added">199         final NodeMap&lt;Block&gt; nodeToBlockMap = schedule.getNodeToBlockMap();</span>
<span class="line-added">200         final BlockMap&lt;List&lt;Node&gt;&gt; blockToNodesMap = schedule.getBlockToNodesMap();</span>
<span class="line-added">201 </span>
<span class="line-added">202         // Nodes affected by side effects must be in the same block</span>
<span class="line-added">203         for (ConsumedNode cn : consumed) {</span>
<span class="line-added">204             if (!cn.ignoresSideEffects) {</span>
<span class="line-added">205                 Block b = nodeToBlockMap.get(cn.node);</span>
<span class="line-added">206                 if (emitBlock == null) {</span>
<span class="line-added">207                     emitBlock = b;</span>
<span class="line-added">208                     startIndexSideEffect = endIndexSideEffect = blockToNodesMap.get(b).indexOf(cn.node);</span>
<span class="line-added">209                 } else if (emitBlock == b) {</span>
<span class="line-added">210                     int index = blockToNodesMap.get(b).indexOf(cn.node);</span>
<span class="line-added">211                     startIndexSideEffect = Math.min(startIndexSideEffect, index);</span>
<span class="line-added">212                     endIndexSideEffect = Math.max(endIndexSideEffect, index);</span>
<span class="line-added">213                 } else {</span>
<span class="line-added">214                     logFailedMatch(&quot;nodes affected by side effects in different blocks %s&quot;, cn.node);</span>
<span class="line-added">215                     return Result.notInBlock(cn.node, rule.getPattern());</span>
<span class="line-added">216                 }</span>
<span class="line-added">217             }</span>
<span class="line-added">218         }</span>
<span class="line-added">219         if (emitBlock != null) {</span>
<span class="line-added">220             // There must be no side effects between nodes that are affected by side effects</span>
<span class="line-added">221             assert startIndexSideEffect != -1 &amp;&amp; endIndexSideEffect != -1;</span>
<span class="line-added">222             final List&lt;Node&gt; nodes = blockToNodesMap.get(emitBlock);</span>
<span class="line-added">223             for (int i = startIndexSideEffect; i &lt;= endIndexSideEffect; i++) {</span>
<span class="line-added">224                 Node node = nodes.get(i);</span>
<span class="line-added">225                 if (!sideEffectFree(node) &amp;&amp; !consumed.contains(node)) {</span>
<span class="line-added">226                     logFailedMatch(&quot;unexpected side effect %s&quot;, node);</span>
<span class="line-added">227                     return Result.notSafe(node, rule.getPattern());</span>
<span class="line-added">228                 }</span>
<span class="line-added">229             }</span>
<span class="line-added">230             // early position is at the node affected by side effects the closest to the root</span>
<span class="line-added">231             emitIndex = endIndexSideEffect;</span>
<span class="line-added">232         } else {</span>
<span class="line-added">233             // Nodes not affected by side effect: early position is at the root</span>
<span class="line-added">234             emitBlock = nodeToBlockMap.get(root);</span>
<span class="line-added">235             emitIndex = rootIndex;</span>
<span class="line-added">236         }</span>
<span class="line-added">237         return Result.OK;</span>
<span class="line-added">238     }</span>
<span class="line-added">239 </span>
<span class="line-added">240     private static boolean sideEffectFree(Node node) {</span>
<span class="line-added">241         // The order of evaluation of these nodes controlled by data dependence so they</span>
<span class="line-added">242         // don&#39;t interfere with this match.</span>
<span class="line-added">243         return node instanceof VirtualObjectNode || node instanceof FloatingNode;</span>
<span class="line-added">244     }</span>
<span class="line-added">245 </span>
<span class="line-added">246     private void findLatePosition() {</span>
<span class="line-added">247         // If emit position is at a node affected by side effects that&#39;s followed by side effect</span>
<span class="line-added">248         // free nodes, the node can be emitted later. This helps when the match has inputs that are</span>
<span class="line-added">249         // late in the block.</span>
<span class="line-added">250         int index = rootIndex;</span>
<span class="line-added">251         if (emitBlock != rootBlock) {</span>
<span class="line-added">252             index = schedule.getBlockToNodesMap().get(emitBlock).size() - 1;</span>
<span class="line-added">253         }</span>
<span class="line-added">254         final List&lt;Node&gt; emitBlockNodes = schedule.getBlockToNodesMap().get(emitBlock);</span>
<span class="line-added">255         for (int i = emitIndex + 1; i &lt;= index; i++) {</span>
<span class="line-added">256             Node node = emitBlockNodes.get(i);</span>
<span class="line-added">257             ConsumedNode cn = consumed.find(node);</span>
<span class="line-added">258             if (cn == null) {</span>
<span class="line-added">259                 if (!sideEffectFree(node)) {</span>
<span class="line-added">260                     return;</span>
<span class="line-added">261                 }</span>
<span class="line-added">262             } else {</span>
<span class="line-added">263                 assert cn.ignoresSideEffects;</span>
<span class="line-added">264                 emitIndex = i;</span>
<span class="line-added">265             }</span>
<span class="line-added">266         }</span>
<span class="line-added">267     }</span>
<span class="line-added">268 </span>
<span class="line-added">269     private Result verifyInputs() {</span>
<span class="line-added">270         DebugContext debug = root.getDebug();</span>
<span class="line-added">271         if (emitBlock != rootBlock) {</span>
<span class="line-added">272             assert consumed.find(root).ignoresSideEffects;</span>
<span class="line-added">273             Result result = verifyInputsDifferentBlock(root);</span>
<span class="line-added">274             if (result == Result.OK) {</span>
<span class="line-added">275                 MatchContextSuccessDifferentBlocks.increment(debug);</span>
<span class="line-added">276             }</span>
<span class="line-added">277             return result;</span>
<span class="line-added">278         }</span>
<span class="line-added">279         // We are going to emit the match at emitIndex. We need to make sure nodes of the match</span>
<span class="line-added">280         // between emitIndex and rootIndex don&#39;t have inputs after position emitIndex that would</span>
<span class="line-added">281         // make emitIndex an illegal position.</span>
<span class="line-added">282         final List&lt;Node&gt; nodes = schedule.getBlockToNodesMap().get(rootBlock);</span>
<span class="line-added">283         for (int i = emitIndex + 1; i &lt;= rootIndex; i++) {</span>
284             Node node = nodes.get(i);
<a name="18" id="anc18"></a><span class="line-modified">285             ConsumedNode cn = consumed.find(node);</span>
<span class="line-modified">286             if (cn != null) {</span>
<span class="line-modified">287                 assert cn.ignoresSideEffects;</span>
<span class="line-modified">288                 for (Node in : node.inputs()) {</span>
<span class="line-modified">289                     if (!consumed.contains(in)) {</span>
<span class="line-modified">290                         for (int j = emitIndex + 1; j &lt; i; j++) {</span>
<span class="line-modified">291                             if (nodes.get(j) == in) {</span>
<span class="line-modified">292                                 logFailedMatch(&quot;Earliest position in block is too late %s&quot;, in);</span>
<span class="line-modified">293                                 assert consumed.find(root).ignoresSideEffects;</span>
<span class="line-modified">294                                 assert verifyInputsDifferentBlock(root) != Result.OK;</span>
<span class="line-modified">295                                 return Result.tooLate(node, rule.getPattern());</span>
<span class="line-added">296                             }</span>
<span class="line-added">297                         }</span>
298                     }
299                 }
<a name="19" id="anc19"></a>
300             }
301         }
<a name="20" id="anc20"></a><span class="line-added">302         assert verifyInputsDifferentBlock(root) == Result.OK;</span>
303         return Result.OK;
304     }
305 
<a name="21" id="anc21"></a><span class="line-added">306     private Result verifyInputsDifferentBlock(Node node) {</span>
<span class="line-added">307         // Is there an input that&#39;s not part of the match that&#39;s after the emit position?</span>
<span class="line-added">308         for (Node in : node.inputs()) {</span>
<span class="line-added">309             if (in instanceof PhiNode) {</span>
<span class="line-added">310                 Block b = schedule.getNodeToBlockMap().get(((PhiNode) in).merge());</span>
<span class="line-added">311                 if (dominates(b, emitBlock)) {</span>
<span class="line-added">312                     continue;</span>
<span class="line-added">313                 }</span>
<span class="line-added">314             } else {</span>
<span class="line-added">315                 Block b = schedule.getNodeToBlockMap().get(in);</span>
<span class="line-added">316                 if (strictlyDominates(b, emitBlock) || (b == emitBlock &amp;&amp; schedule.getBlockToNodesMap().get(emitBlock).indexOf(in) &lt;= emitIndex)) {</span>
<span class="line-added">317                     continue;</span>
<span class="line-added">318                 }</span>
<span class="line-added">319             }</span>
<span class="line-added">320             ConsumedNode cn = consumed.find(in);</span>
<span class="line-added">321             if (cn == null) {</span>
<span class="line-added">322                 logFailedMatch(&quot;Earliest position in block is too late %s&quot;, in);</span>
<span class="line-added">323                 return Result.tooLate(node, rule.getPattern());</span>
<span class="line-added">324             }</span>
<span class="line-added">325             assert cn.ignoresSideEffects;</span>
<span class="line-added">326             Result res = verifyInputsDifferentBlock(in);</span>
<span class="line-added">327             if (res != Result.OK) {</span>
<span class="line-added">328                 return res;</span>
<span class="line-added">329             }</span>
<span class="line-added">330         }</span>
<span class="line-added">331         return Result.OK;</span>
<span class="line-added">332     }</span>
<span class="line-added">333 </span>
<span class="line-added">334     private void logFailedMatch(String s, Node node) {</span>
<span class="line-added">335         if (LogVerbose.getValue(root.getOptions())) {</span>
<span class="line-added">336             DebugContext debug = root.getDebug();</span>
<span class="line-added">337             debug.log(s, node);</span>
<span class="line-added">338             int startIndex = emitIndex;</span>
<span class="line-added">339             if (emitBlock != rootBlock) {</span>
<span class="line-added">340                 int endIndex = schedule.getBlockToNodesMap().get(emitBlock).size() - 1;</span>
<span class="line-added">341                 final List&lt;Node&gt; emitBlockNodes = schedule.getBlockToNodesMap().get(emitBlock);</span>
<span class="line-added">342                 debug.log(&quot;%s:&quot;, emitBlock);</span>
<span class="line-added">343                 for (int j = startIndex; j &lt;= endIndex; j++) {</span>
<span class="line-added">344                     Node theNode = emitBlockNodes.get(j);</span>
<span class="line-added">345                     debug.log(&quot;%s(%s) %1s&quot;, consumed.contains(theNode) ? &quot;*&quot; : &quot; &quot;, theNode.getUsageCount(), theNode);</span>
<span class="line-added">346                 }</span>
<span class="line-added">347                 startIndex = 0;</span>
<span class="line-added">348             }</span>
<span class="line-added">349             debug.log(&quot;%s:&quot;, rootBlock);</span>
<span class="line-added">350             final List&lt;Node&gt; nodes = schedule.getBlockToNodesMap().get(rootBlock);</span>
<span class="line-added">351             for (int j = startIndex; j &lt;= rootIndex; j++) {</span>
<span class="line-added">352                 Node theNode = nodes.get(j);</span>
<span class="line-added">353                 debug.log(&quot;%s(%s) %1s&quot;, consumed.contains(theNode) ? &quot;*&quot; : &quot; &quot;, theNode.getUsageCount(), theNode);</span>
<span class="line-added">354             }</span>
<span class="line-added">355         }</span>
<span class="line-added">356     }</span>
<span class="line-added">357 </span>
358     /**
359      * Mark the interior nodes with INTERIOR_MATCH and set the Value of the root to be the result.
360      * During final LIR generation it will be evaluated to produce the actual LIR value.
361      *
362      * @param result
363      */
364     public void setResult(ComplexMatchResult result) {
365         ComplexMatchValue value = new ComplexMatchValue(result);
<a name="22" id="anc22"></a><span class="line-added">366         Node emitNode = schedule.getBlockToNodesMap().get(emitBlock).get(emitIndex);</span>
367         DebugContext debug = root.getDebug();
368         if (debug.isLogEnabled()) {
<a name="23" id="anc23"></a><span class="line-modified">369             debug.log(&quot;matched %s %s%s&quot;, rule.getName(), rule.getPattern(), emitIndex != rootIndex ? &quot; skipping side effects&quot; : &quot;&quot;);</span>
370             debug.log(&quot;with nodes %s&quot;, rule.formatMatch(root));
371         }
<a name="24" id="anc24"></a><span class="line-modified">372         for (ConsumedNode cn : consumed) {</span>
<span class="line-modified">373             if (cn.node == root || cn.node == emitNode) {</span>
<span class="line-modified">374                 continue;</span>



375             }
<a name="25" id="anc25"></a><span class="line-added">376             // All the interior nodes should be skipped during the normal doRoot calls in</span>
<span class="line-added">377             // NodeLIRBuilder so mark them as interior matches. The root of the match will get a</span>
<span class="line-added">378             // closure which will be evaluated to produce the final LIR.</span>
<span class="line-added">379             builder.setMatchResult(cn.node, ComplexMatchValue.INTERIOR_MATCH);</span>
<span class="line-added">380         }</span>
<span class="line-added">381         builder.setMatchResult(emitNode, value);</span>
<span class="line-added">382         if (root != emitNode) {</span>
<span class="line-added">383             // Match is not emitted at the position of root in the block but the uses of root needs</span>
<span class="line-added">384             // the result of the match so add a ComplexMatchValue that will simply return the result</span>
<span class="line-added">385             // of the actual match above.</span>
<span class="line-added">386             builder.setMatchResult(root, new ComplexMatchValue(gen -&gt; gen.operand(emitNode)));</span>
387         }
<a name="26" id="anc26"></a>
388     }
389 
390     /**
391      * Mark a node as consumed by the match. Consumed nodes will never be evaluated.
392      *
393      * @return Result.OK if the node can be safely consumed.
394      */
<a name="27" id="anc27"></a><span class="line-modified">395     public Result consume(Node node, boolean ignoresSideEffects, boolean atRoot) {</span>
<span class="line-modified">396         if (atRoot) {</span>
<span class="line-modified">397             consumed.add(node, ignoresSideEffects);</span>
<span class="line-modified">398             return Result.OK;</span>



399         }
<a name="28" id="anc28"></a><span class="line-added">400         assert MatchPattern.isSingleValueUser(node) : &quot;should have already been checked&quot;;</span>
401 
402         if (builder.hasOperand(node)) {
403             return Result.alreadyUsed(node, rule.getPattern());
404         }
405 
<a name="29" id="anc29"></a><span class="line-modified">406         consumed.add(node, ignoresSideEffects);</span>




407         return Result.OK;
408     }
409 
410     /**
411      * Return the named node. It&#39;s an error if the
412      *
413      * @param name the name of a node in the match rule
414      * @return the matched node
415      * @throws GraalError is the named node doesn&#39;t exist.
416      */
417     public Node namedNode(String name) {
418         if (namedNodes != null) {
419             NamedNode value = namedNodes.get(name);
420             if (value != null) {
421                 return value.value;
422             }
423         }
424         throw new GraalError(&quot;missing node %s&quot;, name);
425     }
426 
427     @Override
428     public String toString() {
<a name="30" id="anc30"></a><span class="line-modified">429         return String.format(&quot;%s %s (%s/%d, %s/%d) consumed %s&quot;, rule, root, rootBlock, rootIndex, emitBlock, emitIndex, consumed);</span>
430     }
431 }
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
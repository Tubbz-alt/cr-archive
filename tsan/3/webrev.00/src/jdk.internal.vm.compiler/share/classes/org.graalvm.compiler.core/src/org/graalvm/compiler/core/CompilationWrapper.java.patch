diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/CompilationWrapper.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/CompilationWrapper.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/CompilationWrapper.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/CompilationWrapper.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,14 +23,15 @@
 
 
 package org.graalvm.compiler.core;
 
 import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.ExitVM;
-import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAction;
+import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAsFailure;
 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
 import static org.graalvm.compiler.core.GraalCompilerOptions.ExitVMOnException;
 import static org.graalvm.compiler.core.GraalCompilerOptions.MaxCompilationProblemsPerAction;
+import static org.graalvm.compiler.core.common.GraalOptions.TrackNodeSourcePosition;
 import static org.graalvm.compiler.debug.DebugContext.VERBOSE_LEVEL;
 import static org.graalvm.compiler.debug.DebugOptions.Dump;
 import static org.graalvm.compiler.debug.DebugOptions.DumpPath;
 import static org.graalvm.compiler.debug.DebugOptions.MethodFilter;
 
@@ -43,18 +44,17 @@
 
 import org.graalvm.compiler.debug.DebugContext;
 import org.graalvm.compiler.debug.DiagnosticsOutputDirectory;
 import org.graalvm.compiler.debug.PathUtilities;
 import org.graalvm.compiler.debug.TTY;
-import org.graalvm.compiler.options.EnumOptionKey;
 import org.graalvm.compiler.options.OptionValues;
 
 import jdk.vm.ci.code.BailoutException;
 
 /**
  * Wrapper for a compilation that centralizes what action to take based on
- * {@link GraalCompilerOptions#CompilationBailoutAction} and
+ * {@link GraalCompilerOptions#CompilationBailoutAsFailure} and
  * {@link GraalCompilerOptions#CompilationFailureAction} when an uncaught exception occurs during
  * compilation.
  */
 public abstract class CompilationWrapper<T> {
 
@@ -69,18 +69,21 @@
     public enum ExceptionAction {
         /**
          * Print nothing to the console.
          */
         Silent,
+
         /**
          * Print a stack trace to the console.
          */
         Print,
+
         /**
          * An exception causes the compilation to be retried with extra diagnostics enabled.
          */
         Diagnose,
+
         /**
          * Same as {@link #Diagnose} except that the VM process is exited after retrying.
          */
         ExitVM;
 
@@ -120,31 +123,34 @@
      * @return a value representing the result of a failed compilation (may be {@code null})
      */
     protected abstract T handleException(Throwable t);
 
     /**
-     * Gets the action to take based on the value of {@code actionKey} in {@code options}.
+     * Gets the action to take based on the value of
+     * {@link GraalCompilerOptions#CompilationBailoutAsFailure},
+     * {@link GraalCompilerOptions#CompilationFailureAction} and
+     * {@link GraalCompilerOptions#ExitVMOnException} in {@code options}.
      *
-     * Subclasses can override this to choose a different action based on factors such as whether
-     * {@code actionKey} has been explicitly set in {@code options} for example.
+     * Subclasses can override this to choose a different action.
      *
      * @param cause the cause of the bailout or failure
      */
-    protected ExceptionAction lookupAction(OptionValues options, EnumOptionKey<ExceptionAction> actionKey, Throwable cause) {
-        if (actionKey == CompilationFailureAction) {
-            if (ExitVMOnException.getValue(options)) {
-                assert CompilationFailureAction.getDefaultValue() != ExceptionAction.ExitVM;
-                assert ExitVMOnException.getDefaultValue() != true;
-                if (CompilationFailureAction.hasBeenSet(options) && CompilationFailureAction.getValue(options) != ExceptionAction.ExitVM) {
-                    TTY.printf("WARNING: Ignoring %s=%s since %s=true has been explicitly specified.%n",
-                                    CompilationFailureAction.getName(), CompilationFailureAction.getValue(options),
-                                    ExitVMOnException.getName());
-                }
-                return ExceptionAction.ExitVM;
+    protected ExceptionAction lookupAction(OptionValues options, Throwable cause) {
+        if (cause instanceof BailoutException && !CompilationBailoutAsFailure.getValue(options)) {
+            return ExceptionAction.Silent;
+        }
+        if (ExitVMOnException.getValue(options)) {
+            assert CompilationFailureAction.getDefaultValue() != ExceptionAction.ExitVM;
+            assert ExitVMOnException.getDefaultValue() != true;
+            if (CompilationFailureAction.hasBeenSet(options) && CompilationFailureAction.getValue(options) != ExceptionAction.ExitVM) {
+                TTY.printf("WARNING: Ignoring %s=%s since %s=true has been explicitly specified.%n",
+                                CompilationFailureAction.getName(), CompilationFailureAction.getValue(options),
+                                ExitVMOnException.getName());
             }
+            return ExceptionAction.ExitVM;
         }
-        return actionKey.getValue(options);
+        return CompilationFailureAction.getValue(options);
     }
 
     /**
      * Perform the compilation wrapped by this object.
      *
@@ -159,63 +165,53 @@
     public abstract String toString();
 
     /**
      * Creates the {@link DebugContext} to use when retrying a compilation.
      *
+     * @param initialDebug the debug context used in the failing compilation
      * @param options the options for configuring the debug context
      * @param logStream the log stream to use in the debug context
      */
-    protected abstract DebugContext createRetryDebugContext(OptionValues options, PrintStream logStream);
+    protected abstract DebugContext createRetryDebugContext(DebugContext initialDebug, OptionValues options, PrintStream logStream);
 
     @SuppressWarnings("try")
     public final T run(DebugContext initialDebug) {
         try {
             return performCompilation(initialDebug);
         } catch (Throwable cause) {
             OptionValues initialOptions = initialDebug.getOptions();
 
-            String causeType = "failure";
-            EnumOptionKey<ExceptionAction> actionKey;
-            if (cause instanceof BailoutException) {
-                actionKey = CompilationBailoutAction;
-                causeType = "bailout";
-            } else {
-                actionKey = CompilationFailureAction;
-                causeType = "failure";
-            }
             synchronized (CompilationFailureAction) {
                 // Serialize all compilation failure handling.
                 // This prevents retry compilation storms and interleaving
                 // of compilation exception messages.
                 // It also allows for reliable testing of CompilationWrapper
                 // by avoiding a race whereby retry compilation output from a
                 // forced crash (i.e., use of GraalCompilerOptions.CrashAt)
                 // is truncated.
 
-                ExceptionAction action = lookupAction(initialOptions, actionKey, cause);
+                ExceptionAction action = lookupAction(initialOptions, cause);
 
-                action = adjustAction(initialOptions, actionKey, action);
+                action = adjustAction(initialOptions, action);
 
                 if (action == ExceptionAction.Silent) {
                     return handleException(cause);
                 }
 
                 if (action == ExceptionAction.Print) {
                     ByteArrayOutputStream baos = new ByteArrayOutputStream();
                     try (PrintStream ps = new PrintStream(baos)) {
                         ps.printf("%s: Compilation of %s failed: ", Thread.currentThread(), this);
                         cause.printStackTrace(ps);
-                        ps.printf("To disable compilation %s notifications, set %s to %s (e.g., -Dgraal.%s=%s).%n",
-                                        causeType,
-                                        actionKey.getName(), ExceptionAction.Silent,
-                                        actionKey.getName(), ExceptionAction.Silent);
-                        ps.printf("To capture more information for diagnosing or reporting a compilation %s, " +
+                        ps.printf("To disable compilation failure notifications, set %s to %s (e.g., -Dgraal.%s=%s).%n",
+                                        CompilationFailureAction.getName(), ExceptionAction.Silent,
+                                        CompilationFailureAction.getName(), ExceptionAction.Silent);
+                        ps.printf("To capture more information for diagnosing or reporting a compilation failure, " +
                                         "set %s to %s or %s (e.g., -Dgraal.%s=%s).%n",
-                                        causeType,
-                                        actionKey.getName(), ExceptionAction.Diagnose,
+                                        CompilationFailureAction.getName(), ExceptionAction.Diagnose,
                                         ExceptionAction.ExitVM,
-                                        actionKey.getName(), ExceptionAction.Diagnose);
+                                        CompilationFailureAction.getName(), ExceptionAction.Diagnose);
                     }
                     TTY.print(baos.toString());
                     return handleException(cause);
                 }
 
@@ -245,21 +241,22 @@
                 }
 
                 String message;
                 ByteArrayOutputStream baos = new ByteArrayOutputStream();
                 try (PrintStream ps = new PrintStream(baos)) {
+                    // This output is used by external tools to detect compilation failures.
+                    ps.println("[[[Graal compilation failure]]]");
+
                     ps.printf("%s: Compilation of %s failed:%n", Thread.currentThread(), this);
                     cause.printStackTrace(ps);
-                    ps.printf("To disable compilation %s notifications, set %s to %s (e.g., -Dgraal.%s=%s).%n",
-                                    causeType,
-                                    actionKey.getName(), ExceptionAction.Silent,
-                                    actionKey.getName(), ExceptionAction.Silent);
-                    ps.printf("To print a message for a compilation %s without retrying the compilation, " +
+                    ps.printf("To disable compilation failure notifications, set %s to %s (e.g., -Dgraal.%s=%s).%n",
+                                    CompilationFailureAction.getName(), ExceptionAction.Silent,
+                                    CompilationFailureAction.getName(), ExceptionAction.Silent);
+                    ps.printf("To print a message for a compilation failure without retrying the compilation, " +
                                     "set %s to %s (e.g., -Dgraal.%s=%s).%n",
-                                    causeType,
-                                    actionKey.getName(), ExceptionAction.Print,
-                                    actionKey.getName(), ExceptionAction.Print);
+                                    CompilationFailureAction.getName(), ExceptionAction.Print,
+                                    CompilationFailureAction.getName(), ExceptionAction.Print);
                     if (dumpPath != null) {
                         ps.println("Retrying compilation of " + this);
                     } else {
                         ps.println("Not retrying compilation of " + this + " as the dump path could not be created.");
                     }
@@ -279,15 +276,16 @@
                 }
 
                 OptionValues retryOptions = new OptionValues(initialOptions,
                                 Dump, ":" + VERBOSE_LEVEL,
                                 MethodFilter, null,
-                                DumpPath, dumpPath.getPath());
+                                DumpPath, dumpPath.getPath(),
+                                TrackNodeSourcePosition, true);
 
                 ByteArrayOutputStream logBaos = new ByteArrayOutputStream();
                 PrintStream ps = new PrintStream(logBaos);
-                try (DebugContext retryDebug = createRetryDebugContext(retryOptions, ps)) {
+                try (DebugContext retryDebug = createRetryDebugContext(initialDebug, retryOptions, ps)) {
                     T res = performCompilation(retryDebug);
                     ps.println("There was no exception during retry.");
                     maybeExitVM(action);
                     return res;
                 } catch (Throwable e) {
@@ -307,31 +305,37 @@
                 }
             }
         }
     }
 
+    /**
+     * Calls {@link System#exit(int)} in the runtime embedding the Graal compiler. This will be a
+     * different runtime than Graal's runtime in the case of libgraal.
+     */
+    protected abstract void exitHostVM(int status);
+
     private void maybeExitVM(ExceptionAction action) {
         if (action == ExitVM) {
             TTY.println("Exiting VM after retry compilation of " + this);
-            System.exit(-1);
+            exitHostVM(-1);
         }
     }
 
     /**
      * Adjusts {@code initialAction} if necessary based on
      * {@link GraalCompilerOptions#MaxCompilationProblemsPerAction}.
      */
-    private ExceptionAction adjustAction(OptionValues initialOptions, EnumOptionKey<ExceptionAction> actionKey, ExceptionAction initialAction) {
+    private ExceptionAction adjustAction(OptionValues initialOptions, ExceptionAction initialAction) {
         ExceptionAction action = initialAction;
         int maxProblems = MaxCompilationProblemsPerAction.getValue(initialOptions);
         if (action != ExceptionAction.ExitVM) {
             synchronized (problemsHandledPerAction) {
                 while (action != ExceptionAction.Silent) {
                     int problems = problemsHandledPerAction.getOrDefault(action, 0);
                     if (problems >= maxProblems) {
                         if (problems == maxProblems) {
-                            TTY.printf("Warning: adjusting %s from %s to %s after %s (%d) failed compilations%n", actionKey, action, action.quieter(),
+                            TTY.printf("Warning: adjusting %s from %s to %s after %s (%d) failed compilations%n", CompilationFailureAction, action, action.quieter(),
                                             MaxCompilationProblemsPerAction, maxProblems);
                             // Ensure that the message above is only printed once
                             problemsHandledPerAction.put(action, problems + 1);
                         }
                         action = action.quieter();

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/LIRCompilerBackend.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DebugInfoBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LIRGenerationProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/LIRCompilerBackend.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
107 
108     @SuppressWarnings(&quot;try&quot;)
109     public static LIRGenerationResult emitLIR(Backend backend, StructuredGraph graph, Object stub, RegisterConfig registerConfig, LIRSuites lirSuites) {
110         String registerPressure = GraalOptions.RegisterPressure.getValue(graph.getOptions());
111         String[] allocationRestrictedTo = registerPressure == null ? null : registerPressure.split(&quot;,&quot;);
112         try {
113             return emitLIR0(backend, graph, stub, registerConfig, lirSuites, allocationRestrictedTo);
114         } catch (OutOfRegistersException e) {
115             if (allocationRestrictedTo != null) {
116                 allocationRestrictedTo = null;
117                 return emitLIR0(backend, graph, stub, registerConfig, lirSuites, allocationRestrictedTo);
118             }
119             /* If the re-execution fails we convert the exception into a &quot;hard&quot; failure */
120             throw new GraalError(e);
121         } finally {
122             graph.checkCancellation();
123         }
124     }
125 
126     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">127     private static LIRGenerationResult emitLIR0(Backend backend, StructuredGraph graph, Object stub, RegisterConfig registerConfig, LIRSuites lirSuites,</span>




128                     String[] allocationRestrictedTo) {
129         DebugContext debug = graph.getDebug();
130         try (DebugContext.Scope ds = debug.scope(&quot;EmitLIR&quot;); DebugCloseable a = EmitLIR.start(debug)) {
131             assert !graph.hasValueProxies();
132 
133             ScheduleResult schedule = graph.getLastSchedule();
134             Block[] blocks = schedule.getCFG().getBlocks();
135             Block startBlock = schedule.getCFG().getStartBlock();
136             assert startBlock != null;
137             assert startBlock.getPredecessorCount() == 0;
138 
139             AbstractBlockBase&lt;?&gt;[] codeEmittingOrder = ComputeBlockOrder.computeCodeEmittingOrder(blocks.length, startBlock);
140             AbstractBlockBase&lt;?&gt;[] linearScanOrder = ComputeBlockOrder.computeLinearScanOrder(blocks.length, startBlock);
141             LIR lir = new LIR(schedule.getCFG(), linearScanOrder, codeEmittingOrder, graph.getOptions(), graph.getDebug());
142 
143             LIRGenerationProvider lirBackend = (LIRGenerationProvider) backend;
<span class="line-modified">144             LIRGenerationResult lirGenRes = lirBackend.newLIRGenerationResult(graph.compilationId(), lir, registerConfig, graph, stub);</span>

145             LIRGeneratorTool lirGen = lirBackend.newLIRGenerator(lirGenRes);
146             NodeLIRBuilderTool nodeLirGen = lirBackend.newNodeLIRBuilder(graph, lirGen);
147 
148             // LIR generation
149             LIRGenerationContext context = new LIRGenerationContext(lirGen, nodeLirGen, graph, schedule);
150             new LIRGenerationPhase().apply(backend.getTarget(), lirGenRes, context);
151 
152             try (DebugContext.Scope s = debug.scope(&quot;LIRStages&quot;, nodeLirGen, lirGenRes, lir)) {
153                 // Dump LIR along with HIR (the LIR is looked up from context)
154                 debug.dump(DebugContext.BASIC_LEVEL, graph.getLastSchedule(), &quot;After LIR generation&quot;);
<span class="line-modified">155                 LIRGenerationResult result = emitLowLevel(backend.getTarget(), lirGenRes, lirGen, lirSuites, backend.newRegisterAllocationConfig(registerConfig, allocationRestrictedTo));</span>
156                 return result;
157             } catch (Throwable e) {
158                 throw debug.handle(e);
159             }
160         } catch (Throwable e) {
161             throw debug.handle(e);
162         } finally {
163             graph.checkCancellation();
164         }
165     }
166 
167     private static LIRGenerationResult emitLowLevel(TargetDescription target, LIRGenerationResult lirGenRes, LIRGeneratorTool lirGen, LIRSuites lirSuites,
168                     RegisterAllocationConfig registerAllocationConfig) {
169         DebugContext debug = lirGenRes.getLIR().getDebug();
170         PreAllocationOptimizationContext preAllocOptContext = new PreAllocationOptimizationContext(lirGen);
171         lirSuites.getPreAllocationOptimizationStage().apply(target, lirGenRes, preAllocOptContext);
172         debug.dump(DebugContext.BASIC_LEVEL, lirGenRes.getLIR(), &quot;After PreAllocationOptimizationStage&quot;);
173 
174         AllocationContext allocContext = new AllocationContext(lirGen.getSpillMoveFactory(), registerAllocationConfig);
175         lirSuites.getAllocationStage().apply(target, lirGenRes, allocContext);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
107 
108     @SuppressWarnings(&quot;try&quot;)
109     public static LIRGenerationResult emitLIR(Backend backend, StructuredGraph graph, Object stub, RegisterConfig registerConfig, LIRSuites lirSuites) {
110         String registerPressure = GraalOptions.RegisterPressure.getValue(graph.getOptions());
111         String[] allocationRestrictedTo = registerPressure == null ? null : registerPressure.split(&quot;,&quot;);
112         try {
113             return emitLIR0(backend, graph, stub, registerConfig, lirSuites, allocationRestrictedTo);
114         } catch (OutOfRegistersException e) {
115             if (allocationRestrictedTo != null) {
116                 allocationRestrictedTo = null;
117                 return emitLIR0(backend, graph, stub, registerConfig, lirSuites, allocationRestrictedTo);
118             }
119             /* If the re-execution fails we convert the exception into a &quot;hard&quot; failure */
120             throw new GraalError(e);
121         } finally {
122             graph.checkCancellation();
123         }
124     }
125 
126     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">127     private static LIRGenerationResult emitLIR0(Backend backend,</span>
<span class="line-added">128                     StructuredGraph graph,</span>
<span class="line-added">129                     Object stub,</span>
<span class="line-added">130                     RegisterConfig registerConfig,</span>
<span class="line-added">131                     LIRSuites lirSuites,</span>
132                     String[] allocationRestrictedTo) {
133         DebugContext debug = graph.getDebug();
134         try (DebugContext.Scope ds = debug.scope(&quot;EmitLIR&quot;); DebugCloseable a = EmitLIR.start(debug)) {
135             assert !graph.hasValueProxies();
136 
137             ScheduleResult schedule = graph.getLastSchedule();
138             Block[] blocks = schedule.getCFG().getBlocks();
139             Block startBlock = schedule.getCFG().getStartBlock();
140             assert startBlock != null;
141             assert startBlock.getPredecessorCount() == 0;
142 
143             AbstractBlockBase&lt;?&gt;[] codeEmittingOrder = ComputeBlockOrder.computeCodeEmittingOrder(blocks.length, startBlock);
144             AbstractBlockBase&lt;?&gt;[] linearScanOrder = ComputeBlockOrder.computeLinearScanOrder(blocks.length, startBlock);
145             LIR lir = new LIR(schedule.getCFG(), linearScanOrder, codeEmittingOrder, graph.getOptions(), graph.getDebug());
146 
147             LIRGenerationProvider lirBackend = (LIRGenerationProvider) backend;
<span class="line-modified">148             RegisterAllocationConfig registerAllocationConfig = backend.newRegisterAllocationConfig(registerConfig, allocationRestrictedTo);</span>
<span class="line-added">149             LIRGenerationResult lirGenRes = lirBackend.newLIRGenerationResult(graph.compilationId(), lir, registerAllocationConfig, graph, stub);</span>
150             LIRGeneratorTool lirGen = lirBackend.newLIRGenerator(lirGenRes);
151             NodeLIRBuilderTool nodeLirGen = lirBackend.newNodeLIRBuilder(graph, lirGen);
152 
153             // LIR generation
154             LIRGenerationContext context = new LIRGenerationContext(lirGen, nodeLirGen, graph, schedule);
155             new LIRGenerationPhase().apply(backend.getTarget(), lirGenRes, context);
156 
157             try (DebugContext.Scope s = debug.scope(&quot;LIRStages&quot;, nodeLirGen, lirGenRes, lir)) {
158                 // Dump LIR along with HIR (the LIR is looked up from context)
159                 debug.dump(DebugContext.BASIC_LEVEL, graph.getLastSchedule(), &quot;After LIR generation&quot;);
<span class="line-modified">160                 LIRGenerationResult result = emitLowLevel(backend.getTarget(), lirGenRes, lirGen, lirSuites, registerAllocationConfig);</span>
161                 return result;
162             } catch (Throwable e) {
163                 throw debug.handle(e);
164             }
165         } catch (Throwable e) {
166             throw debug.handle(e);
167         } finally {
168             graph.checkCancellation();
169         }
170     }
171 
172     private static LIRGenerationResult emitLowLevel(TargetDescription target, LIRGenerationResult lirGenRes, LIRGeneratorTool lirGen, LIRSuites lirSuites,
173                     RegisterAllocationConfig registerAllocationConfig) {
174         DebugContext debug = lirGenRes.getLIR().getDebug();
175         PreAllocationOptimizationContext preAllocOptContext = new PreAllocationOptimizationContext(lirGen);
176         lirSuites.getPreAllocationOptimizationStage().apply(target, lirGenRes, preAllocOptContext);
177         debug.dump(DebugContext.BASIC_LEVEL, lirGenRes.getLIR(), &quot;After PreAllocationOptimizationStage&quot;);
178 
179         AllocationContext allocContext = new AllocationContext(lirGen.getSpillMoveFactory(), registerAllocationConfig);
180         lirSuites.getAllocationStage().apply(target, lirGenRes, allocContext);
</pre>
</td>
</tr>
</table>
<center><a href="DebugInfoBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LIRGenerationProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
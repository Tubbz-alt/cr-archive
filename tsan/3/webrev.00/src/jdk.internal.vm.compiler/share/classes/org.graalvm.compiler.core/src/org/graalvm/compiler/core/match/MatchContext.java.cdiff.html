<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/match/MatchContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../gen/NodeMatchRules.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MatchPattern.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/match/MatchContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,44 ***</span>
   */
  
  
  package org.graalvm.compiler.core.match;
  
  import static org.graalvm.compiler.debug.DebugOptions.LogVerbose;
  
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.List;
  
  import jdk.internal.vm.compiler.collections.EconomicMap;
  import jdk.internal.vm.compiler.collections.Equivalence;
  import org.graalvm.compiler.core.gen.NodeLIRBuilder;
  import org.graalvm.compiler.core.match.MatchPattern.Result;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.nodes.calc.FloatingNode;
  import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  
  /**
   * Container for state captured during a match.
   */
  public class MatchContext {
  
      private final Node root;
  
<span class="line-removed">-     private final List&lt;Node&gt; nodes;</span>
<span class="line-removed">- </span>
      private final MatchStatement rule;
  
      private EconomicMap&lt;String, NamedNode&gt; namedNodes;
  
<span class="line-modified">!     private ArrayList&lt;Node&gt; consumed;</span>
  
<span class="line-modified">!     private int startIndex;</span>
  
<span class="line-modified">!     private int endIndex;</span>
  
      private final NodeLIRBuilder builder;
  
      private static class NamedNode {
          final Class&lt;? extends Node&gt; type;
<span class="line-new-header">--- 22,124 ---</span>
   */
  
  
  package org.graalvm.compiler.core.match;
  
<span class="line-added">+ import static org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph.dominates;</span>
<span class="line-added">+ import static org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph.strictlyDominates;</span>
  import static org.graalvm.compiler.debug.DebugOptions.LogVerbose;
  
  import java.util.ArrayList;
  import java.util.Arrays;
<span class="line-added">+ import java.util.Iterator;</span>
  import java.util.List;
  
  import jdk.internal.vm.compiler.collections.EconomicMap;
  import jdk.internal.vm.compiler.collections.Equivalence;
<span class="line-added">+ import org.graalvm.compiler.core.common.cfg.BlockMap;</span>
  import org.graalvm.compiler.core.gen.NodeLIRBuilder;
  import org.graalvm.compiler.core.match.MatchPattern.Result;
<span class="line-added">+ import org.graalvm.compiler.debug.CounterKey;</span>
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.graph.Node;
<span class="line-added">+ import org.graalvm.compiler.graph.NodeMap;</span>
<span class="line-added">+ import org.graalvm.compiler.nodes.PhiNode;</span>
<span class="line-added">+ import org.graalvm.compiler.nodes.StructuredGraph;</span>
  import org.graalvm.compiler.nodes.calc.FloatingNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.cfg.Block;</span>
  import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  
  /**
   * Container for state captured during a match.
   */
  public class MatchContext {
<span class="line-added">+     private static final CounterKey MatchContextSuccessDifferentBlocks = DebugContext.counter(&quot;MatchContextSuccessDifferentBlocks&quot;);</span>
  
      private final Node root;
  
      private final MatchStatement rule;
<span class="line-added">+     private final StructuredGraph.ScheduleResult schedule;</span>
  
      private EconomicMap&lt;String, NamedNode&gt; namedNodes;
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * A node consumed by a match. Keeps track of whether side effects can be ignored.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static final class ConsumedNode {</span>
<span class="line-added">+         final Node node;</span>
<span class="line-added">+         final boolean ignoresSideEffects;</span>
<span class="line-added">+ </span>
<span class="line-added">+         ConsumedNode(Node node, boolean ignoresSideEffects) {</span>
<span class="line-added">+             this.node = node;</span>
<span class="line-added">+             this.ignoresSideEffects = ignoresSideEffects;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * The collection of nodes consumed by this match.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static final class ConsumedNodes implements Iterable&lt;ConsumedNode&gt; {</span>
<span class="line-added">+         private ArrayList&lt;ConsumedNode&gt; nodes;</span>
<span class="line-added">+ </span>
<span class="line-added">+         ConsumedNodes() {</span>
<span class="line-added">+             this.nodes = null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         public void add(Node node, boolean ignoresSideEffects) {</span>
<span class="line-added">+             if (nodes == null) {</span>
<span class="line-added">+                 nodes = new ArrayList&lt;&gt;(2);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             nodes.add(new ConsumedNode(node, ignoresSideEffects));</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         public boolean contains(Node node) {</span>
<span class="line-added">+             for (ConsumedNode c : nodes) {</span>
<span class="line-added">+                 if (c.node == node) {</span>
<span class="line-added">+                     return true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         public ConsumedNode find(Node node) {</span>
<span class="line-added">+             for (ConsumedNode c : nodes) {</span>
<span class="line-added">+                 if (c.node == node) {</span>
<span class="line-added">+                     return c;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public String toString() {</span>
<span class="line-added">+             Node[] arr = new Node[nodes.size()];</span>
<span class="line-added">+             int i = 0;</span>
<span class="line-added">+             for (ConsumedNode c : nodes) {</span>
<span class="line-added">+                 arr[i++] = c.node;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return Arrays.toString(arr);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public Iterator&lt;ConsumedNode&gt; iterator() {</span>
<span class="line-added">+             return nodes.iterator();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     private ConsumedNodes consumed = new ConsumedNodes();</span>
  
<span class="line-modified">!     private Block rootBlock;</span>
<span class="line-added">+     private int rootIndex;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Block and index in the block at which the match should be emitted. Differs from</span>
<span class="line-added">+      * rootBlock/rootIndex for (ZeroExtend Read=access) for instance: match should be emitted where</span>
<span class="line-added">+      * the Read is.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private int emitIndex;</span>
<span class="line-added">+     private Block emitBlock;</span>
  
      private final NodeLIRBuilder builder;
  
      private static class NamedNode {
          final Class&lt;? extends Node&gt; type;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,18 ***</span>
              this.type = type;
              this.value = value;
          }
      }
  
<span class="line-modified">!     public MatchContext(NodeLIRBuilder builder, MatchStatement rule, int index, Node node, List&lt;Node&gt; nodes) {</span>
          this.builder = builder;
          this.rule = rule;
          this.root = node;
<span class="line-modified">!         this.nodes = nodes;</span>
<span class="line-modified">!         assert index == nodes.indexOf(node);</span>
          // The root should be the last index since all the inputs must be scheduled before it.
<span class="line-modified">!         startIndex = endIndex = index;</span>
      }
  
      public Node getRoot() {
          return root;
      }
<span class="line-new-header">--- 149,19 ---</span>
              this.type = type;
              this.value = value;
          }
      }
  
<span class="line-modified">!     public MatchContext(NodeLIRBuilder builder, MatchStatement rule, int index, Node node, Block rootBlock, StructuredGraph.ScheduleResult schedule) {</span>
          this.builder = builder;
          this.rule = rule;
          this.root = node;
<span class="line-modified">!         assert index == schedule.getBlockToNodesMap().get(rootBlock).indexOf(node);</span>
<span class="line-modified">!         this.schedule = schedule;</span>
          // The root should be the last index since all the inputs must be scheduled before it.
<span class="line-modified">!         this.rootBlock = rootBlock;</span>
<span class="line-added">+         rootIndex = index;</span>
      }
  
      public Node getRoot() {
          return root;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,79 ***</span>
              return Result.OK;
          }
      }
  
      public Result validate() {
<span class="line-modified">!         // Ensure that there&#39;s no unsafe work in between these operations.</span>
<span class="line-modified">!         for (int i = startIndex; i &lt;= endIndex; i++) {</span>
              Node node = nodes.get(i);
<span class="line-modified">!             if (node instanceof VirtualObjectNode || node instanceof FloatingNode) {</span>
<span class="line-modified">!                 // The order of evaluation of these nodes controlled by data dependence so they</span>
<span class="line-modified">!                 // don&#39;t interfere with this match.</span>
<span class="line-modified">!                 continue;</span>
<span class="line-modified">!             } else if ((consumed == null || !consumed.contains(node)) &amp;&amp; node != root) {</span>
<span class="line-modified">!                 if (LogVerbose.getValue(root.getOptions())) {</span>
<span class="line-modified">!                     DebugContext debug = root.getDebug();</span>
<span class="line-modified">!                     debug.log(&quot;unexpected node %s&quot;, node);</span>
<span class="line-modified">!                     for (int j = startIndex; j &lt;= endIndex; j++) {</span>
<span class="line-modified">!                         Node theNode = nodes.get(j);</span>
<span class="line-modified">!                         debug.log(&quot;%s(%s) %1s&quot;, (consumed != null &amp;&amp; consumed.contains(theNode) || theNode == root) ? &quot;*&quot; : &quot; &quot;, theNode.getUsageCount(), theNode);</span>
                      }
                  }
<span class="line-removed">-                 return Result.notSafe(node, rule.getPattern());</span>
              }
          }
          return Result.OK;
      }
  
      /**
       * Mark the interior nodes with INTERIOR_MATCH and set the Value of the root to be the result.
       * During final LIR generation it will be evaluated to produce the actual LIR value.
       *
       * @param result
       */
      public void setResult(ComplexMatchResult result) {
          ComplexMatchValue value = new ComplexMatchValue(result);
          DebugContext debug = root.getDebug();
          if (debug.isLogEnabled()) {
<span class="line-modified">!             debug.log(&quot;matched %s %s&quot;, rule.getName(), rule.getPattern());</span>
              debug.log(&quot;with nodes %s&quot;, rule.formatMatch(root));
          }
<span class="line-modified">!         if (consumed != null) {</span>
<span class="line-modified">!             for (Node node : consumed) {</span>
<span class="line-modified">!                 // All the interior nodes should be skipped during the normal doRoot calls in</span>
<span class="line-removed">-                 // NodeLIRBuilder so mark them as interior matches. The root of the match will get a</span>
<span class="line-removed">-                 // closure which will be evaluated to produce the final LIR.</span>
<span class="line-removed">-                 builder.setMatchResult(node, ComplexMatchValue.INTERIOR_MATCH);</span>
              }
          }
<span class="line-removed">-         builder.setMatchResult(root, value);</span>
      }
  
      /**
       * Mark a node as consumed by the match. Consumed nodes will never be evaluated.
       *
       * @return Result.OK if the node can be safely consumed.
       */
<span class="line-modified">!     public Result consume(Node node) {</span>
<span class="line-modified">!         assert MatchPattern.isSingleValueUser(node) : &quot;should have already been checked&quot;;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Check NOT_IN_BLOCK first since that usually implies ALREADY_USED</span>
<span class="line-removed">-         int index = nodes.indexOf(node);</span>
<span class="line-removed">-         if (index == -1) {</span>
<span class="line-removed">-             return Result.notInBlock(node, rule.getPattern());</span>
          }
  
          if (builder.hasOperand(node)) {
              return Result.alreadyUsed(node, rule.getPattern());
          }
  
<span class="line-modified">!         startIndex = Math.min(startIndex, index);</span>
<span class="line-removed">-         if (consumed == null) {</span>
<span class="line-removed">-             consumed = new ArrayList&lt;&gt;(2);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         consumed.add(node);</span>
          return Result.OK;
      }
  
      /**
       * Return the named node. It&#39;s an error if the
<span class="line-new-header">--- 182,230 ---</span>
              return Result.OK;
          }
      }
  
      public Result validate() {
<span class="line-modified">!         Result result = findEarlyPosition();</span>
<span class="line-modified">!         if (result != Result.OK) {</span>
<span class="line-added">+             return result;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         findLatePosition();</span>
<span class="line-added">+         assert emitIndex == rootIndex || consumed.find(root).ignoresSideEffects;</span>
<span class="line-added">+         return verifyInputs();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private Result findEarlyPosition() {</span>
<span class="line-added">+         int startIndexSideEffect = -1;</span>
<span class="line-added">+         int endIndexSideEffect = -1;</span>
<span class="line-added">+         final NodeMap&lt;Block&gt; nodeToBlockMap = schedule.getNodeToBlockMap();</span>
<span class="line-added">+         final BlockMap&lt;List&lt;Node&gt;&gt; blockToNodesMap = schedule.getBlockToNodesMap();</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Nodes affected by side effects must be in the same block</span>
<span class="line-added">+         for (ConsumedNode cn : consumed) {</span>
<span class="line-added">+             if (!cn.ignoresSideEffects) {</span>
<span class="line-added">+                 Block b = nodeToBlockMap.get(cn.node);</span>
<span class="line-added">+                 if (emitBlock == null) {</span>
<span class="line-added">+                     emitBlock = b;</span>
<span class="line-added">+                     startIndexSideEffect = endIndexSideEffect = blockToNodesMap.get(b).indexOf(cn.node);</span>
<span class="line-added">+                 } else if (emitBlock == b) {</span>
<span class="line-added">+                     int index = blockToNodesMap.get(b).indexOf(cn.node);</span>
<span class="line-added">+                     startIndexSideEffect = Math.min(startIndexSideEffect, index);</span>
<span class="line-added">+                     endIndexSideEffect = Math.max(endIndexSideEffect, index);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     logFailedMatch(&quot;nodes affected by side effects in different blocks %s&quot;, cn.node);</span>
<span class="line-added">+                     return Result.notInBlock(cn.node, rule.getPattern());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (emitBlock != null) {</span>
<span class="line-added">+             // There must be no side effects between nodes that are affected by side effects</span>
<span class="line-added">+             assert startIndexSideEffect != -1 &amp;&amp; endIndexSideEffect != -1;</span>
<span class="line-added">+             final List&lt;Node&gt; nodes = blockToNodesMap.get(emitBlock);</span>
<span class="line-added">+             for (int i = startIndexSideEffect; i &lt;= endIndexSideEffect; i++) {</span>
<span class="line-added">+                 Node node = nodes.get(i);</span>
<span class="line-added">+                 if (!sideEffectFree(node) &amp;&amp; !consumed.contains(node)) {</span>
<span class="line-added">+                     logFailedMatch(&quot;unexpected side effect %s&quot;, node);</span>
<span class="line-added">+                     return Result.notSafe(node, rule.getPattern());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // early position is at the node affected by side effects the closest to the root</span>
<span class="line-added">+             emitIndex = endIndexSideEffect;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             // Nodes not affected by side effect: early position is at the root</span>
<span class="line-added">+             emitBlock = nodeToBlockMap.get(root);</span>
<span class="line-added">+             emitIndex = rootIndex;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return Result.OK;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static boolean sideEffectFree(Node node) {</span>
<span class="line-added">+         // The order of evaluation of these nodes controlled by data dependence so they</span>
<span class="line-added">+         // don&#39;t interfere with this match.</span>
<span class="line-added">+         return node instanceof VirtualObjectNode || node instanceof FloatingNode;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private void findLatePosition() {</span>
<span class="line-added">+         // If emit position is at a node affected by side effects that&#39;s followed by side effect</span>
<span class="line-added">+         // free nodes, the node can be emitted later. This helps when the match has inputs that are</span>
<span class="line-added">+         // late in the block.</span>
<span class="line-added">+         int index = rootIndex;</span>
<span class="line-added">+         if (emitBlock != rootBlock) {</span>
<span class="line-added">+             index = schedule.getBlockToNodesMap().get(emitBlock).size() - 1;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         final List&lt;Node&gt; emitBlockNodes = schedule.getBlockToNodesMap().get(emitBlock);</span>
<span class="line-added">+         for (int i = emitIndex + 1; i &lt;= index; i++) {</span>
<span class="line-added">+             Node node = emitBlockNodes.get(i);</span>
<span class="line-added">+             ConsumedNode cn = consumed.find(node);</span>
<span class="line-added">+             if (cn == null) {</span>
<span class="line-added">+                 if (!sideEffectFree(node)) {</span>
<span class="line-added">+                     return;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 assert cn.ignoresSideEffects;</span>
<span class="line-added">+                 emitIndex = i;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private Result verifyInputs() {</span>
<span class="line-added">+         DebugContext debug = root.getDebug();</span>
<span class="line-added">+         if (emitBlock != rootBlock) {</span>
<span class="line-added">+             assert consumed.find(root).ignoresSideEffects;</span>
<span class="line-added">+             Result result = verifyInputsDifferentBlock(root);</span>
<span class="line-added">+             if (result == Result.OK) {</span>
<span class="line-added">+                 MatchContextSuccessDifferentBlocks.increment(debug);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return result;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // We are going to emit the match at emitIndex. We need to make sure nodes of the match</span>
<span class="line-added">+         // between emitIndex and rootIndex don&#39;t have inputs after position emitIndex that would</span>
<span class="line-added">+         // make emitIndex an illegal position.</span>
<span class="line-added">+         final List&lt;Node&gt; nodes = schedule.getBlockToNodesMap().get(rootBlock);</span>
<span class="line-added">+         for (int i = emitIndex + 1; i &lt;= rootIndex; i++) {</span>
              Node node = nodes.get(i);
<span class="line-modified">!             ConsumedNode cn = consumed.find(node);</span>
<span class="line-modified">!             if (cn != null) {</span>
<span class="line-modified">!                 assert cn.ignoresSideEffects;</span>
<span class="line-modified">!                 for (Node in : node.inputs()) {</span>
<span class="line-modified">!                     if (!consumed.contains(in)) {</span>
<span class="line-modified">!                         for (int j = emitIndex + 1; j &lt; i; j++) {</span>
<span class="line-modified">!                             if (nodes.get(j) == in) {</span>
<span class="line-modified">!                                 logFailedMatch(&quot;Earliest position in block is too late %s&quot;, in);</span>
<span class="line-modified">!                                 assert consumed.find(root).ignoresSideEffects;</span>
<span class="line-modified">!                                 assert verifyInputsDifferentBlock(root) != Result.OK;</span>
<span class="line-modified">!                                 return Result.tooLate(node, rule.getPattern());</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
                      }
                  }
              }
          }
<span class="line-added">+         assert verifyInputsDifferentBlock(root) == Result.OK;</span>
          return Result.OK;
      }
  
<span class="line-added">+     private Result verifyInputsDifferentBlock(Node node) {</span>
<span class="line-added">+         // Is there an input that&#39;s not part of the match that&#39;s after the emit position?</span>
<span class="line-added">+         for (Node in : node.inputs()) {</span>
<span class="line-added">+             if (in instanceof PhiNode) {</span>
<span class="line-added">+                 Block b = schedule.getNodeToBlockMap().get(((PhiNode) in).merge());</span>
<span class="line-added">+                 if (dominates(b, emitBlock)) {</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 Block b = schedule.getNodeToBlockMap().get(in);</span>
<span class="line-added">+                 if (strictlyDominates(b, emitBlock) || (b == emitBlock &amp;&amp; schedule.getBlockToNodesMap().get(emitBlock).indexOf(in) &lt;= emitIndex)) {</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             ConsumedNode cn = consumed.find(in);</span>
<span class="line-added">+             if (cn == null) {</span>
<span class="line-added">+                 logFailedMatch(&quot;Earliest position in block is too late %s&quot;, in);</span>
<span class="line-added">+                 return Result.tooLate(node, rule.getPattern());</span>
<span class="line-added">+             }</span>
<span class="line-added">+             assert cn.ignoresSideEffects;</span>
<span class="line-added">+             Result res = verifyInputsDifferentBlock(in);</span>
<span class="line-added">+             if (res != Result.OK) {</span>
<span class="line-added">+                 return res;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return Result.OK;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private void logFailedMatch(String s, Node node) {</span>
<span class="line-added">+         if (LogVerbose.getValue(root.getOptions())) {</span>
<span class="line-added">+             DebugContext debug = root.getDebug();</span>
<span class="line-added">+             debug.log(s, node);</span>
<span class="line-added">+             int startIndex = emitIndex;</span>
<span class="line-added">+             if (emitBlock != rootBlock) {</span>
<span class="line-added">+                 int endIndex = schedule.getBlockToNodesMap().get(emitBlock).size() - 1;</span>
<span class="line-added">+                 final List&lt;Node&gt; emitBlockNodes = schedule.getBlockToNodesMap().get(emitBlock);</span>
<span class="line-added">+                 debug.log(&quot;%s:&quot;, emitBlock);</span>
<span class="line-added">+                 for (int j = startIndex; j &lt;= endIndex; j++) {</span>
<span class="line-added">+                     Node theNode = emitBlockNodes.get(j);</span>
<span class="line-added">+                     debug.log(&quot;%s(%s) %1s&quot;, consumed.contains(theNode) ? &quot;*&quot; : &quot; &quot;, theNode.getUsageCount(), theNode);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 startIndex = 0;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             debug.log(&quot;%s:&quot;, rootBlock);</span>
<span class="line-added">+             final List&lt;Node&gt; nodes = schedule.getBlockToNodesMap().get(rootBlock);</span>
<span class="line-added">+             for (int j = startIndex; j &lt;= rootIndex; j++) {</span>
<span class="line-added">+                 Node theNode = nodes.get(j);</span>
<span class="line-added">+                 debug.log(&quot;%s(%s) %1s&quot;, consumed.contains(theNode) ? &quot;*&quot; : &quot; &quot;, theNode.getUsageCount(), theNode);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Mark the interior nodes with INTERIOR_MATCH and set the Value of the root to be the result.
       * During final LIR generation it will be evaluated to produce the actual LIR value.
       *
       * @param result
       */
      public void setResult(ComplexMatchResult result) {
          ComplexMatchValue value = new ComplexMatchValue(result);
<span class="line-added">+         Node emitNode = schedule.getBlockToNodesMap().get(emitBlock).get(emitIndex);</span>
          DebugContext debug = root.getDebug();
          if (debug.isLogEnabled()) {
<span class="line-modified">!             debug.log(&quot;matched %s %s%s&quot;, rule.getName(), rule.getPattern(), emitIndex != rootIndex ? &quot; skipping side effects&quot; : &quot;&quot;);</span>
              debug.log(&quot;with nodes %s&quot;, rule.formatMatch(root));
          }
<span class="line-modified">!         for (ConsumedNode cn : consumed) {</span>
<span class="line-modified">!             if (cn.node == root || cn.node == emitNode) {</span>
<span class="line-modified">!                 continue;</span>
              }
<span class="line-added">+             // All the interior nodes should be skipped during the normal doRoot calls in</span>
<span class="line-added">+             // NodeLIRBuilder so mark them as interior matches. The root of the match will get a</span>
<span class="line-added">+             // closure which will be evaluated to produce the final LIR.</span>
<span class="line-added">+             builder.setMatchResult(cn.node, ComplexMatchValue.INTERIOR_MATCH);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         builder.setMatchResult(emitNode, value);</span>
<span class="line-added">+         if (root != emitNode) {</span>
<span class="line-added">+             // Match is not emitted at the position of root in the block but the uses of root needs</span>
<span class="line-added">+             // the result of the match so add a ComplexMatchValue that will simply return the result</span>
<span class="line-added">+             // of the actual match above.</span>
<span class="line-added">+             builder.setMatchResult(root, new ComplexMatchValue(gen -&gt; gen.operand(emitNode)));</span>
          }
      }
  
      /**
       * Mark a node as consumed by the match. Consumed nodes will never be evaluated.
       *
       * @return Result.OK if the node can be safely consumed.
       */
<span class="line-modified">!     public Result consume(Node node, boolean ignoresSideEffects, boolean atRoot) {</span>
<span class="line-modified">!         if (atRoot) {</span>
<span class="line-modified">!             consumed.add(node, ignoresSideEffects);</span>
<span class="line-modified">!             return Result.OK;</span>
          }
<span class="line-added">+         assert MatchPattern.isSingleValueUser(node) : &quot;should have already been checked&quot;;</span>
  
          if (builder.hasOperand(node)) {
              return Result.alreadyUsed(node, rule.getPattern());
          }
  
<span class="line-modified">!         consumed.add(node, ignoresSideEffects);</span>
          return Result.OK;
      }
  
      /**
       * Return the named node. It&#39;s an error if the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 192,8 ***</span>
          throw new GraalError(&quot;missing node %s&quot;, name);
      }
  
      @Override
      public String toString() {
<span class="line-modified">!         return String.format(&quot;%s %s (%d, %d) consumed %s&quot;, rule, root, startIndex, endIndex, consumed != null ? Arrays.toString(consumed.toArray()) : &quot;&quot;);</span>
      }
  }
<span class="line-new-header">--- 424,8 ---</span>
          throw new GraalError(&quot;missing node %s&quot;, name);
      }
  
      @Override
      public String toString() {
<span class="line-modified">!         return String.format(&quot;%s %s (%s/%d, %s/%d) consumed %s&quot;, rule, root, rootBlock, rootIndex, emitBlock, emitIndex, consumed);</span>
      }
  }
</pre>
<center><a href="../gen/NodeMatchRules.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MatchPattern.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
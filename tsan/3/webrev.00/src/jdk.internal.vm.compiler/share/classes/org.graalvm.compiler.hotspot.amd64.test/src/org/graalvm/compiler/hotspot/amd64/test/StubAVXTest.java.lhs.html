<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64.test/src/org/graalvm/compiler/hotspot/amd64/test/StubAVXTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package org.graalvm.compiler.hotspot.amd64.test;
 27 
<a name="2" id="anc2"></a>
 28 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
 29 
 30 import org.graalvm.compiler.api.replacements.Snippet;
 31 import org.graalvm.compiler.asm.amd64.AMD64Address;
 32 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 33 import org.graalvm.compiler.bytecode.BytecodeProvider;
 34 import org.graalvm.compiler.core.common.CompilationIdentifier;
 35 import org.graalvm.compiler.core.common.LIRKind;
 36 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 37 import org.graalvm.compiler.core.common.type.DataPointerConstant;
 38 import org.graalvm.compiler.debug.DebugContext;
 39 import org.graalvm.compiler.hotspot.HotSpotBackend;
 40 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
 41 import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProviderImpl;
 42 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 43 import org.graalvm.compiler.hotspot.stubs.SnippetStub;
 44 import org.graalvm.compiler.lir.LIRInstructionClass;
 45 import org.graalvm.compiler.lir.Variable;
 46 import org.graalvm.compiler.lir.amd64.AMD64LIRInstruction;
 47 import org.graalvm.compiler.lir.asm.ArrayDataPointerConstant;
 48 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 49 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 50 import org.graalvm.compiler.lir.jtt.LIRTest;
 51 import org.graalvm.compiler.lir.jtt.LIRTestSpecification;
 52 import org.graalvm.compiler.nodes.StructuredGraph;
 53 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 54 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 55 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 56 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 57 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 58 import org.graalvm.compiler.options.OptionValues;
 59 import org.graalvm.compiler.replacements.ReplacementsImpl;
 60 import org.graalvm.compiler.replacements.classfile.ClassfileBytecodeProvider;
 61 import org.junit.Assume;
 62 import org.junit.Before;
 63 import org.junit.Test;
 64 
 65 import jdk.vm.ci.amd64.AMD64;
 66 import jdk.vm.ci.amd64.AMD64.CPUFeature;
 67 import jdk.vm.ci.amd64.AMD64Kind;
 68 import jdk.vm.ci.code.Register;
 69 import jdk.vm.ci.code.ValueUtil;
 70 import jdk.vm.ci.meta.AllocatableValue;
 71 import jdk.vm.ci.meta.MetaAccessProvider;
 72 import jdk.vm.ci.meta.ResolvedJavaMethod;
 73 import jdk.vm.ci.meta.Value;
 74 
 75 public class StubAVXTest extends LIRTest {
 76 
 77     @Before
 78     public void checkAMD64() {
 79         Assume.assumeTrue(&quot;skipping AMD64 specific test&quot;, getTarget().arch instanceof AMD64);
 80         Assume.assumeTrue(&quot;skipping AVX test&quot;, ((AMD64) getTarget().arch).getFeatures().contains(CPUFeature.AVX));
 81         if (getBackend() instanceof HotSpotBackend) {
 82             HotSpotBackend backend = (HotSpotBackend) getBackend();
 83             Assume.assumeTrue(&quot;skipping because of MaxVectorSize&quot;, backend.getRuntime().getVMConfig().maxVectorSize &gt;= 32);
 84         }
 85     }
 86 
 87     private static final DataPointerConstant avxConstant = new ArrayDataPointerConstant(new float[]{1f, 2f, 3f, 4f, 5f, 6f, 7f, 8f}, 32);
 88 
 89     private static class LoadAVXConstant extends AMD64LIRInstruction {
 90         public static final LIRInstructionClass&lt;LoadAVXConstant&gt; TYPE = LIRInstructionClass.create(LoadAVXConstant.class);
 91 
 92         @Def({REG}) AllocatableValue result;
 93 
 94         LoadAVXConstant(AllocatableValue result) {
 95             super(TYPE);
 96             this.result = result;
 97         }
 98 
 99         @Override
100         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
101             masm.vmovdqu(ValueUtil.asRegister(result), (AMD64Address) crb.recordDataReferenceInCode(avxConstant));
102         }
103     }
104 
105     private static final LIRTestSpecification loadAVXConstant = new LIRTestSpecification() {
106 
107         @Override
108         public void generate(LIRGeneratorTool gen) {
109             Variable ret = gen.newVariable(LIRKind.value(AMD64Kind.V256_SINGLE));
110             gen.append(new LoadAVXConstant(ret));
111             setResult(ret);
112         }
113     };
114 
115     @LIRIntrinsic
116     public static Object loadAVXConstant(@SuppressWarnings(&quot;unused&quot;) LIRTestSpecification spec) {
117         return null;
118     }
119 
120     private static class CompareAVXRegister extends AMD64LIRInstruction {
121         public static final LIRInstructionClass&lt;CompareAVXRegister&gt; TYPE = LIRInstructionClass.create(CompareAVXRegister.class);
122 
123         @Def({REG}) AllocatableValue result;
124         @Use({REG}) AllocatableValue left;
125         @Use({REG}) AllocatableValue right;
126         @Temp({REG}) AllocatableValue temp;
127 
128         CompareAVXRegister(AllocatableValue result, AllocatableValue left, AllocatableValue right, AllocatableValue temp) {
129             super(TYPE);
130             this.result = result;
131             this.left = left;
132             this.right = right;
133             this.temp = temp;
134         }
135 
136         private static int getRXB(Register reg, Register rm) {
137             int rxb = (reg.encoding &amp; 0x08) &gt;&gt; 1;
138             rxb |= (rm.encoding &amp; 0x08) &gt;&gt; 3;
139             return rxb;
140         }
141 
142         @Override
143         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
144             Register res = ValueUtil.asRegister(result);
145             Register x = ValueUtil.asRegister(left);
146             Register y = ValueUtil.asRegister(right);
147             Register tmp = ValueUtil.asRegister(temp);
148 
149             // VEX.NDS.256.0F.WIG C2 /r ib(0)
150             // VCMPPS tmp, x, y, EQ
151             masm.emitByte(0xC4);                                   // VEX 3-byte
152             masm.emitByte((~getRXB(tmp, y) &amp; 0x7) &lt;&lt; 5 | 0x01);    // RXB m-mmmmm (0F)
153             masm.emitByte(((~x.encoding &amp; 0x0f) &lt;&lt; 3) | 0b1_00);   // W(0) vvvv L(1) pp(0)
154             masm.emitByte(0xC2);
155             masm.emitByte(0xC0 | ((tmp.encoding &amp; 0x07) &lt;&lt; 3) | (y.encoding &amp; 0x07));
156             masm.emitByte(0);
157 
158             // VEX.256.0F.WIG 50 /r
159             // VMOVMSKPS res, tmp
160             masm.emitByte(0xC4);                                   // VEX 3-byte
161             masm.emitByte((~getRXB(res, tmp) &amp; 0x7) &lt;&lt; 5 | 0x01);  // RXB m-mmmmm (0F)
162             masm.emitByte(0b0_1111_1_00);                          // W(0) vvvv L(1) pp(0)
163             masm.emitByte(0x50);
164             masm.emitByte(0xC0 | ((res.encoding &amp; 0x07) &lt;&lt; 3) | (tmp.encoding &amp; 0x07));
165         }
166     }
167 
168     private static final LIRTestSpecification compareAVXRegister = new LIRTestSpecification() {
169 
170         @Override
171         public void generate(LIRGeneratorTool gen, Value arg0, Value arg1) {
172             Variable ret = gen.newVariable(LIRKind.value(AMD64Kind.DWORD));
173             gen.append(new CompareAVXRegister(ret, gen.asAllocatable(arg0), gen.asAllocatable(arg1), gen.newVariable(LIRKind.value(AMD64Kind.V256_QWORD))));
174             setResult(ret);
175         }
176     };
177 
178     private static class TestStub extends SnippetStub {
179 
180         TestStub(OptionValues options, HotSpotProviders providers, HotSpotForeignCallLinkage linkage) {
181             super(&quot;testStub&quot;, options, providers, linkage);
182         }
183 
184         @Snippet
185         static void testStub() {
186         }
187 
188         @Override
189         protected void registerSnippet() {
190         }
191 
192         @Override
193         protected StructuredGraph buildInitialGraph(DebugContext debug, CompilationIdentifier compilationId, Object[] args) {
194             // Build the snippet graph directly since snippet registration is closed at this point.
195             ReplacementsImpl d = (ReplacementsImpl) providers.getReplacements();
196             MetaAccessProvider metaAccess = d.getProviders().getMetaAccess();
197             BytecodeProvider bytecodes = new ClassfileBytecodeProvider(metaAccess, d.snippetReflection, ClassLoader.getSystemClassLoader());
198             return d.makeGraph(debug, bytecodes, method, args, null, false, null);
199         }
200     }
201 
202     public static final ForeignCallDescriptor TEST_STUB = new ForeignCallDescriptor(&quot;test_stub&quot;, void.class);
203 
204     @LIRIntrinsic
205     public static int compareAVXRegister(@SuppressWarnings(&quot;unused&quot;) LIRTestSpecification spec, Object left, Object right) {
206         return left == right ? 0xff : 0;
207     }
208 
209     @Override
210     protected GraphBuilderConfiguration editGraphBuilderConfiguration(GraphBuilderConfiguration conf) {
211         InvocationPlugins invocationPlugins = conf.getPlugins().getInvocationPlugins();
212         InvocationPlugins.Registration r = new InvocationPlugins.Registration(invocationPlugins, TestStub.class);
213         r.register0(&quot;testStub&quot;, new InvocationPlugin() {
214             @Override
215             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver) {
216                 b.add(new ForeignCallNode(getProviders().getForeignCalls(), TEST_STUB));
217                 return true;
218             }
219         });
220         return super.editGraphBuilderConfiguration(conf);
221     }
222 
223     public static int testStub() {
224         Object preStub = loadAVXConstant(loadAVXConstant);
225 
226         // do something to potentially destroy the value
227         TestStub.testStub();
228 
229         Object postStub = loadAVXConstant(loadAVXConstant);
230         return compareAVXRegister(compareAVXRegister, preStub, postStub);
231     }
232 
233     @Test
234     public void test() {
235         HotSpotProviders providers = (HotSpotProviders) getProviders();
236         HotSpotForeignCallsProviderImpl foreignCalls = (HotSpotForeignCallsProviderImpl) providers.getForeignCalls();
<a name="3" id="anc3"></a><span class="line-modified">237         HotSpotForeignCallLinkage linkage = foreignCalls.registerStubCall(TEST_STUB, HotSpotForeignCallLinkage.Transition.LEAF_NOFP, HotSpotForeignCallLinkage.Reexecutability.REEXECUTABLE);</span>

238         linkage.setCompiledStub(new TestStub(getInitialOptions(), providers, linkage));
239         runTest(&quot;testStub&quot;);
240     }
241 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
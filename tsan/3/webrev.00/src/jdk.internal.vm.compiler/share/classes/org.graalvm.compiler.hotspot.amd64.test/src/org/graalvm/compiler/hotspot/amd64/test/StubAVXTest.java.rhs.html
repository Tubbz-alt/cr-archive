<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64.test/src/org/graalvm/compiler/hotspot/amd64/test/StubAVXTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package org.graalvm.compiler.hotspot.amd64.test;
 27 
<a name="2" id="anc2"></a><span class="line-added"> 28 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.RegisterEffect.COMPUTES_REGISTERS_KILLED;</span>
 29 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
 30 
 31 import org.graalvm.compiler.api.replacements.Snippet;
 32 import org.graalvm.compiler.asm.amd64.AMD64Address;
 33 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 34 import org.graalvm.compiler.bytecode.BytecodeProvider;
 35 import org.graalvm.compiler.core.common.CompilationIdentifier;
 36 import org.graalvm.compiler.core.common.LIRKind;
 37 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 38 import org.graalvm.compiler.core.common.type.DataPointerConstant;
 39 import org.graalvm.compiler.debug.DebugContext;
 40 import org.graalvm.compiler.hotspot.HotSpotBackend;
 41 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
 42 import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProviderImpl;
 43 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 44 import org.graalvm.compiler.hotspot.stubs.SnippetStub;
 45 import org.graalvm.compiler.lir.LIRInstructionClass;
 46 import org.graalvm.compiler.lir.Variable;
 47 import org.graalvm.compiler.lir.amd64.AMD64LIRInstruction;
 48 import org.graalvm.compiler.lir.asm.ArrayDataPointerConstant;
 49 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 50 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 51 import org.graalvm.compiler.lir.jtt.LIRTest;
 52 import org.graalvm.compiler.lir.jtt.LIRTestSpecification;
 53 import org.graalvm.compiler.nodes.StructuredGraph;
 54 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 55 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 56 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 57 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 58 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 59 import org.graalvm.compiler.options.OptionValues;
 60 import org.graalvm.compiler.replacements.ReplacementsImpl;
 61 import org.graalvm.compiler.replacements.classfile.ClassfileBytecodeProvider;
 62 import org.junit.Assume;
 63 import org.junit.Before;
 64 import org.junit.Test;
 65 
 66 import jdk.vm.ci.amd64.AMD64;
 67 import jdk.vm.ci.amd64.AMD64.CPUFeature;
 68 import jdk.vm.ci.amd64.AMD64Kind;
 69 import jdk.vm.ci.code.Register;
 70 import jdk.vm.ci.code.ValueUtil;
 71 import jdk.vm.ci.meta.AllocatableValue;
 72 import jdk.vm.ci.meta.MetaAccessProvider;
 73 import jdk.vm.ci.meta.ResolvedJavaMethod;
 74 import jdk.vm.ci.meta.Value;
 75 
 76 public class StubAVXTest extends LIRTest {
 77 
 78     @Before
 79     public void checkAMD64() {
 80         Assume.assumeTrue(&quot;skipping AMD64 specific test&quot;, getTarget().arch instanceof AMD64);
 81         Assume.assumeTrue(&quot;skipping AVX test&quot;, ((AMD64) getTarget().arch).getFeatures().contains(CPUFeature.AVX));
 82         if (getBackend() instanceof HotSpotBackend) {
 83             HotSpotBackend backend = (HotSpotBackend) getBackend();
 84             Assume.assumeTrue(&quot;skipping because of MaxVectorSize&quot;, backend.getRuntime().getVMConfig().maxVectorSize &gt;= 32);
 85         }
 86     }
 87 
 88     private static final DataPointerConstant avxConstant = new ArrayDataPointerConstant(new float[]{1f, 2f, 3f, 4f, 5f, 6f, 7f, 8f}, 32);
 89 
 90     private static class LoadAVXConstant extends AMD64LIRInstruction {
 91         public static final LIRInstructionClass&lt;LoadAVXConstant&gt; TYPE = LIRInstructionClass.create(LoadAVXConstant.class);
 92 
 93         @Def({REG}) AllocatableValue result;
 94 
 95         LoadAVXConstant(AllocatableValue result) {
 96             super(TYPE);
 97             this.result = result;
 98         }
 99 
100         @Override
101         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
102             masm.vmovdqu(ValueUtil.asRegister(result), (AMD64Address) crb.recordDataReferenceInCode(avxConstant));
103         }
104     }
105 
106     private static final LIRTestSpecification loadAVXConstant = new LIRTestSpecification() {
107 
108         @Override
109         public void generate(LIRGeneratorTool gen) {
110             Variable ret = gen.newVariable(LIRKind.value(AMD64Kind.V256_SINGLE));
111             gen.append(new LoadAVXConstant(ret));
112             setResult(ret);
113         }
114     };
115 
116     @LIRIntrinsic
117     public static Object loadAVXConstant(@SuppressWarnings(&quot;unused&quot;) LIRTestSpecification spec) {
118         return null;
119     }
120 
121     private static class CompareAVXRegister extends AMD64LIRInstruction {
122         public static final LIRInstructionClass&lt;CompareAVXRegister&gt; TYPE = LIRInstructionClass.create(CompareAVXRegister.class);
123 
124         @Def({REG}) AllocatableValue result;
125         @Use({REG}) AllocatableValue left;
126         @Use({REG}) AllocatableValue right;
127         @Temp({REG}) AllocatableValue temp;
128 
129         CompareAVXRegister(AllocatableValue result, AllocatableValue left, AllocatableValue right, AllocatableValue temp) {
130             super(TYPE);
131             this.result = result;
132             this.left = left;
133             this.right = right;
134             this.temp = temp;
135         }
136 
137         private static int getRXB(Register reg, Register rm) {
138             int rxb = (reg.encoding &amp; 0x08) &gt;&gt; 1;
139             rxb |= (rm.encoding &amp; 0x08) &gt;&gt; 3;
140             return rxb;
141         }
142 
143         @Override
144         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
145             Register res = ValueUtil.asRegister(result);
146             Register x = ValueUtil.asRegister(left);
147             Register y = ValueUtil.asRegister(right);
148             Register tmp = ValueUtil.asRegister(temp);
149 
150             // VEX.NDS.256.0F.WIG C2 /r ib(0)
151             // VCMPPS tmp, x, y, EQ
152             masm.emitByte(0xC4);                                   // VEX 3-byte
153             masm.emitByte((~getRXB(tmp, y) &amp; 0x7) &lt;&lt; 5 | 0x01);    // RXB m-mmmmm (0F)
154             masm.emitByte(((~x.encoding &amp; 0x0f) &lt;&lt; 3) | 0b1_00);   // W(0) vvvv L(1) pp(0)
155             masm.emitByte(0xC2);
156             masm.emitByte(0xC0 | ((tmp.encoding &amp; 0x07) &lt;&lt; 3) | (y.encoding &amp; 0x07));
157             masm.emitByte(0);
158 
159             // VEX.256.0F.WIG 50 /r
160             // VMOVMSKPS res, tmp
161             masm.emitByte(0xC4);                                   // VEX 3-byte
162             masm.emitByte((~getRXB(res, tmp) &amp; 0x7) &lt;&lt; 5 | 0x01);  // RXB m-mmmmm (0F)
163             masm.emitByte(0b0_1111_1_00);                          // W(0) vvvv L(1) pp(0)
164             masm.emitByte(0x50);
165             masm.emitByte(0xC0 | ((res.encoding &amp; 0x07) &lt;&lt; 3) | (tmp.encoding &amp; 0x07));
166         }
167     }
168 
169     private static final LIRTestSpecification compareAVXRegister = new LIRTestSpecification() {
170 
171         @Override
172         public void generate(LIRGeneratorTool gen, Value arg0, Value arg1) {
173             Variable ret = gen.newVariable(LIRKind.value(AMD64Kind.DWORD));
174             gen.append(new CompareAVXRegister(ret, gen.asAllocatable(arg0), gen.asAllocatable(arg1), gen.newVariable(LIRKind.value(AMD64Kind.V256_QWORD))));
175             setResult(ret);
176         }
177     };
178 
179     private static class TestStub extends SnippetStub {
180 
181         TestStub(OptionValues options, HotSpotProviders providers, HotSpotForeignCallLinkage linkage) {
182             super(&quot;testStub&quot;, options, providers, linkage);
183         }
184 
185         @Snippet
186         static void testStub() {
187         }
188 
189         @Override
190         protected void registerSnippet() {
191         }
192 
193         @Override
194         protected StructuredGraph buildInitialGraph(DebugContext debug, CompilationIdentifier compilationId, Object[] args) {
195             // Build the snippet graph directly since snippet registration is closed at this point.
196             ReplacementsImpl d = (ReplacementsImpl) providers.getReplacements();
197             MetaAccessProvider metaAccess = d.getProviders().getMetaAccess();
198             BytecodeProvider bytecodes = new ClassfileBytecodeProvider(metaAccess, d.snippetReflection, ClassLoader.getSystemClassLoader());
199             return d.makeGraph(debug, bytecodes, method, args, null, false, null);
200         }
201     }
202 
203     public static final ForeignCallDescriptor TEST_STUB = new ForeignCallDescriptor(&quot;test_stub&quot;, void.class);
204 
205     @LIRIntrinsic
206     public static int compareAVXRegister(@SuppressWarnings(&quot;unused&quot;) LIRTestSpecification spec, Object left, Object right) {
207         return left == right ? 0xff : 0;
208     }
209 
210     @Override
211     protected GraphBuilderConfiguration editGraphBuilderConfiguration(GraphBuilderConfiguration conf) {
212         InvocationPlugins invocationPlugins = conf.getPlugins().getInvocationPlugins();
213         InvocationPlugins.Registration r = new InvocationPlugins.Registration(invocationPlugins, TestStub.class);
214         r.register0(&quot;testStub&quot;, new InvocationPlugin() {
215             @Override
216             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver) {
217                 b.add(new ForeignCallNode(getProviders().getForeignCalls(), TEST_STUB));
218                 return true;
219             }
220         });
221         return super.editGraphBuilderConfiguration(conf);
222     }
223 
224     public static int testStub() {
225         Object preStub = loadAVXConstant(loadAVXConstant);
226 
227         // do something to potentially destroy the value
228         TestStub.testStub();
229 
230         Object postStub = loadAVXConstant(loadAVXConstant);
231         return compareAVXRegister(compareAVXRegister, preStub, postStub);
232     }
233 
234     @Test
235     public void test() {
236         HotSpotProviders providers = (HotSpotProviders) getProviders();
237         HotSpotForeignCallsProviderImpl foreignCalls = (HotSpotForeignCallsProviderImpl) providers.getForeignCalls();
<a name="3" id="anc3"></a><span class="line-modified">238         HotSpotForeignCallLinkage linkage = foreignCalls.registerStubCall(TEST_STUB, HotSpotForeignCallLinkage.Transition.LEAF_NO_VZERO, HotSpotForeignCallLinkage.Reexecutability.REEXECUTABLE,</span>
<span class="line-added">239                         COMPUTES_REGISTERS_KILLED);</span>
240         linkage.setCompiledStub(new TestStub(getInitialOptions(), providers, linkage));
241         runTest(&quot;testStub&quot;);
242     }
243 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.sparc/src/org/graalvm/compiler/hotspot/sparc/SPARCHotSpotLIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SPARCHotSpotForeignCallsProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="SPARCHotSpotLoweringProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.sparc/src/org/graalvm/compiler/hotspot/sparc/SPARCHotSpotLIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.sparc;
 26 
 27 import static jdk.vm.ci.sparc.SPARCKind.WORD;
 28 import static jdk.vm.ci.sparc.SPARCKind.XWORD;
 29 import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
 30 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;

 31 
 32 import org.graalvm.compiler.asm.sparc.SPARCAssembler;
 33 import org.graalvm.compiler.core.common.CompressEncoding;
 34 import org.graalvm.compiler.core.common.LIRKind;
 35 import org.graalvm.compiler.core.common.calc.Condition;
 36 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 37 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 38 import org.graalvm.compiler.core.sparc.SPARCArithmeticLIRGenerator;
 39 import org.graalvm.compiler.core.sparc.SPARCLIRGenerator;
 40 import org.graalvm.compiler.core.sparc.SPARCLIRKindTool;
 41 import org.graalvm.compiler.debug.GraalError;
 42 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 43 import org.graalvm.compiler.hotspot.HotSpotBackend;
 44 import org.graalvm.compiler.hotspot.HotSpotDebugInfoBuilder;
 45 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
 46 import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
 47 import org.graalvm.compiler.hotspot.HotSpotLIRGenerator;
 48 import org.graalvm.compiler.hotspot.HotSpotLockStack;
 49 import org.graalvm.compiler.hotspot.debug.BenchmarkCounters;
 50 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 51 import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
 52 import org.graalvm.compiler.hotspot.stubs.Stub;
 53 import org.graalvm.compiler.lir.LIRFrameState;
 54 import org.graalvm.compiler.lir.LIRInstruction;
 55 import org.graalvm.compiler.lir.LabelRef;
<span class="line-removed"> 56 import org.graalvm.compiler.lir.StandardOp.SaveRegistersOp;</span>
 57 import org.graalvm.compiler.lir.SwitchStrategy;
 58 import org.graalvm.compiler.lir.Variable;
 59 import org.graalvm.compiler.lir.VirtualStackSlot;
 60 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 61 import org.graalvm.compiler.lir.sparc.SPARCAddressValue;
 62 import org.graalvm.compiler.lir.sparc.SPARCControlFlow.StrategySwitchOp;
 63 import org.graalvm.compiler.lir.sparc.SPARCFrameMapBuilder;
 64 import org.graalvm.compiler.lir.sparc.SPARCImmediateAddressValue;
 65 import org.graalvm.compiler.lir.sparc.SPARCMove.CompareAndSwapOp;
 66 import org.graalvm.compiler.lir.sparc.SPARCMove.NullCheckOp;
 67 import org.graalvm.compiler.lir.sparc.SPARCMove.StoreOp;
 68 import org.graalvm.compiler.lir.sparc.SPARCPrefetchOp;
 69 import org.graalvm.compiler.lir.sparc.SPARCSaveRegistersOp;
 70 
 71 import jdk.vm.ci.code.CallingConvention;
 72 import jdk.vm.ci.code.Register;
 73 import jdk.vm.ci.code.RegisterValue;
 74 import jdk.vm.ci.code.StackSlot;
 75 import jdk.vm.ci.hotspot.HotSpotCompressedNullConstant;
 76 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
</pre>
<hr />
<pre>
221         LIRKind wordKind = LIRKind.value(target().arch.getWordKind());
222         RegisterValue thread = getProviders().getRegisters().getThreadRegister().asValue(wordKind);
223         SPARCAddressValue pendingDeoptAddress = new SPARCImmediateAddressValue(wordKind, thread, offset);
224         append(new StoreOp(v.getPlatformKind(), pendingDeoptAddress, load(v), null));
225     }
226 
227     @Override
228     public void emitDeoptimize(Value actionAndReason, Value speculation, LIRFrameState state) {
229         moveDeoptValuesToThread(actionAndReason, speculation);
230         append(new SPARCDeoptimizeOp(state, target().arch.getWordKind()));
231     }
232 
233     @Override
234     public void emitDeoptimizeCaller(DeoptimizationAction action, DeoptimizationReason reason) {
235         Value actionAndReason = emitJavaConstant(getMetaAccess().encodeDeoptActionAndReason(action, reason, 0));
236         Value speculation = emitJavaConstant(getMetaAccess().encodeSpeculation(SpeculationLog.NO_SPECULATION));
237         moveDeoptValuesToThread(actionAndReason, speculation);
238         append(new SPARCHotSpotDeoptimizeCallerOp());
239     }
240 






241     @Override
242     public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue) {
243         ValueKind&lt;?&gt; kind = newValue.getValueKind();
244         assert kind.equals(expectedValue.getValueKind());
245         SPARCKind memKind = (SPARCKind) kind.getPlatformKind();
246         Variable result = newVariable(newValue.getValueKind());
247         append(new CompareAndSwapOp(result, asAllocatable(address), asAllocatable(expectedValue), asAllocatable(newValue)));
248         return emitConditionalMove(memKind, expectedValue, result, Condition.EQ, true, trueValue, falseValue);
249     }
250 
251     @Override
252     public Variable emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue) {
253         ValueKind&lt;?&gt; kind = newValue.getValueKind();
254         assert kind.equals(expectedValue.getValueKind());
255         Variable result = newVariable(newValue.getValueKind());
256         append(new CompareAndSwapOp(result, asAllocatable(address), asAllocatable(expectedValue), asAllocatable(newValue)));
257         return result;
258     }
259 
260     @Override
</pre>
<hr />
<pre>
332         if (inputKind.isReference(0)) {
333             // oop
334             Variable result = newVariable(LIRKind.reference(XWORD));
335             append(new SPARCHotSpotMove.UncompressPointer(result, asAllocatable(pointer), getProviders().getRegisters().getHeapBaseRegister().asValue(), encoding, nonNull));
336             return result;
337         } else {
338             // metaspace pointer
339             Variable result = newVariable(LIRKind.value(XWORD));
340             AllocatableValue base = Value.ILLEGAL;
341             if (encoding.hasBase()) {
342                 base = emitLoadConstant(LIRKind.value(XWORD), JavaConstant.forLong(encoding.getBase()));
343             }
344             append(new SPARCHotSpotMove.UncompressPointer(result, asAllocatable(pointer), base, encoding, nonNull));
345             return result;
346         }
347     }
348 
349     /**
350      * @param savedRegisters the registers saved by this operation which may be subject to pruning
351      * @param savedRegisterLocations the slots to which the registers are saved
<span class="line-removed">352      * @param supportsRemove determines if registers can be pruned</span>
353      */
<span class="line-modified">354     protected SPARCSaveRegistersOp emitSaveRegisters(Register[] savedRegisters, AllocatableValue[] savedRegisterLocations, boolean supportsRemove) {</span>
<span class="line-modified">355         SPARCSaveRegistersOp save = new SPARCSaveRegistersOp(savedRegisters, savedRegisterLocations, supportsRemove);</span>
356         append(save);
357         return save;
358     }
359 
360     @Override
361     public void emitNullCheck(Value address, LIRFrameState state) {
362         PlatformKind kind = address.getPlatformKind();
363         if (kind == WORD) {
364             CompressEncoding encoding = config.getOopEncoding();
365             Value uncompressed = emitUncompress(address, encoding, false);
366             append(new NullCheckOp(asAddressValue(uncompressed), state));
367         } else {
368             super.emitNullCheck(address, state);
369         }
370     }
371 
372     @Override
373     public LIRInstruction createBenchmarkCounter(String name, String group, Value increment) {
374         if (BenchmarkCounters.enabled) {
375             return new SPARCHotSpotCounterOp(name, group, increment, getProviders().getRegisters(), config);
</pre>
<hr />
<pre>
385         throw GraalError.shouldNotReachHere(&quot;BenchmarkCounters are not enabled!&quot;);
386     }
387 
388     public AllocatableValue getSafepointAddressValue() {
389         if (this.safepointAddressValue == null) {
390             this.safepointAddressValue = SPARCHotSpotSafepointOp.getSafepointAddressValue(this);
391         }
392         return this.safepointAddressValue;
393     }
394 
395     @Override
396     protected StrategySwitchOp createStrategySwitchOp(AllocatableValue base, SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Variable key, Variable scratchValue) {
397         return new SPARCHotSpotStrategySwitchOp(base, strategy, keyTargets, defaultTarget, key, scratchValue);
398     }
399 
400     public void setDebugInfoBuilder(HotSpotDebugInfoBuilder debugInfoBuilder) {
401         this.debugInfoBuilder = debugInfoBuilder;
402     }
403 
404     @Override
<span class="line-modified">405     public SaveRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues) {</span>
406         throw GraalError.unimplemented();
407     }
408 
409     @Override
410     public LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConstant[] zapValues) {
411         throw GraalError.unimplemented();
412     }
413 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.sparc;
 26 
 27 import static jdk.vm.ci.sparc.SPARCKind.WORD;
 28 import static jdk.vm.ci.sparc.SPARCKind.XWORD;
 29 import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
 30 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
<span class="line-added"> 31 import static org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;</span>
 32 
 33 import org.graalvm.compiler.asm.sparc.SPARCAssembler;
 34 import org.graalvm.compiler.core.common.CompressEncoding;
 35 import org.graalvm.compiler.core.common.LIRKind;
 36 import org.graalvm.compiler.core.common.calc.Condition;
 37 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 38 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 39 import org.graalvm.compiler.core.sparc.SPARCArithmeticLIRGenerator;
 40 import org.graalvm.compiler.core.sparc.SPARCLIRGenerator;
 41 import org.graalvm.compiler.core.sparc.SPARCLIRKindTool;
 42 import org.graalvm.compiler.debug.GraalError;
 43 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 44 import org.graalvm.compiler.hotspot.HotSpotBackend;
 45 import org.graalvm.compiler.hotspot.HotSpotDebugInfoBuilder;
 46 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
 47 import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
 48 import org.graalvm.compiler.hotspot.HotSpotLIRGenerator;
 49 import org.graalvm.compiler.hotspot.HotSpotLockStack;
 50 import org.graalvm.compiler.hotspot.debug.BenchmarkCounters;
 51 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 52 import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
 53 import org.graalvm.compiler.hotspot.stubs.Stub;
 54 import org.graalvm.compiler.lir.LIRFrameState;
 55 import org.graalvm.compiler.lir.LIRInstruction;
 56 import org.graalvm.compiler.lir.LabelRef;

 57 import org.graalvm.compiler.lir.SwitchStrategy;
 58 import org.graalvm.compiler.lir.Variable;
 59 import org.graalvm.compiler.lir.VirtualStackSlot;
 60 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 61 import org.graalvm.compiler.lir.sparc.SPARCAddressValue;
 62 import org.graalvm.compiler.lir.sparc.SPARCControlFlow.StrategySwitchOp;
 63 import org.graalvm.compiler.lir.sparc.SPARCFrameMapBuilder;
 64 import org.graalvm.compiler.lir.sparc.SPARCImmediateAddressValue;
 65 import org.graalvm.compiler.lir.sparc.SPARCMove.CompareAndSwapOp;
 66 import org.graalvm.compiler.lir.sparc.SPARCMove.NullCheckOp;
 67 import org.graalvm.compiler.lir.sparc.SPARCMove.StoreOp;
 68 import org.graalvm.compiler.lir.sparc.SPARCPrefetchOp;
 69 import org.graalvm.compiler.lir.sparc.SPARCSaveRegistersOp;
 70 
 71 import jdk.vm.ci.code.CallingConvention;
 72 import jdk.vm.ci.code.Register;
 73 import jdk.vm.ci.code.RegisterValue;
 74 import jdk.vm.ci.code.StackSlot;
 75 import jdk.vm.ci.hotspot.HotSpotCompressedNullConstant;
 76 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
</pre>
<hr />
<pre>
221         LIRKind wordKind = LIRKind.value(target().arch.getWordKind());
222         RegisterValue thread = getProviders().getRegisters().getThreadRegister().asValue(wordKind);
223         SPARCAddressValue pendingDeoptAddress = new SPARCImmediateAddressValue(wordKind, thread, offset);
224         append(new StoreOp(v.getPlatformKind(), pendingDeoptAddress, load(v), null));
225     }
226 
227     @Override
228     public void emitDeoptimize(Value actionAndReason, Value speculation, LIRFrameState state) {
229         moveDeoptValuesToThread(actionAndReason, speculation);
230         append(new SPARCDeoptimizeOp(state, target().arch.getWordKind()));
231     }
232 
233     @Override
234     public void emitDeoptimizeCaller(DeoptimizationAction action, DeoptimizationReason reason) {
235         Value actionAndReason = emitJavaConstant(getMetaAccess().encodeDeoptActionAndReason(action, reason, 0));
236         Value speculation = emitJavaConstant(getMetaAccess().encodeSpeculation(SpeculationLog.NO_SPECULATION));
237         moveDeoptValuesToThread(actionAndReason, speculation);
238         append(new SPARCHotSpotDeoptimizeCallerOp());
239     }
240 
<span class="line-added">241     @Override</span>
<span class="line-added">242     public void emitDeoptimizeWithExceptionInCaller(Value exception) {</span>
<span class="line-added">243         Register thread = getProviders().getRegisters().getThreadRegister();</span>
<span class="line-added">244         append(new SPARCHotSpotDeoptimizeWithExceptionCallerOp(config, exception, thread));</span>
<span class="line-added">245     }</span>
<span class="line-added">246 </span>
247     @Override
248     public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue) {
249         ValueKind&lt;?&gt; kind = newValue.getValueKind();
250         assert kind.equals(expectedValue.getValueKind());
251         SPARCKind memKind = (SPARCKind) kind.getPlatformKind();
252         Variable result = newVariable(newValue.getValueKind());
253         append(new CompareAndSwapOp(result, asAllocatable(address), asAllocatable(expectedValue), asAllocatable(newValue)));
254         return emitConditionalMove(memKind, expectedValue, result, Condition.EQ, true, trueValue, falseValue);
255     }
256 
257     @Override
258     public Variable emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue) {
259         ValueKind&lt;?&gt; kind = newValue.getValueKind();
260         assert kind.equals(expectedValue.getValueKind());
261         Variable result = newVariable(newValue.getValueKind());
262         append(new CompareAndSwapOp(result, asAllocatable(address), asAllocatable(expectedValue), asAllocatable(newValue)));
263         return result;
264     }
265 
266     @Override
</pre>
<hr />
<pre>
338         if (inputKind.isReference(0)) {
339             // oop
340             Variable result = newVariable(LIRKind.reference(XWORD));
341             append(new SPARCHotSpotMove.UncompressPointer(result, asAllocatable(pointer), getProviders().getRegisters().getHeapBaseRegister().asValue(), encoding, nonNull));
342             return result;
343         } else {
344             // metaspace pointer
345             Variable result = newVariable(LIRKind.value(XWORD));
346             AllocatableValue base = Value.ILLEGAL;
347             if (encoding.hasBase()) {
348                 base = emitLoadConstant(LIRKind.value(XWORD), JavaConstant.forLong(encoding.getBase()));
349             }
350             append(new SPARCHotSpotMove.UncompressPointer(result, asAllocatable(pointer), base, encoding, nonNull));
351             return result;
352         }
353     }
354 
355     /**
356      * @param savedRegisters the registers saved by this operation which may be subject to pruning
357      * @param savedRegisterLocations the slots to which the registers are saved

358      */
<span class="line-modified">359     protected SPARCSaveRegistersOp emitSaveRegisters(Register[] savedRegisters, AllocatableValue[] savedRegisterLocations) {</span>
<span class="line-modified">360         SPARCSaveRegistersOp save = new SPARCSaveRegistersOp(savedRegisters, savedRegisterLocations);</span>
361         append(save);
362         return save;
363     }
364 
365     @Override
366     public void emitNullCheck(Value address, LIRFrameState state) {
367         PlatformKind kind = address.getPlatformKind();
368         if (kind == WORD) {
369             CompressEncoding encoding = config.getOopEncoding();
370             Value uncompressed = emitUncompress(address, encoding, false);
371             append(new NullCheckOp(asAddressValue(uncompressed), state));
372         } else {
373             super.emitNullCheck(address, state);
374         }
375     }
376 
377     @Override
378     public LIRInstruction createBenchmarkCounter(String name, String group, Value increment) {
379         if (BenchmarkCounters.enabled) {
380             return new SPARCHotSpotCounterOp(name, group, increment, getProviders().getRegisters(), config);
</pre>
<hr />
<pre>
390         throw GraalError.shouldNotReachHere(&quot;BenchmarkCounters are not enabled!&quot;);
391     }
392 
393     public AllocatableValue getSafepointAddressValue() {
394         if (this.safepointAddressValue == null) {
395             this.safepointAddressValue = SPARCHotSpotSafepointOp.getSafepointAddressValue(this);
396         }
397         return this.safepointAddressValue;
398     }
399 
400     @Override
401     protected StrategySwitchOp createStrategySwitchOp(AllocatableValue base, SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Variable key, Variable scratchValue) {
402         return new SPARCHotSpotStrategySwitchOp(base, strategy, keyTargets, defaultTarget, key, scratchValue);
403     }
404 
405     public void setDebugInfoBuilder(HotSpotDebugInfoBuilder debugInfoBuilder) {
406         this.debugInfoBuilder = debugInfoBuilder;
407     }
408 
409     @Override
<span class="line-modified">410     public ZapRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues) {</span>
411         throw GraalError.unimplemented();
412     }
413 
414     @Override
415     public LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConstant[] zapValues) {
416         throw GraalError.unimplemented();
417     }
418 }
</pre>
</td>
</tr>
</table>
<center><a href="SPARCHotSpotForeignCallsProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="SPARCHotSpotLoweringProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
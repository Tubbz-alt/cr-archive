<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.sparc/src/org/graalvm/compiler/hotspot/sparc/SPARCHotSpotBackend.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SPARCDeoptimizeOp.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="SPARCHotSpotBackendFactory.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.sparc/src/org/graalvm/compiler/hotspot/sparc/SPARCHotSpotBackend.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,11 ***</span>
  import java.util.ArrayList;
  import java.util.HashSet;
  import java.util.Set;
  import java.util.concurrent.ConcurrentHashMap;
  
<span class="line-removed">- import jdk.internal.vm.compiler.collections.EconomicMap;</span>
  import jdk.internal.vm.compiler.collections.EconomicSet;
  import jdk.internal.vm.compiler.collections.Equivalence;
  import org.graalvm.compiler.asm.Assembler;
  import org.graalvm.compiler.asm.Label;
  import org.graalvm.compiler.asm.sparc.SPARCAddress;
<span class="line-new-header">--- 46,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,11 ***</span>
  import org.graalvm.compiler.asm.sparc.SPARCMacroAssembler;
  import org.graalvm.compiler.asm.sparc.SPARCMacroAssembler.ScratchRegister;
  import org.graalvm.compiler.code.CompilationResult;
  import org.graalvm.compiler.code.DataSection;
  import org.graalvm.compiler.code.DataSection.Data;
<span class="line-removed">- import org.graalvm.compiler.core.common.CompilationIdentifier;</span>
  import org.graalvm.compiler.core.common.alloc.RegisterAllocationConfig;
  import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
  import org.graalvm.compiler.core.gen.LIRGenerationProvider;
  import org.graalvm.compiler.core.sparc.SPARCNodeMatchRules;
  import org.graalvm.compiler.debug.CounterKey;
<span class="line-new-header">--- 57,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,13 ***</span>
  import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProvider;
  import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
  import org.graalvm.compiler.hotspot.stubs.Stub;
  import org.graalvm.compiler.lir.InstructionValueConsumer;
  import org.graalvm.compiler.lir.LIR;
<span class="line-removed">- import org.graalvm.compiler.lir.LIRFrameState;</span>
  import org.graalvm.compiler.lir.LIRInstruction;
<span class="line-removed">- import org.graalvm.compiler.lir.StandardOp.SaveRegistersOp;</span>
  import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
  import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
  import org.graalvm.compiler.lir.asm.DataBuilder;
  import org.graalvm.compiler.lir.asm.FrameContext;
  import org.graalvm.compiler.lir.framemap.FrameMap;
<span class="line-new-header">--- 73,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,27 ***</span>
              CounterKey m = counters.computeIfAbsent(name, (n) -&gt; DebugContext.counter(n));
              m.add(debug, count);
          }
      }
  
<span class="line-modified">!     private FrameMapBuilder newFrameMapBuilder(RegisterConfig registerConfig) {</span>
          RegisterConfig registerConfigNonNull = registerConfig == null ? getCodeCache().getRegisterConfig() : registerConfig;
          FrameMap frameMap = new SPARCFrameMap(getCodeCache(), registerConfigNonNull, this);
          return new SPARCFrameMapBuilder(frameMap, getCodeCache(), registerConfigNonNull);
      }
  
      @Override
      public LIRGeneratorTool newLIRGenerator(LIRGenerationResult lirGenRes) {
          return new SPARCHotSpotLIRGenerator(getProviders(), getRuntime().getVMConfig(), lirGenRes);
      }
  
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     public LIRGenerationResult newLIRGenerationResult(CompilationIdentifier compilationId, LIR lir, RegisterConfig registerConfig, StructuredGraph graph, Object stub) {</span>
<span class="line-removed">-         return new HotSpotLIRGenerationResult(compilationId, lir, newFrameMapBuilder(registerConfig), makeCallingConvention(graph, (Stub) stub), stub,</span>
<span class="line-removed">-                         config.requiresReservedStackCheck(graph.getMethods()));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      @Override
      public NodeLIRBuilderTool newNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool lirGen) {
          return new SPARCHotSpotNodeLIRBuilder(graph, lirGen, new SPARCNodeMatchRules(lirGen));
      }
  
<span class="line-new-header">--- 129,22 ---</span>
              CounterKey m = counters.computeIfAbsent(name, (n) -&gt; DebugContext.counter(n));
              m.add(debug, count);
          }
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-added">+     protected FrameMapBuilder newFrameMapBuilder(RegisterConfig registerConfig) {</span>
          RegisterConfig registerConfigNonNull = registerConfig == null ? getCodeCache().getRegisterConfig() : registerConfig;
          FrameMap frameMap = new SPARCFrameMap(getCodeCache(), registerConfigNonNull, this);
          return new SPARCFrameMapBuilder(frameMap, getCodeCache(), registerConfigNonNull);
      }
  
      @Override
      public LIRGeneratorTool newLIRGenerator(LIRGenerationResult lirGenRes) {
          return new SPARCHotSpotLIRGenerator(getProviders(), getRuntime().getVMConfig(), lirGenRes);
      }
  
      @Override
      public NodeLIRBuilderTool newNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool lirGen) {
          return new SPARCHotSpotNodeLIRBuilder(graph, lirGen, new SPARCNodeMatchRules(lirGen));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,14 ***</span>
          if (deoptimizationRescueSlot != null &amp;&amp; stub == null) {
              crb.compilationResult.setCustomStackAreaOffset(deoptimizationRescueSlot);
          }
  
          if (stub != null) {
<span class="line-modified">!             // Even on sparc we need to save floating point registers</span>
<span class="line-removed">-             EconomicSet&lt;Register&gt; destroyedCallerRegisters = gatherDestroyedCallerRegisters(lir);</span>
<span class="line-removed">-             EconomicMap&lt;LIRFrameState, SaveRegistersOp&gt; calleeSaveInfo = gen.getCalleeSaveInfo();</span>
<span class="line-removed">-             updateStub(stub, destroyedCallerRegisters, calleeSaveInfo, frameMap);</span>
          }
          assert registerSizePredictionValidator(crb, debug);
          return crb;
      }
  
<span class="line-new-header">--- 235,11 ---</span>
          if (deoptimizationRescueSlot != null &amp;&amp; stub == null) {
              crb.compilationResult.setCustomStackAreaOffset(deoptimizationRescueSlot);
          }
  
          if (stub != null) {
<span class="line-modified">!             updateStub(stub, gen, frameMap);</span>
          }
          assert registerSizePredictionValidator(crb, debug);
          return crb;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 359,11 ***</span>
          HotSpotForeignCallsProvider foreignCalls = getProviders().getForeignCalls();
          if (!frameContext.isStub) {
              crb.recordMark(config.MARKID_EXCEPTION_HANDLER_ENTRY);
              SPARCCall.directCall(crb, masm, foreignCalls.lookupForeignCall(EXCEPTION_HANDLER), null, null);
              crb.recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);
<span class="line-modified">!             SPARCCall.directCall(crb, masm, foreignCalls.lookupForeignCall(DEOPTIMIZATION_HANDLER), null, null);</span>
          } else {
              // No need to emit the stubs for entries back into the method since
              // it has no calls that can cause such &quot;return&quot; entries
          }
  
<span class="line-new-header">--- 347,11 ---</span>
          HotSpotForeignCallsProvider foreignCalls = getProviders().getForeignCalls();
          if (!frameContext.isStub) {
              crb.recordMark(config.MARKID_EXCEPTION_HANDLER_ENTRY);
              SPARCCall.directCall(crb, masm, foreignCalls.lookupForeignCall(EXCEPTION_HANDLER), null, null);
              crb.recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);
<span class="line-modified">!             SPARCCall.directCall(crb, masm, foreignCalls.lookupForeignCall(DEOPT_BLOB_UNPACK), null, null);</span>
          } else {
              // No need to emit the stubs for entries back into the method since
              // it has no calls that can cause such &quot;return&quot; entries
          }
  
</pre>
<center><a href="SPARCDeoptimizeOp.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="SPARCHotSpotBackendFactory.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64AddressNode.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64AddressNode.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64AddressNode.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64AddressNode.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -61,19 +61,28 @@
     @OptionalInput private ValueNode index;
     private Scale scale;
 
     private int displacement;
 
+    /*
+     * If this address has been improved by folding an uncompress operation into it, this is set by
+     * the address lowering to the uncompression scale used by the encoding strategy. It is null
+     * otherwise. This might be different from scale if we lowered an uncompression followed by
+     * further improvements that modify the scale.
+     */
+    private Scale uncompressionScale;
+
     public AMD64AddressNode(ValueNode base) {
         this(base, null);
     }
 
     public AMD64AddressNode(ValueNode base, ValueNode index) {
         super(TYPE);
         this.base = base;
         this.index = index;
         this.scale = Scale.Times1;
+        this.uncompressionScale = null;
     }
 
     public void canonicalizeIndex(SimplifierTool tool) {
         if (index instanceof AddNode && ((IntegerStamp) index.stamp(NodeView.DEFAULT)).getBits() == 64) {
             AddNode add = (AddNode) index;
@@ -101,16 +110,18 @@
         LIRGeneratorTool tool = gen.getLIRGeneratorTool();
 
         AllocatableValue baseValue = base == null ? Value.ILLEGAL : tool.asAllocatable(gen.operand(base));
         AllocatableValue indexValue = index == null ? Value.ILLEGAL : tool.asAllocatable(gen.operand(index));
 
-        AllocatableValue baseReference = LIRKind.derivedBaseFromValue(baseValue);
+        AllocatableValue baseReference = base == null ? null : LIRKind.derivedBaseFromValue(baseValue);
         AllocatableValue indexReference;
         if (index == null) {
             indexReference = null;
         } else if (scale.equals(Scale.Times1)) {
             indexReference = LIRKind.derivedBaseFromValue(indexValue);
+        } else if (scale.equals(uncompressionScale) && LIRKind.isScalarCompressedReference(indexValue.getValueKind())) {
+            indexReference = LIRKind.derivedBaseFromValue(indexValue);
         } else {
             if (LIRKind.isValue(indexValue)) {
                 indexReference = null;
             } else {
                 indexReference = Value.ILLEGAL;
@@ -161,10 +172,14 @@
 
     public void setDisplacement(int displacement) {
         this.displacement = displacement;
     }
 
+    public void setUncompressionScale(Scale scale) {
+        this.uncompressionScale = scale;
+    }
+
     @Override
     public long getMaxConstantDisplacement() {
         return displacement;
     }
 

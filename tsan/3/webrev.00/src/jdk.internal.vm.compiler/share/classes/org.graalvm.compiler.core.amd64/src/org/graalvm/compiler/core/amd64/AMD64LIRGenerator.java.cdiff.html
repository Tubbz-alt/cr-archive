<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64LIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64ArithmeticLIRGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64MoveFactory.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64LIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 45,12 ***</span>
  
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
<span class="line-removed">- import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;</span>
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.core.common.NumUtil;
  import org.graalvm.compiler.core.common.calc.Condition;
  import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
  import org.graalvm.compiler.core.common.spi.LIRKindTool;
<span class="line-new-header">--- 45,15 ---</span>
  
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
<span class="line-added">+ import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMOp;</span>
<span class="line-added">+ import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;</span>
<span class="line-added">+ import org.graalvm.compiler.asm.amd64.AVXKind;</span>
<span class="line-added">+ import org.graalvm.compiler.asm.amd64.AVXKind.AVXSize;</span>
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.core.common.NumUtil;
  import org.graalvm.compiler.core.common.calc.Condition;
  import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
  import org.graalvm.compiler.core.common.spi.LIRKindTool;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,11 ***</span>
  import org.graalvm.compiler.lir.LIRFrameState;
  import org.graalvm.compiler.lir.LIRInstruction;
  import org.graalvm.compiler.lir.LIRValueUtil;
  import org.graalvm.compiler.lir.LabelRef;
  import org.graalvm.compiler.lir.StandardOp.JumpOp;
<span class="line-modified">! import org.graalvm.compiler.lir.StandardOp.SaveRegistersOp;</span>
  import org.graalvm.compiler.lir.SwitchStrategy;
  import org.graalvm.compiler.lir.Variable;
  import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
  import org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool;
  import org.graalvm.compiler.lir.amd64.AMD64ArrayCompareToOp;
<span class="line-new-header">--- 62,11 ---</span>
  import org.graalvm.compiler.lir.LIRFrameState;
  import org.graalvm.compiler.lir.LIRInstruction;
  import org.graalvm.compiler.lir.LIRValueUtil;
  import org.graalvm.compiler.lir.LabelRef;
  import org.graalvm.compiler.lir.StandardOp.JumpOp;
<span class="line-modified">! import org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;</span>
  import org.graalvm.compiler.lir.SwitchStrategy;
  import org.graalvm.compiler.lir.Variable;
  import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
  import org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool;
  import org.graalvm.compiler.lir.amd64.AMD64ArrayCompareToOp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,24 ***</span>
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondMoveOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondSetOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatBranchOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondMoveOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondSetOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.ReturnOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.StrategySwitchOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TableSwitchOp;
<span class="line-removed">- import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.HashTableSwitchOp;</span>
  import org.graalvm.compiler.lir.amd64.AMD64LFenceOp;
  import org.graalvm.compiler.lir.amd64.AMD64Move;
  import org.graalvm.compiler.lir.amd64.AMD64Move.CompareAndSwapOp;
  import org.graalvm.compiler.lir.amd64.AMD64Move.MembarOp;
  import org.graalvm.compiler.lir.amd64.AMD64Move.StackLeaOp;
  import org.graalvm.compiler.lir.amd64.AMD64PauseOp;
  import org.graalvm.compiler.lir.amd64.AMD64StringLatin1InflateOp;
  import org.graalvm.compiler.lir.amd64.AMD64StringUTF16CompressOp;
  import org.graalvm.compiler.lir.amd64.AMD64ZapRegistersOp;
  import org.graalvm.compiler.lir.amd64.AMD64ZapStackOp;
  import org.graalvm.compiler.lir.gen.LIRGenerationResult;
  import org.graalvm.compiler.lir.gen.LIRGenerator;
  import org.graalvm.compiler.lir.hashing.Hasher;
  import org.graalvm.compiler.phases.util.Providers;
  
<span class="line-new-header">--- 81,26 ---</span>
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondMoveOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondSetOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatBranchOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondMoveOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondSetOp;
<span class="line-added">+ import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.HashTableSwitchOp;</span>
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.ReturnOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.StrategySwitchOp;
  import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TableSwitchOp;
  import org.graalvm.compiler.lir.amd64.AMD64LFenceOp;
  import org.graalvm.compiler.lir.amd64.AMD64Move;
  import org.graalvm.compiler.lir.amd64.AMD64Move.CompareAndSwapOp;
  import org.graalvm.compiler.lir.amd64.AMD64Move.MembarOp;
  import org.graalvm.compiler.lir.amd64.AMD64Move.StackLeaOp;
  import org.graalvm.compiler.lir.amd64.AMD64PauseOp;
  import org.graalvm.compiler.lir.amd64.AMD64StringLatin1InflateOp;
  import org.graalvm.compiler.lir.amd64.AMD64StringUTF16CompressOp;
  import org.graalvm.compiler.lir.amd64.AMD64ZapRegistersOp;
  import org.graalvm.compiler.lir.amd64.AMD64ZapStackOp;
<span class="line-added">+ import org.graalvm.compiler.lir.amd64.AMD64ZeroMemoryOp;</span>
<span class="line-added">+ import org.graalvm.compiler.lir.amd64.vector.AMD64VectorCompareOp;</span>
  import org.graalvm.compiler.lir.gen.LIRGenerationResult;
  import org.graalvm.compiler.lir.gen.LIRGenerator;
  import org.graalvm.compiler.lir.hashing.Hasher;
  import org.graalvm.compiler.phases.util.Providers;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 402,21 ***</span>
          Variable result = newVariable(trueValue.getValueKind());
          append(new CondMoveOp(result, Condition.EQ, load(trueValue), loadNonConst(falseValue)));
          return result;
      }
  
      private void emitIntegerTest(Value a, Value b) {
<span class="line-modified">!         assert ((AMD64Kind) a.getPlatformKind()).isInteger();</span>
<span class="line-modified">!         OperandSize size = a.getPlatformKind() == AMD64Kind.QWORD ? QWORD : DWORD;</span>
<span class="line-removed">-         if (isJavaConstant(b) &amp;&amp; NumUtil.is32bit(asJavaConstant(b).asLong())) {</span>
<span class="line-removed">-             append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(a), (int) asJavaConstant(b).asLong()));</span>
<span class="line-removed">-         } else if (isJavaConstant(a) &amp;&amp; NumUtil.is32bit(asJavaConstant(a).asLong())) {</span>
<span class="line-removed">-             append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(b), (int) asJavaConstant(a).asLong()));</span>
<span class="line-removed">-         } else if (isAllocatableValue(b)) {</span>
<span class="line-removed">-             append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(b), asAllocatable(a)));</span>
          } else {
<span class="line-modified">!             append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(a), asAllocatable(b)));</span>
          }
      }
  
      /**
       * This method emits the compare against memory instruction, and may reorder the operands. It
<span class="line-new-header">--- 407,34 ---</span>
          Variable result = newVariable(trueValue.getValueKind());
          append(new CondMoveOp(result, Condition.EQ, load(trueValue), loadNonConst(falseValue)));
          return result;
      }
  
<span class="line-added">+     protected static AVXSize getRegisterSize(Value a) {</span>
<span class="line-added">+         AMD64Kind kind = (AMD64Kind) a.getPlatformKind();</span>
<span class="line-added">+         if (kind.isXMM()) {</span>
<span class="line-added">+             return AVXKind.getRegisterSize(kind);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return AVXSize.XMM;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private void emitIntegerTest(Value a, Value b) {
<span class="line-modified">!         if (a.getPlatformKind().getVectorLength() &gt; 1) {</span>
<span class="line-modified">!             append(new AMD64VectorCompareOp(VexRMOp.VPTEST, getRegisterSize(a), asAllocatable(a), asAllocatable(b)));</span>
          } else {
<span class="line-modified">!             assert ((AMD64Kind) a.getPlatformKind()).isInteger();</span>
<span class="line-added">+             OperandSize size = a.getPlatformKind() == AMD64Kind.QWORD ? QWORD : DWORD;</span>
<span class="line-added">+             if (isJavaConstant(b) &amp;&amp; NumUtil.is32bit(asJavaConstant(b).asLong())) {</span>
<span class="line-added">+                 append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(a), (int) asJavaConstant(b).asLong()));</span>
<span class="line-added">+             } else if (isJavaConstant(a) &amp;&amp; NumUtil.is32bit(asJavaConstant(a).asLong())) {</span>
<span class="line-added">+                 append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(b), (int) asJavaConstant(a).asLong()));</span>
<span class="line-added">+             } else if (isAllocatableValue(b)) {</span>
<span class="line-added">+                 append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(b), asAllocatable(a)));</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(a), asAllocatable(b)));</span>
<span class="line-added">+             }</span>
          }
      }
  
      /**
       * This method emits the compare against memory instruction, and may reorder the operands. It
</pre>
<hr />
<pre>
<span class="line-old-header">*** 459,22 ***</span>
  
      protected boolean emitCompareMemoryConOp(OperandSize size, ConstantValue a, AMD64AddressValue b, LIRFrameState state) {
          if (JavaConstant.isNull(a.getConstant())) {
              append(new AMD64BinaryConsumer.MemoryConstOp(CMP, size, b, 0, state));
              return true;
<span class="line-modified">!         } else if (a.getConstant() instanceof VMConstant &amp;&amp; size == DWORD) {</span>
              VMConstant vc = (VMConstant) a.getConstant();
              append(new AMD64BinaryConsumer.MemoryVMConstOp(CMP.getMIOpcode(size, false), b, vc, state));
              return true;
          } else {
<span class="line-modified">!             long value = a.getJavaConstant().asLong();</span>
<span class="line-modified">!             if (NumUtil.is32bit(value)) {</span>
<span class="line-modified">!                 append(new AMD64BinaryConsumer.MemoryConstOp(CMP, size, b, (int) value, state));</span>
<span class="line-modified">!                 return true;</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 return emitCompareRegMemoryOp(size, asAllocatable(a), b, state);</span>
              }
          }
      }
  
      private boolean emitCompareRegMemoryOp(OperandSize size, AllocatableValue a, AMD64AddressValue b, LIRFrameState state) {
          AMD64RMOp op = CMP.getRMOpcode(size);
<span class="line-new-header">--- 477,23 ---</span>
  
      protected boolean emitCompareMemoryConOp(OperandSize size, ConstantValue a, AMD64AddressValue b, LIRFrameState state) {
          if (JavaConstant.isNull(a.getConstant())) {
              append(new AMD64BinaryConsumer.MemoryConstOp(CMP, size, b, 0, state));
              return true;
<span class="line-modified">!         } else if (a.getConstant() instanceof VMConstant &amp;&amp; size == DWORD &amp;&amp; target().inlineObjects) {</span>
              VMConstant vc = (VMConstant) a.getConstant();
              append(new AMD64BinaryConsumer.MemoryVMConstOp(CMP.getMIOpcode(size, false), b, vc, state));
              return true;
          } else {
<span class="line-modified">!             if (a.getConstant() instanceof JavaConstant &amp;&amp; a.getJavaConstant().getJavaKind() != JavaKind.Object) {</span>
<span class="line-modified">!                 long value = a.getJavaConstant().asLong();</span>
<span class="line-modified">!                 if (NumUtil.is32bit(value)) {</span>
<span class="line-modified">!                     append(new AMD64BinaryConsumer.MemoryConstOp(CMP, size, b, (int) value, state));</span>
<span class="line-modified">!                     return true;</span>
<span class="line-modified">!                 }</span>
              }
<span class="line-added">+             return emitCompareRegMemoryOp(size, asAllocatable(a), b, state);</span>
          }
      }
  
      private boolean emitCompareRegMemoryOp(OperandSize size, AllocatableValue a, AMD64AddressValue b, LIRFrameState state) {
          AMD64RMOp op = CMP.getRMOpcode(size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 545,46 ***</span>
          emitMove(result, raxRes);
          return result;
      }
  
      @Override
<span class="line-modified">!     public Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, int constantLength, boolean directPointers) {</span>
          Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
<span class="line-modified">!         append(new AMD64ArrayEqualsOp(this, kind, kind, result, array1, array2, asAllocatable(length), constantLength, directPointers, getMaxVectorSize()));</span>
          return result;
      }
  
      @Override
<span class="line-modified">!     public Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, int constantLength, boolean directPointers) {</span>
          Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
<span class="line-modified">!         append(new AMD64ArrayEqualsOp(this, kind1, kind2, result, array1, array2, asAllocatable(length), constantLength, directPointers, getMaxVectorSize()));</span>
          return result;
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Return a conservative estimate of the page size for use by the String.indexOf intrinsic.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     protected int getVMPageSize() {</span>
<span class="line-removed">-         return 4096;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Return the maximum size of vector registers used in SSE/AVX instructions.
       */
      protected int getMaxVectorSize() {
          // default for &quot;unlimited&quot;
          return -1;
      }
  
      @Override
<span class="line-modified">!     public Variable emitArrayIndexOf(JavaKind kind, boolean findTwoConsecutive, Value arrayPointer, Value arrayLength, Value... searchValues) {</span>
<span class="line-modified">!         Variable result = newVariable(LIRKind.value(AMD64Kind.QWORD));</span>
<span class="line-modified">!         Value[] allocatableSearchValues = new Value[searchValues.length];</span>
<span class="line-modified">!         for (int i = 0; i &lt; searchValues.length; i++) {</span>
<span class="line-removed">-             allocatableSearchValues[i] = asAllocatable(searchValues[i]);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         append(new AMD64ArrayIndexOfOp(kind, findTwoConsecutive, getVMPageSize(), getMaxVectorSize(), this, result, asAllocatable(arrayPointer), asAllocatable(arrayLength), allocatableSearchValues));</span>
          return result;
      }
  
      @Override
      public void emitStringLatin1Inflate(Value src, Value dst, Value len) {
<span class="line-new-header">--- 564,36 ---</span>
          emitMove(result, raxRes);
          return result;
      }
  
      @Override
<span class="line-modified">!     public Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, boolean directPointers) {</span>
          Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
<span class="line-modified">!         append(new AMD64ArrayEqualsOp(this, kind, kind, result, array1, array2, length, directPointers, getMaxVectorSize()));</span>
          return result;
      }
  
      @Override
<span class="line-modified">!     public Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, boolean directPointers) {</span>
          Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
<span class="line-modified">!         append(new AMD64ArrayEqualsOp(this, kind1, kind2, result, array1, array2, length, directPointers, getMaxVectorSize()));</span>
          return result;
      }
  
      /**
       * Return the maximum size of vector registers used in SSE/AVX instructions.
       */
      protected int getMaxVectorSize() {
          // default for &quot;unlimited&quot;
          return -1;
      }
  
      @Override
<span class="line-modified">!     public Variable emitArrayIndexOf(JavaKind arrayKind, JavaKind valueKind, boolean findTwoConsecutive, Value arrayPointer, Value arrayLength, Value fromIndex, Value... searchValues) {</span>
<span class="line-modified">!         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-modified">!         append(new AMD64ArrayIndexOfOp(arrayKind, valueKind, findTwoConsecutive, getMaxVectorSize(), this, result,</span>
<span class="line-modified">!                         asAllocatable(arrayPointer), asAllocatable(arrayLength), asAllocatable(fromIndex), searchValues));</span>
          return result;
      }
  
      @Override
      public void emitStringLatin1Inflate(Value src, Value dst, Value len) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 662,11 ***</span>
      public void emitPause() {
          append(new AMD64PauseOp());
      }
  
      @Override
<span class="line-modified">!     public SaveRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues) {</span>
          return new AMD64ZapRegistersOp(zappedRegisters, zapValues);
      }
  
      @Override
      public LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConstant[] zapValues) {
<span class="line-new-header">--- 671,11 ---</span>
      public void emitPause() {
          append(new AMD64PauseOp());
      }
  
      @Override
<span class="line-modified">!     public ZapRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues) {</span>
          return new AMD64ZapRegistersOp(zappedRegisters, zapValues);
      }
  
      @Override
      public LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConstant[] zapValues) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 675,6 ***</span>
<span class="line-new-header">--- 684,13 ---</span>
  
      @Override
      public void emitSpeculationFence() {
          append(new AMD64LFenceOp());
      }
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void emitZeroMemory(Value address, Value length, boolean isAligned) {</span>
<span class="line-added">+         RegisterValue lengthReg = AMD64.rcx.asValue(length.getValueKind());</span>
<span class="line-added">+         emitMove(lengthReg, length);</span>
<span class="line-added">+         append(new AMD64ZeroMemoryOp(asAddressValue(address), lengthReg));</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="AMD64ArithmeticLIRGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64MoveFactory.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
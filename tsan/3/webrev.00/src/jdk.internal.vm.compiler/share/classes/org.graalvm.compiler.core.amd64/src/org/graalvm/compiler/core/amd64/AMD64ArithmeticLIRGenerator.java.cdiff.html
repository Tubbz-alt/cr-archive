<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64ArithmeticLIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64AddressNode.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64LIRGenerator.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64ArithmeticLIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 55,10 ***</span>
<span class="line-new-header">--- 55,12 ---</span>
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift.SHR;
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VADDSD;
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VADDSS;
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VDIVSD;
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VDIVSS;
<span class="line-added">+ import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VFMADD231SD;</span>
<span class="line-added">+ import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VFMADD231SS;</span>
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VMULSD;
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VMULSS;
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VORPD;
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VORPS;
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VSUBSD;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,12 ***</span>
<span class="line-new-header">--- 120,14 ---</span>
  import org.graalvm.compiler.lir.amd64.AMD64MathTanOp;
  import org.graalvm.compiler.lir.amd64.AMD64Move;
  import org.graalvm.compiler.lir.amd64.AMD64MulDivOp;
  import org.graalvm.compiler.lir.amd64.AMD64ShiftOp;
  import org.graalvm.compiler.lir.amd64.AMD64SignExtendOp;
<span class="line-added">+ import org.graalvm.compiler.lir.amd64.AMD64Ternary;</span>
  import org.graalvm.compiler.lir.amd64.AMD64Unary;
  import org.graalvm.compiler.lir.amd64.vector.AMD64VectorBinary;
<span class="line-added">+ import org.graalvm.compiler.lir.amd64.vector.AMD64VectorBinary.AVXBinaryConstFloatOp;</span>
  import org.graalvm.compiler.lir.amd64.vector.AMD64VectorBinary.AVXBinaryOp;
  import org.graalvm.compiler.lir.amd64.vector.AMD64VectorUnary;
  import org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator;
  
  import jdk.vm.ci.amd64.AMD64;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,10 ***</span>
<span class="line-new-header">--- 448,17 ---</span>
              default:
                  throw GraalError.shouldNotReachHere();
          }
      }
  
<span class="line-added">+     public Value emitBinaryMemory(VexRVMOp op, OperandSize size, AllocatableValue a, AMD64AddressValue location, LIRFrameState state) {</span>
<span class="line-added">+         assert (size.isXmmType() &amp;&amp; supportAVX());</span>
<span class="line-added">+         Variable result = getLIRGen().newVariable(LIRKind.combine(a));</span>
<span class="line-added">+         getLIRGen().append(new AMD64VectorBinary.AVXBinaryMemoryOp(op, getRegisterSize(result), result, a, location, state));</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public Value emitBinaryMemory(AMD64RMOp op, OperandSize size, AllocatableValue a, AMD64AddressValue location, LIRFrameState state) {
          Variable result = getLIRGen().newVariable(LIRKind.combine(a));
          getLIRGen().append(new AMD64Binary.MemoryTwoOp(op, size, result, a, location, state));
          return result;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 687,14 ***</span>
              JavaConstant c = asJavaConstant(b);
              if (c.asLong() == 1) {
                  getLIRGen().append(new AMD64Unary.MOp(op.m1Op, size, result, input));
              } else {
                  /*
<span class="line-modified">!                  * c is implicitly masked to 5 or 6 bits by the CPU, so casting it to (int) is</span>
<span class="line-removed">-                  * always correct, even without the NumUtil.is32bit() test.</span>
                   */
<span class="line-modified">!                 getLIRGen().append(new AMD64Binary.ConstOp(op.miOp, size, result, input, (int) c.asLong()));</span>
              }
          } else {
              getLIRGen().emitMove(RCX_I, b);
              getLIRGen().append(new AMD64ShiftOp(op.mcOp, size, result, input, RCX_I));
          }
<span class="line-new-header">--- 698,13 ---</span>
              JavaConstant c = asJavaConstant(b);
              if (c.asLong() == 1) {
                  getLIRGen().append(new AMD64Unary.MOp(op.m1Op, size, result, input));
              } else {
                  /*
<span class="line-modified">!                  * c needs to be masked here, because shifts with immediate expect a byte.</span>
                   */
<span class="line-modified">!                 getLIRGen().append(new AMD64Binary.ConstOp(op.miOp, size, result, input, (byte) c.asLong()));</span>
              }
          } else {
              getLIRGen().emitMove(RCX_I, b);
              getLIRGen().append(new AMD64ShiftOp(op.mcOp, size, result, input, RCX_I));
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 960,10 ***</span>
<span class="line-new-header">--- 970,26 ---</span>
              getLIRGen().append(new AMD64Unary.RMOp(BSR, DWORD, result, asAllocatable(value)));
          }
          return result;
      }
  
<span class="line-added">+     @Override</span>
<span class="line-added">+     public Variable emitFusedMultiplyAdd(Value a, Value b, Value c) {</span>
<span class="line-added">+         Variable result = getLIRGen().newVariable(LIRKind.combine(a, b, c));</span>
<span class="line-added">+         assert ((AMD64Kind) a.getPlatformKind()).isXMM() &amp;&amp; ((AMD64Kind) b.getPlatformKind()).isXMM() &amp;&amp; ((AMD64Kind) c.getPlatformKind()).isXMM();</span>
<span class="line-added">+         assert a.getPlatformKind().equals(b.getPlatformKind());</span>
<span class="line-added">+         assert b.getPlatformKind().equals(c.getPlatformKind());</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (a.getPlatformKind() == AMD64Kind.DOUBLE) {</span>
<span class="line-added">+             getLIRGen().append(new AMD64Ternary.ThreeOp(VFMADD231SD, AVXSize.XMM, result, asAllocatable(c), asAllocatable(a), asAllocatable(b)));</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             assert a.getPlatformKind() == AMD64Kind.SINGLE;</span>
<span class="line-added">+             getLIRGen().append(new AMD64Ternary.ThreeOp(VFMADD231SS, AVXSize.XMM, result, asAllocatable(c), asAllocatable(a), asAllocatable(b)));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public Value emitCountLeadingZeros(Value value) {
          Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AMD64Kind.DWORD));
          assert ((AMD64Kind) value.getPlatformKind()).isInteger();
          if (value.getPlatformKind() == AMD64Kind.QWORD) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1277,11 ***</span>
                      getLIRGen().append(new AMD64BinaryConsumer.Op(TEST, size, left, left));
                  }
                  return;
              } else if (c instanceof VMConstant) {
                  VMConstant vc = (VMConstant) c;
<span class="line-modified">!                 if (size == DWORD &amp;&amp; !GeneratePIC.getValue(getOptions())) {</span>
                      getLIRGen().append(new AMD64BinaryConsumer.VMConstOp(CMP.getMIOpcode(DWORD, false), left, vc));
                  } else {
                      getLIRGen().append(new AMD64BinaryConsumer.DataOp(CMP.getRMOpcode(size), size, left, vc));
                  }
                  return;
<span class="line-new-header">--- 1303,11 ---</span>
                      getLIRGen().append(new AMD64BinaryConsumer.Op(TEST, size, left, left));
                  }
                  return;
              } else if (c instanceof VMConstant) {
                  VMConstant vc = (VMConstant) c;
<span class="line-modified">!                 if (size == DWORD &amp;&amp; !GeneratePIC.getValue(getOptions()) &amp;&amp; getLIRGen().target().inlineObjects) {</span>
                      getLIRGen().append(new AMD64BinaryConsumer.VMConstOp(CMP.getMIOpcode(DWORD, false), left, vc));
                  } else {
                      getLIRGen().append(new AMD64BinaryConsumer.DataOp(CMP.getRMOpcode(size), size, left, vc));
                  }
                  return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1312,11 ***</span>
              getLIRGen().append(new AMD64Binary.RMIOp(AMD64RMIOp.ROUNDSD, OperandSize.PD, result, asAllocatable(value), mode.encoding));
          }
          return result;
      }
  
<span class="line-modified">!     private boolean supportAVX() {</span>
          TargetDescription target = getLIRGen().target();
          return ((AMD64) target.arch).getFeatures().contains(CPUFeature.AVX);
      }
  
      private static AVXSize getRegisterSize(Value a) {
<span class="line-new-header">--- 1338,11 ---</span>
              getLIRGen().append(new AMD64Binary.RMIOp(AMD64RMIOp.ROUNDSD, OperandSize.PD, result, asAllocatable(value), mode.encoding));
          }
          return result;
      }
  
<span class="line-modified">!     public boolean supportAVX() {</span>
          TargetDescription target = getLIRGen().target();
          return ((AMD64) target.arch).getFeatures().contains(CPUFeature.AVX);
      }
  
      private static AVXSize getRegisterSize(Value a) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1326,12 ***</span>
          } else {
              return AVXSize.XMM;
          }
      }
  
<span class="line-modified">!     private Variable emitBinary(LIRKind resultKind, VexRVMOp op, Value a, Value b) {</span>
          Variable result = getLIRGen().newVariable(resultKind);
<span class="line-modified">!         getLIRGen().append(new AVXBinaryOp(op, getRegisterSize(result), result, asAllocatable(a), asAllocatable(b)));</span>
          return result;
      }
  
  }
<span class="line-new-header">--- 1352,16 ---</span>
          } else {
              return AVXSize.XMM;
          }
      }
  
<span class="line-modified">!     protected Variable emitBinary(LIRKind resultKind, VexRVMOp op, Value a, Value b) {</span>
          Variable result = getLIRGen().newVariable(resultKind);
<span class="line-modified">!         if (b instanceof ConstantValue &amp;&amp; (b.getPlatformKind() == AMD64Kind.SINGLE || b.getPlatformKind() == AMD64Kind.DOUBLE)) {</span>
<span class="line-added">+             getLIRGen().append(new AVXBinaryConstFloatOp(op, getRegisterSize(result), result, asAllocatable(a), (ConstantValue) b));</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             getLIRGen().append(new AVXBinaryOp(op, getRegisterSize(result), result, asAllocatable(a), asAllocatable(b)));</span>
<span class="line-added">+         }</span>
          return result;
      }
  
  }
</pre>
<center><a href="AMD64AddressNode.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64LIRGenerator.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
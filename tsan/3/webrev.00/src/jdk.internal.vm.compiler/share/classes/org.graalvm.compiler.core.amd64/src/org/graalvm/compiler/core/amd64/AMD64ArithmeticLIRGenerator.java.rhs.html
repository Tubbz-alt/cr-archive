<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64ArithmeticLIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 
  26 package org.graalvm.compiler.core.amd64;
  27 
  28 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.ADD;
  29 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.AND;
  30 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.CMP;
  31 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.OR;
  32 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.SUB;
  33 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.XOR;
  34 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp.NEG;
  35 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp.NOT;
  36 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.BSF;
  37 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.BSR;
  38 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.LZCNT;
  39 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOV;
  40 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSD;
  41 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSS;
  42 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSX;
  43 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSXB;
  44 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSXD;
  45 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVZX;
  46 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVZXB;
  47 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.POPCNT;
  48 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.TEST;
  49 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.TESTB;
  50 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.TZCNT;
  51 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift.ROL;
  52 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift.ROR;
  53 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift.SAR;
  54 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift.SHL;
  55 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift.SHR;
  56 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VADDSD;
  57 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VADDSS;
  58 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VDIVSD;
  59 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VDIVSS;
<a name="1" id="anc1"></a><span class="line-added">  60 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VFMADD231SD;</span>
<span class="line-added">  61 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VFMADD231SS;</span>
  62 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VMULSD;
  63 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VMULSS;
  64 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VORPD;
  65 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VORPS;
  66 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VSUBSD;
  67 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VSUBSS;
  68 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VXORPD;
  69 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VXORPS;
  70 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.BYTE;
  71 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.DWORD;
  72 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PD;
  73 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PS;
  74 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.QWORD;
  75 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.SD;
  76 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.SS;
  77 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.WORD;
  78 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
  79 import static org.graalvm.compiler.lir.LIRValueUtil.asConstantValue;
  80 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
  81 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
  82 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
  83 import static org.graalvm.compiler.lir.amd64.AMD64Arithmetic.DREM;
  84 import static org.graalvm.compiler.lir.amd64.AMD64Arithmetic.FREM;
  85 
  86 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic;
  87 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
  88 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp;
  89 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MROp;
  90 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMIOp;
  91 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
  92 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift;
  93 import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
  94 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexGeneralPurposeRMOp;
  95 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexGeneralPurposeRVMOp;
  96 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp;
  97 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;
  98 import org.graalvm.compiler.asm.amd64.AVXKind;
  99 import org.graalvm.compiler.asm.amd64.AVXKind.AVXSize;
 100 import org.graalvm.compiler.core.common.LIRKind;
 101 import org.graalvm.compiler.core.common.NumUtil;
 102 import org.graalvm.compiler.core.common.calc.FloatConvert;
 103 import org.graalvm.compiler.debug.GraalError;
 104 import org.graalvm.compiler.lir.ConstantValue;
 105 import org.graalvm.compiler.lir.LIRFrameState;
 106 import org.graalvm.compiler.lir.LIRValueUtil;
 107 import org.graalvm.compiler.lir.Variable;
 108 import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
 109 import org.graalvm.compiler.lir.amd64.AMD64Arithmetic.FPDivRemOp;
 110 import org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool;
 111 import org.graalvm.compiler.lir.amd64.AMD64Binary;
 112 import org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer;
 113 import org.graalvm.compiler.lir.amd64.AMD64ClearRegisterOp;
 114 import org.graalvm.compiler.lir.amd64.AMD64MathCosOp;
 115 import org.graalvm.compiler.lir.amd64.AMD64MathExpOp;
 116 import org.graalvm.compiler.lir.amd64.AMD64MathLog10Op;
 117 import org.graalvm.compiler.lir.amd64.AMD64MathLogOp;
 118 import org.graalvm.compiler.lir.amd64.AMD64MathPowOp;
 119 import org.graalvm.compiler.lir.amd64.AMD64MathSinOp;
 120 import org.graalvm.compiler.lir.amd64.AMD64MathTanOp;
 121 import org.graalvm.compiler.lir.amd64.AMD64Move;
 122 import org.graalvm.compiler.lir.amd64.AMD64MulDivOp;
 123 import org.graalvm.compiler.lir.amd64.AMD64ShiftOp;
 124 import org.graalvm.compiler.lir.amd64.AMD64SignExtendOp;
<a name="2" id="anc2"></a><span class="line-added"> 125 import org.graalvm.compiler.lir.amd64.AMD64Ternary;</span>
 126 import org.graalvm.compiler.lir.amd64.AMD64Unary;
 127 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorBinary;
<a name="3" id="anc3"></a><span class="line-added"> 128 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorBinary.AVXBinaryConstFloatOp;</span>
 129 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorBinary.AVXBinaryOp;
 130 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorUnary;
 131 import org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator;
 132 
 133 import jdk.vm.ci.amd64.AMD64;
 134 import jdk.vm.ci.amd64.AMD64.CPUFeature;
 135 import jdk.vm.ci.amd64.AMD64Kind;
 136 import jdk.vm.ci.code.CodeUtil;
 137 import jdk.vm.ci.code.Register;
 138 import jdk.vm.ci.code.RegisterValue;
 139 import jdk.vm.ci.code.TargetDescription;
 140 import jdk.vm.ci.meta.AllocatableValue;
 141 import jdk.vm.ci.meta.Constant;
 142 import jdk.vm.ci.meta.JavaConstant;
 143 import jdk.vm.ci.meta.JavaKind;
 144 import jdk.vm.ci.meta.PlatformKind;
 145 import jdk.vm.ci.meta.VMConstant;
 146 import jdk.vm.ci.meta.Value;
 147 import jdk.vm.ci.meta.ValueKind;
 148 
 149 /**
 150  * This class implements the AMD64 specific portion of the LIR generator.
 151  */
 152 public class AMD64ArithmeticLIRGenerator extends ArithmeticLIRGenerator implements AMD64ArithmeticLIRGeneratorTool {
 153 
 154     private static final RegisterValue RCX_I = AMD64.rcx.asValue(LIRKind.value(AMD64Kind.DWORD));
 155 
 156     public AMD64ArithmeticLIRGenerator(AllocatableValue nullRegisterValue) {
 157         this.nullRegisterValue = nullRegisterValue;
 158     }
 159 
 160     private final AllocatableValue nullRegisterValue;
 161 
 162     @Override
 163     public Variable emitNegate(Value inputVal) {
 164         AllocatableValue input = asAllocatable(inputVal);
 165         Variable result = getLIRGen().newVariable(LIRKind.combine(input));
 166         boolean isAvx = supportAVX();
 167         switch ((AMD64Kind) input.getPlatformKind()) {
 168             case DWORD:
 169                 getLIRGen().append(new AMD64Unary.MOp(NEG, DWORD, result, input));
 170                 break;
 171             case QWORD:
 172                 getLIRGen().append(new AMD64Unary.MOp(NEG, QWORD, result, input));
 173                 break;
 174             case SINGLE:
 175                 JavaConstant floatMask = JavaConstant.forFloat(Float.intBitsToFloat(0x80000000));
 176                 if (isAvx) {
 177                     getLIRGen().append(new AVXBinaryOp(VXORPS, getRegisterSize(result), result, asAllocatable(input), asAllocatable(getLIRGen().emitJavaConstant(floatMask))));
 178                 } else {
 179                     getLIRGen().append(new AMD64Binary.DataTwoOp(SSEOp.XOR, PS, result, input, floatMask, 16));
 180                 }
 181                 break;
 182             case DOUBLE:
 183                 JavaConstant doubleMask = JavaConstant.forDouble(Double.longBitsToDouble(0x8000000000000000L));
 184                 if (isAvx) {
 185                     getLIRGen().append(new AVXBinaryOp(VXORPD, getRegisterSize(result), result, asAllocatable(input), asAllocatable(getLIRGen().emitJavaConstant(doubleMask))));
 186                 } else {
 187                     getLIRGen().append(new AMD64Binary.DataTwoOp(SSEOp.XOR, PD, result, input, doubleMask, 16));
 188                 }
 189                 break;
 190             default:
 191                 throw GraalError.shouldNotReachHere(input.getPlatformKind().toString());
 192         }
 193         return result;
 194     }
 195 
 196     @Override
 197     public Variable emitNot(Value inputVal) {
 198         AllocatableValue input = asAllocatable(inputVal);
 199         Variable result = getLIRGen().newVariable(LIRKind.combine(input));
 200         switch ((AMD64Kind) input.getPlatformKind()) {
 201             case DWORD:
 202                 getLIRGen().append(new AMD64Unary.MOp(NOT, DWORD, result, input));
 203                 break;
 204             case QWORD:
 205                 getLIRGen().append(new AMD64Unary.MOp(NOT, QWORD, result, input));
 206                 break;
 207             default:
 208                 throw GraalError.shouldNotReachHere();
 209         }
 210         return result;
 211     }
 212 
 213     private Variable emitBinary(LIRKind resultKind, AMD64BinaryArithmetic op, OperandSize size, boolean commutative, Value a, Value b, boolean setFlags) {
 214         if (isJavaConstant(b)) {
 215             return emitBinaryConst(resultKind, op, size, commutative, asAllocatable(a), asConstantValue(b), setFlags);
 216         } else if (commutative &amp;&amp; isJavaConstant(a)) {
 217             return emitBinaryConst(resultKind, op, size, commutative, asAllocatable(b), asConstantValue(a), setFlags);
 218         } else {
 219             return emitBinaryVar(resultKind, op.getRMOpcode(size), size, commutative, asAllocatable(a), asAllocatable(b));
 220         }
 221     }
 222 
 223     private Variable emitBinary(LIRKind resultKind, AMD64RMOp op, OperandSize size, boolean commutative, Value a, Value b) {
 224         if (isJavaConstant(b)) {
 225             return emitBinaryConst(resultKind, op, size, asAllocatable(a), asJavaConstant(b));
 226         } else if (commutative &amp;&amp; isJavaConstant(a)) {
 227             return emitBinaryConst(resultKind, op, size, asAllocatable(b), asJavaConstant(a));
 228         } else {
 229             return emitBinaryVar(resultKind, op, size, commutative, asAllocatable(a), asAllocatable(b));
 230         }
 231     }
 232 
 233     private Variable emitBinaryConst(LIRKind resultKind, AMD64BinaryArithmetic op, OperandSize size, boolean commutative, AllocatableValue a, ConstantValue b, boolean setFlags) {
 234         long value = b.getJavaConstant().asLong();
 235         if (NumUtil.isInt(value)) {
 236             Variable result = getLIRGen().newVariable(resultKind);
 237             int constant = (int) value;
 238 
 239             if (!setFlags) {
 240                 AMD64MOp mop = getMOp(op, constant);
 241                 if (mop != null) {
 242                     getLIRGen().append(new AMD64Unary.MOp(mop, size, result, a));
 243                     return result;
 244                 }
 245             }
 246 
 247             getLIRGen().append(new AMD64Binary.ConstOp(op, size, result, a, constant));
 248             return result;
 249         } else {
 250             return emitBinaryVar(resultKind, op.getRMOpcode(size), size, commutative, a, asAllocatable(b));
 251         }
 252     }
 253 
 254     private static AMD64MOp getMOp(AMD64BinaryArithmetic op, int constant) {
 255         if (constant == 1) {
 256             if (op.equals(AMD64BinaryArithmetic.ADD)) {
 257                 return AMD64MOp.INC;
 258             }
 259             if (op.equals(AMD64BinaryArithmetic.SUB)) {
 260                 return AMD64MOp.DEC;
 261             }
 262         } else if (constant == -1) {
 263             if (op.equals(AMD64BinaryArithmetic.ADD)) {
 264                 return AMD64MOp.DEC;
 265             }
 266             if (op.equals(AMD64BinaryArithmetic.SUB)) {
 267                 return AMD64MOp.INC;
 268             }
 269         }
 270         return null;
 271     }
 272 
 273     private Variable emitBinaryConst(LIRKind resultKind, AMD64RMOp op, OperandSize size, AllocatableValue a, JavaConstant b) {
 274         Variable result = getLIRGen().newVariable(resultKind);
 275         getLIRGen().append(new AMD64Binary.DataTwoOp(op, size, result, a, b));
 276         return result;
 277     }
 278 
 279     private Variable emitBinaryVar(LIRKind resultKind, AMD64RMOp op, OperandSize size, boolean commutative, AllocatableValue a, AllocatableValue b) {
 280         Variable result = getLIRGen().newVariable(resultKind);
 281         if (commutative) {
 282             getLIRGen().append(new AMD64Binary.CommutativeTwoOp(op, size, result, a, b));
 283         } else {
 284             getLIRGen().append(new AMD64Binary.TwoOp(op, size, result, a, b));
 285         }
 286         return result;
 287     }
 288 
 289     @Override
 290     protected boolean isNumericInteger(PlatformKind kind) {
 291         return ((AMD64Kind) kind).isInteger();
 292     }
 293 
 294     private Variable emitBaseOffsetLea(LIRKind resultKind, Value base, int offset, OperandSize size) {
 295         Variable result = getLIRGen().newVariable(resultKind);
 296         AMD64AddressValue address = new AMD64AddressValue(resultKind, asAllocatable(base), offset);
 297         getLIRGen().append(new AMD64Move.LeaOp(result, address, size));
 298         return result;
 299     }
 300 
 301     @Override
 302     public Variable emitAdd(LIRKind resultKind, Value a, Value b, boolean setFlags) {
 303         boolean isAvx = supportAVX();
 304         switch ((AMD64Kind) a.getPlatformKind()) {
 305             case DWORD:
 306                 if (isJavaConstant(b) &amp;&amp; !setFlags) {
 307                     long displacement = asJavaConstant(b).asLong();
 308                     if (NumUtil.isInt(displacement) &amp;&amp; displacement != 1 &amp;&amp; displacement != -1) {
 309                         return emitBaseOffsetLea(resultKind, a, (int) displacement, OperandSize.DWORD);
 310                     }
 311                 }
 312                 return emitBinary(resultKind, ADD, DWORD, true, a, b, setFlags);
 313             case QWORD:
 314                 if (isJavaConstant(b) &amp;&amp; !setFlags) {
 315                     long displacement = asJavaConstant(b).asLong();
 316                     if (NumUtil.isInt(displacement) &amp;&amp; displacement != 1 &amp;&amp; displacement != -1) {
 317                         return emitBaseOffsetLea(resultKind, a, (int) displacement, OperandSize.QWORD);
 318                     }
 319                 }
 320                 return emitBinary(resultKind, ADD, QWORD, true, a, b, setFlags);
 321             case SINGLE:
 322                 if (isAvx) {
 323                     return emitBinary(resultKind, VADDSS, a, b);
 324                 } else {
 325                     return emitBinary(resultKind, SSEOp.ADD, SS, true, a, b);
 326                 }
 327             case DOUBLE:
 328                 if (isAvx) {
 329                     return emitBinary(resultKind, VADDSD, a, b);
 330                 } else {
 331                     return emitBinary(resultKind, SSEOp.ADD, SD, true, a, b);
 332                 }
 333             default:
 334                 throw GraalError.shouldNotReachHere();
 335         }
 336     }
 337 
 338     @Override
 339     public Variable emitSub(LIRKind resultKind, Value a, Value b, boolean setFlags) {
 340         boolean isAvx = supportAVX();
 341         switch ((AMD64Kind) a.getPlatformKind()) {
 342             case DWORD:
 343                 return emitBinary(resultKind, SUB, DWORD, false, a, b, setFlags);
 344             case QWORD:
 345                 return emitBinary(resultKind, SUB, QWORD, false, a, b, setFlags);
 346             case SINGLE:
 347                 if (isAvx) {
 348                     return emitBinary(resultKind, VSUBSS, a, b);
 349                 } else {
 350                     return emitBinary(resultKind, SSEOp.SUB, SS, false, a, b);
 351                 }
 352             case DOUBLE:
 353                 if (isAvx) {
 354                     return emitBinary(resultKind, VSUBSD, a, b);
 355                 } else {
 356                     return emitBinary(resultKind, SSEOp.SUB, SD, false, a, b);
 357                 }
 358             default:
 359                 throw GraalError.shouldNotReachHere();
 360         }
 361     }
 362 
 363     private Variable emitIMULConst(OperandSize size, AllocatableValue a, ConstantValue b) {
 364         long value = b.getJavaConstant().asLong();
 365         if (NumUtil.isInt(value)) {
 366             int imm = (int) value;
 367             AMD64RMIOp op;
 368             if (NumUtil.isByte(imm)) {
 369                 op = AMD64RMIOp.IMUL_SX;
 370             } else {
 371                 op = AMD64RMIOp.IMUL;
 372             }
 373 
 374             Variable ret = getLIRGen().newVariable(LIRKind.combine(a, b));
 375             getLIRGen().append(new AMD64Binary.RMIOp(op, size, ret, a, imm));
 376             return ret;
 377         } else {
 378             return emitBinaryVar(LIRKind.combine(a, b), AMD64RMOp.IMUL, size, true, a, asAllocatable(b));
 379         }
 380     }
 381 
 382     private Variable emitIMUL(OperandSize size, Value a, Value b) {
 383         if (isJavaConstant(b)) {
 384             return emitIMULConst(size, asAllocatable(a), asConstantValue(b));
 385         } else if (isJavaConstant(a)) {
 386             return emitIMULConst(size, asAllocatable(b), asConstantValue(a));
 387         } else {
 388             return emitBinaryVar(LIRKind.combine(a, b), AMD64RMOp.IMUL, size, true, asAllocatable(a), asAllocatable(b));
 389         }
 390     }
 391 
 392     @Override
 393     public Variable emitMul(Value a, Value b, boolean setFlags) {
 394         boolean isAvx = supportAVX();
 395         LIRKind resultKind = LIRKind.combine(a, b);
 396         switch ((AMD64Kind) a.getPlatformKind()) {
 397             case DWORD:
 398                 return emitIMUL(DWORD, a, b);
 399             case QWORD:
 400                 return emitIMUL(QWORD, a, b);
 401             case SINGLE:
 402                 if (isAvx) {
 403                     return emitBinary(resultKind, VMULSS, a, b);
 404                 } else {
 405                     return emitBinary(resultKind, SSEOp.MUL, SS, true, a, b);
 406                 }
 407             case DOUBLE:
 408                 if (isAvx) {
 409                     return emitBinary(resultKind, VMULSD, a, b);
 410                 } else {
 411                     return emitBinary(resultKind, SSEOp.MUL, SD, true, a, b);
 412                 }
 413             default:
 414                 throw GraalError.shouldNotReachHere();
 415         }
 416     }
 417 
 418     private RegisterValue moveToReg(Register reg, Value v) {
 419         RegisterValue ret = reg.asValue(v.getValueKind());
 420         getLIRGen().emitMove(ret, v);
 421         return ret;
 422     }
 423 
 424     private Value emitMulHigh(AMD64MOp opcode, OperandSize size, Value a, Value b) {
 425         AMD64MulDivOp mulHigh = getLIRGen().append(new AMD64MulDivOp(opcode, size, LIRKind.combine(a, b), moveToReg(AMD64.rax, a), asAllocatable(b)));
 426         return getLIRGen().emitMove(mulHigh.getHighResult());
 427     }
 428 
 429     @Override
 430     public Value emitMulHigh(Value a, Value b) {
 431         switch ((AMD64Kind) a.getPlatformKind()) {
 432             case DWORD:
 433                 return emitMulHigh(AMD64MOp.IMUL, DWORD, a, b);
 434             case QWORD:
 435                 return emitMulHigh(AMD64MOp.IMUL, QWORD, a, b);
 436             default:
 437                 throw GraalError.shouldNotReachHere();
 438         }
 439     }
 440 
 441     @Override
 442     public Value emitUMulHigh(Value a, Value b) {
 443         switch ((AMD64Kind) a.getPlatformKind()) {
 444             case DWORD:
 445                 return emitMulHigh(AMD64MOp.MUL, DWORD, a, b);
 446             case QWORD:
 447                 return emitMulHigh(AMD64MOp.MUL, QWORD, a, b);
 448             default:
 449                 throw GraalError.shouldNotReachHere();
 450         }
 451     }
 452 
<a name="4" id="anc4"></a><span class="line-added"> 453     public Value emitBinaryMemory(VexRVMOp op, OperandSize size, AllocatableValue a, AMD64AddressValue location, LIRFrameState state) {</span>
<span class="line-added"> 454         assert (size.isXmmType() &amp;&amp; supportAVX());</span>
<span class="line-added"> 455         Variable result = getLIRGen().newVariable(LIRKind.combine(a));</span>
<span class="line-added"> 456         getLIRGen().append(new AMD64VectorBinary.AVXBinaryMemoryOp(op, getRegisterSize(result), result, a, location, state));</span>
<span class="line-added"> 457         return result;</span>
<span class="line-added"> 458     }</span>
<span class="line-added"> 459 </span>
 460     public Value emitBinaryMemory(AMD64RMOp op, OperandSize size, AllocatableValue a, AMD64AddressValue location, LIRFrameState state) {
 461         Variable result = getLIRGen().newVariable(LIRKind.combine(a));
 462         getLIRGen().append(new AMD64Binary.MemoryTwoOp(op, size, result, a, location, state));
 463         return result;
 464     }
 465 
 466     protected Value emitConvertMemoryOp(PlatformKind kind, AMD64RMOp op, OperandSize size, AMD64AddressValue address, LIRFrameState state) {
 467         Variable result = getLIRGen().newVariable(LIRKind.value(kind));
 468         getLIRGen().append(new AMD64Unary.MemoryOp(op, size, result, address, state));
 469         return result;
 470     }
 471 
 472     protected Value emitZeroExtendMemory(AMD64Kind memoryKind, int resultBits, AMD64AddressValue address, LIRFrameState state) {
 473         // Issue a zero extending load of the proper bit size and set the result to
 474         // the proper kind.
 475         Variable result = getLIRGen().newVariable(LIRKind.value(resultBits &lt;= 32 ? AMD64Kind.DWORD : AMD64Kind.QWORD));
 476         switch (memoryKind) {
 477             case BYTE:
 478                 getLIRGen().append(new AMD64Unary.MemoryOp(MOVZXB, DWORD, result, address, state));
 479                 break;
 480             case WORD:
 481                 getLIRGen().append(new AMD64Unary.MemoryOp(MOVZX, DWORD, result, address, state));
 482                 break;
 483             case DWORD:
 484                 getLIRGen().append(new AMD64Unary.MemoryOp(MOV, DWORD, result, address, state));
 485                 break;
 486             case QWORD:
 487                 getLIRGen().append(new AMD64Unary.MemoryOp(MOV, QWORD, result, address, state));
 488                 break;
 489             default:
 490                 throw GraalError.shouldNotReachHere();
 491         }
 492         return result;
 493     }
 494 
 495     private AMD64MulDivOp emitIDIV(OperandSize size, Value a, Value b, LIRFrameState state) {
 496         LIRKind kind = LIRKind.combine(a, b);
 497 
 498         AMD64SignExtendOp sx = getLIRGen().append(new AMD64SignExtendOp(size, kind, moveToReg(AMD64.rax, a)));
 499         return getLIRGen().append(new AMD64MulDivOp(AMD64MOp.IDIV, size, kind, sx.getHighResult(), sx.getLowResult(), asAllocatable(b), state));
 500     }
 501 
 502     private AMD64MulDivOp emitDIV(OperandSize size, Value a, Value b, LIRFrameState state) {
 503         LIRKind kind = LIRKind.combine(a, b);
 504 
 505         RegisterValue rax = moveToReg(AMD64.rax, a);
 506         RegisterValue rdx = AMD64.rdx.asValue(kind);
 507         getLIRGen().append(new AMD64ClearRegisterOp(size, rdx));
 508         return getLIRGen().append(new AMD64MulDivOp(AMD64MOp.DIV, size, kind, rdx, rax, asAllocatable(b), state));
 509     }
 510 
 511     public Value[] emitSignedDivRem(Value a, Value b, LIRFrameState state) {
 512         AMD64MulDivOp op;
 513         switch ((AMD64Kind) a.getPlatformKind()) {
 514             case DWORD:
 515                 op = emitIDIV(DWORD, a, b, state);
 516                 break;
 517             case QWORD:
 518                 op = emitIDIV(QWORD, a, b, state);
 519                 break;
 520             default:
 521                 throw GraalError.shouldNotReachHere();
 522         }
 523         return new Value[]{getLIRGen().emitMove(op.getQuotient()), getLIRGen().emitMove(op.getRemainder())};
 524     }
 525 
 526     public Value[] emitUnsignedDivRem(Value a, Value b, LIRFrameState state) {
 527         AMD64MulDivOp op;
 528         switch ((AMD64Kind) a.getPlatformKind()) {
 529             case DWORD:
 530                 op = emitDIV(DWORD, a, b, state);
 531                 break;
 532             case QWORD:
 533                 op = emitDIV(QWORD, a, b, state);
 534                 break;
 535             default:
 536                 throw GraalError.shouldNotReachHere();
 537         }
 538         return new Value[]{getLIRGen().emitMove(op.getQuotient()), getLIRGen().emitMove(op.getRemainder())};
 539     }
 540 
 541     @Override
 542     public Value emitDiv(Value a, Value b, LIRFrameState state) {
 543         boolean isAvx = supportAVX();
 544         LIRKind resultKind = LIRKind.combine(a, b);
 545         switch ((AMD64Kind) a.getPlatformKind()) {
 546             case DWORD:
 547                 AMD64MulDivOp op = emitIDIV(DWORD, a, b, state);
 548                 return getLIRGen().emitMove(op.getQuotient());
 549             case QWORD:
 550                 AMD64MulDivOp lop = emitIDIV(QWORD, a, b, state);
 551                 return getLIRGen().emitMove(lop.getQuotient());
 552             case SINGLE:
 553                 if (isAvx) {
 554                     return emitBinary(resultKind, VDIVSS, a, b);
 555                 } else {
 556                     return emitBinary(resultKind, SSEOp.DIV, SS, false, a, b);
 557                 }
 558             case DOUBLE:
 559                 if (isAvx) {
 560                     return emitBinary(resultKind, VDIVSD, a, b);
 561                 } else {
 562                     return emitBinary(resultKind, SSEOp.DIV, SD, false, a, b);
 563                 }
 564             default:
 565                 throw GraalError.shouldNotReachHere();
 566         }
 567     }
 568 
 569     @Override
 570     public Value emitRem(Value a, Value b, LIRFrameState state) {
 571         switch ((AMD64Kind) a.getPlatformKind()) {
 572             case DWORD:
 573                 AMD64MulDivOp op = emitIDIV(DWORD, a, b, state);
 574                 return getLIRGen().emitMove(op.getRemainder());
 575             case QWORD:
 576                 AMD64MulDivOp lop = emitIDIV(QWORD, a, b, state);
 577                 return getLIRGen().emitMove(lop.getRemainder());
 578             case SINGLE: {
 579                 Variable result = getLIRGen().newVariable(LIRKind.combine(a, b));
 580                 getLIRGen().append(new FPDivRemOp(FREM, result, getLIRGen().load(a), getLIRGen().load(b)));
 581                 return result;
 582             }
 583             case DOUBLE: {
 584                 Variable result = getLIRGen().newVariable(LIRKind.combine(a, b));
 585                 getLIRGen().append(new FPDivRemOp(DREM, result, getLIRGen().load(a), getLIRGen().load(b)));
 586                 return result;
 587             }
 588             default:
 589                 throw GraalError.shouldNotReachHere();
 590         }
 591     }
 592 
 593     @Override
 594     public Variable emitUDiv(Value a, Value b, LIRFrameState state) {
 595         AMD64MulDivOp op;
 596         switch ((AMD64Kind) a.getPlatformKind()) {
 597             case DWORD:
 598                 op = emitDIV(DWORD, a, b, state);
 599                 break;
 600             case QWORD:
 601                 op = emitDIV(QWORD, a, b, state);
 602                 break;
 603             default:
 604                 throw GraalError.shouldNotReachHere();
 605         }
 606         return getLIRGen().emitMove(op.getQuotient());
 607     }
 608 
 609     @Override
 610     public Variable emitURem(Value a, Value b, LIRFrameState state) {
 611         AMD64MulDivOp op;
 612         switch ((AMD64Kind) a.getPlatformKind()) {
 613             case DWORD:
 614                 op = emitDIV(DWORD, a, b, state);
 615                 break;
 616             case QWORD:
 617                 op = emitDIV(QWORD, a, b, state);
 618                 break;
 619             default:
 620                 throw GraalError.shouldNotReachHere();
 621         }
 622         return getLIRGen().emitMove(op.getRemainder());
 623     }
 624 
 625     @Override
 626     public Variable emitAnd(Value a, Value b) {
 627         LIRKind resultKind = LIRKind.combine(a, b);
 628         switch ((AMD64Kind) a.getPlatformKind()) {
 629             case DWORD:
 630                 return emitBinary(resultKind, AND, DWORD, true, a, b, false);
 631             case QWORD:
 632                 return emitBinary(resultKind, AND, QWORD, true, a, b, false);
 633             case SINGLE:
 634                 return emitBinary(resultKind, SSEOp.AND, PS, true, a, b);
 635             case DOUBLE:
 636                 return emitBinary(resultKind, SSEOp.AND, PD, true, a, b);
 637             default:
 638                 throw GraalError.shouldNotReachHere();
 639         }
 640     }
 641 
 642     @Override
 643     public Variable emitOr(Value a, Value b) {
 644         boolean isAvx = supportAVX();
 645         LIRKind resultKind = LIRKind.combine(a, b);
 646         switch ((AMD64Kind) a.getPlatformKind()) {
 647             case DWORD:
 648                 return emitBinary(resultKind, OR, DWORD, true, a, b, false);
 649             case QWORD:
 650                 return emitBinary(resultKind, OR, QWORD, true, a, b, false);
 651             case SINGLE:
 652                 if (isAvx) {
 653                     return emitBinary(resultKind, VORPS, a, b);
 654                 } else {
 655                     return emitBinary(resultKind, SSEOp.OR, PS, true, a, b);
 656                 }
 657             case DOUBLE:
 658                 if (isAvx) {
 659                     return emitBinary(resultKind, VORPD, a, b);
 660                 } else {
 661                     return emitBinary(resultKind, SSEOp.OR, PD, true, a, b);
 662                 }
 663             default:
 664                 throw GraalError.shouldNotReachHere();
 665         }
 666     }
 667 
 668     @Override
 669     public Variable emitXor(Value a, Value b) {
 670         boolean isAvx = supportAVX();
 671         LIRKind resultKind = LIRKind.combine(a, b);
 672         switch ((AMD64Kind) a.getPlatformKind()) {
 673             case DWORD:
 674                 return emitBinary(resultKind, XOR, DWORD, true, a, b, false);
 675             case QWORD:
 676                 return emitBinary(resultKind, XOR, QWORD, true, a, b, false);
 677             case SINGLE:
 678                 if (isAvx) {
 679                     return emitBinary(resultKind, VXORPS, a, b);
 680                 } else {
 681                     return emitBinary(resultKind, SSEOp.XOR, PS, true, a, b);
 682                 }
 683             case DOUBLE:
 684                 if (isAvx) {
 685                     return emitBinary(resultKind, VXORPD, a, b);
 686                 } else {
 687                     return emitBinary(resultKind, SSEOp.XOR, PD, true, a, b);
 688                 }
 689             default:
 690                 throw GraalError.shouldNotReachHere();
 691         }
 692     }
 693 
 694     private Variable emitShift(AMD64Shift op, OperandSize size, Value a, Value b) {
 695         Variable result = getLIRGen().newVariable(LIRKind.combine(a, b).changeType(a.getPlatformKind()));
 696         AllocatableValue input = asAllocatable(a);
 697         if (isJavaConstant(b)) {
 698             JavaConstant c = asJavaConstant(b);
 699             if (c.asLong() == 1) {
 700                 getLIRGen().append(new AMD64Unary.MOp(op.m1Op, size, result, input));
 701             } else {
 702                 /*
<a name="5" id="anc5"></a><span class="line-modified"> 703                  * c needs to be masked here, because shifts with immediate expect a byte.</span>

 704                  */
<a name="6" id="anc6"></a><span class="line-modified"> 705                 getLIRGen().append(new AMD64Binary.ConstOp(op.miOp, size, result, input, (byte) c.asLong()));</span>
 706             }
 707         } else {
 708             getLIRGen().emitMove(RCX_I, b);
 709             getLIRGen().append(new AMD64ShiftOp(op.mcOp, size, result, input, RCX_I));
 710         }
 711         return result;
 712     }
 713 
 714     @Override
 715     public Variable emitShl(Value a, Value b) {
 716         switch ((AMD64Kind) a.getPlatformKind()) {
 717             case DWORD:
 718                 return emitShift(SHL, DWORD, a, b);
 719             case QWORD:
 720                 return emitShift(SHL, QWORD, a, b);
 721             default:
 722                 throw GraalError.shouldNotReachHere();
 723         }
 724     }
 725 
 726     @Override
 727     public Variable emitShr(Value a, Value b) {
 728         switch ((AMD64Kind) a.getPlatformKind()) {
 729             case DWORD:
 730                 return emitShift(SAR, DWORD, a, b);
 731             case QWORD:
 732                 return emitShift(SAR, QWORD, a, b);
 733             default:
 734                 throw GraalError.shouldNotReachHere();
 735         }
 736     }
 737 
 738     @Override
 739     public Variable emitUShr(Value a, Value b) {
 740         switch ((AMD64Kind) a.getPlatformKind()) {
 741             case DWORD:
 742                 return emitShift(SHR, DWORD, a, b);
 743             case QWORD:
 744                 return emitShift(SHR, QWORD, a, b);
 745             default:
 746                 throw GraalError.shouldNotReachHere();
 747         }
 748     }
 749 
 750     public Variable emitRol(Value a, Value b) {
 751         switch ((AMD64Kind) a.getPlatformKind()) {
 752             case DWORD:
 753                 return emitShift(ROL, DWORD, a, b);
 754             case QWORD:
 755                 return emitShift(ROL, QWORD, a, b);
 756             default:
 757                 throw GraalError.shouldNotReachHere();
 758         }
 759     }
 760 
 761     @Override
 762     public Variable emitRor(Value a, Value b) {
 763         switch ((AMD64Kind) a.getPlatformKind()) {
 764             case DWORD:
 765                 return emitShift(ROR, DWORD, a, b);
 766             case QWORD:
 767                 return emitShift(ROR, QWORD, a, b);
 768             default:
 769                 throw GraalError.shouldNotReachHere();
 770         }
 771     }
 772 
 773     private AllocatableValue emitConvertOp(LIRKind kind, AMD64RMOp op, OperandSize size, Value input) {
 774         Variable result = getLIRGen().newVariable(kind);
 775         getLIRGen().append(new AMD64Unary.RMOp(op, size, result, asAllocatable(input)));
 776         return result;
 777     }
 778 
 779     private AllocatableValue emitConvertOp(LIRKind kind, AMD64MROp op, OperandSize size, Value input) {
 780         Variable result = getLIRGen().newVariable(kind);
 781         getLIRGen().append(new AMD64Unary.MROp(op, size, result, asAllocatable(input)));
 782         return result;
 783     }
 784 
 785     @Override
 786     public Value emitReinterpret(LIRKind to, Value inputVal) {
 787         ValueKind&lt;?&gt; from = inputVal.getValueKind();
 788         if (to.equals(from)) {
 789             return inputVal;
 790         }
 791 
 792         AllocatableValue input = asAllocatable(inputVal);
 793         /*
 794          * Conversions between integer to floating point types require moves between CPU and FPU
 795          * registers.
 796          */
 797         AMD64Kind fromKind = (AMD64Kind) from.getPlatformKind();
 798         switch ((AMD64Kind) to.getPlatformKind()) {
 799             case DWORD:
 800                 switch (fromKind) {
 801                     case SINGLE:
 802                         return emitConvertOp(to, AMD64MROp.MOVD, DWORD, input);
 803                 }
 804                 break;
 805             case QWORD:
 806                 switch (fromKind) {
 807                     case DOUBLE:
 808                         return emitConvertOp(to, AMD64MROp.MOVQ, QWORD, input);
 809                 }
 810                 break;
 811             case SINGLE:
 812                 switch (fromKind) {
 813                     case DWORD:
 814                         return emitConvertOp(to, AMD64RMOp.MOVD, DWORD, input);
 815                 }
 816                 break;
 817             case DOUBLE:
 818                 switch (fromKind) {
 819                     case QWORD:
 820                         return emitConvertOp(to, AMD64RMOp.MOVQ, QWORD, input);
 821                 }
 822                 break;
 823         }
 824         throw GraalError.shouldNotReachHere();
 825     }
 826 
 827     @Override
 828     public Value emitFloatConvert(FloatConvert op, Value input) {
 829         switch (op) {
 830             case D2F:
 831                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.SINGLE), SSEOp.CVTSD2SS, SD, input);
 832             case D2I:
 833                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DWORD), SSEOp.CVTTSD2SI, DWORD, input);
 834             case D2L:
 835                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.QWORD), SSEOp.CVTTSD2SI, QWORD, input);
 836             case F2D:
 837                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DOUBLE), SSEOp.CVTSS2SD, SS, input);
 838             case F2I:
 839                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DWORD), SSEOp.CVTTSS2SI, DWORD, input);
 840             case F2L:
 841                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.QWORD), SSEOp.CVTTSS2SI, QWORD, input);
 842             case I2D:
 843                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DOUBLE), SSEOp.CVTSI2SD, DWORD, input);
 844             case I2F:
 845                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.SINGLE), SSEOp.CVTSI2SS, DWORD, input);
 846             case L2D:
 847                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DOUBLE), SSEOp.CVTSI2SD, QWORD, input);
 848             case L2F:
 849                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.SINGLE), SSEOp.CVTSI2SS, QWORD, input);
 850             default:
 851                 throw GraalError.shouldNotReachHere();
 852         }
 853     }
 854 
 855     @Override
 856     public Value emitNarrow(Value inputVal, int bits) {
 857         if (inputVal.getPlatformKind() == AMD64Kind.QWORD &amp;&amp; bits &lt;= 32) {
 858             // TODO make it possible to reinterpret Long as Int in LIR without move
 859             return emitConvertOp(LIRKind.combine(inputVal).changeType(AMD64Kind.DWORD), AMD64RMOp.MOV, DWORD, inputVal);
 860         } else {
 861             return inputVal;
 862         }
 863     }
 864 
 865     @Override
 866     public Value emitSignExtend(Value inputVal, int fromBits, int toBits) {
 867         assert fromBits &lt;= toBits &amp;&amp; toBits &lt;= 64;
 868         if (fromBits == toBits) {
 869             return inputVal;
 870         } else if (toBits &gt; 32) {
 871             // sign extend to 64 bits
 872             switch (fromBits) {
 873                 case 8:
 874                     return emitConvertOp(LIRKind.combine(inputVal).changeType(AMD64Kind.QWORD), MOVSXB, QWORD, inputVal);
 875                 case 16:
 876                     return emitConvertOp(LIRKind.combine(inputVal).changeType(AMD64Kind.QWORD), MOVSX, QWORD, inputVal);
 877                 case 32:
 878                     return emitConvertOp(LIRKind.combine(inputVal).changeType(AMD64Kind.QWORD), MOVSXD, QWORD, inputVal);
 879                 default:
 880                     throw GraalError.unimplemented(&quot;unsupported sign extension (&quot; + fromBits + &quot; bit -&gt; &quot; + toBits + &quot; bit)&quot;);
 881             }
 882         } else {
 883             // sign extend to 32 bits (smaller values are internally represented as 32 bit values)
 884             switch (fromBits) {
 885                 case 8:
 886                     return emitConvertOp(LIRKind.combine(inputVal).changeType(AMD64Kind.DWORD), MOVSXB, DWORD, inputVal);
 887                 case 16:
 888                     return emitConvertOp(LIRKind.combine(inputVal).changeType(AMD64Kind.DWORD), MOVSX, DWORD, inputVal);
 889                 case 32:
 890                     return inputVal;
 891                 default:
 892                     throw GraalError.unimplemented(&quot;unsupported sign extension (&quot; + fromBits + &quot; bit -&gt; &quot; + toBits + &quot; bit)&quot;);
 893             }
 894         }
 895     }
 896 
 897     @Override
 898     public Value emitZeroExtend(Value inputVal, int fromBits, int toBits) {
 899         assert fromBits &lt;= toBits &amp;&amp; toBits &lt;= 64;
 900         if (fromBits == toBits) {
 901             return inputVal;
 902         } else if (fromBits &gt; 32) {
 903             assert inputVal.getPlatformKind() == AMD64Kind.QWORD;
 904             Variable result = getLIRGen().newVariable(LIRKind.combine(inputVal));
 905             long mask = CodeUtil.mask(fromBits);
 906             getLIRGen().append(new AMD64Binary.DataTwoOp(AND.getRMOpcode(QWORD), QWORD, result, asAllocatable(inputVal), JavaConstant.forLong(mask)));
 907             return result;
 908         } else {
 909             LIRKind resultKind = LIRKind.combine(inputVal);
 910             if (toBits &gt; 32) {
 911                 resultKind = resultKind.changeType(AMD64Kind.QWORD);
 912             } else {
 913                 resultKind = resultKind.changeType(AMD64Kind.DWORD);
 914             }
 915 
 916             /*
 917              * Always emit DWORD operations, even if the resultKind is Long. On AMD64, all DWORD
 918              * operations implicitly set the upper half of the register to 0, which is what we want
 919              * anyway. Compared to the QWORD oparations, the encoding of the DWORD operations is
 920              * sometimes one byte shorter.
 921              */
 922             switch (fromBits) {
 923                 case 8:
 924                     return emitConvertOp(resultKind, MOVZXB, DWORD, inputVal);
 925                 case 16:
 926                     return emitConvertOp(resultKind, MOVZX, DWORD, inputVal);
 927                 case 32:
 928                     return emitConvertOp(resultKind, MOV, DWORD, inputVal);
 929             }
 930 
 931             // odd bit count, fall back on manual masking
 932             Variable result = getLIRGen().newVariable(resultKind);
 933             JavaConstant mask;
 934             if (toBits &gt; 32) {
 935                 mask = JavaConstant.forLong(CodeUtil.mask(fromBits));
 936             } else {
 937                 mask = JavaConstant.forInt((int) CodeUtil.mask(fromBits));
 938             }
 939             getLIRGen().append(new AMD64Binary.DataTwoOp(AND.getRMOpcode(DWORD), DWORD, result, asAllocatable(inputVal), mask));
 940             return result;
 941         }
 942     }
 943 
 944     @Override
 945     public Variable emitBitCount(Value value) {
 946         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AMD64Kind.DWORD));
 947         assert ((AMD64Kind) value.getPlatformKind()).isInteger();
 948         if (value.getPlatformKind() == AMD64Kind.QWORD) {
 949             getLIRGen().append(new AMD64Unary.RMOp(POPCNT, QWORD, result, asAllocatable(value)));
 950         } else {
 951             getLIRGen().append(new AMD64Unary.RMOp(POPCNT, DWORD, result, asAllocatable(value)));
 952         }
 953         return result;
 954     }
 955 
 956     @Override
 957     public Variable emitBitScanForward(Value value) {
 958         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AMD64Kind.DWORD));
 959         getLIRGen().append(new AMD64Unary.RMOp(BSF, QWORD, result, asAllocatable(value)));
 960         return result;
 961     }
 962 
 963     @Override
 964     public Variable emitBitScanReverse(Value value) {
 965         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AMD64Kind.DWORD));
 966         assert ((AMD64Kind) value.getPlatformKind()).isInteger();
 967         if (value.getPlatformKind() == AMD64Kind.QWORD) {
 968             getLIRGen().append(new AMD64Unary.RMOp(BSR, QWORD, result, asAllocatable(value)));
 969         } else {
 970             getLIRGen().append(new AMD64Unary.RMOp(BSR, DWORD, result, asAllocatable(value)));
 971         }
 972         return result;
 973     }
 974 
<a name="7" id="anc7"></a><span class="line-added"> 975     @Override</span>
<span class="line-added"> 976     public Variable emitFusedMultiplyAdd(Value a, Value b, Value c) {</span>
<span class="line-added"> 977         Variable result = getLIRGen().newVariable(LIRKind.combine(a, b, c));</span>
<span class="line-added"> 978         assert ((AMD64Kind) a.getPlatformKind()).isXMM() &amp;&amp; ((AMD64Kind) b.getPlatformKind()).isXMM() &amp;&amp; ((AMD64Kind) c.getPlatformKind()).isXMM();</span>
<span class="line-added"> 979         assert a.getPlatformKind().equals(b.getPlatformKind());</span>
<span class="line-added"> 980         assert b.getPlatformKind().equals(c.getPlatformKind());</span>
<span class="line-added"> 981 </span>
<span class="line-added"> 982         if (a.getPlatformKind() == AMD64Kind.DOUBLE) {</span>
<span class="line-added"> 983             getLIRGen().append(new AMD64Ternary.ThreeOp(VFMADD231SD, AVXSize.XMM, result, asAllocatable(c), asAllocatable(a), asAllocatable(b)));</span>
<span class="line-added"> 984         } else {</span>
<span class="line-added"> 985             assert a.getPlatformKind() == AMD64Kind.SINGLE;</span>
<span class="line-added"> 986             getLIRGen().append(new AMD64Ternary.ThreeOp(VFMADD231SS, AVXSize.XMM, result, asAllocatable(c), asAllocatable(a), asAllocatable(b)));</span>
<span class="line-added"> 987         }</span>
<span class="line-added"> 988         return result;</span>
<span class="line-added"> 989     }</span>
<span class="line-added"> 990 </span>
 991     @Override
 992     public Value emitCountLeadingZeros(Value value) {
 993         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AMD64Kind.DWORD));
 994         assert ((AMD64Kind) value.getPlatformKind()).isInteger();
 995         if (value.getPlatformKind() == AMD64Kind.QWORD) {
 996             getLIRGen().append(new AMD64Unary.RMOp(LZCNT, QWORD, result, asAllocatable(value)));
 997         } else {
 998             getLIRGen().append(new AMD64Unary.RMOp(LZCNT, DWORD, result, asAllocatable(value)));
 999         }
1000         return result;
1001     }
1002 
1003     @Override
1004     public Value emitCountTrailingZeros(Value value) {
1005         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AMD64Kind.DWORD));
1006         assert ((AMD64Kind) value.getPlatformKind()).isInteger();
1007         if (value.getPlatformKind() == AMD64Kind.QWORD) {
1008             getLIRGen().append(new AMD64Unary.RMOp(TZCNT, QWORD, result, asAllocatable(value)));
1009         } else {
1010             getLIRGen().append(new AMD64Unary.RMOp(TZCNT, DWORD, result, asAllocatable(value)));
1011         }
1012         return result;
1013     }
1014 
1015     @Override
1016     public Value emitLogicalAndNot(Value value1, Value value2) {
1017         Variable result = getLIRGen().newVariable(LIRKind.combine(value1, value2));
1018 
1019         if (value1.getPlatformKind() == AMD64Kind.QWORD) {
1020             getLIRGen().append(new AMD64VectorBinary.AVXBinaryOp(VexGeneralPurposeRVMOp.ANDN, AVXSize.QWORD, result, asAllocatable(value1), asAllocatable(value2)));
1021         } else {
1022             getLIRGen().append(new AMD64VectorBinary.AVXBinaryOp(VexGeneralPurposeRVMOp.ANDN, AVXSize.DWORD, result, asAllocatable(value1), asAllocatable(value2)));
1023         }
1024         return result;
1025     }
1026 
1027     @Override
1028     public Value emitLowestSetIsolatedBit(Value value) {
1029         Variable result = getLIRGen().newVariable(LIRKind.combine(value));
1030 
1031         if (value.getPlatformKind() == AMD64Kind.QWORD) {
1032             getLIRGen().append(new AMD64VectorUnary.AVXUnaryOp(VexGeneralPurposeRMOp.BLSI, AVXSize.QWORD, result, asAllocatable(value)));
1033         } else {
1034             getLIRGen().append(new AMD64VectorUnary.AVXUnaryOp(VexGeneralPurposeRMOp.BLSI, AVXSize.DWORD, result, asAllocatable(value)));
1035         }
1036 
1037         return result;
1038     }
1039 
1040     @Override
1041     public Value emitGetMaskUpToLowestSetBit(Value value) {
1042         Variable result = getLIRGen().newVariable(LIRKind.combine(value));
1043 
1044         if (value.getPlatformKind() == AMD64Kind.QWORD) {
1045             getLIRGen().append(new AMD64VectorUnary.AVXUnaryOp(VexGeneralPurposeRMOp.BLSMSK, AVXSize.QWORD, result, asAllocatable(value)));
1046         } else {
1047             getLIRGen().append(new AMD64VectorUnary.AVXUnaryOp(VexGeneralPurposeRMOp.BLSMSK, AVXSize.DWORD, result, asAllocatable(value)));
1048         }
1049 
1050         return result;
1051     }
1052 
1053     @Override
1054     public Value emitResetLowestSetBit(Value value) {
1055         Variable result = getLIRGen().newVariable(LIRKind.combine(value));
1056 
1057         if (value.getPlatformKind() == AMD64Kind.QWORD) {
1058             getLIRGen().append(new AMD64VectorUnary.AVXUnaryOp(VexGeneralPurposeRMOp.BLSR, AVXSize.QWORD, result, asAllocatable(value)));
1059         } else {
1060             getLIRGen().append(new AMD64VectorUnary.AVXUnaryOp(VexGeneralPurposeRMOp.BLSR, AVXSize.DWORD, result, asAllocatable(value)));
1061         }
1062 
1063         return result;
1064     }
1065 
1066     @Override
1067     public Value emitMathAbs(Value input) {
1068         Variable result = getLIRGen().newVariable(LIRKind.combine(input));
1069         switch ((AMD64Kind) input.getPlatformKind()) {
1070             case SINGLE:
1071                 getLIRGen().append(new AMD64Binary.DataTwoOp(SSEOp.AND, PS, result, asAllocatable(input), JavaConstant.forFloat(Float.intBitsToFloat(0x7FFFFFFF)), 16));
1072                 break;
1073             case DOUBLE:
1074                 getLIRGen().append(new AMD64Binary.DataTwoOp(SSEOp.AND, PD, result, asAllocatable(input), JavaConstant.forDouble(Double.longBitsToDouble(0x7FFFFFFFFFFFFFFFL)), 16));
1075                 break;
1076             default:
1077                 throw GraalError.shouldNotReachHere();
1078         }
1079         return result;
1080     }
1081 
1082     @Override
1083     public Value emitMathSqrt(Value input) {
1084         Variable result = getLIRGen().newVariable(LIRKind.combine(input));
1085         switch ((AMD64Kind) input.getPlatformKind()) {
1086             case SINGLE:
1087                 getLIRGen().append(new AMD64Unary.RMOp(SSEOp.SQRT, SS, result, asAllocatable(input)));
1088                 break;
1089             case DOUBLE:
1090                 getLIRGen().append(new AMD64Unary.RMOp(SSEOp.SQRT, SD, result, asAllocatable(input)));
1091                 break;
1092             default:
1093                 throw GraalError.shouldNotReachHere();
1094         }
1095         return result;
1096     }
1097 
1098     @Override
1099     public Value emitMathLog(Value input, boolean base10) {
1100         if (base10) {
1101             return new AMD64MathLog10Op().emitLIRWrapper(getLIRGen(), input);
1102         } else {
1103             return new AMD64MathLogOp().emitLIRWrapper(getLIRGen(), input);
1104         }
1105     }
1106 
1107     @Override
1108     public Value emitMathCos(Value input) {
1109         return new AMD64MathCosOp().emitLIRWrapper(getLIRGen(), input);
1110     }
1111 
1112     @Override
1113     public Value emitMathSin(Value input) {
1114         return new AMD64MathSinOp().emitLIRWrapper(getLIRGen(), input);
1115     }
1116 
1117     @Override
1118     public Value emitMathTan(Value input) {
1119         return new AMD64MathTanOp().emitLIRWrapper(getLIRGen(), input);
1120     }
1121 
1122     @Override
1123     public Value emitMathExp(Value input) {
1124         return new AMD64MathExpOp().emitLIRWrapper(getLIRGen(), input);
1125     }
1126 
1127     @Override
1128     public Value emitMathPow(Value x, Value y) {
1129         return new AMD64MathPowOp().emitLIRWrapper(getLIRGen(), x, y);
1130     }
1131 
1132     protected AMD64LIRGenerator getAMD64LIRGen() {
1133         return (AMD64LIRGenerator) getLIRGen();
1134     }
1135 
1136     @Override
1137     public Variable emitLoad(LIRKind kind, Value address, LIRFrameState state) {
1138         AMD64AddressValue loadAddress = getAMD64LIRGen().asAddressValue(address);
1139         Variable result = getLIRGen().newVariable(getLIRGen().toRegisterKind(kind));
1140         switch ((AMD64Kind) kind.getPlatformKind()) {
1141             case BYTE:
1142                 getLIRGen().append(new AMD64Unary.MemoryOp(MOVSXB, DWORD, result, loadAddress, state));
1143                 break;
1144             case WORD:
1145                 getLIRGen().append(new AMD64Unary.MemoryOp(MOVSX, DWORD, result, loadAddress, state));
1146                 break;
1147             case DWORD:
1148                 getLIRGen().append(new AMD64Unary.MemoryOp(MOV, DWORD, result, loadAddress, state));
1149                 break;
1150             case QWORD:
1151                 getLIRGen().append(new AMD64Unary.MemoryOp(MOV, QWORD, result, loadAddress, state));
1152                 break;
1153             case SINGLE:
1154                 getLIRGen().append(new AMD64Unary.MemoryOp(MOVSS, SS, result, loadAddress, state));
1155                 break;
1156             case DOUBLE:
1157                 getLIRGen().append(new AMD64Unary.MemoryOp(MOVSD, SD, result, loadAddress, state));
1158                 break;
1159             default:
1160                 throw GraalError.shouldNotReachHere();
1161         }
1162         return result;
1163     }
1164 
1165     protected void emitStoreConst(AMD64Kind kind, AMD64AddressValue address, ConstantValue value, LIRFrameState state) {
1166         Constant c = value.getConstant();
1167         if (JavaConstant.isNull(c)) {
1168             assert kind == AMD64Kind.DWORD || kind == AMD64Kind.QWORD;
1169             OperandSize size = kind == AMD64Kind.DWORD ? DWORD : QWORD;
1170             getLIRGen().append(new AMD64BinaryConsumer.MemoryConstOp(AMD64MIOp.MOV, size, address, 0, state));
1171             return;
1172         } else if (c instanceof VMConstant) {
1173             // only 32-bit constants can be patched
1174             if (kind == AMD64Kind.DWORD) {
1175                 if (getLIRGen().target().inlineObjects || !(c instanceof JavaConstant)) {
1176                     // if c is a JavaConstant, it&#39;s an oop, otherwise it&#39;s a metaspace constant
1177                     assert !(c instanceof JavaConstant) || ((JavaConstant) c).getJavaKind() == JavaKind.Object;
1178                     getLIRGen().append(new AMD64BinaryConsumer.MemoryVMConstOp(AMD64MIOp.MOV, address, (VMConstant) c, state));
1179                     return;
1180                 }
1181             }
1182         } else {
1183             JavaConstant jc = (JavaConstant) c;
1184             assert jc.getJavaKind().isPrimitive();
1185 
1186             AMD64MIOp op = AMD64MIOp.MOV;
1187             OperandSize size;
1188             long imm;
1189 
1190             switch (kind) {
1191                 case BYTE:
1192                     op = AMD64MIOp.MOVB;
1193                     size = BYTE;
1194                     imm = jc.asInt();
1195                     break;
1196                 case WORD:
1197                     size = WORD;
1198                     imm = jc.asInt();
1199                     break;
1200                 case DWORD:
1201                     size = DWORD;
1202                     imm = jc.asInt();
1203                     break;
1204                 case QWORD:
1205                     size = QWORD;
1206                     imm = jc.asLong();
1207                     break;
1208                 case SINGLE:
1209                     size = DWORD;
1210                     imm = Float.floatToRawIntBits(jc.asFloat());
1211                     break;
1212                 case DOUBLE:
1213                     size = QWORD;
1214                     imm = Double.doubleToRawLongBits(jc.asDouble());
1215                     break;
1216                 default:
1217                     throw GraalError.shouldNotReachHere(&quot;unexpected kind &quot; + kind);
1218             }
1219 
1220             if (NumUtil.isInt(imm)) {
1221                 getLIRGen().append(new AMD64BinaryConsumer.MemoryConstOp(op, size, address, (int) imm, state));
1222                 return;
1223             }
1224         }
1225 
1226         // fallback: load, then store
1227         emitStore(kind, address, asAllocatable(value), state);
1228     }
1229 
1230     protected void emitStore(AMD64Kind kind, AMD64AddressValue address, AllocatableValue value, LIRFrameState state) {
1231         switch (kind) {
1232             case BYTE:
1233                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOVB, BYTE, address, value, state));
1234                 break;
1235             case WORD:
1236                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOV, WORD, address, value, state));
1237                 break;
1238             case DWORD:
1239                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOV, DWORD, address, value, state));
1240                 break;
1241             case QWORD:
1242                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOV, QWORD, address, value, state));
1243                 break;
1244             case SINGLE:
1245                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOVSS, SS, address, value, state));
1246                 break;
1247             case DOUBLE:
1248                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOVSD, SD, address, value, state));
1249                 break;
1250             default:
1251                 throw GraalError.shouldNotReachHere();
1252         }
1253     }
1254 
1255     @Override
1256     public void emitStore(ValueKind&lt;?&gt; lirKind, Value address, Value input, LIRFrameState state) {
1257         AMD64AddressValue storeAddress = getAMD64LIRGen().asAddressValue(address);
1258         AMD64Kind kind = (AMD64Kind) lirKind.getPlatformKind();
1259         if (isConstantValue(input)) {
1260             emitStoreConst(kind, storeAddress, asConstantValue(input), state);
1261         } else {
1262             emitStore(kind, storeAddress, asAllocatable(input), state);
1263         }
1264     }
1265 
1266     private boolean mustReplaceNullWithNullRegister(Constant nullConstant) {
1267         /* Uncompressed null pointers only */
1268         return nullRegisterValue != null &amp;&amp; JavaConstant.NULL_POINTER.equals(nullConstant);
1269     }
1270 
1271     @Override
1272     public void emitCompareOp(AMD64Kind cmpKind, Variable left, Value right) {
1273         OperandSize size;
1274         switch (cmpKind) {
1275             case BYTE:
1276                 size = BYTE;
1277                 break;
1278             case WORD:
1279                 size = WORD;
1280                 break;
1281             case DWORD:
1282                 size = DWORD;
1283                 break;
1284             case QWORD:
1285                 size = QWORD;
1286                 break;
1287             case SINGLE:
1288                 getLIRGen().append(new AMD64BinaryConsumer.Op(SSEOp.UCOMIS, PS, left, asAllocatable(right)));
1289                 return;
1290             case DOUBLE:
1291                 getLIRGen().append(new AMD64BinaryConsumer.Op(SSEOp.UCOMIS, PD, left, asAllocatable(right)));
1292                 return;
1293             default:
1294                 throw GraalError.shouldNotReachHere(&quot;unexpected kind: &quot; + cmpKind);
1295         }
1296 
1297         if (isConstantValue(right)) {
1298             Constant c = LIRValueUtil.asConstant(right);
1299             if (JavaConstant.isNull(c)) {
1300                 if (mustReplaceNullWithNullRegister(c)) {
1301                     getLIRGen().append(new AMD64BinaryConsumer.Op(AMD64RMOp.CMP, size, left, nullRegisterValue));
1302                 } else {
1303                     getLIRGen().append(new AMD64BinaryConsumer.Op(TEST, size, left, left));
1304                 }
1305                 return;
1306             } else if (c instanceof VMConstant) {
1307                 VMConstant vc = (VMConstant) c;
<a name="8" id="anc8"></a><span class="line-modified">1308                 if (size == DWORD &amp;&amp; !GeneratePIC.getValue(getOptions()) &amp;&amp; getLIRGen().target().inlineObjects) {</span>
1309                     getLIRGen().append(new AMD64BinaryConsumer.VMConstOp(CMP.getMIOpcode(DWORD, false), left, vc));
1310                 } else {
1311                     getLIRGen().append(new AMD64BinaryConsumer.DataOp(CMP.getRMOpcode(size), size, left, vc));
1312                 }
1313                 return;
1314             } else if (c instanceof JavaConstant) {
1315                 JavaConstant jc = (JavaConstant) c;
1316                 if (jc.isDefaultForKind()) {
1317                     AMD64RMOp op = size == BYTE ? TESTB : TEST;
1318                     getLIRGen().append(new AMD64BinaryConsumer.Op(op, size, left, left));
1319                     return;
1320                 } else if (NumUtil.is32bit(jc.asLong())) {
1321                     getLIRGen().append(new AMD64BinaryConsumer.ConstOp(CMP, size, left, (int) jc.asLong()));
1322                     return;
1323                 }
1324             }
1325         }
1326 
1327         // fallback: load, then compare
1328         getLIRGen().append(new AMD64BinaryConsumer.Op(CMP.getRMOpcode(size), size, left, asAllocatable(right)));
1329     }
1330 
1331     @Override
1332     public Value emitRound(Value value, RoundingMode mode) {
1333         Variable result = getLIRGen().newVariable(LIRKind.combine(value));
1334         assert ((AMD64Kind) value.getPlatformKind()).isXMM();
1335         if (value.getPlatformKind() == AMD64Kind.SINGLE) {
1336             getLIRGen().append(new AMD64Binary.RMIOp(AMD64RMIOp.ROUNDSS, OperandSize.PD, result, asAllocatable(value), mode.encoding));
1337         } else {
1338             getLIRGen().append(new AMD64Binary.RMIOp(AMD64RMIOp.ROUNDSD, OperandSize.PD, result, asAllocatable(value), mode.encoding));
1339         }
1340         return result;
1341     }
1342 
<a name="9" id="anc9"></a><span class="line-modified">1343     public boolean supportAVX() {</span>
1344         TargetDescription target = getLIRGen().target();
1345         return ((AMD64) target.arch).getFeatures().contains(CPUFeature.AVX);
1346     }
1347 
1348     private static AVXSize getRegisterSize(Value a) {
1349         AMD64Kind kind = (AMD64Kind) a.getPlatformKind();
1350         if (kind.isXMM()) {
1351             return AVXKind.getRegisterSize(kind);
1352         } else {
1353             return AVXSize.XMM;
1354         }
1355     }
1356 
<a name="10" id="anc10"></a><span class="line-modified">1357     protected Variable emitBinary(LIRKind resultKind, VexRVMOp op, Value a, Value b) {</span>
1358         Variable result = getLIRGen().newVariable(resultKind);
<a name="11" id="anc11"></a><span class="line-modified">1359         if (b instanceof ConstantValue &amp;&amp; (b.getPlatformKind() == AMD64Kind.SINGLE || b.getPlatformKind() == AMD64Kind.DOUBLE)) {</span>
<span class="line-added">1360             getLIRGen().append(new AVXBinaryConstFloatOp(op, getRegisterSize(result), result, asAllocatable(a), (ConstantValue) b));</span>
<span class="line-added">1361         } else {</span>
<span class="line-added">1362             getLIRGen().append(new AVXBinaryOp(op, getRegisterSize(result), result, asAllocatable(a), asAllocatable(b)));</span>
<span class="line-added">1363         }</span>
1364         return result;
1365     }
1366 
1367 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64LIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64ArithmeticLIRGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64MoveFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64LIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 import static jdk.vm.ci.code.ValueUtil.isRegister;
 31 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.CMP;
 32 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.DWORD;
 33 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PD;
 34 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PS;
 35 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.QWORD;
 36 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 37 import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
 38 import static org.graalvm.compiler.lir.LIRValueUtil.asConstantValue;
 39 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 40 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
 41 import static org.graalvm.compiler.lir.LIRValueUtil.isIntConstant;
 42 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 43 
 44 import java.util.Optional;
 45 
 46 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic;
 47 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
 48 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
 49 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
<span class="line-removed"> 50 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;</span>
 51 import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;




 52 import org.graalvm.compiler.core.common.LIRKind;
 53 import org.graalvm.compiler.core.common.NumUtil;
 54 import org.graalvm.compiler.core.common.calc.Condition;
 55 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 56 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 57 import org.graalvm.compiler.debug.GraalError;
 58 import org.graalvm.compiler.lir.ConstantValue;
 59 import org.graalvm.compiler.lir.LIRFrameState;
 60 import org.graalvm.compiler.lir.LIRInstruction;
 61 import org.graalvm.compiler.lir.LIRValueUtil;
 62 import org.graalvm.compiler.lir.LabelRef;
 63 import org.graalvm.compiler.lir.StandardOp.JumpOp;
<span class="line-modified"> 64 import org.graalvm.compiler.lir.StandardOp.SaveRegistersOp;</span>
 65 import org.graalvm.compiler.lir.SwitchStrategy;
 66 import org.graalvm.compiler.lir.Variable;
 67 import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
 68 import org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool;
 69 import org.graalvm.compiler.lir.amd64.AMD64ArrayCompareToOp;
 70 import org.graalvm.compiler.lir.amd64.AMD64ArrayEqualsOp;
 71 import org.graalvm.compiler.lir.amd64.AMD64ArrayIndexOfOp;
 72 import org.graalvm.compiler.lir.amd64.AMD64Binary;
 73 import org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer;
 74 import org.graalvm.compiler.lir.amd64.AMD64ByteSwapOp;
 75 import org.graalvm.compiler.lir.amd64.AMD64Call;
 76 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow;
 77 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.BranchOp;
 78 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondMoveOp;
 79 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondSetOp;
 80 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatBranchOp;
 81 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondMoveOp;
 82 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondSetOp;

 83 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.ReturnOp;
 84 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.StrategySwitchOp;
 85 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TableSwitchOp;
<span class="line-removed"> 86 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.HashTableSwitchOp;</span>
 87 import org.graalvm.compiler.lir.amd64.AMD64LFenceOp;
 88 import org.graalvm.compiler.lir.amd64.AMD64Move;
 89 import org.graalvm.compiler.lir.amd64.AMD64Move.CompareAndSwapOp;
 90 import org.graalvm.compiler.lir.amd64.AMD64Move.MembarOp;
 91 import org.graalvm.compiler.lir.amd64.AMD64Move.StackLeaOp;
 92 import org.graalvm.compiler.lir.amd64.AMD64PauseOp;
 93 import org.graalvm.compiler.lir.amd64.AMD64StringLatin1InflateOp;
 94 import org.graalvm.compiler.lir.amd64.AMD64StringUTF16CompressOp;
 95 import org.graalvm.compiler.lir.amd64.AMD64ZapRegistersOp;
 96 import org.graalvm.compiler.lir.amd64.AMD64ZapStackOp;


 97 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 98 import org.graalvm.compiler.lir.gen.LIRGenerator;
 99 import org.graalvm.compiler.lir.hashing.Hasher;
100 import org.graalvm.compiler.phases.util.Providers;
101 
102 import jdk.vm.ci.amd64.AMD64;
103 import jdk.vm.ci.amd64.AMD64Kind;
104 import jdk.vm.ci.code.CallingConvention;
105 import jdk.vm.ci.code.Register;
106 import jdk.vm.ci.code.RegisterValue;
107 import jdk.vm.ci.code.StackSlot;
108 import jdk.vm.ci.meta.AllocatableValue;
109 import jdk.vm.ci.meta.JavaConstant;
110 import jdk.vm.ci.meta.JavaKind;
111 import jdk.vm.ci.meta.PlatformKind;
112 import jdk.vm.ci.meta.VMConstant;
113 import jdk.vm.ci.meta.Value;
114 import jdk.vm.ci.meta.ValueKind;
115 
116 /**
</pre>
<hr />
<pre>
387                 }
388             } else {
389                 append(new CondSetOp(result, finalCondition.negate()));
390             }
391         } else if (isFloatComparison) {
392             append(new FloatCondMoveOp(result, finalCondition, unorderedIsTrue, load(finalTrueValue), load(finalFalseValue)));
393         } else {
394             append(new CondMoveOp(result, finalCondition, load(finalTrueValue), loadNonConst(finalFalseValue)));
395         }
396         return result;
397     }
398 
399     @Override
400     public Variable emitIntegerTestMove(Value left, Value right, Value trueValue, Value falseValue) {
401         emitIntegerTest(left, right);
402         Variable result = newVariable(trueValue.getValueKind());
403         append(new CondMoveOp(result, Condition.EQ, load(trueValue), loadNonConst(falseValue)));
404         return result;
405     }
406 









407     private void emitIntegerTest(Value a, Value b) {
<span class="line-modified">408         assert ((AMD64Kind) a.getPlatformKind()).isInteger();</span>
<span class="line-modified">409         OperandSize size = a.getPlatformKind() == AMD64Kind.QWORD ? QWORD : DWORD;</span>
<span class="line-removed">410         if (isJavaConstant(b) &amp;&amp; NumUtil.is32bit(asJavaConstant(b).asLong())) {</span>
<span class="line-removed">411             append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(a), (int) asJavaConstant(b).asLong()));</span>
<span class="line-removed">412         } else if (isJavaConstant(a) &amp;&amp; NumUtil.is32bit(asJavaConstant(a).asLong())) {</span>
<span class="line-removed">413             append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(b), (int) asJavaConstant(a).asLong()));</span>
<span class="line-removed">414         } else if (isAllocatableValue(b)) {</span>
<span class="line-removed">415             append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(b), asAllocatable(a)));</span>
416         } else {
<span class="line-modified">417             append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(a), asAllocatable(b)));</span>










418         }
419     }
420 
421     /**
422      * This method emits the compare against memory instruction, and may reorder the operands. It
423      * returns true if it did so.
424      *
425      * @param b the right operand of the comparison
426      * @return true if the left and right operands were switched, false otherwise
427      */
428     private boolean emitCompareMemory(AMD64Kind cmpKind, Value a, AMD64AddressValue b, LIRFrameState state) {
429         OperandSize size;
430         switch (cmpKind) {
431             case BYTE:
432                 size = OperandSize.BYTE;
433                 break;
434             case WORD:
435                 size = OperandSize.WORD;
436                 break;
437             case DWORD:
</pre>
<hr />
<pre>
444                 append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PS, asAllocatable(a), b, state));
445                 return false;
446             case DOUBLE:
447                 append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PD, asAllocatable(a), b, state));
448                 return false;
449             default:
450                 throw GraalError.shouldNotReachHere(&quot;unexpected kind: &quot; + cmpKind);
451         }
452 
453         if (isConstantValue(a)) {
454             return emitCompareMemoryConOp(size, asConstantValue(a), b, state);
455         } else {
456             return emitCompareRegMemoryOp(size, asAllocatable(a), b, state);
457         }
458     }
459 
460     protected boolean emitCompareMemoryConOp(OperandSize size, ConstantValue a, AMD64AddressValue b, LIRFrameState state) {
461         if (JavaConstant.isNull(a.getConstant())) {
462             append(new AMD64BinaryConsumer.MemoryConstOp(CMP, size, b, 0, state));
463             return true;
<span class="line-modified">464         } else if (a.getConstant() instanceof VMConstant &amp;&amp; size == DWORD) {</span>
465             VMConstant vc = (VMConstant) a.getConstant();
466             append(new AMD64BinaryConsumer.MemoryVMConstOp(CMP.getMIOpcode(size, false), b, vc, state));
467             return true;
468         } else {
<span class="line-modified">469             long value = a.getJavaConstant().asLong();</span>
<span class="line-modified">470             if (NumUtil.is32bit(value)) {</span>
<span class="line-modified">471                 append(new AMD64BinaryConsumer.MemoryConstOp(CMP, size, b, (int) value, state));</span>
<span class="line-modified">472                 return true;</span>
<span class="line-modified">473             } else {</span>
<span class="line-modified">474                 return emitCompareRegMemoryOp(size, asAllocatable(a), b, state);</span>
475             }

476         }
477     }
478 
479     private boolean emitCompareRegMemoryOp(OperandSize size, AllocatableValue a, AMD64AddressValue b, LIRFrameState state) {
480         AMD64RMOp op = CMP.getRMOpcode(size);
481         append(new AMD64BinaryConsumer.MemoryRMOp(op, size, a, b, state));
482         return false;
483     }
484 
485     /**
486      * This method emits the compare instruction, and may reorder the operands. It returns true if
487      * it did so.
488      *
489      * @param a the left operand of the comparison
490      * @param b the right operand of the comparison
491      * @param cond the condition of the comparison
492      * @return true if the left and right operands were switched, false otherwise
493      */
494     private Condition emitCompare(PlatformKind cmpKind, Value a, Value b, Condition cond) {
495         if (LIRValueUtil.isVariable(b)) {
</pre>
<hr />
<pre>
530         Variable result = newVariable(LIRKind.combine(input));
531         append(new AMD64ByteSwapOp(result, input));
532         return result;
533     }
534 
535     @Override
536     public Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
537         LIRKind resultKind = LIRKind.value(AMD64Kind.DWORD);
538         RegisterValue raxRes = AMD64.rax.asValue(resultKind);
539         RegisterValue cnt1 = AMD64.rcx.asValue(length1.getValueKind());
540         RegisterValue cnt2 = AMD64.rdx.asValue(length2.getValueKind());
541         emitMove(cnt1, length1);
542         emitMove(cnt2, length2);
543         append(new AMD64ArrayCompareToOp(this, kind1, kind2, raxRes, array1, array2, cnt1, cnt2));
544         Variable result = newVariable(resultKind);
545         emitMove(result, raxRes);
546         return result;
547     }
548 
549     @Override
<span class="line-modified">550     public Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, int constantLength, boolean directPointers) {</span>
551         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
<span class="line-modified">552         append(new AMD64ArrayEqualsOp(this, kind, kind, result, array1, array2, asAllocatable(length), constantLength, directPointers, getMaxVectorSize()));</span>
553         return result;
554     }
555 
556     @Override
<span class="line-modified">557     public Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, int constantLength, boolean directPointers) {</span>
558         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
<span class="line-modified">559         append(new AMD64ArrayEqualsOp(this, kind1, kind2, result, array1, array2, asAllocatable(length), constantLength, directPointers, getMaxVectorSize()));</span>
560         return result;
561     }
562 
<span class="line-removed">563     /**</span>
<span class="line-removed">564      * Return a conservative estimate of the page size for use by the String.indexOf intrinsic.</span>
<span class="line-removed">565      */</span>
<span class="line-removed">566     protected int getVMPageSize() {</span>
<span class="line-removed">567         return 4096;</span>
<span class="line-removed">568     }</span>
<span class="line-removed">569 </span>
570     /**
571      * Return the maximum size of vector registers used in SSE/AVX instructions.
572      */
573     protected int getMaxVectorSize() {
574         // default for &quot;unlimited&quot;
575         return -1;
576     }
577 
578     @Override
<span class="line-modified">579     public Variable emitArrayIndexOf(JavaKind kind, boolean findTwoConsecutive, Value arrayPointer, Value arrayLength, Value... searchValues) {</span>
<span class="line-modified">580         Variable result = newVariable(LIRKind.value(AMD64Kind.QWORD));</span>
<span class="line-modified">581         Value[] allocatableSearchValues = new Value[searchValues.length];</span>
<span class="line-modified">582         for (int i = 0; i &lt; searchValues.length; i++) {</span>
<span class="line-removed">583             allocatableSearchValues[i] = asAllocatable(searchValues[i]);</span>
<span class="line-removed">584         }</span>
<span class="line-removed">585         append(new AMD64ArrayIndexOfOp(kind, findTwoConsecutive, getVMPageSize(), getMaxVectorSize(), this, result, asAllocatable(arrayPointer), asAllocatable(arrayLength), allocatableSearchValues));</span>
586         return result;
587     }
588 
589     @Override
590     public void emitStringLatin1Inflate(Value src, Value dst, Value len) {
591         RegisterValue rsrc = AMD64.rsi.asValue(src.getValueKind());
592         RegisterValue rdst = AMD64.rdi.asValue(dst.getValueKind());
593         RegisterValue rlen = AMD64.rdx.asValue(len.getValueKind());
594 
595         emitMove(rsrc, src);
596         emitMove(rdst, dst);
597         emitMove(rlen, len);
598 
599         append(new AMD64StringLatin1InflateOp(this, rsrc, rdst, rlen));
600     }
601 
602     @Override
603     public Variable emitStringUTF16Compress(Value src, Value dst, Value len) {
604         RegisterValue rsrc = AMD64.rsi.asValue(src.getValueKind());
605         RegisterValue rdst = AMD64.rdi.asValue(dst.getValueKind());
</pre>
<hr />
<pre>
647 
648     @Override
649     protected Optional&lt;Hasher&gt; hasherFor(JavaConstant[] keyConstants, double minDensity) {
650         return Hasher.forKeys(keyConstants, minDensity);
651     }
652 
653     @Override
654     protected void emitHashTableSwitch(Hasher hasher, JavaConstant[] keys, LabelRef defaultTarget, LabelRef[] targets, Value value) {
655         Value index = hasher.hash(value, arithmeticLIRGen);
656         Variable scratch = newVariable(LIRKind.value(target().arch.getWordKind()));
657         Variable entryScratch = newVariable(LIRKind.value(target().arch.getWordKind()));
658         append(new HashTableSwitchOp(keys, defaultTarget, targets, value, index, scratch, entryScratch));
659     }
660 
661     @Override
662     public void emitPause() {
663         append(new AMD64PauseOp());
664     }
665 
666     @Override
<span class="line-modified">667     public SaveRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues) {</span>
668         return new AMD64ZapRegistersOp(zappedRegisters, zapValues);
669     }
670 
671     @Override
672     public LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConstant[] zapValues) {
673         return new AMD64ZapStackOp(zappedStack, zapValues);
674     }
675 
676     @Override
677     public void emitSpeculationFence() {
678         append(new AMD64LFenceOp());
679     }







680 }
</pre>
</td>
<td>
<hr />
<pre>
 30 import static jdk.vm.ci.code.ValueUtil.isRegister;
 31 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.CMP;
 32 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.DWORD;
 33 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PD;
 34 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PS;
 35 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.QWORD;
 36 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 37 import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
 38 import static org.graalvm.compiler.lir.LIRValueUtil.asConstantValue;
 39 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 40 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
 41 import static org.graalvm.compiler.lir.LIRValueUtil.isIntConstant;
 42 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 43 
 44 import java.util.Optional;
 45 
 46 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic;
 47 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
 48 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
 49 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;

 50 import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
<span class="line-added"> 51 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMOp;</span>
<span class="line-added"> 52 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;</span>
<span class="line-added"> 53 import org.graalvm.compiler.asm.amd64.AVXKind;</span>
<span class="line-added"> 54 import org.graalvm.compiler.asm.amd64.AVXKind.AVXSize;</span>
 55 import org.graalvm.compiler.core.common.LIRKind;
 56 import org.graalvm.compiler.core.common.NumUtil;
 57 import org.graalvm.compiler.core.common.calc.Condition;
 58 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 59 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 60 import org.graalvm.compiler.debug.GraalError;
 61 import org.graalvm.compiler.lir.ConstantValue;
 62 import org.graalvm.compiler.lir.LIRFrameState;
 63 import org.graalvm.compiler.lir.LIRInstruction;
 64 import org.graalvm.compiler.lir.LIRValueUtil;
 65 import org.graalvm.compiler.lir.LabelRef;
 66 import org.graalvm.compiler.lir.StandardOp.JumpOp;
<span class="line-modified"> 67 import org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;</span>
 68 import org.graalvm.compiler.lir.SwitchStrategy;
 69 import org.graalvm.compiler.lir.Variable;
 70 import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
 71 import org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool;
 72 import org.graalvm.compiler.lir.amd64.AMD64ArrayCompareToOp;
 73 import org.graalvm.compiler.lir.amd64.AMD64ArrayEqualsOp;
 74 import org.graalvm.compiler.lir.amd64.AMD64ArrayIndexOfOp;
 75 import org.graalvm.compiler.lir.amd64.AMD64Binary;
 76 import org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer;
 77 import org.graalvm.compiler.lir.amd64.AMD64ByteSwapOp;
 78 import org.graalvm.compiler.lir.amd64.AMD64Call;
 79 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow;
 80 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.BranchOp;
 81 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondMoveOp;
 82 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondSetOp;
 83 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatBranchOp;
 84 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondMoveOp;
 85 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondSetOp;
<span class="line-added"> 86 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.HashTableSwitchOp;</span>
 87 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.ReturnOp;
 88 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.StrategySwitchOp;
 89 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TableSwitchOp;

 90 import org.graalvm.compiler.lir.amd64.AMD64LFenceOp;
 91 import org.graalvm.compiler.lir.amd64.AMD64Move;
 92 import org.graalvm.compiler.lir.amd64.AMD64Move.CompareAndSwapOp;
 93 import org.graalvm.compiler.lir.amd64.AMD64Move.MembarOp;
 94 import org.graalvm.compiler.lir.amd64.AMD64Move.StackLeaOp;
 95 import org.graalvm.compiler.lir.amd64.AMD64PauseOp;
 96 import org.graalvm.compiler.lir.amd64.AMD64StringLatin1InflateOp;
 97 import org.graalvm.compiler.lir.amd64.AMD64StringUTF16CompressOp;
 98 import org.graalvm.compiler.lir.amd64.AMD64ZapRegistersOp;
 99 import org.graalvm.compiler.lir.amd64.AMD64ZapStackOp;
<span class="line-added">100 import org.graalvm.compiler.lir.amd64.AMD64ZeroMemoryOp;</span>
<span class="line-added">101 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorCompareOp;</span>
102 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
103 import org.graalvm.compiler.lir.gen.LIRGenerator;
104 import org.graalvm.compiler.lir.hashing.Hasher;
105 import org.graalvm.compiler.phases.util.Providers;
106 
107 import jdk.vm.ci.amd64.AMD64;
108 import jdk.vm.ci.amd64.AMD64Kind;
109 import jdk.vm.ci.code.CallingConvention;
110 import jdk.vm.ci.code.Register;
111 import jdk.vm.ci.code.RegisterValue;
112 import jdk.vm.ci.code.StackSlot;
113 import jdk.vm.ci.meta.AllocatableValue;
114 import jdk.vm.ci.meta.JavaConstant;
115 import jdk.vm.ci.meta.JavaKind;
116 import jdk.vm.ci.meta.PlatformKind;
117 import jdk.vm.ci.meta.VMConstant;
118 import jdk.vm.ci.meta.Value;
119 import jdk.vm.ci.meta.ValueKind;
120 
121 /**
</pre>
<hr />
<pre>
392                 }
393             } else {
394                 append(new CondSetOp(result, finalCondition.negate()));
395             }
396         } else if (isFloatComparison) {
397             append(new FloatCondMoveOp(result, finalCondition, unorderedIsTrue, load(finalTrueValue), load(finalFalseValue)));
398         } else {
399             append(new CondMoveOp(result, finalCondition, load(finalTrueValue), loadNonConst(finalFalseValue)));
400         }
401         return result;
402     }
403 
404     @Override
405     public Variable emitIntegerTestMove(Value left, Value right, Value trueValue, Value falseValue) {
406         emitIntegerTest(left, right);
407         Variable result = newVariable(trueValue.getValueKind());
408         append(new CondMoveOp(result, Condition.EQ, load(trueValue), loadNonConst(falseValue)));
409         return result;
410     }
411 
<span class="line-added">412     protected static AVXSize getRegisterSize(Value a) {</span>
<span class="line-added">413         AMD64Kind kind = (AMD64Kind) a.getPlatformKind();</span>
<span class="line-added">414         if (kind.isXMM()) {</span>
<span class="line-added">415             return AVXKind.getRegisterSize(kind);</span>
<span class="line-added">416         } else {</span>
<span class="line-added">417             return AVXSize.XMM;</span>
<span class="line-added">418         }</span>
<span class="line-added">419     }</span>
<span class="line-added">420 </span>
421     private void emitIntegerTest(Value a, Value b) {
<span class="line-modified">422         if (a.getPlatformKind().getVectorLength() &gt; 1) {</span>
<span class="line-modified">423             append(new AMD64VectorCompareOp(VexRMOp.VPTEST, getRegisterSize(a), asAllocatable(a), asAllocatable(b)));</span>






424         } else {
<span class="line-modified">425             assert ((AMD64Kind) a.getPlatformKind()).isInteger();</span>
<span class="line-added">426             OperandSize size = a.getPlatformKind() == AMD64Kind.QWORD ? QWORD : DWORD;</span>
<span class="line-added">427             if (isJavaConstant(b) &amp;&amp; NumUtil.is32bit(asJavaConstant(b).asLong())) {</span>
<span class="line-added">428                 append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(a), (int) asJavaConstant(b).asLong()));</span>
<span class="line-added">429             } else if (isJavaConstant(a) &amp;&amp; NumUtil.is32bit(asJavaConstant(a).asLong())) {</span>
<span class="line-added">430                 append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(b), (int) asJavaConstant(a).asLong()));</span>
<span class="line-added">431             } else if (isAllocatableValue(b)) {</span>
<span class="line-added">432                 append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(b), asAllocatable(a)));</span>
<span class="line-added">433             } else {</span>
<span class="line-added">434                 append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(a), asAllocatable(b)));</span>
<span class="line-added">435             }</span>
436         }
437     }
438 
439     /**
440      * This method emits the compare against memory instruction, and may reorder the operands. It
441      * returns true if it did so.
442      *
443      * @param b the right operand of the comparison
444      * @return true if the left and right operands were switched, false otherwise
445      */
446     private boolean emitCompareMemory(AMD64Kind cmpKind, Value a, AMD64AddressValue b, LIRFrameState state) {
447         OperandSize size;
448         switch (cmpKind) {
449             case BYTE:
450                 size = OperandSize.BYTE;
451                 break;
452             case WORD:
453                 size = OperandSize.WORD;
454                 break;
455             case DWORD:
</pre>
<hr />
<pre>
462                 append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PS, asAllocatable(a), b, state));
463                 return false;
464             case DOUBLE:
465                 append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PD, asAllocatable(a), b, state));
466                 return false;
467             default:
468                 throw GraalError.shouldNotReachHere(&quot;unexpected kind: &quot; + cmpKind);
469         }
470 
471         if (isConstantValue(a)) {
472             return emitCompareMemoryConOp(size, asConstantValue(a), b, state);
473         } else {
474             return emitCompareRegMemoryOp(size, asAllocatable(a), b, state);
475         }
476     }
477 
478     protected boolean emitCompareMemoryConOp(OperandSize size, ConstantValue a, AMD64AddressValue b, LIRFrameState state) {
479         if (JavaConstant.isNull(a.getConstant())) {
480             append(new AMD64BinaryConsumer.MemoryConstOp(CMP, size, b, 0, state));
481             return true;
<span class="line-modified">482         } else if (a.getConstant() instanceof VMConstant &amp;&amp; size == DWORD &amp;&amp; target().inlineObjects) {</span>
483             VMConstant vc = (VMConstant) a.getConstant();
484             append(new AMD64BinaryConsumer.MemoryVMConstOp(CMP.getMIOpcode(size, false), b, vc, state));
485             return true;
486         } else {
<span class="line-modified">487             if (a.getConstant() instanceof JavaConstant &amp;&amp; a.getJavaConstant().getJavaKind() != JavaKind.Object) {</span>
<span class="line-modified">488                 long value = a.getJavaConstant().asLong();</span>
<span class="line-modified">489                 if (NumUtil.is32bit(value)) {</span>
<span class="line-modified">490                     append(new AMD64BinaryConsumer.MemoryConstOp(CMP, size, b, (int) value, state));</span>
<span class="line-modified">491                     return true;</span>
<span class="line-modified">492                 }</span>
493             }
<span class="line-added">494             return emitCompareRegMemoryOp(size, asAllocatable(a), b, state);</span>
495         }
496     }
497 
498     private boolean emitCompareRegMemoryOp(OperandSize size, AllocatableValue a, AMD64AddressValue b, LIRFrameState state) {
499         AMD64RMOp op = CMP.getRMOpcode(size);
500         append(new AMD64BinaryConsumer.MemoryRMOp(op, size, a, b, state));
501         return false;
502     }
503 
504     /**
505      * This method emits the compare instruction, and may reorder the operands. It returns true if
506      * it did so.
507      *
508      * @param a the left operand of the comparison
509      * @param b the right operand of the comparison
510      * @param cond the condition of the comparison
511      * @return true if the left and right operands were switched, false otherwise
512      */
513     private Condition emitCompare(PlatformKind cmpKind, Value a, Value b, Condition cond) {
514         if (LIRValueUtil.isVariable(b)) {
</pre>
<hr />
<pre>
549         Variable result = newVariable(LIRKind.combine(input));
550         append(new AMD64ByteSwapOp(result, input));
551         return result;
552     }
553 
554     @Override
555     public Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
556         LIRKind resultKind = LIRKind.value(AMD64Kind.DWORD);
557         RegisterValue raxRes = AMD64.rax.asValue(resultKind);
558         RegisterValue cnt1 = AMD64.rcx.asValue(length1.getValueKind());
559         RegisterValue cnt2 = AMD64.rdx.asValue(length2.getValueKind());
560         emitMove(cnt1, length1);
561         emitMove(cnt2, length2);
562         append(new AMD64ArrayCompareToOp(this, kind1, kind2, raxRes, array1, array2, cnt1, cnt2));
563         Variable result = newVariable(resultKind);
564         emitMove(result, raxRes);
565         return result;
566     }
567 
568     @Override
<span class="line-modified">569     public Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, boolean directPointers) {</span>
570         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
<span class="line-modified">571         append(new AMD64ArrayEqualsOp(this, kind, kind, result, array1, array2, length, directPointers, getMaxVectorSize()));</span>
572         return result;
573     }
574 
575     @Override
<span class="line-modified">576     public Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, boolean directPointers) {</span>
577         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
<span class="line-modified">578         append(new AMD64ArrayEqualsOp(this, kind1, kind2, result, array1, array2, length, directPointers, getMaxVectorSize()));</span>
579         return result;
580     }
581 







582     /**
583      * Return the maximum size of vector registers used in SSE/AVX instructions.
584      */
585     protected int getMaxVectorSize() {
586         // default for &quot;unlimited&quot;
587         return -1;
588     }
589 
590     @Override
<span class="line-modified">591     public Variable emitArrayIndexOf(JavaKind arrayKind, JavaKind valueKind, boolean findTwoConsecutive, Value arrayPointer, Value arrayLength, Value fromIndex, Value... searchValues) {</span>
<span class="line-modified">592         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-modified">593         append(new AMD64ArrayIndexOfOp(arrayKind, valueKind, findTwoConsecutive, getMaxVectorSize(), this, result,</span>
<span class="line-modified">594                         asAllocatable(arrayPointer), asAllocatable(arrayLength), asAllocatable(fromIndex), searchValues));</span>



595         return result;
596     }
597 
598     @Override
599     public void emitStringLatin1Inflate(Value src, Value dst, Value len) {
600         RegisterValue rsrc = AMD64.rsi.asValue(src.getValueKind());
601         RegisterValue rdst = AMD64.rdi.asValue(dst.getValueKind());
602         RegisterValue rlen = AMD64.rdx.asValue(len.getValueKind());
603 
604         emitMove(rsrc, src);
605         emitMove(rdst, dst);
606         emitMove(rlen, len);
607 
608         append(new AMD64StringLatin1InflateOp(this, rsrc, rdst, rlen));
609     }
610 
611     @Override
612     public Variable emitStringUTF16Compress(Value src, Value dst, Value len) {
613         RegisterValue rsrc = AMD64.rsi.asValue(src.getValueKind());
614         RegisterValue rdst = AMD64.rdi.asValue(dst.getValueKind());
</pre>
<hr />
<pre>
656 
657     @Override
658     protected Optional&lt;Hasher&gt; hasherFor(JavaConstant[] keyConstants, double minDensity) {
659         return Hasher.forKeys(keyConstants, minDensity);
660     }
661 
662     @Override
663     protected void emitHashTableSwitch(Hasher hasher, JavaConstant[] keys, LabelRef defaultTarget, LabelRef[] targets, Value value) {
664         Value index = hasher.hash(value, arithmeticLIRGen);
665         Variable scratch = newVariable(LIRKind.value(target().arch.getWordKind()));
666         Variable entryScratch = newVariable(LIRKind.value(target().arch.getWordKind()));
667         append(new HashTableSwitchOp(keys, defaultTarget, targets, value, index, scratch, entryScratch));
668     }
669 
670     @Override
671     public void emitPause() {
672         append(new AMD64PauseOp());
673     }
674 
675     @Override
<span class="line-modified">676     public ZapRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues) {</span>
677         return new AMD64ZapRegistersOp(zappedRegisters, zapValues);
678     }
679 
680     @Override
681     public LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConstant[] zapValues) {
682         return new AMD64ZapStackOp(zappedStack, zapValues);
683     }
684 
685     @Override
686     public void emitSpeculationFence() {
687         append(new AMD64LFenceOp());
688     }
<span class="line-added">689 </span>
<span class="line-added">690     @Override</span>
<span class="line-added">691     public void emitZeroMemory(Value address, Value length, boolean isAligned) {</span>
<span class="line-added">692         RegisterValue lengthReg = AMD64.rcx.asValue(length.getValueKind());</span>
<span class="line-added">693         emitMove(lengthReg, length);</span>
<span class="line-added">694         append(new AMD64ZeroMemoryOp(asAddressValue(address), lengthReg));</span>
<span class="line-added">695     }</span>
696 }
</pre>
</td>
</tr>
</table>
<center><a href="AMD64ArithmeticLIRGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64MoveFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64AddressNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.core.amd64.test/src/org/graalvm/compiler/core/amd64/test/StackStoreTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ArithmeticLIRGenerator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64AddressNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 46 
 47 import jdk.vm.ci.meta.AllocatableValue;
 48 import jdk.vm.ci.meta.Value;
 49 
 50 /**
 51  * Represents an address of the form [base + index*scale + displacement]. Both base and index are
 52  * optional.
 53  */
 54 @NodeInfo
 55 public class AMD64AddressNode extends AddressNode implements Simplifiable, LIRLowerable {
 56 
 57     public static final NodeClass&lt;AMD64AddressNode&gt; TYPE = NodeClass.create(AMD64AddressNode.class);
 58 
 59     @OptionalInput private ValueNode base;
 60 
 61     @OptionalInput private ValueNode index;
 62     private Scale scale;
 63 
 64     private int displacement;
 65 








 66     public AMD64AddressNode(ValueNode base) {
 67         this(base, null);
 68     }
 69 
 70     public AMD64AddressNode(ValueNode base, ValueNode index) {
 71         super(TYPE);
 72         this.base = base;
 73         this.index = index;
 74         this.scale = Scale.Times1;

 75     }
 76 
 77     public void canonicalizeIndex(SimplifierTool tool) {
 78         if (index instanceof AddNode &amp;&amp; ((IntegerStamp) index.stamp(NodeView.DEFAULT)).getBits() == 64) {
 79             AddNode add = (AddNode) index;
 80             ValueNode valX = add.getX();
 81             if (valX instanceof PhiNode) {
 82                 PhiNode phi = (PhiNode) valX;
 83                 if (phi.merge() instanceof LoopBeginNode) {
 84                     LoopBeginNode loopNode = (LoopBeginNode) phi.merge();
 85                     if (!loopNode.isSimpleLoop()) {
 86                         ValueNode valY = add.getY();
 87                         if (valY instanceof ConstantNode) {
 88                             int addBy = valY.asJavaConstant().asInt();
 89                             displacement = displacement + scale.value * addBy;
 90                             replaceFirstInput(index, phi);
 91                             tool.addToWorkList(index);
 92                         }
 93                     }
 94                 }
 95             }
 96         }
 97     }
 98 
 99     @Override
100     public void generate(NodeLIRBuilderTool gen) {
101         LIRGeneratorTool tool = gen.getLIRGeneratorTool();
102 
103         AllocatableValue baseValue = base == null ? Value.ILLEGAL : tool.asAllocatable(gen.operand(base));
104         AllocatableValue indexValue = index == null ? Value.ILLEGAL : tool.asAllocatable(gen.operand(index));
105 
<span class="line-modified">106         AllocatableValue baseReference = LIRKind.derivedBaseFromValue(baseValue);</span>
107         AllocatableValue indexReference;
108         if (index == null) {
109             indexReference = null;
110         } else if (scale.equals(Scale.Times1)) {
111             indexReference = LIRKind.derivedBaseFromValue(indexValue);


112         } else {
113             if (LIRKind.isValue(indexValue)) {
114                 indexReference = null;
115             } else {
116                 indexReference = Value.ILLEGAL;
117             }
118         }
119 
120         LIRKind kind = LIRKind.combineDerived(tool.getLIRKind(stamp(NodeView.DEFAULT)), baseReference, indexReference);
121         gen.setResult(this, new AMD64AddressValue(kind, baseValue, indexValue, scale, displacement));
122     }
123 
124     @Override
125     public ValueNode getBase() {
126         return base;
127     }
128 
129     public void setBase(ValueNode base) {
130         // allow modification before inserting into the graph
131         if (isAlive()) {
</pre>
<hr />
<pre>
146         }
147         this.index = index;
148     }
149 
150     public Scale getScale() {
151         return scale;
152     }
153 
154     public void setScale(Scale scale) {
155         this.scale = scale;
156     }
157 
158     public int getDisplacement() {
159         return displacement;
160     }
161 
162     public void setDisplacement(int displacement) {
163         this.displacement = displacement;
164     }
165 




166     @Override
167     public long getMaxConstantDisplacement() {
168         return displacement;
169     }
170 
171     @Override
172     public void simplify(SimplifierTool tool) {
173         canonicalizeIndex(tool);
174     }
175 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 46 
 47 import jdk.vm.ci.meta.AllocatableValue;
 48 import jdk.vm.ci.meta.Value;
 49 
 50 /**
 51  * Represents an address of the form [base + index*scale + displacement]. Both base and index are
 52  * optional.
 53  */
 54 @NodeInfo
 55 public class AMD64AddressNode extends AddressNode implements Simplifiable, LIRLowerable {
 56 
 57     public static final NodeClass&lt;AMD64AddressNode&gt; TYPE = NodeClass.create(AMD64AddressNode.class);
 58 
 59     @OptionalInput private ValueNode base;
 60 
 61     @OptionalInput private ValueNode index;
 62     private Scale scale;
 63 
 64     private int displacement;
 65 
<span class="line-added"> 66     /*</span>
<span class="line-added"> 67      * If this address has been improved by folding an uncompress operation into it, this is set by</span>
<span class="line-added"> 68      * the address lowering to the uncompression scale used by the encoding strategy. It is null</span>
<span class="line-added"> 69      * otherwise. This might be different from scale if we lowered an uncompression followed by</span>
<span class="line-added"> 70      * further improvements that modify the scale.</span>
<span class="line-added"> 71      */</span>
<span class="line-added"> 72     private Scale uncompressionScale;</span>
<span class="line-added"> 73 </span>
 74     public AMD64AddressNode(ValueNode base) {
 75         this(base, null);
 76     }
 77 
 78     public AMD64AddressNode(ValueNode base, ValueNode index) {
 79         super(TYPE);
 80         this.base = base;
 81         this.index = index;
 82         this.scale = Scale.Times1;
<span class="line-added"> 83         this.uncompressionScale = null;</span>
 84     }
 85 
 86     public void canonicalizeIndex(SimplifierTool tool) {
 87         if (index instanceof AddNode &amp;&amp; ((IntegerStamp) index.stamp(NodeView.DEFAULT)).getBits() == 64) {
 88             AddNode add = (AddNode) index;
 89             ValueNode valX = add.getX();
 90             if (valX instanceof PhiNode) {
 91                 PhiNode phi = (PhiNode) valX;
 92                 if (phi.merge() instanceof LoopBeginNode) {
 93                     LoopBeginNode loopNode = (LoopBeginNode) phi.merge();
 94                     if (!loopNode.isSimpleLoop()) {
 95                         ValueNode valY = add.getY();
 96                         if (valY instanceof ConstantNode) {
 97                             int addBy = valY.asJavaConstant().asInt();
 98                             displacement = displacement + scale.value * addBy;
 99                             replaceFirstInput(index, phi);
100                             tool.addToWorkList(index);
101                         }
102                     }
103                 }
104             }
105         }
106     }
107 
108     @Override
109     public void generate(NodeLIRBuilderTool gen) {
110         LIRGeneratorTool tool = gen.getLIRGeneratorTool();
111 
112         AllocatableValue baseValue = base == null ? Value.ILLEGAL : tool.asAllocatable(gen.operand(base));
113         AllocatableValue indexValue = index == null ? Value.ILLEGAL : tool.asAllocatable(gen.operand(index));
114 
<span class="line-modified">115         AllocatableValue baseReference = base == null ? null : LIRKind.derivedBaseFromValue(baseValue);</span>
116         AllocatableValue indexReference;
117         if (index == null) {
118             indexReference = null;
119         } else if (scale.equals(Scale.Times1)) {
120             indexReference = LIRKind.derivedBaseFromValue(indexValue);
<span class="line-added">121         } else if (scale.equals(uncompressionScale) &amp;&amp; LIRKind.isScalarCompressedReference(indexValue.getValueKind())) {</span>
<span class="line-added">122             indexReference = LIRKind.derivedBaseFromValue(indexValue);</span>
123         } else {
124             if (LIRKind.isValue(indexValue)) {
125                 indexReference = null;
126             } else {
127                 indexReference = Value.ILLEGAL;
128             }
129         }
130 
131         LIRKind kind = LIRKind.combineDerived(tool.getLIRKind(stamp(NodeView.DEFAULT)), baseReference, indexReference);
132         gen.setResult(this, new AMD64AddressValue(kind, baseValue, indexValue, scale, displacement));
133     }
134 
135     @Override
136     public ValueNode getBase() {
137         return base;
138     }
139 
140     public void setBase(ValueNode base) {
141         // allow modification before inserting into the graph
142         if (isAlive()) {
</pre>
<hr />
<pre>
157         }
158         this.index = index;
159     }
160 
161     public Scale getScale() {
162         return scale;
163     }
164 
165     public void setScale(Scale scale) {
166         this.scale = scale;
167     }
168 
169     public int getDisplacement() {
170         return displacement;
171     }
172 
173     public void setDisplacement(int displacement) {
174         this.displacement = displacement;
175     }
176 
<span class="line-added">177     public void setUncompressionScale(Scale scale) {</span>
<span class="line-added">178         this.uncompressionScale = scale;</span>
<span class="line-added">179     }</span>
<span class="line-added">180 </span>
181     @Override
182     public long getMaxConstantDisplacement() {
183         return displacement;
184     }
185 
186     @Override
187     public void simplify(SimplifierTool tool) {
188         canonicalizeIndex(tool);
189     }
190 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../org.graalvm.compiler.core.amd64.test/src/org/graalvm/compiler/core/amd64/test/StackStoreTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ArithmeticLIRGenerator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
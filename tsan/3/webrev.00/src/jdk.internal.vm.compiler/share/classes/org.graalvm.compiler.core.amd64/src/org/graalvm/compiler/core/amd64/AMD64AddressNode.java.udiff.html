<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64AddressNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.core.amd64.test/src/org/graalvm/compiler/core/amd64/test/StackStoreTest.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ArithmeticLIRGenerator.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64AddressNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61,19 +61,28 @@</span>
      @OptionalInput private ValueNode index;
      private Scale scale;
  
      private int displacement;
  
<span class="udiff-line-added">+     /*</span>
<span class="udiff-line-added">+      * If this address has been improved by folding an uncompress operation into it, this is set by</span>
<span class="udiff-line-added">+      * the address lowering to the uncompression scale used by the encoding strategy. It is null</span>
<span class="udiff-line-added">+      * otherwise. This might be different from scale if we lowered an uncompression followed by</span>
<span class="udiff-line-added">+      * further improvements that modify the scale.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private Scale uncompressionScale;</span>
<span class="udiff-line-added">+ </span>
      public AMD64AddressNode(ValueNode base) {
          this(base, null);
      }
  
      public AMD64AddressNode(ValueNode base, ValueNode index) {
          super(TYPE);
          this.base = base;
          this.index = index;
          this.scale = Scale.Times1;
<span class="udiff-line-added">+         this.uncompressionScale = null;</span>
      }
  
      public void canonicalizeIndex(SimplifierTool tool) {
          if (index instanceof AddNode &amp;&amp; ((IntegerStamp) index.stamp(NodeView.DEFAULT)).getBits() == 64) {
              AddNode add = (AddNode) index;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -101,16 +110,18 @@</span>
          LIRGeneratorTool tool = gen.getLIRGeneratorTool();
  
          AllocatableValue baseValue = base == null ? Value.ILLEGAL : tool.asAllocatable(gen.operand(base));
          AllocatableValue indexValue = index == null ? Value.ILLEGAL : tool.asAllocatable(gen.operand(index));
  
<span class="udiff-line-modified-removed">-         AllocatableValue baseReference = LIRKind.derivedBaseFromValue(baseValue);</span>
<span class="udiff-line-modified-added">+         AllocatableValue baseReference = base == null ? null : LIRKind.derivedBaseFromValue(baseValue);</span>
          AllocatableValue indexReference;
          if (index == null) {
              indexReference = null;
          } else if (scale.equals(Scale.Times1)) {
              indexReference = LIRKind.derivedBaseFromValue(indexValue);
<span class="udiff-line-added">+         } else if (scale.equals(uncompressionScale) &amp;&amp; LIRKind.isScalarCompressedReference(indexValue.getValueKind())) {</span>
<span class="udiff-line-added">+             indexReference = LIRKind.derivedBaseFromValue(indexValue);</span>
          } else {
              if (LIRKind.isValue(indexValue)) {
                  indexReference = null;
              } else {
                  indexReference = Value.ILLEGAL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -161,10 +172,14 @@</span>
  
      public void setDisplacement(int displacement) {
          this.displacement = displacement;
      }
  
<span class="udiff-line-added">+     public void setUncompressionScale(Scale scale) {</span>
<span class="udiff-line-added">+         this.uncompressionScale = scale;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @Override
      public long getMaxConstantDisplacement() {
          return displacement;
      }
  
</pre>
<center><a href="../../../../../../../org.graalvm.compiler.core.amd64.test/src/org/graalvm/compiler/core/amd64/test/StackStoreTest.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ArithmeticLIRGenerator.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64NodeMatchRules.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64MoveFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/Fields.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64NodeMatchRules.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package org.graalvm.compiler.core.amd64;
 27 
 28 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.ADD;
 29 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.AND;
 30 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.OR;
 31 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.SUB;
 32 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.XOR;
 33 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSX;
 34 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSXB;
 35 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSXD;






 36 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.DWORD;
 37 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.QWORD;
 38 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.SD;
 39 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.SS;
 40 

 41 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
 42 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
 43 import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
 44 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;
 45 import org.graalvm.compiler.core.common.LIRKind;
 46 import org.graalvm.compiler.core.common.NumUtil;
 47 import org.graalvm.compiler.core.common.calc.CanonicalCondition;
 48 import org.graalvm.compiler.core.common.calc.Condition;
 49 import org.graalvm.compiler.core.gen.NodeLIRBuilder;
 50 import org.graalvm.compiler.core.gen.NodeMatchRules;
 51 import org.graalvm.compiler.core.match.ComplexMatchResult;
 52 import org.graalvm.compiler.core.match.MatchRule;
 53 import org.graalvm.compiler.debug.GraalError;
 54 import org.graalvm.compiler.lir.LIRFrameState;
 55 import org.graalvm.compiler.lir.LIRValueUtil;
 56 import org.graalvm.compiler.lir.LabelRef;
 57 import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
 58 import org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer;
 59 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.BranchOp;
 60 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
</pre>
<hr />
<pre>
335 
336         JavaConstant bCst = b.asJavaConstant();
337         long bValue;
338         if (bCst.getJavaKind() == JavaKind.Int) {
339             bValue = bCst.asInt();
340         } else if (bCst.getJavaKind() == JavaKind.Long) {
341             bValue = bCst.asLong();
342         } else {
343             return null;
344         }
345 
346         if (bValue == -1) {
347             return builder -&gt; getArithmeticLIRGenerator().emitResetLowestSetBit(operand(a));
348         } else {
349             return null;
350         }
351     }
352 
353     @MatchRule(&quot;(If (IntegerTest Read=access value))&quot;)
354     @MatchRule(&quot;(If (IntegerTest FloatingRead=access value))&quot;)

355     public ComplexMatchResult integerTestBranchMemory(IfNode root, LIRLowerableAccess access, ValueNode value) {
356         return emitIntegerTestBranchMemory(root, value, access);
357     }
358 
359     @MatchRule(&quot;(If (IntegerEquals=compare value Read=access))&quot;)
360     @MatchRule(&quot;(If (IntegerLessThan=compare value Read=access))&quot;)
361     @MatchRule(&quot;(If (IntegerBelow=compare value Read=access))&quot;)
362     @MatchRule(&quot;(If (IntegerEquals=compare value FloatingRead=access))&quot;)
363     @MatchRule(&quot;(If (IntegerLessThan=compare value FloatingRead=access))&quot;)
364     @MatchRule(&quot;(If (IntegerBelow=compare value FloatingRead=access))&quot;)



365     @MatchRule(&quot;(If (FloatEquals=compare value Read=access))&quot;)
366     @MatchRule(&quot;(If (FloatEquals=compare value FloatingRead=access))&quot;)

367     @MatchRule(&quot;(If (FloatLessThan=compare value Read=access))&quot;)
368     @MatchRule(&quot;(If (FloatLessThan=compare value FloatingRead=access))&quot;)

369     @MatchRule(&quot;(If (PointerEquals=compare value Read=access))&quot;)
370     @MatchRule(&quot;(If (PointerEquals=compare value FloatingRead=access))&quot;)

371     @MatchRule(&quot;(If (ObjectEquals=compare value Read=access))&quot;)
372     @MatchRule(&quot;(If (ObjectEquals=compare value FloatingRead=access))&quot;)

373     public ComplexMatchResult ifCompareMemory(IfNode root, CompareNode compare, ValueNode value, LIRLowerableAccess access) {
374         return emitCompareBranchMemory(root, compare, value, access);
375     }
376 
377     @MatchRule(&quot;(If (ObjectEquals=compare value ValueCompareAndSwap=cas))&quot;)
378     @MatchRule(&quot;(If (PointerEquals=compare value ValueCompareAndSwap=cas))&quot;)
379     @MatchRule(&quot;(If (FloatEquals=compare value ValueCompareAndSwap=cas))&quot;)
380     @MatchRule(&quot;(If (IntegerEquals=compare value ValueCompareAndSwap=cas))&quot;)
381     public ComplexMatchResult ifCompareValueCas(IfNode root, CompareNode compare, ValueNode value, ValueCompareAndSwapNode cas) {
382         assert compare.condition() == CanonicalCondition.EQ;
<span class="line-modified">383         if (value == cas.getExpectedValue() &amp;&amp; cas.usages().count() == 1) {</span>
384             return builder -&gt; {
385                 LIRKind kind = getLirKind(cas);
386                 LabelRef trueLabel = getLIRBlock(root.trueSuccessor());
387                 LabelRef falseLabel = getLIRBlock(root.falseSuccessor());
388                 double trueLabelProbability = root.probability(root.trueSuccessor());
389                 Value expectedValue = operand(cas.getExpectedValue());
390                 Value newValue = operand(cas.getNewValue());
391                 AMD64AddressValue address = (AMD64AddressValue) operand(cas.getAddress());
392                 getLIRGeneratorTool().emitCompareAndSwapBranch(kind, address, expectedValue, newValue, Condition.EQ, trueLabel, falseLabel, trueLabelProbability);
393                 return null;
394             };
395         }
396         return null;
397     }
398 
399     @MatchRule(&quot;(If (ObjectEquals=compare value LogicCompareAndSwap=cas))&quot;)
400     @MatchRule(&quot;(If (PointerEquals=compare value LogicCompareAndSwap=cas))&quot;)
401     @MatchRule(&quot;(If (FloatEquals=compare value LogicCompareAndSwap=cas))&quot;)
402     @MatchRule(&quot;(If (IntegerEquals=compare value LogicCompareAndSwap=cas))&quot;)
403     public ComplexMatchResult ifCompareLogicCas(IfNode root, CompareNode compare, ValueNode value, LogicCompareAndSwapNode cas) {
404         JavaConstant constant = value.asJavaConstant();
405         assert compare.condition() == CanonicalCondition.EQ;
<span class="line-modified">406         if (constant != null &amp;&amp; cas.usages().count() == 1) {</span>
407             long constantValue = constant.asLong();
408             boolean successIsTrue;
409             if (constantValue == 0) {
410                 successIsTrue = false;
411             } else if (constantValue == 1) {
412                 successIsTrue = true;
413             } else {
414                 return null;
415             }
416             return builder -&gt; {
417                 LIRKind kind = getLirKind(cas);
418                 LabelRef trueLabel = getLIRBlock(root.trueSuccessor());
419                 LabelRef falseLabel = getLIRBlock(root.falseSuccessor());
420                 double trueLabelProbability = root.probability(root.trueSuccessor());
421                 Value expectedValue = operand(cas.getExpectedValue());
422                 Value newValue = operand(cas.getNewValue());
423                 AMD64AddressValue address = (AMD64AddressValue) operand(cas.getAddress());
424                 Condition condition = successIsTrue ? Condition.EQ : Condition.NE;
425                 getLIRGeneratorTool().emitCompareAndSwapBranch(kind, address, expectedValue, newValue, condition, trueLabel, falseLabel, trueLabelProbability);
426                 return null;
</pre>
<hr />
<pre>
446     public ComplexMatchResult rotateRightVariable(ValueNode value, ConstantNode delta, ValueNode shiftAmount) {
447         if (delta.asJavaConstant().asLong() == 0 || delta.asJavaConstant().asLong() == 32) {
448             return builder -&gt; getArithmeticLIRGenerator().emitRor(operand(value), operand(shiftAmount));
449         }
450         return null;
451     }
452 
453     @MatchRule(&quot;(Or (LeftShift value shiftAmount) (UnsignedRightShift value (Sub Constant=delta shiftAmount)))&quot;)
454     public ComplexMatchResult rotateLeftVariable(ValueNode value, ValueNode shiftAmount, ConstantNode delta) {
455         if (delta.asJavaConstant().asLong() == 0 || delta.asJavaConstant().asLong() == 32) {
456             return builder -&gt; getArithmeticLIRGenerator().emitRol(operand(value), operand(shiftAmount));
457         }
458         return null;
459     }
460 
461     private ComplexMatchResult binaryRead(AMD64RMOp op, OperandSize size, ValueNode value, LIRLowerableAccess access) {
462         return builder -&gt; getArithmeticLIRGenerator().emitBinaryMemory(op, size, getLIRGeneratorTool().asAllocatable(operand(value)), (AMD64AddressValue) operand(access.getAddress()),
463                         getState(access));
464     }
465 






466     @MatchRule(&quot;(Add value Read=access)&quot;)
467     @MatchRule(&quot;(Add value FloatingRead=access)&quot;)

468     public ComplexMatchResult addMemory(ValueNode value, LIRLowerableAccess access) {
469         OperandSize size = getMemorySize(access);
470         if (size.isXmmType()) {
<span class="line-modified">471             return binaryRead(SSEOp.ADD, size, value, access);</span>




472         } else {
473             return binaryRead(ADD.getRMOpcode(size), size, value, access);
474         }
475     }
476 
477     @MatchRule(&quot;(Sub value Read=access)&quot;)
478     @MatchRule(&quot;(Sub value FloatingRead=access)&quot;)

479     public ComplexMatchResult subMemory(ValueNode value, LIRLowerableAccess access) {
480         OperandSize size = getMemorySize(access);
481         if (size.isXmmType()) {
<span class="line-modified">482             return binaryRead(SSEOp.SUB, size, value, access);</span>




483         } else {
484             return binaryRead(SUB.getRMOpcode(size), size, value, access);
485         }
486     }
487 
488     @MatchRule(&quot;(Mul value Read=access)&quot;)
489     @MatchRule(&quot;(Mul value FloatingRead=access)&quot;)

490     public ComplexMatchResult mulMemory(ValueNode value, LIRLowerableAccess access) {
491         OperandSize size = getMemorySize(access);
492         if (size.isXmmType()) {
<span class="line-modified">493             return binaryRead(SSEOp.MUL, size, value, access);</span>




494         } else {
495             return binaryRead(AMD64RMOp.IMUL, size, value, access);
496         }
497     }
498 
499     @MatchRule(&quot;(And value Read=access)&quot;)
500     @MatchRule(&quot;(And value FloatingRead=access)&quot;)

501     public ComplexMatchResult andMemory(ValueNode value, LIRLowerableAccess access) {
502         OperandSize size = getMemorySize(access);
503         if (size.isXmmType()) {
504             return null;
505         } else {
506             return binaryRead(AND.getRMOpcode(size), size, value, access);
507         }
508     }
509 
510     @MatchRule(&quot;(Or value Read=access)&quot;)
511     @MatchRule(&quot;(Or value FloatingRead=access)&quot;)

512     public ComplexMatchResult orMemory(ValueNode value, LIRLowerableAccess access) {
513         OperandSize size = getMemorySize(access);
514         if (size.isXmmType()) {
515             return null;
516         } else {
517             return binaryRead(OR.getRMOpcode(size), size, value, access);
518         }
519     }
520 
521     @MatchRule(&quot;(Xor value Read=access)&quot;)
522     @MatchRule(&quot;(Xor value FloatingRead=access)&quot;)

523     public ComplexMatchResult xorMemory(ValueNode value, LIRLowerableAccess access) {
524         OperandSize size = getMemorySize(access);
525         if (size.isXmmType()) {
526             return null;
527         } else {
528             return binaryRead(XOR.getRMOpcode(size), size, value, access);
529         }
530     }
531 
532     @MatchRule(&quot;(Write object Narrow=narrow)&quot;)
533     public ComplexMatchResult writeNarrow(WriteNode root, NarrowNode narrow) {
534         return builder -&gt; {
535             LIRKind writeKind = getLIRGeneratorTool().getLIRKind(root.value().stamp(NodeView.DEFAULT));
536             getArithmeticLIRGenerator().emitStore(writeKind, operand(root.getAddress()), operand(narrow.getValue()), state(root));
537             return null;
538         };
539     }
540 
541     @MatchRule(&quot;(SignExtend Read=access)&quot;)
542     @MatchRule(&quot;(SignExtend FloatingRead=access)&quot;)

543     public ComplexMatchResult signExtend(SignExtendNode root, LIRLowerableAccess access) {
544         return emitSignExtendMemory(access, root.getInputBits(), root.getResultBits(), null);
545     }
546 
547     @MatchRule(&quot;(ZeroExtend Read=access)&quot;)
548     @MatchRule(&quot;(ZeroExtend FloatingRead=access)&quot;)

549     public ComplexMatchResult zeroExtend(ZeroExtendNode root, LIRLowerableAccess access) {
550         AMD64Kind memoryKind = getMemoryKind(access);
551         return builder -&gt; getArithmeticLIRGenerator().emitZeroExtendMemory(memoryKind, root.getResultBits(), (AMD64AddressValue) operand(access.getAddress()), getState(access));
552     }
553 
554     @MatchRule(&quot;(Narrow Read=access)&quot;)
555     @MatchRule(&quot;(Narrow FloatingRead=access)&quot;)

556     public ComplexMatchResult narrowRead(NarrowNode root, LIRLowerableAccess access) {
557         return new ComplexMatchResult() {
558             @Override
559             public Value evaluate(NodeLIRBuilder builder) {
560                 AMD64AddressValue address = (AMD64AddressValue) operand(access.getAddress());
561                 LIRKind addressKind = LIRKind.combineDerived(getLIRGeneratorTool().getLIRKind(root.asNode().stamp(NodeView.DEFAULT)),
562                                 address.getBase(), address.getIndex());
563                 AMD64AddressValue newAddress = address.withKind(addressKind);
564                 LIRKind readKind = getLIRGeneratorTool().getLIRKind(root.stamp(NodeView.DEFAULT));
565                 return getArithmeticLIRGenerator().emitZeroExtendMemory((AMD64Kind) readKind.getPlatformKind(),
566                                 root.getResultBits(), newAddress, getState(access));
567             }
568         };
569     }
570 
571     @MatchRule(&quot;(SignExtend (Narrow=narrow Read=access))&quot;)
572     @MatchRule(&quot;(SignExtend (Narrow=narrow FloatingRead=access))&quot;)

573     public ComplexMatchResult signExtendNarrowRead(SignExtendNode root, NarrowNode narrow, LIRLowerableAccess access) {
574         LIRKind kind = getLIRGeneratorTool().getLIRKind(narrow.stamp(NodeView.DEFAULT));
575         return emitSignExtendMemory(access, narrow.getResultBits(), root.getResultBits(), kind);
576     }
577 
578     @MatchRule(&quot;(FloatConvert Read=access)&quot;)
579     @MatchRule(&quot;(FloatConvert FloatingRead=access)&quot;)

580     public ComplexMatchResult floatConvert(FloatConvertNode root, LIRLowerableAccess access) {
581         switch (root.getFloatConvert()) {
582             case D2F:
583                 return emitConvertMemoryOp(AMD64Kind.SINGLE, SSEOp.CVTSD2SS, SD, access);
584             case D2I:
585                 return emitConvertMemoryOp(AMD64Kind.DWORD, SSEOp.CVTTSD2SI, DWORD, access);
586             case D2L:
587                 return emitConvertMemoryOp(AMD64Kind.QWORD, SSEOp.CVTTSD2SI, QWORD, access);
588             case F2D:
589                 return emitConvertMemoryOp(AMD64Kind.DOUBLE, SSEOp.CVTSS2SD, SS, access);
590             case F2I:
591                 return emitConvertMemoryOp(AMD64Kind.DWORD, SSEOp.CVTTSS2SI, DWORD, access);
592             case F2L:
593                 return emitConvertMemoryOp(AMD64Kind.QWORD, SSEOp.CVTTSS2SI, QWORD, access);
594             case I2D:
595                 return emitConvertMemoryOp(AMD64Kind.DOUBLE, SSEOp.CVTSI2SD, DWORD, access);
596             case I2F:
597                 return emitConvertMemoryOp(AMD64Kind.SINGLE, SSEOp.CVTSI2SS, DWORD, access);
598             case L2D:
599                 return emitConvertMemoryOp(AMD64Kind.DOUBLE, SSEOp.CVTSI2SD, QWORD, access);
600             case L2F:
601                 return emitConvertMemoryOp(AMD64Kind.SINGLE, SSEOp.CVTSI2SS, QWORD, access);
602             default:
603                 throw GraalError.shouldNotReachHere();
604         }
605     }
606 
607     @MatchRule(&quot;(Reinterpret Read=access)&quot;)
608     @MatchRule(&quot;(Reinterpret FloatingRead=access)&quot;)

609     public ComplexMatchResult reinterpret(ReinterpretNode root, LIRLowerableAccess access) {
610         return builder -&gt; {
611             LIRKind kind = getLIRGeneratorTool().getLIRKind(root.stamp(NodeView.DEFAULT));
612             return emitReinterpretMemory(kind, access);
613         };
614 
615     }
616 
617     @MatchRule(&quot;(Write object Reinterpret=reinterpret)&quot;)
618     public ComplexMatchResult writeReinterpret(WriteNode root, ReinterpretNode reinterpret) {
619         return builder -&gt; {
620             LIRKind kind = getLIRGeneratorTool().getLIRKind(reinterpret.getValue().stamp(NodeView.DEFAULT));
621             AllocatableValue value = getLIRGeneratorTool().asAllocatable(operand(reinterpret.getValue()));
622 
623             AMD64AddressValue address = (AMD64AddressValue) operand(root.getAddress());
624             getArithmeticLIRGenerator().emitStore((AMD64Kind) kind.getPlatformKind(), address, value, getState(root));
625             return null;
626         };
627     }
628 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package org.graalvm.compiler.core.amd64;
 27 
 28 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.ADD;
 29 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.AND;
 30 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.OR;
 31 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.SUB;
 32 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.XOR;
 33 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSX;
 34 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSXB;
 35 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSXD;
<span class="line-added"> 36 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VADDSD;</span>
<span class="line-added"> 37 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VADDSS;</span>
<span class="line-added"> 38 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VMULSD;</span>
<span class="line-added"> 39 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VMULSS;</span>
<span class="line-added"> 40 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VSUBSD;</span>
<span class="line-added"> 41 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VSUBSS;</span>
 42 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.DWORD;
 43 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.QWORD;
 44 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.SD;
 45 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.SS;
 46 
<span class="line-added"> 47 import org.graalvm.compiler.asm.amd64.AMD64Assembler;</span>
 48 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
 49 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
 50 import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
 51 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;
 52 import org.graalvm.compiler.core.common.LIRKind;
 53 import org.graalvm.compiler.core.common.NumUtil;
 54 import org.graalvm.compiler.core.common.calc.CanonicalCondition;
 55 import org.graalvm.compiler.core.common.calc.Condition;
 56 import org.graalvm.compiler.core.gen.NodeLIRBuilder;
 57 import org.graalvm.compiler.core.gen.NodeMatchRules;
 58 import org.graalvm.compiler.core.match.ComplexMatchResult;
 59 import org.graalvm.compiler.core.match.MatchRule;
 60 import org.graalvm.compiler.debug.GraalError;
 61 import org.graalvm.compiler.lir.LIRFrameState;
 62 import org.graalvm.compiler.lir.LIRValueUtil;
 63 import org.graalvm.compiler.lir.LabelRef;
 64 import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
 65 import org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer;
 66 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.BranchOp;
 67 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
</pre>
<hr />
<pre>
342 
343         JavaConstant bCst = b.asJavaConstant();
344         long bValue;
345         if (bCst.getJavaKind() == JavaKind.Int) {
346             bValue = bCst.asInt();
347         } else if (bCst.getJavaKind() == JavaKind.Long) {
348             bValue = bCst.asLong();
349         } else {
350             return null;
351         }
352 
353         if (bValue == -1) {
354             return builder -&gt; getArithmeticLIRGenerator().emitResetLowestSetBit(operand(a));
355         } else {
356             return null;
357         }
358     }
359 
360     @MatchRule(&quot;(If (IntegerTest Read=access value))&quot;)
361     @MatchRule(&quot;(If (IntegerTest FloatingRead=access value))&quot;)
<span class="line-added">362     @MatchRule(&quot;(If (IntegerTest VolatileRead=access value))&quot;)</span>
363     public ComplexMatchResult integerTestBranchMemory(IfNode root, LIRLowerableAccess access, ValueNode value) {
364         return emitIntegerTestBranchMemory(root, value, access);
365     }
366 
367     @MatchRule(&quot;(If (IntegerEquals=compare value Read=access))&quot;)
368     @MatchRule(&quot;(If (IntegerLessThan=compare value Read=access))&quot;)
369     @MatchRule(&quot;(If (IntegerBelow=compare value Read=access))&quot;)
370     @MatchRule(&quot;(If (IntegerEquals=compare value FloatingRead=access))&quot;)
371     @MatchRule(&quot;(If (IntegerLessThan=compare value FloatingRead=access))&quot;)
372     @MatchRule(&quot;(If (IntegerBelow=compare value FloatingRead=access))&quot;)
<span class="line-added">373     @MatchRule(&quot;(If (IntegerEquals=compare value VolatileRead=access))&quot;)</span>
<span class="line-added">374     @MatchRule(&quot;(If (IntegerLessThan=compare value VolatileRead=access))&quot;)</span>
<span class="line-added">375     @MatchRule(&quot;(If (IntegerBelow=compare value VolatileRead=access))&quot;)</span>
376     @MatchRule(&quot;(If (FloatEquals=compare value Read=access))&quot;)
377     @MatchRule(&quot;(If (FloatEquals=compare value FloatingRead=access))&quot;)
<span class="line-added">378     @MatchRule(&quot;(If (FloatEquals=compare value VolatileRead=access))&quot;)</span>
379     @MatchRule(&quot;(If (FloatLessThan=compare value Read=access))&quot;)
380     @MatchRule(&quot;(If (FloatLessThan=compare value FloatingRead=access))&quot;)
<span class="line-added">381     @MatchRule(&quot;(If (FloatLessThan=compare value VolatileRead=access))&quot;)</span>
382     @MatchRule(&quot;(If (PointerEquals=compare value Read=access))&quot;)
383     @MatchRule(&quot;(If (PointerEquals=compare value FloatingRead=access))&quot;)
<span class="line-added">384     @MatchRule(&quot;(If (PointerEquals=compare value VolatileRead=access))&quot;)</span>
385     @MatchRule(&quot;(If (ObjectEquals=compare value Read=access))&quot;)
386     @MatchRule(&quot;(If (ObjectEquals=compare value FloatingRead=access))&quot;)
<span class="line-added">387     @MatchRule(&quot;(If (ObjectEquals=compare value VolatileRead=access))&quot;)</span>
388     public ComplexMatchResult ifCompareMemory(IfNode root, CompareNode compare, ValueNode value, LIRLowerableAccess access) {
389         return emitCompareBranchMemory(root, compare, value, access);
390     }
391 
392     @MatchRule(&quot;(If (ObjectEquals=compare value ValueCompareAndSwap=cas))&quot;)
393     @MatchRule(&quot;(If (PointerEquals=compare value ValueCompareAndSwap=cas))&quot;)
394     @MatchRule(&quot;(If (FloatEquals=compare value ValueCompareAndSwap=cas))&quot;)
395     @MatchRule(&quot;(If (IntegerEquals=compare value ValueCompareAndSwap=cas))&quot;)
396     public ComplexMatchResult ifCompareValueCas(IfNode root, CompareNode compare, ValueNode value, ValueCompareAndSwapNode cas) {
397         assert compare.condition() == CanonicalCondition.EQ;
<span class="line-modified">398         if (value == cas.getExpectedValue() &amp;&amp; cas.hasExactlyOneUsage()) {</span>
399             return builder -&gt; {
400                 LIRKind kind = getLirKind(cas);
401                 LabelRef trueLabel = getLIRBlock(root.trueSuccessor());
402                 LabelRef falseLabel = getLIRBlock(root.falseSuccessor());
403                 double trueLabelProbability = root.probability(root.trueSuccessor());
404                 Value expectedValue = operand(cas.getExpectedValue());
405                 Value newValue = operand(cas.getNewValue());
406                 AMD64AddressValue address = (AMD64AddressValue) operand(cas.getAddress());
407                 getLIRGeneratorTool().emitCompareAndSwapBranch(kind, address, expectedValue, newValue, Condition.EQ, trueLabel, falseLabel, trueLabelProbability);
408                 return null;
409             };
410         }
411         return null;
412     }
413 
414     @MatchRule(&quot;(If (ObjectEquals=compare value LogicCompareAndSwap=cas))&quot;)
415     @MatchRule(&quot;(If (PointerEquals=compare value LogicCompareAndSwap=cas))&quot;)
416     @MatchRule(&quot;(If (FloatEquals=compare value LogicCompareAndSwap=cas))&quot;)
417     @MatchRule(&quot;(If (IntegerEquals=compare value LogicCompareAndSwap=cas))&quot;)
418     public ComplexMatchResult ifCompareLogicCas(IfNode root, CompareNode compare, ValueNode value, LogicCompareAndSwapNode cas) {
419         JavaConstant constant = value.asJavaConstant();
420         assert compare.condition() == CanonicalCondition.EQ;
<span class="line-modified">421         if (constant != null &amp;&amp; cas.hasExactlyOneUsage()) {</span>
422             long constantValue = constant.asLong();
423             boolean successIsTrue;
424             if (constantValue == 0) {
425                 successIsTrue = false;
426             } else if (constantValue == 1) {
427                 successIsTrue = true;
428             } else {
429                 return null;
430             }
431             return builder -&gt; {
432                 LIRKind kind = getLirKind(cas);
433                 LabelRef trueLabel = getLIRBlock(root.trueSuccessor());
434                 LabelRef falseLabel = getLIRBlock(root.falseSuccessor());
435                 double trueLabelProbability = root.probability(root.trueSuccessor());
436                 Value expectedValue = operand(cas.getExpectedValue());
437                 Value newValue = operand(cas.getNewValue());
438                 AMD64AddressValue address = (AMD64AddressValue) operand(cas.getAddress());
439                 Condition condition = successIsTrue ? Condition.EQ : Condition.NE;
440                 getLIRGeneratorTool().emitCompareAndSwapBranch(kind, address, expectedValue, newValue, condition, trueLabel, falseLabel, trueLabelProbability);
441                 return null;
</pre>
<hr />
<pre>
461     public ComplexMatchResult rotateRightVariable(ValueNode value, ConstantNode delta, ValueNode shiftAmount) {
462         if (delta.asJavaConstant().asLong() == 0 || delta.asJavaConstant().asLong() == 32) {
463             return builder -&gt; getArithmeticLIRGenerator().emitRor(operand(value), operand(shiftAmount));
464         }
465         return null;
466     }
467 
468     @MatchRule(&quot;(Or (LeftShift value shiftAmount) (UnsignedRightShift value (Sub Constant=delta shiftAmount)))&quot;)
469     public ComplexMatchResult rotateLeftVariable(ValueNode value, ValueNode shiftAmount, ConstantNode delta) {
470         if (delta.asJavaConstant().asLong() == 0 || delta.asJavaConstant().asLong() == 32) {
471             return builder -&gt; getArithmeticLIRGenerator().emitRol(operand(value), operand(shiftAmount));
472         }
473         return null;
474     }
475 
476     private ComplexMatchResult binaryRead(AMD64RMOp op, OperandSize size, ValueNode value, LIRLowerableAccess access) {
477         return builder -&gt; getArithmeticLIRGenerator().emitBinaryMemory(op, size, getLIRGeneratorTool().asAllocatable(operand(value)), (AMD64AddressValue) operand(access.getAddress()),
478                         getState(access));
479     }
480 
<span class="line-added">481     private ComplexMatchResult binaryRead(AMD64Assembler.VexRVMOp op, OperandSize size, ValueNode value, LIRLowerableAccess access) {</span>
<span class="line-added">482         assert size == SS || size == SD;</span>
<span class="line-added">483         return builder -&gt; getArithmeticLIRGenerator().emitBinaryMemory(op, size, getLIRGeneratorTool().asAllocatable(operand(value)), (AMD64AddressValue) operand(access.getAddress()),</span>
<span class="line-added">484                         getState(access));</span>
<span class="line-added">485     }</span>
<span class="line-added">486 </span>
487     @MatchRule(&quot;(Add value Read=access)&quot;)
488     @MatchRule(&quot;(Add value FloatingRead=access)&quot;)
<span class="line-added">489     @MatchRule(&quot;(Add value VolatileRead=access)&quot;)</span>
490     public ComplexMatchResult addMemory(ValueNode value, LIRLowerableAccess access) {
491         OperandSize size = getMemorySize(access);
492         if (size.isXmmType()) {
<span class="line-modified">493             if (getArithmeticLIRGenerator().supportAVX()) {</span>
<span class="line-added">494                 return binaryRead(size == SS ? VADDSS : VADDSD, size, value, access);</span>
<span class="line-added">495             } else {</span>
<span class="line-added">496                 return binaryRead(SSEOp.ADD, size, value, access);</span>
<span class="line-added">497             }</span>
498         } else {
499             return binaryRead(ADD.getRMOpcode(size), size, value, access);
500         }
501     }
502 
503     @MatchRule(&quot;(Sub value Read=access)&quot;)
504     @MatchRule(&quot;(Sub value FloatingRead=access)&quot;)
<span class="line-added">505     @MatchRule(&quot;(Sub value VolatileRead=access)&quot;)</span>
506     public ComplexMatchResult subMemory(ValueNode value, LIRLowerableAccess access) {
507         OperandSize size = getMemorySize(access);
508         if (size.isXmmType()) {
<span class="line-modified">509             if (getArithmeticLIRGenerator().supportAVX()) {</span>
<span class="line-added">510                 return binaryRead(size == SS ? VSUBSS : VSUBSD, size, value, access);</span>
<span class="line-added">511             } else {</span>
<span class="line-added">512                 return binaryRead(SSEOp.SUB, size, value, access);</span>
<span class="line-added">513             }</span>
514         } else {
515             return binaryRead(SUB.getRMOpcode(size), size, value, access);
516         }
517     }
518 
519     @MatchRule(&quot;(Mul value Read=access)&quot;)
520     @MatchRule(&quot;(Mul value FloatingRead=access)&quot;)
<span class="line-added">521     @MatchRule(&quot;(Mul value VolatileRead=access)&quot;)</span>
522     public ComplexMatchResult mulMemory(ValueNode value, LIRLowerableAccess access) {
523         OperandSize size = getMemorySize(access);
524         if (size.isXmmType()) {
<span class="line-modified">525             if (getArithmeticLIRGenerator().supportAVX()) {</span>
<span class="line-added">526                 return binaryRead(size == SS ? VMULSS : VMULSD, size, value, access);</span>
<span class="line-added">527             } else {</span>
<span class="line-added">528                 return binaryRead(SSEOp.MUL, size, value, access);</span>
<span class="line-added">529             }</span>
530         } else {
531             return binaryRead(AMD64RMOp.IMUL, size, value, access);
532         }
533     }
534 
535     @MatchRule(&quot;(And value Read=access)&quot;)
536     @MatchRule(&quot;(And value FloatingRead=access)&quot;)
<span class="line-added">537     @MatchRule(&quot;(And value VolatileRead=access)&quot;)</span>
538     public ComplexMatchResult andMemory(ValueNode value, LIRLowerableAccess access) {
539         OperandSize size = getMemorySize(access);
540         if (size.isXmmType()) {
541             return null;
542         } else {
543             return binaryRead(AND.getRMOpcode(size), size, value, access);
544         }
545     }
546 
547     @MatchRule(&quot;(Or value Read=access)&quot;)
548     @MatchRule(&quot;(Or value FloatingRead=access)&quot;)
<span class="line-added">549     @MatchRule(&quot;(Or value VolatileRead=access)&quot;)</span>
550     public ComplexMatchResult orMemory(ValueNode value, LIRLowerableAccess access) {
551         OperandSize size = getMemorySize(access);
552         if (size.isXmmType()) {
553             return null;
554         } else {
555             return binaryRead(OR.getRMOpcode(size), size, value, access);
556         }
557     }
558 
559     @MatchRule(&quot;(Xor value Read=access)&quot;)
560     @MatchRule(&quot;(Xor value FloatingRead=access)&quot;)
<span class="line-added">561     @MatchRule(&quot;(Xor value VolatileRead=access)&quot;)</span>
562     public ComplexMatchResult xorMemory(ValueNode value, LIRLowerableAccess access) {
563         OperandSize size = getMemorySize(access);
564         if (size.isXmmType()) {
565             return null;
566         } else {
567             return binaryRead(XOR.getRMOpcode(size), size, value, access);
568         }
569     }
570 
571     @MatchRule(&quot;(Write object Narrow=narrow)&quot;)
572     public ComplexMatchResult writeNarrow(WriteNode root, NarrowNode narrow) {
573         return builder -&gt; {
574             LIRKind writeKind = getLIRGeneratorTool().getLIRKind(root.value().stamp(NodeView.DEFAULT));
575             getArithmeticLIRGenerator().emitStore(writeKind, operand(root.getAddress()), operand(narrow.getValue()), state(root));
576             return null;
577         };
578     }
579 
580     @MatchRule(&quot;(SignExtend Read=access)&quot;)
581     @MatchRule(&quot;(SignExtend FloatingRead=access)&quot;)
<span class="line-added">582     @MatchRule(&quot;(SignExtend VolatileRead=access)&quot;)</span>
583     public ComplexMatchResult signExtend(SignExtendNode root, LIRLowerableAccess access) {
584         return emitSignExtendMemory(access, root.getInputBits(), root.getResultBits(), null);
585     }
586 
587     @MatchRule(&quot;(ZeroExtend Read=access)&quot;)
588     @MatchRule(&quot;(ZeroExtend FloatingRead=access)&quot;)
<span class="line-added">589     @MatchRule(&quot;(ZeroExtend VolatileRead=access)&quot;)</span>
590     public ComplexMatchResult zeroExtend(ZeroExtendNode root, LIRLowerableAccess access) {
591         AMD64Kind memoryKind = getMemoryKind(access);
592         return builder -&gt; getArithmeticLIRGenerator().emitZeroExtendMemory(memoryKind, root.getResultBits(), (AMD64AddressValue) operand(access.getAddress()), getState(access));
593     }
594 
595     @MatchRule(&quot;(Narrow Read=access)&quot;)
596     @MatchRule(&quot;(Narrow FloatingRead=access)&quot;)
<span class="line-added">597     @MatchRule(&quot;(Narrow VolatileRead=access)&quot;)</span>
598     public ComplexMatchResult narrowRead(NarrowNode root, LIRLowerableAccess access) {
599         return new ComplexMatchResult() {
600             @Override
601             public Value evaluate(NodeLIRBuilder builder) {
602                 AMD64AddressValue address = (AMD64AddressValue) operand(access.getAddress());
603                 LIRKind addressKind = LIRKind.combineDerived(getLIRGeneratorTool().getLIRKind(root.asNode().stamp(NodeView.DEFAULT)),
604                                 address.getBase(), address.getIndex());
605                 AMD64AddressValue newAddress = address.withKind(addressKind);
606                 LIRKind readKind = getLIRGeneratorTool().getLIRKind(root.stamp(NodeView.DEFAULT));
607                 return getArithmeticLIRGenerator().emitZeroExtendMemory((AMD64Kind) readKind.getPlatformKind(),
608                                 root.getResultBits(), newAddress, getState(access));
609             }
610         };
611     }
612 
613     @MatchRule(&quot;(SignExtend (Narrow=narrow Read=access))&quot;)
614     @MatchRule(&quot;(SignExtend (Narrow=narrow FloatingRead=access))&quot;)
<span class="line-added">615     @MatchRule(&quot;(SignExtend (Narrow=narrow VolatileRead=access))&quot;)</span>
616     public ComplexMatchResult signExtendNarrowRead(SignExtendNode root, NarrowNode narrow, LIRLowerableAccess access) {
617         LIRKind kind = getLIRGeneratorTool().getLIRKind(narrow.stamp(NodeView.DEFAULT));
618         return emitSignExtendMemory(access, narrow.getResultBits(), root.getResultBits(), kind);
619     }
620 
621     @MatchRule(&quot;(FloatConvert Read=access)&quot;)
622     @MatchRule(&quot;(FloatConvert FloatingRead=access)&quot;)
<span class="line-added">623     @MatchRule(&quot;(FloatConvert VolatileRead=access)&quot;)</span>
624     public ComplexMatchResult floatConvert(FloatConvertNode root, LIRLowerableAccess access) {
625         switch (root.getFloatConvert()) {
626             case D2F:
627                 return emitConvertMemoryOp(AMD64Kind.SINGLE, SSEOp.CVTSD2SS, SD, access);
628             case D2I:
629                 return emitConvertMemoryOp(AMD64Kind.DWORD, SSEOp.CVTTSD2SI, DWORD, access);
630             case D2L:
631                 return emitConvertMemoryOp(AMD64Kind.QWORD, SSEOp.CVTTSD2SI, QWORD, access);
632             case F2D:
633                 return emitConvertMemoryOp(AMD64Kind.DOUBLE, SSEOp.CVTSS2SD, SS, access);
634             case F2I:
635                 return emitConvertMemoryOp(AMD64Kind.DWORD, SSEOp.CVTTSS2SI, DWORD, access);
636             case F2L:
637                 return emitConvertMemoryOp(AMD64Kind.QWORD, SSEOp.CVTTSS2SI, QWORD, access);
638             case I2D:
639                 return emitConvertMemoryOp(AMD64Kind.DOUBLE, SSEOp.CVTSI2SD, DWORD, access);
640             case I2F:
641                 return emitConvertMemoryOp(AMD64Kind.SINGLE, SSEOp.CVTSI2SS, DWORD, access);
642             case L2D:
643                 return emitConvertMemoryOp(AMD64Kind.DOUBLE, SSEOp.CVTSI2SD, QWORD, access);
644             case L2F:
645                 return emitConvertMemoryOp(AMD64Kind.SINGLE, SSEOp.CVTSI2SS, QWORD, access);
646             default:
647                 throw GraalError.shouldNotReachHere();
648         }
649     }
650 
651     @MatchRule(&quot;(Reinterpret Read=access)&quot;)
652     @MatchRule(&quot;(Reinterpret FloatingRead=access)&quot;)
<span class="line-added">653     @MatchRule(&quot;(Reinterpret VolatileRead=access)&quot;)</span>
654     public ComplexMatchResult reinterpret(ReinterpretNode root, LIRLowerableAccess access) {
655         return builder -&gt; {
656             LIRKind kind = getLIRGeneratorTool().getLIRKind(root.stamp(NodeView.DEFAULT));
657             return emitReinterpretMemory(kind, access);
658         };
659 
660     }
661 
662     @MatchRule(&quot;(Write object Reinterpret=reinterpret)&quot;)
663     public ComplexMatchResult writeReinterpret(WriteNode root, ReinterpretNode reinterpret) {
664         return builder -&gt; {
665             LIRKind kind = getLIRGeneratorTool().getLIRKind(reinterpret.getValue().stamp(NodeView.DEFAULT));
666             AllocatableValue value = getLIRGeneratorTool().asAllocatable(operand(reinterpret.getValue()));
667 
668             AMD64AddressValue address = (AMD64AddressValue) operand(root.getAddress());
669             getArithmeticLIRGenerator().emitStore((AMD64Kind) kind.getPlatformKind(), address, value, getState(root));
670             return null;
671         };
672     }
673 
</pre>
</td>
</tr>
</table>
<center><a href="AMD64MoveFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/Fields.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
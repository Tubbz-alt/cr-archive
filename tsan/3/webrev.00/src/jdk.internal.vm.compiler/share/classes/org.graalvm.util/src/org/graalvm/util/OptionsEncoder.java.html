<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.util/src/org/graalvm/util/OptionsEncoder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
 1 /*
 2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
 3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4  *
 5  * This code is free software; you can redistribute it and/or modify it
 6  * under the terms of the GNU General Public License version 2 only, as
 7  * published by the Free Software Foundation.
 8  *
 9  * This code is distributed in the hope that it will be useful, but WITHOUT
10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12  * version 2 for more details (a copy is included in the LICENSE file that
13  * accompanied this code).
14  *
15  * You should have received a copy of the GNU General Public License version
16  * 2 along with this work; if not, write to the Free Software Foundation,
17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18  *
19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20  * or visit www.oracle.com if you need additional information or have any
21  * questions.
22  */
23 
24 
25 package org.graalvm.util;
26 
27 import java.io.ByteArrayInputStream;
28 import java.io.ByteArrayOutputStream;
29 import java.io.IOException;
30 import java.util.LinkedHashMap;
31 import java.util.Map;
32 
33 /**
34  * Facilities for encoding/decoding a set of options to/from a byte array.
35  */
36 public final class OptionsEncoder {
37 
38     private OptionsEncoder() {
39     }
40 
41     /**
42      * Determines if {@code value} is supported by {@link #encode(Map)}.
43      */
44     public static boolean isValueSupported(Object value) {
45         return TypedDataOutputStream.isValueSupported(value);
46     }
47 
48     /**
49      * Encodes {@code options} into a byte array.
50      *
51      * @throws IllegalArgumentException if any value in {@code options} is not
52      *             {@linkplain #isValueSupported(Object) supported}
53      */
54     public static byte[] encode(final Map&lt;String, Object&gt; options) {
55         try (ByteArrayOutputStream baout = new ByteArrayOutputStream()) {
56             try (TypedDataOutputStream out = new TypedDataOutputStream(baout)) {
57                 out.writeInt(options.size());
58                 for (Map.Entry&lt;String, Object&gt; e : options.entrySet()) {
59                     out.writeUTF(e.getKey());
60                     try {
61                         out.writeTypedValue(e.getValue());
62                     } catch (IllegalArgumentException iae) {
63                         throw new IllegalArgumentException(String.format(&quot;Key: %s, Value: %s, Value type: %s&quot;,
64                                         e.getKey(), e.getValue(), e.getValue().getClass()), iae);
65                     }
66                 }
67             }
68             return baout.toByteArray();
69         } catch (IOException ioe) {
70             throw new IllegalArgumentException(ioe);
71         }
72     }
73 
74     /**
75      * Decodes {@code input} into a name/value map.
76      *
77      * @throws IllegalArgumentException if {@code input} cannot be decoded
78      */
79     public static Map&lt;String, Object&gt; decode(byte[] input) {
80         Map&lt;String, Object&gt; res = new LinkedHashMap&lt;&gt;();
81         try (TypedDataInputStream in = new TypedDataInputStream(new ByteArrayInputStream(input))) {
82             final int size = in.readInt();
83             for (int i = 0; i &lt; size; i++) {
84                 final String key = in.readUTF();
85                 final Object value = in.readTypedValue();
86                 res.put(key, value);
87             }
88             if (in.available() != 0) {
89                 throw new IllegalArgumentException(in.available() + &quot; undecoded bytes&quot;);
90             }
91         } catch (IOException ioe) {
92             throw new IllegalArgumentException(ioe);
93         }
94         return res;
95     }
96 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64BaseAssembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64Assembler.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64MacroAssembler.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64BaseAssembler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -30,15 +30,15 @@</span>
  import static jdk.vm.ci.amd64.AMD64.r13;
  import static jdk.vm.ci.amd64.AMD64.rbp;
  import static jdk.vm.ci.amd64.AMD64.rsp;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.EVEXPrefixConfig.B0;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.EVEXPrefixConfig.B1;
<span class="udiff-line-removed">- import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.EVEXPrefixConfig.L512;</span>
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.EVEXPrefixConfig.Z0;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.EVEXPrefixConfig.Z1;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.L128;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.L256;
<span class="udiff-line-added">+ import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.L512;</span>
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.LZ;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.M_0F;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.M_0F38;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.M_0F3A;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.P_;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -508,30 +508,32 @@</span>
       */
      protected final void emitModRM(Register reg, Register rm) {
          emitModRM(reg.encoding &amp; 0x07, rm);
      }
  
<span class="udiff-line-added">+     public static final int DEFAULT_DISP8_SCALE = 1;</span>
<span class="udiff-line-added">+ </span>
      /**
       * Emits the ModR/M byte and optionally the SIB byte for one register and one memory operand.
       *
       * @param force4Byte use 4 byte encoding for displacements that would normally fit in a byte
       */
      protected final void emitOperandHelper(Register reg, AMD64Address addr, boolean force4Byte, int additionalInstructionSize) {
          assert !reg.equals(Register.None);
<span class="udiff-line-modified-removed">-         emitOperandHelper(encode(reg), addr, force4Byte, additionalInstructionSize, 1);</span>
<span class="udiff-line-modified-added">+         emitOperandHelper(encode(reg), addr, force4Byte, additionalInstructionSize, DEFAULT_DISP8_SCALE);</span>
      }
  
      protected final void emitOperandHelper(int reg, AMD64Address addr, int additionalInstructionSize) {
<span class="udiff-line-modified-removed">-         emitOperandHelper(reg, addr, false, additionalInstructionSize, 1);</span>
<span class="udiff-line-modified-added">+         emitOperandHelper(reg, addr, false, additionalInstructionSize, DEFAULT_DISP8_SCALE);</span>
      }
  
      protected final void emitOperandHelper(Register reg, AMD64Address addr, int additionalInstructionSize) {
          assert !reg.equals(Register.None);
<span class="udiff-line-modified-removed">-         emitOperandHelper(encode(reg), addr, false, additionalInstructionSize, 1);</span>
<span class="udiff-line-modified-added">+         emitOperandHelper(encode(reg), addr, false, additionalInstructionSize, DEFAULT_DISP8_SCALE);</span>
      }
  
<span class="udiff-line-modified-removed">-     protected final void emitEVEXOperandHelper(Register reg, AMD64Address addr, int additionalInstructionSize, int evexDisp8Scale) {</span>
<span class="udiff-line-modified-added">+     protected final void emitOperandHelper(Register reg, AMD64Address addr, int additionalInstructionSize, int evexDisp8Scale) {</span>
          assert !reg.equals(Register.None);
          emitOperandHelper(encode(reg), addr, false, additionalInstructionSize, evexDisp8Scale);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -737,10 +739,11 @@</span>
      }
  
      public static final class VEXPrefixConfig {
          public static final int L128 = 0;
          public static final int L256 = 1;
<span class="udiff-line-added">+         public static final int L512 = 2;</span>
          public static final int LZ = 0;
  
          public static final int W0 = 0;
          public static final int W1 = 1;
          public static final int WIG = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -934,22 +937,33 @@</span>
              default:
                  return LZ;
          }
      }
  
<span class="udiff-line-modified-removed">-     public final void vexPrefix(Register dst, Register nds, Register src, AVXSize size, int pp, int mmmmm, int w, boolean checkAVX) {</span>
<span class="udiff-line-modified-added">+     public static boolean isAVX512Register(Register reg) {</span>
<span class="udiff-line-added">+         return reg != null &amp;&amp; reg.isValid() &amp;&amp; AMD64.XMM.equals(reg.getRegisterCategory()) &amp;&amp; reg.encoding &gt; 15;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public final boolean vexPrefix(Register dst, Register nds, Register src, AVXSize size, int pp, int mmmmm, int w, int wEvex, boolean checkAVX) {</span>
<span class="udiff-line-added">+         if (isAVX512Register(dst) || isAVX512Register(nds) || isAVX512Register(src) || size == AVXSize.ZMM) {</span>
<span class="udiff-line-added">+             evexPrefix(dst, Register.None, nds, src, size, pp, mmmmm, wEvex, Z0, B0);</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         }</span>
          emitVEX(getLFlag(size), pp, mmmmm, w, getRXB(dst, src), nds.isValid() ? nds.encoding() : 0, checkAVX);
<span class="udiff-line-added">+         return false;</span>
      }
  
<span class="udiff-line-modified-removed">-     public final void vexPrefix(Register dst, Register nds, AMD64Address src, AVXSize size, int pp, int mmmmm, int w, boolean checkAVX) {</span>
<span class="udiff-line-modified-added">+     public final boolean vexPrefix(Register dst, Register nds, AMD64Address src, AVXSize size, int pp, int mmmmm, int w, int wEvex, boolean checkAVX) {</span>
<span class="udiff-line-added">+         if (isAVX512Register(dst) || isAVX512Register(nds) || size == AVXSize.ZMM) {</span>
<span class="udiff-line-added">+             evexPrefix(dst, Register.None, nds, src, size, pp, mmmmm, wEvex, Z0, B0);</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         }</span>
          emitVEX(getLFlag(size), pp, mmmmm, w, getRXB(dst, src), nds.isValid() ? nds.encoding() : 0, checkAVX);
<span class="udiff-line-added">+         return false;</span>
      }
  
      protected static final class EVEXPrefixConfig {
<span class="udiff-line-removed">-         public static final int L512 = 2;</span>
<span class="udiff-line-removed">-         public static final int LIG = 0;</span>
<span class="udiff-line-removed">- </span>
          public static final int Z0 = 0x0;
          public static final int Z1 = 0x1;
  
          public static final int B0 = 0x0;
          public static final int B1 = 0x1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -965,10 +979,11 @@</span>
       * scaling factor N depending on the tuple type and the vector length.
       *
       * Reference: Intel Software Developer&#39;s Manual Volume 2, Section 2.6.5
       */
      protected enum EVEXTuple {
<span class="udiff-line-added">+         INVALID(NOT_SUPPORTED_VECTOR_LENGTH, NOT_SUPPORTED_VECTOR_LENGTH, NOT_SUPPORTED_VECTOR_LENGTH),</span>
          FV_NO_BROADCAST_32BIT(16, 32, 64),
          FV_BROADCAST_32BIT(4, 4, 4),
          FV_NO_BROADCAST_64BIT(16, 32, 64),
          FV_BROADCAST_64BIT(8, 8, 8),
          HV_NO_BROADCAST_32BIT(8, 16, 32),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1152,11 +1167,11 @@</span>
  
      /**
       * Helper method for emitting EVEX prefix in the form of RRRM. Because the memory addressing in
       * EVEX-encoded instructions employ a compressed displacement scheme when using disp8 form, the
       * user of this API should make sure to encode the operands using
<span class="udiff-line-modified-removed">-      * {@link #emitEVEXOperandHelper(Register, AMD64Address, int, int)}.</span>
<span class="udiff-line-modified-added">+      * {@link #emitOperandHelper(Register, AMD64Address, int, int)}.</span>
       */
      protected final void evexPrefix(Register dst, Register mask, Register nds, AMD64Address src, AVXSize size, int pp, int mm, int w, int z, int b) {
          assert !mask.isValid() || inRC(MASK, mask);
          emitEVEX(getLFlag(size), pp, mm, w, getRXB(dst, src), dst.encoding, nds.isValid() ? nds.encoding() : 0, z, b, mask.isValid() ? mask.encoding : 0);
      }
</pre>
<center><a href="AMD64Assembler.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64MacroAssembler.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64Assembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64AsmOptions.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64BaseAssembler.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64Assembler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,12 ***</span>
<span class="line-new-header">--- 25,18 ---</span>
  package org.graalvm.compiler.asm.amd64;
  
  import static jdk.vm.ci.amd64.AMD64.CPU;
  import static jdk.vm.ci.amd64.AMD64.MASK;
  import static jdk.vm.ci.amd64.AMD64.XMM;
<span class="line-added">+ import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512BW;</span>
<span class="line-added">+ import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512CD;</span>
<span class="line-added">+ import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512DQ;</span>
<span class="line-added">+ import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512F;</span>
<span class="line-added">+ import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512VL;</span>
  import static jdk.vm.ci.code.MemoryBarriers.STORE_LOAD;
  import static org.graalvm.compiler.asm.amd64.AMD64AsmOptions.UseAddressNop;
<span class="line-added">+ import static org.graalvm.compiler.asm.amd64.AMD64AsmOptions.UseIntelNops;</span>
  import static org.graalvm.compiler.asm.amd64.AMD64AsmOptions.UseNormalNop;
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.ADD;
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.AND;
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.CMP;
  import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.OR;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 52,10 ***</span>
<span class="line-new-header">--- 58,11 ---</span>
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.SD;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.SS;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.WORD;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.L128;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.L256;
<span class="line-added">+ import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.L512;</span>
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.LZ;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.M_0F;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.M_0F38;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.M_0F3A;
  import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.P_;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,11 ***</span>
  import java.util.EnumSet;
  
  import org.graalvm.compiler.asm.Label;
  import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
  import org.graalvm.compiler.asm.amd64.AVXKind.AVXSize;
<span class="line-removed">- import org.graalvm.compiler.core.common.NumUtil;</span>
  import org.graalvm.compiler.core.common.calc.Condition;
  import org.graalvm.compiler.debug.GraalError;
  
  import jdk.vm.ci.amd64.AMD64;
  import jdk.vm.ci.amd64.AMD64.CPUFeature;
<span class="line-new-header">--- 80,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 893,39 ***</span>
              mcOp = new AMD64MOp(opcode, 0, 0xD3, code, OpAssertion.WordOrLargerAssertion);
              miOp = new AMD64MIOp(opcode, true, 0, 0xC1, code, OpAssertion.WordOrLargerAssertion);
          }
      }
  
      private enum VEXOpAssertion {
<span class="line-modified">!         AVX1(CPUFeature.AVX, CPUFeature.AVX),</span>
<span class="line-modified">!         AVX1_2(CPUFeature.AVX, CPUFeature.AVX2),</span>
<span class="line-modified">!         AVX2(CPUFeature.AVX2, CPUFeature.AVX2),</span>
<span class="line-modified">!         AVX1_128ONLY(CPUFeature.AVX, null),</span>
<span class="line-modified">!         AVX1_256ONLY(null, CPUFeature.AVX),</span>
<span class="line-modified">!         AVX2_256ONLY(null, CPUFeature.AVX2),</span>
<span class="line-modified">!         XMM_CPU(CPUFeature.AVX, null, XMM, null, CPU, null),</span>
<span class="line-modified">!         XMM_XMM_CPU(CPUFeature.AVX, null, XMM, XMM, CPU, null),</span>
<span class="line-modified">!         CPU_XMM(CPUFeature.AVX, null, CPU, null, XMM, null),</span>
<span class="line-modified">!         AVX1_2_CPU_XMM(CPUFeature.AVX, CPUFeature.AVX2, CPU, null, XMM, null),</span>
<span class="line-modified">!         BMI1(CPUFeature.BMI1, null, CPU, CPU, CPU, null),</span>
<span class="line-modified">!         BMI2(CPUFeature.BMI2, null, CPU, CPU, CPU, null);</span>
  
          private final CPUFeature l128feature;
          private final CPUFeature l256feature;
  
          private final RegisterCategory rCategory;
          private final RegisterCategory vCategory;
          private final RegisterCategory mCategory;
          private final RegisterCategory imm8Category;
  
<span class="line-modified">!         VEXOpAssertion(CPUFeature l128feature, CPUFeature l256feature) {</span>
<span class="line-modified">!             this(l128feature, l256feature, XMM, XMM, XMM, XMM);</span>
          }
  
<span class="line-modified">!         VEXOpAssertion(CPUFeature l128feature, CPUFeature l256feature, RegisterCategory rCategory, RegisterCategory vCategory, RegisterCategory mCategory, RegisterCategory imm8Category) {</span>
              this.l128feature = l128feature;
              this.l256feature = l256feature;
              this.rCategory = rCategory;
              this.vCategory = vCategory;
              this.mCategory = mCategory;
              this.imm8Category = imm8Category;
          }
<span class="line-new-header">--- 899,94 ---</span>
              mcOp = new AMD64MOp(opcode, 0, 0xD3, code, OpAssertion.WordOrLargerAssertion);
              miOp = new AMD64MIOp(opcode, true, 0, 0xC1, code, OpAssertion.WordOrLargerAssertion);
          }
      }
  
<span class="line-added">+     private enum EVEXFeatureAssertion {</span>
<span class="line-added">+         AVX512F_ALL(EnumSet.of(AVX512F), EnumSet.of(AVX512F), EnumSet.of(AVX512F)),</span>
<span class="line-added">+         AVX512F_128ONLY(EnumSet.of(AVX512F), null, null),</span>
<span class="line-added">+         AVX512F_VL(EnumSet.of(AVX512F, AVX512VL), EnumSet.of(AVX512F, AVX512VL), EnumSet.of(AVX512F)),</span>
<span class="line-added">+         AVX512CD_VL(EnumSet.of(AVX512F, AVX512CD, AVX512VL), EnumSet.of(AVX512F, AVX512CD, AVX512VL), EnumSet.of(AVX512F, AVX512CD)),</span>
<span class="line-added">+         AVX512DQ_VL(EnumSet.of(AVX512F, AVX512DQ, AVX512VL), EnumSet.of(AVX512F, AVX512DQ, AVX512VL), EnumSet.of(AVX512F, AVX512DQ)),</span>
<span class="line-added">+         AVX512BW_VL(EnumSet.of(AVX512F, AVX512BW, AVX512VL), EnumSet.of(AVX512F, AVX512BW, AVX512VL), EnumSet.of(AVX512F, AVX512BW));</span>
<span class="line-added">+ </span>
<span class="line-added">+         private final EnumSet&lt;CPUFeature&gt; l128features;</span>
<span class="line-added">+         private final EnumSet&lt;CPUFeature&gt; l256features;</span>
<span class="line-added">+         private final EnumSet&lt;CPUFeature&gt; l512features;</span>
<span class="line-added">+ </span>
<span class="line-added">+         EVEXFeatureAssertion(EnumSet&lt;CPUFeature&gt; l128features, EnumSet&lt;CPUFeature&gt; l256features, EnumSet&lt;CPUFeature&gt; l512features) {</span>
<span class="line-added">+             this.l128features = l128features;</span>
<span class="line-added">+             this.l256features = l256features;</span>
<span class="line-added">+             this.l512features = l512features;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         public boolean check(AMD64 arch, int l) {</span>
<span class="line-added">+             switch (l) {</span>
<span class="line-added">+                 case L128:</span>
<span class="line-added">+                     assert l128features != null &amp;&amp; arch.getFeatures().containsAll(l128features) : &quot;emitting illegal 128 bit instruction&quot;;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 case L256:</span>
<span class="line-added">+                     assert l256features != null &amp;&amp; arch.getFeatures().containsAll(l256features) : &quot;emitting illegal 256 bit instruction&quot;;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 case L512:</span>
<span class="line-added">+                     assert l512features != null &amp;&amp; arch.getFeatures().containsAll(l512features) : &quot;emitting illegal 512 bit instruction&quot;;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         public boolean supports(EnumSet&lt;CPUFeature&gt; features, AVXSize avxSize) {</span>
<span class="line-added">+             switch (avxSize) {</span>
<span class="line-added">+                 case XMM:</span>
<span class="line-added">+                     return l128features != null &amp;&amp; features.containsAll(l128features);</span>
<span class="line-added">+                 case YMM:</span>
<span class="line-added">+                     return l256features != null &amp;&amp; features.containsAll(l256features);</span>
<span class="line-added">+                 case ZMM:</span>
<span class="line-added">+                     return l512features != null &amp;&amp; features.containsAll(l512features);</span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     throw GraalError.shouldNotReachHere();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private enum VEXOpAssertion {
<span class="line-modified">!         AVX1(CPUFeature.AVX, CPUFeature.AVX, null),</span>
<span class="line-modified">!         AVX1_2(CPUFeature.AVX, CPUFeature.AVX2, null),</span>
<span class="line-modified">!         AVX2(CPUFeature.AVX2, CPUFeature.AVX2, null),</span>
<span class="line-modified">!         AVX1_128ONLY(CPUFeature.AVX, null, null),</span>
<span class="line-modified">!         AVX1_256ONLY(null, CPUFeature.AVX, null),</span>
<span class="line-modified">!         AVX2_256ONLY(null, CPUFeature.AVX2, null),</span>
<span class="line-modified">!         XMM_CPU(CPUFeature.AVX, null, null, XMM, null, CPU, null),</span>
<span class="line-modified">!         XMM_XMM_CPU(CPUFeature.AVX, null, null, XMM, XMM, CPU, null),</span>
<span class="line-modified">!         CPU_XMM(CPUFeature.AVX, null, null, CPU, null, XMM, null),</span>
<span class="line-modified">!         AVX1_2_CPU_XMM(CPUFeature.AVX, CPUFeature.AVX2, null, CPU, null, XMM, null),</span>
<span class="line-modified">!         BMI1(CPUFeature.BMI1, null, null, CPU, CPU, CPU, null),</span>
<span class="line-modified">!         BMI2(CPUFeature.BMI2, null, null, CPU, CPU, CPU, null),</span>
<span class="line-added">+         FMA(CPUFeature.FMA, null, null, XMM, XMM, XMM, null),</span>
<span class="line-added">+ </span>
<span class="line-added">+         XMM_CPU_AVX512F_128ONLY(CPUFeature.AVX, null, EVEXFeatureAssertion.AVX512F_128ONLY, XMM, null, CPU, null),</span>
<span class="line-added">+         AVX1_AVX512F_ALL(CPUFeature.AVX, CPUFeature.AVX, EVEXFeatureAssertion.AVX512F_ALL),</span>
<span class="line-added">+         AVX1_AVX512F_VL(CPUFeature.AVX, CPUFeature.AVX, EVEXFeatureAssertion.AVX512F_VL);</span>
  
          private final CPUFeature l128feature;
          private final CPUFeature l256feature;
<span class="line-added">+         private final EVEXFeatureAssertion l512features;</span>
  
          private final RegisterCategory rCategory;
          private final RegisterCategory vCategory;
          private final RegisterCategory mCategory;
          private final RegisterCategory imm8Category;
  
<span class="line-modified">!         VEXOpAssertion(CPUFeature l128feature, CPUFeature l256feature, EVEXFeatureAssertion l512features) {</span>
<span class="line-modified">!             this(l128feature, l256feature, l512features, XMM, XMM, XMM, XMM);</span>
          }
  
<span class="line-modified">!         VEXOpAssertion(CPUFeature l128feature, CPUFeature l256feature, EVEXFeatureAssertion l512features, RegisterCategory rCategory, RegisterCategory vCategory, RegisterCategory mCategory,</span>
<span class="line-added">+                         RegisterCategory imm8Category) {</span>
              this.l128feature = l128feature;
              this.l256feature = l256feature;
<span class="line-added">+             this.l512features = l512features;</span>
              this.rCategory = rCategory;
              this.vCategory = vCategory;
              this.mCategory = mCategory;
              this.imm8Category = imm8Category;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 937,17 ***</span>
          public boolean check(AMD64 arch, AVXSize size, Register r, Register v, Register m, Register imm8) {
              return check(arch, getLFlag(size), r, v, m, imm8);
          }
  
          public boolean check(AMD64 arch, int l, Register r, Register v, Register m, Register imm8) {
<span class="line-modified">!             switch (l) {</span>
<span class="line-modified">!                 case L128:</span>
<span class="line-modified">!                     assert l128feature != null &amp;&amp; arch.getFeatures().contains(l128feature) : &quot;emitting illegal 128 bit instruction&quot;;</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 case L256:</span>
<span class="line-modified">!                     assert l256feature != null &amp;&amp; arch.getFeatures().contains(l256feature) : &quot;emitting illegal 256 bit instruction&quot;;</span>
<span class="line-removed">-                     break;</span>
              }
              if (r != null) {
                  assert r.getRegisterCategory().equals(rCategory);
              }
              if (v != null) {
<span class="line-new-header">--- 998,16 ---</span>
          public boolean check(AMD64 arch, AVXSize size, Register r, Register v, Register m, Register imm8) {
              return check(arch, getLFlag(size), r, v, m, imm8);
          }
  
          public boolean check(AMD64 arch, int l, Register r, Register v, Register m, Register imm8) {
<span class="line-modified">!             if (isAVX512Register(r) || isAVX512Register(v) || isAVX512Register(m) || l == L512) {</span>
<span class="line-modified">!                 assert l512features != null &amp;&amp; l512features.check(arch, l);</span>
<span class="line-modified">!             } else if (l == L128) {</span>
<span class="line-modified">!                 assert l128feature != null &amp;&amp; arch.getFeatures().contains(l128feature) : &quot;emitting illegal 128 bit instruction&quot;;</span>
<span class="line-modified">!             } else if (l == L256) {</span>
<span class="line-modified">!                 assert l256feature != null &amp;&amp; arch.getFeatures().contains(l256feature) : &quot;emitting illegal 256 bit instruction&quot;;</span>
              }
              if (r != null) {
                  assert r.getRegisterCategory().equals(rCategory);
              }
              if (v != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 960,19 ***</span>
                  assert imm8.getRegisterCategory().equals(imm8Category);
              }
              return true;
          }
  
<span class="line-modified">!         public boolean supports(EnumSet&lt;CPUFeature&gt; features, AVXSize avxSize) {</span>
<span class="line-modified">!             switch (avxSize) {</span>
<span class="line-modified">!                 case XMM:</span>
<span class="line-modified">!                     return l128feature != null &amp;&amp; features.contains(l128feature);</span>
<span class="line-modified">!                 case YMM:</span>
<span class="line-modified">!                     return l256feature != null &amp;&amp; features.contains(l256feature);</span>
<span class="line-modified">!                 default:</span>
<span class="line-removed">-                     throw GraalError.shouldNotReachHere();</span>
              }
          }
      }
  
      /**
       * Base class for VEX-encoded instructions.
<span class="line-new-header">--- 1020,19 ---</span>
                  assert imm8.getRegisterCategory().equals(imm8Category);
              }
              return true;
          }
  
<span class="line-modified">!         public boolean supports(EnumSet&lt;CPUFeature&gt; features, AVXSize avxSize, boolean useZMMRegisters) {</span>
<span class="line-modified">!             if (useZMMRegisters || avxSize == AVXSize.ZMM) {</span>
<span class="line-modified">!                 return l512features != null &amp;&amp; l512features.supports(features, avxSize);</span>
<span class="line-modified">!             } else if (avxSize == AVXSize.XMM) {</span>
<span class="line-modified">!                 return l128feature != null &amp;&amp; features.contains(l128feature);</span>
<span class="line-modified">!             } else if (avxSize == AVXSize.YMM) {</span>
<span class="line-modified">!                 return l256feature != null &amp;&amp; features.contains(l256feature);</span>
              }
<span class="line-added">+             throw GraalError.shouldNotReachHere();</span>
          }
      }
  
      /**
       * Base class for VEX-encoded instructions.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 984,49 ***</span>
          protected final int op;
  
          private final String opcode;
          protected final VEXOpAssertion assertion;
  
<span class="line-modified">!         protected VexOp(String opcode, int pp, int mmmmm, int w, int op, VEXOpAssertion assertion) {</span>
              this.pp = pp;
              this.mmmmm = mmmmm;
              this.w = w;
              this.op = op;
              this.opcode = opcode;
              this.assertion = assertion;
          }
  
          public final boolean isSupported(AMD64Assembler vasm, AVXSize size) {
<span class="line-modified">!             return assertion.supports(((AMD64) vasm.target.arch).getFeatures(), size);</span>
          }
  
          @Override
          public String toString() {
              return opcode;
          }
      }
  
      /**
       * VEX-encoded instructions with an operand order of RM, but the M operand must be a register.
       */
      public static class VexRROp extends VexOp {
          // @formatter:off
<span class="line-modified">!         public static final VexRROp VMASKMOVDQU = new VexRROp(&quot;VMASKMOVDQU&quot;, P_66, M_0F, WIG, 0xF7, VEXOpAssertion.AVX1_128ONLY);</span>
          // @formatter:on
  
<span class="line-modified">!         protected VexRROp(String opcode, int pp, int mmmmm, int w, int op) {</span>
<span class="line-modified">!             this(opcode, pp, mmmmm, w, op, VEXOpAssertion.AVX1);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         protected VexRROp(String opcode, int pp, int mmmmm, int w, int op, VEXOpAssertion assertion) {</span>
<span class="line-removed">-             super(opcode, pp, mmmmm, w, op, assertion);</span>
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, null, src);
              assert op != 0x1A || op != 0x5A;
<span class="line-modified">!             asm.vexPrefix(dst, Register.None, src, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src);
          }
      }
  
<span class="line-new-header">--- 1044,63 ---</span>
          protected final int op;
  
          private final String opcode;
          protected final VEXOpAssertion assertion;
  
<span class="line-modified">!         protected final EVEXTuple evexTuple;</span>
<span class="line-added">+         protected final int wEvex;</span>
<span class="line-added">+ </span>
<span class="line-added">+         protected VexOp(String opcode, int pp, int mmmmm, int w, int op, VEXOpAssertion assertion, EVEXTuple evexTuple, int wEvex) {</span>
              this.pp = pp;
              this.mmmmm = mmmmm;
              this.w = w;
              this.op = op;
              this.opcode = opcode;
              this.assertion = assertion;
<span class="line-added">+             this.evexTuple = evexTuple;</span>
<span class="line-added">+             this.wEvex = wEvex;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         protected VexOp(String opcode, int pp, int mmmmm, int w, int op, VEXOpAssertion assertion) {</span>
<span class="line-added">+             this(opcode, pp, mmmmm, w, op, assertion, EVEXTuple.INVALID, WIG);</span>
          }
  
          public final boolean isSupported(AMD64Assembler vasm, AVXSize size) {
<span class="line-modified">!             return isSupported(vasm, size, false);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         public final boolean isSupported(AMD64Assembler vasm, AVXSize size, boolean useZMMRegisters) {</span>
<span class="line-added">+             return assertion.supports(((AMD64) vasm.target.arch).getFeatures(), size, useZMMRegisters);</span>
          }
  
          @Override
          public String toString() {
              return opcode;
          }
<span class="line-added">+ </span>
<span class="line-added">+         protected final int getDisp8Scale(boolean useEvex, AVXSize size) {</span>
<span class="line-added">+             return useEvex ? evexTuple.getDisp8ScalingFactor(size) : DEFAULT_DISP8_SCALE;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
      }
  
      /**
       * VEX-encoded instructions with an operand order of RM, but the M operand must be a register.
       */
      public static class VexRROp extends VexOp {
          // @formatter:off
<span class="line-modified">!         public static final VexRROp VMASKMOVDQU = new VexRROp(&quot;VMASKMOVDQU&quot;, P_66, M_0F, WIG, 0xF7, VEXOpAssertion.AVX1_128ONLY, EVEXTuple.INVALID, WIG);</span>
          // @formatter:on
  
<span class="line-modified">!         protected VexRROp(String opcode, int pp, int mmmmm, int w, int op, VEXOpAssertion assertion, EVEXTuple evexTuple, int wEvex) {</span>
<span class="line-modified">!             super(opcode, pp, mmmmm, w, op, assertion, evexTuple, wEvex);</span>
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, null, src);
              assert op != 0x1A || op != 0x5A;
<span class="line-modified">!             asm.vexPrefix(dst, Register.None, src, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1074,22 ***</span>
          public static final VexRMOp VUCOMISS        = new VexRMOp(&quot;VUCOMISS&quot;,        P_,   M_0F,   WIG, 0x2E);
          public static final VexRMOp VUCOMISD        = new VexRMOp(&quot;VUCOMISD&quot;,        P_66, M_0F,   WIG, 0x2E);
          // @formatter:on
  
          protected VexRMOp(String opcode, int pp, int mmmmm, int w, int op) {
<span class="line-modified">!             this(opcode, pp, mmmmm, w, op, VEXOpAssertion.AVX1);</span>
          }
  
          protected VexRMOp(String opcode, int pp, int mmmmm, int w, int op, VEXOpAssertion assertion) {
<span class="line-modified">!             super(opcode, pp, mmmmm, w, op, assertion);</span>
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, AMD64Address src) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, null, null);
<span class="line-modified">!             asm.vexPrefix(dst, Register.None, src, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(dst, src, 0);</span>
          }
      }
  
      /**
       * VEX-encoded move instructions.
<span class="line-new-header">--- 1148,26 ---</span>
          public static final VexRMOp VUCOMISS        = new VexRMOp(&quot;VUCOMISS&quot;,        P_,   M_0F,   WIG, 0x2E);
          public static final VexRMOp VUCOMISD        = new VexRMOp(&quot;VUCOMISD&quot;,        P_66, M_0F,   WIG, 0x2E);
          // @formatter:on
  
          protected VexRMOp(String opcode, int pp, int mmmmm, int w, int op) {
<span class="line-modified">!             this(opcode, pp, mmmmm, w, op, VEXOpAssertion.AVX1, EVEXTuple.INVALID, WIG);</span>
          }
  
          protected VexRMOp(String opcode, int pp, int mmmmm, int w, int op, VEXOpAssertion assertion) {
<span class="line-modified">!             this(opcode, pp, mmmmm, w, op, assertion, EVEXTuple.INVALID, WIG);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         protected VexRMOp(String opcode, int pp, int mmmmm, int w, int op, VEXOpAssertion assertion, EVEXTuple evexTuple, int wEvex) {</span>
<span class="line-added">+             super(opcode, pp, mmmmm, w, op, assertion, evexTuple, wEvex);</span>
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, AMD64Address src) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, null, null);
<span class="line-modified">!             boolean useEvex = asm.vexPrefix(dst, Register.None, src, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(dst, src, 0, getDisp8Scale(useEvex, size));</span>
          }
      }
  
      /**
       * VEX-encoded move instructions.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1097,43 ***</span>
       * These instructions have two opcodes: op is the forward move instruction with an operand order
       * of RM, and opReverse is the reverse move instruction with an operand order of MR.
       */
      public static final class VexMoveOp extends VexRMOp {
          // @formatter:off
<span class="line-modified">!         public static final VexMoveOp VMOVDQA = new VexMoveOp(&quot;VMOVDQA&quot;, P_66, M_0F, WIG, 0x6F, 0x7F);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVDQU = new VexMoveOp(&quot;VMOVDQU&quot;, P_F3, M_0F, WIG, 0x6F, 0x7F);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVAPS = new VexMoveOp(&quot;VMOVAPS&quot;, P_,   M_0F, WIG, 0x28, 0x29);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVAPD = new VexMoveOp(&quot;VMOVAPD&quot;, P_66, M_0F, WIG, 0x28, 0x29);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVUPS = new VexMoveOp(&quot;VMOVUPS&quot;, P_,   M_0F, WIG, 0x10, 0x11);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVUPD = new VexMoveOp(&quot;VMOVUPD&quot;, P_66, M_0F, WIG, 0x10, 0x11);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVSS  = new VexMoveOp(&quot;VMOVSS&quot;,  P_F3, M_0F, WIG, 0x10, 0x11);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVSD  = new VexMoveOp(&quot;VMOVSD&quot;,  P_F2, M_0F, WIG, 0x10, 0x11);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVD   = new VexMoveOp(&quot;VMOVD&quot;,   P_66, M_0F, W0,  0x6E, 0x7E, VEXOpAssertion.XMM_CPU);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVQ   = new VexMoveOp(&quot;VMOVQ&quot;,   P_66, M_0F, W1,  0x6E, 0x7E, VEXOpAssertion.XMM_CPU);</span>
          // @formatter:on
  
          private final int opReverse;
  
          private VexMoveOp(String opcode, int pp, int mmmmm, int w, int op, int opReverse) {
<span class="line-modified">!             this(opcode, pp, mmmmm, w, op, opReverse, VEXOpAssertion.AVX1);</span>
          }
  
          private VexMoveOp(String opcode, int pp, int mmmmm, int w, int op, int opReverse, VEXOpAssertion assertion) {
<span class="line-modified">!             super(opcode, pp, mmmmm, w, op, assertion);</span>
              this.opReverse = opReverse;
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, AMD64Address dst, Register src) {
              assert assertion.check((AMD64) asm.target.arch, size, src, null, null);
<span class="line-modified">!             asm.vexPrefix(src, Register.None, dst, size, pp, mmmmm, w, false);</span>
              asm.emitByte(opReverse);
<span class="line-modified">!             asm.emitOperandHelper(src, dst, 0);</span>
          }
  
          public void emitReverse(AMD64Assembler asm, AVXSize size, Register dst, Register src) {
              assert assertion.check((AMD64) asm.target.arch, size, src, null, dst);
<span class="line-modified">!             asm.vexPrefix(src, Register.None, dst, size, pp, mmmmm, w, false);</span>
              asm.emitByte(opReverse);
              asm.emitModRM(src, dst);
          }
      }
  
<span class="line-new-header">--- 1175,49 ---</span>
       * These instructions have two opcodes: op is the forward move instruction with an operand order
       * of RM, and opReverse is the reverse move instruction with an operand order of MR.
       */
      public static final class VexMoveOp extends VexRMOp {
          // @formatter:off
<span class="line-modified">!         public static final VexMoveOp VMOVDQA32 = new VexMoveOp(&quot;VMOVDQA32&quot;, P_66, M_0F, WIG, 0x6F, 0x7F, VEXOpAssertion.AVX1_AVX512F_VL,         EVEXTuple.FVM,       W0);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVDQA64 = new VexMoveOp(&quot;VMOVDQA64&quot;, P_66, M_0F, WIG, 0x6F, 0x7F, VEXOpAssertion.AVX1_AVX512F_VL,         EVEXTuple.FVM,       W1);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVDQU32 = new VexMoveOp(&quot;VMOVDQU32&quot;, P_F3, M_0F, WIG, 0x6F, 0x7F, VEXOpAssertion.AVX1_AVX512F_VL,         EVEXTuple.FVM,       W0);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVDQU64 = new VexMoveOp(&quot;VMOVDQU64&quot;, P_F3, M_0F, WIG, 0x6F, 0x7F, VEXOpAssertion.AVX1_AVX512F_VL,         EVEXTuple.FVM,       W1);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVAPS   = new VexMoveOp(&quot;VMOVAPS&quot;,   P_,   M_0F, WIG, 0x28, 0x29, VEXOpAssertion.AVX1_AVX512F_VL,         EVEXTuple.FVM,       W0);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVAPD   = new VexMoveOp(&quot;VMOVAPD&quot;,   P_66, M_0F, WIG, 0x28, 0x29, VEXOpAssertion.AVX1_AVX512F_VL,         EVEXTuple.FVM,       W1);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVUPS   = new VexMoveOp(&quot;VMOVUPS&quot;,   P_,   M_0F, WIG, 0x10, 0x11, VEXOpAssertion.AVX1_AVX512F_VL,         EVEXTuple.FVM,       W0);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVUPD   = new VexMoveOp(&quot;VMOVUPD&quot;,   P_66, M_0F, WIG, 0x10, 0x11, VEXOpAssertion.AVX1_AVX512F_VL,         EVEXTuple.FVM,       W1);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVSS    = new VexMoveOp(&quot;VMOVSS&quot;,    P_F3, M_0F, WIG, 0x10, 0x11, VEXOpAssertion.AVX1_AVX512F_ALL,        EVEXTuple.T1S_32BIT, W0);</span>
<span class="line-modified">!         public static final VexMoveOp VMOVSD    = new VexMoveOp(&quot;VMOVSD&quot;,    P_F2, M_0F, WIG, 0x10, 0x11, VEXOpAssertion.AVX1_AVX512F_ALL,        EVEXTuple.T1S_64BIT, W1);</span>
<span class="line-added">+         public static final VexMoveOp VMOVD     = new VexMoveOp(&quot;VMOVD&quot;,     P_66, M_0F, W0,  0x6E, 0x7E, VEXOpAssertion.XMM_CPU_AVX512F_128ONLY, EVEXTuple.T1F_32BIT, W0);</span>
<span class="line-added">+         public static final VexMoveOp VMOVQ     = new VexMoveOp(&quot;VMOVQ&quot;,     P_66, M_0F, W1,  0x6E, 0x7E, VEXOpAssertion.XMM_CPU_AVX512F_128ONLY, EVEXTuple.T1S_64BIT, W1);</span>
          // @formatter:on
  
          private final int opReverse;
  
          private VexMoveOp(String opcode, int pp, int mmmmm, int w, int op, int opReverse) {
<span class="line-modified">!             this(opcode, pp, mmmmm, w, op, opReverse, VEXOpAssertion.AVX1, EVEXTuple.INVALID, WIG);</span>
          }
  
          private VexMoveOp(String opcode, int pp, int mmmmm, int w, int op, int opReverse, VEXOpAssertion assertion) {
<span class="line-modified">!             this(opcode, pp, mmmmm, w, op, opReverse, assertion, EVEXTuple.INVALID, WIG);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private VexMoveOp(String opcode, int pp, int mmmmm, int w, int op, int opReverse, VEXOpAssertion assertion, EVEXTuple evexTuple, int wEvex) {</span>
<span class="line-added">+             super(opcode, pp, mmmmm, w, op, assertion, evexTuple, wEvex);</span>
              this.opReverse = opReverse;
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, AMD64Address dst, Register src) {
              assert assertion.check((AMD64) asm.target.arch, size, src, null, null);
<span class="line-modified">!             boolean useEvex = asm.vexPrefix(src, Register.None, dst, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(opReverse);
<span class="line-modified">!             asm.emitOperandHelper(src, dst, 0, getDisp8Scale(useEvex, size));</span>
          }
  
          public void emitReverse(AMD64Assembler asm, AVXSize size, Register dst, Register src) {
              assert assertion.check((AMD64) asm.target.arch, size, src, null, dst);
<span class="line-modified">!             asm.vexPrefix(src, Register.None, dst, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(opReverse);
              asm.emitModRM(src, dst);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1157,21 ***</span>
          }
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, null, src);
<span class="line-modified">!             asm.vexPrefix(dst, Register.None, src, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src);
              asm.emitByte(imm8);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, AMD64Address src, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, null, null);
<span class="line-modified">!             asm.vexPrefix(dst, Register.None, src, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(dst, src, 1);</span>
              asm.emitByte(imm8);
          }
      }
  
      /**
<span class="line-new-header">--- 1241,21 ---</span>
          }
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, null, src);
<span class="line-modified">!             asm.vexPrefix(dst, Register.None, src, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src);
              asm.emitByte(imm8);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, AMD64Address src, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, null, null);
<span class="line-modified">!             boolean useEvex = asm.vexPrefix(dst, Register.None, src, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(dst, src, 1, getDisp8Scale(useEvex, size));</span>
              asm.emitByte(imm8);
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1192,52 ***</span>
          }
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, src, null, dst);
<span class="line-modified">!             asm.vexPrefix(src, Register.None, dst, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
              asm.emitModRM(src, dst);
              asm.emitByte(imm8);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, AMD64Address dst, Register src, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, src, null, null);
<span class="line-modified">!             asm.vexPrefix(src, Register.None, dst, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(src, dst, 1);</span>
              asm.emitByte(imm8);
          }
      }
  
      /**
       * VEX-encoded instructions with an operand order of RVMR.
       */
      public static class VexRVMROp extends VexOp {
          // @formatter:off
<span class="line-modified">!         public static final VexRVMROp VPBLENDVB  = new VexRVMROp(&quot;VPBLENDVB&quot;,  P_66, M_0F3A, W0, 0x4C, VEXOpAssertion.AVX1_2);</span>
<span class="line-modified">!         public static final VexRVMROp VPBLENDVPS = new VexRVMROp(&quot;VPBLENDVPS&quot;, P_66, M_0F3A, W0, 0x4A, VEXOpAssertion.AVX1);</span>
<span class="line-modified">!         public static final VexRVMROp VPBLENDVPD = new VexRVMROp(&quot;VPBLENDVPD&quot;, P_66, M_0F3A, W0, 0x4B, VEXOpAssertion.AVX1);</span>
          // @formatter:on
  
          protected VexRVMROp(String opcode, int pp, int mmmmm, int w, int op, VEXOpAssertion assertion) {
              super(opcode, pp, mmmmm, w, op, assertion);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register mask, Register src1, Register src2) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, mask, src1, src2);
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src2);
              asm.emitByte(mask.encoding() &lt;&lt; 4);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register mask, Register src1, AMD64Address src2) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, mask, src1, null);
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(dst, src2, 0);</span>
              asm.emitByte(mask.encoding() &lt;&lt; 4);
          }
      }
  
      /**
<span class="line-new-header">--- 1276,52 ---</span>
          }
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, src, null, dst);
<span class="line-modified">!             asm.vexPrefix(src, Register.None, dst, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitModRM(src, dst);
              asm.emitByte(imm8);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, AMD64Address dst, Register src, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, src, null, null);
<span class="line-modified">!             boolean useEvex = asm.vexPrefix(src, Register.None, dst, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(src, dst, 1, getDisp8Scale(useEvex, size));</span>
              asm.emitByte(imm8);
          }
      }
  
      /**
       * VEX-encoded instructions with an operand order of RVMR.
       */
      public static class VexRVMROp extends VexOp {
          // @formatter:off
<span class="line-modified">!         public static final VexRVMROp VPBLENDVB = new VexRVMROp(&quot;VPBLENDVB&quot;, P_66, M_0F3A, W0, 0x4C, VEXOpAssertion.AVX1_2);</span>
<span class="line-modified">!         public static final VexRVMROp VBLENDVPS = new VexRVMROp(&quot;VBLENDVPS&quot;, P_66, M_0F3A, W0, 0x4A, VEXOpAssertion.AVX1);</span>
<span class="line-modified">!         public static final VexRVMROp VBLENDVPD = new VexRVMROp(&quot;VBLENDVPD&quot;, P_66, M_0F3A, W0, 0x4B, VEXOpAssertion.AVX1);</span>
          // @formatter:on
  
          protected VexRVMROp(String opcode, int pp, int mmmmm, int w, int op, VEXOpAssertion assertion) {
              super(opcode, pp, mmmmm, w, op, assertion);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register mask, Register src1, Register src2) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, mask, src1, src2);
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src2);
              asm.emitByte(mask.encoding() &lt;&lt; 4);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register mask, Register src1, AMD64Address src2) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, mask, src1, null);
<span class="line-modified">!             boolean useEvex = asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(dst, src2, 0, getDisp8Scale(useEvex, size));</span>
              asm.emitByte(mask.encoding() &lt;&lt; 4);
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1307,10 ***</span>
<span class="line-new-header">--- 1391,12 ---</span>
          public static final VexRVMOp VPCMPEQQ  = new VexRVMOp(&quot;VPCMPEQQ&quot;,  P_66, M_0F38, WIG, 0x29, VEXOpAssertion.AVX1_2);
          public static final VexRVMOp VPCMPGTB  = new VexRVMOp(&quot;VPCMPGTB&quot;,  P_66, M_0F,   WIG, 0x64, VEXOpAssertion.AVX1_2);
          public static final VexRVMOp VPCMPGTW  = new VexRVMOp(&quot;VPCMPGTW&quot;,  P_66, M_0F,   WIG, 0x65, VEXOpAssertion.AVX1_2);
          public static final VexRVMOp VPCMPGTD  = new VexRVMOp(&quot;VPCMPGTD&quot;,  P_66, M_0F,   WIG, 0x66, VEXOpAssertion.AVX1_2);
          public static final VexRVMOp VPCMPGTQ  = new VexRVMOp(&quot;VPCMPGTQ&quot;,  P_66, M_0F38, WIG, 0x37, VEXOpAssertion.AVX1_2);
<span class="line-added">+         public static final VexRVMOp VFMADD231SS = new VexRVMOp(&quot;VFMADD231SS&quot;, P_66, M_0F38, W0, 0xB9, VEXOpAssertion.FMA);</span>
<span class="line-added">+         public static final VexRVMOp VFMADD231SD = new VexRVMOp(&quot;VFMADD231SD&quot;, P_66, M_0F38, W1, 0xB9, VEXOpAssertion.FMA);</span>
          // @formatter:on
  
          private VexRVMOp(String opcode, int pp, int mmmmm, int w, int op) {
              this(opcode, pp, mmmmm, w, op, VEXOpAssertion.AVX1);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1319,20 ***</span>
              super(opcode, pp, mmmmm, w, op, assertion);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, Register src2) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, src1, src2);
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src2);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, AMD64Address src2) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, src1, null);
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(dst, src2, 0);</span>
          }
      }
  
      public static final class VexGeneralPurposeRVMOp extends VexRVMOp {
          // @formatter:off
<span class="line-new-header">--- 1405,20 ---</span>
              super(opcode, pp, mmmmm, w, op, assertion);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, Register src2) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, src1, src2);
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src2);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, AMD64Address src2) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, src1, null);
<span class="line-modified">!             boolean useEvex = asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(dst, src2, 0, getDisp8Scale(useEvex, size));</span>
          }
      }
  
      public static final class VexGeneralPurposeRVMOp extends VexRVMOp {
          // @formatter:off
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1348,20 ***</span>
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, Register src2) {
              assert assertion.check((AMD64) asm.target.arch, LZ, dst, src1, src2, null);
              assert size == AVXSize.DWORD || size == AVXSize.QWORD;
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, size == AVXSize.DWORD ? W0 : W1, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src2);
          }
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, AMD64Address src2) {
              assert assertion.check((AMD64) asm.target.arch, LZ, dst, src1, null, null);
              assert size == AVXSize.DWORD || size == AVXSize.QWORD;
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, size == AVXSize.DWORD ? W0 : W1, false);</span>
              asm.emitByte(op);
              asm.emitOperandHelper(dst, src2, 0);
          }
      }
  
<span class="line-new-header">--- 1434,20 ---</span>
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, Register src2) {
              assert assertion.check((AMD64) asm.target.arch, LZ, dst, src1, src2, null);
              assert size == AVXSize.DWORD || size == AVXSize.QWORD;
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, size == AVXSize.DWORD ? W0 : W1, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src2);
          }
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, AMD64Address src2) {
              assert assertion.check((AMD64) asm.target.arch, LZ, dst, src1, null, null);
              assert size == AVXSize.DWORD || size == AVXSize.QWORD;
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, size == AVXSize.DWORD ? W0 : W1, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitOperandHelper(dst, src2, 0);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1379,19 ***</span>
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, Register src2) {
              assert assertion.check((AMD64) asm.target.arch, LZ, dst, src2, src1, null);
              assert size == AVXSize.DWORD || size == AVXSize.QWORD;
<span class="line-modified">!             asm.vexPrefix(dst, src2, src1, size, pp, mmmmm, size == AVXSize.DWORD ? W0 : W1, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src1);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, AMD64Address src1, Register src2) {
              assert assertion.check((AMD64) asm.target.arch, LZ, dst, src2, null, null);
              assert size == AVXSize.DWORD || size == AVXSize.QWORD;
<span class="line-modified">!             asm.vexPrefix(dst, src2, src1, size, pp, mmmmm, size == AVXSize.DWORD ? W0 : W1, false);</span>
              asm.emitByte(op);
              asm.emitOperandHelper(dst, src1, 0);
          }
      }
  
<span class="line-new-header">--- 1465,19 ---</span>
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, Register src2) {
              assert assertion.check((AMD64) asm.target.arch, LZ, dst, src2, src1, null);
              assert size == AVXSize.DWORD || size == AVXSize.QWORD;
<span class="line-modified">!             asm.vexPrefix(dst, src2, src1, size, pp, mmmmm, size == AVXSize.DWORD ? W0 : W1, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src1);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, AMD64Address src1, Register src2) {
              assert assertion.check((AMD64) asm.target.arch, LZ, dst, src2, null, null);
              assert size == AVXSize.DWORD || size == AVXSize.QWORD;
<span class="line-modified">!             asm.vexPrefix(dst, src2, src1, size, pp, mmmmm, size == AVXSize.DWORD ? W0 : W1, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitOperandHelper(dst, src1, 0);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1409,19 ***</span>
          }
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, null, null);
<span class="line-modified">!             asm.vexPrefix(AMD64.cpuRegisters[ext], dst, src, size, pp, mmmmm, size == AVXSize.DWORD ? W0 : W1, false);</span>
              asm.emitByte(op);
              asm.emitModRM(ext, src);
          }
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, AMD64Address src) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, null, null);
<span class="line-modified">!             asm.vexPrefix(AMD64.cpuRegisters[ext], dst, src, size, pp, mmmmm, size == AVXSize.DWORD ? W0 : W1, false);</span>
              asm.emitByte(op);
              asm.emitOperandHelper(ext, src, 0);
          }
      }
  
<span class="line-new-header">--- 1495,19 ---</span>
          }
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, null, null);
<span class="line-modified">!             asm.vexPrefix(AMD64.cpuRegisters[ext], dst, src, size, pp, mmmmm, size == AVXSize.DWORD ? W0 : W1, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitModRM(ext, src);
          }
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, AMD64Address src) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, null, null);
<span class="line-modified">!             asm.vexPrefix(AMD64.cpuRegisters[ext], dst, src, size, pp, mmmmm, size == AVXSize.DWORD ? W0 : W1, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitOperandHelper(ext, src, 0);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1450,11 ***</span>
          }
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, null, dst, src);
<span class="line-modified">!             asm.vexPrefix(null, dst, src, size, pp, mmmmm, w, false);</span>
              asm.emitByte(immOp);
              asm.emitModRM(r, src);
              asm.emitByte(imm8);
          }
      }
<span class="line-new-header">--- 1536,11 ---</span>
          }
  
          @Override
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, null, dst, src);
<span class="line-modified">!             asm.vexPrefix(null, dst, src, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(immOp);
              asm.emitModRM(r, src);
              asm.emitByte(imm8);
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1478,20 ***</span>
              this.opReverse = opReverse;
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register mask, AMD64Address src) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, mask, null);
<span class="line-modified">!             asm.vexPrefix(dst, mask, src, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
              asm.emitOperandHelper(dst, src, 0);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, AMD64Address dst, Register mask, Register src) {
              assert assertion.check((AMD64) asm.target.arch, size, src, mask, null);
<span class="line-modified">!             asm.vexPrefix(src, mask, dst, size, pp, mmmmm, w, false);</span>
              asm.emitByte(opReverse);
<span class="line-modified">!             asm.emitOperandHelper(src, dst, 0);</span>
          }
      }
  
      /**
       * VEX-encoded instructions with an operand order of RVMI.
<span class="line-new-header">--- 1564,20 ---</span>
              this.opReverse = opReverse;
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register mask, AMD64Address src) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, mask, null);
<span class="line-modified">!             asm.vexPrefix(dst, mask, src, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitOperandHelper(dst, src, 0);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, AMD64Address dst, Register mask, Register src) {
              assert assertion.check((AMD64) asm.target.arch, size, src, mask, null);
<span class="line-modified">!             boolean useEvex = asm.vexPrefix(src, mask, dst, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(opReverse);
<span class="line-modified">!             asm.emitOperandHelper(src, dst, 0, getDisp8Scale(useEvex, size));</span>
          }
      }
  
      /**
       * VEX-encoded instructions with an operand order of RVMI.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1513,22 ***</span>
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, Register src2, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, src1, src2);
              assert (imm8 &amp; 0xFF) == imm8;
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src2);
              asm.emitByte(imm8);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, AMD64Address src2, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, src1, null);
              assert (imm8 &amp; 0xFF) == imm8;
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(dst, src2, 1);</span>
              asm.emitByte(imm8);
          }
      }
  
      /**
<span class="line-new-header">--- 1599,22 ---</span>
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, Register src2, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, src1, src2);
              assert (imm8 &amp; 0xFF) == imm8;
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src2);
              asm.emitByte(imm8);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, AMD64Address src2, int imm8) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, src1, null);
              assert (imm8 &amp; 0xFF) == imm8;
<span class="line-modified">!             boolean useEvex = asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(dst, src2, 1, getDisp8Scale(useEvex, size));</span>
              asm.emitByte(imm8);
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1626,21 ***</span>
              super(opcode, pp, mmmmm, w, op, VEXOpAssertion.AVX1);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, Register src2, Predicate p) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, src1, src2);
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src2);
              asm.emitByte(p.imm8);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, AMD64Address src2, Predicate p) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, src1, null);
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(dst, src2, 1);</span>
              asm.emitByte(p.imm8);
          }
      }
  
      public final void addl(AMD64Address dst, int imm32) {
<span class="line-new-header">--- 1712,21 ---</span>
              super(opcode, pp, mmmmm, w, op, VEXOpAssertion.AVX1);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, Register src2, Predicate p) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, src1, src2);
<span class="line-modified">!             asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
              asm.emitModRM(dst, src2);
              asm.emitByte(p.imm8);
          }
  
          public void emit(AMD64Assembler asm, AVXSize size, Register dst, Register src1, AMD64Address src2, Predicate p) {
              assert assertion.check((AMD64) asm.target.arch, size, dst, src1, null);
<span class="line-modified">!             boolean useEvex = asm.vexPrefix(dst, src1, src2, size, pp, mmmmm, w, wEvex, false);</span>
              asm.emitByte(op);
<span class="line-modified">!             asm.emitOperandHelper(dst, src2, 1, getDisp8Scale(useEvex, size));</span>
              asm.emitByte(p.imm8);
          }
      }
  
      public final void addl(AMD64Address dst, int imm32) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1880,11 ***</span>
          } else {
              // Note: could eliminate cond. jumps to this jump if condition
              // is the same however, seems to be rather unlikely case.
              // Note: use jccb() if label to be bound is very close to get
              // an 8-bit displacement
<span class="line-modified">!             l.addPatchAt(position());</span>
              emitByte(0x0F);
              emitByte(0x80 | cc.getValue());
              emitInt(0);
          }
  
<span class="line-new-header">--- 1966,11 ---</span>
          } else {
              // Note: could eliminate cond. jumps to this jump if condition
              // is the same however, seems to be rather unlikely case.
              // Note: use jccb() if label to be bound is very close to get
              // an 8-bit displacement
<span class="line-modified">!             l.addPatchAt(position(), this);</span>
              emitByte(0x0F);
              emitByte(0x80 | cc.getValue());
              emitInt(0);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1898,11 ***</span>
              long disp = entry - position();
              // 0111 tttn #8-bit disp
              emitByte(0x70 | cc.getValue());
              emitByte((int) ((disp - shortSize) &amp; 0xFF));
          } else {
<span class="line-modified">!             l.addPatchAt(position());</span>
              emitByte(0x70 | cc.getValue());
              emitByte(0);
          }
      }
  
<span class="line-new-header">--- 1984,11 ---</span>
              long disp = entry - position();
              // 0111 tttn #8-bit disp
              emitByte(0x70 | cc.getValue());
              emitByte((int) ((disp - shortSize) &amp; 0xFF));
          } else {
<span class="line-modified">!             l.addPatchAt(position(), this);</span>
              emitByte(0x70 | cc.getValue());
              emitByte(0);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1927,11 ***</span>
              // By default, forward jumps are always 32-bit displacements, since
              // we can&#39;t yet know where the label will be bound. If you&#39;re sure that
              // the forward jump will not run beyond 256 bytes, use jmpb to
              // force an 8-bit displacement.
  
<span class="line-modified">!             l.addPatchAt(position());</span>
              emitByte(0xE9);
              emitInt(0);
          }
      }
  
<span class="line-new-header">--- 2013,11 ---</span>
              // By default, forward jumps are always 32-bit displacements, since
              // we can&#39;t yet know where the label will be bound. If you&#39;re sure that
              // the forward jump will not run beyond 256 bytes, use jmpb to
              // force an 8-bit displacement.
  
<span class="line-modified">!             l.addPatchAt(position(), this);</span>
              emitByte(0xE9);
              emitInt(0);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1948,18 ***</span>
      }
  
      public final void jmpb(Label l) {
          if (l.isBound()) {
              int shortSize = 2;
<span class="line-modified">!             int entry = l.position();</span>
<span class="line-modified">!             assert isByte((entry - position()) + shortSize) : &quot;Dispacement too large for a short jmp&quot;;</span>
<span class="line-modified">!             long offs = entry - position();</span>
              emitByte(0xEB);
<span class="line-modified">!             emitByte((int) ((offs - shortSize) &amp; 0xFF));</span>
          } else {
<span class="line-modified">! </span>
<span class="line-removed">-             l.addPatchAt(position());</span>
              emitByte(0xEB);
              emitByte(0);
          }
      }
  
<span class="line-new-header">--- 2034,17 ---</span>
      }
  
      public final void jmpb(Label l) {
          if (l.isBound()) {
              int shortSize = 2;
<span class="line-modified">!             // Displacement is relative to byte just after jmpb instruction</span>
<span class="line-modified">!             int displacement = l.position() - position() - shortSize;</span>
<span class="line-modified">!             GraalError.guarantee(isByte(displacement), &quot;Displacement too large to be encoded as a byte: %d&quot;, displacement);</span>
              emitByte(0xEB);
<span class="line-modified">!             emitByte(displacement &amp; 0xFF);</span>
          } else {
<span class="line-modified">!             l.addPatchAt(position(), this);</span>
              emitByte(0xEB);
              emitByte(0);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2292,129 ***</span>
              }
              return;
          }
  
          if (UseAddressNop) {
<span class="line-modified">!             //</span>
<span class="line-modified">!             // Using multi-bytes nops &quot;0x0F 0x1F [Address]&quot; for AMD.</span>
<span class="line-modified">!             // 1: 0x90</span>
<span class="line-modified">!             // 2: 0x66 0x90</span>
<span class="line-removed">-             // 3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)</span>
<span class="line-removed">-             // 4: 0x0F 0x1F 0x40 0x00</span>
<span class="line-removed">-             // 5: 0x0F 0x1F 0x44 0x00 0x00</span>
<span class="line-removed">-             // 6: 0x66 0x0F 0x1F 0x44 0x00 0x00</span>
<span class="line-removed">-             // 7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00</span>
<span class="line-removed">-             // 8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-removed">-             // 9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-removed">-             // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-removed">-             // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // The rest coding is AMD specific - use consecutive Address nops</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // 12: 0x66 0x0F 0x1F 0x44 0x00 0x00 0x66 0x0F 0x1F 0x44 0x00 0x00</span>
<span class="line-removed">-             // 13: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00 0x66 0x0F 0x1F 0x44 0x00 0x00</span>
<span class="line-removed">-             // 14: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00</span>
<span class="line-removed">-             // 15: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00</span>
<span class="line-removed">-             // 16: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-removed">-             // Size prefixes (0x66) are added for larger sizes</span>
<span class="line-removed">- </span>
<span class="line-removed">-             while (i &gt;= 22) {</span>
<span class="line-removed">-                 i -= 11;</span>
<span class="line-removed">-                 emitByte(0x66); // size prefix</span>
<span class="line-removed">-                 emitByte(0x66); // size prefix</span>
<span class="line-removed">-                 emitByte(0x66); // size prefix</span>
<span class="line-removed">-                 addrNop8();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             // Generate first nop for size between 21-12</span>
<span class="line-removed">-             switch (i) {</span>
<span class="line-removed">-                 case 21:</span>
<span class="line-removed">-                     i -= 11;</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     addrNop8();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 20:</span>
<span class="line-removed">-                 case 19:</span>
<span class="line-removed">-                     i -= 10;</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     addrNop8();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 18:</span>
<span class="line-removed">-                 case 17:</span>
<span class="line-removed">-                     i -= 9;</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     addrNop8();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 16:</span>
<span class="line-removed">-                 case 15:</span>
<span class="line-removed">-                     i -= 8;</span>
<span class="line-removed">-                     addrNop8();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 14:</span>
<span class="line-removed">-                 case 13:</span>
<span class="line-removed">-                     i -= 7;</span>
<span class="line-removed">-                     addrNop7();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 12:</span>
<span class="line-removed">-                     i -= 6;</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     addrNop5();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 default:</span>
<span class="line-removed">-                     assert i &lt; 12;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Generate second nop for size between 11-1</span>
<span class="line-removed">-             switch (i) {</span>
<span class="line-removed">-                 case 11:</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     addrNop8();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 10:</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     addrNop8();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 9:</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     addrNop8();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 8:</span>
<span class="line-removed">-                     addrNop8();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 7:</span>
<span class="line-removed">-                     addrNop7();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 6:</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     addrNop5();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 5:</span>
<span class="line-removed">-                     addrNop5();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 4:</span>
<span class="line-removed">-                     addrNop4();</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 3:</span>
<span class="line-removed">-                     // Don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     emitByte(0x90); // nop</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 2:</span>
<span class="line-removed">-                     emitByte(0x66); // size prefix</span>
<span class="line-removed">-                     emitByte(0x90); // nop</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case 1:</span>
<span class="line-removed">-                     emitByte(0x90); // nop</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 default:</span>
<span class="line-removed">-                     assert i == 0;</span>
              }
              return;
          }
  
          // Using nops with size prefixes &quot;0x66 0x90&quot;.
<span class="line-new-header">--- 2377,14 ---</span>
              }
              return;
          }
  
          if (UseAddressNop) {
<span class="line-modified">!             if (UseIntelNops) {</span>
<span class="line-modified">!                 intelNops(i);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 amdNops(i);</span>
              }
              return;
          }
  
          // Using nops with size prefixes &quot;0x66 0x90&quot;.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2481,10 ***</span>
<span class="line-new-header">--- 2451,226 ---</span>
              default:
                  assert i == 0;
          }
      }
  
<span class="line-added">+     private void amdNops(int count) {</span>
<span class="line-added">+         int i = count;</span>
<span class="line-added">+         //</span>
<span class="line-added">+         // Using multi-bytes nops &quot;0x0F 0x1F [Address]&quot; for AMD.</span>
<span class="line-added">+         // 1: 0x90</span>
<span class="line-added">+         // 2: 0x66 0x90</span>
<span class="line-added">+         // 3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)</span>
<span class="line-added">+         // 4: 0x0F 0x1F 0x40 0x00</span>
<span class="line-added">+         // 5: 0x0F 0x1F 0x44 0x00 0x00</span>
<span class="line-added">+         // 6: 0x66 0x0F 0x1F 0x44 0x00 0x00</span>
<span class="line-added">+         // 7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00</span>
<span class="line-added">+         // 8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-added">+         // 9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-added">+         // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-added">+         // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-added">+ </span>
<span class="line-added">+         // The rest coding is AMD specific - use consecutive Address nops</span>
<span class="line-added">+ </span>
<span class="line-added">+         // 12: 0x66 0x0F 0x1F 0x44 0x00 0x00 0x66 0x0F 0x1F 0x44 0x00 0x00</span>
<span class="line-added">+         // 13: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00 0x66 0x0F 0x1F 0x44 0x00 0x00</span>
<span class="line-added">+         // 14: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00</span>
<span class="line-added">+         // 15: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00</span>
<span class="line-added">+         // 16: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-added">+         // Size prefixes (0x66) are added for larger sizes</span>
<span class="line-added">+ </span>
<span class="line-added">+         while (i &gt;= 22) {</span>
<span class="line-added">+             i -= 11;</span>
<span class="line-added">+             emitByte(0x66); // size prefix</span>
<span class="line-added">+             emitByte(0x66); // size prefix</span>
<span class="line-added">+             emitByte(0x66); // size prefix</span>
<span class="line-added">+             addrNop8();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // Generate first nop for size between 21-12</span>
<span class="line-added">+         switch (i) {</span>
<span class="line-added">+             case 21:</span>
<span class="line-added">+                 i -= 11;</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 addrNop8();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 20:</span>
<span class="line-added">+             case 19:</span>
<span class="line-added">+                 i -= 10;</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 addrNop8();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 18:</span>
<span class="line-added">+             case 17:</span>
<span class="line-added">+                 i -= 9;</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 addrNop8();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 16:</span>
<span class="line-added">+             case 15:</span>
<span class="line-added">+                 i -= 8;</span>
<span class="line-added">+                 addrNop8();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 14:</span>
<span class="line-added">+             case 13:</span>
<span class="line-added">+                 i -= 7;</span>
<span class="line-added">+                 addrNop7();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 12:</span>
<span class="line-added">+                 i -= 6;</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 addrNop5();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 assert i &lt; 12;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Generate second nop for size between 11-1</span>
<span class="line-added">+         switch (i) {</span>
<span class="line-added">+             case 11:</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 addrNop8();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 10:</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 addrNop8();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 9:</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 addrNop8();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 8:</span>
<span class="line-added">+                 addrNop8();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 7:</span>
<span class="line-added">+                 addrNop7();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 6:</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 addrNop5();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 5:</span>
<span class="line-added">+                 addrNop5();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 4:</span>
<span class="line-added">+                 addrNop4();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 3:</span>
<span class="line-added">+                 // Don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 emitByte(0x90); // nop</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 2:</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 emitByte(0x90); // nop</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 1:</span>
<span class="line-added">+                 emitByte(0x90); // nop</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 assert i == 0;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @SuppressWarnings(&quot;fallthrough&quot;)</span>
<span class="line-added">+     private void intelNops(int count) {</span>
<span class="line-added">+         //</span>
<span class="line-added">+         // Using multi-bytes nops &quot;0x0F 0x1F [address]&quot; for Intel</span>
<span class="line-added">+         // 1: 0x90</span>
<span class="line-added">+         // 2: 0x66 0x90</span>
<span class="line-added">+         // 3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)</span>
<span class="line-added">+         // 4: 0x0F 0x1F 0x40 0x00</span>
<span class="line-added">+         // 5: 0x0F 0x1F 0x44 0x00 0x00</span>
<span class="line-added">+         // 6: 0x66 0x0F 0x1F 0x44 0x00 0x00</span>
<span class="line-added">+         // 7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00</span>
<span class="line-added">+         // 8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-added">+         // 9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-added">+         // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-added">+         // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00</span>
<span class="line-added">+ </span>
<span class="line-added">+         // The rest coding is Intel specific - don&#39;t use consecutive address nops</span>
<span class="line-added">+ </span>
<span class="line-added">+         // 12: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90</span>
<span class="line-added">+         // 13: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90</span>
<span class="line-added">+         // 14: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90</span>
<span class="line-added">+         // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90</span>
<span class="line-added">+ </span>
<span class="line-added">+         int i = count;</span>
<span class="line-added">+         while (i &gt;= 15) {</span>
<span class="line-added">+             // For Intel don&#39;t generate consecutive addess nops (mix with regular nops)</span>
<span class="line-added">+             i -= 15;</span>
<span class="line-added">+             emitByte(0x66);   // size prefix</span>
<span class="line-added">+             emitByte(0x66);   // size prefix</span>
<span class="line-added">+             emitByte(0x66);   // size prefix</span>
<span class="line-added">+             addrNop8();</span>
<span class="line-added">+             emitByte(0x66);   // size prefix</span>
<span class="line-added">+             emitByte(0x66);   // size prefix</span>
<span class="line-added">+             emitByte(0x66);   // size prefix</span>
<span class="line-added">+             emitByte(0x90);</span>
<span class="line-added">+             // nop</span>
<span class="line-added">+         }</span>
<span class="line-added">+         switch (i) {</span>
<span class="line-added">+             case 14:</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 // fall through</span>
<span class="line-added">+             case 13:</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 // fall through</span>
<span class="line-added">+             case 12:</span>
<span class="line-added">+                 addrNop8();</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 emitByte(0x90);</span>
<span class="line-added">+                 // nop</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 11:</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 // fall through</span>
<span class="line-added">+             case 10:</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 // fall through</span>
<span class="line-added">+             case 9:</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 // fall through</span>
<span class="line-added">+             case 8:</span>
<span class="line-added">+                 addrNop8();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 7:</span>
<span class="line-added">+                 addrNop7();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 6:</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 // fall through</span>
<span class="line-added">+             case 5:</span>
<span class="line-added">+                 addrNop5();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 4:</span>
<span class="line-added">+                 addrNop4();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case 3:</span>
<span class="line-added">+                 // Don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 // fall through</span>
<span class="line-added">+             case 2:</span>
<span class="line-added">+                 emitByte(0x66); // size prefix</span>
<span class="line-added">+                 // fall through</span>
<span class="line-added">+             case 1:</span>
<span class="line-added">+                 emitByte(0x90);</span>
<span class="line-added">+                 // nop</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 assert i == 0;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public final void orl(Register dst, Register src) {
          OR.rmOp.emit(this, DWORD, dst, src);
      }
  
      public final void orl(Register dst, int imm32) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2951,18 ***</span>
  
      public final void xorps(Register dst, Register src) {
          SSEOp.XOR.emit(this, PS, dst, src);
      }
  
<span class="line-modified">!     protected final void decl(Register dst) {</span>
          // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
          prefix(dst);
          emitByte(0xFF);
          emitModRM(1, dst);
      }
  
<span class="line-modified">!     protected final void incl(Register dst) {</span>
          // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
          prefix(dst);
          emitByte(0xFF);
          emitModRM(0, dst);
      }
<span class="line-new-header">--- 3137,18 ---</span>
  
      public final void xorps(Register dst, Register src) {
          SSEOp.XOR.emit(this, PS, dst, src);
      }
  
<span class="line-modified">!     public final void decl(Register dst) {</span>
          // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
          prefix(dst);
          emitByte(0xFF);
          emitModRM(1, dst);
      }
  
<span class="line-modified">!     public final void incl(Register dst) {</span>
          // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
          prefix(dst);
          emitByte(0xFF);
          emitModRM(0, dst);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3003,10 ***</span>
<span class="line-new-header">--- 3189,22 ---</span>
      public final void cdqq() {
          rexw();
          emitByte(0x99);
      }
  
<span class="line-added">+     public final void repStosb() {</span>
<span class="line-added">+         emitByte(0xf3);</span>
<span class="line-added">+         rexw();</span>
<span class="line-added">+         emitByte(0xaa);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public final void repStosq() {</span>
<span class="line-added">+         emitByte(0xf3);</span>
<span class="line-added">+         rexw();</span>
<span class="line-added">+         emitByte(0xab);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public final void cmovq(ConditionFlag cc, Register dst, Register src) {
          prefixq(dst, src);
          emitByte(0x0F);
          emitByte(0x40 | cc.getValue());
          emitModRM(dst, src);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3395,13 ***</span>
              final int imm8 = branchTarget - (branch + 2);
              /*
               * Since a wrongly patched short branch can potentially lead to working but really bad
               * behaving code we should always fail with an exception instead of having an assert.
               */
<span class="line-modified">!             if (!NumUtil.isByte(imm8)) {</span>
<span class="line-removed">-                 throw new InternalError(&quot;branch displacement out of range: &quot; + imm8);</span>
<span class="line-removed">-             }</span>
              emitByte(imm8, branch + 1);
  
          } else {
  
              int off = 1;
<span class="line-new-header">--- 3593,11 ---</span>
              final int imm8 = branchTarget - (branch + 2);
              /*
               * Since a wrongly patched short branch can potentially lead to working but really bad
               * behaving code we should always fail with an exception instead of having an assert.
               */
<span class="line-modified">!             GraalError.guarantee(isByte(imm8), &quot;Displacement too large to be encoded as a byte: %d&quot;, imm8);</span>
              emitByte(imm8, branch + 1);
  
          } else {
  
              int off = 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3633,16 ***</span>
      public final void vpxor(Register dst, Register nds, AMD64Address src) {
          VexRVMOp.VPXOR.emit(this, AVXSize.YMM, dst, nds, src);
      }
  
      public final void vmovdqu(Register dst, AMD64Address src) {
<span class="line-modified">!         VexMoveOp.VMOVDQU.emit(this, AVXSize.YMM, dst, src);</span>
      }
  
      public final void vmovdqu(AMD64Address dst, Register src) {
          assert inRC(XMM, src);
<span class="line-modified">!         VexMoveOp.VMOVDQU.emit(this, AVXSize.YMM, dst, src);</span>
      }
  
      public final void vpmovzxbw(Register dst, AMD64Address src) {
          assert supports(CPUFeature.AVX2);
          VexRMOp.VPMOVZXBW.emit(this, AVXSize.YMM, dst, src);
<span class="line-new-header">--- 3829,16 ---</span>
      public final void vpxor(Register dst, Register nds, AMD64Address src) {
          VexRVMOp.VPXOR.emit(this, AVXSize.YMM, dst, nds, src);
      }
  
      public final void vmovdqu(Register dst, AMD64Address src) {
<span class="line-modified">!         VexMoveOp.VMOVDQU32.emit(this, AVXSize.YMM, dst, src);</span>
      }
  
      public final void vmovdqu(AMD64Address dst, Register src) {
          assert inRC(XMM, src);
<span class="line-modified">!         VexMoveOp.VMOVDQU32.emit(this, AVXSize.YMM, dst, src);</span>
      }
  
      public final void vpmovzxbw(Register dst, AMD64Address src) {
          assert supports(CPUFeature.AVX2);
          VexRMOp.VPMOVZXBW.emit(this, AVXSize.YMM, dst, src);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3658,11 ***</span>
      // This instruction produces ZF or CF flags
      public final void kortestd(Register src1, Register src2) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, src1) &amp;&amp; inRC(MASK, src2);
          // Code: VEX.L0.66.0F.W1 98 /r
<span class="line-modified">!         vexPrefix(src1, Register.None, src2, AVXSize.XMM, P_66, M_0F, W1, true);</span>
          emitByte(0x98);
          emitModRM(src1, src2);
      }
  
      // Insn: KORTESTQ k1, k2
<span class="line-new-header">--- 3854,11 ---</span>
      // This instruction produces ZF or CF flags
      public final void kortestd(Register src1, Register src2) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, src1) &amp;&amp; inRC(MASK, src2);
          // Code: VEX.L0.66.0F.W1 98 /r
<span class="line-modified">!         vexPrefix(src1, Register.None, src2, AVXSize.XMM, P_66, M_0F, W1, W1, true);</span>
          emitByte(0x98);
          emitModRM(src1, src2);
      }
  
      // Insn: KORTESTQ k1, k2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3670,11 ***</span>
      // This instruction produces ZF or CF flags
      public final void kortestq(Register src1, Register src2) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, src1) &amp;&amp; inRC(MASK, src2);
          // Code: VEX.L0.0F.W1 98 /r
<span class="line-modified">!         vexPrefix(src1, Register.None, src2, AVXSize.XMM, P_, M_0F, W1, true);</span>
          emitByte(0x98);
          emitModRM(src1, src2);
      }
  
      public final void kmovd(Register dst, Register src) {
<span class="line-new-header">--- 3866,11 ---</span>
      // This instruction produces ZF or CF flags
      public final void kortestq(Register src1, Register src2) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, src1) &amp;&amp; inRC(MASK, src2);
          // Code: VEX.L0.0F.W1 98 /r
<span class="line-modified">!         vexPrefix(src1, Register.None, src2, AVXSize.XMM, P_, M_0F, W1, W1, true);</span>
          emitByte(0x98);
          emitModRM(src1, src2);
      }
  
      public final void kmovd(Register dst, Register src) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3686,27 ***</span>
          if (inRC(MASK, dst)) {
              if (inRC(MASK, src)) {
                  // kmovd(KRegister dst, KRegister src):
                  // Insn: KMOVD k1, k2/m32
                  // Code: VEX.L0.66.0F.W1 90 /r
<span class="line-modified">!                 vexPrefix(dst, Register.None, src, AVXSize.XMM, P_66, M_0F, W1, true);</span>
                  emitByte(0x90);
                  emitModRM(dst, src);
              } else {
                  // kmovd(KRegister dst, Register src)
                  // Insn: KMOVD k1, r32
                  // Code: VEX.L0.F2.0F.W0 92 /r
<span class="line-modified">!                 vexPrefix(dst, Register.None, src, AVXSize.XMM, P_F2, M_0F, W0, true);</span>
                  emitByte(0x92);
                  emitModRM(dst, src);
              }
          } else {
              if (inRC(MASK, src)) {
                  // kmovd(Register dst, KRegister src)
                  // Insn: KMOVD r32, k1
                  // Code: VEX.L0.F2.0F.W0 93 /r
<span class="line-modified">!                 vexPrefix(dst, Register.None, src, AVXSize.XMM, P_F2, M_0F, W0, true);</span>
                  emitByte(0x93);
                  emitModRM(dst, src);
              } else {
                  throw GraalError.shouldNotReachHere();
              }
<span class="line-new-header">--- 3882,27 ---</span>
          if (inRC(MASK, dst)) {
              if (inRC(MASK, src)) {
                  // kmovd(KRegister dst, KRegister src):
                  // Insn: KMOVD k1, k2/m32
                  // Code: VEX.L0.66.0F.W1 90 /r
<span class="line-modified">!                 vexPrefix(dst, Register.None, src, AVXSize.XMM, P_66, M_0F, W1, W1, true);</span>
                  emitByte(0x90);
                  emitModRM(dst, src);
              } else {
                  // kmovd(KRegister dst, Register src)
                  // Insn: KMOVD k1, r32
                  // Code: VEX.L0.F2.0F.W0 92 /r
<span class="line-modified">!                 vexPrefix(dst, Register.None, src, AVXSize.XMM, P_F2, M_0F, W0, W0, true);</span>
                  emitByte(0x92);
                  emitModRM(dst, src);
              }
          } else {
              if (inRC(MASK, src)) {
                  // kmovd(Register dst, KRegister src)
                  // Insn: KMOVD r32, k1
                  // Code: VEX.L0.F2.0F.W0 93 /r
<span class="line-modified">!                 vexPrefix(dst, Register.None, src, AVXSize.XMM, P_F2, M_0F, W0, W0, true);</span>
                  emitByte(0x93);
                  emitModRM(dst, src);
              } else {
                  throw GraalError.shouldNotReachHere();
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3722,27 ***</span>
          if (inRC(MASK, dst)) {
              if (inRC(MASK, src)) {
                  // kmovq(KRegister dst, KRegister src):
                  // Insn: KMOVQ k1, k2/m64
                  // Code: VEX.L0.0F.W1 90 /r
<span class="line-modified">!                 vexPrefix(dst, Register.None, src, AVXSize.XMM, P_, M_0F, W1, true);</span>
                  emitByte(0x90);
                  emitModRM(dst, src);
              } else {
                  // kmovq(KRegister dst, Register src)
                  // Insn: KMOVQ k1, r64
                  // Code: VEX.L0.F2.0F.W1 92 /r
<span class="line-modified">!                 vexPrefix(dst, Register.None, src, AVXSize.XMM, P_F2, M_0F, W1, true);</span>
                  emitByte(0x92);
                  emitModRM(dst, src);
              }
          } else {
              if (inRC(MASK, src)) {
                  // kmovq(Register dst, KRegister src)
                  // Insn: KMOVQ r64, k1
                  // Code: VEX.L0.F2.0F.W1 93 /r
<span class="line-modified">!                 vexPrefix(dst, Register.None, src, AVXSize.XMM, P_F2, M_0F, W1, true);</span>
                  emitByte(0x93);
                  emitModRM(dst, src);
              } else {
                  throw GraalError.shouldNotReachHere();
              }
<span class="line-new-header">--- 3918,27 ---</span>
          if (inRC(MASK, dst)) {
              if (inRC(MASK, src)) {
                  // kmovq(KRegister dst, KRegister src):
                  // Insn: KMOVQ k1, k2/m64
                  // Code: VEX.L0.0F.W1 90 /r
<span class="line-modified">!                 vexPrefix(dst, Register.None, src, AVXSize.XMM, P_, M_0F, W1, W1, true);</span>
                  emitByte(0x90);
                  emitModRM(dst, src);
              } else {
                  // kmovq(KRegister dst, Register src)
                  // Insn: KMOVQ k1, r64
                  // Code: VEX.L0.F2.0F.W1 92 /r
<span class="line-modified">!                 vexPrefix(dst, Register.None, src, AVXSize.XMM, P_F2, M_0F, W1, W1, true);</span>
                  emitByte(0x92);
                  emitModRM(dst, src);
              }
          } else {
              if (inRC(MASK, src)) {
                  // kmovq(Register dst, KRegister src)
                  // Insn: KMOVQ r64, k1
                  // Code: VEX.L0.F2.0F.W1 93 /r
<span class="line-modified">!                 vexPrefix(dst, Register.None, src, AVXSize.XMM, P_F2, M_0F, W1, W1, true);</span>
                  emitByte(0x93);
                  emitModRM(dst, src);
              } else {
                  throw GraalError.shouldNotReachHere();
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3753,40 ***</span>
  
      public final void ktestd(Register src1, Register src2) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, src1) &amp;&amp; inRC(MASK, src2);
          // Code: VEX.L0.66.0F.W1 99 /r
<span class="line-modified">!         vexPrefix(src1, Register.None, src2, AVXSize.XMM, P_66, M_0F, W1, true);</span>
          emitByte(0x99);
          emitModRM(src1, src2);
      }
  
      public final void evmovdqu64(Register dst, AMD64Address src) {
          assert supports(CPUFeature.AVX512F);
          assert inRC(XMM, dst);
          evexPrefix(dst, Register.None, Register.None, src, AVXSize.ZMM, P_F3, M_0F, W1, Z0, B0);
          emitByte(0x6F);
<span class="line-modified">!         emitEVEXOperandHelper(dst, src, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VPMOVZXBW zmm1, m256
  
      public final void evpmovzxbw(Register dst, AMD64Address src) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(XMM, dst);
          // Code: EVEX.512.66.0F38.WIG 30 /r
          evexPrefix(dst, Register.None, Register.None, src, AVXSize.ZMM, P_66, M_0F38, WIG, Z0, B0);
          emitByte(0x30);
<span class="line-modified">!         emitEVEXOperandHelper(dst, src, 0, EVEXTuple.HVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      public final void evpcmpeqb(Register kdst, Register nds, AMD64Address src) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, kdst) &amp;&amp; inRC(XMM, nds);
          evexPrefix(kdst, Register.None, nds, src, AVXSize.ZMM, P_66, M_0F, WIG, Z0, B0);
          emitByte(0x74);
<span class="line-modified">!         emitEVEXOperandHelper(kdst, src, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VMOVDQU16 zmm1 {k1}{z}, zmm2/m512
      // -----
      // Insn: VMOVDQU16 zmm1, m512
<span class="line-new-header">--- 3949,40 ---</span>
  
      public final void ktestd(Register src1, Register src2) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, src1) &amp;&amp; inRC(MASK, src2);
          // Code: VEX.L0.66.0F.W1 99 /r
<span class="line-modified">!         vexPrefix(src1, Register.None, src2, AVXSize.XMM, P_66, M_0F, W1, W1, true);</span>
          emitByte(0x99);
          emitModRM(src1, src2);
      }
  
      public final void evmovdqu64(Register dst, AMD64Address src) {
          assert supports(CPUFeature.AVX512F);
          assert inRC(XMM, dst);
          evexPrefix(dst, Register.None, Register.None, src, AVXSize.ZMM, P_F3, M_0F, W1, Z0, B0);
          emitByte(0x6F);
<span class="line-modified">!         emitOperandHelper(dst, src, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VPMOVZXBW zmm1, m256
  
      public final void evpmovzxbw(Register dst, AMD64Address src) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(XMM, dst);
          // Code: EVEX.512.66.0F38.WIG 30 /r
          evexPrefix(dst, Register.None, Register.None, src, AVXSize.ZMM, P_66, M_0F38, WIG, Z0, B0);
          emitByte(0x30);
<span class="line-modified">!         emitOperandHelper(dst, src, 0, EVEXTuple.HVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      public final void evpcmpeqb(Register kdst, Register nds, AMD64Address src) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, kdst) &amp;&amp; inRC(XMM, nds);
          evexPrefix(kdst, Register.None, nds, src, AVXSize.ZMM, P_66, M_0F, WIG, Z0, B0);
          emitByte(0x74);
<span class="line-modified">!         emitOperandHelper(kdst, src, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VMOVDQU16 zmm1 {k1}{z}, zmm2/m512
      // -----
      // Insn: VMOVDQU16 zmm1, m512
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3795,22 ***</span>
          assert supports(CPUFeature.AVX512BW);
          assert inRC(XMM, dst);
          // Code: EVEX.512.F2.0F.W1 6F /r
          evexPrefix(dst, Register.None, Register.None, src, AVXSize.ZMM, P_F2, M_0F, W1, Z0, B0);
          emitByte(0x6F);
<span class="line-modified">!         emitEVEXOperandHelper(dst, src, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VMOVDQU16 zmm1, k1:z, m512
  
      public final void evmovdqu16(Register dst, Register mask, AMD64Address src) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(XMM, dst) &amp;&amp; inRC(MASK, mask);
          // Code: EVEX.512.F2.0F.W1 6F /r
          evexPrefix(dst, mask, Register.None, src, AVXSize.ZMM, P_F2, M_0F, W1, Z1, B0);
          emitByte(0x6F);
<span class="line-modified">!         emitEVEXOperandHelper(dst, src, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VMOVDQU16 zmm2/m512 {k1}{z}, zmm1
      // -----
      // Insn: VMOVDQU16 m512, zmm1
<span class="line-new-header">--- 3991,22 ---</span>
          assert supports(CPUFeature.AVX512BW);
          assert inRC(XMM, dst);
          // Code: EVEX.512.F2.0F.W1 6F /r
          evexPrefix(dst, Register.None, Register.None, src, AVXSize.ZMM, P_F2, M_0F, W1, Z0, B0);
          emitByte(0x6F);
<span class="line-modified">!         emitOperandHelper(dst, src, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VMOVDQU16 zmm1, k1:z, m512
  
      public final void evmovdqu16(Register dst, Register mask, AMD64Address src) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(XMM, dst) &amp;&amp; inRC(MASK, mask);
          // Code: EVEX.512.F2.0F.W1 6F /r
          evexPrefix(dst, mask, Register.None, src, AVXSize.ZMM, P_F2, M_0F, W1, Z1, B0);
          emitByte(0x6F);
<span class="line-modified">!         emitOperandHelper(dst, src, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VMOVDQU16 zmm2/m512 {k1}{z}, zmm1
      // -----
      // Insn: VMOVDQU16 m512, zmm1
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3819,22 ***</span>
          assert supports(CPUFeature.AVX512BW);
          assert inRC(XMM, src);
          // Code: EVEX.512.F2.0F.W1 7F /r
          evexPrefix(src, Register.None, Register.None, dst, AVXSize.ZMM, P_F2, M_0F, W1, Z0, B0);
          emitByte(0x7F);
<span class="line-modified">!         emitEVEXOperandHelper(src, dst, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VMOVDQU16 m512, k1, zmm1
  
      public final void evmovdqu16(AMD64Address dst, Register mask, Register src) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, mask) &amp;&amp; inRC(XMM, src);
          // Code: EVEX.512.F2.0F.W1 7F /r
          evexPrefix(src, mask, Register.None, dst, AVXSize.ZMM, P_F2, M_0F, W1, Z0, B0);
          emitByte(0x7F);
<span class="line-modified">!         emitEVEXOperandHelper(src, dst, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VPBROADCASTW zmm1 {k1}{z}, reg
      // -----
      // Insn: VPBROADCASTW zmm1, reg
<span class="line-new-header">--- 4015,22 ---</span>
          assert supports(CPUFeature.AVX512BW);
          assert inRC(XMM, src);
          // Code: EVEX.512.F2.0F.W1 7F /r
          evexPrefix(src, Register.None, Register.None, dst, AVXSize.ZMM, P_F2, M_0F, W1, Z0, B0);
          emitByte(0x7F);
<span class="line-modified">!         emitOperandHelper(src, dst, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VMOVDQU16 m512, k1, zmm1
  
      public final void evmovdqu16(AMD64Address dst, Register mask, Register src) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, mask) &amp;&amp; inRC(XMM, src);
          // Code: EVEX.512.F2.0F.W1 7F /r
          evexPrefix(src, mask, Register.None, dst, AVXSize.ZMM, P_F2, M_0F, W1, Z0, B0);
          emitByte(0x7F);
<span class="line-modified">!         emitOperandHelper(src, dst, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VPBROADCASTW zmm1 {k1}{z}, reg
      // -----
      // Insn: VPBROADCASTW zmm1, reg
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3885,22 ***</span>
          assert supports(CPUFeature.AVX512BW);
          assert inRC(XMM, src);
          // Code: EVEX.512.F3.0F38.W0 30 /r
          evexPrefix(src, Register.None, Register.None, dst, AVXSize.ZMM, P_F3, M_0F38, W0, Z0, B0);
          emitByte(0x30);
<span class="line-modified">!         emitEVEXOperandHelper(src, dst, 0, EVEXTuple.HVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VPMOVWB m256, k1, zmm2
  
      public final void evpmovwb(AMD64Address dst, Register mask, Register src) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, mask) &amp;&amp; inRC(XMM, src);
          // Code: EVEX.512.F3.0F38.W0 30 /r
          evexPrefix(src, mask, Register.None, dst, AVXSize.ZMM, P_F3, M_0F38, W0, Z0, B0);
          emitByte(0x30);
<span class="line-modified">!         emitEVEXOperandHelper(src, dst, 0, EVEXTuple.HVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VPMOVZXBW zmm1 {k1}{z}, ymm2/m256
      // -----
      // Insn: VPMOVZXBW zmm1, k1, m256
<span class="line-new-header">--- 4081,22 ---</span>
          assert supports(CPUFeature.AVX512BW);
          assert inRC(XMM, src);
          // Code: EVEX.512.F3.0F38.W0 30 /r
          evexPrefix(src, Register.None, Register.None, dst, AVXSize.ZMM, P_F3, M_0F38, W0, Z0, B0);
          emitByte(0x30);
<span class="line-modified">!         emitOperandHelper(src, dst, 0, EVEXTuple.HVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VPMOVWB m256, k1, zmm2
  
      public final void evpmovwb(AMD64Address dst, Register mask, Register src) {
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, mask) &amp;&amp; inRC(XMM, src);
          // Code: EVEX.512.F3.0F38.W0 30 /r
          evexPrefix(src, mask, Register.None, dst, AVXSize.ZMM, P_F3, M_0F38, W0, Z0, B0);
          emitByte(0x30);
<span class="line-modified">!         emitOperandHelper(src, dst, 0, EVEXTuple.HVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
      // Insn: VPMOVZXBW zmm1 {k1}{z}, ymm2/m256
      // -----
      // Insn: VPMOVZXBW zmm1, k1, m256
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3909,9 ***</span>
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, mask) &amp;&amp; inRC(XMM, dst);
          // Code: EVEX.512.66.0F38.WIG 30 /r
          evexPrefix(dst, mask, Register.None, src, AVXSize.ZMM, P_66, M_0F38, WIG, Z0, B0);
          emitByte(0x30);
<span class="line-modified">!         emitEVEXOperandHelper(dst, src, 0, EVEXTuple.HVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
  }
<span class="line-new-header">--- 4105,9 ---</span>
          assert supports(CPUFeature.AVX512BW);
          assert inRC(MASK, mask) &amp;&amp; inRC(XMM, dst);
          // Code: EVEX.512.66.0F38.WIG 30 /r
          evexPrefix(dst, mask, Register.None, src, AVXSize.ZMM, P_66, M_0F38, WIG, Z0, B0);
          emitByte(0x30);
<span class="line-modified">!         emitOperandHelper(dst, src, 0, EVEXTuple.HVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
      }
  
  }
</pre>
<center><a href="AMD64AsmOptions.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64BaseAssembler.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
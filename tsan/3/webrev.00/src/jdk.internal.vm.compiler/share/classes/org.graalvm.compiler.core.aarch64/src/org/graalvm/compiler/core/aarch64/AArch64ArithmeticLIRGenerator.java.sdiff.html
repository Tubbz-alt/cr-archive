<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64ArithmeticLIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64TestBitAndBranchTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64LIRGenerator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64ArithmeticLIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package org.graalvm.compiler.core.aarch64;
 27 
 28 import static jdk.vm.ci.aarch64.AArch64Kind.DWORD;
 29 import static jdk.vm.ci.aarch64.AArch64Kind.QWORD;
 30 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 31 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 32 import static org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp.BitManipulationOpCode.BSR;
 33 import static org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp.BitManipulationOpCode.CLZ;
 34 import static org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp.BitManipulationOpCode.CTZ;

 35 
 36 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 37 import org.graalvm.compiler.core.common.LIRKind;
 38 import org.graalvm.compiler.core.common.NumUtil;
 39 import org.graalvm.compiler.core.common.calc.FloatConvert;
 40 import org.graalvm.compiler.debug.GraalError;
 41 import org.graalvm.compiler.lir.ConstantValue;
 42 import org.graalvm.compiler.lir.LIRFrameState;
 43 import org.graalvm.compiler.lir.Variable;
 44 import org.graalvm.compiler.lir.aarch64.AArch64AddressValue;
 45 import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticLIRGeneratorTool;
 46 import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp;
 47 import org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp;
 48 import org.graalvm.compiler.lir.aarch64.AArch64Move.LoadOp;
 49 import org.graalvm.compiler.lir.aarch64.AArch64Move.StoreConstantOp;
 50 import org.graalvm.compiler.lir.aarch64.AArch64Move.StoreOp;
 51 import org.graalvm.compiler.lir.aarch64.AArch64ReinterpretOp;
 52 import org.graalvm.compiler.lir.aarch64.AArch64SignExtendOp;
 53 import org.graalvm.compiler.lir.aarch64.AArch64Unary;
 54 import org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator;
 55 
 56 import jdk.vm.ci.aarch64.AArch64Kind;
 57 import jdk.vm.ci.meta.AllocatableValue;
 58 import jdk.vm.ci.meta.JavaConstant;
 59 import jdk.vm.ci.meta.PlatformKind;
 60 import jdk.vm.ci.meta.Value;
 61 import jdk.vm.ci.meta.ValueKind;
 62 
 63 public class AArch64ArithmeticLIRGenerator extends ArithmeticLIRGenerator implements AArch64ArithmeticLIRGeneratorTool {
 64 






 65     @Override
 66     public AArch64LIRGenerator getLIRGen() {
 67         return (AArch64LIRGenerator) super.getLIRGen();
 68     }
 69 









 70     @Override
 71     protected boolean isNumericInteger(PlatformKind kind) {
 72         return ((AArch64Kind) kind).isInteger();
 73     }
 74 
 75     @Override
 76     protected Variable emitAdd(LIRKind resultKind, Value a, Value b, boolean setFlags) {
 77         if (isNumericInteger(a.getPlatformKind())) {
 78             AArch64ArithmeticOp op = setFlags ? AArch64ArithmeticOp.ADDS : AArch64ArithmeticOp.ADD;
 79             return emitBinary(resultKind, op, true, a, b);
 80         } else {
 81             assert !setFlags : &quot;Cannot set flags on floating point arithmetic&quot;;
 82             return emitBinary(resultKind, AArch64ArithmeticOp.FADD, true, a, b);
 83         }
 84     }
 85 
 86     @Override
 87     protected Variable emitSub(LIRKind resultKind, Value a, Value b, boolean setFlags) {
 88         if (isNumericInteger(a.getPlatformKind())) {
 89             AArch64ArithmeticOp op = setFlags ? AArch64ArithmeticOp.SUBS : AArch64ArithmeticOp.SUB;
</pre>
<hr />
<pre>
187     public Value emitShr(Value a, Value b) {
188         assert isNumericInteger(a.getPlatformKind());
189         return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.ASHR, false, a, b);
190     }
191 
192     @Override
193     public Value emitUShr(Value a, Value b) {
194         assert isNumericInteger(a.getPlatformKind());
195         return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.LSHR, false, a, b);
196     }
197 
198     @Override
199     public Value emitFloatConvert(FloatConvert op, Value inputVal) {
200         PlatformKind resultPlatformKind = getFloatConvertResultKind(op);
201         LIRKind resultLirKind = LIRKind.combine(inputVal).changeType(resultPlatformKind);
202         Variable result = getLIRGen().newVariable(resultLirKind);
203         getLIRGen().append(new AArch64FloatConvertOp(op, result, asAllocatable(inputVal)));
204         return result;
205     }
206 
<span class="line-modified">207     public Value emitMAdd(Value a, Value b, Value c) {</span>
<span class="line-modified">208         return emitMultiplyAddSub(AArch64ArithmeticOp.ADD, a, b, c);</span>
209     }
210 
<span class="line-modified">211     public Value emitMSub(Value a, Value b, Value c) {</span>
<span class="line-modified">212         return emitMultiplyAddSub(AArch64ArithmeticOp.SUB, a, b, c);</span>
213     }
214 
215     private Value emitMultiplyAddSub(AArch64ArithmeticOp op, Value a, Value b, Value c) {
<span class="line-modified">216         assert isNumericInteger(a.getPlatformKind());</span>
<span class="line-modified">217         assert isNumericInteger(b.getPlatformKind());</span>
<span class="line-modified">218         assert isNumericInteger(c.getPlatformKind());</span>















219 
<span class="line-removed">220         Variable result = getLIRGen().newVariable(LIRKind.combine(a, b, c));</span>
221         AllocatableValue x = moveSp(asAllocatable(a));
222         AllocatableValue y = moveSp(asAllocatable(b));
223         AllocatableValue z = moveSp(asAllocatable(c));
224         getLIRGen().append(new AArch64ArithmeticOp.MultiplyAddSubOp(op, result, x, y, z));
225         return result;
226     }
227 
228     private static PlatformKind getFloatConvertResultKind(FloatConvert op) {
229         switch (op) {
230             case F2I:
231             case D2I:
232                 return AArch64Kind.DWORD;
233             case F2L:
234             case D2L:
235                 return AArch64Kind.QWORD;
236             case I2F:
237             case L2F:
238             case D2F:
239                 return AArch64Kind.SINGLE;
240             case I2D:
</pre>
<hr />
<pre>
400     }
401 
402     @Override
403     public Value emitMathAbs(Value input) {
404         return emitUnary(getOpCode(input, AArch64ArithmeticOp.ABS, AArch64ArithmeticOp.FABS), input);
405     }
406 
407     @Override
408     public Value emitMathSqrt(Value input) {
409         assert input.getPlatformKind() == AArch64Kind.DOUBLE;
410         return emitUnary(AArch64ArithmeticOp.SQRT, input);
411     }
412 
413     @Override
414     public Variable emitBitScanForward(Value value) {
415         throw GraalError.unimplemented();
416     }
417 
418     @Override
419     public Value emitBitCount(Value operand) {
<span class="line-modified">420         throw GraalError.unimplemented(&quot;AArch64 ISA does not offer way to implement this more efficiently than a simple Java algorithm.&quot;);</span>



421     }
422 
423     @Override
424     public Value emitBitScanReverse(Value value) {
425         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AArch64Kind.DWORD));
<span class="line-modified">426         getLIRGen().append(new AArch64BitManipulationOp(BSR, result, asAllocatable(value)));</span>
427         return result;
428     }
429 





430     @Override
431     public Value emitCountLeadingZeros(Value value) {
432         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AArch64Kind.DWORD));
<span class="line-modified">433         getLIRGen().append(new AArch64BitManipulationOp(CLZ, result, asAllocatable(value)));</span>
434         return result;
435     }
436 
437     @Override
438     public Value emitCountTrailingZeros(Value value) {
439         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AArch64Kind.DWORD));
<span class="line-modified">440         getLIRGen().append(new AArch64BitManipulationOp(CTZ, result, asAllocatable(value)));</span>
441         return result;
442     }
443 
444     private Variable emitUnary(AArch64ArithmeticOp op, Value inputVal) {
445         AllocatableValue input = asAllocatable(inputVal);
446         Variable result = getLIRGen().newVariable(LIRKind.combine(input));
447         getLIRGen().append(new AArch64ArithmeticOp.UnaryOp(op, result, input));
448         return result;
449     }
450 
451     private AllocatableValue moveSp(AllocatableValue val) {
452         return getLIRGen().moveSp(val);
453     }
454 
455     /**
456      * Returns the opcode depending on the platform kind of val.
457      */
458     private AArch64ArithmeticOp getOpCode(Value val, AArch64ArithmeticOp intOp, AArch64ArithmeticOp floatOp) {
459         return isNumericInteger(val.getPlatformKind()) ? intOp : floatOp;
460     }
</pre>
<hr />
<pre>
467         return result;
468     }
469 
470     @Override
471     public void emitStore(ValueKind&lt;?&gt; lirKind, Value address, Value inputVal, LIRFrameState state) {
472         AArch64AddressValue storeAddress = getLIRGen().asAddressValue(address);
473         AArch64Kind kind = (AArch64Kind) lirKind.getPlatformKind();
474 
475         if (isJavaConstant(inputVal) &amp;&amp; kind.isInteger()) {
476             JavaConstant c = asJavaConstant(inputVal);
477             if (c.isDefaultForKind()) {
478                 // We can load 0 directly into integer registers
479                 getLIRGen().append(new StoreConstantOp(kind, storeAddress, c, state));
480                 return;
481             }
482         }
483         AllocatableValue input = asAllocatable(inputVal);
484         getLIRGen().append(new StoreOp(kind, storeAddress, input, state));
485     }
486 
<span class="line-removed">487     @Override</span>
<span class="line-removed">488     public void emitCompareOp(AArch64Kind cmpKind, Variable left, Value right) {</span>
<span class="line-removed">489         throw GraalError.unimplemented();</span>
<span class="line-removed">490     }</span>
<span class="line-removed">491 </span>
492     @Override
493     public Value emitRound(Value value, RoundingMode mode) {
494         AArch64ArithmeticOp op;
495         switch (mode) {
496             case NEAREST:
497                 op = AArch64ArithmeticOp.FRINTN;
498                 break;
499             case UP:
500                 op = AArch64ArithmeticOp.FRINTP;
501                 break;
502             case DOWN:
503                 op = AArch64ArithmeticOp.FRINTM;
504                 break;
505             default:
506                 throw GraalError.shouldNotReachHere();
507         }
508 
509         return emitUnary(op, value);
510     }
511 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package org.graalvm.compiler.core.aarch64;
 27 
 28 import static jdk.vm.ci.aarch64.AArch64Kind.DWORD;
 29 import static jdk.vm.ci.aarch64.AArch64Kind.QWORD;
 30 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 31 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 32 import static org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp.BitManipulationOpCode.BSR;
 33 import static org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp.BitManipulationOpCode.CLZ;
 34 import static org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp.BitManipulationOpCode.CTZ;
<span class="line-added"> 35 import static org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp.BitManipulationOpCode.POPCNT;</span>
 36 
 37 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 38 import org.graalvm.compiler.core.common.LIRKind;
 39 import org.graalvm.compiler.core.common.NumUtil;
 40 import org.graalvm.compiler.core.common.calc.FloatConvert;
 41 import org.graalvm.compiler.debug.GraalError;
 42 import org.graalvm.compiler.lir.ConstantValue;
 43 import org.graalvm.compiler.lir.LIRFrameState;
 44 import org.graalvm.compiler.lir.Variable;
 45 import org.graalvm.compiler.lir.aarch64.AArch64AddressValue;
 46 import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticLIRGeneratorTool;
 47 import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp;
 48 import org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp;
 49 import org.graalvm.compiler.lir.aarch64.AArch64Move.LoadOp;
 50 import org.graalvm.compiler.lir.aarch64.AArch64Move.StoreConstantOp;
 51 import org.graalvm.compiler.lir.aarch64.AArch64Move.StoreOp;
 52 import org.graalvm.compiler.lir.aarch64.AArch64ReinterpretOp;
 53 import org.graalvm.compiler.lir.aarch64.AArch64SignExtendOp;
 54 import org.graalvm.compiler.lir.aarch64.AArch64Unary;
 55 import org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator;
 56 
 57 import jdk.vm.ci.aarch64.AArch64Kind;
 58 import jdk.vm.ci.meta.AllocatableValue;
 59 import jdk.vm.ci.meta.JavaConstant;
 60 import jdk.vm.ci.meta.PlatformKind;
 61 import jdk.vm.ci.meta.Value;
 62 import jdk.vm.ci.meta.ValueKind;
 63 
 64 public class AArch64ArithmeticLIRGenerator extends ArithmeticLIRGenerator implements AArch64ArithmeticLIRGeneratorTool {
 65 
<span class="line-added"> 66     public AArch64ArithmeticLIRGenerator(AllocatableValue nullRegisterValue) {</span>
<span class="line-added"> 67         this.nullRegisterValue = nullRegisterValue;</span>
<span class="line-added"> 68     }</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70     private final AllocatableValue nullRegisterValue;</span>
<span class="line-added"> 71 </span>
 72     @Override
 73     public AArch64LIRGenerator getLIRGen() {
 74         return (AArch64LIRGenerator) super.getLIRGen();
 75     }
 76 
<span class="line-added"> 77     public boolean mustReplaceNullWithNullRegister(JavaConstant nullConstant) {</span>
<span class="line-added"> 78         /* Uncompressed null pointers only */</span>
<span class="line-added"> 79         return nullRegisterValue != null &amp;&amp; JavaConstant.NULL_POINTER.equals(nullConstant);</span>
<span class="line-added"> 80     }</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82     public AllocatableValue getNullRegisterValue() {</span>
<span class="line-added"> 83         return nullRegisterValue;</span>
<span class="line-added"> 84     }</span>
<span class="line-added"> 85 </span>
 86     @Override
 87     protected boolean isNumericInteger(PlatformKind kind) {
 88         return ((AArch64Kind) kind).isInteger();
 89     }
 90 
 91     @Override
 92     protected Variable emitAdd(LIRKind resultKind, Value a, Value b, boolean setFlags) {
 93         if (isNumericInteger(a.getPlatformKind())) {
 94             AArch64ArithmeticOp op = setFlags ? AArch64ArithmeticOp.ADDS : AArch64ArithmeticOp.ADD;
 95             return emitBinary(resultKind, op, true, a, b);
 96         } else {
 97             assert !setFlags : &quot;Cannot set flags on floating point arithmetic&quot;;
 98             return emitBinary(resultKind, AArch64ArithmeticOp.FADD, true, a, b);
 99         }
100     }
101 
102     @Override
103     protected Variable emitSub(LIRKind resultKind, Value a, Value b, boolean setFlags) {
104         if (isNumericInteger(a.getPlatformKind())) {
105             AArch64ArithmeticOp op = setFlags ? AArch64ArithmeticOp.SUBS : AArch64ArithmeticOp.SUB;
</pre>
<hr />
<pre>
203     public Value emitShr(Value a, Value b) {
204         assert isNumericInteger(a.getPlatformKind());
205         return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.ASHR, false, a, b);
206     }
207 
208     @Override
209     public Value emitUShr(Value a, Value b) {
210         assert isNumericInteger(a.getPlatformKind());
211         return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.LSHR, false, a, b);
212     }
213 
214     @Override
215     public Value emitFloatConvert(FloatConvert op, Value inputVal) {
216         PlatformKind resultPlatformKind = getFloatConvertResultKind(op);
217         LIRKind resultLirKind = LIRKind.combine(inputVal).changeType(resultPlatformKind);
218         Variable result = getLIRGen().newVariable(resultLirKind);
219         getLIRGen().append(new AArch64FloatConvertOp(op, result, asAllocatable(inputVal)));
220         return result;
221     }
222 
<span class="line-modified">223     Value emitIntegerMAdd(Value a, Value b, Value c, boolean isI2L) {</span>
<span class="line-modified">224         return emitMultiplyAddSub(isI2L ? AArch64ArithmeticOp.SMADDL : AArch64ArithmeticOp.MADD, a, b, c);</span>
225     }
226 
<span class="line-modified">227     Value emitIntegerMSub(Value a, Value b, Value c, boolean isI2L) {</span>
<span class="line-modified">228         return emitMultiplyAddSub(isI2L ? AArch64ArithmeticOp.SMSUBL : AArch64ArithmeticOp.MSUB, a, b, c);</span>
229     }
230 
231     private Value emitMultiplyAddSub(AArch64ArithmeticOp op, Value a, Value b, Value c) {
<span class="line-modified">232         assert a.getPlatformKind() == b.getPlatformKind();</span>
<span class="line-modified">233         Variable result;</span>
<span class="line-modified">234         if (op == AArch64ArithmeticOp.SMADDL || op == AArch64ArithmeticOp.SMSUBL) {</span>
<span class="line-added">235             // For signed multiply int and then add/sub long.</span>
<span class="line-added">236             assert a.getPlatformKind() != c.getPlatformKind();</span>
<span class="line-added">237             result = getLIRGen().newVariable(LIRKind.combine(c));</span>
<span class="line-added">238         } else {</span>
<span class="line-added">239             assert a.getPlatformKind() == c.getPlatformKind();</span>
<span class="line-added">240             if (op == AArch64ArithmeticOp.FADD) {</span>
<span class="line-added">241                 // For floating-point Math.fma intrinsic.</span>
<span class="line-added">242                 assert a.getPlatformKind() == AArch64Kind.SINGLE || a.getPlatformKind() == AArch64Kind.DOUBLE;</span>
<span class="line-added">243             } else {</span>
<span class="line-added">244                 // For int/long multiply add or sub.</span>
<span class="line-added">245                 assert op == AArch64ArithmeticOp.MADD || op == AArch64ArithmeticOp.MSUB;</span>
<span class="line-added">246                 assert isNumericInteger(a.getPlatformKind());</span>
<span class="line-added">247             }</span>
<span class="line-added">248             result = getLIRGen().newVariable(LIRKind.combine(a, b, c));</span>
<span class="line-added">249         }</span>
250 

251         AllocatableValue x = moveSp(asAllocatable(a));
252         AllocatableValue y = moveSp(asAllocatable(b));
253         AllocatableValue z = moveSp(asAllocatable(c));
254         getLIRGen().append(new AArch64ArithmeticOp.MultiplyAddSubOp(op, result, x, y, z));
255         return result;
256     }
257 
258     private static PlatformKind getFloatConvertResultKind(FloatConvert op) {
259         switch (op) {
260             case F2I:
261             case D2I:
262                 return AArch64Kind.DWORD;
263             case F2L:
264             case D2L:
265                 return AArch64Kind.QWORD;
266             case I2F:
267             case L2F:
268             case D2F:
269                 return AArch64Kind.SINGLE;
270             case I2D:
</pre>
<hr />
<pre>
430     }
431 
432     @Override
433     public Value emitMathAbs(Value input) {
434         return emitUnary(getOpCode(input, AArch64ArithmeticOp.ABS, AArch64ArithmeticOp.FABS), input);
435     }
436 
437     @Override
438     public Value emitMathSqrt(Value input) {
439         assert input.getPlatformKind() == AArch64Kind.DOUBLE;
440         return emitUnary(AArch64ArithmeticOp.SQRT, input);
441     }
442 
443     @Override
444     public Variable emitBitScanForward(Value value) {
445         throw GraalError.unimplemented();
446     }
447 
448     @Override
449     public Value emitBitCount(Value operand) {
<span class="line-modified">450         assert ((AArch64Kind) operand.getPlatformKind()).isInteger();</span>
<span class="line-added">451         Variable result = getLIRGen().newVariable(LIRKind.combine(operand).changeType(AArch64Kind.DWORD));</span>
<span class="line-added">452         getLIRGen().append(new AArch64BitManipulationOp(getLIRGen(), POPCNT, result, asAllocatable(operand)));</span>
<span class="line-added">453         return result;</span>
454     }
455 
456     @Override
457     public Value emitBitScanReverse(Value value) {
458         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AArch64Kind.DWORD));
<span class="line-modified">459         getLIRGen().append(new AArch64BitManipulationOp(getLIRGen(), BSR, result, asAllocatable(value)));</span>
460         return result;
461     }
462 
<span class="line-added">463     @Override</span>
<span class="line-added">464     public Value emitFusedMultiplyAdd(Value a, Value b, Value c) {</span>
<span class="line-added">465         return emitMultiplyAddSub(AArch64ArithmeticOp.FMADD, a, b, c);</span>
<span class="line-added">466     }</span>
<span class="line-added">467 </span>
468     @Override
469     public Value emitCountLeadingZeros(Value value) {
470         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AArch64Kind.DWORD));
<span class="line-modified">471         getLIRGen().append(new AArch64BitManipulationOp(getLIRGen(), CLZ, result, asAllocatable(value)));</span>
472         return result;
473     }
474 
475     @Override
476     public Value emitCountTrailingZeros(Value value) {
477         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AArch64Kind.DWORD));
<span class="line-modified">478         getLIRGen().append(new AArch64BitManipulationOp(getLIRGen(), CTZ, result, asAllocatable(value)));</span>
479         return result;
480     }
481 
482     private Variable emitUnary(AArch64ArithmeticOp op, Value inputVal) {
483         AllocatableValue input = asAllocatable(inputVal);
484         Variable result = getLIRGen().newVariable(LIRKind.combine(input));
485         getLIRGen().append(new AArch64ArithmeticOp.UnaryOp(op, result, input));
486         return result;
487     }
488 
489     private AllocatableValue moveSp(AllocatableValue val) {
490         return getLIRGen().moveSp(val);
491     }
492 
493     /**
494      * Returns the opcode depending on the platform kind of val.
495      */
496     private AArch64ArithmeticOp getOpCode(Value val, AArch64ArithmeticOp intOp, AArch64ArithmeticOp floatOp) {
497         return isNumericInteger(val.getPlatformKind()) ? intOp : floatOp;
498     }
</pre>
<hr />
<pre>
505         return result;
506     }
507 
508     @Override
509     public void emitStore(ValueKind&lt;?&gt; lirKind, Value address, Value inputVal, LIRFrameState state) {
510         AArch64AddressValue storeAddress = getLIRGen().asAddressValue(address);
511         AArch64Kind kind = (AArch64Kind) lirKind.getPlatformKind();
512 
513         if (isJavaConstant(inputVal) &amp;&amp; kind.isInteger()) {
514             JavaConstant c = asJavaConstant(inputVal);
515             if (c.isDefaultForKind()) {
516                 // We can load 0 directly into integer registers
517                 getLIRGen().append(new StoreConstantOp(kind, storeAddress, c, state));
518                 return;
519             }
520         }
521         AllocatableValue input = asAllocatable(inputVal);
522         getLIRGen().append(new StoreOp(kind, storeAddress, input, state));
523     }
524 





525     @Override
526     public Value emitRound(Value value, RoundingMode mode) {
527         AArch64ArithmeticOp op;
528         switch (mode) {
529             case NEAREST:
530                 op = AArch64ArithmeticOp.FRINTN;
531                 break;
532             case UP:
533                 op = AArch64ArithmeticOp.FRINTP;
534                 break;
535             case DOWN:
536                 op = AArch64ArithmeticOp.FRINTM;
537                 break;
538             default:
539                 throw GraalError.shouldNotReachHere();
540         }
541 
542         return emitUnary(op, value);
543     }
544 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64TestBitAndBranchTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64LIRGenerator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
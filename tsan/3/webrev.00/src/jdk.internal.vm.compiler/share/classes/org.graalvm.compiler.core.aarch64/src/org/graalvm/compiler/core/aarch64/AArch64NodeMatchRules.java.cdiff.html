<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64LIRGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64ReadNode.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,58 ***</span>
  
  
  
  package org.graalvm.compiler.core.aarch64;
  
  import jdk.vm.ci.meta.AllocatableValue;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.Value;
  import jdk.internal.vm.compiler.collections.EconomicMap;
  import jdk.internal.vm.compiler.collections.Equivalence;
  import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.core.gen.NodeMatchRules;
  import org.graalvm.compiler.core.match.ComplexMatchResult;
  import org.graalvm.compiler.core.match.MatchRule;
<span class="line-removed">- import org.graalvm.compiler.graph.Node;</span>
  import org.graalvm.compiler.lir.LIRFrameState;
  import org.graalvm.compiler.lir.LabelRef;
  import org.graalvm.compiler.lir.Variable;
  import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp;
  import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow;
  import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
  import org.graalvm.compiler.nodes.ConstantNode;
  import org.graalvm.compiler.nodes.DeoptimizingNode;
  import org.graalvm.compiler.nodes.IfNode;
  import org.graalvm.compiler.nodes.NodeView;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.calc.AddNode;
  import org.graalvm.compiler.nodes.calc.AndNode;
  import org.graalvm.compiler.nodes.calc.BinaryNode;
  import org.graalvm.compiler.nodes.calc.LeftShiftNode;
  import org.graalvm.compiler.nodes.calc.NotNode;
  import org.graalvm.compiler.nodes.calc.OrNode;
  import org.graalvm.compiler.nodes.calc.RightShiftNode;
  import org.graalvm.compiler.nodes.calc.SubNode;
  import org.graalvm.compiler.nodes.calc.UnsignedRightShiftNode;
  import org.graalvm.compiler.nodes.calc.XorNode;
  import org.graalvm.compiler.nodes.memory.Access;
  
<span class="line-removed">- import jdk.vm.ci.aarch64.AArch64Kind;</span>
<span class="line-removed">- </span>
  public class AArch64NodeMatchRules extends NodeMatchRules {
<span class="line-modified">!     private static final EconomicMap&lt;Class&lt;? extends Node&gt;, AArch64ArithmeticOp&gt; nodeOpMap;</span>
<span class="line-modified">! </span>
      private static final EconomicMap&lt;Class&lt;? extends BinaryNode&gt;, AArch64MacroAssembler.ShiftType&gt; shiftTypeMap;
  
      static {
<span class="line-modified">!         nodeOpMap = EconomicMap.create(Equivalence.IDENTITY, 5);</span>
<span class="line-modified">!         nodeOpMap.put(AddNode.class, AArch64ArithmeticOp.ADD);</span>
<span class="line-modified">!         nodeOpMap.put(SubNode.class, AArch64ArithmeticOp.SUB);</span>
<span class="line-modified">!         nodeOpMap.put(AndNode.class, AArch64ArithmeticOp.AND);</span>
<span class="line-modified">!         nodeOpMap.put(OrNode.class, AArch64ArithmeticOp.OR);</span>
<span class="line-modified">!         nodeOpMap.put(XorNode.class, AArch64ArithmeticOp.XOR);</span>
  
          shiftTypeMap = EconomicMap.create(Equivalence.IDENTITY, 3);
          shiftTypeMap.put(LeftShiftNode.class, AArch64MacroAssembler.ShiftType.LSL);
          shiftTypeMap.put(RightShiftNode.class, AArch64MacroAssembler.ShiftType.ASR);
          shiftTypeMap.put(UnsignedRightShiftNode.class, AArch64MacroAssembler.ShiftType.LSR);
<span class="line-new-header">--- 23,73 ---</span>
  
  
  
  package org.graalvm.compiler.core.aarch64;
  
<span class="line-added">+ import jdk.vm.ci.aarch64.AArch64Kind;</span>
<span class="line-added">+ import jdk.vm.ci.code.CodeUtil;</span>
  import jdk.vm.ci.meta.AllocatableValue;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.Value;
  import jdk.internal.vm.compiler.collections.EconomicMap;
  import jdk.internal.vm.compiler.collections.Equivalence;
  import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
  import org.graalvm.compiler.core.common.LIRKind;
<span class="line-added">+ import org.graalvm.compiler.core.common.calc.CanonicalCondition;</span>
  import org.graalvm.compiler.core.gen.NodeMatchRules;
  import org.graalvm.compiler.core.match.ComplexMatchResult;
  import org.graalvm.compiler.core.match.MatchRule;
  import org.graalvm.compiler.lir.LIRFrameState;
  import org.graalvm.compiler.lir.LabelRef;
  import org.graalvm.compiler.lir.Variable;
  import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp;
<span class="line-added">+ import org.graalvm.compiler.lir.aarch64.AArch64BitFieldOp;</span>
  import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow;
  import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
  import org.graalvm.compiler.nodes.ConstantNode;
  import org.graalvm.compiler.nodes.DeoptimizingNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.FixedNode;</span>
  import org.graalvm.compiler.nodes.IfNode;
  import org.graalvm.compiler.nodes.NodeView;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.calc.AddNode;
  import org.graalvm.compiler.nodes.calc.AndNode;
  import org.graalvm.compiler.nodes.calc.BinaryNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;</span>
  import org.graalvm.compiler.nodes.calc.LeftShiftNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.calc.MulNode;</span>
<span class="line-added">+ import org.graalvm.compiler.nodes.calc.NarrowNode;</span>
<span class="line-added">+ import org.graalvm.compiler.nodes.calc.NegateNode;</span>
  import org.graalvm.compiler.nodes.calc.NotNode;
  import org.graalvm.compiler.nodes.calc.OrNode;
  import org.graalvm.compiler.nodes.calc.RightShiftNode;
  import org.graalvm.compiler.nodes.calc.SubNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.calc.UnaryNode;</span>
  import org.graalvm.compiler.nodes.calc.UnsignedRightShiftNode;
  import org.graalvm.compiler.nodes.calc.XorNode;
  import org.graalvm.compiler.nodes.memory.Access;
  
  public class AArch64NodeMatchRules extends NodeMatchRules {
<span class="line-modified">!     private static final EconomicMap&lt;Class&lt;? extends BinaryNode&gt;, AArch64ArithmeticOp&gt; binaryOpMap;</span>
<span class="line-modified">!     private static final EconomicMap&lt;Class&lt;? extends BinaryNode&gt;, AArch64BitFieldOp.BitFieldOpCode&gt; bitFieldOpMap;</span>
      private static final EconomicMap&lt;Class&lt;? extends BinaryNode&gt;, AArch64MacroAssembler.ShiftType&gt; shiftTypeMap;
  
      static {
<span class="line-modified">!         binaryOpMap = EconomicMap.create(Equivalence.IDENTITY, 9);</span>
<span class="line-modified">!         binaryOpMap.put(AddNode.class, AArch64ArithmeticOp.ADD);</span>
<span class="line-modified">!         binaryOpMap.put(SubNode.class, AArch64ArithmeticOp.SUB);</span>
<span class="line-modified">!         binaryOpMap.put(MulNode.class, AArch64ArithmeticOp.MUL);</span>
<span class="line-modified">!         binaryOpMap.put(AndNode.class, AArch64ArithmeticOp.AND);</span>
<span class="line-modified">!         binaryOpMap.put(OrNode.class, AArch64ArithmeticOp.OR);</span>
<span class="line-added">+         binaryOpMap.put(XorNode.class, AArch64ArithmeticOp.XOR);</span>
<span class="line-added">+         binaryOpMap.put(LeftShiftNode.class, AArch64ArithmeticOp.SHL);</span>
<span class="line-added">+         binaryOpMap.put(RightShiftNode.class, AArch64ArithmeticOp.ASHR);</span>
<span class="line-added">+         binaryOpMap.put(UnsignedRightShiftNode.class, AArch64ArithmeticOp.LSHR);</span>
<span class="line-added">+ </span>
<span class="line-added">+         bitFieldOpMap = EconomicMap.create(Equivalence.IDENTITY, 2);</span>
<span class="line-added">+         bitFieldOpMap.put(UnsignedRightShiftNode.class, AArch64BitFieldOp.BitFieldOpCode.UBFX);</span>
<span class="line-added">+         bitFieldOpMap.put(LeftShiftNode.class, AArch64BitFieldOp.BitFieldOpCode.UBFIZ);</span>
  
          shiftTypeMap = EconomicMap.create(Equivalence.IDENTITY, 3);
          shiftTypeMap.put(LeftShiftNode.class, AArch64MacroAssembler.ShiftType.LSL);
          shiftTypeMap.put(RightShiftNode.class, AArch64MacroAssembler.ShiftType.ASR);
          shiftTypeMap.put(UnsignedRightShiftNode.class, AArch64MacroAssembler.ShiftType.LSR);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,11 ***</span>
  
      private AllocatableValue moveSp(AllocatableValue value) {
          return getLIRGeneratorTool().moveSp(value);
      }
  
<span class="line-modified">!     private ComplexMatchResult emitBinaryShift(AArch64ArithmeticOp op, ValueNode value, BinaryNode shift, boolean isShiftNot) {</span>
          AArch64MacroAssembler.ShiftType shiftType = shiftTypeMap.get(shift.getClass());
          assert shiftType != null;
          assert value.getStackKind().isNumericInteger();
          assert shift.getX().getStackKind().isNumericInteger();
          assert shift.getY() instanceof ConstantNode;
<span class="line-new-header">--- 112,25 ---</span>
  
      private AllocatableValue moveSp(AllocatableValue value) {
          return getLIRGeneratorTool().moveSp(value);
      }
  
<span class="line-modified">!     private ComplexMatchResult emitBitField(AArch64BitFieldOp.BitFieldOpCode op, ValueNode value, int lsb, int width) {</span>
<span class="line-added">+         assert op != null;</span>
<span class="line-added">+         assert value.getStackKind().isNumericInteger();</span>
<span class="line-added">+ </span>
<span class="line-added">+         return builder -&gt; {</span>
<span class="line-added">+             Value a = operand(value);</span>
<span class="line-added">+             Variable result = gen.newVariable(LIRKind.combine(a));</span>
<span class="line-added">+             AllocatableValue src = moveSp(gen.asAllocatable(a));</span>
<span class="line-added">+             gen.append(new AArch64BitFieldOp(op, result, src, lsb, width));</span>
<span class="line-added">+             return result;</span>
<span class="line-added">+         };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private ComplexMatchResult emitBinaryShift(AArch64ArithmeticOp op, ValueNode value, BinaryNode shift,</span>
<span class="line-added">+                     boolean isShiftNot) {</span>
          AArch64MacroAssembler.ShiftType shiftType = shiftTypeMap.get(shift.getClass());
          assert shiftType != null;
          assert value.getStackKind().isNumericInteger();
          assert shift.getX().getStackKind().isNumericInteger();
          assert shift.getY() instanceof ConstantNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,18 ***</span>
              gen.append(new AArch64ArithmeticOp.BinaryShiftOp(op, result, x, y, shiftType, shiftAmount, isShiftNot));
              return result;
          };
      }
  
      @MatchRule(&quot;(Add=binary a (LeftShift=shift b Constant))&quot;)
      @MatchRule(&quot;(Add=binary a (RightShift=shift b Constant))&quot;)
      @MatchRule(&quot;(Add=binary a (UnsignedRightShift=shift b Constant))&quot;)
      @MatchRule(&quot;(Sub=binary a (LeftShift=shift b Constant))&quot;)
      @MatchRule(&quot;(Sub=binary a (RightShift=shift b Constant))&quot;)
      @MatchRule(&quot;(Sub=binary a (UnsignedRightShift=shift b Constant))&quot;)
      public ComplexMatchResult addSubShift(BinaryNode binary, ValueNode a, BinaryNode shift) {
<span class="line-modified">!         AArch64ArithmeticOp op = nodeOpMap.get(binary.getClass());</span>
          assert op != null;
          return emitBinaryShift(op, a, shift, false);
      }
  
      @MatchRule(&quot;(And=binary a (LeftShift=shift b Constant))&quot;)
<span class="line-new-header">--- 145,68 ---</span>
              gen.append(new AArch64ArithmeticOp.BinaryShiftOp(op, result, x, y, shiftType, shiftAmount, isShiftNot));
              return result;
          };
      }
  
<span class="line-added">+     private ComplexMatchResult emitBitTestAndBranch(FixedNode trueSuccessor, FixedNode falseSuccessor,</span>
<span class="line-added">+                     ValueNode value, double trueProbability, int nbits) {</span>
<span class="line-added">+         return builder -&gt; {</span>
<span class="line-added">+             LabelRef trueDestination = getLIRBlock(trueSuccessor);</span>
<span class="line-added">+             LabelRef falseDestination = getLIRBlock(falseSuccessor);</span>
<span class="line-added">+             AllocatableValue src = moveSp(gen.asAllocatable(operand(value)));</span>
<span class="line-added">+             gen.append(new AArch64ControlFlow.BitTestAndBranchOp(trueDestination, falseDestination, src,</span>
<span class="line-added">+                             trueProbability, nbits));</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static boolean isNarrowingLongToInt(NarrowNode narrow) {</span>
<span class="line-added">+         return narrow.getInputBits() == 64 &amp;&amp; narrow.getResultBits() == 32;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @MatchRule(&quot;(And (UnsignedRightShift=shift a Constant=b) Constant=c)&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(LeftShift=shift (And a Constant=c) Constant=b)&quot;)</span>
<span class="line-added">+     public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode a, ConstantNode b, ConstantNode c) {</span>
<span class="line-added">+         JavaKind srcKind = a.getStackKind();</span>
<span class="line-added">+         assert srcKind.isNumericInteger();</span>
<span class="line-added">+         AArch64BitFieldOp.BitFieldOpCode op = bitFieldOpMap.get(shift.getClass());</span>
<span class="line-added">+         assert op != null;</span>
<span class="line-added">+         int distance = b.asJavaConstant().asInt();</span>
<span class="line-added">+         long mask = c.asJavaConstant().asLong();</span>
<span class="line-added">+ </span>
<span class="line-added">+         // The Java(R) Language Specification CHAPTER 15.19 Shift Operators says:</span>
<span class="line-added">+         // &quot;If the promoted type of the left-hand operand is int(long), then only the five(six)</span>
<span class="line-added">+         // lowest-order bits of the right-hand operand are used as the shift distance.&quot;</span>
<span class="line-added">+         distance = distance &amp; (srcKind == JavaKind.Int ? 0x1f : 0x3f);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Constraint 1: Mask plus one should be a power-of-2 integer.</span>
<span class="line-added">+         if (!CodeUtil.isPowerOf2(mask + 1)) {</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         int width = CodeUtil.log2(mask + 1);</span>
<span class="line-added">+         int srcBits = srcKind.getBitCount();</span>
<span class="line-added">+         // Constraint 2: Bit field width is less than 31(63) for int(long) as any bit field move</span>
<span class="line-added">+         // operations can be done by a single shift instruction if the width is 31(63).</span>
<span class="line-added">+         if (width &gt;= srcBits - 1) {</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // Constraint 3: Sum of bit field width and the shift distance is less or equal to 32(64)</span>
<span class="line-added">+         // for int(long) as the specification of AArch64 bit field instructions.</span>
<span class="line-added">+         if (width + distance &gt; srcBits) {</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return emitBitField(op, a, distance, width);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @MatchRule(&quot;(Add=binary a (LeftShift=shift b Constant))&quot;)
      @MatchRule(&quot;(Add=binary a (RightShift=shift b Constant))&quot;)
      @MatchRule(&quot;(Add=binary a (UnsignedRightShift=shift b Constant))&quot;)
      @MatchRule(&quot;(Sub=binary a (LeftShift=shift b Constant))&quot;)
      @MatchRule(&quot;(Sub=binary a (RightShift=shift b Constant))&quot;)
      @MatchRule(&quot;(Sub=binary a (UnsignedRightShift=shift b Constant))&quot;)
      public ComplexMatchResult addSubShift(BinaryNode binary, ValueNode a, BinaryNode shift) {
<span class="line-modified">!         AArch64ArithmeticOp op = binaryOpMap.get(binary.getClass());</span>
          assert op != null;
          return emitBinaryShift(op, a, shift, false);
      }
  
      @MatchRule(&quot;(And=binary a (LeftShift=shift b Constant))&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 147,17 ***</span>
      @MatchRule(&quot;(Or=binary a (Not (UnsignedRightShift=shift b Constant)))&quot;)
      @MatchRule(&quot;(Xor=binary a (Not (LeftShift=shift b Constant)))&quot;)
      @MatchRule(&quot;(Xor=binary a (Not (RightShift=shift b Constant)))&quot;)
      @MatchRule(&quot;(Xor=binary a (Not (UnsignedRightShift=shift b Constant)))&quot;)
      public ComplexMatchResult logicShift(BinaryNode binary, ValueNode a, BinaryNode shift) {
<span class="line-modified">!         AArch64ArithmeticOp op = nodeOpMap.get(binary.getClass());</span>
          assert op != null;
          ValueNode operand = binary.getX() == a ? binary.getY() : binary.getX();
          boolean isShiftNot = operand instanceof NotNode;
          return emitBinaryShift(op, a, shift, isShiftNot);
      }
  
      @MatchRule(&quot;(Mul (Negate a) b)&quot;)
      @MatchRule(&quot;(Negate (Mul a b))&quot;)
      public ComplexMatchResult multiplyNegate(ValueNode a, ValueNode b) {
          if (a.getStackKind().isNumericInteger() &amp;&amp; b.getStackKind().isNumericInteger()) {
              return builder -&gt; getArithmeticLIRGenerator().emitMNeg(operand(a), operand(b));
<span class="line-new-header">--- 226,113 ---</span>
      @MatchRule(&quot;(Or=binary a (Not (UnsignedRightShift=shift b Constant)))&quot;)
      @MatchRule(&quot;(Xor=binary a (Not (LeftShift=shift b Constant)))&quot;)
      @MatchRule(&quot;(Xor=binary a (Not (RightShift=shift b Constant)))&quot;)
      @MatchRule(&quot;(Xor=binary a (Not (UnsignedRightShift=shift b Constant)))&quot;)
      public ComplexMatchResult logicShift(BinaryNode binary, ValueNode a, BinaryNode shift) {
<span class="line-modified">!         AArch64ArithmeticOp op = binaryOpMap.get(binary.getClass());</span>
          assert op != null;
          ValueNode operand = binary.getX() == a ? binary.getY() : binary.getX();
          boolean isShiftNot = operand instanceof NotNode;
          return emitBinaryShift(op, a, shift, isShiftNot);
      }
  
<span class="line-added">+     @MatchRule(&quot;(Add=binary (Mul (SignExtend a) (SignExtend b)) c)&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Sub=binary c (Mul (SignExtend a) (SignExtend b)))&quot;)</span>
<span class="line-added">+     public ComplexMatchResult signedMultiplyAddSubLong(BinaryNode binary, ValueNode a, ValueNode b, ValueNode c) {</span>
<span class="line-added">+         assert a.getStackKind() == JavaKind.Int &amp;&amp; b.getStackKind() == JavaKind.Int &amp;&amp; c.getStackKind() == JavaKind.Long;</span>
<span class="line-added">+         if (binary instanceof AddNode) {</span>
<span class="line-added">+             return builder -&gt; getArithmeticLIRGenerator().emitIntegerMAdd(operand(a), operand(b), operand(c), true);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return builder -&gt; getArithmeticLIRGenerator().emitIntegerMSub(operand(a), operand(b), operand(c), true);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @MatchRule(&quot;(Negate (Mul=mul (SignExtend a) (SignExtend b)))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Mul=mul (Negate (SignExtend a)) (SignExtend b))&quot;)</span>
<span class="line-added">+     public ComplexMatchResult signedMultiplyNegLong(MulNode mul, ValueNode a, ValueNode b) {</span>
<span class="line-added">+         assert a.getStackKind() == JavaKind.Int &amp;&amp; b.getStackKind() == JavaKind.Int;</span>
<span class="line-added">+         LIRKind resultKind = LIRKind.fromJavaKind(gen.target().arch, mul.getStackKind());</span>
<span class="line-added">+         return builder -&gt; getArithmeticLIRGenerator().emitBinary(</span>
<span class="line-added">+                         resultKind, AArch64ArithmeticOp.SMNEGL, true, operand(a), operand(b));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @MatchRule(&quot;(Mul=mul (SignExtend a) (SignExtend b))&quot;)</span>
<span class="line-added">+     public ComplexMatchResult signedMultiplyLong(MulNode mul, ValueNode a, ValueNode b) {</span>
<span class="line-added">+         assert a.getStackKind() == JavaKind.Int &amp;&amp; b.getStackKind() == JavaKind.Int;</span>
<span class="line-added">+         LIRKind resultKind = LIRKind.fromJavaKind(gen.target().arch, mul.getStackKind());</span>
<span class="line-added">+         return builder -&gt; getArithmeticLIRGenerator().emitBinary(</span>
<span class="line-added">+                         resultKind, AArch64ArithmeticOp.SMULL, true, operand(a), operand(b));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @MatchRule(&quot;(Add=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Sub=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Mul=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(And=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Or=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Xor=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(LeftShift=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(RightShift=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(UnsignedRightShift=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Add=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Sub=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Mul=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(And=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Or=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Xor=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(LeftShift=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(RightShift=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(UnsignedRightShift=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Sub=binary (Narrow=narrow a) b)&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(LeftShift=binary (Narrow=narrow a) b)&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(RightShift=binary (Narrow=narrow a) b)&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(UnsignedRightShift=binary (Narrow=narrow a) b)&quot;)</span>
<span class="line-added">+     public ComplexMatchResult elideL2IForBinary(BinaryNode binary, NarrowNode narrow) {</span>
<span class="line-added">+         assert binary.getStackKind().isNumericInteger();</span>
<span class="line-added">+ </span>
<span class="line-added">+         ValueNode a = narrow;</span>
<span class="line-added">+         ValueNode b = binary.getX() == narrow ? binary.getY() : binary.getX();</span>
<span class="line-added">+         boolean isL2Ia = isNarrowingLongToInt((NarrowNode) a);</span>
<span class="line-added">+         boolean isL2Ib = (b instanceof NarrowNode) &amp;&amp; isNarrowingLongToInt((NarrowNode) b);</span>
<span class="line-added">+         if (!isL2Ia &amp;&amp; !isL2Ib) {</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // Get the value of L2I NarrowNode as the src value.</span>
<span class="line-added">+         ValueNode src1 = isL2Ia ? ((NarrowNode) a).getValue() : a;</span>
<span class="line-added">+         ValueNode src2 = isL2Ib ? ((NarrowNode) b).getValue() : b;</span>
<span class="line-added">+ </span>
<span class="line-added">+         AArch64ArithmeticOp op = binaryOpMap.get(binary.getClass());</span>
<span class="line-added">+         assert op != null;</span>
<span class="line-added">+         boolean commutative = binary.getNodeClass().isCommutative();</span>
<span class="line-added">+         LIRKind resultKind = LIRKind.fromJavaKind(gen.target().arch, binary.getStackKind());</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Must keep the right operator order for un-commutative binary operations.</span>
<span class="line-added">+         if (a == binary.getX()) {</span>
<span class="line-added">+             return builder -&gt; getArithmeticLIRGenerator().emitBinary(</span>
<span class="line-added">+                             resultKind, op, commutative, operand(src1), operand(src2));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return builder -&gt; getArithmeticLIRGenerator().emitBinary(</span>
<span class="line-added">+                         resultKind, op, commutative, operand(src2), operand(src1));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @MatchRule(&quot;(Negate=unary (Narrow=narrow value))&quot;)</span>
<span class="line-added">+     @MatchRule(&quot;(Not=unary (Narrow=narrow value))&quot;)</span>
<span class="line-added">+     public ComplexMatchResult elideL2IForUnary(UnaryNode unary, NarrowNode narrow) {</span>
<span class="line-added">+         assert unary.getStackKind().isNumericInteger();</span>
<span class="line-added">+         if (!isNarrowingLongToInt(narrow)) {</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         AArch64ArithmeticOp op = unary instanceof NegateNode ? AArch64ArithmeticOp.NEG</span>
<span class="line-added">+                         : AArch64ArithmeticOp.NOT;</span>
<span class="line-added">+         return builder -&gt; {</span>
<span class="line-added">+             AllocatableValue input = gen.asAllocatable(operand(narrow.getValue()));</span>
<span class="line-added">+             LIRKind resultKind = LIRKind.fromJavaKind(gen.target().arch, unary.getStackKind());</span>
<span class="line-added">+             Variable result = gen.newVariable(resultKind);</span>
<span class="line-added">+             gen.append(new AArch64ArithmeticOp.UnaryOp(op, result, moveSp(input)));</span>
<span class="line-added">+             return result;</span>
<span class="line-added">+         };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @MatchRule(&quot;(Mul (Negate a) b)&quot;)
      @MatchRule(&quot;(Negate (Mul a b))&quot;)
      public ComplexMatchResult multiplyNegate(ValueNode a, ValueNode b) {
          if (a.getStackKind().isNumericInteger() &amp;&amp; b.getStackKind().isNumericInteger()) {
              return builder -&gt; getArithmeticLIRGenerator().emitMNeg(operand(a), operand(b));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,37 ***</span>
          if (!kindA.isNumericInteger() || !kindB.isNumericInteger() || !kindC.isNumericInteger()) {
              return null;
          }
  
          if (binary instanceof AddNode) {
<span class="line-modified">!             return builder -&gt; getArithmeticLIRGenerator().emitMAdd(operand(a), operand(b), operand(c));</span>
          }
<span class="line-modified">!         return builder -&gt; getArithmeticLIRGenerator().emitMSub(operand(a), operand(b), operand(c));</span>
      }
  
      /**
       * ((x &amp; (1 &lt;&lt; n)) == 0) -&gt; tbz/tbnz n label.
       */
      @MatchRule(&quot;(If (IntegerTest value Constant=a))&quot;)
      public ComplexMatchResult testBitAndBranch(IfNode root, ValueNode value, ConstantNode a) {
          if (value.getStackKind().isNumericInteger()) {
              long constant = a.asJavaConstant().asLong();
              if (Long.bitCount(constant) == 1) {
<span class="line-modified">!                 int bitToTest = Long.numberOfTrailingZeros(constant);</span>
<span class="line-modified">!                 return builder -&gt; {</span>
<span class="line-removed">-                     LabelRef trueDestination = getLIRBlock(root.trueSuccessor());</span>
<span class="line-removed">-                     LabelRef falseDestination = getLIRBlock(root.falseSuccessor());</span>
<span class="line-removed">-                     AllocatableValue src = moveSp(gen.asAllocatable(operand(value)));</span>
<span class="line-removed">-                     double trueDestinationProbability = root.getTrueSuccessorProbability();</span>
<span class="line-removed">-                     gen.append(new AArch64ControlFlow.BitTestAndBranchOp(trueDestination, falseDestination, src, trueDestinationProbability, bitToTest));</span>
<span class="line-removed">-                     return null;</span>
<span class="line-removed">-                 };</span>
              }
          }
          return null;
      }
  
      @Override
      public AArch64LIRGenerator getLIRGeneratorTool() {
          return (AArch64LIRGenerator) gen;
      }
  
<span class="line-new-header">--- 349,44 ---</span>
          if (!kindA.isNumericInteger() || !kindB.isNumericInteger() || !kindC.isNumericInteger()) {
              return null;
          }
  
          if (binary instanceof AddNode) {
<span class="line-modified">!             return builder -&gt; getArithmeticLIRGenerator().emitIntegerMAdd(operand(a), operand(b), operand(c), false);</span>
          }
<span class="line-modified">!         return builder -&gt; getArithmeticLIRGenerator().emitIntegerMSub(operand(a), operand(b), operand(c), false);</span>
      }
  
      /**
       * ((x &amp; (1 &lt;&lt; n)) == 0) -&gt; tbz/tbnz n label.
       */
      @MatchRule(&quot;(If (IntegerTest value Constant=a))&quot;)
      public ComplexMatchResult testBitAndBranch(IfNode root, ValueNode value, ConstantNode a) {
          if (value.getStackKind().isNumericInteger()) {
              long constant = a.asJavaConstant().asLong();
              if (Long.bitCount(constant) == 1) {
<span class="line-modified">!                 return emitBitTestAndBranch(root.trueSuccessor(), root.falseSuccessor(), value,</span>
<span class="line-modified">!                                 root.getTrueSuccessorProbability(), Long.numberOfTrailingZeros(constant));</span>
              }
          }
          return null;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * if x &lt; 0 &lt;=&gt; tbz x, sizeOfBits(x) - 1, label.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @MatchRule(&quot;(If (IntegerLessThan=lessNode x Constant=y))&quot;)</span>
<span class="line-added">+     public ComplexMatchResult checkNegativeAndBranch(IfNode root, IntegerLessThanNode lessNode, ValueNode x, ConstantNode y) {</span>
<span class="line-added">+         JavaKind xKind = x.getStackKind();</span>
<span class="line-added">+         assert xKind.isNumericInteger();</span>
<span class="line-added">+         if (y.isJavaConstant() &amp;&amp; (0 == y.asJavaConstant().asLong()) &amp;&amp; lessNode.condition().equals(CanonicalCondition.LT)) {</span>
<span class="line-added">+             return emitBitTestAndBranch(root.falseSuccessor(), root.trueSuccessor(), x,</span>
<span class="line-added">+                             1.0 - root.getTrueSuccessorProbability(), xKind.getBitCount() - 1);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return null;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public AArch64LIRGenerator getLIRGeneratorTool() {
          return (AArch64LIRGenerator) gen;
      }
  
</pre>
<center><a href="AArch64LIRGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64ReadNode.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64ArithmeticLIRGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64NodeMatchRules.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 31 
 32 import java.util.function.Function;
 33 
 34 import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;
 35 import org.graalvm.compiler.asm.aarch64.AArch64Assembler.ConditionFlag;
 36 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 37 import org.graalvm.compiler.core.common.LIRKind;
 38 import org.graalvm.compiler.core.common.calc.Condition;
 39 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 40 import org.graalvm.compiler.debug.GraalError;
 41 import org.graalvm.compiler.lir.LIRFrameState;
 42 import org.graalvm.compiler.lir.LIRValueUtil;
 43 import org.graalvm.compiler.lir.LabelRef;
 44 import org.graalvm.compiler.lir.StandardOp;
 45 import org.graalvm.compiler.lir.SwitchStrategy;
 46 import org.graalvm.compiler.lir.Variable;
 47 import org.graalvm.compiler.lir.aarch64.AArch64AddressValue;
 48 import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp;
 49 import org.graalvm.compiler.lir.aarch64.AArch64ArrayCompareToOp;
 50 import org.graalvm.compiler.lir.aarch64.AArch64ArrayEqualsOp;




 51 import org.graalvm.compiler.lir.aarch64.AArch64ByteSwapOp;
 52 import org.graalvm.compiler.lir.aarch64.AArch64Compare;
 53 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow;
 54 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.BranchOp;
 55 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.CompareBranchZeroOp;
 56 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.CondMoveOp;
 57 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.CondSetOp;
 58 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.StrategySwitchOp;
 59 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.TableSwitchOp;
 60 import org.graalvm.compiler.lir.aarch64.AArch64LIRFlagsVersioned;
 61 import org.graalvm.compiler.lir.aarch64.AArch64Move;
<span class="line-removed"> 62 import org.graalvm.compiler.lir.aarch64.AArch64AtomicMove.AtomicReadAndAddOp;</span>
<span class="line-removed"> 63 import org.graalvm.compiler.lir.aarch64.AArch64AtomicMove.AtomicReadAndAddLSEOp;</span>
<span class="line-removed"> 64 import org.graalvm.compiler.lir.aarch64.AArch64AtomicMove.CompareAndSwapOp;</span>
<span class="line-removed"> 65 import org.graalvm.compiler.lir.aarch64.AArch64AtomicMove.AtomicReadAndWriteOp;</span>
 66 import org.graalvm.compiler.lir.aarch64.AArch64Move.MembarOp;
 67 import org.graalvm.compiler.lir.aarch64.AArch64PauseOp;
 68 import org.graalvm.compiler.lir.aarch64.AArch64SpeculativeBarrier;

 69 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 70 import org.graalvm.compiler.lir.gen.LIRGenerator;
 71 import org.graalvm.compiler.phases.util.Providers;
 72 
 73 import jdk.vm.ci.aarch64.AArch64;
 74 import jdk.vm.ci.aarch64.AArch64Kind;
 75 import jdk.vm.ci.code.CallingConvention;
 76 import jdk.vm.ci.code.RegisterValue;
 77 import jdk.vm.ci.meta.AllocatableValue;
 78 import jdk.vm.ci.meta.JavaConstant;
 79 import jdk.vm.ci.meta.JavaKind;
 80 import jdk.vm.ci.meta.PlatformKind;
 81 import jdk.vm.ci.meta.PrimitiveConstant;
 82 import jdk.vm.ci.meta.Value;
 83 import jdk.vm.ci.meta.ValueKind;
 84 
 85 public abstract class AArch64LIRGenerator extends LIRGenerator {
 86 
 87     public AArch64LIRGenerator(LIRKindTool lirKindTool, AArch64ArithmeticLIRGenerator arithmeticLIRGen, MoveFactory moveFactory, Providers providers, LIRGenerationResult lirGenRes) {
 88         super(lirKindTool, arithmeticLIRGen, moveFactory, providers, lirGenRes);
</pre>
<hr />
<pre>
147         } else {
148             return new AArch64AddressValue(address.getValueKind(), asAllocatable(address), Value.ILLEGAL, 0, 1, AddressingMode.BASE_REGISTER_ONLY);
149         }
150     }
151 
152     @Override
153     public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue) {
154         Variable prevValue = newVariable(expectedValue.getValueKind());
155         Variable scratch = newVariable(LIRKind.value(AArch64Kind.DWORD));
156         append(new CompareAndSwapOp(prevValue, loadReg(expectedValue), loadReg(newValue), asAllocatable(address), scratch));
157         assert trueValue.getValueKind().equals(falseValue.getValueKind());
158         Variable result = newVariable(trueValue.getValueKind());
159         append(new CondMoveOp(result, ConditionFlag.EQ, asAllocatable(trueValue), asAllocatable(falseValue)));
160         return result;
161     }
162 
163     @Override
164     public Variable emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue) {
165         Variable result = newVariable(newValue.getValueKind());
166         Variable scratch = newVariable(LIRKind.value(AArch64Kind.WORD));
<span class="line-modified">167         append(new CompareAndSwapOp(result, loadNonCompareConst(expectedValue), loadReg(newValue), asAllocatable(address), scratch));</span>
168         return result;
169     }
170 
171     @Override
172     public Value emitAtomicReadAndWrite(Value address, ValueKind&lt;?&gt; kind, Value newValue) {
173         Variable result = newVariable(kind);
174         Variable scratch = newVariable(kind);
175         append(new AtomicReadAndWriteOp((AArch64Kind) kind.getPlatformKind(), asAllocatable(result), asAllocatable(address), asAllocatable(newValue), asAllocatable(scratch)));
176         return result;
177     }
178 
179     @Override
180     public Value emitAtomicReadAndAdd(Value address, ValueKind&lt;?&gt; kind, Value delta) {
181         Variable result = newVariable(kind);
182         if (AArch64LIRFlagsVersioned.useLSE(target().arch)) {
183             append(new AtomicReadAndAddLSEOp((AArch64Kind) kind.getPlatformKind(), asAllocatable(result), asAllocatable(address), asAllocatable(delta)));
184         } else {
185             append(new AtomicReadAndAddOp((AArch64Kind) kind.getPlatformKind(), asAllocatable(result), asAllocatable(address), delta));
186         }
187         return result;
</pre>
<hr />
<pre>
221         ((AArch64ArithmeticLIRGenerator) getArithmetic()).emitBinary(LIRKind.combine(left, right), AArch64ArithmeticOp.ANDS, true, left, right);
222         append(new AArch64ControlFlow.BranchOp(ConditionFlag.EQ, trueDestination, falseDestination, trueSuccessorProbability));
223     }
224 
225     /**
226      * Conditionally move trueValue into new variable if cond + unorderedIsTrue is true, else
227      * falseValue.
228      *
229      * @param left Arbitrary value. Has to have same type as right. Non null.
230      * @param right Arbitrary value. Has to have same type as left. Non null.
231      * @param cond condition that decides whether to move trueValue or falseValue into result. Non
232      *            null.
233      * @param unorderedIsTrue defines whether floating-point comparisons consider unordered true or
234      *            not. Ignored for integer comparisons.
235      * @param trueValue arbitrary value same type as falseValue. Non null.
236      * @param falseValue arbitrary value same type as trueValue. Non null.
237      * @return value containing trueValue if cond + unorderedIsTrue is true, else falseValue. Non
238      *         null.
239      */
240     @Override
<span class="line-modified">241     public Variable emitConditionalMove(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, Value trueValue, Value falseValue) {</span>
<span class="line-modified">242         boolean mirrored = emitCompare(cmpKind, left, right, cond, unorderedIsTrue);</span>





243         Condition finalCondition = mirrored ? cond.mirror() : cond;
244         boolean finalUnorderedIsTrue = mirrored ? !unorderedIsTrue : unorderedIsTrue;
245         ConditionFlag cmpCondition = toConditionFlag(((AArch64Kind) cmpKind).isInteger(), finalCondition, finalUnorderedIsTrue);
246         Variable result = newVariable(trueValue.getValueKind());
247 
248         if (isIntConstant(trueValue, 1) &amp;&amp; isIntConstant(falseValue, 0)) {
249             append(new CondSetOp(result, cmpCondition));
250         } else if (isIntConstant(trueValue, 0) &amp;&amp; isIntConstant(falseValue, 1)) {
251             append(new CondSetOp(result, cmpCondition.negate()));
252         } else {
253             append(new CondMoveOp(result, cmpCondition, loadReg(trueValue), loadReg(falseValue)));
254         }
255         return result;
256     }
257 
258     @Override
<span class="line-modified">259     public void emitCompareBranch(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, LabelRef trueDestination, LabelRef falseDestination,</span>
260                     double trueDestinationProbability) {

261         if (cond == Condition.EQ) {
262             // emit cbz instruction for IsNullNode.
263             assert !LIRValueUtil.isNullConstant(left) : &quot;emitNullCheckBranch()&#39;s null input should be in right.&quot;;
<span class="line-modified">264             if (LIRValueUtil.isNullConstant(right)) {</span>
<span class="line-modified">265                 append(new CompareBranchZeroOp(asAllocatable(left), trueDestination, falseDestination, trueDestinationProbability));</span>
<span class="line-modified">266                 return;</span>







267             }
268 
269             // emit cbz instruction for IntegerEquals when any of the inputs is zero.
270             AArch64Kind kind = (AArch64Kind) cmpKind;
271             if (kind.isInteger()) {
272                 if (isIntConstant(left, 0)) {
<span class="line-modified">273                     append(new CompareBranchZeroOp(asAllocatable(right), trueDestination, falseDestination, trueDestinationProbability));</span>
274                     return;
<span class="line-modified">275                 } else if (isIntConstant(right, 0)) {</span>
276                     append(new CompareBranchZeroOp(asAllocatable(left), trueDestination, falseDestination, trueDestinationProbability));
277                     return;
278                 }
279             }
280         }
281 
<span class="line-modified">282         boolean mirrored = emitCompare(cmpKind, left, right, cond, unorderedIsTrue);</span>
283         Condition finalCondition = mirrored ? cond.mirror() : cond;
284         boolean finalUnorderedIsTrue = mirrored ? !unorderedIsTrue : unorderedIsTrue;
285         ConditionFlag cmpCondition = toConditionFlag(((AArch64Kind) cmpKind).isInteger(), finalCondition, finalUnorderedIsTrue);
286         append(new BranchOp(cmpCondition, trueDestination, falseDestination, trueDestinationProbability));
287     }
288 
289     private static ConditionFlag toConditionFlag(boolean isInt, Condition cond, boolean unorderedIsTrue) {
290         return isInt ? toIntConditionFlag(cond) : toFloatConditionFlag(cond, unorderedIsTrue);
291     }
292 
293     /**
294      * Takes a Condition and unorderedIsTrue flag and returns the correct Aarch64 specific
295      * ConditionFlag. Note: This is only correct if the emitCompare code for floats has correctly
296      * handled the case of &#39;EQ &amp;&amp; unorderedIsTrue&#39;, respectively &#39;NE &amp;&amp; !unorderedIsTrue&#39;!
297      */
298     private static ConditionFlag toFloatConditionFlag(Condition cond, boolean unorderedIsTrue) {
299         switch (cond) {
300             case LT:
301                 return unorderedIsTrue ? ConditionFlag.LT : ConditionFlag.LO;
302             case LE:
</pre>
<hr />
<pre>
500         append(new AArch64ByteSwapOp(result, input));
501         return result;
502     }
503 
504     @Override
505     public Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
506         LIRKind resultKind = LIRKind.value(AArch64Kind.DWORD);
507         // DMS TODO: check calling conversion and registers used
508         RegisterValue res = AArch64.r0.asValue(resultKind);
509         RegisterValue cnt1 = AArch64.r1.asValue(length1.getValueKind());
510         RegisterValue cnt2 = AArch64.r2.asValue(length2.getValueKind());
511         emitMove(cnt1, length1);
512         emitMove(cnt2, length2);
513         append(new AArch64ArrayCompareToOp(this, kind1, kind2, res, array1, array2, cnt1, cnt2));
514         Variable result = newVariable(resultKind);
515         emitMove(result, res);
516         return result;
517     }
518 
519     @Override
<span class="line-modified">520     public Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, int constantLength, boolean directPointers) {</span>
521         Variable result = newVariable(LIRKind.value(AArch64Kind.DWORD));
522         append(new AArch64ArrayEqualsOp(this, kind, result, array1, array2, asAllocatable(length), directPointers));
523         return result;
524     }
525 
526     @Override
527     protected JavaConstant zapValueForKind(PlatformKind kind) {
528         long dead = 0xDEADDEADDEADDEADL;
529         switch ((AArch64Kind) kind) {
530             case BYTE:
531                 return JavaConstant.forByte((byte) dead);
532             case WORD:
533                 return JavaConstant.forShort((short) dead);
534             case DWORD:
535                 return JavaConstant.forInt((int) dead);
536             case QWORD:
537                 return JavaConstant.forLong(dead);
538             case SINGLE:
539                 return JavaConstant.forFloat(Float.intBitsToFloat((int) dead));
540             case DOUBLE:
</pre>
<hr />
<pre>
553      * [x0] instead of: ldr x0, [x19].
554      */
555     protected AllocatableValue loadReg(Value val) {
556         if (!(val instanceof Variable || val instanceof RegisterValue)) {
557             return emitMove(val);
558         }
559         return (AllocatableValue) val;
560     }
561 
562     @Override
563     public void emitPause() {
564         append(new AArch64PauseOp());
565     }
566 
567     public abstract void emitCCall(long address, CallingConvention nativeCallingConvention, Value[] args);
568 
569     @Override
570     public void emitSpeculationFence() {
571         append(new AArch64SpeculativeBarrier());
572     }













573 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 31 
 32 import java.util.function.Function;
 33 
 34 import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;
 35 import org.graalvm.compiler.asm.aarch64.AArch64Assembler.ConditionFlag;
 36 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 37 import org.graalvm.compiler.core.common.LIRKind;
 38 import org.graalvm.compiler.core.common.calc.Condition;
 39 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 40 import org.graalvm.compiler.debug.GraalError;
 41 import org.graalvm.compiler.lir.LIRFrameState;
 42 import org.graalvm.compiler.lir.LIRValueUtil;
 43 import org.graalvm.compiler.lir.LabelRef;
 44 import org.graalvm.compiler.lir.StandardOp;
 45 import org.graalvm.compiler.lir.SwitchStrategy;
 46 import org.graalvm.compiler.lir.Variable;
 47 import org.graalvm.compiler.lir.aarch64.AArch64AddressValue;
 48 import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp;
 49 import org.graalvm.compiler.lir.aarch64.AArch64ArrayCompareToOp;
 50 import org.graalvm.compiler.lir.aarch64.AArch64ArrayEqualsOp;
<span class="line-added"> 51 import org.graalvm.compiler.lir.aarch64.AArch64AtomicMove.AtomicReadAndAddLSEOp;</span>
<span class="line-added"> 52 import org.graalvm.compiler.lir.aarch64.AArch64AtomicMove.AtomicReadAndAddOp;</span>
<span class="line-added"> 53 import org.graalvm.compiler.lir.aarch64.AArch64AtomicMove.AtomicReadAndWriteOp;</span>
<span class="line-added"> 54 import org.graalvm.compiler.lir.aarch64.AArch64AtomicMove.CompareAndSwapOp;</span>
 55 import org.graalvm.compiler.lir.aarch64.AArch64ByteSwapOp;
 56 import org.graalvm.compiler.lir.aarch64.AArch64Compare;
 57 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow;
 58 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.BranchOp;
 59 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.CompareBranchZeroOp;
 60 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.CondMoveOp;
 61 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.CondSetOp;
 62 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.StrategySwitchOp;
 63 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.TableSwitchOp;
 64 import org.graalvm.compiler.lir.aarch64.AArch64LIRFlagsVersioned;
 65 import org.graalvm.compiler.lir.aarch64.AArch64Move;




 66 import org.graalvm.compiler.lir.aarch64.AArch64Move.MembarOp;
 67 import org.graalvm.compiler.lir.aarch64.AArch64PauseOp;
 68 import org.graalvm.compiler.lir.aarch64.AArch64SpeculativeBarrier;
<span class="line-added"> 69 import org.graalvm.compiler.lir.aarch64.AArch64ZeroMemoryOp;</span>
 70 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 71 import org.graalvm.compiler.lir.gen.LIRGenerator;
 72 import org.graalvm.compiler.phases.util.Providers;
 73 
 74 import jdk.vm.ci.aarch64.AArch64;
 75 import jdk.vm.ci.aarch64.AArch64Kind;
 76 import jdk.vm.ci.code.CallingConvention;
 77 import jdk.vm.ci.code.RegisterValue;
 78 import jdk.vm.ci.meta.AllocatableValue;
 79 import jdk.vm.ci.meta.JavaConstant;
 80 import jdk.vm.ci.meta.JavaKind;
 81 import jdk.vm.ci.meta.PlatformKind;
 82 import jdk.vm.ci.meta.PrimitiveConstant;
 83 import jdk.vm.ci.meta.Value;
 84 import jdk.vm.ci.meta.ValueKind;
 85 
 86 public abstract class AArch64LIRGenerator extends LIRGenerator {
 87 
 88     public AArch64LIRGenerator(LIRKindTool lirKindTool, AArch64ArithmeticLIRGenerator arithmeticLIRGen, MoveFactory moveFactory, Providers providers, LIRGenerationResult lirGenRes) {
 89         super(lirKindTool, arithmeticLIRGen, moveFactory, providers, lirGenRes);
</pre>
<hr />
<pre>
148         } else {
149             return new AArch64AddressValue(address.getValueKind(), asAllocatable(address), Value.ILLEGAL, 0, 1, AddressingMode.BASE_REGISTER_ONLY);
150         }
151     }
152 
153     @Override
154     public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue) {
155         Variable prevValue = newVariable(expectedValue.getValueKind());
156         Variable scratch = newVariable(LIRKind.value(AArch64Kind.DWORD));
157         append(new CompareAndSwapOp(prevValue, loadReg(expectedValue), loadReg(newValue), asAllocatable(address), scratch));
158         assert trueValue.getValueKind().equals(falseValue.getValueKind());
159         Variable result = newVariable(trueValue.getValueKind());
160         append(new CondMoveOp(result, ConditionFlag.EQ, asAllocatable(trueValue), asAllocatable(falseValue)));
161         return result;
162     }
163 
164     @Override
165     public Variable emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue) {
166         Variable result = newVariable(newValue.getValueKind());
167         Variable scratch = newVariable(LIRKind.value(AArch64Kind.WORD));
<span class="line-modified">168         append(new CompareAndSwapOp(result, loadReg(expectedValue), loadReg(newValue), asAllocatable(address), scratch));</span>
169         return result;
170     }
171 
172     @Override
173     public Value emitAtomicReadAndWrite(Value address, ValueKind&lt;?&gt; kind, Value newValue) {
174         Variable result = newVariable(kind);
175         Variable scratch = newVariable(kind);
176         append(new AtomicReadAndWriteOp((AArch64Kind) kind.getPlatformKind(), asAllocatable(result), asAllocatable(address), asAllocatable(newValue), asAllocatable(scratch)));
177         return result;
178     }
179 
180     @Override
181     public Value emitAtomicReadAndAdd(Value address, ValueKind&lt;?&gt; kind, Value delta) {
182         Variable result = newVariable(kind);
183         if (AArch64LIRFlagsVersioned.useLSE(target().arch)) {
184             append(new AtomicReadAndAddLSEOp((AArch64Kind) kind.getPlatformKind(), asAllocatable(result), asAllocatable(address), asAllocatable(delta)));
185         } else {
186             append(new AtomicReadAndAddOp((AArch64Kind) kind.getPlatformKind(), asAllocatable(result), asAllocatable(address), delta));
187         }
188         return result;
</pre>
<hr />
<pre>
222         ((AArch64ArithmeticLIRGenerator) getArithmetic()).emitBinary(LIRKind.combine(left, right), AArch64ArithmeticOp.ANDS, true, left, right);
223         append(new AArch64ControlFlow.BranchOp(ConditionFlag.EQ, trueDestination, falseDestination, trueSuccessorProbability));
224     }
225 
226     /**
227      * Conditionally move trueValue into new variable if cond + unorderedIsTrue is true, else
228      * falseValue.
229      *
230      * @param left Arbitrary value. Has to have same type as right. Non null.
231      * @param right Arbitrary value. Has to have same type as left. Non null.
232      * @param cond condition that decides whether to move trueValue or falseValue into result. Non
233      *            null.
234      * @param unorderedIsTrue defines whether floating-point comparisons consider unordered true or
235      *            not. Ignored for integer comparisons.
236      * @param trueValue arbitrary value same type as falseValue. Non null.
237      * @param falseValue arbitrary value same type as trueValue. Non null.
238      * @return value containing trueValue if cond + unorderedIsTrue is true, else falseValue. Non
239      *         null.
240      */
241     @Override
<span class="line-modified">242     public Variable emitConditionalMove(PlatformKind cmpKind, Value left, final Value right, Condition cond, boolean unorderedIsTrue, Value trueValue, Value falseValue) {</span>
<span class="line-modified">243         AArch64ArithmeticLIRGenerator arithLir = ((AArch64ArithmeticLIRGenerator) arithmeticLIRGen);</span>
<span class="line-added">244         Value actualRight = right;</span>
<span class="line-added">245         if (isJavaConstant(actualRight) &amp;&amp; arithLir.mustReplaceNullWithNullRegister((asJavaConstant(actualRight)))) {</span>
<span class="line-added">246             actualRight = arithLir.getNullRegisterValue();</span>
<span class="line-added">247         }</span>
<span class="line-added">248         boolean mirrored = emitCompare(cmpKind, left, actualRight, cond, unorderedIsTrue);</span>
249         Condition finalCondition = mirrored ? cond.mirror() : cond;
250         boolean finalUnorderedIsTrue = mirrored ? !unorderedIsTrue : unorderedIsTrue;
251         ConditionFlag cmpCondition = toConditionFlag(((AArch64Kind) cmpKind).isInteger(), finalCondition, finalUnorderedIsTrue);
252         Variable result = newVariable(trueValue.getValueKind());
253 
254         if (isIntConstant(trueValue, 1) &amp;&amp; isIntConstant(falseValue, 0)) {
255             append(new CondSetOp(result, cmpCondition));
256         } else if (isIntConstant(trueValue, 0) &amp;&amp; isIntConstant(falseValue, 1)) {
257             append(new CondSetOp(result, cmpCondition.negate()));
258         } else {
259             append(new CondMoveOp(result, cmpCondition, loadReg(trueValue), loadReg(falseValue)));
260         }
261         return result;
262     }
263 
264     @Override
<span class="line-modified">265     public void emitCompareBranch(PlatformKind cmpKind, Value left, final Value right, Condition cond, boolean unorderedIsTrue, LabelRef trueDestination, LabelRef falseDestination,</span>
266                     double trueDestinationProbability) {
<span class="line-added">267         Value actualRight = right;</span>
268         if (cond == Condition.EQ) {
269             // emit cbz instruction for IsNullNode.
270             assert !LIRValueUtil.isNullConstant(left) : &quot;emitNullCheckBranch()&#39;s null input should be in right.&quot;;
<span class="line-modified">271             AArch64ArithmeticLIRGenerator arithLir = ((AArch64ArithmeticLIRGenerator) arithmeticLIRGen);</span>
<span class="line-modified">272             if (LIRValueUtil.isNullConstant(actualRight)) {</span>
<span class="line-modified">273                 JavaConstant rightConstant = asJavaConstant(actualRight);</span>
<span class="line-added">274                 if (arithLir.mustReplaceNullWithNullRegister(rightConstant)) {</span>
<span class="line-added">275                     actualRight = arithLir.getNullRegisterValue();</span>
<span class="line-added">276                 } else {</span>
<span class="line-added">277                     append(new CompareBranchZeroOp(asAllocatable(left), trueDestination, falseDestination,</span>
<span class="line-added">278                                     trueDestinationProbability));</span>
<span class="line-added">279                     return;</span>
<span class="line-added">280                 }</span>
281             }
282 
283             // emit cbz instruction for IntegerEquals when any of the inputs is zero.
284             AArch64Kind kind = (AArch64Kind) cmpKind;
285             if (kind.isInteger()) {
286                 if (isIntConstant(left, 0)) {
<span class="line-modified">287                     append(new CompareBranchZeroOp(asAllocatable(actualRight), trueDestination, falseDestination, trueDestinationProbability));</span>
288                     return;
<span class="line-modified">289                 } else if (isIntConstant(actualRight, 0)) {</span>
290                     append(new CompareBranchZeroOp(asAllocatable(left), trueDestination, falseDestination, trueDestinationProbability));
291                     return;
292                 }
293             }
294         }
295 
<span class="line-modified">296         boolean mirrored = emitCompare(cmpKind, left, actualRight, cond, unorderedIsTrue);</span>
297         Condition finalCondition = mirrored ? cond.mirror() : cond;
298         boolean finalUnorderedIsTrue = mirrored ? !unorderedIsTrue : unorderedIsTrue;
299         ConditionFlag cmpCondition = toConditionFlag(((AArch64Kind) cmpKind).isInteger(), finalCondition, finalUnorderedIsTrue);
300         append(new BranchOp(cmpCondition, trueDestination, falseDestination, trueDestinationProbability));
301     }
302 
303     private static ConditionFlag toConditionFlag(boolean isInt, Condition cond, boolean unorderedIsTrue) {
304         return isInt ? toIntConditionFlag(cond) : toFloatConditionFlag(cond, unorderedIsTrue);
305     }
306 
307     /**
308      * Takes a Condition and unorderedIsTrue flag and returns the correct Aarch64 specific
309      * ConditionFlag. Note: This is only correct if the emitCompare code for floats has correctly
310      * handled the case of &#39;EQ &amp;&amp; unorderedIsTrue&#39;, respectively &#39;NE &amp;&amp; !unorderedIsTrue&#39;!
311      */
312     private static ConditionFlag toFloatConditionFlag(Condition cond, boolean unorderedIsTrue) {
313         switch (cond) {
314             case LT:
315                 return unorderedIsTrue ? ConditionFlag.LT : ConditionFlag.LO;
316             case LE:
</pre>
<hr />
<pre>
514         append(new AArch64ByteSwapOp(result, input));
515         return result;
516     }
517 
518     @Override
519     public Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
520         LIRKind resultKind = LIRKind.value(AArch64Kind.DWORD);
521         // DMS TODO: check calling conversion and registers used
522         RegisterValue res = AArch64.r0.asValue(resultKind);
523         RegisterValue cnt1 = AArch64.r1.asValue(length1.getValueKind());
524         RegisterValue cnt2 = AArch64.r2.asValue(length2.getValueKind());
525         emitMove(cnt1, length1);
526         emitMove(cnt2, length2);
527         append(new AArch64ArrayCompareToOp(this, kind1, kind2, res, array1, array2, cnt1, cnt2));
528         Variable result = newVariable(resultKind);
529         emitMove(result, res);
530         return result;
531     }
532 
533     @Override
<span class="line-modified">534     public Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, boolean directPointers) {</span>
535         Variable result = newVariable(LIRKind.value(AArch64Kind.DWORD));
536         append(new AArch64ArrayEqualsOp(this, kind, result, array1, array2, asAllocatable(length), directPointers));
537         return result;
538     }
539 
540     @Override
541     protected JavaConstant zapValueForKind(PlatformKind kind) {
542         long dead = 0xDEADDEADDEADDEADL;
543         switch ((AArch64Kind) kind) {
544             case BYTE:
545                 return JavaConstant.forByte((byte) dead);
546             case WORD:
547                 return JavaConstant.forShort((short) dead);
548             case DWORD:
549                 return JavaConstant.forInt((int) dead);
550             case QWORD:
551                 return JavaConstant.forLong(dead);
552             case SINGLE:
553                 return JavaConstant.forFloat(Float.intBitsToFloat((int) dead));
554             case DOUBLE:
</pre>
<hr />
<pre>
567      * [x0] instead of: ldr x0, [x19].
568      */
569     protected AllocatableValue loadReg(Value val) {
570         if (!(val instanceof Variable || val instanceof RegisterValue)) {
571             return emitMove(val);
572         }
573         return (AllocatableValue) val;
574     }
575 
576     @Override
577     public void emitPause() {
578         append(new AArch64PauseOp());
579     }
580 
581     public abstract void emitCCall(long address, CallingConvention nativeCallingConvention, Value[] args);
582 
583     @Override
584     public void emitSpeculationFence() {
585         append(new AArch64SpeculativeBarrier());
586     }
<span class="line-added">587 </span>
<span class="line-added">588     @Override</span>
<span class="line-added">589     public void emitZeroMemory(Value address, Value length, boolean isAligned) {</span>
<span class="line-added">590         emitZeroMemory(address, length, isAligned, false, -1);</span>
<span class="line-added">591     }</span>
<span class="line-added">592 </span>
<span class="line-added">593     protected final void emitZeroMemory(Value address, Value length, boolean isAligned, boolean useDcZva, int zvaLength) {</span>
<span class="line-added">594         RegisterValue regAddress = AArch64.r0.asValue(address.getValueKind());</span>
<span class="line-added">595         RegisterValue regLength = AArch64.r1.asValue(length.getValueKind());</span>
<span class="line-added">596         emitMove(regAddress, address);</span>
<span class="line-added">597         emitMove(regLength, length);</span>
<span class="line-added">598         append(new AArch64ZeroMemoryOp(regAddress, regLength, isAligned, useDcZva, zvaLength));</span>
<span class="line-added">599     }</span>
600 }
</pre>
</td>
</tr>
</table>
<center><a href="AArch64ArithmeticLIRGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64NodeMatchRules.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
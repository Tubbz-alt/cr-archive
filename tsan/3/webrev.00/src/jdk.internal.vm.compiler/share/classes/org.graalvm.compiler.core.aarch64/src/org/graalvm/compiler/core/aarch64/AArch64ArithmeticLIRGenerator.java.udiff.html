<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64ArithmeticLIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64TestBitAndBranchTest.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64LIRGenerator.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64ArithmeticLIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30,10 +30,11 @@</span>
  import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
  import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
  import static org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp.BitManipulationOpCode.BSR;
  import static org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp.BitManipulationOpCode.CLZ;
  import static org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp.BitManipulationOpCode.CTZ;
<span class="udiff-line-added">+ import static org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp.BitManipulationOpCode.POPCNT;</span>
  
  import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.core.common.NumUtil;
  import org.graalvm.compiler.core.common.calc.FloatConvert;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -60,15 +61,30 @@</span>
  import jdk.vm.ci.meta.Value;
  import jdk.vm.ci.meta.ValueKind;
  
  public class AArch64ArithmeticLIRGenerator extends ArithmeticLIRGenerator implements AArch64ArithmeticLIRGeneratorTool {
  
<span class="udiff-line-added">+     public AArch64ArithmeticLIRGenerator(AllocatableValue nullRegisterValue) {</span>
<span class="udiff-line-added">+         this.nullRegisterValue = nullRegisterValue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private final AllocatableValue nullRegisterValue;</span>
<span class="udiff-line-added">+ </span>
      @Override
      public AArch64LIRGenerator getLIRGen() {
          return (AArch64LIRGenerator) super.getLIRGen();
      }
  
<span class="udiff-line-added">+     public boolean mustReplaceNullWithNullRegister(JavaConstant nullConstant) {</span>
<span class="udiff-line-added">+         /* Uncompressed null pointers only */</span>
<span class="udiff-line-added">+         return nullRegisterValue != null &amp;&amp; JavaConstant.NULL_POINTER.equals(nullConstant);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public AllocatableValue getNullRegisterValue() {</span>
<span class="udiff-line-added">+         return nullRegisterValue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @Override
      protected boolean isNumericInteger(PlatformKind kind) {
          return ((AArch64Kind) kind).isInteger();
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -202,24 +218,38 @@</span>
          Variable result = getLIRGen().newVariable(resultLirKind);
          getLIRGen().append(new AArch64FloatConvertOp(op, result, asAllocatable(inputVal)));
          return result;
      }
  
<span class="udiff-line-modified-removed">-     public Value emitMAdd(Value a, Value b, Value c) {</span>
<span class="udiff-line-modified-removed">-         return emitMultiplyAddSub(AArch64ArithmeticOp.ADD, a, b, c);</span>
<span class="udiff-line-modified-added">+     Value emitIntegerMAdd(Value a, Value b, Value c, boolean isI2L) {</span>
<span class="udiff-line-modified-added">+         return emitMultiplyAddSub(isI2L ? AArch64ArithmeticOp.SMADDL : AArch64ArithmeticOp.MADD, a, b, c);</span>
      }
  
<span class="udiff-line-modified-removed">-     public Value emitMSub(Value a, Value b, Value c) {</span>
<span class="udiff-line-modified-removed">-         return emitMultiplyAddSub(AArch64ArithmeticOp.SUB, a, b, c);</span>
<span class="udiff-line-modified-added">+     Value emitIntegerMSub(Value a, Value b, Value c, boolean isI2L) {</span>
<span class="udiff-line-modified-added">+         return emitMultiplyAddSub(isI2L ? AArch64ArithmeticOp.SMSUBL : AArch64ArithmeticOp.MSUB, a, b, c);</span>
      }
  
      private Value emitMultiplyAddSub(AArch64ArithmeticOp op, Value a, Value b, Value c) {
<span class="udiff-line-modified-removed">-         assert isNumericInteger(a.getPlatformKind());</span>
<span class="udiff-line-modified-removed">-         assert isNumericInteger(b.getPlatformKind());</span>
<span class="udiff-line-modified-removed">-         assert isNumericInteger(c.getPlatformKind());</span>
<span class="udiff-line-modified-added">+         assert a.getPlatformKind() == b.getPlatformKind();</span>
<span class="udiff-line-modified-added">+         Variable result;</span>
<span class="udiff-line-modified-added">+         if (op == AArch64ArithmeticOp.SMADDL || op == AArch64ArithmeticOp.SMSUBL) {</span>
<span class="udiff-line-added">+             // For signed multiply int and then add/sub long.</span>
<span class="udiff-line-added">+             assert a.getPlatformKind() != c.getPlatformKind();</span>
<span class="udiff-line-added">+             result = getLIRGen().newVariable(LIRKind.combine(c));</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             assert a.getPlatformKind() == c.getPlatformKind();</span>
<span class="udiff-line-added">+             if (op == AArch64ArithmeticOp.FADD) {</span>
<span class="udiff-line-added">+                 // For floating-point Math.fma intrinsic.</span>
<span class="udiff-line-added">+                 assert a.getPlatformKind() == AArch64Kind.SINGLE || a.getPlatformKind() == AArch64Kind.DOUBLE;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 // For int/long multiply add or sub.</span>
<span class="udiff-line-added">+                 assert op == AArch64ArithmeticOp.MADD || op == AArch64ArithmeticOp.MSUB;</span>
<span class="udiff-line-added">+                 assert isNumericInteger(a.getPlatformKind());</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             result = getLIRGen().newVariable(LIRKind.combine(a, b, c));</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-removed">-         Variable result = getLIRGen().newVariable(LIRKind.combine(a, b, c));</span>
          AllocatableValue x = moveSp(asAllocatable(a));
          AllocatableValue y = moveSp(asAllocatable(b));
          AllocatableValue z = moveSp(asAllocatable(c));
          getLIRGen().append(new AArch64ArithmeticOp.MultiplyAddSubOp(op, result, x, y, z));
          return result;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -415,31 +445,39 @@</span>
          throw GraalError.unimplemented();
      }
  
      @Override
      public Value emitBitCount(Value operand) {
<span class="udiff-line-modified-removed">-         throw GraalError.unimplemented(&quot;AArch64 ISA does not offer way to implement this more efficiently than a simple Java algorithm.&quot;);</span>
<span class="udiff-line-modified-added">+         assert ((AArch64Kind) operand.getPlatformKind()).isInteger();</span>
<span class="udiff-line-added">+         Variable result = getLIRGen().newVariable(LIRKind.combine(operand).changeType(AArch64Kind.DWORD));</span>
<span class="udiff-line-added">+         getLIRGen().append(new AArch64BitManipulationOp(getLIRGen(), POPCNT, result, asAllocatable(operand)));</span>
<span class="udiff-line-added">+         return result;</span>
      }
  
      @Override
      public Value emitBitScanReverse(Value value) {
          Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AArch64Kind.DWORD));
<span class="udiff-line-modified-removed">-         getLIRGen().append(new AArch64BitManipulationOp(BSR, result, asAllocatable(value)));</span>
<span class="udiff-line-modified-added">+         getLIRGen().append(new AArch64BitManipulationOp(getLIRGen(), BSR, result, asAllocatable(value)));</span>
          return result;
      }
  
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public Value emitFusedMultiplyAdd(Value a, Value b, Value c) {</span>
<span class="udiff-line-added">+         return emitMultiplyAddSub(AArch64ArithmeticOp.FMADD, a, b, c);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @Override
      public Value emitCountLeadingZeros(Value value) {
          Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AArch64Kind.DWORD));
<span class="udiff-line-modified-removed">-         getLIRGen().append(new AArch64BitManipulationOp(CLZ, result, asAllocatable(value)));</span>
<span class="udiff-line-modified-added">+         getLIRGen().append(new AArch64BitManipulationOp(getLIRGen(), CLZ, result, asAllocatable(value)));</span>
          return result;
      }
  
      @Override
      public Value emitCountTrailingZeros(Value value) {
          Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AArch64Kind.DWORD));
<span class="udiff-line-modified-removed">-         getLIRGen().append(new AArch64BitManipulationOp(CTZ, result, asAllocatable(value)));</span>
<span class="udiff-line-modified-added">+         getLIRGen().append(new AArch64BitManipulationOp(getLIRGen(), CTZ, result, asAllocatable(value)));</span>
          return result;
      }
  
      private Variable emitUnary(AArch64ArithmeticOp op, Value inputVal) {
          AllocatableValue input = asAllocatable(inputVal);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -482,15 +520,10 @@</span>
          }
          AllocatableValue input = asAllocatable(inputVal);
          getLIRGen().append(new StoreOp(kind, storeAddress, input, state));
      }
  
<span class="udiff-line-removed">-     @Override</span>
<span class="udiff-line-removed">-     public void emitCompareOp(AArch64Kind cmpKind, Variable left, Value right) {</span>
<span class="udiff-line-removed">-         throw GraalError.unimplemented();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      @Override
      public Value emitRound(Value value, RoundingMode mode) {
          AArch64ArithmeticOp op;
          switch (mode) {
              case NEAREST:
</pre>
<center><a href="../../../../../../../org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64TestBitAndBranchTest.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64LIRGenerator.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
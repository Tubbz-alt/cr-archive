<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package org.graalvm.compiler.core.aarch64;
 27 
<a name="2" id="anc2"></a><span class="line-added"> 28 import jdk.vm.ci.aarch64.AArch64Kind;</span>
<span class="line-added"> 29 import jdk.vm.ci.code.CodeUtil;</span>
 30 import jdk.vm.ci.meta.AllocatableValue;
 31 import jdk.vm.ci.meta.JavaKind;
 32 import jdk.vm.ci.meta.Value;
 33 import jdk.internal.vm.compiler.collections.EconomicMap;
 34 import jdk.internal.vm.compiler.collections.Equivalence;
 35 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 36 import org.graalvm.compiler.core.common.LIRKind;
<a name="3" id="anc3"></a><span class="line-added"> 37 import org.graalvm.compiler.core.common.calc.CanonicalCondition;</span>
 38 import org.graalvm.compiler.core.gen.NodeMatchRules;
 39 import org.graalvm.compiler.core.match.ComplexMatchResult;
 40 import org.graalvm.compiler.core.match.MatchRule;
<a name="4" id="anc4"></a>
 41 import org.graalvm.compiler.lir.LIRFrameState;
 42 import org.graalvm.compiler.lir.LabelRef;
 43 import org.graalvm.compiler.lir.Variable;
 44 import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp;
<a name="5" id="anc5"></a><span class="line-added"> 45 import org.graalvm.compiler.lir.aarch64.AArch64BitFieldOp;</span>
 46 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow;
 47 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 48 import org.graalvm.compiler.nodes.ConstantNode;
 49 import org.graalvm.compiler.nodes.DeoptimizingNode;
<a name="6" id="anc6"></a><span class="line-added"> 50 import org.graalvm.compiler.nodes.FixedNode;</span>
 51 import org.graalvm.compiler.nodes.IfNode;
 52 import org.graalvm.compiler.nodes.NodeView;
 53 import org.graalvm.compiler.nodes.ValueNode;
 54 import org.graalvm.compiler.nodes.calc.AddNode;
 55 import org.graalvm.compiler.nodes.calc.AndNode;
 56 import org.graalvm.compiler.nodes.calc.BinaryNode;
<a name="7" id="anc7"></a><span class="line-added"> 57 import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;</span>
 58 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
<a name="8" id="anc8"></a><span class="line-added"> 59 import org.graalvm.compiler.nodes.calc.MulNode;</span>
<span class="line-added"> 60 import org.graalvm.compiler.nodes.calc.NarrowNode;</span>
<span class="line-added"> 61 import org.graalvm.compiler.nodes.calc.NegateNode;</span>
 62 import org.graalvm.compiler.nodes.calc.NotNode;
 63 import org.graalvm.compiler.nodes.calc.OrNode;
 64 import org.graalvm.compiler.nodes.calc.RightShiftNode;
 65 import org.graalvm.compiler.nodes.calc.SubNode;
<a name="9" id="anc9"></a><span class="line-added"> 66 import org.graalvm.compiler.nodes.calc.UnaryNode;</span>
 67 import org.graalvm.compiler.nodes.calc.UnsignedRightShiftNode;
 68 import org.graalvm.compiler.nodes.calc.XorNode;
 69 import org.graalvm.compiler.nodes.memory.Access;
 70 
<a name="10" id="anc10"></a>

 71 public class AArch64NodeMatchRules extends NodeMatchRules {
<a name="11" id="anc11"></a><span class="line-modified"> 72     private static final EconomicMap&lt;Class&lt;? extends BinaryNode&gt;, AArch64ArithmeticOp&gt; binaryOpMap;</span>
<span class="line-modified"> 73     private static final EconomicMap&lt;Class&lt;? extends BinaryNode&gt;, AArch64BitFieldOp.BitFieldOpCode&gt; bitFieldOpMap;</span>
 74     private static final EconomicMap&lt;Class&lt;? extends BinaryNode&gt;, AArch64MacroAssembler.ShiftType&gt; shiftTypeMap;
 75 
 76     static {
<a name="12" id="anc12"></a><span class="line-modified"> 77         binaryOpMap = EconomicMap.create(Equivalence.IDENTITY, 9);</span>
<span class="line-modified"> 78         binaryOpMap.put(AddNode.class, AArch64ArithmeticOp.ADD);</span>
<span class="line-modified"> 79         binaryOpMap.put(SubNode.class, AArch64ArithmeticOp.SUB);</span>
<span class="line-modified"> 80         binaryOpMap.put(MulNode.class, AArch64ArithmeticOp.MUL);</span>
<span class="line-modified"> 81         binaryOpMap.put(AndNode.class, AArch64ArithmeticOp.AND);</span>
<span class="line-modified"> 82         binaryOpMap.put(OrNode.class, AArch64ArithmeticOp.OR);</span>
<span class="line-added"> 83         binaryOpMap.put(XorNode.class, AArch64ArithmeticOp.XOR);</span>
<span class="line-added"> 84         binaryOpMap.put(LeftShiftNode.class, AArch64ArithmeticOp.SHL);</span>
<span class="line-added"> 85         binaryOpMap.put(RightShiftNode.class, AArch64ArithmeticOp.ASHR);</span>
<span class="line-added"> 86         binaryOpMap.put(UnsignedRightShiftNode.class, AArch64ArithmeticOp.LSHR);</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88         bitFieldOpMap = EconomicMap.create(Equivalence.IDENTITY, 2);</span>
<span class="line-added"> 89         bitFieldOpMap.put(UnsignedRightShiftNode.class, AArch64BitFieldOp.BitFieldOpCode.UBFX);</span>
<span class="line-added"> 90         bitFieldOpMap.put(LeftShiftNode.class, AArch64BitFieldOp.BitFieldOpCode.UBFIZ);</span>
 91 
 92         shiftTypeMap = EconomicMap.create(Equivalence.IDENTITY, 3);
 93         shiftTypeMap.put(LeftShiftNode.class, AArch64MacroAssembler.ShiftType.LSL);
 94         shiftTypeMap.put(RightShiftNode.class, AArch64MacroAssembler.ShiftType.ASR);
 95         shiftTypeMap.put(UnsignedRightShiftNode.class, AArch64MacroAssembler.ShiftType.LSR);
 96     }
 97 
 98     public AArch64NodeMatchRules(LIRGeneratorTool gen) {
 99         super(gen);
100     }
101 
102     protected LIRFrameState getState(Access access) {
103         if (access instanceof DeoptimizingNode) {
104             return state((DeoptimizingNode) access);
105         }
106         return null;
107     }
108 
109     protected AArch64Kind getMemoryKind(Access access) {
110         return (AArch64Kind) gen.getLIRKind(access.asNode().stamp(NodeView.DEFAULT)).getPlatformKind();
111     }
112 
113     private AllocatableValue moveSp(AllocatableValue value) {
114         return getLIRGeneratorTool().moveSp(value);
115     }
116 
<a name="13" id="anc13"></a><span class="line-modified">117     private ComplexMatchResult emitBitField(AArch64BitFieldOp.BitFieldOpCode op, ValueNode value, int lsb, int width) {</span>
<span class="line-added">118         assert op != null;</span>
<span class="line-added">119         assert value.getStackKind().isNumericInteger();</span>
<span class="line-added">120 </span>
<span class="line-added">121         return builder -&gt; {</span>
<span class="line-added">122             Value a = operand(value);</span>
<span class="line-added">123             Variable result = gen.newVariable(LIRKind.combine(a));</span>
<span class="line-added">124             AllocatableValue src = moveSp(gen.asAllocatable(a));</span>
<span class="line-added">125             gen.append(new AArch64BitFieldOp(op, result, src, lsb, width));</span>
<span class="line-added">126             return result;</span>
<span class="line-added">127         };</span>
<span class="line-added">128     }</span>
<span class="line-added">129 </span>
<span class="line-added">130     private ComplexMatchResult emitBinaryShift(AArch64ArithmeticOp op, ValueNode value, BinaryNode shift,</span>
<span class="line-added">131                     boolean isShiftNot) {</span>
132         AArch64MacroAssembler.ShiftType shiftType = shiftTypeMap.get(shift.getClass());
133         assert shiftType != null;
134         assert value.getStackKind().isNumericInteger();
135         assert shift.getX().getStackKind().isNumericInteger();
136         assert shift.getY() instanceof ConstantNode;
137 
138         return builder -&gt; {
139             Value a = operand(value);
140             Value b = operand(shift.getX());
141             Variable result = gen.newVariable(LIRKind.combine(a, b));
142             AllocatableValue x = moveSp(gen.asAllocatable(a));
143             AllocatableValue y = moveSp(gen.asAllocatable(b));
144             int shiftAmount = shift.getY().asJavaConstant().asInt();
145             gen.append(new AArch64ArithmeticOp.BinaryShiftOp(op, result, x, y, shiftType, shiftAmount, isShiftNot));
146             return result;
147         };
148     }
149 
<a name="14" id="anc14"></a><span class="line-added">150     private ComplexMatchResult emitBitTestAndBranch(FixedNode trueSuccessor, FixedNode falseSuccessor,</span>
<span class="line-added">151                     ValueNode value, double trueProbability, int nbits) {</span>
<span class="line-added">152         return builder -&gt; {</span>
<span class="line-added">153             LabelRef trueDestination = getLIRBlock(trueSuccessor);</span>
<span class="line-added">154             LabelRef falseDestination = getLIRBlock(falseSuccessor);</span>
<span class="line-added">155             AllocatableValue src = moveSp(gen.asAllocatable(operand(value)));</span>
<span class="line-added">156             gen.append(new AArch64ControlFlow.BitTestAndBranchOp(trueDestination, falseDestination, src,</span>
<span class="line-added">157                             trueProbability, nbits));</span>
<span class="line-added">158             return null;</span>
<span class="line-added">159         };</span>
<span class="line-added">160     }</span>
<span class="line-added">161 </span>
<span class="line-added">162     private static boolean isNarrowingLongToInt(NarrowNode narrow) {</span>
<span class="line-added">163         return narrow.getInputBits() == 64 &amp;&amp; narrow.getResultBits() == 32;</span>
<span class="line-added">164     }</span>
<span class="line-added">165 </span>
<span class="line-added">166     @MatchRule(&quot;(And (UnsignedRightShift=shift a Constant=b) Constant=c)&quot;)</span>
<span class="line-added">167     @MatchRule(&quot;(LeftShift=shift (And a Constant=c) Constant=b)&quot;)</span>
<span class="line-added">168     public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode a, ConstantNode b, ConstantNode c) {</span>
<span class="line-added">169         JavaKind srcKind = a.getStackKind();</span>
<span class="line-added">170         assert srcKind.isNumericInteger();</span>
<span class="line-added">171         AArch64BitFieldOp.BitFieldOpCode op = bitFieldOpMap.get(shift.getClass());</span>
<span class="line-added">172         assert op != null;</span>
<span class="line-added">173         int distance = b.asJavaConstant().asInt();</span>
<span class="line-added">174         long mask = c.asJavaConstant().asLong();</span>
<span class="line-added">175 </span>
<span class="line-added">176         // The Java(R) Language Specification CHAPTER 15.19 Shift Operators says:</span>
<span class="line-added">177         // &quot;If the promoted type of the left-hand operand is int(long), then only the five(six)</span>
<span class="line-added">178         // lowest-order bits of the right-hand operand are used as the shift distance.&quot;</span>
<span class="line-added">179         distance = distance &amp; (srcKind == JavaKind.Int ? 0x1f : 0x3f);</span>
<span class="line-added">180 </span>
<span class="line-added">181         // Constraint 1: Mask plus one should be a power-of-2 integer.</span>
<span class="line-added">182         if (!CodeUtil.isPowerOf2(mask + 1)) {</span>
<span class="line-added">183             return null;</span>
<span class="line-added">184         }</span>
<span class="line-added">185         int width = CodeUtil.log2(mask + 1);</span>
<span class="line-added">186         int srcBits = srcKind.getBitCount();</span>
<span class="line-added">187         // Constraint 2: Bit field width is less than 31(63) for int(long) as any bit field move</span>
<span class="line-added">188         // operations can be done by a single shift instruction if the width is 31(63).</span>
<span class="line-added">189         if (width &gt;= srcBits - 1) {</span>
<span class="line-added">190             return null;</span>
<span class="line-added">191         }</span>
<span class="line-added">192         // Constraint 3: Sum of bit field width and the shift distance is less or equal to 32(64)</span>
<span class="line-added">193         // for int(long) as the specification of AArch64 bit field instructions.</span>
<span class="line-added">194         if (width + distance &gt; srcBits) {</span>
<span class="line-added">195             return null;</span>
<span class="line-added">196         }</span>
<span class="line-added">197         return emitBitField(op, a, distance, width);</span>
<span class="line-added">198     }</span>
<span class="line-added">199 </span>
200     @MatchRule(&quot;(Add=binary a (LeftShift=shift b Constant))&quot;)
201     @MatchRule(&quot;(Add=binary a (RightShift=shift b Constant))&quot;)
202     @MatchRule(&quot;(Add=binary a (UnsignedRightShift=shift b Constant))&quot;)
203     @MatchRule(&quot;(Sub=binary a (LeftShift=shift b Constant))&quot;)
204     @MatchRule(&quot;(Sub=binary a (RightShift=shift b Constant))&quot;)
205     @MatchRule(&quot;(Sub=binary a (UnsignedRightShift=shift b Constant))&quot;)
206     public ComplexMatchResult addSubShift(BinaryNode binary, ValueNode a, BinaryNode shift) {
<a name="15" id="anc15"></a><span class="line-modified">207         AArch64ArithmeticOp op = binaryOpMap.get(binary.getClass());</span>
208         assert op != null;
209         return emitBinaryShift(op, a, shift, false);
210     }
211 
212     @MatchRule(&quot;(And=binary a (LeftShift=shift b Constant))&quot;)
213     @MatchRule(&quot;(And=binary a (RightShift=shift b Constant))&quot;)
214     @MatchRule(&quot;(And=binary a (UnsignedRightShift=shift b Constant))&quot;)
215     @MatchRule(&quot;(Or=binary a (LeftShift=shift b Constant))&quot;)
216     @MatchRule(&quot;(Or=binary a (RightShift=shift b Constant))&quot;)
217     @MatchRule(&quot;(Or=binary a (UnsignedRightShift=shift b Constant))&quot;)
218     @MatchRule(&quot;(Xor=binary a (LeftShift=shift b Constant))&quot;)
219     @MatchRule(&quot;(Xor=binary a (RightShift=shift b Constant))&quot;)
220     @MatchRule(&quot;(Xor=binary a (UnsignedRightShift=shift b Constant))&quot;)
221     @MatchRule(&quot;(And=binary a (Not (LeftShift=shift b Constant)))&quot;)
222     @MatchRule(&quot;(And=binary a (Not (RightShift=shift b Constant)))&quot;)
223     @MatchRule(&quot;(And=binary a (Not (UnsignedRightShift=shift b Constant)))&quot;)
224     @MatchRule(&quot;(Or=binary a (Not (LeftShift=shift b Constant)))&quot;)
225     @MatchRule(&quot;(Or=binary a (Not (RightShift=shift b Constant)))&quot;)
226     @MatchRule(&quot;(Or=binary a (Not (UnsignedRightShift=shift b Constant)))&quot;)
227     @MatchRule(&quot;(Xor=binary a (Not (LeftShift=shift b Constant)))&quot;)
228     @MatchRule(&quot;(Xor=binary a (Not (RightShift=shift b Constant)))&quot;)
229     @MatchRule(&quot;(Xor=binary a (Not (UnsignedRightShift=shift b Constant)))&quot;)
230     public ComplexMatchResult logicShift(BinaryNode binary, ValueNode a, BinaryNode shift) {
<a name="16" id="anc16"></a><span class="line-modified">231         AArch64ArithmeticOp op = binaryOpMap.get(binary.getClass());</span>
232         assert op != null;
233         ValueNode operand = binary.getX() == a ? binary.getY() : binary.getX();
234         boolean isShiftNot = operand instanceof NotNode;
235         return emitBinaryShift(op, a, shift, isShiftNot);
236     }
237 
<a name="17" id="anc17"></a><span class="line-added">238     @MatchRule(&quot;(Add=binary (Mul (SignExtend a) (SignExtend b)) c)&quot;)</span>
<span class="line-added">239     @MatchRule(&quot;(Sub=binary c (Mul (SignExtend a) (SignExtend b)))&quot;)</span>
<span class="line-added">240     public ComplexMatchResult signedMultiplyAddSubLong(BinaryNode binary, ValueNode a, ValueNode b, ValueNode c) {</span>
<span class="line-added">241         assert a.getStackKind() == JavaKind.Int &amp;&amp; b.getStackKind() == JavaKind.Int &amp;&amp; c.getStackKind() == JavaKind.Long;</span>
<span class="line-added">242         if (binary instanceof AddNode) {</span>
<span class="line-added">243             return builder -&gt; getArithmeticLIRGenerator().emitIntegerMAdd(operand(a), operand(b), operand(c), true);</span>
<span class="line-added">244         }</span>
<span class="line-added">245         return builder -&gt; getArithmeticLIRGenerator().emitIntegerMSub(operand(a), operand(b), operand(c), true);</span>
<span class="line-added">246     }</span>
<span class="line-added">247 </span>
<span class="line-added">248     @MatchRule(&quot;(Negate (Mul=mul (SignExtend a) (SignExtend b)))&quot;)</span>
<span class="line-added">249     @MatchRule(&quot;(Mul=mul (Negate (SignExtend a)) (SignExtend b))&quot;)</span>
<span class="line-added">250     public ComplexMatchResult signedMultiplyNegLong(MulNode mul, ValueNode a, ValueNode b) {</span>
<span class="line-added">251         assert a.getStackKind() == JavaKind.Int &amp;&amp; b.getStackKind() == JavaKind.Int;</span>
<span class="line-added">252         LIRKind resultKind = LIRKind.fromJavaKind(gen.target().arch, mul.getStackKind());</span>
<span class="line-added">253         return builder -&gt; getArithmeticLIRGenerator().emitBinary(</span>
<span class="line-added">254                         resultKind, AArch64ArithmeticOp.SMNEGL, true, operand(a), operand(b));</span>
<span class="line-added">255     }</span>
<span class="line-added">256 </span>
<span class="line-added">257     @MatchRule(&quot;(Mul=mul (SignExtend a) (SignExtend b))&quot;)</span>
<span class="line-added">258     public ComplexMatchResult signedMultiplyLong(MulNode mul, ValueNode a, ValueNode b) {</span>
<span class="line-added">259         assert a.getStackKind() == JavaKind.Int &amp;&amp; b.getStackKind() == JavaKind.Int;</span>
<span class="line-added">260         LIRKind resultKind = LIRKind.fromJavaKind(gen.target().arch, mul.getStackKind());</span>
<span class="line-added">261         return builder -&gt; getArithmeticLIRGenerator().emitBinary(</span>
<span class="line-added">262                         resultKind, AArch64ArithmeticOp.SMULL, true, operand(a), operand(b));</span>
<span class="line-added">263     }</span>
<span class="line-added">264 </span>
<span class="line-added">265     @MatchRule(&quot;(Add=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">266     @MatchRule(&quot;(Sub=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">267     @MatchRule(&quot;(Mul=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">268     @MatchRule(&quot;(And=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">269     @MatchRule(&quot;(Or=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">270     @MatchRule(&quot;(Xor=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">271     @MatchRule(&quot;(LeftShift=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">272     @MatchRule(&quot;(RightShift=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">273     @MatchRule(&quot;(UnsignedRightShift=binary (Narrow=narrow a) (Narrow b))&quot;)</span>
<span class="line-added">274     @MatchRule(&quot;(Add=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">275     @MatchRule(&quot;(Sub=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">276     @MatchRule(&quot;(Mul=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">277     @MatchRule(&quot;(And=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">278     @MatchRule(&quot;(Or=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">279     @MatchRule(&quot;(Xor=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">280     @MatchRule(&quot;(LeftShift=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">281     @MatchRule(&quot;(RightShift=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">282     @MatchRule(&quot;(UnsignedRightShift=binary a (Narrow=narrow b))&quot;)</span>
<span class="line-added">283     @MatchRule(&quot;(Sub=binary (Narrow=narrow a) b)&quot;)</span>
<span class="line-added">284     @MatchRule(&quot;(LeftShift=binary (Narrow=narrow a) b)&quot;)</span>
<span class="line-added">285     @MatchRule(&quot;(RightShift=binary (Narrow=narrow a) b)&quot;)</span>
<span class="line-added">286     @MatchRule(&quot;(UnsignedRightShift=binary (Narrow=narrow a) b)&quot;)</span>
<span class="line-added">287     public ComplexMatchResult elideL2IForBinary(BinaryNode binary, NarrowNode narrow) {</span>
<span class="line-added">288         assert binary.getStackKind().isNumericInteger();</span>
<span class="line-added">289 </span>
<span class="line-added">290         ValueNode a = narrow;</span>
<span class="line-added">291         ValueNode b = binary.getX() == narrow ? binary.getY() : binary.getX();</span>
<span class="line-added">292         boolean isL2Ia = isNarrowingLongToInt((NarrowNode) a);</span>
<span class="line-added">293         boolean isL2Ib = (b instanceof NarrowNode) &amp;&amp; isNarrowingLongToInt((NarrowNode) b);</span>
<span class="line-added">294         if (!isL2Ia &amp;&amp; !isL2Ib) {</span>
<span class="line-added">295             return null;</span>
<span class="line-added">296         }</span>
<span class="line-added">297         // Get the value of L2I NarrowNode as the src value.</span>
<span class="line-added">298         ValueNode src1 = isL2Ia ? ((NarrowNode) a).getValue() : a;</span>
<span class="line-added">299         ValueNode src2 = isL2Ib ? ((NarrowNode) b).getValue() : b;</span>
<span class="line-added">300 </span>
<span class="line-added">301         AArch64ArithmeticOp op = binaryOpMap.get(binary.getClass());</span>
<span class="line-added">302         assert op != null;</span>
<span class="line-added">303         boolean commutative = binary.getNodeClass().isCommutative();</span>
<span class="line-added">304         LIRKind resultKind = LIRKind.fromJavaKind(gen.target().arch, binary.getStackKind());</span>
<span class="line-added">305 </span>
<span class="line-added">306         // Must keep the right operator order for un-commutative binary operations.</span>
<span class="line-added">307         if (a == binary.getX()) {</span>
<span class="line-added">308             return builder -&gt; getArithmeticLIRGenerator().emitBinary(</span>
<span class="line-added">309                             resultKind, op, commutative, operand(src1), operand(src2));</span>
<span class="line-added">310         }</span>
<span class="line-added">311         return builder -&gt; getArithmeticLIRGenerator().emitBinary(</span>
<span class="line-added">312                         resultKind, op, commutative, operand(src2), operand(src1));</span>
<span class="line-added">313     }</span>
<span class="line-added">314 </span>
<span class="line-added">315     @MatchRule(&quot;(Negate=unary (Narrow=narrow value))&quot;)</span>
<span class="line-added">316     @MatchRule(&quot;(Not=unary (Narrow=narrow value))&quot;)</span>
<span class="line-added">317     public ComplexMatchResult elideL2IForUnary(UnaryNode unary, NarrowNode narrow) {</span>
<span class="line-added">318         assert unary.getStackKind().isNumericInteger();</span>
<span class="line-added">319         if (!isNarrowingLongToInt(narrow)) {</span>
<span class="line-added">320             return null;</span>
<span class="line-added">321         }</span>
<span class="line-added">322 </span>
<span class="line-added">323         AArch64ArithmeticOp op = unary instanceof NegateNode ? AArch64ArithmeticOp.NEG</span>
<span class="line-added">324                         : AArch64ArithmeticOp.NOT;</span>
<span class="line-added">325         return builder -&gt; {</span>
<span class="line-added">326             AllocatableValue input = gen.asAllocatable(operand(narrow.getValue()));</span>
<span class="line-added">327             LIRKind resultKind = LIRKind.fromJavaKind(gen.target().arch, unary.getStackKind());</span>
<span class="line-added">328             Variable result = gen.newVariable(resultKind);</span>
<span class="line-added">329             gen.append(new AArch64ArithmeticOp.UnaryOp(op, result, moveSp(input)));</span>
<span class="line-added">330             return result;</span>
<span class="line-added">331         };</span>
<span class="line-added">332     }</span>
<span class="line-added">333 </span>
334     @MatchRule(&quot;(Mul (Negate a) b)&quot;)
335     @MatchRule(&quot;(Negate (Mul a b))&quot;)
336     public ComplexMatchResult multiplyNegate(ValueNode a, ValueNode b) {
337         if (a.getStackKind().isNumericInteger() &amp;&amp; b.getStackKind().isNumericInteger()) {
338             return builder -&gt; getArithmeticLIRGenerator().emitMNeg(operand(a), operand(b));
339         }
340         return null;
341     }
342 
343     @MatchRule(&quot;(Add=binary (Mul a b) c)&quot;)
344     @MatchRule(&quot;(Sub=binary c (Mul a b))&quot;)
345     public ComplexMatchResult multiplyAddSub(BinaryNode binary, ValueNode a, ValueNode b, ValueNode c) {
346         JavaKind kindA = a.getStackKind();
347         JavaKind kindB = b.getStackKind();
348         JavaKind kindC = c.getStackKind();
349         if (!kindA.isNumericInteger() || !kindB.isNumericInteger() || !kindC.isNumericInteger()) {
350             return null;
351         }
352 
353         if (binary instanceof AddNode) {
<a name="18" id="anc18"></a><span class="line-modified">354             return builder -&gt; getArithmeticLIRGenerator().emitIntegerMAdd(operand(a), operand(b), operand(c), false);</span>
355         }
<a name="19" id="anc19"></a><span class="line-modified">356         return builder -&gt; getArithmeticLIRGenerator().emitIntegerMSub(operand(a), operand(b), operand(c), false);</span>
357     }
358 
359     /**
360      * ((x &amp; (1 &lt;&lt; n)) == 0) -&gt; tbz/tbnz n label.
361      */
362     @MatchRule(&quot;(If (IntegerTest value Constant=a))&quot;)
363     public ComplexMatchResult testBitAndBranch(IfNode root, ValueNode value, ConstantNode a) {
364         if (value.getStackKind().isNumericInteger()) {
365             long constant = a.asJavaConstant().asLong();
366             if (Long.bitCount(constant) == 1) {
<a name="20" id="anc20"></a><span class="line-modified">367                 return emitBitTestAndBranch(root.trueSuccessor(), root.falseSuccessor(), value,</span>
<span class="line-modified">368                                 root.getTrueSuccessorProbability(), Long.numberOfTrailingZeros(constant));</span>







369             }
370         }
371         return null;
372     }
373 
<a name="21" id="anc21"></a><span class="line-added">374     /**</span>
<span class="line-added">375      * if x &lt; 0 &lt;=&gt; tbz x, sizeOfBits(x) - 1, label.</span>
<span class="line-added">376      */</span>
<span class="line-added">377     @MatchRule(&quot;(If (IntegerLessThan=lessNode x Constant=y))&quot;)</span>
<span class="line-added">378     public ComplexMatchResult checkNegativeAndBranch(IfNode root, IntegerLessThanNode lessNode, ValueNode x, ConstantNode y) {</span>
<span class="line-added">379         JavaKind xKind = x.getStackKind();</span>
<span class="line-added">380         assert xKind.isNumericInteger();</span>
<span class="line-added">381         if (y.isJavaConstant() &amp;&amp; (0 == y.asJavaConstant().asLong()) &amp;&amp; lessNode.condition().equals(CanonicalCondition.LT)) {</span>
<span class="line-added">382             return emitBitTestAndBranch(root.falseSuccessor(), root.trueSuccessor(), x,</span>
<span class="line-added">383                             1.0 - root.getTrueSuccessorProbability(), xKind.getBitCount() - 1);</span>
<span class="line-added">384         }</span>
<span class="line-added">385         return null;</span>
<span class="line-added">386     }</span>
<span class="line-added">387 </span>
388     @Override
389     public AArch64LIRGenerator getLIRGeneratorTool() {
390         return (AArch64LIRGenerator) gen;
391     }
392 
393     protected AArch64ArithmeticLIRGenerator getArithmeticLIRGenerator() {
394         return (AArch64ArithmeticLIRGenerator) getLIRGeneratorTool().getArithmetic();
395     }
396 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.printer/src/org/graalvm/compiler/printer/GraphPrinterDumpHandler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraphPrinter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../org.graalvm.compiler.replacements.aarch64/src/org/graalvm/compiler/replacements/aarch64/AArch64GraphBuilderPlugins.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.printer/src/org/graalvm/compiler/printer/GraphPrinterDumpHandler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.printer;
 26 
 27 import static org.graalvm.compiler.debug.DebugConfig.asJavaMethod;
 28 
 29 import java.io.IOException;
 30 import java.nio.channels.ClosedByInterruptException;
 31 import java.util.ArrayList;
 32 import java.util.Arrays;
 33 import java.util.Collections;
 34 import java.util.Date;
 35 import java.util.HashMap;
 36 import java.util.List;
 37 import java.util.Map;
 38 import java.util.WeakHashMap;
 39 

 40 import org.graalvm.compiler.debug.DebugContext;
 41 import org.graalvm.compiler.debug.DebugDumpHandler;
 42 import org.graalvm.compiler.debug.DebugDumpScope;
 43 import org.graalvm.compiler.debug.DebugOptions;

 44 import org.graalvm.compiler.debug.GraalError;
 45 import org.graalvm.compiler.debug.TTY;
<span class="line-removed"> 46 import org.graalvm.compiler.debug.DebugOptions.PrintGraphTarget;</span>
 47 import org.graalvm.compiler.graph.Graph;
 48 import org.graalvm.compiler.nodes.StructuredGraph;
 49 import org.graalvm.compiler.options.OptionValues;
 50 import org.graalvm.compiler.phases.contract.NodeCostUtil;
 51 import org.graalvm.compiler.serviceprovider.GraalServices;
 52 
 53 import jdk.vm.ci.meta.JavaMethod;
 54 import jdk.vm.ci.meta.ResolvedJavaMethod;

 55 
 56 //JaCoCo Exclude
 57 
 58 /**
 59  * Observes compilation events and uses {@link BinaryGraphPrinter} to generate a graph
 60  * representation that can be inspected with the Graph Visualizer.
 61  */
 62 public class GraphPrinterDumpHandler implements DebugDumpHandler {
 63 
 64     private static final int FAILURE_LIMIT = 8;
 65     private final GraphPrinterSupplier printerSupplier;
 66     protected GraphPrinter printer;
 67     private List&lt;String&gt; previousInlineContext;

 68     private int[] dumpIds = {};
 69     private int failuresCount;
 70     private Map&lt;Graph, List&lt;String&gt;&gt; inlineContextMap;
 71     private final String jvmArguments;
 72     private final String sunJavaCommand;
 73 
 74     @FunctionalInterface
 75     public interface GraphPrinterSupplier {
 76         GraphPrinter get(DebugContext ctx, Graph graph) throws IOException;
 77     }
 78 
 79     /**
 80      * Creates a new {@link GraphPrinterDumpHandler}.
 81      *
 82      * @param printerSupplier Supplier used to create the GraphPrinter. Should supply an optional or
 83      *            null in case of failure.
 84      */
 85     public GraphPrinterDumpHandler(GraphPrinterSupplier printerSupplier) {
 86         this.printerSupplier = printerSupplier;
 87         /* Add the JVM and Java arguments to the graph properties to help identify it. */
 88         this.jvmArguments = jvmArguments();
<span class="line-modified"> 89         this.sunJavaCommand = System.getProperty(&quot;sun.java.command&quot;);</span>
 90     }
 91 
 92     private static String jvmArguments() {
 93         List&lt;String&gt; inputArguments = GraalServices.getInputArguments();
 94         if (inputArguments != null) {
 95             return String.join(&quot; &quot;, inputArguments);
 96         }
 97         return &quot;unknown&quot;;
 98     }
 99 
100     private void ensureInitialized(DebugContext ctx, Graph graph) {
101         if (printer == null) {
102             if (failuresCount &gt;= FAILURE_LIMIT) {
103                 return;
104             }
105             previousInlineContext = new ArrayList&lt;&gt;();
106             inlineContextMap = new WeakHashMap&lt;&gt;();
107             DebugContext debug = graph.getDebug();
108             try {
109                 printer = printerSupplier.get(ctx, graph);
</pre>
<hr />
<pre>
118         if (dumpIds.length &lt; depth) {
119             dumpIds = Arrays.copyOf(dumpIds, depth);
120         }
121         return dumpIds[depth - 1]++;
122     }
123 
124     @Override
125     @SuppressWarnings(&quot;try&quot;)
126     public void dump(DebugContext debug, Object object, final String format, Object... arguments) {
127         OptionValues options = debug.getOptions();
128         if (object instanceof Graph &amp;&amp; DebugOptions.PrintGraph.getValue(options) != PrintGraphTarget.Disable) {
129             final Graph graph = (Graph) object;
130             ensureInitialized(debug, graph);
131             if (printer == null) {
132                 return;
133             }
134 
135             // Get all current JavaMethod instances in the context.
136             List&lt;String&gt; inlineContext = getInlineContext(graph);
137 
<span class="line-modified">138             if (inlineContext != previousInlineContext) {</span>
















139                 Map&lt;Object, Object&gt; properties = new HashMap&lt;&gt;();
140                 properties.put(&quot;graph&quot;, graph.toString());
141                 addCompilationId(properties, graph);
<span class="line-modified">142                 if (inlineContext.equals(previousInlineContext)) {</span>
<span class="line-modified">143                     /*</span>
<span class="line-modified">144                      * two different graphs have the same inline context, so make sure they appear</span>
<span class="line-modified">145                      * in different folders by closing and reopening the top scope.</span>
<span class="line-modified">146                      */</span>
<span class="line-removed">147                     int inlineDepth = previousInlineContext.size() - 1;</span>
<span class="line-removed">148                     closeScope(debug, inlineDepth);</span>
<span class="line-removed">149                     openScope(debug, inlineContext.get(inlineDepth), inlineDepth, properties);</span>
<span class="line-removed">150                 } else {</span>
<span class="line-removed">151                     // Check for method scopes that must be closed since the previous dump.</span>
<span class="line-removed">152                     for (int i = 0; i &lt; previousInlineContext.size(); ++i) {</span>
<span class="line-removed">153                         if (i &gt;= inlineContext.size() || !inlineContext.get(i).equals(previousInlineContext.get(i))) {</span>
<span class="line-removed">154                             for (int inlineDepth = previousInlineContext.size() - 1; inlineDepth &gt;= i; --inlineDepth) {</span>
<span class="line-removed">155                                 closeScope(debug, inlineDepth);</span>
<span class="line-removed">156                             }</span>
<span class="line-removed">157                             break;</span>
158                         }

159                     }
<span class="line-modified">160                     // Check for method scopes that must be opened since the previous dump.</span>
<span class="line-modified">161                     for (int i = 0; i &lt; inlineContext.size(); ++i) {</span>
<span class="line-modified">162                         if (i &gt;= previousInlineContext.size() || !inlineContext.get(i).equals(previousInlineContext.get(i))) {</span>
<span class="line-modified">163                             for (int inlineDepth = i; inlineDepth &lt; inlineContext.size(); ++inlineDepth) {</span>
<span class="line-modified">164                                 openScope(debug, inlineContext.get(inlineDepth), inlineDepth, inlineDepth == inlineContext.size() - 1 ? properties : null);</span>
<span class="line-modified">165                             }</span>
<span class="line-removed">166                             break;</span>
167                         }

168                     }
169                 }
170             }
171 
172             // Save inline context for next dump.
173             previousInlineContext = inlineContext;
174 
175             // Capture before creating the sandbox
176             String currentScopeName = debug.getCurrentScopeName();
177             try (DebugContext.Scope s = debug.sandbox(&quot;PrintingGraph&quot;, null)) {
178                 // Finally, output the graph.
179                 Map&lt;Object, Object&gt; properties = new HashMap&lt;&gt;();
180                 properties.put(&quot;graph&quot;, graph.toString());
181                 properties.put(&quot;scope&quot;, currentScopeName);
182                 if (graph instanceof StructuredGraph) {
183                     properties.put(&quot;compilationIdentifier&quot;, ((StructuredGraph) graph).compilationId());
184                     try {
185                         int size = NodeCostUtil.computeGraphSize((StructuredGraph) graph);
186                         properties.put(&quot;node-cost graph size&quot;, size);
187                     } catch (Throwable t) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.printer;
 26 
 27 import static org.graalvm.compiler.debug.DebugConfig.asJavaMethod;
 28 
 29 import java.io.IOException;
 30 import java.nio.channels.ClosedByInterruptException;
 31 import java.util.ArrayList;
 32 import java.util.Arrays;
 33 import java.util.Collections;
 34 import java.util.Date;
 35 import java.util.HashMap;
 36 import java.util.List;
 37 import java.util.Map;
 38 import java.util.WeakHashMap;
 39 
<span class="line-added"> 40 import org.graalvm.compiler.core.common.CompilationIdentifier;</span>
 41 import org.graalvm.compiler.debug.DebugContext;
 42 import org.graalvm.compiler.debug.DebugDumpHandler;
 43 import org.graalvm.compiler.debug.DebugDumpScope;
 44 import org.graalvm.compiler.debug.DebugOptions;
<span class="line-added"> 45 import org.graalvm.compiler.debug.DebugOptions.PrintGraphTarget;</span>
 46 import org.graalvm.compiler.debug.GraalError;
 47 import org.graalvm.compiler.debug.TTY;

 48 import org.graalvm.compiler.graph.Graph;
 49 import org.graalvm.compiler.nodes.StructuredGraph;
 50 import org.graalvm.compiler.options.OptionValues;
 51 import org.graalvm.compiler.phases.contract.NodeCostUtil;
 52 import org.graalvm.compiler.serviceprovider.GraalServices;
 53 
 54 import jdk.vm.ci.meta.JavaMethod;
 55 import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="line-added"> 56 import jdk.vm.ci.services.Services;</span>
 57 
 58 //JaCoCo Exclude
 59 
 60 /**
 61  * Observes compilation events and uses {@link BinaryGraphPrinter} to generate a graph
 62  * representation that can be inspected with the Graph Visualizer.
 63  */
 64 public class GraphPrinterDumpHandler implements DebugDumpHandler {
 65 
 66     private static final int FAILURE_LIMIT = 8;
 67     private final GraphPrinterSupplier printerSupplier;
 68     protected GraphPrinter printer;
 69     private List&lt;String&gt; previousInlineContext;
<span class="line-added"> 70     private CompilationIdentifier previousCompilationID = CompilationIdentifier.INVALID_COMPILATION_ID;</span>
 71     private int[] dumpIds = {};
 72     private int failuresCount;
 73     private Map&lt;Graph, List&lt;String&gt;&gt; inlineContextMap;
 74     private final String jvmArguments;
 75     private final String sunJavaCommand;
 76 
 77     @FunctionalInterface
 78     public interface GraphPrinterSupplier {
 79         GraphPrinter get(DebugContext ctx, Graph graph) throws IOException;
 80     }
 81 
 82     /**
 83      * Creates a new {@link GraphPrinterDumpHandler}.
 84      *
 85      * @param printerSupplier Supplier used to create the GraphPrinter. Should supply an optional or
 86      *            null in case of failure.
 87      */
 88     public GraphPrinterDumpHandler(GraphPrinterSupplier printerSupplier) {
 89         this.printerSupplier = printerSupplier;
 90         /* Add the JVM and Java arguments to the graph properties to help identify it. */
 91         this.jvmArguments = jvmArguments();
<span class="line-modified"> 92         this.sunJavaCommand = Services.getSavedProperties().get(&quot;sun.java.command&quot;);</span>
 93     }
 94 
 95     private static String jvmArguments() {
 96         List&lt;String&gt; inputArguments = GraalServices.getInputArguments();
 97         if (inputArguments != null) {
 98             return String.join(&quot; &quot;, inputArguments);
 99         }
100         return &quot;unknown&quot;;
101     }
102 
103     private void ensureInitialized(DebugContext ctx, Graph graph) {
104         if (printer == null) {
105             if (failuresCount &gt;= FAILURE_LIMIT) {
106                 return;
107             }
108             previousInlineContext = new ArrayList&lt;&gt;();
109             inlineContextMap = new WeakHashMap&lt;&gt;();
110             DebugContext debug = graph.getDebug();
111             try {
112                 printer = printerSupplier.get(ctx, graph);
</pre>
<hr />
<pre>
121         if (dumpIds.length &lt; depth) {
122             dumpIds = Arrays.copyOf(dumpIds, depth);
123         }
124         return dumpIds[depth - 1]++;
125     }
126 
127     @Override
128     @SuppressWarnings(&quot;try&quot;)
129     public void dump(DebugContext debug, Object object, final String format, Object... arguments) {
130         OptionValues options = debug.getOptions();
131         if (object instanceof Graph &amp;&amp; DebugOptions.PrintGraph.getValue(options) != PrintGraphTarget.Disable) {
132             final Graph graph = (Graph) object;
133             ensureInitialized(debug, graph);
134             if (printer == null) {
135                 return;
136             }
137 
138             // Get all current JavaMethod instances in the context.
139             List&lt;String&gt; inlineContext = getInlineContext(graph);
140 
<span class="line-modified">141             if (graph instanceof StructuredGraph) {</span>
<span class="line-added">142                 CompilationIdentifier compilationID = ((StructuredGraph) graph).compilationId();</span>
<span class="line-added">143                 // If the graph to be dumped is with an invalid compilation id, it is likely derived</span>
<span class="line-added">144                 // from inlining.</span>
<span class="line-added">145                 if (compilationID != CompilationIdentifier.INVALID_COMPILATION_ID) {</span>
<span class="line-added">146                     if (previousCompilationID != CompilationIdentifier.INVALID_COMPILATION_ID &amp;&amp; !compilationID.equals(previousCompilationID)) {</span>
<span class="line-added">147                         // Compilation ID does not match, close existing scopes.</span>
<span class="line-added">148                         for (int inlineDepth = previousInlineContext.size() - 1; inlineDepth &gt;= 0; --inlineDepth) {</span>
<span class="line-added">149                             closeScope(debug, inlineDepth);</span>
<span class="line-added">150                         }</span>
<span class="line-added">151                         previousInlineContext = new ArrayList&lt;&gt;();</span>
<span class="line-added">152                     }</span>
<span class="line-added">153                     previousCompilationID = compilationID;</span>
<span class="line-added">154                 }</span>
<span class="line-added">155             }</span>
<span class="line-added">156 </span>
<span class="line-added">157             if (!inlineContext.equals(previousInlineContext)) {</span>
158                 Map&lt;Object, Object&gt; properties = new HashMap&lt;&gt;();
159                 properties.put(&quot;graph&quot;, graph.toString());
160                 addCompilationId(properties, graph);
<span class="line-modified">161                 // Check for method scopes that must be closed since the previous dump.</span>
<span class="line-modified">162                 for (int i = 0; i &lt; previousInlineContext.size(); ++i) {</span>
<span class="line-modified">163                     if (i &gt;= inlineContext.size() || !inlineContext.get(i).equals(previousInlineContext.get(i))) {</span>
<span class="line-modified">164                         for (int inlineDepth = previousInlineContext.size() - 1; inlineDepth &gt;= i; --inlineDepth) {</span>
<span class="line-modified">165                             closeScope(debug, inlineDepth);</span>











166                         }
<span class="line-added">167                         break;</span>
168                     }
<span class="line-modified">169                 }</span>
<span class="line-modified">170                 // Check for method scopes that must be opened since the previous dump.</span>
<span class="line-modified">171                 for (int i = 0; i &lt; inlineContext.size(); ++i) {</span>
<span class="line-modified">172                     if (i &gt;= previousInlineContext.size() || !inlineContext.get(i).equals(previousInlineContext.get(i))) {</span>
<span class="line-modified">173                         for (int inlineDepth = i; inlineDepth &lt; inlineContext.size(); ++inlineDepth) {</span>
<span class="line-modified">174                             openScope(debug, inlineContext.get(inlineDepth), inlineDepth, inlineDepth == inlineContext.size() - 1 ? properties : null);</span>

175                         }
<span class="line-added">176                         break;</span>
177                     }
178                 }
179             }
180 
181             // Save inline context for next dump.
182             previousInlineContext = inlineContext;
183 
184             // Capture before creating the sandbox
185             String currentScopeName = debug.getCurrentScopeName();
186             try (DebugContext.Scope s = debug.sandbox(&quot;PrintingGraph&quot;, null)) {
187                 // Finally, output the graph.
188                 Map&lt;Object, Object&gt; properties = new HashMap&lt;&gt;();
189                 properties.put(&quot;graph&quot;, graph.toString());
190                 properties.put(&quot;scope&quot;, currentScopeName);
191                 if (graph instanceof StructuredGraph) {
192                     properties.put(&quot;compilationIdentifier&quot;, ((StructuredGraph) graph).compilationId());
193                     try {
194                         int size = NodeCostUtil.computeGraphSize((StructuredGraph) graph);
195                         properties.put(&quot;node-cost graph size&quot;, size);
196                     } catch (Throwable t) {
</pre>
</td>
</tr>
</table>
<center><a href="GraphPrinter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../org.graalvm.compiler.replacements.aarch64/src/org/graalvm/compiler/replacements/aarch64/AArch64GraphBuilderPlugins.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.printer/src/org/graalvm/compiler/printer/BinaryGraphPrinter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.printer;
 26 
 27 import static org.graalvm.compiler.graph.Edges.Type.Inputs;
 28 import static org.graalvm.compiler.graph.Edges.Type.Successors;
 29 
 30 import java.io.IOException;
 31 import java.net.URI;
 32 import java.net.URISyntaxException;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.Collection;
 36 import java.util.Collections;
 37 import java.util.LinkedList;
 38 import java.util.List;
 39 import java.util.Map;
 40 
 41 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 42 import org.graalvm.compiler.bytecode.Bytecode;
 43 import org.graalvm.compiler.core.common.cfg.BlockMap;
 44 import org.graalvm.compiler.debug.DebugContext;
 45 import org.graalvm.compiler.graph.CachedGraph;
 46 import org.graalvm.compiler.graph.Edges;
 47 import org.graalvm.compiler.graph.Graph;
 48 import org.graalvm.compiler.graph.InputEdges;
 49 import org.graalvm.compiler.graph.Node;
 50 import org.graalvm.compiler.graph.NodeClass;
 51 import org.graalvm.compiler.graph.NodeMap;
 52 import org.graalvm.compiler.graph.NodeSourcePosition;
 53 import org.graalvm.compiler.graph.SourceLanguagePosition;
 54 import org.graalvm.compiler.nodes.AbstractBeginNode;
 55 import org.graalvm.compiler.nodes.AbstractEndNode;
 56 import org.graalvm.compiler.nodes.AbstractMergeNode;
 57 import org.graalvm.compiler.nodes.ConstantNode;
 58 import org.graalvm.compiler.nodes.ControlSinkNode;
 59 import org.graalvm.compiler.nodes.ControlSplitNode;
 60 import org.graalvm.compiler.nodes.FixedNode;
 61 import org.graalvm.compiler.nodes.PhiNode;
 62 import org.graalvm.compiler.nodes.ProxyNode;
 63 import org.graalvm.compiler.nodes.StructuredGraph;
 64 import org.graalvm.compiler.nodes.VirtualState;
 65 import org.graalvm.compiler.nodes.cfg.Block;
 66 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 67 import org.graalvm.compiler.nodes.util.JavaConstantFormattable;
 68 import org.graalvm.graphio.GraphBlocks;
 69 import org.graalvm.graphio.GraphElements;
 70 import org.graalvm.graphio.GraphLocations;
 71 import org.graalvm.graphio.GraphOutput;
 72 import org.graalvm.graphio.GraphStructure;
 73 import org.graalvm.graphio.GraphTypes;
 74 
 75 import jdk.vm.ci.meta.JavaType;
 76 import jdk.vm.ci.meta.ResolvedJavaField;
 77 import jdk.vm.ci.meta.ResolvedJavaMethod;
 78 import jdk.vm.ci.meta.Signature;
 79 
 80 public class BinaryGraphPrinter implements
 81                 GraphStructure&lt;BinaryGraphPrinter.GraphInfo, Node, NodeClass&lt;?&gt;, Edges&gt;,
 82                 GraphBlocks&lt;BinaryGraphPrinter.GraphInfo, Block, Node&gt;,
 83                 GraphElements&lt;ResolvedJavaMethod, ResolvedJavaField, Signature, NodeSourcePosition&gt;,
 84                 GraphLocations&lt;ResolvedJavaMethod, NodeSourcePosition, SourceLanguagePosition&gt;,
 85                 GraphTypes, GraphPrinter {
 86     private final SnippetReflectionProvider snippetReflection;
 87     private final GraphOutput&lt;BinaryGraphPrinter.GraphInfo, ResolvedJavaMethod&gt; output;
 88 
 89     public BinaryGraphPrinter(DebugContext ctx, SnippetReflectionProvider snippetReflection) throws IOException {
 90         // @formatter:off
 91         this.output = ctx.buildOutput(GraphOutput.newBuilder(this).
 92                         protocolVersion(6, 1).
 93                         blocks(this).
 94                         elementsAndLocations(this, this).
 95                         types(this)
 96         );
 97         // @formatter:on
 98         this.snippetReflection = snippetReflection;
 99     }
100 
101     @Override
102     public SnippetReflectionProvider getSnippetReflectionProvider() {
103         return snippetReflection;
104     }
105 
106     @Override
107     public void beginGroup(DebugContext debug, String name, String shortName, ResolvedJavaMethod method, int bci, Map&lt;Object, Object&gt; properties) throws IOException {
108         output.beginGroup(new GraphInfo(debug, null), name, shortName, method, bci, DebugContext.addVersionProperties(properties));
109     }
110 
111     @Override
112     public void endGroup() throws IOException {
113         output.endGroup();
114     }
115 
116     @Override
117     public void close() {
118         output.close();
119     }
120 
121     @Override
122     public ResolvedJavaMethod method(Object object) {
123         if (object instanceof Bytecode) {
124             return ((Bytecode) object).getMethod();
125         } else if (object instanceof ResolvedJavaMethod) {
126             return ((ResolvedJavaMethod) object);
127         } else {
128             return null;
129         }
130     }
131 
132     @Override
133     public Node node(Object obj) {
134         return obj instanceof Node ? (Node) obj : null;
135     }
136 
137     @Override
138     public NodeClass&lt;?&gt; nodeClass(Object obj) {
139         if (obj instanceof NodeClass&lt;?&gt;) {
140             return (NodeClass&lt;?&gt;) obj;
141         }
142         return null;
143     }
144 
145     @Override
146     public NodeClass&lt;?&gt; classForNode(Node node) {
147         return node.getNodeClass();
148     }
149 
150     @Override
151     public Object nodeClassType(NodeClass&lt;?&gt; node) {
152         return node.getJavaClass();
153     }
154 
155     @Override
156     public String nameTemplate(NodeClass&lt;?&gt; nodeClass) {
157         return nodeClass.getNameTemplate();
158     }
159 
160     @Override
161     public final GraphInfo graph(GraphInfo currrent, Object obj) {
162         if (obj instanceof Graph) {
163             return new GraphInfo(currrent.debug, (Graph) obj);
164         } else if (obj instanceof CachedGraph) {
165             return new GraphInfo(currrent.debug, ((CachedGraph&lt;?&gt;) obj).getReadonlyCopy());
166         } else {
167             return null;
168         }
169     }
170 
171     @Override
172     public int nodeId(Node n) {
173         return getNodeId(n);
174     }
175 
176     @Override
177     public Edges portInputs(NodeClass&lt;?&gt; nodeClass) {
178         return nodeClass.getEdges(Inputs);
179     }
180 
181     @Override
182     public Edges portOutputs(NodeClass&lt;?&gt; nodeClass) {
183         return nodeClass.getEdges(Successors);
184     }
185 
186     @SuppressWarnings(&quot;deprecation&quot;)
187     private static int getNodeId(Node node) {
188         return node == null ? -1 : node.getId();
189     }
190 
191     @Override
192     public List&lt;Node&gt; blockNodes(GraphInfo info, Block block) {
193         List&lt;Node&gt; nodes = info.blockToNodes.get(block);
194         if (nodes == null) {
195             return null;
196         }
197         List&lt;Node&gt; extraNodes = new LinkedList&lt;&gt;();
198         for (Node node : nodes) {
199             findExtraNodes(node, extraNodes);
200         }
201         extraNodes.removeAll(nodes);
202         extraNodes.addAll(0, nodes);
203         return extraNodes;
204     }
205 
206     @Override
207     public int blockId(Block sux) {
208         return sux.getId();
209     }
210 
211     @Override
212     public List&lt;Block&gt; blockSuccessors(Block block) {
213         return Arrays.asList(block.getSuccessors());
214     }
215 
216     @Override
217     public Iterable&lt;Node&gt; nodes(GraphInfo info) {
218         return info.graph.getNodes();
219     }
220 
221     @Override
222     public int nodesCount(GraphInfo info) {
223         return info.graph.getNodeCount();
224     }
225 
226     @Override
227     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
228     public void nodeProperties(GraphInfo info, Node node, Map&lt;String, Object&gt; props) {
229         node.getDebugProperties((Map) props);
230         NodeMap&lt;Block&gt; nodeToBlocks = info.nodeToBlocks;
231 
232         if (nodeToBlocks != null) {
233             Block block = getBlockForNode(node, nodeToBlocks);
234             if (block != null) {
235                 props.put(&quot;relativeFrequency&quot;, block.getRelativeFrequency());
236                 props.put(&quot;nodeToBlock&quot;, block);
237             }
238         }
239 
240         props.put(&quot;nodeCostSize&quot;, node.estimatedNodeSize());
241         props.put(&quot;nodeCostCycles&quot;, node.estimatedNodeCycles());
242 
243         if (nodeToBlocks != null) {
244             Object block = getBlockForNode(node, nodeToBlocks);
245             if (block != null) {
246                 props.put(&quot;nodeToBlock&quot;, block);
247             }
248         }
249 
250         if (node instanceof ControlSinkNode) {
251             props.put(&quot;category&quot;, &quot;controlSink&quot;);
252         } else if (node instanceof ControlSplitNode) {
253             props.put(&quot;category&quot;, &quot;controlSplit&quot;);
254         } else if (node instanceof AbstractMergeNode) {
255             props.put(&quot;category&quot;, &quot;merge&quot;);
256         } else if (node instanceof AbstractBeginNode) {
257             props.put(&quot;category&quot;, &quot;begin&quot;);
258         } else if (node instanceof AbstractEndNode) {
259             props.put(&quot;category&quot;, &quot;end&quot;);
260         } else if (node instanceof FixedNode) {
261             props.put(&quot;category&quot;, &quot;fixed&quot;);
262         } else if (node instanceof VirtualState) {
263             props.put(&quot;category&quot;, &quot;state&quot;);
264         } else if (node instanceof PhiNode) {
265             props.put(&quot;category&quot;, &quot;phi&quot;);
266         } else if (node instanceof ProxyNode) {
267             props.put(&quot;category&quot;, &quot;proxy&quot;);
268         } else {
269             if (node instanceof ConstantNode) {
270                 ConstantNode cn = (ConstantNode) node;
271                 updateStringPropertiesForConstant((Map) props, cn);
272             }
273             props.put(&quot;category&quot;, &quot;floating&quot;);
274         }
275         if (getSnippetReflectionProvider() != null) {
276             for (Map.Entry&lt;String, Object&gt; prop : props.entrySet()) {
277                 if (prop.getValue() instanceof JavaConstantFormattable) {
278                     props.put(prop.getKey(), ((JavaConstantFormattable) prop.getValue()).format(this));
279                 }
280             }
281         }
282     }
283 
284     private Block getBlockForNode(Node node, NodeMap&lt;Block&gt; nodeToBlocks) {
285         if (nodeToBlocks.isNew(node)) {
286             return null;
287         } else {
288             Block block = nodeToBlocks.get(node);
289             if (block != null) {
290                 return block;
291             } else if (node instanceof PhiNode) {
292                 return getBlockForNode(((PhiNode) node).merge(), nodeToBlocks);
293             }
294         }
295         return null;
296     }
297 
298     private static void findExtraNodes(Node node, Collection&lt;? super Node&gt; extraNodes) {
299         if (node instanceof AbstractMergeNode) {
300             AbstractMergeNode merge = (AbstractMergeNode) node;
301             for (PhiNode phi : merge.phis()) {
302                 extraNodes.add(phi);
303             }
304         }
305     }
306 
307     @Override
308     public boolean nodeHasPredecessor(Node node) {
309         return node.predecessor() != null;
310     }
311 
312     @Override
313     public List&lt;Block&gt; blocks(GraphInfo graph) {
314         return graph.blocks;
315     }
316 
317     @Override
318     public void print(DebugContext debug, Graph graph, Map&lt;Object, Object&gt; properties, int id, String format, Object... args) throws IOException {
319         output.print(new GraphInfo(debug, graph), properties, id, format, args);
320     }
321 
322     @Override
323     public int portSize(Edges port) {
324         return port.getCount();
325     }
326 
327     @Override
328     public boolean edgeDirect(Edges port, int index) {
329         return index &lt; port.getDirectCount();
330     }
331 
332     @Override
333     public String edgeName(Edges port, int index) {
334         return port.getName(index);
335     }
336 
337     @Override
338     public Object edgeType(Edges port, int index) {
339         return ((InputEdges) port).getInputType(index);
340     }
341 
342     @Override
343     public Collection&lt;? extends Node&gt; edgeNodes(GraphInfo graph, Node node, Edges port, int i) {
344         if (i &lt; port.getDirectCount()) {
345             Node single = Edges.getNode(node, port.getOffsets(), i);
346             return Collections.singletonList(single);
347         } else {
348             return Edges.getNodeList(node, port.getOffsets(), i);
349         }
350     }
351 
352     @Override
353     public Object enumClass(Object enumValue) {
354         if (enumValue instanceof Enum) {
355             return enumValue.getClass();
356         }
357         return null;
358     }
359 
360     @Override
361     public int enumOrdinal(Object obj) {
362         if (obj instanceof Enum&lt;?&gt;) {
363             return ((Enum&lt;?&gt;) obj).ordinal();
364         }
365         return -1;
366     }
367 
368     @SuppressWarnings(&quot;unchecked&quot;)
369     @Override
370     public String[] enumTypeValues(Object clazz) {
371         if (clazz instanceof Class&lt;?&gt;) {
372             Class&lt;? extends Enum&lt;?&gt;&gt; enumClass = (Class&lt;? extends Enum&lt;?&gt;&gt;) clazz;
373             Enum&lt;?&gt;[] constants = enumClass.getEnumConstants();
374             if (constants != null) {
375                 String[] names = new String[constants.length];
376                 for (int i = 0; i &lt; constants.length; i++) {
377                     names[i] = constants[i].name();
378                 }
379                 return names;
380             }
381         }
382         return null;
383     }
384 
385     @Override
386     public String typeName(Object obj) {
387         if (obj instanceof Class&lt;?&gt;) {
388             return ((Class&lt;?&gt;) obj).getName();
389         }
390         if (obj instanceof JavaType) {
391             return ((JavaType) obj).toJavaName();
392         }
393         return null;
394     }
395 
396     @Override
397     public byte[] methodCode(ResolvedJavaMethod method) {
398         return method.getCode();
399     }
400 
401     @Override
402     public int methodModifiers(ResolvedJavaMethod method) {
403         return method.getModifiers();
404     }
405 
406     @Override
407     public Signature methodSignature(ResolvedJavaMethod method) {
408         return method.getSignature();
409     }
410 
411     @Override
412     public String methodName(ResolvedJavaMethod method) {
413         return method.getName();
414     }
415 
416     @Override
417     public Object methodDeclaringClass(ResolvedJavaMethod method) {
418         return method.getDeclaringClass();
419     }
420 
421     @Override
422     public int fieldModifiers(ResolvedJavaField field) {
423         return field.getModifiers();
424     }
425 
426     @Override
427     public String fieldTypeName(ResolvedJavaField field) {
428         return field.getType().toJavaName();
429     }
430 
431     @Override
432     public String fieldName(ResolvedJavaField field) {
433         return field.getName();
434     }
435 
436     @Override
437     public Object fieldDeclaringClass(ResolvedJavaField field) {
438         return field.getDeclaringClass();
439     }
440 
441     @Override
442     public ResolvedJavaField field(Object object) {
443         if (object instanceof ResolvedJavaField) {
444             return (ResolvedJavaField) object;
445         }
446         return null;
447     }
448 
449     @Override
450     public Signature signature(Object object) {
451         if (object instanceof Signature) {
452             return (Signature) object;
453         }
454         return null;
455     }
456 
457     @Override
458     public int signatureParameterCount(Signature signature) {
459         return signature.getParameterCount(false);
460     }
461 
462     @Override
463     public String signatureParameterTypeName(Signature signature, int index) {
464         return signature.getParameterType(index, null).getName();
465     }
466 
467     @Override
468     public String signatureReturnTypeName(Signature signature) {
469         return signature.getReturnType(null).getName();
470     }
471 
472     @Override
473     public NodeSourcePosition nodeSourcePosition(Object object) {
474         if (object instanceof NodeSourcePosition) {
475             return (NodeSourcePosition) object;
476         }
477         return null;
478     }
479 
480     @Override
481     public ResolvedJavaMethod nodeSourcePositionMethod(NodeSourcePosition pos) {
482         return pos.getMethod();
483     }
484 
485     @Override
486     public NodeSourcePosition nodeSourcePositionCaller(NodeSourcePosition pos) {
487         return pos.getCaller();
488     }
489 
490     @Override
491     public int nodeSourcePositionBCI(NodeSourcePosition pos) {
492         return pos.getBCI();
493     }
494 
495     @Override
496     public StackTraceElement methodStackTraceElement(ResolvedJavaMethod method, int bci, NodeSourcePosition pos) {
497         return method.asStackTraceElement(bci);
498     }
499 
500     @Override
501     public Iterable&lt;SourceLanguagePosition&gt; methodLocation(ResolvedJavaMethod method, int bci, NodeSourcePosition pos) {
502         StackTraceElement e = methodStackTraceElement(method, bci, pos);
503         class JavaSourcePosition implements SourceLanguagePosition {
504 
505             @Override
506             public String toShortString() {
507                 return e.toString();
508             }
509 
510             @Override
511             public int getOffsetEnd() {
512                 return -1;
513             }
514 
515             @Override
516             public int getOffsetStart() {
517                 return -1;
518             }
519 
520             @Override
521             public int getLineNumber() {
522                 return e.getLineNumber();
523             }
524 
525             @Override
526             public URI getURI() {
527                 String path = e.getFileName();
528                 try {
529                     return new URI(null, null, path == null ? &quot;(Unknown Source)&quot; : path, null);
530                 } catch (URISyntaxException ex) {
531                     throw new IllegalArgumentException(ex);
532                 }
533             }
534 
535             @Override
536             public String getLanguage() {
537                 return &quot;Java&quot;;
538             }
539         }
540 
541         List&lt;SourceLanguagePosition&gt; arr = new ArrayList&lt;&gt;();
542         arr.add(new JavaSourcePosition());
543         NodeSourcePosition at = pos;
544         while (at != null) {
545             SourceLanguagePosition cur = at.getSourceLanguage();
546             if (cur != null) {
547                 arr.add(cur);
548             }
549             at = at.getCaller();
550         }
551         return arr;
552     }
553 
554     @Override
555     public String locationLanguage(SourceLanguagePosition location) {
556         return location.getLanguage();
557     }
558 
559     @Override
560     public URI locationURI(SourceLanguagePosition location) {
561         return location.getURI();
562     }
563 
564     @Override
565     public int locationLineNumber(SourceLanguagePosition location) {
566         return location.getLineNumber();
567     }
568 
569     @Override
570     public int locationOffsetStart(SourceLanguagePosition location) {
571         return location.getOffsetStart();
572     }
573 
574     @Override
575     public int locationOffsetEnd(SourceLanguagePosition location) {
576         return location.getOffsetEnd();
577     }
578 
579     static final class GraphInfo {
580         final DebugContext debug;
581         final Graph graph;
582         final ControlFlowGraph cfg;
583         final BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes;
584         final NodeMap&lt;Block&gt; nodeToBlocks;
585         final List&lt;Block&gt; blocks;
586 
587         private GraphInfo(DebugContext debug, Graph graph) {
588             this.debug = debug;
589             this.graph = graph;
590             StructuredGraph.ScheduleResult scheduleResult = null;
591             if (graph instanceof StructuredGraph) {
592                 StructuredGraph structuredGraph = (StructuredGraph) graph;
593                 scheduleResult = GraalDebugHandlersFactory.tryGetSchedule(debug, structuredGraph);
594             }
595             cfg = scheduleResult == null ? debug.contextLookup(ControlFlowGraph.class) : scheduleResult.getCFG();
596             blockToNodes = scheduleResult == null ? null : scheduleResult.getBlockToNodesMap();
597             nodeToBlocks = scheduleResult == null ? null : scheduleResult.getNodeToBlockMap();
598             blocks = cfg == null ? null : Arrays.asList(cfg.getBlocks());
599         }
600     }
601 
602 }
    </pre>
  </body>
</html>
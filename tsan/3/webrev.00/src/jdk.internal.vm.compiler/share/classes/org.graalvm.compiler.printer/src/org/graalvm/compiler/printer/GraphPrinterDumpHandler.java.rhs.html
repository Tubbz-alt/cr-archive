<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.printer/src/org/graalvm/compiler/printer/GraphPrinterDumpHandler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.printer;
 26 
 27 import static org.graalvm.compiler.debug.DebugConfig.asJavaMethod;
 28 
 29 import java.io.IOException;
 30 import java.nio.channels.ClosedByInterruptException;
 31 import java.util.ArrayList;
 32 import java.util.Arrays;
 33 import java.util.Collections;
 34 import java.util.Date;
 35 import java.util.HashMap;
 36 import java.util.List;
 37 import java.util.Map;
 38 import java.util.WeakHashMap;
 39 
<a name="2" id="anc2"></a><span class="line-added"> 40 import org.graalvm.compiler.core.common.CompilationIdentifier;</span>
 41 import org.graalvm.compiler.debug.DebugContext;
 42 import org.graalvm.compiler.debug.DebugDumpHandler;
 43 import org.graalvm.compiler.debug.DebugDumpScope;
 44 import org.graalvm.compiler.debug.DebugOptions;
<a name="3" id="anc3"></a><span class="line-added"> 45 import org.graalvm.compiler.debug.DebugOptions.PrintGraphTarget;</span>
 46 import org.graalvm.compiler.debug.GraalError;
 47 import org.graalvm.compiler.debug.TTY;
<a name="4" id="anc4"></a>
 48 import org.graalvm.compiler.graph.Graph;
 49 import org.graalvm.compiler.nodes.StructuredGraph;
 50 import org.graalvm.compiler.options.OptionValues;
 51 import org.graalvm.compiler.phases.contract.NodeCostUtil;
 52 import org.graalvm.compiler.serviceprovider.GraalServices;
 53 
 54 import jdk.vm.ci.meta.JavaMethod;
 55 import jdk.vm.ci.meta.ResolvedJavaMethod;
<a name="5" id="anc5"></a><span class="line-added"> 56 import jdk.vm.ci.services.Services;</span>
 57 
 58 //JaCoCo Exclude
 59 
 60 /**
 61  * Observes compilation events and uses {@link BinaryGraphPrinter} to generate a graph
 62  * representation that can be inspected with the Graph Visualizer.
 63  */
 64 public class GraphPrinterDumpHandler implements DebugDumpHandler {
 65 
 66     private static final int FAILURE_LIMIT = 8;
 67     private final GraphPrinterSupplier printerSupplier;
 68     protected GraphPrinter printer;
 69     private List&lt;String&gt; previousInlineContext;
<a name="6" id="anc6"></a><span class="line-added"> 70     private CompilationIdentifier previousCompilationID = CompilationIdentifier.INVALID_COMPILATION_ID;</span>
 71     private int[] dumpIds = {};
 72     private int failuresCount;
 73     private Map&lt;Graph, List&lt;String&gt;&gt; inlineContextMap;
 74     private final String jvmArguments;
 75     private final String sunJavaCommand;
 76 
 77     @FunctionalInterface
 78     public interface GraphPrinterSupplier {
 79         GraphPrinter get(DebugContext ctx, Graph graph) throws IOException;
 80     }
 81 
 82     /**
 83      * Creates a new {@link GraphPrinterDumpHandler}.
 84      *
 85      * @param printerSupplier Supplier used to create the GraphPrinter. Should supply an optional or
 86      *            null in case of failure.
 87      */
 88     public GraphPrinterDumpHandler(GraphPrinterSupplier printerSupplier) {
 89         this.printerSupplier = printerSupplier;
 90         /* Add the JVM and Java arguments to the graph properties to help identify it. */
 91         this.jvmArguments = jvmArguments();
<a name="7" id="anc7"></a><span class="line-modified"> 92         this.sunJavaCommand = Services.getSavedProperties().get(&quot;sun.java.command&quot;);</span>
 93     }
 94 
 95     private static String jvmArguments() {
 96         List&lt;String&gt; inputArguments = GraalServices.getInputArguments();
 97         if (inputArguments != null) {
 98             return String.join(&quot; &quot;, inputArguments);
 99         }
100         return &quot;unknown&quot;;
101     }
102 
103     private void ensureInitialized(DebugContext ctx, Graph graph) {
104         if (printer == null) {
105             if (failuresCount &gt;= FAILURE_LIMIT) {
106                 return;
107             }
108             previousInlineContext = new ArrayList&lt;&gt;();
109             inlineContextMap = new WeakHashMap&lt;&gt;();
110             DebugContext debug = graph.getDebug();
111             try {
112                 printer = printerSupplier.get(ctx, graph);
113             } catch (IOException e) {
114                 handleException(debug, e);
115             }
116         }
117     }
118 
119     private int nextDumpId() {
120         int depth = previousInlineContext.size();
121         if (dumpIds.length &lt; depth) {
122             dumpIds = Arrays.copyOf(dumpIds, depth);
123         }
124         return dumpIds[depth - 1]++;
125     }
126 
127     @Override
128     @SuppressWarnings(&quot;try&quot;)
129     public void dump(DebugContext debug, Object object, final String format, Object... arguments) {
130         OptionValues options = debug.getOptions();
131         if (object instanceof Graph &amp;&amp; DebugOptions.PrintGraph.getValue(options) != PrintGraphTarget.Disable) {
132             final Graph graph = (Graph) object;
133             ensureInitialized(debug, graph);
134             if (printer == null) {
135                 return;
136             }
137 
138             // Get all current JavaMethod instances in the context.
139             List&lt;String&gt; inlineContext = getInlineContext(graph);
140 
<a name="8" id="anc8"></a><span class="line-modified">141             if (graph instanceof StructuredGraph) {</span>
<span class="line-added">142                 CompilationIdentifier compilationID = ((StructuredGraph) graph).compilationId();</span>
<span class="line-added">143                 // If the graph to be dumped is with an invalid compilation id, it is likely derived</span>
<span class="line-added">144                 // from inlining.</span>
<span class="line-added">145                 if (compilationID != CompilationIdentifier.INVALID_COMPILATION_ID) {</span>
<span class="line-added">146                     if (previousCompilationID != CompilationIdentifier.INVALID_COMPILATION_ID &amp;&amp; !compilationID.equals(previousCompilationID)) {</span>
<span class="line-added">147                         // Compilation ID does not match, close existing scopes.</span>
<span class="line-added">148                         for (int inlineDepth = previousInlineContext.size() - 1; inlineDepth &gt;= 0; --inlineDepth) {</span>
<span class="line-added">149                             closeScope(debug, inlineDepth);</span>
<span class="line-added">150                         }</span>
<span class="line-added">151                         previousInlineContext = new ArrayList&lt;&gt;();</span>
<span class="line-added">152                     }</span>
<span class="line-added">153                     previousCompilationID = compilationID;</span>
<span class="line-added">154                 }</span>
<span class="line-added">155             }</span>
<span class="line-added">156 </span>
<span class="line-added">157             if (!inlineContext.equals(previousInlineContext)) {</span>
158                 Map&lt;Object, Object&gt; properties = new HashMap&lt;&gt;();
159                 properties.put(&quot;graph&quot;, graph.toString());
160                 addCompilationId(properties, graph);
<a name="9" id="anc9"></a><span class="line-modified">161                 // Check for method scopes that must be closed since the previous dump.</span>
<span class="line-modified">162                 for (int i = 0; i &lt; previousInlineContext.size(); ++i) {</span>
<span class="line-modified">163                     if (i &gt;= inlineContext.size() || !inlineContext.get(i).equals(previousInlineContext.get(i))) {</span>
<span class="line-modified">164                         for (int inlineDepth = previousInlineContext.size() - 1; inlineDepth &gt;= i; --inlineDepth) {</span>
<span class="line-modified">165                             closeScope(debug, inlineDepth);</span>











166                         }
<a name="10" id="anc10"></a><span class="line-added">167                         break;</span>
168                     }
<a name="11" id="anc11"></a><span class="line-modified">169                 }</span>
<span class="line-modified">170                 // Check for method scopes that must be opened since the previous dump.</span>
<span class="line-modified">171                 for (int i = 0; i &lt; inlineContext.size(); ++i) {</span>
<span class="line-modified">172                     if (i &gt;= previousInlineContext.size() || !inlineContext.get(i).equals(previousInlineContext.get(i))) {</span>
<span class="line-modified">173                         for (int inlineDepth = i; inlineDepth &lt; inlineContext.size(); ++inlineDepth) {</span>
<span class="line-modified">174                             openScope(debug, inlineContext.get(inlineDepth), inlineDepth, inlineDepth == inlineContext.size() - 1 ? properties : null);</span>

175                         }
<a name="12" id="anc12"></a><span class="line-added">176                         break;</span>
177                     }
178                 }
179             }
180 
181             // Save inline context for next dump.
182             previousInlineContext = inlineContext;
183 
184             // Capture before creating the sandbox
185             String currentScopeName = debug.getCurrentScopeName();
186             try (DebugContext.Scope s = debug.sandbox(&quot;PrintingGraph&quot;, null)) {
187                 // Finally, output the graph.
188                 Map&lt;Object, Object&gt; properties = new HashMap&lt;&gt;();
189                 properties.put(&quot;graph&quot;, graph.toString());
190                 properties.put(&quot;scope&quot;, currentScopeName);
191                 if (graph instanceof StructuredGraph) {
192                     properties.put(&quot;compilationIdentifier&quot;, ((StructuredGraph) graph).compilationId());
193                     try {
194                         int size = NodeCostUtil.computeGraphSize((StructuredGraph) graph);
195                         properties.put(&quot;node-cost graph size&quot;, size);
196                     } catch (Throwable t) {
197                         properties.put(&quot;node-cost-exception&quot;, t.getMessage());
198                     }
199                 }
200                 printer.print(debug, graph, properties, nextDumpId(), format, arguments);
201             } catch (IOException e) {
202                 handleException(debug, e);
203             } catch (Throwable e) {
204                 throw debug.handle(e);
205             }
206         }
207     }
208 
209     void handleException(DebugContext debug, IOException e) {
210         if (debug != null &amp;&amp; DebugOptions.DumpingErrorsAreFatal.getValue(debug.getOptions())) {
211             throw new GraalError(e);
212         }
213         if (e instanceof ClosedByInterruptException) {
214             /*
215              * The current dumping was aborted by an interrupt so treat this as a transient failure.
216              */
217             failuresCount = 0;
218         } else {
219             failuresCount++;
220         }
221         printer = null;
222         e.printStackTrace(TTY.out);
223         if (failuresCount &gt; FAILURE_LIMIT) {
224             TTY.println(&quot;Too many failures with dumping. Disabling dump in thread &quot; + Thread.currentThread());
225         }
226     }
227 
228     private static void addCompilationId(Map&lt;Object, Object&gt; properties, final Graph graph) {
229         if (graph instanceof StructuredGraph) {
230             properties.put(&quot;compilationId&quot;, ((StructuredGraph) graph).compilationId());
231         }
232     }
233 
234     private List&lt;String&gt; getInlineContext(Graph graph) {
235         List&lt;String&gt; result = inlineContextMap.get(graph);
236         if (result == null) {
237             result = new ArrayList&lt;&gt;();
238             Object lastMethodOrGraph = null;
239             boolean graphSeen = false;
240             DebugContext debug = graph.getDebug();
241             for (Object o : debug.context()) {
242                 if (o == graph) {
243                     graphSeen = true;
244                 }
245 
246                 if (o instanceof DebugDumpScope) {
247                     DebugDumpScope debugDumpScope = (DebugDumpScope) o;
248                     if (debugDumpScope.decorator &amp;&amp; !result.isEmpty()) {
249                         result.set(result.size() - 1, debugDumpScope.name + &quot;:&quot; + result.get(result.size() - 1));
250                     } else {
251                         result.add(debugDumpScope.name);
252                     }
253                 } else {
254                     addMethodContext(result, o, lastMethodOrGraph);
255                 }
256                 if (o instanceof JavaMethod || o instanceof Graph) {
257                     lastMethodOrGraph = o;
258                 }
259             }
260             if (result.size() == 2 &amp;&amp; result.get(1).startsWith(&quot;TruffleGraal&quot;)) {
261                 result.clear();
262                 result.add(&quot;Graal Graphs&quot;);
263             }
264             if (result.isEmpty()) {
265                 result.add(graph.toString());
266                 graphSeen = true;
267             }
268             // Reverse list such that inner method comes after outer method.
269             Collections.reverse(result);
270             if (!graphSeen) {
271                 /*
272                  * The graph isn&#39;t in any context but is being processed within another graph so add
273                  * it to the end of the scopes.
274                  */
275                 if (asJavaMethod(graph) != null) {
276                     addMethodContext(result, graph, lastMethodOrGraph);
277                 } else {
278                     result.add(graph.toString());
279                 }
280             }
281             inlineContextMap.put(graph, result);
282         }
283         return result;
284     }
285 
286     private static void addMethodContext(List&lt;String&gt; result, Object o, Object lastMethodOrGraph) {
287         JavaMethod method = asJavaMethod(o);
288         if (method != null) {
289             /*
290              * Include the current method in the context if there was no previous JavaMethod or
291              * JavaMethodContext or if the method is different or if the method is the same but it
292              * comes from two different graphs. This ensures that recursive call patterns are
293              * handled properly.
294              */
295             if (lastMethodOrGraph == null || asJavaMethod(lastMethodOrGraph) == null || !asJavaMethod(lastMethodOrGraph).equals(method) ||
296                             (lastMethodOrGraph != o &amp;&amp; lastMethodOrGraph instanceof Graph &amp;&amp; o instanceof Graph)) {
297                 result.add(method.format(&quot;%H.%n(%p)&quot;));
298             } else {
299                 /*
300                  * This prevents multiple adjacent method context objects for the same method from
301                  * resulting in multiple IGV tree levels. This works on the assumption that real
302                  * inlining debug scopes will have a graph context object between the inliner and
303                  * inlinee context objects.
304                  */
305             }
306         }
307     }
308 
309     private void openScope(DebugContext debug, String name, int inlineDepth, Map&lt;Object, Object&gt; properties) {
310         try {
311             Map&lt;Object, Object&gt; props = properties;
312             if (inlineDepth == 0) {
313                 /* Include some VM specific properties at the root. */
314                 if (props == null) {
315                     props = new HashMap&lt;&gt;();
316                 }
317                 props.put(&quot;jvmArguments&quot;, jvmArguments);
318                 if (sunJavaCommand != null) {
319                     props.put(&quot;sun.java.command&quot;, sunJavaCommand);
320                 }
321                 props.put(&quot;date&quot;, new Date().toString());
322             }
323             printer.beginGroup(debug, name, name, debug.contextLookup(ResolvedJavaMethod.class), -1, props);
324         } catch (IOException e) {
325             handleException(debug, e);
326         }
327     }
328 
329     private void closeScope(DebugContext debug, int inlineDepth) {
330         dumpIds[inlineDepth] = 0;
331         try {
332             if (printer != null) {
333                 printer.endGroup();
334             }
335         } catch (IOException e) {
336             handleException(debug, e);
337         }
338     }
339 
340     @Override
341     public void close() {
342         if (previousInlineContext != null) {
343             for (int inlineDepth = 0; inlineDepth &lt; previousInlineContext.size(); inlineDepth++) {
344                 closeScope(null, inlineDepth);
345             }
346         }
347         if (printer != null) {
348             printer.close();
349             printer = null;
350         }
351     }
352 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
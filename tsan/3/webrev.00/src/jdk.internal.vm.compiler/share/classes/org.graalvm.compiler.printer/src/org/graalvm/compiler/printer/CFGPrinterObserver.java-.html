<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.printer/src/org/graalvm/compiler/printer/CFGPrinterObserver.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.printer;
 26 
 27 import static org.graalvm.compiler.debug.DebugOptions.PrintCFG;
 28 
 29 import java.io.BufferedOutputStream;
 30 import java.io.File;
 31 import java.io.FileOutputStream;
 32 import java.io.IOException;
 33 import java.io.OutputStream;
 34 import java.nio.file.Path;
 35 import java.util.ArrayList;
 36 import java.util.Collections;
 37 import java.util.List;
 38 
 39 import org.graalvm.compiler.bytecode.BytecodeDisassembler;
 40 import org.graalvm.compiler.code.CompilationResult;
 41 import org.graalvm.compiler.code.DisassemblerProvider;
 42 import org.graalvm.compiler.core.common.CompilationIdentifier;
 43 import org.graalvm.compiler.core.common.alloc.Trace;
 44 import org.graalvm.compiler.core.common.alloc.TraceBuilderResult;
 45 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 46 import org.graalvm.compiler.core.gen.NodeLIRBuilder;
 47 import org.graalvm.compiler.debug.DebugContext;
 48 import org.graalvm.compiler.debug.DebugDumpHandler;
 49 import org.graalvm.compiler.debug.DebugDumpScope;
 50 import org.graalvm.compiler.debug.GraalError;
 51 import org.graalvm.compiler.debug.TTY;
 52 import org.graalvm.compiler.graph.Graph;
 53 import org.graalvm.compiler.java.BciBlockMapping;
 54 import org.graalvm.compiler.lir.LIR;
 55 import org.graalvm.compiler.lir.debug.IntervalDumper;
 56 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 57 import org.graalvm.compiler.nodes.StructuredGraph;
 58 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 59 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 60 import org.graalvm.compiler.options.OptionValues;
 61 import org.graalvm.compiler.serviceprovider.GraalServices;
 62 
 63 import jdk.vm.ci.code.CodeCacheProvider;
 64 import jdk.vm.ci.code.InstalledCode;
 65 import jdk.vm.ci.meta.JavaMethod;
 66 import jdk.vm.ci.meta.ResolvedJavaMethod;
 67 
 68 /**
 69  * Observes compilation events and uses {@link CFGPrinter} to produce a control flow graph for the
 70  * &lt;a href=&quot;http://java.net/projects/c1visualizer/&quot;&gt;C1 Visualizer&lt;/a&gt;.
 71  */
 72 public class CFGPrinterObserver implements DebugDumpHandler {
 73 
 74     private CFGPrinter cfgPrinter;
 75     private File cfgFile;
 76     private JavaMethod curMethod;
 77     private CompilationIdentifier curCompilation;
 78     private List&lt;String&gt; curDecorators = Collections.emptyList();
 79 
 80     @Override
 81     public void dump(DebugContext debug, Object object, String format, Object... arguments) {
 82         String message = String.format(format, arguments);
 83         try {
 84             dumpSandboxed(debug, object, message);
 85         } catch (Throwable ex) {
 86             TTY.println(&quot;CFGPrinter: Exception during output of &quot; + message + &quot;: &quot; + ex);
 87             ex.printStackTrace();
 88         }
 89     }
 90 
 91     /**
 92      * Looks for the outer most method and its {@link DebugDumpScope#decorator}s in the current
 93      * debug scope and opens a new compilation scope if this pair does not match the current method
 94      * and decorator pair.
 95      */
 96     private boolean checkMethodScope(DebugContext debug) {
 97         JavaMethod method = null;
 98         CompilationIdentifier compilation = null;
 99         ArrayList&lt;String&gt; decorators = new ArrayList&lt;&gt;();
100         for (Object o : debug.context()) {
101             if (o instanceof JavaMethod) {
102                 method = (JavaMethod) o;
103                 decorators.clear();
104             } else if (o instanceof StructuredGraph) {
105                 StructuredGraph graph = (StructuredGraph) o;
106                 if (graph.method() != null) {
107                     method = graph.method();
108                     decorators.clear();
109                     compilation = graph.compilationId();
110                 }
111             } else if (o instanceof DebugDumpScope) {
112                 DebugDumpScope debugDumpScope = (DebugDumpScope) o;
113                 if (debugDumpScope.decorator) {
114                     decorators.add(debugDumpScope.name);
115                 }
116             } else if (o instanceof CompilationResult) {
117                 CompilationResult compilationResult = (CompilationResult) o;
118                 compilation = compilationResult.getCompilationId();
119             }
120         }
121 
122         if (method == null &amp;&amp; compilation == null) {
123             return false;
124         }
125 
126         if (compilation != null) {
127             if (!compilation.equals(curCompilation) || !curDecorators.equals(decorators)) {
128                 cfgPrinter.printCompilation(compilation);
129             }
130         } else {
131             if (!method.equals(curMethod) || !curDecorators.equals(decorators)) {
132                 cfgPrinter.printCompilation(method);
133             }
134         }
135         curCompilation = compilation;
136         curMethod = method;
137         curDecorators = decorators;
138         return true;
139     }
140 
141     private static boolean isFrontendObject(Object object) {
142         return object instanceof Graph || object instanceof BciBlockMapping;
143     }
144 
145     private LIR lastLIR = null;
146     private IntervalDumper delayedIntervals = null;
147 
148     public void dumpSandboxed(DebugContext debug, Object object, String message) {
149         OptionValues options = debug.getOptions();
150         boolean dumpFrontend = PrintCFG.getValue(options);
151         if (!dumpFrontend &amp;&amp; isFrontendObject(object)) {
152             return;
153         }
154 
155         if (cfgPrinter == null) {
156             try {
157                 Path dumpFile = debug.getDumpPath(&quot;.cfg&quot;, false);
158                 cfgFile = dumpFile.toFile();
159                 OutputStream out = new BufferedOutputStream(new FileOutputStream(cfgFile));
160                 cfgPrinter = new CFGPrinter(out);
161             } catch (IOException e) {
162                 throw (GraalError) new GraalError(&quot;Could not open %s&quot;, cfgFile == null ? &quot;[null]&quot; : cfgFile.getAbsolutePath()).initCause(e);
163             }
164         }
165 
166         if (!checkMethodScope(debug)) {
167             return;
168         }
169         try {
170             if (curMethod instanceof ResolvedJavaMethod) {
171                 cfgPrinter.method = (ResolvedJavaMethod) curMethod;
172             }
173 
174             if (object instanceof LIR) {
175                 cfgPrinter.lir = (LIR) object;
176             } else {
177                 cfgPrinter.lir = debug.contextLookup(LIR.class);
178             }
179             cfgPrinter.nodeLirGenerator = debug.contextLookup(NodeLIRBuilder.class);
180             cfgPrinter.res = debug.contextLookup(LIRGenerationResult.class);
181             if (cfgPrinter.nodeLirGenerator != null) {
182                 cfgPrinter.target = cfgPrinter.nodeLirGenerator.getLIRGeneratorTool().target();
183             }
184             if (cfgPrinter.lir != null &amp;&amp; cfgPrinter.lir.getControlFlowGraph() instanceof ControlFlowGraph) {
185                 cfgPrinter.cfg = (ControlFlowGraph) cfgPrinter.lir.getControlFlowGraph();
186             }
187 
188             CodeCacheProvider codeCache = debug.contextLookup(CodeCacheProvider.class);
189             if (codeCache != null) {
190                 cfgPrinter.target = codeCache.getTarget();
191             }
192 
193             if (object instanceof BciBlockMapping) {
194                 BciBlockMapping blockMap = (BciBlockMapping) object;
195                 cfgPrinter.printCFG(message, blockMap);
196                 if (blockMap.code.getCode() != null) {
197                     cfgPrinter.printBytecodes(new BytecodeDisassembler(false).disassemble(blockMap.code));
198                 }
199 
200             } else if (object instanceof LIR) {
201                 // Currently no node printing for lir
202                 cfgPrinter.printCFG(message, cfgPrinter.lir.codeEmittingOrder(), false);
203                 lastLIR = (LIR) object;
204                 if (delayedIntervals != null) {
205                     cfgPrinter.printIntervals(message, delayedIntervals);
206                     delayedIntervals = null;
207                 }
208             } else if (object instanceof ScheduleResult) {
209                 cfgPrinter.printSchedule(message, (ScheduleResult) object);
210             } else if (object instanceof StructuredGraph) {
211                 if (cfgPrinter.cfg == null) {
212                     StructuredGraph graph = (StructuredGraph) object;
213                     cfgPrinter.cfg = ControlFlowGraph.compute(graph, true, true, true, false);
214                     cfgPrinter.printCFG(message, cfgPrinter.cfg.getBlocks(), true);
215                 } else {
216                     cfgPrinter.printCFG(message, cfgPrinter.cfg.getBlocks(), true);
217                 }
218 
219             } else if (object instanceof CompilationResult) {
220                 final CompilationResult compResult = (CompilationResult) object;
221                 cfgPrinter.printMachineCode(disassemble(codeCache, compResult, null), message);
222             } else if (object instanceof InstalledCode) {
223                 CompilationResult compResult = debug.contextLookup(CompilationResult.class);
224                 if (compResult != null) {
225                     cfgPrinter.printMachineCode(disassemble(codeCache, compResult, (InstalledCode) object), message);
226                 }
227             } else if (object instanceof IntervalDumper) {
228                 if (lastLIR == cfgPrinter.lir) {
229                     cfgPrinter.printIntervals(message, (IntervalDumper) object);
230                 } else {
231                     if (delayedIntervals != null) {
232                         debug.log(&quot;Some delayed intervals were dropped (%s)&quot;, delayedIntervals);
233                     }
234                     delayedIntervals = (IntervalDumper) object;
235                 }
236             } else if (object instanceof AbstractBlockBase&lt;?&gt;[]) {
237                 cfgPrinter.printCFG(message, (AbstractBlockBase&lt;?&gt;[]) object, false);
238             } else if (object instanceof Trace) {
239                 cfgPrinter.printCFG(message, ((Trace) object).getBlocks(), false);
240             } else if (object instanceof TraceBuilderResult) {
241                 cfgPrinter.printTraces(message, (TraceBuilderResult) object);
242             }
243         } finally {
244             cfgPrinter.target = null;
245             cfgPrinter.lir = null;
246             cfgPrinter.res = null;
247             cfgPrinter.nodeLirGenerator = null;
248             cfgPrinter.cfg = null;
249             cfgPrinter.flush();
250         }
251     }
252 
253     /** Lazy initialization to delay service lookup until disassembler is actually needed. */
254     static class DisassemblerHolder {
255         private static final DisassemblerProvider disassembler;
256 
257         static {
258             DisassemblerProvider selected = null;
259             for (DisassemblerProvider d : GraalServices.load(DisassemblerProvider.class)) {
260                 String name = d.getName().toLowerCase();
261                 if (name.contains(&quot;hcf&quot;) || name.contains(&quot;hexcodefile&quot;)) {
262                     selected = d;
263                     break;
264                 }
265             }
266             if (selected == null) {
267                 selected = new DisassemblerProvider() {
268                     @Override
269                     public String getName() {
270                         return &quot;nop&quot;;
271                     }
272                 };
273             }
274             disassembler = selected;
275         }
276     }
277 
278     private static String disassemble(CodeCacheProvider codeCache, CompilationResult compResult, InstalledCode installedCode) {
279         DisassemblerProvider dis = DisassemblerHolder.disassembler;
280         if (installedCode != null) {
281             return dis.disassembleInstalledCode(codeCache, compResult, installedCode);
282         }
283         return dis.disassembleCompiledCode(codeCache, compResult);
284     }
285 
286     @Override
287     public void close() {
288         if (cfgPrinter != null) {
289             cfgPrinter.close();
290             cfgPrinter = null;
291             curDecorators = Collections.emptyList();
292             curMethod = null;
293             curCompilation = null;
294         }
295     }
296 
297     public String getDumpPath() {
298         if (cfgFile != null) {
299             return cfgFile.getAbsolutePath();
300         }
301         return null;
302     }
303 }
    </pre>
  </body>
</html>
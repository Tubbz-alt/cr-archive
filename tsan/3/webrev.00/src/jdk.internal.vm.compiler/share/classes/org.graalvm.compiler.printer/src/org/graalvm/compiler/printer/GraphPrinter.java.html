<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.printer/src/org/graalvm/compiler/printer/GraphPrinter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.printer;
 26 
 27 import java.io.Closeable;
 28 import java.io.IOException;
 29 import java.lang.reflect.Array;
 30 import java.util.Arrays;
 31 import java.util.Collections;
 32 import java.util.IdentityHashMap;
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.Set;
 36 
 37 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 38 import org.graalvm.compiler.debug.DebugContext;
 39 import org.graalvm.compiler.debug.DebugContext.Scope;
 40 import org.graalvm.compiler.graph.Graph;
 41 import org.graalvm.compiler.nodes.ConstantNode;
 42 import org.graalvm.compiler.nodes.StructuredGraph;
 43 import org.graalvm.compiler.nodes.util.JavaConstantFormatter;
 44 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 45 import org.graalvm.compiler.serviceprovider.GraalServices;
 46 
 47 import jdk.vm.ci.meta.JavaConstant;
 48 import jdk.vm.ci.meta.JavaKind;
 49 import jdk.vm.ci.meta.JavaType;
 50 import jdk.vm.ci.meta.MetaUtil;
 51 import jdk.vm.ci.meta.ResolvedJavaMethod;
 52 
 53 interface GraphPrinter extends Closeable, JavaConstantFormatter {
 54 
 55     /**
 56      * Starts a new group of graphs with the given name, short name and method byte code index (BCI)
 57      * as properties.
 58      */
 59     void beginGroup(DebugContext debug, String name, String shortName, ResolvedJavaMethod method, int bci, Map&lt;Object, Object&gt; properties) throws IOException;
 60 
 61     /**
 62      * Prints an entire {@link Graph} with the specified title, optionally using short names for
 63      * nodes.
 64      */
 65     void print(DebugContext debug, Graph graph, Map&lt;Object, Object&gt; properties, int id, String format, Object... args) throws IOException;
 66 
 67     SnippetReflectionProvider getSnippetReflectionProvider();
 68 
 69     /**
 70      * Ends the current group.
 71      */
 72     void endGroup() throws IOException;
 73 
 74     @Override
 75     void close();
 76 
 77     /**
 78      * Classes whose {@link #toString()} method does not run any untrusted code.
 79      */
 80     List&lt;Class&lt;?&gt;&gt; TRUSTED_CLASSES = Arrays.asList(
 81                     String.class,
 82                     Class.class,
 83                     Boolean.class,
 84                     Byte.class,
 85                     Character.class,
 86                     Short.class,
 87                     Integer.class,
 88                     Float.class,
 89                     Long.class,
 90                     Double.class);
 91     int MAX_CONSTANT_TO_STRING_LENGTH = 50;
 92 
 93     /**
 94      * Determines if invoking {@link Object#toString()} on an instance of {@code c} will only run
 95      * trusted code.
 96      */
 97     static boolean isToStringTrusted(Class&lt;?&gt; c) {
 98         if (TRUSTED_CLASSES.contains(c)) {
 99             return true;
100         }
101         if (GraalServices.isToStringTrusted(c)) {
102             return true;
103         }
104         if (c.getClassLoader() == GraphPrinter.class.getClassLoader()) {
105             return true;
106         }
107         return false;
108     }
109 
110     /**
111      * Use the real {@link Object#toString()} method for {@link JavaConstant JavaConstants} that are
112      * wrapping trusted types, otherwise just return the result of {@link JavaConstant#toString()}.
113      */
114     @Override
115     default String format(JavaConstant constant) {
116         SnippetReflectionProvider snippetReflection = getSnippetReflectionProvider();
117         if (snippetReflection != null) {
118             if (constant.getJavaKind() == JavaKind.Object) {
119                 Object obj = null;
120                 /*
121                  * Ignore any exceptions on unknown JavaConstant implementations in debugging code.
122                  */
123                 try {
124                     obj = snippetReflection.asObject(Object.class, constant);
125                 } catch (Throwable ex) {
126                 }
127                 if (obj != null) {
128                     Set&lt;Object&gt; visited = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());
129                     return GraphPrinter.constantToString(obj, visited);
130                 }
131             }
132         }
133         return constant.toString();
134     }
135 
136     /**
137      * Sets or updates the {@code &quot;rawvalue&quot;} and {@code &quot;toString&quot;} properties in {@code props} for
138      * {@code cn} if it&#39;s a boxed Object value and {@code snippetReflection} can access the raw
139      * value.
140      */
141     default void updateStringPropertiesForConstant(Map&lt;Object, Object&gt; props, ConstantNode cn) {
142         if (cn.isJavaConstant() &amp;&amp; cn.getStackKind().isObject()) {
143             String toString = format(cn.asJavaConstant());
144             String rawvalue = GraphPrinter.truncate(toString);
145             // Overwrite the value inserted by
146             // ConstantNode.getDebugProperties()
147             props.put(&quot;rawvalue&quot;, rawvalue);
148             if (!rawvalue.equals(toString)) {
149                 props.put(&quot;toString&quot;, toString);
150             }
151         }
152     }
153 
154     /**
155      * Replaces all {@link JavaType} elements in {@code args} with the result of
156      * {@link JavaType#getUnqualifiedName()}.
157      *
158      * @return a copy of {@code args} with the above mentioned substitutions or {@code args} if no
159      *         substitutions were performed
160      */
161     default Object[] simplifyClassArgs(Object... args) {
162         Object[] res = args;
163         for (int i = 0; i &lt; args.length; i++) {
164             Object arg = args[i];
165             if (arg instanceof JavaType) {
166                 if (args == res) {
167                     res = new Object[args.length];
168                     for (int a = 0; a &lt; i; a++) {
169                         res[a] = args[a];
170                     }
171                 }
172                 res[i] = ((JavaType) arg).getUnqualifiedName();
173             } else {
174                 res[i] = arg;
175             }
176         }
177         return res;
178     }
179 
180     static String truncate(String s) {
181         if (s.length() &gt; MAX_CONSTANT_TO_STRING_LENGTH) {
182             return s.substring(0, MAX_CONSTANT_TO_STRING_LENGTH - 3) + &quot;...&quot;;
183         }
184         return s;
185     }
186 
187     static String constantToString(Object value, Set&lt;Object&gt; visited) {
188         if (!visited.contains(value)) {
189             Class&lt;?&gt; c = value.getClass();
190             String suffix = &quot;&quot;;
191             if (c.isArray()) {
192                 return constantArrayToString(value, visited);
193             }
194             visited.add(value);
195             if (value instanceof Enum) {
196                 return ((Enum&lt;?&gt;) value).name();
197             } else if (isToStringTrusted(c)) {
198                 try {
199                     return value.toString();
200                 } catch (Throwable t) {
201                     suffix = &quot;[toString error: &quot; + t.getClass().getName() + &quot;]&quot;;
202                     if (isToStringTrusted(t.getClass())) {
203                         try {
204                             suffix = &quot;[toString error: &quot; + t + &quot;]&quot;;
205                         } catch (Throwable t2) {
206                             // No point in going further
207                         }
208                     }
209                 }
210             }
211             return MetaUtil.getSimpleName(c, true) + &quot;@&quot; + Integer.toHexString(System.identityHashCode(value)) + suffix;
212         } else {
213             return &quot;...&quot;;
214         }
215 
216     }
217 
218     static String constantArrayToString(Object array, Set&lt;Object&gt; visited) {
219         if (!visited.contains(array)) {
220             visited.add(array);
221             Class&lt;?&gt; componentType = array.getClass().getComponentType();
222             assert componentType != null;
223             int arrayLength = Array.getLength(array);
224             StringBuilder buf = new StringBuilder(MetaUtil.getSimpleName(componentType, true)).append(&#39;[&#39;).append(arrayLength).append(&quot;]{&quot;);
225             int length = arrayLength;
226             boolean primitive = componentType.isPrimitive();
227             for (int i = 0; i &lt; length; i++) {
228                 if (primitive) {
229                     buf.append(Array.get(array, i));
230                 } else {
231                     Object o = ((Object[]) array)[i];
232                     buf.append(o == null ? &quot;null&quot; : constantToString(o, visited));
233                 }
234                 if (i != length - 1) {
235                     buf.append(&quot;, &quot;);
236                 }
237             }
238             return buf.append(&#39;}&#39;).toString();
239         } else {
240             return &quot;...&quot;;
241         }
242     }
243 
244     @SuppressWarnings(&quot;try&quot;)
245     static StructuredGraph.ScheduleResult getScheduleOrNull(Graph graph) {
246         if (graph instanceof StructuredGraph) {
247             StructuredGraph sgraph = (StructuredGraph) graph;
248             StructuredGraph.ScheduleResult scheduleResult = sgraph.getLastSchedule();
249             if (scheduleResult == null) {
250                 DebugContext debug = graph.getDebug();
251                 try (Scope scope = debug.disable()) {
252                     SchedulePhase schedule = new SchedulePhase(graph.getOptions());
253                     schedule.apply(sgraph);
254                     scheduleResult = sgraph.getLastSchedule();
255                 } catch (Throwable t) {
256                 }
257             }
258             return scheduleResult;
259         }
260         return null;
261     }
262 }
    </pre>
  </body>
</html>
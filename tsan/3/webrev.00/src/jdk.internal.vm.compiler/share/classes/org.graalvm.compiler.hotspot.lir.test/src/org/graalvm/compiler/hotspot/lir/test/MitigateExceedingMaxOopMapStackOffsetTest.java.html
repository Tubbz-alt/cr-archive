<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.lir.test/src/org/graalvm/compiler/hotspot/lir/test/MitigateExceedingMaxOopMapStackOffsetTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.lir.test;
 26 
 27 import java.util.ArrayList;
 28 import java.util.List;
 29 
 30 import org.graalvm.compiler.core.common.LIRKind;
 31 import org.graalvm.compiler.hotspot.HotSpotBackend;
 32 import org.graalvm.compiler.lir.VirtualStackSlot;
 33 import org.graalvm.compiler.lir.framemap.FrameMapBuilder;
 34 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 35 import org.graalvm.compiler.lir.jtt.LIRTest;
 36 import org.graalvm.compiler.lir.jtt.LIRTestSpecification;
 37 import org.graalvm.compiler.lir.stackslotalloc.LSStackSlotAllocator;
 38 import org.graalvm.compiler.nodes.SafepointNode;
 39 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 40 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 41 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 42 import org.junit.Assume;
 43 import org.junit.Test;
 44 
 45 import jdk.vm.ci.meta.AllocatableValue;
 46 import jdk.vm.ci.meta.JavaConstant;
 47 import jdk.vm.ci.meta.ResolvedJavaMethod;
 48 
 49 /**
 50  * Tests the mitigation against overflowing the max size limit for a HotSpot OopMap. The mitigation
 51  * works by {@link LSStackSlotAllocator} placing reference typed stack slots at lower offsets.
 52  */
 53 public class MitigateExceedingMaxOopMapStackOffsetTest extends LIRTest {
 54 
 55     /**
 56      * Allocate stacks slots and initializes those at an odd index with a reference constant and
 57      * those at an even index with a primitive constant.
 58      */
 59     private static class WriteStackValues extends LIRTestSpecification {
 60         private final JavaConstant objectConstant;
 61         private final JavaConstant primitiveConstant;
 62 
 63         WriteStackValues(JavaConstant objectConstant, JavaConstant primitiveConstant) {
 64             this.objectConstant = objectConstant;
 65             this.primitiveConstant = primitiveConstant;
 66         }
 67 
 68         @Override
 69         public void generate(LIRGeneratorTool gen) {
 70             FrameMapBuilder frameMapBuilder = gen.getResult().getFrameMapBuilder();
 71             LIRKind objectLirKind = LIRKind.reference(gen.target().arch.getPlatformKind(objectConstant.getJavaKind()));
 72             LIRKind primitiveLirKind = LIRKind.value(gen.target().arch.getPlatformKind(primitiveConstant.getJavaKind()));
 73 
 74             int numSlots = numPrimitiveSlots + numReferenceSlots;
 75             List&lt;AllocatableValue&gt; slotList = new ArrayList&lt;&gt;(numSlots);
 76             // Place reference slots at top and bottom of virtual frame
 77             // with primitive slots in the middle. This tests that slot
 78             // partitioning works.
 79             AllocatableValue srcObject = gen.emitLoadConstant(objectLirKind, objectConstant);
 80             for (int i = 0; i &lt; numReferenceSlots / 2; i++) {
 81                 VirtualStackSlot slot = frameMapBuilder.allocateSpillSlot(objectLirKind);
 82                 slotList.add(slot);
 83                 gen.emitMove(slot, srcObject);
 84             }
 85             AllocatableValue srcPrimitive = gen.emitLoadConstant(objectLirKind, primitiveConstant);
 86             for (int i = 0; i &lt; numPrimitiveSlots; i++) {
 87                 VirtualStackSlot slot = frameMapBuilder.allocateSpillSlot(primitiveLirKind);
 88                 slotList.add(slot);
 89                 gen.emitMove(slot, srcPrimitive);
 90             }
 91             for (int i = numReferenceSlots / 2; i &lt; numReferenceSlots; i++) {
 92                 VirtualStackSlot slot = frameMapBuilder.allocateSpillSlot(objectLirKind);
 93                 slotList.add(slot);
 94                 gen.emitMove(slot, srcObject);
 95             }
 96             slots = slotList.toArray(new AllocatableValue[slotList.size()]);
 97         }
 98     }
 99 
100     /**
101      * Read stacks slots and move their content into a blackhole.
102      */
103     private static class ReadStackValues extends LIRTestSpecification {
104 
105         ReadStackValues() {
106         }
107 
108         @Override
109         public void generate(LIRGeneratorTool gen) {
110             for (int i = 0; i &lt; slots.length; i++) {
111                 gen.emitBlackhole(gen.emitMove(slots[i]));
112             }
113         }
114     }
115 
116     @Override
117     protected GraphBuilderConfiguration editGraphBuilderConfiguration(GraphBuilderConfiguration conf) {
118         InvocationPlugin safepointPlugin = new InvocationPlugin() {
119             @Override
120             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
121                 b.add(new SafepointNode());
122                 return true;
123             }
124         };
125         conf.getPlugins().getInvocationPlugins().register(safepointPlugin, getClass(), &quot;safepoint&quot;);
126         return super.editGraphBuilderConfiguration(conf);
127     }
128 
129     /*
130      * Safepoint Snippet
131      */
132     private static void safepoint() {
133     }
134 
135     private static int numPrimitiveSlots;
136     private static int numReferenceSlots;
137     private static AllocatableValue[] slots;
138 
139     private static final LIRTestSpecification readStackValues = new ReadStackValues();
140 
141     @SuppressWarnings(&quot;unused&quot;)
142     @LIRIntrinsic
143     public static void instrinsic(LIRTestSpecification spec) {
144     }
145 
146     private static final LIRTestSpecification writeStackValues = new WriteStackValues(JavaConstant.NULL_POINTER, JavaConstant.LONG_0);
147 
148     public void testStackObjects() {
149         instrinsic(writeStackValues);
150         safepoint();
151         instrinsic(readStackValues);
152     }
153 
154     @Test
155     public void runStackObjects() {
156         int max = ((HotSpotBackend) getBackend()).getRuntime().getVMConfig().maxOopMapStackOffset;
157         Assume.assumeFalse(&quot;no limit on oop map size&quot;, max == Integer.MAX_VALUE);
158         numPrimitiveSlots = (max / 8) * 2;
159         numReferenceSlots = (max / 8) - 100; // Should be enough margin for all platforms
160         runTest(&quot;testStackObjects&quot;);
161     }
162 }
    </pre>
  </body>
</html>
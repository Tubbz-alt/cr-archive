<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop.phases/src/org/graalvm/compiler/loop/phases/LoopTransformations.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LoopSafepointEliminationPhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.loop.test/src/org/graalvm/compiler/loop/test/LoopPartialUnrollTest.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop.phases/src/org/graalvm/compiler/loop/phases/LoopTransformations.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 33,13 ***</span>
<span class="line-new-header">--- 33,17 ---</span>
  import jdk.internal.vm.compiler.collections.EconomicMap;
  import org.graalvm.compiler.core.common.RetryableBailoutException;
  import org.graalvm.compiler.core.common.calc.CanonicalCondition;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.graph.Graph.Mark;
<span class="line-added">+ import org.graalvm.compiler.graph.Graph.NodeEventScope;</span>
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.Position;
<span class="line-added">+ import org.graalvm.compiler.graph.spi.Simplifiable;</span>
<span class="line-added">+ import org.graalvm.compiler.graph.spi.SimplifierTool;</span>
  import org.graalvm.compiler.loop.CountedLoopInfo;
<span class="line-added">+ import org.graalvm.compiler.loop.DefaultLoopPolicies;</span>
  import org.graalvm.compiler.loop.InductionVariable.Direction;
  import org.graalvm.compiler.loop.LoopEx;
  import org.graalvm.compiler.loop.LoopFragmentInside;
  import org.graalvm.compiler.loop.LoopFragmentWhole;
  import org.graalvm.compiler.nodeinfo.InputType;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 47,10 ***</span>
<span class="line-new-header">--- 51,11 ---</span>
  import org.graalvm.compiler.nodes.AbstractEndNode;
  import org.graalvm.compiler.nodes.AbstractMergeNode;
  import org.graalvm.compiler.nodes.BeginNode;
  import org.graalvm.compiler.nodes.ControlSplitNode;
  import org.graalvm.compiler.nodes.EndNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.FixedGuardNode;</span>
  import org.graalvm.compiler.nodes.FixedNode;
  import org.graalvm.compiler.nodes.FixedWithNextNode;
  import org.graalvm.compiler.nodes.IfNode;
  import org.graalvm.compiler.nodes.LogicNode;
  import org.graalvm.compiler.nodes.LoopBeginNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,41 ***</span>
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.calc.AddNode;
  import org.graalvm.compiler.nodes.calc.CompareNode;
  import org.graalvm.compiler.nodes.calc.ConditionalNode;
<span class="line-removed">- import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;</span>
  import org.graalvm.compiler.nodes.extended.OpaqueNode;
  import org.graalvm.compiler.nodes.extended.SwitchNode;
  import org.graalvm.compiler.phases.common.CanonicalizerPhase;
<span class="line-modified">! import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
  
  public abstract class LoopTransformations {
  
      private LoopTransformations() {
          // does not need to be instantiated
      }
  
      public static void peel(LoopEx loop) {
          loop.inside().duplicate().insertBefore(loop);
<span class="line-modified">!         loop.loopBegin().setLoopFrequency(Math.max(0.0, loop.loopBegin().loopFrequency() - 1));</span>
      }
  
<span class="line-modified">!     public static void fullUnroll(LoopEx loop, PhaseContext context, CanonicalizerPhase canonicalizer) {</span>
          // assert loop.isCounted(); //TODO (gd) strengthen : counted with known trip count
          LoopBeginNode loopBegin = loop.loopBegin();
          StructuredGraph graph = loopBegin.graph();
          int initialNodeCount = graph.getNodeCount();
<span class="line-modified">!         while (!loopBegin.isDeleted()) {</span>
<span class="line-modified">!             Mark mark = graph.getMark();</span>
<span class="line-modified">!             peel(loop);</span>
<span class="line-modified">!             canonicalizer.applyIncremental(graph, context, mark);</span>
<span class="line-modified">!             loop.invalidateFragments();</span>
<span class="line-modified">!             if (graph.getNodeCount() &gt; initialNodeCount + MaximumDesiredSize.getValue(graph.getOptions()) * 2) {</span>
<span class="line-modified">!                 throw new RetryableBailoutException(&quot;FullUnroll : Graph seems to grow out of proportion&quot;);</span>
              }
          }
      }
  
      public static void unswitch(LoopEx loop, List&lt;ControlSplitNode&gt; controlSplitNodeSet) {
          ControlSplitNode firstNode = controlSplitNodeSet.iterator().next();
          LoopFragmentWhole originalLoop = loop.whole();
<span class="line-new-header">--- 65,82 ---</span>
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.calc.AddNode;
  import org.graalvm.compiler.nodes.calc.CompareNode;
  import org.graalvm.compiler.nodes.calc.ConditionalNode;
  import org.graalvm.compiler.nodes.extended.OpaqueNode;
  import org.graalvm.compiler.nodes.extended.SwitchNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
<span class="line-added">+ import org.graalvm.compiler.nodes.util.GraphUtil;</span>
<span class="line-added">+ import org.graalvm.compiler.nodes.util.IntegerHelper;</span>
  import org.graalvm.compiler.phases.common.CanonicalizerPhase;
<span class="line-modified">! import org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener;</span>
  
  public abstract class LoopTransformations {
  
      private LoopTransformations() {
          // does not need to be instantiated
      }
  
      public static void peel(LoopEx loop) {
<span class="line-added">+         loop.detectCounted();</span>
          loop.inside().duplicate().insertBefore(loop);
<span class="line-modified">!         if (loop.isCounted()) {</span>
<span class="line-added">+             // For counted loops we assume that we have an effect on the loop frequency.</span>
<span class="line-added">+             loop.loopBegin().setLoopFrequency(Math.max(1.0, loop.loopBegin().loopFrequency() - 1));</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-added">+     public static void fullUnroll(LoopEx loop, CoreProviders context, CanonicalizerPhase canonicalizer) {</span>
          // assert loop.isCounted(); //TODO (gd) strengthen : counted with known trip count
          LoopBeginNode loopBegin = loop.loopBegin();
          StructuredGraph graph = loopBegin.graph();
          int initialNodeCount = graph.getNodeCount();
<span class="line-modified">!         SimplifierTool defaultSimplifier = GraphUtil.getDefaultSimplifier(context.getMetaAccess(), context.getConstantReflection(), context.getConstantFieldProvider(),</span>
<span class="line-modified">!                         canonicalizer.getCanonicalizeReads(), graph.getAssumptions(), graph.getOptions());</span>
<span class="line-modified">!         /*</span>
<span class="line-modified">!          * IMPORTANT: Canonicalizations inside the body of the remaining loop can introduce new</span>
<span class="line-modified">!          * control flow that is not automatically picked up by the control flow graph computation of</span>
<span class="line-modified">!          * the original LoopEx data structure, thus we disable simplification and manually simplify</span>
<span class="line-modified">!          * conditions in the peeled iteration to simplify the exit path.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         CanonicalizerPhase c = canonicalizer.copyWithoutSimplification();</span>
<span class="line-added">+         EconomicSetNodeEventListener l = new EconomicSetNodeEventListener();</span>
<span class="line-added">+         int peelings = 0;</span>
<span class="line-added">+         try (NodeEventScope ev = graph.trackNodeEvents(l)) {</span>
<span class="line-added">+             while (!loopBegin.isDeleted()) {</span>
<span class="line-added">+                 Mark newNodes = graph.getMark();</span>
<span class="line-added">+                 /*</span>
<span class="line-added">+                  * Mark is not enough for the canonicalization of the floating nodes in the unrolled</span>
<span class="line-added">+                  * code since pre-existing constants are not new nodes. Therefore, we canonicalize</span>
<span class="line-added">+                  * (without simplification) all floating nodes changed during peeling but only</span>
<span class="line-added">+                  * simplify new (in the peeled iteration) ones.</span>
<span class="line-added">+                  */</span>
<span class="line-added">+                 EconomicSetNodeEventListener peeledListener = new EconomicSetNodeEventListener();</span>
<span class="line-added">+                 try (NodeEventScope peeledScope = graph.trackNodeEvents(peeledListener)) {</span>
<span class="line-added">+                     LoopTransformations.peel(loop);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 graph.getDebug().dump(DebugContext.VERY_DETAILED_LEVEL, graph, &quot;After peeling loop %s&quot;, loop);</span>
<span class="line-added">+                 c.applyIncremental(graph, context, peeledListener.getNodes());</span>
<span class="line-added">+                 loop.invalidateFragments();</span>
<span class="line-added">+                 for (Node n : graph.getNewNodes(newNodes)) {</span>
<span class="line-added">+                     if (n.isAlive() &amp;&amp; (n instanceof IfNode || n instanceof SwitchNode || n instanceof FixedGuardNode || n instanceof BeginNode)) {</span>
<span class="line-added">+                         Simplifiable s = (Simplifiable) n;</span>
<span class="line-added">+                         s.simplify(defaultSimplifier);</span>
<span class="line-added">+                         graph.getDebug().dump(DebugContext.VERY_DETAILED_LEVEL, graph, &quot;After simplifying if %s&quot;, s);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (graph.getNodeCount() &gt; initialNodeCount + MaximumDesiredSize.getValue(graph.getOptions()) * 2 ||</span>
<span class="line-added">+                                 peelings &gt; DefaultLoopPolicies.Options.FullUnrollMaxIterations.getValue(graph.getOptions())) {</span>
<span class="line-added">+                     throw new RetryableBailoutException(&quot;FullUnroll : Graph seems to grow out of proportion&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 peelings++;</span>
              }
          }
<span class="line-added">+         // Canonicalize with the original canonicalizer to capture all simplifications</span>
<span class="line-added">+         canonicalizer.applyIncremental(graph, context, l.getNodes());</span>
      }
  
      public static void unswitch(LoopEx loop, List&lt;ControlSplitNode&gt; controlSplitNodeSet) {
          ControlSplitNode firstNode = controlSplitNodeSet.iterator().next();
          LoopFragmentWhole originalLoop = loop.whole();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 278,13 ***</span>
          cleanupMerge(postMergeNode, postLoopExitNode);
          cleanupMerge(mainMergeNode, mainLandingNode);
  
          // Change the preLoop to execute one iteration for now
          updatePreLoopLimit(preCounted);
<span class="line-modified">!         preLoopBegin.setLoopFrequency(1);</span>
<span class="line-modified">!         mainLoopBegin.setLoopFrequency(Math.max(0.0, mainLoopBegin.loopFrequency() - 2));</span>
<span class="line-modified">!         postLoopBegin.setLoopFrequency(Math.max(0.0, postLoopBegin.loopFrequency() - 1));</span>
  
          // The pre and post loops don&#39;t require safepoints at all
          for (SafepointNode safepoint : preLoop.nodes().filter(SafepointNode.class)) {
              graph.removeFixed(safepoint);
          }
<span class="line-new-header">--- 324,13 ---</span>
          cleanupMerge(postMergeNode, postLoopExitNode);
          cleanupMerge(mainMergeNode, mainLandingNode);
  
          // Change the preLoop to execute one iteration for now
          updatePreLoopLimit(preCounted);
<span class="line-modified">!         preLoopBegin.setLoopFrequency(1.0);</span>
<span class="line-modified">!         mainLoopBegin.setLoopFrequency(Math.max(1.0, mainLoopBegin.loopFrequency() - 2));</span>
<span class="line-modified">!         postLoopBegin.setLoopFrequency(Math.max(1.0, postLoopBegin.loopFrequency() - 1));</span>
  
          // The pre and post loops don&#39;t require safepoints at all
          for (SafepointNode safepoint : preLoop.nodes().filter(SafepointNode.class)) {
              graph.removeFixed(safepoint);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 357,15 ***</span>
          // Update the pre loops limit test
          // Make new limit one iteration
          ValueNode newLimit = AddNode.add(preCounted.getStart(), preCounted.getCounter().strideNode(), NodeView.DEFAULT);
          // Fetch the variable we are not replacing and configure the one we are
          ValueNode ub = preCounted.getLimit();
          LogicNode entryCheck;
          if (preCounted.getDirection() == Direction.Up) {
<span class="line-modified">!             entryCheck = IntegerLessThanNode.create(newLimit, ub, NodeView.DEFAULT);</span>
          } else {
<span class="line-modified">!             entryCheck = IntegerLessThanNode.create(ub, newLimit, NodeView.DEFAULT);</span>
          }
          newLimit = ConditionalNode.create(entryCheck, newLimit, ub, NodeView.DEFAULT);
          // Re-wire the condition with the new limit
          CompareNode compareNode = (CompareNode) preCounted.getLimitTest().condition();
          compareNode.replaceFirstInput(ub, compareNode.graph().addOrUniqueWithInputs(newLimit));
<span class="line-new-header">--- 403,16 ---</span>
          // Update the pre loops limit test
          // Make new limit one iteration
          ValueNode newLimit = AddNode.add(preCounted.getStart(), preCounted.getCounter().strideNode(), NodeView.DEFAULT);
          // Fetch the variable we are not replacing and configure the one we are
          ValueNode ub = preCounted.getLimit();
<span class="line-added">+         IntegerHelper helper = preCounted.getCounterIntegerHelper();</span>
          LogicNode entryCheck;
          if (preCounted.getDirection() == Direction.Up) {
<span class="line-modified">!             entryCheck = helper.createCompareNode(newLimit, ub, NodeView.DEFAULT);</span>
          } else {
<span class="line-modified">!             entryCheck = helper.createCompareNode(ub, newLimit, NodeView.DEFAULT);</span>
          }
          newLimit = ConditionalNode.create(entryCheck, newLimit, ub, NodeView.DEFAULT);
          // Re-wire the condition with the new limit
          CompareNode compareNode = (CompareNode) preCounted.getLimitTest().condition();
          compareNode.replaceFirstInput(ub, compareNode.graph().addOrUniqueWithInputs(newLimit));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 392,13 ***</span>
                      if (controls == null) {
                          firstSwitch = switchNode;
                          invariantValue = switchNode.value();
                          controls = new ArrayList&lt;&gt;();
                          controls.add(switchNode);
<span class="line-modified">!                     } else if (switchNode.value() == invariantValue &amp;&amp; firstSwitch.structureEquals(switchNode)) {</span>
<span class="line-modified">!                         // Only collect switches which test the same values in the same order</span>
<span class="line-modified">!                         controls.add(switchNode);</span>
                      }
                  }
              }
          }
          return controls;
<span class="line-new-header">--- 439,18 ---</span>
                      if (controls == null) {
                          firstSwitch = switchNode;
                          invariantValue = switchNode.value();
                          controls = new ArrayList&lt;&gt;();
                          controls.add(switchNode);
<span class="line-modified">!                     } else if (switchNode.value() == invariantValue) {</span>
<span class="line-modified">!                         // Fortify: Suppress Null Dereference false positive</span>
<span class="line-modified">!                         assert firstSwitch != null;</span>
<span class="line-added">+ </span>
<span class="line-added">+                         if (firstSwitch.structureEquals(switchNode)) {</span>
<span class="line-added">+                             // Only collect switches which test the same values in the same order</span>
<span class="line-added">+                             controls.add(switchNode);</span>
<span class="line-added">+                         }</span>
                      }
                  }
              }
          }
          return controls;
</pre>
<center><a href="LoopSafepointEliminationPhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.loop.test/src/org/graalvm/compiler/loop/test/LoopPartialUnrollTest.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
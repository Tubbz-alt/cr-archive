<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop.phases/src/org/graalvm/compiler/loop/phases/ConvertDeoptimizeToGuardPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ContextlessLoopPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFullUnrollPhase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop.phases/src/org/graalvm/compiler/loop/phases/ConvertDeoptimizeToGuardPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 42 import org.graalvm.compiler.nodes.AbstractMergeNode;
 43 import org.graalvm.compiler.nodes.ConstantNode;
 44 import org.graalvm.compiler.nodes.ControlSplitNode;
 45 import org.graalvm.compiler.nodes.DeoptimizeNode;
 46 import org.graalvm.compiler.nodes.EndNode;
 47 import org.graalvm.compiler.nodes.FixedGuardNode;
 48 import org.graalvm.compiler.nodes.FixedNode;
 49 import org.graalvm.compiler.nodes.FixedWithNextNode;
 50 import org.graalvm.compiler.nodes.GuardNode;
 51 import org.graalvm.compiler.nodes.IfNode;
 52 import org.graalvm.compiler.nodes.LogicNode;
 53 import org.graalvm.compiler.nodes.LoopExitNode;
 54 import org.graalvm.compiler.nodes.ProxyNode;
 55 import org.graalvm.compiler.nodes.StartNode;
 56 import org.graalvm.compiler.nodes.StaticDeoptimizingNode;
 57 import org.graalvm.compiler.nodes.StructuredGraph;
 58 import org.graalvm.compiler.nodes.ValueNode;
 59 import org.graalvm.compiler.nodes.ValuePhiNode;
 60 import org.graalvm.compiler.nodes.calc.CompareNode;
 61 import org.graalvm.compiler.nodes.cfg.Block;

 62 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 63 import org.graalvm.compiler.nodes.util.GraphUtil;
 64 import org.graalvm.compiler.phases.BasePhase;
 65 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 66 import org.graalvm.compiler.phases.common.LazyValue;
<span class="line-removed"> 67 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 68 
 69 import jdk.vm.ci.meta.Constant;
 70 import jdk.vm.ci.meta.DeoptimizationAction;
 71 
 72 /**
 73  * This phase will find branches which always end with a {@link DeoptimizeNode} and replace their
 74  * {@link ControlSplitNode ControlSplitNodes} with {@link FixedGuardNode FixedGuardNodes}.
 75  *
 76  * This is useful because {@link FixedGuardNode FixedGuardNodes} will be lowered to {@link GuardNode
 77  * GuardNodes} which can later be optimized more aggressively than control-flow constructs.
 78  *
 79  * This is currently only done for branches that start from a {@link IfNode}. If it encounters a
 80  * branch starting at an other kind of {@link ControlSplitNode}, it will only bring the
 81  * {@link DeoptimizeNode} as close to the {@link ControlSplitNode} as possible.
 82  *
 83  */
<span class="line-modified"> 84 public class ConvertDeoptimizeToGuardPhase extends BasePhase&lt;PhaseContext&gt; {</span>
 85     @Override
 86     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 87     protected void run(final StructuredGraph graph, PhaseContext context) {</span>
 88         assert graph.hasValueProxies() : &quot;ConvertDeoptimizeToGuardPhase always creates proxies&quot;;
 89         assert !graph.getGuardsStage().areFrameStatesAtDeopts() : graph.getGuardsStage();
 90         LazyValue&lt;LoopsData&gt; lazyLoops = new LazyValue&lt;&gt;(() -&gt; new LoopsData(graph));
 91 
 92         for (DeoptimizeNode d : graph.getNodes(DeoptimizeNode.TYPE)) {
 93             assert d.isAlive();
 94             if (d.getAction() == DeoptimizationAction.None) {
 95                 continue;
 96             }
 97             try (DebugCloseable closable = d.withNodeSourcePosition()) {
 98                 propagateFixed(d, d, context != null ? context.getLowerer() : null, lazyLoops);
 99             }
100         }
101 
102         if (context != null) {
103             for (FixedGuardNode fixedGuard : graph.getNodes(FixedGuardNode.TYPE)) {
104                 try (DebugCloseable closable = fixedGuard.withNodeSourcePosition()) {
105                     trySplitFixedGuard(fixedGuard, context, lazyLoops);
106                 }
107             }
108         }
109 
110         new DeadCodeEliminationPhase(Optional).apply(graph);
111     }
112 
<span class="line-modified">113     private static void trySplitFixedGuard(FixedGuardNode fixedGuard, PhaseContext context, LazyValue&lt;LoopsData&gt; lazyLoops) {</span>
114         LogicNode condition = fixedGuard.condition();
115         if (condition instanceof CompareNode) {
116             CompareNode compare = (CompareNode) condition;
117             ValueNode x = compare.getX();
118             ValuePhiNode xPhi = (x instanceof ValuePhiNode) ? (ValuePhiNode) x : null;
119             if (x instanceof ConstantNode || xPhi != null) {
120                 ValueNode y = compare.getY();
121                 ValuePhiNode yPhi = (y instanceof ValuePhiNode) ? (ValuePhiNode) y : null;
122                 if (y instanceof ConstantNode || yPhi != null) {
123                     processFixedGuardAndPhis(fixedGuard, context, compare, x, xPhi, y, yPhi, lazyLoops);
124                 }
125             }
126         }
127     }
128 
<span class="line-modified">129     private static void processFixedGuardAndPhis(FixedGuardNode fixedGuard, PhaseContext context, CompareNode compare, ValueNode x, ValuePhiNode xPhi, ValueNode y, ValuePhiNode yPhi,</span>
130                     LazyValue&lt;LoopsData&gt; lazyLoops) {
131         AbstractBeginNode pred = AbstractBeginNode.prevBegin(fixedGuard);
132         if (pred instanceof AbstractMergeNode) {
133             AbstractMergeNode merge = (AbstractMergeNode) pred;
134             if (xPhi != null &amp;&amp; xPhi.merge() != merge) {
135                 return;
136             }
137             if (yPhi != null &amp;&amp; yPhi.merge() != merge) {
138                 return;
139             }
140 
141             processFixedGuardAndMerge(fixedGuard, context, compare, x, xPhi, y, yPhi, merge, lazyLoops);
142         }
143     }
144 
145     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">146     private static void processFixedGuardAndMerge(FixedGuardNode fixedGuard, PhaseContext context, CompareNode compare, ValueNode x, ValuePhiNode xPhi, ValueNode y, ValuePhiNode yPhi,</span>
147                     AbstractMergeNode merge, LazyValue&lt;LoopsData&gt; lazyLoops) {
148         List&lt;EndNode&gt; mergePredecessors = merge.cfgPredecessors().snapshot();
149         for (AbstractEndNode mergePredecessor : mergePredecessors) {
150             if (!mergePredecessor.isAlive()) {
151                 break;
152             }
153             Constant xs;
154             if (xPhi == null) {
155                 xs = x.asConstant();
156             } else {
157                 xs = xPhi.valueAt(mergePredecessor).asConstant();
158             }
159             Constant ys;
160             if (yPhi == null) {
161                 ys = y.asConstant();
162             } else {
163                 ys = yPhi.valueAt(mergePredecessor).asConstant();
164             }
165             if (xs != null &amp;&amp; ys != null &amp;&amp; compare.condition().foldCondition(xs, ys, context.getConstantReflection(), compare.unorderedIsTrue()) == fixedGuard.isNegated()) {
166                 try (DebugCloseable position = fixedGuard.withNodeSourcePosition()) {
</pre>
<hr />
<pre>
200                     } else {
201                         // Prioritize the source position of the IfNode
202                         try (DebugCloseable closable = ifNode.withNodeSourcePosition()) {
203                             StructuredGraph graph = ifNode.graph();
204                             LogicNode conditionNode = ifNode.condition();
205                             boolean negateGuardCondition = current == ifNode.trueSuccessor();
206                             NodeSourcePosition survivingSuccessorPosition = negateGuardCondition ? ifNode.falseSuccessor().getNodeSourcePosition() : ifNode.trueSuccessor().getNodeSourcePosition();
207                             FixedGuardNode guard = graph.add(
208                                             new FixedGuardNode(conditionNode, deopt.getReason(), deopt.getAction(), deopt.getSpeculation(), negateGuardCondition, survivingSuccessorPosition));
209                             FixedWithNextNode pred = (FixedWithNextNode) ifNode.predecessor();
210                             AbstractBeginNode survivingSuccessor;
211                             if (negateGuardCondition) {
212                                 survivingSuccessor = ifNode.falseSuccessor();
213                             } else {
214                                 survivingSuccessor = ifNode.trueSuccessor();
215                             }
216                             graph.removeSplitPropagate(ifNode, survivingSuccessor);
217 
218                             Node newGuard = guard;
219                             if (survivingSuccessor instanceof LoopExitNode) {
<span class="line-modified">220                                 newGuard = ProxyNode.forGuard(guard, (LoopExitNode) survivingSuccessor, graph);</span>
221                             }
222                             survivingSuccessor.replaceAtUsages(InputType.Guard, newGuard);
223 
224                             graph.getDebug().log(&quot;Converting deopt on %-5s branch of %s to guard for remaining branch %s.&quot;, negateGuardCondition, ifNode, survivingSuccessor);
225                             FixedNode next = pred.next();
226                             pred.setNext(guard);
227                             guard.setNext(next);
228                             SimplifierTool simplifierTool = GraphUtil.getDefaultSimplifier(null, null, null, false, graph.getAssumptions(), graph.getOptions(), loweringProvider);
229                             survivingSuccessor.simplify(simplifierTool);
230                         }
231                     }
232                     return;
233                 } else if (current.predecessor() == null || current.predecessor() instanceof ControlSplitNode) {
234                     assert current.predecessor() != null || (current instanceof StartNode &amp;&amp; current == ((AbstractBeginNode) current).graph().start());
235                     moveAsDeoptAfter((AbstractBeginNode) current, deopt);
236                     return;
237                 }
238             }
239             current = current.predecessor();
240         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 42 import org.graalvm.compiler.nodes.AbstractMergeNode;
 43 import org.graalvm.compiler.nodes.ConstantNode;
 44 import org.graalvm.compiler.nodes.ControlSplitNode;
 45 import org.graalvm.compiler.nodes.DeoptimizeNode;
 46 import org.graalvm.compiler.nodes.EndNode;
 47 import org.graalvm.compiler.nodes.FixedGuardNode;
 48 import org.graalvm.compiler.nodes.FixedNode;
 49 import org.graalvm.compiler.nodes.FixedWithNextNode;
 50 import org.graalvm.compiler.nodes.GuardNode;
 51 import org.graalvm.compiler.nodes.IfNode;
 52 import org.graalvm.compiler.nodes.LogicNode;
 53 import org.graalvm.compiler.nodes.LoopExitNode;
 54 import org.graalvm.compiler.nodes.ProxyNode;
 55 import org.graalvm.compiler.nodes.StartNode;
 56 import org.graalvm.compiler.nodes.StaticDeoptimizingNode;
 57 import org.graalvm.compiler.nodes.StructuredGraph;
 58 import org.graalvm.compiler.nodes.ValueNode;
 59 import org.graalvm.compiler.nodes.ValuePhiNode;
 60 import org.graalvm.compiler.nodes.calc.CompareNode;
 61 import org.graalvm.compiler.nodes.cfg.Block;
<span class="line-added"> 62 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 63 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 64 import org.graalvm.compiler.nodes.util.GraphUtil;
 65 import org.graalvm.compiler.phases.BasePhase;
 66 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 67 import org.graalvm.compiler.phases.common.LazyValue;

 68 
 69 import jdk.vm.ci.meta.Constant;
 70 import jdk.vm.ci.meta.DeoptimizationAction;
 71 
 72 /**
 73  * This phase will find branches which always end with a {@link DeoptimizeNode} and replace their
 74  * {@link ControlSplitNode ControlSplitNodes} with {@link FixedGuardNode FixedGuardNodes}.
 75  *
 76  * This is useful because {@link FixedGuardNode FixedGuardNodes} will be lowered to {@link GuardNode
 77  * GuardNodes} which can later be optimized more aggressively than control-flow constructs.
 78  *
 79  * This is currently only done for branches that start from a {@link IfNode}. If it encounters a
 80  * branch starting at an other kind of {@link ControlSplitNode}, it will only bring the
 81  * {@link DeoptimizeNode} as close to the {@link ControlSplitNode} as possible.
 82  *
 83  */
<span class="line-modified"> 84 public class ConvertDeoptimizeToGuardPhase extends BasePhase&lt;CoreProviders&gt; {</span>
 85     @Override
 86     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 87     protected void run(final StructuredGraph graph, CoreProviders context) {</span>
 88         assert graph.hasValueProxies() : &quot;ConvertDeoptimizeToGuardPhase always creates proxies&quot;;
 89         assert !graph.getGuardsStage().areFrameStatesAtDeopts() : graph.getGuardsStage();
 90         LazyValue&lt;LoopsData&gt; lazyLoops = new LazyValue&lt;&gt;(() -&gt; new LoopsData(graph));
 91 
 92         for (DeoptimizeNode d : graph.getNodes(DeoptimizeNode.TYPE)) {
 93             assert d.isAlive();
 94             if (d.getAction() == DeoptimizationAction.None) {
 95                 continue;
 96             }
 97             try (DebugCloseable closable = d.withNodeSourcePosition()) {
 98                 propagateFixed(d, d, context != null ? context.getLowerer() : null, lazyLoops);
 99             }
100         }
101 
102         if (context != null) {
103             for (FixedGuardNode fixedGuard : graph.getNodes(FixedGuardNode.TYPE)) {
104                 try (DebugCloseable closable = fixedGuard.withNodeSourcePosition()) {
105                     trySplitFixedGuard(fixedGuard, context, lazyLoops);
106                 }
107             }
108         }
109 
110         new DeadCodeEliminationPhase(Optional).apply(graph);
111     }
112 
<span class="line-modified">113     private static void trySplitFixedGuard(FixedGuardNode fixedGuard, CoreProviders context, LazyValue&lt;LoopsData&gt; lazyLoops) {</span>
114         LogicNode condition = fixedGuard.condition();
115         if (condition instanceof CompareNode) {
116             CompareNode compare = (CompareNode) condition;
117             ValueNode x = compare.getX();
118             ValuePhiNode xPhi = (x instanceof ValuePhiNode) ? (ValuePhiNode) x : null;
119             if (x instanceof ConstantNode || xPhi != null) {
120                 ValueNode y = compare.getY();
121                 ValuePhiNode yPhi = (y instanceof ValuePhiNode) ? (ValuePhiNode) y : null;
122                 if (y instanceof ConstantNode || yPhi != null) {
123                     processFixedGuardAndPhis(fixedGuard, context, compare, x, xPhi, y, yPhi, lazyLoops);
124                 }
125             }
126         }
127     }
128 
<span class="line-modified">129     private static void processFixedGuardAndPhis(FixedGuardNode fixedGuard, CoreProviders context, CompareNode compare, ValueNode x, ValuePhiNode xPhi, ValueNode y, ValuePhiNode yPhi,</span>
130                     LazyValue&lt;LoopsData&gt; lazyLoops) {
131         AbstractBeginNode pred = AbstractBeginNode.prevBegin(fixedGuard);
132         if (pred instanceof AbstractMergeNode) {
133             AbstractMergeNode merge = (AbstractMergeNode) pred;
134             if (xPhi != null &amp;&amp; xPhi.merge() != merge) {
135                 return;
136             }
137             if (yPhi != null &amp;&amp; yPhi.merge() != merge) {
138                 return;
139             }
140 
141             processFixedGuardAndMerge(fixedGuard, context, compare, x, xPhi, y, yPhi, merge, lazyLoops);
142         }
143     }
144 
145     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">146     private static void processFixedGuardAndMerge(FixedGuardNode fixedGuard, CoreProviders context, CompareNode compare, ValueNode x, ValuePhiNode xPhi, ValueNode y, ValuePhiNode yPhi,</span>
147                     AbstractMergeNode merge, LazyValue&lt;LoopsData&gt; lazyLoops) {
148         List&lt;EndNode&gt; mergePredecessors = merge.cfgPredecessors().snapshot();
149         for (AbstractEndNode mergePredecessor : mergePredecessors) {
150             if (!mergePredecessor.isAlive()) {
151                 break;
152             }
153             Constant xs;
154             if (xPhi == null) {
155                 xs = x.asConstant();
156             } else {
157                 xs = xPhi.valueAt(mergePredecessor).asConstant();
158             }
159             Constant ys;
160             if (yPhi == null) {
161                 ys = y.asConstant();
162             } else {
163                 ys = yPhi.valueAt(mergePredecessor).asConstant();
164             }
165             if (xs != null &amp;&amp; ys != null &amp;&amp; compare.condition().foldCondition(xs, ys, context.getConstantReflection(), compare.unorderedIsTrue()) == fixedGuard.isNegated()) {
166                 try (DebugCloseable position = fixedGuard.withNodeSourcePosition()) {
</pre>
<hr />
<pre>
200                     } else {
201                         // Prioritize the source position of the IfNode
202                         try (DebugCloseable closable = ifNode.withNodeSourcePosition()) {
203                             StructuredGraph graph = ifNode.graph();
204                             LogicNode conditionNode = ifNode.condition();
205                             boolean negateGuardCondition = current == ifNode.trueSuccessor();
206                             NodeSourcePosition survivingSuccessorPosition = negateGuardCondition ? ifNode.falseSuccessor().getNodeSourcePosition() : ifNode.trueSuccessor().getNodeSourcePosition();
207                             FixedGuardNode guard = graph.add(
208                                             new FixedGuardNode(conditionNode, deopt.getReason(), deopt.getAction(), deopt.getSpeculation(), negateGuardCondition, survivingSuccessorPosition));
209                             FixedWithNextNode pred = (FixedWithNextNode) ifNode.predecessor();
210                             AbstractBeginNode survivingSuccessor;
211                             if (negateGuardCondition) {
212                                 survivingSuccessor = ifNode.falseSuccessor();
213                             } else {
214                                 survivingSuccessor = ifNode.trueSuccessor();
215                             }
216                             graph.removeSplitPropagate(ifNode, survivingSuccessor);
217 
218                             Node newGuard = guard;
219                             if (survivingSuccessor instanceof LoopExitNode) {
<span class="line-modified">220                                 newGuard = ProxyNode.forGuard(guard, (LoopExitNode) survivingSuccessor);</span>
221                             }
222                             survivingSuccessor.replaceAtUsages(InputType.Guard, newGuard);
223 
224                             graph.getDebug().log(&quot;Converting deopt on %-5s branch of %s to guard for remaining branch %s.&quot;, negateGuardCondition, ifNode, survivingSuccessor);
225                             FixedNode next = pred.next();
226                             pred.setNext(guard);
227                             guard.setNext(next);
228                             SimplifierTool simplifierTool = GraphUtil.getDefaultSimplifier(null, null, null, false, graph.getAssumptions(), graph.getOptions(), loweringProvider);
229                             survivingSuccessor.simplify(simplifierTool);
230                         }
231                     }
232                     return;
233                 } else if (current.predecessor() == null || current.predecessor() instanceof ControlSplitNode) {
234                     assert current.predecessor() != null || (current instanceof StartNode &amp;&amp; current == ((AbstractBeginNode) current).graph().start());
235                     moveAsDeoptAfter((AbstractBeginNode) current, deopt);
236                     return;
237                 }
238             }
239             current = current.predecessor();
240         }
</pre>
</td>
</tr>
</table>
<center><a href="ContextlessLoopPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFullUnrollPhase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
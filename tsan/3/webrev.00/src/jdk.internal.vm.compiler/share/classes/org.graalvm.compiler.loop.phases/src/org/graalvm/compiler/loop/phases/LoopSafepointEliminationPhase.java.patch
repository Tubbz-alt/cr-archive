diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop.phases/src/org/graalvm/compiler/loop/phases/LoopSafepointEliminationPhase.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop.phases/src/org/graalvm/compiler/loop/phases/LoopSafepointEliminationPhase.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop.phases/src/org/graalvm/compiler/loop/phases/LoopSafepointEliminationPhase.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop.phases/src/org/graalvm/compiler/loop/phases/LoopSafepointEliminationPhase.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -38,22 +38,28 @@
 public class LoopSafepointEliminationPhase extends BasePhase<MidTierContext> {
 
     @Override
     protected void run(StructuredGraph graph, MidTierContext context) {
         LoopsData loops = new LoopsData(graph);
-        if (context.getOptimisticOptimizations().useLoopLimitChecks(graph.getOptions()) && graph.getGuardsStage().allowsFloatingGuards()) {
-            loops.detectedCountedLoops();
-            for (LoopEx loop : loops.countedLoops()) {
-                if (loop.loop().getChildren().isEmpty() && loop.counted().getStamp().getBits() <= 32) {
-                    boolean hasSafepoint = false;
-                    for (LoopEndNode loopEnd : loop.loopBegin().loopEnds()) {
-                        hasSafepoint |= loopEnd.canSafepoint();
-                    }
-                    if (hasSafepoint) {
-                        loop.counted().createOverFlowGuard();
-                        loop.loopBegin().disableSafepoint();
+        loops.detectedCountedLoops();
+        for (LoopEx loop : loops.countedLoops()) {
+            if (loop.loop().getChildren().isEmpty() && loop.counted().getStamp().getBits() <= 32) {
+                boolean hasSafepoint = false;
+                for (LoopEndNode loopEnd : loop.loopBegin().loopEnds()) {
+                    hasSafepoint |= loopEnd.canSafepoint();
+                }
+                if (hasSafepoint) {
+                    if (!loop.counted().counterNeverOverflows()) {
+                        // Counter can overflow, need to create a guard.
+                        if (context.getOptimisticOptimizations().useLoopLimitChecks(graph.getOptions()) && graph.getGuardsStage().allowsFloatingGuards()) {
+                            loop.counted().createOverFlowGuard();
+                        } else {
+                            // Cannot disable this safepoint, because the loop could overflow.
+                            continue;
+                        }
                     }
+                    loop.loopBegin().disableSafepoint();
                 }
             }
         }
         for (LoopEx loop : loops.loops()) {
             for (LoopEndNode loopEnd : loop.loopBegin().loopEnds()) {

diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayCompareToOp.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayCompareToOp.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayCompareToOp.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayCompareToOp.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -153,11 +153,11 @@
         AMD64Address.Scale scale = null;
         AMD64Address.Scale scale1 = null;
         AMD64Address.Scale scale2 = null;
 
         // if (ae != StrIntrinsicNode::LL) {
-        if (kind1 == JavaKind.Byte && kind2 == JavaKind.Byte) {
+        if (!(kind1 == JavaKind.Byte && kind2 == JavaKind.Byte)) {
             stride2x2 = 0x20;
         }
 
         // if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
         if (kind1 != kind2) {
@@ -529,11 +529,11 @@
 
             masm.kmovq(cnt1, k7);
             masm.notq(cnt1);
             masm.bsfq(cnt2, cnt1);
             // if (ae != StrIntrinsicNode::LL) {
-            if (kind1 != JavaKind.Byte && kind2 != JavaKind.Byte) {
+            if (!(kind1 == JavaKind.Byte && kind2 == JavaKind.Byte)) {
                 // Divide diff by 2 to get number of chars
                 masm.sarl(cnt2, 1);
             }
             masm.addq(result, cnt2);
             // if (ae == StrIntrinsicNode::LL) {
@@ -577,6 +577,11 @@
         } else {
             masm.movzbl(elem1, new AMD64Address(str1, index, scale1, 0));
             masm.movzwl(elem2, new AMD64Address(str2, index, scale2, 0));
         }
     }
+
+    @Override
+    public boolean needsClearUpperVectorRegisters() {
+        return true;
+    }
 }

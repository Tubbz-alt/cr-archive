<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Move.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64MathTanOp.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64RestoreRegistersOp.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Move.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,11 ***</span>
  
      @Opcode(&quot;MOVE&quot;)
      public static final class MoveToRegOp extends AbstractMoveOp {
          public static final LIRInstructionClass&lt;MoveToRegOp&gt; TYPE = LIRInstructionClass.create(MoveToRegOp.class);
  
<span class="line-modified">!         @Def({REG, HINT}) protected AllocatableValue result;</span>
          @Use({REG, STACK}) protected AllocatableValue input;
  
          public MoveToRegOp(AMD64Kind moveKind, AllocatableValue result, AllocatableValue input) {
              super(TYPE, moveKind);
              this.result = result;
<span class="line-new-header">--- 94,11 ---</span>
  
      @Opcode(&quot;MOVE&quot;)
      public static final class MoveToRegOp extends AbstractMoveOp {
          public static final LIRInstructionClass&lt;MoveToRegOp&gt; TYPE = LIRInstructionClass.create(MoveToRegOp.class);
  
<span class="line-modified">!         @Def({REG, STACK, HINT}) protected AllocatableValue result;</span>
          @Use({REG, STACK}) protected AllocatableValue input;
  
          public MoveToRegOp(AMD64Kind moveKind, AllocatableValue result, AllocatableValue input) {
              super(TYPE, moveKind);
              this.result = result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 154,11 ***</span>
          }
  
          @Override
          public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
              if (isRegister(result)) {
<span class="line-modified">!                 const2reg(crb, masm, asRegister(result), input);</span>
              } else {
                  assert isStackSlot(result);
                  const2stack(crb, masm, result, input);
              }
          }
<span class="line-new-header">--- 154,11 ---</span>
          }
  
          @Override
          public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
              if (isRegister(result)) {
<span class="line-modified">!                 const2reg(crb, masm, asRegister(result), input, (AMD64Kind) result.getPlatformKind());</span>
              } else {
                  assert isStackSlot(result);
                  const2stack(crb, masm, result, input);
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 555,11 ***</span>
              } else {
                  throw GraalError.shouldNotReachHere();
              }
          } else if (isJavaConstant(input)) {
              if (isRegister(result)) {
<span class="line-modified">!                 const2reg(crb, masm, asRegister(result), asJavaConstant(input));</span>
              } else if (isStackSlot(result)) {
                  const2stack(crb, masm, result, asJavaConstant(input));
              } else {
                  throw GraalError.shouldNotReachHere();
              }
<span class="line-new-header">--- 555,11 ---</span>
              } else {
                  throw GraalError.shouldNotReachHere();
              }
          } else if (isJavaConstant(input)) {
              if (isRegister(result)) {
<span class="line-modified">!                 const2reg(crb, masm, asRegister(result), asJavaConstant(input), moveKind);</span>
              } else if (isStackSlot(result)) {
                  const2stack(crb, masm, result, asJavaConstant(input));
              } else {
                  throw GraalError.shouldNotReachHere();
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 643,11 ***</span>
              default:
                  throw GraalError.shouldNotReachHere();
          }
      }
  
<span class="line-modified">!     public static void const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input) {</span>
          /*
           * Note: we use the kind of the input operand (and not the kind of the result operand)
           * because they don&#39;t match in all cases. For example, an object constant can be loaded to a
           * long register when unsafe casts occurred (e.g., for a write barrier where arithmetic
           * operations are then performed on the pointer).
<span class="line-new-header">--- 643,11 ---</span>
              default:
                  throw GraalError.shouldNotReachHere();
          }
      }
  
<span class="line-modified">!     public static void const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind) {</span>
          /*
           * Note: we use the kind of the input operand (and not the kind of the result operand)
           * because they don&#39;t match in all cases. For example, an object constant can be loaded to a
           * long register when unsafe casts occurred (e.g., for a write barrier where arithmetic
           * operations are then performed on the pointer).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 689,24 ***</span>
                  } else {
                      masm.movdbl(result, (AMD64Address) crb.asDoubleConstRef(input));
                  }
                  break;
              case Object:
                  // Do not optimize with an XOR as this instruction may be between
                  // a CMP and a Jcc in which case the XOR will modify the condition
                  // flags and interfere with the Jcc.
                  if (input.isNull()) {
<span class="line-modified">!                     if (crb.mustReplaceWithNullRegister(input)) {</span>
<span class="line-modified">!                         masm.movq(result, crb.nullRegister);</span>
                      } else {
                          masm.movslq(result, 0);
                      }
<span class="line-removed">-                 } else if (crb.target.inlineObjects) {</span>
<span class="line-removed">-                     crb.recordInlineDataInCode(input);</span>
<span class="line-removed">-                     masm.movq(result, 0xDEADDEADDEADDEADL, true);</span>
                  } else {
<span class="line-modified">!                     masm.movq(result, (AMD64Address) crb.recordDataReferenceInCode(input, 0));</span>
                  }
                  break;
              default:
                  throw GraalError.shouldNotReachHere();
          }
<span class="line-new-header">--- 689,38 ---</span>
                  } else {
                      masm.movdbl(result, (AMD64Address) crb.asDoubleConstRef(input));
                  }
                  break;
              case Object:
<span class="line-added">+                 assert moveKind != null : &quot;a nun-null moveKind is required for loading an object constant&quot;;</span>
                  // Do not optimize with an XOR as this instruction may be between
                  // a CMP and a Jcc in which case the XOR will modify the condition
                  // flags and interfere with the Jcc.
                  if (input.isNull()) {
<span class="line-modified">!                     if (moveKind == AMD64Kind.QWORD &amp;&amp; crb.mustReplaceWithUncompressedNullRegister(input)) {</span>
<span class="line-modified">!                         masm.movq(result, crb.uncompressedNullRegister);</span>
                      } else {
<span class="line-added">+                         // Upper bits will be zeroed so this also works for narrow oops</span>
                          masm.movslq(result, 0);
                      }
                  } else {
<span class="line-modified">!                     if (crb.target.inlineObjects) {</span>
<span class="line-added">+                         crb.recordInlineDataInCode(input);</span>
<span class="line-added">+                         if (moveKind == AMD64Kind.DWORD) {</span>
<span class="line-added">+                             // Support for narrow oops</span>
<span class="line-added">+                             masm.movl(result, 0xDEADDEAD, true);</span>
<span class="line-added">+                         } else {</span>
<span class="line-added">+                             masm.movq(result, 0xDEADDEADDEADDEADL, true);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         if (moveKind == AMD64Kind.DWORD) {</span>
<span class="line-added">+                             // Support for narrow oops</span>
<span class="line-added">+                             masm.movl(result, (AMD64Address) crb.recordDataReferenceInCode(input, 0));</span>
<span class="line-added">+                         } else {</span>
<span class="line-added">+                             masm.movq(result, (AMD64Address) crb.recordDataReferenceInCode(input, 0));</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
                  }
                  break;
              default:
                  throw GraalError.shouldNotReachHere();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 750,17 ***</span>
              case Double:
                  imm = doubleToRawLongBits(input.asDouble());
                  break;
              case Object:
                  if (input.isNull()) {
<span class="line-modified">!                     if (crb.mustReplaceWithNullRegister(input)) {</span>
<span class="line-modified">!                         masm.movq(dest, crb.nullRegister);</span>
                          return;
                      }
                      imm = 0;
                  } else {
<span class="line-modified">!                     throw GraalError.shouldNotReachHere(&quot;Non-null object constants must be in register&quot;);</span>
                  }
                  break;
              default:
                  throw GraalError.shouldNotReachHere();
          }
<span class="line-new-header">--- 764,17 ---</span>
              case Double:
                  imm = doubleToRawLongBits(input.asDouble());
                  break;
              case Object:
                  if (input.isNull()) {
<span class="line-modified">!                     if (crb.mustReplaceWithUncompressedNullRegister(input)) {</span>
<span class="line-modified">!                         masm.movq(dest, crb.uncompressedNullRegister);</span>
                          return;
                      }
                      imm = 0;
                  } else {
<span class="line-modified">!                     throw GraalError.shouldNotReachHere(&quot;Non-null object constants must be in a register&quot;);</span>
                  }
                  break;
              default:
                  throw GraalError.shouldNotReachHere();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 939,11 ***</span>
              this.input = input;
          }
  
          @Override
          public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
<span class="line-modified">!             Register nullRegister = crb.nullRegister;</span>
              if (!nullRegister.equals(Register.None)) {
                  emitConversion(asRegister(result), asRegister(input), nullRegister, masm);
              }
          }
  
<span class="line-new-header">--- 953,11 ---</span>
              this.input = input;
          }
  
          @Override
          public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
<span class="line-modified">!             Register nullRegister = crb.uncompressedNullRegister;</span>
              if (!nullRegister.equals(Register.None)) {
                  emitConversion(asRegister(result), asRegister(input), nullRegister, masm);
              }
          }
  
</pre>
<center><a href="AMD64MathTanOp.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64RestoreRegistersOp.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ControlFlow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64Call.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64FrameMap.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ControlFlow.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
196 
197             protected SwitchClosure(Register keyRegister, CompilationResultBuilder crb, AMD64MacroAssembler masm) {
198                 super(crb, masm, keyTargets, defaultTarget);
199                 this.keyRegister = keyRegister;
200                 this.crb = crb;
201                 this.masm = masm;
202             }
203 
204             protected void emitComparison(Constant c) {
205                 JavaConstant jc = (JavaConstant) c;
206                 switch (jc.getJavaKind()) {
207                     case Int:
208                         long lc = jc.asLong();
209                         assert NumUtil.isInt(lc);
210                         masm.cmpl(keyRegister, (int) lc);
211                         break;
212                     case Long:
213                         masm.cmpq(keyRegister, (AMD64Address) crb.asLongConstRef(jc));
214                         break;
215                     case Object:
<span class="line-modified">216                         AMD64Move.const2reg(crb, masm, asRegister(scratch), jc);</span>
217                         masm.cmpptr(keyRegister, asRegister(scratch));
218                         break;
219                     default:
220                         throw new GraalError(&quot;switch only supported for int, long and object&quot;);
221                 }
222             }
223 
224             @Override
225             protected void conditionalJump(int index, Condition condition, Label target) {
226                 emitComparison(keyConstants[index]);
227                 masm.jcc(intCond(condition), target);
228             }
229         }
230     }
231 
232     public static final class TableSwitchOp extends AMD64BlockEndOp {
233         public static final LIRInstructionClass&lt;TableSwitchOp&gt; TYPE = LIRInstructionClass.create(TableSwitchOp.class);
234         private final int lowKey;
235         private final LabelRef defaultTarget;
236         private final LabelRef[] targets;
</pre>
<hr />
<pre>
282             masm.addq(scratchReg, idxScratchReg);
283             masm.jmp(scratchReg);
284 
285             // Inserting padding so that jump table address is 4-byte aligned
286             masm.align(4);
287 
288             // Patch LEA instruction above now that we know the position of the jump table
289             // this is ugly but there is no better way to do this given the assembler API
290             final int jumpTablePos = masm.position();
291             final int leaDisplacementPosition = afterLea - 4;
292             masm.emitInt(jumpTablePos - afterLea, leaDisplacementPosition);
293 
294             // Emit jump table entries
295             for (LabelRef target : targets) {
296                 Label label = target.label();
297                 int offsetToJumpTableBase = masm.position() - jumpTablePos;
298                 if (label.isBound()) {
299                     int imm32 = label.position() - jumpTablePos;
300                     masm.emitInt(imm32);
301                 } else {
<span class="line-modified">302                     label.addPatchAt(masm.position());</span>
303 
304                     masm.emitByte(0); // pseudo-opcode for jump table entry
305                     masm.emitShort(offsetToJumpTableBase);
306                     masm.emitByte(0); // padding to make jump table entry 4 bytes wide
307                 }
308             }
309 
310             JumpTable jt = new JumpTable(jumpTablePos, lowKey, highKey, 4);
311             crb.compilationResult.addAnnotation(jt);
312         }
313     }
314 
315     public static final class HashTableSwitchOp extends AMD64BlockEndOp {
316         public static final LIRInstructionClass&lt;HashTableSwitchOp&gt; TYPE = LIRInstructionClass.create(HashTableSwitchOp.class);
317         private final JavaConstant[] keys;
318         private final LabelRef defaultTarget;
319         private final LabelRef[] targets;
320         @Alive protected Value value;
321         @Alive protected Value hash;
322         @Temp({REG}) protected Value entryScratch;
</pre>
<hr />
<pre>
376 
377             // Patch LEA instruction above now that we know the position of the jump table
378             // this is ugly but there is no better way to do this given the assembler API
379             final int jumpTablePos = masm.position();
380             final int leaDisplacementPosition = afterLea - 4;
381             masm.emitInt(jumpTablePos - afterLea, leaDisplacementPosition);
382 
383             // Emit jump table entries
384             for (int i = 0; i &lt; targets.length; i++) {
385 
386                 Label label = targets[i].label();
387 
388                 if (defaultTarget != null) {
389                     masm.emitInt(keys[i].asInt());
390                 }
391                 if (label.isBound()) {
392                     int imm32 = label.position() - jumpTablePos;
393                     masm.emitInt(imm32);
394                 } else {
395                     int offsetToJumpTableBase = masm.position() - jumpTablePos;
<span class="line-modified">396                     label.addPatchAt(masm.position());</span>
397                     masm.emitByte(0); // pseudo-opcode for jump table entry
398                     masm.emitShort(offsetToJumpTableBase);
399                     masm.emitByte(0); // padding to make jump table entry 4 bytes wide
400                 }
401             }
402 
403             JumpTable jt = new JumpTable(jumpTablePos, keys[0].asInt(), keys[keys.length - 1].asInt(), 4);
404             crb.compilationResult.addAnnotation(jt);
405         }
406     }
407 
408     @Opcode(&quot;SETcc&quot;)
409     public static final class CondSetOp extends AMD64LIRInstruction {
410         public static final LIRInstructionClass&lt;CondSetOp&gt; TYPE = LIRInstructionClass.create(CondSetOp.class);
411         @Def({REG, HINT}) protected Value result;
412         private final ConditionFlag condition;
413 
414         public CondSetOp(Variable result, Condition condition) {
415             super(TYPE);
416             this.result = result;
</pre>
</td>
<td>
<hr />
<pre>
196 
197             protected SwitchClosure(Register keyRegister, CompilationResultBuilder crb, AMD64MacroAssembler masm) {
198                 super(crb, masm, keyTargets, defaultTarget);
199                 this.keyRegister = keyRegister;
200                 this.crb = crb;
201                 this.masm = masm;
202             }
203 
204             protected void emitComparison(Constant c) {
205                 JavaConstant jc = (JavaConstant) c;
206                 switch (jc.getJavaKind()) {
207                     case Int:
208                         long lc = jc.asLong();
209                         assert NumUtil.isInt(lc);
210                         masm.cmpl(keyRegister, (int) lc);
211                         break;
212                     case Long:
213                         masm.cmpq(keyRegister, (AMD64Address) crb.asLongConstRef(jc));
214                         break;
215                     case Object:
<span class="line-modified">216                         AMD64Move.const2reg(crb, masm, asRegister(scratch), jc, AMD64Kind.QWORD);</span>
217                         masm.cmpptr(keyRegister, asRegister(scratch));
218                         break;
219                     default:
220                         throw new GraalError(&quot;switch only supported for int, long and object&quot;);
221                 }
222             }
223 
224             @Override
225             protected void conditionalJump(int index, Condition condition, Label target) {
226                 emitComparison(keyConstants[index]);
227                 masm.jcc(intCond(condition), target);
228             }
229         }
230     }
231 
232     public static final class TableSwitchOp extends AMD64BlockEndOp {
233         public static final LIRInstructionClass&lt;TableSwitchOp&gt; TYPE = LIRInstructionClass.create(TableSwitchOp.class);
234         private final int lowKey;
235         private final LabelRef defaultTarget;
236         private final LabelRef[] targets;
</pre>
<hr />
<pre>
282             masm.addq(scratchReg, idxScratchReg);
283             masm.jmp(scratchReg);
284 
285             // Inserting padding so that jump table address is 4-byte aligned
286             masm.align(4);
287 
288             // Patch LEA instruction above now that we know the position of the jump table
289             // this is ugly but there is no better way to do this given the assembler API
290             final int jumpTablePos = masm.position();
291             final int leaDisplacementPosition = afterLea - 4;
292             masm.emitInt(jumpTablePos - afterLea, leaDisplacementPosition);
293 
294             // Emit jump table entries
295             for (LabelRef target : targets) {
296                 Label label = target.label();
297                 int offsetToJumpTableBase = masm.position() - jumpTablePos;
298                 if (label.isBound()) {
299                     int imm32 = label.position() - jumpTablePos;
300                     masm.emitInt(imm32);
301                 } else {
<span class="line-modified">302                     label.addPatchAt(masm.position(), masm);</span>
303 
304                     masm.emitByte(0); // pseudo-opcode for jump table entry
305                     masm.emitShort(offsetToJumpTableBase);
306                     masm.emitByte(0); // padding to make jump table entry 4 bytes wide
307                 }
308             }
309 
310             JumpTable jt = new JumpTable(jumpTablePos, lowKey, highKey, 4);
311             crb.compilationResult.addAnnotation(jt);
312         }
313     }
314 
315     public static final class HashTableSwitchOp extends AMD64BlockEndOp {
316         public static final LIRInstructionClass&lt;HashTableSwitchOp&gt; TYPE = LIRInstructionClass.create(HashTableSwitchOp.class);
317         private final JavaConstant[] keys;
318         private final LabelRef defaultTarget;
319         private final LabelRef[] targets;
320         @Alive protected Value value;
321         @Alive protected Value hash;
322         @Temp({REG}) protected Value entryScratch;
</pre>
<hr />
<pre>
376 
377             // Patch LEA instruction above now that we know the position of the jump table
378             // this is ugly but there is no better way to do this given the assembler API
379             final int jumpTablePos = masm.position();
380             final int leaDisplacementPosition = afterLea - 4;
381             masm.emitInt(jumpTablePos - afterLea, leaDisplacementPosition);
382 
383             // Emit jump table entries
384             for (int i = 0; i &lt; targets.length; i++) {
385 
386                 Label label = targets[i].label();
387 
388                 if (defaultTarget != null) {
389                     masm.emitInt(keys[i].asInt());
390                 }
391                 if (label.isBound()) {
392                     int imm32 = label.position() - jumpTablePos;
393                     masm.emitInt(imm32);
394                 } else {
395                     int offsetToJumpTableBase = masm.position() - jumpTablePos;
<span class="line-modified">396                     label.addPatchAt(masm.position(), masm);</span>
397                     masm.emitByte(0); // pseudo-opcode for jump table entry
398                     masm.emitShort(offsetToJumpTableBase);
399                     masm.emitByte(0); // padding to make jump table entry 4 bytes wide
400                 }
401             }
402 
403             JumpTable jt = new JumpTable(jumpTablePos, keys[0].asInt(), keys[keys.length - 1].asInt(), 4);
404             crb.compilationResult.addAnnotation(jt);
405         }
406     }
407 
408     @Opcode(&quot;SETcc&quot;)
409     public static final class CondSetOp extends AMD64LIRInstruction {
410         public static final LIRInstructionClass&lt;CondSetOp&gt; TYPE = LIRInstructionClass.create(CondSetOp.class);
411         @Def({REG, HINT}) protected Value result;
412         private final ConditionFlag condition;
413 
414         public CondSetOp(Variable result, Condition condition) {
415             super(TYPE);
416             this.result = result;
</pre>
</td>
</tr>
</table>
<center><a href="AMD64Call.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64FrameMap.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayIndexOfOp.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64ArrayEqualsOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64Binary.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayIndexOfOp.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019 Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.amd64;
 26 
<span class="line-modified"> 27 import jdk.vm.ci.amd64.AMD64;</span>
<span class="line-modified"> 28 import jdk.vm.ci.amd64.AMD64.CPUFeature;</span>
<span class="line-modified"> 29 import jdk.vm.ci.amd64.AMD64Kind;</span>
<span class="line-modified"> 30 import jdk.vm.ci.code.Register;</span>
<span class="line-modified"> 31 import jdk.vm.ci.meta.JavaKind;</span>
<span class="line-modified"> 32 import jdk.vm.ci.meta.Value;</span>




 33 import org.graalvm.compiler.asm.Label;
 34 import org.graalvm.compiler.asm.amd64.AMD64Address;

 35 import org.graalvm.compiler.asm.amd64.AMD64Assembler;

 36 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMoveOp;
 37 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMIOp;
 38 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMOp;
 39 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp;

 40 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 41 import org.graalvm.compiler.asm.amd64.AVXKind;
 42 import org.graalvm.compiler.core.common.LIRKind;


 43 import org.graalvm.compiler.lir.LIRInstructionClass;
 44 import org.graalvm.compiler.lir.Opcode;
 45 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 46 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 47 
<span class="line-modified"> 48 import static jdk.vm.ci.code.ValueUtil.asRegister;</span>
<span class="line-modified"> 49 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
<span class="line-modified"> 50 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;</span>




 51 
 52 /**
 53  */
 54 @Opcode(&quot;AMD64_ARRAY_INDEX_OF&quot;)
 55 public final class AMD64ArrayIndexOfOp extends AMD64LIRInstruction {
 56     public static final LIRInstructionClass&lt;AMD64ArrayIndexOfOp&gt; TYPE = LIRInstructionClass.create(AMD64ArrayIndexOfOp.class);
 57 
<span class="line-modified"> 58     private final JavaKind kind;</span>
<span class="line-removed"> 59     private final int vmPageSize;</span>
 60     private final int nValues;
 61     private final boolean findTwoConsecutive;
 62     private final AMD64Kind vectorKind;


 63 
 64     @Def({REG}) protected Value resultValue;
 65     @Alive({REG}) protected Value arrayPtrValue;
<span class="line-modified"> 66     @Use({REG}) protected Value arrayLengthValue;</span>
<span class="line-modified"> 67     @Alive({REG}) protected Value searchValue1;</span>
<span class="line-modified"> 68     @Alive({REG, ILLEGAL}) protected Value searchValue2;</span>
<span class="line-modified"> 69     @Alive({REG, ILLEGAL}) protected Value searchValue3;</span>
<span class="line-modified"> 70     @Alive({REG, ILLEGAL}) protected Value searchValue4;</span>
<span class="line-modified"> 71     @Temp({REG}) protected Value arraySlotsRemaining;</span>
 72     @Temp({REG}) protected Value comparisonResult1;
<span class="line-modified"> 73     @Temp({REG}) protected Value comparisonResult2;</span>
<span class="line-removed"> 74     @Temp({REG}) protected Value comparisonResult3;</span>
<span class="line-removed"> 75     @Temp({REG}) protected Value comparisonResult4;</span>
 76     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal1;
 77     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal2;
 78     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal3;
 79     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal4;
 80     @Temp({REG, ILLEGAL}) protected Value vectorArray1;
 81     @Temp({REG, ILLEGAL}) protected Value vectorArray2;
 82     @Temp({REG, ILLEGAL}) protected Value vectorArray3;
 83     @Temp({REG, ILLEGAL}) protected Value vectorArray4;
 84 
<span class="line-modified"> 85     public AMD64ArrayIndexOfOp(JavaKind kind, boolean findTwoConsecutive, int vmPageSize, int maxVectorSize, LIRGeneratorTool tool, Value result, Value arrayPtr, Value arrayLength,</span>
<span class="line-modified"> 86                     Value... searchValues) {</span>
 87         super(TYPE);
<span class="line-modified"> 88         this.kind = kind;</span>


 89         this.findTwoConsecutive = findTwoConsecutive;
<span class="line-removed"> 90         this.vmPageSize = vmPageSize;</span>
 91         assert 0 &lt; searchValues.length &amp;&amp; searchValues.length &lt;= 4;
<span class="line-modified"> 92         assert byteMode(kind) || charMode(kind);</span>
 93         assert supports(tool, CPUFeature.SSE2) || supports(tool, CPUFeature.AVX) || supportsAVX2(tool);
 94         nValues = searchValues.length;
 95         assert !findTwoConsecutive || nValues == 1;
 96         resultValue = result;
 97         arrayPtrValue = arrayPtr;
 98         arrayLengthValue = arrayLength;

 99         searchValue1 = searchValues[0];
100         searchValue2 = nValues &gt; 1 ? searchValues[1] : Value.ILLEGAL;
101         searchValue3 = nValues &gt; 2 ? searchValues[2] : Value.ILLEGAL;
102         searchValue4 = nValues &gt; 3 ? searchValues[3] : Value.ILLEGAL;
<span class="line-modified">103         arraySlotsRemaining = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-modified">104         comparisonResult1 = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-modified">105         comparisonResult2 = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-modified">106         comparisonResult3 = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-removed">107         comparisonResult4 = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-removed">108         vectorKind = supportsAVX2(tool) &amp;&amp; (maxVectorSize &lt; 0 || maxVectorSize &gt;= 32) ? byteMode(kind) ? AMD64Kind.V256_BYTE : AMD64Kind.V256_WORD</span>
<span class="line-removed">109                         : byteMode(kind) ? AMD64Kind.V128_BYTE : AMD64Kind.V128_WORD;</span>
110         vectorCompareVal1 = tool.newVariable(LIRKind.value(vectorKind));
111         vectorCompareVal2 = nValues &gt; 1 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
112         vectorCompareVal3 = nValues &gt; 2 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
113         vectorCompareVal4 = nValues &gt; 3 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
114         vectorArray1 = tool.newVariable(LIRKind.value(vectorKind));
115         vectorArray2 = tool.newVariable(LIRKind.value(vectorKind));
116         vectorArray3 = tool.newVariable(LIRKind.value(vectorKind));
117         vectorArray4 = tool.newVariable(LIRKind.value(vectorKind));
118     }
119 
120     private static boolean byteMode(JavaKind kind) {
121         return kind == JavaKind.Byte;
122     }
123 
124     private static boolean charMode(JavaKind kind) {
125         return kind == JavaKind.Char;
126     }
127 
128     private JavaKind getComparisonKind() {
<span class="line-modified">129         return findTwoConsecutive ? (byteMode(kind) ? JavaKind.Char : JavaKind.Int) : kind;</span>
130     }
131 
132     private AVXKind.AVXSize getVectorSize() {
133         return AVXKind.getDataSize(vectorKind);
134     }
135 
136     @Override
137     public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler asm) {

138         Register arrayPtr = asRegister(arrayPtrValue);
139         Register arrayLength = asRegister(arrayLengthValue);
<span class="line-modified">140         Register result = asRegister(resultValue);</span>
<span class="line-modified">141         Register slotsRemaining = asRegister(arraySlotsRemaining);</span>
<span class="line-modified">142         Register[] searchValue = {</span>
<span class="line-modified">143                         nValues &gt; 0 ? asRegister(searchValue1) : null,</span>
<span class="line-modified">144                         nValues &gt; 1 ? asRegister(searchValue2) : null,</span>
<span class="line-modified">145                         nValues &gt; 2 ? asRegister(searchValue3) : null,</span>
<span class="line-modified">146                         nValues &gt; 3 ? asRegister(searchValue4) : null,</span>
147         };
148         Register[] vecCmp = {
149                         nValues &gt; 0 ? asRegister(vectorCompareVal1) : null,
150                         nValues &gt; 1 ? asRegister(vectorCompareVal2) : null,
151                         nValues &gt; 2 ? asRegister(vectorCompareVal3) : null,
152                         nValues &gt; 3 ? asRegister(vectorCompareVal4) : null,
153         };
154         Register[] vecArray = {
155                         asRegister(vectorArray1),
156                         asRegister(vectorArray2),
157                         asRegister(vectorArray3),
158                         asRegister(vectorArray4),
159         };
160         Register[] cmpResult = {
161                         asRegister(comparisonResult1),
<span class="line-modified">162                         asRegister(comparisonResult2),</span>
<span class="line-removed">163                         asRegister(comparisonResult3),</span>
<span class="line-removed">164                         asRegister(comparisonResult4),</span>
165         };
<span class="line-modified">166         Label retFound = new Label();</span>
<span class="line-removed">167         Label retNotFound = new Label();</span>
<span class="line-removed">168         Label end = new Label();</span>
<span class="line-removed">169 </span>
<span class="line-removed">170         // load array length</span>
<span class="line-removed">171         // important: this must be the first register manipulation, since arrayLengthValue is</span>
<span class="line-removed">172         // annotated with @Use</span>
<span class="line-removed">173         asm.movl(slotsRemaining, arrayLength);</span>
<span class="line-removed">174         // load array pointer</span>
<span class="line-removed">175         asm.movq(result, arrayPtr);</span>
<span class="line-removed">176         // move search values to vectors</span>
<span class="line-removed">177         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-removed">178             if (asm.supports(CPUFeature.AVX)) {</span>
<span class="line-removed">179                 VexMoveOp.VMOVD.emit(asm, AVXKind.AVXSize.DWORD, vecCmp[i], searchValue[i]);</span>
<span class="line-removed">180             } else {</span>
<span class="line-removed">181                 asm.movdl(vecCmp[i], searchValue[i]);</span>
<span class="line-removed">182             }</span>
<span class="line-removed">183         }</span>
<span class="line-removed">184         // fill comparison vector with copies of the search value</span>
<span class="line-removed">185         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-removed">186             emitBroadcast(asm, getComparisonKind(), vecCmp[i], vecArray[0], getVectorSize());</span>
<span class="line-removed">187         }</span>
<span class="line-removed">188 </span>
<span class="line-removed">189         emitArrayIndexOfChars(crb, asm, result, slotsRemaining, searchValue, vecCmp, vecArray, cmpResult, retFound, retNotFound);</span>
<span class="line-removed">190 </span>
<span class="line-removed">191         // return -1 (no match)</span>
<span class="line-removed">192         asm.bind(retNotFound);</span>
<span class="line-removed">193         asm.movq(result, -1);</span>
<span class="line-removed">194         asm.jmpb(end);</span>
<span class="line-removed">195 </span>
<span class="line-removed">196         asm.bind(retFound);</span>
<span class="line-removed">197         // convert array pointer to offset</span>
<span class="line-removed">198         asm.subq(result, arrayPtr);</span>
<span class="line-removed">199         if (charMode(kind)) {</span>
<span class="line-removed">200             asm.shrq(result, 1);</span>
<span class="line-removed">201         }</span>
<span class="line-removed">202         asm.bind(end);</span>
<span class="line-removed">203     }</span>
<span class="line-removed">204 </span>
<span class="line-removed">205     private void emitArrayIndexOfChars(CompilationResultBuilder crb, AMD64MacroAssembler asm,</span>
<span class="line-removed">206                     Register arrayPtr,</span>
<span class="line-removed">207                     Register slotsRemaining,</span>
<span class="line-removed">208                     Register[] searchValue,</span>
<span class="line-removed">209                     Register[] vecCmp,</span>
<span class="line-removed">210                     Register[] vecArray,</span>
<span class="line-removed">211                     Register[] cmpResult,</span>
<span class="line-removed">212                     Label retFound,</span>
<span class="line-removed">213                     Label retNotFound) {</span>
<span class="line-removed">214         int nVectors = nValues == 1 ? 4 : nValues == 2 ? 2 : 1;</span>
<span class="line-removed">215         AVXKind.AVXSize vectorSize = getVectorSize();</span>
216 
217         Label bulkVectorLoop = new Label();
218         Label singleVectorLoop = new Label();
219         Label[] vectorFound = {
220                         new Label(),
221                         new Label(),
222                         new Label(),
223                         new Label(),
224         };
<span class="line-modified">225         Label lessThanVectorSizeRemaining = new Label();</span>
<span class="line-modified">226         Label lessThanVectorSizeRemainingLoop = new Label();</span>
<span class="line-modified">227         Label bulkVectorLoopExit = nVectors == 1 ? lessThanVectorSizeRemaining : singleVectorLoop;</span>
<span class="line-modified">228         int bytesPerVector = vectorSize.getBytes();</span>
<span class="line-modified">229         int arraySlotsPerVector = vectorSize.getBytes() / kind.getByteCount();</span>
<span class="line-modified">230         int singleVectorLoopCondition = arraySlotsPerVector;</span>
<span class="line-modified">231         int bulkSize = arraySlotsPerVector * nVectors;</span>
<span class="line-modified">232         int bulkSizeBytes = bytesPerVector * nVectors;</span>
<span class="line-removed">233         int bulkLoopCondition = bulkSize;</span>
<span class="line-removed">234         int[] vectorOffsets;</span>
<span class="line-removed">235         JavaKind vectorCompareKind = kind;</span>
236         if (findTwoConsecutive) {
<span class="line-removed">237             singleVectorLoopCondition++;</span>
<span class="line-removed">238             bulkLoopCondition++;</span>
239             bulkSize /= 2;
<span class="line-modified">240             bulkSizeBytes /= 2;</span>
<span class="line-modified">241             vectorOffsets = new int[]{0, kind.getByteCount(), bytesPerVector, bytesPerVector + kind.getByteCount()};</span>
<span class="line-modified">242             vectorCompareKind = byteMode(kind) ? JavaKind.Char : JavaKind.Int;</span>


























































243         } else {
<span class="line-modified">244             vectorOffsets = new int[]{0, bytesPerVector, bytesPerVector * 2, bytesPerVector * 3};</span>




















245         }






246 
<span class="line-removed">247         // load copy of low part of array pointer</span>
<span class="line-removed">248         Register tmpArrayPtrLow = cmpResult[0];</span>
<span class="line-removed">249         asm.movl(tmpArrayPtrLow, arrayPtr);</span>
<span class="line-removed">250 </span>
<span class="line-removed">251         // check if bulk vector load is in bounds</span>
<span class="line-removed">252         asm.cmpl(slotsRemaining, bulkLoopCondition);</span>
<span class="line-removed">253         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);</span>
<span class="line-removed">254 </span>
<span class="line-removed">255         // check if array pointer is aligned to bulkSize</span>
<span class="line-removed">256         asm.andl(tmpArrayPtrLow, bulkSizeBytes - 1);</span>
<span class="line-removed">257         asm.jcc(AMD64Assembler.ConditionFlag.Zero, bulkVectorLoop);</span>
<span class="line-removed">258 </span>
<span class="line-removed">259         // do one unaligned bulk comparison pass and adjust alignment afterwards</span>
<span class="line-removed">260         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, nVectors, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, false);</span>
<span class="line-removed">261         // load copy of low part of array pointer</span>
<span class="line-removed">262         asm.movl(tmpArrayPtrLow, arrayPtr);</span>
<span class="line-removed">263         // adjust array pointer</span>
<span class="line-removed">264         asm.addq(arrayPtr, bulkSizeBytes);</span>
<span class="line-removed">265         // adjust number of array slots remaining</span>
<span class="line-removed">266         asm.subl(slotsRemaining, bulkSize);</span>
<span class="line-removed">267         // get offset to bulk size alignment</span>
<span class="line-removed">268         asm.andl(tmpArrayPtrLow, bulkSizeBytes - 1);</span>
<span class="line-removed">269         emitBytesToArraySlots(asm, kind, tmpArrayPtrLow);</span>
<span class="line-removed">270         // adjust array pointer to bulk size alignment</span>
<span class="line-removed">271         asm.andq(arrayPtr, ~(bulkSizeBytes - 1));</span>
<span class="line-removed">272         // adjust number of array slots remaining</span>
<span class="line-removed">273         asm.addl(slotsRemaining, tmpArrayPtrLow);</span>
274         // check if there are enough array slots remaining for the bulk loop
<span class="line-modified">275         asm.cmpl(slotsRemaining, bulkLoopCondition);</span>
<span class="line-modified">276         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);</span>
277 
278         emitAlign(crb, asm);
279         asm.bind(bulkVectorLoop);
280         // memory-aligned bulk comparison
<span class="line-modified">281         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, nVectors, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, !findTwoConsecutive);</span>
<span class="line-modified">282         // adjust number of array slots remaining</span>
<span class="line-modified">283         asm.subl(slotsRemaining, bulkSize);</span>
<span class="line-removed">284         // adjust array pointer</span>
<span class="line-removed">285         asm.addq(arrayPtr, bulkSizeBytes);</span>
286         // check if there are enough array slots remaining for the bulk loop
<span class="line-modified">287         asm.cmpl(slotsRemaining, bulkLoopCondition);</span>
<span class="line-modified">288         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);</span>
<span class="line-removed">289         // continue loop</span>
<span class="line-removed">290         asm.jmp(bulkVectorLoop);</span>
291 
<span class="line-modified">292         if (nVectors &gt; 1) {</span>








293             emitAlign(crb, asm);
294             // same loop as bulkVectorLoop, with only one vector
295             asm.bind(singleVectorLoop);
<span class="line-modified">296             // check if single vector load is in bounds</span>
<span class="line-modified">297             asm.cmpl(slotsRemaining, singleVectorLoopCondition);</span>
<span class="line-modified">298             asm.jcc(AMD64Assembler.ConditionFlag.Below, lessThanVectorSizeRemaining);</span>



299             // compare
<span class="line-modified">300             emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, findTwoConsecutive ? 2 : 1, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, false);</span>
<span class="line-modified">301             // adjust number of array slots remaining</span>
<span class="line-modified">302             asm.subl(slotsRemaining, arraySlotsPerVector);</span>
<span class="line-modified">303             // adjust array pointer</span>
<span class="line-removed">304             asm.addq(arrayPtr, bytesPerVector);</span>
<span class="line-removed">305             // continue loop</span>
<span class="line-removed">306             asm.jmpb(singleVectorLoop);</span>
307         }
308 
<span class="line-modified">309         asm.bind(lessThanVectorSizeRemaining);</span>
<span class="line-modified">310         // check if any array slots remain</span>
<span class="line-modified">311         asm.testl(slotsRemaining, slotsRemaining);</span>
<span class="line-removed">312         asm.jcc(AMD64Assembler.ConditionFlag.Zero, retNotFound);</span>
<span class="line-removed">313 </span>
<span class="line-removed">314         // a vector compare will read out of bounds of the input array.</span>
<span class="line-removed">315         // check if the out-of-bounds read would cross a memory page boundary.</span>
<span class="line-removed">316         // load copy of low part of array pointer</span>
<span class="line-removed">317         asm.movl(tmpArrayPtrLow, arrayPtr);</span>
<span class="line-removed">318         // check if pointer + vector size would cross the page boundary</span>
<span class="line-removed">319         asm.andl(tmpArrayPtrLow, (vmPageSize - 1));</span>
<span class="line-removed">320         asm.cmpl(tmpArrayPtrLow, (vmPageSize - (findTwoConsecutive ? bytesPerVector + kind.getByteCount() : bytesPerVector)));</span>
<span class="line-removed">321         // if the page boundary would be crossed, do byte/character-wise comparison instead.</span>
<span class="line-removed">322         asm.jccb(AMD64Assembler.ConditionFlag.Above, lessThanVectorSizeRemainingLoop);</span>
<span class="line-removed">323 </span>
<span class="line-removed">324         Label[] overBoundsMatch = {new Label(), new Label()};</span>
<span class="line-removed">325         // otherwise, do a vector compare that reads beyond array bounds</span>
<span class="line-removed">326         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, findTwoConsecutive ? 2 : 1, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, overBoundsMatch, false);</span>
<span class="line-removed">327         // no match</span>
<span class="line-removed">328         asm.jmp(retNotFound);</span>
329         if (findTwoConsecutive) {
<span class="line-modified">330             Label overBoundsFinish = new Label();</span>
<span class="line-removed">331             asm.bind(overBoundsMatch[1]);</span>
<span class="line-removed">332             // get match offset of second result</span>
<span class="line-removed">333             asm.bsfq(cmpResult[1], cmpResult[1]);</span>
<span class="line-removed">334             asm.addl(cmpResult[1], kind.getByteCount());</span>
<span class="line-removed">335             // replace first result with second and continue</span>
<span class="line-removed">336             asm.movl(cmpResult[0], cmpResult[1]);</span>
<span class="line-removed">337             asm.jmpb(overBoundsFinish);</span>
338 
<span class="line-modified">339             asm.bind(overBoundsMatch[0]);</span>
<span class="line-modified">340             emitFindTwoCharPrefixMinResult(asm, kind, cmpResult, overBoundsFinish);</span>
<span class="line-modified">341         } else {</span>
<span class="line-modified">342             asm.bind(overBoundsMatch[0]);</span>
<span class="line-modified">343             // find match offset</span>






344             asm.bsfq(cmpResult[0], cmpResult[0]);
<span class="line-modified">345         }</span>

















346 
<span class="line-modified">347         // adjust array pointer for match result</span>
<span class="line-modified">348         asm.addq(arrayPtr, cmpResult[0]);</span>
<span class="line-modified">349         if (charMode(kind)) {</span>
<span class="line-removed">350             // convert byte offset to chars</span>
<span class="line-removed">351             asm.shrl(cmpResult[0], 1);</span>
<span class="line-removed">352         }</span>
<span class="line-removed">353         // check if offset of matched value is greater than number of bytes remaining / out of array</span>
<span class="line-removed">354         // bounds</span>
<span class="line-removed">355         if (findTwoConsecutive) {</span>
<span class="line-removed">356             asm.decrementl(slotsRemaining);</span>
<span class="line-removed">357         }</span>
<span class="line-removed">358         asm.cmpl(cmpResult[0], slotsRemaining);</span>
<span class="line-removed">359         // match is out of bounds, return no match</span>
<span class="line-removed">360         asm.jcc(AMD64Assembler.ConditionFlag.GreaterEqual, retNotFound);</span>
<span class="line-removed">361         // adjust number of array slots remaining</span>
<span class="line-removed">362         if (findTwoConsecutive) {</span>
<span class="line-removed">363             asm.incrementl(slotsRemaining, 1);</span>
<span class="line-removed">364         }</span>
<span class="line-removed">365         asm.subl(slotsRemaining, cmpResult[0]);</span>
<span class="line-removed">366         // match is in bounds, return offset</span>
<span class="line-removed">367         asm.jmp(retFound);</span>
368 
<span class="line-modified">369         // compare remaining slots in the array one-by-one</span>
<span class="line-modified">370         asm.bind(lessThanVectorSizeRemainingLoop);</span>
<span class="line-modified">371         // check if enough array slots remain</span>
<span class="line-modified">372         asm.cmpl(slotsRemaining, findTwoConsecutive ? 1 : 0);</span>
<span class="line-modified">373         asm.jcc(AMD64Assembler.ConditionFlag.LessEqual, retNotFound);</span>
<span class="line-modified">374         // load char / byte</span>
<span class="line-modified">375         if (byteMode(kind)) {</span>
<span class="line-modified">376             if (findTwoConsecutive) {</span>
<span class="line-modified">377                 asm.movzwl(cmpResult[0], new AMD64Address(arrayPtr));</span>
<span class="line-modified">378             } else {</span>
<span class="line-modified">379                 asm.movzbl(cmpResult[0], new AMD64Address(arrayPtr));</span>





380             }


381         } else {
<span class="line-modified">382             if (findTwoConsecutive) {</span>
<span class="line-modified">383                 asm.movl(cmpResult[0], new AMD64Address(arrayPtr));</span>
<span class="line-modified">384             } else {</span>
<span class="line-modified">385                 asm.movzwl(cmpResult[0], new AMD64Address(arrayPtr));</span>




386             }









387         }
<span class="line-modified">388         // check for match</span>



389         for (int i = 0; i &lt; nValues; i++) {
<span class="line-modified">390             emitCompareInst(asm, getComparisonKind(), cmpResult[0], searchValue[i]);</span>
<span class="line-modified">391             asm.jcc(AMD64Assembler.ConditionFlag.Equal, retFound);</span>

392         }
<span class="line-modified">393         // adjust number of array slots remaining</span>
<span class="line-modified">394         asm.decrementl(slotsRemaining);</span>
<span class="line-removed">395         // adjust array pointer</span>
<span class="line-removed">396         asm.addq(arrayPtr, kind.getByteCount());</span>
<span class="line-removed">397         // continue loop</span>
<span class="line-removed">398         asm.jmpb(lessThanVectorSizeRemainingLoop);</span>
399 
<span class="line-modified">400         for (int i = 1; i &lt; nVectors; i += (findTwoConsecutive ? 2 : 1)) {</span>
<span class="line-modified">401             emitVectorFoundWithOffset(asm, kind, vectorOffsets[i], arrayPtr, cmpResult[i], slotsRemaining, vectorFound[i], retFound);</span>
<span class="line-modified">402         }</span>
403 
<span class="line-modified">404         if (findTwoConsecutive) {</span>
<span class="line-modified">405             asm.bind(vectorFound[2]);</span>
<span class="line-modified">406             asm.addq(arrayPtr, vectorOffsets[2]);</span>
<span class="line-modified">407             // adjust number of array slots remaining</span>
<span class="line-modified">408             asm.subl(slotsRemaining, charMode(kind) ? vectorOffsets[2] / 2 : vectorOffsets[2]);</span>
<span class="line-modified">409             asm.movl(cmpResult[0], cmpResult[2]);</span>
<span class="line-modified">410             asm.movl(cmpResult[1], cmpResult[3]);</span>
<span class="line-modified">411             asm.bind(vectorFound[0]);</span>
<span class="line-removed">412             emitFindTwoCharPrefixMinResult(asm, kind, cmpResult, new Label());</span>
413         } else {
<span class="line-modified">414             asm.bind(vectorFound[0]);</span>
<span class="line-removed">415             // find index of first set bit in bit mask</span>
<span class="line-removed">416             asm.bsfq(cmpResult[0], cmpResult[0]);</span>
417         }
<span class="line-modified">418         // add offset to array pointer</span>
<span class="line-modified">419         asm.addq(arrayPtr, cmpResult[0]);</span>
<span class="line-modified">420         if (charMode(kind)) {</span>
<span class="line-modified">421             // convert byte offset to chars</span>
<span class="line-modified">422             asm.shrl(cmpResult[0], 1);</span>
<span class="line-modified">423         }</span>
<span class="line-removed">424         // adjust number of array slots remaining</span>
<span class="line-removed">425         asm.subl(slotsRemaining, cmpResult[0]);</span>
<span class="line-removed">426         asm.jmpb(retFound);</span>
427     }
428 
<span class="line-modified">429     private static void emitFindTwoCharPrefixMinResult(AMD64MacroAssembler asm, JavaKind kind, Register[] cmpResult, Label done) {</span>
<span class="line-modified">430         // find match offset</span>
<span class="line-modified">431         asm.bsfq(cmpResult[0], cmpResult[0]);</span>
<span class="line-modified">432         // check if second result is also a match</span>
<span class="line-modified">433         asm.testl(cmpResult[1], cmpResult[1]);</span>
<span class="line-modified">434         asm.jcc(AMD64Assembler.ConditionFlag.Zero, done);</span>
<span class="line-modified">435         // get match offset of second result</span>
<span class="line-modified">436         asm.bsfq(cmpResult[1], cmpResult[1]);</span>
<span class="line-modified">437         asm.addl(cmpResult[1], kind.getByteCount());</span>
<span class="line-modified">438         // check if first result is less than second</span>
<span class="line-modified">439         asm.cmpl(cmpResult[0], cmpResult[1]);</span>
<span class="line-modified">440         asm.jcc(AMD64Assembler.ConditionFlag.LessEqual, done);</span>
<span class="line-modified">441         // first result is greater than second, replace it with the second result</span>
<span class="line-modified">442         asm.movl(cmpResult[0], cmpResult[1]);</span>
<span class="line-modified">443         asm.bind(done);</span>
444     }
445 
446     private static void emitAlign(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
447         asm.align(crb.target.wordSize * 2);
448     }
449 
450     /**
451      * Fills {@code vecDst} with copies of its lowest byte, word or dword.
452      */
453     private static void emitBroadcast(AMD64MacroAssembler asm, JavaKind kind, Register vecDst, Register vecTmp, AVXKind.AVXSize vectorSize) {
454         switch (kind) {
455             case Byte:
456                 if (asm.supports(CPUFeature.AVX2)) {
457                     VexRMOp.VPBROADCASTB.emit(asm, vectorSize, vecDst, vecDst);
458                 } else if (asm.supports(CPUFeature.AVX)) {
459                     VexRVMOp.VPXOR.emit(asm, vectorSize, vecTmp, vecTmp, vecTmp);
460                     VexRVMOp.VPSHUFB.emit(asm, vectorSize, vecDst, vecDst, vecTmp);
461                 } else if (asm.supports(CPUFeature.SSSE3)) {
462                     asm.pxor(vecTmp, vecTmp);
463                     asm.pshufb(vecDst, vecTmp);
</pre>
<hr />
<pre>
476                     VexRMIOp.VPSHUFD.emit(asm, vectorSize, vecDst, vecDst, 0);
477                 } else { // SSE
478                     asm.pshuflw(vecDst, vecDst, 0);
479                     asm.pshufd(vecDst, vecDst, 0);
480                 }
481                 break;
482             case Int:
483                 if (asm.supports(CPUFeature.AVX2)) {
484                     VexRMOp.VPBROADCASTD.emit(asm, vectorSize, vecDst, vecDst);
485                 } else if (asm.supports(CPUFeature.AVX)) {
486                     VexRMIOp.VPSHUFD.emit(asm, vectorSize, vecDst, vecDst, 0);
487                 } else { // SSE
488                     asm.pshufd(vecDst, vecDst, 0);
489                 }
490                 break;
491             default:
492                 throw new UnsupportedOperationException();
493         }
494     }
495 
<span class="line-modified">496     /**</span>
<span class="line-removed">497      * Convert a byte offset stored in {@code bytes} to an array index offset.</span>
<span class="line-removed">498      */</span>
<span class="line-removed">499     private static void emitBytesToArraySlots(AMD64MacroAssembler asm, JavaKind kind, Register bytes) {</span>
<span class="line-removed">500         if (charMode(kind)) {</span>
<span class="line-removed">501             asm.shrl(bytes, 1);</span>
<span class="line-removed">502         } else {</span>
<span class="line-removed">503             assert byteMode(kind);</span>
<span class="line-removed">504         }</span>
<span class="line-removed">505     }</span>
<span class="line-removed">506 </span>
<span class="line-removed">507     private static void emitVectorCompare(AMD64MacroAssembler asm,</span>
508                     JavaKind kind,
<span class="line-removed">509                     AVXKind.AVXSize vectorSize,</span>
<span class="line-removed">510                     int nValues,</span>
511                     int nVectors,
<span class="line-removed">512                     int[] vectorOffsets,</span>
513                     Register arrayPtr,

514                     Register[] vecCmp,
515                     Register[] vecArray,
516                     Register[] cmpResult,
517                     Label[] vectorFound,

518                     boolean alignedLoad) {
519         // load array contents into vectors
<span class="line-modified">520         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-modified">521             for (int j = 0; j &lt; nVectors; j++) {</span>
<span class="line-modified">522                 emitArrayLoad(asm, vectorSize, vecArray[(i * nVectors) + j], arrayPtr, vectorOffsets[j], alignedLoad);</span>

523             }
524         }
525         // compare all loaded bytes to the search value.
526         // matching bytes are set to 0xff, non-matching bytes are set to 0x00.
<span class="line-modified">527         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-removed">528             for (int j = 0; j &lt; nVectors; j++) {</span>
<span class="line-removed">529                 emitVectorCompareInst(asm, kind, vectorSize, vecArray[(i * nVectors) + j], vecCmp[i]);</span>
<span class="line-removed">530             }</span>
<span class="line-removed">531         }</span>
<span class="line-removed">532         // create 32-bit-masks from the most significant bit of every byte in the comparison</span>
<span class="line-removed">533         // results.</span>
<span class="line-removed">534         for (int i = 0; i &lt; nValues * nVectors; i++) {</span>
<span class="line-removed">535             emitMOVMSK(asm, vectorSize, cmpResult[i], vecArray[i]);</span>
<span class="line-removed">536         }</span>
<span class="line-removed">537         // join results of comparisons against multiple values</span>
<span class="line-removed">538         for (int stride = 1; stride &lt; nValues; stride *= 2) {</span>
539             for (int i = 0; i &lt; nVectors; i++) {
<span class="line-modified">540                 for (int j = 0; j + stride &lt; nValues; j += stride * 2) {</span>
<span class="line-modified">541                     asm.orl(cmpResult[i + (j * nVectors)], cmpResult[i + ((j + stride) * nVectors)]);</span>







542                 }











543             }
<span class="line-removed">544         }</span>
<span class="line-removed">545         // check if a match was found</span>
<span class="line-removed">546         for (int i = 0; i &lt; nVectors; i++) {</span>
<span class="line-removed">547             asm.testl(cmpResult[i], cmpResult[i]);</span>
<span class="line-removed">548             asm.jcc(AMD64Assembler.ConditionFlag.NotZero, vectorFound[i]);</span>
549         }
550     }
551 
<span class="line-modified">552     private static void emitVectorFoundWithOffset(AMD64MacroAssembler asm,</span>
<span class="line-modified">553                     JavaKind kind,</span>
<span class="line-modified">554                     int resultOffset,</span>
<span class="line-modified">555                     Register result,</span>
<span class="line-modified">556                     Register cmpResult,</span>
<span class="line-modified">557                     Register slotsRemaining,</span>
<span class="line-removed">558                     Label entry,</span>
<span class="line-removed">559                     Label ret) {</span>
<span class="line-removed">560         asm.bind(entry);</span>
<span class="line-removed">561         if (resultOffset &gt; 0) {</span>
<span class="line-removed">562             // adjust array pointer</span>
<span class="line-removed">563             asm.addq(result, resultOffset);</span>
<span class="line-removed">564             // adjust number of array slots remaining</span>
<span class="line-removed">565             asm.subl(slotsRemaining, charMode(kind) ? resultOffset / 2 : resultOffset);</span>
<span class="line-removed">566         }</span>
<span class="line-removed">567         // find index of first set bit in bit mask</span>
<span class="line-removed">568         asm.bsfq(cmpResult, cmpResult);</span>
<span class="line-removed">569         // add offset to array pointer</span>
<span class="line-removed">570         asm.addq(result, cmpResult);</span>
<span class="line-removed">571         if (charMode(kind)) {</span>
<span class="line-removed">572             // convert byte offset to chars</span>
<span class="line-removed">573             asm.shrl(cmpResult, 1);</span>
574         }
<span class="line-removed">575         // adjust number of array slots remaining</span>
<span class="line-removed">576         asm.subl(slotsRemaining, cmpResult);</span>
<span class="line-removed">577         asm.jmpb(ret);</span>
578     }
579 
<span class="line-modified">580     private static void emitArrayLoad(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register vecDst, Register arrayPtr, int offset, boolean alignedLoad) {</span>
<span class="line-modified">581         AMD64Address src = new AMD64Address(arrayPtr, offset);</span>
582         if (asm.supports(CPUFeature.AVX)) {
<span class="line-modified">583             VexMoveOp loadOp = alignedLoad ? VexMoveOp.VMOVDQA : VexMoveOp.VMOVDQU;</span>
584             loadOp.emit(asm, vectorSize, vecDst, src);
585         } else {
586             // SSE
587             asm.movdqu(vecDst, src);
588         }
589     }
590 
591     /**
592      * Compares all packed bytes/words/dwords in {@code vecArray} to {@code vecCmp}. Matching values
593      * are set to all ones (0xff, 0xffff, ...), non-matching values are set to zero.
594      */
595     private static void emitVectorCompareInst(AMD64MacroAssembler asm, JavaKind kind, AVXKind.AVXSize vectorSize, Register vecArray, Register vecCmp) {
596         switch (kind) {
597             case Byte:
598                 if (asm.supports(CPUFeature.AVX)) {
599                     VexRVMOp.VPCMPEQB.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
600                 } else { // SSE
601                     asm.pcmpeqb(vecArray, vecCmp);
602                 }
603                 break;
604             case Short:
605             case Char:
606                 if (asm.supports(CPUFeature.AVX)) {
607                     VexRVMOp.VPCMPEQW.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
608                 } else { // SSE
609                     asm.pcmpeqw(vecArray, vecCmp);
610                 }
611                 break;
612             case Int:
613                 if (asm.supports(CPUFeature.AVX)) {
614                     VexRVMOp.VPCMPEQD.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
615                 } else { // SSE
616                     asm.pcmpeqd(vecArray, vecCmp);
617                 }
618                 break;
619             default:
620                 throw new UnsupportedOperationException();
621         }
622     }
623 









624     private static void emitMOVMSK(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register dst, Register vecSrc) {
625         if (asm.supports(CPUFeature.AVX)) {
626             VexRMOp.VPMOVMSKB.emit(asm, vectorSize, dst, vecSrc);
627         } else {
628             // SSE
629             asm.pmovmskb(dst, vecSrc);
630         }
631     }
632 
<span class="line-modified">633     private static void emitCompareInst(AMD64MacroAssembler asm, JavaKind kind, Register dst, Register src) {</span>
634         switch (kind) {
635             case Byte:
<span class="line-modified">636                 asm.cmpb(dst, src);</span>
<span class="line-removed">637                 break;</span>
638             case Short:
639             case Char:
<span class="line-modified">640                 asm.cmpw(dst, src);</span>
<span class="line-removed">641                 break;</span>
642             case Int:
<span class="line-modified">643                 asm.cmpl(dst, src);</span>
<span class="line-removed">644                 break;</span>
645             default:
<span class="line-modified">646                 asm.cmpq(dst, src);</span>
647         }
648     }
649 
650     private static boolean supportsAVX2(LIRGeneratorTool tool) {
651         return supports(tool, CPUFeature.AVX2);
652     }
653 
654     private static boolean supports(LIRGeneratorTool tool, CPUFeature cpuFeature) {
655         return ((AMD64) tool.target().arch).getFeatures().contains(cpuFeature);
656     }





657 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.amd64;
 26 
<span class="line-modified"> 27 import static jdk.vm.ci.code.ValueUtil.asRegister;</span>
<span class="line-modified"> 28 import static jdk.vm.ci.code.ValueUtil.isRegister;</span>
<span class="line-modified"> 29 import static jdk.vm.ci.code.ValueUtil.isStackSlot;</span>
<span class="line-modified"> 30 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.CONST;</span>
<span class="line-modified"> 31 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
<span class="line-modified"> 32 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;</span>
<span class="line-added"> 33 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;</span>
<span class="line-added"> 34 </span>
<span class="line-added"> 35 import java.util.Objects;</span>
<span class="line-added"> 36 </span>
 37 import org.graalvm.compiler.asm.Label;
 38 import org.graalvm.compiler.asm.amd64.AMD64Address;
<span class="line-added"> 39 import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;</span>
 40 import org.graalvm.compiler.asm.amd64.AMD64Assembler;
<span class="line-added"> 41 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;</span>
 42 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMoveOp;
 43 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMIOp;
 44 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMOp;
 45 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp;
<span class="line-added"> 46 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;</span>
 47 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 48 import org.graalvm.compiler.asm.amd64.AVXKind;
 49 import org.graalvm.compiler.core.common.LIRKind;
<span class="line-added"> 50 import org.graalvm.compiler.core.common.NumUtil;</span>
<span class="line-added"> 51 import org.graalvm.compiler.lir.ConstantValue;</span>
 52 import org.graalvm.compiler.lir.LIRInstructionClass;
 53 import org.graalvm.compiler.lir.Opcode;
 54 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 55 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 56 
<span class="line-modified"> 57 import jdk.vm.ci.amd64.AMD64;</span>
<span class="line-modified"> 58 import jdk.vm.ci.amd64.AMD64.CPUFeature;</span>
<span class="line-modified"> 59 import jdk.vm.ci.amd64.AMD64Kind;</span>
<span class="line-added"> 60 import jdk.vm.ci.code.Register;</span>
<span class="line-added"> 61 import jdk.vm.ci.meta.JavaConstant;</span>
<span class="line-added"> 62 import jdk.vm.ci.meta.JavaKind;</span>
<span class="line-added"> 63 import jdk.vm.ci.meta.Value;</span>
 64 
 65 /**
 66  */
 67 @Opcode(&quot;AMD64_ARRAY_INDEX_OF&quot;)
 68 public final class AMD64ArrayIndexOfOp extends AMD64LIRInstruction {
 69     public static final LIRInstructionClass&lt;AMD64ArrayIndexOfOp&gt; TYPE = LIRInstructionClass.create(AMD64ArrayIndexOfOp.class);
 70 
<span class="line-modified"> 71     private final JavaKind valueKind;</span>

 72     private final int nValues;
 73     private final boolean findTwoConsecutive;
 74     private final AMD64Kind vectorKind;
<span class="line-added"> 75     private final int arrayBaseOffset;</span>
<span class="line-added"> 76     private final Scale arrayIndexScale;</span>
 77 
 78     @Def({REG}) protected Value resultValue;
 79     @Alive({REG}) protected Value arrayPtrValue;
<span class="line-modified"> 80     @Alive({REG}) protected Value arrayLengthValue;</span>
<span class="line-modified"> 81     @Use({REG}) protected Value fromIndexValue;</span>
<span class="line-modified"> 82     @Alive({REG, STACK, CONST}) protected Value searchValue1;</span>
<span class="line-modified"> 83     @Alive({REG, STACK, CONST, ILLEGAL}) protected Value searchValue2;</span>
<span class="line-modified"> 84     @Alive({REG, STACK, CONST, ILLEGAL}) protected Value searchValue3;</span>
<span class="line-modified"> 85     @Alive({REG, STACK, CONST, ILLEGAL}) protected Value searchValue4;</span>
 86     @Temp({REG}) protected Value comparisonResult1;
<span class="line-modified"> 87     @Temp({REG, ILLEGAL}) protected Value comparisonResult2;</span>


 88     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal1;
 89     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal2;
 90     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal3;
 91     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal4;
 92     @Temp({REG, ILLEGAL}) protected Value vectorArray1;
 93     @Temp({REG, ILLEGAL}) protected Value vectorArray2;
 94     @Temp({REG, ILLEGAL}) protected Value vectorArray3;
 95     @Temp({REG, ILLEGAL}) protected Value vectorArray4;
 96 
<span class="line-modified"> 97     public AMD64ArrayIndexOfOp(JavaKind arrayKind, JavaKind valueKind, boolean findTwoConsecutive, int maxVectorSize, LIRGeneratorTool tool,</span>
<span class="line-modified"> 98                     Value result, Value arrayPtr, Value arrayLength, Value fromIndex, Value... searchValues) {</span>
 99         super(TYPE);
<span class="line-modified">100         this.valueKind = valueKind;</span>
<span class="line-added">101         this.arrayBaseOffset = tool.getProviders().getMetaAccess().getArrayBaseOffset(arrayKind);</span>
<span class="line-added">102         this.arrayIndexScale = Objects.requireNonNull(Scale.fromInt(tool.getProviders().getMetaAccess().getArrayIndexScale(valueKind)));</span>
103         this.findTwoConsecutive = findTwoConsecutive;

104         assert 0 &lt; searchValues.length &amp;&amp; searchValues.length &lt;= 4;
<span class="line-modified">105         assert byteMode(valueKind) || charMode(valueKind);</span>
106         assert supports(tool, CPUFeature.SSE2) || supports(tool, CPUFeature.AVX) || supportsAVX2(tool);
107         nValues = searchValues.length;
108         assert !findTwoConsecutive || nValues == 1;
109         resultValue = result;
110         arrayPtrValue = arrayPtr;
111         arrayLengthValue = arrayLength;
<span class="line-added">112         fromIndexValue = fromIndex;</span>
113         searchValue1 = searchValues[0];
114         searchValue2 = nValues &gt; 1 ? searchValues[1] : Value.ILLEGAL;
115         searchValue3 = nValues &gt; 2 ? searchValues[2] : Value.ILLEGAL;
116         searchValue4 = nValues &gt; 3 ? searchValues[3] : Value.ILLEGAL;
<span class="line-modified">117         comparisonResult1 = tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));</span>
<span class="line-modified">118         comparisonResult2 = findTwoConsecutive ? tool.newVariable(LIRKind.value(tool.target().arch.getWordKind())) : Value.ILLEGAL;</span>
<span class="line-modified">119         vectorKind = supportsAVX2(tool) &amp;&amp; (maxVectorSize &lt; 0 || maxVectorSize &gt;= 32) ? byteMode(valueKind) ? AMD64Kind.V256_BYTE : AMD64Kind.V256_WORD</span>
<span class="line-modified">120                         : byteMode(valueKind) ? AMD64Kind.V128_BYTE : AMD64Kind.V128_WORD;</span>



121         vectorCompareVal1 = tool.newVariable(LIRKind.value(vectorKind));
122         vectorCompareVal2 = nValues &gt; 1 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
123         vectorCompareVal3 = nValues &gt; 2 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
124         vectorCompareVal4 = nValues &gt; 3 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
125         vectorArray1 = tool.newVariable(LIRKind.value(vectorKind));
126         vectorArray2 = tool.newVariable(LIRKind.value(vectorKind));
127         vectorArray3 = tool.newVariable(LIRKind.value(vectorKind));
128         vectorArray4 = tool.newVariable(LIRKind.value(vectorKind));
129     }
130 
131     private static boolean byteMode(JavaKind kind) {
132         return kind == JavaKind.Byte;
133     }
134 
135     private static boolean charMode(JavaKind kind) {
136         return kind == JavaKind.Char;
137     }
138 
139     private JavaKind getComparisonKind() {
<span class="line-modified">140         return findTwoConsecutive ? (byteMode(valueKind) ? JavaKind.Char : JavaKind.Int) : valueKind;</span>
141     }
142 
143     private AVXKind.AVXSize getVectorSize() {
144         return AVXKind.getDataSize(vectorKind);
145     }
146 
147     @Override
148     public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
<span class="line-added">149         int nVectors = nValues == 1 ? 4 : nValues == 2 ? 2 : 1;</span>
150         Register arrayPtr = asRegister(arrayPtrValue);
151         Register arrayLength = asRegister(arrayLengthValue);
<span class="line-modified">152         Register fromIndex = asRegister(fromIndexValue);</span>
<span class="line-modified">153         Register index = asRegister(resultValue);</span>
<span class="line-modified">154         Value[] searchValue = {</span>
<span class="line-modified">155                         nValues &gt; 0 ? searchValue1 : null,</span>
<span class="line-modified">156                         nValues &gt; 1 ? searchValue2 : null,</span>
<span class="line-modified">157                         nValues &gt; 2 ? searchValue3 : null,</span>
<span class="line-modified">158                         nValues &gt; 3 ? searchValue4 : null,</span>
159         };
160         Register[] vecCmp = {
161                         nValues &gt; 0 ? asRegister(vectorCompareVal1) : null,
162                         nValues &gt; 1 ? asRegister(vectorCompareVal2) : null,
163                         nValues &gt; 2 ? asRegister(vectorCompareVal3) : null,
164                         nValues &gt; 3 ? asRegister(vectorCompareVal4) : null,
165         };
166         Register[] vecArray = {
167                         asRegister(vectorArray1),
168                         asRegister(vectorArray2),
169                         asRegister(vectorArray3),
170                         asRegister(vectorArray4),
171         };
172         Register[] cmpResult = {
173                         asRegister(comparisonResult1),
<span class="line-modified">174                         findTwoConsecutive ? asRegister(comparisonResult2) : null,</span>


175         };
<span class="line-modified">176         Label ret = new Label();</span>

















































177 
178         Label bulkVectorLoop = new Label();
179         Label singleVectorLoop = new Label();
180         Label[] vectorFound = {
181                         new Label(),
182                         new Label(),
183                         new Label(),
184                         new Label(),
185         };
<span class="line-modified">186         Label runVectorized = new Label();</span>
<span class="line-modified">187         Label elementWiseLoop = new Label();</span>
<span class="line-modified">188         Label elementWiseFound = new Label();</span>
<span class="line-modified">189         Label elementWiseNotFound = new Label();</span>
<span class="line-modified">190         Label skipBulkVectorLoop = new Label();</span>
<span class="line-modified">191         int vectorSize = getVectorSize().getBytes() / valueKind.getByteCount();</span>
<span class="line-modified">192         int bulkSize = vectorSize * nVectors;</span>
<span class="line-modified">193         JavaKind vectorCompareKind = valueKind;</span>



194         if (findTwoConsecutive) {


195             bulkSize /= 2;
<span class="line-modified">196             vectorCompareKind = byteMode(valueKind) ? JavaKind.Char : JavaKind.Int;</span>
<span class="line-modified">197         }</span>
<span class="line-modified">198         // index = fromIndex + vectorSize (+1 if findTwoConsecutive)</span>
<span class="line-added">199         // important: this must be the first register manipulation, since fromIndex is</span>
<span class="line-added">200         // annotated with @Use</span>
<span class="line-added">201         asm.leaq(index, new AMD64Address(fromIndex, vectorSize + (findTwoConsecutive ? 1 : 0)));</span>
<span class="line-added">202 </span>
<span class="line-added">203         // check if vector vector load is in bounds</span>
<span class="line-added">204         asm.cmpq(index, arrayLength);</span>
<span class="line-added">205         asm.jccb(AMD64Assembler.ConditionFlag.LessEqual, runVectorized);</span>
<span class="line-added">206 </span>
<span class="line-added">207         // search range is smaller than vector size, do element-wise comparison</span>
<span class="line-added">208 </span>
<span class="line-added">209         // index = fromIndex (+ 1 if findTwoConsecutive)</span>
<span class="line-added">210         asm.subq(index, vectorSize);</span>
<span class="line-added">211         // check if enough array slots remain</span>
<span class="line-added">212         asm.cmpq(index, arrayLength);</span>
<span class="line-added">213         asm.jccb(AMD64Assembler.ConditionFlag.GreaterEqual, elementWiseNotFound);</span>
<span class="line-added">214         // compare one-by-one</span>
<span class="line-added">215         asm.bind(elementWiseLoop);</span>
<span class="line-added">216         // check for match</span>
<span class="line-added">217         OperandSize cmpSize = getOpSize(getComparisonKind());</span>
<span class="line-added">218         // address = findTwoConsecutive ? array[index - 1] : array[index]</span>
<span class="line-added">219         AMD64Address arrayAddr = new AMD64Address(arrayPtr, index, arrayIndexScale, arrayBaseOffset - (findTwoConsecutive ? valueKind.getByteCount() : 0));</span>
<span class="line-added">220         boolean valuesOnStack = searchValuesOnStack(searchValue);</span>
<span class="line-added">221         if (valuesOnStack) {</span>
<span class="line-added">222             (cmpSize == OperandSize.BYTE ? AMD64RMOp.MOVB : AMD64RMOp.MOV).emit(asm, cmpSize, cmpResult[0], arrayAddr);</span>
<span class="line-added">223             for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-added">224                 if (isConstant(searchValue[i])) {</span>
<span class="line-added">225                     int imm = asConstant(searchValue[i]).asInt();</span>
<span class="line-added">226                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getMIOpcode(cmpSize, NumUtil.isByte(imm)).emit(asm, cmpSize, cmpResult[0], imm);</span>
<span class="line-added">227                 } else if (isStackSlot(searchValue[i])) {</span>
<span class="line-added">228                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getRMOpcode(cmpSize).emit(asm, cmpSize, cmpResult[0], (AMD64Address) crb.asAddress(searchValue[i]));</span>
<span class="line-added">229                 } else {</span>
<span class="line-added">230                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getRMOpcode(cmpSize).emit(asm, cmpSize, cmpResult[0], asRegister(searchValue[i]));</span>
<span class="line-added">231                 }</span>
<span class="line-added">232                 asm.jccb(AMD64Assembler.ConditionFlag.Equal, elementWiseFound);</span>
<span class="line-added">233             }</span>
<span class="line-added">234         } else {</span>
<span class="line-added">235             for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-added">236                 if (isConstant(searchValue[i])) {</span>
<span class="line-added">237                     int imm = asConstant(searchValue[i]).asInt();</span>
<span class="line-added">238                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getMIOpcode(cmpSize, NumUtil.isByte(imm)).emit(asm, cmpSize, arrayAddr, imm);</span>
<span class="line-added">239                 } else {</span>
<span class="line-added">240                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getRMOpcode(cmpSize).emit(asm, cmpSize, asRegister(searchValue[i]), arrayAddr);</span>
<span class="line-added">241                 }</span>
<span class="line-added">242                 asm.jccb(AMD64Assembler.ConditionFlag.Equal, elementWiseFound);</span>
<span class="line-added">243             }</span>
<span class="line-added">244         }</span>
<span class="line-added">245         // adjust index</span>
<span class="line-added">246         asm.incrementq(index, 1);</span>
<span class="line-added">247         // continue loop</span>
<span class="line-added">248         asm.cmpq(index, arrayLength);</span>
<span class="line-added">249         asm.jccb(AMD64Assembler.ConditionFlag.Less, elementWiseLoop);</span>
<span class="line-added">250 </span>
<span class="line-added">251         asm.bind(elementWiseNotFound);</span>
<span class="line-added">252         asm.xorq(index, index);</span>
<span class="line-added">253 </span>
<span class="line-added">254         if (findTwoConsecutive) {</span>
<span class="line-added">255             asm.bind(elementWiseFound);</span>
<span class="line-added">256             asm.decrementq(index, 1);</span>
257         } else {
<span class="line-modified">258             asm.decrementq(index, 1);</span>
<span class="line-added">259             asm.bind(elementWiseFound);</span>
<span class="line-added">260         }</span>
<span class="line-added">261         asm.jmp(ret);</span>
<span class="line-added">262 </span>
<span class="line-added">263         // vectorized implementation</span>
<span class="line-added">264         asm.bind(runVectorized);</span>
<span class="line-added">265 </span>
<span class="line-added">266         // move search values to vectors</span>
<span class="line-added">267         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-added">268             // fill comparison vector with copies of the search value</span>
<span class="line-added">269             broadcastSearchValue(crb, asm, vecCmp[i], searchValue[i], cmpResult[0], vecArray[0]);</span>
<span class="line-added">270         }</span>
<span class="line-added">271 </span>
<span class="line-added">272         // do one unaligned vector comparison pass and adjust alignment afterwards</span>
<span class="line-added">273         emitVectorCompare(asm, vectorCompareKind, findTwoConsecutive ? 2 : 1, arrayPtr, index, vecCmp, vecArray, cmpResult, vectorFound, false, false);</span>
<span class="line-added">274 </span>
<span class="line-added">275         // adjust index to vector size alignment</span>
<span class="line-added">276         asm.leaq(cmpResult[0], new AMD64Address(arrayPtr, arrayBaseOffset));</span>
<span class="line-added">277         if (charMode(valueKind)) {</span>
<span class="line-added">278             asm.shrq(cmpResult[0], 1);</span>
279         }
<span class="line-added">280         asm.addq(index, cmpResult[0]);</span>
<span class="line-added">281         // adjust to next lower multiple of vector size</span>
<span class="line-added">282         asm.andq(index, ~(vectorSize - 1));</span>
<span class="line-added">283         asm.subq(index, cmpResult[0]);</span>
<span class="line-added">284         // add bulk size</span>
<span class="line-added">285         asm.addq(index, bulkSize);</span>
286 



























287         // check if there are enough array slots remaining for the bulk loop
<span class="line-modified">288         asm.cmpq(index, arrayLength);</span>
<span class="line-modified">289         asm.jccb(AMD64Assembler.ConditionFlag.Greater, skipBulkVectorLoop);</span>
290 
291         emitAlign(crb, asm);
292         asm.bind(bulkVectorLoop);
293         // memory-aligned bulk comparison
<span class="line-modified">294         emitVectorCompare(asm, vectorCompareKind, nVectors, arrayPtr, index, vecCmp, vecArray, cmpResult, vectorFound, false, !findTwoConsecutive);</span>
<span class="line-modified">295         // adjust index</span>
<span class="line-modified">296         asm.addq(index, bulkSize);</span>


297         // check if there are enough array slots remaining for the bulk loop
<span class="line-modified">298         asm.cmpq(index, arrayLength);</span>
<span class="line-modified">299         asm.jccb(AMD64Assembler.ConditionFlag.LessEqual, bulkVectorLoop);</span>


300 
<span class="line-modified">301         asm.bind(skipBulkVectorLoop);</span>
<span class="line-added">302         if ((findTwoConsecutive &amp;&amp; nVectors == 2) || nVectors == 1) {</span>
<span class="line-added">303             // do last load from end of array</span>
<span class="line-added">304             asm.movq(index, arrayLength);</span>
<span class="line-added">305             // compare</span>
<span class="line-added">306             emitVectorCompare(asm, vectorCompareKind, findTwoConsecutive ? 2 : 1, arrayPtr, index, vecCmp, vecArray, cmpResult, vectorFound, true, false);</span>
<span class="line-added">307         } else {</span>
<span class="line-added">308             // remove bulk offset</span>
<span class="line-added">309             asm.subq(index, bulkSize);</span>
310             emitAlign(crb, asm);
311             // same loop as bulkVectorLoop, with only one vector
312             asm.bind(singleVectorLoop);
<span class="line-modified">313             // add vector size</span>
<span class="line-modified">314             asm.addq(index, vectorSize);</span>
<span class="line-modified">315             // check if vector load is in bounds</span>
<span class="line-added">316             asm.cmpq(index, arrayLength);</span>
<span class="line-added">317             // if load would be over bounds, set the load to the end of the array</span>
<span class="line-added">318             asm.cmovq(AMD64Assembler.ConditionFlag.Greater, index, arrayLength);</span>
319             // compare
<span class="line-modified">320             emitVectorCompare(asm, vectorCompareKind, findTwoConsecutive ? 2 : 1, arrayPtr, index, vecCmp, vecArray, cmpResult, vectorFound, true, false);</span>
<span class="line-modified">321             // check if there are enough array slots remaining for the loop</span>
<span class="line-modified">322             asm.cmpq(index, arrayLength);</span>
<span class="line-modified">323             asm.jccb(AMD64Assembler.ConditionFlag.Less, singleVectorLoop);</span>



324         }
325 
<span class="line-modified">326         asm.movl(index, -1);</span>
<span class="line-modified">327         asm.jmpb(ret);</span>
<span class="line-modified">328 </span>

















329         if (findTwoConsecutive) {
<span class="line-modified">330             Label vectorFound2Done = new Label();</span>







331 
<span class="line-modified">332             // vectorFound[0] and vectorFound[2] behave like the single-char case</span>
<span class="line-modified">333             asm.bind(vectorFound[2]);</span>
<span class="line-modified">334             // add static offset</span>
<span class="line-modified">335             asm.subq(index, getResultIndexDelta(2));</span>
<span class="line-modified">336             asm.jmpb(vectorFound2Done);</span>
<span class="line-added">337 </span>
<span class="line-added">338             asm.bind(vectorFound[0]);</span>
<span class="line-added">339             // add static offset</span>
<span class="line-added">340             asm.subq(index, getResultIndexDelta(0));</span>
<span class="line-added">341             asm.bind(vectorFound2Done);</span>
<span class="line-added">342             // find offset</span>
343             asm.bsfq(cmpResult[0], cmpResult[0]);
<span class="line-modified">344             if (charMode(valueKind)) {</span>
<span class="line-added">345                 // convert byte offset to chars</span>
<span class="line-added">346                 asm.shrl(cmpResult[0], 1);</span>
<span class="line-added">347             }</span>
<span class="line-added">348             // add offset to index</span>
<span class="line-added">349             asm.addq(index, cmpResult[0]);</span>
<span class="line-added">350             asm.jmpb(ret);</span>
<span class="line-added">351 </span>
<span class="line-added">352             Label minResult = new Label();</span>
<span class="line-added">353             Label minResultDone = new Label();</span>
<span class="line-added">354 </span>
<span class="line-added">355             // in vectorFound[1] and vectorFound[3], we have to check the results 0 and 2 as well</span>
<span class="line-added">356             if (nVectors &gt; 2) {</span>
<span class="line-added">357                 asm.bind(vectorFound[3]);</span>
<span class="line-added">358                 // add offset</span>
<span class="line-added">359                 asm.subq(index, getResultIndexDelta(3));</span>
<span class="line-added">360                 asm.jmpb(minResult);</span>
<span class="line-added">361             }</span>
362 
<span class="line-modified">363             asm.bind(vectorFound[1]);</span>
<span class="line-modified">364             // add offset</span>
<span class="line-modified">365             asm.subq(index, getResultIndexDelta(1));</span>


















366 
<span class="line-modified">367             asm.bind(minResult);</span>
<span class="line-modified">368             // find offset 0</span>
<span class="line-modified">369             asm.bsfq(cmpResult[1], cmpResult[1]);</span>
<span class="line-modified">370             // check if second result is also a match</span>
<span class="line-modified">371             asm.testq(cmpResult[0], cmpResult[0]);</span>
<span class="line-modified">372             asm.jccb(AMD64Assembler.ConditionFlag.Zero, minResultDone);</span>
<span class="line-modified">373             // find offset 1</span>
<span class="line-modified">374             asm.bsfq(cmpResult[0], cmpResult[0]);</span>
<span class="line-modified">375             asm.addq(cmpResult[0], valueKind.getByteCount());</span>
<span class="line-modified">376             // if first result is greater than second, replace it with the second result</span>
<span class="line-modified">377             asm.cmpq(cmpResult[1], cmpResult[0]);</span>
<span class="line-added">378             asm.cmovq(AMD64Assembler.ConditionFlag.Greater, cmpResult[1], cmpResult[0]);</span>
<span class="line-added">379             asm.bind(minResultDone);</span>
<span class="line-added">380             if (charMode(valueKind)) {</span>
<span class="line-added">381                 // convert byte offset to chars</span>
<span class="line-added">382                 asm.shrl(cmpResult[1], 1);</span>
383             }
<span class="line-added">384             // add offset to index</span>
<span class="line-added">385             asm.addq(index, cmpResult[1]);</span>
386         } else {
<span class="line-modified">387             Label end = new Label();</span>
<span class="line-modified">388             for (int i = 0; i &lt; nVectors; i++) {</span>
<span class="line-modified">389                 asm.bind(vectorFound[i]);</span>
<span class="line-modified">390                 // add static offset</span>
<span class="line-added">391                 asm.subq(index, getResultIndexDelta(i));</span>
<span class="line-added">392                 if (i &lt; nVectors - 1) {</span>
<span class="line-added">393                     asm.jmpb(end);</span>
<span class="line-added">394                 }</span>
395             }
<span class="line-added">396             asm.bind(end);</span>
<span class="line-added">397             // find offset</span>
<span class="line-added">398             asm.bsfq(cmpResult[0], cmpResult[0]);</span>
<span class="line-added">399             if (charMode(valueKind)) {</span>
<span class="line-added">400                 // convert byte offset to chars</span>
<span class="line-added">401                 asm.shrl(cmpResult[0], 1);</span>
<span class="line-added">402             }</span>
<span class="line-added">403             // add offset to index</span>
<span class="line-added">404             asm.addq(index, cmpResult[0]);</span>
405         }
<span class="line-modified">406         asm.bind(ret);</span>
<span class="line-added">407     }</span>
<span class="line-added">408 </span>
<span class="line-added">409     private boolean searchValuesOnStack(Value[] searchValue) {</span>
410         for (int i = 0; i &lt; nValues; i++) {
<span class="line-modified">411             if (isStackSlot(searchValue[i])) {</span>
<span class="line-modified">412                 return true;</span>
<span class="line-added">413             }</span>
414         }
<span class="line-modified">415         return false;</span>
<span class="line-modified">416     }</span>




417 
<span class="line-modified">418     private int getResultIndexDelta(int i) {</span>
<span class="line-modified">419         return (((findTwoConsecutive ? i / 2 : i) + 1) * (getVectorSize().getBytes() / valueKind.getByteCount())) + (findTwoConsecutive ? (i &amp; 1) : 0);</span>
<span class="line-modified">420     }</span>
421 
<span class="line-modified">422     private int getVectorOffset(int i) {</span>
<span class="line-modified">423         return arrayBaseOffset - getResultIndexDelta(i) * valueKind.getByteCount();</span>
<span class="line-modified">424     }</span>
<span class="line-modified">425 </span>
<span class="line-modified">426     private void broadcastSearchValue(CompilationResultBuilder crb, AMD64MacroAssembler asm, Register dst, Value srcVal, Register tmpReg, Register tmpVector) {</span>
<span class="line-modified">427         Register src = asRegOrTmpReg(crb, asm, srcVal, tmpReg);</span>
<span class="line-modified">428         if (asm.supports(CPUFeature.AVX)) {</span>
<span class="line-modified">429             VexMoveOp.VMOVD.emit(asm, AVXKind.AVXSize.DWORD, dst, src);</span>

430         } else {
<span class="line-modified">431             asm.movdl(dst, src);</span>


432         }
<span class="line-modified">433         emitBroadcast(asm, getComparisonKind(), dst, tmpVector, getVectorSize());</span>
<span class="line-modified">434     }</span>
<span class="line-modified">435 </span>
<span class="line-modified">436     private static boolean isConstant(Value val) {</span>
<span class="line-modified">437         assert !(val instanceof ConstantValue) || ((ConstantValue) val).isJavaConstant();</span>
<span class="line-modified">438         return val instanceof ConstantValue;</span>



439     }
440 
<span class="line-modified">441     private static JavaConstant asConstant(Value val) {</span>
<span class="line-modified">442         return ((ConstantValue) val).getJavaConstant();</span>
<span class="line-modified">443     }</span>
<span class="line-modified">444 </span>
<span class="line-modified">445     private static Register asRegOrTmpReg(CompilationResultBuilder crb, AMD64MacroAssembler asm, Value val, Register tmpReg) {</span>
<span class="line-modified">446         if (isRegister(val)) {</span>
<span class="line-modified">447             return asRegister(val);</span>
<span class="line-modified">448         } else if (isStackSlot(val)) {</span>
<span class="line-modified">449             asm.movl(tmpReg, (AMD64Address) crb.asAddress(val));</span>
<span class="line-modified">450             return tmpReg;</span>
<span class="line-modified">451         } else {</span>
<span class="line-modified">452             assert isConstant(val);</span>
<span class="line-modified">453             asm.movl(tmpReg, asConstant(val).asInt());</span>
<span class="line-modified">454             return tmpReg;</span>
<span class="line-modified">455         }</span>
456     }
457 
458     private static void emitAlign(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
459         asm.align(crb.target.wordSize * 2);
460     }
461 
462     /**
463      * Fills {@code vecDst} with copies of its lowest byte, word or dword.
464      */
465     private static void emitBroadcast(AMD64MacroAssembler asm, JavaKind kind, Register vecDst, Register vecTmp, AVXKind.AVXSize vectorSize) {
466         switch (kind) {
467             case Byte:
468                 if (asm.supports(CPUFeature.AVX2)) {
469                     VexRMOp.VPBROADCASTB.emit(asm, vectorSize, vecDst, vecDst);
470                 } else if (asm.supports(CPUFeature.AVX)) {
471                     VexRVMOp.VPXOR.emit(asm, vectorSize, vecTmp, vecTmp, vecTmp);
472                     VexRVMOp.VPSHUFB.emit(asm, vectorSize, vecDst, vecDst, vecTmp);
473                 } else if (asm.supports(CPUFeature.SSSE3)) {
474                     asm.pxor(vecTmp, vecTmp);
475                     asm.pshufb(vecDst, vecTmp);
</pre>
<hr />
<pre>
488                     VexRMIOp.VPSHUFD.emit(asm, vectorSize, vecDst, vecDst, 0);
489                 } else { // SSE
490                     asm.pshuflw(vecDst, vecDst, 0);
491                     asm.pshufd(vecDst, vecDst, 0);
492                 }
493                 break;
494             case Int:
495                 if (asm.supports(CPUFeature.AVX2)) {
496                     VexRMOp.VPBROADCASTD.emit(asm, vectorSize, vecDst, vecDst);
497                 } else if (asm.supports(CPUFeature.AVX)) {
498                     VexRMIOp.VPSHUFD.emit(asm, vectorSize, vecDst, vecDst, 0);
499                 } else { // SSE
500                     asm.pshufd(vecDst, vecDst, 0);
501                 }
502                 break;
503             default:
504                 throw new UnsupportedOperationException();
505         }
506     }
507 
<span class="line-modified">508     private void emitVectorCompare(AMD64MacroAssembler asm,</span>











509                     JavaKind kind,


510                     int nVectors,

511                     Register arrayPtr,
<span class="line-added">512                     Register index,</span>
513                     Register[] vecCmp,
514                     Register[] vecArray,
515                     Register[] cmpResult,
516                     Label[] vectorFound,
<span class="line-added">517                     boolean shortJmp,</span>
518                     boolean alignedLoad) {
519         // load array contents into vectors
<span class="line-modified">520         for (int i = 0; i &lt; nVectors; i++) {</span>
<span class="line-modified">521             int base = i * nValues;</span>
<span class="line-modified">522             for (int j = 0; j &lt; nValues; j++) {</span>
<span class="line-added">523                 emitArrayLoad(asm, getVectorSize(), vecArray[base + j], arrayPtr, index, getVectorOffset(nVectors - (i + 1)), alignedLoad);</span>
524             }
525         }
526         // compare all loaded bytes to the search value.
527         // matching bytes are set to 0xff, non-matching bytes are set to 0x00.
<span class="line-modified">528         if (!findTwoConsecutive) {</span>











529             for (int i = 0; i &lt; nVectors; i++) {
<span class="line-modified">530                 int base = i * nValues;</span>
<span class="line-modified">531                 for (int j = 0; j &lt; nValues; j++) {</span>
<span class="line-added">532                     emitVectorCompareInst(asm, kind, getVectorSize(), vecArray[base + j], vecCmp[j]);</span>
<span class="line-added">533                     if ((j &amp; 1) == 1) {</span>
<span class="line-added">534                         emitPOR(asm, getVectorSize(), vecArray[base + j - 1], vecArray[base + j]);</span>
<span class="line-added">535                     }</span>
<span class="line-added">536                 }</span>
<span class="line-added">537                 if (nValues &gt; 2) {</span>
<span class="line-added">538                     emitPOR(asm, getVectorSize(), vecArray[base], vecArray[base + 2]);</span>
539                 }
<span class="line-added">540                 emitMOVMSK(asm, getVectorSize(), cmpResult[0], vecArray[base]);</span>
<span class="line-added">541                 emitJnz(asm, cmpResult[0], vectorFound[nVectors - (i + 1)], shortJmp);</span>
<span class="line-added">542             }</span>
<span class="line-added">543         } else {</span>
<span class="line-added">544             for (int i = 0; i &lt; nVectors; i += 2) {</span>
<span class="line-added">545                 emitVectorCompareInst(asm, kind, getVectorSize(), vecArray[i], vecCmp[0]);</span>
<span class="line-added">546                 emitVectorCompareInst(asm, kind, getVectorSize(), vecArray[i + 1], vecCmp[0]);</span>
<span class="line-added">547                 emitMOVMSK(asm, getVectorSize(), cmpResult[1], vecArray[i]);</span>
<span class="line-added">548                 emitMOVMSK(asm, getVectorSize(), cmpResult[0], vecArray[i + 1]);</span>
<span class="line-added">549                 emitJnz(asm, cmpResult[1], vectorFound[nVectors - (i + 1)], shortJmp);</span>
<span class="line-added">550                 emitJnz(asm, cmpResult[0], vectorFound[nVectors - (i + 2)], shortJmp);</span>
551             }





552         }
553     }
554 
<span class="line-modified">555     private static void emitJnz(AMD64MacroAssembler asm, Register cond, Label tgt, boolean shortJmp) {</span>
<span class="line-modified">556         asm.testl(cond, cond);</span>
<span class="line-modified">557         if (shortJmp) {</span>
<span class="line-modified">558             asm.jccb(AMD64Assembler.ConditionFlag.NotZero, tgt);</span>
<span class="line-modified">559         } else {</span>
<span class="line-modified">560             asm.jcc(AMD64Assembler.ConditionFlag.NotZero, tgt);</span>
















561         }



562     }
563 
<span class="line-modified">564     private void emitArrayLoad(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register vecDst, Register arrayPtr, Register index, int offset, boolean alignedLoad) {</span>
<span class="line-modified">565         AMD64Address src = new AMD64Address(arrayPtr, index, arrayIndexScale, offset);</span>
566         if (asm.supports(CPUFeature.AVX)) {
<span class="line-modified">567             VexMoveOp loadOp = alignedLoad ? VexMoveOp.VMOVDQA32 : VexMoveOp.VMOVDQU32;</span>
568             loadOp.emit(asm, vectorSize, vecDst, src);
569         } else {
570             // SSE
571             asm.movdqu(vecDst, src);
572         }
573     }
574 
575     /**
576      * Compares all packed bytes/words/dwords in {@code vecArray} to {@code vecCmp}. Matching values
577      * are set to all ones (0xff, 0xffff, ...), non-matching values are set to zero.
578      */
579     private static void emitVectorCompareInst(AMD64MacroAssembler asm, JavaKind kind, AVXKind.AVXSize vectorSize, Register vecArray, Register vecCmp) {
580         switch (kind) {
581             case Byte:
582                 if (asm.supports(CPUFeature.AVX)) {
583                     VexRVMOp.VPCMPEQB.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
584                 } else { // SSE
585                     asm.pcmpeqb(vecArray, vecCmp);
586                 }
587                 break;
588             case Short:
589             case Char:
590                 if (asm.supports(CPUFeature.AVX)) {
591                     VexRVMOp.VPCMPEQW.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
592                 } else { // SSE
593                     asm.pcmpeqw(vecArray, vecCmp);
594                 }
595                 break;
596             case Int:
597                 if (asm.supports(CPUFeature.AVX)) {
598                     VexRVMOp.VPCMPEQD.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
599                 } else { // SSE
600                     asm.pcmpeqd(vecArray, vecCmp);
601                 }
602                 break;
603             default:
604                 throw new UnsupportedOperationException();
605         }
606     }
607 
<span class="line-added">608     private static void emitPOR(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register dst, Register vecSrc) {</span>
<span class="line-added">609         if (asm.supports(CPUFeature.AVX)) {</span>
<span class="line-added">610             VexRVMOp.VPOR.emit(asm, vectorSize, dst, dst, vecSrc);</span>
<span class="line-added">611         } else {</span>
<span class="line-added">612             // SSE</span>
<span class="line-added">613             asm.por(dst, vecSrc);</span>
<span class="line-added">614         }</span>
<span class="line-added">615     }</span>
<span class="line-added">616 </span>
617     private static void emitMOVMSK(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register dst, Register vecSrc) {
618         if (asm.supports(CPUFeature.AVX)) {
619             VexRMOp.VPMOVMSKB.emit(asm, vectorSize, dst, vecSrc);
620         } else {
621             // SSE
622             asm.pmovmskb(dst, vecSrc);
623         }
624     }
625 
<span class="line-modified">626     private static OperandSize getOpSize(JavaKind kind) {</span>
627         switch (kind) {
628             case Byte:
<span class="line-modified">629                 return OperandSize.BYTE;</span>

630             case Short:
631             case Char:
<span class="line-modified">632                 return OperandSize.WORD;</span>

633             case Int:
<span class="line-modified">634                 return OperandSize.DWORD;</span>

635             default:
<span class="line-modified">636                 return OperandSize.QWORD;</span>
637         }
638     }
639 
640     private static boolean supportsAVX2(LIRGeneratorTool tool) {
641         return supports(tool, CPUFeature.AVX2);
642     }
643 
644     private static boolean supports(LIRGeneratorTool tool, CPUFeature cpuFeature) {
645         return ((AMD64) tool.target().arch).getFeatures().contains(cpuFeature);
646     }
<span class="line-added">647 </span>
<span class="line-added">648     @Override</span>
<span class="line-added">649     public boolean needsClearUpperVectorRegisters() {</span>
<span class="line-added">650         return true;</span>
<span class="line-added">651     }</span>
652 }
</pre>
</td>
</tr>
</table>
<center><a href="AMD64ArrayEqualsOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64Binary.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
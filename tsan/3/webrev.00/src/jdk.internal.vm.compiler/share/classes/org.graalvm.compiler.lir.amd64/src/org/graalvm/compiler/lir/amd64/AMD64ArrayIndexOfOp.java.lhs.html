<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayIndexOfOp.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2019 Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.amd64;
 26 
<a name="2" id="anc2"></a><span class="line-modified"> 27 import jdk.vm.ci.amd64.AMD64;</span>
<span class="line-modified"> 28 import jdk.vm.ci.amd64.AMD64.CPUFeature;</span>
<span class="line-modified"> 29 import jdk.vm.ci.amd64.AMD64Kind;</span>
<span class="line-modified"> 30 import jdk.vm.ci.code.Register;</span>
<span class="line-modified"> 31 import jdk.vm.ci.meta.JavaKind;</span>
<span class="line-modified"> 32 import jdk.vm.ci.meta.Value;</span>




 33 import org.graalvm.compiler.asm.Label;
 34 import org.graalvm.compiler.asm.amd64.AMD64Address;
<a name="3" id="anc3"></a>
 35 import org.graalvm.compiler.asm.amd64.AMD64Assembler;
<a name="4" id="anc4"></a>
 36 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMoveOp;
 37 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMIOp;
 38 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMOp;
 39 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp;
<a name="5" id="anc5"></a>
 40 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 41 import org.graalvm.compiler.asm.amd64.AVXKind;
 42 import org.graalvm.compiler.core.common.LIRKind;
<a name="6" id="anc6"></a>

 43 import org.graalvm.compiler.lir.LIRInstructionClass;
 44 import org.graalvm.compiler.lir.Opcode;
 45 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 46 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 47 
<a name="7" id="anc7"></a><span class="line-modified"> 48 import static jdk.vm.ci.code.ValueUtil.asRegister;</span>
<span class="line-modified"> 49 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
<span class="line-modified"> 50 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;</span>




 51 
 52 /**
 53  */
 54 @Opcode(&quot;AMD64_ARRAY_INDEX_OF&quot;)
 55 public final class AMD64ArrayIndexOfOp extends AMD64LIRInstruction {
 56     public static final LIRInstructionClass&lt;AMD64ArrayIndexOfOp&gt; TYPE = LIRInstructionClass.create(AMD64ArrayIndexOfOp.class);
 57 
<a name="8" id="anc8"></a><span class="line-modified"> 58     private final JavaKind kind;</span>
<span class="line-removed"> 59     private final int vmPageSize;</span>
 60     private final int nValues;
 61     private final boolean findTwoConsecutive;
 62     private final AMD64Kind vectorKind;
<a name="9" id="anc9"></a>

 63 
 64     @Def({REG}) protected Value resultValue;
 65     @Alive({REG}) protected Value arrayPtrValue;
<a name="10" id="anc10"></a><span class="line-modified"> 66     @Use({REG}) protected Value arrayLengthValue;</span>
<span class="line-modified"> 67     @Alive({REG}) protected Value searchValue1;</span>
<span class="line-modified"> 68     @Alive({REG, ILLEGAL}) protected Value searchValue2;</span>
<span class="line-modified"> 69     @Alive({REG, ILLEGAL}) protected Value searchValue3;</span>
<span class="line-modified"> 70     @Alive({REG, ILLEGAL}) protected Value searchValue4;</span>
<span class="line-modified"> 71     @Temp({REG}) protected Value arraySlotsRemaining;</span>
 72     @Temp({REG}) protected Value comparisonResult1;
<a name="11" id="anc11"></a><span class="line-modified"> 73     @Temp({REG}) protected Value comparisonResult2;</span>
<span class="line-removed"> 74     @Temp({REG}) protected Value comparisonResult3;</span>
<span class="line-removed"> 75     @Temp({REG}) protected Value comparisonResult4;</span>
 76     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal1;
 77     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal2;
 78     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal3;
 79     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal4;
 80     @Temp({REG, ILLEGAL}) protected Value vectorArray1;
 81     @Temp({REG, ILLEGAL}) protected Value vectorArray2;
 82     @Temp({REG, ILLEGAL}) protected Value vectorArray3;
 83     @Temp({REG, ILLEGAL}) protected Value vectorArray4;
 84 
<a name="12" id="anc12"></a><span class="line-modified"> 85     public AMD64ArrayIndexOfOp(JavaKind kind, boolean findTwoConsecutive, int vmPageSize, int maxVectorSize, LIRGeneratorTool tool, Value result, Value arrayPtr, Value arrayLength,</span>
<span class="line-modified"> 86                     Value... searchValues) {</span>
 87         super(TYPE);
<a name="13" id="anc13"></a><span class="line-modified"> 88         this.kind = kind;</span>


 89         this.findTwoConsecutive = findTwoConsecutive;
<a name="14" id="anc14"></a><span class="line-removed"> 90         this.vmPageSize = vmPageSize;</span>
 91         assert 0 &lt; searchValues.length &amp;&amp; searchValues.length &lt;= 4;
<a name="15" id="anc15"></a><span class="line-modified"> 92         assert byteMode(kind) || charMode(kind);</span>
 93         assert supports(tool, CPUFeature.SSE2) || supports(tool, CPUFeature.AVX) || supportsAVX2(tool);
 94         nValues = searchValues.length;
 95         assert !findTwoConsecutive || nValues == 1;
 96         resultValue = result;
 97         arrayPtrValue = arrayPtr;
 98         arrayLengthValue = arrayLength;
<a name="16" id="anc16"></a>
 99         searchValue1 = searchValues[0];
100         searchValue2 = nValues &gt; 1 ? searchValues[1] : Value.ILLEGAL;
101         searchValue3 = nValues &gt; 2 ? searchValues[2] : Value.ILLEGAL;
102         searchValue4 = nValues &gt; 3 ? searchValues[3] : Value.ILLEGAL;
<a name="17" id="anc17"></a><span class="line-modified">103         arraySlotsRemaining = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-modified">104         comparisonResult1 = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-modified">105         comparisonResult2 = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-modified">106         comparisonResult3 = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-removed">107         comparisonResult4 = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-removed">108         vectorKind = supportsAVX2(tool) &amp;&amp; (maxVectorSize &lt; 0 || maxVectorSize &gt;= 32) ? byteMode(kind) ? AMD64Kind.V256_BYTE : AMD64Kind.V256_WORD</span>
<span class="line-removed">109                         : byteMode(kind) ? AMD64Kind.V128_BYTE : AMD64Kind.V128_WORD;</span>
110         vectorCompareVal1 = tool.newVariable(LIRKind.value(vectorKind));
111         vectorCompareVal2 = nValues &gt; 1 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
112         vectorCompareVal3 = nValues &gt; 2 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
113         vectorCompareVal4 = nValues &gt; 3 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
114         vectorArray1 = tool.newVariable(LIRKind.value(vectorKind));
115         vectorArray2 = tool.newVariable(LIRKind.value(vectorKind));
116         vectorArray3 = tool.newVariable(LIRKind.value(vectorKind));
117         vectorArray4 = tool.newVariable(LIRKind.value(vectorKind));
118     }
119 
120     private static boolean byteMode(JavaKind kind) {
121         return kind == JavaKind.Byte;
122     }
123 
124     private static boolean charMode(JavaKind kind) {
125         return kind == JavaKind.Char;
126     }
127 
128     private JavaKind getComparisonKind() {
<a name="18" id="anc18"></a><span class="line-modified">129         return findTwoConsecutive ? (byteMode(kind) ? JavaKind.Char : JavaKind.Int) : kind;</span>
130     }
131 
132     private AVXKind.AVXSize getVectorSize() {
133         return AVXKind.getDataSize(vectorKind);
134     }
135 
136     @Override
137     public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
<a name="19" id="anc19"></a>
138         Register arrayPtr = asRegister(arrayPtrValue);
139         Register arrayLength = asRegister(arrayLengthValue);
<a name="20" id="anc20"></a><span class="line-modified">140         Register result = asRegister(resultValue);</span>
<span class="line-modified">141         Register slotsRemaining = asRegister(arraySlotsRemaining);</span>
<span class="line-modified">142         Register[] searchValue = {</span>
<span class="line-modified">143                         nValues &gt; 0 ? asRegister(searchValue1) : null,</span>
<span class="line-modified">144                         nValues &gt; 1 ? asRegister(searchValue2) : null,</span>
<span class="line-modified">145                         nValues &gt; 2 ? asRegister(searchValue3) : null,</span>
<span class="line-modified">146                         nValues &gt; 3 ? asRegister(searchValue4) : null,</span>
147         };
148         Register[] vecCmp = {
149                         nValues &gt; 0 ? asRegister(vectorCompareVal1) : null,
150                         nValues &gt; 1 ? asRegister(vectorCompareVal2) : null,
151                         nValues &gt; 2 ? asRegister(vectorCompareVal3) : null,
152                         nValues &gt; 3 ? asRegister(vectorCompareVal4) : null,
153         };
154         Register[] vecArray = {
155                         asRegister(vectorArray1),
156                         asRegister(vectorArray2),
157                         asRegister(vectorArray3),
158                         asRegister(vectorArray4),
159         };
160         Register[] cmpResult = {
161                         asRegister(comparisonResult1),
<a name="21" id="anc21"></a><span class="line-modified">162                         asRegister(comparisonResult2),</span>
<span class="line-removed">163                         asRegister(comparisonResult3),</span>
<span class="line-removed">164                         asRegister(comparisonResult4),</span>
165         };
<a name="22" id="anc22"></a><span class="line-modified">166         Label retFound = new Label();</span>
<span class="line-removed">167         Label retNotFound = new Label();</span>
<span class="line-removed">168         Label end = new Label();</span>
<span class="line-removed">169 </span>
<span class="line-removed">170         // load array length</span>
<span class="line-removed">171         // important: this must be the first register manipulation, since arrayLengthValue is</span>
<span class="line-removed">172         // annotated with @Use</span>
<span class="line-removed">173         asm.movl(slotsRemaining, arrayLength);</span>
<span class="line-removed">174         // load array pointer</span>
<span class="line-removed">175         asm.movq(result, arrayPtr);</span>
<span class="line-removed">176         // move search values to vectors</span>
<span class="line-removed">177         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-removed">178             if (asm.supports(CPUFeature.AVX)) {</span>
<span class="line-removed">179                 VexMoveOp.VMOVD.emit(asm, AVXKind.AVXSize.DWORD, vecCmp[i], searchValue[i]);</span>
<span class="line-removed">180             } else {</span>
<span class="line-removed">181                 asm.movdl(vecCmp[i], searchValue[i]);</span>
<span class="line-removed">182             }</span>
<span class="line-removed">183         }</span>
<span class="line-removed">184         // fill comparison vector with copies of the search value</span>
<span class="line-removed">185         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-removed">186             emitBroadcast(asm, getComparisonKind(), vecCmp[i], vecArray[0], getVectorSize());</span>
<span class="line-removed">187         }</span>
<span class="line-removed">188 </span>
<span class="line-removed">189         emitArrayIndexOfChars(crb, asm, result, slotsRemaining, searchValue, vecCmp, vecArray, cmpResult, retFound, retNotFound);</span>
<span class="line-removed">190 </span>
<span class="line-removed">191         // return -1 (no match)</span>
<span class="line-removed">192         asm.bind(retNotFound);</span>
<span class="line-removed">193         asm.movq(result, -1);</span>
<span class="line-removed">194         asm.jmpb(end);</span>
<span class="line-removed">195 </span>
<span class="line-removed">196         asm.bind(retFound);</span>
<span class="line-removed">197         // convert array pointer to offset</span>
<span class="line-removed">198         asm.subq(result, arrayPtr);</span>
<span class="line-removed">199         if (charMode(kind)) {</span>
<span class="line-removed">200             asm.shrq(result, 1);</span>
<span class="line-removed">201         }</span>
<span class="line-removed">202         asm.bind(end);</span>
<span class="line-removed">203     }</span>
<span class="line-removed">204 </span>
<span class="line-removed">205     private void emitArrayIndexOfChars(CompilationResultBuilder crb, AMD64MacroAssembler asm,</span>
<span class="line-removed">206                     Register arrayPtr,</span>
<span class="line-removed">207                     Register slotsRemaining,</span>
<span class="line-removed">208                     Register[] searchValue,</span>
<span class="line-removed">209                     Register[] vecCmp,</span>
<span class="line-removed">210                     Register[] vecArray,</span>
<span class="line-removed">211                     Register[] cmpResult,</span>
<span class="line-removed">212                     Label retFound,</span>
<span class="line-removed">213                     Label retNotFound) {</span>
<span class="line-removed">214         int nVectors = nValues == 1 ? 4 : nValues == 2 ? 2 : 1;</span>
<span class="line-removed">215         AVXKind.AVXSize vectorSize = getVectorSize();</span>
216 
217         Label bulkVectorLoop = new Label();
218         Label singleVectorLoop = new Label();
219         Label[] vectorFound = {
220                         new Label(),
221                         new Label(),
222                         new Label(),
223                         new Label(),
224         };
<a name="23" id="anc23"></a><span class="line-modified">225         Label lessThanVectorSizeRemaining = new Label();</span>
<span class="line-modified">226         Label lessThanVectorSizeRemainingLoop = new Label();</span>
<span class="line-modified">227         Label bulkVectorLoopExit = nVectors == 1 ? lessThanVectorSizeRemaining : singleVectorLoop;</span>
<span class="line-modified">228         int bytesPerVector = vectorSize.getBytes();</span>
<span class="line-modified">229         int arraySlotsPerVector = vectorSize.getBytes() / kind.getByteCount();</span>
<span class="line-modified">230         int singleVectorLoopCondition = arraySlotsPerVector;</span>
<span class="line-modified">231         int bulkSize = arraySlotsPerVector * nVectors;</span>
<span class="line-modified">232         int bulkSizeBytes = bytesPerVector * nVectors;</span>
<span class="line-removed">233         int bulkLoopCondition = bulkSize;</span>
<span class="line-removed">234         int[] vectorOffsets;</span>
<span class="line-removed">235         JavaKind vectorCompareKind = kind;</span>
236         if (findTwoConsecutive) {
<a name="24" id="anc24"></a><span class="line-removed">237             singleVectorLoopCondition++;</span>
<span class="line-removed">238             bulkLoopCondition++;</span>
239             bulkSize /= 2;
<a name="25" id="anc25"></a><span class="line-modified">240             bulkSizeBytes /= 2;</span>
<span class="line-modified">241             vectorOffsets = new int[]{0, kind.getByteCount(), bytesPerVector, bytesPerVector + kind.getByteCount()};</span>
<span class="line-modified">242             vectorCompareKind = byteMode(kind) ? JavaKind.Char : JavaKind.Int;</span>


























































243         } else {
<a name="26" id="anc26"></a><span class="line-modified">244             vectorOffsets = new int[]{0, bytesPerVector, bytesPerVector * 2, bytesPerVector * 3};</span>




















245         }
<a name="27" id="anc27"></a>





246 
<a name="28" id="anc28"></a><span class="line-removed">247         // load copy of low part of array pointer</span>
<span class="line-removed">248         Register tmpArrayPtrLow = cmpResult[0];</span>
<span class="line-removed">249         asm.movl(tmpArrayPtrLow, arrayPtr);</span>
<span class="line-removed">250 </span>
<span class="line-removed">251         // check if bulk vector load is in bounds</span>
<span class="line-removed">252         asm.cmpl(slotsRemaining, bulkLoopCondition);</span>
<span class="line-removed">253         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);</span>
<span class="line-removed">254 </span>
<span class="line-removed">255         // check if array pointer is aligned to bulkSize</span>
<span class="line-removed">256         asm.andl(tmpArrayPtrLow, bulkSizeBytes - 1);</span>
<span class="line-removed">257         asm.jcc(AMD64Assembler.ConditionFlag.Zero, bulkVectorLoop);</span>
<span class="line-removed">258 </span>
<span class="line-removed">259         // do one unaligned bulk comparison pass and adjust alignment afterwards</span>
<span class="line-removed">260         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, nVectors, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, false);</span>
<span class="line-removed">261         // load copy of low part of array pointer</span>
<span class="line-removed">262         asm.movl(tmpArrayPtrLow, arrayPtr);</span>
<span class="line-removed">263         // adjust array pointer</span>
<span class="line-removed">264         asm.addq(arrayPtr, bulkSizeBytes);</span>
<span class="line-removed">265         // adjust number of array slots remaining</span>
<span class="line-removed">266         asm.subl(slotsRemaining, bulkSize);</span>
<span class="line-removed">267         // get offset to bulk size alignment</span>
<span class="line-removed">268         asm.andl(tmpArrayPtrLow, bulkSizeBytes - 1);</span>
<span class="line-removed">269         emitBytesToArraySlots(asm, kind, tmpArrayPtrLow);</span>
<span class="line-removed">270         // adjust array pointer to bulk size alignment</span>
<span class="line-removed">271         asm.andq(arrayPtr, ~(bulkSizeBytes - 1));</span>
<span class="line-removed">272         // adjust number of array slots remaining</span>
<span class="line-removed">273         asm.addl(slotsRemaining, tmpArrayPtrLow);</span>
274         // check if there are enough array slots remaining for the bulk loop
<a name="29" id="anc29"></a><span class="line-modified">275         asm.cmpl(slotsRemaining, bulkLoopCondition);</span>
<span class="line-modified">276         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);</span>
277 
278         emitAlign(crb, asm);
279         asm.bind(bulkVectorLoop);
280         // memory-aligned bulk comparison
<a name="30" id="anc30"></a><span class="line-modified">281         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, nVectors, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, !findTwoConsecutive);</span>
<span class="line-modified">282         // adjust number of array slots remaining</span>
<span class="line-modified">283         asm.subl(slotsRemaining, bulkSize);</span>
<span class="line-removed">284         // adjust array pointer</span>
<span class="line-removed">285         asm.addq(arrayPtr, bulkSizeBytes);</span>
286         // check if there are enough array slots remaining for the bulk loop
<a name="31" id="anc31"></a><span class="line-modified">287         asm.cmpl(slotsRemaining, bulkLoopCondition);</span>
<span class="line-modified">288         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);</span>
<span class="line-removed">289         // continue loop</span>
<span class="line-removed">290         asm.jmp(bulkVectorLoop);</span>
291 
<a name="32" id="anc32"></a><span class="line-modified">292         if (nVectors &gt; 1) {</span>








293             emitAlign(crb, asm);
294             // same loop as bulkVectorLoop, with only one vector
295             asm.bind(singleVectorLoop);
<a name="33" id="anc33"></a><span class="line-modified">296             // check if single vector load is in bounds</span>
<span class="line-modified">297             asm.cmpl(slotsRemaining, singleVectorLoopCondition);</span>
<span class="line-modified">298             asm.jcc(AMD64Assembler.ConditionFlag.Below, lessThanVectorSizeRemaining);</span>



299             // compare
<a name="34" id="anc34"></a><span class="line-modified">300             emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, findTwoConsecutive ? 2 : 1, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, false);</span>
<span class="line-modified">301             // adjust number of array slots remaining</span>
<span class="line-modified">302             asm.subl(slotsRemaining, arraySlotsPerVector);</span>
<span class="line-modified">303             // adjust array pointer</span>
<span class="line-removed">304             asm.addq(arrayPtr, bytesPerVector);</span>
<span class="line-removed">305             // continue loop</span>
<span class="line-removed">306             asm.jmpb(singleVectorLoop);</span>
307         }
308 
<a name="35" id="anc35"></a><span class="line-modified">309         asm.bind(lessThanVectorSizeRemaining);</span>
<span class="line-modified">310         // check if any array slots remain</span>
<span class="line-modified">311         asm.testl(slotsRemaining, slotsRemaining);</span>
<span class="line-removed">312         asm.jcc(AMD64Assembler.ConditionFlag.Zero, retNotFound);</span>
<span class="line-removed">313 </span>
<span class="line-removed">314         // a vector compare will read out of bounds of the input array.</span>
<span class="line-removed">315         // check if the out-of-bounds read would cross a memory page boundary.</span>
<span class="line-removed">316         // load copy of low part of array pointer</span>
<span class="line-removed">317         asm.movl(tmpArrayPtrLow, arrayPtr);</span>
<span class="line-removed">318         // check if pointer + vector size would cross the page boundary</span>
<span class="line-removed">319         asm.andl(tmpArrayPtrLow, (vmPageSize - 1));</span>
<span class="line-removed">320         asm.cmpl(tmpArrayPtrLow, (vmPageSize - (findTwoConsecutive ? bytesPerVector + kind.getByteCount() : bytesPerVector)));</span>
<span class="line-removed">321         // if the page boundary would be crossed, do byte/character-wise comparison instead.</span>
<span class="line-removed">322         asm.jccb(AMD64Assembler.ConditionFlag.Above, lessThanVectorSizeRemainingLoop);</span>
<span class="line-removed">323 </span>
<span class="line-removed">324         Label[] overBoundsMatch = {new Label(), new Label()};</span>
<span class="line-removed">325         // otherwise, do a vector compare that reads beyond array bounds</span>
<span class="line-removed">326         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, findTwoConsecutive ? 2 : 1, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, overBoundsMatch, false);</span>
<span class="line-removed">327         // no match</span>
<span class="line-removed">328         asm.jmp(retNotFound);</span>
329         if (findTwoConsecutive) {
<a name="36" id="anc36"></a><span class="line-modified">330             Label overBoundsFinish = new Label();</span>
<span class="line-removed">331             asm.bind(overBoundsMatch[1]);</span>
<span class="line-removed">332             // get match offset of second result</span>
<span class="line-removed">333             asm.bsfq(cmpResult[1], cmpResult[1]);</span>
<span class="line-removed">334             asm.addl(cmpResult[1], kind.getByteCount());</span>
<span class="line-removed">335             // replace first result with second and continue</span>
<span class="line-removed">336             asm.movl(cmpResult[0], cmpResult[1]);</span>
<span class="line-removed">337             asm.jmpb(overBoundsFinish);</span>
338 
<a name="37" id="anc37"></a><span class="line-modified">339             asm.bind(overBoundsMatch[0]);</span>
<span class="line-modified">340             emitFindTwoCharPrefixMinResult(asm, kind, cmpResult, overBoundsFinish);</span>
<span class="line-modified">341         } else {</span>
<span class="line-modified">342             asm.bind(overBoundsMatch[0]);</span>
<span class="line-modified">343             // find match offset</span>






344             asm.bsfq(cmpResult[0], cmpResult[0]);
<a name="38" id="anc38"></a><span class="line-modified">345         }</span>

















346 
<a name="39" id="anc39"></a><span class="line-modified">347         // adjust array pointer for match result</span>
<span class="line-modified">348         asm.addq(arrayPtr, cmpResult[0]);</span>
<span class="line-modified">349         if (charMode(kind)) {</span>
<span class="line-removed">350             // convert byte offset to chars</span>
<span class="line-removed">351             asm.shrl(cmpResult[0], 1);</span>
<span class="line-removed">352         }</span>
<span class="line-removed">353         // check if offset of matched value is greater than number of bytes remaining / out of array</span>
<span class="line-removed">354         // bounds</span>
<span class="line-removed">355         if (findTwoConsecutive) {</span>
<span class="line-removed">356             asm.decrementl(slotsRemaining);</span>
<span class="line-removed">357         }</span>
<span class="line-removed">358         asm.cmpl(cmpResult[0], slotsRemaining);</span>
<span class="line-removed">359         // match is out of bounds, return no match</span>
<span class="line-removed">360         asm.jcc(AMD64Assembler.ConditionFlag.GreaterEqual, retNotFound);</span>
<span class="line-removed">361         // adjust number of array slots remaining</span>
<span class="line-removed">362         if (findTwoConsecutive) {</span>
<span class="line-removed">363             asm.incrementl(slotsRemaining, 1);</span>
<span class="line-removed">364         }</span>
<span class="line-removed">365         asm.subl(slotsRemaining, cmpResult[0]);</span>
<span class="line-removed">366         // match is in bounds, return offset</span>
<span class="line-removed">367         asm.jmp(retFound);</span>
368 
<a name="40" id="anc40"></a><span class="line-modified">369         // compare remaining slots in the array one-by-one</span>
<span class="line-modified">370         asm.bind(lessThanVectorSizeRemainingLoop);</span>
<span class="line-modified">371         // check if enough array slots remain</span>
<span class="line-modified">372         asm.cmpl(slotsRemaining, findTwoConsecutive ? 1 : 0);</span>
<span class="line-modified">373         asm.jcc(AMD64Assembler.ConditionFlag.LessEqual, retNotFound);</span>
<span class="line-modified">374         // load char / byte</span>
<span class="line-modified">375         if (byteMode(kind)) {</span>
<span class="line-modified">376             if (findTwoConsecutive) {</span>
<span class="line-modified">377                 asm.movzwl(cmpResult[0], new AMD64Address(arrayPtr));</span>
<span class="line-modified">378             } else {</span>
<span class="line-modified">379                 asm.movzbl(cmpResult[0], new AMD64Address(arrayPtr));</span>





380             }
<a name="41" id="anc41"></a>

381         } else {
<a name="42" id="anc42"></a><span class="line-modified">382             if (findTwoConsecutive) {</span>
<span class="line-modified">383                 asm.movl(cmpResult[0], new AMD64Address(arrayPtr));</span>
<span class="line-modified">384             } else {</span>
<span class="line-modified">385                 asm.movzwl(cmpResult[0], new AMD64Address(arrayPtr));</span>




386             }
<a name="43" id="anc43"></a>








387         }
<a name="44" id="anc44"></a><span class="line-modified">388         // check for match</span>



389         for (int i = 0; i &lt; nValues; i++) {
<a name="45" id="anc45"></a><span class="line-modified">390             emitCompareInst(asm, getComparisonKind(), cmpResult[0], searchValue[i]);</span>
<span class="line-modified">391             asm.jcc(AMD64Assembler.ConditionFlag.Equal, retFound);</span>

392         }
<a name="46" id="anc46"></a><span class="line-modified">393         // adjust number of array slots remaining</span>
<span class="line-modified">394         asm.decrementl(slotsRemaining);</span>
<span class="line-removed">395         // adjust array pointer</span>
<span class="line-removed">396         asm.addq(arrayPtr, kind.getByteCount());</span>
<span class="line-removed">397         // continue loop</span>
<span class="line-removed">398         asm.jmpb(lessThanVectorSizeRemainingLoop);</span>
399 
<a name="47" id="anc47"></a><span class="line-modified">400         for (int i = 1; i &lt; nVectors; i += (findTwoConsecutive ? 2 : 1)) {</span>
<span class="line-modified">401             emitVectorFoundWithOffset(asm, kind, vectorOffsets[i], arrayPtr, cmpResult[i], slotsRemaining, vectorFound[i], retFound);</span>
<span class="line-modified">402         }</span>
403 
<a name="48" id="anc48"></a><span class="line-modified">404         if (findTwoConsecutive) {</span>
<span class="line-modified">405             asm.bind(vectorFound[2]);</span>
<span class="line-modified">406             asm.addq(arrayPtr, vectorOffsets[2]);</span>
<span class="line-modified">407             // adjust number of array slots remaining</span>
<span class="line-modified">408             asm.subl(slotsRemaining, charMode(kind) ? vectorOffsets[2] / 2 : vectorOffsets[2]);</span>
<span class="line-modified">409             asm.movl(cmpResult[0], cmpResult[2]);</span>
<span class="line-modified">410             asm.movl(cmpResult[1], cmpResult[3]);</span>
<span class="line-modified">411             asm.bind(vectorFound[0]);</span>
<span class="line-removed">412             emitFindTwoCharPrefixMinResult(asm, kind, cmpResult, new Label());</span>
413         } else {
<a name="49" id="anc49"></a><span class="line-modified">414             asm.bind(vectorFound[0]);</span>
<span class="line-removed">415             // find index of first set bit in bit mask</span>
<span class="line-removed">416             asm.bsfq(cmpResult[0], cmpResult[0]);</span>
417         }
<a name="50" id="anc50"></a><span class="line-modified">418         // add offset to array pointer</span>
<span class="line-modified">419         asm.addq(arrayPtr, cmpResult[0]);</span>
<span class="line-modified">420         if (charMode(kind)) {</span>
<span class="line-modified">421             // convert byte offset to chars</span>
<span class="line-modified">422             asm.shrl(cmpResult[0], 1);</span>
<span class="line-modified">423         }</span>
<span class="line-removed">424         // adjust number of array slots remaining</span>
<span class="line-removed">425         asm.subl(slotsRemaining, cmpResult[0]);</span>
<span class="line-removed">426         asm.jmpb(retFound);</span>
427     }
428 
<a name="51" id="anc51"></a><span class="line-modified">429     private static void emitFindTwoCharPrefixMinResult(AMD64MacroAssembler asm, JavaKind kind, Register[] cmpResult, Label done) {</span>
<span class="line-modified">430         // find match offset</span>
<span class="line-modified">431         asm.bsfq(cmpResult[0], cmpResult[0]);</span>
<span class="line-modified">432         // check if second result is also a match</span>
<span class="line-modified">433         asm.testl(cmpResult[1], cmpResult[1]);</span>
<span class="line-modified">434         asm.jcc(AMD64Assembler.ConditionFlag.Zero, done);</span>
<span class="line-modified">435         // get match offset of second result</span>
<span class="line-modified">436         asm.bsfq(cmpResult[1], cmpResult[1]);</span>
<span class="line-modified">437         asm.addl(cmpResult[1], kind.getByteCount());</span>
<span class="line-modified">438         // check if first result is less than second</span>
<span class="line-modified">439         asm.cmpl(cmpResult[0], cmpResult[1]);</span>
<span class="line-modified">440         asm.jcc(AMD64Assembler.ConditionFlag.LessEqual, done);</span>
<span class="line-modified">441         // first result is greater than second, replace it with the second result</span>
<span class="line-modified">442         asm.movl(cmpResult[0], cmpResult[1]);</span>
<span class="line-modified">443         asm.bind(done);</span>
444     }
445 
446     private static void emitAlign(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
447         asm.align(crb.target.wordSize * 2);
448     }
449 
450     /**
451      * Fills {@code vecDst} with copies of its lowest byte, word or dword.
452      */
453     private static void emitBroadcast(AMD64MacroAssembler asm, JavaKind kind, Register vecDst, Register vecTmp, AVXKind.AVXSize vectorSize) {
454         switch (kind) {
455             case Byte:
456                 if (asm.supports(CPUFeature.AVX2)) {
457                     VexRMOp.VPBROADCASTB.emit(asm, vectorSize, vecDst, vecDst);
458                 } else if (asm.supports(CPUFeature.AVX)) {
459                     VexRVMOp.VPXOR.emit(asm, vectorSize, vecTmp, vecTmp, vecTmp);
460                     VexRVMOp.VPSHUFB.emit(asm, vectorSize, vecDst, vecDst, vecTmp);
461                 } else if (asm.supports(CPUFeature.SSSE3)) {
462                     asm.pxor(vecTmp, vecTmp);
463                     asm.pshufb(vecDst, vecTmp);
464                 } else { // SSE2
465                     asm.punpcklbw(vecDst, vecDst);
466                     asm.punpcklbw(vecDst, vecDst);
467                     asm.pshufd(vecDst, vecDst, 0);
468                 }
469                 break;
470             case Short:
471             case Char:
472                 if (asm.supports(CPUFeature.AVX2)) {
473                     VexRMOp.VPBROADCASTW.emit(asm, vectorSize, vecDst, vecDst);
474                 } else if (asm.supports(CPUFeature.AVX)) {
475                     VexRMIOp.VPSHUFLW.emit(asm, vectorSize, vecDst, vecDst, 0);
476                     VexRMIOp.VPSHUFD.emit(asm, vectorSize, vecDst, vecDst, 0);
477                 } else { // SSE
478                     asm.pshuflw(vecDst, vecDst, 0);
479                     asm.pshufd(vecDst, vecDst, 0);
480                 }
481                 break;
482             case Int:
483                 if (asm.supports(CPUFeature.AVX2)) {
484                     VexRMOp.VPBROADCASTD.emit(asm, vectorSize, vecDst, vecDst);
485                 } else if (asm.supports(CPUFeature.AVX)) {
486                     VexRMIOp.VPSHUFD.emit(asm, vectorSize, vecDst, vecDst, 0);
487                 } else { // SSE
488                     asm.pshufd(vecDst, vecDst, 0);
489                 }
490                 break;
491             default:
492                 throw new UnsupportedOperationException();
493         }
494     }
495 
<a name="52" id="anc52"></a><span class="line-modified">496     /**</span>
<span class="line-removed">497      * Convert a byte offset stored in {@code bytes} to an array index offset.</span>
<span class="line-removed">498      */</span>
<span class="line-removed">499     private static void emitBytesToArraySlots(AMD64MacroAssembler asm, JavaKind kind, Register bytes) {</span>
<span class="line-removed">500         if (charMode(kind)) {</span>
<span class="line-removed">501             asm.shrl(bytes, 1);</span>
<span class="line-removed">502         } else {</span>
<span class="line-removed">503             assert byteMode(kind);</span>
<span class="line-removed">504         }</span>
<span class="line-removed">505     }</span>
<span class="line-removed">506 </span>
<span class="line-removed">507     private static void emitVectorCompare(AMD64MacroAssembler asm,</span>
508                     JavaKind kind,
<a name="53" id="anc53"></a><span class="line-removed">509                     AVXKind.AVXSize vectorSize,</span>
<span class="line-removed">510                     int nValues,</span>
511                     int nVectors,
<a name="54" id="anc54"></a><span class="line-removed">512                     int[] vectorOffsets,</span>
513                     Register arrayPtr,
<a name="55" id="anc55"></a>
514                     Register[] vecCmp,
515                     Register[] vecArray,
516                     Register[] cmpResult,
517                     Label[] vectorFound,
<a name="56" id="anc56"></a>
518                     boolean alignedLoad) {
519         // load array contents into vectors
<a name="57" id="anc57"></a><span class="line-modified">520         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-modified">521             for (int j = 0; j &lt; nVectors; j++) {</span>
<span class="line-modified">522                 emitArrayLoad(asm, vectorSize, vecArray[(i * nVectors) + j], arrayPtr, vectorOffsets[j], alignedLoad);</span>

523             }
524         }
525         // compare all loaded bytes to the search value.
526         // matching bytes are set to 0xff, non-matching bytes are set to 0x00.
<a name="58" id="anc58"></a><span class="line-modified">527         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-removed">528             for (int j = 0; j &lt; nVectors; j++) {</span>
<span class="line-removed">529                 emitVectorCompareInst(asm, kind, vectorSize, vecArray[(i * nVectors) + j], vecCmp[i]);</span>
<span class="line-removed">530             }</span>
<span class="line-removed">531         }</span>
<span class="line-removed">532         // create 32-bit-masks from the most significant bit of every byte in the comparison</span>
<span class="line-removed">533         // results.</span>
<span class="line-removed">534         for (int i = 0; i &lt; nValues * nVectors; i++) {</span>
<span class="line-removed">535             emitMOVMSK(asm, vectorSize, cmpResult[i], vecArray[i]);</span>
<span class="line-removed">536         }</span>
<span class="line-removed">537         // join results of comparisons against multiple values</span>
<span class="line-removed">538         for (int stride = 1; stride &lt; nValues; stride *= 2) {</span>
539             for (int i = 0; i &lt; nVectors; i++) {
<a name="59" id="anc59"></a><span class="line-modified">540                 for (int j = 0; j + stride &lt; nValues; j += stride * 2) {</span>
<span class="line-modified">541                     asm.orl(cmpResult[i + (j * nVectors)], cmpResult[i + ((j + stride) * nVectors)]);</span>







542                 }
<a name="60" id="anc60"></a>










543             }
<a name="61" id="anc61"></a><span class="line-removed">544         }</span>
<span class="line-removed">545         // check if a match was found</span>
<span class="line-removed">546         for (int i = 0; i &lt; nVectors; i++) {</span>
<span class="line-removed">547             asm.testl(cmpResult[i], cmpResult[i]);</span>
<span class="line-removed">548             asm.jcc(AMD64Assembler.ConditionFlag.NotZero, vectorFound[i]);</span>
549         }
550     }
551 
<a name="62" id="anc62"></a><span class="line-modified">552     private static void emitVectorFoundWithOffset(AMD64MacroAssembler asm,</span>
<span class="line-modified">553                     JavaKind kind,</span>
<span class="line-modified">554                     int resultOffset,</span>
<span class="line-modified">555                     Register result,</span>
<span class="line-modified">556                     Register cmpResult,</span>
<span class="line-modified">557                     Register slotsRemaining,</span>
<span class="line-removed">558                     Label entry,</span>
<span class="line-removed">559                     Label ret) {</span>
<span class="line-removed">560         asm.bind(entry);</span>
<span class="line-removed">561         if (resultOffset &gt; 0) {</span>
<span class="line-removed">562             // adjust array pointer</span>
<span class="line-removed">563             asm.addq(result, resultOffset);</span>
<span class="line-removed">564             // adjust number of array slots remaining</span>
<span class="line-removed">565             asm.subl(slotsRemaining, charMode(kind) ? resultOffset / 2 : resultOffset);</span>
<span class="line-removed">566         }</span>
<span class="line-removed">567         // find index of first set bit in bit mask</span>
<span class="line-removed">568         asm.bsfq(cmpResult, cmpResult);</span>
<span class="line-removed">569         // add offset to array pointer</span>
<span class="line-removed">570         asm.addq(result, cmpResult);</span>
<span class="line-removed">571         if (charMode(kind)) {</span>
<span class="line-removed">572             // convert byte offset to chars</span>
<span class="line-removed">573             asm.shrl(cmpResult, 1);</span>
574         }
<a name="63" id="anc63"></a><span class="line-removed">575         // adjust number of array slots remaining</span>
<span class="line-removed">576         asm.subl(slotsRemaining, cmpResult);</span>
<span class="line-removed">577         asm.jmpb(ret);</span>
578     }
579 
<a name="64" id="anc64"></a><span class="line-modified">580     private static void emitArrayLoad(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register vecDst, Register arrayPtr, int offset, boolean alignedLoad) {</span>
<span class="line-modified">581         AMD64Address src = new AMD64Address(arrayPtr, offset);</span>
582         if (asm.supports(CPUFeature.AVX)) {
<a name="65" id="anc65"></a><span class="line-modified">583             VexMoveOp loadOp = alignedLoad ? VexMoveOp.VMOVDQA : VexMoveOp.VMOVDQU;</span>
584             loadOp.emit(asm, vectorSize, vecDst, src);
585         } else {
586             // SSE
587             asm.movdqu(vecDst, src);
588         }
589     }
590 
591     /**
592      * Compares all packed bytes/words/dwords in {@code vecArray} to {@code vecCmp}. Matching values
593      * are set to all ones (0xff, 0xffff, ...), non-matching values are set to zero.
594      */
595     private static void emitVectorCompareInst(AMD64MacroAssembler asm, JavaKind kind, AVXKind.AVXSize vectorSize, Register vecArray, Register vecCmp) {
596         switch (kind) {
597             case Byte:
598                 if (asm.supports(CPUFeature.AVX)) {
599                     VexRVMOp.VPCMPEQB.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
600                 } else { // SSE
601                     asm.pcmpeqb(vecArray, vecCmp);
602                 }
603                 break;
604             case Short:
605             case Char:
606                 if (asm.supports(CPUFeature.AVX)) {
607                     VexRVMOp.VPCMPEQW.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
608                 } else { // SSE
609                     asm.pcmpeqw(vecArray, vecCmp);
610                 }
611                 break;
612             case Int:
613                 if (asm.supports(CPUFeature.AVX)) {
614                     VexRVMOp.VPCMPEQD.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
615                 } else { // SSE
616                     asm.pcmpeqd(vecArray, vecCmp);
617                 }
618                 break;
619             default:
620                 throw new UnsupportedOperationException();
621         }
622     }
623 
<a name="66" id="anc66"></a>








624     private static void emitMOVMSK(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register dst, Register vecSrc) {
625         if (asm.supports(CPUFeature.AVX)) {
626             VexRMOp.VPMOVMSKB.emit(asm, vectorSize, dst, vecSrc);
627         } else {
628             // SSE
629             asm.pmovmskb(dst, vecSrc);
630         }
631     }
632 
<a name="67" id="anc67"></a><span class="line-modified">633     private static void emitCompareInst(AMD64MacroAssembler asm, JavaKind kind, Register dst, Register src) {</span>
634         switch (kind) {
635             case Byte:
<a name="68" id="anc68"></a><span class="line-modified">636                 asm.cmpb(dst, src);</span>
<span class="line-removed">637                 break;</span>
638             case Short:
639             case Char:
<a name="69" id="anc69"></a><span class="line-modified">640                 asm.cmpw(dst, src);</span>
<span class="line-removed">641                 break;</span>
642             case Int:
<a name="70" id="anc70"></a><span class="line-modified">643                 asm.cmpl(dst, src);</span>
<span class="line-removed">644                 break;</span>
645             default:
<a name="71" id="anc71"></a><span class="line-modified">646                 asm.cmpq(dst, src);</span>
647         }
648     }
649 
650     private static boolean supportsAVX2(LIRGeneratorTool tool) {
651         return supports(tool, CPUFeature.AVX2);
652     }
653 
654     private static boolean supports(LIRGeneratorTool tool, CPUFeature cpuFeature) {
655         return ((AMD64) tool.target().arch).getFeatures().contains(cpuFeature);
656     }
<a name="72" id="anc72"></a>




657 }
<a name="73" id="anc73"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="73" type="hidden" />
</body>
</html>
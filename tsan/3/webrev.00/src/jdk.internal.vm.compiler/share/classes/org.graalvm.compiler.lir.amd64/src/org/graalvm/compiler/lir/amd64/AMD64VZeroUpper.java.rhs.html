<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64VZeroUpper.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.amd64;
 26 
 27 import static jdk.vm.ci.code.ValueUtil.asRegister;
 28 import static jdk.vm.ci.code.ValueUtil.isRegister;
 29 
<a name="2" id="anc2"></a><span class="line-added"> 30 import java.util.ArrayList;</span>
 31 import java.util.BitSet;
 32 
 33 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 34 import org.graalvm.compiler.lir.LIRInstructionClass;
<a name="3" id="anc3"></a><span class="line-added"> 35 import org.graalvm.compiler.lir.amd64.AMD64Call.ForeignCallOp;</span>
<span class="line-added"> 36 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorInstruction;</span>
 37 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 38 
 39 import jdk.vm.ci.amd64.AMD64;
 40 import jdk.vm.ci.code.Register;
<a name="4" id="anc4"></a><span class="line-added"> 41 import jdk.vm.ci.code.RegisterConfig;</span>
 42 import jdk.vm.ci.code.RegisterValue;
 43 import jdk.vm.ci.meta.Value;
 44 
<a name="5" id="anc5"></a><span class="line-added"> 45 /**</span>
<span class="line-added"> 46  * vzeroupper is essential to avoid performance penalty during SSE-AVX transition. Specifically,</span>
<span class="line-added"> 47  * once we have executed instructions that modify the upper bits (i.e., 128+) of the YMM registers,</span>
<span class="line-added"> 48  * we need to perform vzeroupper to transit the state to 128bits before executing any SSE</span>
<span class="line-added"> 49  * instructions. We don&#39;t need to place vzeroupper between VEX-encoded SSE instructions and legacy</span>
<span class="line-added"> 50  * SSE instructions, nor between AVX instructions and VEX-encoded SSE instructions.</span>
<span class="line-added"> 51  *</span>
<span class="line-added"> 52  * When running Graal on HotSpot, we emit a vzeroupper LIR operation (i.e. an instance of this</span>
<span class="line-added"> 53  * class) before a foreign call to the runtime function where Graal has no knowledge. The underlying</span>
<span class="line-added"> 54  * reason is that HotSpot is SSE-compiled so as to support older CPUs. We also emit a vzeroupper</span>
<span class="line-added"> 55  * instruction (see {@code AMD64HotSpotReturnOp.emitCode}) upon returning, if the current LIR graph</span>
<span class="line-added"> 56  * contains LIR operations that touch the upper bits of the YMM registers, including but not limited</span>
<span class="line-added"> 57  * to {@link AMD64VectorInstruction}, {@link AMD64ArrayCompareToOp}, {@link AMD64ArrayEqualsOp},</span>
<span class="line-added"> 58  * {@link AMD64ArrayIndexOfOp}, and {@link ForeignCallOp} that invokes to Graal-compiled stubs. For</span>
<span class="line-added"> 59  * the last case, since Graal-compiled stubs is under our control, we don&#39;t emit vzeroupper upon</span>
<span class="line-added"> 60  * returning of the stub, but rather do that upon returning of the current method.</span>
<span class="line-added"> 61  *</span>
<span class="line-added"> 62  * On JDK8, C2 does not emit many vzeroupper instructions, potentially because that YMM registers</span>
<span class="line-added"> 63  * are not heavily employed (C2 vectorization starts using YMM registers in 9, source</span>
<span class="line-added"> 64  * https://cr.openjdk.java.net/~vlivanov/talks/2017_Vectorization_in_HotSpot_JVM.pdf) and thus less</span>
<span class="line-added"> 65  * care has been taken to place these instructions. One example is that many intrinsics employ YMM</span>
<span class="line-added"> 66  * registers starting from https://bugs.openjdk.java.net/browse/JDK-8005419, but does not properly</span>
<span class="line-added"> 67  * place vzeroupper upon returning of the intrinsic stub or the caller of the stub.</span>
<span class="line-added"> 68  *</span>
<span class="line-added"> 69  * Most vzeroupper were added in JDK 10 (https://bugs.openjdk.java.net/browse/JDK-8178811), and was</span>
<span class="line-added"> 70  * later restricted on Haswell Xeon due to performance regression</span>
<span class="line-added"> 71  * (https://bugs.openjdk.java.net/browse/JDK-8190934). The actual condition for placing vzeroupper</span>
<span class="line-added"> 72  * is at http://hg.openjdk.java.net/jdk/jdk/file/c7d9df2e470c/src/hotspot/cpu/x86/x86_64.ad#l428. To</span>
<span class="line-added"> 73  * summarize, if nmethod employs YMM registers (or intrinsics which use them, search for</span>
<span class="line-added"> 74  * clear_upper_avx() in opto/library_call.cpp) vzeroupper will be generated on nmethod&#39;s exit and</span>
<span class="line-added"> 75  * before any calls in nmethod, because even compiled nmethods can still use only SSE instructions.</span>
<span class="line-added"> 76  *</span>
<span class="line-added"> 77  * This means, if a Java method performs a call to an intrinsic that employs YMM registers,</span>
<span class="line-added"> 78  * C2-compiled code will place a vzeroupper before the call, upon exit of the stub and upon exit of</span>
<span class="line-added"> 79  * this method. Graal will only place the last, because it ensures that Graal-compiled Java method</span>
<span class="line-added"> 80  * and stubs will be consistent on using VEX-encoding.</span>
<span class="line-added"> 81  *</span>
<span class="line-added"> 82  * In SubstrateVM, since the whole image is compiled consistently with or without VEX encoding (the</span>
<span class="line-added"> 83  * later is the default behavior, see {@code NativeImageGenerator.createTarget}), there is no need</span>
<span class="line-added"> 84  * for vzeroupper. For dynamic compilation on a SubstrateVM image, if the image is SSE-compiled, we</span>
<span class="line-added"> 85  * then need vzeroupper when returning from the dynamic compiled code to the pre-built image code.</span>
<span class="line-added"> 86  */</span>
 87 public class AMD64VZeroUpper extends AMD64LIRInstruction {
 88 
 89     public static final LIRInstructionClass&lt;AMD64VZeroUpper&gt; TYPE = LIRInstructionClass.create(AMD64VZeroUpper.class);
 90 
 91     @Temp protected final RegisterValue[] xmmRegisters;
 92 
<a name="6" id="anc6"></a><span class="line-modified"> 93     public AMD64VZeroUpper(Value[] exclude, RegisterConfig registerConfig) {</span>
 94         super(TYPE);
<a name="7" id="anc7"></a><span class="line-modified"> 95         xmmRegisters = initRegisterValues(exclude, registerConfig);</span>
 96     }
 97 
<a name="8" id="anc8"></a><span class="line-modified"> 98     private static RegisterValue[] initRegisterValues(Value[] exclude, RegisterConfig registerConfig) {</span>
 99         BitSet skippedRegs = new BitSet();
<a name="9" id="anc9"></a>
100         if (exclude != null) {
101             for (Value value : exclude) {
102                 if (isRegister(value) &amp;&amp; asRegister(value).getRegisterCategory().equals(AMD64.XMM)) {
103                     skippedRegs.set(asRegister(value).number);
<a name="10" id="anc10"></a>
104                 }
105             }
106         }
<a name="11" id="anc11"></a><span class="line-modified">107         ArrayList&lt;RegisterValue&gt; regs = new ArrayList&lt;&gt;();</span>
<span class="line-modified">108         for (Register r : registerConfig.getCallerSaveRegisters()) {</span>
<span class="line-modified">109             if (r.getRegisterCategory().equals(AMD64.XMM) &amp;&amp; !skippedRegs.get(r.number)) {</span>
<span class="line-modified">110                 regs.add(r.asValue());</span>

111             }
112         }
<a name="12" id="anc12"></a><span class="line-modified">113         return regs.toArray(new RegisterValue[regs.size()]);</span>
114     }
115 
116     @Override
117     public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
118         asm.vzeroupper();
119     }
120 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayIndexOfOp.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.amd64;
 26 
<a name="2" id="anc2"></a><span class="line-modified"> 27 import static jdk.vm.ci.code.ValueUtil.asRegister;</span>
<span class="line-modified"> 28 import static jdk.vm.ci.code.ValueUtil.isRegister;</span>
<span class="line-modified"> 29 import static jdk.vm.ci.code.ValueUtil.isStackSlot;</span>
<span class="line-modified"> 30 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.CONST;</span>
<span class="line-modified"> 31 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
<span class="line-modified"> 32 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;</span>
<span class="line-added"> 33 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;</span>
<span class="line-added"> 34 </span>
<span class="line-added"> 35 import java.util.Objects;</span>
<span class="line-added"> 36 </span>
 37 import org.graalvm.compiler.asm.Label;
 38 import org.graalvm.compiler.asm.amd64.AMD64Address;
<a name="3" id="anc3"></a><span class="line-added"> 39 import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;</span>
 40 import org.graalvm.compiler.asm.amd64.AMD64Assembler;
<a name="4" id="anc4"></a><span class="line-added"> 41 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;</span>
 42 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMoveOp;
 43 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMIOp;
 44 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMOp;
 45 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp;
<a name="5" id="anc5"></a><span class="line-added"> 46 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;</span>
 47 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 48 import org.graalvm.compiler.asm.amd64.AVXKind;
 49 import org.graalvm.compiler.core.common.LIRKind;
<a name="6" id="anc6"></a><span class="line-added"> 50 import org.graalvm.compiler.core.common.NumUtil;</span>
<span class="line-added"> 51 import org.graalvm.compiler.lir.ConstantValue;</span>
 52 import org.graalvm.compiler.lir.LIRInstructionClass;
 53 import org.graalvm.compiler.lir.Opcode;
 54 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 55 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 56 
<a name="7" id="anc7"></a><span class="line-modified"> 57 import jdk.vm.ci.amd64.AMD64;</span>
<span class="line-modified"> 58 import jdk.vm.ci.amd64.AMD64.CPUFeature;</span>
<span class="line-modified"> 59 import jdk.vm.ci.amd64.AMD64Kind;</span>
<span class="line-added"> 60 import jdk.vm.ci.code.Register;</span>
<span class="line-added"> 61 import jdk.vm.ci.meta.JavaConstant;</span>
<span class="line-added"> 62 import jdk.vm.ci.meta.JavaKind;</span>
<span class="line-added"> 63 import jdk.vm.ci.meta.Value;</span>
 64 
 65 /**
 66  */
 67 @Opcode(&quot;AMD64_ARRAY_INDEX_OF&quot;)
 68 public final class AMD64ArrayIndexOfOp extends AMD64LIRInstruction {
 69     public static final LIRInstructionClass&lt;AMD64ArrayIndexOfOp&gt; TYPE = LIRInstructionClass.create(AMD64ArrayIndexOfOp.class);
 70 
<a name="8" id="anc8"></a><span class="line-modified"> 71     private final JavaKind valueKind;</span>

 72     private final int nValues;
 73     private final boolean findTwoConsecutive;
 74     private final AMD64Kind vectorKind;
<a name="9" id="anc9"></a><span class="line-added"> 75     private final int arrayBaseOffset;</span>
<span class="line-added"> 76     private final Scale arrayIndexScale;</span>
 77 
 78     @Def({REG}) protected Value resultValue;
 79     @Alive({REG}) protected Value arrayPtrValue;
<a name="10" id="anc10"></a><span class="line-modified"> 80     @Alive({REG}) protected Value arrayLengthValue;</span>
<span class="line-modified"> 81     @Use({REG}) protected Value fromIndexValue;</span>
<span class="line-modified"> 82     @Alive({REG, STACK, CONST}) protected Value searchValue1;</span>
<span class="line-modified"> 83     @Alive({REG, STACK, CONST, ILLEGAL}) protected Value searchValue2;</span>
<span class="line-modified"> 84     @Alive({REG, STACK, CONST, ILLEGAL}) protected Value searchValue3;</span>
<span class="line-modified"> 85     @Alive({REG, STACK, CONST, ILLEGAL}) protected Value searchValue4;</span>
 86     @Temp({REG}) protected Value comparisonResult1;
<a name="11" id="anc11"></a><span class="line-modified"> 87     @Temp({REG, ILLEGAL}) protected Value comparisonResult2;</span>


 88     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal1;
 89     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal2;
 90     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal3;
 91     @Temp({REG, ILLEGAL}) protected Value vectorCompareVal4;
 92     @Temp({REG, ILLEGAL}) protected Value vectorArray1;
 93     @Temp({REG, ILLEGAL}) protected Value vectorArray2;
 94     @Temp({REG, ILLEGAL}) protected Value vectorArray3;
 95     @Temp({REG, ILLEGAL}) protected Value vectorArray4;
 96 
<a name="12" id="anc12"></a><span class="line-modified"> 97     public AMD64ArrayIndexOfOp(JavaKind arrayKind, JavaKind valueKind, boolean findTwoConsecutive, int maxVectorSize, LIRGeneratorTool tool,</span>
<span class="line-modified"> 98                     Value result, Value arrayPtr, Value arrayLength, Value fromIndex, Value... searchValues) {</span>
 99         super(TYPE);
<a name="13" id="anc13"></a><span class="line-modified">100         this.valueKind = valueKind;</span>
<span class="line-added">101         this.arrayBaseOffset = tool.getProviders().getMetaAccess().getArrayBaseOffset(arrayKind);</span>
<span class="line-added">102         this.arrayIndexScale = Objects.requireNonNull(Scale.fromInt(tool.getProviders().getMetaAccess().getArrayIndexScale(valueKind)));</span>
103         this.findTwoConsecutive = findTwoConsecutive;
<a name="14" id="anc14"></a>
104         assert 0 &lt; searchValues.length &amp;&amp; searchValues.length &lt;= 4;
<a name="15" id="anc15"></a><span class="line-modified">105         assert byteMode(valueKind) || charMode(valueKind);</span>
106         assert supports(tool, CPUFeature.SSE2) || supports(tool, CPUFeature.AVX) || supportsAVX2(tool);
107         nValues = searchValues.length;
108         assert !findTwoConsecutive || nValues == 1;
109         resultValue = result;
110         arrayPtrValue = arrayPtr;
111         arrayLengthValue = arrayLength;
<a name="16" id="anc16"></a><span class="line-added">112         fromIndexValue = fromIndex;</span>
113         searchValue1 = searchValues[0];
114         searchValue2 = nValues &gt; 1 ? searchValues[1] : Value.ILLEGAL;
115         searchValue3 = nValues &gt; 2 ? searchValues[2] : Value.ILLEGAL;
116         searchValue4 = nValues &gt; 3 ? searchValues[3] : Value.ILLEGAL;
<a name="17" id="anc17"></a><span class="line-modified">117         comparisonResult1 = tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));</span>
<span class="line-modified">118         comparisonResult2 = findTwoConsecutive ? tool.newVariable(LIRKind.value(tool.target().arch.getWordKind())) : Value.ILLEGAL;</span>
<span class="line-modified">119         vectorKind = supportsAVX2(tool) &amp;&amp; (maxVectorSize &lt; 0 || maxVectorSize &gt;= 32) ? byteMode(valueKind) ? AMD64Kind.V256_BYTE : AMD64Kind.V256_WORD</span>
<span class="line-modified">120                         : byteMode(valueKind) ? AMD64Kind.V128_BYTE : AMD64Kind.V128_WORD;</span>



121         vectorCompareVal1 = tool.newVariable(LIRKind.value(vectorKind));
122         vectorCompareVal2 = nValues &gt; 1 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
123         vectorCompareVal3 = nValues &gt; 2 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
124         vectorCompareVal4 = nValues &gt; 3 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
125         vectorArray1 = tool.newVariable(LIRKind.value(vectorKind));
126         vectorArray2 = tool.newVariable(LIRKind.value(vectorKind));
127         vectorArray3 = tool.newVariable(LIRKind.value(vectorKind));
128         vectorArray4 = tool.newVariable(LIRKind.value(vectorKind));
129     }
130 
131     private static boolean byteMode(JavaKind kind) {
132         return kind == JavaKind.Byte;
133     }
134 
135     private static boolean charMode(JavaKind kind) {
136         return kind == JavaKind.Char;
137     }
138 
139     private JavaKind getComparisonKind() {
<a name="18" id="anc18"></a><span class="line-modified">140         return findTwoConsecutive ? (byteMode(valueKind) ? JavaKind.Char : JavaKind.Int) : valueKind;</span>
141     }
142 
143     private AVXKind.AVXSize getVectorSize() {
144         return AVXKind.getDataSize(vectorKind);
145     }
146 
147     @Override
148     public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
<a name="19" id="anc19"></a><span class="line-added">149         int nVectors = nValues == 1 ? 4 : nValues == 2 ? 2 : 1;</span>
150         Register arrayPtr = asRegister(arrayPtrValue);
151         Register arrayLength = asRegister(arrayLengthValue);
<a name="20" id="anc20"></a><span class="line-modified">152         Register fromIndex = asRegister(fromIndexValue);</span>
<span class="line-modified">153         Register index = asRegister(resultValue);</span>
<span class="line-modified">154         Value[] searchValue = {</span>
<span class="line-modified">155                         nValues &gt; 0 ? searchValue1 : null,</span>
<span class="line-modified">156                         nValues &gt; 1 ? searchValue2 : null,</span>
<span class="line-modified">157                         nValues &gt; 2 ? searchValue3 : null,</span>
<span class="line-modified">158                         nValues &gt; 3 ? searchValue4 : null,</span>
159         };
160         Register[] vecCmp = {
161                         nValues &gt; 0 ? asRegister(vectorCompareVal1) : null,
162                         nValues &gt; 1 ? asRegister(vectorCompareVal2) : null,
163                         nValues &gt; 2 ? asRegister(vectorCompareVal3) : null,
164                         nValues &gt; 3 ? asRegister(vectorCompareVal4) : null,
165         };
166         Register[] vecArray = {
167                         asRegister(vectorArray1),
168                         asRegister(vectorArray2),
169                         asRegister(vectorArray3),
170                         asRegister(vectorArray4),
171         };
172         Register[] cmpResult = {
173                         asRegister(comparisonResult1),
<a name="21" id="anc21"></a><span class="line-modified">174                         findTwoConsecutive ? asRegister(comparisonResult2) : null,</span>


175         };
<a name="22" id="anc22"></a><span class="line-modified">176         Label ret = new Label();</span>

















































177 
178         Label bulkVectorLoop = new Label();
179         Label singleVectorLoop = new Label();
180         Label[] vectorFound = {
181                         new Label(),
182                         new Label(),
183                         new Label(),
184                         new Label(),
185         };
<a name="23" id="anc23"></a><span class="line-modified">186         Label runVectorized = new Label();</span>
<span class="line-modified">187         Label elementWiseLoop = new Label();</span>
<span class="line-modified">188         Label elementWiseFound = new Label();</span>
<span class="line-modified">189         Label elementWiseNotFound = new Label();</span>
<span class="line-modified">190         Label skipBulkVectorLoop = new Label();</span>
<span class="line-modified">191         int vectorSize = getVectorSize().getBytes() / valueKind.getByteCount();</span>
<span class="line-modified">192         int bulkSize = vectorSize * nVectors;</span>
<span class="line-modified">193         JavaKind vectorCompareKind = valueKind;</span>



194         if (findTwoConsecutive) {
<a name="24" id="anc24"></a>

195             bulkSize /= 2;
<a name="25" id="anc25"></a><span class="line-modified">196             vectorCompareKind = byteMode(valueKind) ? JavaKind.Char : JavaKind.Int;</span>
<span class="line-modified">197         }</span>
<span class="line-modified">198         // index = fromIndex + vectorSize (+1 if findTwoConsecutive)</span>
<span class="line-added">199         // important: this must be the first register manipulation, since fromIndex is</span>
<span class="line-added">200         // annotated with @Use</span>
<span class="line-added">201         asm.leaq(index, new AMD64Address(fromIndex, vectorSize + (findTwoConsecutive ? 1 : 0)));</span>
<span class="line-added">202 </span>
<span class="line-added">203         // check if vector vector load is in bounds</span>
<span class="line-added">204         asm.cmpq(index, arrayLength);</span>
<span class="line-added">205         asm.jccb(AMD64Assembler.ConditionFlag.LessEqual, runVectorized);</span>
<span class="line-added">206 </span>
<span class="line-added">207         // search range is smaller than vector size, do element-wise comparison</span>
<span class="line-added">208 </span>
<span class="line-added">209         // index = fromIndex (+ 1 if findTwoConsecutive)</span>
<span class="line-added">210         asm.subq(index, vectorSize);</span>
<span class="line-added">211         // check if enough array slots remain</span>
<span class="line-added">212         asm.cmpq(index, arrayLength);</span>
<span class="line-added">213         asm.jccb(AMD64Assembler.ConditionFlag.GreaterEqual, elementWiseNotFound);</span>
<span class="line-added">214         // compare one-by-one</span>
<span class="line-added">215         asm.bind(elementWiseLoop);</span>
<span class="line-added">216         // check for match</span>
<span class="line-added">217         OperandSize cmpSize = getOpSize(getComparisonKind());</span>
<span class="line-added">218         // address = findTwoConsecutive ? array[index - 1] : array[index]</span>
<span class="line-added">219         AMD64Address arrayAddr = new AMD64Address(arrayPtr, index, arrayIndexScale, arrayBaseOffset - (findTwoConsecutive ? valueKind.getByteCount() : 0));</span>
<span class="line-added">220         boolean valuesOnStack = searchValuesOnStack(searchValue);</span>
<span class="line-added">221         if (valuesOnStack) {</span>
<span class="line-added">222             (cmpSize == OperandSize.BYTE ? AMD64RMOp.MOVB : AMD64RMOp.MOV).emit(asm, cmpSize, cmpResult[0], arrayAddr);</span>
<span class="line-added">223             for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-added">224                 if (isConstant(searchValue[i])) {</span>
<span class="line-added">225                     int imm = asConstant(searchValue[i]).asInt();</span>
<span class="line-added">226                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getMIOpcode(cmpSize, NumUtil.isByte(imm)).emit(asm, cmpSize, cmpResult[0], imm);</span>
<span class="line-added">227                 } else if (isStackSlot(searchValue[i])) {</span>
<span class="line-added">228                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getRMOpcode(cmpSize).emit(asm, cmpSize, cmpResult[0], (AMD64Address) crb.asAddress(searchValue[i]));</span>
<span class="line-added">229                 } else {</span>
<span class="line-added">230                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getRMOpcode(cmpSize).emit(asm, cmpSize, cmpResult[0], asRegister(searchValue[i]));</span>
<span class="line-added">231                 }</span>
<span class="line-added">232                 asm.jccb(AMD64Assembler.ConditionFlag.Equal, elementWiseFound);</span>
<span class="line-added">233             }</span>
<span class="line-added">234         } else {</span>
<span class="line-added">235             for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-added">236                 if (isConstant(searchValue[i])) {</span>
<span class="line-added">237                     int imm = asConstant(searchValue[i]).asInt();</span>
<span class="line-added">238                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getMIOpcode(cmpSize, NumUtil.isByte(imm)).emit(asm, cmpSize, arrayAddr, imm);</span>
<span class="line-added">239                 } else {</span>
<span class="line-added">240                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getRMOpcode(cmpSize).emit(asm, cmpSize, asRegister(searchValue[i]), arrayAddr);</span>
<span class="line-added">241                 }</span>
<span class="line-added">242                 asm.jccb(AMD64Assembler.ConditionFlag.Equal, elementWiseFound);</span>
<span class="line-added">243             }</span>
<span class="line-added">244         }</span>
<span class="line-added">245         // adjust index</span>
<span class="line-added">246         asm.incrementq(index, 1);</span>
<span class="line-added">247         // continue loop</span>
<span class="line-added">248         asm.cmpq(index, arrayLength);</span>
<span class="line-added">249         asm.jccb(AMD64Assembler.ConditionFlag.Less, elementWiseLoop);</span>
<span class="line-added">250 </span>
<span class="line-added">251         asm.bind(elementWiseNotFound);</span>
<span class="line-added">252         asm.xorq(index, index);</span>
<span class="line-added">253 </span>
<span class="line-added">254         if (findTwoConsecutive) {</span>
<span class="line-added">255             asm.bind(elementWiseFound);</span>
<span class="line-added">256             asm.decrementq(index, 1);</span>
257         } else {
<a name="26" id="anc26"></a><span class="line-modified">258             asm.decrementq(index, 1);</span>
<span class="line-added">259             asm.bind(elementWiseFound);</span>
<span class="line-added">260         }</span>
<span class="line-added">261         asm.jmp(ret);</span>
<span class="line-added">262 </span>
<span class="line-added">263         // vectorized implementation</span>
<span class="line-added">264         asm.bind(runVectorized);</span>
<span class="line-added">265 </span>
<span class="line-added">266         // move search values to vectors</span>
<span class="line-added">267         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-added">268             // fill comparison vector with copies of the search value</span>
<span class="line-added">269             broadcastSearchValue(crb, asm, vecCmp[i], searchValue[i], cmpResult[0], vecArray[0]);</span>
<span class="line-added">270         }</span>
<span class="line-added">271 </span>
<span class="line-added">272         // do one unaligned vector comparison pass and adjust alignment afterwards</span>
<span class="line-added">273         emitVectorCompare(asm, vectorCompareKind, findTwoConsecutive ? 2 : 1, arrayPtr, index, vecCmp, vecArray, cmpResult, vectorFound, false, false);</span>
<span class="line-added">274 </span>
<span class="line-added">275         // adjust index to vector size alignment</span>
<span class="line-added">276         asm.leaq(cmpResult[0], new AMD64Address(arrayPtr, arrayBaseOffset));</span>
<span class="line-added">277         if (charMode(valueKind)) {</span>
<span class="line-added">278             asm.shrq(cmpResult[0], 1);</span>
279         }
<a name="27" id="anc27"></a><span class="line-added">280         asm.addq(index, cmpResult[0]);</span>
<span class="line-added">281         // adjust to next lower multiple of vector size</span>
<span class="line-added">282         asm.andq(index, ~(vectorSize - 1));</span>
<span class="line-added">283         asm.subq(index, cmpResult[0]);</span>
<span class="line-added">284         // add bulk size</span>
<span class="line-added">285         asm.addq(index, bulkSize);</span>
286 
<a name="28" id="anc28"></a>


























287         // check if there are enough array slots remaining for the bulk loop
<a name="29" id="anc29"></a><span class="line-modified">288         asm.cmpq(index, arrayLength);</span>
<span class="line-modified">289         asm.jccb(AMD64Assembler.ConditionFlag.Greater, skipBulkVectorLoop);</span>
290 
291         emitAlign(crb, asm);
292         asm.bind(bulkVectorLoop);
293         // memory-aligned bulk comparison
<a name="30" id="anc30"></a><span class="line-modified">294         emitVectorCompare(asm, vectorCompareKind, nVectors, arrayPtr, index, vecCmp, vecArray, cmpResult, vectorFound, false, !findTwoConsecutive);</span>
<span class="line-modified">295         // adjust index</span>
<span class="line-modified">296         asm.addq(index, bulkSize);</span>


297         // check if there are enough array slots remaining for the bulk loop
<a name="31" id="anc31"></a><span class="line-modified">298         asm.cmpq(index, arrayLength);</span>
<span class="line-modified">299         asm.jccb(AMD64Assembler.ConditionFlag.LessEqual, bulkVectorLoop);</span>


300 
<a name="32" id="anc32"></a><span class="line-modified">301         asm.bind(skipBulkVectorLoop);</span>
<span class="line-added">302         if ((findTwoConsecutive &amp;&amp; nVectors == 2) || nVectors == 1) {</span>
<span class="line-added">303             // do last load from end of array</span>
<span class="line-added">304             asm.movq(index, arrayLength);</span>
<span class="line-added">305             // compare</span>
<span class="line-added">306             emitVectorCompare(asm, vectorCompareKind, findTwoConsecutive ? 2 : 1, arrayPtr, index, vecCmp, vecArray, cmpResult, vectorFound, true, false);</span>
<span class="line-added">307         } else {</span>
<span class="line-added">308             // remove bulk offset</span>
<span class="line-added">309             asm.subq(index, bulkSize);</span>
310             emitAlign(crb, asm);
311             // same loop as bulkVectorLoop, with only one vector
312             asm.bind(singleVectorLoop);
<a name="33" id="anc33"></a><span class="line-modified">313             // add vector size</span>
<span class="line-modified">314             asm.addq(index, vectorSize);</span>
<span class="line-modified">315             // check if vector load is in bounds</span>
<span class="line-added">316             asm.cmpq(index, arrayLength);</span>
<span class="line-added">317             // if load would be over bounds, set the load to the end of the array</span>
<span class="line-added">318             asm.cmovq(AMD64Assembler.ConditionFlag.Greater, index, arrayLength);</span>
319             // compare
<a name="34" id="anc34"></a><span class="line-modified">320             emitVectorCompare(asm, vectorCompareKind, findTwoConsecutive ? 2 : 1, arrayPtr, index, vecCmp, vecArray, cmpResult, vectorFound, true, false);</span>
<span class="line-modified">321             // check if there are enough array slots remaining for the loop</span>
<span class="line-modified">322             asm.cmpq(index, arrayLength);</span>
<span class="line-modified">323             asm.jccb(AMD64Assembler.ConditionFlag.Less, singleVectorLoop);</span>



324         }
325 
<a name="35" id="anc35"></a><span class="line-modified">326         asm.movl(index, -1);</span>
<span class="line-modified">327         asm.jmpb(ret);</span>
<span class="line-modified">328 </span>

















329         if (findTwoConsecutive) {
<a name="36" id="anc36"></a><span class="line-modified">330             Label vectorFound2Done = new Label();</span>







331 
<a name="37" id="anc37"></a><span class="line-modified">332             // vectorFound[0] and vectorFound[2] behave like the single-char case</span>
<span class="line-modified">333             asm.bind(vectorFound[2]);</span>
<span class="line-modified">334             // add static offset</span>
<span class="line-modified">335             asm.subq(index, getResultIndexDelta(2));</span>
<span class="line-modified">336             asm.jmpb(vectorFound2Done);</span>
<span class="line-added">337 </span>
<span class="line-added">338             asm.bind(vectorFound[0]);</span>
<span class="line-added">339             // add static offset</span>
<span class="line-added">340             asm.subq(index, getResultIndexDelta(0));</span>
<span class="line-added">341             asm.bind(vectorFound2Done);</span>
<span class="line-added">342             // find offset</span>
343             asm.bsfq(cmpResult[0], cmpResult[0]);
<a name="38" id="anc38"></a><span class="line-modified">344             if (charMode(valueKind)) {</span>
<span class="line-added">345                 // convert byte offset to chars</span>
<span class="line-added">346                 asm.shrl(cmpResult[0], 1);</span>
<span class="line-added">347             }</span>
<span class="line-added">348             // add offset to index</span>
<span class="line-added">349             asm.addq(index, cmpResult[0]);</span>
<span class="line-added">350             asm.jmpb(ret);</span>
<span class="line-added">351 </span>
<span class="line-added">352             Label minResult = new Label();</span>
<span class="line-added">353             Label minResultDone = new Label();</span>
<span class="line-added">354 </span>
<span class="line-added">355             // in vectorFound[1] and vectorFound[3], we have to check the results 0 and 2 as well</span>
<span class="line-added">356             if (nVectors &gt; 2) {</span>
<span class="line-added">357                 asm.bind(vectorFound[3]);</span>
<span class="line-added">358                 // add offset</span>
<span class="line-added">359                 asm.subq(index, getResultIndexDelta(3));</span>
<span class="line-added">360                 asm.jmpb(minResult);</span>
<span class="line-added">361             }</span>
362 
<a name="39" id="anc39"></a><span class="line-modified">363             asm.bind(vectorFound[1]);</span>
<span class="line-modified">364             // add offset</span>
<span class="line-modified">365             asm.subq(index, getResultIndexDelta(1));</span>


















366 
<a name="40" id="anc40"></a><span class="line-modified">367             asm.bind(minResult);</span>
<span class="line-modified">368             // find offset 0</span>
<span class="line-modified">369             asm.bsfq(cmpResult[1], cmpResult[1]);</span>
<span class="line-modified">370             // check if second result is also a match</span>
<span class="line-modified">371             asm.testq(cmpResult[0], cmpResult[0]);</span>
<span class="line-modified">372             asm.jccb(AMD64Assembler.ConditionFlag.Zero, minResultDone);</span>
<span class="line-modified">373             // find offset 1</span>
<span class="line-modified">374             asm.bsfq(cmpResult[0], cmpResult[0]);</span>
<span class="line-modified">375             asm.addq(cmpResult[0], valueKind.getByteCount());</span>
<span class="line-modified">376             // if first result is greater than second, replace it with the second result</span>
<span class="line-modified">377             asm.cmpq(cmpResult[1], cmpResult[0]);</span>
<span class="line-added">378             asm.cmovq(AMD64Assembler.ConditionFlag.Greater, cmpResult[1], cmpResult[0]);</span>
<span class="line-added">379             asm.bind(minResultDone);</span>
<span class="line-added">380             if (charMode(valueKind)) {</span>
<span class="line-added">381                 // convert byte offset to chars</span>
<span class="line-added">382                 asm.shrl(cmpResult[1], 1);</span>
383             }
<a name="41" id="anc41"></a><span class="line-added">384             // add offset to index</span>
<span class="line-added">385             asm.addq(index, cmpResult[1]);</span>
386         } else {
<a name="42" id="anc42"></a><span class="line-modified">387             Label end = new Label();</span>
<span class="line-modified">388             for (int i = 0; i &lt; nVectors; i++) {</span>
<span class="line-modified">389                 asm.bind(vectorFound[i]);</span>
<span class="line-modified">390                 // add static offset</span>
<span class="line-added">391                 asm.subq(index, getResultIndexDelta(i));</span>
<span class="line-added">392                 if (i &lt; nVectors - 1) {</span>
<span class="line-added">393                     asm.jmpb(end);</span>
<span class="line-added">394                 }</span>
395             }
<a name="43" id="anc43"></a><span class="line-added">396             asm.bind(end);</span>
<span class="line-added">397             // find offset</span>
<span class="line-added">398             asm.bsfq(cmpResult[0], cmpResult[0]);</span>
<span class="line-added">399             if (charMode(valueKind)) {</span>
<span class="line-added">400                 // convert byte offset to chars</span>
<span class="line-added">401                 asm.shrl(cmpResult[0], 1);</span>
<span class="line-added">402             }</span>
<span class="line-added">403             // add offset to index</span>
<span class="line-added">404             asm.addq(index, cmpResult[0]);</span>
405         }
<a name="44" id="anc44"></a><span class="line-modified">406         asm.bind(ret);</span>
<span class="line-added">407     }</span>
<span class="line-added">408 </span>
<span class="line-added">409     private boolean searchValuesOnStack(Value[] searchValue) {</span>
410         for (int i = 0; i &lt; nValues; i++) {
<a name="45" id="anc45"></a><span class="line-modified">411             if (isStackSlot(searchValue[i])) {</span>
<span class="line-modified">412                 return true;</span>
<span class="line-added">413             }</span>
414         }
<a name="46" id="anc46"></a><span class="line-modified">415         return false;</span>
<span class="line-modified">416     }</span>




417 
<a name="47" id="anc47"></a><span class="line-modified">418     private int getResultIndexDelta(int i) {</span>
<span class="line-modified">419         return (((findTwoConsecutive ? i / 2 : i) + 1) * (getVectorSize().getBytes() / valueKind.getByteCount())) + (findTwoConsecutive ? (i &amp; 1) : 0);</span>
<span class="line-modified">420     }</span>
421 
<a name="48" id="anc48"></a><span class="line-modified">422     private int getVectorOffset(int i) {</span>
<span class="line-modified">423         return arrayBaseOffset - getResultIndexDelta(i) * valueKind.getByteCount();</span>
<span class="line-modified">424     }</span>
<span class="line-modified">425 </span>
<span class="line-modified">426     private void broadcastSearchValue(CompilationResultBuilder crb, AMD64MacroAssembler asm, Register dst, Value srcVal, Register tmpReg, Register tmpVector) {</span>
<span class="line-modified">427         Register src = asRegOrTmpReg(crb, asm, srcVal, tmpReg);</span>
<span class="line-modified">428         if (asm.supports(CPUFeature.AVX)) {</span>
<span class="line-modified">429             VexMoveOp.VMOVD.emit(asm, AVXKind.AVXSize.DWORD, dst, src);</span>

430         } else {
<a name="49" id="anc49"></a><span class="line-modified">431             asm.movdl(dst, src);</span>


432         }
<a name="50" id="anc50"></a><span class="line-modified">433         emitBroadcast(asm, getComparisonKind(), dst, tmpVector, getVectorSize());</span>
<span class="line-modified">434     }</span>
<span class="line-modified">435 </span>
<span class="line-modified">436     private static boolean isConstant(Value val) {</span>
<span class="line-modified">437         assert !(val instanceof ConstantValue) || ((ConstantValue) val).isJavaConstant();</span>
<span class="line-modified">438         return val instanceof ConstantValue;</span>



439     }
440 
<a name="51" id="anc51"></a><span class="line-modified">441     private static JavaConstant asConstant(Value val) {</span>
<span class="line-modified">442         return ((ConstantValue) val).getJavaConstant();</span>
<span class="line-modified">443     }</span>
<span class="line-modified">444 </span>
<span class="line-modified">445     private static Register asRegOrTmpReg(CompilationResultBuilder crb, AMD64MacroAssembler asm, Value val, Register tmpReg) {</span>
<span class="line-modified">446         if (isRegister(val)) {</span>
<span class="line-modified">447             return asRegister(val);</span>
<span class="line-modified">448         } else if (isStackSlot(val)) {</span>
<span class="line-modified">449             asm.movl(tmpReg, (AMD64Address) crb.asAddress(val));</span>
<span class="line-modified">450             return tmpReg;</span>
<span class="line-modified">451         } else {</span>
<span class="line-modified">452             assert isConstant(val);</span>
<span class="line-modified">453             asm.movl(tmpReg, asConstant(val).asInt());</span>
<span class="line-modified">454             return tmpReg;</span>
<span class="line-modified">455         }</span>
456     }
457 
458     private static void emitAlign(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
459         asm.align(crb.target.wordSize * 2);
460     }
461 
462     /**
463      * Fills {@code vecDst} with copies of its lowest byte, word or dword.
464      */
465     private static void emitBroadcast(AMD64MacroAssembler asm, JavaKind kind, Register vecDst, Register vecTmp, AVXKind.AVXSize vectorSize) {
466         switch (kind) {
467             case Byte:
468                 if (asm.supports(CPUFeature.AVX2)) {
469                     VexRMOp.VPBROADCASTB.emit(asm, vectorSize, vecDst, vecDst);
470                 } else if (asm.supports(CPUFeature.AVX)) {
471                     VexRVMOp.VPXOR.emit(asm, vectorSize, vecTmp, vecTmp, vecTmp);
472                     VexRVMOp.VPSHUFB.emit(asm, vectorSize, vecDst, vecDst, vecTmp);
473                 } else if (asm.supports(CPUFeature.SSSE3)) {
474                     asm.pxor(vecTmp, vecTmp);
475                     asm.pshufb(vecDst, vecTmp);
476                 } else { // SSE2
477                     asm.punpcklbw(vecDst, vecDst);
478                     asm.punpcklbw(vecDst, vecDst);
479                     asm.pshufd(vecDst, vecDst, 0);
480                 }
481                 break;
482             case Short:
483             case Char:
484                 if (asm.supports(CPUFeature.AVX2)) {
485                     VexRMOp.VPBROADCASTW.emit(asm, vectorSize, vecDst, vecDst);
486                 } else if (asm.supports(CPUFeature.AVX)) {
487                     VexRMIOp.VPSHUFLW.emit(asm, vectorSize, vecDst, vecDst, 0);
488                     VexRMIOp.VPSHUFD.emit(asm, vectorSize, vecDst, vecDst, 0);
489                 } else { // SSE
490                     asm.pshuflw(vecDst, vecDst, 0);
491                     asm.pshufd(vecDst, vecDst, 0);
492                 }
493                 break;
494             case Int:
495                 if (asm.supports(CPUFeature.AVX2)) {
496                     VexRMOp.VPBROADCASTD.emit(asm, vectorSize, vecDst, vecDst);
497                 } else if (asm.supports(CPUFeature.AVX)) {
498                     VexRMIOp.VPSHUFD.emit(asm, vectorSize, vecDst, vecDst, 0);
499                 } else { // SSE
500                     asm.pshufd(vecDst, vecDst, 0);
501                 }
502                 break;
503             default:
504                 throw new UnsupportedOperationException();
505         }
506     }
507 
<a name="52" id="anc52"></a><span class="line-modified">508     private void emitVectorCompare(AMD64MacroAssembler asm,</span>











509                     JavaKind kind,
<a name="53" id="anc53"></a>

510                     int nVectors,
<a name="54" id="anc54"></a>
511                     Register arrayPtr,
<a name="55" id="anc55"></a><span class="line-added">512                     Register index,</span>
513                     Register[] vecCmp,
514                     Register[] vecArray,
515                     Register[] cmpResult,
516                     Label[] vectorFound,
<a name="56" id="anc56"></a><span class="line-added">517                     boolean shortJmp,</span>
518                     boolean alignedLoad) {
519         // load array contents into vectors
<a name="57" id="anc57"></a><span class="line-modified">520         for (int i = 0; i &lt; nVectors; i++) {</span>
<span class="line-modified">521             int base = i * nValues;</span>
<span class="line-modified">522             for (int j = 0; j &lt; nValues; j++) {</span>
<span class="line-added">523                 emitArrayLoad(asm, getVectorSize(), vecArray[base + j], arrayPtr, index, getVectorOffset(nVectors - (i + 1)), alignedLoad);</span>
524             }
525         }
526         // compare all loaded bytes to the search value.
527         // matching bytes are set to 0xff, non-matching bytes are set to 0x00.
<a name="58" id="anc58"></a><span class="line-modified">528         if (!findTwoConsecutive) {</span>











529             for (int i = 0; i &lt; nVectors; i++) {
<a name="59" id="anc59"></a><span class="line-modified">530                 int base = i * nValues;</span>
<span class="line-modified">531                 for (int j = 0; j &lt; nValues; j++) {</span>
<span class="line-added">532                     emitVectorCompareInst(asm, kind, getVectorSize(), vecArray[base + j], vecCmp[j]);</span>
<span class="line-added">533                     if ((j &amp; 1) == 1) {</span>
<span class="line-added">534                         emitPOR(asm, getVectorSize(), vecArray[base + j - 1], vecArray[base + j]);</span>
<span class="line-added">535                     }</span>
<span class="line-added">536                 }</span>
<span class="line-added">537                 if (nValues &gt; 2) {</span>
<span class="line-added">538                     emitPOR(asm, getVectorSize(), vecArray[base], vecArray[base + 2]);</span>
539                 }
<a name="60" id="anc60"></a><span class="line-added">540                 emitMOVMSK(asm, getVectorSize(), cmpResult[0], vecArray[base]);</span>
<span class="line-added">541                 emitJnz(asm, cmpResult[0], vectorFound[nVectors - (i + 1)], shortJmp);</span>
<span class="line-added">542             }</span>
<span class="line-added">543         } else {</span>
<span class="line-added">544             for (int i = 0; i &lt; nVectors; i += 2) {</span>
<span class="line-added">545                 emitVectorCompareInst(asm, kind, getVectorSize(), vecArray[i], vecCmp[0]);</span>
<span class="line-added">546                 emitVectorCompareInst(asm, kind, getVectorSize(), vecArray[i + 1], vecCmp[0]);</span>
<span class="line-added">547                 emitMOVMSK(asm, getVectorSize(), cmpResult[1], vecArray[i]);</span>
<span class="line-added">548                 emitMOVMSK(asm, getVectorSize(), cmpResult[0], vecArray[i + 1]);</span>
<span class="line-added">549                 emitJnz(asm, cmpResult[1], vectorFound[nVectors - (i + 1)], shortJmp);</span>
<span class="line-added">550                 emitJnz(asm, cmpResult[0], vectorFound[nVectors - (i + 2)], shortJmp);</span>
551             }
<a name="61" id="anc61"></a>




552         }
553     }
554 
<a name="62" id="anc62"></a><span class="line-modified">555     private static void emitJnz(AMD64MacroAssembler asm, Register cond, Label tgt, boolean shortJmp) {</span>
<span class="line-modified">556         asm.testl(cond, cond);</span>
<span class="line-modified">557         if (shortJmp) {</span>
<span class="line-modified">558             asm.jccb(AMD64Assembler.ConditionFlag.NotZero, tgt);</span>
<span class="line-modified">559         } else {</span>
<span class="line-modified">560             asm.jcc(AMD64Assembler.ConditionFlag.NotZero, tgt);</span>
















561         }
<a name="63" id="anc63"></a>


562     }
563 
<a name="64" id="anc64"></a><span class="line-modified">564     private void emitArrayLoad(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register vecDst, Register arrayPtr, Register index, int offset, boolean alignedLoad) {</span>
<span class="line-modified">565         AMD64Address src = new AMD64Address(arrayPtr, index, arrayIndexScale, offset);</span>
566         if (asm.supports(CPUFeature.AVX)) {
<a name="65" id="anc65"></a><span class="line-modified">567             VexMoveOp loadOp = alignedLoad ? VexMoveOp.VMOVDQA32 : VexMoveOp.VMOVDQU32;</span>
568             loadOp.emit(asm, vectorSize, vecDst, src);
569         } else {
570             // SSE
571             asm.movdqu(vecDst, src);
572         }
573     }
574 
575     /**
576      * Compares all packed bytes/words/dwords in {@code vecArray} to {@code vecCmp}. Matching values
577      * are set to all ones (0xff, 0xffff, ...), non-matching values are set to zero.
578      */
579     private static void emitVectorCompareInst(AMD64MacroAssembler asm, JavaKind kind, AVXKind.AVXSize vectorSize, Register vecArray, Register vecCmp) {
580         switch (kind) {
581             case Byte:
582                 if (asm.supports(CPUFeature.AVX)) {
583                     VexRVMOp.VPCMPEQB.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
584                 } else { // SSE
585                     asm.pcmpeqb(vecArray, vecCmp);
586                 }
587                 break;
588             case Short:
589             case Char:
590                 if (asm.supports(CPUFeature.AVX)) {
591                     VexRVMOp.VPCMPEQW.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
592                 } else { // SSE
593                     asm.pcmpeqw(vecArray, vecCmp);
594                 }
595                 break;
596             case Int:
597                 if (asm.supports(CPUFeature.AVX)) {
598                     VexRVMOp.VPCMPEQD.emit(asm, vectorSize, vecArray, vecCmp, vecArray);
599                 } else { // SSE
600                     asm.pcmpeqd(vecArray, vecCmp);
601                 }
602                 break;
603             default:
604                 throw new UnsupportedOperationException();
605         }
606     }
607 
<a name="66" id="anc66"></a><span class="line-added">608     private static void emitPOR(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register dst, Register vecSrc) {</span>
<span class="line-added">609         if (asm.supports(CPUFeature.AVX)) {</span>
<span class="line-added">610             VexRVMOp.VPOR.emit(asm, vectorSize, dst, dst, vecSrc);</span>
<span class="line-added">611         } else {</span>
<span class="line-added">612             // SSE</span>
<span class="line-added">613             asm.por(dst, vecSrc);</span>
<span class="line-added">614         }</span>
<span class="line-added">615     }</span>
<span class="line-added">616 </span>
617     private static void emitMOVMSK(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register dst, Register vecSrc) {
618         if (asm.supports(CPUFeature.AVX)) {
619             VexRMOp.VPMOVMSKB.emit(asm, vectorSize, dst, vecSrc);
620         } else {
621             // SSE
622             asm.pmovmskb(dst, vecSrc);
623         }
624     }
625 
<a name="67" id="anc67"></a><span class="line-modified">626     private static OperandSize getOpSize(JavaKind kind) {</span>
627         switch (kind) {
628             case Byte:
<a name="68" id="anc68"></a><span class="line-modified">629                 return OperandSize.BYTE;</span>

630             case Short:
631             case Char:
<a name="69" id="anc69"></a><span class="line-modified">632                 return OperandSize.WORD;</span>

633             case Int:
<a name="70" id="anc70"></a><span class="line-modified">634                 return OperandSize.DWORD;</span>

635             default:
<a name="71" id="anc71"></a><span class="line-modified">636                 return OperandSize.QWORD;</span>
637         }
638     }
639 
640     private static boolean supportsAVX2(LIRGeneratorTool tool) {
641         return supports(tool, CPUFeature.AVX2);
642     }
643 
644     private static boolean supports(LIRGeneratorTool tool, CPUFeature cpuFeature) {
645         return ((AMD64) tool.target().arch).getFeatures().contains(cpuFeature);
646     }
<a name="72" id="anc72"></a><span class="line-added">647 </span>
<span class="line-added">648     @Override</span>
<span class="line-added">649     public boolean needsClearUpperVectorRegisters() {</span>
<span class="line-added">650         return true;</span>
<span class="line-added">651     }</span>
652 }
<a name="73" id="anc73"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="73" type="hidden" />
</body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64StringUTF16CompressOp.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64StringUTF16CompressOp.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64StringUTF16CompressOp.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64StringUTF16CompressOp.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,38 +29,42 @@
 import static jdk.vm.ci.amd64.AMD64.k3;
 import static jdk.vm.ci.amd64.AMD64.rax;
 import static jdk.vm.ci.amd64.AMD64.rdi;
 import static jdk.vm.ci.amd64.AMD64.rdx;
 import static jdk.vm.ci.amd64.AMD64.rsi;
-
 import static jdk.vm.ci.amd64.AMD64.rsp;
 import static jdk.vm.ci.code.ValueUtil.asRegister;
 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
+import static org.graalvm.compiler.lir.amd64.AMD64StringLatin1InflateOp.useAVX512ForStringInflateCompress;
 
-import jdk.vm.ci.amd64.AMD64;
 import org.graalvm.compiler.asm.Label;
 import org.graalvm.compiler.asm.amd64.AMD64Address;
 import org.graalvm.compiler.asm.amd64.AMD64Assembler;
 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 import org.graalvm.compiler.core.common.LIRKind;
 import org.graalvm.compiler.lir.LIRInstructionClass;
 import org.graalvm.compiler.lir.Opcode;
 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 
+import jdk.vm.ci.amd64.AMD64;
 import jdk.vm.ci.amd64.AMD64Kind;
 import jdk.vm.ci.code.Register;
 import jdk.vm.ci.meta.Value;
 
 @Opcode("AMD64_STRING_COMPRESS")
 public final class AMD64StringUTF16CompressOp extends AMD64LIRInstruction {
     public static final LIRInstructionClass<AMD64StringUTF16CompressOp> TYPE = LIRInstructionClass.create(AMD64StringUTF16CompressOp.class);
 
     @Def({REG}) private Value rres;
-    @Alive({REG}) private Value rsrc;
-    @Alive({REG}) private Value rdst;
-    @Alive({REG}) private Value rlen;
+    @Use({REG}) private Value rsrc;
+    @Use({REG}) private Value rdst;
+    @Use({REG}) private Value rlen;
+
+    @Temp({REG}) private Value rsrcTemp;
+    @Temp({REG}) private Value rdstTemp;
+    @Temp({REG}) private Value rlenTemp;
 
     @Temp({REG}) private Value vtmp1;
     @Temp({REG}) private Value vtmp2;
     @Temp({REG}) private Value vtmp3;
     @Temp({REG}) private Value vtmp4;
@@ -73,15 +77,15 @@
         assert asRegister(dst).equals(rdi);
         assert asRegister(len).equals(rdx);
         assert asRegister(res).equals(rax);
 
         rres = res;
-        rsrc = src;
-        rdst = dst;
-        rlen = len;
+        rsrcTemp = rsrc = src;
+        rdstTemp = rdst = dst;
+        rlenTemp = rlen = len;
 
-        LIRKind vkind = LIRKind.value(AMD64Kind.V512_BYTE);
+        LIRKind vkind = useAVX512ForStringInflateCompress(tool.target()) ? LIRKind.value(AMD64Kind.V512_BYTE) : LIRKind.value(AMD64Kind.V128_BYTE);
 
         vtmp1 = tool.newVariable(vkind);
         vtmp2 = tool.newVariable(vkind);
         vtmp3 = tool.newVariable(vkind);
         vtmp4 = tool.newVariable(vkind);
@@ -134,14 +138,11 @@
 
         assert len.number != res.number;
 
         masm.push(len);      // Save length for return.
 
-        if (masm.supports(AMD64.CPUFeature.AVX512BW) &&
-                        masm.supports(AMD64.CPUFeature.AVX512VL) &&
-                        masm.supports(AMD64.CPUFeature.BMI2)) {
-
+        if (useAVX512ForStringInflateCompress(masm.target)) {
             Label labelRestoreK1ReturnZero = new Label();
             Label labelAvxPostAlignment = new Label();
 
             // If the length of the string is less than 32, we chose not to use the
             // AVX512 instructions.
@@ -337,6 +338,10 @@
         masm.addq(rsp, 8 /* wordSize */);
 
         masm.bind(labelDone);
     }
 
+    @Override
+    public boolean needsClearUpperVectorRegisters() {
+        return true;
+    }
 }

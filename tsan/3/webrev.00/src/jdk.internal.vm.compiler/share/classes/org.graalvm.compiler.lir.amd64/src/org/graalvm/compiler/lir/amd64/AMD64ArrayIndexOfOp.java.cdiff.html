<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayIndexOfOp.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64ArrayEqualsOp.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64Binary.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayIndexOfOp.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019 Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,93 ***</span>
   */
  
  
  package org.graalvm.compiler.lir.amd64;
  
<span class="line-modified">! import jdk.vm.ci.amd64.AMD64;</span>
<span class="line-modified">! import jdk.vm.ci.amd64.AMD64.CPUFeature;</span>
<span class="line-modified">! import jdk.vm.ci.amd64.AMD64Kind;</span>
<span class="line-modified">! import jdk.vm.ci.code.Register;</span>
<span class="line-modified">! import jdk.vm.ci.meta.JavaKind;</span>
<span class="line-modified">! import jdk.vm.ci.meta.Value;</span>
  import org.graalvm.compiler.asm.Label;
  import org.graalvm.compiler.asm.amd64.AMD64Address;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMoveOp;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMIOp;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMOp;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp;
  import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
  import org.graalvm.compiler.asm.amd64.AVXKind;
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.lir.LIRInstructionClass;
  import org.graalvm.compiler.lir.Opcode;
  import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
  import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
  
<span class="line-modified">! import static jdk.vm.ci.code.ValueUtil.asRegister;</span>
<span class="line-modified">! import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
<span class="line-modified">! import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;</span>
  
  /**
   */
  @Opcode(&quot;AMD64_ARRAY_INDEX_OF&quot;)
  public final class AMD64ArrayIndexOfOp extends AMD64LIRInstruction {
      public static final LIRInstructionClass&lt;AMD64ArrayIndexOfOp&gt; TYPE = LIRInstructionClass.create(AMD64ArrayIndexOfOp.class);
  
<span class="line-modified">!     private final JavaKind kind;</span>
<span class="line-removed">-     private final int vmPageSize;</span>
      private final int nValues;
      private final boolean findTwoConsecutive;
      private final AMD64Kind vectorKind;
  
      @Def({REG}) protected Value resultValue;
      @Alive({REG}) protected Value arrayPtrValue;
<span class="line-modified">!     @Use({REG}) protected Value arrayLengthValue;</span>
<span class="line-modified">!     @Alive({REG}) protected Value searchValue1;</span>
<span class="line-modified">!     @Alive({REG, ILLEGAL}) protected Value searchValue2;</span>
<span class="line-modified">!     @Alive({REG, ILLEGAL}) protected Value searchValue3;</span>
<span class="line-modified">!     @Alive({REG, ILLEGAL}) protected Value searchValue4;</span>
<span class="line-modified">!     @Temp({REG}) protected Value arraySlotsRemaining;</span>
      @Temp({REG}) protected Value comparisonResult1;
<span class="line-modified">!     @Temp({REG}) protected Value comparisonResult2;</span>
<span class="line-removed">-     @Temp({REG}) protected Value comparisonResult3;</span>
<span class="line-removed">-     @Temp({REG}) protected Value comparisonResult4;</span>
      @Temp({REG, ILLEGAL}) protected Value vectorCompareVal1;
      @Temp({REG, ILLEGAL}) protected Value vectorCompareVal2;
      @Temp({REG, ILLEGAL}) protected Value vectorCompareVal3;
      @Temp({REG, ILLEGAL}) protected Value vectorCompareVal4;
      @Temp({REG, ILLEGAL}) protected Value vectorArray1;
      @Temp({REG, ILLEGAL}) protected Value vectorArray2;
      @Temp({REG, ILLEGAL}) protected Value vectorArray3;
      @Temp({REG, ILLEGAL}) protected Value vectorArray4;
  
<span class="line-modified">!     public AMD64ArrayIndexOfOp(JavaKind kind, boolean findTwoConsecutive, int vmPageSize, int maxVectorSize, LIRGeneratorTool tool, Value result, Value arrayPtr, Value arrayLength,</span>
<span class="line-modified">!                     Value... searchValues) {</span>
          super(TYPE);
<span class="line-modified">!         this.kind = kind;</span>
          this.findTwoConsecutive = findTwoConsecutive;
<span class="line-removed">-         this.vmPageSize = vmPageSize;</span>
          assert 0 &lt; searchValues.length &amp;&amp; searchValues.length &lt;= 4;
<span class="line-modified">!         assert byteMode(kind) || charMode(kind);</span>
          assert supports(tool, CPUFeature.SSE2) || supports(tool, CPUFeature.AVX) || supportsAVX2(tool);
          nValues = searchValues.length;
          assert !findTwoConsecutive || nValues == 1;
          resultValue = result;
          arrayPtrValue = arrayPtr;
          arrayLengthValue = arrayLength;
          searchValue1 = searchValues[0];
          searchValue2 = nValues &gt; 1 ? searchValues[1] : Value.ILLEGAL;
          searchValue3 = nValues &gt; 2 ? searchValues[2] : Value.ILLEGAL;
          searchValue4 = nValues &gt; 3 ? searchValues[3] : Value.ILLEGAL;
<span class="line-modified">!         arraySlotsRemaining = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-modified">!         comparisonResult1 = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-modified">!         comparisonResult2 = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-modified">!         comparisonResult3 = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-removed">-         comparisonResult4 = tool.newVariable(LIRKind.value(AMD64Kind.DWORD));</span>
<span class="line-removed">-         vectorKind = supportsAVX2(tool) &amp;&amp; (maxVectorSize &lt; 0 || maxVectorSize &gt;= 32) ? byteMode(kind) ? AMD64Kind.V256_BYTE : AMD64Kind.V256_WORD</span>
<span class="line-removed">-                         : byteMode(kind) ? AMD64Kind.V128_BYTE : AMD64Kind.V128_WORD;</span>
          vectorCompareVal1 = tool.newVariable(LIRKind.value(vectorKind));
          vectorCompareVal2 = nValues &gt; 1 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
          vectorCompareVal3 = nValues &gt; 2 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
          vectorCompareVal4 = nValues &gt; 3 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
          vectorArray1 = tool.newVariable(LIRKind.value(vectorKind));
<span class="line-new-header">--- 22,104 ---</span>
   */
  
  
  package org.graalvm.compiler.lir.amd64;
  
<span class="line-modified">! import static jdk.vm.ci.code.ValueUtil.asRegister;</span>
<span class="line-modified">! import static jdk.vm.ci.code.ValueUtil.isRegister;</span>
<span class="line-modified">! import static jdk.vm.ci.code.ValueUtil.isStackSlot;</span>
<span class="line-modified">! import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.CONST;</span>
<span class="line-modified">! import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
<span class="line-modified">! import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;</span>
<span class="line-added">+ import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;</span>
<span class="line-added">+ </span>
<span class="line-added">+ import java.util.Objects;</span>
<span class="line-added">+ </span>
  import org.graalvm.compiler.asm.Label;
  import org.graalvm.compiler.asm.amd64.AMD64Address;
<span class="line-added">+ import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;</span>
  import org.graalvm.compiler.asm.amd64.AMD64Assembler;
<span class="line-added">+ import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;</span>
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexMoveOp;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMIOp;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMOp;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp;
<span class="line-added">+ import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;</span>
  import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
  import org.graalvm.compiler.asm.amd64.AVXKind;
  import org.graalvm.compiler.core.common.LIRKind;
<span class="line-added">+ import org.graalvm.compiler.core.common.NumUtil;</span>
<span class="line-added">+ import org.graalvm.compiler.lir.ConstantValue;</span>
  import org.graalvm.compiler.lir.LIRInstructionClass;
  import org.graalvm.compiler.lir.Opcode;
  import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
  import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
  
<span class="line-modified">! import jdk.vm.ci.amd64.AMD64;</span>
<span class="line-modified">! import jdk.vm.ci.amd64.AMD64.CPUFeature;</span>
<span class="line-modified">! import jdk.vm.ci.amd64.AMD64Kind;</span>
<span class="line-added">+ import jdk.vm.ci.code.Register;</span>
<span class="line-added">+ import jdk.vm.ci.meta.JavaConstant;</span>
<span class="line-added">+ import jdk.vm.ci.meta.JavaKind;</span>
<span class="line-added">+ import jdk.vm.ci.meta.Value;</span>
  
  /**
   */
  @Opcode(&quot;AMD64_ARRAY_INDEX_OF&quot;)
  public final class AMD64ArrayIndexOfOp extends AMD64LIRInstruction {
      public static final LIRInstructionClass&lt;AMD64ArrayIndexOfOp&gt; TYPE = LIRInstructionClass.create(AMD64ArrayIndexOfOp.class);
  
<span class="line-modified">!     private final JavaKind valueKind;</span>
      private final int nValues;
      private final boolean findTwoConsecutive;
      private final AMD64Kind vectorKind;
<span class="line-added">+     private final int arrayBaseOffset;</span>
<span class="line-added">+     private final Scale arrayIndexScale;</span>
  
      @Def({REG}) protected Value resultValue;
      @Alive({REG}) protected Value arrayPtrValue;
<span class="line-modified">!     @Alive({REG}) protected Value arrayLengthValue;</span>
<span class="line-modified">!     @Use({REG}) protected Value fromIndexValue;</span>
<span class="line-modified">!     @Alive({REG, STACK, CONST}) protected Value searchValue1;</span>
<span class="line-modified">!     @Alive({REG, STACK, CONST, ILLEGAL}) protected Value searchValue2;</span>
<span class="line-modified">!     @Alive({REG, STACK, CONST, ILLEGAL}) protected Value searchValue3;</span>
<span class="line-modified">!     @Alive({REG, STACK, CONST, ILLEGAL}) protected Value searchValue4;</span>
      @Temp({REG}) protected Value comparisonResult1;
<span class="line-modified">!     @Temp({REG, ILLEGAL}) protected Value comparisonResult2;</span>
      @Temp({REG, ILLEGAL}) protected Value vectorCompareVal1;
      @Temp({REG, ILLEGAL}) protected Value vectorCompareVal2;
      @Temp({REG, ILLEGAL}) protected Value vectorCompareVal3;
      @Temp({REG, ILLEGAL}) protected Value vectorCompareVal4;
      @Temp({REG, ILLEGAL}) protected Value vectorArray1;
      @Temp({REG, ILLEGAL}) protected Value vectorArray2;
      @Temp({REG, ILLEGAL}) protected Value vectorArray3;
      @Temp({REG, ILLEGAL}) protected Value vectorArray4;
  
<span class="line-modified">!     public AMD64ArrayIndexOfOp(JavaKind arrayKind, JavaKind valueKind, boolean findTwoConsecutive, int maxVectorSize, LIRGeneratorTool tool,</span>
<span class="line-modified">!                     Value result, Value arrayPtr, Value arrayLength, Value fromIndex, Value... searchValues) {</span>
          super(TYPE);
<span class="line-modified">!         this.valueKind = valueKind;</span>
<span class="line-added">+         this.arrayBaseOffset = tool.getProviders().getMetaAccess().getArrayBaseOffset(arrayKind);</span>
<span class="line-added">+         this.arrayIndexScale = Objects.requireNonNull(Scale.fromInt(tool.getProviders().getMetaAccess().getArrayIndexScale(valueKind)));</span>
          this.findTwoConsecutive = findTwoConsecutive;
          assert 0 &lt; searchValues.length &amp;&amp; searchValues.length &lt;= 4;
<span class="line-modified">!         assert byteMode(valueKind) || charMode(valueKind);</span>
          assert supports(tool, CPUFeature.SSE2) || supports(tool, CPUFeature.AVX) || supportsAVX2(tool);
          nValues = searchValues.length;
          assert !findTwoConsecutive || nValues == 1;
          resultValue = result;
          arrayPtrValue = arrayPtr;
          arrayLengthValue = arrayLength;
<span class="line-added">+         fromIndexValue = fromIndex;</span>
          searchValue1 = searchValues[0];
          searchValue2 = nValues &gt; 1 ? searchValues[1] : Value.ILLEGAL;
          searchValue3 = nValues &gt; 2 ? searchValues[2] : Value.ILLEGAL;
          searchValue4 = nValues &gt; 3 ? searchValues[3] : Value.ILLEGAL;
<span class="line-modified">!         comparisonResult1 = tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));</span>
<span class="line-modified">!         comparisonResult2 = findTwoConsecutive ? tool.newVariable(LIRKind.value(tool.target().arch.getWordKind())) : Value.ILLEGAL;</span>
<span class="line-modified">!         vectorKind = supportsAVX2(tool) &amp;&amp; (maxVectorSize &lt; 0 || maxVectorSize &gt;= 32) ? byteMode(valueKind) ? AMD64Kind.V256_BYTE : AMD64Kind.V256_WORD</span>
<span class="line-modified">!                         : byteMode(valueKind) ? AMD64Kind.V128_BYTE : AMD64Kind.V128_WORD;</span>
          vectorCompareVal1 = tool.newVariable(LIRKind.value(vectorKind));
          vectorCompareVal2 = nValues &gt; 1 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
          vectorCompareVal3 = nValues &gt; 2 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
          vectorCompareVal4 = nValues &gt; 3 ? tool.newVariable(LIRKind.value(vectorKind)) : Value.ILLEGAL;
          vectorArray1 = tool.newVariable(LIRKind.value(vectorKind));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,28 ***</span>
      private static boolean charMode(JavaKind kind) {
          return kind == JavaKind.Char;
      }
  
      private JavaKind getComparisonKind() {
<span class="line-modified">!         return findTwoConsecutive ? (byteMode(kind) ? JavaKind.Char : JavaKind.Int) : kind;</span>
      }
  
      private AVXKind.AVXSize getVectorSize() {
          return AVXKind.getDataSize(vectorKind);
      }
  
      @Override
      public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
          Register arrayPtr = asRegister(arrayPtrValue);
          Register arrayLength = asRegister(arrayLengthValue);
<span class="line-modified">!         Register result = asRegister(resultValue);</span>
<span class="line-modified">!         Register slotsRemaining = asRegister(arraySlotsRemaining);</span>
<span class="line-modified">!         Register[] searchValue = {</span>
<span class="line-modified">!                         nValues &gt; 0 ? asRegister(searchValue1) : null,</span>
<span class="line-modified">!                         nValues &gt; 1 ? asRegister(searchValue2) : null,</span>
<span class="line-modified">!                         nValues &gt; 2 ? asRegister(searchValue3) : null,</span>
<span class="line-modified">!                         nValues &gt; 3 ? asRegister(searchValue4) : null,</span>
          };
          Register[] vecCmp = {
                          nValues &gt; 0 ? asRegister(vectorCompareVal1) : null,
                          nValues &gt; 1 ? asRegister(vectorCompareVal2) : null,
                          nValues &gt; 2 ? asRegister(vectorCompareVal3) : null,
<span class="line-new-header">--- 135,29 ---</span>
      private static boolean charMode(JavaKind kind) {
          return kind == JavaKind.Char;
      }
  
      private JavaKind getComparisonKind() {
<span class="line-modified">!         return findTwoConsecutive ? (byteMode(valueKind) ? JavaKind.Char : JavaKind.Int) : valueKind;</span>
      }
  
      private AVXKind.AVXSize getVectorSize() {
          return AVXKind.getDataSize(vectorKind);
      }
  
      @Override
      public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
<span class="line-added">+         int nVectors = nValues == 1 ? 4 : nValues == 2 ? 2 : 1;</span>
          Register arrayPtr = asRegister(arrayPtrValue);
          Register arrayLength = asRegister(arrayLengthValue);
<span class="line-modified">!         Register fromIndex = asRegister(fromIndexValue);</span>
<span class="line-modified">!         Register index = asRegister(resultValue);</span>
<span class="line-modified">!         Value[] searchValue = {</span>
<span class="line-modified">!                         nValues &gt; 0 ? searchValue1 : null,</span>
<span class="line-modified">!                         nValues &gt; 1 ? searchValue2 : null,</span>
<span class="line-modified">!                         nValues &gt; 2 ? searchValue3 : null,</span>
<span class="line-modified">!                         nValues &gt; 3 ? searchValue4 : null,</span>
          };
          Register[] vecCmp = {
                          nValues &gt; 0 ? asRegister(vectorCompareVal1) : null,
                          nValues &gt; 1 ? asRegister(vectorCompareVal2) : null,
                          nValues &gt; 2 ? asRegister(vectorCompareVal3) : null,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,292 ***</span>
                          asRegister(vectorArray3),
                          asRegister(vectorArray4),
          };
          Register[] cmpResult = {
                          asRegister(comparisonResult1),
<span class="line-modified">!                         asRegister(comparisonResult2),</span>
<span class="line-removed">-                         asRegister(comparisonResult3),</span>
<span class="line-removed">-                         asRegister(comparisonResult4),</span>
          };
<span class="line-modified">!         Label retFound = new Label();</span>
<span class="line-removed">-         Label retNotFound = new Label();</span>
<span class="line-removed">-         Label end = new Label();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // load array length</span>
<span class="line-removed">-         // important: this must be the first register manipulation, since arrayLengthValue is</span>
<span class="line-removed">-         // annotated with @Use</span>
<span class="line-removed">-         asm.movl(slotsRemaining, arrayLength);</span>
<span class="line-removed">-         // load array pointer</span>
<span class="line-removed">-         asm.movq(result, arrayPtr);</span>
<span class="line-removed">-         // move search values to vectors</span>
<span class="line-removed">-         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-removed">-             if (asm.supports(CPUFeature.AVX)) {</span>
<span class="line-removed">-                 VexMoveOp.VMOVD.emit(asm, AVXKind.AVXSize.DWORD, vecCmp[i], searchValue[i]);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 asm.movdl(vecCmp[i], searchValue[i]);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // fill comparison vector with copies of the search value</span>
<span class="line-removed">-         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-removed">-             emitBroadcast(asm, getComparisonKind(), vecCmp[i], vecArray[0], getVectorSize());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         emitArrayIndexOfChars(crb, asm, result, slotsRemaining, searchValue, vecCmp, vecArray, cmpResult, retFound, retNotFound);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // return -1 (no match)</span>
<span class="line-removed">-         asm.bind(retNotFound);</span>
<span class="line-removed">-         asm.movq(result, -1);</span>
<span class="line-removed">-         asm.jmpb(end);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         asm.bind(retFound);</span>
<span class="line-removed">-         // convert array pointer to offset</span>
<span class="line-removed">-         asm.subq(result, arrayPtr);</span>
<span class="line-removed">-         if (charMode(kind)) {</span>
<span class="line-removed">-             asm.shrq(result, 1);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         asm.bind(end);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private void emitArrayIndexOfChars(CompilationResultBuilder crb, AMD64MacroAssembler asm,</span>
<span class="line-removed">-                     Register arrayPtr,</span>
<span class="line-removed">-                     Register slotsRemaining,</span>
<span class="line-removed">-                     Register[] searchValue,</span>
<span class="line-removed">-                     Register[] vecCmp,</span>
<span class="line-removed">-                     Register[] vecArray,</span>
<span class="line-removed">-                     Register[] cmpResult,</span>
<span class="line-removed">-                     Label retFound,</span>
<span class="line-removed">-                     Label retNotFound) {</span>
<span class="line-removed">-         int nVectors = nValues == 1 ? 4 : nValues == 2 ? 2 : 1;</span>
<span class="line-removed">-         AVXKind.AVXSize vectorSize = getVectorSize();</span>
  
          Label bulkVectorLoop = new Label();
          Label singleVectorLoop = new Label();
          Label[] vectorFound = {
                          new Label(),
                          new Label(),
                          new Label(),
                          new Label(),
          };
<span class="line-modified">!         Label lessThanVectorSizeRemaining = new Label();</span>
<span class="line-modified">!         Label lessThanVectorSizeRemainingLoop = new Label();</span>
<span class="line-modified">!         Label bulkVectorLoopExit = nVectors == 1 ? lessThanVectorSizeRemaining : singleVectorLoop;</span>
<span class="line-modified">!         int bytesPerVector = vectorSize.getBytes();</span>
<span class="line-modified">!         int arraySlotsPerVector = vectorSize.getBytes() / kind.getByteCount();</span>
<span class="line-modified">!         int singleVectorLoopCondition = arraySlotsPerVector;</span>
<span class="line-modified">!         int bulkSize = arraySlotsPerVector * nVectors;</span>
<span class="line-modified">!         int bulkSizeBytes = bytesPerVector * nVectors;</span>
<span class="line-removed">-         int bulkLoopCondition = bulkSize;</span>
<span class="line-removed">-         int[] vectorOffsets;</span>
<span class="line-removed">-         JavaKind vectorCompareKind = kind;</span>
          if (findTwoConsecutive) {
<span class="line-removed">-             singleVectorLoopCondition++;</span>
<span class="line-removed">-             bulkLoopCondition++;</span>
              bulkSize /= 2;
<span class="line-modified">!             bulkSizeBytes /= 2;</span>
<span class="line-modified">!             vectorOffsets = new int[]{0, kind.getByteCount(), bytesPerVector, bytesPerVector + kind.getByteCount()};</span>
<span class="line-modified">!             vectorCompareKind = byteMode(kind) ? JavaKind.Char : JavaKind.Int;</span>
          } else {
<span class="line-modified">!             vectorOffsets = new int[]{0, bytesPerVector, bytesPerVector * 2, bytesPerVector * 3};</span>
          }
  
<span class="line-removed">-         // load copy of low part of array pointer</span>
<span class="line-removed">-         Register tmpArrayPtrLow = cmpResult[0];</span>
<span class="line-removed">-         asm.movl(tmpArrayPtrLow, arrayPtr);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // check if bulk vector load is in bounds</span>
<span class="line-removed">-         asm.cmpl(slotsRemaining, bulkLoopCondition);</span>
<span class="line-removed">-         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // check if array pointer is aligned to bulkSize</span>
<span class="line-removed">-         asm.andl(tmpArrayPtrLow, bulkSizeBytes - 1);</span>
<span class="line-removed">-         asm.jcc(AMD64Assembler.ConditionFlag.Zero, bulkVectorLoop);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // do one unaligned bulk comparison pass and adjust alignment afterwards</span>
<span class="line-removed">-         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, nVectors, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, false);</span>
<span class="line-removed">-         // load copy of low part of array pointer</span>
<span class="line-removed">-         asm.movl(tmpArrayPtrLow, arrayPtr);</span>
<span class="line-removed">-         // adjust array pointer</span>
<span class="line-removed">-         asm.addq(arrayPtr, bulkSizeBytes);</span>
<span class="line-removed">-         // adjust number of array slots remaining</span>
<span class="line-removed">-         asm.subl(slotsRemaining, bulkSize);</span>
<span class="line-removed">-         // get offset to bulk size alignment</span>
<span class="line-removed">-         asm.andl(tmpArrayPtrLow, bulkSizeBytes - 1);</span>
<span class="line-removed">-         emitBytesToArraySlots(asm, kind, tmpArrayPtrLow);</span>
<span class="line-removed">-         // adjust array pointer to bulk size alignment</span>
<span class="line-removed">-         asm.andq(arrayPtr, ~(bulkSizeBytes - 1));</span>
<span class="line-removed">-         // adjust number of array slots remaining</span>
<span class="line-removed">-         asm.addl(slotsRemaining, tmpArrayPtrLow);</span>
          // check if there are enough array slots remaining for the bulk loop
<span class="line-modified">!         asm.cmpl(slotsRemaining, bulkLoopCondition);</span>
<span class="line-modified">!         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);</span>
  
          emitAlign(crb, asm);
          asm.bind(bulkVectorLoop);
          // memory-aligned bulk comparison
<span class="line-modified">!         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, nVectors, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, !findTwoConsecutive);</span>
<span class="line-modified">!         // adjust number of array slots remaining</span>
<span class="line-modified">!         asm.subl(slotsRemaining, bulkSize);</span>
<span class="line-removed">-         // adjust array pointer</span>
<span class="line-removed">-         asm.addq(arrayPtr, bulkSizeBytes);</span>
          // check if there are enough array slots remaining for the bulk loop
<span class="line-modified">!         asm.cmpl(slotsRemaining, bulkLoopCondition);</span>
<span class="line-modified">!         asm.jcc(AMD64Assembler.ConditionFlag.Below, bulkVectorLoopExit);</span>
<span class="line-removed">-         // continue loop</span>
<span class="line-removed">-         asm.jmp(bulkVectorLoop);</span>
  
<span class="line-modified">!         if (nVectors &gt; 1) {</span>
              emitAlign(crb, asm);
              // same loop as bulkVectorLoop, with only one vector
              asm.bind(singleVectorLoop);
<span class="line-modified">!             // check if single vector load is in bounds</span>
<span class="line-modified">!             asm.cmpl(slotsRemaining, singleVectorLoopCondition);</span>
<span class="line-modified">!             asm.jcc(AMD64Assembler.ConditionFlag.Below, lessThanVectorSizeRemaining);</span>
              // compare
<span class="line-modified">!             emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, findTwoConsecutive ? 2 : 1, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, vectorFound, false);</span>
<span class="line-modified">!             // adjust number of array slots remaining</span>
<span class="line-modified">!             asm.subl(slotsRemaining, arraySlotsPerVector);</span>
<span class="line-modified">!             // adjust array pointer</span>
<span class="line-removed">-             asm.addq(arrayPtr, bytesPerVector);</span>
<span class="line-removed">-             // continue loop</span>
<span class="line-removed">-             asm.jmpb(singleVectorLoop);</span>
          }
  
<span class="line-modified">!         asm.bind(lessThanVectorSizeRemaining);</span>
<span class="line-modified">!         // check if any array slots remain</span>
<span class="line-modified">!         asm.testl(slotsRemaining, slotsRemaining);</span>
<span class="line-removed">-         asm.jcc(AMD64Assembler.ConditionFlag.Zero, retNotFound);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // a vector compare will read out of bounds of the input array.</span>
<span class="line-removed">-         // check if the out-of-bounds read would cross a memory page boundary.</span>
<span class="line-removed">-         // load copy of low part of array pointer</span>
<span class="line-removed">-         asm.movl(tmpArrayPtrLow, arrayPtr);</span>
<span class="line-removed">-         // check if pointer + vector size would cross the page boundary</span>
<span class="line-removed">-         asm.andl(tmpArrayPtrLow, (vmPageSize - 1));</span>
<span class="line-removed">-         asm.cmpl(tmpArrayPtrLow, (vmPageSize - (findTwoConsecutive ? bytesPerVector + kind.getByteCount() : bytesPerVector)));</span>
<span class="line-removed">-         // if the page boundary would be crossed, do byte/character-wise comparison instead.</span>
<span class="line-removed">-         asm.jccb(AMD64Assembler.ConditionFlag.Above, lessThanVectorSizeRemainingLoop);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Label[] overBoundsMatch = {new Label(), new Label()};</span>
<span class="line-removed">-         // otherwise, do a vector compare that reads beyond array bounds</span>
<span class="line-removed">-         emitVectorCompare(asm, vectorCompareKind, vectorSize, nValues, findTwoConsecutive ? 2 : 1, vectorOffsets, arrayPtr, vecCmp, vecArray, cmpResult, overBoundsMatch, false);</span>
<span class="line-removed">-         // no match</span>
<span class="line-removed">-         asm.jmp(retNotFound);</span>
          if (findTwoConsecutive) {
<span class="line-modified">!             Label overBoundsFinish = new Label();</span>
<span class="line-removed">-             asm.bind(overBoundsMatch[1]);</span>
<span class="line-removed">-             // get match offset of second result</span>
<span class="line-removed">-             asm.bsfq(cmpResult[1], cmpResult[1]);</span>
<span class="line-removed">-             asm.addl(cmpResult[1], kind.getByteCount());</span>
<span class="line-removed">-             // replace first result with second and continue</span>
<span class="line-removed">-             asm.movl(cmpResult[0], cmpResult[1]);</span>
<span class="line-removed">-             asm.jmpb(overBoundsFinish);</span>
  
<span class="line-modified">!             asm.bind(overBoundsMatch[0]);</span>
<span class="line-modified">!             emitFindTwoCharPrefixMinResult(asm, kind, cmpResult, overBoundsFinish);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             asm.bind(overBoundsMatch[0]);</span>
<span class="line-modified">!             // find match offset</span>
              asm.bsfq(cmpResult[0], cmpResult[0]);
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         // adjust array pointer for match result</span>
<span class="line-modified">!         asm.addq(arrayPtr, cmpResult[0]);</span>
<span class="line-modified">!         if (charMode(kind)) {</span>
<span class="line-removed">-             // convert byte offset to chars</span>
<span class="line-removed">-             asm.shrl(cmpResult[0], 1);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // check if offset of matched value is greater than number of bytes remaining / out of array</span>
<span class="line-removed">-         // bounds</span>
<span class="line-removed">-         if (findTwoConsecutive) {</span>
<span class="line-removed">-             asm.decrementl(slotsRemaining);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         asm.cmpl(cmpResult[0], slotsRemaining);</span>
<span class="line-removed">-         // match is out of bounds, return no match</span>
<span class="line-removed">-         asm.jcc(AMD64Assembler.ConditionFlag.GreaterEqual, retNotFound);</span>
<span class="line-removed">-         // adjust number of array slots remaining</span>
<span class="line-removed">-         if (findTwoConsecutive) {</span>
<span class="line-removed">-             asm.incrementl(slotsRemaining, 1);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         asm.subl(slotsRemaining, cmpResult[0]);</span>
<span class="line-removed">-         // match is in bounds, return offset</span>
<span class="line-removed">-         asm.jmp(retFound);</span>
  
<span class="line-modified">!         // compare remaining slots in the array one-by-one</span>
<span class="line-modified">!         asm.bind(lessThanVectorSizeRemainingLoop);</span>
<span class="line-modified">!         // check if enough array slots remain</span>
<span class="line-modified">!         asm.cmpl(slotsRemaining, findTwoConsecutive ? 1 : 0);</span>
<span class="line-modified">!         asm.jcc(AMD64Assembler.ConditionFlag.LessEqual, retNotFound);</span>
<span class="line-modified">!         // load char / byte</span>
<span class="line-modified">!         if (byteMode(kind)) {</span>
<span class="line-modified">!             if (findTwoConsecutive) {</span>
<span class="line-modified">!                 asm.movzwl(cmpResult[0], new AMD64Address(arrayPtr));</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 asm.movzbl(cmpResult[0], new AMD64Address(arrayPtr));</span>
              }
          } else {
<span class="line-modified">!             if (findTwoConsecutive) {</span>
<span class="line-modified">!                 asm.movl(cmpResult[0], new AMD64Address(arrayPtr));</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 asm.movzwl(cmpResult[0], new AMD64Address(arrayPtr));</span>
              }
          }
<span class="line-modified">!         // check for match</span>
          for (int i = 0; i &lt; nValues; i++) {
<span class="line-modified">!             emitCompareInst(asm, getComparisonKind(), cmpResult[0], searchValue[i]);</span>
<span class="line-modified">!             asm.jcc(AMD64Assembler.ConditionFlag.Equal, retFound);</span>
          }
<span class="line-modified">!         // adjust number of array slots remaining</span>
<span class="line-modified">!         asm.decrementl(slotsRemaining);</span>
<span class="line-removed">-         // adjust array pointer</span>
<span class="line-removed">-         asm.addq(arrayPtr, kind.getByteCount());</span>
<span class="line-removed">-         // continue loop</span>
<span class="line-removed">-         asm.jmpb(lessThanVectorSizeRemainingLoop);</span>
  
<span class="line-modified">!         for (int i = 1; i &lt; nVectors; i += (findTwoConsecutive ? 2 : 1)) {</span>
<span class="line-modified">!             emitVectorFoundWithOffset(asm, kind, vectorOffsets[i], arrayPtr, cmpResult[i], slotsRemaining, vectorFound[i], retFound);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         if (findTwoConsecutive) {</span>
<span class="line-modified">!             asm.bind(vectorFound[2]);</span>
<span class="line-modified">!             asm.addq(arrayPtr, vectorOffsets[2]);</span>
<span class="line-modified">!             // adjust number of array slots remaining</span>
<span class="line-modified">!             asm.subl(slotsRemaining, charMode(kind) ? vectorOffsets[2] / 2 : vectorOffsets[2]);</span>
<span class="line-modified">!             asm.movl(cmpResult[0], cmpResult[2]);</span>
<span class="line-modified">!             asm.movl(cmpResult[1], cmpResult[3]);</span>
<span class="line-modified">!             asm.bind(vectorFound[0]);</span>
<span class="line-removed">-             emitFindTwoCharPrefixMinResult(asm, kind, cmpResult, new Label());</span>
          } else {
<span class="line-modified">!             asm.bind(vectorFound[0]);</span>
<span class="line-removed">-             // find index of first set bit in bit mask</span>
<span class="line-removed">-             asm.bsfq(cmpResult[0], cmpResult[0]);</span>
          }
<span class="line-modified">!         // add offset to array pointer</span>
<span class="line-modified">!         asm.addq(arrayPtr, cmpResult[0]);</span>
<span class="line-modified">!         if (charMode(kind)) {</span>
<span class="line-modified">!             // convert byte offset to chars</span>
<span class="line-modified">!             asm.shrl(cmpResult[0], 1);</span>
<span class="line-modified">!         }</span>
<span class="line-removed">-         // adjust number of array slots remaining</span>
<span class="line-removed">-         asm.subl(slotsRemaining, cmpResult[0]);</span>
<span class="line-removed">-         asm.jmpb(retFound);</span>
      }
  
<span class="line-modified">!     private static void emitFindTwoCharPrefixMinResult(AMD64MacroAssembler asm, JavaKind kind, Register[] cmpResult, Label done) {</span>
<span class="line-modified">!         // find match offset</span>
<span class="line-modified">!         asm.bsfq(cmpResult[0], cmpResult[0]);</span>
<span class="line-modified">!         // check if second result is also a match</span>
<span class="line-modified">!         asm.testl(cmpResult[1], cmpResult[1]);</span>
<span class="line-modified">!         asm.jcc(AMD64Assembler.ConditionFlag.Zero, done);</span>
<span class="line-modified">!         // get match offset of second result</span>
<span class="line-modified">!         asm.bsfq(cmpResult[1], cmpResult[1]);</span>
<span class="line-modified">!         asm.addl(cmpResult[1], kind.getByteCount());</span>
<span class="line-modified">!         // check if first result is less than second</span>
<span class="line-modified">!         asm.cmpl(cmpResult[0], cmpResult[1]);</span>
<span class="line-modified">!         asm.jcc(AMD64Assembler.ConditionFlag.LessEqual, done);</span>
<span class="line-modified">!         // first result is greater than second, replace it with the second result</span>
<span class="line-modified">!         asm.movl(cmpResult[0], cmpResult[1]);</span>
<span class="line-modified">!         asm.bind(done);</span>
      }
  
      private static void emitAlign(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
          asm.align(crb.target.wordSize * 2);
      }
<span class="line-new-header">--- 169,292 ---</span>
                          asRegister(vectorArray3),
                          asRegister(vectorArray4),
          };
          Register[] cmpResult = {
                          asRegister(comparisonResult1),
<span class="line-modified">!                         findTwoConsecutive ? asRegister(comparisonResult2) : null,</span>
          };
<span class="line-modified">!         Label ret = new Label();</span>
  
          Label bulkVectorLoop = new Label();
          Label singleVectorLoop = new Label();
          Label[] vectorFound = {
                          new Label(),
                          new Label(),
                          new Label(),
                          new Label(),
          };
<span class="line-modified">!         Label runVectorized = new Label();</span>
<span class="line-modified">!         Label elementWiseLoop = new Label();</span>
<span class="line-modified">!         Label elementWiseFound = new Label();</span>
<span class="line-modified">!         Label elementWiseNotFound = new Label();</span>
<span class="line-modified">!         Label skipBulkVectorLoop = new Label();</span>
<span class="line-modified">!         int vectorSize = getVectorSize().getBytes() / valueKind.getByteCount();</span>
<span class="line-modified">!         int bulkSize = vectorSize * nVectors;</span>
<span class="line-modified">!         JavaKind vectorCompareKind = valueKind;</span>
          if (findTwoConsecutive) {
              bulkSize /= 2;
<span class="line-modified">!             vectorCompareKind = byteMode(valueKind) ? JavaKind.Char : JavaKind.Int;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // index = fromIndex + vectorSize (+1 if findTwoConsecutive)</span>
<span class="line-added">+         // important: this must be the first register manipulation, since fromIndex is</span>
<span class="line-added">+         // annotated with @Use</span>
<span class="line-added">+         asm.leaq(index, new AMD64Address(fromIndex, vectorSize + (findTwoConsecutive ? 1 : 0)));</span>
<span class="line-added">+ </span>
<span class="line-added">+         // check if vector vector load is in bounds</span>
<span class="line-added">+         asm.cmpq(index, arrayLength);</span>
<span class="line-added">+         asm.jccb(AMD64Assembler.ConditionFlag.LessEqual, runVectorized);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // search range is smaller than vector size, do element-wise comparison</span>
<span class="line-added">+ </span>
<span class="line-added">+         // index = fromIndex (+ 1 if findTwoConsecutive)</span>
<span class="line-added">+         asm.subq(index, vectorSize);</span>
<span class="line-added">+         // check if enough array slots remain</span>
<span class="line-added">+         asm.cmpq(index, arrayLength);</span>
<span class="line-added">+         asm.jccb(AMD64Assembler.ConditionFlag.GreaterEqual, elementWiseNotFound);</span>
<span class="line-added">+         // compare one-by-one</span>
<span class="line-added">+         asm.bind(elementWiseLoop);</span>
<span class="line-added">+         // check for match</span>
<span class="line-added">+         OperandSize cmpSize = getOpSize(getComparisonKind());</span>
<span class="line-added">+         // address = findTwoConsecutive ? array[index - 1] : array[index]</span>
<span class="line-added">+         AMD64Address arrayAddr = new AMD64Address(arrayPtr, index, arrayIndexScale, arrayBaseOffset - (findTwoConsecutive ? valueKind.getByteCount() : 0));</span>
<span class="line-added">+         boolean valuesOnStack = searchValuesOnStack(searchValue);</span>
<span class="line-added">+         if (valuesOnStack) {</span>
<span class="line-added">+             (cmpSize == OperandSize.BYTE ? AMD64RMOp.MOVB : AMD64RMOp.MOV).emit(asm, cmpSize, cmpResult[0], arrayAddr);</span>
<span class="line-added">+             for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-added">+                 if (isConstant(searchValue[i])) {</span>
<span class="line-added">+                     int imm = asConstant(searchValue[i]).asInt();</span>
<span class="line-added">+                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getMIOpcode(cmpSize, NumUtil.isByte(imm)).emit(asm, cmpSize, cmpResult[0], imm);</span>
<span class="line-added">+                 } else if (isStackSlot(searchValue[i])) {</span>
<span class="line-added">+                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getRMOpcode(cmpSize).emit(asm, cmpSize, cmpResult[0], (AMD64Address) crb.asAddress(searchValue[i]));</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getRMOpcode(cmpSize).emit(asm, cmpSize, cmpResult[0], asRegister(searchValue[i]));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 asm.jccb(AMD64Assembler.ConditionFlag.Equal, elementWiseFound);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-added">+                 if (isConstant(searchValue[i])) {</span>
<span class="line-added">+                     int imm = asConstant(searchValue[i]).asInt();</span>
<span class="line-added">+                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getMIOpcode(cmpSize, NumUtil.isByte(imm)).emit(asm, cmpSize, arrayAddr, imm);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     AMD64Assembler.AMD64BinaryArithmetic.CMP.getRMOpcode(cmpSize).emit(asm, cmpSize, asRegister(searchValue[i]), arrayAddr);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 asm.jccb(AMD64Assembler.ConditionFlag.Equal, elementWiseFound);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // adjust index</span>
<span class="line-added">+         asm.incrementq(index, 1);</span>
<span class="line-added">+         // continue loop</span>
<span class="line-added">+         asm.cmpq(index, arrayLength);</span>
<span class="line-added">+         asm.jccb(AMD64Assembler.ConditionFlag.Less, elementWiseLoop);</span>
<span class="line-added">+ </span>
<span class="line-added">+         asm.bind(elementWiseNotFound);</span>
<span class="line-added">+         asm.xorq(index, index);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (findTwoConsecutive) {</span>
<span class="line-added">+             asm.bind(elementWiseFound);</span>
<span class="line-added">+             asm.decrementq(index, 1);</span>
          } else {
<span class="line-modified">!             asm.decrementq(index, 1);</span>
<span class="line-added">+             asm.bind(elementWiseFound);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         asm.jmp(ret);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // vectorized implementation</span>
<span class="line-added">+         asm.bind(runVectorized);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // move search values to vectors</span>
<span class="line-added">+         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-added">+             // fill comparison vector with copies of the search value</span>
<span class="line-added">+             broadcastSearchValue(crb, asm, vecCmp[i], searchValue[i], cmpResult[0], vecArray[0]);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // do one unaligned vector comparison pass and adjust alignment afterwards</span>
<span class="line-added">+         emitVectorCompare(asm, vectorCompareKind, findTwoConsecutive ? 2 : 1, arrayPtr, index, vecCmp, vecArray, cmpResult, vectorFound, false, false);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // adjust index to vector size alignment</span>
<span class="line-added">+         asm.leaq(cmpResult[0], new AMD64Address(arrayPtr, arrayBaseOffset));</span>
<span class="line-added">+         if (charMode(valueKind)) {</span>
<span class="line-added">+             asm.shrq(cmpResult[0], 1);</span>
          }
<span class="line-added">+         asm.addq(index, cmpResult[0]);</span>
<span class="line-added">+         // adjust to next lower multiple of vector size</span>
<span class="line-added">+         asm.andq(index, ~(vectorSize - 1));</span>
<span class="line-added">+         asm.subq(index, cmpResult[0]);</span>
<span class="line-added">+         // add bulk size</span>
<span class="line-added">+         asm.addq(index, bulkSize);</span>
  
          // check if there are enough array slots remaining for the bulk loop
<span class="line-modified">!         asm.cmpq(index, arrayLength);</span>
<span class="line-modified">!         asm.jccb(AMD64Assembler.ConditionFlag.Greater, skipBulkVectorLoop);</span>
  
          emitAlign(crb, asm);
          asm.bind(bulkVectorLoop);
          // memory-aligned bulk comparison
<span class="line-modified">!         emitVectorCompare(asm, vectorCompareKind, nVectors, arrayPtr, index, vecCmp, vecArray, cmpResult, vectorFound, false, !findTwoConsecutive);</span>
<span class="line-modified">!         // adjust index</span>
<span class="line-modified">!         asm.addq(index, bulkSize);</span>
          // check if there are enough array slots remaining for the bulk loop
<span class="line-modified">!         asm.cmpq(index, arrayLength);</span>
<span class="line-modified">!         asm.jccb(AMD64Assembler.ConditionFlag.LessEqual, bulkVectorLoop);</span>
  
<span class="line-modified">!         asm.bind(skipBulkVectorLoop);</span>
<span class="line-added">+         if ((findTwoConsecutive &amp;&amp; nVectors == 2) || nVectors == 1) {</span>
<span class="line-added">+             // do last load from end of array</span>
<span class="line-added">+             asm.movq(index, arrayLength);</span>
<span class="line-added">+             // compare</span>
<span class="line-added">+             emitVectorCompare(asm, vectorCompareKind, findTwoConsecutive ? 2 : 1, arrayPtr, index, vecCmp, vecArray, cmpResult, vectorFound, true, false);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             // remove bulk offset</span>
<span class="line-added">+             asm.subq(index, bulkSize);</span>
              emitAlign(crb, asm);
              // same loop as bulkVectorLoop, with only one vector
              asm.bind(singleVectorLoop);
<span class="line-modified">!             // add vector size</span>
<span class="line-modified">!             asm.addq(index, vectorSize);</span>
<span class="line-modified">!             // check if vector load is in bounds</span>
<span class="line-added">+             asm.cmpq(index, arrayLength);</span>
<span class="line-added">+             // if load would be over bounds, set the load to the end of the array</span>
<span class="line-added">+             asm.cmovq(AMD64Assembler.ConditionFlag.Greater, index, arrayLength);</span>
              // compare
<span class="line-modified">!             emitVectorCompare(asm, vectorCompareKind, findTwoConsecutive ? 2 : 1, arrayPtr, index, vecCmp, vecArray, cmpResult, vectorFound, true, false);</span>
<span class="line-modified">!             // check if there are enough array slots remaining for the loop</span>
<span class="line-modified">!             asm.cmpq(index, arrayLength);</span>
<span class="line-modified">!             asm.jccb(AMD64Assembler.ConditionFlag.Less, singleVectorLoop);</span>
          }
  
<span class="line-modified">!         asm.movl(index, -1);</span>
<span class="line-modified">!         asm.jmpb(ret);</span>
<span class="line-modified">! </span>
          if (findTwoConsecutive) {
<span class="line-modified">!             Label vectorFound2Done = new Label();</span>
  
<span class="line-modified">!             // vectorFound[0] and vectorFound[2] behave like the single-char case</span>
<span class="line-modified">!             asm.bind(vectorFound[2]);</span>
<span class="line-modified">!             // add static offset</span>
<span class="line-modified">!             asm.subq(index, getResultIndexDelta(2));</span>
<span class="line-modified">!             asm.jmpb(vectorFound2Done);</span>
<span class="line-added">+ </span>
<span class="line-added">+             asm.bind(vectorFound[0]);</span>
<span class="line-added">+             // add static offset</span>
<span class="line-added">+             asm.subq(index, getResultIndexDelta(0));</span>
<span class="line-added">+             asm.bind(vectorFound2Done);</span>
<span class="line-added">+             // find offset</span>
              asm.bsfq(cmpResult[0], cmpResult[0]);
<span class="line-modified">!             if (charMode(valueKind)) {</span>
<span class="line-added">+                 // convert byte offset to chars</span>
<span class="line-added">+                 asm.shrl(cmpResult[0], 1);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // add offset to index</span>
<span class="line-added">+             asm.addq(index, cmpResult[0]);</span>
<span class="line-added">+             asm.jmpb(ret);</span>
<span class="line-added">+ </span>
<span class="line-added">+             Label minResult = new Label();</span>
<span class="line-added">+             Label minResultDone = new Label();</span>
<span class="line-added">+ </span>
<span class="line-added">+             // in vectorFound[1] and vectorFound[3], we have to check the results 0 and 2 as well</span>
<span class="line-added">+             if (nVectors &gt; 2) {</span>
<span class="line-added">+                 asm.bind(vectorFound[3]);</span>
<span class="line-added">+                 // add offset</span>
<span class="line-added">+                 asm.subq(index, getResultIndexDelta(3));</span>
<span class="line-added">+                 asm.jmpb(minResult);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             asm.bind(vectorFound[1]);</span>
<span class="line-modified">!             // add offset</span>
<span class="line-modified">!             asm.subq(index, getResultIndexDelta(1));</span>
  
<span class="line-modified">!             asm.bind(minResult);</span>
<span class="line-modified">!             // find offset 0</span>
<span class="line-modified">!             asm.bsfq(cmpResult[1], cmpResult[1]);</span>
<span class="line-modified">!             // check if second result is also a match</span>
<span class="line-modified">!             asm.testq(cmpResult[0], cmpResult[0]);</span>
<span class="line-modified">!             asm.jccb(AMD64Assembler.ConditionFlag.Zero, minResultDone);</span>
<span class="line-modified">!             // find offset 1</span>
<span class="line-modified">!             asm.bsfq(cmpResult[0], cmpResult[0]);</span>
<span class="line-modified">!             asm.addq(cmpResult[0], valueKind.getByteCount());</span>
<span class="line-modified">!             // if first result is greater than second, replace it with the second result</span>
<span class="line-modified">!             asm.cmpq(cmpResult[1], cmpResult[0]);</span>
<span class="line-added">+             asm.cmovq(AMD64Assembler.ConditionFlag.Greater, cmpResult[1], cmpResult[0]);</span>
<span class="line-added">+             asm.bind(minResultDone);</span>
<span class="line-added">+             if (charMode(valueKind)) {</span>
<span class="line-added">+                 // convert byte offset to chars</span>
<span class="line-added">+                 asm.shrl(cmpResult[1], 1);</span>
              }
<span class="line-added">+             // add offset to index</span>
<span class="line-added">+             asm.addq(index, cmpResult[1]);</span>
          } else {
<span class="line-modified">!             Label end = new Label();</span>
<span class="line-modified">!             for (int i = 0; i &lt; nVectors; i++) {</span>
<span class="line-modified">!                 asm.bind(vectorFound[i]);</span>
<span class="line-modified">!                 // add static offset</span>
<span class="line-added">+                 asm.subq(index, getResultIndexDelta(i));</span>
<span class="line-added">+                 if (i &lt; nVectors - 1) {</span>
<span class="line-added">+                     asm.jmpb(end);</span>
<span class="line-added">+                 }</span>
              }
<span class="line-added">+             asm.bind(end);</span>
<span class="line-added">+             // find offset</span>
<span class="line-added">+             asm.bsfq(cmpResult[0], cmpResult[0]);</span>
<span class="line-added">+             if (charMode(valueKind)) {</span>
<span class="line-added">+                 // convert byte offset to chars</span>
<span class="line-added">+                 asm.shrl(cmpResult[0], 1);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // add offset to index</span>
<span class="line-added">+             asm.addq(index, cmpResult[0]);</span>
          }
<span class="line-modified">!         asm.bind(ret);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private boolean searchValuesOnStack(Value[] searchValue) {</span>
          for (int i = 0; i &lt; nValues; i++) {
<span class="line-modified">!             if (isStackSlot(searchValue[i])) {</span>
<span class="line-modified">!                 return true;</span>
<span class="line-added">+             }</span>
          }
<span class="line-modified">!         return false;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     private int getResultIndexDelta(int i) {</span>
<span class="line-modified">!         return (((findTwoConsecutive ? i / 2 : i) + 1) * (getVectorSize().getBytes() / valueKind.getByteCount())) + (findTwoConsecutive ? (i &amp; 1) : 0);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     private int getVectorOffset(int i) {</span>
<span class="line-modified">!         return arrayBaseOffset - getResultIndexDelta(i) * valueKind.getByteCount();</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private void broadcastSearchValue(CompilationResultBuilder crb, AMD64MacroAssembler asm, Register dst, Value srcVal, Register tmpReg, Register tmpVector) {</span>
<span class="line-modified">!         Register src = asRegOrTmpReg(crb, asm, srcVal, tmpReg);</span>
<span class="line-modified">!         if (asm.supports(CPUFeature.AVX)) {</span>
<span class="line-modified">!             VexMoveOp.VMOVD.emit(asm, AVXKind.AVXSize.DWORD, dst, src);</span>
          } else {
<span class="line-modified">!             asm.movdl(dst, src);</span>
          }
<span class="line-modified">!         emitBroadcast(asm, getComparisonKind(), dst, tmpVector, getVectorSize());</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static boolean isConstant(Value val) {</span>
<span class="line-modified">!         assert !(val instanceof ConstantValue) || ((ConstantValue) val).isJavaConstant();</span>
<span class="line-modified">!         return val instanceof ConstantValue;</span>
      }
  
<span class="line-modified">!     private static JavaConstant asConstant(Value val) {</span>
<span class="line-modified">!         return ((ConstantValue) val).getJavaConstant();</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static Register asRegOrTmpReg(CompilationResultBuilder crb, AMD64MacroAssembler asm, Value val, Register tmpReg) {</span>
<span class="line-modified">!         if (isRegister(val)) {</span>
<span class="line-modified">!             return asRegister(val);</span>
<span class="line-modified">!         } else if (isStackSlot(val)) {</span>
<span class="line-modified">!             asm.movl(tmpReg, (AMD64Address) crb.asAddress(val));</span>
<span class="line-modified">!             return tmpReg;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             assert isConstant(val);</span>
<span class="line-modified">!             asm.movl(tmpReg, asConstant(val).asInt());</span>
<span class="line-modified">!             return tmpReg;</span>
<span class="line-modified">!         }</span>
      }
  
      private static void emitAlign(CompilationResultBuilder crb, AMD64MacroAssembler asm) {
          asm.align(crb.target.wordSize * 2);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 491,98 ***</span>
              default:
                  throw new UnsupportedOperationException();
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-removed">-      * Convert a byte offset stored in {@code bytes} to an array index offset.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static void emitBytesToArraySlots(AMD64MacroAssembler asm, JavaKind kind, Register bytes) {</span>
<span class="line-removed">-         if (charMode(kind)) {</span>
<span class="line-removed">-             asm.shrl(bytes, 1);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             assert byteMode(kind);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static void emitVectorCompare(AMD64MacroAssembler asm,</span>
                      JavaKind kind,
<span class="line-removed">-                     AVXKind.AVXSize vectorSize,</span>
<span class="line-removed">-                     int nValues,</span>
                      int nVectors,
<span class="line-removed">-                     int[] vectorOffsets,</span>
                      Register arrayPtr,
                      Register[] vecCmp,
                      Register[] vecArray,
                      Register[] cmpResult,
                      Label[] vectorFound,
                      boolean alignedLoad) {
          // load array contents into vectors
<span class="line-modified">!         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-modified">!             for (int j = 0; j &lt; nVectors; j++) {</span>
<span class="line-modified">!                 emitArrayLoad(asm, vectorSize, vecArray[(i * nVectors) + j], arrayPtr, vectorOffsets[j], alignedLoad);</span>
              }
          }
          // compare all loaded bytes to the search value.
          // matching bytes are set to 0xff, non-matching bytes are set to 0x00.
<span class="line-modified">!         for (int i = 0; i &lt; nValues; i++) {</span>
<span class="line-removed">-             for (int j = 0; j &lt; nVectors; j++) {</span>
<span class="line-removed">-                 emitVectorCompareInst(asm, kind, vectorSize, vecArray[(i * nVectors) + j], vecCmp[i]);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // create 32-bit-masks from the most significant bit of every byte in the comparison</span>
<span class="line-removed">-         // results.</span>
<span class="line-removed">-         for (int i = 0; i &lt; nValues * nVectors; i++) {</span>
<span class="line-removed">-             emitMOVMSK(asm, vectorSize, cmpResult[i], vecArray[i]);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // join results of comparisons against multiple values</span>
<span class="line-removed">-         for (int stride = 1; stride &lt; nValues; stride *= 2) {</span>
              for (int i = 0; i &lt; nVectors; i++) {
<span class="line-modified">!                 for (int j = 0; j + stride &lt; nValues; j += stride * 2) {</span>
<span class="line-modified">!                     asm.orl(cmpResult[i + (j * nVectors)], cmpResult[i + ((j + stride) * nVectors)]);</span>
                  }
              }
<span class="line-removed">-         }</span>
<span class="line-removed">-         // check if a match was found</span>
<span class="line-removed">-         for (int i = 0; i &lt; nVectors; i++) {</span>
<span class="line-removed">-             asm.testl(cmpResult[i], cmpResult[i]);</span>
<span class="line-removed">-             asm.jcc(AMD64Assembler.ConditionFlag.NotZero, vectorFound[i]);</span>
          }
      }
  
<span class="line-modified">!     private static void emitVectorFoundWithOffset(AMD64MacroAssembler asm,</span>
<span class="line-modified">!                     JavaKind kind,</span>
<span class="line-modified">!                     int resultOffset,</span>
<span class="line-modified">!                     Register result,</span>
<span class="line-modified">!                     Register cmpResult,</span>
<span class="line-modified">!                     Register slotsRemaining,</span>
<span class="line-removed">-                     Label entry,</span>
<span class="line-removed">-                     Label ret) {</span>
<span class="line-removed">-         asm.bind(entry);</span>
<span class="line-removed">-         if (resultOffset &gt; 0) {</span>
<span class="line-removed">-             // adjust array pointer</span>
<span class="line-removed">-             asm.addq(result, resultOffset);</span>
<span class="line-removed">-             // adjust number of array slots remaining</span>
<span class="line-removed">-             asm.subl(slotsRemaining, charMode(kind) ? resultOffset / 2 : resultOffset);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // find index of first set bit in bit mask</span>
<span class="line-removed">-         asm.bsfq(cmpResult, cmpResult);</span>
<span class="line-removed">-         // add offset to array pointer</span>
<span class="line-removed">-         asm.addq(result, cmpResult);</span>
<span class="line-removed">-         if (charMode(kind)) {</span>
<span class="line-removed">-             // convert byte offset to chars</span>
<span class="line-removed">-             asm.shrl(cmpResult, 1);</span>
          }
<span class="line-removed">-         // adjust number of array slots remaining</span>
<span class="line-removed">-         asm.subl(slotsRemaining, cmpResult);</span>
<span class="line-removed">-         asm.jmpb(ret);</span>
      }
  
<span class="line-modified">!     private static void emitArrayLoad(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register vecDst, Register arrayPtr, int offset, boolean alignedLoad) {</span>
<span class="line-modified">!         AMD64Address src = new AMD64Address(arrayPtr, offset);</span>
          if (asm.supports(CPUFeature.AVX)) {
<span class="line-modified">!             VexMoveOp loadOp = alignedLoad ? VexMoveOp.VMOVDQA : VexMoveOp.VMOVDQU;</span>
              loadOp.emit(asm, vectorSize, vecDst, src);
          } else {
              // SSE
              asm.movdqu(vecDst, src);
          }
<span class="line-new-header">--- 503,70 ---</span>
              default:
                  throw new UnsupportedOperationException();
          }
      }
  
<span class="line-modified">!     private void emitVectorCompare(AMD64MacroAssembler asm,</span>
                      JavaKind kind,
                      int nVectors,
                      Register arrayPtr,
<span class="line-added">+                     Register index,</span>
                      Register[] vecCmp,
                      Register[] vecArray,
                      Register[] cmpResult,
                      Label[] vectorFound,
<span class="line-added">+                     boolean shortJmp,</span>
                      boolean alignedLoad) {
          // load array contents into vectors
<span class="line-modified">!         for (int i = 0; i &lt; nVectors; i++) {</span>
<span class="line-modified">!             int base = i * nValues;</span>
<span class="line-modified">!             for (int j = 0; j &lt; nValues; j++) {</span>
<span class="line-added">+                 emitArrayLoad(asm, getVectorSize(), vecArray[base + j], arrayPtr, index, getVectorOffset(nVectors - (i + 1)), alignedLoad);</span>
              }
          }
          // compare all loaded bytes to the search value.
          // matching bytes are set to 0xff, non-matching bytes are set to 0x00.
<span class="line-modified">!         if (!findTwoConsecutive) {</span>
              for (int i = 0; i &lt; nVectors; i++) {
<span class="line-modified">!                 int base = i * nValues;</span>
<span class="line-modified">!                 for (int j = 0; j &lt; nValues; j++) {</span>
<span class="line-added">+                     emitVectorCompareInst(asm, kind, getVectorSize(), vecArray[base + j], vecCmp[j]);</span>
<span class="line-added">+                     if ((j &amp; 1) == 1) {</span>
<span class="line-added">+                         emitPOR(asm, getVectorSize(), vecArray[base + j - 1], vecArray[base + j]);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (nValues &gt; 2) {</span>
<span class="line-added">+                     emitPOR(asm, getVectorSize(), vecArray[base], vecArray[base + 2]);</span>
                  }
<span class="line-added">+                 emitMOVMSK(asm, getVectorSize(), cmpResult[0], vecArray[base]);</span>
<span class="line-added">+                 emitJnz(asm, cmpResult[0], vectorFound[nVectors - (i + 1)], shortJmp);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             for (int i = 0; i &lt; nVectors; i += 2) {</span>
<span class="line-added">+                 emitVectorCompareInst(asm, kind, getVectorSize(), vecArray[i], vecCmp[0]);</span>
<span class="line-added">+                 emitVectorCompareInst(asm, kind, getVectorSize(), vecArray[i + 1], vecCmp[0]);</span>
<span class="line-added">+                 emitMOVMSK(asm, getVectorSize(), cmpResult[1], vecArray[i]);</span>
<span class="line-added">+                 emitMOVMSK(asm, getVectorSize(), cmpResult[0], vecArray[i + 1]);</span>
<span class="line-added">+                 emitJnz(asm, cmpResult[1], vectorFound[nVectors - (i + 1)], shortJmp);</span>
<span class="line-added">+                 emitJnz(asm, cmpResult[0], vectorFound[nVectors - (i + 2)], shortJmp);</span>
              }
          }
      }
  
<span class="line-modified">!     private static void emitJnz(AMD64MacroAssembler asm, Register cond, Label tgt, boolean shortJmp) {</span>
<span class="line-modified">!         asm.testl(cond, cond);</span>
<span class="line-modified">!         if (shortJmp) {</span>
<span class="line-modified">!             asm.jccb(AMD64Assembler.ConditionFlag.NotZero, tgt);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             asm.jcc(AMD64Assembler.ConditionFlag.NotZero, tgt);</span>
          }
      }
  
<span class="line-modified">!     private void emitArrayLoad(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register vecDst, Register arrayPtr, Register index, int offset, boolean alignedLoad) {</span>
<span class="line-modified">!         AMD64Address src = new AMD64Address(arrayPtr, index, arrayIndexScale, offset);</span>
          if (asm.supports(CPUFeature.AVX)) {
<span class="line-modified">!             VexMoveOp loadOp = alignedLoad ? VexMoveOp.VMOVDQA32 : VexMoveOp.VMOVDQU32;</span>
              loadOp.emit(asm, vectorSize, vecDst, src);
          } else {
              // SSE
              asm.movdqu(vecDst, src);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 619,39 ***</span>
              default:
                  throw new UnsupportedOperationException();
          }
      }
  
      private static void emitMOVMSK(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register dst, Register vecSrc) {
          if (asm.supports(CPUFeature.AVX)) {
              VexRMOp.VPMOVMSKB.emit(asm, vectorSize, dst, vecSrc);
          } else {
              // SSE
              asm.pmovmskb(dst, vecSrc);
          }
      }
  
<span class="line-modified">!     private static void emitCompareInst(AMD64MacroAssembler asm, JavaKind kind, Register dst, Register src) {</span>
          switch (kind) {
              case Byte:
<span class="line-modified">!                 asm.cmpb(dst, src);</span>
<span class="line-removed">-                 break;</span>
              case Short:
              case Char:
<span class="line-modified">!                 asm.cmpw(dst, src);</span>
<span class="line-removed">-                 break;</span>
              case Int:
<span class="line-modified">!                 asm.cmpl(dst, src);</span>
<span class="line-removed">-                 break;</span>
              default:
<span class="line-modified">!                 asm.cmpq(dst, src);</span>
          }
      }
  
      private static boolean supportsAVX2(LIRGeneratorTool tool) {
          return supports(tool, CPUFeature.AVX2);
      }
  
      private static boolean supports(LIRGeneratorTool tool, CPUFeature cpuFeature) {
          return ((AMD64) tool.target().arch).getFeatures().contains(cpuFeature);
      }
  }
<span class="line-new-header">--- 603,50 ---</span>
              default:
                  throw new UnsupportedOperationException();
          }
      }
  
<span class="line-added">+     private static void emitPOR(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register dst, Register vecSrc) {</span>
<span class="line-added">+         if (asm.supports(CPUFeature.AVX)) {</span>
<span class="line-added">+             VexRVMOp.VPOR.emit(asm, vectorSize, dst, dst, vecSrc);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             // SSE</span>
<span class="line-added">+             asm.por(dst, vecSrc);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private static void emitMOVMSK(AMD64MacroAssembler asm, AVXKind.AVXSize vectorSize, Register dst, Register vecSrc) {
          if (asm.supports(CPUFeature.AVX)) {
              VexRMOp.VPMOVMSKB.emit(asm, vectorSize, dst, vecSrc);
          } else {
              // SSE
              asm.pmovmskb(dst, vecSrc);
          }
      }
  
<span class="line-modified">!     private static OperandSize getOpSize(JavaKind kind) {</span>
          switch (kind) {
              case Byte:
<span class="line-modified">!                 return OperandSize.BYTE;</span>
              case Short:
              case Char:
<span class="line-modified">!                 return OperandSize.WORD;</span>
              case Int:
<span class="line-modified">!                 return OperandSize.DWORD;</span>
              default:
<span class="line-modified">!                 return OperandSize.QWORD;</span>
          }
      }
  
      private static boolean supportsAVX2(LIRGeneratorTool tool) {
          return supports(tool, CPUFeature.AVX2);
      }
  
      private static boolean supports(LIRGeneratorTool tool, CPUFeature cpuFeature) {
          return ((AMD64) tool.target().arch).getFeatures().contains(cpuFeature);
      }
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public boolean needsClearUpperVectorRegisters() {</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="AMD64ArrayEqualsOp.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64Binary.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
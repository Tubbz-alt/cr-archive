diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Binary.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Binary.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Binary.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Binary.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -135,10 +135,15 @@
             } else {
                 assert isStackSlot(input);
                 opcode.emit(masm, size, asRegister(result), (AMD64Address) crb.asAddress(input));
             }
         }
+
+        public AMD64RMOp getOpcode() {
+            return opcode;
+        }
+
     }
 
     /**
      * Instruction that has one {@link AllocatableValue} operand and one 32-bit immediate operand.
      */
@@ -261,10 +266,15 @@
                 state = nullCheckState;
                 return true;
             }
             return false;
         }
+
+        public AMD64RMOp getOpcode() {
+            return opcode;
+        }
+
     }
 
     /**
      * Instruction with a separate result operand, one {@link AllocatableValue} input and one 32-bit
      * immediate input.

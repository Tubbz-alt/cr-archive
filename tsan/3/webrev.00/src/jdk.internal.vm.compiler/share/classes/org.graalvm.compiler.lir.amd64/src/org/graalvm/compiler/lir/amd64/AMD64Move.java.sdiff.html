<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Move.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64MathTanOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64RestoreRegistersOp.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Move.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  79     private abstract static class AbstractMoveOp extends AMD64LIRInstruction implements ValueMoveOp {
  80         public static final LIRInstructionClass&lt;AbstractMoveOp&gt; TYPE = LIRInstructionClass.create(AbstractMoveOp.class);
  81 
  82         private AMD64Kind moveKind;
  83 
  84         protected AbstractMoveOp(LIRInstructionClass&lt;? extends AbstractMoveOp&gt; c, AMD64Kind moveKind) {
  85             super(c);
  86             this.moveKind = moveKind;
  87         }
  88 
  89         @Override
  90         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
  91             move(moveKind, crb, masm, getResult(), getInput());
  92         }
  93     }
  94 
  95     @Opcode(&quot;MOVE&quot;)
  96     public static final class MoveToRegOp extends AbstractMoveOp {
  97         public static final LIRInstructionClass&lt;MoveToRegOp&gt; TYPE = LIRInstructionClass.create(MoveToRegOp.class);
  98 
<span class="line-modified">  99         @Def({REG, HINT}) protected AllocatableValue result;</span>
 100         @Use({REG, STACK}) protected AllocatableValue input;
 101 
 102         public MoveToRegOp(AMD64Kind moveKind, AllocatableValue result, AllocatableValue input) {
 103             super(TYPE, moveKind);
 104             this.result = result;
 105             this.input = input;
 106         }
 107 
 108         @Override
 109         public AllocatableValue getInput() {
 110             return input;
 111         }
 112 
 113         @Override
 114         public AllocatableValue getResult() {
 115             return result;
 116         }
 117     }
 118 
 119     @Opcode(&quot;MOVE&quot;)
</pre>
<hr />
<pre>
 139             return result;
 140         }
 141     }
 142 
 143     @Opcode(&quot;MOVE&quot;)
 144     public static class MoveFromConstOp extends AMD64LIRInstruction implements LoadConstantOp {
 145         public static final LIRInstructionClass&lt;MoveFromConstOp&gt; TYPE = LIRInstructionClass.create(MoveFromConstOp.class);
 146 
 147         @Def({REG, STACK}) protected AllocatableValue result;
 148         private final JavaConstant input;
 149 
 150         public MoveFromConstOp(AllocatableValue result, JavaConstant input) {
 151             super(TYPE);
 152             this.result = result;
 153             this.input = input;
 154         }
 155 
 156         @Override
 157         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 158             if (isRegister(result)) {
<span class="line-modified"> 159                 const2reg(crb, masm, asRegister(result), input);</span>
 160             } else {
 161                 assert isStackSlot(result);
 162                 const2stack(crb, masm, result, input);
 163             }
 164         }
 165 
 166         @Override
 167         public Constant getConstant() {
 168             return input;
 169         }
 170 
 171         @Override
 172         public AllocatableValue getResult() {
 173             return result;
 174         }
 175     }
 176 
 177     @Opcode(&quot;STACKMOVE&quot;)
 178     public static final class AMD64StackMove extends AMD64LIRInstruction implements ValueMoveOp {
 179         public static final LIRInstructionClass&lt;AMD64StackMove&gt; TYPE = LIRInstructionClass.create(AMD64StackMove.class);
</pre>
<hr />
<pre>
 540         move((AMD64Kind) result.getPlatformKind(), crb, masm, result, input);
 541     }
 542 
 543     public static void move(AMD64Kind moveKind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Value input) {
 544         if (isRegister(input)) {
 545             if (isRegister(result)) {
 546                 reg2reg(moveKind, masm, result, input);
 547             } else if (isStackSlot(result)) {
 548                 reg2stack(moveKind, crb, masm, result, asRegister(input));
 549             } else {
 550                 throw GraalError.shouldNotReachHere();
 551             }
 552         } else if (isStackSlot(input)) {
 553             if (isRegister(result)) {
 554                 stack2reg(moveKind, crb, masm, asRegister(result), input);
 555             } else {
 556                 throw GraalError.shouldNotReachHere();
 557             }
 558         } else if (isJavaConstant(input)) {
 559             if (isRegister(result)) {
<span class="line-modified"> 560                 const2reg(crb, masm, asRegister(result), asJavaConstant(input));</span>
 561             } else if (isStackSlot(result)) {
 562                 const2stack(crb, masm, result, asJavaConstant(input));
 563             } else {
 564                 throw GraalError.shouldNotReachHere();
 565             }
 566         } else {
 567             throw GraalError.shouldNotReachHere();
 568         }
 569     }
 570 
 571     private static void reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input) {
 572         if (asRegister(input).equals(asRegister(result))) {
 573             return;
 574         }
 575         assert asRegister(result).getRegisterCategory().equals(asRegister(input).getRegisterCategory());
 576         switch (kind) {
 577             case BYTE:
 578             case WORD:
 579             case DWORD:
 580                 masm.movl(asRegister(result), asRegister(input));
</pre>
<hr />
<pre>
 628             case WORD:
 629                 masm.movswl(result, src);
 630                 break;
 631             case DWORD:
 632                 masm.movl(result, src);
 633                 break;
 634             case QWORD:
 635                 masm.movq(result, src);
 636                 break;
 637             case SINGLE:
 638                 masm.movflt(result, src);
 639                 break;
 640             case DOUBLE:
 641                 masm.movdbl(result, src);
 642                 break;
 643             default:
 644                 throw GraalError.shouldNotReachHere();
 645         }
 646     }
 647 
<span class="line-modified"> 648     public static void const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input) {</span>
 649         /*
 650          * Note: we use the kind of the input operand (and not the kind of the result operand)
 651          * because they don&#39;t match in all cases. For example, an object constant can be loaded to a
 652          * long register when unsafe casts occurred (e.g., for a write barrier where arithmetic
 653          * operations are then performed on the pointer).
 654          */
 655         switch (input.getJavaKind().getStackKind()) {
 656             case Int:
 657                 // Do not optimize with an XOR as this instruction may be between
 658                 // a CMP and a Jcc in which case the XOR will modify the condition
 659                 // flags and interfere with the Jcc.
 660                 masm.movl(result, input.asInt());
 661 
 662                 break;
 663             case Long:
 664                 // Do not optimize with an XOR as this instruction may be between
 665                 // a CMP and a Jcc in which case the XOR will modify the condition
 666                 // flags and interfere with the Jcc.
 667                 if (input.asLong() == (int) input.asLong()) {
 668                     // Sign extended to long
</pre>
<hr />
<pre>
 674                     masm.movq(result, input.asLong());
 675                 }
 676                 break;
 677             case Float:
 678                 // This is *not* the same as &#39;constant == 0.0f&#39; in the case where constant is -0.0f
 679                 if (Float.floatToRawIntBits(input.asFloat()) == Float.floatToRawIntBits(0.0f)) {
 680                     masm.xorps(result, result);
 681                 } else {
 682                     masm.movflt(result, (AMD64Address) crb.asFloatConstRef(input));
 683                 }
 684                 break;
 685             case Double:
 686                 // This is *not* the same as &#39;constant == 0.0d&#39; in the case where constant is -0.0d
 687                 if (Double.doubleToRawLongBits(input.asDouble()) == Double.doubleToRawLongBits(0.0d)) {
 688                     masm.xorpd(result, result);
 689                 } else {
 690                     masm.movdbl(result, (AMD64Address) crb.asDoubleConstRef(input));
 691                 }
 692                 break;
 693             case Object:

 694                 // Do not optimize with an XOR as this instruction may be between
 695                 // a CMP and a Jcc in which case the XOR will modify the condition
 696                 // flags and interfere with the Jcc.
 697                 if (input.isNull()) {
<span class="line-modified"> 698                     if (crb.mustReplaceWithNullRegister(input)) {</span>
<span class="line-modified"> 699                         masm.movq(result, crb.nullRegister);</span>
 700                     } else {

 701                         masm.movslq(result, 0);
 702                     }
<span class="line-removed"> 703                 } else if (crb.target.inlineObjects) {</span>
<span class="line-removed"> 704                     crb.recordInlineDataInCode(input);</span>
<span class="line-removed"> 705                     masm.movq(result, 0xDEADDEADDEADDEADL, true);</span>
 706                 } else {
<span class="line-modified"> 707                     masm.movq(result, (AMD64Address) crb.recordDataReferenceInCode(input, 0));</span>















 708                 }
 709                 break;
 710             default:
 711                 throw GraalError.shouldNotReachHere();
 712         }
 713     }
 714 
 715     public static boolean canMoveConst2Stack(JavaConstant input) {
 716         switch (input.getJavaKind().getStackKind()) {
 717             case Int:
 718                 break;
 719             case Long:
 720                 break;
 721             case Float:
 722                 break;
 723             case Double:
 724                 break;
 725             case Object:
 726                 if (input.isNull()) {
 727                     return true;
</pre>
<hr />
<pre>
 735     }
 736 
 737     public static void const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input) {
 738         AMD64Address dest = (AMD64Address) crb.asAddress(result);
 739         final long imm;
 740         switch (input.getJavaKind().getStackKind()) {
 741             case Int:
 742                 imm = input.asInt();
 743                 break;
 744             case Long:
 745                 imm = input.asLong();
 746                 break;
 747             case Float:
 748                 imm = floatToRawIntBits(input.asFloat());
 749                 break;
 750             case Double:
 751                 imm = doubleToRawLongBits(input.asDouble());
 752                 break;
 753             case Object:
 754                 if (input.isNull()) {
<span class="line-modified"> 755                     if (crb.mustReplaceWithNullRegister(input)) {</span>
<span class="line-modified"> 756                         masm.movq(dest, crb.nullRegister);</span>
 757                         return;
 758                     }
 759                     imm = 0;
 760                 } else {
<span class="line-modified"> 761                     throw GraalError.shouldNotReachHere(&quot;Non-null object constants must be in register&quot;);</span>
 762                 }
 763                 break;
 764             default:
 765                 throw GraalError.shouldNotReachHere();
 766         }
 767 
 768         switch ((AMD64Kind) result.getPlatformKind()) {
 769             case BYTE:
 770                 assert NumUtil.isByte(imm) : &quot;Is not in byte range: &quot; + imm;
 771                 AMD64MIOp.MOVB.emit(masm, OperandSize.BYTE, dest, (int) imm);
 772                 break;
 773             case WORD:
 774                 assert NumUtil.isShort(imm) : &quot;Is not in short range: &quot; + imm;
 775                 AMD64MIOp.MOV.emit(masm, OperandSize.WORD, dest, (int) imm);
 776                 break;
 777             case DWORD:
 778             case SINGLE:
 779                 assert NumUtil.isInt(imm) : &quot;Is not in int range: &quot; + imm;
 780                 masm.movl(dest, (int) imm);
 781                 break;
</pre>
<hr />
<pre>
 924                     masm.jccb(Equal, done);
 925                     masm.addq(resReg, baseReg);
 926                     masm.bind(done);
 927                 }
 928             }
 929         }
 930     }
 931 
 932     private abstract static class ZeroNullConversionOp extends AMD64LIRInstruction {
 933         @Def({REG, HINT}) protected AllocatableValue result;
 934         @Use({REG}) protected AllocatableValue input;
 935 
 936         protected ZeroNullConversionOp(LIRInstructionClass&lt;? extends ZeroNullConversionOp&gt; type, AllocatableValue result, AllocatableValue input) {
 937             super(type);
 938             this.result = result;
 939             this.input = input;
 940         }
 941 
 942         @Override
 943         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
<span class="line-modified"> 944             Register nullRegister = crb.nullRegister;</span>
 945             if (!nullRegister.equals(Register.None)) {
 946                 emitConversion(asRegister(result), asRegister(input), nullRegister, masm);
 947             }
 948         }
 949 
 950         protected abstract void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm);
 951     }
 952 
 953     public static class ConvertNullToZeroOp extends ZeroNullConversionOp {
 954         public static final LIRInstructionClass&lt;ConvertNullToZeroOp&gt; TYPE = LIRInstructionClass.create(ConvertNullToZeroOp.class);
 955 
 956         public ConvertNullToZeroOp(AllocatableValue result, AllocatableValue input) {
 957             super(TYPE, result, input);
 958         }
 959 
 960         @Override
 961         protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm) {
 962             if (inputRegister.equals(resultRegister)) {
 963                 masm.subq(inputRegister, nullRegister);
 964                 Label done = new Label();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  79     private abstract static class AbstractMoveOp extends AMD64LIRInstruction implements ValueMoveOp {
  80         public static final LIRInstructionClass&lt;AbstractMoveOp&gt; TYPE = LIRInstructionClass.create(AbstractMoveOp.class);
  81 
  82         private AMD64Kind moveKind;
  83 
  84         protected AbstractMoveOp(LIRInstructionClass&lt;? extends AbstractMoveOp&gt; c, AMD64Kind moveKind) {
  85             super(c);
  86             this.moveKind = moveKind;
  87         }
  88 
  89         @Override
  90         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
  91             move(moveKind, crb, masm, getResult(), getInput());
  92         }
  93     }
  94 
  95     @Opcode(&quot;MOVE&quot;)
  96     public static final class MoveToRegOp extends AbstractMoveOp {
  97         public static final LIRInstructionClass&lt;MoveToRegOp&gt; TYPE = LIRInstructionClass.create(MoveToRegOp.class);
  98 
<span class="line-modified">  99         @Def({REG, STACK, HINT}) protected AllocatableValue result;</span>
 100         @Use({REG, STACK}) protected AllocatableValue input;
 101 
 102         public MoveToRegOp(AMD64Kind moveKind, AllocatableValue result, AllocatableValue input) {
 103             super(TYPE, moveKind);
 104             this.result = result;
 105             this.input = input;
 106         }
 107 
 108         @Override
 109         public AllocatableValue getInput() {
 110             return input;
 111         }
 112 
 113         @Override
 114         public AllocatableValue getResult() {
 115             return result;
 116         }
 117     }
 118 
 119     @Opcode(&quot;MOVE&quot;)
</pre>
<hr />
<pre>
 139             return result;
 140         }
 141     }
 142 
 143     @Opcode(&quot;MOVE&quot;)
 144     public static class MoveFromConstOp extends AMD64LIRInstruction implements LoadConstantOp {
 145         public static final LIRInstructionClass&lt;MoveFromConstOp&gt; TYPE = LIRInstructionClass.create(MoveFromConstOp.class);
 146 
 147         @Def({REG, STACK}) protected AllocatableValue result;
 148         private final JavaConstant input;
 149 
 150         public MoveFromConstOp(AllocatableValue result, JavaConstant input) {
 151             super(TYPE);
 152             this.result = result;
 153             this.input = input;
 154         }
 155 
 156         @Override
 157         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 158             if (isRegister(result)) {
<span class="line-modified"> 159                 const2reg(crb, masm, asRegister(result), input, (AMD64Kind) result.getPlatformKind());</span>
 160             } else {
 161                 assert isStackSlot(result);
 162                 const2stack(crb, masm, result, input);
 163             }
 164         }
 165 
 166         @Override
 167         public Constant getConstant() {
 168             return input;
 169         }
 170 
 171         @Override
 172         public AllocatableValue getResult() {
 173             return result;
 174         }
 175     }
 176 
 177     @Opcode(&quot;STACKMOVE&quot;)
 178     public static final class AMD64StackMove extends AMD64LIRInstruction implements ValueMoveOp {
 179         public static final LIRInstructionClass&lt;AMD64StackMove&gt; TYPE = LIRInstructionClass.create(AMD64StackMove.class);
</pre>
<hr />
<pre>
 540         move((AMD64Kind) result.getPlatformKind(), crb, masm, result, input);
 541     }
 542 
 543     public static void move(AMD64Kind moveKind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Value input) {
 544         if (isRegister(input)) {
 545             if (isRegister(result)) {
 546                 reg2reg(moveKind, masm, result, input);
 547             } else if (isStackSlot(result)) {
 548                 reg2stack(moveKind, crb, masm, result, asRegister(input));
 549             } else {
 550                 throw GraalError.shouldNotReachHere();
 551             }
 552         } else if (isStackSlot(input)) {
 553             if (isRegister(result)) {
 554                 stack2reg(moveKind, crb, masm, asRegister(result), input);
 555             } else {
 556                 throw GraalError.shouldNotReachHere();
 557             }
 558         } else if (isJavaConstant(input)) {
 559             if (isRegister(result)) {
<span class="line-modified"> 560                 const2reg(crb, masm, asRegister(result), asJavaConstant(input), moveKind);</span>
 561             } else if (isStackSlot(result)) {
 562                 const2stack(crb, masm, result, asJavaConstant(input));
 563             } else {
 564                 throw GraalError.shouldNotReachHere();
 565             }
 566         } else {
 567             throw GraalError.shouldNotReachHere();
 568         }
 569     }
 570 
 571     private static void reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input) {
 572         if (asRegister(input).equals(asRegister(result))) {
 573             return;
 574         }
 575         assert asRegister(result).getRegisterCategory().equals(asRegister(input).getRegisterCategory());
 576         switch (kind) {
 577             case BYTE:
 578             case WORD:
 579             case DWORD:
 580                 masm.movl(asRegister(result), asRegister(input));
</pre>
<hr />
<pre>
 628             case WORD:
 629                 masm.movswl(result, src);
 630                 break;
 631             case DWORD:
 632                 masm.movl(result, src);
 633                 break;
 634             case QWORD:
 635                 masm.movq(result, src);
 636                 break;
 637             case SINGLE:
 638                 masm.movflt(result, src);
 639                 break;
 640             case DOUBLE:
 641                 masm.movdbl(result, src);
 642                 break;
 643             default:
 644                 throw GraalError.shouldNotReachHere();
 645         }
 646     }
 647 
<span class="line-modified"> 648     public static void const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind) {</span>
 649         /*
 650          * Note: we use the kind of the input operand (and not the kind of the result operand)
 651          * because they don&#39;t match in all cases. For example, an object constant can be loaded to a
 652          * long register when unsafe casts occurred (e.g., for a write barrier where arithmetic
 653          * operations are then performed on the pointer).
 654          */
 655         switch (input.getJavaKind().getStackKind()) {
 656             case Int:
 657                 // Do not optimize with an XOR as this instruction may be between
 658                 // a CMP and a Jcc in which case the XOR will modify the condition
 659                 // flags and interfere with the Jcc.
 660                 masm.movl(result, input.asInt());
 661 
 662                 break;
 663             case Long:
 664                 // Do not optimize with an XOR as this instruction may be between
 665                 // a CMP and a Jcc in which case the XOR will modify the condition
 666                 // flags and interfere with the Jcc.
 667                 if (input.asLong() == (int) input.asLong()) {
 668                     // Sign extended to long
</pre>
<hr />
<pre>
 674                     masm.movq(result, input.asLong());
 675                 }
 676                 break;
 677             case Float:
 678                 // This is *not* the same as &#39;constant == 0.0f&#39; in the case where constant is -0.0f
 679                 if (Float.floatToRawIntBits(input.asFloat()) == Float.floatToRawIntBits(0.0f)) {
 680                     masm.xorps(result, result);
 681                 } else {
 682                     masm.movflt(result, (AMD64Address) crb.asFloatConstRef(input));
 683                 }
 684                 break;
 685             case Double:
 686                 // This is *not* the same as &#39;constant == 0.0d&#39; in the case where constant is -0.0d
 687                 if (Double.doubleToRawLongBits(input.asDouble()) == Double.doubleToRawLongBits(0.0d)) {
 688                     masm.xorpd(result, result);
 689                 } else {
 690                     masm.movdbl(result, (AMD64Address) crb.asDoubleConstRef(input));
 691                 }
 692                 break;
 693             case Object:
<span class="line-added"> 694                 assert moveKind != null : &quot;a nun-null moveKind is required for loading an object constant&quot;;</span>
 695                 // Do not optimize with an XOR as this instruction may be between
 696                 // a CMP and a Jcc in which case the XOR will modify the condition
 697                 // flags and interfere with the Jcc.
 698                 if (input.isNull()) {
<span class="line-modified"> 699                     if (moveKind == AMD64Kind.QWORD &amp;&amp; crb.mustReplaceWithUncompressedNullRegister(input)) {</span>
<span class="line-modified"> 700                         masm.movq(result, crb.uncompressedNullRegister);</span>
 701                     } else {
<span class="line-added"> 702                         // Upper bits will be zeroed so this also works for narrow oops</span>
 703                         masm.movslq(result, 0);
 704                     }



 705                 } else {
<span class="line-modified"> 706                     if (crb.target.inlineObjects) {</span>
<span class="line-added"> 707                         crb.recordInlineDataInCode(input);</span>
<span class="line-added"> 708                         if (moveKind == AMD64Kind.DWORD) {</span>
<span class="line-added"> 709                             // Support for narrow oops</span>
<span class="line-added"> 710                             masm.movl(result, 0xDEADDEAD, true);</span>
<span class="line-added"> 711                         } else {</span>
<span class="line-added"> 712                             masm.movq(result, 0xDEADDEADDEADDEADL, true);</span>
<span class="line-added"> 713                         }</span>
<span class="line-added"> 714                     } else {</span>
<span class="line-added"> 715                         if (moveKind == AMD64Kind.DWORD) {</span>
<span class="line-added"> 716                             // Support for narrow oops</span>
<span class="line-added"> 717                             masm.movl(result, (AMD64Address) crb.recordDataReferenceInCode(input, 0));</span>
<span class="line-added"> 718                         } else {</span>
<span class="line-added"> 719                             masm.movq(result, (AMD64Address) crb.recordDataReferenceInCode(input, 0));</span>
<span class="line-added"> 720                         }</span>
<span class="line-added"> 721                     }</span>
 722                 }
 723                 break;
 724             default:
 725                 throw GraalError.shouldNotReachHere();
 726         }
 727     }
 728 
 729     public static boolean canMoveConst2Stack(JavaConstant input) {
 730         switch (input.getJavaKind().getStackKind()) {
 731             case Int:
 732                 break;
 733             case Long:
 734                 break;
 735             case Float:
 736                 break;
 737             case Double:
 738                 break;
 739             case Object:
 740                 if (input.isNull()) {
 741                     return true;
</pre>
<hr />
<pre>
 749     }
 750 
 751     public static void const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input) {
 752         AMD64Address dest = (AMD64Address) crb.asAddress(result);
 753         final long imm;
 754         switch (input.getJavaKind().getStackKind()) {
 755             case Int:
 756                 imm = input.asInt();
 757                 break;
 758             case Long:
 759                 imm = input.asLong();
 760                 break;
 761             case Float:
 762                 imm = floatToRawIntBits(input.asFloat());
 763                 break;
 764             case Double:
 765                 imm = doubleToRawLongBits(input.asDouble());
 766                 break;
 767             case Object:
 768                 if (input.isNull()) {
<span class="line-modified"> 769                     if (crb.mustReplaceWithUncompressedNullRegister(input)) {</span>
<span class="line-modified"> 770                         masm.movq(dest, crb.uncompressedNullRegister);</span>
 771                         return;
 772                     }
 773                     imm = 0;
 774                 } else {
<span class="line-modified"> 775                     throw GraalError.shouldNotReachHere(&quot;Non-null object constants must be in a register&quot;);</span>
 776                 }
 777                 break;
 778             default:
 779                 throw GraalError.shouldNotReachHere();
 780         }
 781 
 782         switch ((AMD64Kind) result.getPlatformKind()) {
 783             case BYTE:
 784                 assert NumUtil.isByte(imm) : &quot;Is not in byte range: &quot; + imm;
 785                 AMD64MIOp.MOVB.emit(masm, OperandSize.BYTE, dest, (int) imm);
 786                 break;
 787             case WORD:
 788                 assert NumUtil.isShort(imm) : &quot;Is not in short range: &quot; + imm;
 789                 AMD64MIOp.MOV.emit(masm, OperandSize.WORD, dest, (int) imm);
 790                 break;
 791             case DWORD:
 792             case SINGLE:
 793                 assert NumUtil.isInt(imm) : &quot;Is not in int range: &quot; + imm;
 794                 masm.movl(dest, (int) imm);
 795                 break;
</pre>
<hr />
<pre>
 938                     masm.jccb(Equal, done);
 939                     masm.addq(resReg, baseReg);
 940                     masm.bind(done);
 941                 }
 942             }
 943         }
 944     }
 945 
 946     private abstract static class ZeroNullConversionOp extends AMD64LIRInstruction {
 947         @Def({REG, HINT}) protected AllocatableValue result;
 948         @Use({REG}) protected AllocatableValue input;
 949 
 950         protected ZeroNullConversionOp(LIRInstructionClass&lt;? extends ZeroNullConversionOp&gt; type, AllocatableValue result, AllocatableValue input) {
 951             super(type);
 952             this.result = result;
 953             this.input = input;
 954         }
 955 
 956         @Override
 957         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
<span class="line-modified"> 958             Register nullRegister = crb.uncompressedNullRegister;</span>
 959             if (!nullRegister.equals(Register.None)) {
 960                 emitConversion(asRegister(result), asRegister(input), nullRegister, masm);
 961             }
 962         }
 963 
 964         protected abstract void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm);
 965     }
 966 
 967     public static class ConvertNullToZeroOp extends ZeroNullConversionOp {
 968         public static final LIRInstructionClass&lt;ConvertNullToZeroOp&gt; TYPE = LIRInstructionClass.create(ConvertNullToZeroOp.class);
 969 
 970         public ConvertNullToZeroOp(AllocatableValue result, AllocatableValue input) {
 971             super(TYPE, result, input);
 972         }
 973 
 974         @Override
 975         protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm) {
 976             if (inputRegister.equals(resultRegister)) {
 977                 masm.subq(inputRegister, nullRegister);
 978                 Label done = new Label();
</pre>
</td>
</tr>
</table>
<center><a href="AMD64MathTanOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64RestoreRegistersOp.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayEqualsOp.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64ArrayCompareToOp.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ArrayIndexOfOp.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayEqualsOp.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,17 ***</span>
   */
  
  
  package org.graalvm.compiler.lir.amd64;
  
<span class="line-modified">! import jdk.vm.ci.amd64.AMD64;</span>
<span class="line-modified">! import jdk.vm.ci.amd64.AMD64.CPUFeature;</span>
<span class="line-modified">! import jdk.vm.ci.amd64.AMD64Kind;</span>
<span class="line-modified">! import jdk.vm.ci.code.Register;</span>
<span class="line-modified">! import jdk.vm.ci.code.TargetDescription;</span>
<span class="line-modified">! import jdk.vm.ci.meta.JavaKind;</span>
<span class="line-modified">! import jdk.vm.ci.meta.Value;</span>
  import org.graalvm.compiler.asm.Label;
  import org.graalvm.compiler.asm.amd64.AMD64Address;
  import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
<span class="line-new-header">--- 22,18 ---</span>
   */
  
  
  package org.graalvm.compiler.lir.amd64;
  
<span class="line-modified">! import static jdk.vm.ci.code.ValueUtil.asRegister;</span>
<span class="line-modified">! import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.XOR;</span>
<span class="line-modified">! import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.CONST;</span>
<span class="line-modified">! import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
<span class="line-modified">! import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;</span>
<span class="line-modified">! </span>
<span class="line-modified">! import java.util.Objects;</span>
<span class="line-added">+ </span>
  import org.graalvm.compiler.asm.Label;
  import org.graalvm.compiler.asm.amd64.AMD64Address;
  import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 41,19 ***</span>
  import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
  import org.graalvm.compiler.asm.amd64.AVXKind;
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.lir.LIRInstructionClass;
  import org.graalvm.compiler.lir.Opcode;
  import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
  import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
  
<span class="line-modified">! import static jdk.vm.ci.code.ValueUtil.asRegister;</span>
<span class="line-modified">! import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
<span class="line-modified">! import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;</span>
<span class="line-modified">! </span>
<span class="line-modified">! import java.util.Objects;</span>
  
  /**
   * Emits code which compares two arrays of the same length. If the CPU supports any vector
   * instructions specialized code is emitted to leverage these instructions.
   *
<span class="line-new-header">--- 42,22 ---</span>
  import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
  import org.graalvm.compiler.asm.amd64.AVXKind;
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.lir.LIRInstructionClass;
<span class="line-added">+ import org.graalvm.compiler.lir.LIRValueUtil;</span>
  import org.graalvm.compiler.lir.Opcode;
  import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
  import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
  
<span class="line-modified">! import jdk.vm.ci.amd64.AMD64;</span>
<span class="line-modified">! import jdk.vm.ci.amd64.AMD64.CPUFeature;</span>
<span class="line-modified">! import jdk.vm.ci.amd64.AMD64Kind;</span>
<span class="line-modified">! import jdk.vm.ci.code.Register;</span>
<span class="line-modified">! import jdk.vm.ci.code.TargetDescription;</span>
<span class="line-added">+ import jdk.vm.ci.meta.JavaKind;</span>
<span class="line-added">+ import jdk.vm.ci.meta.Value;</span>
  
  /**
   * Emits code which compares two arrays of the same length. If the CPU supports any vector
   * instructions specialized code is emitted to leverage these instructions.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,32 ***</span>
      private final int arrayBaseOffset1;
      private final int arrayBaseOffset2;
      private final Scale arrayIndexScale1;
      private final Scale arrayIndexScale2;
      private final AVXKind.AVXSize vectorSize;
<span class="line-removed">-     private final int constantLength;</span>
      private final boolean signExtend;
  
      @Def({REG}) private Value resultValue;
      @Alive({REG}) private Value array1Value;
      @Alive({REG}) private Value array2Value;
<span class="line-modified">!     @Alive({REG}) private Value lengthValue;</span>
<span class="line-modified">!     @Temp({REG}) private Value temp1;</span>
<span class="line-modified">!     @Temp({REG}) private Value temp2;</span>
      @Temp({REG}) private Value temp3;
<span class="line-modified">!     @Temp({REG}) private Value temp4;</span>
  
      @Temp({REG, ILLEGAL}) private Value temp5;
      @Temp({REG, ILLEGAL}) private Value tempXMM;
  
      @Temp({REG, ILLEGAL}) private Value vectorTemp1;
      @Temp({REG, ILLEGAL}) private Value vectorTemp2;
      @Temp({REG, ILLEGAL}) private Value vectorTemp3;
      @Temp({REG, ILLEGAL}) private Value vectorTemp4;
  
      public AMD64ArrayEqualsOp(LIRGeneratorTool tool, JavaKind kind1, JavaKind kind2, Value result, Value array1, Value array2, Value length,
<span class="line-modified">!                     int constantLength, boolean directPointers, int maxVectorSize) {</span>
          super(TYPE);
          this.kind1 = kind1;
          this.kind2 = kind2;
          this.signExtend = kind1 != JavaKind.Char &amp;&amp; kind2 != JavaKind.Char;
  
<span class="line-new-header">--- 74,31 ---</span>
      private final int arrayBaseOffset1;
      private final int arrayBaseOffset2;
      private final Scale arrayIndexScale1;
      private final Scale arrayIndexScale2;
      private final AVXKind.AVXSize vectorSize;
      private final boolean signExtend;
  
      @Def({REG}) private Value resultValue;
      @Alive({REG}) private Value array1Value;
      @Alive({REG}) private Value array2Value;
<span class="line-modified">!     @Alive({REG, CONST}) private Value lengthValue;</span>
<span class="line-modified">!     @Temp({REG, ILLEGAL}) private Value temp1;</span>
<span class="line-modified">!     @Temp({REG, ILLEGAL}) private Value temp2;</span>
      @Temp({REG}) private Value temp3;
<span class="line-modified">!     @Temp({REG, ILLEGAL}) private Value temp4;</span>
  
      @Temp({REG, ILLEGAL}) private Value temp5;
      @Temp({REG, ILLEGAL}) private Value tempXMM;
  
      @Temp({REG, ILLEGAL}) private Value vectorTemp1;
      @Temp({REG, ILLEGAL}) private Value vectorTemp2;
      @Temp({REG, ILLEGAL}) private Value vectorTemp3;
      @Temp({REG, ILLEGAL}) private Value vectorTemp4;
  
      public AMD64ArrayEqualsOp(LIRGeneratorTool tool, JavaKind kind1, JavaKind kind2, Value result, Value array1, Value array2, Value length,
<span class="line-modified">!                     boolean directPointers, int maxVectorSize) {</span>
          super(TYPE);
          this.kind1 = kind1;
          this.kind2 = kind2;
          this.signExtend = kind1 != JavaKind.Char &amp;&amp; kind2 != JavaKind.Char;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,24 ***</span>
          this.arrayBaseOffset1 = directPointers ? 0 : tool.getProviders().getMetaAccess().getArrayBaseOffset(kind1);
          this.arrayBaseOffset2 = directPointers ? 0 : tool.getProviders().getMetaAccess().getArrayBaseOffset(kind2);
          this.arrayIndexScale1 = Objects.requireNonNull(Scale.fromInt(tool.getProviders().getMetaAccess().getArrayIndexScale(kind1)));
          this.arrayIndexScale2 = Objects.requireNonNull(Scale.fromInt(tool.getProviders().getMetaAccess().getArrayIndexScale(kind2)));
          this.vectorSize = ((AMD64) tool.target().arch).getFeatures().contains(CPUFeature.AVX2) &amp;&amp; (maxVectorSize &lt; 0 || maxVectorSize &gt;= 32) ? AVXKind.AVXSize.YMM : AVXKind.AVXSize.XMM;
<span class="line-removed">-         this.constantLength = constantLength;</span>
  
          this.resultValue = result;
          this.array1Value = array1;
          this.array2Value = array2;
          this.lengthValue = length;
  
          // Allocate some temporaries.
<span class="line-modified">!         this.temp1 = tool.newVariable(LIRKind.unknownReference(tool.target().arch.getWordKind()));</span>
<span class="line-modified">!         this.temp2 = tool.newVariable(LIRKind.unknownReference(tool.target().arch.getWordKind()));</span>
          this.temp3 = tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));
<span class="line-modified">!         this.temp4 = tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));</span>
  
<span class="line-removed">-         this.temp5 = kind1.isNumericFloat() || kind1 != kind2 ? tool.newVariable(LIRKind.value(tool.target().arch.getWordKind())) : Value.ILLEGAL;</span>
          if (kind1 == JavaKind.Float) {
              this.tempXMM = tool.newVariable(LIRKind.value(AMD64Kind.SINGLE));
          } else if (kind1 == JavaKind.Double) {
              this.tempXMM = tool.newVariable(LIRKind.value(AMD64Kind.DOUBLE));
          } else {
<span class="line-new-header">--- 107,33 ---</span>
          this.arrayBaseOffset1 = directPointers ? 0 : tool.getProviders().getMetaAccess().getArrayBaseOffset(kind1);
          this.arrayBaseOffset2 = directPointers ? 0 : tool.getProviders().getMetaAccess().getArrayBaseOffset(kind2);
          this.arrayIndexScale1 = Objects.requireNonNull(Scale.fromInt(tool.getProviders().getMetaAccess().getArrayIndexScale(kind1)));
          this.arrayIndexScale2 = Objects.requireNonNull(Scale.fromInt(tool.getProviders().getMetaAccess().getArrayIndexScale(kind2)));
          this.vectorSize = ((AMD64) tool.target().arch).getFeatures().contains(CPUFeature.AVX2) &amp;&amp; (maxVectorSize &lt; 0 || maxVectorSize &gt;= 32) ? AVXKind.AVXSize.YMM : AVXKind.AVXSize.XMM;
  
          this.resultValue = result;
          this.array1Value = array1;
          this.array2Value = array2;
          this.lengthValue = length;
  
          // Allocate some temporaries.
<span class="line-modified">!         if (supportsSSE41(tool.target()) &amp;&amp; canGenerateConstantLengthCompare(tool.target()) &amp;&amp; !constantLengthCompareNeedsTmpArrayPointers()) {</span>
<span class="line-modified">!             this.temp1 = Value.ILLEGAL;</span>
<span class="line-added">+             this.temp2 = Value.ILLEGAL;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             this.temp1 = tool.newVariable(LIRKind.unknownReference(tool.target().arch.getWordKind()));</span>
<span class="line-added">+             this.temp2 = tool.newVariable(LIRKind.unknownReference(tool.target().arch.getWordKind()));</span>
<span class="line-added">+         }</span>
          this.temp3 = tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));
<span class="line-modified">!         if (supportsSSE41(tool.target()) &amp;&amp; canGenerateConstantLengthCompare(tool.target())) {</span>
<span class="line-added">+             this.temp4 = Value.ILLEGAL;</span>
<span class="line-added">+             this.temp5 = Value.ILLEGAL;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             this.temp4 = tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));</span>
<span class="line-added">+             this.temp5 = kind1.isNumericFloat() || kind1 != kind2 ? tool.newVariable(LIRKind.value(tool.target().arch.getWordKind())) : Value.ILLEGAL;</span>
<span class="line-added">+         }</span>
  
          if (kind1 == JavaKind.Float) {
              this.tempXMM = tool.newVariable(LIRKind.value(AMD64Kind.SINGLE));
          } else if (kind1 == JavaKind.Double) {
              this.tempXMM = tool.newVariable(LIRKind.value(AMD64Kind.DOUBLE));
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 149,34 ***</span>
              this.vectorTemp4 = Value.ILLEGAL;
          }
      }
  
      private boolean canGenerateConstantLengthCompare(TargetDescription target) {
<span class="line-modified">!         return constantLength &gt;= 0 &amp;&amp; kind1.isNumericInteger() &amp;&amp; (kind1 == kind2 || getElementsPerVector(AVXKind.AVXSize.XMM) &lt;= constantLength) &amp;&amp; supportsSSE41(target);</span>
      }
  
      @Override
      public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
          Register result = asRegister(resultValue);
<span class="line-removed">-         Register array1 = asRegister(temp1);</span>
<span class="line-removed">-         Register array2 = asRegister(temp2);</span>
  
          Label trueLabel = new Label();
          Label falseLabel = new Label();
          Label done = new Label();
  
<span class="line-removed">-         // Load array base addresses.</span>
<span class="line-removed">-         masm.leaq(array1, new AMD64Address(asRegister(array1Value), arrayBaseOffset1));</span>
<span class="line-removed">-         masm.leaq(array2, new AMD64Address(asRegister(array2Value), arrayBaseOffset2));</span>
<span class="line-removed">- </span>
          if (canGenerateConstantLengthCompare(crb.target)) {
<span class="line-modified">!             emitConstantLengthArrayCompareBytes(crb, masm, array1, array2, asRegister(temp3), asRegister(temp4),</span>
<span class="line-removed">-                             new Register[]{asRegister(vectorTemp1), asRegister(vectorTemp2), asRegister(vectorTemp3), asRegister(vectorTemp4)}, falseLabel);</span>
          } else {
              Register length = asRegister(temp3);
              // Get array length.
<span class="line-modified">!             masm.movl(length, asRegister(lengthValue));</span>
              // copy
              masm.movl(result, length);
              emitArrayCompare(crb, masm, result, array1, array2, length, trueLabel, falseLabel);
          }
  
<span class="line-new-header">--- 161,40 ---</span>
              this.vectorTemp4 = Value.ILLEGAL;
          }
      }
  
      private boolean canGenerateConstantLengthCompare(TargetDescription target) {
<span class="line-modified">!         return LIRValueUtil.isJavaConstant(lengthValue) &amp;&amp; kind1.isNumericInteger() &amp;&amp; (kind1 == kind2 || getElementsPerVector(AVXKind.AVXSize.XMM) &lt;= constantLength()) &amp;&amp; supportsSSE41(target);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private int constantLength() {</span>
<span class="line-added">+         return LIRValueUtil.asJavaConstant(lengthValue).asInt();</span>
      }
  
      @Override
      public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
          Register result = asRegister(resultValue);
  
          Label trueLabel = new Label();
          Label falseLabel = new Label();
          Label done = new Label();
  
          if (canGenerateConstantLengthCompare(crb.target)) {
<span class="line-modified">!             emitConstantLengthArrayCompareBytes(crb, masm, new Register[]{asRegister(vectorTemp1), asRegister(vectorTemp2), asRegister(vectorTemp3), asRegister(vectorTemp4)}, falseLabel);</span>
          } else {
<span class="line-added">+             Register array1 = asRegister(temp1);</span>
<span class="line-added">+             Register array2 = asRegister(temp2);</span>
<span class="line-added">+             // Load array base addresses.</span>
<span class="line-added">+             masm.leaq(array1, new AMD64Address(asRegister(array1Value), arrayBaseOffset1));</span>
<span class="line-added">+             masm.leaq(array2, new AMD64Address(asRegister(array2Value), arrayBaseOffset2));</span>
              Register length = asRegister(temp3);
              // Get array length.
<span class="line-modified">!             if (LIRValueUtil.isJavaConstant(lengthValue)) {</span>
<span class="line-added">+                 masm.movl(length, constantLength());</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 masm.movl(length, asRegister(lengthValue));</span>
<span class="line-added">+             }</span>
              // copy
              masm.movl(result, length);
              emitArrayCompare(crb, masm, result, array1, array2, length, trueLabel, falseLabel);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 703,86 ***</span>
          masm.jccb(ConditionFlag.NotZero, loop);
          // Floats within the range are equal, revert change to the register index
          masm.subq(index, range);
      }
  
      /**
       * Emits specialized assembly for checking equality of memory regions
       * {@code arrayPtr1[0..nBytes]} and {@code arrayPtr2[0..nBytes]}. If they match, execution
       * continues directly after the emitted code block, otherwise we jump to {@code noMatch}.
       */
      private void emitConstantLengthArrayCompareBytes(
                      CompilationResultBuilder crb,
                      AMD64MacroAssembler asm,
<span class="line-removed">-                     Register arrayPtr1,</span>
<span class="line-removed">-                     Register arrayPtr2,</span>
<span class="line-removed">-                     Register tmp1,</span>
<span class="line-removed">-                     Register tmp2,</span>
                      Register[] tmpVectors,
                      Label noMatch) {
<span class="line-modified">!         if (constantLength == 0) {</span>
              // do nothing
              return;
          }
          AVXKind.AVXSize vSize = vectorSize;
<span class="line-modified">!         if (constantLength &lt; getElementsPerVector(vectorSize)) {</span>
              vSize = AVXKind.AVXSize.XMM;
          }
          int elementsPerVector = getElementsPerVector(vSize);
<span class="line-modified">!         if (elementsPerVector &gt; constantLength) {</span>
              assert kind1 == kind2;
<span class="line-modified">!             int byteLength = constantLength &lt;&lt; arrayIndexScale1.log2;</span>
<span class="line-modified">!             // array is shorter than any vector register, use regular CMP instructions</span>
              int movSize = (byteLength &lt; 2) ? 1 : ((byteLength &lt; 4) ? 2 : ((byteLength &lt; 8) ? 4 : 8));
<span class="line-modified">!             emitMovBytes(asm, tmp1, new AMD64Address(arrayPtr1), movSize);</span>
<span class="line-modified">!             emitMovBytes(asm, tmp2, new AMD64Address(arrayPtr2), movSize);</span>
<span class="line-modified">!             emitCmpBytes(asm, tmp1, tmp2, movSize);</span>
<span class="line-removed">-             asm.jcc(AMD64Assembler.ConditionFlag.NotEqual, noMatch);</span>
              if (byteLength &gt; movSize) {
<span class="line-modified">!                 emitMovBytes(asm, tmp1, new AMD64Address(arrayPtr1, byteLength - movSize), movSize);</span>
<span class="line-modified">!                 emitMovBytes(asm, tmp2, new AMD64Address(arrayPtr2, byteLength - movSize), movSize);</span>
<span class="line-modified">!                 emitCmpBytes(asm, tmp1, tmp2, movSize);</span>
<span class="line-removed">-                 asm.jcc(AMD64Assembler.ConditionFlag.NotEqual, noMatch);</span>
              }
          } else {
              int elementsPerVectorLoop = 2 * elementsPerVector;
<span class="line-modified">!             int tailCount = constantLength &amp; (elementsPerVectorLoop - 1);</span>
<span class="line-modified">!             int vectorCount = constantLength &amp; ~(elementsPerVectorLoop - 1);</span>
              int bytesPerVector = vSize.getBytes();
              if (vectorCount &gt; 0) {
                  Label loopBegin = new Label();
<span class="line-modified">!                 asm.leaq(arrayPtr1, new AMD64Address(arrayPtr1, vectorCount &lt;&lt; arrayIndexScale1.log2));</span>
<span class="line-modified">!                 asm.leaq(arrayPtr2, new AMD64Address(arrayPtr2, vectorCount &lt;&lt; arrayIndexScale2.log2));</span>
<span class="line-modified">!                 asm.movq(tmp1, -vectorCount);</span>
                  asm.align(crb.target.wordSize * 2);
                  asm.bind(loopBegin);
<span class="line-modified">!                 emitVectorLoad1(asm, tmpVectors[0], arrayPtr1, tmp1, 0, vSize);</span>
<span class="line-modified">!                 emitVectorLoad2(asm, tmpVectors[1], arrayPtr2, tmp1, 0, vSize);</span>
<span class="line-modified">!                 emitVectorLoad1(asm, tmpVectors[2], arrayPtr1, tmp1, scaleDisplacement1(bytesPerVector), vSize);</span>
<span class="line-modified">!                 emitVectorLoad2(asm, tmpVectors[3], arrayPtr2, tmp1, scaleDisplacement2(bytesPerVector), vSize);</span>
                  emitVectorXor(asm, tmpVectors[0], tmpVectors[1], vSize);
                  emitVectorXor(asm, tmpVectors[2], tmpVectors[3], vSize);
                  emitVectorTest(asm, tmpVectors[0], vSize);
<span class="line-modified">!                 asm.jcc(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
                  emitVectorTest(asm, tmpVectors[2], vSize);
<span class="line-modified">!                 asm.jcc(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
<span class="line-modified">!                 asm.addq(tmp1, elementsPerVectorLoop);</span>
<span class="line-modified">!                 asm.jcc(AMD64Assembler.ConditionFlag.NotZero, loopBegin);</span>
              }
              if (tailCount &gt; 0) {
<span class="line-modified">!                 emitVectorLoad1(asm, tmpVectors[0], arrayPtr1, (tailCount &lt;&lt; arrayIndexScale1.log2) - scaleDisplacement1(bytesPerVector), vSize);</span>
<span class="line-modified">!                 emitVectorLoad2(asm, tmpVectors[1], arrayPtr2, (tailCount &lt;&lt; arrayIndexScale2.log2) - scaleDisplacement2(bytesPerVector), vSize);</span>
                  emitVectorXor(asm, tmpVectors[0], tmpVectors[1], vSize);
                  if (tailCount &gt; elementsPerVector) {
<span class="line-modified">!                     emitVectorLoad1(asm, tmpVectors[2], arrayPtr1, 0, vSize);</span>
<span class="line-modified">!                     emitVectorLoad2(asm, tmpVectors[3], arrayPtr2, 0, vSize);</span>
                      emitVectorXor(asm, tmpVectors[2], tmpVectors[3], vSize);
                      emitVectorTest(asm, tmpVectors[2], vSize);
<span class="line-modified">!                     asm.jcc(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
                  }
                  emitVectorTest(asm, tmpVectors[0], vSize);
<span class="line-modified">!                 asm.jcc(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
              }
          }
      }
  
      private void emitMovBytes(AMD64MacroAssembler asm, Register dst, AMD64Address src, int size) {
<span class="line-new-header">--- 721,96 ---</span>
          masm.jccb(ConditionFlag.NotZero, loop);
          // Floats within the range are equal, revert change to the register index
          masm.subq(index, range);
      }
  
<span class="line-added">+     private boolean constantLengthCompareNeedsTmpArrayPointers() {</span>
<span class="line-added">+         AVXKind.AVXSize vSize = vectorSize;</span>
<span class="line-added">+         if (constantLength() &lt; getElementsPerVector(vectorSize)) {</span>
<span class="line-added">+             vSize = AVXKind.AVXSize.XMM;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         int vectorCount = constantLength() &amp; ~(2 * getElementsPerVector(vSize) - 1);</span>
<span class="line-added">+         return vectorCount &gt; 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Emits specialized assembly for checking equality of memory regions
       * {@code arrayPtr1[0..nBytes]} and {@code arrayPtr2[0..nBytes]}. If they match, execution
       * continues directly after the emitted code block, otherwise we jump to {@code noMatch}.
       */
      private void emitConstantLengthArrayCompareBytes(
                      CompilationResultBuilder crb,
                      AMD64MacroAssembler asm,
                      Register[] tmpVectors,
                      Label noMatch) {
<span class="line-modified">!         if (constantLength() == 0) {</span>
              // do nothing
              return;
          }
<span class="line-added">+         Register arrayPtr1 = asRegister(array1Value);</span>
<span class="line-added">+         Register arrayPtr2 = asRegister(array2Value);</span>
<span class="line-added">+         Register tmp = asRegister(temp3);</span>
          AVXKind.AVXSize vSize = vectorSize;
<span class="line-modified">!         if (constantLength() &lt; getElementsPerVector(vectorSize)) {</span>
              vSize = AVXKind.AVXSize.XMM;
          }
          int elementsPerVector = getElementsPerVector(vSize);
<span class="line-modified">!         if (elementsPerVector &gt; constantLength()) {</span>
              assert kind1 == kind2;
<span class="line-modified">!             int byteLength = constantLength() &lt;&lt; arrayIndexScale1.log2;</span>
<span class="line-modified">!             // array is shorter than any vector register, use regular XOR instructions</span>
              int movSize = (byteLength &lt; 2) ? 1 : ((byteLength &lt; 4) ? 2 : ((byteLength &lt; 8) ? 4 : 8));
<span class="line-modified">!             emitMovBytes(asm, tmp, new AMD64Address(arrayPtr1, arrayBaseOffset1), movSize);</span>
<span class="line-modified">!             emitXorBytes(asm, tmp, new AMD64Address(arrayPtr2, arrayBaseOffset2), movSize);</span>
<span class="line-modified">!             asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
              if (byteLength &gt; movSize) {
<span class="line-modified">!                 emitMovBytes(asm, tmp, new AMD64Address(arrayPtr1, arrayBaseOffset1 + byteLength - movSize), movSize);</span>
<span class="line-modified">!                 emitXorBytes(asm, tmp, new AMD64Address(arrayPtr2, arrayBaseOffset2 + byteLength - movSize), movSize);</span>
<span class="line-modified">!                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
              }
          } else {
              int elementsPerVectorLoop = 2 * elementsPerVector;
<span class="line-modified">!             int tailCount = constantLength() &amp; (elementsPerVectorLoop - 1);</span>
<span class="line-modified">!             int vectorCount = constantLength() &amp; ~(elementsPerVectorLoop - 1);</span>
              int bytesPerVector = vSize.getBytes();
              if (vectorCount &gt; 0) {
                  Label loopBegin = new Label();
<span class="line-modified">!                 Register tmpArrayPtr1 = asRegister(temp1);</span>
<span class="line-modified">!                 Register tmpArrayPtr2 = asRegister(temp2);</span>
<span class="line-modified">!                 asm.leaq(tmpArrayPtr1, new AMD64Address(arrayPtr1, vectorCount &lt;&lt; arrayIndexScale1.log2));</span>
<span class="line-added">+                 asm.leaq(tmpArrayPtr2, new AMD64Address(arrayPtr2, vectorCount &lt;&lt; arrayIndexScale2.log2));</span>
<span class="line-added">+                 arrayPtr1 = tmpArrayPtr1;</span>
<span class="line-added">+                 arrayPtr2 = tmpArrayPtr2;</span>
<span class="line-added">+                 asm.movq(tmp, -vectorCount);</span>
                  asm.align(crb.target.wordSize * 2);
                  asm.bind(loopBegin);
<span class="line-modified">!                 emitVectorLoad1(asm, tmpVectors[0], arrayPtr1, tmp, arrayBaseOffset1, vSize);</span>
<span class="line-modified">!                 emitVectorLoad2(asm, tmpVectors[1], arrayPtr2, tmp, arrayBaseOffset2, vSize);</span>
<span class="line-modified">!                 emitVectorLoad1(asm, tmpVectors[2], arrayPtr1, tmp, arrayBaseOffset1 + scaleDisplacement1(bytesPerVector), vSize);</span>
<span class="line-modified">!                 emitVectorLoad2(asm, tmpVectors[3], arrayPtr2, tmp, arrayBaseOffset2 + scaleDisplacement2(bytesPerVector), vSize);</span>
                  emitVectorXor(asm, tmpVectors[0], tmpVectors[1], vSize);
                  emitVectorXor(asm, tmpVectors[2], tmpVectors[3], vSize);
                  emitVectorTest(asm, tmpVectors[0], vSize);
<span class="line-modified">!                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
                  emitVectorTest(asm, tmpVectors[2], vSize);
<span class="line-modified">!                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
<span class="line-modified">!                 asm.addq(tmp, elementsPerVectorLoop);</span>
<span class="line-modified">!                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, loopBegin);</span>
              }
              if (tailCount &gt; 0) {
<span class="line-modified">!                 emitVectorLoad1(asm, tmpVectors[0], arrayPtr1, arrayBaseOffset1 + (tailCount &lt;&lt; arrayIndexScale1.log2) - scaleDisplacement1(bytesPerVector), vSize);</span>
<span class="line-modified">!                 emitVectorLoad2(asm, tmpVectors[1], arrayPtr2, arrayBaseOffset2 + (tailCount &lt;&lt; arrayIndexScale2.log2) - scaleDisplacement2(bytesPerVector), vSize);</span>
                  emitVectorXor(asm, tmpVectors[0], tmpVectors[1], vSize);
                  if (tailCount &gt; elementsPerVector) {
<span class="line-modified">!                     emitVectorLoad1(asm, tmpVectors[2], arrayPtr1, arrayBaseOffset1, vSize);</span>
<span class="line-modified">!                     emitVectorLoad2(asm, tmpVectors[3], arrayPtr2, arrayBaseOffset2, vSize);</span>
                      emitVectorXor(asm, tmpVectors[2], tmpVectors[3], vSize);
                      emitVectorTest(asm, tmpVectors[2], vSize);
<span class="line-modified">!                     asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
                  }
                  emitVectorTest(asm, tmpVectors[0], vSize);
<span class="line-modified">!                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
              }
          }
      }
  
      private void emitMovBytes(AMD64MacroAssembler asm, Register dst, AMD64Address src, int size) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 815,13 ***</span>
              default:
                  throw new IllegalStateException();
          }
      }
  
<span class="line-modified">!     private static void emitCmpBytes(AMD64MacroAssembler asm, Register dst, Register src, int size) {</span>
<span class="line-modified">!         if (size &lt; 8) {</span>
<span class="line-modified">!             asm.cmpl(dst, src);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             asm.cmpq(dst, src);</span>
          }
      }
  }
<span class="line-new-header">--- 843,30 ---</span>
              default:
                  throw new IllegalStateException();
          }
      }
  
<span class="line-modified">!     private static void emitXorBytes(AMD64MacroAssembler asm, Register dst, AMD64Address src, int size) {</span>
<span class="line-modified">!         OperandSize opSize = getOperandSize(size);</span>
<span class="line-modified">!         XOR.getRMOpcode(opSize).emit(asm, opSize, dst, src);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-added">+     private static OperandSize getOperandSize(int size) {</span>
<span class="line-added">+         switch (size) {</span>
<span class="line-added">+             case 1:</span>
<span class="line-added">+                 return OperandSize.BYTE;</span>
<span class="line-added">+             case 2:</span>
<span class="line-added">+                 return OperandSize.WORD;</span>
<span class="line-added">+             case 4:</span>
<span class="line-added">+                 return OperandSize.DWORD;</span>
<span class="line-added">+             case 8:</span>
<span class="line-added">+                 return OperandSize.QWORD;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 throw new IllegalStateException();</span>
          }
      }
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public boolean needsClearUpperVectorRegisters() {</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="AMD64ArrayCompareToOp.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ArrayIndexOfOp.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
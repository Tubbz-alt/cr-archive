<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Binary.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.amd64;
 26 
 27 import static jdk.vm.ci.code.ValueUtil.asRegister;
 28 import static jdk.vm.ci.code.ValueUtil.isRegister;
 29 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 30 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.COMPOSITE;
 31 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;
 32 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
 33 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;
 34 import static org.graalvm.compiler.lir.LIRValueUtil.differentRegisters;
 35 import static org.graalvm.compiler.lir.LIRValueUtil.sameRegister;
 36 
 37 import org.graalvm.compiler.asm.amd64.AMD64Address;
 38 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic;
 39 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
 40 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMIOp;
 41 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
 42 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;
 43 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 44 import org.graalvm.compiler.core.common.NumUtil;
 45 import org.graalvm.compiler.lir.LIRFrameState;
 46 import org.graalvm.compiler.lir.LIRInstructionClass;
 47 import org.graalvm.compiler.lir.Opcode;
 48 import org.graalvm.compiler.lir.StandardOp.ImplicitNullCheck;
 49 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 50 
 51 import jdk.vm.ci.code.site.DataSectionReference;
 52 import jdk.vm.ci.meta.AllocatableValue;
 53 import jdk.vm.ci.meta.JavaConstant;
 54 import jdk.vm.ci.meta.Value;
 55 
 56 /**
 57  * AMD64 LIR instructions that have two inputs and one output.
 58  */
 59 public class AMD64Binary {
 60 
 61     /**
 62      * Instruction that has two {@link AllocatableValue} operands.
 63      */
 64     public static class TwoOp extends AMD64LIRInstruction {
 65         public static final LIRInstructionClass&lt;TwoOp&gt; TYPE = LIRInstructionClass.create(TwoOp.class);
 66 
 67         @Opcode private final AMD64RMOp opcode;
 68         private final OperandSize size;
 69 
 70         @Def({REG, HINT}) protected AllocatableValue result;
 71         @Use({REG}) protected AllocatableValue x;
 72         /**
 73          * This argument must be Alive to ensure that result and y are not assigned to the same
 74          * register, which would break the code generation by destroying y too early.
 75          */
 76         @Alive({REG, STACK}) protected AllocatableValue y;
 77 
 78         public TwoOp(AMD64RMOp opcode, OperandSize size, AllocatableValue result, AllocatableValue x, AllocatableValue y) {
 79             super(TYPE);
 80             this.opcode = opcode;
 81             this.size = size;
 82 
 83             this.result = result;
 84             this.x = x;
 85             this.y = y;
 86         }
 87 
 88         @Override
 89         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 90             AMD64Move.move(crb, masm, result, x);
 91             if (isRegister(y)) {
 92                 opcode.emit(masm, size, asRegister(result), asRegister(y));
 93             } else {
 94                 assert isStackSlot(y);
 95                 opcode.emit(masm, size, asRegister(result), (AMD64Address) crb.asAddress(y));
 96             }
 97         }
 98     }
 99 
100     /**
101      * Commutative instruction that has two {@link AllocatableValue} operands.
102      */
103     public static class CommutativeTwoOp extends AMD64LIRInstruction {
104         public static final LIRInstructionClass&lt;CommutativeTwoOp&gt; TYPE = LIRInstructionClass.create(CommutativeTwoOp.class);
105 
106         @Opcode private final AMD64RMOp opcode;
107         private final OperandSize size;
108 
109         @Def({REG, HINT}) protected AllocatableValue result;
110         @Use({REG, STACK}) protected AllocatableValue x;
111         @Use({REG, STACK}) protected AllocatableValue y;
112 
113         public CommutativeTwoOp(AMD64RMOp opcode, OperandSize size, AllocatableValue result, AllocatableValue x, AllocatableValue y) {
114             super(TYPE);
115             this.opcode = opcode;
116             this.size = size;
117 
118             this.result = result;
119             this.x = x;
120             this.y = y;
121         }
122 
123         @Override
124         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
125             AllocatableValue input;
126             if (sameRegister(result, y)) {
127                 input = x;
128             } else {
129                 AMD64Move.move(crb, masm, result, x);
130                 input = y;
131             }
132 
133             if (isRegister(input)) {
134                 opcode.emit(masm, size, asRegister(result), asRegister(input));
135             } else {
136                 assert isStackSlot(input);
137                 opcode.emit(masm, size, asRegister(result), (AMD64Address) crb.asAddress(input));
138             }
139         }
140     }
141 
142     /**
143      * Instruction that has one {@link AllocatableValue} operand and one 32-bit immediate operand.
144      */
145     public static class ConstOp extends AMD64LIRInstruction {
146         public static final LIRInstructionClass&lt;ConstOp&gt; TYPE = LIRInstructionClass.create(ConstOp.class);
147 
148         @Opcode private final AMD64MIOp opcode;
149         private final OperandSize size;
150 
151         @Def({REG, HINT}) protected AllocatableValue result;
152         @Use({REG}) protected AllocatableValue x;
153         private final int y;
154 
155         public ConstOp(AMD64BinaryArithmetic opcode, OperandSize size, AllocatableValue result, AllocatableValue x, int y) {
156             this(opcode.getMIOpcode(size, NumUtil.isByte(y)), size, result, x, y);
157         }
158 
159         public ConstOp(AMD64MIOp opcode, OperandSize size, AllocatableValue result, AllocatableValue x, int y) {
160             super(TYPE);
161             this.opcode = opcode;
162             this.size = size;
163 
164             this.result = result;
165             this.x = x;
166             this.y = y;
167         }
168 
169         @Override
170         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
171             AMD64Move.move(crb, masm, result, x);
172             opcode.emit(masm, size, asRegister(result), y);
173         }
174     }
175 
176     /**
177      * Instruction that has one {@link AllocatableValue} operand and one
178      * {@link DataSectionReference} operand.
179      */
180     public static class DataTwoOp extends AMD64LIRInstruction {
181         public static final LIRInstructionClass&lt;DataTwoOp&gt; TYPE = LIRInstructionClass.create(DataTwoOp.class);
182 
183         @Opcode private final AMD64RMOp opcode;
184         private final OperandSize size;
185 
186         @Def({REG, HINT}) protected AllocatableValue result;
187         @Use({REG}) protected AllocatableValue x;
188         private final JavaConstant y;
189 
190         private final int alignment;
191 
192         public DataTwoOp(AMD64RMOp opcode, OperandSize size, AllocatableValue result, AllocatableValue x, JavaConstant y) {
193             this(opcode, size, result, x, y, y.getJavaKind().getByteCount());
194         }
195 
196         public DataTwoOp(AMD64RMOp opcode, OperandSize size, AllocatableValue result, AllocatableValue x, JavaConstant y, int alignment) {
197             super(TYPE);
198             this.opcode = opcode;
199             this.size = size;
200 
201             this.result = result;
202             this.x = x;
203             this.y = y;
204 
205             this.alignment = alignment;
206         }
207 
208         @Override
209         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
210             AMD64Move.move(crb, masm, result, x);
211             opcode.emit(masm, size, asRegister(result), (AMD64Address) crb.recordDataReferenceInCode(y, alignment));
212         }
213     }
214 
215     /**
216      * Instruction that has one {@link AllocatableValue} operand and one {@link AMD64AddressValue
217      * memory} operand.
218      */
219     public static class MemoryTwoOp extends AMD64LIRInstruction implements ImplicitNullCheck {
220         public static final LIRInstructionClass&lt;MemoryTwoOp&gt; TYPE = LIRInstructionClass.create(MemoryTwoOp.class);
221 
222         @Opcode private final AMD64RMOp opcode;
223         private final OperandSize size;
224 
225         @Def({REG, HINT}) protected AllocatableValue result;
226         @Use({REG}) protected AllocatableValue x;
227         @Alive({COMPOSITE}) protected AMD64AddressValue y;
228 
229         @State protected LIRFrameState state;
230 
231         public MemoryTwoOp(AMD64RMOp opcode, OperandSize size, AllocatableValue result, AllocatableValue x, AMD64AddressValue y, LIRFrameState state) {
232             super(TYPE);
233             this.opcode = opcode;
234             this.size = size;
235 
236             this.result = result;
237             this.x = x;
238             this.y = y;
239 
240             this.state = state;
241         }
242 
243         @Override
244         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
245             AMD64Move.move(crb, masm, result, x);
246             if (state != null) {
247                 crb.recordImplicitException(masm.position(), state);
248             }
249             opcode.emit(masm, size, asRegister(result), y.toAddress());
250         }
251 
252         @Override
253         public void verify() {
254             super.verify();
255             assert differentRegisters(result, y) || sameRegister(x, y);
256         }
257 
258         @Override
259         public boolean makeNullCheckFor(Value value, LIRFrameState nullCheckState, int implicitNullCheckLimit) {
260             if (state == null &amp;&amp; y.isValidImplicitNullCheckFor(value, implicitNullCheckLimit)) {
261                 state = nullCheckState;
262                 return true;
263             }
264             return false;
265         }
266     }
267 
268     /**
269      * Instruction with a separate result operand, one {@link AllocatableValue} input and one 32-bit
270      * immediate input.
271      */
272     public static class RMIOp extends AMD64LIRInstruction {
273         public static final LIRInstructionClass&lt;RMIOp&gt; TYPE = LIRInstructionClass.create(RMIOp.class);
274 
275         @Opcode private final AMD64RMIOp opcode;
276         private final OperandSize size;
277 
278         @Def({REG}) protected AllocatableValue result;
279         @Use({REG, STACK}) protected AllocatableValue x;
280         private final int y;
281 
282         public RMIOp(AMD64RMIOp opcode, OperandSize size, AllocatableValue result, AllocatableValue x, int y) {
283             super(TYPE);
284             this.opcode = opcode;
285             this.size = size;
286 
287             this.result = result;
288             this.x = x;
289             this.y = y;
290         }
291 
292         @Override
293         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
294             if (isRegister(x)) {
295                 opcode.emit(masm, size, asRegister(result), asRegister(x), y);
296             } else {
297                 assert isStackSlot(x);
298                 opcode.emit(masm, size, asRegister(result), (AMD64Address) crb.asAddress(x), y);
299             }
300         }
301     }
302 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayEqualsOp.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64ArrayCompareToOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ArrayIndexOfOp.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayEqualsOp.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.amd64;
 26 
<span class="line-modified"> 27 import jdk.vm.ci.amd64.AMD64;</span>
<span class="line-modified"> 28 import jdk.vm.ci.amd64.AMD64.CPUFeature;</span>
<span class="line-modified"> 29 import jdk.vm.ci.amd64.AMD64Kind;</span>
<span class="line-modified"> 30 import jdk.vm.ci.code.Register;</span>
<span class="line-modified"> 31 import jdk.vm.ci.code.TargetDescription;</span>
<span class="line-modified"> 32 import jdk.vm.ci.meta.JavaKind;</span>
<span class="line-modified"> 33 import jdk.vm.ci.meta.Value;</span>

 34 import org.graalvm.compiler.asm.Label;
 35 import org.graalvm.compiler.asm.amd64.AMD64Address;
 36 import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
 37 import org.graalvm.compiler.asm.amd64.AMD64Assembler;
 38 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
 39 import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
 40 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;
 41 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 42 import org.graalvm.compiler.asm.amd64.AVXKind;
 43 import org.graalvm.compiler.core.common.LIRKind;
 44 import org.graalvm.compiler.debug.GraalError;
 45 import org.graalvm.compiler.lir.LIRInstructionClass;

 46 import org.graalvm.compiler.lir.Opcode;
 47 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 48 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 49 
<span class="line-modified"> 50 import static jdk.vm.ci.code.ValueUtil.asRegister;</span>
<span class="line-modified"> 51 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
<span class="line-modified"> 52 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;</span>
<span class="line-modified"> 53 </span>
<span class="line-modified"> 54 import java.util.Objects;</span>


 55 
 56 /**
 57  * Emits code which compares two arrays of the same length. If the CPU supports any vector
 58  * instructions specialized code is emitted to leverage these instructions.
 59  *
 60  * This op can also compare arrays of different integer types (e.g. {@code byte[]} and
 61  * {@code char[]}) with on-the-fly sign- or zero-extension. If one of the given arrays is a
 62  * {@code char[]} array, the smaller elements are zero-extended, otherwise they are sign-extended.
 63  */
 64 @Opcode(&quot;ARRAY_EQUALS&quot;)
 65 public final class AMD64ArrayEqualsOp extends AMD64LIRInstruction {
 66     public static final LIRInstructionClass&lt;AMD64ArrayEqualsOp&gt; TYPE = LIRInstructionClass.create(AMD64ArrayEqualsOp.class);
 67 
 68     private final JavaKind kind1;
 69     private final JavaKind kind2;
 70     private final int arrayBaseOffset1;
 71     private final int arrayBaseOffset2;
 72     private final Scale arrayIndexScale1;
 73     private final Scale arrayIndexScale2;
 74     private final AVXKind.AVXSize vectorSize;
<span class="line-removed"> 75     private final int constantLength;</span>
 76     private final boolean signExtend;
 77 
 78     @Def({REG}) private Value resultValue;
 79     @Alive({REG}) private Value array1Value;
 80     @Alive({REG}) private Value array2Value;
<span class="line-modified"> 81     @Alive({REG}) private Value lengthValue;</span>
<span class="line-modified"> 82     @Temp({REG}) private Value temp1;</span>
<span class="line-modified"> 83     @Temp({REG}) private Value temp2;</span>
 84     @Temp({REG}) private Value temp3;
<span class="line-modified"> 85     @Temp({REG}) private Value temp4;</span>
 86 
 87     @Temp({REG, ILLEGAL}) private Value temp5;
 88     @Temp({REG, ILLEGAL}) private Value tempXMM;
 89 
 90     @Temp({REG, ILLEGAL}) private Value vectorTemp1;
 91     @Temp({REG, ILLEGAL}) private Value vectorTemp2;
 92     @Temp({REG, ILLEGAL}) private Value vectorTemp3;
 93     @Temp({REG, ILLEGAL}) private Value vectorTemp4;
 94 
 95     public AMD64ArrayEqualsOp(LIRGeneratorTool tool, JavaKind kind1, JavaKind kind2, Value result, Value array1, Value array2, Value length,
<span class="line-modified"> 96                     int constantLength, boolean directPointers, int maxVectorSize) {</span>
 97         super(TYPE);
 98         this.kind1 = kind1;
 99         this.kind2 = kind2;
100         this.signExtend = kind1 != JavaKind.Char &amp;&amp; kind2 != JavaKind.Char;
101 
102         assert kind1.isNumericInteger() &amp;&amp; kind2.isNumericInteger() || kind1 == kind2;
103 
104         this.arrayBaseOffset1 = directPointers ? 0 : tool.getProviders().getMetaAccess().getArrayBaseOffset(kind1);
105         this.arrayBaseOffset2 = directPointers ? 0 : tool.getProviders().getMetaAccess().getArrayBaseOffset(kind2);
106         this.arrayIndexScale1 = Objects.requireNonNull(Scale.fromInt(tool.getProviders().getMetaAccess().getArrayIndexScale(kind1)));
107         this.arrayIndexScale2 = Objects.requireNonNull(Scale.fromInt(tool.getProviders().getMetaAccess().getArrayIndexScale(kind2)));
108         this.vectorSize = ((AMD64) tool.target().arch).getFeatures().contains(CPUFeature.AVX2) &amp;&amp; (maxVectorSize &lt; 0 || maxVectorSize &gt;= 32) ? AVXKind.AVXSize.YMM : AVXKind.AVXSize.XMM;
<span class="line-removed">109         this.constantLength = constantLength;</span>
110 
111         this.resultValue = result;
112         this.array1Value = array1;
113         this.array2Value = array2;
114         this.lengthValue = length;
115 
116         // Allocate some temporaries.
<span class="line-modified">117         this.temp1 = tool.newVariable(LIRKind.unknownReference(tool.target().arch.getWordKind()));</span>
<span class="line-modified">118         this.temp2 = tool.newVariable(LIRKind.unknownReference(tool.target().arch.getWordKind()));</span>





119         this.temp3 = tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));
<span class="line-modified">120         this.temp4 = tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));</span>






121 
<span class="line-removed">122         this.temp5 = kind1.isNumericFloat() || kind1 != kind2 ? tool.newVariable(LIRKind.value(tool.target().arch.getWordKind())) : Value.ILLEGAL;</span>
123         if (kind1 == JavaKind.Float) {
124             this.tempXMM = tool.newVariable(LIRKind.value(AMD64Kind.SINGLE));
125         } else if (kind1 == JavaKind.Double) {
126             this.tempXMM = tool.newVariable(LIRKind.value(AMD64Kind.DOUBLE));
127         } else {
128             this.tempXMM = Value.ILLEGAL;
129         }
130 
131         // We only need the vector temporaries if we generate SSE code.
132         if (supportsSSE41(tool.target())) {
133             if (canGenerateConstantLengthCompare(tool.target())) {
134                 LIRKind lirKind = LIRKind.value(vectorSize == AVXKind.AVXSize.YMM ? AMD64Kind.V256_BYTE : AMD64Kind.V128_BYTE);
135                 this.vectorTemp1 = tool.newVariable(lirKind);
136                 this.vectorTemp2 = tool.newVariable(lirKind);
137                 this.vectorTemp3 = tool.newVariable(lirKind);
138                 this.vectorTemp4 = tool.newVariable(lirKind);
139             } else {
140                 this.vectorTemp1 = tool.newVariable(LIRKind.value(AMD64Kind.DOUBLE));
141                 this.vectorTemp2 = tool.newVariable(LIRKind.value(AMD64Kind.DOUBLE));
142                 this.vectorTemp3 = Value.ILLEGAL;
143                 this.vectorTemp4 = Value.ILLEGAL;
144             }
145         } else {
146             this.vectorTemp1 = Value.ILLEGAL;
147             this.vectorTemp2 = Value.ILLEGAL;
148             this.vectorTemp3 = Value.ILLEGAL;
149             this.vectorTemp4 = Value.ILLEGAL;
150         }
151     }
152 
153     private boolean canGenerateConstantLengthCompare(TargetDescription target) {
<span class="line-modified">154         return constantLength &gt;= 0 &amp;&amp; kind1.isNumericInteger() &amp;&amp; (kind1 == kind2 || getElementsPerVector(AVXKind.AVXSize.XMM) &lt;= constantLength) &amp;&amp; supportsSSE41(target);</span>




155     }
156 
157     @Override
158     public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
159         Register result = asRegister(resultValue);
<span class="line-removed">160         Register array1 = asRegister(temp1);</span>
<span class="line-removed">161         Register array2 = asRegister(temp2);</span>
162 
163         Label trueLabel = new Label();
164         Label falseLabel = new Label();
165         Label done = new Label();
166 
<span class="line-removed">167         // Load array base addresses.</span>
<span class="line-removed">168         masm.leaq(array1, new AMD64Address(asRegister(array1Value), arrayBaseOffset1));</span>
<span class="line-removed">169         masm.leaq(array2, new AMD64Address(asRegister(array2Value), arrayBaseOffset2));</span>
<span class="line-removed">170 </span>
171         if (canGenerateConstantLengthCompare(crb.target)) {
<span class="line-modified">172             emitConstantLengthArrayCompareBytes(crb, masm, array1, array2, asRegister(temp3), asRegister(temp4),</span>
<span class="line-removed">173                             new Register[]{asRegister(vectorTemp1), asRegister(vectorTemp2), asRegister(vectorTemp3), asRegister(vectorTemp4)}, falseLabel);</span>
174         } else {





175             Register length = asRegister(temp3);
176             // Get array length.
<span class="line-modified">177             masm.movl(length, asRegister(lengthValue));</span>




178             // copy
179             masm.movl(result, length);
180             emitArrayCompare(crb, masm, result, array1, array2, length, trueLabel, falseLabel);
181         }
182 
183         // Return true
184         masm.bind(trueLabel);
185         masm.movl(result, 1);
186         masm.jmpb(done);
187 
188         // Return false
189         masm.bind(falseLabel);
190         masm.xorl(result, result);
191 
192         // That&#39;s it
193         masm.bind(done);
194     }
195 
196     private void emitArrayCompare(CompilationResultBuilder crb, AMD64MacroAssembler masm,
197                     Register result, Register array1, Register array2, Register length,
</pre>
<hr />
<pre>
688      */
689     private void emitFloatCompareWithinRange(CompilationResultBuilder crb, AMD64MacroAssembler masm,
690                     Register base1, Register base2, Register index, int offset, Label falseLabel, int range) {
691         assert kind1.isNumericFloat();
692         Label loop = new Label();
693         Register i = asRegister(temp5);
694 
695         masm.movq(i, range);
696         masm.negq(i);
697         // Align the main loop
698         masm.align(crb.target.wordSize * 2);
699         masm.bind(loop);
700         emitFloatCompare(masm, base1, base2, index, offset, falseLabel, range == 1);
701         masm.incrementq(index, 1);
702         masm.incrementq(i, 1);
703         masm.jccb(ConditionFlag.NotZero, loop);
704         // Floats within the range are equal, revert change to the register index
705         masm.subq(index, range);
706     }
707 









708     /**
709      * Emits specialized assembly for checking equality of memory regions
710      * {@code arrayPtr1[0..nBytes]} and {@code arrayPtr2[0..nBytes]}. If they match, execution
711      * continues directly after the emitted code block, otherwise we jump to {@code noMatch}.
712      */
713     private void emitConstantLengthArrayCompareBytes(
714                     CompilationResultBuilder crb,
715                     AMD64MacroAssembler asm,
<span class="line-removed">716                     Register arrayPtr1,</span>
<span class="line-removed">717                     Register arrayPtr2,</span>
<span class="line-removed">718                     Register tmp1,</span>
<span class="line-removed">719                     Register tmp2,</span>
720                     Register[] tmpVectors,
721                     Label noMatch) {
<span class="line-modified">722         if (constantLength == 0) {</span>
723             // do nothing
724             return;
725         }



726         AVXKind.AVXSize vSize = vectorSize;
<span class="line-modified">727         if (constantLength &lt; getElementsPerVector(vectorSize)) {</span>
728             vSize = AVXKind.AVXSize.XMM;
729         }
730         int elementsPerVector = getElementsPerVector(vSize);
<span class="line-modified">731         if (elementsPerVector &gt; constantLength) {</span>
732             assert kind1 == kind2;
<span class="line-modified">733             int byteLength = constantLength &lt;&lt; arrayIndexScale1.log2;</span>
<span class="line-modified">734             // array is shorter than any vector register, use regular CMP instructions</span>
735             int movSize = (byteLength &lt; 2) ? 1 : ((byteLength &lt; 4) ? 2 : ((byteLength &lt; 8) ? 4 : 8));
<span class="line-modified">736             emitMovBytes(asm, tmp1, new AMD64Address(arrayPtr1), movSize);</span>
<span class="line-modified">737             emitMovBytes(asm, tmp2, new AMD64Address(arrayPtr2), movSize);</span>
<span class="line-modified">738             emitCmpBytes(asm, tmp1, tmp2, movSize);</span>
<span class="line-removed">739             asm.jcc(AMD64Assembler.ConditionFlag.NotEqual, noMatch);</span>
740             if (byteLength &gt; movSize) {
<span class="line-modified">741                 emitMovBytes(asm, tmp1, new AMD64Address(arrayPtr1, byteLength - movSize), movSize);</span>
<span class="line-modified">742                 emitMovBytes(asm, tmp2, new AMD64Address(arrayPtr2, byteLength - movSize), movSize);</span>
<span class="line-modified">743                 emitCmpBytes(asm, tmp1, tmp2, movSize);</span>
<span class="line-removed">744                 asm.jcc(AMD64Assembler.ConditionFlag.NotEqual, noMatch);</span>
745             }
746         } else {
747             int elementsPerVectorLoop = 2 * elementsPerVector;
<span class="line-modified">748             int tailCount = constantLength &amp; (elementsPerVectorLoop - 1);</span>
<span class="line-modified">749             int vectorCount = constantLength &amp; ~(elementsPerVectorLoop - 1);</span>
750             int bytesPerVector = vSize.getBytes();
751             if (vectorCount &gt; 0) {
752                 Label loopBegin = new Label();
<span class="line-modified">753                 asm.leaq(arrayPtr1, new AMD64Address(arrayPtr1, vectorCount &lt;&lt; arrayIndexScale1.log2));</span>
<span class="line-modified">754                 asm.leaq(arrayPtr2, new AMD64Address(arrayPtr2, vectorCount &lt;&lt; arrayIndexScale2.log2));</span>
<span class="line-modified">755                 asm.movq(tmp1, -vectorCount);</span>




756                 asm.align(crb.target.wordSize * 2);
757                 asm.bind(loopBegin);
<span class="line-modified">758                 emitVectorLoad1(asm, tmpVectors[0], arrayPtr1, tmp1, 0, vSize);</span>
<span class="line-modified">759                 emitVectorLoad2(asm, tmpVectors[1], arrayPtr2, tmp1, 0, vSize);</span>
<span class="line-modified">760                 emitVectorLoad1(asm, tmpVectors[2], arrayPtr1, tmp1, scaleDisplacement1(bytesPerVector), vSize);</span>
<span class="line-modified">761                 emitVectorLoad2(asm, tmpVectors[3], arrayPtr2, tmp1, scaleDisplacement2(bytesPerVector), vSize);</span>
762                 emitVectorXor(asm, tmpVectors[0], tmpVectors[1], vSize);
763                 emitVectorXor(asm, tmpVectors[2], tmpVectors[3], vSize);
764                 emitVectorTest(asm, tmpVectors[0], vSize);
<span class="line-modified">765                 asm.jcc(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
766                 emitVectorTest(asm, tmpVectors[2], vSize);
<span class="line-modified">767                 asm.jcc(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
<span class="line-modified">768                 asm.addq(tmp1, elementsPerVectorLoop);</span>
<span class="line-modified">769                 asm.jcc(AMD64Assembler.ConditionFlag.NotZero, loopBegin);</span>
770             }
771             if (tailCount &gt; 0) {
<span class="line-modified">772                 emitVectorLoad1(asm, tmpVectors[0], arrayPtr1, (tailCount &lt;&lt; arrayIndexScale1.log2) - scaleDisplacement1(bytesPerVector), vSize);</span>
<span class="line-modified">773                 emitVectorLoad2(asm, tmpVectors[1], arrayPtr2, (tailCount &lt;&lt; arrayIndexScale2.log2) - scaleDisplacement2(bytesPerVector), vSize);</span>
774                 emitVectorXor(asm, tmpVectors[0], tmpVectors[1], vSize);
775                 if (tailCount &gt; elementsPerVector) {
<span class="line-modified">776                     emitVectorLoad1(asm, tmpVectors[2], arrayPtr1, 0, vSize);</span>
<span class="line-modified">777                     emitVectorLoad2(asm, tmpVectors[3], arrayPtr2, 0, vSize);</span>
778                     emitVectorXor(asm, tmpVectors[2], tmpVectors[3], vSize);
779                     emitVectorTest(asm, tmpVectors[2], vSize);
<span class="line-modified">780                     asm.jcc(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
781                 }
782                 emitVectorTest(asm, tmpVectors[0], vSize);
<span class="line-modified">783                 asm.jcc(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
784             }
785         }
786     }
787 
788     private void emitMovBytes(AMD64MacroAssembler asm, Register dst, AMD64Address src, int size) {
789         switch (size) {
790             case 1:
791                 if (signExtend) {
792                     asm.movsbq(dst, src);
793                 } else {
794                     asm.movzbq(dst, src);
795                 }
796                 break;
797             case 2:
798                 if (signExtend) {
799                     asm.movswq(dst, src);
800                 } else {
801                     asm.movzwq(dst, src);
802                 }
803                 break;
804             case 4:
805                 if (signExtend) {
806                     asm.movslq(dst, src);
807                 } else {
808                     // there is no movzlq
809                     asm.movl(dst, src);
810                 }
811                 break;
812             case 8:
813                 asm.movq(dst, src);
814                 break;
815             default:
816                 throw new IllegalStateException();
817         }
818     }
819 
<span class="line-modified">820     private static void emitCmpBytes(AMD64MacroAssembler asm, Register dst, Register src, int size) {</span>
<span class="line-modified">821         if (size &lt; 8) {</span>
<span class="line-modified">822             asm.cmpl(dst, src);</span>
<span class="line-modified">823         } else {</span>
<span class="line-modified">824             asm.cmpq(dst, src);</span>












825         }
826     }





827 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.amd64;
 26 
<span class="line-modified"> 27 import static jdk.vm.ci.code.ValueUtil.asRegister;</span>
<span class="line-modified"> 28 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.XOR;</span>
<span class="line-modified"> 29 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.CONST;</span>
<span class="line-modified"> 30 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
<span class="line-modified"> 31 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;</span>
<span class="line-modified"> 32 </span>
<span class="line-modified"> 33 import java.util.Objects;</span>
<span class="line-added"> 34 </span>
 35 import org.graalvm.compiler.asm.Label;
 36 import org.graalvm.compiler.asm.amd64.AMD64Address;
 37 import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
 38 import org.graalvm.compiler.asm.amd64.AMD64Assembler;
 39 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
 40 import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
 41 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;
 42 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 43 import org.graalvm.compiler.asm.amd64.AVXKind;
 44 import org.graalvm.compiler.core.common.LIRKind;
 45 import org.graalvm.compiler.debug.GraalError;
 46 import org.graalvm.compiler.lir.LIRInstructionClass;
<span class="line-added"> 47 import org.graalvm.compiler.lir.LIRValueUtil;</span>
 48 import org.graalvm.compiler.lir.Opcode;
 49 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 50 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 51 
<span class="line-modified"> 52 import jdk.vm.ci.amd64.AMD64;</span>
<span class="line-modified"> 53 import jdk.vm.ci.amd64.AMD64.CPUFeature;</span>
<span class="line-modified"> 54 import jdk.vm.ci.amd64.AMD64Kind;</span>
<span class="line-modified"> 55 import jdk.vm.ci.code.Register;</span>
<span class="line-modified"> 56 import jdk.vm.ci.code.TargetDescription;</span>
<span class="line-added"> 57 import jdk.vm.ci.meta.JavaKind;</span>
<span class="line-added"> 58 import jdk.vm.ci.meta.Value;</span>
 59 
 60 /**
 61  * Emits code which compares two arrays of the same length. If the CPU supports any vector
 62  * instructions specialized code is emitted to leverage these instructions.
 63  *
 64  * This op can also compare arrays of different integer types (e.g. {@code byte[]} and
 65  * {@code char[]}) with on-the-fly sign- or zero-extension. If one of the given arrays is a
 66  * {@code char[]} array, the smaller elements are zero-extended, otherwise they are sign-extended.
 67  */
 68 @Opcode(&quot;ARRAY_EQUALS&quot;)
 69 public final class AMD64ArrayEqualsOp extends AMD64LIRInstruction {
 70     public static final LIRInstructionClass&lt;AMD64ArrayEqualsOp&gt; TYPE = LIRInstructionClass.create(AMD64ArrayEqualsOp.class);
 71 
 72     private final JavaKind kind1;
 73     private final JavaKind kind2;
 74     private final int arrayBaseOffset1;
 75     private final int arrayBaseOffset2;
 76     private final Scale arrayIndexScale1;
 77     private final Scale arrayIndexScale2;
 78     private final AVXKind.AVXSize vectorSize;

 79     private final boolean signExtend;
 80 
 81     @Def({REG}) private Value resultValue;
 82     @Alive({REG}) private Value array1Value;
 83     @Alive({REG}) private Value array2Value;
<span class="line-modified"> 84     @Alive({REG, CONST}) private Value lengthValue;</span>
<span class="line-modified"> 85     @Temp({REG, ILLEGAL}) private Value temp1;</span>
<span class="line-modified"> 86     @Temp({REG, ILLEGAL}) private Value temp2;</span>
 87     @Temp({REG}) private Value temp3;
<span class="line-modified"> 88     @Temp({REG, ILLEGAL}) private Value temp4;</span>
 89 
 90     @Temp({REG, ILLEGAL}) private Value temp5;
 91     @Temp({REG, ILLEGAL}) private Value tempXMM;
 92 
 93     @Temp({REG, ILLEGAL}) private Value vectorTemp1;
 94     @Temp({REG, ILLEGAL}) private Value vectorTemp2;
 95     @Temp({REG, ILLEGAL}) private Value vectorTemp3;
 96     @Temp({REG, ILLEGAL}) private Value vectorTemp4;
 97 
 98     public AMD64ArrayEqualsOp(LIRGeneratorTool tool, JavaKind kind1, JavaKind kind2, Value result, Value array1, Value array2, Value length,
<span class="line-modified"> 99                     boolean directPointers, int maxVectorSize) {</span>
100         super(TYPE);
101         this.kind1 = kind1;
102         this.kind2 = kind2;
103         this.signExtend = kind1 != JavaKind.Char &amp;&amp; kind2 != JavaKind.Char;
104 
105         assert kind1.isNumericInteger() &amp;&amp; kind2.isNumericInteger() || kind1 == kind2;
106 
107         this.arrayBaseOffset1 = directPointers ? 0 : tool.getProviders().getMetaAccess().getArrayBaseOffset(kind1);
108         this.arrayBaseOffset2 = directPointers ? 0 : tool.getProviders().getMetaAccess().getArrayBaseOffset(kind2);
109         this.arrayIndexScale1 = Objects.requireNonNull(Scale.fromInt(tool.getProviders().getMetaAccess().getArrayIndexScale(kind1)));
110         this.arrayIndexScale2 = Objects.requireNonNull(Scale.fromInt(tool.getProviders().getMetaAccess().getArrayIndexScale(kind2)));
111         this.vectorSize = ((AMD64) tool.target().arch).getFeatures().contains(CPUFeature.AVX2) &amp;&amp; (maxVectorSize &lt; 0 || maxVectorSize &gt;= 32) ? AVXKind.AVXSize.YMM : AVXKind.AVXSize.XMM;

112 
113         this.resultValue = result;
114         this.array1Value = array1;
115         this.array2Value = array2;
116         this.lengthValue = length;
117 
118         // Allocate some temporaries.
<span class="line-modified">119         if (supportsSSE41(tool.target()) &amp;&amp; canGenerateConstantLengthCompare(tool.target()) &amp;&amp; !constantLengthCompareNeedsTmpArrayPointers()) {</span>
<span class="line-modified">120             this.temp1 = Value.ILLEGAL;</span>
<span class="line-added">121             this.temp2 = Value.ILLEGAL;</span>
<span class="line-added">122         } else {</span>
<span class="line-added">123             this.temp1 = tool.newVariable(LIRKind.unknownReference(tool.target().arch.getWordKind()));</span>
<span class="line-added">124             this.temp2 = tool.newVariable(LIRKind.unknownReference(tool.target().arch.getWordKind()));</span>
<span class="line-added">125         }</span>
126         this.temp3 = tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));
<span class="line-modified">127         if (supportsSSE41(tool.target()) &amp;&amp; canGenerateConstantLengthCompare(tool.target())) {</span>
<span class="line-added">128             this.temp4 = Value.ILLEGAL;</span>
<span class="line-added">129             this.temp5 = Value.ILLEGAL;</span>
<span class="line-added">130         } else {</span>
<span class="line-added">131             this.temp4 = tool.newVariable(LIRKind.value(tool.target().arch.getWordKind()));</span>
<span class="line-added">132             this.temp5 = kind1.isNumericFloat() || kind1 != kind2 ? tool.newVariable(LIRKind.value(tool.target().arch.getWordKind())) : Value.ILLEGAL;</span>
<span class="line-added">133         }</span>
134 

135         if (kind1 == JavaKind.Float) {
136             this.tempXMM = tool.newVariable(LIRKind.value(AMD64Kind.SINGLE));
137         } else if (kind1 == JavaKind.Double) {
138             this.tempXMM = tool.newVariable(LIRKind.value(AMD64Kind.DOUBLE));
139         } else {
140             this.tempXMM = Value.ILLEGAL;
141         }
142 
143         // We only need the vector temporaries if we generate SSE code.
144         if (supportsSSE41(tool.target())) {
145             if (canGenerateConstantLengthCompare(tool.target())) {
146                 LIRKind lirKind = LIRKind.value(vectorSize == AVXKind.AVXSize.YMM ? AMD64Kind.V256_BYTE : AMD64Kind.V128_BYTE);
147                 this.vectorTemp1 = tool.newVariable(lirKind);
148                 this.vectorTemp2 = tool.newVariable(lirKind);
149                 this.vectorTemp3 = tool.newVariable(lirKind);
150                 this.vectorTemp4 = tool.newVariable(lirKind);
151             } else {
152                 this.vectorTemp1 = tool.newVariable(LIRKind.value(AMD64Kind.DOUBLE));
153                 this.vectorTemp2 = tool.newVariable(LIRKind.value(AMD64Kind.DOUBLE));
154                 this.vectorTemp3 = Value.ILLEGAL;
155                 this.vectorTemp4 = Value.ILLEGAL;
156             }
157         } else {
158             this.vectorTemp1 = Value.ILLEGAL;
159             this.vectorTemp2 = Value.ILLEGAL;
160             this.vectorTemp3 = Value.ILLEGAL;
161             this.vectorTemp4 = Value.ILLEGAL;
162         }
163     }
164 
165     private boolean canGenerateConstantLengthCompare(TargetDescription target) {
<span class="line-modified">166         return LIRValueUtil.isJavaConstant(lengthValue) &amp;&amp; kind1.isNumericInteger() &amp;&amp; (kind1 == kind2 || getElementsPerVector(AVXKind.AVXSize.XMM) &lt;= constantLength()) &amp;&amp; supportsSSE41(target);</span>
<span class="line-added">167     }</span>
<span class="line-added">168 </span>
<span class="line-added">169     private int constantLength() {</span>
<span class="line-added">170         return LIRValueUtil.asJavaConstant(lengthValue).asInt();</span>
171     }
172 
173     @Override
174     public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
175         Register result = asRegister(resultValue);


176 
177         Label trueLabel = new Label();
178         Label falseLabel = new Label();
179         Label done = new Label();
180 




181         if (canGenerateConstantLengthCompare(crb.target)) {
<span class="line-modified">182             emitConstantLengthArrayCompareBytes(crb, masm, new Register[]{asRegister(vectorTemp1), asRegister(vectorTemp2), asRegister(vectorTemp3), asRegister(vectorTemp4)}, falseLabel);</span>

183         } else {
<span class="line-added">184             Register array1 = asRegister(temp1);</span>
<span class="line-added">185             Register array2 = asRegister(temp2);</span>
<span class="line-added">186             // Load array base addresses.</span>
<span class="line-added">187             masm.leaq(array1, new AMD64Address(asRegister(array1Value), arrayBaseOffset1));</span>
<span class="line-added">188             masm.leaq(array2, new AMD64Address(asRegister(array2Value), arrayBaseOffset2));</span>
189             Register length = asRegister(temp3);
190             // Get array length.
<span class="line-modified">191             if (LIRValueUtil.isJavaConstant(lengthValue)) {</span>
<span class="line-added">192                 masm.movl(length, constantLength());</span>
<span class="line-added">193             } else {</span>
<span class="line-added">194                 masm.movl(length, asRegister(lengthValue));</span>
<span class="line-added">195             }</span>
196             // copy
197             masm.movl(result, length);
198             emitArrayCompare(crb, masm, result, array1, array2, length, trueLabel, falseLabel);
199         }
200 
201         // Return true
202         masm.bind(trueLabel);
203         masm.movl(result, 1);
204         masm.jmpb(done);
205 
206         // Return false
207         masm.bind(falseLabel);
208         masm.xorl(result, result);
209 
210         // That&#39;s it
211         masm.bind(done);
212     }
213 
214     private void emitArrayCompare(CompilationResultBuilder crb, AMD64MacroAssembler masm,
215                     Register result, Register array1, Register array2, Register length,
</pre>
<hr />
<pre>
706      */
707     private void emitFloatCompareWithinRange(CompilationResultBuilder crb, AMD64MacroAssembler masm,
708                     Register base1, Register base2, Register index, int offset, Label falseLabel, int range) {
709         assert kind1.isNumericFloat();
710         Label loop = new Label();
711         Register i = asRegister(temp5);
712 
713         masm.movq(i, range);
714         masm.negq(i);
715         // Align the main loop
716         masm.align(crb.target.wordSize * 2);
717         masm.bind(loop);
718         emitFloatCompare(masm, base1, base2, index, offset, falseLabel, range == 1);
719         masm.incrementq(index, 1);
720         masm.incrementq(i, 1);
721         masm.jccb(ConditionFlag.NotZero, loop);
722         // Floats within the range are equal, revert change to the register index
723         masm.subq(index, range);
724     }
725 
<span class="line-added">726     private boolean constantLengthCompareNeedsTmpArrayPointers() {</span>
<span class="line-added">727         AVXKind.AVXSize vSize = vectorSize;</span>
<span class="line-added">728         if (constantLength() &lt; getElementsPerVector(vectorSize)) {</span>
<span class="line-added">729             vSize = AVXKind.AVXSize.XMM;</span>
<span class="line-added">730         }</span>
<span class="line-added">731         int vectorCount = constantLength() &amp; ~(2 * getElementsPerVector(vSize) - 1);</span>
<span class="line-added">732         return vectorCount &gt; 0;</span>
<span class="line-added">733     }</span>
<span class="line-added">734 </span>
735     /**
736      * Emits specialized assembly for checking equality of memory regions
737      * {@code arrayPtr1[0..nBytes]} and {@code arrayPtr2[0..nBytes]}. If they match, execution
738      * continues directly after the emitted code block, otherwise we jump to {@code noMatch}.
739      */
740     private void emitConstantLengthArrayCompareBytes(
741                     CompilationResultBuilder crb,
742                     AMD64MacroAssembler asm,




743                     Register[] tmpVectors,
744                     Label noMatch) {
<span class="line-modified">745         if (constantLength() == 0) {</span>
746             // do nothing
747             return;
748         }
<span class="line-added">749         Register arrayPtr1 = asRegister(array1Value);</span>
<span class="line-added">750         Register arrayPtr2 = asRegister(array2Value);</span>
<span class="line-added">751         Register tmp = asRegister(temp3);</span>
752         AVXKind.AVXSize vSize = vectorSize;
<span class="line-modified">753         if (constantLength() &lt; getElementsPerVector(vectorSize)) {</span>
754             vSize = AVXKind.AVXSize.XMM;
755         }
756         int elementsPerVector = getElementsPerVector(vSize);
<span class="line-modified">757         if (elementsPerVector &gt; constantLength()) {</span>
758             assert kind1 == kind2;
<span class="line-modified">759             int byteLength = constantLength() &lt;&lt; arrayIndexScale1.log2;</span>
<span class="line-modified">760             // array is shorter than any vector register, use regular XOR instructions</span>
761             int movSize = (byteLength &lt; 2) ? 1 : ((byteLength &lt; 4) ? 2 : ((byteLength &lt; 8) ? 4 : 8));
<span class="line-modified">762             emitMovBytes(asm, tmp, new AMD64Address(arrayPtr1, arrayBaseOffset1), movSize);</span>
<span class="line-modified">763             emitXorBytes(asm, tmp, new AMD64Address(arrayPtr2, arrayBaseOffset2), movSize);</span>
<span class="line-modified">764             asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>

765             if (byteLength &gt; movSize) {
<span class="line-modified">766                 emitMovBytes(asm, tmp, new AMD64Address(arrayPtr1, arrayBaseOffset1 + byteLength - movSize), movSize);</span>
<span class="line-modified">767                 emitXorBytes(asm, tmp, new AMD64Address(arrayPtr2, arrayBaseOffset2 + byteLength - movSize), movSize);</span>
<span class="line-modified">768                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>

769             }
770         } else {
771             int elementsPerVectorLoop = 2 * elementsPerVector;
<span class="line-modified">772             int tailCount = constantLength() &amp; (elementsPerVectorLoop - 1);</span>
<span class="line-modified">773             int vectorCount = constantLength() &amp; ~(elementsPerVectorLoop - 1);</span>
774             int bytesPerVector = vSize.getBytes();
775             if (vectorCount &gt; 0) {
776                 Label loopBegin = new Label();
<span class="line-modified">777                 Register tmpArrayPtr1 = asRegister(temp1);</span>
<span class="line-modified">778                 Register tmpArrayPtr2 = asRegister(temp2);</span>
<span class="line-modified">779                 asm.leaq(tmpArrayPtr1, new AMD64Address(arrayPtr1, vectorCount &lt;&lt; arrayIndexScale1.log2));</span>
<span class="line-added">780                 asm.leaq(tmpArrayPtr2, new AMD64Address(arrayPtr2, vectorCount &lt;&lt; arrayIndexScale2.log2));</span>
<span class="line-added">781                 arrayPtr1 = tmpArrayPtr1;</span>
<span class="line-added">782                 arrayPtr2 = tmpArrayPtr2;</span>
<span class="line-added">783                 asm.movq(tmp, -vectorCount);</span>
784                 asm.align(crb.target.wordSize * 2);
785                 asm.bind(loopBegin);
<span class="line-modified">786                 emitVectorLoad1(asm, tmpVectors[0], arrayPtr1, tmp, arrayBaseOffset1, vSize);</span>
<span class="line-modified">787                 emitVectorLoad2(asm, tmpVectors[1], arrayPtr2, tmp, arrayBaseOffset2, vSize);</span>
<span class="line-modified">788                 emitVectorLoad1(asm, tmpVectors[2], arrayPtr1, tmp, arrayBaseOffset1 + scaleDisplacement1(bytesPerVector), vSize);</span>
<span class="line-modified">789                 emitVectorLoad2(asm, tmpVectors[3], arrayPtr2, tmp, arrayBaseOffset2 + scaleDisplacement2(bytesPerVector), vSize);</span>
790                 emitVectorXor(asm, tmpVectors[0], tmpVectors[1], vSize);
791                 emitVectorXor(asm, tmpVectors[2], tmpVectors[3], vSize);
792                 emitVectorTest(asm, tmpVectors[0], vSize);
<span class="line-modified">793                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
794                 emitVectorTest(asm, tmpVectors[2], vSize);
<span class="line-modified">795                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
<span class="line-modified">796                 asm.addq(tmp, elementsPerVectorLoop);</span>
<span class="line-modified">797                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, loopBegin);</span>
798             }
799             if (tailCount &gt; 0) {
<span class="line-modified">800                 emitVectorLoad1(asm, tmpVectors[0], arrayPtr1, arrayBaseOffset1 + (tailCount &lt;&lt; arrayIndexScale1.log2) - scaleDisplacement1(bytesPerVector), vSize);</span>
<span class="line-modified">801                 emitVectorLoad2(asm, tmpVectors[1], arrayPtr2, arrayBaseOffset2 + (tailCount &lt;&lt; arrayIndexScale2.log2) - scaleDisplacement2(bytesPerVector), vSize);</span>
802                 emitVectorXor(asm, tmpVectors[0], tmpVectors[1], vSize);
803                 if (tailCount &gt; elementsPerVector) {
<span class="line-modified">804                     emitVectorLoad1(asm, tmpVectors[2], arrayPtr1, arrayBaseOffset1, vSize);</span>
<span class="line-modified">805                     emitVectorLoad2(asm, tmpVectors[3], arrayPtr2, arrayBaseOffset2, vSize);</span>
806                     emitVectorXor(asm, tmpVectors[2], tmpVectors[3], vSize);
807                     emitVectorTest(asm, tmpVectors[2], vSize);
<span class="line-modified">808                     asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
809                 }
810                 emitVectorTest(asm, tmpVectors[0], vSize);
<span class="line-modified">811                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);</span>
812             }
813         }
814     }
815 
816     private void emitMovBytes(AMD64MacroAssembler asm, Register dst, AMD64Address src, int size) {
817         switch (size) {
818             case 1:
819                 if (signExtend) {
820                     asm.movsbq(dst, src);
821                 } else {
822                     asm.movzbq(dst, src);
823                 }
824                 break;
825             case 2:
826                 if (signExtend) {
827                     asm.movswq(dst, src);
828                 } else {
829                     asm.movzwq(dst, src);
830                 }
831                 break;
832             case 4:
833                 if (signExtend) {
834                     asm.movslq(dst, src);
835                 } else {
836                     // there is no movzlq
837                     asm.movl(dst, src);
838                 }
839                 break;
840             case 8:
841                 asm.movq(dst, src);
842                 break;
843             default:
844                 throw new IllegalStateException();
845         }
846     }
847 
<span class="line-modified">848     private static void emitXorBytes(AMD64MacroAssembler asm, Register dst, AMD64Address src, int size) {</span>
<span class="line-modified">849         OperandSize opSize = getOperandSize(size);</span>
<span class="line-modified">850         XOR.getRMOpcode(opSize).emit(asm, opSize, dst, src);</span>
<span class="line-modified">851     }</span>
<span class="line-modified">852 </span>
<span class="line-added">853     private static OperandSize getOperandSize(int size) {</span>
<span class="line-added">854         switch (size) {</span>
<span class="line-added">855             case 1:</span>
<span class="line-added">856                 return OperandSize.BYTE;</span>
<span class="line-added">857             case 2:</span>
<span class="line-added">858                 return OperandSize.WORD;</span>
<span class="line-added">859             case 4:</span>
<span class="line-added">860                 return OperandSize.DWORD;</span>
<span class="line-added">861             case 8:</span>
<span class="line-added">862                 return OperandSize.QWORD;</span>
<span class="line-added">863             default:</span>
<span class="line-added">864                 throw new IllegalStateException();</span>
865         }
866     }
<span class="line-added">867 </span>
<span class="line-added">868     @Override</span>
<span class="line-added">869     public boolean needsClearUpperVectorRegisters() {</span>
<span class="line-added">870         return true;</span>
<span class="line-added">871     }</span>
872 }
</pre>
</td>
</tr>
</table>
<center><a href="AMD64ArrayCompareToOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ArrayIndexOfOp.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64.test/src/org/graalvm/compiler/core/amd64/test/AMD64MatchRuleTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64SuitesCreator.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantStackMoveTest.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64.test/src/org/graalvm/compiler/core/amd64/test/AMD64MatchRuleTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,18 +24,23 @@</span>
  
  package org.graalvm.compiler.core.amd64.test;
  
  import static org.junit.Assume.assumeTrue;
  
<span class="udiff-line-added">+ import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;</span>
  import org.graalvm.compiler.core.test.MatchRuleTest;
  import org.graalvm.compiler.lir.LIR;
  import org.graalvm.compiler.lir.LIRInstruction;
<span class="udiff-line-added">+ import org.graalvm.compiler.lir.amd64.AMD64Binary;</span>
  import org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.MemoryConstOp;
<span class="udiff-line-added">+ import org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer.ConstOp;</span>
<span class="udiff-line-added">+ import org.graalvm.compiler.lir.amd64.AMD64Unary;</span>
  import org.junit.Before;
  import org.junit.Test;
  
  import jdk.vm.ci.amd64.AMD64;
<span class="udiff-line-added">+ import jdk.vm.ci.amd64.AMD64Kind;</span>
  
  public class AMD64MatchRuleTest extends MatchRuleTest {
      @Before
      public void checkAMD64() {
          assumeTrue(&quot;skipping AMD64 specific test&quot;, getTarget().arch instanceof AMD64);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -75,6 +80,184 @@</span>
          public TestClass(int x) {
              super();
              this.x = x;
          }
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static volatile short shortValue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static long testVolatileExtensionSnippet() {</span>
<span class="udiff-line-added">+         return shortValue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Test</span>
<span class="udiff-line-added">+     public void testVolatileExtension() {</span>
<span class="udiff-line-added">+         compile(getResolvedJavaMethod(&quot;testVolatileExtensionSnippet&quot;), null);</span>
<span class="udiff-line-added">+         LIR lir = getLIR();</span>
<span class="udiff-line-added">+         boolean found = false;</span>
<span class="udiff-line-added">+         for (LIRInstruction ins : lir.getLIRforBlock(lir.codeEmittingOrder()[0])) {</span>
<span class="udiff-line-added">+             if (ins instanceof AMD64Unary.MemoryOp) {</span>
<span class="udiff-line-added">+                 ins.visitEachOutput((value, mode, flags) -&gt; assertTrue(value.getPlatformKind().toString(), value.getPlatformKind().equals(AMD64Kind.QWORD)));</span>
<span class="udiff-line-added">+                 assertFalse(&quot;MemoryOp expected only once in first block&quot;, found);</span>
<span class="udiff-line-added">+                 found = true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assertTrue(&quot;sign extending load must be in the LIR&quot;, found);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static int intValue;</span>
<span class="udiff-line-added">+     static volatile int volatileIntValue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Can&#39;t match test and load of input because of volatile store in between.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public static short testLoadTestNoMatchSnippet() {</span>
<span class="udiff-line-added">+         int v = intValue;</span>
<span class="udiff-line-added">+         volatileIntValue = 42;</span>
<span class="udiff-line-added">+         if (v == 42) {</span>
<span class="udiff-line-added">+             return shortValue;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return 0;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Test</span>
<span class="udiff-line-added">+     public void testLoadTestNoMatch() {</span>
<span class="udiff-line-added">+         compile(getResolvedJavaMethod(&quot;testLoadTestNoMatchSnippet&quot;), null);</span>
<span class="udiff-line-added">+         LIR lir = getLIR();</span>
<span class="udiff-line-added">+         boolean found = false;</span>
<span class="udiff-line-added">+         for (LIRInstruction ins : lir.getLIRforBlock(lir.codeEmittingOrder()[0])) {</span>
<span class="udiff-line-added">+             if (ins instanceof ConstOp &amp;&amp; ((ConstOp) ins).getOpcode().toString().equals(&quot;CMP&quot;)) {</span>
<span class="udiff-line-added">+                 assertFalse(&quot;CMP expected only once in first block&quot;, found);</span>
<span class="udiff-line-added">+                 found = true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assertTrue(&quot;CMP must be in the LIR&quot;, found);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Should match as an add with a memory operand.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public static int testAddLoadSnippet() {</span>
<span class="udiff-line-added">+         int v1 = volatileIntValue;</span>
<span class="udiff-line-added">+         int v2 = intValue;</span>
<span class="udiff-line-added">+         return v2 + (2 * v1);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Test</span>
<span class="udiff-line-added">+     public void testAddLoad() {</span>
<span class="udiff-line-added">+         compile(getResolvedJavaMethod(&quot;testAddLoadSnippet&quot;), null);</span>
<span class="udiff-line-added">+         LIR lir = getLIR();</span>
<span class="udiff-line-added">+         boolean found = false;</span>
<span class="udiff-line-added">+         for (LIRInstruction ins : lir.getLIRforBlock(lir.codeEmittingOrder()[0])) {</span>
<span class="udiff-line-added">+             if (ins instanceof AMD64Binary.MemoryTwoOp &amp;&amp; ((AMD64Binary.MemoryTwoOp) ins).getOpcode().toString().equals(&quot;ADD&quot;)) {</span>
<span class="udiff-line-added">+                 assertFalse(&quot;MemoryTwoOp expected only once in first block&quot;, found);</span>
<span class="udiff-line-added">+                 found = true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assertTrue(&quot;ADD with memory argument must be in the LIR&quot;, found);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Can&#39;t match as an add with a memory operand because the other add input is too late.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public static int testAddLoadNoMatchSnippet() {</span>
<span class="udiff-line-added">+         int v1 = volatileIntValue;</span>
<span class="udiff-line-added">+         int v2 = intValue;</span>
<span class="udiff-line-added">+         return v1 + (2 * v2);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Test</span>
<span class="udiff-line-added">+     public void testAddLoadNoMatch() {</span>
<span class="udiff-line-added">+         compile(getResolvedJavaMethod(&quot;testAddLoadNoMatchSnippet&quot;), null);</span>
<span class="udiff-line-added">+         LIR lir = getLIR();</span>
<span class="udiff-line-added">+         boolean found = false;</span>
<span class="udiff-line-added">+         for (LIRInstruction ins : lir.getLIRforBlock(lir.codeEmittingOrder()[0])) {</span>
<span class="udiff-line-added">+             if (ins instanceof AMD64Binary.CommutativeTwoOp &amp;&amp; ((AMD64Binary.CommutativeTwoOp) ins).getOpcode().toString().equals(&quot;ADD&quot;)) {</span>
<span class="udiff-line-added">+                 assertFalse(&quot;CommutativeTwoOp expected only once in first block&quot;, found);</span>
<span class="udiff-line-added">+                 found = true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assertTrue(&quot;ADD with memory argument must not be in the LIR&quot;, found);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * sign extension and load are in different blocks but can still be matched as a single</span>
<span class="udiff-line-added">+      * instruction.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public static long testVolatileExtensionDifferentBlocksSnippet(boolean flag) {</span>
<span class="udiff-line-added">+         short v = shortValue;</span>
<span class="udiff-line-added">+         if (flag) {</span>
<span class="udiff-line-added">+             return v;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return 0;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Test</span>
<span class="udiff-line-added">+     public void testVolatileExtensionDifferentBlocks() {</span>
<span class="udiff-line-added">+         compile(getResolvedJavaMethod(&quot;testVolatileExtensionDifferentBlocksSnippet&quot;), null);</span>
<span class="udiff-line-added">+         LIR lir = getLIR();</span>
<span class="udiff-line-added">+         boolean found = false;</span>
<span class="udiff-line-added">+         for (LIRInstruction ins : lir.getLIRforBlock(lir.codeEmittingOrder()[0])) {</span>
<span class="udiff-line-added">+             if (ins instanceof AMD64Unary.MemoryOp) {</span>
<span class="udiff-line-added">+                 ins.visitEachOutput((value, mode, flags) -&gt; assertTrue(value.getPlatformKind().toString(), value.getPlatformKind().equals(AMD64Kind.QWORD)));</span>
<span class="udiff-line-added">+                 assertFalse(&quot;MemoryOp expected only once in first block&quot;, found);</span>
<span class="udiff-line-added">+                 found = true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assertTrue(&quot;sign extending load must be in the LIR&quot;, found);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Add and load are not in the same block and one input is too late: can&#39;t match.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public static int testAddLoadDifferentBlocksNoMatchSnippet(boolean flag) {</span>
<span class="udiff-line-added">+         int v1 = volatileIntValue;</span>
<span class="udiff-line-added">+         if (flag) {</span>
<span class="udiff-line-added">+             int v2 = intValue;</span>
<span class="udiff-line-added">+             return v1 + (2 * v2);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return 0;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Test</span>
<span class="udiff-line-added">+     public void testAddLoadDifferentBlocksNoMatch() {</span>
<span class="udiff-line-added">+         compile(getResolvedJavaMethod(&quot;testAddLoadDifferentBlocksNoMatchSnippet&quot;), null);</span>
<span class="udiff-line-added">+         LIR lir = getLIR();</span>
<span class="udiff-line-added">+         boolean found = false;</span>
<span class="udiff-line-added">+         for (AbstractBlockBase&lt;?&gt; b : lir.codeEmittingOrder()) {</span>
<span class="udiff-line-added">+             for (LIRInstruction ins : lir.getLIRforBlock(b)) {</span>
<span class="udiff-line-added">+                 if (ins instanceof AMD64Binary.CommutativeTwoOp &amp;&amp; ((AMD64Binary.CommutativeTwoOp) ins).getOpcode().toString().equals(&quot;ADD&quot;)) {</span>
<span class="udiff-line-added">+                     assertFalse(&quot;CommutativeTwoOp expected only once in first block&quot;, found);</span>
<span class="udiff-line-added">+                     found = true;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assertTrue(&quot;ADD with memory argument must not be in the LIR&quot;, found);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Add and load are in different blocks but can still match.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public static int testAddLoadDifferentBlocksSnippet(boolean flag) {</span>
<span class="udiff-line-added">+         int v2 = intValue;</span>
<span class="udiff-line-added">+         int v1 = volatileIntValue;</span>
<span class="udiff-line-added">+         if (flag) {</span>
<span class="udiff-line-added">+             return v1 + v2;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return 0;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Test</span>
<span class="udiff-line-added">+     public void testAddLoadDifferentBlocks() {</span>
<span class="udiff-line-added">+         compile(getResolvedJavaMethod(&quot;testAddLoadDifferentBlocksSnippet&quot;), null);</span>
<span class="udiff-line-added">+         LIR lir = getLIR();</span>
<span class="udiff-line-added">+         boolean found = false;</span>
<span class="udiff-line-added">+         for (LIRInstruction ins : lir.getLIRforBlock(lir.codeEmittingOrder()[0])) {</span>
<span class="udiff-line-added">+             if (ins instanceof AMD64Binary.MemoryTwoOp &amp;&amp; ((AMD64Binary.MemoryTwoOp) ins).getOpcode().toString().equals(&quot;ADD&quot;)) {</span>
<span class="udiff-line-added">+                 assertFalse(&quot;MemoryTwoOp expected only once in first block&quot;, found);</span>
<span class="udiff-line-added">+                 found = true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assertTrue(&quot;ADD with memory argument must be in the LIR&quot;, found);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
  }
</pre>
<center><a href="../../../../../../../../org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64SuitesCreator.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantStackMoveTest.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/IfNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.nodes;
  26 
  27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_1;
  28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_2;
  29 
  30 import java.util.ArrayList;
  31 import java.util.Arrays;
  32 import java.util.Iterator;
  33 import java.util.List;
  34 import java.util.Objects;
  35 
  36 import jdk.internal.vm.compiler.collections.EconomicMap;
  37 import jdk.internal.vm.compiler.collections.Equivalence;
  38 import org.graalvm.compiler.bytecode.BytecodeDisassembler;
  39 import org.graalvm.compiler.bytecode.Bytecodes;
  40 import org.graalvm.compiler.bytecode.Bytes;
  41 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  42 import org.graalvm.compiler.core.common.calc.Condition;
<a name="2" id="anc2"></a><span class="line-added">  43 import org.graalvm.compiler.core.common.type.FloatStamp;</span>
  44 import org.graalvm.compiler.core.common.type.IntegerStamp;
<a name="3" id="anc3"></a><span class="line-added">  45 import org.graalvm.compiler.core.common.type.PrimitiveStamp;</span>
  46 import org.graalvm.compiler.core.common.type.Stamp;
  47 import org.graalvm.compiler.core.common.type.StampFactory;
  48 import org.graalvm.compiler.debug.CounterKey;
  49 import org.graalvm.compiler.debug.DebugCloseable;
  50 import org.graalvm.compiler.debug.DebugContext;
  51 import org.graalvm.compiler.debug.GraalError;
<a name="4" id="anc4"></a><span class="line-added">  52 import org.graalvm.compiler.graph.IterableNodeType;</span>
  53 import org.graalvm.compiler.graph.Node;
  54 import org.graalvm.compiler.graph.NodeClass;
  55 import org.graalvm.compiler.graph.NodeSourcePosition;
  56 import org.graalvm.compiler.graph.iterators.NodeIterable;
<a name="5" id="anc5"></a>
  57 import org.graalvm.compiler.graph.spi.Simplifiable;
  58 import org.graalvm.compiler.graph.spi.SimplifierTool;
  59 import org.graalvm.compiler.nodeinfo.InputType;
  60 import org.graalvm.compiler.nodeinfo.NodeInfo;
<a name="6" id="anc6"></a><span class="line-added">  61 import org.graalvm.compiler.nodes.calc.AddNode;</span>
  62 import org.graalvm.compiler.nodes.calc.CompareNode;
  63 import org.graalvm.compiler.nodes.calc.ConditionalNode;
<a name="7" id="anc7"></a><span class="line-added">  64 import org.graalvm.compiler.nodes.calc.FloatNormalizeCompareNode;</span>
  65 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  66 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  67 import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;
<a name="8" id="anc8"></a><span class="line-added">  68 import org.graalvm.compiler.nodes.calc.IntegerNormalizeCompareNode;</span>
  69 import org.graalvm.compiler.nodes.calc.IsNullNode;
<a name="9" id="anc9"></a>
  70 import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
  71 import org.graalvm.compiler.nodes.extended.UnboxNode;
  72 import org.graalvm.compiler.nodes.java.InstanceOfNode;
  73 import org.graalvm.compiler.nodes.java.LoadFieldNode;
  74 import org.graalvm.compiler.nodes.spi.LIRLowerable;
  75 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
<a name="10" id="anc10"></a><span class="line-added">  76 import org.graalvm.compiler.nodes.spi.SwitchFoldable;</span>
  77 import org.graalvm.compiler.nodes.util.GraphUtil;
  78 
<a name="11" id="anc11"></a><span class="line-added">  79 import jdk.vm.ci.code.CodeUtil;</span>
  80 import jdk.vm.ci.meta.Constant;
  81 import jdk.vm.ci.meta.JavaConstant;
  82 import jdk.vm.ci.meta.JavaKind;
  83 import jdk.vm.ci.meta.MetaAccessProvider;
  84 import jdk.vm.ci.meta.PrimitiveConstant;
  85 import jdk.vm.ci.meta.ResolvedJavaMethod;
  86 import jdk.vm.ci.meta.ResolvedJavaType;
  87 import jdk.vm.ci.meta.TriState;
  88 
  89 /**
  90  * The {@code IfNode} represents a branch that can go one of two directions depending on the outcome
  91  * of a comparison.
  92  */
  93 @NodeInfo(cycles = CYCLES_1, size = SIZE_2, sizeRationale = &quot;2 jmps&quot;)
<a name="12" id="anc12"></a><span class="line-modified">  94 public final class IfNode extends ControlSplitNode implements Simplifiable, LIRLowerable, IterableNodeType, SwitchFoldable {</span>
  95     public static final NodeClass&lt;IfNode&gt; TYPE = NodeClass.create(IfNode.class);
  96 
  97     private static final CounterKey CORRECTED_PROBABILITIES = DebugContext.counter(&quot;CorrectedProbabilities&quot;);
  98 
  99     @Successor AbstractBeginNode trueSuccessor;
 100     @Successor AbstractBeginNode falseSuccessor;
 101     @Input(InputType.Condition) LogicNode condition;
 102     protected double trueSuccessorProbability;
 103 
 104     public LogicNode condition() {
 105         return condition;
 106     }
 107 
 108     public void setCondition(LogicNode x) {
 109         updateUsages(condition, x);
 110         condition = x;
 111     }
 112 
 113     public IfNode(LogicNode condition, FixedNode trueSuccessor, FixedNode falseSuccessor, double trueSuccessorProbability) {
 114         this(condition, BeginNode.begin(trueSuccessor), BeginNode.begin(falseSuccessor), trueSuccessorProbability);
 115     }
 116 
 117     public IfNode(LogicNode condition, AbstractBeginNode trueSuccessor, AbstractBeginNode falseSuccessor, double trueSuccessorProbability) {
 118         super(TYPE, StampFactory.forVoid());
 119         this.condition = condition;
 120         this.falseSuccessor = falseSuccessor;
 121         this.trueSuccessor = trueSuccessor;
 122         setTrueSuccessorProbability(trueSuccessorProbability);
 123     }
 124 
 125     /**
 126      * Gets the true successor.
 127      *
 128      * @return the true successor
 129      */
 130     public AbstractBeginNode trueSuccessor() {
 131         return trueSuccessor;
 132     }
 133 
 134     /**
 135      * Gets the false successor.
 136      *
 137      * @return the false successor
 138      */
 139     public AbstractBeginNode falseSuccessor() {
 140         return falseSuccessor;
 141     }
 142 
 143     public double getTrueSuccessorProbability() {
 144         return this.trueSuccessorProbability;
 145     }
 146 
 147     public void setTrueSuccessor(AbstractBeginNode node) {
 148         updatePredecessor(trueSuccessor, node);
 149         trueSuccessor = node;
 150     }
 151 
 152     public void setFalseSuccessor(AbstractBeginNode node) {
 153         updatePredecessor(falseSuccessor, node);
 154         falseSuccessor = node;
 155     }
 156 
 157     /**
 158      * Gets the node corresponding to the specified outcome of the branch.
 159      *
 160      * @param istrue {@code true} if the true successor is requested, {@code false} otherwise
 161      * @return the corresponding successor
 162      */
 163     public AbstractBeginNode successor(boolean istrue) {
 164         return istrue ? trueSuccessor : falseSuccessor;
 165     }
 166 
 167     public void setTrueSuccessorProbability(double prob) {
 168         assert prob &gt;= -0.000000001 &amp;&amp; prob &lt;= 1.000000001 : &quot;Probability out of bounds: &quot; + prob;
 169         trueSuccessorProbability = Math.min(1.0, Math.max(0.0, prob));
 170     }
 171 
 172     @Override
 173     public double probability(AbstractBeginNode successor) {
 174         return successor == trueSuccessor ? trueSuccessorProbability : 1 - trueSuccessorProbability;
 175     }
 176 
 177     @Override
 178     public void generate(NodeLIRBuilderTool gen) {
 179         gen.emitIf(this);
 180     }
 181 
 182     @Override
 183     public boolean verify() {
 184         assertTrue(condition() != null, &quot;missing condition&quot;);
 185         assertTrue(trueSuccessor() != null, &quot;missing trueSuccessor&quot;);
 186         assertTrue(falseSuccessor() != null, &quot;missing falseSuccessor&quot;);
 187         return super.verify();
 188     }
 189 
 190     private boolean compareCallContext(NodeSourcePosition successorPosition) {
 191         NodeSourcePosition position = getNodeSourcePosition();
 192         NodeSourcePosition successor = successorPosition;
 193         while (position != null) {
 194             assertTrue(Objects.equals(position.getMethod(), successor.getMethod()), &quot;method mismatch&quot;);
 195             position = position.getCaller();
 196             successor = successor.getCaller();
 197         }
 198         assertTrue(successor == null, &quot;successor position has more methods&quot;);
 199         return true;
 200     }
 201 
 202     @Override
 203     public boolean verifySourcePosition() {
 204         NodeSourcePosition sourcePosition = getNodeSourcePosition();
 205         assertTrue(sourcePosition != null, &quot;missing IfNode source position&quot;);
 206 
 207         NodeSourcePosition trueSuccessorPosition = trueSuccessor.getNodeSourcePosition();
 208         assertTrue(trueSuccessorPosition != null, &quot;missing IfNode true successor source position&quot;);
 209 
 210         NodeSourcePosition falseSuccessorPosition = falseSuccessor.getNodeSourcePosition();
 211         assertTrue(falseSuccessorPosition != null, &quot;missing IfNode false successor source position&quot;);
 212 
 213         int bci = sourcePosition.getBCI();
 214         ResolvedJavaMethod method = sourcePosition.getMethod();
 215         int bytecode = BytecodeDisassembler.getBytecodeAt(method, bci);
 216 
 217         if (!Bytecodes.isIfBytecode(bytecode)) {
 218             return true;
 219         }
 220 
 221         byte[] code = (new ResolvedJavaMethodBytecode(method)).getCode();
 222         int targetBCI = bci + Bytes.beS2(code, bci + 1);
 223         int nextBCI = bci + Bytecodes.lengthOf(bytecode);
 224 
 225         // At least one successor should have the correct BCI to indicate any possible negation that
 226         // occurred after bytecode parsing
 227         boolean matchingSuccessorFound = false;
 228         if (trueSuccessorPosition.getBCI() == nextBCI || trueSuccessorPosition.getBCI() == targetBCI) {
 229             assertTrue(compareCallContext(trueSuccessorPosition), &quot;call context different from IfNode in trueSuccessor&quot;);
 230             matchingSuccessorFound = true;
 231         }
 232 
 233         if (falseSuccessorPosition.getBCI() == nextBCI || falseSuccessorPosition.getBCI() == targetBCI) {
 234             assertTrue(compareCallContext(falseSuccessorPosition), &quot;call context different from IfNode in falseSuccessor&quot;);
 235             matchingSuccessorFound = true;
 236         }
 237 
 238         assertTrue(matchingSuccessorFound, &quot;no matching successor position found in IfNode&quot;);
 239         assertTrue(trueSuccessorPosition.getBCI() != falseSuccessorPosition.getBCI(), &quot;successor positions same in IfNode&quot;);
 240 
 241         return true;
 242     }
 243 
 244     public void eliminateNegation() {
 245         AbstractBeginNode oldTrueSuccessor = trueSuccessor;
 246         AbstractBeginNode oldFalseSuccessor = falseSuccessor;
 247         trueSuccessor = oldFalseSuccessor;
 248         falseSuccessor = oldTrueSuccessor;
 249         trueSuccessorProbability = 1 - trueSuccessorProbability;
 250         setCondition(((LogicNegationNode) condition).getValue());
 251     }
 252 
 253     @Override
 254     public void simplify(SimplifierTool tool) {
 255         if (trueSuccessor().next() instanceof DeoptimizeNode) {
 256             if (trueSuccessorProbability != 0) {
 257                 CORRECTED_PROBABILITIES.increment(getDebug());
 258                 trueSuccessorProbability = 0;
 259             }
 260         } else if (falseSuccessor().next() instanceof DeoptimizeNode) {
 261             if (trueSuccessorProbability != 1) {
 262                 CORRECTED_PROBABILITIES.increment(getDebug());
 263                 trueSuccessorProbability = 1;
 264             }
 265         }
 266 
 267         if (condition() instanceof LogicNegationNode) {
 268             eliminateNegation();
 269         }
 270         if (condition() instanceof LogicConstantNode) {
 271             LogicConstantNode c = (LogicConstantNode) condition();
 272             if (c.getValue()) {
 273                 tool.deleteBranch(falseSuccessor());
 274                 tool.addToWorkList(trueSuccessor());
 275                 graph().removeSplit(this, trueSuccessor());
 276             } else {
 277                 tool.deleteBranch(trueSuccessor());
 278                 tool.addToWorkList(falseSuccessor());
 279                 graph().removeSplit(this, falseSuccessor());
 280             }
 281             return;
 282         }
 283         if (tool.allUsagesAvailable() &amp;&amp; trueSuccessor().hasNoUsages() &amp;&amp; falseSuccessor().hasNoUsages()) {
 284 
 285             pushNodesThroughIf(tool);
 286 
 287             if (checkForUnsignedCompare(tool) || removeOrMaterializeIf(tool)) {
 288                 return;
 289             }
 290         }
 291 
 292         if (removeIntermediateMaterialization(tool)) {
 293             return;
 294         }
 295 
<a name="13" id="anc13"></a><span class="line-modified"> 296         if (conditionalNodeOptimization(tool)) {</span>
 297             return;
 298         }
 299 
<a name="14" id="anc14"></a><span class="line-modified"> 300         if (switchTransformationOptimization(tool)) {</span>
 301             return;
 302         }
 303 
<a name="15" id="anc15"></a><span class="line-modified"> 304         if (falseSuccessor().hasNoUsages() &amp;&amp; (!(falseSuccessor() instanceof LoopExitNode)) &amp;&amp; falseSuccessor().next() instanceof IfNode &amp;&amp;</span>
<span class="line-added"> 305                         !(((IfNode) falseSuccessor().next()).falseSuccessor() instanceof LoopExitNode)) {</span>
 306             AbstractBeginNode intermediateBegin = falseSuccessor();
 307             IfNode nextIf = (IfNode) intermediateBegin.next();
 308             double probabilityB = (1.0 - this.trueSuccessorProbability) * nextIf.trueSuccessorProbability;
 309             if (this.trueSuccessorProbability &lt; probabilityB) {
 310                 // Reordering of those two if statements is beneficial from the point of view of
 311                 // their probabilities.
 312                 if (prepareForSwap(tool, condition(), nextIf.condition())) {
 313                     // Reordering is allowed from (if1 =&gt; begin =&gt; if2) to (if2 =&gt; begin =&gt; if1).
 314                     assert intermediateBegin.next() == nextIf;
 315                     AbstractBeginNode bothFalseBegin = nextIf.falseSuccessor();
 316                     nextIf.setFalseSuccessor(null);
 317                     intermediateBegin.setNext(null);
 318                     this.setFalseSuccessor(null);
 319 
 320                     this.replaceAtPredecessor(nextIf);
 321                     nextIf.setFalseSuccessor(intermediateBegin);
 322                     intermediateBegin.setNext(this);
 323                     this.setFalseSuccessor(bothFalseBegin);
 324 
 325                     NodeSourcePosition intermediateBeginPosition = intermediateBegin.getNodeSourcePosition();
 326                     intermediateBegin.setNodeSourcePosition(bothFalseBegin.getNodeSourcePosition());
 327                     bothFalseBegin.setNodeSourcePosition(intermediateBeginPosition);
 328 
 329                     nextIf.setTrueSuccessorProbability(probabilityB);
 330                     if (probabilityB == 1.0) {
 331                         this.setTrueSuccessorProbability(0.0);
 332                     } else {
 333                         double newProbability = this.trueSuccessorProbability / (1.0 - probabilityB);
 334                         this.setTrueSuccessorProbability(Math.min(1.0, newProbability));
 335                     }
 336                     return;
 337                 }
 338             }
 339         }
 340 
 341         if (tryEliminateBoxedReferenceEquals(tool)) {
 342             return;
 343         }
 344     }
 345 
<a name="16" id="anc16"></a><span class="line-modified"> 346     private static boolean isUnboxedFrom(MetaAccessProvider meta, NodeView view, ValueNode x, ValueNode src) {</span>
 347         if (x == src) {
 348             return true;
 349         } else if (x instanceof UnboxNode) {
 350             return isUnboxedFrom(meta, view, ((UnboxNode) x).getValue(), src);
 351         } else if (x instanceof PiNode) {
 352             PiNode pi = (PiNode) x;
 353             return isUnboxedFrom(meta, view, pi.getOriginalNode(), src);
 354         } else if (x instanceof LoadFieldNode) {
 355             LoadFieldNode load = (LoadFieldNode) x;
 356             ResolvedJavaType integerType = meta.lookupJavaType(Integer.class);
 357             if (load.getValue().stamp(view).javaType(meta).equals(integerType)) {
 358                 return isUnboxedFrom(meta, view, load.getValue(), src);
 359             } else {
 360                 return false;
 361             }
 362         } else {
 363             return false;
 364         }
 365     }
 366 
 367     /**
 368      * Attempts to replace the following pattern:
 369      *
 370      * &lt;pre&gt;
 371      * Integer x = ...;
 372      * Integer y = ...;
 373      * if ((x == y) || x.equals(y)) { ... }
 374      * &lt;/pre&gt;
 375      *
 376      * with:
 377      *
 378      * &lt;pre&gt;
 379      * Integer x = ...;
 380      * Integer y = ...;
 381      * if (x.equals(y)) { ... }
 382      * &lt;/pre&gt;
 383      *
 384      * whenever the probability that the reference check will pass is relatively small.
 385      *
 386      * See GR-1315 for more information.
 387      */
 388     private boolean tryEliminateBoxedReferenceEquals(SimplifierTool tool) {
 389         if (!(condition instanceof ObjectEqualsNode)) {
 390             return false;
 391         }
 392 
 393         MetaAccessProvider meta = tool.getMetaAccess();
 394         ObjectEqualsNode equalsCondition = (ObjectEqualsNode) condition;
 395         ValueNode x = equalsCondition.getX();
 396         ValueNode y = equalsCondition.getY();
 397         ResolvedJavaType integerType = meta.lookupJavaType(Integer.class);
 398 
 399         // At least one argument for reference equal must be a boxed primitive.
 400         NodeView view = NodeView.from(tool);
 401         if (!x.stamp(view).javaType(meta).equals(integerType) &amp;&amp; !y.stamp(view).javaType(meta).equals(integerType)) {
 402             return false;
 403         }
 404 
 405         // The reference equality check is usually more efficient compared to a boxing check.
 406         // The success of the reference equals must therefore be relatively rare, otherwise it makes
 407         // no sense to eliminate it.
 408         if (getTrueSuccessorProbability() &gt; 0.4) {
 409             return false;
 410         }
 411 
 412         // True branch must be empty.
 413         if (trueSuccessor instanceof BeginNode || trueSuccessor instanceof LoopExitNode) {
 414             if (trueSuccessor.next() instanceof EndNode) {
 415                 // Empty true branch.
 416             } else {
 417                 return false;
 418             }
 419         } else {
 420             return false;
 421         }
 422 
 423         // False branch must only check the unboxed values.
 424         UnboxNode unbox = null;
 425         FixedGuardNode unboxCheck = null;
 426         for (FixedNode node : falseSuccessor.getBlockNodes()) {
 427             if (!(node instanceof BeginNode || node instanceof UnboxNode || node instanceof FixedGuardNode || node instanceof EndNode ||
 428                             node instanceof LoadFieldNode || node instanceof LoopExitNode)) {
 429                 return false;
 430             }
 431             if (node instanceof UnboxNode) {
 432                 if (unbox == null) {
 433                     unbox = (UnboxNode) node;
 434                 } else {
 435                     return false;
 436                 }
 437             }
 438             if (!(node instanceof FixedGuardNode)) {
 439                 continue;
 440             }
 441             FixedGuardNode fixed = (FixedGuardNode) node;
 442             if (!(fixed.condition() instanceof IntegerEqualsNode)) {
 443                 continue;
 444             }
 445             IntegerEqualsNode equals = (IntegerEqualsNode) fixed.condition();
 446             if ((isUnboxedFrom(meta, view, equals.getX(), x) &amp;&amp; isUnboxedFrom(meta, view, equals.getY(), y)) ||
 447                             (isUnboxedFrom(meta, view, equals.getX(), y) &amp;&amp; isUnboxedFrom(meta, view, equals.getY(), x))) {
 448                 unboxCheck = fixed;
 449             }
 450         }
 451         if (unbox == null || unboxCheck == null) {
 452             return false;
 453         }
 454 
 455         // Falsify the reference check.
 456         setCondition(graph().addOrUniqueWithInputs(LogicConstantNode.contradiction()));
 457 
 458         return true;
 459     }
 460 
<a name="17" id="anc17"></a><span class="line-added"> 461     // SwitchFoldable implementation.</span>
<span class="line-added"> 462 </span>
<span class="line-added"> 463     @Override</span>
<span class="line-added"> 464     public Node getNextSwitchFoldableBranch() {</span>
<span class="line-added"> 465         return falseSuccessor();</span>
<span class="line-added"> 466     }</span>
<span class="line-added"> 467 </span>
<span class="line-added"> 468     @Override</span>
<span class="line-added"> 469     public boolean isInSwitch(ValueNode switchValue) {</span>
<span class="line-added"> 470         return SwitchFoldable.maybeIsInSwitch(condition()) &amp;&amp; SwitchFoldable.sameSwitchValue(condition(), switchValue);</span>
<span class="line-added"> 471     }</span>
<span class="line-added"> 472 </span>
<span class="line-added"> 473     @Override</span>
<span class="line-added"> 474     public void cutOffCascadeNode() {</span>
<span class="line-added"> 475         setTrueSuccessor(null);</span>
<span class="line-added"> 476     }</span>
<span class="line-added"> 477 </span>
<span class="line-added"> 478     @Override</span>
<span class="line-added"> 479     public void cutOffLowestCascadeNode() {</span>
<span class="line-added"> 480         setFalseSuccessor(null);</span>
<span class="line-added"> 481         setTrueSuccessor(null);</span>
<span class="line-added"> 482     }</span>
<span class="line-added"> 483 </span>
<span class="line-added"> 484     @Override</span>
<span class="line-added"> 485     public AbstractBeginNode getDefault() {</span>
<span class="line-added"> 486         return falseSuccessor();</span>
<span class="line-added"> 487     }</span>
<span class="line-added"> 488 </span>
<span class="line-added"> 489     @Override</span>
<span class="line-added"> 490     public ValueNode switchValue() {</span>
<span class="line-added"> 491         if (SwitchFoldable.maybeIsInSwitch(condition())) {</span>
<span class="line-added"> 492             return ((IntegerEqualsNode) condition()).getX();</span>
<span class="line-added"> 493         }</span>
<span class="line-added"> 494         return null;</span>
<span class="line-added"> 495     }</span>
<span class="line-added"> 496 </span>
<span class="line-added"> 497     @Override</span>
<span class="line-added"> 498     public boolean isNonInitializedProfile() {</span>
<span class="line-added"> 499         return getTrueSuccessorProbability() == 0.5d;</span>
<span class="line-added"> 500     }</span>
<span class="line-added"> 501 </span>
<span class="line-added"> 502     @Override</span>
<span class="line-added"> 503     public int intKeyAt(int i) {</span>
<span class="line-added"> 504         assert i == 0;</span>
<span class="line-added"> 505         return ((IntegerEqualsNode) condition()).getY().asJavaConstant().asInt();</span>
<span class="line-added"> 506     }</span>
<span class="line-added"> 507 </span>
<span class="line-added"> 508     @Override</span>
<span class="line-added"> 509     public double keyProbability(int i) {</span>
<span class="line-added"> 510         assert i == 0;</span>
<span class="line-added"> 511         return getTrueSuccessorProbability();</span>
<span class="line-added"> 512     }</span>
<span class="line-added"> 513 </span>
<span class="line-added"> 514     @Override</span>
<span class="line-added"> 515     public AbstractBeginNode keySuccessor(int i) {</span>
<span class="line-added"> 516         assert i == 0;</span>
<span class="line-added"> 517         return trueSuccessor();</span>
<span class="line-added"> 518     }</span>
<span class="line-added"> 519 </span>
<span class="line-added"> 520     @Override</span>
<span class="line-added"> 521     public double defaultProbability() {</span>
<span class="line-added"> 522         return 1.0d - getTrueSuccessorProbability();</span>
<span class="line-added"> 523     }</span>
<span class="line-added"> 524 </span>
 525     /**
 526      * Try to optimize this as if it were a {@link ConditionalNode}.
 527      */
 528     private boolean conditionalNodeOptimization(SimplifierTool tool) {
 529         if (trueSuccessor().next() instanceof AbstractEndNode &amp;&amp; falseSuccessor().next() instanceof AbstractEndNode) {
 530             AbstractEndNode trueEnd = (AbstractEndNode) trueSuccessor().next();
 531             AbstractEndNode falseEnd = (AbstractEndNode) falseSuccessor().next();
 532             if (trueEnd.merge() != falseEnd.merge()) {
 533                 return false;
 534             }
 535             if (!(trueEnd.merge() instanceof MergeNode)) {
 536                 return false;
 537             }
 538             MergeNode merge = (MergeNode) trueEnd.merge();
<a name="18" id="anc18"></a><span class="line-modified"> 539             if (!merge.hasExactlyOneUsage() || merge.phis().count() != 1) {</span>
 540                 return false;
 541             }
 542 
<a name="19" id="anc19"></a><span class="line-modified"> 543             if (trueSuccessor().hasAnchored() || falseSuccessor().hasAnchored()) {</span>
 544                 return false;
 545             }
 546 
 547             PhiNode phi = merge.phis().first();
 548             ValueNode falseValue = phi.valueAt(falseEnd);
 549             ValueNode trueValue = phi.valueAt(trueEnd);
 550 
 551             NodeView view = NodeView.from(tool);
 552             ValueNode result = ConditionalNode.canonicalizeConditional(condition, trueValue, falseValue, phi.stamp(view), view);
 553             if (result != null) {
 554                 /*
 555                  * canonicalizeConditional returns possibly new nodes so add them to the graph.
 556                  */
 557                 if (result.graph() == null) {
 558                     result = graph().addOrUniqueWithInputs(result);
 559                 }
 560                 result = proxyReplacement(result);
 561                 /*
 562                  * This optimization can be performed even if multiple values merge at this phi
 563                  * since the two inputs get simplified into one.
 564                  */
 565                 phi.setValueAt(trueEnd, result);
 566                 removeThroughFalseBranch(tool, merge);
 567                 return true;
 568             }
 569         }
 570 
 571         return false;
 572     }
 573 
 574     private void pushNodesThroughIf(SimplifierTool tool) {
 575         assert trueSuccessor().hasNoUsages() &amp;&amp; falseSuccessor().hasNoUsages();
 576         // push similar nodes upwards through the if, thereby deduplicating them
 577         do {
 578             AbstractBeginNode trueSucc = trueSuccessor();
 579             AbstractBeginNode falseSucc = falseSuccessor();
 580             if (trueSucc instanceof BeginNode &amp;&amp; falseSucc instanceof BeginNode &amp;&amp; trueSucc.next() instanceof FixedWithNextNode &amp;&amp; falseSucc.next() instanceof FixedWithNextNode) {
 581                 FixedWithNextNode trueNext = (FixedWithNextNode) trueSucc.next();
 582                 FixedWithNextNode falseNext = (FixedWithNextNode) falseSucc.next();
 583                 NodeClass&lt;?&gt; nodeClass = trueNext.getNodeClass();
 584                 if (trueNext.getClass() == falseNext.getClass()) {
 585                     if (trueNext instanceof AbstractBeginNode) {
 586                         // Cannot do this optimization for begin nodes, because it could
 587                         // move guards above the if that need to stay below a branch.
 588                     } else if (nodeClass.equalInputs(trueNext, falseNext) &amp;&amp; trueNext.valueEquals(falseNext)) {
 589                         falseNext.replaceAtUsages(trueNext);
 590                         graph().removeFixed(falseNext);
 591                         GraphUtil.unlinkFixedNode(trueNext);
 592                         graph().addBeforeFixed(this, trueNext);
 593                         for (Node usage : trueNext.usages().snapshot()) {
 594                             if (usage.isAlive()) {
 595                                 NodeClass&lt;?&gt; usageNodeClass = usage.getNodeClass();
 596                                 if (usageNodeClass.valueNumberable() &amp;&amp; !usageNodeClass.isLeafNode()) {
 597                                     Node newNode = graph().findDuplicate(usage);
 598                                     if (newNode != null) {
 599                                         usage.replaceAtUsagesAndDelete(newNode);
 600                                     }
 601                                 }
 602                                 if (usage.isAlive()) {
 603                                     tool.addToWorkList(usage);
 604                                 }
 605                             }
 606                         }
 607                         continue;
 608                     }
 609                 }
 610             }
 611             break;
 612         } while (true);
 613     }
 614 
 615     /**
 616      * Recognize a couple patterns that can be merged into an unsigned compare.
 617      *
 618      * @param tool
 619      * @return true if a replacement was done.
 620      */
 621     @SuppressWarnings(&quot;try&quot;)
 622     private boolean checkForUnsignedCompare(SimplifierTool tool) {
 623         assert trueSuccessor().hasNoUsages() &amp;&amp; falseSuccessor().hasNoUsages();
 624         if (condition() instanceof IntegerLessThanNode) {
 625             NodeView view = NodeView.from(tool);
 626             IntegerLessThanNode lessThan = (IntegerLessThanNode) condition();
 627             Constant y = lessThan.getY().stamp(view).asConstant();
 628             if (y instanceof PrimitiveConstant &amp;&amp; ((PrimitiveConstant) y).asLong() == 0 &amp;&amp; falseSuccessor().next() instanceof IfNode) {
 629                 IfNode ifNode2 = (IfNode) falseSuccessor().next();
 630                 if (ifNode2.condition() instanceof IntegerLessThanNode) {
 631                     IntegerLessThanNode lessThan2 = (IntegerLessThanNode) ifNode2.condition();
 632                     AbstractBeginNode falseSucc = ifNode2.falseSuccessor();
 633                     AbstractBeginNode trueSucc = ifNode2.trueSuccessor();
 634                     IntegerBelowNode below = null;
 635                     /*
 636                      * Convert x &gt;= 0 &amp;&amp; x &lt; positive which is represented as !(x &lt; 0) &amp;&amp; x &lt;
 637                      * &lt;positive&gt; into an unsigned compare.
 638                      */
 639                     if (lessThan2.getX() == lessThan.getX() &amp;&amp; lessThan2.getY().stamp(view) instanceof IntegerStamp &amp;&amp;
 640                                     ((IntegerStamp) lessThan2.getY().stamp(view)).isPositive() &amp;&amp;
 641                                     sameDestination(trueSuccessor(), ifNode2.falseSuccessor)) {
 642                         below = graph().unique(new IntegerBelowNode(lessThan2.getX(), lessThan2.getY()));
 643                         // swap direction
 644                         AbstractBeginNode tmp = falseSucc;
 645                         falseSucc = trueSucc;
 646                         trueSucc = tmp;
 647                     } else if (lessThan2.getY() == lessThan.getX() &amp;&amp; sameDestination(trueSuccessor(), ifNode2.trueSuccessor)) {
 648                         /*
 649                          * Convert x &gt;= 0 &amp;&amp; x &lt;= positive which is represented as !(x &lt; 0) &amp;&amp;
 650                          * !(&lt;positive&gt; &gt; x), into x &lt;| positive + 1. This can only be done for
 651                          * constants since there isn&#39;t a IntegerBelowEqualThanNode but that doesn&#39;t
 652                          * appear to be interesting.
 653                          */
 654                         JavaConstant positive = lessThan2.getX().asJavaConstant();
 655                         if (positive != null &amp;&amp; positive.asLong() &gt; 0 &amp;&amp; positive.asLong() &lt; positive.getJavaKind().getMaxValue()) {
 656                             ConstantNode newLimit = ConstantNode.forIntegerStamp(lessThan2.getX().stamp(view), positive.asLong() + 1, graph());
 657                             below = graph().unique(new IntegerBelowNode(lessThan.getX(), newLimit));
 658                         }
 659                     }
 660                     if (below != null) {
 661                         try (DebugCloseable position = ifNode2.withNodeSourcePosition()) {
 662                             ifNode2.setTrueSuccessor(null);
 663                             ifNode2.setFalseSuccessor(null);
 664 
 665                             IfNode newIfNode = graph().add(new IfNode(below, falseSucc, trueSucc, 1 - trueSuccessorProbability));
 666                             // Remove the &lt; 0 test.
 667                             tool.deleteBranch(trueSuccessor);
 668                             graph().removeSplit(this, falseSuccessor);
 669 
 670                             // Replace the second test with the new one.
 671                             ifNode2.predecessor().replaceFirstSuccessor(ifNode2, newIfNode);
 672                             ifNode2.safeDelete();
 673                             return true;
 674                         }
 675                     }
 676                 }
<a name="20" id="anc20"></a><span class="line-added"> 677             } else if (y instanceof PrimitiveConstant &amp;&amp; ((PrimitiveConstant) y).asLong() &lt; 0 &amp;&amp; falseSuccessor().next() instanceof IfNode) {</span>
<span class="line-added"> 678                 IfNode ifNode2 = (IfNode) falseSuccessor().next();</span>
<span class="line-added"> 679                 AbstractBeginNode falseSucc = ifNode2.falseSuccessor();</span>
<span class="line-added"> 680                 AbstractBeginNode trueSucc = ifNode2.trueSuccessor();</span>
<span class="line-added"> 681                 IntegerBelowNode below = null;</span>
<span class="line-added"> 682                 if (ifNode2.condition() instanceof IntegerLessThanNode) {</span>
<span class="line-added"> 683                     ValueNode x = lessThan.getX();</span>
<span class="line-added"> 684                     IntegerLessThanNode lessThan2 = (IntegerLessThanNode) ifNode2.condition();</span>
<span class="line-added"> 685                     /*</span>
<span class="line-added"> 686                      * Convert x &gt;= -C1 &amp;&amp; x &lt; C2, represented as !(x &lt; -C1) &amp;&amp; x &lt; C2, into an</span>
<span class="line-added"> 687                      * unsigned compare. This condition is equivalent to x + C1 |&lt;| C1 + C2 if C1 +</span>
<span class="line-added"> 688                      * C2 does not overflow.</span>
<span class="line-added"> 689                      */</span>
<span class="line-added"> 690                     Constant c2 = lessThan2.getY().stamp(view).asConstant();</span>
<span class="line-added"> 691                     if (lessThan2.getX() == x &amp;&amp; c2 instanceof PrimitiveConstant &amp;&amp; ((PrimitiveConstant) c2).asLong() &gt; 0 &amp;&amp;</span>
<span class="line-added"> 692                                     x.stamp(view).isCompatible(lessThan.getY().stamp(view)) &amp;&amp;</span>
<span class="line-added"> 693                                     x.stamp(view).isCompatible(lessThan2.getY().stamp(view)) &amp;&amp;</span>
<span class="line-added"> 694                                     sameDestination(trueSuccessor(), ifNode2.falseSuccessor)) {</span>
<span class="line-added"> 695                         long newLimitValue = -((PrimitiveConstant) y).asLong() + ((PrimitiveConstant) c2).asLong();</span>
<span class="line-added"> 696                         // Make sure the limit fits into the target type without overflow.</span>
<span class="line-added"> 697                         if (newLimitValue &gt; 0 &amp;&amp; newLimitValue &lt;= CodeUtil.maxValue(PrimitiveStamp.getBits(x.stamp(view)))) {</span>
<span class="line-added"> 698                             ConstantNode newLimit = ConstantNode.forIntegerStamp(x.stamp(view), newLimitValue, graph());</span>
<span class="line-added"> 699                             ConstantNode c1 = ConstantNode.forIntegerStamp(x.stamp(view), -((PrimitiveConstant) y).asLong(), graph());</span>
<span class="line-added"> 700                             ValueNode addNode = graph().addOrUniqueWithInputs(AddNode.create(x, c1, view));</span>
<span class="line-added"> 701                             below = graph().unique(new IntegerBelowNode(addNode, newLimit));</span>
<span class="line-added"> 702                         }</span>
<span class="line-added"> 703                     }</span>
<span class="line-added"> 704                 }</span>
<span class="line-added"> 705                 if (below != null) {</span>
<span class="line-added"> 706                     try (DebugCloseable position = ifNode2.withNodeSourcePosition()) {</span>
<span class="line-added"> 707                         ifNode2.setTrueSuccessor(null);</span>
<span class="line-added"> 708                         ifNode2.setFalseSuccessor(null);</span>
<span class="line-added"> 709 </span>
<span class="line-added"> 710                         IfNode newIfNode = graph().add(new IfNode(below, trueSucc, falseSucc, trueSuccessorProbability));</span>
<span class="line-added"> 711                         // Remove the &lt; -C1 test.</span>
<span class="line-added"> 712                         tool.deleteBranch(trueSuccessor);</span>
<span class="line-added"> 713                         graph().removeSplit(this, falseSuccessor);</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715                         // Replace the second test with the new one.</span>
<span class="line-added"> 716                         ifNode2.predecessor().replaceFirstSuccessor(ifNode2, newIfNode);</span>
<span class="line-added"> 717                         ifNode2.safeDelete();</span>
<span class="line-added"> 718                         return true;</span>
<span class="line-added"> 719                     }</span>
<span class="line-added"> 720                 }</span>
 721             }
 722         }
 723         return false;
 724     }
 725 
 726     /**
 727      * Check it these two blocks end up at the same place. Meeting at the same merge, or
 728      * deoptimizing in the same way.
 729      */
 730     private static boolean sameDestination(AbstractBeginNode succ1, AbstractBeginNode succ2) {
 731         Node next1 = succ1.next();
 732         Node next2 = succ2.next();
 733         if (next1 instanceof EndNode &amp;&amp; next2 instanceof EndNode) {
 734             EndNode end1 = (EndNode) next1;
 735             EndNode end2 = (EndNode) next2;
 736             if (end1.merge() == end2.merge()) {
 737                 for (PhiNode phi : end1.merge().phis()) {
 738                     if (phi.valueAt(end1) != phi.valueAt(end2)) {
 739                         return false;
 740                     }
 741                 }
 742                 // They go to the same MergeNode and merge the same values
 743                 return true;
 744             }
 745         } else if (next1 instanceof DeoptimizeNode &amp;&amp; next2 instanceof DeoptimizeNode) {
 746             DeoptimizeNode deopt1 = (DeoptimizeNode) next1;
 747             DeoptimizeNode deopt2 = (DeoptimizeNode) next2;
 748             if (deopt1.getReason() == deopt2.getReason() &amp;&amp; deopt1.getAction() == deopt2.getAction()) {
 749                 // Same deoptimization reason and action.
 750                 return true;
 751             }
 752         } else if (next1 instanceof LoopExitNode &amp;&amp; next2 instanceof LoopExitNode) {
 753             LoopExitNode exit1 = (LoopExitNode) next1;
 754             LoopExitNode exit2 = (LoopExitNode) next2;
 755             if (exit1.loopBegin() == exit2.loopBegin() &amp;&amp; exit1.stateAfter() == exit2.stateAfter() &amp;&amp; exit1.stateAfter() == null &amp;&amp; sameDestination(exit1, exit2)) {
 756                 // Exit the same loop and end up at the same place.
 757                 return true;
 758             }
 759         } else if (next1 instanceof ReturnNode &amp;&amp; next2 instanceof ReturnNode) {
 760             ReturnNode exit1 = (ReturnNode) next1;
 761             ReturnNode exit2 = (ReturnNode) next2;
 762             if (exit1.result() == exit2.result()) {
 763                 // Exit the same loop and end up at the same place.
 764                 return true;
 765             }
 766         }
 767         return false;
 768     }
 769 
 770     private static boolean prepareForSwap(SimplifierTool tool, LogicNode a, LogicNode b) {
 771         DebugContext debug = a.getDebug();
 772         if (a instanceof InstanceOfNode) {
 773             InstanceOfNode instanceOfA = (InstanceOfNode) a;
 774             if (b instanceof IsNullNode) {
 775                 IsNullNode isNullNode = (IsNullNode) b;
 776                 if (isNullNode.getValue() == instanceOfA.getValue()) {
 777                     debug.log(&quot;Can swap instanceof and isnull if&quot;);
 778                     return true;
 779                 }
 780             } else if (b instanceof InstanceOfNode) {
 781                 InstanceOfNode instanceOfB = (InstanceOfNode) b;
 782                 if (instanceOfA.getValue() == instanceOfB.getValue() &amp;&amp; !instanceOfA.type().getType().isInterface() &amp;&amp; !instanceOfB.type().getType().isInterface() &amp;&amp;
 783                                 !instanceOfA.type().getType().isAssignableFrom(instanceOfB.type().getType()) &amp;&amp; !instanceOfB.type().getType().isAssignableFrom(instanceOfA.type().getType())) {
 784                     // Two instanceof on the same value with mutually exclusive types.
 785                     debug.log(&quot;Can swap instanceof for types %s and %s&quot;, instanceOfA.type(), instanceOfB.type());
 786                     return true;
 787                 }
 788             }
 789         } else if (a instanceof CompareNode) {
 790             CompareNode compareA = (CompareNode) a;
 791             Condition conditionA = compareA.condition().asCondition();
 792             if (compareA.unorderedIsTrue()) {
 793                 return false;
 794             }
 795             if (b instanceof CompareNode) {
 796                 CompareNode compareB = (CompareNode) b;
 797                 if (compareA == compareB) {
 798                     debug.log(&quot;Same conditions =&gt; do not swap and leave the work for global value numbering.&quot;);
 799                     return false;
 800                 }
 801                 if (compareB.unorderedIsTrue()) {
 802                     return false;
 803                 }
 804                 Condition comparableCondition = null;
 805                 Condition conditionB = compareB.condition().asCondition();
 806                 if (compareB.getX() == compareA.getX() &amp;&amp; compareB.getY() == compareA.getY()) {
 807                     comparableCondition = conditionB;
 808                 } else if (compareB.getX() == compareA.getY() &amp;&amp; compareB.getY() == compareA.getX()) {
 809                     comparableCondition = conditionB.mirror();
 810                 }
 811 
 812                 if (comparableCondition != null) {
 813                     Condition combined = conditionA.join(comparableCondition);
 814                     if (combined == null) {
 815                         // The two conditions are disjoint =&gt; can reorder.
 816                         debug.log(&quot;Can swap disjoint coditions on same values: %s and %s&quot;, conditionA, comparableCondition);
 817                         return true;
 818                     }
 819                 } else if (conditionA == Condition.EQ &amp;&amp; conditionB == Condition.EQ) {
 820                     boolean canSwap = false;
 821                     if ((compareA.getX() == compareB.getX() &amp;&amp; valuesDistinct(tool, compareA.getY(), compareB.getY()))) {
 822                         canSwap = true;
 823                     } else if ((compareA.getX() == compareB.getY() &amp;&amp; valuesDistinct(tool, compareA.getY(), compareB.getX()))) {
 824                         canSwap = true;
 825                     } else if ((compareA.getY() == compareB.getX() &amp;&amp; valuesDistinct(tool, compareA.getX(), compareB.getY()))) {
 826                         canSwap = true;
 827                     } else if ((compareA.getY() == compareB.getY() &amp;&amp; valuesDistinct(tool, compareA.getX(), compareB.getX()))) {
 828                         canSwap = true;
 829                     }
 830 
 831                     if (canSwap) {
 832                         debug.log(&quot;Can swap equality condition with one shared and one disjoint value.&quot;);
 833                         return true;
 834                     }
 835                 }
 836             }
 837         }
 838 
 839         return false;
 840     }
 841 
 842     private static boolean valuesDistinct(SimplifierTool tool, ValueNode a, ValueNode b) {
 843         if (a.isConstant() &amp;&amp; b.isConstant()) {
 844             Boolean equal = tool.getConstantReflection().constantEquals(a.asConstant(), b.asConstant());
 845             if (equal != null) {
 846                 return !equal.booleanValue();
 847             }
 848         }
 849 
 850         NodeView view = NodeView.from(tool);
 851         Stamp stampA = a.stamp(view);
 852         Stamp stampB = b.stamp(view);
 853         return stampA.alwaysDistinct(stampB);
 854     }
 855 
 856     /**
 857      * Tries to remove an empty if construct or replace an if construct with a materialization.
 858      *
 859      * @return true if a transformation was made, false otherwise
 860      */
 861     private boolean removeOrMaterializeIf(SimplifierTool tool) {
 862         assert trueSuccessor().hasNoUsages() &amp;&amp; falseSuccessor().hasNoUsages();
 863         if (trueSuccessor().next() instanceof AbstractEndNode &amp;&amp; falseSuccessor().next() instanceof AbstractEndNode) {
 864             AbstractEndNode trueEnd = (AbstractEndNode) trueSuccessor().next();
 865             AbstractEndNode falseEnd = (AbstractEndNode) falseSuccessor().next();
 866             AbstractMergeNode merge = trueEnd.merge();
 867             if (merge == falseEnd.merge() &amp;&amp; trueSuccessor().anchored().isEmpty() &amp;&amp; falseSuccessor().anchored().isEmpty()) {
 868                 PhiNode singlePhi = null;
 869                 int distinct = 0;
 870                 for (PhiNode phi : merge.phis()) {
 871                     ValueNode trueValue = phi.valueAt(trueEnd);
 872                     ValueNode falseValue = phi.valueAt(falseEnd);
 873                     if (trueValue != falseValue) {
 874                         distinct++;
 875                         singlePhi = phi;
 876                     }
 877                 }
 878                 if (distinct == 0) {
 879                     /*
 880                      * Multiple phis but merging same values for true and false, so simply delete
 881                      * the path
 882                      */
 883                     removeThroughFalseBranch(tool, merge);
 884                     return true;
 885                 } else if (distinct == 1) {
<a name="21" id="anc21"></a><span class="line-added"> 886                     // Fortify: Suppress Null Dereference false positive</span>
<span class="line-added"> 887                     assert singlePhi != null;</span>
<span class="line-added"> 888 </span>
 889                     ValueNode trueValue = singlePhi.valueAt(trueEnd);
 890                     ValueNode falseValue = singlePhi.valueAt(falseEnd);
 891                     ValueNode conditional = canonicalizeConditionalCascade(tool, trueValue, falseValue);
 892                     if (conditional != null) {
 893                         conditional = proxyReplacement(conditional);
 894                         singlePhi.setValueAt(trueEnd, conditional);
 895                         removeThroughFalseBranch(tool, merge);
 896                         return true;
 897                     }
 898                 }
 899             }
 900         }
 901         if (trueSuccessor().next() instanceof ReturnNode &amp;&amp; falseSuccessor().next() instanceof ReturnNode) {
 902             ReturnNode trueEnd = (ReturnNode) trueSuccessor().next();
 903             ReturnNode falseEnd = (ReturnNode) falseSuccessor().next();
 904             ValueNode trueValue = trueEnd.result();
 905             ValueNode falseValue = falseEnd.result();
 906             ValueNode value = null;
<a name="22" id="anc22"></a><span class="line-added"> 907             boolean needsProxy = false;</span>
 908             if (trueValue != null) {
 909                 if (trueValue == falseValue) {
 910                     value = trueValue;
 911                 } else {
 912                     value = canonicalizeConditionalCascade(tool, trueValue, falseValue);
 913                     if (value == null) {
 914                         return false;
 915                     }
<a name="23" id="anc23"></a><span class="line-added"> 916                     needsProxy = true;</span>
 917                 }
 918             }
<a name="24" id="anc24"></a><span class="line-added"> 919 </span>
<span class="line-added"> 920             if (trueSuccessor() instanceof LoopExitNode) {</span>
<span class="line-added"> 921                 LoopBeginNode loopBegin = ((LoopExitNode) trueSuccessor()).loopBegin();</span>
<span class="line-added"> 922                 assert loopBegin == ((LoopExitNode) falseSuccessor()).loopBegin();</span>
<span class="line-added"> 923                 LoopExitNode loopExitNode = graph().add(new LoopExitNode(loopBegin));</span>
<span class="line-added"> 924                 graph().addBeforeFixed(this, loopExitNode);</span>
<span class="line-added"> 925                 if (graph().hasValueProxies() &amp;&amp; needsProxy) {</span>
<span class="line-added"> 926                     value = graph().addOrUnique(new ValueProxyNode(value, loopExitNode));</span>
<span class="line-added"> 927                 }</span>
<span class="line-added"> 928             }</span>
<span class="line-added"> 929 </span>
 930             ReturnNode newReturn = graph().add(new ReturnNode(value));
 931             replaceAtPredecessor(newReturn);
 932             GraphUtil.killCFG(this);
 933             return true;
 934         }
 935         return false;
 936     }
 937 
 938     private ValueNode proxyReplacement(ValueNode replacement) {
 939         /*
 940          * Special case: Every empty diamond we collapse to a conditional node can potentially
 941          * contain loop exit nodes on both branches. See the graph below: The two loop exits
 942          * (instanceof begin node) exit the same loop. The resulting phi is defined outside the
 943          * loop, but the resulting conditional node will be inside the loop, so we need to proxy the
 944          * resulting conditional node. Callers of this method ensure that true and false successor
 945          * have no usages, therefore a and b in the graph below can never be proxies themselves.
 946          */
 947         // @formatter:off
 948         //              +--+
 949         //              |If|
 950         //              +--+      +-----+ +-----+
 951         //         +----+  +----+ |  a  | |  b  |
 952         //         |Lex |  |Lex | +----^+ +^----+
 953         //         +----+  +----+      |   |
 954         //           +-------+         +---+
 955         //           | Merge +---------+Phi|
 956         //           +-------+         +---+
 957         // @formatter:on
 958         if (this.graph().hasValueProxies()) {
 959             if (trueSuccessor instanceof LoopExitNode &amp;&amp; falseSuccessor instanceof LoopExitNode) {
 960                 assert ((LoopExitNode) trueSuccessor).loopBegin() == ((LoopExitNode) falseSuccessor).loopBegin();
 961                 /*
 962                  * we can collapse all proxy nodes on one loop exit, the surviving one, which will
 963                  * be the true successor
 964                  */
<a name="25" id="anc25"></a><span class="line-modified"> 965                 if (falseSuccessor.anchored().isEmpty() &amp;&amp; falseSuccessor.hasUsages()) {</span>
 966                     for (Node n : falseSuccessor.usages().snapshot()) {
 967                         assert n instanceof ProxyNode;
 968                         ((ProxyNode) n).setProxyPoint((LoopExitNode) trueSuccessor);
 969                     }
 970                 }
 971                 /*
 972                  * The true successor (surviving loop exit) can have usages, namely proxy nodes, the
 973                  * false successor however, must not have usages any more after the code above
 974                  */
<a name="26" id="anc26"></a><span class="line-modified"> 975                 assert trueSuccessor.anchored().isEmpty() &amp;&amp; falseSuccessor.hasNoUsages();</span>
 976                 return this.graph().addOrUnique(new ValueProxyNode(replacement, (LoopExitNode) trueSuccessor));
 977             }
 978         }
 979         return replacement;
 980     }
 981 
 982     protected void removeThroughFalseBranch(SimplifierTool tool, AbstractMergeNode merge) {
 983         AbstractBeginNode trueBegin = trueSuccessor();
 984         LogicNode conditionNode = condition();
 985         graph().removeSplitPropagate(this, trueBegin);
 986         tool.addToWorkList(trueBegin);
 987         if (conditionNode != null) {
 988             GraphUtil.tryKillUnused(conditionNode);
 989         }
 990         if (merge.isAlive() &amp;&amp; merge.forwardEndCount() &gt; 1) {
 991             for (FixedNode end : merge.forwardEnds()) {
 992                 Node cur = end;
 993                 while (cur != null &amp;&amp; cur.predecessor() instanceof BeginNode) {
 994                     cur = cur.predecessor();
 995                 }
 996                 if (cur != null &amp;&amp; cur.predecessor() instanceof IfNode) {
 997                     tool.addToWorkList(cur.predecessor());
 998                 }
 999             }
1000         }
1001     }
1002 
1003     private ValueNode canonicalizeConditionalViaImplies(ValueNode trueValue, ValueNode falseValue) {
1004         ValueNode collapsedTrue = trueValue;
1005         ValueNode collapsedFalse = falseValue;
1006         boolean simplify = false;
1007         if (trueValue instanceof ConditionalNode) {
1008             TriState result = condition().implies(false, ((ConditionalNode) trueValue).condition());
1009             if (result.isKnown()) {
1010                 simplify = true;
1011                 collapsedTrue = result.toBoolean() ? ((ConditionalNode) trueValue).trueValue() : ((ConditionalNode) trueValue).falseValue();
1012             }
1013         }
1014         if (falseValue instanceof ConditionalNode) {
1015             TriState result = condition().implies(true, ((ConditionalNode) falseValue).condition());
1016             if (result.isKnown()) {
1017                 simplify = true;
1018                 collapsedFalse = result.toBoolean() ? ((ConditionalNode) falseValue).trueValue() : ((ConditionalNode) falseValue).falseValue();
1019             }
1020         }
1021         if (simplify) {
1022             return graph().unique(new ConditionalNode(condition(), collapsedTrue, collapsedFalse));
1023         }
1024         return null;
1025     }
1026 
1027     private ValueNode canonicalizeConditionalCascade(SimplifierTool tool, ValueNode trueValue, ValueNode falseValue) {
1028         if (trueValue.getStackKind() != falseValue.getStackKind()) {
1029             return null;
1030         }
1031         if (trueValue.getStackKind() != JavaKind.Int &amp;&amp; trueValue.getStackKind() != JavaKind.Long) {
1032             return null;
1033         }
1034         if (trueValue.isConstant() &amp;&amp; falseValue.isConstant()) {
1035             return graph().unique(new ConditionalNode(condition(), trueValue, falseValue));
1036         }
1037         ValueNode value = canonicalizeConditionalViaImplies(trueValue, falseValue);
1038         if (value != null) {
1039             return value;
1040         }
1041         if (!graph().isAfterExpandLogic()) {
1042             /*
1043              * !isAfterExpandLogic() =&gt; Cannot spawn NormalizeCompareNodes after lowering in the
1044              * ExpandLogicPhase.
1045              */
1046             ConditionalNode conditional = null;
1047             ValueNode constant = null;
1048             boolean negateCondition;
1049             if (trueValue instanceof ConditionalNode &amp;&amp; falseValue.isConstant()) {
1050                 conditional = (ConditionalNode) trueValue;
1051                 constant = falseValue;
1052                 negateCondition = true;
1053             } else if (falseValue instanceof ConditionalNode &amp;&amp; trueValue.isConstant()) {
1054                 conditional = (ConditionalNode) falseValue;
1055                 constant = trueValue;
1056                 negateCondition = false;
1057             } else {
1058                 return null;
1059             }
1060             boolean negateConditionalCondition = false;
1061             ValueNode otherValue = null;
1062             if (constant == conditional.trueValue()) {
1063                 otherValue = conditional.falseValue();
1064                 negateConditionalCondition = false;
1065             } else if (constant == conditional.falseValue()) {
1066                 otherValue = conditional.trueValue();
1067                 negateConditionalCondition = true;
1068             }
1069             if (otherValue != null &amp;&amp; otherValue.isConstant()) {
1070                 double shortCutProbability = probability(trueSuccessor());
1071                 LogicNode newCondition = LogicNode.or(condition(), negateCondition, conditional.condition(), negateConditionalCondition, shortCutProbability);
1072                 return graph().unique(new ConditionalNode(newCondition, constant, otherValue));
1073             }
1074 
1075             if (constant.isJavaConstant() &amp;&amp; conditional.trueValue().isJavaConstant() &amp;&amp; conditional.falseValue().isJavaConstant() &amp;&amp; condition() instanceof CompareNode &amp;&amp;
1076                             conditional.condition() instanceof CompareNode) {
1077 
<a name="27" id="anc27"></a><span class="line-modified">1078                 CompareNode condition1 = (CompareNode) condition();</span>
<span class="line-added">1079                 Condition cond1 = condition1.condition().asCondition();</span>
1080                 if (negateCondition) {
1081                     cond1 = cond1.negate();
1082                 }
1083                 // cond1 is EQ, NE, LT, or GE
<a name="28" id="anc28"></a><span class="line-modified">1084                 CompareNode condition2 = (CompareNode) conditional.condition();</span>
<span class="line-modified">1085                 Condition cond2 = condition2.condition().asCondition();</span>
<span class="line-modified">1086                 ValueNode x = condition1.getX();</span>
<span class="line-modified">1087                 ValueNode y = condition1.getY();</span>
<span class="line-modified">1088                 ValueNode x2 = condition2.getX();</span>
<span class="line-added">1089                 ValueNode y2 = condition2.getY();</span>
1090                 // `x cond1 y ? c1 : (x2 cond2 y2 ? c2 : c3)`
1091                 boolean sameVars = x == x2 &amp;&amp; y == y2;
1092                 if (!sameVars &amp;&amp; x == y2 &amp;&amp; y == x2) {
1093                     sameVars = true;
1094                     cond2 = cond2.mirror();
1095                 }
1096                 if (sameVars) {
<a name="29" id="anc29"></a><span class="line-added">1097 </span>
1098                     JavaKind stackKind = conditional.trueValue().stamp(NodeView.from(tool)).getStackKind();
1099                     assert !stackKind.isNumericFloat();
1100 
<a name="30" id="anc30"></a><span class="line-modified">1101                     long c1 = constant.asJavaConstant().asLong();</span>
<span class="line-modified">1102                     long c2 = conditional.trueValue().asJavaConstant().asLong();</span>
<span class="line-modified">1103                     long c3 = conditional.falseValue().asJavaConstant().asLong();</span>



































1104 
<a name="31" id="anc31"></a><span class="line-modified">1105                     // canonicalize cond2</span>
<span class="line-modified">1106                     cond2 = cond2.join(cond1.negate());</span>
<span class="line-modified">1107                     if (cond2 == null) {</span>
<span class="line-modified">1108                         // mixing signed and unsigned cases, or useless combination of conditions</span>
<span class="line-modified">1109                         return null;</span>




























































1110                     }
<a name="32" id="anc32"></a><span class="line-modified">1111                     // derive cond3 from cond1 and cond2</span>
<span class="line-modified">1112                     Condition cond3 = cond1.negate().join(cond2.negate());</span>
<span class="line-modified">1113                     if (cond3 == null) {</span>
<span class="line-modified">1114                         // mixing signed and unsigned cases, or useless combination of conditions</span>
<span class="line-added">1115                         return null;</span>
1116                     }
<a name="33" id="anc33"></a><span class="line-modified">1117                     boolean unsigned = cond1.isUnsigned() || cond2.isUnsigned();</span>
<span class="line-modified">1118                     boolean floatingPoint = x.stamp(NodeView.from(tool)) instanceof FloatStamp;</span>
<span class="line-modified">1119                     assert !floatingPoint || y.stamp(NodeView.from(tool)) instanceof FloatStamp;</span>
<span class="line-modified">1120                     assert !(floatingPoint &amp;&amp; unsigned);</span>
<span class="line-modified">1121 </span>
<span class="line-modified">1122                     long expected1 = expectedConstantForNormalize(cond1);</span>
<span class="line-modified">1123                     long expected2 = expectedConstantForNormalize(cond2);</span>
<span class="line-modified">1124                     long expected3 = expectedConstantForNormalize(cond3);</span>
<span class="line-modified">1125 </span>
<span class="line-modified">1126                     if (c1 == expected1 &amp;&amp; c2 == expected2 &amp;&amp; c3 == expected3) {</span>
<span class="line-modified">1127                         // normal order</span>
<span class="line-modified">1128                     } else if (c1 == 0 - expected1 &amp;&amp; c2 == 0 - expected2 &amp;&amp; c3 == 0 - expected3) {</span>
<span class="line-modified">1129                         // reverse order</span>
<span class="line-modified">1130                         ValueNode tmp = x;</span>
<span class="line-modified">1131                         x = y;</span>
<span class="line-modified">1132                         y = tmp;</span>
<span class="line-modified">1133                     } else {</span>
<span class="line-modified">1134                         // cannot be expressed by NormalizeCompareNode</span>
<span class="line-modified">1135                         return null;</span>
<span class="line-modified">1136                     }</span>
<span class="line-modified">1137                     if (floatingPoint) {</span>
<span class="line-modified">1138                         boolean unorderedLess = false;</span>
<span class="line-modified">1139                         if (((FloatStamp) x.stamp).canBeNaN() || ((FloatStamp) y.stamp).canBeNaN()) {</span>
<span class="line-modified">1140                             // we may encounter NaNs, check the unordered value</span>
<span class="line-modified">1141                             // (following the original condition&#39;s &quot;unorderedIsTrue&quot; path)</span>
<span class="line-modified">1142                             long unorderedValue = condition1.unorderedIsTrue() ? c1 : condition2.unorderedIsTrue() ? c2 : c3;</span>
<span class="line-modified">1143                             if (unorderedValue == 0) {</span>
<span class="line-modified">1144                                 // returning &quot;0&quot; for unordered is not possible</span>
<span class="line-modified">1145                                 return null;</span>
<span class="line-modified">1146                             }</span>
<span class="line-modified">1147                             unorderedLess = unorderedValue == -1;</span>
<span class="line-modified">1148                         }</span>
<span class="line-modified">1149                         return graph().unique(new FloatNormalizeCompareNode(x, y, stackKind, unorderedLess));</span>
<span class="line-modified">1150                     } else {</span>
<span class="line-modified">1151                         return graph().unique(new IntegerNormalizeCompareNode(x, y, stackKind, unsigned));</span>





























































1152                     }
<a name="34" id="anc34"></a>





1153                 }
<a name="35" id="anc35"></a>

























1154             }
1155         }
<a name="36" id="anc36"></a><span class="line-added">1156         return null;</span>
1157     }
1158 
<a name="37" id="anc37"></a><span class="line-modified">1159     private static long expectedConstantForNormalize(Condition condition) {</span>
<span class="line-modified">1160         if (condition == Condition.EQ) {</span>
<span class="line-modified">1161             return 0;</span>
<span class="line-modified">1162         } else if (condition == Condition.LT || condition == Condition.BT) {</span>
<span class="line-modified">1163             return -1;</span>
<span class="line-modified">1164         } else {</span>
<span class="line-modified">1165             assert condition == Condition.GT || condition == Condition.AT;</span>
<span class="line-added">1166             return 1;</span>
1167         }
1168     }
1169 
<a name="38" id="anc38"></a><span class="line-modified">1170     public enum NodeColor {</span>
<span class="line-modified">1171         NONE,</span>
<span class="line-modified">1172         CONDITION_USAGE,</span>
<span class="line-modified">1173         TRUE_BRANCH,</span>
<span class="line-modified">1174         FALSE_BRANCH,</span>
<span class="line-modified">1175         PHI_MIXED,</span>
<span class="line-modified">1176         MIXED</span>



















1177     }
1178 
1179     /**
1180      * Tries to connect code that initializes a variable directly with the successors of an if
1181      * construct that switches on the variable. For example, the pseudo code below:
1182      *
1183      * &lt;pre&gt;
1184      * contains(list, e, yes, no) {
1185      *     if (list == null || e == null) {
1186      *         condition = false;
1187      *     } else {
1188      *         condition = false;
1189      *         for (i in list) {
1190      *             if (i.equals(e)) {
1191      *                 condition = true;
1192      *                 break;
1193      *             }
1194      *         }
1195      *     }
1196      *     if (condition) {
1197      *         return yes;
1198      *     } else {
1199      *         return no;
1200      *     }
1201      * }
1202      * &lt;/pre&gt;
1203      *
1204      * will be transformed into:
1205      *
1206      * &lt;pre&gt;
1207      * contains(list, e, yes, no) {
1208      *     if (list == null || e == null) {
1209      *         return no;
1210      *     } else {
1211      *         condition = false;
1212      *         for (i in list) {
1213      *             if (i.equals(e)) {
1214      *                 return yes;
1215      *             }
1216      *         }
1217      *         return no;
1218      *     }
1219      * }
1220      * &lt;/pre&gt;
1221      *
1222      * @return true if a transformation was made, false otherwise
1223      */
1224     private boolean removeIntermediateMaterialization(SimplifierTool tool) {
1225         if (!(predecessor() instanceof AbstractMergeNode) || predecessor() instanceof LoopBeginNode) {
1226             return false;
1227         }
1228         AbstractMergeNode merge = (AbstractMergeNode) predecessor();
1229 
1230         if (!(condition() instanceof CompareNode)) {
1231             return false;
1232         }
1233 
1234         CompareNode compare = (CompareNode) condition();
1235         if (compare.getUsageCount() != 1) {
1236             return false;
1237         }
1238 
1239         // Only consider merges with a single usage that is both a phi and an operand of the
1240         // comparison
1241         NodeIterable&lt;Node&gt; mergeUsages = merge.usages();
1242         if (mergeUsages.count() != 1) {
1243             return false;
1244         }
1245         Node singleUsage = mergeUsages.first();
1246         if (!(singleUsage instanceof ValuePhiNode) || (singleUsage != compare.getX() &amp;&amp; singleUsage != compare.getY())) {
1247             return false;
1248         }
1249 
<a name="39" id="anc39"></a><span class="line-added">1250         if (trueSuccessor().isUsedAsGuardInput() || falseSuccessor().isUsedAsGuardInput()) {</span>
<span class="line-added">1251             return false;</span>
<span class="line-added">1252         }</span>
<span class="line-added">1253 </span>
1254         // Ensure phi is used by at most the comparison and the merge&#39;s frame state (if any)
1255         ValuePhiNode phi = (ValuePhiNode) singleUsage;
1256         NodeIterable&lt;Node&gt; phiUsages = phi.usages();
<a name="40" id="anc40"></a>


1257         for (Node usage : phiUsages) {
<a name="41" id="anc41"></a><span class="line-modified">1258             if (usage == compare) {</span>
<span class="line-modified">1259                 continue;</span>
<span class="line-added">1260             }</span>
<span class="line-added">1261             if (usage == merge.stateAfter()) {</span>
<span class="line-added">1262                 continue;</span>
<span class="line-added">1263             }</span>
<span class="line-added">1264             // Checkstyle: stop</span>
<span class="line-added">1265             // @formatter:off</span>
<span class="line-added">1266             //</span>
<span class="line-added">1267             // We also want to allow the usage to be on the loop-proxy if one of the branches is a</span>
<span class="line-added">1268             // loop exit.</span>
<span class="line-added">1269             //</span>
<span class="line-added">1270             // This pattern:</span>
<span class="line-added">1271             //</span>
<span class="line-added">1272             //      if-------&gt;cond</span>
<span class="line-added">1273             //     /  \</span>
<span class="line-added">1274             // begin  begin</span>
<span class="line-added">1275             //   |      |</span>
<span class="line-added">1276             //  end    end        C1 V2</span>
<span class="line-added">1277             //     \  /            \ /</span>
<span class="line-added">1278             //     merge----------&gt;phi&lt;------    C1</span>
<span class="line-added">1279             //       |              ^        \  /</span>
<span class="line-added">1280             //       if-------------|--------&gt;==</span>
<span class="line-added">1281             //      /  \            |</span>
<span class="line-added">1282             //     A    B&lt;--------Proxy</span>
<span class="line-added">1283             //</span>
<span class="line-added">1284             // Must be simplified to:</span>
<span class="line-added">1285             //</span>
<span class="line-added">1286             //       if----------------------&gt;cond</span>
<span class="line-added">1287             //      /  \</span>
<span class="line-added">1288             //     A    B&lt;--------Proxy------&gt;V2</span>
<span class="line-added">1289             //</span>
<span class="line-added">1290             // @formatter:on</span>
<span class="line-added">1291             // Checkstyle: resume</span>
<span class="line-added">1292             if (usage instanceof ValueProxyNode) {</span>
<span class="line-added">1293                 ValueProxyNode proxy = (ValueProxyNode) usage;</span>
<span class="line-added">1294                 if (proxy.proxyPoint() == trueSuccessor || proxy.proxyPoint() == falseSuccessor) {</span>
<span class="line-added">1295                     continue;</span>
<span class="line-added">1296                 }</span>
1297             }
<a name="42" id="anc42"></a><span class="line-added">1298             return false;</span>
1299         }
1300 
1301         List&lt;EndNode&gt; mergePredecessors = merge.cfgPredecessors().snapshot();
1302         assert phi.valueCount() == merge.forwardEndCount();
1303 
1304         Constant[] xs = constantValues(compare.getX(), merge, false);
1305         Constant[] ys = constantValues(compare.getY(), merge, false);
1306         if (xs == null || ys == null) {
1307             return false;
1308         }
1309 
<a name="43" id="anc43"></a><span class="line-modified">1310         if (merge.stateAfter() != null &amp;&amp; !GraphUtil.mayRemoveSplit(this)) {</span>

1311             return false;
1312         }
1313 
1314         List&lt;EndNode&gt; falseEnds = new ArrayList&lt;&gt;(mergePredecessors.size());
1315         List&lt;EndNode&gt; trueEnds = new ArrayList&lt;&gt;(mergePredecessors.size());
1316         EconomicMap&lt;AbstractEndNode, ValueNode&gt; phiValues = EconomicMap.create(Equivalence.IDENTITY, mergePredecessors.size());
1317 
1318         AbstractBeginNode oldFalseSuccessor = falseSuccessor();
1319         AbstractBeginNode oldTrueSuccessor = trueSuccessor();
1320 
1321         setFalseSuccessor(null);
1322         setTrueSuccessor(null);
1323 
1324         Iterator&lt;EndNode&gt; ends = mergePredecessors.iterator();
1325         for (int i = 0; i &lt; xs.length; i++) {
1326             EndNode end = ends.next();
1327             phiValues.put(end, phi.valueAt(end));
1328             if (compare.condition().foldCondition(xs[i], ys[i], tool.getConstantReflection(), compare.unorderedIsTrue())) {
1329                 trueEnds.add(end);
1330             } else {
1331                 falseEnds.add(end);
1332             }
1333         }
1334         assert !ends.hasNext();
1335         assert falseEnds.size() + trueEnds.size() == xs.length;
1336 
<a name="44" id="anc44"></a><span class="line-modified">1337         connectEnds(falseEnds, phi, phiValues, oldFalseSuccessor, merge, tool);</span>
<span class="line-modified">1338         connectEnds(trueEnds, phi, phiValues, oldTrueSuccessor, merge, tool);</span>
1339 
1340         if (this.trueSuccessorProbability == 0.0) {
1341             for (AbstractEndNode endNode : trueEnds) {
1342                 propagateZeroProbability(endNode);
1343             }
1344         }
1345 
1346         if (this.trueSuccessorProbability == 1.0) {
1347             for (AbstractEndNode endNode : falseEnds) {
1348                 propagateZeroProbability(endNode);
1349             }
1350         }
1351 
1352         /*
1353          * Remove obsolete ends only after processing all ends, otherwise oldTrueSuccessor or
1354          * oldFalseSuccessor might have been removed if it is a LoopExitNode.
1355          */
1356         if (falseEnds.isEmpty()) {
1357             GraphUtil.killCFG(oldFalseSuccessor);
1358         }
1359         if (trueEnds.isEmpty()) {
1360             GraphUtil.killCFG(oldTrueSuccessor);
1361         }
1362         GraphUtil.killCFG(merge);
1363 
1364         assert !merge.isAlive() : merge;
1365         assert !phi.isAlive() : phi;
1366         assert !compare.isAlive() : compare;
1367         assert !this.isAlive() : this;
1368 
1369         return true;
1370     }
1371 
<a name="45" id="anc45"></a><span class="line-modified">1372     private static void propagateZeroProbability(FixedNode startNode) {</span>
1373         Node prev = null;
1374         for (FixedNode node : GraphUtil.predecessorIterable(startNode)) {
1375             if (node instanceof IfNode) {
1376                 IfNode ifNode = (IfNode) node;
1377                 if (ifNode.trueSuccessor() == prev) {
1378                     if (ifNode.trueSuccessorProbability == 0.0) {
1379                         return;
1380                     } else if (ifNode.trueSuccessorProbability == 1.0) {
1381                         continue;
1382                     } else {
1383                         ifNode.setTrueSuccessorProbability(0.0);
1384                         return;
1385                     }
1386                 } else if (ifNode.falseSuccessor() == prev) {
1387                     if (ifNode.trueSuccessorProbability == 1.0) {
1388                         return;
1389                     } else if (ifNode.trueSuccessorProbability == 0.0) {
1390                         continue;
1391                     } else {
1392                         ifNode.setTrueSuccessorProbability(1.0);
1393                         return;
1394                     }
1395                 } else {
1396                     throw new GraalError(&quot;Illegal state&quot;);
1397                 }
1398             } else if (node instanceof AbstractMergeNode &amp;&amp; !(node instanceof LoopBeginNode)) {
1399                 for (AbstractEndNode endNode : ((AbstractMergeNode) node).cfgPredecessors()) {
1400                     propagateZeroProbability(endNode);
1401                 }
1402                 return;
1403             }
1404             prev = node;
1405         }
1406     }
1407 
<a name="46" id="anc46"></a>






































1408     /**
1409      * Connects a set of ends to a given successor, inserting a merge node if there is more than one
1410      * end. If {@code ends} is not empty, then {@code successor} is added to {@code tool}&#39;s
1411      * {@linkplain SimplifierTool#addToWorkList(org.graalvm.compiler.graph.Node) work list}.
1412      *
<a name="47" id="anc47"></a><span class="line-modified">1413      * @param phi the original single-usage phi of the preceding merge</span>
1414      * @param phiValues the values of the phi at the merge, keyed by the merge ends
<a name="48" id="anc48"></a><span class="line-added">1415      * @param oldMerge the merge being removed</span>
1416      */
<a name="49" id="anc49"></a><span class="line-modified">1417     private void connectEnds(List&lt;EndNode&gt; ends, ValuePhiNode phi, EconomicMap&lt;AbstractEndNode, ValueNode&gt; phiValues, AbstractBeginNode successor, AbstractMergeNode oldMerge, SimplifierTool tool) {</span>
1418         if (!ends.isEmpty()) {
<a name="50" id="anc50"></a><span class="line-added">1419             // If there was a value proxy usage, then the proxy needs a new value.</span>
<span class="line-added">1420             ValueProxyNode valueProxy = null;</span>
<span class="line-added">1421             if (successor instanceof LoopExitNode) {</span>
<span class="line-added">1422                 for (Node usage : phi.usages()) {</span>
<span class="line-added">1423                     if (usage instanceof ValueProxyNode &amp;&amp; ((ValueProxyNode) usage).proxyPoint() == successor) {</span>
<span class="line-added">1424                         valueProxy = (ValueProxyNode) usage;</span>
<span class="line-added">1425                     }</span>
<span class="line-added">1426                 }</span>
<span class="line-added">1427             }</span>
<span class="line-added">1428             final ValueProxyNode proxy = valueProxy;</span>
1429             if (ends.size() == 1) {
1430                 AbstractEndNode end = ends.get(0);
<a name="51" id="anc51"></a><span class="line-added">1431                 if (proxy != null) {</span>
<span class="line-added">1432                     phi.replaceAtUsages(phiValues.get(end), n -&gt; n == proxy);</span>
<span class="line-added">1433                 }</span>
1434                 ((FixedWithNextNode) end.predecessor()).setNext(successor);
1435                 oldMerge.removeEnd(end);
1436                 GraphUtil.killCFG(end);
1437             } else {
1438                 // Need a new phi in case the frame state is used by more than the merge being
1439                 // removed.
1440                 NodeView view = NodeView.from(tool);
1441                 AbstractMergeNode newMerge = graph().add(new MergeNode());
1442                 PhiNode oldPhi = (PhiNode) oldMerge.usages().first();
1443                 PhiNode newPhi = graph().addWithoutUnique(new ValuePhiNode(oldPhi.stamp(view), newMerge));
1444 
<a name="52" id="anc52"></a><span class="line-added">1445                 if (proxy != null) {</span>
<span class="line-added">1446                     phi.replaceAtUsages(newPhi, n -&gt; n == proxy);</span>
<span class="line-added">1447                 }</span>
<span class="line-added">1448 </span>
1449                 for (EndNode end : ends) {
1450                     newPhi.addInput(phiValues.get(end));
1451                     newMerge.addForwardEnd(end);
1452                 }
1453 
1454                 FrameState stateAfter = oldMerge.stateAfter();
1455                 if (stateAfter != null) {
1456                     stateAfter = stateAfter.duplicate();
1457                     stateAfter.replaceFirstInput(oldPhi, newPhi);
1458                     newMerge.setStateAfter(stateAfter);
1459                 }
1460 
1461                 newMerge.setNext(successor);
1462             }
1463             tool.addToWorkList(successor);
1464         }
1465     }
1466 
1467     /**
1468      * Gets an array of constants derived from a node that is either a {@link ConstantNode} or a
1469      * {@link PhiNode} whose input values are all constants. The length of the returned array is
1470      * equal to the number of ends terminating in a given merge node.
1471      *
1472      * @return null if {@code node} is neither a {@link ConstantNode} nor a {@link PhiNode} whose
1473      *         input values are all constants
1474      */
1475     public static Constant[] constantValues(ValueNode node, AbstractMergeNode merge, boolean allowNull) {
1476         if (node.isConstant()) {
1477             Constant[] result = new Constant[merge.forwardEndCount()];
1478             Arrays.fill(result, node.asConstant());
1479             return result;
1480         }
1481 
1482         if (node instanceof PhiNode) {
1483             PhiNode phi = (PhiNode) node;
1484             if (phi.merge() == merge &amp;&amp; phi instanceof ValuePhiNode &amp;&amp; phi.valueCount() == merge.forwardEndCount()) {
1485                 Constant[] result = new Constant[merge.forwardEndCount()];
1486                 int i = 0;
1487                 for (ValueNode n : phi.values()) {
1488                     if (!allowNull &amp;&amp; !n.isConstant()) {
1489                         return null;
1490                     }
1491                     result[i++] = n.asConstant();
1492                 }
1493                 return result;
1494             }
1495         }
1496 
1497         return null;
1498     }
1499 
1500     @Override
1501     public AbstractBeginNode getPrimarySuccessor() {
1502         return null;
1503     }
1504 
1505     public AbstractBeginNode getSuccessor(boolean result) {
1506         return result ? this.trueSuccessor() : this.falseSuccessor();
1507     }
1508 
1509     @Override
1510     public boolean setProbability(AbstractBeginNode successor, double value) {
1511         if (successor == this.trueSuccessor()) {
1512             this.setTrueSuccessorProbability(value);
1513             return true;
1514         } else if (successor == this.falseSuccessor()) {
1515             this.setTrueSuccessorProbability(1.0 - value);
1516             return true;
1517         }
1518         return false;
1519     }
1520 
1521     @Override
1522     public int getSuccessorCount() {
1523         return 2;
1524     }
1525 }
<a name="53" id="anc53"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="53" type="hidden" />
</body>
</html>
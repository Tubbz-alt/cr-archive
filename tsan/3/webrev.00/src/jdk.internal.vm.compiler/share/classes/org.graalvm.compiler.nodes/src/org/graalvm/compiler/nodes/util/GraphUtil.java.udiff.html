<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/util/GraphUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../type/StampTool.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../virtual/AllocatedObjectNode.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/util/GraphUtil.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -52,15 +52,17 @@</span>
  import org.graalvm.compiler.graph.spi.SimplifierTool;
  import org.graalvm.compiler.nodes.AbstractBeginNode;
  import org.graalvm.compiler.nodes.AbstractEndNode;
  import org.graalvm.compiler.nodes.AbstractMergeNode;
  import org.graalvm.compiler.nodes.ConstantNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.ControlSinkNode;</span>
  import org.graalvm.compiler.nodes.ControlSplitNode;
  import org.graalvm.compiler.nodes.FixedNode;
  import org.graalvm.compiler.nodes.FixedWithNextNode;
  import org.graalvm.compiler.nodes.FrameState;
  import org.graalvm.compiler.nodes.GuardNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.IfNode;</span>
  import org.graalvm.compiler.nodes.LoopBeginNode;
  import org.graalvm.compiler.nodes.LoopEndNode;
  import org.graalvm.compiler.nodes.LoopExitNode;
  import org.graalvm.compiler.nodes.NodeView;
  import org.graalvm.compiler.nodes.PhiNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103,10 +105,12 @@</span>
      public static class Options {
          @Option(help = &quot;Verify that there are no new unused nodes when performing killCFG&quot;, type = OptionType.Debug)//
          public static final OptionKey&lt;Boolean&gt; VerifyKillCFGUnusedNodes = new OptionKey&lt;&gt;(false);
      }
  
<span class="udiff-line-added">+     public static final int MAX_FRAMESTATE_SEARCH_DEPTH = 4;</span>
<span class="udiff-line-added">+ </span>
      private static void killCFGInner(FixedNode node) {
          EconomicSet&lt;Node&gt; markedNodes = EconomicSet.create();
          EconomicMap&lt;AbstractMergeNode, List&lt;AbstractEndNode&gt;&gt; unmarkedMerges = EconomicMap.create();
  
          // Detach this node from CFG
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -241,14 +245,16 @@</span>
          try (DebugContext.Scope scope = debug.scope(&quot;KillCFG&quot;, node)) {
              EconomicSet&lt;Node&gt; unusedNodes = null;
              EconomicSet&lt;Node&gt; unsafeNodes = null;
              Graph.NodeEventScope nodeEventScope = null;
              OptionValues options = node.getOptions();
<span class="udiff-line-modified-removed">-             if (Graph.Options.VerifyGraalGraphEdges.getValue(options)) {</span>
<span class="udiff-line-modified-added">+             boolean verifyGraalGraphEdges = Graph.Options.VerifyGraalGraphEdges.getValue(options);</span>
<span class="udiff-line-added">+             boolean verifyKillCFGUnusedNodes = GraphUtil.Options.VerifyKillCFGUnusedNodes.getValue(options);</span>
<span class="udiff-line-added">+             if (verifyGraalGraphEdges) {</span>
                  unsafeNodes = collectUnsafeNodes(node.graph());
              }
<span class="udiff-line-modified-removed">-             if (GraphUtil.Options.VerifyKillCFGUnusedNodes.getValue(options)) {</span>
<span class="udiff-line-modified-added">+             if (verifyKillCFGUnusedNodes) {</span>
                  EconomicSet&lt;Node&gt; collectedUnusedNodes = unusedNodes = EconomicSet.create(Equivalence.IDENTITY);
                  nodeEventScope = node.graph().trackNodeEvents(new Graph.NodeEventListener() {
                      @Override
                      public void changed(Graph.NodeEvent e, Node n) {
                          if (e == Graph.NodeEvent.ZERO_USAGES &amp;&amp; isFloatingNode(n) &amp;&amp; !(n instanceof GuardNode)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -258,16 +264,16 @@</span>
                  });
              }
              debug.dump(DebugContext.VERY_DETAILED_LEVEL, node.graph(), &quot;Before killCFG %s&quot;, node);
              killCFGInner(node);
              debug.dump(DebugContext.VERY_DETAILED_LEVEL, node.graph(), &quot;After killCFG %s&quot;, node);
<span class="udiff-line-modified-removed">-             if (Graph.Options.VerifyGraalGraphEdges.getValue(options)) {</span>
<span class="udiff-line-modified-added">+             if (verifyGraalGraphEdges) {</span>
                  EconomicSet&lt;Node&gt; newUnsafeNodes = collectUnsafeNodes(node.graph());
                  newUnsafeNodes.removeAll(unsafeNodes);
                  assert newUnsafeNodes.isEmpty() : &quot;New unsafe nodes: &quot; + newUnsafeNodes;
              }
<span class="udiff-line-modified-removed">-             if (GraphUtil.Options.VerifyKillCFGUnusedNodes.getValue(options)) {</span>
<span class="udiff-line-modified-added">+             if (verifyKillCFGUnusedNodes) {</span>
                  nodeEventScope.close();
                  Iterator&lt;Node&gt; iterator = unusedNodes.iterator();
                  while (iterator.hasNext()) {
                      Node curNode = iterator.next();
                      if (curNode.isDeleted()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -738,33 +744,40 @@</span>
          return singleLength;
      }
  
      /**
       * Tries to find an original value of the given node by traversing through proxies and
<span class="udiff-line-modified-removed">-      * unambiguous phis. Note that this method will perform an exhaustive search through phis. It is</span>
<span class="udiff-line-removed">-      * intended to be used during graph building, when phi nodes aren&#39;t yet canonicalized.</span>
<span class="udiff-line-modified-added">+      * unambiguous phis. Note that this method will perform an exhaustive search through phis.</span>
       *
<span class="udiff-line-modified-removed">-      * @param value The node whose original value should be determined.</span>
<span class="udiff-line-modified-removed">-      * @return The original value (which might be the input value itself).</span>
<span class="udiff-line-modified-added">+      * @param value the node whose original value should be determined</span>
<span class="udiff-line-modified-added">+      * @param abortOnLoopPhi specifies if the traversal through phis should stop and return</span>
<span class="udiff-line-added">+      *            {@code value} if it hits a {@linkplain PhiNode#isLoopPhi loop phi}. This argument</span>
<span class="udiff-line-added">+      *            must be {@code true} if used during graph building as loop phi nodes may not yet</span>
<span class="udiff-line-added">+      *            have all their inputs computed.</span>
<span class="udiff-line-added">+      * @return the original value (which might be {@code value} itself)</span>
       */
<span class="udiff-line-modified-removed">-     public static ValueNode originalValue(ValueNode value) {</span>
<span class="udiff-line-modified-removed">-         ValueNode result = originalValueSimple(value);</span>
<span class="udiff-line-modified-added">+     public static ValueNode originalValue(ValueNode value, boolean abortOnLoopPhi) {</span>
<span class="udiff-line-modified-added">+         ValueNode result = originalValueSimple(value, abortOnLoopPhi);</span>
          assert result != null;
          return result;
      }
  
<span class="udiff-line-modified-removed">-     private static ValueNode originalValueSimple(ValueNode value) {</span>
<span class="udiff-line-modified-added">+     private static ValueNode originalValueSimple(ValueNode value, boolean abortOnLoopPhi) {</span>
          /* The very simple case: look through proxies. */
          ValueNode cur = originalValueForProxy(value);
  
          while (cur instanceof PhiNode) {
              /*
               * We found a phi function. Check if we can analyze it without allocating temporary data
               * structures.
               */
              PhiNode phi = (PhiNode) cur;
  
<span class="udiff-line-added">+             if (abortOnLoopPhi &amp;&amp; phi.isLoopPhi()) {</span>
<span class="udiff-line-added">+                 return value;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              ValueNode phiSingleValue = null;
              int count = phi.valueCount();
              for (int i = 0; i &lt; count; ++i) {
                  ValueNode phiCurValue = originalValueForProxy(phi.valueAt(i));
                  if (phiCurValue == phi) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -779,11 +792,11 @@</span>
                          /*
                           * We have two different input values for the phi function, and at least one
                           * of the inputs is another phi function. We need to do a complicated
                           * exhaustive check.
                           */
<span class="udiff-line-modified-removed">-                         return originalValueForComplicatedPhi(phi, new NodeBitMap(value.graph()));</span>
<span class="udiff-line-modified-added">+                         return originalValueForComplicatedPhi(value, phi, new NodeBitMap(value.graph()), abortOnLoopPhi);</span>
                      } else {
                          /*
                           * We have two different input values for the phi function, but none of them
                           * is another phi function. This phi function cannot be reduce any further,
                           * so the phi function is the original value.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -815,12 +828,16 @@</span>
      }
  
      /**
       * Handling for complicated nestings of phi functions. We need to reduce phi functions
       * recursively, and need a temporary map of visited nodes to avoid endless recursion of cycles.
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param value the node whose original value is being determined</span>
<span class="udiff-line-added">+      * @param abortOnLoopPhi specifies if the traversal through phis should stop and return</span>
<span class="udiff-line-added">+      *            {@code value} if it hits a {@linkplain PhiNode#isLoopPhi loop phi}</span>
       */
<span class="udiff-line-modified-removed">-     private static ValueNode originalValueForComplicatedPhi(PhiNode phi, NodeBitMap visited) {</span>
<span class="udiff-line-modified-added">+     private static ValueNode originalValueForComplicatedPhi(ValueNode value, PhiNode phi, NodeBitMap visited, boolean abortOnLoopPhi) {</span>
          if (visited.isMarked(phi)) {
              /*
               * Found a phi function that was already seen. Either a cycle, or just a second phi
               * input to a path we have already processed.
               */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -832,11 +849,20 @@</span>
          int count = phi.valueCount();
          for (int i = 0; i &lt; count; ++i) {
              ValueNode phiCurValue = originalValueForProxy(phi.valueAt(i));
              if (phiCurValue instanceof PhiNode) {
                  /* Recursively process a phi function input. */
<span class="udiff-line-modified-removed">-                 phiCurValue = originalValueForComplicatedPhi((PhiNode) phiCurValue, visited);</span>
<span class="udiff-line-modified-added">+                 PhiNode curPhi = (PhiNode) phiCurValue;</span>
<span class="udiff-line-added">+                 if (abortOnLoopPhi &amp;&amp; curPhi.isLoopPhi()) {</span>
<span class="udiff-line-added">+                     return value;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 phiCurValue = originalValueForComplicatedPhi(value, curPhi, visited, abortOnLoopPhi);</span>
<span class="udiff-line-added">+                 if (phiCurValue == value) {</span>
<span class="udiff-line-added">+                     // Hit a loop phi</span>
<span class="udiff-line-added">+                     assert abortOnLoopPhi;</span>
<span class="udiff-line-added">+                     return value;</span>
<span class="udiff-line-added">+                 }</span>
              }
  
              if (phiCurValue == null) {
                  /* Cycle to a phi function that was already seen. We can ignore this input. */
              } else if (phiSingleValue == null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1086,6 +1112,57 @@</span>
          /* Perform the replacement. */
          VirtualArrayNode newVirtualArray = virtualArrayProvider.apply(newComponentType, newLengthInt);
          tool.createVirtualObject(newVirtualArray, newEntryState, Collections.&lt;MonitorIdNode&gt; emptyList(), false);
          tool.replaceWithVirtual(newVirtualArray);
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Snippet lowerings may produce patterns without a frame state on the merge. We need to take</span>
<span class="udiff-line-added">+      * extra care when optimizing these patterns.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public static boolean checkFrameState(FixedNode start, int maxDepth) {</span>
<span class="udiff-line-added">+         if (maxDepth == 0) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         FixedNode node = start;</span>
<span class="udiff-line-added">+         while (true) {</span>
<span class="udiff-line-added">+             if (node instanceof AbstractMergeNode) {</span>
<span class="udiff-line-added">+                 AbstractMergeNode mergeNode = (AbstractMergeNode) node;</span>
<span class="udiff-line-added">+                 if (mergeNode.stateAfter() == null) {</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else if (node instanceof StateSplit) {</span>
<span class="udiff-line-added">+                 StateSplit stateSplitNode = (StateSplit) node;</span>
<span class="udiff-line-added">+                 if (stateSplitNode.stateAfter() != null) {</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (node instanceof ControlSplitNode) {</span>
<span class="udiff-line-added">+                 ControlSplitNode controlSplitNode = (ControlSplitNode) node;</span>
<span class="udiff-line-added">+                 for (Node succ : controlSplitNode.cfgSuccessors()) {</span>
<span class="udiff-line-added">+                     if (checkFrameState((FixedNode) succ, maxDepth - 1)) {</span>
<span class="udiff-line-added">+                         return true;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+             } else if (node instanceof FixedWithNextNode) {</span>
<span class="udiff-line-added">+                 FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) node;</span>
<span class="udiff-line-added">+                 node = fixedWithNextNode.next();</span>
<span class="udiff-line-added">+             } else if (node instanceof AbstractEndNode) {</span>
<span class="udiff-line-added">+                 AbstractEndNode endNode = (AbstractEndNode) node;</span>
<span class="udiff-line-added">+                 node = endNode.merge();</span>
<span class="udiff-line-added">+             } else if (node instanceof ControlSinkNode) {</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 assert false : &quot;unexpected node&quot;;</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static boolean mayRemoveSplit(IfNode ifNode) {</span>
<span class="udiff-line-added">+         return GraphUtil.checkFrameState(ifNode.trueSuccessor(), MAX_FRAMESTATE_SEARCH_DEPTH) &amp;&amp; GraphUtil.checkFrameState(ifNode.falseSuccessor(), MAX_FRAMESTATE_SEARCH_DEPTH);</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="../type/StampTool.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../virtual/AllocatedObjectNode.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/IntegerTestNode.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/IntegerTestNode.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/IntegerTestNode.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/IntegerTestNode.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,18 +25,21 @@
 package org.graalvm.compiler.nodes.calc;
 
 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_2;
 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_2;
 
+import java.nio.ByteBuffer;
+
 import org.graalvm.compiler.core.common.type.IntegerStamp;
 import org.graalvm.compiler.core.common.type.Stamp;
 import org.graalvm.compiler.graph.NodeClass;
 import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;
 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 import org.graalvm.compiler.nodeinfo.NodeInfo;
 import org.graalvm.compiler.nodes.BinaryOpLogicNode;
 import org.graalvm.compiler.nodes.LogicConstantNode;
+import org.graalvm.compiler.nodes.LogicNode;
 import org.graalvm.compiler.nodes.NodeView;
 import org.graalvm.compiler.nodes.ValueNode;
 
 import jdk.vm.ci.meta.TriState;
 
@@ -51,26 +54,57 @@
 
     public IntegerTestNode(ValueNode x, ValueNode y) {
         super(TYPE, x, y);
     }
 
-    @Override
-    public ValueNode canonical(CanonicalizerTool tool, ValueNode forX, ValueNode forY) {
-        NodeView view = NodeView.from(tool);
+    public static LogicNode create(ValueNode x, ValueNode y, NodeView view) {
+        LogicNode value = canonical(x, y, view);
+        if (value != null) {
+            return value;
+        }
+        return new IntegerTestNode(x, y);
+    }
+
+    private static LogicNode canonical(ValueNode forX, ValueNode forY, NodeView view) {
         if (forX.isConstant() && forY.isConstant()) {
-            return LogicConstantNode.forBoolean((forX.asJavaConstant().asLong() & forY.asJavaConstant().asLong()) == 0);
+            if (forX.isJavaConstant() && forY.isJavaConstant()) {
+                return LogicConstantNode.forBoolean((forX.asJavaConstant().asLong() & forY.asJavaConstant().asLong()) == 0);
+            }
+            if (forX.isSerializableConstant() && forY.isSerializableConstant()) {
+                int bufSize = Math.min(forX.asSerializableConstant().getSerializedSize(), forX.asSerializableConstant().getSerializedSize());
+                ByteBuffer xBuf = ByteBuffer.allocate(bufSize);
+                ByteBuffer yBuf = ByteBuffer.allocate(bufSize);
+                forX.asSerializableConstant().serialize(xBuf);
+                forY.asSerializableConstant().serialize(yBuf);
+                return serializableToConst(xBuf, yBuf, bufSize);
+            }
         }
         if (forX.stamp(view) instanceof IntegerStamp && forY.stamp(view) instanceof IntegerStamp) {
             IntegerStamp xStamp = (IntegerStamp) forX.stamp(view);
             IntegerStamp yStamp = (IntegerStamp) forY.stamp(view);
             if ((xStamp.upMask() & yStamp.upMask()) == 0) {
                 return LogicConstantNode.tautology();
             } else if ((xStamp.downMask() & yStamp.downMask()) != 0) {
                 return LogicConstantNode.contradiction();
             }
         }
-        return this;
+        return null;
+    }
+
+    @Override
+    public ValueNode canonical(CanonicalizerTool tool, ValueNode forX, ValueNode forY) {
+        ValueNode value = canonical(forX, forY, NodeView.from(tool));
+        return value != null ? value : this;
+    }
+
+    private static LogicNode serializableToConst(ByteBuffer xBuf, ByteBuffer yBuf, int bufSize) {
+        for (int i = 0; i < bufSize; i++) {
+            if ((xBuf.get(i) & yBuf.get(i)) != 0) {
+                return LogicConstantNode.contradiction();
+            }
+        }
+        return LogicConstantNode.tautology();
     }
 
     @Override
     public Stamp getSucceedingStampForX(boolean negated, Stamp xStamp, Stamp yStamp) {
         return getSucceedingStamp(negated, xStamp, yStamp);

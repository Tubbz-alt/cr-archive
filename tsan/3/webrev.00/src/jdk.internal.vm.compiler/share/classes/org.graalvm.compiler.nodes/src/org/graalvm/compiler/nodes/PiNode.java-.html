<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/PiNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes;
 26 
 27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_0;
 28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_0;
 29 
 30 import org.graalvm.compiler.core.common.type.AbstractPointerStamp;
 31 import org.graalvm.compiler.core.common.type.ObjectStamp;
 32 import org.graalvm.compiler.core.common.type.Stamp;
 33 import org.graalvm.compiler.core.common.type.StampFactory;
 34 import org.graalvm.compiler.core.common.type.TypeReference;
 35 import org.graalvm.compiler.debug.DebugContext;
 36 import org.graalvm.compiler.graph.IterableNodeType;
 37 import org.graalvm.compiler.graph.Node;
 38 import org.graalvm.compiler.graph.NodeClass;
 39 import org.graalvm.compiler.graph.spi.Canonicalizable;
 40 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 41 import org.graalvm.compiler.nodeinfo.NodeInfo;
 42 import org.graalvm.compiler.nodes.extended.GuardingNode;
 43 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 44 import org.graalvm.compiler.nodes.memory.ReadNode;
 45 import org.graalvm.compiler.nodes.spi.LIRLowerable;
 46 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
 47 import org.graalvm.compiler.nodes.spi.ValueProxy;
 48 import org.graalvm.compiler.nodes.spi.Virtualizable;
 49 import org.graalvm.compiler.nodes.spi.VirtualizerTool;
 50 import org.graalvm.compiler.nodes.type.StampTool;
 51 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 52 
 53 import jdk.vm.ci.meta.JavaKind;
 54 import jdk.vm.ci.meta.ResolvedJavaMethod;
 55 import jdk.vm.ci.meta.ResolvedJavaType;
 56 
 57 //JaCoCo Exclude
 58 
 59 /**
 60  * A node that changes the type of its input, usually narrowing it. For example, a {@link PiNode}
 61  * refines the type of a receiver during type-guarded inlining to be the type tested by the guard.
 62  *
 63  * In contrast to a {@link GuardedValueNode}, a {@link PiNode} is useless as soon as the type of its
 64  * input is as narrow or narrower than the {@link PiNode}&#39;s type. The {@link PiNode}, and therefore
 65  * also the scheduling restriction enforced by the guard, will go away.
 66  */
 67 @NodeInfo(cycles = CYCLES_0, size = SIZE_0)
 68 public class PiNode extends FloatingGuardedNode implements LIRLowerable, Virtualizable, IterableNodeType, Canonicalizable, ValueProxy {
 69 
 70     public static final NodeClass&lt;PiNode&gt; TYPE = NodeClass.create(PiNode.class);
 71     @Input ValueNode object;
 72     protected Stamp piStamp;
 73 
 74     public ValueNode object() {
 75         return object;
 76     }
 77 
 78     protected PiNode(NodeClass&lt;? extends PiNode&gt; c, ValueNode object, Stamp stamp, GuardingNode guard) {
 79         super(c, stamp, guard);
 80         this.object = object;
 81         this.piStamp = stamp;
 82         assert piStamp.isCompatible(object.stamp(NodeView.DEFAULT)) : &quot;Object stamp not compatible to piStamp&quot;;
 83         inferStamp();
 84     }
 85 
 86     public PiNode(ValueNode object, Stamp stamp) {
 87         this(object, stamp, null);
 88     }
 89 
 90     public PiNode(ValueNode object, Stamp stamp, ValueNode guard) {
 91         this(TYPE, object, stamp, (GuardingNode) guard);
 92     }
 93 
 94     public PiNode(ValueNode object, ValueNode guard) {
 95         this(object, AbstractPointerStamp.pointerNonNull(object.stamp(NodeView.DEFAULT)), guard);
 96     }
 97 
 98     public PiNode(ValueNode object, ResolvedJavaType toType, boolean exactType, boolean nonNull) {
 99         this(object, StampFactory.object(exactType ? TypeReference.createExactTrusted(toType) : TypeReference.createWithoutAssumptions(toType),
100                         nonNull || StampTool.isPointerNonNull(object.stamp(NodeView.DEFAULT))));
101     }
102 
103     public static ValueNode create(ValueNode object, Stamp stamp) {
104         ValueNode value = canonical(object, stamp, null, null);
105         if (value != null) {
106             return value;
107         }
108         return new PiNode(object, stamp);
109     }
110 
111     public static ValueNode create(ValueNode object, Stamp stamp, ValueNode guard) {
112         ValueNode value = canonical(object, stamp, (GuardingNode) guard, null);
113         if (value != null) {
114             return value;
115         }
116         return new PiNode(object, stamp, guard);
117     }
118 
119     public static ValueNode create(ValueNode object, ValueNode guard) {
120         Stamp stamp = AbstractPointerStamp.pointerNonNull(object.stamp(NodeView.DEFAULT));
121         ValueNode value = canonical(object, stamp, (GuardingNode) guard, null);
122         if (value != null) {
123             return value;
124         }
125         return new PiNode(object, stamp, guard);
126     }
127 
128     @SuppressWarnings(&quot;unused&quot;)
129     public static boolean intrinsify(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode object, ValueNode guard) {
130         Stamp stamp = AbstractPointerStamp.pointerNonNull(object.stamp(NodeView.DEFAULT));
131         ValueNode value = canonical(object, stamp, (GuardingNode) guard, null);
132         if (value == null) {
133             value = new PiNode(object, stamp, guard);
134         }
135         b.push(JavaKind.Object, b.append(value));
136         return true;
137     }
138 
139     @SuppressWarnings(&quot;unused&quot;)
140     public static boolean intrinsify(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode object, ResolvedJavaType toType, boolean exactType, boolean nonNull) {
141         Stamp stamp = StampFactory.object(exactType ? TypeReference.createExactTrusted(toType) : TypeReference.createWithoutAssumptions(toType),
142                         nonNull || StampTool.isPointerNonNull(object.stamp(NodeView.DEFAULT)));
143         ValueNode value = canonical(object, stamp, null, null);
144         if (value == null) {
145             value = new PiNode(object, stamp);
146         }
147         b.push(JavaKind.Object, b.append(value));
148         return true;
149     }
150 
151     public final Stamp piStamp() {
152         return piStamp;
153     }
154 
155     public void strengthenPiStamp(Stamp newPiStamp) {
156         assert this.piStamp.join(newPiStamp).equals(newPiStamp) : &quot;stamp can only improve&quot;;
157         this.piStamp = newPiStamp;
158     }
159 
160     @Override
161     public void generate(NodeLIRBuilderTool generator) {
162         if (generator.hasOperand(object)) {
163             generator.setResult(this, generator.operand(object));
164         }
165     }
166 
167     @Override
168     public boolean inferStamp() {
169         return updateStamp(computeStamp());
170     }
171 
172     private Stamp computeStamp() {
173         return piStamp.improveWith(object().stamp(NodeView.DEFAULT));
174     }
175 
176     @Override
177     public void virtualize(VirtualizerTool tool) {
178         ValueNode alias = tool.getAlias(object());
179         if (alias instanceof VirtualObjectNode) {
180             VirtualObjectNode virtual = (VirtualObjectNode) alias;
181             ResolvedJavaType type = StampTool.typeOrNull(this, tool.getMetaAccess());
182             if (type != null &amp;&amp; type.isAssignableFrom(virtual.type())) {
183                 tool.replaceWithVirtual(virtual);
184             } else {
185                 tool.getDebug().log(DebugContext.INFO_LEVEL, &quot;could not virtualize Pi because of type mismatch: %s %s vs %s&quot;, this, type, virtual.type());
186             }
187         }
188     }
189 
190     public static ValueNode canonical(ValueNode object, Stamp stamp, GuardingNode guard, PiNode self) {
191         // Use most up to date stamp.
192         Stamp computedStamp = stamp.improveWith(object.stamp(NodeView.DEFAULT));
193 
194         // The pi node does not give any additional information =&gt; skip it.
195         if (computedStamp.equals(object.stamp(NodeView.DEFAULT))) {
196             return object;
197         }
198 
199         if (guard == null) {
200             // Try to merge the pi node with a load node.
201             if (object instanceof ReadNode &amp;&amp; !object.hasMoreThanOneUsage()) {
202                 ReadNode readNode = (ReadNode) object;
203                 readNode.setStamp(readNode.stamp(NodeView.DEFAULT).improveWith(stamp));
204                 return readNode;
205             }
206         } else {
207             for (Node n : guard.asNode().usages()) {
208                 if (n instanceof PiNode &amp;&amp; n != self) {
209                     PiNode otherPi = (PiNode) n;
210                     assert otherPi.guard == guard;
211                     if (object == otherPi.object() &amp;&amp; computedStamp.equals(otherPi.stamp(NodeView.DEFAULT))) {
212                         /*
213                          * Two PiNodes with the same guard and same result, so return the one with
214                          * the more precise piStamp.
215                          */
216                         Stamp newStamp = stamp.join(otherPi.piStamp);
217                         if (newStamp.equals(otherPi.piStamp)) {
218                             return otherPi;
219                         }
220                     }
221                 }
222             }
223         }
224         return null;
225     }
226 
227     @Override
228     public Node canonical(CanonicalizerTool tool) {
229         Node value = canonical(object(), piStamp(), getGuard(), this);
230         if (value != null) {
231             return value;
232         }
233         return this;
234     }
235 
236     @Override
237     public ValueNode getOriginalNode() {
238         return object;
239     }
240 
241     public void setOriginalNode(ValueNode newNode) {
242         this.updateUsages(object, newNode);
243         this.object = newNode;
244         assert piStamp.isCompatible(object.stamp(NodeView.DEFAULT)) : &quot;New object stamp not compatible to piStamp&quot;;
245     }
246 
247     /**
248      * Casts an object to have an exact, non-null stamp representing {@link Class}.
249      */
250     public static Class&lt;?&gt; asNonNullClass(Object object) {
251         return asNonNullClassIntrinsic(object, Class.class, true, true);
252     }
253 
254     /**
255      * Casts an object to have an exact, non-null stamp representing {@link Class}.
256      */
257     public static Class&lt;?&gt; asNonNullObject(Object object) {
258         return asNonNullClassIntrinsic(object, Object.class, false, true);
259     }
260 
261     @NodeIntrinsic(PiNode.class)
262     private static native Class&lt;?&gt; asNonNullClassIntrinsic(Object object, @ConstantNodeParameter Class&lt;?&gt; toType, @ConstantNodeParameter boolean exactType, @ConstantNodeParameter boolean nonNull);
263 
264     /**
265      * Changes the stamp of an object inside a snippet to be the stamp of the node replaced by the
266      * snippet.
267      */
268     @NodeIntrinsic(PiNode.Placeholder.class)
269     public static native Object piCastToSnippetReplaceeStamp(Object object);
270 
271     /**
272      * Changes the stamp of an object and ensures the newly stamped value is non-null and does not
273      * float above a given guard.
274      */
275     @NodeIntrinsic
276     public static native Object piCastNonNull(Object object, GuardingNode guard);
277 
278     /**
279      * Changes the stamp of an object and ensures the newly stamped value is non-null and does not
280      * float above a given guard.
281      */
282     @NodeIntrinsic
283     public static native Class&lt;?&gt; piCastNonNullClass(Class&lt;?&gt; type, GuardingNode guard);
284 
285     /**
286      * Changes the stamp of an object to represent a given type and to indicate that the object is
287      * not null.
288      */
289     public static Object piCastNonNull(Object object, @ConstantNodeParameter ResolvedJavaType toType) {
290         return piCast(object, toType, false, true);
291     }
292 
293     @NodeIntrinsic
294     public static native Object piCast(Object object, @ConstantNodeParameter ResolvedJavaType toType, @ConstantNodeParameter boolean exactType, @ConstantNodeParameter boolean nonNull);
295 
296     /**
297      * A placeholder node in a snippet that will be replaced with a {@link PiNode} when the snippet
298      * is instantiated.
299      */
300     @NodeInfo(cycles = CYCLES_0, size = SIZE_0)
301     public static class Placeholder extends FloatingGuardedNode {
302 
303         public static final NodeClass&lt;Placeholder&gt; TYPE = NodeClass.create(Placeholder.class);
304         @Input ValueNode object;
305 
306         public ValueNode object() {
307             return object;
308         }
309 
310         protected Placeholder(NodeClass&lt;? extends Placeholder&gt; c, ValueNode object) {
311             super(c, PlaceholderStamp.SINGLETON, null);
312             this.object = object;
313         }
314 
315         public Placeholder(ValueNode object) {
316             this(TYPE, object);
317         }
318 
319         /**
320          * Replaces this node with a {@link PiNode} during snippet instantiation.
321          *
322          * @param snippetReplaceeStamp the stamp of the node being replace by the snippet
323          */
324         public void makeReplacement(Stamp snippetReplaceeStamp) {
325             ValueNode value = graph().maybeAddOrUnique(PiNode.create(object(), snippetReplaceeStamp, null));
326             replaceAndDelete(value);
327         }
328     }
329 
330     /**
331      * A stamp for {@link Placeholder} nodes which are only used in snippets. It is replaced by an
332      * actual stamp when the snippet is instantiated.
333      */
334     public static final class PlaceholderStamp extends ObjectStamp {
335         private static final PlaceholderStamp SINGLETON = new PlaceholderStamp();
336 
337         public static PlaceholderStamp singleton() {
338             return SINGLETON;
339         }
340 
341         private PlaceholderStamp() {
342             super(null, false, false, false);
343         }
344 
345         @Override
346         public int hashCode() {
347             return System.identityHashCode(this);
348         }
349 
350         @Override
351         public boolean equals(Object obj) {
352             return this == obj;
353         }
354 
355         @Override
356         public String toString() {
357             return &quot;PlaceholderStamp&quot;;
358         }
359     }
360 }
    </pre>
  </body>
</html>
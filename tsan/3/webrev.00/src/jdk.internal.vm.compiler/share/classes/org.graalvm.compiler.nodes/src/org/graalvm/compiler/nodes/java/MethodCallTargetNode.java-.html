<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/MethodCallTargetNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.java;
 26 
 27 import org.graalvm.compiler.core.common.type.Stamp;
 28 import org.graalvm.compiler.core.common.type.StampFactory;
 29 import org.graalvm.compiler.core.common.type.StampPair;
 30 import org.graalvm.compiler.core.common.type.TypeReference;
 31 import org.graalvm.compiler.graph.IterableNodeType;
 32 import org.graalvm.compiler.graph.Node;
 33 import org.graalvm.compiler.graph.NodeClass;
 34 import org.graalvm.compiler.graph.spi.Simplifiable;
 35 import org.graalvm.compiler.graph.spi.SimplifierTool;
 36 import org.graalvm.compiler.nodeinfo.NodeInfo;
 37 import org.graalvm.compiler.nodeinfo.Verbosity;
 38 import org.graalvm.compiler.nodes.CallTargetNode;
 39 import org.graalvm.compiler.nodes.FixedGuardNode;
 40 import org.graalvm.compiler.nodes.Invoke;
 41 import org.graalvm.compiler.nodes.LogicNode;
 42 import org.graalvm.compiler.nodes.NodeView;
 43 import org.graalvm.compiler.nodes.PiNode;
 44 import org.graalvm.compiler.nodes.StructuredGraph;
 45 import org.graalvm.compiler.nodes.ValueNode;
 46 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;
 47 import org.graalvm.compiler.nodes.spi.UncheckedInterfaceProvider;
 48 import org.graalvm.compiler.nodes.type.StampTool;
 49 
 50 import jdk.vm.ci.code.BytecodeFrame;
 51 import jdk.vm.ci.meta.Assumptions;
 52 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 53 import jdk.vm.ci.meta.DeoptimizationAction;
 54 import jdk.vm.ci.meta.DeoptimizationReason;
 55 import jdk.vm.ci.meta.JavaKind;
 56 import jdk.vm.ci.meta.JavaTypeProfile;
 57 import jdk.vm.ci.meta.ResolvedJavaMethod;
 58 import jdk.vm.ci.meta.ResolvedJavaType;
 59 
 60 @NodeInfo
 61 public class MethodCallTargetNode extends CallTargetNode implements IterableNodeType, Simplifiable {
 62     public static final NodeClass&lt;MethodCallTargetNode&gt; TYPE = NodeClass.create(MethodCallTargetNode.class);
 63     protected JavaTypeProfile profile;
 64 
 65     public MethodCallTargetNode(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] arguments, StampPair returnStamp, JavaTypeProfile profile) {
 66         this(TYPE, invokeKind, targetMethod, arguments, returnStamp, profile);
 67     }
 68 
 69     protected MethodCallTargetNode(NodeClass&lt;? extends MethodCallTargetNode&gt; c, InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] arguments, StampPair returnStamp,
 70                     JavaTypeProfile profile) {
 71         super(c, arguments, targetMethod, invokeKind, returnStamp);
 72         this.profile = profile;
 73     }
 74 
 75     /**
 76      * Gets the instruction that produces the receiver object for this invocation, if any.
 77      *
 78      * @return the instruction that produces the receiver object for this invocation if any,
 79      *         {@code null} if this invocation does not take a receiver object
 80      */
 81     public ValueNode receiver() {
 82         return isStatic() ? null : arguments().get(0);
 83     }
 84 
 85     /**
 86      * Checks whether this is an invocation of a static method.
 87      *
 88      * @return {@code true} if the invocation is a static invocation
 89      */
 90     public boolean isStatic() {
 91         return invokeKind() == InvokeKind.Static;
 92     }
 93 
 94     public JavaKind returnKind() {
 95         return targetMethod().getSignature().getReturnKind();
 96     }
 97 
 98     public Invoke invoke() {
 99         return (Invoke) this.usages().first();
100     }
101 
102     @Override
103     public boolean verify() {
104         assert getUsageCount() &lt;= 1 : &quot;call target may only be used by a single invoke&quot;;
105         for (Node n : usages()) {
106             assertTrue(n instanceof Invoke, &quot;call target can only be used from an invoke (%s)&quot;, n);
107         }
108         if (invokeKind().isDirect()) {
109             assertTrue(targetMethod().isConcrete(), &quot;special calls or static calls are only allowed for concrete methods (%s)&quot;, targetMethod());
110         }
111         if (invokeKind() == InvokeKind.Static) {
112             assertTrue(targetMethod().isStatic(), &quot;static calls are only allowed for static methods (%s)&quot;, targetMethod());
113         } else {
114             assertFalse(targetMethod().isStatic(), &quot;static calls are only allowed for non-static methods (%s)&quot;, targetMethod());
115         }
116         return super.verify();
117     }
118 
119     @Override
120     public String toString(Verbosity verbosity) {
121         if (verbosity == Verbosity.Long) {
122             return super.toString(Verbosity.Short) + &quot;(&quot; + targetMethod() + &quot;)&quot;;
123         } else {
124             return super.toString(verbosity);
125         }
126     }
127 
128     public static ResolvedJavaMethod findSpecialCallTarget(InvokeKind invokeKind, ValueNode receiver, ResolvedJavaMethod targetMethod, ResolvedJavaType contextType) {
129         if (invokeKind.isDirect()) {
130             return null;
131         }
132 
133         // check for trivial cases (e.g. final methods, nonvirtual methods)
134         if (targetMethod.canBeStaticallyBound()) {
135             return targetMethod;
136         }
137 
138         return devirtualizeCall(invokeKind, targetMethod, contextType, receiver.graph().getAssumptions(), receiver.stamp(NodeView.DEFAULT));
139     }
140 
141     public static ResolvedJavaMethod devirtualizeCall(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ResolvedJavaType contextType, Assumptions assumptions, Stamp receiverStamp) {
142         TypeReference type = StampTool.typeReferenceOrNull(receiverStamp);
143         if (type == null &amp;&amp; invokeKind == InvokeKind.Virtual) {
144             // For virtual calls, we are guaranteed to receive a correct receiver type.
145             type = TypeReference.createTrusted(assumptions, targetMethod.getDeclaringClass());
146         }
147 
148         if (type != null) {
149             /*
150              * either the holder class is exact, or the receiver object has an exact type, or it&#39;s
151              * an array type
152              */
153             ResolvedJavaMethod resolvedMethod = type.getType().resolveConcreteMethod(targetMethod, contextType);
154             if (resolvedMethod != null &amp;&amp; (resolvedMethod.canBeStaticallyBound() || type.isExact() || type.getType().isArray())) {
155                 return resolvedMethod;
156             }
157 
158             AssumptionResult&lt;ResolvedJavaMethod&gt; uniqueConcreteMethod = type.getType().findUniqueConcreteMethod(targetMethod);
159             if (uniqueConcreteMethod != null &amp;&amp; uniqueConcreteMethod.canRecordTo(assumptions)) {
160                 uniqueConcreteMethod.recordTo(assumptions);
161                 return uniqueConcreteMethod.getResult();
162             }
163         }
164         return null;
165     }
166 
167     @Override
168     public void simplify(SimplifierTool tool) {
169         // attempt to devirtualize the call
170         if (invoke().getContextMethod() == null) {
171             // avoid invokes that have placeholder bcis: they do not have a valid contextType
172             assert (invoke().stateAfter() != null &amp;&amp; BytecodeFrame.isPlaceholderBci(invoke().stateAfter().bci)) || BytecodeFrame.isPlaceholderBci(invoke().stateDuring().bci);
173             return;
174         }
175         ResolvedJavaType contextType = (invoke().stateAfter() == null &amp;&amp; invoke().stateDuring() == null) ? null : invoke().getContextType();
176         ResolvedJavaMethod specialCallTarget = findSpecialCallTarget(invokeKind, receiver(), targetMethod, contextType);
177         if (specialCallTarget != null) {
178             this.setTargetMethod(specialCallTarget);
179             setInvokeKind(InvokeKind.Special);
180             return;
181         }
182 
183         Assumptions assumptions = graph().getAssumptions();
184         /*
185          * Even though we are not registering an assumption (see comment below), the optimization is
186          * only valid when speculative optimizations are enabled.
187          */
188         if (invokeKind().isIndirect() &amp;&amp; invokeKind().isInterface() &amp;&amp; assumptions != null) {
189 
190             // check if the type of the receiver can narrow the result
191             ValueNode receiver = receiver();
192 
193             // try to turn a interface call into a virtual call
194             ResolvedJavaType declaredReceiverType = targetMethod().getDeclaringClass();
195 
196             /*
197              * We need to check the invoke kind to avoid recursive simplification for virtual
198              * interface methods calls.
199              */
200             if (declaredReceiverType.isInterface()) {
201                 ResolvedJavaType singleImplementor = declaredReceiverType.getSingleImplementor();
202                 if (singleImplementor != null &amp;&amp; !singleImplementor.equals(declaredReceiverType)) {
203                     TypeReference speculatedType = TypeReference.createTrusted(assumptions, singleImplementor);
204                     if (tryCheckCastSingleImplementor(receiver, speculatedType)) {
205                         return;
206                     }
207                 }
208             }
209 
210             if (receiver instanceof UncheckedInterfaceProvider) {
211                 UncheckedInterfaceProvider uncheckedInterfaceProvider = (UncheckedInterfaceProvider) receiver;
212                 Stamp uncheckedStamp = uncheckedInterfaceProvider.uncheckedStamp();
213                 if (uncheckedStamp != null) {
214                     TypeReference speculatedType = StampTool.typeReferenceOrNull(uncheckedStamp);
215                     if (speculatedType != null) {
216                         tryCheckCastSingleImplementor(receiver, speculatedType);
217                     }
218                 }
219             }
220         }
221     }
222 
223     private boolean tryCheckCastSingleImplementor(ValueNode receiver, TypeReference speculatedType) {
224         ResolvedJavaType singleImplementor = speculatedType.getType();
225         if (singleImplementor != null) {
226             ResolvedJavaMethod singleImplementorMethod = singleImplementor.resolveConcreteMethod(targetMethod(), invoke().getContextType());
227             if (singleImplementorMethod != null) {
228                 /**
229                  * We have an invoke on an interface with a single implementor. We can replace this
230                  * with an invoke virtual.
231                  *
232                  * To do so we need to ensure two properties: 1) the receiver must implement the
233                  * interface (declaredReceiverType). The verifier does not prove this so we need a
234                  * dynamic check. 2) we need to ensure that there is still only one implementor of
235                  * this interface, i.e. that we are calling the right method. We could do this with
236                  * an assumption but as we need an instanceof check anyway we can verify both
237                  * properties by checking of the receiver is an instance of the single implementor.
238                  */
239                 ValueAnchorNode anchor = new ValueAnchorNode(null);
240                 if (anchor != null) {
241                     graph().add(anchor);
242                     graph().addBeforeFixed(invoke().asNode(), anchor);
243                 }
244                 LogicNode condition = graph().addOrUniqueWithInputs(InstanceOfNode.create(speculatedType, receiver, getProfile(), anchor));
245                 FixedGuardNode guard = graph().add(new FixedGuardNode(condition, DeoptimizationReason.OptimizedTypeCheckViolated, DeoptimizationAction.InvalidateRecompile, false));
246                 graph().addBeforeFixed(invoke().asNode(), guard);
247                 ValueNode valueNode = graph().addOrUnique(new PiNode(receiver, StampFactory.objectNonNull(speculatedType), guard));
248                 arguments().set(0, valueNode);
249                 if (speculatedType.isExact()) {
250                     setInvokeKind(InvokeKind.Special);
251                 } else {
252                     setInvokeKind(InvokeKind.Virtual);
253                 }
254                 setTargetMethod(singleImplementorMethod);
255                 return true;
256             }
257         }
258         return false;
259     }
260 
261     public JavaTypeProfile getProfile() {
262         return profile;
263     }
264 
265     @Override
266     public String targetName() {
267         if (targetMethod() == null) {
268             return &quot;??Invalid!&quot;;
269         }
270         return targetMethod().format(&quot;%h.%n&quot;);
271     }
272 
273     public static MethodCallTargetNode find(StructuredGraph graph, ResolvedJavaMethod method) {
274         for (MethodCallTargetNode target : graph.getNodes(MethodCallTargetNode.TYPE)) {
275             if (target.targetMethod().equals(method)) {
276                 return target;
277             }
278         }
279         return null;
280     }
281 }
    </pre>
  </body>
</html>
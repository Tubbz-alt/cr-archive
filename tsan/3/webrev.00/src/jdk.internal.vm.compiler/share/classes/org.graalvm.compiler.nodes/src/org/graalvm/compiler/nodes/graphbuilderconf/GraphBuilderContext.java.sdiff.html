<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/GraphBuilderContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraphBuilderConfiguration.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphBuilderTool.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/GraphBuilderContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 30 
 31 import org.graalvm.compiler.bytecode.Bytecode;
 32 import org.graalvm.compiler.bytecode.BytecodeProvider;
 33 import org.graalvm.compiler.core.common.type.AbstractPointerStamp;
 34 import org.graalvm.compiler.core.common.type.Stamp;
 35 import org.graalvm.compiler.core.common.type.StampFactory;
 36 import org.graalvm.compiler.core.common.type.StampPair;
 37 import org.graalvm.compiler.debug.GraalError;
 38 import org.graalvm.compiler.nodes.AbstractBeginNode;
 39 import org.graalvm.compiler.nodes.AbstractMergeNode;
 40 import org.graalvm.compiler.nodes.CallTargetNode;
 41 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 42 import org.graalvm.compiler.nodes.ConstantNode;
 43 import org.graalvm.compiler.nodes.DynamicPiNode;
 44 import org.graalvm.compiler.nodes.FixedGuardNode;
 45 import org.graalvm.compiler.nodes.Invoke;
 46 import org.graalvm.compiler.nodes.LogicNode;
 47 import org.graalvm.compiler.nodes.NodeView;
 48 import org.graalvm.compiler.nodes.PiNode;
 49 import org.graalvm.compiler.nodes.StateSplit;

 50 import org.graalvm.compiler.nodes.ValueNode;
 51 import org.graalvm.compiler.nodes.calc.IsNullNode;
 52 import org.graalvm.compiler.nodes.calc.NarrowNode;
 53 import org.graalvm.compiler.nodes.calc.SignExtendNode;
 54 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
 55 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
 56 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 57 import org.graalvm.compiler.nodes.type.StampTool;
 58 
 59 import jdk.vm.ci.code.BailoutException;
 60 import jdk.vm.ci.meta.Assumptions;
 61 import jdk.vm.ci.meta.DeoptimizationAction;
 62 import jdk.vm.ci.meta.DeoptimizationReason;
 63 import jdk.vm.ci.meta.JavaKind;
 64 import jdk.vm.ci.meta.JavaType;
 65 import jdk.vm.ci.meta.ResolvedJavaMethod;
 66 
 67 /**
 68  * Used by a {@link GraphBuilderPlugin} to interface with an object that parses the bytecode of a
 69  * single {@linkplain #getMethod() method} as part of building a {@linkplain #getGraph() graph} .
</pre>
<hr />
<pre>
147      *            handling the replaced invoke are to be force inlined
148      */
149     Invoke handleReplacedInvoke(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, boolean forceInlineEverything);
150 
151     void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType);
152 
153     /**
154      * Intrinsifies an invocation of a given method by inlining the bytecodes of a given
155      * substitution method.
156      *
157      * @param bytecodeProvider used to get the bytecodes to parse for the substitution method
158      * @param targetMethod the method being intrinsified
159      * @param substitute the intrinsic implementation
160      * @param receiver the receiver, or null for static methods
161      * @param argsIncludingReceiver the arguments with which to inline the invocation
162      *
163      * @return whether the intrinsification was successful
164      */
165     boolean intrinsify(BytecodeProvider bytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] argsIncludingReceiver);
166 













167     /**
168      * Creates a snap shot of the current frame state with the BCI of the instruction after the one
169      * currently being parsed and assigns it to a given {@linkplain StateSplit#hasSideEffect() side
170      * effect} node.
171      *
172      * @param sideEffect a side effect node just appended to the graph
173      */
174     void setStateAfter(StateSplit sideEffect);
175 
176     /**
177      * Gets the parsing context for the method that inlines the method being parsed by this context.
178      */
179     GraphBuilderContext getParent();
180 
181     /**
182      * Gets the first ancestor parsing context that is not parsing a {@linkplain #parsingIntrinsic()
183      * intrinsic}.
184      */
185     default GraphBuilderContext getNonIntrinsicAncestor() {
186         GraphBuilderContext ancestor = getParent();
</pre>
<hr />
<pre>
226      */
227     default int getDepth() {
228         GraphBuilderContext parent = getParent();
229         int result = 0;
230         while (parent != null) {
231             result++;
232             parent = parent.getParent();
233         }
234         return result;
235     }
236 
237     /**
238      * Determines if this parsing context is within the bytecode of an intrinsic or a method inlined
239      * by an intrinsic.
240      */
241     @Override
242     default boolean parsingIntrinsic() {
243         return getIntrinsic() != null;
244     }
245 







246     /**
247      * Gets the intrinsic of the current parsing context or {@code null} if not
248      * {@link #parsingIntrinsic() parsing an intrinsic}.
249      */
250     IntrinsicContext getIntrinsic();
251 
252     BailoutException bailout(String string);
253 
254     default ValueNode nullCheckedValue(ValueNode value) {
255         return nullCheckedValue(value, InvalidateReprofile);
256     }
257 
258     /**
259      * Gets a version of a given value that has a {@linkplain StampTool#isPointerNonNull(ValueNode)
260      * non-null} stamp.
261      */
262     default ValueNode nullCheckedValue(ValueNode value, DeoptimizationAction action) {
263         if (!StampTool.isPointerNonNull(value)) {
264             LogicNode condition = getGraph().unique(IsNullNode.create(value));
265             FixedGuardNode fixedGuard = append(new FixedGuardNode(condition, NullCheckException, action, true));
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 30 
 31 import org.graalvm.compiler.bytecode.Bytecode;
 32 import org.graalvm.compiler.bytecode.BytecodeProvider;
 33 import org.graalvm.compiler.core.common.type.AbstractPointerStamp;
 34 import org.graalvm.compiler.core.common.type.Stamp;
 35 import org.graalvm.compiler.core.common.type.StampFactory;
 36 import org.graalvm.compiler.core.common.type.StampPair;
 37 import org.graalvm.compiler.debug.GraalError;
 38 import org.graalvm.compiler.nodes.AbstractBeginNode;
 39 import org.graalvm.compiler.nodes.AbstractMergeNode;
 40 import org.graalvm.compiler.nodes.CallTargetNode;
 41 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 42 import org.graalvm.compiler.nodes.ConstantNode;
 43 import org.graalvm.compiler.nodes.DynamicPiNode;
 44 import org.graalvm.compiler.nodes.FixedGuardNode;
 45 import org.graalvm.compiler.nodes.Invoke;
 46 import org.graalvm.compiler.nodes.LogicNode;
 47 import org.graalvm.compiler.nodes.NodeView;
 48 import org.graalvm.compiler.nodes.PiNode;
 49 import org.graalvm.compiler.nodes.StateSplit;
<span class="line-added"> 50 import org.graalvm.compiler.nodes.StructuredGraph;</span>
 51 import org.graalvm.compiler.nodes.ValueNode;
 52 import org.graalvm.compiler.nodes.calc.IsNullNode;
 53 import org.graalvm.compiler.nodes.calc.NarrowNode;
 54 import org.graalvm.compiler.nodes.calc.SignExtendNode;
 55 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
 56 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
 57 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 58 import org.graalvm.compiler.nodes.type.StampTool;
 59 
 60 import jdk.vm.ci.code.BailoutException;
 61 import jdk.vm.ci.meta.Assumptions;
 62 import jdk.vm.ci.meta.DeoptimizationAction;
 63 import jdk.vm.ci.meta.DeoptimizationReason;
 64 import jdk.vm.ci.meta.JavaKind;
 65 import jdk.vm.ci.meta.JavaType;
 66 import jdk.vm.ci.meta.ResolvedJavaMethod;
 67 
 68 /**
 69  * Used by a {@link GraphBuilderPlugin} to interface with an object that parses the bytecode of a
 70  * single {@linkplain #getMethod() method} as part of building a {@linkplain #getGraph() graph} .
</pre>
<hr />
<pre>
148      *            handling the replaced invoke are to be force inlined
149      */
150     Invoke handleReplacedInvoke(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, boolean forceInlineEverything);
151 
152     void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType);
153 
154     /**
155      * Intrinsifies an invocation of a given method by inlining the bytecodes of a given
156      * substitution method.
157      *
158      * @param bytecodeProvider used to get the bytecodes to parse for the substitution method
159      * @param targetMethod the method being intrinsified
160      * @param substitute the intrinsic implementation
161      * @param receiver the receiver, or null for static methods
162      * @param argsIncludingReceiver the arguments with which to inline the invocation
163      *
164      * @return whether the intrinsification was successful
165      */
166     boolean intrinsify(BytecodeProvider bytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] argsIncludingReceiver);
167 
<span class="line-added">168     /**</span>
<span class="line-added">169      * Intrinsifies an invocation of a given method by inlining the graph of a given substitution</span>
<span class="line-added">170      * method.</span>
<span class="line-added">171      *</span>
<span class="line-added">172      * @param targetMethod the method being intrinsified</span>
<span class="line-added">173      * @param substituteGraph the intrinsic implementation</span>
<span class="line-added">174      * @param receiver the receiver, or null for static methods</span>
<span class="line-added">175      * @param argsIncludingReceiver the arguments with which to inline the invocation</span>
<span class="line-added">176      *</span>
<span class="line-added">177      * @return whether the intrinsification was successful</span>
<span class="line-added">178      */</span>
<span class="line-added">179     boolean intrinsify(ResolvedJavaMethod targetMethod, StructuredGraph substituteGraph, InvocationPlugin.Receiver receiver, ValueNode[] argsIncludingReceiver);</span>
<span class="line-added">180 </span>
181     /**
182      * Creates a snap shot of the current frame state with the BCI of the instruction after the one
183      * currently being parsed and assigns it to a given {@linkplain StateSplit#hasSideEffect() side
184      * effect} node.
185      *
186      * @param sideEffect a side effect node just appended to the graph
187      */
188     void setStateAfter(StateSplit sideEffect);
189 
190     /**
191      * Gets the parsing context for the method that inlines the method being parsed by this context.
192      */
193     GraphBuilderContext getParent();
194 
195     /**
196      * Gets the first ancestor parsing context that is not parsing a {@linkplain #parsingIntrinsic()
197      * intrinsic}.
198      */
199     default GraphBuilderContext getNonIntrinsicAncestor() {
200         GraphBuilderContext ancestor = getParent();
</pre>
<hr />
<pre>
240      */
241     default int getDepth() {
242         GraphBuilderContext parent = getParent();
243         int result = 0;
244         while (parent != null) {
245             result++;
246             parent = parent.getParent();
247         }
248         return result;
249     }
250 
251     /**
252      * Determines if this parsing context is within the bytecode of an intrinsic or a method inlined
253      * by an intrinsic.
254      */
255     @Override
256     default boolean parsingIntrinsic() {
257         return getIntrinsic() != null;
258     }
259 
<span class="line-added">260     /**</span>
<span class="line-added">261      * Determines if a graph builder plugin is enabled under current context.</span>
<span class="line-added">262      */</span>
<span class="line-added">263     default boolean isPluginEnabled(GraphBuilderPlugin plugin) {</span>
<span class="line-added">264         return parsingIntrinsic() || !(plugin instanceof GeneratedInvocationPlugin &amp;&amp; ((GeneratedInvocationPlugin) plugin).isGeneratedFromFoldOrNodeIntrinsic());</span>
<span class="line-added">265     }</span>
<span class="line-added">266 </span>
267     /**
268      * Gets the intrinsic of the current parsing context or {@code null} if not
269      * {@link #parsingIntrinsic() parsing an intrinsic}.
270      */
271     IntrinsicContext getIntrinsic();
272 
273     BailoutException bailout(String string);
274 
275     default ValueNode nullCheckedValue(ValueNode value) {
276         return nullCheckedValue(value, InvalidateReprofile);
277     }
278 
279     /**
280      * Gets a version of a given value that has a {@linkplain StampTool#isPointerNonNull(ValueNode)
281      * non-null} stamp.
282      */
283     default ValueNode nullCheckedValue(ValueNode value, DeoptimizationAction action) {
284         if (!StampTool.isPointerNonNull(value)) {
285             LogicNode condition = getGraph().unique(IsNullNode.create(value));
286             FixedGuardNode fixedGuard = append(new FixedGuardNode(condition, NullCheckException, action, true));
</pre>
</td>
</tr>
</table>
<center><a href="GraphBuilderConfiguration.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphBuilderTool.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
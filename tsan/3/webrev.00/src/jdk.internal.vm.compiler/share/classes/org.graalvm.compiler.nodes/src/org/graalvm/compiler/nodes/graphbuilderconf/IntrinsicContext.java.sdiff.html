<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/IntrinsicContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineInvokePlugin.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InvocationPlugin.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/IntrinsicContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.graphbuilderconf;
 26 
 27 import static jdk.vm.ci.code.BytecodeFrame.AFTER_BCI;
 28 import static jdk.vm.ci.code.BytecodeFrame.AFTER_EXCEPTION_BCI;
 29 import static jdk.vm.ci.code.BytecodeFrame.BEFORE_BCI;
 30 import static jdk.vm.ci.code.BytecodeFrame.INVALID_FRAMESTATE_BCI;

 31 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;
 32 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION;
 33 
 34 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 35 import org.graalvm.compiler.bytecode.BytecodeProvider;
 36 import org.graalvm.compiler.graph.NodeSourcePosition;
 37 import org.graalvm.compiler.nodes.AbstractMergeNode;
 38 import org.graalvm.compiler.nodes.FrameState;
 39 import org.graalvm.compiler.nodes.Invoke;
 40 import org.graalvm.compiler.nodes.LoopExitNode;
 41 import org.graalvm.compiler.nodes.StateSplit;
 42 import org.graalvm.compiler.nodes.StructuredGraph;
 43 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
 44 
 45 import jdk.vm.ci.meta.ResolvedJavaMethod;
 46 
 47 /**
 48  * An intrinsic is a substitute implementation of a Java method (or a bytecode in the case of
 49  * snippets) that is itself implemented in Java. This interface provides information about the
 50  * intrinsic currently being processed by the graph builder.
</pre>
<hr />
<pre>
119     public BytecodeProvider getBytecodeProvider() {
120         return bytecodeProvider;
121     }
122 
123     /**
124      * Determines if a call within the compilation scope of this intrinsic represents a call to the
125      * {@linkplain #getOriginalMethod() original} method. This denotes the path where a partial
126      * intrinsification falls back to the original method.
127      */
128     public boolean isCallToOriginal(ResolvedJavaMethod targetMethod) {
129         return originalMethod.equals(targetMethod) || intrinsicMethod.equals(targetMethod);
130     }
131 
132     private NodeSourcePosition nodeSourcePosition;
133 
134     public boolean isPostParseInlined() {
135         return compilationContext.equals(INLINE_AFTER_PARSING);
136     }
137 
138     public boolean isCompilationRoot() {
<span class="line-modified">139         return compilationContext.equals(ROOT_COMPILATION);</span>




140     }
141 
142     public NodeSourcePosition getNodeSourcePosition() {
143         return nodeSourcePosition;
144     }
145 
146     public void setNodeSourcePosition(NodeSourcePosition position) {
147         assert nodeSourcePosition == null : &quot;can only be set once&quot;;
148         this.nodeSourcePosition = position;
149     }
150 
151     /**
152      * Denotes the compilation context in which an intrinsic is being parsed.
153      */
154     public enum CompilationContext {
155         /**
156          * An intrinsic is being processed when parsing an invoke bytecode that calls the
157          * intrinsified method.
158          */
159         INLINE_DURING_PARSING,
160 
161         /**
162          * An intrinsic is being processed when inlining an {@link Invoke} in an existing graph.
163          */
164         INLINE_AFTER_PARSING,
165 
166         /**
167          * An intrinsic is the root of compilation.
168          */
<span class="line-modified">169         ROOT_COMPILATION</span>





170     }
171 
172     /**
173      * Models the state of a graph in terms of {@link StateSplit#hasSideEffect() side effects} that
174      * are control flow predecessors of the current point in a graph.
175      */
176     public interface SideEffectsState {
177 
178         /**
179          * Determines if the current program point is preceded by one or more side effects.
180          */
181         boolean isAfterSideEffect();
182 
183         /**
184          * Gets the side effects preceding the current program point.
185          */
186         Iterable&lt;StateSplit&gt; sideEffects();
187 
188         /**
189          * Records a side effect for the current program point.
190          */
191         void addSideEffect(StateSplit sideEffect);
192     }
193 





194     public FrameState createFrameState(StructuredGraph graph, SideEffectsState sideEffects, StateSplit forStateSplit, NodeSourcePosition sourcePosition) {
195         assert forStateSplit != graph.start();
196         if (forStateSplit.hasSideEffect()) {
197             if (sideEffects.isAfterSideEffect()) {
198                 // Only the last side effect on any execution path in a replacement
199                 // can inherit the stateAfter of the replaced node
200                 FrameState invalid = graph.add(new FrameState(INVALID_FRAMESTATE_BCI));
201                 if (graph.trackNodeSourcePosition()) {
202                     invalid.setNodeSourcePosition(sourcePosition);
203                 }
204                 for (StateSplit lastSideEffect : sideEffects.sideEffects()) {
205                     lastSideEffect.setStateAfter(invalid);
206                 }
207             }
<span class="line-removed">208             sideEffects.addSideEffect(forStateSplit);</span>
209             FrameState frameState;
<span class="line-modified">210             if (forStateSplit instanceof ExceptionObjectNode) {</span>
<span class="line-modified">211                 frameState = graph.add(new FrameState(AFTER_EXCEPTION_BCI, (ExceptionObjectNode) forStateSplit));</span>
212             } else {
<span class="line-modified">213                 frameState = graph.add(new FrameState(AFTER_BCI));</span>





214             }
215             if (graph.trackNodeSourcePosition()) {
216                 frameState.setNodeSourcePosition(sourcePosition);
217             }
218             return frameState;
219         } else {
220             if (forStateSplit instanceof AbstractMergeNode || forStateSplit instanceof LoopExitNode) {
221                 // Merge nodes always need a frame state
222                 if (sideEffects.isAfterSideEffect()) {
223                     // A merge after one or more side effects
224                     FrameState frameState = graph.add(new FrameState(AFTER_BCI));
225                     if (graph.trackNodeSourcePosition()) {
226                         frameState.setNodeSourcePosition(sourcePosition);
227                     }
228                     return frameState;
229                 } else {
230                     // A merge before any side effects
231                     FrameState frameState = graph.add(new FrameState(BEFORE_BCI));
232                     if (graph.trackNodeSourcePosition()) {
233                         frameState.setNodeSourcePosition(sourcePosition);
234                     }
235                     return frameState;
236                 }
237             } else {
238                 // Other non-side-effects do not need a state
239                 return null;
240             }
241         }
242     }
243 
244     @Override
245     public String toString() {
<span class="line-modified">246         return &quot;Intrinsic{original: &quot; + originalMethod.format(&quot;%H.%n(%p)&quot;) + &quot;, intrinsic: &quot; + intrinsicMethod.format(&quot;%H.%n(%p)&quot;) + &quot;, context: &quot; + compilationContext + &quot;}&quot;;</span>

247     }
248 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.graphbuilderconf;
 26 
 27 import static jdk.vm.ci.code.BytecodeFrame.AFTER_BCI;
 28 import static jdk.vm.ci.code.BytecodeFrame.AFTER_EXCEPTION_BCI;
 29 import static jdk.vm.ci.code.BytecodeFrame.BEFORE_BCI;
 30 import static jdk.vm.ci.code.BytecodeFrame.INVALID_FRAMESTATE_BCI;
<span class="line-added"> 31 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;</span>
 32 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;
 33 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION;
 34 
 35 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 36 import org.graalvm.compiler.bytecode.BytecodeProvider;
 37 import org.graalvm.compiler.graph.NodeSourcePosition;
 38 import org.graalvm.compiler.nodes.AbstractMergeNode;
 39 import org.graalvm.compiler.nodes.FrameState;
 40 import org.graalvm.compiler.nodes.Invoke;
 41 import org.graalvm.compiler.nodes.LoopExitNode;
 42 import org.graalvm.compiler.nodes.StateSplit;
 43 import org.graalvm.compiler.nodes.StructuredGraph;
 44 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
 45 
 46 import jdk.vm.ci.meta.ResolvedJavaMethod;
 47 
 48 /**
 49  * An intrinsic is a substitute implementation of a Java method (or a bytecode in the case of
 50  * snippets) that is itself implemented in Java. This interface provides information about the
 51  * intrinsic currently being processed by the graph builder.
</pre>
<hr />
<pre>
120     public BytecodeProvider getBytecodeProvider() {
121         return bytecodeProvider;
122     }
123 
124     /**
125      * Determines if a call within the compilation scope of this intrinsic represents a call to the
126      * {@linkplain #getOriginalMethod() original} method. This denotes the path where a partial
127      * intrinsification falls back to the original method.
128      */
129     public boolean isCallToOriginal(ResolvedJavaMethod targetMethod) {
130         return originalMethod.equals(targetMethod) || intrinsicMethod.equals(targetMethod);
131     }
132 
133     private NodeSourcePosition nodeSourcePosition;
134 
135     public boolean isPostParseInlined() {
136         return compilationContext.equals(INLINE_AFTER_PARSING);
137     }
138 
139     public boolean isCompilationRoot() {
<span class="line-modified">140         return compilationContext.equals(ROOT_COMPILATION) || compilationContext.equals(ROOT_COMPILATION_ENCODING);</span>
<span class="line-added">141     }</span>
<span class="line-added">142 </span>
<span class="line-added">143     public boolean isIntrinsicEncoding() {</span>
<span class="line-added">144         return compilationContext.equals(ROOT_COMPILATION_ENCODING);</span>
145     }
146 
147     public NodeSourcePosition getNodeSourcePosition() {
148         return nodeSourcePosition;
149     }
150 
151     public void setNodeSourcePosition(NodeSourcePosition position) {
152         assert nodeSourcePosition == null : &quot;can only be set once&quot;;
153         this.nodeSourcePosition = position;
154     }
155 
156     /**
157      * Denotes the compilation context in which an intrinsic is being parsed.
158      */
159     public enum CompilationContext {
160         /**
161          * An intrinsic is being processed when parsing an invoke bytecode that calls the
162          * intrinsified method.
163          */
164         INLINE_DURING_PARSING,
165 
166         /**
167          * An intrinsic is being processed when inlining an {@link Invoke} in an existing graph.
168          */
169         INLINE_AFTER_PARSING,
170 
171         /**
172          * An intrinsic is the root of compilation.
173          */
<span class="line-modified">174         ROOT_COMPILATION,</span>
<span class="line-added">175 </span>
<span class="line-added">176         /**</span>
<span class="line-added">177          * An intrinsic is the root of a compilation done for graph encoding.</span>
<span class="line-added">178          */</span>
<span class="line-added">179         ROOT_COMPILATION_ENCODING</span>
180     }
181 
182     /**
183      * Models the state of a graph in terms of {@link StateSplit#hasSideEffect() side effects} that
184      * are control flow predecessors of the current point in a graph.
185      */
186     public interface SideEffectsState {
187 
188         /**
189          * Determines if the current program point is preceded by one or more side effects.
190          */
191         boolean isAfterSideEffect();
192 
193         /**
194          * Gets the side effects preceding the current program point.
195          */
196         Iterable&lt;StateSplit&gt; sideEffects();
197 
198         /**
199          * Records a side effect for the current program point.
200          */
201         void addSideEffect(StateSplit sideEffect);
202     }
203 
<span class="line-added">204     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added">205     public boolean isDeferredInvoke(StateSplit stateSplit) {</span>
<span class="line-added">206         return false;</span>
<span class="line-added">207     }</span>
<span class="line-added">208 </span>
209     public FrameState createFrameState(StructuredGraph graph, SideEffectsState sideEffects, StateSplit forStateSplit, NodeSourcePosition sourcePosition) {
210         assert forStateSplit != graph.start();
211         if (forStateSplit.hasSideEffect()) {
212             if (sideEffects.isAfterSideEffect()) {
213                 // Only the last side effect on any execution path in a replacement
214                 // can inherit the stateAfter of the replaced node
215                 FrameState invalid = graph.add(new FrameState(INVALID_FRAMESTATE_BCI));
216                 if (graph.trackNodeSourcePosition()) {
217                     invalid.setNodeSourcePosition(sourcePosition);
218                 }
219                 for (StateSplit lastSideEffect : sideEffects.sideEffects()) {
220                     lastSideEffect.setStateAfter(invalid);
221                 }
222             }

223             FrameState frameState;
<span class="line-modified">224             if (isDeferredInvoke(forStateSplit)) {</span>
<span class="line-modified">225                 frameState = graph.add(new FrameState(INVALID_FRAMESTATE_BCI));</span>
226             } else {
<span class="line-modified">227                 sideEffects.addSideEffect(forStateSplit);</span>
<span class="line-added">228                 if (forStateSplit instanceof ExceptionObjectNode) {</span>
<span class="line-added">229                     frameState = graph.add(new FrameState(AFTER_EXCEPTION_BCI, (ExceptionObjectNode) forStateSplit));</span>
<span class="line-added">230                 } else {</span>
<span class="line-added">231                     frameState = graph.add(new FrameState(AFTER_BCI));</span>
<span class="line-added">232                 }</span>
233             }
234             if (graph.trackNodeSourcePosition()) {
235                 frameState.setNodeSourcePosition(sourcePosition);
236             }
237             return frameState;
238         } else {
239             if (forStateSplit instanceof AbstractMergeNode || forStateSplit instanceof LoopExitNode) {
240                 // Merge nodes always need a frame state
241                 if (sideEffects.isAfterSideEffect()) {
242                     // A merge after one or more side effects
243                     FrameState frameState = graph.add(new FrameState(AFTER_BCI));
244                     if (graph.trackNodeSourcePosition()) {
245                         frameState.setNodeSourcePosition(sourcePosition);
246                     }
247                     return frameState;
248                 } else {
249                     // A merge before any side effects
250                     FrameState frameState = graph.add(new FrameState(BEFORE_BCI));
251                     if (graph.trackNodeSourcePosition()) {
252                         frameState.setNodeSourcePosition(sourcePosition);
253                     }
254                     return frameState;
255                 }
256             } else {
257                 // Other non-side-effects do not need a state
258                 return null;
259             }
260         }
261     }
262 
263     @Override
264     public String toString() {
<span class="line-modified">265         return &quot;Intrinsic{original: &quot; + originalMethod.format(&quot;%H.%n(%p)&quot;) + &quot;, intrinsic: &quot; + (intrinsicMethod != null ? intrinsicMethod.format(&quot;%H.%n(%p)&quot;) : &quot;null&quot;) + &quot;, context: &quot; +</span>
<span class="line-added">266                         compilationContext + &quot;}&quot;;</span>
267     }
268 }
</pre>
</td>
</tr>
</table>
<center><a href="InlineInvokePlugin.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InvocationPlugin.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
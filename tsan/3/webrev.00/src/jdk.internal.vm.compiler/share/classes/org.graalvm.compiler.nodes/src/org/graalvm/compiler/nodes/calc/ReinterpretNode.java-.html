<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/ReinterpretNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.calc;
 26 
 27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_1;
 28 
 29 import java.nio.ByteBuffer;
 30 import java.nio.ByteOrder;
 31 
 32 import org.graalvm.compiler.core.common.LIRKind;
 33 import org.graalvm.compiler.core.common.type.ArithmeticStamp;
 34 import org.graalvm.compiler.core.common.type.FloatStamp;
 35 import org.graalvm.compiler.core.common.type.IntegerStamp;
 36 import org.graalvm.compiler.core.common.type.Stamp;
 37 import org.graalvm.compiler.core.common.type.StampFactory;
 38 import org.graalvm.compiler.graph.NodeClass;
 39 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 40 import org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool;
 41 import org.graalvm.compiler.nodeinfo.NodeInfo;
 42 import org.graalvm.compiler.nodes.ConstantNode;
 43 import org.graalvm.compiler.nodes.NodeView;
 44 import org.graalvm.compiler.nodes.ValueNode;
 45 import org.graalvm.compiler.nodes.spi.ArithmeticLIRLowerable;
 46 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
 47 
 48 import jdk.vm.ci.code.CodeUtil;
 49 import jdk.vm.ci.meta.JavaKind;
 50 import jdk.vm.ci.meta.SerializableConstant;
 51 
 52 /**
 53  * The {@code ReinterpretNode} class represents a reinterpreting conversion that changes the stamp
 54  * of a primitive value to some other incompatible stamp. The new stamp must have the same width as
 55  * the old stamp.
 56  */
 57 @NodeInfo(cycles = CYCLES_1)
 58 public final class ReinterpretNode extends UnaryNode implements ArithmeticLIRLowerable {
 59 
 60     public static final NodeClass&lt;ReinterpretNode&gt; TYPE = NodeClass.create(ReinterpretNode.class);
 61 
 62     protected ReinterpretNode(JavaKind to, ValueNode value) {
 63         this(StampFactory.forKind(to), value);
 64     }
 65 
 66     protected ReinterpretNode(Stamp to, ValueNode value) {
 67         super(TYPE, getReinterpretStamp(to, value.stamp(NodeView.DEFAULT)), value);
 68         assert to instanceof ArithmeticStamp;
 69     }
 70 
 71     public static ValueNode create(JavaKind to, ValueNode value, NodeView view) {
 72         return create(StampFactory.forKind(to), value, view);
 73     }
 74 
 75     public static ValueNode create(Stamp to, ValueNode value, NodeView view) {
 76         return canonical(null, to, value, view);
 77     }
 78 
 79     private static SerializableConstant evalConst(Stamp stamp, SerializableConstant c) {
 80         /*
 81          * We don&#39;t care about byte order here. Either would produce the correct result.
 82          */
 83         ByteBuffer buffer = ByteBuffer.wrap(new byte[c.getSerializedSize()]).order(ByteOrder.nativeOrder());
 84         c.serialize(buffer);
 85 
 86         buffer.rewind();
 87         SerializableConstant ret = ((ArithmeticStamp) stamp).deserialize(buffer);
 88 
 89         assert !buffer.hasRemaining();
 90         return ret;
 91     }
 92 
 93     @Override
 94     public ValueNode canonical(CanonicalizerTool tool, ValueNode forValue) {
 95         NodeView view = NodeView.from(tool);
 96         return canonical(this, this.stamp(view), forValue, view);
 97     }
 98 
 99     public static ValueNode canonical(ReinterpretNode node, Stamp forStamp, ValueNode forValue, NodeView view) {
100         if (forValue.isConstant()) {
101             return ConstantNode.forConstant(forStamp, evalConst(forStamp, (SerializableConstant) forValue.asConstant()), null);
102         }
103         if (forStamp.isCompatible(forValue.stamp(view))) {
104             return forValue;
105         }
106         if (forValue instanceof ReinterpretNode) {
107             ReinterpretNode reinterpret = (ReinterpretNode) forValue;
108             return new ReinterpretNode(forStamp, reinterpret.getValue());
109         }
110         return node != null ? node : new ReinterpretNode(forStamp, forValue);
111     }
112 
113     /**
114      * Compute the {@link IntegerStamp} from a {@link FloatStamp}, losing as little information as
115      * possible.
116      *
117      * Sorting by their bit pattern reinterpreted as signed integers gives the following order of
118      * floating point numbers:
119      *
120      * -0 | negative numbers | -Inf | NaNs | 0 | positive numbers | +Inf | NaNs
121      *
122      * So we can compute a better integer range if we know that the input is positive, negative,
123      * finite, non-zero and/or not NaN.
124      */
125     private static IntegerStamp floatToInt(FloatStamp stamp) {
126         int bits = stamp.getBits();
127 
128         long signBit = 1L &lt;&lt; (bits - 1);
129         long exponentMask;
130         if (bits == 64) {
131             exponentMask = Double.doubleToRawLongBits(Double.POSITIVE_INFINITY);
132         } else {
133             assert bits == 32;
134             exponentMask = Float.floatToRawIntBits(Float.POSITIVE_INFINITY);
135         }
136 
137         long positiveInfinity = exponentMask;
138         long negativeInfinity = CodeUtil.signExtend(signBit | positiveInfinity, bits);
139         long negativeZero = CodeUtil.signExtend(signBit | 0, bits);
140 
141         if (stamp.isNaN()) {
142             // special case: in addition to the range, we know NaN has all exponent bits set
143             return IntegerStamp.create(bits, negativeInfinity + 1, CodeUtil.maxValue(bits), exponentMask, CodeUtil.mask(bits));
144         }
145 
146         long upperBound;
147         if (stamp.isNonNaN()) {
148             if (stamp.upperBound() &lt; 0.0) {
149                 if (stamp.lowerBound() &gt; Double.NEGATIVE_INFINITY) {
150                     upperBound = negativeInfinity - 1;
151                 } else {
152                     upperBound = negativeInfinity;
153                 }
154             } else if (stamp.upperBound() == 0.0) {
155                 upperBound = 0;
156             } else if (stamp.upperBound() &lt; Double.POSITIVE_INFINITY) {
157                 upperBound = positiveInfinity - 1;
158             } else {
159                 upperBound = positiveInfinity;
160             }
161         } else {
162             upperBound = CodeUtil.maxValue(bits);
163         }
164 
165         long lowerBound;
166         if (stamp.lowerBound() &gt; 0.0) {
167             if (stamp.isNonNaN()) {
168                 lowerBound = 1;
169             } else {
170                 lowerBound = negativeInfinity + 1;
171             }
172         } else if (stamp.upperBound() == Double.NEGATIVE_INFINITY) {
173             lowerBound = negativeInfinity;
174         } else if (stamp.upperBound() &lt; 0.0) {
175             lowerBound = negativeZero + 1;
176         } else {
177             lowerBound = negativeZero;
178         }
179 
180         return StampFactory.forInteger(bits, lowerBound, upperBound);
181     }
182 
183     /**
184      * Compute the {@link IntegerStamp} from a {@link FloatStamp}, losing as little information as
185      * possible.
186      *
187      * Sorting by their bit pattern reinterpreted as signed integers gives the following order of
188      * floating point numbers:
189      *
190      * -0 | negative numbers | -Inf | NaNs | 0 | positive numbers | +Inf | NaNs
191      *
192      * So from certain integer ranges we may be able to infer something about the sign, finiteness
193      * or NaN-ness of the result.
194      */
195     private static FloatStamp intToFloat(IntegerStamp stamp) {
196         int bits = stamp.getBits();
197 
198         double minPositive;
199         double maxPositive;
200 
201         long signBit = 1L &lt;&lt; (bits - 1);
202         long exponentMask;
203         if (bits == 64) {
204             exponentMask = Double.doubleToRawLongBits(Double.POSITIVE_INFINITY);
205             minPositive = Double.MIN_VALUE;
206             maxPositive = Double.MAX_VALUE;
207         } else {
208             assert bits == 32;
209             exponentMask = Float.floatToRawIntBits(Float.POSITIVE_INFINITY);
210             minPositive = Float.MIN_VALUE;
211             maxPositive = Float.MAX_VALUE;
212         }
213 
214         long significandMask = CodeUtil.mask(bits) &amp; ~(signBit | exponentMask);
215 
216         long positiveInfinity = exponentMask;
217         long negativeInfinity = CodeUtil.signExtend(signBit | positiveInfinity, bits);
218         long negativeZero = CodeUtil.signExtend(signBit | 0, bits);
219 
220         if ((stamp.downMask() &amp; exponentMask) == exponentMask &amp;&amp; (stamp.downMask() &amp; significandMask) != 0) {
221             // if all exponent bits and at least one significand bit are set, the result is NaN
222             return new FloatStamp(bits, Double.NaN, Double.NaN, false);
223         }
224 
225         double upperBound;
226         if (stamp.upperBound() &lt; negativeInfinity) {
227             if (stamp.lowerBound() &gt; negativeZero) {
228                 upperBound = -minPositive;
229             } else {
230                 upperBound = -0.0;
231             }
232         } else if (stamp.upperBound() &lt; 0) {
233             if (stamp.lowerBound() &gt; negativeInfinity) {
234                 return new FloatStamp(bits, Double.NaN, Double.NaN, false);
235             } else if (stamp.lowerBound() == negativeInfinity) {
236                 upperBound = Double.NEGATIVE_INFINITY;
237             } else if (stamp.lowerBound() &gt; negativeZero) {
238                 upperBound = -minPositive;
239             } else {
240                 upperBound = -0.0;
241             }
242         } else if (stamp.upperBound() == 0) {
243             upperBound = 0.0;
244         } else if (stamp.upperBound() &lt; positiveInfinity) {
245             upperBound = maxPositive;
246         } else {
247             upperBound = Double.POSITIVE_INFINITY;
248         }
249 
250         double lowerBound;
251         if (stamp.lowerBound() &gt; positiveInfinity) {
252             return new FloatStamp(bits, Double.NaN, Double.NaN, false);
253         } else if (stamp.lowerBound() == positiveInfinity) {
254             lowerBound = Double.POSITIVE_INFINITY;
255         } else if (stamp.lowerBound() &gt; 0) {
256             lowerBound = minPositive;
257         } else if (stamp.lowerBound() &gt; negativeInfinity) {
258             lowerBound = 0.0;
259         } else {
260             lowerBound = Double.NEGATIVE_INFINITY;
261         }
262 
263         boolean nonNaN;
264         if ((stamp.upMask() &amp; exponentMask) != exponentMask) {
265             // NaN has all exponent bits set
266             nonNaN = true;
267         } else {
268             boolean negativeNaNBlock = stamp.lowerBound() &lt; 0 &amp;&amp; stamp.upperBound() &gt; negativeInfinity;
269             boolean positiveNaNBlock = stamp.upperBound() &gt; positiveInfinity;
270             nonNaN = !negativeNaNBlock &amp;&amp; !positiveNaNBlock;
271         }
272 
273         return new FloatStamp(bits, lowerBound, upperBound, nonNaN);
274     }
275 
276     private static Stamp getReinterpretStamp(Stamp toStamp, Stamp fromStamp) {
277         if (toStamp instanceof IntegerStamp &amp;&amp; fromStamp instanceof FloatStamp) {
278             return floatToInt((FloatStamp) fromStamp);
279         } else if (toStamp instanceof FloatStamp &amp;&amp; fromStamp instanceof IntegerStamp) {
280             return intToFloat((IntegerStamp) fromStamp);
281         } else {
282             return toStamp;
283         }
284     }
285 
286     @Override
287     public boolean inferStamp() {
288         return updateStamp(getReinterpretStamp(stamp(NodeView.DEFAULT), getValue().stamp(NodeView.DEFAULT)));
289     }
290 
291     @Override
292     public void generate(NodeLIRBuilderTool builder, ArithmeticLIRGeneratorTool gen) {
293         LIRKind kind = builder.getLIRGeneratorTool().getLIRKind(stamp(NodeView.DEFAULT));
294         builder.setResult(this, gen.emitReinterpret(kind, builder.operand(getValue())));
295     }
296 
297     public static ValueNode reinterpret(JavaKind toKind, ValueNode value) {
298         return value.graph().unique(new ReinterpretNode(toKind, value));
299     }
300 }
    </pre>
  </body>
</html>
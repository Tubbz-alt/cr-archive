<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/GraphDecoder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameState.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphEncoder.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/GraphDecoder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,11 ***</span>
              } else {
                  reader = null;
                  maxFixedNodeOrderId = 0;
              }
  
<span class="line-modified">!             if (loopExplosion != LoopExplosionKind.NONE) {</span>
                  loopExplosionMerges = EconomicSet.create(Equivalence.IDENTITY);
              } else {
                  loopExplosionMerges = null;
              }
          }
<span class="line-new-header">--- 137,11 ---</span>
              } else {
                  reader = null;
                  maxFixedNodeOrderId = 0;
              }
  
<span class="line-modified">!             if (loopExplosion.useExplosion()) {</span>
                  loopExplosionMerges = EconomicSet.create(Equivalence.IDENTITY);
              } else {
                  loopExplosionMerges = null;
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,21 ***</span>
              return position;
          }
  
      }
  
      /** Decoding state maintained for each loop in the encoded graph. */
      protected static class LoopScope {
          public final MethodScope methodScope;
          public final LoopScope outer;
          public final int loopDepth;
          public final int loopIteration;
          /**
<span class="line-modified">!          * Upcoming loop iterations during loop explosions that have not been processed yet. Only</span>
<span class="line-modified">!          * used when {@link MethodScope#loopExplosion} is not {@link LoopExplosionKind#NONE}.</span>
           */
<span class="line-modified">!         public Deque&lt;LoopScope&gt; nextIterations;</span>
          /**
           * Information about already processed loop iterations for state merging during loop
           * explosion. Only used when {@link MethodScope#loopExplosion} is
           * {@link LoopExplosionKind#MERGE_EXPLODE}.
           */
<span class="line-new-header">--- 158,74 ---</span>
              return position;
          }
  
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Marker to distinguish the reasons for the creation of a loop scope during partial evaluation.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public enum LoopScopeTrigger {</span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Start loop scope: creation triggered manually at the beginning of partial evaluation.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         START,</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Loop scope created for the next iteration of a loop if unrolling is enabled in the loop</span>
<span class="line-added">+          * explosion mode. See {@link LoopExplosionKind#unrollLoops()} for details. Loop unrolling</span>
<span class="line-added">+          * will merge loop end nodes for each iteration of the original loop.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         LOOP_BEGIN_UNROLLING,</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Loop scope created for the next iteration of a loop along a particular loop end node if</span>
<span class="line-added">+          * {@link LoopExplosionKind#duplicateLoopEnds()} is enabled and loops are exploded. This</span>
<span class="line-added">+          * means for every loop end we duplicate the next loop iteration of the original loop.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         LOOP_END_DUPLICATION,</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Loop scope created for a loop exit node if {@link LoopExplosionKind#duplicateLoopExits()}</span>
<span class="line-added">+          * is enabled, i.e., code after a loop exit is duplicated per loop exit node.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * Special case nested loops: For compilation units with nested loops where inner loops</span>
<span class="line-added">+          * continue loops at a level n -1 the partial evaluation algorithm will merge outer loops to</span>
<span class="line-added">+          * avoid loop explosion along loop end nodes (which would be the same as</span>
<span class="line-added">+          * {@link #LOOP_END_DUPLICATION}.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         LOOP_EXIT_DUPLICATION</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /** Decoding state maintained for each loop in the encoded graph. */
      protected static class LoopScope {
          public final MethodScope methodScope;
          public final LoopScope outer;
          public final int loopDepth;
          public final int loopIteration;
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Creation trigger of this particular loop scope, i.e., the reason it was created.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         final LoopScopeTrigger trigger;</span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Upcoming, not yet processed, loop iterations created in the context of code duplication</span>
<span class="line-added">+          * along loop exits. Only used when {@link MethodScope#loopExplosion} has</span>
<span class="line-added">+          * {@link LoopExplosionKind#duplicateLoopExits()} enabled.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public Deque&lt;LoopScope&gt; nextIterationFromLoopExitDuplication;</span>
          /**
<span class="line-modified">!          * Same as {@link #nextIterationFromLoopExitDuplication} except that upcoming iterations</span>
<span class="line-modified">!          * have been created because the duplication of loop ends</span>
<span class="line-added">+          * {@link LoopExplosionKind#duplicateLoopEnds()} is enabled.</span>
           */
<span class="line-modified">!         public Deque&lt;LoopScope&gt; nextIterationFromLoopEndDuplication;</span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Same as {@link #nextIterationFromLoopExitDuplication} except that upcoming iterations</span>
<span class="line-added">+          * have been created because the unrolling of a loop with constant iteration count</span>
<span class="line-added">+          * {@link LoopExplosionKind#unrollLoops()} is enabled.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public Deque&lt;LoopScope&gt; nextIterationsFromUnrolling;</span>
          /**
           * Information about already processed loop iterations for state merging during loop
           * explosion. Only used when {@link MethodScope#loopExplosion} is
           * {@link LoopExplosionKind#MERGE_EXPLODE}.
           */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 194,39 ***</span>
          public final Node[] initialCreatedNodes;
  
          protected LoopScope(MethodScope methodScope) {
              this.methodScope = methodScope;
              this.outer = null;
<span class="line-modified">!             this.nextIterations = methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN ? new ArrayDeque&lt;&gt;(2) : null;</span>
              this.loopDepth = 0;
              this.loopIteration = 0;
              this.iterationStates = null;
              this.loopBeginOrderId = -1;
<span class="line-removed">- </span>
              int nodeCount = methodScope.encodedGraph.nodeStartOffsets.length;
              this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);
              this.createdNodes = new Node[nodeCount];
              this.initialCreatedNodes = null;
          }
  
<span class="line-modified">!         protected LoopScope(MethodScope methodScope, LoopScope outer, int loopDepth, int loopIteration, int loopBeginOrderId, Node[] initialCreatedNodes, Node[] createdNodes,</span>
<span class="line-modified">!                         Deque&lt;LoopScope&gt; nextIterations, EconomicMap&lt;LoopExplosionState, LoopExplosionState&gt; iterationStates) {</span>
              this.methodScope = methodScope;
              this.outer = outer;
              this.loopDepth = loopDepth;
              this.loopIteration = loopIteration;
<span class="line-modified">!             this.nextIterations = nextIterations;</span>
              this.iterationStates = iterationStates;
              this.loopBeginOrderId = loopBeginOrderId;
              this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);
              this.initialCreatedNodes = initialCreatedNodes;
              this.createdNodes = createdNodes;
          }
  
          @Override
          public String toString() {
<span class="line-modified">!             return loopDepth + &quot;,&quot; + loopIteration + (loopBeginOrderId == -1 ? &quot;&quot; : &quot;#&quot; + loopBeginOrderId);</span>
          }
      }
  
      protected static class LoopExplosionState {
          public final FrameState state;
<span class="line-new-header">--- 247,80 ---</span>
          public final Node[] initialCreatedNodes;
  
          protected LoopScope(MethodScope methodScope) {
              this.methodScope = methodScope;
              this.outer = null;
<span class="line-modified">!             this.nextIterationFromLoopExitDuplication = methodScope.loopExplosion.duplicateLoopExits() || methodScope.loopExplosion.mergeLoops() ? new ArrayDeque&lt;&gt;(2) : null;</span>
<span class="line-added">+             this.nextIterationFromLoopEndDuplication = methodScope.loopExplosion.duplicateLoopEnds() ? new ArrayDeque&lt;&gt;(2) : null;</span>
<span class="line-added">+             this.nextIterationsFromUnrolling = methodScope.loopExplosion.unrollLoops() ? new ArrayDeque&lt;&gt;(2) : null;</span>
              this.loopDepth = 0;
              this.loopIteration = 0;
              this.iterationStates = null;
              this.loopBeginOrderId = -1;
              int nodeCount = methodScope.encodedGraph.nodeStartOffsets.length;
              this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);
              this.createdNodes = new Node[nodeCount];
              this.initialCreatedNodes = null;
<span class="line-added">+             this.trigger = LoopScopeTrigger.START;</span>
          }
  
<span class="line-modified">!         protected LoopScope(MethodScope methodScope, LoopScope outer, int loopDepth, int loopIteration, int loopBeginOrderId, LoopScopeTrigger trigger, Node[] initialCreatedNodes, Node[] createdNodes,</span>
<span class="line-modified">!                         Deque&lt;LoopScope&gt; nextIterationFromLoopExitDuplication,</span>
<span class="line-added">+                         Deque&lt;LoopScope&gt; nextIterationFromLoopEndDuplication,</span>
<span class="line-added">+                         Deque&lt;LoopScope&gt; nextIterationsFromUnrolling, EconomicMap&lt;LoopExplosionState, LoopExplosionState&gt; iterationStates) {</span>
              this.methodScope = methodScope;
              this.outer = outer;
              this.loopDepth = loopDepth;
              this.loopIteration = loopIteration;
<span class="line-modified">!             this.trigger = trigger;</span>
<span class="line-added">+             this.nextIterationFromLoopExitDuplication = nextIterationFromLoopExitDuplication;</span>
<span class="line-added">+             this.nextIterationFromLoopEndDuplication = nextIterationFromLoopEndDuplication;</span>
<span class="line-added">+             this.nextIterationsFromUnrolling = nextIterationsFromUnrolling;</span>
              this.iterationStates = iterationStates;
              this.loopBeginOrderId = loopBeginOrderId;
              this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);
              this.initialCreatedNodes = initialCreatedNodes;
              this.createdNodes = createdNodes;
          }
  
          @Override
          public String toString() {
<span class="line-modified">!             return loopDepth + &quot;,&quot; + loopIteration + (loopBeginOrderId == -1 ? &quot;&quot; : &quot;#&quot; + loopBeginOrderId) + &quot; triggered by &quot; + trigger;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Determines if iterations generated when decoding this loop have yet to be processed.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @return {@code true} if there are iterations to be decoded, {@code false} else</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public boolean hasIterationsToProcess() {</span>
<span class="line-added">+             return nextIterationFromLoopEndDuplication != null &amp;&amp; !nextIterationFromLoopEndDuplication.isEmpty() ||</span>
<span class="line-added">+                             nextIterationFromLoopExitDuplication != null &amp;&amp; !nextIterationFromLoopExitDuplication.isEmpty() ||</span>
<span class="line-added">+                             nextIterationsFromUnrolling != null &amp;&amp; !nextIterationsFromUnrolling.isEmpty();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Return the next iteration yet to be processed that has been created in the context of</span>
<span class="line-added">+          * decoding this loop scope.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param remove determines if the query of the next iteration should remove it from the</span>
<span class="line-added">+          *            list of iterations to be processed</span>
<span class="line-added">+          * @return the next {@link LoopScope} to be processed that has been created in the context</span>
<span class="line-added">+          *         of decoding this loop scope. Note that the order is not necessarily reflecting</span>
<span class="line-added">+          *         the number of loop iterations.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public LoopScope getNextIterationToProcess(boolean remove) {</span>
<span class="line-added">+             if (nextIterationFromLoopEndDuplication != null &amp;&amp; !nextIterationFromLoopEndDuplication.isEmpty()) {</span>
<span class="line-added">+                 return remove ? nextIterationFromLoopEndDuplication.removeFirst() : nextIterationFromLoopEndDuplication.peekFirst();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (nextIterationFromLoopExitDuplication != null &amp;&amp; !nextIterationFromLoopExitDuplication.isEmpty()) {</span>
<span class="line-added">+                 return remove ? nextIterationFromLoopExitDuplication.removeFirst() : nextIterationFromLoopExitDuplication.peekFirst();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (nextIterationsFromUnrolling != null &amp;&amp; !nextIterationsFromUnrolling.isEmpty()) {</span>
<span class="line-added">+                 return remove ? nextIterationsFromUnrolling.removeFirst() : nextIterationsFromUnrolling.peekFirst();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return null;</span>
          }
      }
  
      protected static class LoopExplosionState {
          public final FrameState state;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 317,11 ***</span>
      @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
      protected static final class ProxyPlaceholder extends FloatingNode implements Canonicalizable {
          public static final NodeClass&lt;ProxyPlaceholder&gt; TYPE = NodeClass.create(ProxyPlaceholder.class);
  
          @Input ValueNode value;
<span class="line-modified">!         @Input(InputType.Unchecked) Node proxyPoint;</span>
  
          public ProxyPlaceholder(ValueNode value, MergeNode proxyPoint) {
              super(TYPE, value.stamp(NodeView.DEFAULT));
              this.value = value;
              this.proxyPoint = proxyPoint;
<span class="line-new-header">--- 411,11 ---</span>
      @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
      protected static final class ProxyPlaceholder extends FloatingNode implements Canonicalizable {
          public static final NodeClass&lt;ProxyPlaceholder&gt; TYPE = NodeClass.create(ProxyPlaceholder.class);
  
          @Input ValueNode value;
<span class="line-modified">!         @Input(InputType.Association) Node proxyPoint;</span>
  
          public ProxyPlaceholder(ValueNode value, MergeNode proxyPoint) {
              super(TYPE, value.stamp(NodeView.DEFAULT));
              this.value = value;
              this.proxyPoint = proxyPoint;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,35 ***</span>
          while (loopScope != null) {
              MethodScope methodScope = loopScope.methodScope;
  
              /* Process loops of method. */
              while (loopScope != null) {
<span class="line-removed">- </span>
                  /* Process nodes of loop. */
                  while (!loopScope.nodesToProcess.isEmpty()) {
                      loopScope = processNextNode(methodScope, loopScope);
                      methodScope = loopScope.methodScope;
                      /*
                       * We can have entered a new loop, and we can have entered a new inlined method.
                       */
                  }
  
                  /* Finished with a loop. */
<span class="line-modified">!                 if (loopScope.nextIterations != null &amp;&amp; !loopScope.nextIterations.isEmpty()) {</span>
<span class="line-modified">!                     /* Loop explosion: process the loop iteration. */</span>
<span class="line-removed">-                     assert loopScope.nextIterations.peekFirst().loopIteration == loopScope.loopIteration + 1;</span>
<span class="line-removed">-                     loopScope = loopScope.nextIterations.removeFirst();</span>
                  } else {
                      propagateCreatedNodes(loopScope);
                      loopScope = loopScope.outer;
                  }
              }
  
              /*
               * Finished with an inlined method. Perform end-of-method cleanup tasks.
               */
<span class="line-modified">!             if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE) {</span>
                  LoopDetector loopDetector = new LoopDetector(graph, methodScope);
                  loopDetector.run();
              }
              if (methodScope.isInlinedMethod()) {
                  finishInlining(methodScope);
<span class="line-new-header">--- 501,32 ---</span>
          while (loopScope != null) {
              MethodScope methodScope = loopScope.methodScope;
  
              /* Process loops of method. */
              while (loopScope != null) {
                  /* Process nodes of loop. */
                  while (!loopScope.nodesToProcess.isEmpty()) {
                      loopScope = processNextNode(methodScope, loopScope);
                      methodScope = loopScope.methodScope;
                      /*
                       * We can have entered a new loop, and we can have entered a new inlined method.
                       */
                  }
  
                  /* Finished with a loop. */
<span class="line-modified">!                 if (loopScope.hasIterationsToProcess()) {</span>
<span class="line-modified">!                     loopScope = loopScope.getNextIterationToProcess(true);</span>
                  } else {
                      propagateCreatedNodes(loopScope);
                      loopScope = loopScope.outer;
                  }
              }
  
              /*
               * Finished with an inlined method. Perform end-of-method cleanup tasks.
               */
<span class="line-modified">!             if (methodScope.loopExplosion.mergeLoops()) {</span>
                  LoopDetector loopDetector = new LoopDetector(graph, methodScope);
                  loopDetector.run();
              }
              if (methodScope.isInlinedMethod()) {
                  finishInlining(methodScope);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 460,23 ***</span>
                  loopScope.outer.createdNodes[i] = loopScope.createdNodes[i];
              }
          }
      }
  
      protected LoopScope processNextNode(MethodScope methodScope, LoopScope loopScope) {
          int nodeOrderId = loopScope.nodesToProcess.nextSetBit(0);
          loopScope.nodesToProcess.clear(nodeOrderId);
  
          FixedNode node = (FixedNode) lookupNode(loopScope, nodeOrderId);
          if (node.isDeleted()) {
              return loopScope;
          }
<span class="line-modified">! </span>
          if ((node instanceof MergeNode ||
<span class="line-modified">!                         (node instanceof LoopBeginNode &amp;&amp; (methodScope.loopExplosion == LoopExplosionKind.FULL_UNROLL || methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE ||</span>
<span class="line-modified">!                                         methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN))) &amp;&amp;</span>
                          ((AbstractMergeNode) node).forwardEndCount() == 1) {
              AbstractMergeNode merge = (AbstractMergeNode) node;
              EndNode singleEnd = merge.forwardEndAt(0);
  
              /* Nodes that would use this merge as the guard need to use the previous block. */
              registerNode(loopScope, nodeOrderId, AbstractBeginNode.prevBegin(singleEnd), true, false);
<span class="line-new-header">--- 551,38 ---</span>
                  loopScope.outer.createdNodes[i] = loopScope.createdNodes[i];
              }
          }
      }
  
<span class="line-added">+     public static final boolean DUMP_DURING_FIXED_NODE_PROCESSING = false;</span>
<span class="line-added">+ </span>
      protected LoopScope processNextNode(MethodScope methodScope, LoopScope loopScope) {
          int nodeOrderId = loopScope.nodesToProcess.nextSetBit(0);
          loopScope.nodesToProcess.clear(nodeOrderId);
  
          FixedNode node = (FixedNode) lookupNode(loopScope, nodeOrderId);
<span class="line-added">+ </span>
          if (node.isDeleted()) {
              return loopScope;
          }
<span class="line-modified">!         if (DUMP_DURING_FIXED_NODE_PROCESSING) {</span>
<span class="line-added">+             if (node != null) {</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;Before processing node %s&quot;, node);</span>
<span class="line-added">+                 } catch (Throwable t) {</span>
<span class="line-added">+                     // swallow here, dumping uninitialized nodes can cause problems</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
          if ((node instanceof MergeNode ||
<span class="line-modified">!                         (node instanceof LoopBeginNode &amp;&amp; (methodScope.loopExplosion.unrollLoops() &amp;&amp;</span>
<span class="line-modified">!                                         !methodScope.loopExplosion.mergeLoops()))) &amp;&amp;</span>
                          ((AbstractMergeNode) node).forwardEndCount() == 1) {
<span class="line-added">+             /*</span>
<span class="line-added">+              * In case node is a loop begin and we are unrolling loops we remove the loop begin</span>
<span class="line-added">+              * since the loop will be gone after PE.</span>
<span class="line-added">+              */</span>
              AbstractMergeNode merge = (AbstractMergeNode) node;
              EndNode singleEnd = merge.forwardEndAt(0);
  
              /* Nodes that would use this merge as the guard need to use the previous block. */
              registerNode(loopScope, nodeOrderId, AbstractBeginNode.prevBegin(singleEnd), true, false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 490,22 ***</span>
          }
  
          LoopScope successorAddScope = loopScope;
          boolean updatePredecessors = true;
          if (node instanceof LoopExitNode) {
<span class="line-modified">!             if (methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN || (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE &amp;&amp; loopScope.loopDepth &gt; 1)) {</span>
                  /*
                   * We do not want to merge loop exits of inner loops. Instead, we want to keep
                   * exploding the outer loop separately for every loop exit and then merge the outer
                   * loop. Therefore, we create a new LoopScope of the outer loop for every loop exit
                   * of the inner loop.
                   */
                  LoopScope outerScope = loopScope.outer;
<span class="line-modified">!                 int nextIterationNumber = outerScope.nextIterations.isEmpty() ? outerScope.loopIteration + 1 : outerScope.nextIterations.getLast().loopIteration + 1;</span>
<span class="line-modified">!                 successorAddScope = new LoopScope(methodScope, outerScope.outer, outerScope.loopDepth, nextIterationNumber, outerScope.loopBeginOrderId,</span>
                                  outerScope.initialCreatedNodes == null ? null : Arrays.copyOf(outerScope.initialCreatedNodes, outerScope.initialCreatedNodes.length),
<span class="line-modified">!                                 Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length), outerScope.nextIterations, outerScope.iterationStates);</span>
                  checkLoopExplosionIteration(methodScope, successorAddScope);
  
                  /*
                   * Nodes that are still unprocessed in the outer scope might be merge nodes that are
                   * also reachable from the new exploded scope. Clearing them ensures that we do not
<span class="line-new-header">--- 596,27 ---</span>
          }
  
          LoopScope successorAddScope = loopScope;
          boolean updatePredecessors = true;
          if (node instanceof LoopExitNode) {
<span class="line-modified">!             if (methodScope.loopExplosion.duplicateLoopExits() || (methodScope.loopExplosion.mergeLoops() &amp;&amp; loopScope.loopDepth &gt; 1)) {</span>
                  /*
                   * We do not want to merge loop exits of inner loops. Instead, we want to keep
                   * exploding the outer loop separately for every loop exit and then merge the outer
                   * loop. Therefore, we create a new LoopScope of the outer loop for every loop exit
                   * of the inner loop.
                   */
                  LoopScope outerScope = loopScope.outer;
<span class="line-modified">!                 int nextIterationNumber = outerScope.nextIterationFromLoopExitDuplication.isEmpty() ? outerScope.loopIteration + 1</span>
<span class="line-modified">!                                 : outerScope.nextIterationFromLoopExitDuplication.getLast().loopIteration + 1;</span>
<span class="line-added">+                 successorAddScope = new LoopScope(methodScope, outerScope.outer, outerScope.loopDepth, nextIterationNumber, outerScope.loopBeginOrderId, LoopScopeTrigger.LOOP_EXIT_DUPLICATION,</span>
                                  outerScope.initialCreatedNodes == null ? null : Arrays.copyOf(outerScope.initialCreatedNodes, outerScope.initialCreatedNodes.length),
<span class="line-modified">!                                 Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),</span>
<span class="line-added">+                                 outerScope.nextIterationFromLoopExitDuplication,</span>
<span class="line-added">+                                 outerScope.nextIterationFromLoopEndDuplication,</span>
<span class="line-added">+                                 outerScope.nextIterationsFromUnrolling,</span>
<span class="line-added">+                                 outerScope.iterationStates);</span>
                  checkLoopExplosionIteration(methodScope, successorAddScope);
  
                  /*
                   * Nodes that are still unprocessed in the outer scope might be merge nodes that are
                   * also reachable from the new exploded scope. Clearing them ensures that we do not
</pre>
<hr />
<pre>
<span class="line-old-header">*** 513,15 ***</span>
                   */
                  for (int id = outerScope.nodesToProcess.nextSetBit(0); id &gt;= 0; id = outerScope.nodesToProcess.nextSetBit(id + 1)) {
                      successorAddScope.createdNodes[id] = null;
                  }
  
<span class="line-modified">!                 outerScope.nextIterations.addLast(successorAddScope);</span>
              } else {
                  successorAddScope = loopScope.outer;
              }
<span class="line-modified">!             updatePredecessors = methodScope.loopExplosion == LoopExplosionKind.NONE;</span>
          }
  
          methodScope.reader.setByteIndex(methodScope.encodedGraph.nodeStartOffsets[nodeOrderId]);
          int typeId = methodScope.reader.getUVInt();
          assert node.getNodeClass() == methodScope.encodedGraph.getNodeClasses()[typeId];
<span class="line-new-header">--- 624,15 ---</span>
                   */
                  for (int id = outerScope.nodesToProcess.nextSetBit(0); id &gt;= 0; id = outerScope.nodesToProcess.nextSetBit(id + 1)) {
                      successorAddScope.createdNodes[id] = null;
                  }
  
<span class="line-modified">!                 outerScope.nextIterationFromLoopExitDuplication.addLast(successorAddScope);</span>
              } else {
                  successorAddScope = loopScope.outer;
              }
<span class="line-modified">!             updatePredecessors = methodScope.loopExplosion.isNoExplosion();</span>
          }
  
          methodScope.reader.setByteIndex(methodScope.encodedGraph.nodeStartOffsets[nodeOrderId]);
          int typeId = methodScope.reader.getUVInt();
          assert node.getNodeClass() == methodScope.encodedGraph.getNodeClasses()[typeId];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,68 ***</span>
          readProperties(methodScope, node);
          makeSuccessorStubs(methodScope, successorAddScope, node, updatePredecessors);
  
          LoopScope resultScope = loopScope;
          if (node instanceof LoopBeginNode) {
<span class="line-modified">!             if (methodScope.loopExplosion != LoopExplosionKind.NONE) {</span>
                  handleLoopExplosionBegin(methodScope, loopScope, (LoopBeginNode) node);
              }
  
          } else if (node instanceof LoopExitNode) {
<span class="line-modified">!             if (methodScope.loopExplosion != LoopExplosionKind.NONE) {</span>
                  handleLoopExplosionProxyNodes(methodScope, loopScope, successorAddScope, (LoopExitNode) node, nodeOrderId);
              } else {
                  handleProxyNodes(methodScope, loopScope, (LoopExitNode) node);
              }
  
          } else if (node instanceof MergeNode) {
              handleMergeNode(((MergeNode) node));
<span class="line-removed">- </span>
          } else if (node instanceof AbstractEndNode) {
              LoopScope phiInputScope = loopScope;
              LoopScope phiNodeScope = loopScope;
  
<span class="line-modified">!             if (methodScope.loopExplosion != LoopExplosionKind.NONE &amp;&amp; node instanceof LoopEndNode) {</span>
<span class="line-modified">!                 node = handleLoopExplosionEnd(methodScope, loopScope, (LoopEndNode) node);</span>
<span class="line-modified">!                 phiNodeScope = loopScope.nextIterations.getLast();</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             int mergeOrderId = readOrderId(methodScope);</span>
              AbstractMergeNode merge = (AbstractMergeNode) lookupNode(phiNodeScope, mergeOrderId);
              if (merge == null) {
                  merge = (AbstractMergeNode) makeStubNode(methodScope, phiNodeScope, mergeOrderId);
<span class="line-removed">- </span>
                  if (merge instanceof LoopBeginNode) {
                      assert phiNodeScope == phiInputScope &amp;&amp; phiNodeScope == loopScope;
<span class="line-modified">!                     resultScope = new LoopScope(methodScope, loopScope, loopScope.loopDepth + 1, 0, mergeOrderId,</span>
<span class="line-modified">!                                     methodScope.loopExplosion != LoopExplosionKind.NONE ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : null,</span>
<span class="line-modified">!                                     methodScope.loopExplosion != LoopExplosionKind.NONE ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : loopScope.createdNodes, //</span>
<span class="line-modified">!                                     methodScope.loopExplosion != LoopExplosionKind.NONE ? new ArrayDeque&lt;&gt;(2) : null, //</span>
<span class="line-modified">!                                     methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE ? EconomicMap.create(Equivalence.DEFAULT) : null);</span>
                      phiInputScope = resultScope;
                      phiNodeScope = resultScope;
  
<span class="line-modified">!                     if (methodScope.loopExplosion != LoopExplosionKind.NONE) {</span>
                          registerNode(loopScope, mergeOrderId, null, true, true);
                      }
                      loopScope.nodesToProcess.clear(mergeOrderId);
                      resultScope.nodesToProcess.set(mergeOrderId);
                  }
              }
<span class="line-removed">- </span>
              handlePhiFunctions(methodScope, phiInputScope, phiNodeScope, (AbstractEndNode) node, merge);
<span class="line-removed">- </span>
          } else if (node instanceof Invoke) {
              InvokeData invokeData = readInvokeData(methodScope, nodeOrderId, (Invoke) node);
              resultScope = handleInvoke(methodScope, loopScope, invokeData);
<span class="line-removed">- </span>
          } else if (node instanceof ReturnNode || node instanceof UnwindNode) {
              methodScope.returnAndUnwindNodes.add((ControlSinkNode) node);
          } else {
              handleFixedNode(methodScope, loopScope, nodeOrderId, node);
          }
<span class="line-modified">! </span>
          return resultScope;
      }
  
      protected InvokeData readInvokeData(MethodScope methodScope, int invokeOrderId, Invoke invoke) {
          ResolvedJavaType contextType = (ResolvedJavaType) readObject(methodScope);
<span class="line-new-header">--- 640,137 ---</span>
          readProperties(methodScope, node);
          makeSuccessorStubs(methodScope, successorAddScope, node, updatePredecessors);
  
          LoopScope resultScope = loopScope;
          if (node instanceof LoopBeginNode) {
<span class="line-modified">!             if (methodScope.loopExplosion.useExplosion()) {</span>
                  handleLoopExplosionBegin(methodScope, loopScope, (LoopBeginNode) node);
              }
  
          } else if (node instanceof LoopExitNode) {
<span class="line-modified">!             if (methodScope.loopExplosion.useExplosion()) {</span>
                  handleLoopExplosionProxyNodes(methodScope, loopScope, successorAddScope, (LoopExitNode) node, nodeOrderId);
              } else {
                  handleProxyNodes(methodScope, loopScope, (LoopExitNode) node);
              }
  
          } else if (node instanceof MergeNode) {
              handleMergeNode(((MergeNode) node));
          } else if (node instanceof AbstractEndNode) {
              LoopScope phiInputScope = loopScope;
              LoopScope phiNodeScope = loopScope;
<span class="line-added">+             int mergeOrderId = readOrderId(methodScope);</span>
  
<span class="line-modified">!             boolean requiresMergeOfOuterLoop = methodScope.loopExplosion.unrollLoops() &amp;&amp;</span>
<span class="line-modified">!                             methodScope.loopExplosion.duplicateLoopExits() &amp;&amp;</span>
<span class="line-modified">!                             (!methodScope.loopExplosion.duplicateLoopEnds()) &amp;&amp;</span>
<span class="line-modified">!                             (!methodScope.loopExplosion.mergeLoops()) &amp;&amp;</span>
<span class="line-added">+                             node instanceof LoopEndNode &amp;&amp;</span>
<span class="line-added">+                             loopScope.trigger == LoopScopeTrigger.LOOP_EXIT_DUPLICATION;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (requiresMergeOfOuterLoop) {</span>
<span class="line-added">+                 EndNode replacementNode = graph.add(new EndNode());</span>
<span class="line-added">+                 node.replaceAtPredecessor(replacementNode);</span>
<span class="line-added">+                 node.safeDelete();</span>
<span class="line-added">+                 node = replacementNode;</span>
<span class="line-added">+                 /*</span>
<span class="line-added">+                  * We are in a loop exit duplicated loop scope and see a loop end node, this can</span>
<span class="line-added">+                  * only happen if we have a loop end to an outer loop. When duplicating over loop</span>
<span class="line-added">+                  * exits we have to merge outer loops for nested inner loops.</span>
<span class="line-added">+                  *</span>
<span class="line-added">+                  * Therefore, we create a correct outer loop iteration and check if there is already</span>
<span class="line-added">+                  * one, if not we create it else we re-use it.</span>
<span class="line-added">+                  */</span>
<span class="line-added">+                 if (loopScope.nextIterationsFromUnrolling.isEmpty()) {</span>
<span class="line-added">+                     // create it</span>
<span class="line-added">+                     int nextIterationNumber = loopScope.nextIterationsFromUnrolling.isEmpty() ? loopScope.loopIteration + 1 : loopScope.nextIterationsFromUnrolling.getLast().loopIteration + 1;</span>
<span class="line-added">+                     LoopScope outerLoopMergeScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId,</span>
<span class="line-added">+                                     LoopScopeTrigger.LOOP_BEGIN_UNROLLING,</span>
<span class="line-added">+                                     Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),</span>
<span class="line-added">+                                     Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),</span>
<span class="line-added">+                                     loopScope.nextIterationFromLoopExitDuplication,</span>
<span class="line-added">+                                     loopScope.nextIterationFromLoopEndDuplication,</span>
<span class="line-added">+                                     loopScope.nextIterationsFromUnrolling,</span>
<span class="line-added">+                                     loopScope.iterationStates);</span>
<span class="line-added">+                     checkLoopExplosionIteration(methodScope, outerLoopMergeScope);</span>
<span class="line-added">+                     loopScope.nextIterationsFromUnrolling.addLast(outerLoopMergeScope);</span>
<span class="line-added">+                     registerNode(outerLoopMergeScope, loopScope.loopBeginOrderId, null, true, true);</span>
<span class="line-added">+                     makeStubNode(methodScope, outerLoopMergeScope, loopScope.loopBeginOrderId);</span>
<span class="line-added">+                     phiNodeScope = outerLoopMergeScope;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // re-use it</span>
<span class="line-added">+                     phiNodeScope = loopScope.nextIterationsFromUnrolling.getLast();</span>
<span class="line-added">+                 }</span>
  
<span class="line-modified">!             } else if (methodScope.loopExplosion.useExplosion() &amp;&amp; node instanceof LoopEndNode) {</span>
<span class="line-added">+                 EndNode replacementNode = graph.add(new EndNode());</span>
<span class="line-added">+                 node.replaceAtPredecessor(replacementNode);</span>
<span class="line-added">+                 node.safeDelete();</span>
<span class="line-added">+                 node = replacementNode;</span>
<span class="line-added">+                 LoopScopeTrigger trigger = handleLoopExplosionEnd(methodScope, loopScope);</span>
<span class="line-added">+                 Deque&lt;LoopScope&gt; phiScope = loopScope.nextIterationsFromUnrolling;</span>
<span class="line-added">+                 if (trigger == LoopScopeTrigger.LOOP_END_DUPLICATION) {</span>
<span class="line-added">+                     phiScope = loopScope.nextIterationFromLoopEndDuplication;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 phiNodeScope = phiScope.getLast();</span>
<span class="line-added">+             }</span>
              AbstractMergeNode merge = (AbstractMergeNode) lookupNode(phiNodeScope, mergeOrderId);
              if (merge == null) {
                  merge = (AbstractMergeNode) makeStubNode(methodScope, phiNodeScope, mergeOrderId);
                  if (merge instanceof LoopBeginNode) {
<span class="line-added">+                     /*</span>
<span class="line-added">+                      * In contrast to the LoopScopeTrigger.START created at the beginning of every</span>
<span class="line-added">+                      * PE, we see a real loop here and create the first real loop scope associated</span>
<span class="line-added">+                      * with a loop.</span>
<span class="line-added">+                      *</span>
<span class="line-added">+                      * Creation of a loop scope if we reach a loop begin node. We process a loop</span>
<span class="line-added">+                      * begin node (always before encountering a loop end associated with the loop</span>
<span class="line-added">+                      * begin) and simply create a normal loop scope. This does not imply an advanced</span>
<span class="line-added">+                      * unrolling strategy (however it can later if we see duplicate over loop end or</span>
<span class="line-added">+                      * exits). Therefore, we still use the start marker here, we could also use the</span>
<span class="line-added">+                      * unrolling marker.</span>
<span class="line-added">+                      *</span>
<span class="line-added">+                      * If we unroll loops we will later remove the loop begin node and replace it</span>
<span class="line-added">+                      * with its forward end (since we do not need to create a loop begin node if we</span>
<span class="line-added">+                      * unroll the entire loop and it has a constant trip count).</span>
<span class="line-added">+                      */</span>
                      assert phiNodeScope == phiInputScope &amp;&amp; phiNodeScope == loopScope;
<span class="line-modified">!                     resultScope = new LoopScope(methodScope, loopScope, loopScope.loopDepth + 1, 0, mergeOrderId, LoopScopeTrigger.START,</span>
<span class="line-modified">!                                     methodScope.loopExplosion.useExplosion() ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : null,</span>
<span class="line-modified">!                                     methodScope.loopExplosion.useExplosion() ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : loopScope.createdNodes, //</span>
<span class="line-modified">!                                     methodScope.loopExplosion.duplicateLoopExits() || methodScope.loopExplosion.mergeLoops() ? new ArrayDeque&lt;&gt;(2) : null,</span>
<span class="line-modified">!                                     methodScope.loopExplosion.duplicateLoopEnds() ? new ArrayDeque&lt;&gt;(2) : null,</span>
<span class="line-added">+                                     methodScope.loopExplosion.unrollLoops() ? new ArrayDeque&lt;&gt;(2) : null, //</span>
<span class="line-added">+                                     methodScope.loopExplosion.mergeLoops() ? EconomicMap.create(Equivalence.DEFAULT) : null);</span>
                      phiInputScope = resultScope;
                      phiNodeScope = resultScope;
  
<span class="line-modified">!                     if (methodScope.loopExplosion.useExplosion()) {</span>
                          registerNode(loopScope, mergeOrderId, null, true, true);
                      }
                      loopScope.nodesToProcess.clear(mergeOrderId);
                      resultScope.nodesToProcess.set(mergeOrderId);
                  }
              }
              handlePhiFunctions(methodScope, phiInputScope, phiNodeScope, (AbstractEndNode) node, merge);
          } else if (node instanceof Invoke) {
              InvokeData invokeData = readInvokeData(methodScope, nodeOrderId, (Invoke) node);
              resultScope = handleInvoke(methodScope, loopScope, invokeData);
          } else if (node instanceof ReturnNode || node instanceof UnwindNode) {
              methodScope.returnAndUnwindNodes.add((ControlSinkNode) node);
          } else {
              handleFixedNode(methodScope, loopScope, nodeOrderId, node);
          }
<span class="line-modified">!         if (DUMP_DURING_FIXED_NODE_PROCESSING) {</span>
<span class="line-added">+             if (node != null) {</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;After processing node %s&quot;, node);</span>
<span class="line-added">+                 } catch (Throwable t) {</span>
<span class="line-added">+                     // swallow here, dumping uninitialized nodes can cause problems</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
          return resultScope;
      }
  
      protected InvokeData readInvokeData(MethodScope methodScope, int invokeOrderId, Invoke invoke) {
          ResolvedJavaType contextType = (ResolvedJavaType) readObject(methodScope);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 656,11 ***</span>
  
          List&lt;EndNode&gt; predecessors = loopBegin.forwardEnds().snapshot();
          FixedNode successor = loopBegin.next();
          FrameState frameState = loopBegin.stateAfter();
  
<span class="line-modified">!         if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE) {</span>
              LoopExplosionState queryState = new LoopExplosionState(frameState, null);
              LoopExplosionState existingState = loopScope.iterationStates.get(queryState);
              if (existingState != null) {
                  loopBegin.replaceAtUsagesAndDelete(existingState.merge);
                  successor.safeDelete();
<span class="line-new-header">--- 836,11 ---</span>
  
          List&lt;EndNode&gt; predecessors = loopBegin.forwardEnds().snapshot();
          FixedNode successor = loopBegin.next();
          FrameState frameState = loopBegin.stateAfter();
  
<span class="line-modified">!         if (methodScope.loopExplosion.mergeLoops()) {</span>
              LoopExplosionState queryState = new LoopExplosionState(frameState, null);
              LoopExplosionState existingState = loopScope.iterationStates.get(queryState);
              if (existingState != null) {
                  loopBegin.replaceAtUsagesAndDelete(existingState.merge);
                  successor.safeDelete();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 672,11 ***</span>
          }
  
          MergeNode merge = graph.add(new MergeNode());
          methodScope.loopExplosionMerges.add(merge);
  
<span class="line-modified">!         if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE) {</span>
              if (loopScope.iterationStates.size() == 0 &amp;&amp; loopScope.loopDepth == 1) {
                  if (methodScope.loopExplosionHead != null) {
                      throw new PermanentBailoutException(&quot;Graal implementation restriction: Method with %s loop explosion must not have more than one top-level loop&quot;, LoopExplosionKind.MERGE_EXPLODE);
                  }
                  methodScope.loopExplosionHead = merge;
<span class="line-new-header">--- 852,11 ---</span>
          }
  
          MergeNode merge = graph.add(new MergeNode());
          methodScope.loopExplosionMerges.add(merge);
  
<span class="line-modified">!         if (methodScope.loopExplosion.mergeLoops()) {</span>
              if (loopScope.iterationStates.size() == 0 &amp;&amp; loopScope.loopDepth == 1) {
                  if (methodScope.loopExplosionHead != null) {
                      throw new PermanentBailoutException(&quot;Graal implementation restriction: Method with %s loop explosion must not have more than one top-level loop&quot;, LoopExplosionKind.MERGE_EXPLODE);
                  }
                  methodScope.loopExplosionHead = merge;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 723,11 ***</span>
          merge.setNext(successor);
          for (EndNode predecessor : predecessors) {
              merge.addForwardEnd(predecessor);
          }
  
<span class="line-modified">!         if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE) {</span>
              LoopExplosionState explosionState = new LoopExplosionState(frameState, merge);
              loopScope.iterationStates.put(explosionState, explosionState);
          }
      }
  
<span class="line-new-header">--- 903,11 ---</span>
          merge.setNext(successor);
          for (EndNode predecessor : predecessors) {
              merge.addForwardEnd(predecessor);
          }
  
<span class="line-modified">!         if (methodScope.loopExplosion.mergeLoops()) {</span>
              LoopExplosionState explosionState = new LoopExplosionState(frameState, merge);
              loopScope.iterationStates.put(explosionState, explosionState);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 739,27 ***</span>
       */
      protected void checkLoopExplosionIteration(MethodScope methodScope, LoopScope loopScope) {
          throw shouldNotReachHere(&quot;when subclass uses loop explosion, it needs to implement this method&quot;);
      }
  
<span class="line-modified">!     protected FixedNode handleLoopExplosionEnd(MethodScope methodScope, LoopScope loopScope, LoopEndNode loopEnd) {</span>
<span class="line-modified">!         EndNode replacementNode = graph.add(new EndNode());</span>
<span class="line-modified">!         loopEnd.replaceAtPredecessor(replacementNode);</span>
<span class="line-modified">!         loopEnd.safeDelete();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         assert methodScope.loopExplosion != LoopExplosionKind.NONE;</span>
<span class="line-modified">!         if (methodScope.loopExplosion != LoopExplosionKind.FULL_UNROLL || loopScope.nextIterations.isEmpty()) {</span>
<span class="line-modified">!             int nextIterationNumber = loopScope.nextIterations.isEmpty() ? loopScope.loopIteration + 1 : loopScope.nextIterations.getLast().loopIteration + 1;</span>
<span class="line-modified">!             LoopScope nextIterationScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId,</span>
                              Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
<span class="line-modified">!                             Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length), loopScope.nextIterations, loopScope.iterationStates);</span>
              checkLoopExplosionIteration(methodScope, nextIterationScope);
<span class="line-modified">!             loopScope.nextIterations.addLast(nextIterationScope);</span>
              registerNode(nextIterationScope, loopScope.loopBeginOrderId, null, true, true);
              makeStubNode(methodScope, nextIterationScope, loopScope.loopBeginOrderId);
          }
<span class="line-modified">!         return replacementNode;</span>
      }
  
      /**
       * Hook for subclasses.
       *
<span class="line-new-header">--- 919,48 ---</span>
       */
      protected void checkLoopExplosionIteration(MethodScope methodScope, LoopScope loopScope) {
          throw shouldNotReachHere(&quot;when subclass uses loop explosion, it needs to implement this method&quot;);
      }
  
<span class="line-modified">!     protected LoopScopeTrigger handleLoopExplosionEnd(MethodScope methodScope, LoopScope loopScope) {</span>
<span class="line-modified">!         /*</span>
<span class="line-modified">!          * This method is only called if we reach a loop end and we use some kind of loop explosion,</span>
<span class="line-modified">!          * i.e., we unroll loops or explode along loop ends.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         LoopScopeTrigger trigger = null;</span>
<span class="line-modified">!         Deque&lt;LoopScope&gt; nextIterations = null;</span>
<span class="line-modified">!         if (methodScope.loopExplosion.duplicateLoopEnds()) {</span>
<span class="line-modified">!             /*</span>
<span class="line-added">+              * Loop explosion along loop ends: We see a loop end, however we do not merge all loop</span>
<span class="line-added">+              * ends at a common merge node but rather duplicate the rest of the loop for every loop</span>
<span class="line-added">+              * end.</span>
<span class="line-added">+              */</span>
<span class="line-added">+             trigger = LoopScopeTrigger.LOOP_END_DUPLICATION;</span>
<span class="line-added">+             nextIterations = loopScope.nextIterationFromLoopEndDuplication;</span>
<span class="line-added">+         } else if (loopScope.nextIterationsFromUnrolling.isEmpty()) {</span>
<span class="line-added">+             /*</span>
<span class="line-added">+              * Regular loop unrolling, i.e., we reach a loop end node of a loop that should be</span>
<span class="line-added">+              * unrolled: We create a new successor scope.</span>
<span class="line-added">+              */</span>
<span class="line-added">+             trigger = LoopScopeTrigger.LOOP_BEGIN_UNROLLING;</span>
<span class="line-added">+             nextIterations = loopScope.nextIterationsFromUnrolling;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (trigger != null) {</span>
<span class="line-added">+             int nextIterationNumber = nextIterations.isEmpty() ? loopScope.loopIteration + 1 : nextIterations.getLast().loopIteration + 1;</span>
<span class="line-added">+             LoopScope nextIterationScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId, trigger,</span>
                              Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
<span class="line-modified">!                             Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),</span>
<span class="line-added">+                             loopScope.nextIterationFromLoopExitDuplication,</span>
<span class="line-added">+                             loopScope.nextIterationFromLoopEndDuplication,</span>
<span class="line-added">+                             loopScope.nextIterationsFromUnrolling,</span>
<span class="line-added">+                             loopScope.iterationStates);</span>
              checkLoopExplosionIteration(methodScope, nextIterationScope);
<span class="line-modified">!             nextIterations.addLast(nextIterationScope);</span>
              registerNode(nextIterationScope, loopScope.loopBeginOrderId, null, true, true);
              makeStubNode(methodScope, nextIterationScope, loopScope.loopBeginOrderId);
          }
<span class="line-modified">!         return trigger;</span>
      }
  
      /**
       * Hook for subclasses.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 798,11 ***</span>
  
          FixedNode loopExitSuccessor = loopExit.next();
          loopExit.replaceAtPredecessor(begin);
  
          MergeNode loopExitPlaceholder = null;
<span class="line-modified">!         if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE &amp;&amp; loopScope.loopDepth == 1) {</span>
              /*
               * This exit might end up as a loop exit of a loop detected after partial evaluation. We
               * need to be able to create a FrameState and the necessary proxy nodes in this case.
               */
              loopExitPlaceholder = graph.add(new MergeNode());
<span class="line-new-header">--- 999,11 ---</span>
  
          FixedNode loopExitSuccessor = loopExit.next();
          loopExit.replaceAtPredecessor(begin);
  
          MergeNode loopExitPlaceholder = null;
<span class="line-modified">!         if (methodScope.loopExplosion.mergeLoops() &amp;&amp; loopScope.loopDepth == 1) {</span>
              /*
               * This exit might end up as a loop exit of a loop detected after partial evaluation. We
               * need to be able to create a FrameState and the necessary proxy nodes in this case.
               */
              loopExitPlaceholder = graph.add(new MergeNode());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 876,37 ***</span>
                   * We do not need a phi node yet.
                   */
                  registerNode(outerScope, proxyOrderId, phiInput, true, false);
                  replacement = phiInput;
  
<span class="line-modified">!             } else if (!merge.isPhiAtMerge(existing)) {</span>
<span class="line-modified">!                 /* Now we have two different values, so we need to create a phi node. */</span>
<span class="line-modified">!                 PhiNode phi;</span>
<span class="line-modified">!                 if (proxy instanceof ValueProxyNode) {</span>
<span class="line-modified">!                     phi = graph.addWithoutUnique(new ValuePhiNode(proxy.stamp(NodeView.DEFAULT), merge));</span>
<span class="line-modified">!                 } else if (proxy instanceof GuardProxyNode) {</span>
<span class="line-modified">!                     phi = graph.addWithoutUnique(new GuardPhiNode(merge));</span>
                  } else {
<span class="line-modified">!                     throw GraalError.shouldNotReachHere();</span>
                  }
<span class="line-removed">-                 /* Add the inputs from all previous exits. */</span>
<span class="line-removed">-                 for (int j = 0; j &lt; merge.phiPredecessorCount() - 1; j++) {</span>
<span class="line-removed">-                     phi.addInput(existing);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 /* Add the input from this exit. */</span>
<span class="line-removed">-                 phi.addInput(phiInput);</span>
<span class="line-removed">-                 registerNode(outerScope, proxyOrderId, phi, true, false);</span>
<span class="line-removed">-                 replacement = phi;</span>
<span class="line-removed">-                 phiCreated = true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 /* Phi node has been created before, so just add the new input. */</span>
<span class="line-removed">-                 PhiNode phi = (PhiNode) existing;</span>
<span class="line-removed">-                 phi.addInput(phiInput);</span>
<span class="line-removed">-                 replacement = phi;</span>
              }
<span class="line-removed">- </span>
              proxy.replaceAtUsagesAndDelete(replacement);
          }
  
          if (loopExitPlaceholder != null) {
              registerNode(loopScope, stateAfterOrderId, null, true, true);
<span class="line-new-header">--- 1077,34 ---</span>
                   * We do not need a phi node yet.
                   */
                  registerNode(outerScope, proxyOrderId, phiInput, true, false);
                  replacement = phiInput;
  
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 // Fortify: Suppress Null Dereference false positive</span>
<span class="line-modified">!                 assert merge != null;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 if (!merge.isPhiAtMerge(existing)) {</span>
<span class="line-modified">!                     /* Now we have two different values, so we need to create a phi node. */</span>
<span class="line-modified">!                     PhiNode phi = proxy.createPhi(merge);</span>
<span class="line-added">+                     /* Add the inputs from all previous exits. */</span>
<span class="line-added">+                     for (int j = 0; j &lt; merge.phiPredecessorCount() - 1; j++) {</span>
<span class="line-added">+                         phi.addInput(existing);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     /* Add the input from this exit. */</span>
<span class="line-added">+                     phi.addInput(phiInput);</span>
<span class="line-added">+                     registerNode(outerScope, proxyOrderId, phi, true, false);</span>
<span class="line-added">+                     replacement = phi;</span>
<span class="line-added">+                     phiCreated = true;</span>
<span class="line-added">+ </span>
                  } else {
<span class="line-modified">!                     /* Phi node has been created before, so just add the new input. */</span>
<span class="line-added">+                     PhiNode phi = (PhiNode) existing;</span>
<span class="line-added">+                     phi.addInput(phiInput);</span>
<span class="line-added">+                     replacement = phi;</span>
                  }
              }
              proxy.replaceAtUsagesAndDelete(replacement);
          }
  
          if (loopExitPlaceholder != null) {
              registerNode(loopScope, stateAfterOrderId, null, true, true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 956,11 ***</span>
           * processing the merge node, we have the final phi function when processing the merge node.
           * The only exception are loop headers of non-exploded loops: since backward branches are
           * not processed yet when processing the loop body, we need to create all phi functions
           * upfront.
           */
<span class="line-modified">!         boolean lazyPhi = allowLazyPhis() &amp;&amp; (!(merge instanceof LoopBeginNode) || methodScope.loopExplosion != LoopExplosionKind.NONE);</span>
          int numPhis = methodScope.reader.getUVInt();
          for (int i = 0; i &lt; numPhis; i++) {
              int phiInputOrderId = readOrderId(methodScope);
              int phiNodeOrderId = readOrderId(methodScope);
  
<span class="line-new-header">--- 1154,11 ---</span>
           * processing the merge node, we have the final phi function when processing the merge node.
           * The only exception are loop headers of non-exploded loops: since backward branches are
           * not processed yet when processing the loop body, we need to create all phi functions
           * upfront.
           */
<span class="line-modified">!         boolean lazyPhi = allowLazyPhis() &amp;&amp; (!(merge instanceof LoopBeginNode) || methodScope.loopExplosion.useExplosion());</span>
          int numPhis = methodScope.reader.getUVInt();
          for (int i = 0; i &lt; numPhis; i++) {
              int phiInputOrderId = readOrderId(methodScope);
              int phiNodeOrderId = readOrderId(methodScope);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 975,11 ***</span>
                   * which starts with a clone of the values that were created before the loop, sees
                   * the stale value when processing the merge the first time. We can safely ignore
                   * the stale value because it will never be needed to be merged (we are exploding
                   * until we hit a return).
                   */
<span class="line-modified">!                 assert methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN &amp;&amp; phiNodeScope.loopIteration &gt; 0;</span>
                  existing = null;
              }
  
              if (lazyPhi &amp;&amp; (existing == null || existing == phiInput)) {
                  /* Phi function not yet necessary. */
<span class="line-new-header">--- 1173,11 ---</span>
                   * which starts with a clone of the values that were created before the loop, sees
                   * the stale value when processing the merge the first time. We can safely ignore
                   * the stale value because it will never be needed to be merged (we are exploding
                   * until we hit a return).
                   */
<span class="line-modified">!                 assert methodScope.loopExplosion.duplicateLoopExits() &amp;&amp; phiNodeScope.loopIteration &gt; 0;</span>
                  existing = null;
              }
  
              if (lazyPhi &amp;&amp; (existing == null || existing == phiInput)) {
                  /* Phi function not yet necessary. */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1330,10 ***</span>
<span class="line-new-header">--- 1528,15 ---</span>
       * Removes unnecessary nodes from the graph after decoding.
       *
       * @param methodScope The current method.
       */
      protected void cleanupGraph(MethodScope methodScope) {
<span class="line-added">+         for (MergeNode merge : graph.getNodes(MergeNode.TYPE)) {</span>
<span class="line-added">+             for (ProxyPlaceholder placeholder : merge.usages().filter(ProxyPlaceholder.class).snapshot()) {</span>
<span class="line-added">+                 placeholder.replaceAndDelete(placeholder.value);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
          assert verifyEdges();
      }
  
      protected boolean verifyEdges() {
          for (Node node : graph.getNodes()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1744,11 ***</span>
                   */
                  GraalError.guarantee(value instanceof ProxyPlaceholder &amp;&amp; ((ProxyPlaceholder) value).proxyPoint == loopExplosionMerge,
                                  &quot;Value flowing out of loop, but we are not prepared to insert a ProxyNode&quot;);
  
                  ProxyPlaceholder proxyPlaceholder = (ProxyPlaceholder) value;
<span class="line-modified">!                 ValueProxyNode proxy = ProxyNode.forValue(proxyPlaceholder.value, loopExit, graph);</span>
                  proxyPlaceholder.setValue(proxy);
                  newValues.add(proxy);
              }
          }
  
<span class="line-new-header">--- 1947,11 ---</span>
                   */
                  GraalError.guarantee(value instanceof ProxyPlaceholder &amp;&amp; ((ProxyPlaceholder) value).proxyPoint == loopExplosionMerge,
                                  &quot;Value flowing out of loop, but we are not prepared to insert a ProxyNode&quot;);
  
                  ProxyPlaceholder proxyPlaceholder = (ProxyPlaceholder) value;
<span class="line-modified">!                 ValueProxyNode proxy = ProxyNode.forValue(proxyPlaceholder.value, loopExit);</span>
                  proxyPlaceholder.setValue(proxy);
                  newValues.add(proxy);
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1812,10 ***</span>
<span class="line-new-header">--- 2015,11 ---</span>
                  loopValue = curLoopValue;
                  explosionHeadValue = curExplosionHeadValue;
              }
          }
          assert loopVariableIndex != -1;
<span class="line-added">+         assert explosionHeadValue != null;</span>
  
          ValuePhiNode loopVariablePhi;
          SortedMap&lt;Integer, AbstractBeginNode&gt; dispatchTable = new TreeMap&lt;&gt;();
          AbstractBeginNode unreachableDefaultSuccessor;
          if (irreducibleLoopSwitch == null) {
</pre>
<center><a href="FrameState.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphEncoder.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
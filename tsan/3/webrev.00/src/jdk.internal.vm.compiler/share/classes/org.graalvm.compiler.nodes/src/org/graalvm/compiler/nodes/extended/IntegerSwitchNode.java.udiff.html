<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/IntegerSwitchNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GuardedUnsafeLoadNode.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="JavaWriteNode.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/IntegerSwitchNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -34,10 +34,11 @@</span>
  import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
  import org.graalvm.compiler.core.common.type.IntegerStamp;
  import org.graalvm.compiler.core.common.type.PrimitiveStamp;
  import org.graalvm.compiler.core.common.type.Stamp;
  import org.graalvm.compiler.core.common.type.StampFactory;
<span class="udiff-line-added">+ import org.graalvm.compiler.graph.Node;</span>
  import org.graalvm.compiler.graph.NodeClass;
  import org.graalvm.compiler.graph.spi.Simplifiable;
  import org.graalvm.compiler.graph.spi.SimplifierTool;
  import org.graalvm.compiler.nodeinfo.NodeInfo;
  import org.graalvm.compiler.nodes.AbstractBeginNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -49,10 +50,11 @@</span>
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  import org.graalvm.compiler.nodes.java.LoadIndexedNode;
  import org.graalvm.compiler.nodes.spi.LIRLowerable;
  import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.spi.SwitchFoldable;</span>
  import org.graalvm.compiler.nodes.util.GraphUtil;
  
  import jdk.vm.ci.meta.DeoptimizationAction;
  import jdk.vm.ci.meta.DeoptimizationReason;
  import jdk.vm.ci.meta.JavaConstant;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61,11 +63,11 @@</span>
  /**
   * The {@code IntegerSwitchNode} represents a switch on integer keys, with a sorted array of key
   * values. The actual implementation of the switch will be decided by the backend.
   */
  @NodeInfo
<span class="udiff-line-modified-removed">- public final class IntegerSwitchNode extends SwitchNode implements LIRLowerable, Simplifiable {</span>
<span class="udiff-line-modified-added">+ public final class IntegerSwitchNode extends SwitchNode implements LIRLowerable, Simplifiable, SwitchFoldable {</span>
      public static final NodeClass&lt;IntegerSwitchNode&gt; TYPE = NodeClass.create(IntegerSwitchNode.class);
  
      protected final int[] keys;
  
      public IntegerSwitchNode(ValueNode value, AbstractBeginNode[] successors, int[] keys, double[] keyProbabilities, int[] keySuccessors) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -73,19 +75,32 @@</span>
          assert keySuccessors.length == keys.length + 1;
          assert keySuccessors.length == keyProbabilities.length;
          this.keys = keys;
          assert value.stamp(NodeView.DEFAULT) instanceof PrimitiveStamp &amp;&amp; value.stamp(NodeView.DEFAULT).getStackKind().isNumericInteger();
          assert assertSorted();
<span class="udiff-line-added">+         assert assertNoUntargettedSuccessor();</span>
      }
  
      private boolean assertSorted() {
          for (int i = 1; i &lt; keys.length; i++) {
              assert keys[i - 1] &lt; keys[i];
          }
          return true;
      }
  
<span class="udiff-line-added">+     private boolean assertNoUntargettedSuccessor() {</span>
<span class="udiff-line-added">+         boolean[] checker = new boolean[successors.size()];</span>
<span class="udiff-line-added">+         for (int successorIndex : keySuccessors) {</span>
<span class="udiff-line-added">+             checker[successorIndex] = true;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         checker[defaultSuccessorIndex()] = true;</span>
<span class="udiff-line-added">+         for (boolean b : checker) {</span>
<span class="udiff-line-added">+             assert b;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      public IntegerSwitchNode(ValueNode value, int successorCount, int[] keys, double[] keyProbabilities, int[] keySuccessors) {
          this(value, new AbstractBeginNode[successorCount], keys, keyProbabilities, keySuccessors);
      }
  
      @Override
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102,10 +117,18 @@</span>
      @Override
      public JavaConstant keyAt(int i) {
          return JavaConstant.forInt(keys[i]);
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Gets the key at the specified index, as a java int.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public int intKeyAt(int i) {</span>
<span class="udiff-line-added">+         return keys[i];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @Override
      public int keyCount() {
          return keys.length;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -146,11 +169,65 @@</span>
              killOtherSuccessors(tool, successorIndexAtKey(value().asJavaConstant().asInt()));
          } else if (tryOptimizeEnumSwitch(tool)) {
              return;
          } else if (tryRemoveUnreachableKeys(tool, value().stamp(view))) {
              return;
<span class="udiff-line-added">+         } else if (switchTransformationOptimization(tool)) {</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private void addSuccessorForDeletion(AbstractBeginNode defaultNode) {</span>
<span class="udiff-line-added">+         successors.add(defaultNode);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public Node getNextSwitchFoldableBranch() {</span>
<span class="udiff-line-added">+         return defaultSuccessor();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public boolean isInSwitch(ValueNode switchValue) {</span>
<span class="udiff-line-added">+         return value == switchValue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public void cutOffCascadeNode() {</span>
<span class="udiff-line-added">+         AbstractBeginNode toKill = defaultSuccessor();</span>
<span class="udiff-line-added">+         clearSuccessors();</span>
<span class="udiff-line-added">+         addSuccessorForDeletion(toKill);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public void cutOffLowestCascadeNode() {</span>
<span class="udiff-line-added">+         clearSuccessors();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public AbstractBeginNode getDefault() {</span>
<span class="udiff-line-added">+         return defaultSuccessor();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public ValueNode switchValue() {</span>
<span class="udiff-line-added">+         return value();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public boolean isNonInitializedProfile() {</span>
<span class="udiff-line-added">+         int nbSuccessors = getSuccessorCount();</span>
<span class="udiff-line-added">+         double prob = 0.0d;</span>
<span class="udiff-line-added">+         for (int i = 0; i &lt; nbSuccessors; i++) {</span>
<span class="udiff-line-added">+             if (keyProbabilities[i] &gt; 0.0d) {</span>
<span class="udiff-line-added">+                 if (prob == 0.0d) {</span>
<span class="udiff-line-added">+                     prob = keyProbabilities[i];</span>
<span class="udiff-line-added">+                 } else if (keyProbabilities[i] != prob) {</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
          }
<span class="udiff-line-added">+         return true;</span>
      }
  
      static final class KeyData {
          final int key;
          final double keyProbability;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -206,11 +283,11 @@</span>
      /**
       * For switch statements on enum values, the Java compiler has to generate complicated code:
       * because {@link Enum#ordinal()} can change when recompiling an enum, it cannot be used
       * directly as the value that is switched on. An intermediate int[] array, which is initialized
       * once at run time based on the actual {@link Enum#ordinal()} values, is used.
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-added">+      * &lt;p&gt;</span>
       * The {@link ConstantFieldProvider} of Graal already detects the int[] arrays and marks them as
       * {@link ConstantNode#isDefaultStable() stable}, i.e., the array elements are constant. The
       * code in this method detects array loads from such a stable array and re-wires the switch to
       * use the keys from the array elements, so that the array load is unnecessary.
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -218,11 +295,11 @@</span>
          if (!(value() instanceof LoadIndexedNode)) {
              /* Not the switch pattern we are looking for. */
              return false;
          }
          LoadIndexedNode loadIndexed = (LoadIndexedNode) value();
<span class="udiff-line-modified-removed">-         if (loadIndexed.usages().count() &gt; 1) {</span>
<span class="udiff-line-modified-added">+         if (loadIndexed.hasMoreThanOneUsage()) {</span>
              /*
               * The array load is necessary for other reasons too, so there is no benefit optimizing
               * the switch.
               */
              return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -350,32 +427,32 @@</span>
                  newKeyProbabilities[i] = 1.0 / newKeyProbabilities.length;
              }
          }
  
          /*
<span class="udiff-line-modified-removed">-          * Collect dead successors. Successors have to be cleaned before adding the new node to the</span>
<span class="udiff-line-modified-removed">-          * graph.</span>
<span class="udiff-line-modified-added">+          * Surviving successors have to be cleaned before adding the new node to the graph. Keep the</span>
<span class="udiff-line-modified-added">+          * dead ones attached to the old node for later cleanup.</span>
           */
<span class="udiff-line-modified-removed">-         List&lt;AbstractBeginNode&gt; deadSuccessors = successors.filter(s -&gt; !newSuccessors.contains(s)).snapshot();</span>
<span class="udiff-line-modified-removed">-         successors.clear();</span>
<span class="udiff-line-modified-added">+         for (int i = 0; i &lt; successors.size(); i++) {</span>
<span class="udiff-line-modified-added">+             if (newSuccessors.contains(successors.get(i))) {</span>
<span class="udiff-line-added">+                 successors.set(i, null);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
  
          /*
           * Create the new switch node. This is done before removing dead successors as `killCFG`
           * could edit some of the inputs (e.g., if `newValue` is a loop-phi of the loop that dies
           * while removing successors).
           */
          AbstractBeginNode[] successorsArray = newSuccessors.toArray(new AbstractBeginNode[newSuccessors.size()]);
          SwitchNode newSwitch = graph().add(new IntegerSwitchNode(newValue, successorsArray, newKeys, newKeyProbabilities, newKeySuccessors));
  
<span class="udiff-line-removed">-         /* Remove dead successors. */</span>
<span class="udiff-line-removed">-         for (AbstractBeginNode successor : deadSuccessors) {</span>
<span class="udiff-line-removed">-             GraphUtil.killCFG(successor);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
          /* Replace ourselves with the new switch */
          ((FixedWithNextNode) predecessor()).setNext(newSwitch);
<span class="udiff-line-modified-removed">-         GraphUtil.killWithUnusedFloatingInputs(this);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+         // Remove the old switch and the dead successors.</span>
<span class="udiff-line-added">+         GraphUtil.killCFG(this);</span>
      }
  
      @Override
      public Stamp getValueStampForSuccessor(AbstractBeginNode beginNode) {
          Stamp result = null;
</pre>
<center><a href="GuardedUnsafeLoadNode.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="JavaWriteNode.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
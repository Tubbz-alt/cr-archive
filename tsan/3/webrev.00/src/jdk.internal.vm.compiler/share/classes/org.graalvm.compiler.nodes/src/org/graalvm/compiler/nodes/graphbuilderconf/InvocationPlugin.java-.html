<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/InvocationPlugin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.graphbuilderconf;
 26 
 27 import java.lang.invoke.MethodHandle;
 28 import java.lang.reflect.Method;
 29 
 30 import org.graalvm.compiler.debug.GraalError;
 31 import org.graalvm.compiler.nodes.Invoke;
 32 import org.graalvm.compiler.nodes.ValueNode;
 33 import org.graalvm.compiler.nodes.type.StampTool;
 34 
 35 import jdk.vm.ci.meta.MetaAccessProvider;
 36 import jdk.vm.ci.meta.ResolvedJavaMethod;
 37 
 38 /**
 39  * Plugin for handling a specific method invocation.
 40  */
 41 public interface InvocationPlugin extends GraphBuilderPlugin {
 42 
 43     /**
 44      * The receiver in a non-static method. The class literal for this interface must be used with
 45      * {@link InvocationPlugins#put(InvocationPlugin, boolean, boolean, Class, String, Class...)} to
 46      * denote the receiver argument for such a non-static method.
 47      */
 48     public interface Receiver {
 49         /**
 50          * Gets the receiver value, null checking it first if necessary.
 51          *
 52          * @return the receiver value with a {@linkplain StampTool#isPointerNonNull(ValueNode)
 53          *         non-null} stamp
 54          */
 55         default ValueNode get() {
 56             return get(true);
 57         }
 58 
 59         /**
 60          * Gets the receiver value, optionally null checking it first if necessary.
 61          */
 62         ValueNode get(boolean performNullCheck);
 63 
 64         /**
 65          * Determines if the receiver is constant.
 66          */
 67         default boolean isConstant() {
 68             return false;
 69         }
 70     }
 71 
 72     /**
 73      * Determines if this plugin is for a method with a polymorphic signature (e.g.
 74      * {@link MethodHandle#invokeExact(Object...)}).
 75      */
 76     default boolean isSignaturePolymorphic() {
 77         return false;
 78     }
 79 
 80     /**
 81      * Determines if this plugin can only be used when inlining the method is it associated with.
 82      * That is, this plugin cannot be used when the associated method is the compilation root.
 83      */
 84     default boolean inlineOnly() {
 85         return isSignaturePolymorphic();
 86     }
 87 
 88     /**
 89      * Determines if this plugin only decorates the method is it associated with. That is, it
 90      * inserts nodes prior to the invocation (e.g. some kind of marker nodes) but still expects the
 91      * parser to process the invocation further.
 92      */
 93     default boolean isDecorator() {
 94         return false;
 95     }
 96 
 97     /**
 98      * Handles invocation of a signature polymorphic method.
 99      *
100      * @param receiver access to the receiver, {@code null} if {@code targetMethod} is static
101      * @param argsIncludingReceiver all arguments to the invocation include the raw receiver in
102      *            position 0 if {@code targetMethod} is not static
103      * @see #execute
104      */
105     default boolean applyPolymorphic(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode... argsIncludingReceiver) {
106         return defaultHandler(b, targetMethod, receiver, argsIncludingReceiver);
107     }
108 
109     /**
110      * @see #execute
111      */
112     default boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver) {
113         return defaultHandler(b, targetMethod, receiver);
114     }
115 
116     /**
117      * @see #execute
118      */
119     default boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode arg) {
120         return defaultHandler(b, targetMethod, receiver, arg);
121     }
122 
123     /**
124      * @see #execute
125      */
126     default boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode arg1, ValueNode arg2) {
127         return defaultHandler(b, targetMethod, receiver, arg1, arg2);
128     }
129 
130     /**
131      * @see #execute
132      */
133     default boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3) {
134         return defaultHandler(b, targetMethod, receiver, arg1, arg2, arg3);
135     }
136 
137     /**
138      * @see #execute
139      */
140     default boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3, ValueNode arg4) {
141         return defaultHandler(b, targetMethod, receiver, arg1, arg2, arg3, arg4);
142     }
143 
144     /**
145      * @see #execute
146      */
147     default boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3, ValueNode arg4, ValueNode arg5) {
148         return defaultHandler(b, targetMethod, receiver, arg1, arg2, arg3, arg4, arg5);
149     }
150 
151     /**
152      * @see #execute
153      */
154     default boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3, ValueNode arg4, ValueNode arg5,
155                     ValueNode arg6) {
156         return defaultHandler(b, targetMethod, receiver, arg1, arg2, arg3, arg4, arg5, arg6);
157     }
158 
159     /**
160      * @see #execute
161      */
162     default boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3, ValueNode arg4, ValueNode arg5,
163                     ValueNode arg6, ValueNode arg7) {
164         return defaultHandler(b, targetMethod, receiver, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
165     }
166 
167     /**
168      * Executes this plugin against a set of invocation arguments.
169      *
170      * The default implementation in {@link InvocationPlugin} dispatches to the {@code apply(...)}
171      * method that matches the number of arguments or to {@link #applyPolymorphic} if {@code plugin}
172      * is {@linkplain #isSignaturePolymorphic() signature polymorphic}.
173      *
174      * @param targetMethod the method for which this plugin is being applied
175      * @param receiver access to the receiver, {@code null} if {@code targetMethod} is static
176      * @param argsIncludingReceiver all arguments to the invocation include the receiver in position
177      *            0 if {@code targetMethod} is not static
178      * @return {@code true} if this plugin handled the invocation of {@code targetMethod}
179      *         {@code false} if the graph builder should process the invoke further (e.g., by
180      *         inlining it or creating an {@link Invoke} node). A plugin that does not handle an
181      *         invocation must not modify the graph being constructed unless it is a
182      *         {@linkplain InvocationPlugin#isDecorator() decorator}.
183      */
184     default boolean execute(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode[] argsIncludingReceiver) {
185         if (isSignaturePolymorphic()) {
186             return applyPolymorphic(b, targetMethod, receiver, argsIncludingReceiver);
187         } else if (receiver != null) {
188             assert !targetMethod.isStatic();
189             assert argsIncludingReceiver.length &gt; 0;
190             if (argsIncludingReceiver.length == 1) {
191                 return apply(b, targetMethod, receiver);
192             } else if (argsIncludingReceiver.length == 2) {
193                 return apply(b, targetMethod, receiver, argsIncludingReceiver[1]);
194             } else if (argsIncludingReceiver.length == 3) {
195                 return apply(b, targetMethod, receiver, argsIncludingReceiver[1], argsIncludingReceiver[2]);
196             } else if (argsIncludingReceiver.length == 4) {
197                 return apply(b, targetMethod, receiver, argsIncludingReceiver[1], argsIncludingReceiver[2], argsIncludingReceiver[3]);
198             } else if (argsIncludingReceiver.length == 5) {
199                 return apply(b, targetMethod, receiver, argsIncludingReceiver[1], argsIncludingReceiver[2], argsIncludingReceiver[3], argsIncludingReceiver[4]);
200             } else {
201                 return defaultHandler(b, targetMethod, receiver, argsIncludingReceiver);
202             }
203         } else {
204             assert targetMethod.isStatic();
205             if (argsIncludingReceiver.length == 0) {
206                 return apply(b, targetMethod, null);
207             } else if (argsIncludingReceiver.length == 1) {
208                 return apply(b, targetMethod, null, argsIncludingReceiver[0]);
209             } else if (argsIncludingReceiver.length == 2) {
210                 return apply(b, targetMethod, null, argsIncludingReceiver[0], argsIncludingReceiver[1]);
211             } else if (argsIncludingReceiver.length == 3) {
212                 return apply(b, targetMethod, null, argsIncludingReceiver[0], argsIncludingReceiver[1], argsIncludingReceiver[2]);
213             } else if (argsIncludingReceiver.length == 4) {
214                 return apply(b, targetMethod, null, argsIncludingReceiver[0], argsIncludingReceiver[1], argsIncludingReceiver[2], argsIncludingReceiver[3]);
215             } else if (argsIncludingReceiver.length == 5) {
216                 return apply(b, targetMethod, null, argsIncludingReceiver[0], argsIncludingReceiver[1], argsIncludingReceiver[2], argsIncludingReceiver[3], argsIncludingReceiver[4]);
217             } else if (argsIncludingReceiver.length == 6) {
218                 return apply(b, targetMethod, null, argsIncludingReceiver[0], argsIncludingReceiver[1], argsIncludingReceiver[2], argsIncludingReceiver[3], argsIncludingReceiver[4],
219                                 argsIncludingReceiver[5]);
220             } else if (argsIncludingReceiver.length == 7) {
221                 return apply(b, targetMethod, null, argsIncludingReceiver[0], argsIncludingReceiver[1], argsIncludingReceiver[2], argsIncludingReceiver[3], argsIncludingReceiver[4],
222                                 argsIncludingReceiver[5], argsIncludingReceiver[6]);
223             } else {
224                 return defaultHandler(b, targetMethod, receiver, argsIncludingReceiver);
225             }
226 
227         }
228     }
229 
230     /**
231      * Handles an invocation when a specific {@code apply} method is not available.
232      */
233     default boolean defaultHandler(@SuppressWarnings(&quot;unused&quot;) GraphBuilderContext b, ResolvedJavaMethod targetMethod, @SuppressWarnings(&quot;unused&quot;) InvocationPlugin.Receiver receiver,
234                     ValueNode... args) {
235         throw new GraalError(&quot;Invocation plugin for %s does not handle invocations with %d arguments&quot;, targetMethod.format(&quot;%H.%n(%p)&quot;), args.length);
236     }
237 
238     default StackTraceElement getApplySourceLocation(MetaAccessProvider metaAccess) {
239         Class&lt;?&gt; c = getClass();
240         for (Method m : c.getDeclaredMethods()) {
241             if (m.getName().equals(&quot;apply&quot;)) {
242                 return metaAccess.lookupJavaMethod(m).asStackTraceElement(0);
243             } else if (m.getName().equals(&quot;defaultHandler&quot;)) {
244                 return metaAccess.lookupJavaMethod(m).asStackTraceElement(0);
245             }
246         }
247         throw new GraalError(&quot;could not find method named \&quot;apply\&quot; or \&quot;defaultHandler\&quot; in &quot; + c.getName());
248     }
249 }
    </pre>
  </body>
</html>
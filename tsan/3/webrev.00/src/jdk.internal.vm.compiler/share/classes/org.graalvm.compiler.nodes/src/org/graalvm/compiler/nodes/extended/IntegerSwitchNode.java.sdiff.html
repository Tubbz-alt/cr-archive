<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/IntegerSwitchNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GuardedUnsafeLoadNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="JavaWriteNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/IntegerSwitchNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.extended;
 26 
 27 import java.util.ArrayList;
 28 import java.util.Arrays;
 29 import java.util.Comparator;
 30 import java.util.HashMap;
 31 import java.util.List;
 32 import java.util.Map;
 33 
 34 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 35 import org.graalvm.compiler.core.common.type.IntegerStamp;
 36 import org.graalvm.compiler.core.common.type.PrimitiveStamp;
 37 import org.graalvm.compiler.core.common.type.Stamp;
 38 import org.graalvm.compiler.core.common.type.StampFactory;

 39 import org.graalvm.compiler.graph.NodeClass;
 40 import org.graalvm.compiler.graph.spi.Simplifiable;
 41 import org.graalvm.compiler.graph.spi.SimplifierTool;
 42 import org.graalvm.compiler.nodeinfo.NodeInfo;
 43 import org.graalvm.compiler.nodes.AbstractBeginNode;
 44 import org.graalvm.compiler.nodes.ConstantNode;
 45 import org.graalvm.compiler.nodes.FixedGuardNode;
 46 import org.graalvm.compiler.nodes.FixedWithNextNode;
 47 import org.graalvm.compiler.nodes.LogicNode;
 48 import org.graalvm.compiler.nodes.NodeView;
 49 import org.graalvm.compiler.nodes.ValueNode;
 50 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
 51 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 52 import org.graalvm.compiler.nodes.spi.LIRLowerable;
 53 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;

 54 import org.graalvm.compiler.nodes.util.GraphUtil;
 55 
 56 import jdk.vm.ci.meta.DeoptimizationAction;
 57 import jdk.vm.ci.meta.DeoptimizationReason;
 58 import jdk.vm.ci.meta.JavaConstant;
 59 import jdk.vm.ci.meta.JavaKind;
 60 
 61 /**
 62  * The {@code IntegerSwitchNode} represents a switch on integer keys, with a sorted array of key
 63  * values. The actual implementation of the switch will be decided by the backend.
 64  */
 65 @NodeInfo
<span class="line-modified"> 66 public final class IntegerSwitchNode extends SwitchNode implements LIRLowerable, Simplifiable {</span>
 67     public static final NodeClass&lt;IntegerSwitchNode&gt; TYPE = NodeClass.create(IntegerSwitchNode.class);
 68 
 69     protected final int[] keys;
 70 
 71     public IntegerSwitchNode(ValueNode value, AbstractBeginNode[] successors, int[] keys, double[] keyProbabilities, int[] keySuccessors) {
 72         super(TYPE, value, successors, keySuccessors, keyProbabilities);
 73         assert keySuccessors.length == keys.length + 1;
 74         assert keySuccessors.length == keyProbabilities.length;
 75         this.keys = keys;
 76         assert value.stamp(NodeView.DEFAULT) instanceof PrimitiveStamp &amp;&amp; value.stamp(NodeView.DEFAULT).getStackKind().isNumericInteger();
 77         assert assertSorted();

 78     }
 79 
 80     private boolean assertSorted() {
 81         for (int i = 1; i &lt; keys.length; i++) {
 82             assert keys[i - 1] &lt; keys[i];
 83         }
 84         return true;
 85     }
 86 












 87     public IntegerSwitchNode(ValueNode value, int successorCount, int[] keys, double[] keyProbabilities, int[] keySuccessors) {
 88         this(value, new AbstractBeginNode[successorCount], keys, keyProbabilities, keySuccessors);
 89     }
 90 
 91     @Override
 92     public boolean isSorted() {
 93         return true;
 94     }
 95 
 96     /**
 97      * Gets the key at the specified index.
 98      *
 99      * @param i the index
100      * @return the key at that index
101      */
102     @Override
103     public JavaConstant keyAt(int i) {
104         return JavaConstant.forInt(keys[i]);
105     }
106 








107     @Override
108     public int keyCount() {
109         return keys.length;
110     }
111 
112     @Override
113     public boolean equalKeys(SwitchNode switchNode) {
114         if (!(switchNode instanceof IntegerSwitchNode)) {
115             return false;
116         }
117         IntegerSwitchNode other = (IntegerSwitchNode) switchNode;
118         return Arrays.equals(keys, other.keys);
119     }
120 
121     @Override
122     public void generate(NodeLIRBuilderTool gen) {
123         gen.emitSwitch(this);
124     }
125 
126     public AbstractBeginNode successorAtKey(int key) {
</pre>
<hr />
<pre>
131         for (int i = 0; i &lt; keyCount(); i++) {
132             if (keys[i] == key) {
133                 return keySuccessorIndex(i);
134             }
135         }
136         return keySuccessorIndex(keyCount());
137     }
138 
139     @Override
140     public void simplify(SimplifierTool tool) {
141         NodeView view = NodeView.from(tool);
142         if (blockSuccessorCount() == 1) {
143             tool.addToWorkList(defaultSuccessor());
144             graph().removeSplitPropagate(this, defaultSuccessor());
145         } else if (value() instanceof ConstantNode) {
146             killOtherSuccessors(tool, successorIndexAtKey(value().asJavaConstant().asInt()));
147         } else if (tryOptimizeEnumSwitch(tool)) {
148             return;
149         } else if (tryRemoveUnreachableKeys(tool, value().stamp(view))) {
150             return;





















































151         }

152     }
153 
154     static final class KeyData {
155         final int key;
156         final double keyProbability;
157         final int keySuccessor;
158 
159         KeyData(int key, double keyProbability, int keySuccessor) {
160             this.key = key;
161             this.keyProbability = keyProbability;
162             this.keySuccessor = keySuccessor;
163         }
164     }
165 
166     /**
167      * Remove unreachable keys from the switch based on the stamp of the value, i.e., based on the
168      * known range of the switch value.
169      */
170     public boolean tryRemoveUnreachableKeys(SimplifierTool tool, Stamp valueStamp) {
171         if (!(valueStamp instanceof IntegerStamp)) {
</pre>
<hr />
<pre>
191         } else if (newKeyDatas.size() == 0) {
192             if (tool != null) {
193                 tool.addToWorkList(defaultSuccessor());
194             }
195             graph().removeSplitPropagate(this, defaultSuccessor());
196             return true;
197 
198         } else {
199             int newDefaultSuccessor = addNewSuccessor(defaultSuccessor(), newSuccessors);
200             double newDefaultProbability = keyProbabilities[keyProbabilities.length - 1];
201             doReplace(value(), newKeyDatas, newSuccessors, newDefaultSuccessor, newDefaultProbability);
202             return true;
203         }
204     }
205 
206     /**
207      * For switch statements on enum values, the Java compiler has to generate complicated code:
208      * because {@link Enum#ordinal()} can change when recompiling an enum, it cannot be used
209      * directly as the value that is switched on. An intermediate int[] array, which is initialized
210      * once at run time based on the actual {@link Enum#ordinal()} values, is used.
<span class="line-modified">211      *</span>
212      * The {@link ConstantFieldProvider} of Graal already detects the int[] arrays and marks them as
213      * {@link ConstantNode#isDefaultStable() stable}, i.e., the array elements are constant. The
214      * code in this method detects array loads from such a stable array and re-wires the switch to
215      * use the keys from the array elements, so that the array load is unnecessary.
216      */
217     private boolean tryOptimizeEnumSwitch(SimplifierTool tool) {
218         if (!(value() instanceof LoadIndexedNode)) {
219             /* Not the switch pattern we are looking for. */
220             return false;
221         }
222         LoadIndexedNode loadIndexed = (LoadIndexedNode) value();
<span class="line-modified">223         if (loadIndexed.usages().count() &gt; 1) {</span>
224             /*
225              * The array load is necessary for other reasons too, so there is no benefit optimizing
226              * the switch.
227              */
228             return false;
229         }
230         assert loadIndexed.usages().first() == this;
231 
232         ValueNode newValue = loadIndexed.index();
233         JavaConstant arrayConstant = loadIndexed.array().asJavaConstant();
234         if (arrayConstant == null || ((ConstantNode) loadIndexed.array()).getStableDimension() != 1 || !((ConstantNode) loadIndexed.array()).isDefaultStable()) {
235             /*
236              * The array is a constant that we can optimize. We require the array elements to be
237              * constant too, since we put them as literal constants into the switch keys.
238              */
239             return false;
240         }
241 
242         Integer optionalArrayLength = tool.getConstantReflection().readArrayLength(arrayConstant);
243         if (optionalArrayLength == null) {
</pre>
<hr />
<pre>
335 
336         newKeySuccessors[newKeyCount] = newDefaultSuccessor;
337         newKeyProbabilities[newKeyCount] = newDefaultProbability;
338 
339         /* Normalize new probabilities so that they sum up to 1. */
340         double totalProbability = 0;
341         for (double probability : newKeyProbabilities) {
342             totalProbability += probability;
343         }
344         if (totalProbability &gt; 0) {
345             for (int i = 0; i &lt; newKeyProbabilities.length; i++) {
346                 newKeyProbabilities[i] /= totalProbability;
347             }
348         } else {
349             for (int i = 0; i &lt; newKeyProbabilities.length; i++) {
350                 newKeyProbabilities[i] = 1.0 / newKeyProbabilities.length;
351             }
352         }
353 
354         /*
<span class="line-modified">355          * Collect dead successors. Successors have to be cleaned before adding the new node to the</span>
<span class="line-modified">356          * graph.</span>
357          */
<span class="line-modified">358         List&lt;AbstractBeginNode&gt; deadSuccessors = successors.filter(s -&gt; !newSuccessors.contains(s)).snapshot();</span>
<span class="line-modified">359         successors.clear();</span>



360 
361         /*
362          * Create the new switch node. This is done before removing dead successors as `killCFG`
363          * could edit some of the inputs (e.g., if `newValue` is a loop-phi of the loop that dies
364          * while removing successors).
365          */
366         AbstractBeginNode[] successorsArray = newSuccessors.toArray(new AbstractBeginNode[newSuccessors.size()]);
367         SwitchNode newSwitch = graph().add(new IntegerSwitchNode(newValue, successorsArray, newKeys, newKeyProbabilities, newKeySuccessors));
368 
<span class="line-removed">369         /* Remove dead successors. */</span>
<span class="line-removed">370         for (AbstractBeginNode successor : deadSuccessors) {</span>
<span class="line-removed">371             GraphUtil.killCFG(successor);</span>
<span class="line-removed">372         }</span>
<span class="line-removed">373 </span>
374         /* Replace ourselves with the new switch */
375         ((FixedWithNextNode) predecessor()).setNext(newSwitch);
<span class="line-modified">376         GraphUtil.killWithUnusedFloatingInputs(this);</span>


377     }
378 
379     @Override
380     public Stamp getValueStampForSuccessor(AbstractBeginNode beginNode) {
381         Stamp result = null;
382         if (beginNode != this.defaultSuccessor()) {
383             for (int i = 0; i &lt; keyCount(); i++) {
384                 if (keySuccessor(i) == beginNode) {
385                     if (result == null) {
386                         result = StampFactory.forConstant(keyAt(i));
387                     } else {
388                         result = result.meet(StampFactory.forConstant(keyAt(i)));
389                     }
390                 }
391             }
392         }
393         return result;
394     }
395 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.extended;
 26 
 27 import java.util.ArrayList;
 28 import java.util.Arrays;
 29 import java.util.Comparator;
 30 import java.util.HashMap;
 31 import java.util.List;
 32 import java.util.Map;
 33 
 34 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 35 import org.graalvm.compiler.core.common.type.IntegerStamp;
 36 import org.graalvm.compiler.core.common.type.PrimitiveStamp;
 37 import org.graalvm.compiler.core.common.type.Stamp;
 38 import org.graalvm.compiler.core.common.type.StampFactory;
<span class="line-added"> 39 import org.graalvm.compiler.graph.Node;</span>
 40 import org.graalvm.compiler.graph.NodeClass;
 41 import org.graalvm.compiler.graph.spi.Simplifiable;
 42 import org.graalvm.compiler.graph.spi.SimplifierTool;
 43 import org.graalvm.compiler.nodeinfo.NodeInfo;
 44 import org.graalvm.compiler.nodes.AbstractBeginNode;
 45 import org.graalvm.compiler.nodes.ConstantNode;
 46 import org.graalvm.compiler.nodes.FixedGuardNode;
 47 import org.graalvm.compiler.nodes.FixedWithNextNode;
 48 import org.graalvm.compiler.nodes.LogicNode;
 49 import org.graalvm.compiler.nodes.NodeView;
 50 import org.graalvm.compiler.nodes.ValueNode;
 51 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
 52 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 53 import org.graalvm.compiler.nodes.spi.LIRLowerable;
 54 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
<span class="line-added"> 55 import org.graalvm.compiler.nodes.spi.SwitchFoldable;</span>
 56 import org.graalvm.compiler.nodes.util.GraphUtil;
 57 
 58 import jdk.vm.ci.meta.DeoptimizationAction;
 59 import jdk.vm.ci.meta.DeoptimizationReason;
 60 import jdk.vm.ci.meta.JavaConstant;
 61 import jdk.vm.ci.meta.JavaKind;
 62 
 63 /**
 64  * The {@code IntegerSwitchNode} represents a switch on integer keys, with a sorted array of key
 65  * values. The actual implementation of the switch will be decided by the backend.
 66  */
 67 @NodeInfo
<span class="line-modified"> 68 public final class IntegerSwitchNode extends SwitchNode implements LIRLowerable, Simplifiable, SwitchFoldable {</span>
 69     public static final NodeClass&lt;IntegerSwitchNode&gt; TYPE = NodeClass.create(IntegerSwitchNode.class);
 70 
 71     protected final int[] keys;
 72 
 73     public IntegerSwitchNode(ValueNode value, AbstractBeginNode[] successors, int[] keys, double[] keyProbabilities, int[] keySuccessors) {
 74         super(TYPE, value, successors, keySuccessors, keyProbabilities);
 75         assert keySuccessors.length == keys.length + 1;
 76         assert keySuccessors.length == keyProbabilities.length;
 77         this.keys = keys;
 78         assert value.stamp(NodeView.DEFAULT) instanceof PrimitiveStamp &amp;&amp; value.stamp(NodeView.DEFAULT).getStackKind().isNumericInteger();
 79         assert assertSorted();
<span class="line-added"> 80         assert assertNoUntargettedSuccessor();</span>
 81     }
 82 
 83     private boolean assertSorted() {
 84         for (int i = 1; i &lt; keys.length; i++) {
 85             assert keys[i - 1] &lt; keys[i];
 86         }
 87         return true;
 88     }
 89 
<span class="line-added"> 90     private boolean assertNoUntargettedSuccessor() {</span>
<span class="line-added"> 91         boolean[] checker = new boolean[successors.size()];</span>
<span class="line-added"> 92         for (int successorIndex : keySuccessors) {</span>
<span class="line-added"> 93             checker[successorIndex] = true;</span>
<span class="line-added"> 94         }</span>
<span class="line-added"> 95         checker[defaultSuccessorIndex()] = true;</span>
<span class="line-added"> 96         for (boolean b : checker) {</span>
<span class="line-added"> 97             assert b;</span>
<span class="line-added"> 98         }</span>
<span class="line-added"> 99         return true;</span>
<span class="line-added">100     }</span>
<span class="line-added">101 </span>
102     public IntegerSwitchNode(ValueNode value, int successorCount, int[] keys, double[] keyProbabilities, int[] keySuccessors) {
103         this(value, new AbstractBeginNode[successorCount], keys, keyProbabilities, keySuccessors);
104     }
105 
106     @Override
107     public boolean isSorted() {
108         return true;
109     }
110 
111     /**
112      * Gets the key at the specified index.
113      *
114      * @param i the index
115      * @return the key at that index
116      */
117     @Override
118     public JavaConstant keyAt(int i) {
119         return JavaConstant.forInt(keys[i]);
120     }
121 
<span class="line-added">122     /**</span>
<span class="line-added">123      * Gets the key at the specified index, as a java int.</span>
<span class="line-added">124      */</span>
<span class="line-added">125     @Override</span>
<span class="line-added">126     public int intKeyAt(int i) {</span>
<span class="line-added">127         return keys[i];</span>
<span class="line-added">128     }</span>
<span class="line-added">129 </span>
130     @Override
131     public int keyCount() {
132         return keys.length;
133     }
134 
135     @Override
136     public boolean equalKeys(SwitchNode switchNode) {
137         if (!(switchNode instanceof IntegerSwitchNode)) {
138             return false;
139         }
140         IntegerSwitchNode other = (IntegerSwitchNode) switchNode;
141         return Arrays.equals(keys, other.keys);
142     }
143 
144     @Override
145     public void generate(NodeLIRBuilderTool gen) {
146         gen.emitSwitch(this);
147     }
148 
149     public AbstractBeginNode successorAtKey(int key) {
</pre>
<hr />
<pre>
154         for (int i = 0; i &lt; keyCount(); i++) {
155             if (keys[i] == key) {
156                 return keySuccessorIndex(i);
157             }
158         }
159         return keySuccessorIndex(keyCount());
160     }
161 
162     @Override
163     public void simplify(SimplifierTool tool) {
164         NodeView view = NodeView.from(tool);
165         if (blockSuccessorCount() == 1) {
166             tool.addToWorkList(defaultSuccessor());
167             graph().removeSplitPropagate(this, defaultSuccessor());
168         } else if (value() instanceof ConstantNode) {
169             killOtherSuccessors(tool, successorIndexAtKey(value().asJavaConstant().asInt()));
170         } else if (tryOptimizeEnumSwitch(tool)) {
171             return;
172         } else if (tryRemoveUnreachableKeys(tool, value().stamp(view))) {
173             return;
<span class="line-added">174         } else if (switchTransformationOptimization(tool)) {</span>
<span class="line-added">175             return;</span>
<span class="line-added">176         }</span>
<span class="line-added">177     }</span>
<span class="line-added">178 </span>
<span class="line-added">179     private void addSuccessorForDeletion(AbstractBeginNode defaultNode) {</span>
<span class="line-added">180         successors.add(defaultNode);</span>
<span class="line-added">181     }</span>
<span class="line-added">182 </span>
<span class="line-added">183     @Override</span>
<span class="line-added">184     public Node getNextSwitchFoldableBranch() {</span>
<span class="line-added">185         return defaultSuccessor();</span>
<span class="line-added">186     }</span>
<span class="line-added">187 </span>
<span class="line-added">188     @Override</span>
<span class="line-added">189     public boolean isInSwitch(ValueNode switchValue) {</span>
<span class="line-added">190         return value == switchValue;</span>
<span class="line-added">191     }</span>
<span class="line-added">192 </span>
<span class="line-added">193     @Override</span>
<span class="line-added">194     public void cutOffCascadeNode() {</span>
<span class="line-added">195         AbstractBeginNode toKill = defaultSuccessor();</span>
<span class="line-added">196         clearSuccessors();</span>
<span class="line-added">197         addSuccessorForDeletion(toKill);</span>
<span class="line-added">198     }</span>
<span class="line-added">199 </span>
<span class="line-added">200     @Override</span>
<span class="line-added">201     public void cutOffLowestCascadeNode() {</span>
<span class="line-added">202         clearSuccessors();</span>
<span class="line-added">203     }</span>
<span class="line-added">204 </span>
<span class="line-added">205     @Override</span>
<span class="line-added">206     public AbstractBeginNode getDefault() {</span>
<span class="line-added">207         return defaultSuccessor();</span>
<span class="line-added">208     }</span>
<span class="line-added">209 </span>
<span class="line-added">210     @Override</span>
<span class="line-added">211     public ValueNode switchValue() {</span>
<span class="line-added">212         return value();</span>
<span class="line-added">213     }</span>
<span class="line-added">214 </span>
<span class="line-added">215     @Override</span>
<span class="line-added">216     public boolean isNonInitializedProfile() {</span>
<span class="line-added">217         int nbSuccessors = getSuccessorCount();</span>
<span class="line-added">218         double prob = 0.0d;</span>
<span class="line-added">219         for (int i = 0; i &lt; nbSuccessors; i++) {</span>
<span class="line-added">220             if (keyProbabilities[i] &gt; 0.0d) {</span>
<span class="line-added">221                 if (prob == 0.0d) {</span>
<span class="line-added">222                     prob = keyProbabilities[i];</span>
<span class="line-added">223                 } else if (keyProbabilities[i] != prob) {</span>
<span class="line-added">224                     return false;</span>
<span class="line-added">225                 }</span>
<span class="line-added">226             }</span>
227         }
<span class="line-added">228         return true;</span>
229     }
230 
231     static final class KeyData {
232         final int key;
233         final double keyProbability;
234         final int keySuccessor;
235 
236         KeyData(int key, double keyProbability, int keySuccessor) {
237             this.key = key;
238             this.keyProbability = keyProbability;
239             this.keySuccessor = keySuccessor;
240         }
241     }
242 
243     /**
244      * Remove unreachable keys from the switch based on the stamp of the value, i.e., based on the
245      * known range of the switch value.
246      */
247     public boolean tryRemoveUnreachableKeys(SimplifierTool tool, Stamp valueStamp) {
248         if (!(valueStamp instanceof IntegerStamp)) {
</pre>
<hr />
<pre>
268         } else if (newKeyDatas.size() == 0) {
269             if (tool != null) {
270                 tool.addToWorkList(defaultSuccessor());
271             }
272             graph().removeSplitPropagate(this, defaultSuccessor());
273             return true;
274 
275         } else {
276             int newDefaultSuccessor = addNewSuccessor(defaultSuccessor(), newSuccessors);
277             double newDefaultProbability = keyProbabilities[keyProbabilities.length - 1];
278             doReplace(value(), newKeyDatas, newSuccessors, newDefaultSuccessor, newDefaultProbability);
279             return true;
280         }
281     }
282 
283     /**
284      * For switch statements on enum values, the Java compiler has to generate complicated code:
285      * because {@link Enum#ordinal()} can change when recompiling an enum, it cannot be used
286      * directly as the value that is switched on. An intermediate int[] array, which is initialized
287      * once at run time based on the actual {@link Enum#ordinal()} values, is used.
<span class="line-modified">288      * &lt;p&gt;</span>
289      * The {@link ConstantFieldProvider} of Graal already detects the int[] arrays and marks them as
290      * {@link ConstantNode#isDefaultStable() stable}, i.e., the array elements are constant. The
291      * code in this method detects array loads from such a stable array and re-wires the switch to
292      * use the keys from the array elements, so that the array load is unnecessary.
293      */
294     private boolean tryOptimizeEnumSwitch(SimplifierTool tool) {
295         if (!(value() instanceof LoadIndexedNode)) {
296             /* Not the switch pattern we are looking for. */
297             return false;
298         }
299         LoadIndexedNode loadIndexed = (LoadIndexedNode) value();
<span class="line-modified">300         if (loadIndexed.hasMoreThanOneUsage()) {</span>
301             /*
302              * The array load is necessary for other reasons too, so there is no benefit optimizing
303              * the switch.
304              */
305             return false;
306         }
307         assert loadIndexed.usages().first() == this;
308 
309         ValueNode newValue = loadIndexed.index();
310         JavaConstant arrayConstant = loadIndexed.array().asJavaConstant();
311         if (arrayConstant == null || ((ConstantNode) loadIndexed.array()).getStableDimension() != 1 || !((ConstantNode) loadIndexed.array()).isDefaultStable()) {
312             /*
313              * The array is a constant that we can optimize. We require the array elements to be
314              * constant too, since we put them as literal constants into the switch keys.
315              */
316             return false;
317         }
318 
319         Integer optionalArrayLength = tool.getConstantReflection().readArrayLength(arrayConstant);
320         if (optionalArrayLength == null) {
</pre>
<hr />
<pre>
412 
413         newKeySuccessors[newKeyCount] = newDefaultSuccessor;
414         newKeyProbabilities[newKeyCount] = newDefaultProbability;
415 
416         /* Normalize new probabilities so that they sum up to 1. */
417         double totalProbability = 0;
418         for (double probability : newKeyProbabilities) {
419             totalProbability += probability;
420         }
421         if (totalProbability &gt; 0) {
422             for (int i = 0; i &lt; newKeyProbabilities.length; i++) {
423                 newKeyProbabilities[i] /= totalProbability;
424             }
425         } else {
426             for (int i = 0; i &lt; newKeyProbabilities.length; i++) {
427                 newKeyProbabilities[i] = 1.0 / newKeyProbabilities.length;
428             }
429         }
430 
431         /*
<span class="line-modified">432          * Surviving successors have to be cleaned before adding the new node to the graph. Keep the</span>
<span class="line-modified">433          * dead ones attached to the old node for later cleanup.</span>
434          */
<span class="line-modified">435         for (int i = 0; i &lt; successors.size(); i++) {</span>
<span class="line-modified">436             if (newSuccessors.contains(successors.get(i))) {</span>
<span class="line-added">437                 successors.set(i, null);</span>
<span class="line-added">438             }</span>
<span class="line-added">439         }</span>
440 
441         /*
442          * Create the new switch node. This is done before removing dead successors as `killCFG`
443          * could edit some of the inputs (e.g., if `newValue` is a loop-phi of the loop that dies
444          * while removing successors).
445          */
446         AbstractBeginNode[] successorsArray = newSuccessors.toArray(new AbstractBeginNode[newSuccessors.size()]);
447         SwitchNode newSwitch = graph().add(new IntegerSwitchNode(newValue, successorsArray, newKeys, newKeyProbabilities, newKeySuccessors));
448 





449         /* Replace ourselves with the new switch */
450         ((FixedWithNextNode) predecessor()).setNext(newSwitch);
<span class="line-modified">451 </span>
<span class="line-added">452         // Remove the old switch and the dead successors.</span>
<span class="line-added">453         GraphUtil.killCFG(this);</span>
454     }
455 
456     @Override
457     public Stamp getValueStampForSuccessor(AbstractBeginNode beginNode) {
458         Stamp result = null;
459         if (beginNode != this.defaultSuccessor()) {
460             for (int i = 0; i &lt; keyCount(); i++) {
461                 if (keySuccessor(i) == beginNode) {
462                     if (result == null) {
463                         result = StampFactory.forConstant(keyAt(i));
464                     } else {
465                         result = result.meet(StampFactory.forConstant(keyAt(i)));
466                     }
467                 }
468             }
469         }
470         return result;
471     }
472 }
</pre>
</td>
</tr>
</table>
<center><a href="GuardedUnsafeLoadNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="JavaWriteNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/IfNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GuardedValueNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Invoke.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/IfNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.nodes;
  26 
  27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_1;
  28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_2;
  29 
  30 import java.util.ArrayList;
  31 import java.util.Arrays;
  32 import java.util.Iterator;
  33 import java.util.List;
  34 import java.util.Objects;
  35 
  36 import jdk.internal.vm.compiler.collections.EconomicMap;
  37 import jdk.internal.vm.compiler.collections.Equivalence;
  38 import org.graalvm.compiler.bytecode.BytecodeDisassembler;
  39 import org.graalvm.compiler.bytecode.Bytecodes;
  40 import org.graalvm.compiler.bytecode.Bytes;
  41 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  42 import org.graalvm.compiler.core.common.calc.Condition;

  43 import org.graalvm.compiler.core.common.type.IntegerStamp;

  44 import org.graalvm.compiler.core.common.type.Stamp;
  45 import org.graalvm.compiler.core.common.type.StampFactory;
  46 import org.graalvm.compiler.debug.CounterKey;
  47 import org.graalvm.compiler.debug.DebugCloseable;
  48 import org.graalvm.compiler.debug.DebugContext;
  49 import org.graalvm.compiler.debug.GraalError;

  50 import org.graalvm.compiler.graph.Node;
  51 import org.graalvm.compiler.graph.NodeClass;
  52 import org.graalvm.compiler.graph.NodeSourcePosition;
  53 import org.graalvm.compiler.graph.iterators.NodeIterable;
<span class="line-removed">  54 import org.graalvm.compiler.graph.spi.Canonicalizable;</span>
  55 import org.graalvm.compiler.graph.spi.Simplifiable;
  56 import org.graalvm.compiler.graph.spi.SimplifierTool;
  57 import org.graalvm.compiler.nodeinfo.InputType;
  58 import org.graalvm.compiler.nodeinfo.NodeInfo;

  59 import org.graalvm.compiler.nodes.calc.CompareNode;
  60 import org.graalvm.compiler.nodes.calc.ConditionalNode;

  61 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  62 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  63 import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;

  64 import org.graalvm.compiler.nodes.calc.IsNullNode;
<span class="line-removed">  65 import org.graalvm.compiler.nodes.calc.NormalizeCompareNode;</span>
  66 import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
  67 import org.graalvm.compiler.nodes.extended.UnboxNode;
  68 import org.graalvm.compiler.nodes.java.InstanceOfNode;
  69 import org.graalvm.compiler.nodes.java.LoadFieldNode;
  70 import org.graalvm.compiler.nodes.spi.LIRLowerable;
  71 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;

  72 import org.graalvm.compiler.nodes.util.GraphUtil;
  73 

  74 import jdk.vm.ci.meta.Constant;
  75 import jdk.vm.ci.meta.JavaConstant;
  76 import jdk.vm.ci.meta.JavaKind;
  77 import jdk.vm.ci.meta.MetaAccessProvider;
  78 import jdk.vm.ci.meta.PrimitiveConstant;
  79 import jdk.vm.ci.meta.ResolvedJavaMethod;
  80 import jdk.vm.ci.meta.ResolvedJavaType;
  81 import jdk.vm.ci.meta.TriState;
  82 
  83 /**
  84  * The {@code IfNode} represents a branch that can go one of two directions depending on the outcome
  85  * of a comparison.
  86  */
  87 @NodeInfo(cycles = CYCLES_1, size = SIZE_2, sizeRationale = &quot;2 jmps&quot;)
<span class="line-modified">  88 public final class IfNode extends ControlSplitNode implements Simplifiable, LIRLowerable {</span>
  89     public static final NodeClass&lt;IfNode&gt; TYPE = NodeClass.create(IfNode.class);
  90 
  91     private static final CounterKey CORRECTED_PROBABILITIES = DebugContext.counter(&quot;CorrectedProbabilities&quot;);
  92 
  93     @Successor AbstractBeginNode trueSuccessor;
  94     @Successor AbstractBeginNode falseSuccessor;
  95     @Input(InputType.Condition) LogicNode condition;
  96     protected double trueSuccessorProbability;
  97 
  98     public LogicNode condition() {
  99         return condition;
 100     }
 101 
 102     public void setCondition(LogicNode x) {
 103         updateUsages(condition, x);
 104         condition = x;
 105     }
 106 
 107     public IfNode(LogicNode condition, FixedNode trueSuccessor, FixedNode falseSuccessor, double trueSuccessorProbability) {
 108         this(condition, BeginNode.begin(trueSuccessor), BeginNode.begin(falseSuccessor), trueSuccessorProbability);
</pre>
<hr />
<pre>
 270             } else {
 271                 tool.deleteBranch(trueSuccessor());
 272                 tool.addToWorkList(falseSuccessor());
 273                 graph().removeSplit(this, falseSuccessor());
 274             }
 275             return;
 276         }
 277         if (tool.allUsagesAvailable() &amp;&amp; trueSuccessor().hasNoUsages() &amp;&amp; falseSuccessor().hasNoUsages()) {
 278 
 279             pushNodesThroughIf(tool);
 280 
 281             if (checkForUnsignedCompare(tool) || removeOrMaterializeIf(tool)) {
 282                 return;
 283             }
 284         }
 285 
 286         if (removeIntermediateMaterialization(tool)) {
 287             return;
 288         }
 289 
<span class="line-modified"> 290         if (splitIfAtPhi(tool)) {</span>
 291             return;
 292         }
 293 
<span class="line-modified"> 294         if (conditionalNodeOptimization(tool)) {</span>
 295             return;
 296         }
 297 
<span class="line-modified"> 298         if (falseSuccessor().hasNoUsages() &amp;&amp; (!(falseSuccessor() instanceof LoopExitNode)) &amp;&amp; falseSuccessor().next() instanceof IfNode) {</span>

 299             AbstractBeginNode intermediateBegin = falseSuccessor();
 300             IfNode nextIf = (IfNode) intermediateBegin.next();
 301             double probabilityB = (1.0 - this.trueSuccessorProbability) * nextIf.trueSuccessorProbability;
 302             if (this.trueSuccessorProbability &lt; probabilityB) {
 303                 // Reordering of those two if statements is beneficial from the point of view of
 304                 // their probabilities.
 305                 if (prepareForSwap(tool, condition(), nextIf.condition())) {
 306                     // Reordering is allowed from (if1 =&gt; begin =&gt; if2) to (if2 =&gt; begin =&gt; if1).
 307                     assert intermediateBegin.next() == nextIf;
 308                     AbstractBeginNode bothFalseBegin = nextIf.falseSuccessor();
 309                     nextIf.setFalseSuccessor(null);
 310                     intermediateBegin.setNext(null);
 311                     this.setFalseSuccessor(null);
 312 
 313                     this.replaceAtPredecessor(nextIf);
 314                     nextIf.setFalseSuccessor(intermediateBegin);
 315                     intermediateBegin.setNext(this);
 316                     this.setFalseSuccessor(bothFalseBegin);
 317 
 318                     NodeSourcePosition intermediateBeginPosition = intermediateBegin.getNodeSourcePosition();
 319                     intermediateBegin.setNodeSourcePosition(bothFalseBegin.getNodeSourcePosition());
 320                     bothFalseBegin.setNodeSourcePosition(intermediateBeginPosition);
 321 
 322                     nextIf.setTrueSuccessorProbability(probabilityB);
 323                     if (probabilityB == 1.0) {
 324                         this.setTrueSuccessorProbability(0.0);
 325                     } else {
 326                         double newProbability = this.trueSuccessorProbability / (1.0 - probabilityB);
 327                         this.setTrueSuccessorProbability(Math.min(1.0, newProbability));
 328                     }
 329                     return;
 330                 }
 331             }
 332         }
 333 
 334         if (tryEliminateBoxedReferenceEquals(tool)) {
 335             return;
 336         }
 337     }
 338 
<span class="line-modified"> 339     private boolean isUnboxedFrom(MetaAccessProvider meta, NodeView view, ValueNode x, ValueNode src) {</span>
 340         if (x == src) {
 341             return true;
 342         } else if (x instanceof UnboxNode) {
 343             return isUnboxedFrom(meta, view, ((UnboxNode) x).getValue(), src);
 344         } else if (x instanceof PiNode) {
 345             PiNode pi = (PiNode) x;
 346             return isUnboxedFrom(meta, view, pi.getOriginalNode(), src);
 347         } else if (x instanceof LoadFieldNode) {
 348             LoadFieldNode load = (LoadFieldNode) x;
 349             ResolvedJavaType integerType = meta.lookupJavaType(Integer.class);
 350             if (load.getValue().stamp(view).javaType(meta).equals(integerType)) {
 351                 return isUnboxedFrom(meta, view, load.getValue(), src);
 352             } else {
 353                 return false;
 354             }
 355         } else {
 356             return false;
 357         }
 358     }
 359 
</pre>
<hr />
<pre>
 434             FixedGuardNode fixed = (FixedGuardNode) node;
 435             if (!(fixed.condition() instanceof IntegerEqualsNode)) {
 436                 continue;
 437             }
 438             IntegerEqualsNode equals = (IntegerEqualsNode) fixed.condition();
 439             if ((isUnboxedFrom(meta, view, equals.getX(), x) &amp;&amp; isUnboxedFrom(meta, view, equals.getY(), y)) ||
 440                             (isUnboxedFrom(meta, view, equals.getX(), y) &amp;&amp; isUnboxedFrom(meta, view, equals.getY(), x))) {
 441                 unboxCheck = fixed;
 442             }
 443         }
 444         if (unbox == null || unboxCheck == null) {
 445             return false;
 446         }
 447 
 448         // Falsify the reference check.
 449         setCondition(graph().addOrUniqueWithInputs(LogicConstantNode.contradiction()));
 450 
 451         return true;
 452     }
 453 
































































 454     /**
 455      * Try to optimize this as if it were a {@link ConditionalNode}.
 456      */
 457     private boolean conditionalNodeOptimization(SimplifierTool tool) {
 458         if (trueSuccessor().next() instanceof AbstractEndNode &amp;&amp; falseSuccessor().next() instanceof AbstractEndNode) {
 459             AbstractEndNode trueEnd = (AbstractEndNode) trueSuccessor().next();
 460             AbstractEndNode falseEnd = (AbstractEndNode) falseSuccessor().next();
 461             if (trueEnd.merge() != falseEnd.merge()) {
 462                 return false;
 463             }
 464             if (!(trueEnd.merge() instanceof MergeNode)) {
 465                 return false;
 466             }
 467             MergeNode merge = (MergeNode) trueEnd.merge();
<span class="line-modified"> 468             if (merge.usages().count() != 1 || merge.phis().count() != 1) {</span>
 469                 return false;
 470             }
 471 
<span class="line-modified"> 472             if (trueSuccessor().anchored().isNotEmpty() || falseSuccessor().anchored().isNotEmpty()) {</span>
 473                 return false;
 474             }
 475 
 476             PhiNode phi = merge.phis().first();
 477             ValueNode falseValue = phi.valueAt(falseEnd);
 478             ValueNode trueValue = phi.valueAt(trueEnd);
 479 
 480             NodeView view = NodeView.from(tool);
 481             ValueNode result = ConditionalNode.canonicalizeConditional(condition, trueValue, falseValue, phi.stamp(view), view);
 482             if (result != null) {
 483                 /*
 484                  * canonicalizeConditional returns possibly new nodes so add them to the graph.
 485                  */
 486                 if (result.graph() == null) {
 487                     result = graph().addOrUniqueWithInputs(result);
 488                 }
 489                 result = proxyReplacement(result);
 490                 /*
 491                  * This optimization can be performed even if multiple values merge at this phi
 492                  * since the two inputs get simplified into one.
</pre>
<hr />
<pre>
 586                             below = graph().unique(new IntegerBelowNode(lessThan.getX(), newLimit));
 587                         }
 588                     }
 589                     if (below != null) {
 590                         try (DebugCloseable position = ifNode2.withNodeSourcePosition()) {
 591                             ifNode2.setTrueSuccessor(null);
 592                             ifNode2.setFalseSuccessor(null);
 593 
 594                             IfNode newIfNode = graph().add(new IfNode(below, falseSucc, trueSucc, 1 - trueSuccessorProbability));
 595                             // Remove the &lt; 0 test.
 596                             tool.deleteBranch(trueSuccessor);
 597                             graph().removeSplit(this, falseSuccessor);
 598 
 599                             // Replace the second test with the new one.
 600                             ifNode2.predecessor().replaceFirstSuccessor(ifNode2, newIfNode);
 601                             ifNode2.safeDelete();
 602                             return true;
 603                         }
 604                     }
 605                 }












































 606             }
 607         }
 608         return false;
 609     }
 610 
 611     /**
 612      * Check it these two blocks end up at the same place. Meeting at the same merge, or
 613      * deoptimizing in the same way.
 614      */
 615     private static boolean sameDestination(AbstractBeginNode succ1, AbstractBeginNode succ2) {
 616         Node next1 = succ1.next();
 617         Node next2 = succ2.next();
 618         if (next1 instanceof EndNode &amp;&amp; next2 instanceof EndNode) {
 619             EndNode end1 = (EndNode) next1;
 620             EndNode end2 = (EndNode) next2;
 621             if (end1.merge() == end2.merge()) {
 622                 for (PhiNode phi : end1.merge().phis()) {
 623                     if (phi.valueAt(end1) != phi.valueAt(end2)) {
 624                         return false;
 625                     }
</pre>
<hr />
<pre>
 751             AbstractMergeNode merge = trueEnd.merge();
 752             if (merge == falseEnd.merge() &amp;&amp; trueSuccessor().anchored().isEmpty() &amp;&amp; falseSuccessor().anchored().isEmpty()) {
 753                 PhiNode singlePhi = null;
 754                 int distinct = 0;
 755                 for (PhiNode phi : merge.phis()) {
 756                     ValueNode trueValue = phi.valueAt(trueEnd);
 757                     ValueNode falseValue = phi.valueAt(falseEnd);
 758                     if (trueValue != falseValue) {
 759                         distinct++;
 760                         singlePhi = phi;
 761                     }
 762                 }
 763                 if (distinct == 0) {
 764                     /*
 765                      * Multiple phis but merging same values for true and false, so simply delete
 766                      * the path
 767                      */
 768                     removeThroughFalseBranch(tool, merge);
 769                     return true;
 770                 } else if (distinct == 1) {



 771                     ValueNode trueValue = singlePhi.valueAt(trueEnd);
 772                     ValueNode falseValue = singlePhi.valueAt(falseEnd);
 773                     ValueNode conditional = canonicalizeConditionalCascade(tool, trueValue, falseValue);
 774                     if (conditional != null) {
 775                         conditional = proxyReplacement(conditional);
 776                         singlePhi.setValueAt(trueEnd, conditional);
 777                         removeThroughFalseBranch(tool, merge);
 778                         return true;
 779                     }
 780                 }
 781             }
 782         }
 783         if (trueSuccessor().next() instanceof ReturnNode &amp;&amp; falseSuccessor().next() instanceof ReturnNode) {
 784             ReturnNode trueEnd = (ReturnNode) trueSuccessor().next();
 785             ReturnNode falseEnd = (ReturnNode) falseSuccessor().next();
 786             ValueNode trueValue = trueEnd.result();
 787             ValueNode falseValue = falseEnd.result();
 788             ValueNode value = null;

 789             if (trueValue != null) {
 790                 if (trueValue == falseValue) {
 791                     value = trueValue;
 792                 } else {
 793                     value = canonicalizeConditionalCascade(tool, trueValue, falseValue);
 794                     if (value == null) {
 795                         return false;
 796                     }

 797                 }
 798             }











 799             ReturnNode newReturn = graph().add(new ReturnNode(value));
 800             replaceAtPredecessor(newReturn);
 801             GraphUtil.killCFG(this);
 802             return true;
 803         }
 804         return false;
 805     }
 806 
 807     private ValueNode proxyReplacement(ValueNode replacement) {
 808         /*
 809          * Special case: Every empty diamond we collapse to a conditional node can potentially
 810          * contain loop exit nodes on both branches. See the graph below: The two loop exits
 811          * (instanceof begin node) exit the same loop. The resulting phi is defined outside the
 812          * loop, but the resulting conditional node will be inside the loop, so we need to proxy the
 813          * resulting conditional node. Callers of this method ensure that true and false successor
 814          * have no usages, therefore a and b in the graph below can never be proxies themselves.
 815          */
 816         // @formatter:off
 817         //              +--+
 818         //              |If|
 819         //              +--+      +-----+ +-----+
 820         //         +----+  +----+ |  a  | |  b  |
 821         //         |Lex |  |Lex | +----^+ +^----+
 822         //         +----+  +----+      |   |
 823         //           +-------+         +---+
 824         //           | Merge +---------+Phi|
 825         //           +-------+         +---+
 826         // @formatter:on
 827         if (this.graph().hasValueProxies()) {
 828             if (trueSuccessor instanceof LoopExitNode &amp;&amp; falseSuccessor instanceof LoopExitNode) {
 829                 assert ((LoopExitNode) trueSuccessor).loopBegin() == ((LoopExitNode) falseSuccessor).loopBegin();
 830                 /*
 831                  * we can collapse all proxy nodes on one loop exit, the surviving one, which will
 832                  * be the true successor
 833                  */
<span class="line-modified"> 834                 if (falseSuccessor.anchored().isEmpty() &amp;&amp; falseSuccessor.usages().isNotEmpty()) {</span>
 835                     for (Node n : falseSuccessor.usages().snapshot()) {
 836                         assert n instanceof ProxyNode;
 837                         ((ProxyNode) n).setProxyPoint((LoopExitNode) trueSuccessor);
 838                     }
 839                 }
 840                 /*
 841                  * The true successor (surviving loop exit) can have usages, namely proxy nodes, the
 842                  * false successor however, must not have usages any more after the code above
 843                  */
<span class="line-modified"> 844                 assert trueSuccessor.anchored().isEmpty() &amp;&amp; falseSuccessor.usages().isEmpty();</span>
 845                 return this.graph().addOrUnique(new ValueProxyNode(replacement, (LoopExitNode) trueSuccessor));
 846             }
 847         }
 848         return replacement;
 849     }
 850 
 851     protected void removeThroughFalseBranch(SimplifierTool tool, AbstractMergeNode merge) {
 852         AbstractBeginNode trueBegin = trueSuccessor();
 853         LogicNode conditionNode = condition();
 854         graph().removeSplitPropagate(this, trueBegin);
 855         tool.addToWorkList(trueBegin);
 856         if (conditionNode != null) {
 857             GraphUtil.tryKillUnused(conditionNode);
 858         }
 859         if (merge.isAlive() &amp;&amp; merge.forwardEndCount() &gt; 1) {
 860             for (FixedNode end : merge.forwardEnds()) {
 861                 Node cur = end;
 862                 while (cur != null &amp;&amp; cur.predecessor() instanceof BeginNode) {
 863                     cur = cur.predecessor();
 864                 }
</pre>
<hr />
<pre>
 927                 return null;
 928             }
 929             boolean negateConditionalCondition = false;
 930             ValueNode otherValue = null;
 931             if (constant == conditional.trueValue()) {
 932                 otherValue = conditional.falseValue();
 933                 negateConditionalCondition = false;
 934             } else if (constant == conditional.falseValue()) {
 935                 otherValue = conditional.trueValue();
 936                 negateConditionalCondition = true;
 937             }
 938             if (otherValue != null &amp;&amp; otherValue.isConstant()) {
 939                 double shortCutProbability = probability(trueSuccessor());
 940                 LogicNode newCondition = LogicNode.or(condition(), negateCondition, conditional.condition(), negateConditionalCondition, shortCutProbability);
 941                 return graph().unique(new ConditionalNode(newCondition, constant, otherValue));
 942             }
 943 
 944             if (constant.isJavaConstant() &amp;&amp; conditional.trueValue().isJavaConstant() &amp;&amp; conditional.falseValue().isJavaConstant() &amp;&amp; condition() instanceof CompareNode &amp;&amp;
 945                             conditional.condition() instanceof CompareNode) {
 946 
<span class="line-modified"> 947                 Condition cond1 = ((CompareNode) condition()).condition().asCondition();</span>

 948                 if (negateCondition) {
 949                     cond1 = cond1.negate();
 950                 }
 951                 // cond1 is EQ, NE, LT, or GE
<span class="line-modified"> 952                 Condition cond2 = ((CompareNode) conditional.condition()).condition().asCondition();</span>
<span class="line-modified"> 953                 ValueNode x = ((CompareNode) condition()).getX();</span>
<span class="line-modified"> 954                 ValueNode y = ((CompareNode) condition()).getY();</span>
<span class="line-modified"> 955                 ValueNode x2 = ((CompareNode) conditional.condition()).getX();</span>
<span class="line-modified"> 956                 ValueNode y2 = ((CompareNode) conditional.condition()).getY();</span>

 957                 // `x cond1 y ? c1 : (x2 cond2 y2 ? c2 : c3)`
 958                 boolean sameVars = x == x2 &amp;&amp; y == y2;
 959                 if (!sameVars &amp;&amp; x == y2 &amp;&amp; y == x2) {
 960                     sameVars = true;
 961                     cond2 = cond2.mirror();
 962                 }
 963                 if (sameVars) {

 964                     JavaKind stackKind = conditional.trueValue().stamp(NodeView.from(tool)).getStackKind();
 965                     assert !stackKind.isNumericFloat();
 966 
<span class="line-modified"> 967                     ValueNode v1 = constant;</span>
<span class="line-modified"> 968                     ValueNode v2 = conditional.trueValue();</span>
<span class="line-modified"> 969                     ValueNode v3 = conditional.falseValue();</span>
<span class="line-removed"> 970 </span>
<span class="line-removed"> 971                     long c1 = v1.asJavaConstant().asLong();</span>
<span class="line-removed"> 972                     long c2 = v2.asJavaConstant().asLong();</span>
<span class="line-removed"> 973                     long c3 = v3.asJavaConstant().asLong();</span>
<span class="line-removed"> 974 </span>
<span class="line-removed"> 975                     if (cond1 == Condition.LT &amp;&amp; cond2 == Condition.EQ &amp;&amp; c1 == -1 &amp;&amp; c2 == 0 &amp;&amp; c3 == 1) {</span>
<span class="line-removed"> 976                         // x &lt; y ? -1 : (x == y ? 0 : 1) =&gt; x cmp y</span>
<span class="line-removed"> 977                         return graph().unique(new NormalizeCompareNode(x, y, stackKind, false));</span>
<span class="line-removed"> 978                     } else if (cond1 == Condition.LT &amp;&amp; cond2 == Condition.EQ &amp;&amp; c1 == 1 &amp;&amp; c2 == 0 &amp;&amp; c3 == -1) {</span>
<span class="line-removed"> 979                         // x &lt; y ? 1 : (x == y ? 0 : -1) =&gt; y cmp x</span>
<span class="line-removed"> 980                         return graph().unique(new NormalizeCompareNode(y, x, stackKind, false));</span>
<span class="line-removed"> 981                     } else if (cond1 == Condition.EQ &amp;&amp; cond2 == Condition.LT &amp;&amp; c1 == 0 &amp;&amp; c2 == -1 &amp;&amp; c3 == 1) {</span>
<span class="line-removed"> 982                         // x == y ? 0 : (x &lt; y ? -1 : 1) =&gt; x cmp y</span>
<span class="line-removed"> 983                         return graph().unique(new NormalizeCompareNode(x, y, stackKind, false));</span>
<span class="line-removed"> 984                     } else if (cond1 == Condition.EQ &amp;&amp; cond2 == Condition.LT &amp;&amp; c1 == 0 &amp;&amp; c2 == 1 &amp;&amp; c3 == -1) {</span>
<span class="line-removed"> 985                         // x == y ? 0 : (x &lt; y ? 1 : -1) =&gt; y cmp x</span>
<span class="line-removed"> 986                         return graph().unique(new NormalizeCompareNode(y, x, stackKind, false));</span>
<span class="line-removed"> 987                     } else if (cond1 == Condition.EQ &amp;&amp; cond2 == Condition.GT &amp;&amp; c1 == 0 &amp;&amp; c2 == -1 &amp;&amp; c3 == 1) {</span>
<span class="line-removed"> 988                         // x == y ? 0 : (x &gt; y ? -1 : 1) =&gt; y cmp x</span>
<span class="line-removed"> 989                         return graph().unique(new NormalizeCompareNode(y, x, stackKind, false));</span>
<span class="line-removed"> 990                     } else if (cond1 == Condition.EQ &amp;&amp; cond2 == Condition.GT &amp;&amp; c1 == 0 &amp;&amp; c2 == 1 &amp;&amp; c3 == -1) {</span>
<span class="line-removed"> 991                         // x == y ? 0 : (x &gt; y ? 1 : -1) =&gt; x cmp y</span>
<span class="line-removed"> 992                         return graph().unique(new NormalizeCompareNode(x, y, stackKind, false));</span>
<span class="line-removed"> 993                     } else if (cond1 == Condition.LT &amp;&amp; cond2 == Condition.GT &amp;&amp; c1 == 1 &amp;&amp; c2 == -1 &amp;&amp; c3 == 0) {</span>
<span class="line-removed"> 994                         // x &lt; y ? 1 : (x &gt; y ? -1 : 0) =&gt; y cmp x</span>
<span class="line-removed"> 995                         return graph().unique(new NormalizeCompareNode(y, x, stackKind, false));</span>
<span class="line-removed"> 996                     } else if (cond1 == Condition.LT &amp;&amp; cond2 == Condition.GT &amp;&amp; c1 == -1 &amp;&amp; c2 == 1 &amp;&amp; c3 == 0) {</span>
<span class="line-removed"> 997                         // x &lt; y ? -1 : (x &gt; y ? 1 : 0) =&gt; x cmp y</span>
<span class="line-removed"> 998                         return graph().unique(new NormalizeCompareNode(x, y, stackKind, false));</span>
<span class="line-removed"> 999                     }</span>
<span class="line-removed">1000                 }</span>
<span class="line-removed">1001             }</span>
<span class="line-removed">1002         }</span>
<span class="line-removed">1003         return null;</span>
<span class="line-removed">1004     }</span>
1005 
<span class="line-modified">1006     /**</span>
<span class="line-modified">1007      * Take an if that is immediately dominated by a merge with a single phi and split off any paths</span>
<span class="line-modified">1008      * where the test would be statically decidable creating a new merge below the approriate side</span>
<span class="line-modified">1009      * of the IfNode. Any undecidable tests will continue to use the original IfNode.</span>
<span class="line-modified">1010      *</span>
<span class="line-removed">1011      * @param tool</span>
<span class="line-removed">1012      */</span>
<span class="line-removed">1013     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-removed">1014     private boolean splitIfAtPhi(SimplifierTool tool) {</span>
<span class="line-removed">1015         if (graph().getGuardsStage().areFrameStatesAtSideEffects()) {</span>
<span class="line-removed">1016             // Disabled until we make sure we have no FrameState-less merges at this stage</span>
<span class="line-removed">1017             return false;</span>
<span class="line-removed">1018         }</span>
<span class="line-removed">1019 </span>
<span class="line-removed">1020         if (!(predecessor() instanceof MergeNode)) {</span>
<span class="line-removed">1021             return false;</span>
<span class="line-removed">1022         }</span>
<span class="line-removed">1023         MergeNode merge = (MergeNode) predecessor();</span>
<span class="line-removed">1024         if (merge.forwardEndCount() == 1) {</span>
<span class="line-removed">1025             // Don&#39;t bother.</span>
<span class="line-removed">1026             return false;</span>
<span class="line-removed">1027         }</span>
<span class="line-removed">1028         if (merge.usages().count() != 1 || merge.phis().count() != 1) {</span>
<span class="line-removed">1029             return false;</span>
<span class="line-removed">1030         }</span>
<span class="line-removed">1031         if (merge.stateAfter() != null) {</span>
<span class="line-removed">1032             /* We&#39;ll get the chance to simplify this after frame state assignment. */</span>
<span class="line-removed">1033             return false;</span>
<span class="line-removed">1034         }</span>
<span class="line-removed">1035         PhiNode phi = merge.phis().first();</span>
<span class="line-removed">1036         if (phi.usages().count() != 1) {</span>
<span class="line-removed">1037             /*</span>
<span class="line-removed">1038              * For simplicity the below code assumes assumes the phi goes dead at the end so skip</span>
<span class="line-removed">1039              * this case.</span>
<span class="line-removed">1040              */</span>
<span class="line-removed">1041             return false;</span>
<span class="line-removed">1042         }</span>
<span class="line-removed">1043 </span>
<span class="line-removed">1044         /*</span>
<span class="line-removed">1045          * Check that the condition uses the phi and that there is only one user of the condition</span>
<span class="line-removed">1046          * expression.</span>
<span class="line-removed">1047          */</span>
<span class="line-removed">1048         if (!conditionUses(condition(), phi)) {</span>
<span class="line-removed">1049             return false;</span>
<span class="line-removed">1050         }</span>
<span class="line-removed">1051 </span>
<span class="line-removed">1052         /*</span>
<span class="line-removed">1053          * We could additionally filter for the case that at least some of the Phi inputs or one of</span>
<span class="line-removed">1054          * the condition inputs are constants but there are cases where a non-constant is</span>
<span class="line-removed">1055          * simplifiable, usually where the stamp allows the question to be answered.</span>
<span class="line-removed">1056          */</span>
<span class="line-removed">1057 </span>
<span class="line-removed">1058         /* Each successor of the if gets a new merge if needed. */</span>
<span class="line-removed">1059         MergeNode trueMerge = null;</span>
<span class="line-removed">1060         MergeNode falseMerge = null;</span>
<span class="line-removed">1061         assert merge.stateAfter() == null;</span>
<span class="line-removed">1062 </span>
<span class="line-removed">1063         for (EndNode end : merge.forwardEnds().snapshot()) {</span>
<span class="line-removed">1064             Node value = phi.valueAt(end);</span>
<span class="line-removed">1065             LogicNode result = computeCondition(tool, condition, phi, value);</span>
<span class="line-removed">1066             if (result instanceof LogicConstantNode) {</span>
<span class="line-removed">1067                 merge.removeEnd(end);</span>
<span class="line-removed">1068                 if (((LogicConstantNode) result).getValue()) {</span>
<span class="line-removed">1069                     if (trueMerge == null) {</span>
<span class="line-removed">1070                         trueMerge = insertMerge(trueSuccessor());</span>
1071                     }
<span class="line-modified">1072                     trueMerge.addForwardEnd(end);</span>
<span class="line-modified">1073                 } else {</span>
<span class="line-modified">1074                     if (falseMerge == null) {</span>
<span class="line-modified">1075                         falseMerge = insertMerge(falseSuccessor());</span>

1076                     }
<span class="line-modified">1077                     falseMerge.addForwardEnd(end);</span>
<span class="line-modified">1078                 }</span>
<span class="line-modified">1079             } else if (result != condition) {</span>
<span class="line-modified">1080                 // Build a new IfNode using the new condition</span>
<span class="line-modified">1081                 BeginNode trueBegin = graph().add(new BeginNode());</span>
<span class="line-modified">1082                 trueBegin.setNodeSourcePosition(trueSuccessor().getNodeSourcePosition());</span>
<span class="line-modified">1083                 BeginNode falseBegin = graph().add(new BeginNode());</span>
<span class="line-modified">1084                 falseBegin.setNodeSourcePosition(falseSuccessor().getNodeSourcePosition());</span>
<span class="line-modified">1085 </span>
<span class="line-modified">1086                 if (result.graph() == null) {</span>
<span class="line-modified">1087                     result = graph().addOrUniqueWithInputs(result);</span>
<span class="line-modified">1088                     result.setNodeSourcePosition(condition.getNodeSourcePosition());</span>
<span class="line-modified">1089                 }</span>
<span class="line-modified">1090                 IfNode newIfNode = graph().add(new IfNode(result, trueBegin, falseBegin, trueSuccessorProbability));</span>
<span class="line-modified">1091                 newIfNode.setNodeSourcePosition(getNodeSourcePosition());</span>
<span class="line-modified">1092                 merge.removeEnd(end);</span>
<span class="line-modified">1093                 ((FixedWithNextNode) end.predecessor()).setNext(newIfNode);</span>
<span class="line-modified">1094 </span>
<span class="line-modified">1095                 if (trueMerge == null) {</span>
<span class="line-modified">1096                     trueMerge = insertMerge(trueSuccessor());</span>
<span class="line-modified">1097                 }</span>
<span class="line-modified">1098                 trueBegin.setNext(graph().add(new EndNode()));</span>
<span class="line-modified">1099                 trueMerge.addForwardEnd((EndNode) trueBegin.next());</span>
<span class="line-modified">1100 </span>
<span class="line-modified">1101                 if (falseMerge == null) {</span>
<span class="line-modified">1102                     falseMerge = insertMerge(falseSuccessor());</span>
<span class="line-modified">1103                 }</span>
<span class="line-modified">1104                 falseBegin.setNext(graph().add(new EndNode()));</span>
<span class="line-modified">1105                 falseMerge.addForwardEnd((EndNode) falseBegin.next());</span>
<span class="line-modified">1106 </span>
<span class="line-modified">1107                 end.safeDelete();</span>
<span class="line-modified">1108             }</span>
<span class="line-modified">1109         }</span>
<span class="line-modified">1110 </span>
<span class="line-modified">1111         transferProxies(trueSuccessor(), trueMerge);</span>
<span class="line-removed">1112         transferProxies(falseSuccessor(), falseMerge);</span>
<span class="line-removed">1113 </span>
<span class="line-removed">1114         cleanupMerge(merge);</span>
<span class="line-removed">1115         cleanupMerge(trueMerge);</span>
<span class="line-removed">1116         cleanupMerge(falseMerge);</span>
<span class="line-removed">1117 </span>
<span class="line-removed">1118         return true;</span>
<span class="line-removed">1119     }</span>
<span class="line-removed">1120 </span>
<span class="line-removed">1121     /**</span>
<span class="line-removed">1122      * @param condition</span>
<span class="line-removed">1123      * @param phi</span>
<span class="line-removed">1124      * @return true if the passed in {@code condition} uses {@code phi} and the condition is only</span>
<span class="line-removed">1125      *         used once. Since the phi will go dead the condition using it will also have to be</span>
<span class="line-removed">1126      *         dead after the optimization.</span>
<span class="line-removed">1127      */</span>
<span class="line-removed">1128     private static boolean conditionUses(LogicNode condition, PhiNode phi) {</span>
<span class="line-removed">1129         if (condition.usages().count() != 1) {</span>
<span class="line-removed">1130             return false;</span>
<span class="line-removed">1131         }</span>
<span class="line-removed">1132         if (condition instanceof ShortCircuitOrNode) {</span>
<span class="line-removed">1133             if (condition.graph().getGuardsStage().areDeoptsFixed()) {</span>
<span class="line-removed">1134                 /*</span>
<span class="line-removed">1135                  * It can be unsafe to simplify a ShortCircuitOr before deopts are fixed because</span>
<span class="line-removed">1136                  * conversion to guards assumes that all the required conditions are being tested.</span>
<span class="line-removed">1137                  * Simplfying the condition based on context before this happens may lose a</span>
<span class="line-removed">1138                  * condition.</span>
<span class="line-removed">1139                  */</span>
<span class="line-removed">1140                 ShortCircuitOrNode orNode = (ShortCircuitOrNode) condition;</span>
<span class="line-removed">1141                 return (conditionUses(orNode.x, phi) || conditionUses(orNode.y, phi));</span>
<span class="line-removed">1142             }</span>
<span class="line-removed">1143         } else if (condition instanceof Canonicalizable.Unary&lt;?&gt;) {</span>
<span class="line-removed">1144             Canonicalizable.Unary&lt;?&gt; unary = (Canonicalizable.Unary&lt;?&gt;) condition;</span>
<span class="line-removed">1145             return unary.getValue() == phi;</span>
<span class="line-removed">1146         } else if (condition instanceof Canonicalizable.Binary&lt;?&gt;) {</span>
<span class="line-removed">1147             Canonicalizable.Binary&lt;?&gt; binary = (Canonicalizable.Binary&lt;?&gt;) condition;</span>
<span class="line-removed">1148             return binary.getX() == phi || binary.getY() == phi;</span>
<span class="line-removed">1149         }</span>
<span class="line-removed">1150         return false;</span>
<span class="line-removed">1151     }</span>
<span class="line-removed">1152 </span>
<span class="line-removed">1153     /**</span>
<span class="line-removed">1154      * Canonicalize {@code} condition using {@code value} in place of {@code phi}.</span>
<span class="line-removed">1155      *</span>
<span class="line-removed">1156      * @param tool</span>
<span class="line-removed">1157      * @param condition</span>
<span class="line-removed">1158      * @param phi</span>
<span class="line-removed">1159      * @param value</span>
<span class="line-removed">1160      * @return an improved LogicNode or the original condition</span>
<span class="line-removed">1161      */</span>
<span class="line-removed">1162     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">1163     private static LogicNode computeCondition(SimplifierTool tool, LogicNode condition, PhiNode phi, Node value) {</span>
<span class="line-removed">1164         if (condition instanceof ShortCircuitOrNode) {</span>
<span class="line-removed">1165             if (condition.graph().getGuardsStage().areDeoptsFixed() &amp;&amp; !condition.graph().isAfterExpandLogic()) {</span>
<span class="line-removed">1166                 ShortCircuitOrNode orNode = (ShortCircuitOrNode) condition;</span>
<span class="line-removed">1167                 LogicNode resultX = computeCondition(tool, orNode.x, phi, value);</span>
<span class="line-removed">1168                 LogicNode resultY = computeCondition(tool, orNode.y, phi, value);</span>
<span class="line-removed">1169                 if (resultX != orNode.x || resultY != orNode.y) {</span>
<span class="line-removed">1170                     LogicNode result = orNode.canonical(tool, resultX, resultY);</span>
<span class="line-removed">1171                     if (result != orNode) {</span>
<span class="line-removed">1172                         return result;</span>
1173                     }
<span class="line-removed">1174                     /*</span>
<span class="line-removed">1175                      * Create a new node to carry the optimized inputs.</span>
<span class="line-removed">1176                      */</span>
<span class="line-removed">1177                     ShortCircuitOrNode newOr = new ShortCircuitOrNode(resultX, orNode.xNegated, resultY,</span>
<span class="line-removed">1178                                     orNode.yNegated, orNode.getShortCircuitProbability());</span>
<span class="line-removed">1179                     return newOr.canonical(tool);</span>
1180                 }
<span class="line-removed">1181                 return orNode;</span>
<span class="line-removed">1182             }</span>
<span class="line-removed">1183         } else if (condition instanceof Canonicalizable.Binary&lt;?&gt;) {</span>
<span class="line-removed">1184             Canonicalizable.Binary&lt;Node&gt; compare = (Canonicalizable.Binary&lt;Node&gt;) condition;</span>
<span class="line-removed">1185             if (compare.getX() == phi) {</span>
<span class="line-removed">1186                 return (LogicNode) compare.canonical(tool, value, compare.getY());</span>
<span class="line-removed">1187             } else if (compare.getY() == phi) {</span>
<span class="line-removed">1188                 return (LogicNode) compare.canonical(tool, compare.getX(), value);</span>
<span class="line-removed">1189             }</span>
<span class="line-removed">1190         } else if (condition instanceof Canonicalizable.Unary&lt;?&gt;) {</span>
<span class="line-removed">1191             Canonicalizable.Unary&lt;Node&gt; compare = (Canonicalizable.Unary&lt;Node&gt;) condition;</span>
<span class="line-removed">1192             if (compare.getValue() == phi) {</span>
<span class="line-removed">1193                 return (LogicNode) compare.canonical(tool, value);</span>
<span class="line-removed">1194             }</span>
<span class="line-removed">1195         }</span>
<span class="line-removed">1196         if (condition instanceof Canonicalizable) {</span>
<span class="line-removed">1197             return (LogicNode) ((Canonicalizable) condition).canonical(tool);</span>
<span class="line-removed">1198         }</span>
<span class="line-removed">1199         return condition;</span>
<span class="line-removed">1200     }</span>
<span class="line-removed">1201 </span>
<span class="line-removed">1202     private static void transferProxies(AbstractBeginNode successor, MergeNode falseMerge) {</span>
<span class="line-removed">1203         if (successor instanceof LoopExitNode &amp;&amp; falseMerge != null) {</span>
<span class="line-removed">1204             LoopExitNode loopExitNode = (LoopExitNode) successor;</span>
<span class="line-removed">1205             for (ProxyNode proxy : loopExitNode.proxies().snapshot()) {</span>
<span class="line-removed">1206                 proxy.replaceFirstInput(successor, falseMerge);</span>
1207             }
1208         }

1209     }
1210 
<span class="line-modified">1211     private void cleanupMerge(MergeNode merge) {</span>
<span class="line-modified">1212         if (merge != null &amp;&amp; merge.isAlive()) {</span>
<span class="line-modified">1213             if (merge.forwardEndCount() == 0) {</span>
<span class="line-modified">1214                 GraphUtil.killCFG(merge);</span>
<span class="line-modified">1215             } else if (merge.forwardEndCount() == 1) {</span>
<span class="line-modified">1216                 graph().reduceTrivialMerge(merge);</span>
<span class="line-modified">1217             }</span>

1218         }
1219     }
1220 
<span class="line-modified">1221     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-modified">1222     private MergeNode insertMerge(AbstractBeginNode begin) {</span>
<span class="line-modified">1223         MergeNode merge = graph().add(new MergeNode());</span>
<span class="line-modified">1224         if (!begin.anchored().isEmpty()) {</span>
<span class="line-modified">1225             Object before = null;</span>
<span class="line-modified">1226             before = begin.anchored().snapshot();</span>
<span class="line-modified">1227             begin.replaceAtUsages(InputType.Guard, merge);</span>
<span class="line-removed">1228             begin.replaceAtUsages(InputType.Anchor, merge);</span>
<span class="line-removed">1229             assert begin.anchored().isEmpty() : before + &quot; &quot; + begin.anchored().snapshot();</span>
<span class="line-removed">1230         }</span>
<span class="line-removed">1231 </span>
<span class="line-removed">1232         AbstractBeginNode theBegin = begin;</span>
<span class="line-removed">1233         if (begin instanceof LoopExitNode) {</span>
<span class="line-removed">1234             // Insert an extra begin to make it easier.</span>
<span class="line-removed">1235             try (DebugCloseable position = begin.withNodeSourcePosition()) {</span>
<span class="line-removed">1236                 theBegin = graph().add(new BeginNode());</span>
<span class="line-removed">1237                 begin.replaceAtPredecessor(theBegin);</span>
<span class="line-removed">1238                 theBegin.setNext(begin);</span>
<span class="line-removed">1239             }</span>
<span class="line-removed">1240         }</span>
<span class="line-removed">1241         FixedNode next = theBegin.next();</span>
<span class="line-removed">1242         next.replaceAtPredecessor(merge);</span>
<span class="line-removed">1243         theBegin.setNext(graph().add(new EndNode()));</span>
<span class="line-removed">1244         merge.addForwardEnd((EndNode) theBegin.next());</span>
<span class="line-removed">1245         merge.setNext(next);</span>
<span class="line-removed">1246         return merge;</span>
1247     }
1248 
1249     /**
1250      * Tries to connect code that initializes a variable directly with the successors of an if
1251      * construct that switches on the variable. For example, the pseudo code below:
1252      *
1253      * &lt;pre&gt;
1254      * contains(list, e, yes, no) {
1255      *     if (list == null || e == null) {
1256      *         condition = false;
1257      *     } else {
1258      *         condition = false;
1259      *         for (i in list) {
1260      *             if (i.equals(e)) {
1261      *                 condition = true;
1262      *                 break;
1263      *             }
1264      *         }
1265      *     }
1266      *     if (condition) {
</pre>
<hr />
<pre>
1300         if (!(condition() instanceof CompareNode)) {
1301             return false;
1302         }
1303 
1304         CompareNode compare = (CompareNode) condition();
1305         if (compare.getUsageCount() != 1) {
1306             return false;
1307         }
1308 
1309         // Only consider merges with a single usage that is both a phi and an operand of the
1310         // comparison
1311         NodeIterable&lt;Node&gt; mergeUsages = merge.usages();
1312         if (mergeUsages.count() != 1) {
1313             return false;
1314         }
1315         Node singleUsage = mergeUsages.first();
1316         if (!(singleUsage instanceof ValuePhiNode) || (singleUsage != compare.getX() &amp;&amp; singleUsage != compare.getY())) {
1317             return false;
1318         }
1319 




1320         // Ensure phi is used by at most the comparison and the merge&#39;s frame state (if any)
1321         ValuePhiNode phi = (ValuePhiNode) singleUsage;
1322         NodeIterable&lt;Node&gt; phiUsages = phi.usages();
<span class="line-removed">1323         if (phiUsages.count() &gt; 2) {</span>
<span class="line-removed">1324             return false;</span>
<span class="line-removed">1325         }</span>
1326         for (Node usage : phiUsages) {
<span class="line-modified">1327             if (usage != compare &amp;&amp; usage != merge.stateAfter()) {</span>
<span class="line-modified">1328                 return false;</span>





































1329             }

1330         }
1331 
1332         List&lt;EndNode&gt; mergePredecessors = merge.cfgPredecessors().snapshot();
1333         assert phi.valueCount() == merge.forwardEndCount();
1334 
1335         Constant[] xs = constantValues(compare.getX(), merge, false);
1336         Constant[] ys = constantValues(compare.getY(), merge, false);
1337         if (xs == null || ys == null) {
1338             return false;
1339         }
1340 
<span class="line-modified">1341         // Sanity check that both ends are not followed by a merge without frame state.</span>
<span class="line-removed">1342         if (!checkFrameState(trueSuccessor()) &amp;&amp; !checkFrameState(falseSuccessor())) {</span>
1343             return false;
1344         }
1345 
1346         List&lt;EndNode&gt; falseEnds = new ArrayList&lt;&gt;(mergePredecessors.size());
1347         List&lt;EndNode&gt; trueEnds = new ArrayList&lt;&gt;(mergePredecessors.size());
1348         EconomicMap&lt;AbstractEndNode, ValueNode&gt; phiValues = EconomicMap.create(Equivalence.IDENTITY, mergePredecessors.size());
1349 
1350         AbstractBeginNode oldFalseSuccessor = falseSuccessor();
1351         AbstractBeginNode oldTrueSuccessor = trueSuccessor();
1352 
1353         setFalseSuccessor(null);
1354         setTrueSuccessor(null);
1355 
1356         Iterator&lt;EndNode&gt; ends = mergePredecessors.iterator();
1357         for (int i = 0; i &lt; xs.length; i++) {
1358             EndNode end = ends.next();
1359             phiValues.put(end, phi.valueAt(end));
1360             if (compare.condition().foldCondition(xs[i], ys[i], tool.getConstantReflection(), compare.unorderedIsTrue())) {
1361                 trueEnds.add(end);
1362             } else {
1363                 falseEnds.add(end);
1364             }
1365         }
1366         assert !ends.hasNext();
1367         assert falseEnds.size() + trueEnds.size() == xs.length;
1368 
<span class="line-modified">1369         connectEnds(falseEnds, phiValues, oldFalseSuccessor, merge, tool);</span>
<span class="line-modified">1370         connectEnds(trueEnds, phiValues, oldTrueSuccessor, merge, tool);</span>
1371 
1372         if (this.trueSuccessorProbability == 0.0) {
1373             for (AbstractEndNode endNode : trueEnds) {
1374                 propagateZeroProbability(endNode);
1375             }
1376         }
1377 
1378         if (this.trueSuccessorProbability == 1.0) {
1379             for (AbstractEndNode endNode : falseEnds) {
1380                 propagateZeroProbability(endNode);
1381             }
1382         }
1383 
1384         /*
1385          * Remove obsolete ends only after processing all ends, otherwise oldTrueSuccessor or
1386          * oldFalseSuccessor might have been removed if it is a LoopExitNode.
1387          */
1388         if (falseEnds.isEmpty()) {
1389             GraphUtil.killCFG(oldFalseSuccessor);
1390         }
1391         if (trueEnds.isEmpty()) {
1392             GraphUtil.killCFG(oldTrueSuccessor);
1393         }
1394         GraphUtil.killCFG(merge);
1395 
1396         assert !merge.isAlive() : merge;
1397         assert !phi.isAlive() : phi;
1398         assert !compare.isAlive() : compare;
1399         assert !this.isAlive() : this;
1400 
1401         return true;
1402     }
1403 
<span class="line-modified">1404     private void propagateZeroProbability(FixedNode startNode) {</span>
1405         Node prev = null;
1406         for (FixedNode node : GraphUtil.predecessorIterable(startNode)) {
1407             if (node instanceof IfNode) {
1408                 IfNode ifNode = (IfNode) node;
1409                 if (ifNode.trueSuccessor() == prev) {
1410                     if (ifNode.trueSuccessorProbability == 0.0) {
1411                         return;
1412                     } else if (ifNode.trueSuccessorProbability == 1.0) {
1413                         continue;
1414                     } else {
1415                         ifNode.setTrueSuccessorProbability(0.0);
1416                         return;
1417                     }
1418                 } else if (ifNode.falseSuccessor() == prev) {
1419                     if (ifNode.trueSuccessorProbability == 1.0) {
1420                         return;
1421                     } else if (ifNode.trueSuccessorProbability == 0.0) {
1422                         continue;
1423                     } else {
1424                         ifNode.setTrueSuccessorProbability(1.0);
1425                         return;
1426                     }
1427                 } else {
1428                     throw new GraalError(&quot;Illegal state&quot;);
1429                 }
1430             } else if (node instanceof AbstractMergeNode &amp;&amp; !(node instanceof LoopBeginNode)) {
1431                 for (AbstractEndNode endNode : ((AbstractMergeNode) node).cfgPredecessors()) {
1432                     propagateZeroProbability(endNode);
1433                 }
1434                 return;
1435             }
1436             prev = node;
1437         }
1438     }
1439 
<span class="line-removed">1440     private static boolean checkFrameState(FixedNode start) {</span>
<span class="line-removed">1441         FixedNode node = start;</span>
<span class="line-removed">1442         while (true) {</span>
<span class="line-removed">1443             if (node instanceof AbstractMergeNode) {</span>
<span class="line-removed">1444                 AbstractMergeNode mergeNode = (AbstractMergeNode) node;</span>
<span class="line-removed">1445                 if (mergeNode.stateAfter() == null) {</span>
<span class="line-removed">1446                     return false;</span>
<span class="line-removed">1447                 } else {</span>
<span class="line-removed">1448                     return true;</span>
<span class="line-removed">1449                 }</span>
<span class="line-removed">1450             } else if (node instanceof StateSplit) {</span>
<span class="line-removed">1451                 StateSplit stateSplitNode = (StateSplit) node;</span>
<span class="line-removed">1452                 if (stateSplitNode.stateAfter() != null) {</span>
<span class="line-removed">1453                     return true;</span>
<span class="line-removed">1454                 }</span>
<span class="line-removed">1455             }</span>
<span class="line-removed">1456 </span>
<span class="line-removed">1457             if (node instanceof ControlSplitNode) {</span>
<span class="line-removed">1458                 ControlSplitNode controlSplitNode = (ControlSplitNode) node;</span>
<span class="line-removed">1459                 for (Node succ : controlSplitNode.cfgSuccessors()) {</span>
<span class="line-removed">1460                     if (checkFrameState((FixedNode) succ)) {</span>
<span class="line-removed">1461                         return true;</span>
<span class="line-removed">1462                     }</span>
<span class="line-removed">1463                 }</span>
<span class="line-removed">1464                 return false;</span>
<span class="line-removed">1465             } else if (node instanceof FixedWithNextNode) {</span>
<span class="line-removed">1466                 FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) node;</span>
<span class="line-removed">1467                 node = fixedWithNextNode.next();</span>
<span class="line-removed">1468             } else if (node instanceof AbstractEndNode) {</span>
<span class="line-removed">1469                 AbstractEndNode endNode = (AbstractEndNode) node;</span>
<span class="line-removed">1470                 node = endNode.merge();</span>
<span class="line-removed">1471             } else if (node instanceof ControlSinkNode) {</span>
<span class="line-removed">1472                 return true;</span>
<span class="line-removed">1473             } else {</span>
<span class="line-removed">1474                 return false;</span>
<span class="line-removed">1475             }</span>
<span class="line-removed">1476         }</span>
<span class="line-removed">1477     }</span>
<span class="line-removed">1478 </span>
1479     /**
1480      * Connects a set of ends to a given successor, inserting a merge node if there is more than one
1481      * end. If {@code ends} is not empty, then {@code successor} is added to {@code tool}&#39;s
1482      * {@linkplain SimplifierTool#addToWorkList(org.graalvm.compiler.graph.Node) work list}.
1483      *
<span class="line-modified">1484      * @param oldMerge the merge being removed</span>
1485      * @param phiValues the values of the phi at the merge, keyed by the merge ends

1486      */
<span class="line-modified">1487     private void connectEnds(List&lt;EndNode&gt; ends, EconomicMap&lt;AbstractEndNode, ValueNode&gt; phiValues, AbstractBeginNode successor, AbstractMergeNode oldMerge, SimplifierTool tool) {</span>
1488         if (!ends.isEmpty()) {










1489             if (ends.size() == 1) {
1490                 AbstractEndNode end = ends.get(0);



1491                 ((FixedWithNextNode) end.predecessor()).setNext(successor);
1492                 oldMerge.removeEnd(end);
1493                 GraphUtil.killCFG(end);
1494             } else {
1495                 // Need a new phi in case the frame state is used by more than the merge being
1496                 // removed.
1497                 NodeView view = NodeView.from(tool);
1498                 AbstractMergeNode newMerge = graph().add(new MergeNode());
1499                 PhiNode oldPhi = (PhiNode) oldMerge.usages().first();
1500                 PhiNode newPhi = graph().addWithoutUnique(new ValuePhiNode(oldPhi.stamp(view), newMerge));
1501 




1502                 for (EndNode end : ends) {
1503                     newPhi.addInput(phiValues.get(end));
1504                     newMerge.addForwardEnd(end);
1505                 }
1506 
1507                 FrameState stateAfter = oldMerge.stateAfter();
1508                 if (stateAfter != null) {
1509                     stateAfter = stateAfter.duplicate();
1510                     stateAfter.replaceFirstInput(oldPhi, newPhi);
1511                     newMerge.setStateAfter(stateAfter);
1512                 }
1513 
1514                 newMerge.setNext(successor);
1515             }
1516             tool.addToWorkList(successor);
1517         }
1518     }
1519 
1520     /**
1521      * Gets an array of constants derived from a node that is either a {@link ConstantNode} or a
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.nodes;
  26 
  27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_1;
  28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_2;
  29 
  30 import java.util.ArrayList;
  31 import java.util.Arrays;
  32 import java.util.Iterator;
  33 import java.util.List;
  34 import java.util.Objects;
  35 
  36 import jdk.internal.vm.compiler.collections.EconomicMap;
  37 import jdk.internal.vm.compiler.collections.Equivalence;
  38 import org.graalvm.compiler.bytecode.BytecodeDisassembler;
  39 import org.graalvm.compiler.bytecode.Bytecodes;
  40 import org.graalvm.compiler.bytecode.Bytes;
  41 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  42 import org.graalvm.compiler.core.common.calc.Condition;
<span class="line-added">  43 import org.graalvm.compiler.core.common.type.FloatStamp;</span>
  44 import org.graalvm.compiler.core.common.type.IntegerStamp;
<span class="line-added">  45 import org.graalvm.compiler.core.common.type.PrimitiveStamp;</span>
  46 import org.graalvm.compiler.core.common.type.Stamp;
  47 import org.graalvm.compiler.core.common.type.StampFactory;
  48 import org.graalvm.compiler.debug.CounterKey;
  49 import org.graalvm.compiler.debug.DebugCloseable;
  50 import org.graalvm.compiler.debug.DebugContext;
  51 import org.graalvm.compiler.debug.GraalError;
<span class="line-added">  52 import org.graalvm.compiler.graph.IterableNodeType;</span>
  53 import org.graalvm.compiler.graph.Node;
  54 import org.graalvm.compiler.graph.NodeClass;
  55 import org.graalvm.compiler.graph.NodeSourcePosition;
  56 import org.graalvm.compiler.graph.iterators.NodeIterable;

  57 import org.graalvm.compiler.graph.spi.Simplifiable;
  58 import org.graalvm.compiler.graph.spi.SimplifierTool;
  59 import org.graalvm.compiler.nodeinfo.InputType;
  60 import org.graalvm.compiler.nodeinfo.NodeInfo;
<span class="line-added">  61 import org.graalvm.compiler.nodes.calc.AddNode;</span>
  62 import org.graalvm.compiler.nodes.calc.CompareNode;
  63 import org.graalvm.compiler.nodes.calc.ConditionalNode;
<span class="line-added">  64 import org.graalvm.compiler.nodes.calc.FloatNormalizeCompareNode;</span>
  65 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  66 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  67 import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;
<span class="line-added">  68 import org.graalvm.compiler.nodes.calc.IntegerNormalizeCompareNode;</span>
  69 import org.graalvm.compiler.nodes.calc.IsNullNode;

  70 import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
  71 import org.graalvm.compiler.nodes.extended.UnboxNode;
  72 import org.graalvm.compiler.nodes.java.InstanceOfNode;
  73 import org.graalvm.compiler.nodes.java.LoadFieldNode;
  74 import org.graalvm.compiler.nodes.spi.LIRLowerable;
  75 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
<span class="line-added">  76 import org.graalvm.compiler.nodes.spi.SwitchFoldable;</span>
  77 import org.graalvm.compiler.nodes.util.GraphUtil;
  78 
<span class="line-added">  79 import jdk.vm.ci.code.CodeUtil;</span>
  80 import jdk.vm.ci.meta.Constant;
  81 import jdk.vm.ci.meta.JavaConstant;
  82 import jdk.vm.ci.meta.JavaKind;
  83 import jdk.vm.ci.meta.MetaAccessProvider;
  84 import jdk.vm.ci.meta.PrimitiveConstant;
  85 import jdk.vm.ci.meta.ResolvedJavaMethod;
  86 import jdk.vm.ci.meta.ResolvedJavaType;
  87 import jdk.vm.ci.meta.TriState;
  88 
  89 /**
  90  * The {@code IfNode} represents a branch that can go one of two directions depending on the outcome
  91  * of a comparison.
  92  */
  93 @NodeInfo(cycles = CYCLES_1, size = SIZE_2, sizeRationale = &quot;2 jmps&quot;)
<span class="line-modified">  94 public final class IfNode extends ControlSplitNode implements Simplifiable, LIRLowerable, IterableNodeType, SwitchFoldable {</span>
  95     public static final NodeClass&lt;IfNode&gt; TYPE = NodeClass.create(IfNode.class);
  96 
  97     private static final CounterKey CORRECTED_PROBABILITIES = DebugContext.counter(&quot;CorrectedProbabilities&quot;);
  98 
  99     @Successor AbstractBeginNode trueSuccessor;
 100     @Successor AbstractBeginNode falseSuccessor;
 101     @Input(InputType.Condition) LogicNode condition;
 102     protected double trueSuccessorProbability;
 103 
 104     public LogicNode condition() {
 105         return condition;
 106     }
 107 
 108     public void setCondition(LogicNode x) {
 109         updateUsages(condition, x);
 110         condition = x;
 111     }
 112 
 113     public IfNode(LogicNode condition, FixedNode trueSuccessor, FixedNode falseSuccessor, double trueSuccessorProbability) {
 114         this(condition, BeginNode.begin(trueSuccessor), BeginNode.begin(falseSuccessor), trueSuccessorProbability);
</pre>
<hr />
<pre>
 276             } else {
 277                 tool.deleteBranch(trueSuccessor());
 278                 tool.addToWorkList(falseSuccessor());
 279                 graph().removeSplit(this, falseSuccessor());
 280             }
 281             return;
 282         }
 283         if (tool.allUsagesAvailable() &amp;&amp; trueSuccessor().hasNoUsages() &amp;&amp; falseSuccessor().hasNoUsages()) {
 284 
 285             pushNodesThroughIf(tool);
 286 
 287             if (checkForUnsignedCompare(tool) || removeOrMaterializeIf(tool)) {
 288                 return;
 289             }
 290         }
 291 
 292         if (removeIntermediateMaterialization(tool)) {
 293             return;
 294         }
 295 
<span class="line-modified"> 296         if (conditionalNodeOptimization(tool)) {</span>
 297             return;
 298         }
 299 
<span class="line-modified"> 300         if (switchTransformationOptimization(tool)) {</span>
 301             return;
 302         }
 303 
<span class="line-modified"> 304         if (falseSuccessor().hasNoUsages() &amp;&amp; (!(falseSuccessor() instanceof LoopExitNode)) &amp;&amp; falseSuccessor().next() instanceof IfNode &amp;&amp;</span>
<span class="line-added"> 305                         !(((IfNode) falseSuccessor().next()).falseSuccessor() instanceof LoopExitNode)) {</span>
 306             AbstractBeginNode intermediateBegin = falseSuccessor();
 307             IfNode nextIf = (IfNode) intermediateBegin.next();
 308             double probabilityB = (1.0 - this.trueSuccessorProbability) * nextIf.trueSuccessorProbability;
 309             if (this.trueSuccessorProbability &lt; probabilityB) {
 310                 // Reordering of those two if statements is beneficial from the point of view of
 311                 // their probabilities.
 312                 if (prepareForSwap(tool, condition(), nextIf.condition())) {
 313                     // Reordering is allowed from (if1 =&gt; begin =&gt; if2) to (if2 =&gt; begin =&gt; if1).
 314                     assert intermediateBegin.next() == nextIf;
 315                     AbstractBeginNode bothFalseBegin = nextIf.falseSuccessor();
 316                     nextIf.setFalseSuccessor(null);
 317                     intermediateBegin.setNext(null);
 318                     this.setFalseSuccessor(null);
 319 
 320                     this.replaceAtPredecessor(nextIf);
 321                     nextIf.setFalseSuccessor(intermediateBegin);
 322                     intermediateBegin.setNext(this);
 323                     this.setFalseSuccessor(bothFalseBegin);
 324 
 325                     NodeSourcePosition intermediateBeginPosition = intermediateBegin.getNodeSourcePosition();
 326                     intermediateBegin.setNodeSourcePosition(bothFalseBegin.getNodeSourcePosition());
 327                     bothFalseBegin.setNodeSourcePosition(intermediateBeginPosition);
 328 
 329                     nextIf.setTrueSuccessorProbability(probabilityB);
 330                     if (probabilityB == 1.0) {
 331                         this.setTrueSuccessorProbability(0.0);
 332                     } else {
 333                         double newProbability = this.trueSuccessorProbability / (1.0 - probabilityB);
 334                         this.setTrueSuccessorProbability(Math.min(1.0, newProbability));
 335                     }
 336                     return;
 337                 }
 338             }
 339         }
 340 
 341         if (tryEliminateBoxedReferenceEquals(tool)) {
 342             return;
 343         }
 344     }
 345 
<span class="line-modified"> 346     private static boolean isUnboxedFrom(MetaAccessProvider meta, NodeView view, ValueNode x, ValueNode src) {</span>
 347         if (x == src) {
 348             return true;
 349         } else if (x instanceof UnboxNode) {
 350             return isUnboxedFrom(meta, view, ((UnboxNode) x).getValue(), src);
 351         } else if (x instanceof PiNode) {
 352             PiNode pi = (PiNode) x;
 353             return isUnboxedFrom(meta, view, pi.getOriginalNode(), src);
 354         } else if (x instanceof LoadFieldNode) {
 355             LoadFieldNode load = (LoadFieldNode) x;
 356             ResolvedJavaType integerType = meta.lookupJavaType(Integer.class);
 357             if (load.getValue().stamp(view).javaType(meta).equals(integerType)) {
 358                 return isUnboxedFrom(meta, view, load.getValue(), src);
 359             } else {
 360                 return false;
 361             }
 362         } else {
 363             return false;
 364         }
 365     }
 366 
</pre>
<hr />
<pre>
 441             FixedGuardNode fixed = (FixedGuardNode) node;
 442             if (!(fixed.condition() instanceof IntegerEqualsNode)) {
 443                 continue;
 444             }
 445             IntegerEqualsNode equals = (IntegerEqualsNode) fixed.condition();
 446             if ((isUnboxedFrom(meta, view, equals.getX(), x) &amp;&amp; isUnboxedFrom(meta, view, equals.getY(), y)) ||
 447                             (isUnboxedFrom(meta, view, equals.getX(), y) &amp;&amp; isUnboxedFrom(meta, view, equals.getY(), x))) {
 448                 unboxCheck = fixed;
 449             }
 450         }
 451         if (unbox == null || unboxCheck == null) {
 452             return false;
 453         }
 454 
 455         // Falsify the reference check.
 456         setCondition(graph().addOrUniqueWithInputs(LogicConstantNode.contradiction()));
 457 
 458         return true;
 459     }
 460 
<span class="line-added"> 461     // SwitchFoldable implementation.</span>
<span class="line-added"> 462 </span>
<span class="line-added"> 463     @Override</span>
<span class="line-added"> 464     public Node getNextSwitchFoldableBranch() {</span>
<span class="line-added"> 465         return falseSuccessor();</span>
<span class="line-added"> 466     }</span>
<span class="line-added"> 467 </span>
<span class="line-added"> 468     @Override</span>
<span class="line-added"> 469     public boolean isInSwitch(ValueNode switchValue) {</span>
<span class="line-added"> 470         return SwitchFoldable.maybeIsInSwitch(condition()) &amp;&amp; SwitchFoldable.sameSwitchValue(condition(), switchValue);</span>
<span class="line-added"> 471     }</span>
<span class="line-added"> 472 </span>
<span class="line-added"> 473     @Override</span>
<span class="line-added"> 474     public void cutOffCascadeNode() {</span>
<span class="line-added"> 475         setTrueSuccessor(null);</span>
<span class="line-added"> 476     }</span>
<span class="line-added"> 477 </span>
<span class="line-added"> 478     @Override</span>
<span class="line-added"> 479     public void cutOffLowestCascadeNode() {</span>
<span class="line-added"> 480         setFalseSuccessor(null);</span>
<span class="line-added"> 481         setTrueSuccessor(null);</span>
<span class="line-added"> 482     }</span>
<span class="line-added"> 483 </span>
<span class="line-added"> 484     @Override</span>
<span class="line-added"> 485     public AbstractBeginNode getDefault() {</span>
<span class="line-added"> 486         return falseSuccessor();</span>
<span class="line-added"> 487     }</span>
<span class="line-added"> 488 </span>
<span class="line-added"> 489     @Override</span>
<span class="line-added"> 490     public ValueNode switchValue() {</span>
<span class="line-added"> 491         if (SwitchFoldable.maybeIsInSwitch(condition())) {</span>
<span class="line-added"> 492             return ((IntegerEqualsNode) condition()).getX();</span>
<span class="line-added"> 493         }</span>
<span class="line-added"> 494         return null;</span>
<span class="line-added"> 495     }</span>
<span class="line-added"> 496 </span>
<span class="line-added"> 497     @Override</span>
<span class="line-added"> 498     public boolean isNonInitializedProfile() {</span>
<span class="line-added"> 499         return getTrueSuccessorProbability() == 0.5d;</span>
<span class="line-added"> 500     }</span>
<span class="line-added"> 501 </span>
<span class="line-added"> 502     @Override</span>
<span class="line-added"> 503     public int intKeyAt(int i) {</span>
<span class="line-added"> 504         assert i == 0;</span>
<span class="line-added"> 505         return ((IntegerEqualsNode) condition()).getY().asJavaConstant().asInt();</span>
<span class="line-added"> 506     }</span>
<span class="line-added"> 507 </span>
<span class="line-added"> 508     @Override</span>
<span class="line-added"> 509     public double keyProbability(int i) {</span>
<span class="line-added"> 510         assert i == 0;</span>
<span class="line-added"> 511         return getTrueSuccessorProbability();</span>
<span class="line-added"> 512     }</span>
<span class="line-added"> 513 </span>
<span class="line-added"> 514     @Override</span>
<span class="line-added"> 515     public AbstractBeginNode keySuccessor(int i) {</span>
<span class="line-added"> 516         assert i == 0;</span>
<span class="line-added"> 517         return trueSuccessor();</span>
<span class="line-added"> 518     }</span>
<span class="line-added"> 519 </span>
<span class="line-added"> 520     @Override</span>
<span class="line-added"> 521     public double defaultProbability() {</span>
<span class="line-added"> 522         return 1.0d - getTrueSuccessorProbability();</span>
<span class="line-added"> 523     }</span>
<span class="line-added"> 524 </span>
 525     /**
 526      * Try to optimize this as if it were a {@link ConditionalNode}.
 527      */
 528     private boolean conditionalNodeOptimization(SimplifierTool tool) {
 529         if (trueSuccessor().next() instanceof AbstractEndNode &amp;&amp; falseSuccessor().next() instanceof AbstractEndNode) {
 530             AbstractEndNode trueEnd = (AbstractEndNode) trueSuccessor().next();
 531             AbstractEndNode falseEnd = (AbstractEndNode) falseSuccessor().next();
 532             if (trueEnd.merge() != falseEnd.merge()) {
 533                 return false;
 534             }
 535             if (!(trueEnd.merge() instanceof MergeNode)) {
 536                 return false;
 537             }
 538             MergeNode merge = (MergeNode) trueEnd.merge();
<span class="line-modified"> 539             if (!merge.hasExactlyOneUsage() || merge.phis().count() != 1) {</span>
 540                 return false;
 541             }
 542 
<span class="line-modified"> 543             if (trueSuccessor().hasAnchored() || falseSuccessor().hasAnchored()) {</span>
 544                 return false;
 545             }
 546 
 547             PhiNode phi = merge.phis().first();
 548             ValueNode falseValue = phi.valueAt(falseEnd);
 549             ValueNode trueValue = phi.valueAt(trueEnd);
 550 
 551             NodeView view = NodeView.from(tool);
 552             ValueNode result = ConditionalNode.canonicalizeConditional(condition, trueValue, falseValue, phi.stamp(view), view);
 553             if (result != null) {
 554                 /*
 555                  * canonicalizeConditional returns possibly new nodes so add them to the graph.
 556                  */
 557                 if (result.graph() == null) {
 558                     result = graph().addOrUniqueWithInputs(result);
 559                 }
 560                 result = proxyReplacement(result);
 561                 /*
 562                  * This optimization can be performed even if multiple values merge at this phi
 563                  * since the two inputs get simplified into one.
</pre>
<hr />
<pre>
 657                             below = graph().unique(new IntegerBelowNode(lessThan.getX(), newLimit));
 658                         }
 659                     }
 660                     if (below != null) {
 661                         try (DebugCloseable position = ifNode2.withNodeSourcePosition()) {
 662                             ifNode2.setTrueSuccessor(null);
 663                             ifNode2.setFalseSuccessor(null);
 664 
 665                             IfNode newIfNode = graph().add(new IfNode(below, falseSucc, trueSucc, 1 - trueSuccessorProbability));
 666                             // Remove the &lt; 0 test.
 667                             tool.deleteBranch(trueSuccessor);
 668                             graph().removeSplit(this, falseSuccessor);
 669 
 670                             // Replace the second test with the new one.
 671                             ifNode2.predecessor().replaceFirstSuccessor(ifNode2, newIfNode);
 672                             ifNode2.safeDelete();
 673                             return true;
 674                         }
 675                     }
 676                 }
<span class="line-added"> 677             } else if (y instanceof PrimitiveConstant &amp;&amp; ((PrimitiveConstant) y).asLong() &lt; 0 &amp;&amp; falseSuccessor().next() instanceof IfNode) {</span>
<span class="line-added"> 678                 IfNode ifNode2 = (IfNode) falseSuccessor().next();</span>
<span class="line-added"> 679                 AbstractBeginNode falseSucc = ifNode2.falseSuccessor();</span>
<span class="line-added"> 680                 AbstractBeginNode trueSucc = ifNode2.trueSuccessor();</span>
<span class="line-added"> 681                 IntegerBelowNode below = null;</span>
<span class="line-added"> 682                 if (ifNode2.condition() instanceof IntegerLessThanNode) {</span>
<span class="line-added"> 683                     ValueNode x = lessThan.getX();</span>
<span class="line-added"> 684                     IntegerLessThanNode lessThan2 = (IntegerLessThanNode) ifNode2.condition();</span>
<span class="line-added"> 685                     /*</span>
<span class="line-added"> 686                      * Convert x &gt;= -C1 &amp;&amp; x &lt; C2, represented as !(x &lt; -C1) &amp;&amp; x &lt; C2, into an</span>
<span class="line-added"> 687                      * unsigned compare. This condition is equivalent to x + C1 |&lt;| C1 + C2 if C1 +</span>
<span class="line-added"> 688                      * C2 does not overflow.</span>
<span class="line-added"> 689                      */</span>
<span class="line-added"> 690                     Constant c2 = lessThan2.getY().stamp(view).asConstant();</span>
<span class="line-added"> 691                     if (lessThan2.getX() == x &amp;&amp; c2 instanceof PrimitiveConstant &amp;&amp; ((PrimitiveConstant) c2).asLong() &gt; 0 &amp;&amp;</span>
<span class="line-added"> 692                                     x.stamp(view).isCompatible(lessThan.getY().stamp(view)) &amp;&amp;</span>
<span class="line-added"> 693                                     x.stamp(view).isCompatible(lessThan2.getY().stamp(view)) &amp;&amp;</span>
<span class="line-added"> 694                                     sameDestination(trueSuccessor(), ifNode2.falseSuccessor)) {</span>
<span class="line-added"> 695                         long newLimitValue = -((PrimitiveConstant) y).asLong() + ((PrimitiveConstant) c2).asLong();</span>
<span class="line-added"> 696                         // Make sure the limit fits into the target type without overflow.</span>
<span class="line-added"> 697                         if (newLimitValue &gt; 0 &amp;&amp; newLimitValue &lt;= CodeUtil.maxValue(PrimitiveStamp.getBits(x.stamp(view)))) {</span>
<span class="line-added"> 698                             ConstantNode newLimit = ConstantNode.forIntegerStamp(x.stamp(view), newLimitValue, graph());</span>
<span class="line-added"> 699                             ConstantNode c1 = ConstantNode.forIntegerStamp(x.stamp(view), -((PrimitiveConstant) y).asLong(), graph());</span>
<span class="line-added"> 700                             ValueNode addNode = graph().addOrUniqueWithInputs(AddNode.create(x, c1, view));</span>
<span class="line-added"> 701                             below = graph().unique(new IntegerBelowNode(addNode, newLimit));</span>
<span class="line-added"> 702                         }</span>
<span class="line-added"> 703                     }</span>
<span class="line-added"> 704                 }</span>
<span class="line-added"> 705                 if (below != null) {</span>
<span class="line-added"> 706                     try (DebugCloseable position = ifNode2.withNodeSourcePosition()) {</span>
<span class="line-added"> 707                         ifNode2.setTrueSuccessor(null);</span>
<span class="line-added"> 708                         ifNode2.setFalseSuccessor(null);</span>
<span class="line-added"> 709 </span>
<span class="line-added"> 710                         IfNode newIfNode = graph().add(new IfNode(below, trueSucc, falseSucc, trueSuccessorProbability));</span>
<span class="line-added"> 711                         // Remove the &lt; -C1 test.</span>
<span class="line-added"> 712                         tool.deleteBranch(trueSuccessor);</span>
<span class="line-added"> 713                         graph().removeSplit(this, falseSuccessor);</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715                         // Replace the second test with the new one.</span>
<span class="line-added"> 716                         ifNode2.predecessor().replaceFirstSuccessor(ifNode2, newIfNode);</span>
<span class="line-added"> 717                         ifNode2.safeDelete();</span>
<span class="line-added"> 718                         return true;</span>
<span class="line-added"> 719                     }</span>
<span class="line-added"> 720                 }</span>
 721             }
 722         }
 723         return false;
 724     }
 725 
 726     /**
 727      * Check it these two blocks end up at the same place. Meeting at the same merge, or
 728      * deoptimizing in the same way.
 729      */
 730     private static boolean sameDestination(AbstractBeginNode succ1, AbstractBeginNode succ2) {
 731         Node next1 = succ1.next();
 732         Node next2 = succ2.next();
 733         if (next1 instanceof EndNode &amp;&amp; next2 instanceof EndNode) {
 734             EndNode end1 = (EndNode) next1;
 735             EndNode end2 = (EndNode) next2;
 736             if (end1.merge() == end2.merge()) {
 737                 for (PhiNode phi : end1.merge().phis()) {
 738                     if (phi.valueAt(end1) != phi.valueAt(end2)) {
 739                         return false;
 740                     }
</pre>
<hr />
<pre>
 866             AbstractMergeNode merge = trueEnd.merge();
 867             if (merge == falseEnd.merge() &amp;&amp; trueSuccessor().anchored().isEmpty() &amp;&amp; falseSuccessor().anchored().isEmpty()) {
 868                 PhiNode singlePhi = null;
 869                 int distinct = 0;
 870                 for (PhiNode phi : merge.phis()) {
 871                     ValueNode trueValue = phi.valueAt(trueEnd);
 872                     ValueNode falseValue = phi.valueAt(falseEnd);
 873                     if (trueValue != falseValue) {
 874                         distinct++;
 875                         singlePhi = phi;
 876                     }
 877                 }
 878                 if (distinct == 0) {
 879                     /*
 880                      * Multiple phis but merging same values for true and false, so simply delete
 881                      * the path
 882                      */
 883                     removeThroughFalseBranch(tool, merge);
 884                     return true;
 885                 } else if (distinct == 1) {
<span class="line-added"> 886                     // Fortify: Suppress Null Dereference false positive</span>
<span class="line-added"> 887                     assert singlePhi != null;</span>
<span class="line-added"> 888 </span>
 889                     ValueNode trueValue = singlePhi.valueAt(trueEnd);
 890                     ValueNode falseValue = singlePhi.valueAt(falseEnd);
 891                     ValueNode conditional = canonicalizeConditionalCascade(tool, trueValue, falseValue);
 892                     if (conditional != null) {
 893                         conditional = proxyReplacement(conditional);
 894                         singlePhi.setValueAt(trueEnd, conditional);
 895                         removeThroughFalseBranch(tool, merge);
 896                         return true;
 897                     }
 898                 }
 899             }
 900         }
 901         if (trueSuccessor().next() instanceof ReturnNode &amp;&amp; falseSuccessor().next() instanceof ReturnNode) {
 902             ReturnNode trueEnd = (ReturnNode) trueSuccessor().next();
 903             ReturnNode falseEnd = (ReturnNode) falseSuccessor().next();
 904             ValueNode trueValue = trueEnd.result();
 905             ValueNode falseValue = falseEnd.result();
 906             ValueNode value = null;
<span class="line-added"> 907             boolean needsProxy = false;</span>
 908             if (trueValue != null) {
 909                 if (trueValue == falseValue) {
 910                     value = trueValue;
 911                 } else {
 912                     value = canonicalizeConditionalCascade(tool, trueValue, falseValue);
 913                     if (value == null) {
 914                         return false;
 915                     }
<span class="line-added"> 916                     needsProxy = true;</span>
 917                 }
 918             }
<span class="line-added"> 919 </span>
<span class="line-added"> 920             if (trueSuccessor() instanceof LoopExitNode) {</span>
<span class="line-added"> 921                 LoopBeginNode loopBegin = ((LoopExitNode) trueSuccessor()).loopBegin();</span>
<span class="line-added"> 922                 assert loopBegin == ((LoopExitNode) falseSuccessor()).loopBegin();</span>
<span class="line-added"> 923                 LoopExitNode loopExitNode = graph().add(new LoopExitNode(loopBegin));</span>
<span class="line-added"> 924                 graph().addBeforeFixed(this, loopExitNode);</span>
<span class="line-added"> 925                 if (graph().hasValueProxies() &amp;&amp; needsProxy) {</span>
<span class="line-added"> 926                     value = graph().addOrUnique(new ValueProxyNode(value, loopExitNode));</span>
<span class="line-added"> 927                 }</span>
<span class="line-added"> 928             }</span>
<span class="line-added"> 929 </span>
 930             ReturnNode newReturn = graph().add(new ReturnNode(value));
 931             replaceAtPredecessor(newReturn);
 932             GraphUtil.killCFG(this);
 933             return true;
 934         }
 935         return false;
 936     }
 937 
 938     private ValueNode proxyReplacement(ValueNode replacement) {
 939         /*
 940          * Special case: Every empty diamond we collapse to a conditional node can potentially
 941          * contain loop exit nodes on both branches. See the graph below: The two loop exits
 942          * (instanceof begin node) exit the same loop. The resulting phi is defined outside the
 943          * loop, but the resulting conditional node will be inside the loop, so we need to proxy the
 944          * resulting conditional node. Callers of this method ensure that true and false successor
 945          * have no usages, therefore a and b in the graph below can never be proxies themselves.
 946          */
 947         // @formatter:off
 948         //              +--+
 949         //              |If|
 950         //              +--+      +-----+ +-----+
 951         //         +----+  +----+ |  a  | |  b  |
 952         //         |Lex |  |Lex | +----^+ +^----+
 953         //         +----+  +----+      |   |
 954         //           +-------+         +---+
 955         //           | Merge +---------+Phi|
 956         //           +-------+         +---+
 957         // @formatter:on
 958         if (this.graph().hasValueProxies()) {
 959             if (trueSuccessor instanceof LoopExitNode &amp;&amp; falseSuccessor instanceof LoopExitNode) {
 960                 assert ((LoopExitNode) trueSuccessor).loopBegin() == ((LoopExitNode) falseSuccessor).loopBegin();
 961                 /*
 962                  * we can collapse all proxy nodes on one loop exit, the surviving one, which will
 963                  * be the true successor
 964                  */
<span class="line-modified"> 965                 if (falseSuccessor.anchored().isEmpty() &amp;&amp; falseSuccessor.hasUsages()) {</span>
 966                     for (Node n : falseSuccessor.usages().snapshot()) {
 967                         assert n instanceof ProxyNode;
 968                         ((ProxyNode) n).setProxyPoint((LoopExitNode) trueSuccessor);
 969                     }
 970                 }
 971                 /*
 972                  * The true successor (surviving loop exit) can have usages, namely proxy nodes, the
 973                  * false successor however, must not have usages any more after the code above
 974                  */
<span class="line-modified"> 975                 assert trueSuccessor.anchored().isEmpty() &amp;&amp; falseSuccessor.hasNoUsages();</span>
 976                 return this.graph().addOrUnique(new ValueProxyNode(replacement, (LoopExitNode) trueSuccessor));
 977             }
 978         }
 979         return replacement;
 980     }
 981 
 982     protected void removeThroughFalseBranch(SimplifierTool tool, AbstractMergeNode merge) {
 983         AbstractBeginNode trueBegin = trueSuccessor();
 984         LogicNode conditionNode = condition();
 985         graph().removeSplitPropagate(this, trueBegin);
 986         tool.addToWorkList(trueBegin);
 987         if (conditionNode != null) {
 988             GraphUtil.tryKillUnused(conditionNode);
 989         }
 990         if (merge.isAlive() &amp;&amp; merge.forwardEndCount() &gt; 1) {
 991             for (FixedNode end : merge.forwardEnds()) {
 992                 Node cur = end;
 993                 while (cur != null &amp;&amp; cur.predecessor() instanceof BeginNode) {
 994                     cur = cur.predecessor();
 995                 }
</pre>
<hr />
<pre>
1058                 return null;
1059             }
1060             boolean negateConditionalCondition = false;
1061             ValueNode otherValue = null;
1062             if (constant == conditional.trueValue()) {
1063                 otherValue = conditional.falseValue();
1064                 negateConditionalCondition = false;
1065             } else if (constant == conditional.falseValue()) {
1066                 otherValue = conditional.trueValue();
1067                 negateConditionalCondition = true;
1068             }
1069             if (otherValue != null &amp;&amp; otherValue.isConstant()) {
1070                 double shortCutProbability = probability(trueSuccessor());
1071                 LogicNode newCondition = LogicNode.or(condition(), negateCondition, conditional.condition(), negateConditionalCondition, shortCutProbability);
1072                 return graph().unique(new ConditionalNode(newCondition, constant, otherValue));
1073             }
1074 
1075             if (constant.isJavaConstant() &amp;&amp; conditional.trueValue().isJavaConstant() &amp;&amp; conditional.falseValue().isJavaConstant() &amp;&amp; condition() instanceof CompareNode &amp;&amp;
1076                             conditional.condition() instanceof CompareNode) {
1077 
<span class="line-modified">1078                 CompareNode condition1 = (CompareNode) condition();</span>
<span class="line-added">1079                 Condition cond1 = condition1.condition().asCondition();</span>
1080                 if (negateCondition) {
1081                     cond1 = cond1.negate();
1082                 }
1083                 // cond1 is EQ, NE, LT, or GE
<span class="line-modified">1084                 CompareNode condition2 = (CompareNode) conditional.condition();</span>
<span class="line-modified">1085                 Condition cond2 = condition2.condition().asCondition();</span>
<span class="line-modified">1086                 ValueNode x = condition1.getX();</span>
<span class="line-modified">1087                 ValueNode y = condition1.getY();</span>
<span class="line-modified">1088                 ValueNode x2 = condition2.getX();</span>
<span class="line-added">1089                 ValueNode y2 = condition2.getY();</span>
1090                 // `x cond1 y ? c1 : (x2 cond2 y2 ? c2 : c3)`
1091                 boolean sameVars = x == x2 &amp;&amp; y == y2;
1092                 if (!sameVars &amp;&amp; x == y2 &amp;&amp; y == x2) {
1093                     sameVars = true;
1094                     cond2 = cond2.mirror();
1095                 }
1096                 if (sameVars) {
<span class="line-added">1097 </span>
1098                     JavaKind stackKind = conditional.trueValue().stamp(NodeView.from(tool)).getStackKind();
1099                     assert !stackKind.isNumericFloat();
1100 
<span class="line-modified">1101                     long c1 = constant.asJavaConstant().asLong();</span>
<span class="line-modified">1102                     long c2 = conditional.trueValue().asJavaConstant().asLong();</span>
<span class="line-modified">1103                     long c3 = conditional.falseValue().asJavaConstant().asLong();</span>



































1104 
<span class="line-modified">1105                     // canonicalize cond2</span>
<span class="line-modified">1106                     cond2 = cond2.join(cond1.negate());</span>
<span class="line-modified">1107                     if (cond2 == null) {</span>
<span class="line-modified">1108                         // mixing signed and unsigned cases, or useless combination of conditions</span>
<span class="line-modified">1109                         return null;</span>




























































1110                     }
<span class="line-modified">1111                     // derive cond3 from cond1 and cond2</span>
<span class="line-modified">1112                     Condition cond3 = cond1.negate().join(cond2.negate());</span>
<span class="line-modified">1113                     if (cond3 == null) {</span>
<span class="line-modified">1114                         // mixing signed and unsigned cases, or useless combination of conditions</span>
<span class="line-added">1115                         return null;</span>
1116                     }
<span class="line-modified">1117                     boolean unsigned = cond1.isUnsigned() || cond2.isUnsigned();</span>
<span class="line-modified">1118                     boolean floatingPoint = x.stamp(NodeView.from(tool)) instanceof FloatStamp;</span>
<span class="line-modified">1119                     assert !floatingPoint || y.stamp(NodeView.from(tool)) instanceof FloatStamp;</span>
<span class="line-modified">1120                     assert !(floatingPoint &amp;&amp; unsigned);</span>
<span class="line-modified">1121 </span>
<span class="line-modified">1122                     long expected1 = expectedConstantForNormalize(cond1);</span>
<span class="line-modified">1123                     long expected2 = expectedConstantForNormalize(cond2);</span>
<span class="line-modified">1124                     long expected3 = expectedConstantForNormalize(cond3);</span>
<span class="line-modified">1125 </span>
<span class="line-modified">1126                     if (c1 == expected1 &amp;&amp; c2 == expected2 &amp;&amp; c3 == expected3) {</span>
<span class="line-modified">1127                         // normal order</span>
<span class="line-modified">1128                     } else if (c1 == 0 - expected1 &amp;&amp; c2 == 0 - expected2 &amp;&amp; c3 == 0 - expected3) {</span>
<span class="line-modified">1129                         // reverse order</span>
<span class="line-modified">1130                         ValueNode tmp = x;</span>
<span class="line-modified">1131                         x = y;</span>
<span class="line-modified">1132                         y = tmp;</span>
<span class="line-modified">1133                     } else {</span>
<span class="line-modified">1134                         // cannot be expressed by NormalizeCompareNode</span>
<span class="line-modified">1135                         return null;</span>
<span class="line-modified">1136                     }</span>
<span class="line-modified">1137                     if (floatingPoint) {</span>
<span class="line-modified">1138                         boolean unorderedLess = false;</span>
<span class="line-modified">1139                         if (((FloatStamp) x.stamp).canBeNaN() || ((FloatStamp) y.stamp).canBeNaN()) {</span>
<span class="line-modified">1140                             // we may encounter NaNs, check the unordered value</span>
<span class="line-modified">1141                             // (following the original condition&#39;s &quot;unorderedIsTrue&quot; path)</span>
<span class="line-modified">1142                             long unorderedValue = condition1.unorderedIsTrue() ? c1 : condition2.unorderedIsTrue() ? c2 : c3;</span>
<span class="line-modified">1143                             if (unorderedValue == 0) {</span>
<span class="line-modified">1144                                 // returning &quot;0&quot; for unordered is not possible</span>
<span class="line-modified">1145                                 return null;</span>
<span class="line-modified">1146                             }</span>
<span class="line-modified">1147                             unorderedLess = unorderedValue == -1;</span>
<span class="line-modified">1148                         }</span>
<span class="line-modified">1149                         return graph().unique(new FloatNormalizeCompareNode(x, y, stackKind, unorderedLess));</span>
<span class="line-modified">1150                     } else {</span>
<span class="line-modified">1151                         return graph().unique(new IntegerNormalizeCompareNode(x, y, stackKind, unsigned));</span>





























































1152                     }






1153                 }


























1154             }
1155         }
<span class="line-added">1156         return null;</span>
1157     }
1158 
<span class="line-modified">1159     private static long expectedConstantForNormalize(Condition condition) {</span>
<span class="line-modified">1160         if (condition == Condition.EQ) {</span>
<span class="line-modified">1161             return 0;</span>
<span class="line-modified">1162         } else if (condition == Condition.LT || condition == Condition.BT) {</span>
<span class="line-modified">1163             return -1;</span>
<span class="line-modified">1164         } else {</span>
<span class="line-modified">1165             assert condition == Condition.GT || condition == Condition.AT;</span>
<span class="line-added">1166             return 1;</span>
1167         }
1168     }
1169 
<span class="line-modified">1170     public enum NodeColor {</span>
<span class="line-modified">1171         NONE,</span>
<span class="line-modified">1172         CONDITION_USAGE,</span>
<span class="line-modified">1173         TRUE_BRANCH,</span>
<span class="line-modified">1174         FALSE_BRANCH,</span>
<span class="line-modified">1175         PHI_MIXED,</span>
<span class="line-modified">1176         MIXED</span>



















1177     }
1178 
1179     /**
1180      * Tries to connect code that initializes a variable directly with the successors of an if
1181      * construct that switches on the variable. For example, the pseudo code below:
1182      *
1183      * &lt;pre&gt;
1184      * contains(list, e, yes, no) {
1185      *     if (list == null || e == null) {
1186      *         condition = false;
1187      *     } else {
1188      *         condition = false;
1189      *         for (i in list) {
1190      *             if (i.equals(e)) {
1191      *                 condition = true;
1192      *                 break;
1193      *             }
1194      *         }
1195      *     }
1196      *     if (condition) {
</pre>
<hr />
<pre>
1230         if (!(condition() instanceof CompareNode)) {
1231             return false;
1232         }
1233 
1234         CompareNode compare = (CompareNode) condition();
1235         if (compare.getUsageCount() != 1) {
1236             return false;
1237         }
1238 
1239         // Only consider merges with a single usage that is both a phi and an operand of the
1240         // comparison
1241         NodeIterable&lt;Node&gt; mergeUsages = merge.usages();
1242         if (mergeUsages.count() != 1) {
1243             return false;
1244         }
1245         Node singleUsage = mergeUsages.first();
1246         if (!(singleUsage instanceof ValuePhiNode) || (singleUsage != compare.getX() &amp;&amp; singleUsage != compare.getY())) {
1247             return false;
1248         }
1249 
<span class="line-added">1250         if (trueSuccessor().isUsedAsGuardInput() || falseSuccessor().isUsedAsGuardInput()) {</span>
<span class="line-added">1251             return false;</span>
<span class="line-added">1252         }</span>
<span class="line-added">1253 </span>
1254         // Ensure phi is used by at most the comparison and the merge&#39;s frame state (if any)
1255         ValuePhiNode phi = (ValuePhiNode) singleUsage;
1256         NodeIterable&lt;Node&gt; phiUsages = phi.usages();



1257         for (Node usage : phiUsages) {
<span class="line-modified">1258             if (usage == compare) {</span>
<span class="line-modified">1259                 continue;</span>
<span class="line-added">1260             }</span>
<span class="line-added">1261             if (usage == merge.stateAfter()) {</span>
<span class="line-added">1262                 continue;</span>
<span class="line-added">1263             }</span>
<span class="line-added">1264             // Checkstyle: stop</span>
<span class="line-added">1265             // @formatter:off</span>
<span class="line-added">1266             //</span>
<span class="line-added">1267             // We also want to allow the usage to be on the loop-proxy if one of the branches is a</span>
<span class="line-added">1268             // loop exit.</span>
<span class="line-added">1269             //</span>
<span class="line-added">1270             // This pattern:</span>
<span class="line-added">1271             //</span>
<span class="line-added">1272             //      if-------&gt;cond</span>
<span class="line-added">1273             //     /  \</span>
<span class="line-added">1274             // begin  begin</span>
<span class="line-added">1275             //   |      |</span>
<span class="line-added">1276             //  end    end        C1 V2</span>
<span class="line-added">1277             //     \  /            \ /</span>
<span class="line-added">1278             //     merge----------&gt;phi&lt;------    C1</span>
<span class="line-added">1279             //       |              ^        \  /</span>
<span class="line-added">1280             //       if-------------|--------&gt;==</span>
<span class="line-added">1281             //      /  \            |</span>
<span class="line-added">1282             //     A    B&lt;--------Proxy</span>
<span class="line-added">1283             //</span>
<span class="line-added">1284             // Must be simplified to:</span>
<span class="line-added">1285             //</span>
<span class="line-added">1286             //       if----------------------&gt;cond</span>
<span class="line-added">1287             //      /  \</span>
<span class="line-added">1288             //     A    B&lt;--------Proxy------&gt;V2</span>
<span class="line-added">1289             //</span>
<span class="line-added">1290             // @formatter:on</span>
<span class="line-added">1291             // Checkstyle: resume</span>
<span class="line-added">1292             if (usage instanceof ValueProxyNode) {</span>
<span class="line-added">1293                 ValueProxyNode proxy = (ValueProxyNode) usage;</span>
<span class="line-added">1294                 if (proxy.proxyPoint() == trueSuccessor || proxy.proxyPoint() == falseSuccessor) {</span>
<span class="line-added">1295                     continue;</span>
<span class="line-added">1296                 }</span>
1297             }
<span class="line-added">1298             return false;</span>
1299         }
1300 
1301         List&lt;EndNode&gt; mergePredecessors = merge.cfgPredecessors().snapshot();
1302         assert phi.valueCount() == merge.forwardEndCount();
1303 
1304         Constant[] xs = constantValues(compare.getX(), merge, false);
1305         Constant[] ys = constantValues(compare.getY(), merge, false);
1306         if (xs == null || ys == null) {
1307             return false;
1308         }
1309 
<span class="line-modified">1310         if (merge.stateAfter() != null &amp;&amp; !GraphUtil.mayRemoveSplit(this)) {</span>

1311             return false;
1312         }
1313 
1314         List&lt;EndNode&gt; falseEnds = new ArrayList&lt;&gt;(mergePredecessors.size());
1315         List&lt;EndNode&gt; trueEnds = new ArrayList&lt;&gt;(mergePredecessors.size());
1316         EconomicMap&lt;AbstractEndNode, ValueNode&gt; phiValues = EconomicMap.create(Equivalence.IDENTITY, mergePredecessors.size());
1317 
1318         AbstractBeginNode oldFalseSuccessor = falseSuccessor();
1319         AbstractBeginNode oldTrueSuccessor = trueSuccessor();
1320 
1321         setFalseSuccessor(null);
1322         setTrueSuccessor(null);
1323 
1324         Iterator&lt;EndNode&gt; ends = mergePredecessors.iterator();
1325         for (int i = 0; i &lt; xs.length; i++) {
1326             EndNode end = ends.next();
1327             phiValues.put(end, phi.valueAt(end));
1328             if (compare.condition().foldCondition(xs[i], ys[i], tool.getConstantReflection(), compare.unorderedIsTrue())) {
1329                 trueEnds.add(end);
1330             } else {
1331                 falseEnds.add(end);
1332             }
1333         }
1334         assert !ends.hasNext();
1335         assert falseEnds.size() + trueEnds.size() == xs.length;
1336 
<span class="line-modified">1337         connectEnds(falseEnds, phi, phiValues, oldFalseSuccessor, merge, tool);</span>
<span class="line-modified">1338         connectEnds(trueEnds, phi, phiValues, oldTrueSuccessor, merge, tool);</span>
1339 
1340         if (this.trueSuccessorProbability == 0.0) {
1341             for (AbstractEndNode endNode : trueEnds) {
1342                 propagateZeroProbability(endNode);
1343             }
1344         }
1345 
1346         if (this.trueSuccessorProbability == 1.0) {
1347             for (AbstractEndNode endNode : falseEnds) {
1348                 propagateZeroProbability(endNode);
1349             }
1350         }
1351 
1352         /*
1353          * Remove obsolete ends only after processing all ends, otherwise oldTrueSuccessor or
1354          * oldFalseSuccessor might have been removed if it is a LoopExitNode.
1355          */
1356         if (falseEnds.isEmpty()) {
1357             GraphUtil.killCFG(oldFalseSuccessor);
1358         }
1359         if (trueEnds.isEmpty()) {
1360             GraphUtil.killCFG(oldTrueSuccessor);
1361         }
1362         GraphUtil.killCFG(merge);
1363 
1364         assert !merge.isAlive() : merge;
1365         assert !phi.isAlive() : phi;
1366         assert !compare.isAlive() : compare;
1367         assert !this.isAlive() : this;
1368 
1369         return true;
1370     }
1371 
<span class="line-modified">1372     private static void propagateZeroProbability(FixedNode startNode) {</span>
1373         Node prev = null;
1374         for (FixedNode node : GraphUtil.predecessorIterable(startNode)) {
1375             if (node instanceof IfNode) {
1376                 IfNode ifNode = (IfNode) node;
1377                 if (ifNode.trueSuccessor() == prev) {
1378                     if (ifNode.trueSuccessorProbability == 0.0) {
1379                         return;
1380                     } else if (ifNode.trueSuccessorProbability == 1.0) {
1381                         continue;
1382                     } else {
1383                         ifNode.setTrueSuccessorProbability(0.0);
1384                         return;
1385                     }
1386                 } else if (ifNode.falseSuccessor() == prev) {
1387                     if (ifNode.trueSuccessorProbability == 1.0) {
1388                         return;
1389                     } else if (ifNode.trueSuccessorProbability == 0.0) {
1390                         continue;
1391                     } else {
1392                         ifNode.setTrueSuccessorProbability(1.0);
1393                         return;
1394                     }
1395                 } else {
1396                     throw new GraalError(&quot;Illegal state&quot;);
1397                 }
1398             } else if (node instanceof AbstractMergeNode &amp;&amp; !(node instanceof LoopBeginNode)) {
1399                 for (AbstractEndNode endNode : ((AbstractMergeNode) node).cfgPredecessors()) {
1400                     propagateZeroProbability(endNode);
1401                 }
1402                 return;
1403             }
1404             prev = node;
1405         }
1406     }
1407 







































1408     /**
1409      * Connects a set of ends to a given successor, inserting a merge node if there is more than one
1410      * end. If {@code ends} is not empty, then {@code successor} is added to {@code tool}&#39;s
1411      * {@linkplain SimplifierTool#addToWorkList(org.graalvm.compiler.graph.Node) work list}.
1412      *
<span class="line-modified">1413      * @param phi the original single-usage phi of the preceding merge</span>
1414      * @param phiValues the values of the phi at the merge, keyed by the merge ends
<span class="line-added">1415      * @param oldMerge the merge being removed</span>
1416      */
<span class="line-modified">1417     private void connectEnds(List&lt;EndNode&gt; ends, ValuePhiNode phi, EconomicMap&lt;AbstractEndNode, ValueNode&gt; phiValues, AbstractBeginNode successor, AbstractMergeNode oldMerge, SimplifierTool tool) {</span>
1418         if (!ends.isEmpty()) {
<span class="line-added">1419             // If there was a value proxy usage, then the proxy needs a new value.</span>
<span class="line-added">1420             ValueProxyNode valueProxy = null;</span>
<span class="line-added">1421             if (successor instanceof LoopExitNode) {</span>
<span class="line-added">1422                 for (Node usage : phi.usages()) {</span>
<span class="line-added">1423                     if (usage instanceof ValueProxyNode &amp;&amp; ((ValueProxyNode) usage).proxyPoint() == successor) {</span>
<span class="line-added">1424                         valueProxy = (ValueProxyNode) usage;</span>
<span class="line-added">1425                     }</span>
<span class="line-added">1426                 }</span>
<span class="line-added">1427             }</span>
<span class="line-added">1428             final ValueProxyNode proxy = valueProxy;</span>
1429             if (ends.size() == 1) {
1430                 AbstractEndNode end = ends.get(0);
<span class="line-added">1431                 if (proxy != null) {</span>
<span class="line-added">1432                     phi.replaceAtUsages(phiValues.get(end), n -&gt; n == proxy);</span>
<span class="line-added">1433                 }</span>
1434                 ((FixedWithNextNode) end.predecessor()).setNext(successor);
1435                 oldMerge.removeEnd(end);
1436                 GraphUtil.killCFG(end);
1437             } else {
1438                 // Need a new phi in case the frame state is used by more than the merge being
1439                 // removed.
1440                 NodeView view = NodeView.from(tool);
1441                 AbstractMergeNode newMerge = graph().add(new MergeNode());
1442                 PhiNode oldPhi = (PhiNode) oldMerge.usages().first();
1443                 PhiNode newPhi = graph().addWithoutUnique(new ValuePhiNode(oldPhi.stamp(view), newMerge));
1444 
<span class="line-added">1445                 if (proxy != null) {</span>
<span class="line-added">1446                     phi.replaceAtUsages(newPhi, n -&gt; n == proxy);</span>
<span class="line-added">1447                 }</span>
<span class="line-added">1448 </span>
1449                 for (EndNode end : ends) {
1450                     newPhi.addInput(phiValues.get(end));
1451                     newMerge.addForwardEnd(end);
1452                 }
1453 
1454                 FrameState stateAfter = oldMerge.stateAfter();
1455                 if (stateAfter != null) {
1456                     stateAfter = stateAfter.duplicate();
1457                     stateAfter.replaceFirstInput(oldPhi, newPhi);
1458                     newMerge.setStateAfter(stateAfter);
1459                 }
1460 
1461                 newMerge.setNext(successor);
1462             }
1463             tool.addToWorkList(successor);
1464         }
1465     }
1466 
1467     /**
1468      * Gets an array of constants derived from a node that is either a {@link ConstantNode} or a
</pre>
</td>
</tr>
</table>
<center><a href="GuardedValueNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Invoke.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/CompareNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BinaryArithmeticNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConditionalNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/CompareNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.calc;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 28 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_1;
 29 
 30 import org.graalvm.compiler.core.common.PermanentBailoutException;
 31 import org.graalvm.compiler.core.common.calc.CanonicalCondition;
 32 import org.graalvm.compiler.core.common.calc.Condition;
 33 import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
 34 import org.graalvm.compiler.core.common.type.AbstractPointerStamp;
 35 import org.graalvm.compiler.core.common.type.IntegerStamp;

 36 import org.graalvm.compiler.graph.NodeClass;

 37 import org.graalvm.compiler.graph.spi.Canonicalizable;

 38 import org.graalvm.compiler.nodeinfo.NodeInfo;
 39 import org.graalvm.compiler.nodes.BinaryOpLogicNode;
 40 import org.graalvm.compiler.nodes.ConstantNode;
 41 import org.graalvm.compiler.nodes.LogicConstantNode;
 42 import org.graalvm.compiler.nodes.LogicNegationNode;
 43 import org.graalvm.compiler.nodes.LogicNode;
 44 import org.graalvm.compiler.nodes.NodeView;
 45 import org.graalvm.compiler.nodes.StructuredGraph;
 46 import org.graalvm.compiler.nodes.ValueNode;

 47 import org.graalvm.compiler.options.OptionValues;
 48 
 49 import jdk.vm.ci.meta.Constant;
 50 import jdk.vm.ci.meta.ConstantReflectionProvider;
 51 import jdk.vm.ci.meta.MetaAccessProvider;
 52 import jdk.vm.ci.meta.PrimitiveConstant;
 53 
 54 @NodeInfo(cycles = CYCLES_1)
 55 public abstract class CompareNode extends BinaryOpLogicNode implements Canonicalizable.Binary&lt;ValueNode&gt; {
 56 
 57     public static final NodeClass&lt;CompareNode&gt; TYPE = NodeClass.create(CompareNode.class);
 58     protected final CanonicalCondition condition;
 59     protected final boolean unorderedIsTrue;
 60 
 61     /**
 62      * Constructs a new Compare instruction.
 63      *
 64      * @param x the instruction producing the first input to the instruction
 65      * @param y the instruction that produces the second input to this instruction
 66      */
</pre>
<hr />
<pre>
167                                 // a good trade-off between introduced new usages and
168                                 // eliminated nodes.
169                                 return null;
170                             }
171                         }
172                         return duplicateModified(convertX.getValue(), convertY.getValue(), unorderedIsTrue, view);
173                     }
174                 }
175             }
176             return null;
177         }
178 
179         protected LogicNode canonicalizeSymmetricConstant(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth,
180                         CanonicalCondition condition, Constant constant, ValueNode nonConstant, boolean mirrored, boolean unorderedIsTrue, NodeView view) {
181             if (nonConstant instanceof ConditionalNode) {
182                 Condition realCondition = condition.asCondition();
183                 if (mirrored) {
184                     realCondition = realCondition.mirror();
185                 }
186                 return optimizeConditional(constant, (ConditionalNode) nonConstant, constantReflection, realCondition, unorderedIsTrue);
<span class="line-modified">187             } else if (nonConstant instanceof NormalizeCompareNode) {</span>
<span class="line-modified">188                 return optimizeNormalizeCompare(constantReflection, metaAccess, options, smallestCompareWidth, constant, (NormalizeCompareNode) nonConstant, mirrored, view);</span>
189             } else if (nonConstant instanceof ConvertNode) {
190                 ConvertNode convert = (ConvertNode) nonConstant;
191                 boolean multiUsage = (convert.asNode().hasMoreThanOneUsage() &amp;&amp; convert.getValue().hasExactlyOneUsage());
<span class="line-modified">192                 if ((convert instanceof ZeroExtendNode || convert instanceof SignExtendNode) &amp;&amp; multiUsage) {</span>
<span class="line-modified">193                     // Do not perform for zero or sign extend if it could introduce</span>













194                     // new live values.
195                     return null;
196                 }
197 








198                 boolean supported = true;
199                 if (convert.getValue().stamp(view) instanceof IntegerStamp) {
200                     IntegerStamp intStamp = (IntegerStamp) convert.getValue().stamp(view);
201                     supported = smallestCompareWidth != null &amp;&amp; intStamp.getBits() &gt;= smallestCompareWidth;
202                 }
203 
204                 if (supported) {
205                     ConstantNode newConstant = canonicalConvertConstant(constantReflection, metaAccess, options, condition, convert, constant, view);
206                     if (newConstant != null) {
207                         if (mirrored) {
208                             return duplicateModified(newConstant, convert.getValue(), unorderedIsTrue, view);
209                         } else {
210                             return duplicateModified(convert.getValue(), newConstant, unorderedIsTrue, view);
211                         }
212                     }
213                 }
214             }
215 
216             return null;
217         }
218 
219         private static ConstantNode canonicalConvertConstant(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, CanonicalCondition condition,
220                         ConvertNode convert, Constant constant, NodeView view) {
221             if (convert.preservesOrder(condition, constant, constantReflection)) {
222                 Constant reverseConverted = convert.reverse(constant, constantReflection);
223                 if (reverseConverted != null &amp;&amp; convert.convert(reverseConverted, constantReflection).equals(constant)) {
224                     if (GeneratePIC.getValue(options)) {
225                         // We always want uncompressed constants
226                         return null;
227                     }
228                     return ConstantNode.forConstant(convert.getValue().stamp(view), reverseConverted, metaAccess);
229                 }
230             }
231             return null;
232         }
233 
234         @SuppressWarnings(&quot;unused&quot;)
235         protected LogicNode optimizeNormalizeCompare(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth,
<span class="line-modified">236                         Constant constant, NormalizeCompareNode normalizeNode, boolean mirrored, NodeView view) {</span>
237             throw new PermanentBailoutException(&quot;NormalizeCompareNode connected to %s (%s %s %s)&quot;, this, constant, normalizeNode, mirrored);
238         }
239 
240         private static LogicNode optimizeConditional(Constant constant, ConditionalNode conditionalNode, ConstantReflectionProvider constantReflection, Condition cond, boolean unorderedIsTrue) {
241             Constant trueConstant = conditionalNode.trueValue().asConstant();
242             Constant falseConstant = conditionalNode.falseValue().asConstant();
243 
244             if (falseConstant != null &amp;&amp; trueConstant != null &amp;&amp; constantReflection != null) {
245                 boolean trueResult = cond.foldCondition(trueConstant, constant, constantReflection, unorderedIsTrue);
246                 boolean falseResult = cond.foldCondition(falseConstant, constant, constantReflection, unorderedIsTrue);
247 
248                 if (trueResult == falseResult) {
249                     return LogicConstantNode.forBoolean(trueResult);
250                 } else {
251                     if (trueResult) {
252                         assert falseResult == false;
253                         return conditionalNode.condition();
254                     } else {
255                         assert falseResult == true;
256                         return LogicNegationNode.create(conditionalNode.condition());
</pre>
<hr />
<pre>
312             if (x.stamp(view) instanceof AbstractObjectStamp) {
313                 assert smallestCompareWidth == null;
314                 comparison = ObjectEqualsNode.create(constantReflection, metaAccess, options, x, y, view);
315             } else if (x.stamp(view) instanceof AbstractPointerStamp) {
316                 comparison = PointerEqualsNode.create(x, y, view);
317             } else {
318                 assert x.getStackKind().isNumericInteger();
319                 comparison = IntegerEqualsNode.create(constantReflection, metaAccess, options, smallestCompareWidth, x, y, view);
320             }
321         } else if (condition == CanonicalCondition.LT) {
322             assert x.getStackKind().isNumericInteger();
323             comparison = IntegerLessThanNode.create(constantReflection, metaAccess, options, smallestCompareWidth, x, y, view);
324         } else {
325             assert condition == CanonicalCondition.BT;
326             assert x.getStackKind().isNumericInteger();
327             comparison = IntegerBelowNode.create(constantReflection, metaAccess, options, smallestCompareWidth, x, y, view);
328         }
329 
330         return comparison;
331     }




















332 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.calc;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 28 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_1;
 29 
 30 import org.graalvm.compiler.core.common.PermanentBailoutException;
 31 import org.graalvm.compiler.core.common.calc.CanonicalCondition;
 32 import org.graalvm.compiler.core.common.calc.Condition;
 33 import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
 34 import org.graalvm.compiler.core.common.type.AbstractPointerStamp;
 35 import org.graalvm.compiler.core.common.type.IntegerStamp;
<span class="line-added"> 36 import org.graalvm.compiler.graph.Node;</span>
 37 import org.graalvm.compiler.graph.NodeClass;
<span class="line-added"> 38 import org.graalvm.compiler.graph.Position;</span>
 39 import org.graalvm.compiler.graph.spi.Canonicalizable;
<span class="line-added"> 40 import org.graalvm.compiler.nodeinfo.InputType;</span>
 41 import org.graalvm.compiler.nodeinfo.NodeInfo;
 42 import org.graalvm.compiler.nodes.BinaryOpLogicNode;
 43 import org.graalvm.compiler.nodes.ConstantNode;
 44 import org.graalvm.compiler.nodes.LogicConstantNode;
 45 import org.graalvm.compiler.nodes.LogicNegationNode;
 46 import org.graalvm.compiler.nodes.LogicNode;
 47 import org.graalvm.compiler.nodes.NodeView;
 48 import org.graalvm.compiler.nodes.StructuredGraph;
 49 import org.graalvm.compiler.nodes.ValueNode;
<span class="line-added"> 50 import org.graalvm.compiler.nodes.memory.VolatileReadNode;</span>
 51 import org.graalvm.compiler.options.OptionValues;
 52 
 53 import jdk.vm.ci.meta.Constant;
 54 import jdk.vm.ci.meta.ConstantReflectionProvider;
 55 import jdk.vm.ci.meta.MetaAccessProvider;
 56 import jdk.vm.ci.meta.PrimitiveConstant;
 57 
 58 @NodeInfo(cycles = CYCLES_1)
 59 public abstract class CompareNode extends BinaryOpLogicNode implements Canonicalizable.Binary&lt;ValueNode&gt; {
 60 
 61     public static final NodeClass&lt;CompareNode&gt; TYPE = NodeClass.create(CompareNode.class);
 62     protected final CanonicalCondition condition;
 63     protected final boolean unorderedIsTrue;
 64 
 65     /**
 66      * Constructs a new Compare instruction.
 67      *
 68      * @param x the instruction producing the first input to the instruction
 69      * @param y the instruction that produces the second input to this instruction
 70      */
</pre>
<hr />
<pre>
171                                 // a good trade-off between introduced new usages and
172                                 // eliminated nodes.
173                                 return null;
174                             }
175                         }
176                         return duplicateModified(convertX.getValue(), convertY.getValue(), unorderedIsTrue, view);
177                     }
178                 }
179             }
180             return null;
181         }
182 
183         protected LogicNode canonicalizeSymmetricConstant(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth,
184                         CanonicalCondition condition, Constant constant, ValueNode nonConstant, boolean mirrored, boolean unorderedIsTrue, NodeView view) {
185             if (nonConstant instanceof ConditionalNode) {
186                 Condition realCondition = condition.asCondition();
187                 if (mirrored) {
188                     realCondition = realCondition.mirror();
189                 }
190                 return optimizeConditional(constant, (ConditionalNode) nonConstant, constantReflection, realCondition, unorderedIsTrue);
<span class="line-modified">191             } else if (nonConstant instanceof AbstractNormalizeCompareNode) {</span>
<span class="line-modified">192                 return optimizeNormalizeCompare(constantReflection, metaAccess, options, smallestCompareWidth, constant, (AbstractNormalizeCompareNode) nonConstant, mirrored, view);</span>
193             } else if (nonConstant instanceof ConvertNode) {
194                 ConvertNode convert = (ConvertNode) nonConstant;
195                 boolean multiUsage = (convert.asNode().hasMoreThanOneUsage() &amp;&amp; convert.getValue().hasExactlyOneUsage());
<span class="line-modified">196                 if (!multiUsage &amp;&amp; convert.asNode().hasMoreThanOneUsage() &amp;&amp; convert.getValue() instanceof VolatileReadNode) {</span>
<span class="line-modified">197                     // Only account for data usages</span>
<span class="line-added">198                     VolatileReadNode read = (VolatileReadNode) convert.getValue();</span>
<span class="line-added">199                     int nonMemoryEdges = 0;</span>
<span class="line-added">200                     for (Node u : read.usages()) {</span>
<span class="line-added">201                         for (Position pos : u.inputPositions()) {</span>
<span class="line-added">202                             if (pos.get(u) == read &amp;&amp; pos.getInputType() != InputType.Memory) {</span>
<span class="line-added">203                                 nonMemoryEdges++;</span>
<span class="line-added">204                             }</span>
<span class="line-added">205                         }</span>
<span class="line-added">206                     }</span>
<span class="line-added">207                     multiUsage = nonMemoryEdges == 1;</span>
<span class="line-added">208                 }</span>
<span class="line-added">209                 if (convert instanceof IntegerConvertNode &amp;&amp; multiUsage) {</span>
<span class="line-added">210                     // Do not perform for integer convers if it could introduce</span>
211                     // new live values.
212                     return null;
213                 }
214 
<span class="line-added">215                 if (convert instanceof NarrowNode) {</span>
<span class="line-added">216                     NarrowNode narrowNode = (NarrowNode) convert;</span>
<span class="line-added">217                     if (narrowNode.getInputBits() &gt; 32 &amp;&amp; !constant.isDefaultForKind()) {</span>
<span class="line-added">218                         // Avoid large integer constants.</span>
<span class="line-added">219                         return null;</span>
<span class="line-added">220                     }</span>
<span class="line-added">221                 }</span>
<span class="line-added">222 </span>
223                 boolean supported = true;
224                 if (convert.getValue().stamp(view) instanceof IntegerStamp) {
225                     IntegerStamp intStamp = (IntegerStamp) convert.getValue().stamp(view);
226                     supported = smallestCompareWidth != null &amp;&amp; intStamp.getBits() &gt;= smallestCompareWidth;
227                 }
228 
229                 if (supported) {
230                     ConstantNode newConstant = canonicalConvertConstant(constantReflection, metaAccess, options, condition, convert, constant, view);
231                     if (newConstant != null) {
232                         if (mirrored) {
233                             return duplicateModified(newConstant, convert.getValue(), unorderedIsTrue, view);
234                         } else {
235                             return duplicateModified(convert.getValue(), newConstant, unorderedIsTrue, view);
236                         }
237                     }
238                 }
239             }
240 
241             return null;
242         }
243 
244         private static ConstantNode canonicalConvertConstant(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, CanonicalCondition condition,
245                         ConvertNode convert, Constant constant, NodeView view) {
246             if (convert.preservesOrder(condition, constant, constantReflection)) {
247                 Constant reverseConverted = convert.reverse(constant, constantReflection);
248                 if (reverseConverted != null &amp;&amp; convert.convert(reverseConverted, constantReflection).equals(constant)) {
249                     if (GeneratePIC.getValue(options)) {
250                         // We always want uncompressed constants
251                         return null;
252                     }
253                     return ConstantNode.forConstant(convert.getValue().stamp(view), reverseConverted, metaAccess);
254                 }
255             }
256             return null;
257         }
258 
259         @SuppressWarnings(&quot;unused&quot;)
260         protected LogicNode optimizeNormalizeCompare(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth,
<span class="line-modified">261                         Constant constant, AbstractNormalizeCompareNode normalizeNode, boolean mirrored, NodeView view) {</span>
262             throw new PermanentBailoutException(&quot;NormalizeCompareNode connected to %s (%s %s %s)&quot;, this, constant, normalizeNode, mirrored);
263         }
264 
265         private static LogicNode optimizeConditional(Constant constant, ConditionalNode conditionalNode, ConstantReflectionProvider constantReflection, Condition cond, boolean unorderedIsTrue) {
266             Constant trueConstant = conditionalNode.trueValue().asConstant();
267             Constant falseConstant = conditionalNode.falseValue().asConstant();
268 
269             if (falseConstant != null &amp;&amp; trueConstant != null &amp;&amp; constantReflection != null) {
270                 boolean trueResult = cond.foldCondition(trueConstant, constant, constantReflection, unorderedIsTrue);
271                 boolean falseResult = cond.foldCondition(falseConstant, constant, constantReflection, unorderedIsTrue);
272 
273                 if (trueResult == falseResult) {
274                     return LogicConstantNode.forBoolean(trueResult);
275                 } else {
276                     if (trueResult) {
277                         assert falseResult == false;
278                         return conditionalNode.condition();
279                     } else {
280                         assert falseResult == true;
281                         return LogicNegationNode.create(conditionalNode.condition());
</pre>
<hr />
<pre>
337             if (x.stamp(view) instanceof AbstractObjectStamp) {
338                 assert smallestCompareWidth == null;
339                 comparison = ObjectEqualsNode.create(constantReflection, metaAccess, options, x, y, view);
340             } else if (x.stamp(view) instanceof AbstractPointerStamp) {
341                 comparison = PointerEqualsNode.create(x, y, view);
342             } else {
343                 assert x.getStackKind().isNumericInteger();
344                 comparison = IntegerEqualsNode.create(constantReflection, metaAccess, options, smallestCompareWidth, x, y, view);
345             }
346         } else if (condition == CanonicalCondition.LT) {
347             assert x.getStackKind().isNumericInteger();
348             comparison = IntegerLessThanNode.create(constantReflection, metaAccess, options, smallestCompareWidth, x, y, view);
349         } else {
350             assert condition == CanonicalCondition.BT;
351             assert x.getStackKind().isNumericInteger();
352             comparison = IntegerBelowNode.create(constantReflection, metaAccess, options, smallestCompareWidth, x, y, view);
353         }
354 
355         return comparison;
356     }
<span class="line-added">357 </span>
<span class="line-added">358     public static LogicNode createFloatCompareNode(StructuredGraph graph, CanonicalCondition condition, ValueNode x, ValueNode y, boolean unorderedIsTrue, NodeView view) {</span>
<span class="line-added">359         LogicNode result = createFloatCompareNode(condition, x, y, unorderedIsTrue, view);</span>
<span class="line-added">360         return (result.graph() == null ? graph.addOrUniqueWithInputs(result) : result);</span>
<span class="line-added">361     }</span>
<span class="line-added">362 </span>
<span class="line-added">363     public static LogicNode createFloatCompareNode(CanonicalCondition condition, ValueNode x, ValueNode y, boolean unorderedIsTrue, NodeView view) {</span>
<span class="line-added">364         assert x.getStackKind() == y.getStackKind();</span>
<span class="line-added">365         assert x.getStackKind().isNumericFloat();</span>
<span class="line-added">366 </span>
<span class="line-added">367         LogicNode comparison;</span>
<span class="line-added">368         if (condition == CanonicalCondition.EQ) {</span>
<span class="line-added">369             comparison = FloatEqualsNode.create(x, y, view);</span>
<span class="line-added">370         } else {</span>
<span class="line-added">371             assert condition == CanonicalCondition.LT;</span>
<span class="line-added">372             comparison = FloatLessThanNode.create(x, y, unorderedIsTrue, view);</span>
<span class="line-added">373         }</span>
<span class="line-added">374 </span>
<span class="line-added">375         return comparison;</span>
<span class="line-added">376     }</span>
377 }
</pre>
</td>
</tr>
</table>
<center><a href="BinaryArithmeticNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConditionalNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/IfNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GuardedValueNode.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Invoke.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/IfNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,41 ***</span>
  import org.graalvm.compiler.bytecode.BytecodeDisassembler;
  import org.graalvm.compiler.bytecode.Bytecodes;
  import org.graalvm.compiler.bytecode.Bytes;
  import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  import org.graalvm.compiler.core.common.calc.Condition;
  import org.graalvm.compiler.core.common.type.IntegerStamp;
  import org.graalvm.compiler.core.common.type.Stamp;
  import org.graalvm.compiler.core.common.type.StampFactory;
  import org.graalvm.compiler.debug.CounterKey;
  import org.graalvm.compiler.debug.DebugCloseable;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.NodeClass;
  import org.graalvm.compiler.graph.NodeSourcePosition;
  import org.graalvm.compiler.graph.iterators.NodeIterable;
<span class="line-removed">- import org.graalvm.compiler.graph.spi.Canonicalizable;</span>
  import org.graalvm.compiler.graph.spi.Simplifiable;
  import org.graalvm.compiler.graph.spi.SimplifierTool;
  import org.graalvm.compiler.nodeinfo.InputType;
  import org.graalvm.compiler.nodeinfo.NodeInfo;
  import org.graalvm.compiler.nodes.calc.CompareNode;
  import org.graalvm.compiler.nodes.calc.ConditionalNode;
  import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;
  import org.graalvm.compiler.nodes.calc.IsNullNode;
<span class="line-removed">- import org.graalvm.compiler.nodes.calc.NormalizeCompareNode;</span>
  import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
  import org.graalvm.compiler.nodes.extended.UnboxNode;
  import org.graalvm.compiler.nodes.java.InstanceOfNode;
  import org.graalvm.compiler.nodes.java.LoadFieldNode;
  import org.graalvm.compiler.nodes.spi.LIRLowerable;
  import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
  import org.graalvm.compiler.nodes.util.GraphUtil;
  
  import jdk.vm.ci.meta.Constant;
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.MetaAccessProvider;
  import jdk.vm.ci.meta.PrimitiveConstant;
<span class="line-new-header">--- 38,47 ---</span>
  import org.graalvm.compiler.bytecode.BytecodeDisassembler;
  import org.graalvm.compiler.bytecode.Bytecodes;
  import org.graalvm.compiler.bytecode.Bytes;
  import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  import org.graalvm.compiler.core.common.calc.Condition;
<span class="line-added">+ import org.graalvm.compiler.core.common.type.FloatStamp;</span>
  import org.graalvm.compiler.core.common.type.IntegerStamp;
<span class="line-added">+ import org.graalvm.compiler.core.common.type.PrimitiveStamp;</span>
  import org.graalvm.compiler.core.common.type.Stamp;
  import org.graalvm.compiler.core.common.type.StampFactory;
  import org.graalvm.compiler.debug.CounterKey;
  import org.graalvm.compiler.debug.DebugCloseable;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.debug.GraalError;
<span class="line-added">+ import org.graalvm.compiler.graph.IterableNodeType;</span>
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.NodeClass;
  import org.graalvm.compiler.graph.NodeSourcePosition;
  import org.graalvm.compiler.graph.iterators.NodeIterable;
  import org.graalvm.compiler.graph.spi.Simplifiable;
  import org.graalvm.compiler.graph.spi.SimplifierTool;
  import org.graalvm.compiler.nodeinfo.InputType;
  import org.graalvm.compiler.nodeinfo.NodeInfo;
<span class="line-added">+ import org.graalvm.compiler.nodes.calc.AddNode;</span>
  import org.graalvm.compiler.nodes.calc.CompareNode;
  import org.graalvm.compiler.nodes.calc.ConditionalNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.calc.FloatNormalizeCompareNode;</span>
  import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.calc.IntegerNormalizeCompareNode;</span>
  import org.graalvm.compiler.nodes.calc.IsNullNode;
  import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
  import org.graalvm.compiler.nodes.extended.UnboxNode;
  import org.graalvm.compiler.nodes.java.InstanceOfNode;
  import org.graalvm.compiler.nodes.java.LoadFieldNode;
  import org.graalvm.compiler.nodes.spi.LIRLowerable;
  import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
<span class="line-added">+ import org.graalvm.compiler.nodes.spi.SwitchFoldable;</span>
  import org.graalvm.compiler.nodes.util.GraphUtil;
  
<span class="line-added">+ import jdk.vm.ci.code.CodeUtil;</span>
  import jdk.vm.ci.meta.Constant;
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.MetaAccessProvider;
  import jdk.vm.ci.meta.PrimitiveConstant;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 83,11 ***</span>
  /**
   * The {@code IfNode} represents a branch that can go one of two directions depending on the outcome
   * of a comparison.
   */
  @NodeInfo(cycles = CYCLES_1, size = SIZE_2, sizeRationale = &quot;2 jmps&quot;)
<span class="line-modified">! public final class IfNode extends ControlSplitNode implements Simplifiable, LIRLowerable {</span>
      public static final NodeClass&lt;IfNode&gt; TYPE = NodeClass.create(IfNode.class);
  
      private static final CounterKey CORRECTED_PROBABILITIES = DebugContext.counter(&quot;CorrectedProbabilities&quot;);
  
      @Successor AbstractBeginNode trueSuccessor;
<span class="line-new-header">--- 89,11 ---</span>
  /**
   * The {@code IfNode} represents a branch that can go one of two directions depending on the outcome
   * of a comparison.
   */
  @NodeInfo(cycles = CYCLES_1, size = SIZE_2, sizeRationale = &quot;2 jmps&quot;)
<span class="line-modified">! public final class IfNode extends ControlSplitNode implements Simplifiable, LIRLowerable, IterableNodeType, SwitchFoldable {</span>
      public static final NodeClass&lt;IfNode&gt; TYPE = NodeClass.create(IfNode.class);
  
      private static final CounterKey CORRECTED_PROBABILITIES = DebugContext.counter(&quot;CorrectedProbabilities&quot;);
  
      @Successor AbstractBeginNode trueSuccessor;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 285,19 ***</span>
  
          if (removeIntermediateMaterialization(tool)) {
              return;
          }
  
<span class="line-modified">!         if (splitIfAtPhi(tool)) {</span>
              return;
          }
  
<span class="line-modified">!         if (conditionalNodeOptimization(tool)) {</span>
              return;
          }
  
<span class="line-modified">!         if (falseSuccessor().hasNoUsages() &amp;&amp; (!(falseSuccessor() instanceof LoopExitNode)) &amp;&amp; falseSuccessor().next() instanceof IfNode) {</span>
              AbstractBeginNode intermediateBegin = falseSuccessor();
              IfNode nextIf = (IfNode) intermediateBegin.next();
              double probabilityB = (1.0 - this.trueSuccessorProbability) * nextIf.trueSuccessorProbability;
              if (this.trueSuccessorProbability &lt; probabilityB) {
                  // Reordering of those two if statements is beneficial from the point of view of
<span class="line-new-header">--- 291,20 ---</span>
  
          if (removeIntermediateMaterialization(tool)) {
              return;
          }
  
<span class="line-modified">!         if (conditionalNodeOptimization(tool)) {</span>
              return;
          }
  
<span class="line-modified">!         if (switchTransformationOptimization(tool)) {</span>
              return;
          }
  
<span class="line-modified">!         if (falseSuccessor().hasNoUsages() &amp;&amp; (!(falseSuccessor() instanceof LoopExitNode)) &amp;&amp; falseSuccessor().next() instanceof IfNode &amp;&amp;</span>
<span class="line-added">+                         !(((IfNode) falseSuccessor().next()).falseSuccessor() instanceof LoopExitNode)) {</span>
              AbstractBeginNode intermediateBegin = falseSuccessor();
              IfNode nextIf = (IfNode) intermediateBegin.next();
              double probabilityB = (1.0 - this.trueSuccessorProbability) * nextIf.trueSuccessorProbability;
              if (this.trueSuccessorProbability &lt; probabilityB) {
                  // Reordering of those two if statements is beneficial from the point of view of
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,11 ***</span>
          if (tryEliminateBoxedReferenceEquals(tool)) {
              return;
          }
      }
  
<span class="line-modified">!     private boolean isUnboxedFrom(MetaAccessProvider meta, NodeView view, ValueNode x, ValueNode src) {</span>
          if (x == src) {
              return true;
          } else if (x instanceof UnboxNode) {
              return isUnboxedFrom(meta, view, ((UnboxNode) x).getValue(), src);
          } else if (x instanceof PiNode) {
<span class="line-new-header">--- 341,11 ---</span>
          if (tryEliminateBoxedReferenceEquals(tool)) {
              return;
          }
      }
  
<span class="line-modified">!     private static boolean isUnboxedFrom(MetaAccessProvider meta, NodeView view, ValueNode x, ValueNode src) {</span>
          if (x == src) {
              return true;
          } else if (x instanceof UnboxNode) {
              return isUnboxedFrom(meta, view, ((UnboxNode) x).getValue(), src);
          } else if (x instanceof PiNode) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 449,10 ***</span>
<span class="line-new-header">--- 456,74 ---</span>
          setCondition(graph().addOrUniqueWithInputs(LogicConstantNode.contradiction()));
  
          return true;
      }
  
<span class="line-added">+     // SwitchFoldable implementation.</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public Node getNextSwitchFoldableBranch() {</span>
<span class="line-added">+         return falseSuccessor();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public boolean isInSwitch(ValueNode switchValue) {</span>
<span class="line-added">+         return SwitchFoldable.maybeIsInSwitch(condition()) &amp;&amp; SwitchFoldable.sameSwitchValue(condition(), switchValue);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void cutOffCascadeNode() {</span>
<span class="line-added">+         setTrueSuccessor(null);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void cutOffLowestCascadeNode() {</span>
<span class="line-added">+         setFalseSuccessor(null);</span>
<span class="line-added">+         setTrueSuccessor(null);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public AbstractBeginNode getDefault() {</span>
<span class="line-added">+         return falseSuccessor();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public ValueNode switchValue() {</span>
<span class="line-added">+         if (SwitchFoldable.maybeIsInSwitch(condition())) {</span>
<span class="line-added">+             return ((IntegerEqualsNode) condition()).getX();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return null;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public boolean isNonInitializedProfile() {</span>
<span class="line-added">+         return getTrueSuccessorProbability() == 0.5d;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public int intKeyAt(int i) {</span>
<span class="line-added">+         assert i == 0;</span>
<span class="line-added">+         return ((IntegerEqualsNode) condition()).getY().asJavaConstant().asInt();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public double keyProbability(int i) {</span>
<span class="line-added">+         assert i == 0;</span>
<span class="line-added">+         return getTrueSuccessorProbability();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public AbstractBeginNode keySuccessor(int i) {</span>
<span class="line-added">+         assert i == 0;</span>
<span class="line-added">+         return trueSuccessor();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public double defaultProbability() {</span>
<span class="line-added">+         return 1.0d - getTrueSuccessorProbability();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Try to optimize this as if it were a {@link ConditionalNode}.
       */
      private boolean conditionalNodeOptimization(SimplifierTool tool) {
          if (trueSuccessor().next() instanceof AbstractEndNode &amp;&amp; falseSuccessor().next() instanceof AbstractEndNode) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 463,15 ***</span>
              }
              if (!(trueEnd.merge() instanceof MergeNode)) {
                  return false;
              }
              MergeNode merge = (MergeNode) trueEnd.merge();
<span class="line-modified">!             if (merge.usages().count() != 1 || merge.phis().count() != 1) {</span>
                  return false;
              }
  
<span class="line-modified">!             if (trueSuccessor().anchored().isNotEmpty() || falseSuccessor().anchored().isNotEmpty()) {</span>
                  return false;
              }
  
              PhiNode phi = merge.phis().first();
              ValueNode falseValue = phi.valueAt(falseEnd);
<span class="line-new-header">--- 534,15 ---</span>
              }
              if (!(trueEnd.merge() instanceof MergeNode)) {
                  return false;
              }
              MergeNode merge = (MergeNode) trueEnd.merge();
<span class="line-modified">!             if (!merge.hasExactlyOneUsage() || merge.phis().count() != 1) {</span>
                  return false;
              }
  
<span class="line-modified">!             if (trueSuccessor().hasAnchored() || falseSuccessor().hasAnchored()) {</span>
                  return false;
              }
  
              PhiNode phi = merge.phis().first();
              ValueNode falseValue = phi.valueAt(falseEnd);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 601,10 ***</span>
<span class="line-new-header">--- 672,54 ---</span>
                              ifNode2.safeDelete();
                              return true;
                          }
                      }
                  }
<span class="line-added">+             } else if (y instanceof PrimitiveConstant &amp;&amp; ((PrimitiveConstant) y).asLong() &lt; 0 &amp;&amp; falseSuccessor().next() instanceof IfNode) {</span>
<span class="line-added">+                 IfNode ifNode2 = (IfNode) falseSuccessor().next();</span>
<span class="line-added">+                 AbstractBeginNode falseSucc = ifNode2.falseSuccessor();</span>
<span class="line-added">+                 AbstractBeginNode trueSucc = ifNode2.trueSuccessor();</span>
<span class="line-added">+                 IntegerBelowNode below = null;</span>
<span class="line-added">+                 if (ifNode2.condition() instanceof IntegerLessThanNode) {</span>
<span class="line-added">+                     ValueNode x = lessThan.getX();</span>
<span class="line-added">+                     IntegerLessThanNode lessThan2 = (IntegerLessThanNode) ifNode2.condition();</span>
<span class="line-added">+                     /*</span>
<span class="line-added">+                      * Convert x &gt;= -C1 &amp;&amp; x &lt; C2, represented as !(x &lt; -C1) &amp;&amp; x &lt; C2, into an</span>
<span class="line-added">+                      * unsigned compare. This condition is equivalent to x + C1 |&lt;| C1 + C2 if C1 +</span>
<span class="line-added">+                      * C2 does not overflow.</span>
<span class="line-added">+                      */</span>
<span class="line-added">+                     Constant c2 = lessThan2.getY().stamp(view).asConstant();</span>
<span class="line-added">+                     if (lessThan2.getX() == x &amp;&amp; c2 instanceof PrimitiveConstant &amp;&amp; ((PrimitiveConstant) c2).asLong() &gt; 0 &amp;&amp;</span>
<span class="line-added">+                                     x.stamp(view).isCompatible(lessThan.getY().stamp(view)) &amp;&amp;</span>
<span class="line-added">+                                     x.stamp(view).isCompatible(lessThan2.getY().stamp(view)) &amp;&amp;</span>
<span class="line-added">+                                     sameDestination(trueSuccessor(), ifNode2.falseSuccessor)) {</span>
<span class="line-added">+                         long newLimitValue = -((PrimitiveConstant) y).asLong() + ((PrimitiveConstant) c2).asLong();</span>
<span class="line-added">+                         // Make sure the limit fits into the target type without overflow.</span>
<span class="line-added">+                         if (newLimitValue &gt; 0 &amp;&amp; newLimitValue &lt;= CodeUtil.maxValue(PrimitiveStamp.getBits(x.stamp(view)))) {</span>
<span class="line-added">+                             ConstantNode newLimit = ConstantNode.forIntegerStamp(x.stamp(view), newLimitValue, graph());</span>
<span class="line-added">+                             ConstantNode c1 = ConstantNode.forIntegerStamp(x.stamp(view), -((PrimitiveConstant) y).asLong(), graph());</span>
<span class="line-added">+                             ValueNode addNode = graph().addOrUniqueWithInputs(AddNode.create(x, c1, view));</span>
<span class="line-added">+                             below = graph().unique(new IntegerBelowNode(addNode, newLimit));</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (below != null) {</span>
<span class="line-added">+                     try (DebugCloseable position = ifNode2.withNodeSourcePosition()) {</span>
<span class="line-added">+                         ifNode2.setTrueSuccessor(null);</span>
<span class="line-added">+                         ifNode2.setFalseSuccessor(null);</span>
<span class="line-added">+ </span>
<span class="line-added">+                         IfNode newIfNode = graph().add(new IfNode(below, trueSucc, falseSucc, trueSuccessorProbability));</span>
<span class="line-added">+                         // Remove the &lt; -C1 test.</span>
<span class="line-added">+                         tool.deleteBranch(trueSuccessor);</span>
<span class="line-added">+                         graph().removeSplit(this, falseSuccessor);</span>
<span class="line-added">+ </span>
<span class="line-added">+                         // Replace the second test with the new one.</span>
<span class="line-added">+                         ifNode2.predecessor().replaceFirstSuccessor(ifNode2, newIfNode);</span>
<span class="line-added">+                         ifNode2.safeDelete();</span>
<span class="line-added">+                         return true;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
              }
          }
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 766,10 ***</span>
<span class="line-new-header">--- 881,13 ---</span>
                       * the path
                       */
                      removeThroughFalseBranch(tool, merge);
                      return true;
                  } else if (distinct == 1) {
<span class="line-added">+                     // Fortify: Suppress Null Dereference false positive</span>
<span class="line-added">+                     assert singlePhi != null;</span>
<span class="line-added">+ </span>
                      ValueNode trueValue = singlePhi.valueAt(trueEnd);
                      ValueNode falseValue = singlePhi.valueAt(falseEnd);
                      ValueNode conditional = canonicalizeConditionalCascade(tool, trueValue, falseValue);
                      if (conditional != null) {
                          conditional = proxyReplacement(conditional);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 784,20 ***</span>
<span class="line-new-header">--- 902,33 ---</span>
              ReturnNode trueEnd = (ReturnNode) trueSuccessor().next();
              ReturnNode falseEnd = (ReturnNode) falseSuccessor().next();
              ValueNode trueValue = trueEnd.result();
              ValueNode falseValue = falseEnd.result();
              ValueNode value = null;
<span class="line-added">+             boolean needsProxy = false;</span>
              if (trueValue != null) {
                  if (trueValue == falseValue) {
                      value = trueValue;
                  } else {
                      value = canonicalizeConditionalCascade(tool, trueValue, falseValue);
                      if (value == null) {
                          return false;
                      }
<span class="line-added">+                     needsProxy = true;</span>
                  }
              }
<span class="line-added">+ </span>
<span class="line-added">+             if (trueSuccessor() instanceof LoopExitNode) {</span>
<span class="line-added">+                 LoopBeginNode loopBegin = ((LoopExitNode) trueSuccessor()).loopBegin();</span>
<span class="line-added">+                 assert loopBegin == ((LoopExitNode) falseSuccessor()).loopBegin();</span>
<span class="line-added">+                 LoopExitNode loopExitNode = graph().add(new LoopExitNode(loopBegin));</span>
<span class="line-added">+                 graph().addBeforeFixed(this, loopExitNode);</span>
<span class="line-added">+                 if (graph().hasValueProxies() &amp;&amp; needsProxy) {</span>
<span class="line-added">+                     value = graph().addOrUnique(new ValueProxyNode(value, loopExitNode));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              ReturnNode newReturn = graph().add(new ReturnNode(value));
              replaceAtPredecessor(newReturn);
              GraphUtil.killCFG(this);
              return true;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 829,21 ***</span>
                  assert ((LoopExitNode) trueSuccessor).loopBegin() == ((LoopExitNode) falseSuccessor).loopBegin();
                  /*
                   * we can collapse all proxy nodes on one loop exit, the surviving one, which will
                   * be the true successor
                   */
<span class="line-modified">!                 if (falseSuccessor.anchored().isEmpty() &amp;&amp; falseSuccessor.usages().isNotEmpty()) {</span>
                      for (Node n : falseSuccessor.usages().snapshot()) {
                          assert n instanceof ProxyNode;
                          ((ProxyNode) n).setProxyPoint((LoopExitNode) trueSuccessor);
                      }
                  }
                  /*
                   * The true successor (surviving loop exit) can have usages, namely proxy nodes, the
                   * false successor however, must not have usages any more after the code above
                   */
<span class="line-modified">!                 assert trueSuccessor.anchored().isEmpty() &amp;&amp; falseSuccessor.usages().isEmpty();</span>
                  return this.graph().addOrUnique(new ValueProxyNode(replacement, (LoopExitNode) trueSuccessor));
              }
          }
          return replacement;
      }
<span class="line-new-header">--- 960,21 ---</span>
                  assert ((LoopExitNode) trueSuccessor).loopBegin() == ((LoopExitNode) falseSuccessor).loopBegin();
                  /*
                   * we can collapse all proxy nodes on one loop exit, the surviving one, which will
                   * be the true successor
                   */
<span class="line-modified">!                 if (falseSuccessor.anchored().isEmpty() &amp;&amp; falseSuccessor.hasUsages()) {</span>
                      for (Node n : falseSuccessor.usages().snapshot()) {
                          assert n instanceof ProxyNode;
                          ((ProxyNode) n).setProxyPoint((LoopExitNode) trueSuccessor);
                      }
                  }
                  /*
                   * The true successor (surviving loop exit) can have usages, namely proxy nodes, the
                   * false successor however, must not have usages any more after the code above
                   */
<span class="line-modified">!                 assert trueSuccessor.anchored().isEmpty() &amp;&amp; falseSuccessor.hasNoUsages();</span>
                  return this.graph().addOrUnique(new ValueProxyNode(replacement, (LoopExitNode) trueSuccessor));
              }
          }
          return replacement;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 942,310 ***</span>
              }
  
              if (constant.isJavaConstant() &amp;&amp; conditional.trueValue().isJavaConstant() &amp;&amp; conditional.falseValue().isJavaConstant() &amp;&amp; condition() instanceof CompareNode &amp;&amp;
                              conditional.condition() instanceof CompareNode) {
  
<span class="line-modified">!                 Condition cond1 = ((CompareNode) condition()).condition().asCondition();</span>
                  if (negateCondition) {
                      cond1 = cond1.negate();
                  }
                  // cond1 is EQ, NE, LT, or GE
<span class="line-modified">!                 Condition cond2 = ((CompareNode) conditional.condition()).condition().asCondition();</span>
<span class="line-modified">!                 ValueNode x = ((CompareNode) condition()).getX();</span>
<span class="line-modified">!                 ValueNode y = ((CompareNode) condition()).getY();</span>
<span class="line-modified">!                 ValueNode x2 = ((CompareNode) conditional.condition()).getX();</span>
<span class="line-modified">!                 ValueNode y2 = ((CompareNode) conditional.condition()).getY();</span>
                  // `x cond1 y ? c1 : (x2 cond2 y2 ? c2 : c3)`
                  boolean sameVars = x == x2 &amp;&amp; y == y2;
                  if (!sameVars &amp;&amp; x == y2 &amp;&amp; y == x2) {
                      sameVars = true;
                      cond2 = cond2.mirror();
                  }
                  if (sameVars) {
                      JavaKind stackKind = conditional.trueValue().stamp(NodeView.from(tool)).getStackKind();
                      assert !stackKind.isNumericFloat();
  
<span class="line-modified">!                     ValueNode v1 = constant;</span>
<span class="line-modified">!                     ValueNode v2 = conditional.trueValue();</span>
<span class="line-modified">!                     ValueNode v3 = conditional.falseValue();</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     long c1 = v1.asJavaConstant().asLong();</span>
<span class="line-removed">-                     long c2 = v2.asJavaConstant().asLong();</span>
<span class="line-removed">-                     long c3 = v3.asJavaConstant().asLong();</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     if (cond1 == Condition.LT &amp;&amp; cond2 == Condition.EQ &amp;&amp; c1 == -1 &amp;&amp; c2 == 0 &amp;&amp; c3 == 1) {</span>
<span class="line-removed">-                         // x &lt; y ? -1 : (x == y ? 0 : 1) =&gt; x cmp y</span>
<span class="line-removed">-                         return graph().unique(new NormalizeCompareNode(x, y, stackKind, false));</span>
<span class="line-removed">-                     } else if (cond1 == Condition.LT &amp;&amp; cond2 == Condition.EQ &amp;&amp; c1 == 1 &amp;&amp; c2 == 0 &amp;&amp; c3 == -1) {</span>
<span class="line-removed">-                         // x &lt; y ? 1 : (x == y ? 0 : -1) =&gt; y cmp x</span>
<span class="line-removed">-                         return graph().unique(new NormalizeCompareNode(y, x, stackKind, false));</span>
<span class="line-removed">-                     } else if (cond1 == Condition.EQ &amp;&amp; cond2 == Condition.LT &amp;&amp; c1 == 0 &amp;&amp; c2 == -1 &amp;&amp; c3 == 1) {</span>
<span class="line-removed">-                         // x == y ? 0 : (x &lt; y ? -1 : 1) =&gt; x cmp y</span>
<span class="line-removed">-                         return graph().unique(new NormalizeCompareNode(x, y, stackKind, false));</span>
<span class="line-removed">-                     } else if (cond1 == Condition.EQ &amp;&amp; cond2 == Condition.LT &amp;&amp; c1 == 0 &amp;&amp; c2 == 1 &amp;&amp; c3 == -1) {</span>
<span class="line-removed">-                         // x == y ? 0 : (x &lt; y ? 1 : -1) =&gt; y cmp x</span>
<span class="line-removed">-                         return graph().unique(new NormalizeCompareNode(y, x, stackKind, false));</span>
<span class="line-removed">-                     } else if (cond1 == Condition.EQ &amp;&amp; cond2 == Condition.GT &amp;&amp; c1 == 0 &amp;&amp; c2 == -1 &amp;&amp; c3 == 1) {</span>
<span class="line-removed">-                         // x == y ? 0 : (x &gt; y ? -1 : 1) =&gt; y cmp x</span>
<span class="line-removed">-                         return graph().unique(new NormalizeCompareNode(y, x, stackKind, false));</span>
<span class="line-removed">-                     } else if (cond1 == Condition.EQ &amp;&amp; cond2 == Condition.GT &amp;&amp; c1 == 0 &amp;&amp; c2 == 1 &amp;&amp; c3 == -1) {</span>
<span class="line-removed">-                         // x == y ? 0 : (x &gt; y ? 1 : -1) =&gt; x cmp y</span>
<span class="line-removed">-                         return graph().unique(new NormalizeCompareNode(x, y, stackKind, false));</span>
<span class="line-removed">-                     } else if (cond1 == Condition.LT &amp;&amp; cond2 == Condition.GT &amp;&amp; c1 == 1 &amp;&amp; c2 == -1 &amp;&amp; c3 == 0) {</span>
<span class="line-removed">-                         // x &lt; y ? 1 : (x &gt; y ? -1 : 0) =&gt; y cmp x</span>
<span class="line-removed">-                         return graph().unique(new NormalizeCompareNode(y, x, stackKind, false));</span>
<span class="line-removed">-                     } else if (cond1 == Condition.LT &amp;&amp; cond2 == Condition.GT &amp;&amp; c1 == -1 &amp;&amp; c2 == 1 &amp;&amp; c3 == 0) {</span>
<span class="line-removed">-                         // x &lt; y ? -1 : (x &gt; y ? 1 : 0) =&gt; x cmp y</span>
<span class="line-removed">-                         return graph().unique(new NormalizeCompareNode(x, y, stackKind, false));</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return null;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Take an if that is immediately dominated by a merge with a single phi and split off any paths</span>
<span class="line-modified">!      * where the test would be statically decidable creating a new merge below the approriate side</span>
<span class="line-modified">!      * of the IfNode. Any undecidable tests will continue to use the original IfNode.</span>
<span class="line-modified">!      *</span>
<span class="line-removed">-      * @param tool</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-removed">-     private boolean splitIfAtPhi(SimplifierTool tool) {</span>
<span class="line-removed">-         if (graph().getGuardsStage().areFrameStatesAtSideEffects()) {</span>
<span class="line-removed">-             // Disabled until we make sure we have no FrameState-less merges at this stage</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (!(predecessor() instanceof MergeNode)) {</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         MergeNode merge = (MergeNode) predecessor();</span>
<span class="line-removed">-         if (merge.forwardEndCount() == 1) {</span>
<span class="line-removed">-             // Don&#39;t bother.</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (merge.usages().count() != 1 || merge.phis().count() != 1) {</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (merge.stateAfter() != null) {</span>
<span class="line-removed">-             /* We&#39;ll get the chance to simplify this after frame state assignment. */</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         PhiNode phi = merge.phis().first();</span>
<span class="line-removed">-         if (phi.usages().count() != 1) {</span>
<span class="line-removed">-             /*</span>
<span class="line-removed">-              * For simplicity the below code assumes assumes the phi goes dead at the end so skip</span>
<span class="line-removed">-              * this case.</span>
<span class="line-removed">-              */</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * Check that the condition uses the phi and that there is only one user of the condition</span>
<span class="line-removed">-          * expression.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         if (!conditionUses(condition(), phi)) {</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * We could additionally filter for the case that at least some of the Phi inputs or one of</span>
<span class="line-removed">-          * the condition inputs are constants but there are cases where a non-constant is</span>
<span class="line-removed">-          * simplifiable, usually where the stamp allows the question to be answered.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /* Each successor of the if gets a new merge if needed. */</span>
<span class="line-removed">-         MergeNode trueMerge = null;</span>
<span class="line-removed">-         MergeNode falseMerge = null;</span>
<span class="line-removed">-         assert merge.stateAfter() == null;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         for (EndNode end : merge.forwardEnds().snapshot()) {</span>
<span class="line-removed">-             Node value = phi.valueAt(end);</span>
<span class="line-removed">-             LogicNode result = computeCondition(tool, condition, phi, value);</span>
<span class="line-removed">-             if (result instanceof LogicConstantNode) {</span>
<span class="line-removed">-                 merge.removeEnd(end);</span>
<span class="line-removed">-                 if (((LogicConstantNode) result).getValue()) {</span>
<span class="line-removed">-                     if (trueMerge == null) {</span>
<span class="line-removed">-                         trueMerge = insertMerge(trueSuccessor());</span>
                      }
<span class="line-modified">!                     trueMerge.addForwardEnd(end);</span>
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     if (falseMerge == null) {</span>
<span class="line-modified">!                         falseMerge = insertMerge(falseSuccessor());</span>
                      }
<span class="line-modified">!                     falseMerge.addForwardEnd(end);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             } else if (result != condition) {</span>
<span class="line-modified">!                 // Build a new IfNode using the new condition</span>
<span class="line-modified">!                 BeginNode trueBegin = graph().add(new BeginNode());</span>
<span class="line-modified">!                 trueBegin.setNodeSourcePosition(trueSuccessor().getNodeSourcePosition());</span>
<span class="line-modified">!                 BeginNode falseBegin = graph().add(new BeginNode());</span>
<span class="line-modified">!                 falseBegin.setNodeSourcePosition(falseSuccessor().getNodeSourcePosition());</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 if (result.graph() == null) {</span>
<span class="line-modified">!                     result = graph().addOrUniqueWithInputs(result);</span>
<span class="line-modified">!                     result.setNodeSourcePosition(condition.getNodeSourcePosition());</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 IfNode newIfNode = graph().add(new IfNode(result, trueBegin, falseBegin, trueSuccessorProbability));</span>
<span class="line-modified">!                 newIfNode.setNodeSourcePosition(getNodeSourcePosition());</span>
<span class="line-modified">!                 merge.removeEnd(end);</span>
<span class="line-modified">!                 ((FixedWithNextNode) end.predecessor()).setNext(newIfNode);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 if (trueMerge == null) {</span>
<span class="line-modified">!                     trueMerge = insertMerge(trueSuccessor());</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 trueBegin.setNext(graph().add(new EndNode()));</span>
<span class="line-modified">!                 trueMerge.addForwardEnd((EndNode) trueBegin.next());</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 if (falseMerge == null) {</span>
<span class="line-modified">!                     falseMerge = insertMerge(falseSuccessor());</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 falseBegin.setNext(graph().add(new EndNode()));</span>
<span class="line-modified">!                 falseMerge.addForwardEnd((EndNode) falseBegin.next());</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 end.safeDelete();</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         transferProxies(trueSuccessor(), trueMerge);</span>
<span class="line-removed">-         transferProxies(falseSuccessor(), falseMerge);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         cleanupMerge(merge);</span>
<span class="line-removed">-         cleanupMerge(trueMerge);</span>
<span class="line-removed">-         cleanupMerge(falseMerge);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * @param condition</span>
<span class="line-removed">-      * @param phi</span>
<span class="line-removed">-      * @return true if the passed in {@code condition} uses {@code phi} and the condition is only</span>
<span class="line-removed">-      *         used once. Since the phi will go dead the condition using it will also have to be</span>
<span class="line-removed">-      *         dead after the optimization.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static boolean conditionUses(LogicNode condition, PhiNode phi) {</span>
<span class="line-removed">-         if (condition.usages().count() != 1) {</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (condition instanceof ShortCircuitOrNode) {</span>
<span class="line-removed">-             if (condition.graph().getGuardsStage().areDeoptsFixed()) {</span>
<span class="line-removed">-                 /*</span>
<span class="line-removed">-                  * It can be unsafe to simplify a ShortCircuitOr before deopts are fixed because</span>
<span class="line-removed">-                  * conversion to guards assumes that all the required conditions are being tested.</span>
<span class="line-removed">-                  * Simplfying the condition based on context before this happens may lose a</span>
<span class="line-removed">-                  * condition.</span>
<span class="line-removed">-                  */</span>
<span class="line-removed">-                 ShortCircuitOrNode orNode = (ShortCircuitOrNode) condition;</span>
<span class="line-removed">-                 return (conditionUses(orNode.x, phi) || conditionUses(orNode.y, phi));</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else if (condition instanceof Canonicalizable.Unary&lt;?&gt;) {</span>
<span class="line-removed">-             Canonicalizable.Unary&lt;?&gt; unary = (Canonicalizable.Unary&lt;?&gt;) condition;</span>
<span class="line-removed">-             return unary.getValue() == phi;</span>
<span class="line-removed">-         } else if (condition instanceof Canonicalizable.Binary&lt;?&gt;) {</span>
<span class="line-removed">-             Canonicalizable.Binary&lt;?&gt; binary = (Canonicalizable.Binary&lt;?&gt;) condition;</span>
<span class="line-removed">-             return binary.getX() == phi || binary.getY() == phi;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Canonicalize {@code} condition using {@code value} in place of {@code phi}.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param tool</span>
<span class="line-removed">-      * @param condition</span>
<span class="line-removed">-      * @param phi</span>
<span class="line-removed">-      * @param value</span>
<span class="line-removed">-      * @return an improved LogicNode or the original condition</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">-     private static LogicNode computeCondition(SimplifierTool tool, LogicNode condition, PhiNode phi, Node value) {</span>
<span class="line-removed">-         if (condition instanceof ShortCircuitOrNode) {</span>
<span class="line-removed">-             if (condition.graph().getGuardsStage().areDeoptsFixed() &amp;&amp; !condition.graph().isAfterExpandLogic()) {</span>
<span class="line-removed">-                 ShortCircuitOrNode orNode = (ShortCircuitOrNode) condition;</span>
<span class="line-removed">-                 LogicNode resultX = computeCondition(tool, orNode.x, phi, value);</span>
<span class="line-removed">-                 LogicNode resultY = computeCondition(tool, orNode.y, phi, value);</span>
<span class="line-removed">-                 if (resultX != orNode.x || resultY != orNode.y) {</span>
<span class="line-removed">-                     LogicNode result = orNode.canonical(tool, resultX, resultY);</span>
<span class="line-removed">-                     if (result != orNode) {</span>
<span class="line-removed">-                         return result;</span>
                      }
<span class="line-removed">-                     /*</span>
<span class="line-removed">-                      * Create a new node to carry the optimized inputs.</span>
<span class="line-removed">-                      */</span>
<span class="line-removed">-                     ShortCircuitOrNode newOr = new ShortCircuitOrNode(resultX, orNode.xNegated, resultY,</span>
<span class="line-removed">-                                     orNode.yNegated, orNode.getShortCircuitProbability());</span>
<span class="line-removed">-                     return newOr.canonical(tool);</span>
                  }
<span class="line-removed">-                 return orNode;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else if (condition instanceof Canonicalizable.Binary&lt;?&gt;) {</span>
<span class="line-removed">-             Canonicalizable.Binary&lt;Node&gt; compare = (Canonicalizable.Binary&lt;Node&gt;) condition;</span>
<span class="line-removed">-             if (compare.getX() == phi) {</span>
<span class="line-removed">-                 return (LogicNode) compare.canonical(tool, value, compare.getY());</span>
<span class="line-removed">-             } else if (compare.getY() == phi) {</span>
<span class="line-removed">-                 return (LogicNode) compare.canonical(tool, compare.getX(), value);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else if (condition instanceof Canonicalizable.Unary&lt;?&gt;) {</span>
<span class="line-removed">-             Canonicalizable.Unary&lt;Node&gt; compare = (Canonicalizable.Unary&lt;Node&gt;) condition;</span>
<span class="line-removed">-             if (compare.getValue() == phi) {</span>
<span class="line-removed">-                 return (LogicNode) compare.canonical(tool, value);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (condition instanceof Canonicalizable) {</span>
<span class="line-removed">-             return (LogicNode) ((Canonicalizable) condition).canonical(tool);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return condition;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static void transferProxies(AbstractBeginNode successor, MergeNode falseMerge) {</span>
<span class="line-removed">-         if (successor instanceof LoopExitNode &amp;&amp; falseMerge != null) {</span>
<span class="line-removed">-             LoopExitNode loopExitNode = (LoopExitNode) successor;</span>
<span class="line-removed">-             for (ProxyNode proxy : loopExitNode.proxies().snapshot()) {</span>
<span class="line-removed">-                 proxy.replaceFirstInput(successor, falseMerge);</span>
              }
          }
      }
  
<span class="line-modified">!     private void cleanupMerge(MergeNode merge) {</span>
<span class="line-modified">!         if (merge != null &amp;&amp; merge.isAlive()) {</span>
<span class="line-modified">!             if (merge.forwardEndCount() == 0) {</span>
<span class="line-modified">!                 GraphUtil.killCFG(merge);</span>
<span class="line-modified">!             } else if (merge.forwardEndCount() == 1) {</span>
<span class="line-modified">!                 graph().reduceTrivialMerge(merge);</span>
<span class="line-modified">!             }</span>
          }
      }
  
<span class="line-modified">!     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-modified">!     private MergeNode insertMerge(AbstractBeginNode begin) {</span>
<span class="line-modified">!         MergeNode merge = graph().add(new MergeNode());</span>
<span class="line-modified">!         if (!begin.anchored().isEmpty()) {</span>
<span class="line-modified">!             Object before = null;</span>
<span class="line-modified">!             before = begin.anchored().snapshot();</span>
<span class="line-modified">!             begin.replaceAtUsages(InputType.Guard, merge);</span>
<span class="line-removed">-             begin.replaceAtUsages(InputType.Anchor, merge);</span>
<span class="line-removed">-             assert begin.anchored().isEmpty() : before + &quot; &quot; + begin.anchored().snapshot();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         AbstractBeginNode theBegin = begin;</span>
<span class="line-removed">-         if (begin instanceof LoopExitNode) {</span>
<span class="line-removed">-             // Insert an extra begin to make it easier.</span>
<span class="line-removed">-             try (DebugCloseable position = begin.withNodeSourcePosition()) {</span>
<span class="line-removed">-                 theBegin = graph().add(new BeginNode());</span>
<span class="line-removed">-                 begin.replaceAtPredecessor(theBegin);</span>
<span class="line-removed">-                 theBegin.setNext(begin);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         FixedNode next = theBegin.next();</span>
<span class="line-removed">-         next.replaceAtPredecessor(merge);</span>
<span class="line-removed">-         theBegin.setNext(graph().add(new EndNode()));</span>
<span class="line-removed">-         merge.addForwardEnd((EndNode) theBegin.next());</span>
<span class="line-removed">-         merge.setNext(next);</span>
<span class="line-removed">-         return merge;</span>
      }
  
      /**
       * Tries to connect code that initializes a variable directly with the successors of an if
       * construct that switches on the variable. For example, the pseudo code below:
<span class="line-new-header">--- 1073,109 ---</span>
              }
  
              if (constant.isJavaConstant() &amp;&amp; conditional.trueValue().isJavaConstant() &amp;&amp; conditional.falseValue().isJavaConstant() &amp;&amp; condition() instanceof CompareNode &amp;&amp;
                              conditional.condition() instanceof CompareNode) {
  
<span class="line-modified">!                 CompareNode condition1 = (CompareNode) condition();</span>
<span class="line-added">+                 Condition cond1 = condition1.condition().asCondition();</span>
                  if (negateCondition) {
                      cond1 = cond1.negate();
                  }
                  // cond1 is EQ, NE, LT, or GE
<span class="line-modified">!                 CompareNode condition2 = (CompareNode) conditional.condition();</span>
<span class="line-modified">!                 Condition cond2 = condition2.condition().asCondition();</span>
<span class="line-modified">!                 ValueNode x = condition1.getX();</span>
<span class="line-modified">!                 ValueNode y = condition1.getY();</span>
<span class="line-modified">!                 ValueNode x2 = condition2.getX();</span>
<span class="line-added">+                 ValueNode y2 = condition2.getY();</span>
                  // `x cond1 y ? c1 : (x2 cond2 y2 ? c2 : c3)`
                  boolean sameVars = x == x2 &amp;&amp; y == y2;
                  if (!sameVars &amp;&amp; x == y2 &amp;&amp; y == x2) {
                      sameVars = true;
                      cond2 = cond2.mirror();
                  }
                  if (sameVars) {
<span class="line-added">+ </span>
                      JavaKind stackKind = conditional.trueValue().stamp(NodeView.from(tool)).getStackKind();
                      assert !stackKind.isNumericFloat();
  
<span class="line-modified">!                     long c1 = constant.asJavaConstant().asLong();</span>
<span class="line-modified">!                     long c2 = conditional.trueValue().asJavaConstant().asLong();</span>
<span class="line-modified">!                     long c3 = conditional.falseValue().asJavaConstant().asLong();</span>
  
<span class="line-modified">!                     // canonicalize cond2</span>
<span class="line-modified">!                     cond2 = cond2.join(cond1.negate());</span>
<span class="line-modified">!                     if (cond2 == null) {</span>
<span class="line-modified">!                         // mixing signed and unsigned cases, or useless combination of conditions</span>
<span class="line-modified">!                         return null;</span>
                      }
<span class="line-modified">!                     // derive cond3 from cond1 and cond2</span>
<span class="line-modified">!                     Condition cond3 = cond1.negate().join(cond2.negate());</span>
<span class="line-modified">!                     if (cond3 == null) {</span>
<span class="line-modified">!                         // mixing signed and unsigned cases, or useless combination of conditions</span>
<span class="line-added">+                         return null;</span>
                      }
<span class="line-modified">!                     boolean unsigned = cond1.isUnsigned() || cond2.isUnsigned();</span>
<span class="line-modified">!                     boolean floatingPoint = x.stamp(NodeView.from(tool)) instanceof FloatStamp;</span>
<span class="line-modified">!                     assert !floatingPoint || y.stamp(NodeView.from(tool)) instanceof FloatStamp;</span>
<span class="line-modified">!                     assert !(floatingPoint &amp;&amp; unsigned);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     long expected1 = expectedConstantForNormalize(cond1);</span>
<span class="line-modified">!                     long expected2 = expectedConstantForNormalize(cond2);</span>
<span class="line-modified">!                     long expected3 = expectedConstantForNormalize(cond3);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     if (c1 == expected1 &amp;&amp; c2 == expected2 &amp;&amp; c3 == expected3) {</span>
<span class="line-modified">!                         // normal order</span>
<span class="line-modified">!                     } else if (c1 == 0 - expected1 &amp;&amp; c2 == 0 - expected2 &amp;&amp; c3 == 0 - expected3) {</span>
<span class="line-modified">!                         // reverse order</span>
<span class="line-modified">!                         ValueNode tmp = x;</span>
<span class="line-modified">!                         x = y;</span>
<span class="line-modified">!                         y = tmp;</span>
<span class="line-modified">!                     } else {</span>
<span class="line-modified">!                         // cannot be expressed by NormalizeCompareNode</span>
<span class="line-modified">!                         return null;</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     if (floatingPoint) {</span>
<span class="line-modified">!                         boolean unorderedLess = false;</span>
<span class="line-modified">!                         if (((FloatStamp) x.stamp).canBeNaN() || ((FloatStamp) y.stamp).canBeNaN()) {</span>
<span class="line-modified">!                             // we may encounter NaNs, check the unordered value</span>
<span class="line-modified">!                             // (following the original condition&#39;s &quot;unorderedIsTrue&quot; path)</span>
<span class="line-modified">!                             long unorderedValue = condition1.unorderedIsTrue() ? c1 : condition2.unorderedIsTrue() ? c2 : c3;</span>
<span class="line-modified">!                             if (unorderedValue == 0) {</span>
<span class="line-modified">!                                 // returning &quot;0&quot; for unordered is not possible</span>
<span class="line-modified">!                                 return null;</span>
<span class="line-modified">!                             }</span>
<span class="line-modified">!                             unorderedLess = unorderedValue == -1;</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">!                         return graph().unique(new FloatNormalizeCompareNode(x, y, stackKind, unorderedLess));</span>
<span class="line-modified">!                     } else {</span>
<span class="line-modified">!                         return graph().unique(new IntegerNormalizeCompareNode(x, y, stackKind, unsigned));</span>
                      }
                  }
              }
          }
<span class="line-added">+         return null;</span>
      }
  
<span class="line-modified">!     private static long expectedConstantForNormalize(Condition condition) {</span>
<span class="line-modified">!         if (condition == Condition.EQ) {</span>
<span class="line-modified">!             return 0;</span>
<span class="line-modified">!         } else if (condition == Condition.LT || condition == Condition.BT) {</span>
<span class="line-modified">!             return -1;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             assert condition == Condition.GT || condition == Condition.AT;</span>
<span class="line-added">+             return 1;</span>
          }
      }
  
<span class="line-modified">!     public enum NodeColor {</span>
<span class="line-modified">!         NONE,</span>
<span class="line-modified">!         CONDITION_USAGE,</span>
<span class="line-modified">!         TRUE_BRANCH,</span>
<span class="line-modified">!         FALSE_BRANCH,</span>
<span class="line-modified">!         PHI_MIXED,</span>
<span class="line-modified">!         MIXED</span>
      }
  
      /**
       * Tries to connect code that initializes a variable directly with the successors of an if
       * construct that switches on the variable. For example, the pseudo code below:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1315,20 ***</span>
          Node singleUsage = mergeUsages.first();
          if (!(singleUsage instanceof ValuePhiNode) || (singleUsage != compare.getX() &amp;&amp; singleUsage != compare.getY())) {
              return false;
          }
  
          // Ensure phi is used by at most the comparison and the merge&#39;s frame state (if any)
          ValuePhiNode phi = (ValuePhiNode) singleUsage;
          NodeIterable&lt;Node&gt; phiUsages = phi.usages();
<span class="line-removed">-         if (phiUsages.count() &gt; 2) {</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
          for (Node usage : phiUsages) {
<span class="line-modified">!             if (usage != compare &amp;&amp; usage != merge.stateAfter()) {</span>
<span class="line-modified">!                 return false;</span>
              }
          }
  
          List&lt;EndNode&gt; mergePredecessors = merge.cfgPredecessors().snapshot();
          assert phi.valueCount() == merge.forwardEndCount();
  
<span class="line-new-header">--- 1245,59 ---</span>
          Node singleUsage = mergeUsages.first();
          if (!(singleUsage instanceof ValuePhiNode) || (singleUsage != compare.getX() &amp;&amp; singleUsage != compare.getY())) {
              return false;
          }
  
<span class="line-added">+         if (trueSuccessor().isUsedAsGuardInput() || falseSuccessor().isUsedAsGuardInput()) {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          // Ensure phi is used by at most the comparison and the merge&#39;s frame state (if any)
          ValuePhiNode phi = (ValuePhiNode) singleUsage;
          NodeIterable&lt;Node&gt; phiUsages = phi.usages();
          for (Node usage : phiUsages) {
<span class="line-modified">!             if (usage == compare) {</span>
<span class="line-modified">!                 continue;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (usage == merge.stateAfter()) {</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // Checkstyle: stop</span>
<span class="line-added">+             // @formatter:off</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // We also want to allow the usage to be on the loop-proxy if one of the branches is a</span>
<span class="line-added">+             // loop exit.</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // This pattern:</span>
<span class="line-added">+             //</span>
<span class="line-added">+             //      if-------&gt;cond</span>
<span class="line-added">+             //     /  \</span>
<span class="line-added">+             // begin  begin</span>
<span class="line-added">+             //   |      |</span>
<span class="line-added">+             //  end    end        C1 V2</span>
<span class="line-added">+             //     \  /            \ /</span>
<span class="line-added">+             //     merge----------&gt;phi&lt;------    C1</span>
<span class="line-added">+             //       |              ^        \  /</span>
<span class="line-added">+             //       if-------------|--------&gt;==</span>
<span class="line-added">+             //      /  \            |</span>
<span class="line-added">+             //     A    B&lt;--------Proxy</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // Must be simplified to:</span>
<span class="line-added">+             //</span>
<span class="line-added">+             //       if----------------------&gt;cond</span>
<span class="line-added">+             //      /  \</span>
<span class="line-added">+             //     A    B&lt;--------Proxy------&gt;V2</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // @formatter:on</span>
<span class="line-added">+             // Checkstyle: resume</span>
<span class="line-added">+             if (usage instanceof ValueProxyNode) {</span>
<span class="line-added">+                 ValueProxyNode proxy = (ValueProxyNode) usage;</span>
<span class="line-added">+                 if (proxy.proxyPoint() == trueSuccessor || proxy.proxyPoint() == falseSuccessor) {</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 }</span>
              }
<span class="line-added">+             return false;</span>
          }
  
          List&lt;EndNode&gt; mergePredecessors = merge.cfgPredecessors().snapshot();
          assert phi.valueCount() == merge.forwardEndCount();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1336,12 ***</span>
          Constant[] ys = constantValues(compare.getY(), merge, false);
          if (xs == null || ys == null) {
              return false;
          }
  
<span class="line-modified">!         // Sanity check that both ends are not followed by a merge without frame state.</span>
<span class="line-removed">-         if (!checkFrameState(trueSuccessor()) &amp;&amp; !checkFrameState(falseSuccessor())) {</span>
              return false;
          }
  
          List&lt;EndNode&gt; falseEnds = new ArrayList&lt;&gt;(mergePredecessors.size());
          List&lt;EndNode&gt; trueEnds = new ArrayList&lt;&gt;(mergePredecessors.size());
<span class="line-new-header">--- 1305,11 ---</span>
          Constant[] ys = constantValues(compare.getY(), merge, false);
          if (xs == null || ys == null) {
              return false;
          }
  
<span class="line-modified">!         if (merge.stateAfter() != null &amp;&amp; !GraphUtil.mayRemoveSplit(this)) {</span>
              return false;
          }
  
          List&lt;EndNode&gt; falseEnds = new ArrayList&lt;&gt;(mergePredecessors.size());
          List&lt;EndNode&gt; trueEnds = new ArrayList&lt;&gt;(mergePredecessors.size());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1364,12 ***</span>
              }
          }
          assert !ends.hasNext();
          assert falseEnds.size() + trueEnds.size() == xs.length;
  
<span class="line-modified">!         connectEnds(falseEnds, phiValues, oldFalseSuccessor, merge, tool);</span>
<span class="line-modified">!         connectEnds(trueEnds, phiValues, oldTrueSuccessor, merge, tool);</span>
  
          if (this.trueSuccessorProbability == 0.0) {
              for (AbstractEndNode endNode : trueEnds) {
                  propagateZeroProbability(endNode);
              }
<span class="line-new-header">--- 1332,12 ---</span>
              }
          }
          assert !ends.hasNext();
          assert falseEnds.size() + trueEnds.size() == xs.length;
  
<span class="line-modified">!         connectEnds(falseEnds, phi, phiValues, oldFalseSuccessor, merge, tool);</span>
<span class="line-modified">!         connectEnds(trueEnds, phi, phiValues, oldTrueSuccessor, merge, tool);</span>
  
          if (this.trueSuccessorProbability == 0.0) {
              for (AbstractEndNode endNode : trueEnds) {
                  propagateZeroProbability(endNode);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1399,11 ***</span>
          assert !this.isAlive() : this;
  
          return true;
      }
  
<span class="line-modified">!     private void propagateZeroProbability(FixedNode startNode) {</span>
          Node prev = null;
          for (FixedNode node : GraphUtil.predecessorIterable(startNode)) {
              if (node instanceof IfNode) {
                  IfNode ifNode = (IfNode) node;
                  if (ifNode.trueSuccessor() == prev) {
<span class="line-new-header">--- 1367,11 ---</span>
          assert !this.isAlive() : this;
  
          return true;
      }
  
<span class="line-modified">!     private static void propagateZeroProbability(FixedNode startNode) {</span>
          Node prev = null;
          for (FixedNode node : GraphUtil.predecessorIterable(startNode)) {
              if (node instanceof IfNode) {
                  IfNode ifNode = (IfNode) node;
                  if (ifNode.trueSuccessor() == prev) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1435,61 ***</span>
              }
              prev = node;
          }
      }
  
<span class="line-removed">-     private static boolean checkFrameState(FixedNode start) {</span>
<span class="line-removed">-         FixedNode node = start;</span>
<span class="line-removed">-         while (true) {</span>
<span class="line-removed">-             if (node instanceof AbstractMergeNode) {</span>
<span class="line-removed">-                 AbstractMergeNode mergeNode = (AbstractMergeNode) node;</span>
<span class="line-removed">-                 if (mergeNode.stateAfter() == null) {</span>
<span class="line-removed">-                     return false;</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     return true;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } else if (node instanceof StateSplit) {</span>
<span class="line-removed">-                 StateSplit stateSplitNode = (StateSplit) node;</span>
<span class="line-removed">-                 if (stateSplitNode.stateAfter() != null) {</span>
<span class="line-removed">-                     return true;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (node instanceof ControlSplitNode) {</span>
<span class="line-removed">-                 ControlSplitNode controlSplitNode = (ControlSplitNode) node;</span>
<span class="line-removed">-                 for (Node succ : controlSplitNode.cfgSuccessors()) {</span>
<span class="line-removed">-                     if (checkFrameState((FixedNode) succ)) {</span>
<span class="line-removed">-                         return true;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             } else if (node instanceof FixedWithNextNode) {</span>
<span class="line-removed">-                 FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) node;</span>
<span class="line-removed">-                 node = fixedWithNextNode.next();</span>
<span class="line-removed">-             } else if (node instanceof AbstractEndNode) {</span>
<span class="line-removed">-                 AbstractEndNode endNode = (AbstractEndNode) node;</span>
<span class="line-removed">-                 node = endNode.merge();</span>
<span class="line-removed">-             } else if (node instanceof ControlSinkNode) {</span>
<span class="line-removed">-                 return true;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Connects a set of ends to a given successor, inserting a merge node if there is more than one
       * end. If {@code ends} is not empty, then {@code successor} is added to {@code tool}&#39;s
       * {@linkplain SimplifierTool#addToWorkList(org.graalvm.compiler.graph.Node) work list}.
       *
<span class="line-modified">!      * @param oldMerge the merge being removed</span>
       * @param phiValues the values of the phi at the merge, keyed by the merge ends
       */
<span class="line-modified">!     private void connectEnds(List&lt;EndNode&gt; ends, EconomicMap&lt;AbstractEndNode, ValueNode&gt; phiValues, AbstractBeginNode successor, AbstractMergeNode oldMerge, SimplifierTool tool) {</span>
          if (!ends.isEmpty()) {
              if (ends.size() == 1) {
                  AbstractEndNode end = ends.get(0);
                  ((FixedWithNextNode) end.predecessor()).setNext(successor);
                  oldMerge.removeEnd(end);
                  GraphUtil.killCFG(end);
              } else {
                  // Need a new phi in case the frame state is used by more than the merge being
<span class="line-new-header">--- 1403,36 ---</span>
              }
              prev = node;
          }
      }
  
      /**
       * Connects a set of ends to a given successor, inserting a merge node if there is more than one
       * end. If {@code ends} is not empty, then {@code successor} is added to {@code tool}&#39;s
       * {@linkplain SimplifierTool#addToWorkList(org.graalvm.compiler.graph.Node) work list}.
       *
<span class="line-modified">!      * @param phi the original single-usage phi of the preceding merge</span>
       * @param phiValues the values of the phi at the merge, keyed by the merge ends
<span class="line-added">+      * @param oldMerge the merge being removed</span>
       */
<span class="line-modified">!     private void connectEnds(List&lt;EndNode&gt; ends, ValuePhiNode phi, EconomicMap&lt;AbstractEndNode, ValueNode&gt; phiValues, AbstractBeginNode successor, AbstractMergeNode oldMerge, SimplifierTool tool) {</span>
          if (!ends.isEmpty()) {
<span class="line-added">+             // If there was a value proxy usage, then the proxy needs a new value.</span>
<span class="line-added">+             ValueProxyNode valueProxy = null;</span>
<span class="line-added">+             if (successor instanceof LoopExitNode) {</span>
<span class="line-added">+                 for (Node usage : phi.usages()) {</span>
<span class="line-added">+                     if (usage instanceof ValueProxyNode &amp;&amp; ((ValueProxyNode) usage).proxyPoint() == successor) {</span>
<span class="line-added">+                         valueProxy = (ValueProxyNode) usage;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             final ValueProxyNode proxy = valueProxy;</span>
              if (ends.size() == 1) {
                  AbstractEndNode end = ends.get(0);
<span class="line-added">+                 if (proxy != null) {</span>
<span class="line-added">+                     phi.replaceAtUsages(phiValues.get(end), n -&gt; n == proxy);</span>
<span class="line-added">+                 }</span>
                  ((FixedWithNextNode) end.predecessor()).setNext(successor);
                  oldMerge.removeEnd(end);
                  GraphUtil.killCFG(end);
              } else {
                  // Need a new phi in case the frame state is used by more than the merge being
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1497,10 ***</span>
<span class="line-new-header">--- 1440,14 ---</span>
                  NodeView view = NodeView.from(tool);
                  AbstractMergeNode newMerge = graph().add(new MergeNode());
                  PhiNode oldPhi = (PhiNode) oldMerge.usages().first();
                  PhiNode newPhi = graph().addWithoutUnique(new ValuePhiNode(oldPhi.stamp(view), newMerge));
  
<span class="line-added">+                 if (proxy != null) {</span>
<span class="line-added">+                     phi.replaceAtUsages(newPhi, n -&gt; n == proxy);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
                  for (EndNode end : ends) {
                      newPhi.addInput(phiValues.get(end));
                      newMerge.addForwardEnd(end);
                  }
  
</pre>
<center><a href="GuardedValueNode.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Invoke.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/UnsafeAccessNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SwitchNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="UnsafeMemoryStoreNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/UnsafeAccessNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.extended;
 26 
 27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_2;
 28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_1;
 29 


 30 import org.graalvm.compiler.core.common.type.Stamp;
 31 import org.graalvm.compiler.graph.Node;
 32 import org.graalvm.compiler.graph.NodeClass;
 33 import org.graalvm.compiler.graph.spi.Canonicalizable;
 34 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 35 import org.graalvm.compiler.nodeinfo.NodeInfo;
 36 import org.graalvm.compiler.nodes.FixedWithNextNode;
 37 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 38 import org.graalvm.compiler.nodes.ValueNode;
 39 import org.graalvm.compiler.nodes.type.StampTool;
 40 import jdk.internal.vm.compiler.word.LocationIdentity;
 41 
 42 import jdk.vm.ci.meta.Assumptions;


 43 import jdk.vm.ci.meta.JavaKind;
 44 import jdk.vm.ci.meta.ResolvedJavaField;
 45 import jdk.vm.ci.meta.ResolvedJavaType;
 46 
 47 @NodeInfo(cycles = CYCLES_2, size = SIZE_1)
 48 public abstract class UnsafeAccessNode extends FixedWithNextNode implements Canonicalizable {
 49 
 50     public static final NodeClass&lt;UnsafeAccessNode&gt; TYPE = NodeClass.create(UnsafeAccessNode.class);
 51     @Input ValueNode object;
 52     @Input ValueNode offset;
 53     protected final JavaKind accessKind;
 54     protected final LocationIdentity locationIdentity;
 55     protected final boolean forceAnyLocation;
 56 
 57     protected UnsafeAccessNode(NodeClass&lt;? extends UnsafeAccessNode&gt; c, Stamp stamp, ValueNode object, ValueNode offset, JavaKind accessKind, LocationIdentity locationIdentity,
 58                     boolean forceAnyLocation) {
 59         super(c, stamp);
 60         this.forceAnyLocation = forceAnyLocation;
 61         assert accessKind != null;
 62         assert locationIdentity != null;
</pre>
<hr />
<pre>
 78         return object;
 79     }
 80 
 81     public ValueNode offset() {
 82         return offset;
 83     }
 84 
 85     public JavaKind accessKind() {
 86         return accessKind;
 87     }
 88 
 89     @Override
 90     public Node canonical(CanonicalizerTool tool) {
 91         if (!isAnyLocationForced() &amp;&amp; getLocationIdentity().isAny()) {
 92             if (offset().isConstant()) {
 93                 long constantOffset = offset().asJavaConstant().asLong();
 94 
 95                 // Try to canonicalize to a field access.
 96                 ResolvedJavaType receiverType = StampTool.typeOrNull(object());
 97                 if (receiverType != null) {
<span class="line-modified"> 98                     ResolvedJavaField field = receiverType.findInstanceFieldWithOffset(constantOffset, accessKind());</span>
<span class="line-modified"> 99                     // No need for checking that the receiver is non-null. The field access includes</span>
<span class="line-modified">100                     // the null check and if a field is found, the offset is so small that this is</span>
<span class="line-modified">101                     // never a valid access of an arbitrary address.</span>




102                     if (field != null &amp;&amp; field.getJavaKind() == this.accessKind()) {
103                         assert !graph().isAfterFloatingReadPhase() : &quot;cannot add more precise memory location after floating read phase&quot;;
104                         // Unsafe accesses never have volatile semantics.
105                         // Memory barriers are placed around such an unsafe access at construction
106                         // time if necessary, unlike AccessFieldNodes which encapsulate their
107                         // potential volatile semantics.
108                         return cloneAsFieldAccess(graph().getAssumptions(), field, false);
109                     }
110                 }
111             }
112             ResolvedJavaType receiverType = StampTool.typeOrNull(object());
113             // Try to build a better location identity.
114             if (receiverType != null &amp;&amp; receiverType.isArray()) {
115                 LocationIdentity identity = NamedLocationIdentity.getArrayLocation(receiverType.getComponentType().getJavaKind());
116                 assert !graph().isAfterFloatingReadPhase() : &quot;cannot add more precise memory location after floating read phase&quot;;
117                 return cloneAsArrayAccess(offset(), identity);
118             }
119         }
120 
121         return this;
122     }
123 
124     protected ValueNode cloneAsFieldAccess(Assumptions assumptions, ResolvedJavaField field) {
125         return cloneAsFieldAccess(assumptions, field, field.isVolatile());
126     }
127 
128     protected abstract ValueNode cloneAsFieldAccess(Assumptions assumptions, ResolvedJavaField field, boolean volatileAccess);
129 
130     protected abstract ValueNode cloneAsArrayAccess(ValueNode location, LocationIdentity identity);






















































131 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.extended;
 26 
 27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_2;
 28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_1;
 29 
<span class="line-added"> 30 import java.nio.ByteOrder;</span>
<span class="line-added"> 31 </span>
 32 import org.graalvm.compiler.core.common.type.Stamp;
 33 import org.graalvm.compiler.graph.Node;
 34 import org.graalvm.compiler.graph.NodeClass;
 35 import org.graalvm.compiler.graph.spi.Canonicalizable;
 36 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 37 import org.graalvm.compiler.nodeinfo.NodeInfo;
 38 import org.graalvm.compiler.nodes.FixedWithNextNode;
 39 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 40 import org.graalvm.compiler.nodes.ValueNode;
 41 import org.graalvm.compiler.nodes.type.StampTool;
 42 import jdk.internal.vm.compiler.word.LocationIdentity;
 43 
 44 import jdk.vm.ci.meta.Assumptions;
<span class="line-added"> 45 import jdk.vm.ci.meta.ConstantReflectionProvider;</span>
<span class="line-added"> 46 import jdk.vm.ci.meta.JavaConstant;</span>
 47 import jdk.vm.ci.meta.JavaKind;
 48 import jdk.vm.ci.meta.ResolvedJavaField;
 49 import jdk.vm.ci.meta.ResolvedJavaType;
 50 
 51 @NodeInfo(cycles = CYCLES_2, size = SIZE_1)
 52 public abstract class UnsafeAccessNode extends FixedWithNextNode implements Canonicalizable {
 53 
 54     public static final NodeClass&lt;UnsafeAccessNode&gt; TYPE = NodeClass.create(UnsafeAccessNode.class);
 55     @Input ValueNode object;
 56     @Input ValueNode offset;
 57     protected final JavaKind accessKind;
 58     protected final LocationIdentity locationIdentity;
 59     protected final boolean forceAnyLocation;
 60 
 61     protected UnsafeAccessNode(NodeClass&lt;? extends UnsafeAccessNode&gt; c, Stamp stamp, ValueNode object, ValueNode offset, JavaKind accessKind, LocationIdentity locationIdentity,
 62                     boolean forceAnyLocation) {
 63         super(c, stamp);
 64         this.forceAnyLocation = forceAnyLocation;
 65         assert accessKind != null;
 66         assert locationIdentity != null;
</pre>
<hr />
<pre>
 82         return object;
 83     }
 84 
 85     public ValueNode offset() {
 86         return offset;
 87     }
 88 
 89     public JavaKind accessKind() {
 90         return accessKind;
 91     }
 92 
 93     @Override
 94     public Node canonical(CanonicalizerTool tool) {
 95         if (!isAnyLocationForced() &amp;&amp; getLocationIdentity().isAny()) {
 96             if (offset().isConstant()) {
 97                 long constantOffset = offset().asJavaConstant().asLong();
 98 
 99                 // Try to canonicalize to a field access.
100                 ResolvedJavaType receiverType = StampTool.typeOrNull(object());
101                 if (receiverType != null) {
<span class="line-modified">102                     ResolvedJavaField field = getStaticFieldUnsafeAccess(tool.getConstantReflection());</span>
<span class="line-modified">103                     if (field == null) {</span>
<span class="line-modified">104                         field = receiverType.findInstanceFieldWithOffset(constantOffset, accessKind());</span>
<span class="line-modified">105                     }</span>
<span class="line-added">106 </span>
<span class="line-added">107                     // No need for checking that the receiver is non-null. The field access</span>
<span class="line-added">108                     // includes the null check and if a field is found, the offset is so small that</span>
<span class="line-added">109                     // this is never a valid access of an arbitrary address.</span>
110                     if (field != null &amp;&amp; field.getJavaKind() == this.accessKind()) {
111                         assert !graph().isAfterFloatingReadPhase() : &quot;cannot add more precise memory location after floating read phase&quot;;
112                         // Unsafe accesses never have volatile semantics.
113                         // Memory barriers are placed around such an unsafe access at construction
114                         // time if necessary, unlike AccessFieldNodes which encapsulate their
115                         // potential volatile semantics.
116                         return cloneAsFieldAccess(graph().getAssumptions(), field, false);
117                     }
118                 }
119             }
120             ResolvedJavaType receiverType = StampTool.typeOrNull(object());
121             // Try to build a better location identity.
122             if (receiverType != null &amp;&amp; receiverType.isArray()) {
123                 LocationIdentity identity = NamedLocationIdentity.getArrayLocation(receiverType.getComponentType().getJavaKind());
124                 assert !graph().isAfterFloatingReadPhase() : &quot;cannot add more precise memory location after floating read phase&quot;;
125                 return cloneAsArrayAccess(offset(), identity);
126             }
127         }
128 
129         return this;
130     }
131 
132     protected ValueNode cloneAsFieldAccess(Assumptions assumptions, ResolvedJavaField field) {
133         return cloneAsFieldAccess(assumptions, field, field.isVolatile());
134     }
135 
136     protected abstract ValueNode cloneAsFieldAccess(Assumptions assumptions, ResolvedJavaField field, boolean volatileAccess);
137 
138     protected abstract ValueNode cloneAsArrayAccess(ValueNode location, LocationIdentity identity);
<span class="line-added">139 </span>
<span class="line-added">140     /**</span>
<span class="line-added">141      * In this method we check if the unsafe access is to a static field. This is the case when</span>
<span class="line-added">142      * {@code object} is a constant of type {@link Class} (static field&#39;s declaring class) and</span>
<span class="line-added">143      * {@code offset} is a constant (HotSpot-specific field offset from the declaring class).</span>
<span class="line-added">144      *</span>
<span class="line-added">145      * @return the static field, if any, that this node is reading</span>
<span class="line-added">146      */</span>
<span class="line-added">147     private ResolvedJavaField getStaticFieldUnsafeAccess(ConstantReflectionProvider constantReflection) {</span>
<span class="line-added">148         if (!object().isJavaConstant() || !offset().isJavaConstant() ||</span>
<span class="line-added">149                         object().isNullConstant() || offset().isNullConstant()) {</span>
<span class="line-added">150             return null;</span>
<span class="line-added">151         }</span>
<span class="line-added">152         JavaConstant objectConstant = object().asJavaConstant();</span>
<span class="line-added">153         JavaConstant offsetConstant = offset().asJavaConstant();</span>
<span class="line-added">154         assert objectConstant != null &amp;&amp; offsetConstant != null : &quot;Verified by the check at the beginning.&quot;;</span>
<span class="line-added">155         ResolvedJavaType staticReceiverType = constantReflection.asJavaType(objectConstant);</span>
<span class="line-added">156         if (staticReceiverType == null) {</span>
<span class="line-added">157             // object is not of type Class so it is not a static field</span>
<span class="line-added">158             return null;</span>
<span class="line-added">159         }</span>
<span class="line-added">160         return findStaticFieldWithOffset(staticReceiverType, offsetConstant.asLong(), accessKind);</span>
<span class="line-added">161     }</span>
<span class="line-added">162 </span>
<span class="line-added">163     private static ResolvedJavaField findStaticFieldWithOffset(ResolvedJavaType type, long offset, JavaKind expectedEntryKind) {</span>
<span class="line-added">164         try {</span>
<span class="line-added">165             ResolvedJavaField[] declaredFields = type.getStaticFields();</span>
<span class="line-added">166             return findFieldWithOffset(offset, expectedEntryKind, declaredFields);</span>
<span class="line-added">167         } catch (UnsupportedOperationException e) {</span>
<span class="line-added">168             return null;</span>
<span class="line-added">169         }</span>
<span class="line-added">170     }</span>
<span class="line-added">171 </span>
<span class="line-added">172     /**</span>
<span class="line-added">173      * NOTE GR-18873: this is a copy-paste implementation derived from</span>
<span class="line-added">174      * {@code jdk.vm.ci.hotspot.HotSpotResolvedObjectTypeImpl#findStaticFieldWithOffset}.</span>
<span class="line-added">175      */</span>
<span class="line-added">176     private static ResolvedJavaField findFieldWithOffset(long offset, JavaKind expectedEntryKind, ResolvedJavaField[] declaredFields) {</span>
<span class="line-added">177         for (ResolvedJavaField field : declaredFields) {</span>
<span class="line-added">178             long resolvedFieldOffset = field.getOffset();</span>
<span class="line-added">179             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN &amp;&amp;</span>
<span class="line-added">180                             expectedEntryKind.isPrimitive() &amp;&amp;</span>
<span class="line-added">181                             !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;</span>
<span class="line-added">182                             field.getJavaKind().isPrimitive()) {</span>
<span class="line-added">183                 resolvedFieldOffset += field.getJavaKind().getByteCount() -</span>
<span class="line-added">184                                 Math.min(field.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());</span>
<span class="line-added">185             }</span>
<span class="line-added">186             if (resolvedFieldOffset == offset) {</span>
<span class="line-added">187                 return field;</span>
<span class="line-added">188             }</span>
<span class="line-added">189         }</span>
<span class="line-added">190         return null;</span>
<span class="line-added">191     }</span>
<span class="line-added">192 </span>
193 }
</pre>
</td>
</tr>
</table>
<center><a href="SwitchNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="UnsafeMemoryStoreNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
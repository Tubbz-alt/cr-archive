diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/ProxyNode.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/ProxyNode.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/ProxyNode.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/ProxyNode.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -27,22 +27,28 @@
 import static org.graalvm.compiler.nodeinfo.InputType.Association;
 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_0;
 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_0;
 
 import org.graalvm.compiler.core.common.type.Stamp;
+import org.graalvm.compiler.graph.Node;
 import org.graalvm.compiler.graph.Node.ValueNumberable;
+import org.graalvm.compiler.graph.spi.Canonicalizable;
+import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 import org.graalvm.compiler.graph.NodeClass;
 import org.graalvm.compiler.nodeinfo.NodeInfo;
 import org.graalvm.compiler.nodes.calc.FloatingNode;
 import org.graalvm.compiler.nodes.extended.GuardingNode;
+import org.graalvm.compiler.nodes.memory.MemoryNode;
+import org.graalvm.compiler.nodes.spi.Proxy;
+import jdk.internal.vm.compiler.word.LocationIdentity;
 
 /**
  * A proxy is inserted at loop exits for any value that is created inside the loop (i.e. was not
  * live on entry to the loop) and is (potentially) used after the loop.
  */
 @NodeInfo(cycles = CYCLES_0, size = SIZE_0)
-public abstract class ProxyNode extends FloatingNode implements ValueNumberable {
+public abstract class ProxyNode extends FloatingNode implements Proxy, ValueNumberable, Canonicalizable {
 
     public static final NodeClass<ProxyNode> TYPE = NodeClass.create(ProxyNode.class);
     @Input(Association) LoopExitNode loopExit;
 
     protected ProxyNode(NodeClass<? extends ProxyNode> c, Stamp stamp, LoopExitNode proxyPoint) {
@@ -60,19 +66,38 @@
 
     public LoopExitNode proxyPoint() {
         return loopExit;
     }
 
+    @Override
+    public ValueNode getOriginalNode() {
+        return value();
+    }
+
     @Override
     public boolean verify() {
         assert !(value() instanceof ProxyNode) || ((ProxyNode) value()).loopExit != loopExit;
         return super.verify();
     }
 
-    public static ValueProxyNode forValue(ValueNode value, LoopExitNode exit, StructuredGraph graph) {
-        return graph.unique(new ValueProxyNode(value, exit));
+    public static ValueProxyNode forValue(ValueNode value, LoopExitNode exit) {
+        return exit.graph().unique(new ValueProxyNode(value, exit));
+    }
+
+    public static GuardProxyNode forGuard(GuardingNode value, LoopExitNode exit) {
+        return exit.graph().unique(new GuardProxyNode(value, exit));
     }
 
-    public static GuardProxyNode forGuard(GuardingNode value, LoopExitNode exit, StructuredGraph graph) {
-        return graph.unique(new GuardProxyNode(value, exit));
+    public static MemoryProxyNode forMemory(MemoryNode value, LoopExitNode exit, LocationIdentity locationIdentity) {
+        return exit.graph().unique(new MemoryProxyNode(value, exit, locationIdentity));
     }
+
+    @Override
+    public Node canonical(CanonicalizerTool tool) {
+        if (value() == null) {
+            return null;
+        }
+        return this;
+    }
+
+    public abstract PhiNode createPhi(AbstractMergeNode merge);
 }

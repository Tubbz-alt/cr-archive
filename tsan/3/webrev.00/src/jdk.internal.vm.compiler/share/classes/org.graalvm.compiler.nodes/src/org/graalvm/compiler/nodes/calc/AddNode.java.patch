diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/AddNode.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/AddNode.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/AddNode.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/AddNode.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -52,11 +52,11 @@
     public AddNode(ValueNode x, ValueNode y) {
         this(TYPE, x, y);
     }
 
     protected AddNode(NodeClass<? extends AddNode> c, ValueNode x, ValueNode y) {
-        super(c, ArithmeticOpTable::getAdd, x, y);
+        super(c, getArithmeticOpTable(x).getAdd(), x, y);
     }
 
     public static ValueNode create(ValueNode x, ValueNode y, NodeView view) {
         BinaryOp<Add> op = ArithmeticOpTable.forStamp(x.stamp(view)).getAdd();
         Stamp stamp = op.foldStamp(x.stamp(view), y.stamp(view));
@@ -69,10 +69,15 @@
         } else {
             return canonical(null, op, x, y, view);
         }
     }
 
+    @Override
+    protected BinaryOp<Add> getOp(ArithmeticOpTable table) {
+        return table.getAdd();
+    }
+
     private static ValueNode canonical(AddNode addNode, BinaryOp<Add> op, ValueNode forX, ValueNode forY, NodeView view) {
         AddNode self = addNode;
         boolean associative = op.isAssociative();
         if (associative) {
             if (forX instanceof SubNode) {

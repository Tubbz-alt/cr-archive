<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/MethodCallTargetNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LoweredAtomicReadAndWriteNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MonitorEnterNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/MethodCallTargetNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.java;
 26 
 27 import org.graalvm.compiler.core.common.type.Stamp;
 28 import org.graalvm.compiler.core.common.type.StampFactory;
 29 import org.graalvm.compiler.core.common.type.StampPair;
 30 import org.graalvm.compiler.core.common.type.TypeReference;
 31 import org.graalvm.compiler.graph.IterableNodeType;
 32 import org.graalvm.compiler.graph.Node;
 33 import org.graalvm.compiler.graph.NodeClass;
 34 import org.graalvm.compiler.graph.spi.Simplifiable;
 35 import org.graalvm.compiler.graph.spi.SimplifierTool;
 36 import org.graalvm.compiler.nodeinfo.NodeInfo;
 37 import org.graalvm.compiler.nodeinfo.Verbosity;

 38 import org.graalvm.compiler.nodes.CallTargetNode;
 39 import org.graalvm.compiler.nodes.FixedGuardNode;
 40 import org.graalvm.compiler.nodes.Invoke;
 41 import org.graalvm.compiler.nodes.LogicNode;
 42 import org.graalvm.compiler.nodes.NodeView;
 43 import org.graalvm.compiler.nodes.PiNode;
 44 import org.graalvm.compiler.nodes.StructuredGraph;
 45 import org.graalvm.compiler.nodes.ValueNode;
<span class="line-modified"> 46 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;</span>
 47 import org.graalvm.compiler.nodes.spi.UncheckedInterfaceProvider;
 48 import org.graalvm.compiler.nodes.type.StampTool;
 49 
 50 import jdk.vm.ci.code.BytecodeFrame;
 51 import jdk.vm.ci.meta.Assumptions;
 52 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 53 import jdk.vm.ci.meta.DeoptimizationAction;
 54 import jdk.vm.ci.meta.DeoptimizationReason;
 55 import jdk.vm.ci.meta.JavaKind;
 56 import jdk.vm.ci.meta.JavaTypeProfile;
 57 import jdk.vm.ci.meta.ResolvedJavaMethod;
 58 import jdk.vm.ci.meta.ResolvedJavaType;
 59 
 60 @NodeInfo
 61 public class MethodCallTargetNode extends CallTargetNode implements IterableNodeType, Simplifiable {
 62     public static final NodeClass&lt;MethodCallTargetNode&gt; TYPE = NodeClass.create(MethodCallTargetNode.class);
 63     protected JavaTypeProfile profile;
 64 
 65     public MethodCallTargetNode(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] arguments, StampPair returnStamp, JavaTypeProfile profile) {
 66         this(TYPE, invokeKind, targetMethod, arguments, returnStamp, profile);
</pre>
<hr />
<pre>
 78      * @return the instruction that produces the receiver object for this invocation if any,
 79      *         {@code null} if this invocation does not take a receiver object
 80      */
 81     public ValueNode receiver() {
 82         return isStatic() ? null : arguments().get(0);
 83     }
 84 
 85     /**
 86      * Checks whether this is an invocation of a static method.
 87      *
 88      * @return {@code true} if the invocation is a static invocation
 89      */
 90     public boolean isStatic() {
 91         return invokeKind() == InvokeKind.Static;
 92     }
 93 
 94     public JavaKind returnKind() {
 95         return targetMethod().getSignature().getReturnKind();
 96     }
 97 
<span class="line-removed"> 98     public Invoke invoke() {</span>
<span class="line-removed"> 99         return (Invoke) this.usages().first();</span>
<span class="line-removed">100     }</span>
<span class="line-removed">101 </span>
102     @Override
103     public boolean verify() {
104         assert getUsageCount() &lt;= 1 : &quot;call target may only be used by a single invoke&quot;;
105         for (Node n : usages()) {
106             assertTrue(n instanceof Invoke, &quot;call target can only be used from an invoke (%s)&quot;, n);
107         }
108         if (invokeKind().isDirect()) {
109             assertTrue(targetMethod().isConcrete(), &quot;special calls or static calls are only allowed for concrete methods (%s)&quot;, targetMethod());
110         }
111         if (invokeKind() == InvokeKind.Static) {
112             assertTrue(targetMethod().isStatic(), &quot;static calls are only allowed for static methods (%s)&quot;, targetMethod());
113         } else {
114             assertFalse(targetMethod().isStatic(), &quot;static calls are only allowed for non-static methods (%s)&quot;, targetMethod());
115         }
116         return super.verify();
117     }
118 
119     @Override
120     public String toString(Verbosity verbosity) {
121         if (verbosity == Verbosity.Long) {
</pre>
<hr />
<pre>
219             }
220         }
221     }
222 
223     private boolean tryCheckCastSingleImplementor(ValueNode receiver, TypeReference speculatedType) {
224         ResolvedJavaType singleImplementor = speculatedType.getType();
225         if (singleImplementor != null) {
226             ResolvedJavaMethod singleImplementorMethod = singleImplementor.resolveConcreteMethod(targetMethod(), invoke().getContextType());
227             if (singleImplementorMethod != null) {
228                 /**
229                  * We have an invoke on an interface with a single implementor. We can replace this
230                  * with an invoke virtual.
231                  *
232                  * To do so we need to ensure two properties: 1) the receiver must implement the
233                  * interface (declaredReceiverType). The verifier does not prove this so we need a
234                  * dynamic check. 2) we need to ensure that there is still only one implementor of
235                  * this interface, i.e. that we are calling the right method. We could do this with
236                  * an assumption but as we need an instanceof check anyway we can verify both
237                  * properties by checking of the receiver is an instance of the single implementor.
238                  */
<span class="line-modified">239                 ValueAnchorNode anchor = new ValueAnchorNode(null);</span>
<span class="line-removed">240                 if (anchor != null) {</span>
<span class="line-removed">241                     graph().add(anchor);</span>
<span class="line-removed">242                     graph().addBeforeFixed(invoke().asNode(), anchor);</span>
<span class="line-removed">243                 }</span>
244                 LogicNode condition = graph().addOrUniqueWithInputs(InstanceOfNode.create(speculatedType, receiver, getProfile(), anchor));
245                 FixedGuardNode guard = graph().add(new FixedGuardNode(condition, DeoptimizationReason.OptimizedTypeCheckViolated, DeoptimizationAction.InvalidateRecompile, false));
246                 graph().addBeforeFixed(invoke().asNode(), guard);
247                 ValueNode valueNode = graph().addOrUnique(new PiNode(receiver, StampFactory.objectNonNull(speculatedType), guard));
248                 arguments().set(0, valueNode);
249                 if (speculatedType.isExact()) {
250                     setInvokeKind(InvokeKind.Special);
251                 } else {
252                     setInvokeKind(InvokeKind.Virtual);
253                 }
254                 setTargetMethod(singleImplementorMethod);
255                 return true;
256             }
257         }
258         return false;
259     }
260 
261     public JavaTypeProfile getProfile() {
262         return profile;
263     }
264 
265     @Override
266     public String targetName() {
267         if (targetMethod() == null) {
268             return &quot;??Invalid!&quot;;
269         }
270         return targetMethod().format(&quot;%h.%n&quot;);
271     }
272 
273     public static MethodCallTargetNode find(StructuredGraph graph, ResolvedJavaMethod method) {
274         for (MethodCallTargetNode target : graph.getNodes(MethodCallTargetNode.TYPE)) {
275             if (target.targetMethod().equals(method)) {
276                 return target;
277             }
278         }
279         return null;
280     }




281 }
</pre>
</td>
<td>
<hr />
<pre>
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.java;
 26 
 27 import org.graalvm.compiler.core.common.type.Stamp;
 28 import org.graalvm.compiler.core.common.type.StampFactory;
 29 import org.graalvm.compiler.core.common.type.StampPair;
 30 import org.graalvm.compiler.core.common.type.TypeReference;
 31 import org.graalvm.compiler.graph.IterableNodeType;
 32 import org.graalvm.compiler.graph.Node;
 33 import org.graalvm.compiler.graph.NodeClass;
 34 import org.graalvm.compiler.graph.spi.Simplifiable;
 35 import org.graalvm.compiler.graph.spi.SimplifierTool;
 36 import org.graalvm.compiler.nodeinfo.NodeInfo;
 37 import org.graalvm.compiler.nodeinfo.Verbosity;
<span class="line-added"> 38 import org.graalvm.compiler.nodes.BeginNode;</span>
 39 import org.graalvm.compiler.nodes.CallTargetNode;
 40 import org.graalvm.compiler.nodes.FixedGuardNode;
 41 import org.graalvm.compiler.nodes.Invoke;
 42 import org.graalvm.compiler.nodes.LogicNode;
 43 import org.graalvm.compiler.nodes.NodeView;
 44 import org.graalvm.compiler.nodes.PiNode;
 45 import org.graalvm.compiler.nodes.StructuredGraph;
 46 import org.graalvm.compiler.nodes.ValueNode;
<span class="line-modified"> 47 import org.graalvm.compiler.nodes.extended.AnchoringNode;</span>
 48 import org.graalvm.compiler.nodes.spi.UncheckedInterfaceProvider;
 49 import org.graalvm.compiler.nodes.type.StampTool;
 50 
 51 import jdk.vm.ci.code.BytecodeFrame;
 52 import jdk.vm.ci.meta.Assumptions;
 53 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 54 import jdk.vm.ci.meta.DeoptimizationAction;
 55 import jdk.vm.ci.meta.DeoptimizationReason;
 56 import jdk.vm.ci.meta.JavaKind;
 57 import jdk.vm.ci.meta.JavaTypeProfile;
 58 import jdk.vm.ci.meta.ResolvedJavaMethod;
 59 import jdk.vm.ci.meta.ResolvedJavaType;
 60 
 61 @NodeInfo
 62 public class MethodCallTargetNode extends CallTargetNode implements IterableNodeType, Simplifiable {
 63     public static final NodeClass&lt;MethodCallTargetNode&gt; TYPE = NodeClass.create(MethodCallTargetNode.class);
 64     protected JavaTypeProfile profile;
 65 
 66     public MethodCallTargetNode(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] arguments, StampPair returnStamp, JavaTypeProfile profile) {
 67         this(TYPE, invokeKind, targetMethod, arguments, returnStamp, profile);
</pre>
<hr />
<pre>
 79      * @return the instruction that produces the receiver object for this invocation if any,
 80      *         {@code null} if this invocation does not take a receiver object
 81      */
 82     public ValueNode receiver() {
 83         return isStatic() ? null : arguments().get(0);
 84     }
 85 
 86     /**
 87      * Checks whether this is an invocation of a static method.
 88      *
 89      * @return {@code true} if the invocation is a static invocation
 90      */
 91     public boolean isStatic() {
 92         return invokeKind() == InvokeKind.Static;
 93     }
 94 
 95     public JavaKind returnKind() {
 96         return targetMethod().getSignature().getReturnKind();
 97     }
 98 




 99     @Override
100     public boolean verify() {
101         assert getUsageCount() &lt;= 1 : &quot;call target may only be used by a single invoke&quot;;
102         for (Node n : usages()) {
103             assertTrue(n instanceof Invoke, &quot;call target can only be used from an invoke (%s)&quot;, n);
104         }
105         if (invokeKind().isDirect()) {
106             assertTrue(targetMethod().isConcrete(), &quot;special calls or static calls are only allowed for concrete methods (%s)&quot;, targetMethod());
107         }
108         if (invokeKind() == InvokeKind.Static) {
109             assertTrue(targetMethod().isStatic(), &quot;static calls are only allowed for static methods (%s)&quot;, targetMethod());
110         } else {
111             assertFalse(targetMethod().isStatic(), &quot;static calls are only allowed for non-static methods (%s)&quot;, targetMethod());
112         }
113         return super.verify();
114     }
115 
116     @Override
117     public String toString(Verbosity verbosity) {
118         if (verbosity == Verbosity.Long) {
</pre>
<hr />
<pre>
216             }
217         }
218     }
219 
220     private boolean tryCheckCastSingleImplementor(ValueNode receiver, TypeReference speculatedType) {
221         ResolvedJavaType singleImplementor = speculatedType.getType();
222         if (singleImplementor != null) {
223             ResolvedJavaMethod singleImplementorMethod = singleImplementor.resolveConcreteMethod(targetMethod(), invoke().getContextType());
224             if (singleImplementorMethod != null) {
225                 /**
226                  * We have an invoke on an interface with a single implementor. We can replace this
227                  * with an invoke virtual.
228                  *
229                  * To do so we need to ensure two properties: 1) the receiver must implement the
230                  * interface (declaredReceiverType). The verifier does not prove this so we need a
231                  * dynamic check. 2) we need to ensure that there is still only one implementor of
232                  * this interface, i.e. that we are calling the right method. We could do this with
233                  * an assumption but as we need an instanceof check anyway we can verify both
234                  * properties by checking of the receiver is an instance of the single implementor.
235                  */
<span class="line-modified">236                 AnchoringNode anchor = BeginNode.prevBegin(invoke().asNode());</span>




237                 LogicNode condition = graph().addOrUniqueWithInputs(InstanceOfNode.create(speculatedType, receiver, getProfile(), anchor));
238                 FixedGuardNode guard = graph().add(new FixedGuardNode(condition, DeoptimizationReason.OptimizedTypeCheckViolated, DeoptimizationAction.InvalidateRecompile, false));
239                 graph().addBeforeFixed(invoke().asNode(), guard);
240                 ValueNode valueNode = graph().addOrUnique(new PiNode(receiver, StampFactory.objectNonNull(speculatedType), guard));
241                 arguments().set(0, valueNode);
242                 if (speculatedType.isExact()) {
243                     setInvokeKind(InvokeKind.Special);
244                 } else {
245                     setInvokeKind(InvokeKind.Virtual);
246                 }
247                 setTargetMethod(singleImplementorMethod);
248                 return true;
249             }
250         }
251         return false;
252     }
253 
254     public JavaTypeProfile getProfile() {
255         return profile;
256     }
257 
258     @Override
259     public String targetName() {
260         if (targetMethod() == null) {
261             return &quot;??Invalid!&quot;;
262         }
263         return targetMethod().format(&quot;%h.%n&quot;);
264     }
265 
266     public static MethodCallTargetNode find(StructuredGraph graph, ResolvedJavaMethod method) {
267         for (MethodCallTargetNode target : graph.getNodes(MethodCallTargetNode.TYPE)) {
268             if (target.targetMethod().equals(method)) {
269                 return target;
270             }
271         }
272         return null;
273     }
<span class="line-added">274 </span>
<span class="line-added">275     public void setJavaTypeProfile(JavaTypeProfile profile) {</span>
<span class="line-added">276         this.profile = profile;</span>
<span class="line-added">277     }</span>
278 }
</pre>
</td>
</tr>
</table>
<center><a href="LoweredAtomicReadAndWriteNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MonitorEnterNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/IntrinsicContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.graphbuilderconf;
 26 
 27 import static jdk.vm.ci.code.BytecodeFrame.AFTER_BCI;
 28 import static jdk.vm.ci.code.BytecodeFrame.AFTER_EXCEPTION_BCI;
 29 import static jdk.vm.ci.code.BytecodeFrame.BEFORE_BCI;
 30 import static jdk.vm.ci.code.BytecodeFrame.INVALID_FRAMESTATE_BCI;
 31 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;
 32 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;
 33 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION;
 34 
 35 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 36 import org.graalvm.compiler.bytecode.BytecodeProvider;
 37 import org.graalvm.compiler.graph.NodeSourcePosition;
 38 import org.graalvm.compiler.nodes.AbstractMergeNode;
 39 import org.graalvm.compiler.nodes.FrameState;
 40 import org.graalvm.compiler.nodes.Invoke;
 41 import org.graalvm.compiler.nodes.LoopExitNode;
 42 import org.graalvm.compiler.nodes.StateSplit;
 43 import org.graalvm.compiler.nodes.StructuredGraph;
 44 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
 45 
 46 import jdk.vm.ci.meta.ResolvedJavaMethod;
 47 
 48 /**
 49  * An intrinsic is a substitute implementation of a Java method (or a bytecode in the case of
 50  * snippets) that is itself implemented in Java. This interface provides information about the
 51  * intrinsic currently being processed by the graph builder.
 52  *
 53  * When in the scope of an intrinsic, the graph builder does not check the value kinds flowing
 54  * through the JVM state since intrinsics can employ non-Java kinds to represent values such as raw
 55  * machine words and pointers.
 56  */
 57 public class IntrinsicContext {
 58 
 59     /**
 60      * Method being intrinsified.
 61      */
 62     final ResolvedJavaMethod originalMethod;
 63 
 64     /**
 65      * Method providing the intrinsic implementation.
 66      */
 67     final ResolvedJavaMethod intrinsicMethod;
 68 
 69     /**
 70      * Provider of bytecode to be parsed for a method that is part of an intrinsic.
 71      */
 72     final BytecodeProvider bytecodeProvider;
 73 
 74     final CompilationContext compilationContext;
 75 
 76     final boolean allowPartialIntrinsicArgumentMismatch;
 77 
 78     public IntrinsicContext(ResolvedJavaMethod method, ResolvedJavaMethod intrinsic, BytecodeProvider bytecodeProvider, CompilationContext compilationContext) {
 79         this(method, intrinsic, bytecodeProvider, compilationContext, false);
 80     }
 81 
 82     public IntrinsicContext(ResolvedJavaMethod method, ResolvedJavaMethod intrinsic, BytecodeProvider bytecodeProvider, CompilationContext compilationContext,
 83                     boolean allowPartialIntrinsicArgumentMismatch) {
 84         this.originalMethod = method;
 85         this.intrinsicMethod = intrinsic;
 86         this.bytecodeProvider = bytecodeProvider;
 87         assert bytecodeProvider != null;
 88         this.compilationContext = compilationContext;
 89         this.allowPartialIntrinsicArgumentMismatch = allowPartialIntrinsicArgumentMismatch;
 90         assert !isCompilationRoot() || method.hasBytecodes() : &quot;Cannot root compile intrinsic for native or abstract method &quot; + method.format(&quot;%H.%n(%p)&quot;);
 91         assert !method.equals(intrinsic) || method.getAnnotation(MethodSubstitution.class) == null : &quot;method and intrinsic must be different: &quot; + method + &quot; &quot; + intrinsic;
 92     }
 93 
 94     /**
 95      * A partial intrinsic exits by (effectively) calling the intrinsified method. Normally, this
 96      * call must use exactly the same arguments as the call that is being intrinsified. This allows
 97      * to override this behavior.
 98      */
 99     public boolean allowPartialIntrinsicArgumentMismatch() {
100         return allowPartialIntrinsicArgumentMismatch;
101     }
102 
103     /**
104      * Gets the method being intrinsified.
105      */
106     public ResolvedJavaMethod getOriginalMethod() {
107         return originalMethod;
108     }
109 
110     /**
111      * Gets the method providing the intrinsic implementation.
112      */
113     public ResolvedJavaMethod getIntrinsicMethod() {
114         return intrinsicMethod;
115     }
116 
117     /**
118      * Gets provider of bytecode to be parsed for a method that is part of an intrinsic.
119      */
120     public BytecodeProvider getBytecodeProvider() {
121         return bytecodeProvider;
122     }
123 
124     /**
125      * Determines if a call within the compilation scope of this intrinsic represents a call to the
126      * {@linkplain #getOriginalMethod() original} method. This denotes the path where a partial
127      * intrinsification falls back to the original method.
128      */
129     public boolean isCallToOriginal(ResolvedJavaMethod targetMethod) {
130         return originalMethod.equals(targetMethod) || intrinsicMethod.equals(targetMethod);
131     }
132 
133     private NodeSourcePosition nodeSourcePosition;
134 
135     public boolean isPostParseInlined() {
136         return compilationContext.equals(INLINE_AFTER_PARSING);
137     }
138 
139     public boolean isCompilationRoot() {
140         return compilationContext.equals(ROOT_COMPILATION) || compilationContext.equals(ROOT_COMPILATION_ENCODING);
141     }
142 
143     public boolean isIntrinsicEncoding() {
144         return compilationContext.equals(ROOT_COMPILATION_ENCODING);
145     }
146 
147     public NodeSourcePosition getNodeSourcePosition() {
148         return nodeSourcePosition;
149     }
150 
151     public void setNodeSourcePosition(NodeSourcePosition position) {
152         assert nodeSourcePosition == null : &quot;can only be set once&quot;;
153         this.nodeSourcePosition = position;
154     }
155 
156     /**
157      * Denotes the compilation context in which an intrinsic is being parsed.
158      */
159     public enum CompilationContext {
160         /**
161          * An intrinsic is being processed when parsing an invoke bytecode that calls the
162          * intrinsified method.
163          */
164         INLINE_DURING_PARSING,
165 
166         /**
167          * An intrinsic is being processed when inlining an {@link Invoke} in an existing graph.
168          */
169         INLINE_AFTER_PARSING,
170 
171         /**
172          * An intrinsic is the root of compilation.
173          */
174         ROOT_COMPILATION,
175 
176         /**
177          * An intrinsic is the root of a compilation done for graph encoding.
178          */
179         ROOT_COMPILATION_ENCODING
180     }
181 
182     /**
183      * Models the state of a graph in terms of {@link StateSplit#hasSideEffect() side effects} that
184      * are control flow predecessors of the current point in a graph.
185      */
186     public interface SideEffectsState {
187 
188         /**
189          * Determines if the current program point is preceded by one or more side effects.
190          */
191         boolean isAfterSideEffect();
192 
193         /**
194          * Gets the side effects preceding the current program point.
195          */
196         Iterable&lt;StateSplit&gt; sideEffects();
197 
198         /**
199          * Records a side effect for the current program point.
200          */
201         void addSideEffect(StateSplit sideEffect);
202     }
203 
204     @SuppressWarnings(&quot;unused&quot;)
205     public boolean isDeferredInvoke(StateSplit stateSplit) {
206         return false;
207     }
208 
209     public FrameState createFrameState(StructuredGraph graph, SideEffectsState sideEffects, StateSplit forStateSplit, NodeSourcePosition sourcePosition) {
210         assert forStateSplit != graph.start();
211         if (forStateSplit.hasSideEffect()) {
212             if (sideEffects.isAfterSideEffect()) {
213                 // Only the last side effect on any execution path in a replacement
214                 // can inherit the stateAfter of the replaced node
215                 FrameState invalid = graph.add(new FrameState(INVALID_FRAMESTATE_BCI));
216                 if (graph.trackNodeSourcePosition()) {
217                     invalid.setNodeSourcePosition(sourcePosition);
218                 }
219                 for (StateSplit lastSideEffect : sideEffects.sideEffects()) {
220                     lastSideEffect.setStateAfter(invalid);
221                 }
222             }
223             FrameState frameState;
224             if (isDeferredInvoke(forStateSplit)) {
225                 frameState = graph.add(new FrameState(INVALID_FRAMESTATE_BCI));
226             } else {
227                 sideEffects.addSideEffect(forStateSplit);
228                 if (forStateSplit instanceof ExceptionObjectNode) {
229                     frameState = graph.add(new FrameState(AFTER_EXCEPTION_BCI, (ExceptionObjectNode) forStateSplit));
230                 } else {
231                     frameState = graph.add(new FrameState(AFTER_BCI));
232                 }
233             }
234             if (graph.trackNodeSourcePosition()) {
235                 frameState.setNodeSourcePosition(sourcePosition);
236             }
237             return frameState;
238         } else {
239             if (forStateSplit instanceof AbstractMergeNode || forStateSplit instanceof LoopExitNode) {
240                 // Merge nodes always need a frame state
241                 if (sideEffects.isAfterSideEffect()) {
242                     // A merge after one or more side effects
243                     FrameState frameState = graph.add(new FrameState(AFTER_BCI));
244                     if (graph.trackNodeSourcePosition()) {
245                         frameState.setNodeSourcePosition(sourcePosition);
246                     }
247                     return frameState;
248                 } else {
249                     // A merge before any side effects
250                     FrameState frameState = graph.add(new FrameState(BEFORE_BCI));
251                     if (graph.trackNodeSourcePosition()) {
252                         frameState.setNodeSourcePosition(sourcePosition);
253                     }
254                     return frameState;
255                 }
256             } else {
257                 // Other non-side-effects do not need a state
258                 return null;
259             }
260         }
261     }
262 
263     @Override
264     public String toString() {
265         return &quot;Intrinsic{original: &quot; + originalMethod.format(&quot;%H.%n(%p)&quot;) + &quot;, intrinsic: &quot; + (intrinsicMethod != null ? intrinsicMethod.format(&quot;%H.%n(%p)&quot;) : &quot;null&quot;) + &quot;, context: &quot; +
266                         compilationContext + &quot;}&quot;;
267     }
268 }
    </pre>
  </body>
</html>
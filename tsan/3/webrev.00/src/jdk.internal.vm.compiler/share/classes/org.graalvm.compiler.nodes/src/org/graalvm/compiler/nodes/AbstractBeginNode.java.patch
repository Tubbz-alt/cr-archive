diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/AbstractBeginNode.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/AbstractBeginNode.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/AbstractBeginNode.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/AbstractBeginNode.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -30,10 +30,11 @@
 import org.graalvm.compiler.core.common.type.Stamp;
 import org.graalvm.compiler.core.common.type.StampFactory;
 import org.graalvm.compiler.graph.IterableNodeType;
 import org.graalvm.compiler.graph.Node;
 import org.graalvm.compiler.graph.NodeClass;
+import org.graalvm.compiler.graph.Position;
 import org.graalvm.compiler.graph.iterators.NodeIterable;
 import org.graalvm.compiler.nodeinfo.InputType;
 import org.graalvm.compiler.nodeinfo.NodeInfo;
 import org.graalvm.compiler.nodes.extended.AnchoringNode;
 import org.graalvm.compiler.nodes.extended.GuardingNode;
@@ -57,34 +58,33 @@
 
     public static AbstractBeginNode prevBegin(FixedNode from) {
         Node next = from;
         while (next != null) {
             if (next instanceof AbstractBeginNode) {
-                AbstractBeginNode begin = (AbstractBeginNode) next;
-                return begin;
+                return (AbstractBeginNode) next;
             }
             next = next.predecessor();
         }
         return null;
     }
 
-    private void evacuateGuards(FixedNode evacuateFrom) {
+    private void evacuateAnchored(FixedNode evacuateFrom) {
         if (!hasNoUsages()) {
             AbstractBeginNode prevBegin = prevBegin(evacuateFrom);
             assert prevBegin != null;
-            for (Node anchored : anchored().snapshot()) {
-                anchored.replaceFirstInput(this, prevBegin);
-            }
+            replaceAtUsages(InputType.Anchor, prevBegin);
+            replaceAtUsages(InputType.Guard, prevBegin);
+            assert anchored().isEmpty() : anchored().snapshot();
         }
     }
 
     public void prepareDelete() {
         prepareDelete((FixedNode) predecessor());
     }
 
     public void prepareDelete(FixedNode evacuateFrom) {
-        evacuateGuards(evacuateFrom);
+        evacuateAnchored(evacuateFrom);
     }
 
     @Override
     public boolean verify() {
         assertTrue(predecessor() != null || this == graph().start() || this instanceof AbstractMergeNode, "begin nodes must be connected");
@@ -96,18 +96,35 @@
         if (withSpeculationFence) {
             gen.getLIRGeneratorTool().emitSpeculationFence();
         }
     }
 
+    public boolean isUsedAsGuardInput() {
+        if (this.hasUsages()) {
+            for (Node n : usages()) {
+                for (Position inputPosition : n.inputPositions()) {
+                    if (inputPosition.getInputType() == InputType.Guard && inputPosition.get(n) == this) {
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
     public NodeIterable<GuardNode> guards() {
         return usages().filter(GuardNode.class);
     }
 
     public NodeIterable<Node> anchored() {
         return usages();
     }
 
+    public boolean hasAnchored() {
+        return this.hasUsages();
+    }
+
     public NodeIterable<FixedNode> getBlockNodes() {
         return new NodeIterable<FixedNode>() {
 
             @Override
             public Iterator<FixedNode> iterator() {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/ConstantNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ComputeObjectAddressNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ControlSplitNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/ConstantNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes;
 26 
 27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_0;
 28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_1;
 29 
 30 import java.util.Map;
 31 
 32 import org.graalvm.compiler.core.common.LIRKind;
 33 import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
 34 import org.graalvm.compiler.core.common.type.FloatStamp;
 35 import org.graalvm.compiler.core.common.type.IntegerStamp;
 36 import org.graalvm.compiler.core.common.type.Stamp;
 37 import org.graalvm.compiler.core.common.type.StampFactory;
 38 import org.graalvm.compiler.debug.GraalError;
 39 import org.graalvm.compiler.graph.Node;
 40 import org.graalvm.compiler.graph.NodeClass;

 41 import org.graalvm.compiler.graph.iterators.NodeIterable;
 42 import org.graalvm.compiler.lir.ConstantValue;

 43 import org.graalvm.compiler.nodeinfo.NodeInfo;
 44 import org.graalvm.compiler.nodeinfo.Verbosity;
 45 import org.graalvm.compiler.nodes.calc.FloatingNode;

 46 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
 47 import org.graalvm.compiler.nodes.spi.LIRLowerable;
 48 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
 49 
 50 import jdk.vm.ci.code.CodeUtil;
 51 import jdk.vm.ci.meta.Constant;
 52 import jdk.vm.ci.meta.ConstantReflectionProvider;
 53 import jdk.vm.ci.meta.JavaConstant;
 54 import jdk.vm.ci.meta.JavaKind;
 55 import jdk.vm.ci.meta.MetaAccessProvider;
 56 import jdk.vm.ci.meta.PrimitiveConstant;
 57 import jdk.vm.ci.meta.ResolvedJavaType;
 58 
 59 /**
 60  * The {@code ConstantNode} represents a {@link Constant constant}.
 61  */
 62 @NodeInfo(nameTemplate = &quot;C({p#rawvalue}) {p#stampKind}&quot;, cycles = CYCLES_0, size = SIZE_1)
 63 public final class ConstantNode extends FloatingNode implements LIRLowerable, ArrayLengthProvider {
 64 
 65     public static final NodeClass&lt;ConstantNode&gt; TYPE = NodeClass.create(ConstantNode.class);
</pre>
<hr />
<pre>
126     }
127 
128     /**
129      * Gathers all the {@link ConstantNode}s that are inputs to the
130      * {@linkplain StructuredGraph#getNodes() live nodes} in a given graph.
131      */
132     public static NodeIterable&lt;ConstantNode&gt; getConstantNodes(StructuredGraph graph) {
133         return graph.getNodes().filter(ConstantNode.class);
134     }
135 
136     /**
137      * Replaces this node at its usages with another node.
138      */
139     public void replace(StructuredGraph graph, Node replacement) {
140         assert graph == graph();
141         replaceAtUsagesAndDelete(replacement);
142     }
143 
144     @Override
145     public void generate(NodeLIRBuilderTool gen) {
<span class="line-modified">146         LIRKind kind = gen.getLIRGeneratorTool().getLIRKind(stamp(NodeView.DEFAULT));</span>

147         if (onlyUsedInVirtualState()) {
148             gen.setResult(this, new ConstantValue(kind, value));


149         } else {
150             gen.setResult(this, gen.getLIRGeneratorTool().emitConstant(kind, value));
151         }
152     }
153 















154     private boolean onlyUsedInVirtualState() {
155         for (Node n : this.usages()) {
156             if (n instanceof VirtualState) {
157                 // Only virtual usage.
158             } else {
159                 return false;
160             }
161         }
162         return true;
163     }
164 
165     public static ConstantNode forConstant(JavaConstant constant, MetaAccessProvider metaAccess, StructuredGraph graph) {
166         if (constant.getJavaKind().getStackKind() == JavaKind.Int &amp;&amp; constant.getJavaKind() != JavaKind.Int) {
167             return forInt(constant.asInt(), graph);
168         }
169         if (constant.getJavaKind() == JavaKind.Object) {
170             return unique(graph, new ConstantNode(constant, StampFactory.forConstant(constant, metaAccess)));
171         } else {
172             return unique(graph, createPrimitive(constant));
173         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes;
 26 
 27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_0;
 28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_1;
 29 
 30 import java.util.Map;
 31 
 32 import org.graalvm.compiler.core.common.LIRKind;
 33 import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
 34 import org.graalvm.compiler.core.common.type.FloatStamp;
 35 import org.graalvm.compiler.core.common.type.IntegerStamp;
 36 import org.graalvm.compiler.core.common.type.Stamp;
 37 import org.graalvm.compiler.core.common.type.StampFactory;
 38 import org.graalvm.compiler.debug.GraalError;
 39 import org.graalvm.compiler.graph.Node;
 40 import org.graalvm.compiler.graph.NodeClass;
<span class="line-added"> 41 import org.graalvm.compiler.graph.NodeMap;</span>
 42 import org.graalvm.compiler.graph.iterators.NodeIterable;
 43 import org.graalvm.compiler.lir.ConstantValue;
<span class="line-added"> 44 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;</span>
 45 import org.graalvm.compiler.nodeinfo.NodeInfo;
 46 import org.graalvm.compiler.nodeinfo.Verbosity;
 47 import org.graalvm.compiler.nodes.calc.FloatingNode;
<span class="line-added"> 48 import org.graalvm.compiler.nodes.cfg.Block;</span>
 49 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
 50 import org.graalvm.compiler.nodes.spi.LIRLowerable;
 51 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
 52 
 53 import jdk.vm.ci.code.CodeUtil;
 54 import jdk.vm.ci.meta.Constant;
 55 import jdk.vm.ci.meta.ConstantReflectionProvider;
 56 import jdk.vm.ci.meta.JavaConstant;
 57 import jdk.vm.ci.meta.JavaKind;
 58 import jdk.vm.ci.meta.MetaAccessProvider;
 59 import jdk.vm.ci.meta.PrimitiveConstant;
 60 import jdk.vm.ci.meta.ResolvedJavaType;
 61 
 62 /**
 63  * The {@code ConstantNode} represents a {@link Constant constant}.
 64  */
 65 @NodeInfo(nameTemplate = &quot;C({p#rawvalue}) {p#stampKind}&quot;, cycles = CYCLES_0, size = SIZE_1)
 66 public final class ConstantNode extends FloatingNode implements LIRLowerable, ArrayLengthProvider {
 67 
 68     public static final NodeClass&lt;ConstantNode&gt; TYPE = NodeClass.create(ConstantNode.class);
</pre>
<hr />
<pre>
129     }
130 
131     /**
132      * Gathers all the {@link ConstantNode}s that are inputs to the
133      * {@linkplain StructuredGraph#getNodes() live nodes} in a given graph.
134      */
135     public static NodeIterable&lt;ConstantNode&gt; getConstantNodes(StructuredGraph graph) {
136         return graph.getNodes().filter(ConstantNode.class);
137     }
138 
139     /**
140      * Replaces this node at its usages with another node.
141      */
142     public void replace(StructuredGraph graph, Node replacement) {
143         assert graph == graph();
144         replaceAtUsagesAndDelete(replacement);
145     }
146 
147     @Override
148     public void generate(NodeLIRBuilderTool gen) {
<span class="line-modified">149         LIRGeneratorTool lirTool = gen.getLIRGeneratorTool();</span>
<span class="line-added">150         LIRKind kind = lirTool.getLIRKind(stamp(NodeView.DEFAULT));</span>
151         if (onlyUsedInVirtualState()) {
152             gen.setResult(this, new ConstantValue(kind, value));
<span class="line-added">153         } else if (lirTool.canInlineConstant(value) || (lirTool.mayEmbedConstantLoad(value) &amp;&amp; hasExactlyOneUsage() &amp;&amp; onlyUsedInCurrentBlock())) {</span>
<span class="line-added">154             gen.setResult(this, new ConstantValue(lirTool.toRegisterKind(kind), value));</span>
155         } else {
156             gen.setResult(this, gen.getLIRGeneratorTool().emitConstant(kind, value));
157         }
158     }
159 
<span class="line-added">160     /**</span>
<span class="line-added">161      * Expecting false for loop invariant.</span>
<span class="line-added">162      */</span>
<span class="line-added">163     private boolean onlyUsedInCurrentBlock() {</span>
<span class="line-added">164         assert graph().getLastSchedule() != null;</span>
<span class="line-added">165         NodeMap&lt;Block&gt; nodeBlockMap = graph().getLastSchedule().getNodeToBlockMap();</span>
<span class="line-added">166         Block currentBlock = nodeBlockMap.get(this);</span>
<span class="line-added">167         for (Node usage : usages()) {</span>
<span class="line-added">168             if (currentBlock != nodeBlockMap.get(usage)) {</span>
<span class="line-added">169                 return false;</span>
<span class="line-added">170             }</span>
<span class="line-added">171         }</span>
<span class="line-added">172         return true;</span>
<span class="line-added">173     }</span>
<span class="line-added">174 </span>
175     private boolean onlyUsedInVirtualState() {
176         for (Node n : this.usages()) {
177             if (n instanceof VirtualState) {
178                 // Only virtual usage.
179             } else {
180                 return false;
181             }
182         }
183         return true;
184     }
185 
186     public static ConstantNode forConstant(JavaConstant constant, MetaAccessProvider metaAccess, StructuredGraph graph) {
187         if (constant.getJavaKind().getStackKind() == JavaKind.Int &amp;&amp; constant.getJavaKind() != JavaKind.Int) {
188             return forInt(constant.asInt(), graph);
189         }
190         if (constant.getJavaKind() == JavaKind.Object) {
191             return unique(graph, new ConstantNode(constant, StampFactory.forConstant(constant, metaAccess)));
192         } else {
193             return unique(graph, createPrimitive(constant));
194         }
</pre>
</td>
</tr>
</table>
<center><a href="ComputeObjectAddressNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ControlSplitNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
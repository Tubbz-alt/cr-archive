diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/GeneratedInvocationPlugin.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/GeneratedInvocationPlugin.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/GeneratedInvocationPlugin.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/GeneratedInvocationPlugin.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -43,10 +43,12 @@
  * Abstract class for a plugin generated for a method annotated by {@link NodeIntrinsic} or
  * {@link Fold}.
  */
 public abstract class GeneratedInvocationPlugin implements InvocationPlugin {
 
+    private ResolvedJavaMethod executeMethod;
+
     /**
      * Gets the class of the annotation for which this plugin was generated.
      */
     public abstract Class<? extends Annotation> getSource();
 
@@ -67,30 +69,48 @@
     protected boolean checkInjectedArgument(GraphBuilderContext b, ValueNode arg, ResolvedJavaMethod foldAnnotatedMethod) {
         if (arg.isNullConstant()) {
             return true;
         }
 
-        if (IS_IN_NATIVE_IMAGE || IS_BUILDING_NATIVE_IMAGE) {
+        if (IS_IN_NATIVE_IMAGE) {
             // The reflection here is problematic for SVM.
             return true;
         }
 
-        MetaAccessProvider metaAccess = b.getMetaAccess();
-        ResolvedJavaMethod executeMethod = metaAccess.lookupJavaMethod(getExecuteMethod());
-        ResolvedJavaType thisClass = metaAccess.lookupJavaType(getClass());
-        ResolvedJavaMethod thisExecuteMethod = thisClass.resolveConcreteMethod(executeMethod, thisClass);
+        if (b.getMethod().equals(foldAnnotatedMethod)) {
+            return false;
+        }
+
+        ResolvedJavaMethod thisExecuteMethod = getExecutedMethod(b);
         if (b.getMethod().equals(thisExecuteMethod)) {
             // The "execute" method of this plugin is itself being compiled. In (only) this context,
             // the injected argument of the call to the @Fold annotated method will be non-null.
+            if (IS_BUILDING_NATIVE_IMAGE) {
+                return false;
+            }
             return true;
         }
         throw new AssertionError("must pass null to injected argument of " + foldAnnotatedMethod.format("%H.%n(%p)") + ", not " + arg);
     }
 
+    private ResolvedJavaMethod getExecutedMethod(GraphBuilderContext b) {
+        if (executeMethod == null) {
+            MetaAccessProvider metaAccess = b.getMetaAccess();
+            ResolvedJavaMethod baseMethod = metaAccess.lookupJavaMethod(getExecuteMethod());
+            ResolvedJavaType thisClass = metaAccess.lookupJavaType(getClass());
+            executeMethod = thisClass.resolveConcreteMethod(baseMethod, thisClass);
+        }
+        return executeMethod;
+    }
+
     private static Method getExecuteMethod() {
         try {
             return GeneratedInvocationPlugin.class.getMethod("execute", GraphBuilderContext.class, ResolvedJavaMethod.class, InvocationPlugin.Receiver.class, ValueNode[].class);
         } catch (NoSuchMethodException | SecurityException e) {
             throw new GraalError(e);
         }
     }
+
+    public final boolean isGeneratedFromFoldOrNodeIntrinsic() {
+        return getSource().equals(Fold.class) || getSource().equals(NodeIntrinsic.class);
+    }
 }

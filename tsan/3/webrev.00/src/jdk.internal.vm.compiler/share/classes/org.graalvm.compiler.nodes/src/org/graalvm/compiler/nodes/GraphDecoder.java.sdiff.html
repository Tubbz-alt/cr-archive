<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/GraphDecoder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameState.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphEncoder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/GraphDecoder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 122             this.loopExplosion = loopExplosion;
 123             this.returnAndUnwindNodes = new ArrayList&lt;&gt;(2);
 124 
 125             if (encodedGraph != null) {
 126                 reader = UnsafeArrayTypeReader.create(encodedGraph.getEncoding(), encodedGraph.getStartOffset(), architecture.supportsUnalignedMemoryAccess());
 127                 maxFixedNodeOrderId = reader.getUVInt();
 128                 if (encodedGraph.nodeStartOffsets == null) {
 129                     int nodeCount = reader.getUVInt();
 130                     int[] nodeStartOffsets = new int[nodeCount];
 131                     for (int i = 0; i &lt; nodeCount; i++) {
 132                         nodeStartOffsets[i] = encodedGraph.getStartOffset() - reader.getUVInt();
 133                     }
 134                     encodedGraph.nodeStartOffsets = nodeStartOffsets;
 135                     graph.setGuardsStage((StructuredGraph.GuardsStage) readObject(this));
 136                 }
 137             } else {
 138                 reader = null;
 139                 maxFixedNodeOrderId = 0;
 140             }
 141 
<span class="line-modified"> 142             if (loopExplosion != LoopExplosionKind.NONE) {</span>
 143                 loopExplosionMerges = EconomicSet.create(Equivalence.IDENTITY);
 144             } else {
 145                 loopExplosionMerges = null;
 146             }
 147         }
 148 
 149         public boolean isInlinedMethod() {
 150             return false;
 151         }
 152 
 153         public NodeSourcePosition getCallerBytecodePosition() {
 154             return getCallerBytecodePosition(null);
 155         }
 156 
 157         public NodeSourcePosition getCallerBytecodePosition(NodeSourcePosition position) {
 158             return position;
 159         }
 160 
 161     }
 162 



































 163     /** Decoding state maintained for each loop in the encoded graph. */
 164     protected static class LoopScope {
 165         public final MethodScope methodScope;
 166         public final LoopScope outer;
 167         public final int loopDepth;
 168         public final int loopIteration;











 169         /**
<span class="line-modified"> 170          * Upcoming loop iterations during loop explosions that have not been processed yet. Only</span>
<span class="line-modified"> 171          * used when {@link MethodScope#loopExplosion} is not {@link LoopExplosionKind#NONE}.</span>

 172          */
<span class="line-modified"> 173         public Deque&lt;LoopScope&gt; nextIterations;</span>






 174         /**
 175          * Information about already processed loop iterations for state merging during loop
 176          * explosion. Only used when {@link MethodScope#loopExplosion} is
 177          * {@link LoopExplosionKind#MERGE_EXPLODE}.
 178          */
 179         public final EconomicMap&lt;LoopExplosionState, LoopExplosionState&gt; iterationStates;
 180         public final int loopBeginOrderId;
 181         /**
 182          * The worklist of fixed nodes to process. Since we already the correct processing order
 183          * from the orderId, we just set the orderId bit in the bitset when a node is ready for
 184          * processing. The lowest set bit is the next node to process.
 185          */
 186         public final BitSet nodesToProcess;
 187         /** Nodes that have been created, indexed by the orderId. */
 188         public final Node[] createdNodes;
 189         /**
 190          * Nodes that have been created in outer loop scopes and existed before starting to process
 191          * this loop, indexed by the orderId. Only used when {@link MethodScope#loopExplosion} is
 192          * not {@link LoopExplosionKind#NONE}.
 193          */
 194         public final Node[] initialCreatedNodes;
 195 
 196         protected LoopScope(MethodScope methodScope) {
 197             this.methodScope = methodScope;
 198             this.outer = null;
<span class="line-modified"> 199             this.nextIterations = methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN ? new ArrayDeque&lt;&gt;(2) : null;</span>


 200             this.loopDepth = 0;
 201             this.loopIteration = 0;
 202             this.iterationStates = null;
 203             this.loopBeginOrderId = -1;
<span class="line-removed"> 204 </span>
 205             int nodeCount = methodScope.encodedGraph.nodeStartOffsets.length;
 206             this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);
 207             this.createdNodes = new Node[nodeCount];
 208             this.initialCreatedNodes = null;

 209         }
 210 
<span class="line-modified"> 211         protected LoopScope(MethodScope methodScope, LoopScope outer, int loopDepth, int loopIteration, int loopBeginOrderId, Node[] initialCreatedNodes, Node[] createdNodes,</span>
<span class="line-modified"> 212                         Deque&lt;LoopScope&gt; nextIterations, EconomicMap&lt;LoopExplosionState, LoopExplosionState&gt; iterationStates) {</span>


 213             this.methodScope = methodScope;
 214             this.outer = outer;
 215             this.loopDepth = loopDepth;
 216             this.loopIteration = loopIteration;
<span class="line-modified"> 217             this.nextIterations = nextIterations;</span>



 218             this.iterationStates = iterationStates;
 219             this.loopBeginOrderId = loopBeginOrderId;
 220             this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);
 221             this.initialCreatedNodes = initialCreatedNodes;
 222             this.createdNodes = createdNodes;
 223         }
 224 
 225         @Override
 226         public String toString() {
<span class="line-modified"> 227             return loopDepth + &quot;,&quot; + loopIteration + (loopBeginOrderId == -1 ? &quot;&quot; : &quot;#&quot; + loopBeginOrderId);</span>


































 228         }
 229     }
 230 
 231     protected static class LoopExplosionState {
 232         public final FrameState state;
 233         public final MergeNode merge;
 234         public final int hashCode;
 235 
 236         protected LoopExplosionState(FrameState state, MergeNode merge) {
 237             this.state = state;
 238             this.merge = merge;
 239 
 240             int h = 0;
 241             for (ValueNode value : state.values()) {
 242                 if (value == null) {
 243                     h = h * 31 + 1234;
 244                 } else {
 245                     h = h * 31 + ProxyPlaceholder.unwrap(value).hashCode();
 246                 }
 247             }
</pre>
<hr />
<pre>
 302             this.callTargetOrderId = callTargetOrderId;
 303             this.stateAfterOrderId = stateAfterOrderId;
 304             this.nextOrderId = nextOrderId;
 305             this.nextNextOrderId = nextNextOrderId;
 306             this.exceptionOrderId = exceptionOrderId;
 307             this.exceptionStateOrderId = exceptionStateOrderId;
 308             this.exceptionNextOrderId = exceptionNextOrderId;
 309         }
 310     }
 311 
 312     /**
 313      * A node that is created during {@link LoopExplosionKind#MERGE_EXPLODE loop explosion} that can
 314      * later be replaced by a ProxyNode if {@link LoopDetector loop detection} finds out that the
 315      * value is defined in the loop, but used outside the loop.
 316      */
 317     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
 318     protected static final class ProxyPlaceholder extends FloatingNode implements Canonicalizable {
 319         public static final NodeClass&lt;ProxyPlaceholder&gt; TYPE = NodeClass.create(ProxyPlaceholder.class);
 320 
 321         @Input ValueNode value;
<span class="line-modified"> 322         @Input(InputType.Unchecked) Node proxyPoint;</span>
 323 
 324         public ProxyPlaceholder(ValueNode value, MergeNode proxyPoint) {
 325             super(TYPE, value.stamp(NodeView.DEFAULT));
 326             this.value = value;
 327             this.proxyPoint = proxyPoint;
 328         }
 329 
 330         void setValue(ValueNode value) {
 331             updateUsages(this.value, value);
 332             this.value = value;
 333         }
 334 
 335         @Override
 336         public Node canonical(CanonicalizerTool tool) {
 337             if (tool.allUsagesAvailable()) {
 338                 /* The node is always unnecessary after graph decoding. */
 339                 return value;
 340             } else {
 341                 return this;
 342             }
</pre>
<hr />
<pre>
 392 
 393             firstNode = makeStubNode(methodScope, loopScope, GraphEncoder.FIRST_NODE_ORDER_ID);
 394             startNode.setNext(firstNode);
 395             loopScope.nodesToProcess.set(GraphEncoder.FIRST_NODE_ORDER_ID);
 396         } else {
 397             firstNode = graph.start();
 398             registerNode(loopScope, GraphEncoder.START_NODE_ORDER_ID, firstNode, false, false);
 399             loopScope.nodesToProcess.set(GraphEncoder.START_NODE_ORDER_ID);
 400         }
 401         return loopScope;
 402     }
 403 
 404     protected final void decode(LoopScope initialLoopScope) {
 405         LoopScope loopScope = initialLoopScope;
 406         /* Process (inlined) methods. */
 407         while (loopScope != null) {
 408             MethodScope methodScope = loopScope.methodScope;
 409 
 410             /* Process loops of method. */
 411             while (loopScope != null) {
<span class="line-removed"> 412 </span>
 413                 /* Process nodes of loop. */
 414                 while (!loopScope.nodesToProcess.isEmpty()) {
 415                     loopScope = processNextNode(methodScope, loopScope);
 416                     methodScope = loopScope.methodScope;
 417                     /*
 418                      * We can have entered a new loop, and we can have entered a new inlined method.
 419                      */
 420                 }
 421 
 422                 /* Finished with a loop. */
<span class="line-modified"> 423                 if (loopScope.nextIterations != null &amp;&amp; !loopScope.nextIterations.isEmpty()) {</span>
<span class="line-modified"> 424                     /* Loop explosion: process the loop iteration. */</span>
<span class="line-removed"> 425                     assert loopScope.nextIterations.peekFirst().loopIteration == loopScope.loopIteration + 1;</span>
<span class="line-removed"> 426                     loopScope = loopScope.nextIterations.removeFirst();</span>
 427                 } else {
 428                     propagateCreatedNodes(loopScope);
 429                     loopScope = loopScope.outer;
 430                 }
 431             }
 432 
 433             /*
 434              * Finished with an inlined method. Perform end-of-method cleanup tasks.
 435              */
<span class="line-modified"> 436             if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE) {</span>
 437                 LoopDetector loopDetector = new LoopDetector(graph, methodScope);
 438                 loopDetector.run();
 439             }
 440             if (methodScope.isInlinedMethod()) {
 441                 finishInlining(methodScope);
 442             }
 443 
 444             /* continue with the caller */
 445             loopScope = methodScope.callerLoopScope;
 446         }
 447     }
 448 
 449     protected void finishInlining(@SuppressWarnings(&quot;unused&quot;) MethodScope inlineScope) {
 450     }
 451 
 452     private static void propagateCreatedNodes(LoopScope loopScope) {
 453         if (loopScope.outer == null || loopScope.createdNodes != loopScope.outer.createdNodes) {
 454             return;
 455         }
 456 
 457         /* Register nodes that were created while decoding the loop to the outside scope. */
 458         for (int i = 0; i &lt; loopScope.createdNodes.length; i++) {
 459             if (loopScope.outer.createdNodes[i] == null) {
 460                 loopScope.outer.createdNodes[i] = loopScope.createdNodes[i];
 461             }
 462         }
 463     }
 464 


 465     protected LoopScope processNextNode(MethodScope methodScope, LoopScope loopScope) {
 466         int nodeOrderId = loopScope.nodesToProcess.nextSetBit(0);
 467         loopScope.nodesToProcess.clear(nodeOrderId);
 468 
 469         FixedNode node = (FixedNode) lookupNode(loopScope, nodeOrderId);

 470         if (node.isDeleted()) {
 471             return loopScope;
 472         }
<span class="line-modified"> 473 </span>








 474         if ((node instanceof MergeNode ||
<span class="line-modified"> 475                         (node instanceof LoopBeginNode &amp;&amp; (methodScope.loopExplosion == LoopExplosionKind.FULL_UNROLL || methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE ||</span>
<span class="line-modified"> 476                                         methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN))) &amp;&amp;</span>
 477                         ((AbstractMergeNode) node).forwardEndCount() == 1) {




 478             AbstractMergeNode merge = (AbstractMergeNode) node;
 479             EndNode singleEnd = merge.forwardEndAt(0);
 480 
 481             /* Nodes that would use this merge as the guard need to use the previous block. */
 482             registerNode(loopScope, nodeOrderId, AbstractBeginNode.prevBegin(singleEnd), true, false);
 483 
 484             FixedNode next = makeStubNode(methodScope, loopScope, nodeOrderId + GraphEncoder.BEGIN_NEXT_ORDER_ID_OFFSET);
 485             singleEnd.replaceAtPredecessor(next);
 486 
 487             merge.safeDelete();
 488             singleEnd.safeDelete();
 489             return loopScope;
 490         }
 491 
 492         LoopScope successorAddScope = loopScope;
 493         boolean updatePredecessors = true;
 494         if (node instanceof LoopExitNode) {
<span class="line-modified"> 495             if (methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN || (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE &amp;&amp; loopScope.loopDepth &gt; 1)) {</span>
 496                 /*
 497                  * We do not want to merge loop exits of inner loops. Instead, we want to keep
 498                  * exploding the outer loop separately for every loop exit and then merge the outer
 499                  * loop. Therefore, we create a new LoopScope of the outer loop for every loop exit
 500                  * of the inner loop.
 501                  */
 502                 LoopScope outerScope = loopScope.outer;
<span class="line-modified"> 503                 int nextIterationNumber = outerScope.nextIterations.isEmpty() ? outerScope.loopIteration + 1 : outerScope.nextIterations.getLast().loopIteration + 1;</span>
<span class="line-modified"> 504                 successorAddScope = new LoopScope(methodScope, outerScope.outer, outerScope.loopDepth, nextIterationNumber, outerScope.loopBeginOrderId,</span>

 505                                 outerScope.initialCreatedNodes == null ? null : Arrays.copyOf(outerScope.initialCreatedNodes, outerScope.initialCreatedNodes.length),
<span class="line-modified"> 506                                 Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length), outerScope.nextIterations, outerScope.iterationStates);</span>




 507                 checkLoopExplosionIteration(methodScope, successorAddScope);
 508 
 509                 /*
 510                  * Nodes that are still unprocessed in the outer scope might be merge nodes that are
 511                  * also reachable from the new exploded scope. Clearing them ensures that we do not
 512                  * merge, but instead keep exploding.
 513                  */
 514                 for (int id = outerScope.nodesToProcess.nextSetBit(0); id &gt;= 0; id = outerScope.nodesToProcess.nextSetBit(id + 1)) {
 515                     successorAddScope.createdNodes[id] = null;
 516                 }
 517 
<span class="line-modified"> 518                 outerScope.nextIterations.addLast(successorAddScope);</span>
 519             } else {
 520                 successorAddScope = loopScope.outer;
 521             }
<span class="line-modified"> 522             updatePredecessors = methodScope.loopExplosion == LoopExplosionKind.NONE;</span>
 523         }
 524 
 525         methodScope.reader.setByteIndex(methodScope.encodedGraph.nodeStartOffsets[nodeOrderId]);
 526         int typeId = methodScope.reader.getUVInt();
 527         assert node.getNodeClass() == methodScope.encodedGraph.getNodeClasses()[typeId];
 528         makeFixedNodeInputs(methodScope, loopScope, node);
 529         readProperties(methodScope, node);
 530         makeSuccessorStubs(methodScope, successorAddScope, node, updatePredecessors);
 531 
 532         LoopScope resultScope = loopScope;
 533         if (node instanceof LoopBeginNode) {
<span class="line-modified"> 534             if (methodScope.loopExplosion != LoopExplosionKind.NONE) {</span>
 535                 handleLoopExplosionBegin(methodScope, loopScope, (LoopBeginNode) node);
 536             }
 537 
 538         } else if (node instanceof LoopExitNode) {
<span class="line-modified"> 539             if (methodScope.loopExplosion != LoopExplosionKind.NONE) {</span>
 540                 handleLoopExplosionProxyNodes(methodScope, loopScope, successorAddScope, (LoopExitNode) node, nodeOrderId);
 541             } else {
 542                 handleProxyNodes(methodScope, loopScope, (LoopExitNode) node);
 543             }
 544 
 545         } else if (node instanceof MergeNode) {
 546             handleMergeNode(((MergeNode) node));
<span class="line-removed"> 547 </span>
 548         } else if (node instanceof AbstractEndNode) {
 549             LoopScope phiInputScope = loopScope;
 550             LoopScope phiNodeScope = loopScope;

 551 
<span class="line-modified"> 552             if (methodScope.loopExplosion != LoopExplosionKind.NONE &amp;&amp; node instanceof LoopEndNode) {</span>
<span class="line-modified"> 553                 node = handleLoopExplosionEnd(methodScope, loopScope, (LoopEndNode) node);</span>
<span class="line-modified"> 554                 phiNodeScope = loopScope.nextIterations.getLast();</span>
<span class="line-modified"> 555             }</span>




































 556 
<span class="line-modified"> 557             int mergeOrderId = readOrderId(methodScope);</span>











 558             AbstractMergeNode merge = (AbstractMergeNode) lookupNode(phiNodeScope, mergeOrderId);
 559             if (merge == null) {
 560                 merge = (AbstractMergeNode) makeStubNode(methodScope, phiNodeScope, mergeOrderId);
<span class="line-removed"> 561 </span>
 562                 if (merge instanceof LoopBeginNode) {
















 563                     assert phiNodeScope == phiInputScope &amp;&amp; phiNodeScope == loopScope;
<span class="line-modified"> 564                     resultScope = new LoopScope(methodScope, loopScope, loopScope.loopDepth + 1, 0, mergeOrderId,</span>
<span class="line-modified"> 565                                     methodScope.loopExplosion != LoopExplosionKind.NONE ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : null,</span>
<span class="line-modified"> 566                                     methodScope.loopExplosion != LoopExplosionKind.NONE ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : loopScope.createdNodes, //</span>
<span class="line-modified"> 567                                     methodScope.loopExplosion != LoopExplosionKind.NONE ? new ArrayDeque&lt;&gt;(2) : null, //</span>
<span class="line-modified"> 568                                     methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE ? EconomicMap.create(Equivalence.DEFAULT) : null);</span>


 569                     phiInputScope = resultScope;
 570                     phiNodeScope = resultScope;
 571 
<span class="line-modified"> 572                     if (methodScope.loopExplosion != LoopExplosionKind.NONE) {</span>
 573                         registerNode(loopScope, mergeOrderId, null, true, true);
 574                     }
 575                     loopScope.nodesToProcess.clear(mergeOrderId);
 576                     resultScope.nodesToProcess.set(mergeOrderId);
 577                 }
 578             }
<span class="line-removed"> 579 </span>
 580             handlePhiFunctions(methodScope, phiInputScope, phiNodeScope, (AbstractEndNode) node, merge);
<span class="line-removed"> 581 </span>
 582         } else if (node instanceof Invoke) {
 583             InvokeData invokeData = readInvokeData(methodScope, nodeOrderId, (Invoke) node);
 584             resultScope = handleInvoke(methodScope, loopScope, invokeData);
<span class="line-removed"> 585 </span>
 586         } else if (node instanceof ReturnNode || node instanceof UnwindNode) {
 587             methodScope.returnAndUnwindNodes.add((ControlSinkNode) node);
 588         } else {
 589             handleFixedNode(methodScope, loopScope, nodeOrderId, node);
 590         }
<span class="line-modified"> 591 </span>








 592         return resultScope;
 593     }
 594 
 595     protected InvokeData readInvokeData(MethodScope methodScope, int invokeOrderId, Invoke invoke) {
 596         ResolvedJavaType contextType = (ResolvedJavaType) readObject(methodScope);
 597         int callTargetOrderId = readOrderId(methodScope);
 598         int stateAfterOrderId = readOrderId(methodScope);
 599         int nextOrderId = readOrderId(methodScope);
 600 
 601         if (invoke instanceof InvokeWithExceptionNode) {
 602             int nextNextOrderId = readOrderId(methodScope);
 603             int exceptionOrderId = readOrderId(methodScope);
 604             int exceptionStateOrderId = readOrderId(methodScope);
 605             int exceptionNextOrderId = readOrderId(methodScope);
 606             return new InvokeData(invoke, contextType, invokeOrderId, callTargetOrderId, stateAfterOrderId, nextOrderId, nextNextOrderId, exceptionOrderId, exceptionStateOrderId,
 607                             exceptionNextOrderId);
 608         } else {
 609             return new InvokeData(invoke, contextType, invokeOrderId, callTargetOrderId, stateAfterOrderId, nextOrderId, -1, -1, -1, -1);
 610         }
 611     }
</pre>
<hr />
<pre>
 641         if (invokeData.invoke instanceof InvokeWithExceptionNode) {
 642             ((InvokeWithExceptionNode) invokeData.invoke).setExceptionEdge((AbstractBeginNode) makeStubNode(methodScope, loopScope, invokeData.exceptionOrderId));
 643         }
 644     }
 645 
 646     /**
 647      * Hook for subclasses to perform simplifications for a non-loop-header control flow merge.
 648      *
 649      * @param merge The control flow merge.
 650      */
 651     protected void handleMergeNode(MergeNode merge) {
 652     }
 653 
 654     protected void handleLoopExplosionBegin(MethodScope methodScope, LoopScope loopScope, LoopBeginNode loopBegin) {
 655         checkLoopExplosionIteration(methodScope, loopScope);
 656 
 657         List&lt;EndNode&gt; predecessors = loopBegin.forwardEnds().snapshot();
 658         FixedNode successor = loopBegin.next();
 659         FrameState frameState = loopBegin.stateAfter();
 660 
<span class="line-modified"> 661         if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE) {</span>
 662             LoopExplosionState queryState = new LoopExplosionState(frameState, null);
 663             LoopExplosionState existingState = loopScope.iterationStates.get(queryState);
 664             if (existingState != null) {
 665                 loopBegin.replaceAtUsagesAndDelete(existingState.merge);
 666                 successor.safeDelete();
 667                 for (EndNode predecessor : predecessors) {
 668                     existingState.merge.addForwardEnd(predecessor);
 669                 }
 670                 return;
 671             }
 672         }
 673 
 674         MergeNode merge = graph.add(new MergeNode());
 675         methodScope.loopExplosionMerges.add(merge);
 676 
<span class="line-modified"> 677         if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE) {</span>
 678             if (loopScope.iterationStates.size() == 0 &amp;&amp; loopScope.loopDepth == 1) {
 679                 if (methodScope.loopExplosionHead != null) {
 680                     throw new PermanentBailoutException(&quot;Graal implementation restriction: Method with %s loop explosion must not have more than one top-level loop&quot;, LoopExplosionKind.MERGE_EXPLODE);
 681                 }
 682                 methodScope.loopExplosionHead = merge;
 683             }
 684 
 685             List&lt;ValueNode&gt; newFrameStateValues = new ArrayList&lt;&gt;();
 686             for (ValueNode frameStateValue : frameState.values) {
 687                 if (frameStateValue == null || frameStateValue.isConstant() || !graph.isNew(methodScope.methodStartMark, frameStateValue)) {
 688                     newFrameStateValues.add(frameStateValue);
 689 
 690                 } else {
 691                     ProxyPlaceholder newFrameStateValue = graph.unique(new ProxyPlaceholder(frameStateValue, merge));
 692                     newFrameStateValues.add(newFrameStateValue);
 693 
 694                     /*
 695                      * We do not have the orderID of the value anymore, so we need to search through
 696                      * the complete list of nodes to find a match.
 697                      */
</pre>
<hr />
<pre>
 708                             }
 709                         }
 710                     }
 711                 }
 712             }
 713 
 714             FrameState newFrameState = graph.add(new FrameState(frameState.outerFrameState(), frameState.getCode(), frameState.bci, newFrameStateValues, frameState.localsSize(),
 715                             frameState.stackSize(), frameState.rethrowException(), frameState.duringCall(), frameState.monitorIds(), frameState.virtualObjectMappings()));
 716 
 717             frameState.replaceAtUsagesAndDelete(newFrameState);
 718             frameState = newFrameState;
 719         }
 720 
 721         loopBegin.replaceAtUsagesAndDelete(merge);
 722         merge.setStateAfter(frameState);
 723         merge.setNext(successor);
 724         for (EndNode predecessor : predecessors) {
 725             merge.addForwardEnd(predecessor);
 726         }
 727 
<span class="line-modified"> 728         if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE) {</span>
 729             LoopExplosionState explosionState = new LoopExplosionState(frameState, merge);
 730             loopScope.iterationStates.put(explosionState, explosionState);
 731         }
 732     }
 733 
 734     /**
 735      * Hook for subclasses.
 736      *
 737      * @param methodScope The current method.
 738      * @param loopScope The current loop.
 739      */
 740     protected void checkLoopExplosionIteration(MethodScope methodScope, LoopScope loopScope) {
 741         throw shouldNotReachHere(&quot;when subclass uses loop explosion, it needs to implement this method&quot;);
 742     }
 743 
<span class="line-modified"> 744     protected FixedNode handleLoopExplosionEnd(MethodScope methodScope, LoopScope loopScope, LoopEndNode loopEnd) {</span>
<span class="line-modified"> 745         EndNode replacementNode = graph.add(new EndNode());</span>
<span class="line-modified"> 746         loopEnd.replaceAtPredecessor(replacementNode);</span>
<span class="line-modified"> 747         loopEnd.safeDelete();</span>
<span class="line-modified"> 748 </span>
<span class="line-modified"> 749         assert methodScope.loopExplosion != LoopExplosionKind.NONE;</span>
<span class="line-modified"> 750         if (methodScope.loopExplosion != LoopExplosionKind.FULL_UNROLL || loopScope.nextIterations.isEmpty()) {</span>
<span class="line-modified"> 751             int nextIterationNumber = loopScope.nextIterations.isEmpty() ? loopScope.loopIteration + 1 : loopScope.nextIterations.getLast().loopIteration + 1;</span>
<span class="line-modified"> 752             LoopScope nextIterationScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId,</span>

















 753                             Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
<span class="line-modified"> 754                             Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length), loopScope.nextIterations, loopScope.iterationStates);</span>




 755             checkLoopExplosionIteration(methodScope, nextIterationScope);
<span class="line-modified"> 756             loopScope.nextIterations.addLast(nextIterationScope);</span>
 757             registerNode(nextIterationScope, loopScope.loopBeginOrderId, null, true, true);
 758             makeStubNode(methodScope, nextIterationScope, loopScope.loopBeginOrderId);
 759         }
<span class="line-modified"> 760         return replacementNode;</span>
 761     }
 762 
 763     /**
 764      * Hook for subclasses.
 765      *
 766      * @param methodScope The current method.
 767      * @param loopScope The current loop.
 768      * @param nodeOrderId The orderId of the node.
 769      * @param node The node to be simplified.
 770      */
 771     protected void handleFixedNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId, FixedNode node) {
 772     }
 773 
 774     protected void handleProxyNodes(MethodScope methodScope, LoopScope loopScope, LoopExitNode loopExit) {
 775         assert loopExit.stateAfter() == null;
 776         int stateAfterOrderId = readOrderId(methodScope);
 777         loopExit.setStateAfter((FrameState) ensureNodeCreated(methodScope, loopScope, stateAfterOrderId));
 778 
 779         int numProxies = methodScope.reader.getUVInt();
 780         for (int i = 0; i &lt; numProxies; i++) {
</pre>
<hr />
<pre>
 783             /*
 784              * The ProxyNode transports a value from the loop to the outer scope. We therefore
 785              * register it in the outer scope.
 786              */
 787             if (loopScope.outer.createdNodes != loopScope.createdNodes) {
 788                 registerNode(loopScope.outer, proxyOrderId, proxy, false, false);
 789             }
 790         }
 791     }
 792 
 793     protected void handleLoopExplosionProxyNodes(MethodScope methodScope, LoopScope loopScope, LoopScope outerScope, LoopExitNode loopExit, int loopExitOrderId) {
 794         assert loopExit.stateAfter() == null;
 795         int stateAfterOrderId = readOrderId(methodScope);
 796 
 797         BeginNode begin = graph.add(new BeginNode());
 798 
 799         FixedNode loopExitSuccessor = loopExit.next();
 800         loopExit.replaceAtPredecessor(begin);
 801 
 802         MergeNode loopExitPlaceholder = null;
<span class="line-modified"> 803         if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE &amp;&amp; loopScope.loopDepth == 1) {</span>
 804             /*
 805              * This exit might end up as a loop exit of a loop detected after partial evaluation. We
 806              * need to be able to create a FrameState and the necessary proxy nodes in this case.
 807              */
 808             loopExitPlaceholder = graph.add(new MergeNode());
 809             methodScope.loopExplosionMerges.add(loopExitPlaceholder);
 810 
 811             EndNode end = graph.add(new EndNode());
 812             begin.setNext(end);
 813             loopExitPlaceholder.addForwardEnd(end);
 814 
 815             begin = graph.add(new BeginNode());
 816             loopExitPlaceholder.setNext(begin);
 817         }
 818 
 819         /*
 820          * In the original graph, the loop exit is not a merge node. Multiple exploded loop
 821          * iterations now take the same loop exit, so we have to introduce a new merge node to
 822          * handle the merge.
 823          */
</pre>
<hr />
<pre>
 861             ProxyNode proxy = (ProxyNode) ensureNodeCreated(methodScope, loopScope, proxyOrderId);
 862             ValueNode phiInput = proxy.value();
 863 
 864             if (loopExitPlaceholder != null) {
 865                 if (!phiInput.isConstant()) {
 866                     phiInput = graph.unique(new ProxyPlaceholder(phiInput, loopExitPlaceholder));
 867                 }
 868                 registerNode(loopScope, proxyOrderId, phiInput, true, false);
 869             }
 870 
 871             ValueNode replacement;
 872             ValueNode existing = (ValueNode) outerScope.createdNodes[proxyOrderId];
 873             if (existing == null || existing == phiInput) {
 874                 /*
 875                  * We are at the first loop exit, or the proxy carries the same value for all exits.
 876                  * We do not need a phi node yet.
 877                  */
 878                 registerNode(outerScope, proxyOrderId, phiInput, true, false);
 879                 replacement = phiInput;
 880 
<span class="line-modified"> 881             } else if (!merge.isPhiAtMerge(existing)) {</span>
<span class="line-modified"> 882                 /* Now we have two different values, so we need to create a phi node. */</span>
<span class="line-modified"> 883                 PhiNode phi;</span>
<span class="line-modified"> 884                 if (proxy instanceof ValueProxyNode) {</span>
<span class="line-modified"> 885                     phi = graph.addWithoutUnique(new ValuePhiNode(proxy.stamp(NodeView.DEFAULT), merge));</span>
<span class="line-modified"> 886                 } else if (proxy instanceof GuardProxyNode) {</span>
<span class="line-modified"> 887                     phi = graph.addWithoutUnique(new GuardPhiNode(merge));</span>










 888                 } else {
<span class="line-modified"> 889                     throw GraalError.shouldNotReachHere();</span>



 890                 }
<span class="line-removed"> 891                 /* Add the inputs from all previous exits. */</span>
<span class="line-removed"> 892                 for (int j = 0; j &lt; merge.phiPredecessorCount() - 1; j++) {</span>
<span class="line-removed"> 893                     phi.addInput(existing);</span>
<span class="line-removed"> 894                 }</span>
<span class="line-removed"> 895                 /* Add the input from this exit. */</span>
<span class="line-removed"> 896                 phi.addInput(phiInput);</span>
<span class="line-removed"> 897                 registerNode(outerScope, proxyOrderId, phi, true, false);</span>
<span class="line-removed"> 898                 replacement = phi;</span>
<span class="line-removed"> 899                 phiCreated = true;</span>
<span class="line-removed"> 900 </span>
<span class="line-removed"> 901             } else {</span>
<span class="line-removed"> 902                 /* Phi node has been created before, so just add the new input. */</span>
<span class="line-removed"> 903                 PhiNode phi = (PhiNode) existing;</span>
<span class="line-removed"> 904                 phi.addInput(phiInput);</span>
<span class="line-removed"> 905                 replacement = phi;</span>
 906             }
<span class="line-removed"> 907 </span>
 908             proxy.replaceAtUsagesAndDelete(replacement);
 909         }
 910 
 911         if (loopExitPlaceholder != null) {
 912             registerNode(loopScope, stateAfterOrderId, null, true, true);
 913             loopExitPlaceholder.setStateAfter((FrameState) ensureNodeCreated(methodScope, loopScope, stateAfterOrderId));
 914         }
 915 
 916         if (merge != null &amp;&amp; (merge.stateAfter() == null || phiCreated)) {
 917             FrameState oldStateAfter = merge.stateAfter();
 918             registerNode(outerScope, stateAfterOrderId, null, true, true);
 919             merge.setStateAfter((FrameState) ensureNodeCreated(methodScope, outerScope, stateAfterOrderId));
 920             if (oldStateAfter != null) {
 921                 oldStateAfter.safeDelete();
 922             }
 923         }
 924         loopExit.safeDelete();
 925         assert loopExitSuccessor.predecessor() == null;
 926         if (merge != null) {
 927             merge.getNodeClass().getSuccessorEdges().update(merge, null, loopExitSuccessor);
</pre>
<hr />
<pre>
 941             int numEnds = ((LoopBeginNode) merge).loopEnds().count();
 942             ((LoopBeginNode) merge).nextEndIndex = numEnds;
 943             ((LoopEndNode) end).endIndex = numEnds - 1;
 944 
 945         } else {
 946             if (merge.ends == null) {
 947                 merge.ends = new NodeInputList&lt;&gt;(merge);
 948             }
 949             merge.addForwardEnd((EndNode) end);
 950         }
 951 
 952         /*
 953          * We create most phi functions lazily. Canonicalization and simplification during decoding
 954          * can lead to dead branches that are not decoded, so we might not need all phi functions
 955          * that the original graph contained. Since we process all predecessors before actually
 956          * processing the merge node, we have the final phi function when processing the merge node.
 957          * The only exception are loop headers of non-exploded loops: since backward branches are
 958          * not processed yet when processing the loop body, we need to create all phi functions
 959          * upfront.
 960          */
<span class="line-modified"> 961         boolean lazyPhi = allowLazyPhis() &amp;&amp; (!(merge instanceof LoopBeginNode) || methodScope.loopExplosion != LoopExplosionKind.NONE);</span>
 962         int numPhis = methodScope.reader.getUVInt();
 963         for (int i = 0; i &lt; numPhis; i++) {
 964             int phiInputOrderId = readOrderId(methodScope);
 965             int phiNodeOrderId = readOrderId(methodScope);
 966 
 967             ValueNode phiInput = (ValueNode) ensureNodeCreated(methodScope, phiInputScope, phiInputOrderId);
 968             ValueNode existing = (ValueNode) lookupNode(phiNodeScope, phiNodeOrderId);
 969 
 970             if (existing != null &amp;&amp; merge.phiPredecessorCount() == 1) {
 971                 /*
 972                  * When exploding loops and the code after the loop (FULL_EXPLODE_UNTIL_RETURN),
 973                  * then an existing value can already be registered: Parsing of the code before the
 974                  * loop registers it when preparing for the later merge. The code after the loop,
 975                  * which starts with a clone of the values that were created before the loop, sees
 976                  * the stale value when processing the merge the first time. We can safely ignore
 977                  * the stale value because it will never be needed to be merged (we are exploding
 978                  * until we hit a return).
 979                  */
<span class="line-modified"> 980                 assert methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN &amp;&amp; phiNodeScope.loopIteration &gt; 0;</span>
 981                 existing = null;
 982             }
 983 
 984             if (lazyPhi &amp;&amp; (existing == null || existing == phiInput)) {
 985                 /* Phi function not yet necessary. */
 986                 registerNode(phiNodeScope, phiNodeOrderId, phiInput, true, false);
 987 
 988             } else if (!merge.isPhiAtMerge(existing)) {
 989                 /*
 990                  * Phi function is necessary. Create it and fill it with existing inputs as well as
 991                  * the new input.
 992                  */
 993                 registerNode(phiNodeScope, phiNodeOrderId, null, true, true);
 994                 PhiNode phi = (PhiNode) ensureNodeCreated(methodScope, phiNodeScope, phiNodeOrderId);
 995 
 996                 phi.setMerge(merge);
 997                 for (int j = 0; j &lt; merge.phiPredecessorCount() - 1; j++) {
 998                     phi.addInput(existing);
 999                 }
1000                 phi.addInput(phiInput);
</pre>
<hr />
<pre>
1315         assert node == null || node.isAlive();
1316         assert allowNull || node != null;
1317         assert allowOverwrite || lookupNode(loopScope, nodeOrderId) == null;
1318         loopScope.createdNodes[nodeOrderId] = node;
1319     }
1320 
1321     protected int readOrderId(MethodScope methodScope) {
1322         return methodScope.reader.getUVInt();
1323     }
1324 
1325     protected Object readObject(MethodScope methodScope) {
1326         return methodScope.encodedGraph.getObject(methodScope.reader.getUVInt());
1327     }
1328 
1329     /**
1330      * Removes unnecessary nodes from the graph after decoding.
1331      *
1332      * @param methodScope The current method.
1333      */
1334     protected void cleanupGraph(MethodScope methodScope) {





1335         assert verifyEdges();
1336     }
1337 
1338     protected boolean verifyEdges() {
1339         for (Node node : graph.getNodes()) {
1340             assert node.isAlive();
1341             for (Node i : node.inputs()) {
1342                 assert i.isAlive();
1343                 assert i.usages().contains(node);
1344             }
1345             for (Node s : node.successors()) {
1346                 assert s.isAlive();
1347                 assert s.predecessor() == node;
1348             }
1349 
1350             for (Node usage : node.usages()) {
1351                 assert usage.isAlive();
1352                 assert usage.inputs().contains(node) : node + &quot; / &quot; + usage + &quot; / &quot; + usage.inputs().count();
1353             }
1354             if (node.predecessor() != null) {
</pre>
<hr />
<pre>
1729              * The LoopExit is inserted before the existing merge, i.e., separately for every branch
1730              * that leads to the merge. So for phi functions of the merge, we need to take the input
1731              * that corresponds to our branch.
1732              */
1733             if (realValue instanceof PhiNode &amp;&amp; loopExplosionMerge.isPhiAtMerge(realValue)) {
1734                 value = ((PhiNode) realValue).valueAt(loopExplosionEnd);
1735                 realValue = ProxyPlaceholder.unwrap(value);
1736             }
1737 
1738             if (realValue == null || realValue.isConstant() || loopBeginValues.contains(realValue) || !graph.isNew(methodScope.methodStartMark, realValue)) {
1739                 newValues.add(realValue);
1740             } else {
1741                 /*
1742                  * The node is not in the FrameState of the LoopBegin, i.e., it is a value computed
1743                  * inside the loop.
1744                  */
1745                 GraalError.guarantee(value instanceof ProxyPlaceholder &amp;&amp; ((ProxyPlaceholder) value).proxyPoint == loopExplosionMerge,
1746                                 &quot;Value flowing out of loop, but we are not prepared to insert a ProxyNode&quot;);
1747 
1748                 ProxyPlaceholder proxyPlaceholder = (ProxyPlaceholder) value;
<span class="line-modified">1749                 ValueProxyNode proxy = ProxyNode.forValue(proxyPlaceholder.value, loopExit, graph);</span>
1750                 proxyPlaceholder.setValue(proxy);
1751                 newValues.add(proxy);
1752             }
1753         }
1754 
1755         FrameState newState = new FrameState(oldState.outerFrameState(), oldState.getCode(), oldState.bci, newValues, oldState.localsSize(), oldState.stackSize(), oldState.rethrowException(),
1756                         oldState.duringCall(), oldState.monitorIds(), oldState.virtualObjectMappings());
1757 
1758         assert loopExit.stateAfter() == null;
1759         loopExit.setStateAfter(graph.add(newState));
1760     }
1761 
1762     /**
1763      * Graal does not support irreducible loops (loops with more than one entry point). There are
1764      * two ways to make them reducible: 1) duplicate nodes (peel a loop iteration starting at the
1765      * second entry point until we reach the first entry point), or 2) insert a big outer loop
1766      * covering the whole method and build a state machine for the different loop entry points.
1767      * Since node duplication can lead to an exponential explosion of nodes in the worst case, we
1768      * use the second approach.
1769      *
</pre>
<hr />
<pre>
1797          * loop. There must be exactly one loop variable.
1798          */
1799         int loopVariableIndex = -1;
1800         ValueNode loopValue = null;
1801         ValueNode explosionHeadValue = null;
1802         for (int i = 0; i &lt; loopValues.size(); i++) {
1803             ValueNode curLoopValue = loopValues.get(i);
1804             ValueNode curExplosionHeadValue = explosionHeadValues.get(i);
1805 
1806             if (curLoopValue != curExplosionHeadValue) {
1807                 if (loopVariableIndex != -1) {
1808                     throw bailout(&quot;must have only one variable that is changed in loop. &quot; + loopValue + &quot; != &quot; + explosionHeadValue + &quot; and &quot; + curLoopValue + &quot; != &quot; + curExplosionHeadValue);
1809                 }
1810 
1811                 loopVariableIndex = i;
1812                 loopValue = curLoopValue;
1813                 explosionHeadValue = curExplosionHeadValue;
1814             }
1815         }
1816         assert loopVariableIndex != -1;

1817 
1818         ValuePhiNode loopVariablePhi;
1819         SortedMap&lt;Integer, AbstractBeginNode&gt; dispatchTable = new TreeMap&lt;&gt;();
1820         AbstractBeginNode unreachableDefaultSuccessor;
1821         if (irreducibleLoopSwitch == null) {
1822             /*
1823              * This is the first irreducible loop. We need to build the initial state machine
1824              * (dispatch for the loop header of the outermost loop).
1825              */
1826             assert !irreducibleLoopHandler.header.isPhiAtMerge(explosionHeadValue);
1827             assert irreducibleLoopHandler.header.phis().isEmpty();
1828 
1829             /* The new phi function for the loop variable. */
1830             loopVariablePhi = graph.addWithoutUnique(new ValuePhiNode(explosionHeadValue.stamp(NodeView.DEFAULT).unrestricted(), irreducibleLoopHandler.header));
1831             for (int i = 0; i &lt; irreducibleLoopHandler.header.phiPredecessorCount(); i++) {
1832                 loopVariablePhi.addInput(explosionHeadValue);
1833             }
1834 
1835             /*
1836              * Build the new FrameState for the loop header. There is only once change in comparison
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 122             this.loopExplosion = loopExplosion;
 123             this.returnAndUnwindNodes = new ArrayList&lt;&gt;(2);
 124 
 125             if (encodedGraph != null) {
 126                 reader = UnsafeArrayTypeReader.create(encodedGraph.getEncoding(), encodedGraph.getStartOffset(), architecture.supportsUnalignedMemoryAccess());
 127                 maxFixedNodeOrderId = reader.getUVInt();
 128                 if (encodedGraph.nodeStartOffsets == null) {
 129                     int nodeCount = reader.getUVInt();
 130                     int[] nodeStartOffsets = new int[nodeCount];
 131                     for (int i = 0; i &lt; nodeCount; i++) {
 132                         nodeStartOffsets[i] = encodedGraph.getStartOffset() - reader.getUVInt();
 133                     }
 134                     encodedGraph.nodeStartOffsets = nodeStartOffsets;
 135                     graph.setGuardsStage((StructuredGraph.GuardsStage) readObject(this));
 136                 }
 137             } else {
 138                 reader = null;
 139                 maxFixedNodeOrderId = 0;
 140             }
 141 
<span class="line-modified"> 142             if (loopExplosion.useExplosion()) {</span>
 143                 loopExplosionMerges = EconomicSet.create(Equivalence.IDENTITY);
 144             } else {
 145                 loopExplosionMerges = null;
 146             }
 147         }
 148 
 149         public boolean isInlinedMethod() {
 150             return false;
 151         }
 152 
 153         public NodeSourcePosition getCallerBytecodePosition() {
 154             return getCallerBytecodePosition(null);
 155         }
 156 
 157         public NodeSourcePosition getCallerBytecodePosition(NodeSourcePosition position) {
 158             return position;
 159         }
 160 
 161     }
 162 
<span class="line-added"> 163     /**</span>
<span class="line-added"> 164      * Marker to distinguish the reasons for the creation of a loop scope during partial evaluation.</span>
<span class="line-added"> 165      */</span>
<span class="line-added"> 166     public enum LoopScopeTrigger {</span>
<span class="line-added"> 167         /**</span>
<span class="line-added"> 168          * Start loop scope: creation triggered manually at the beginning of partial evaluation.</span>
<span class="line-added"> 169          */</span>
<span class="line-added"> 170         START,</span>
<span class="line-added"> 171 </span>
<span class="line-added"> 172         /**</span>
<span class="line-added"> 173          * Loop scope created for the next iteration of a loop if unrolling is enabled in the loop</span>
<span class="line-added"> 174          * explosion mode. See {@link LoopExplosionKind#unrollLoops()} for details. Loop unrolling</span>
<span class="line-added"> 175          * will merge loop end nodes for each iteration of the original loop.</span>
<span class="line-added"> 176          */</span>
<span class="line-added"> 177         LOOP_BEGIN_UNROLLING,</span>
<span class="line-added"> 178 </span>
<span class="line-added"> 179         /**</span>
<span class="line-added"> 180          * Loop scope created for the next iteration of a loop along a particular loop end node if</span>
<span class="line-added"> 181          * {@link LoopExplosionKind#duplicateLoopEnds()} is enabled and loops are exploded. This</span>
<span class="line-added"> 182          * means for every loop end we duplicate the next loop iteration of the original loop.</span>
<span class="line-added"> 183          */</span>
<span class="line-added"> 184         LOOP_END_DUPLICATION,</span>
<span class="line-added"> 185 </span>
<span class="line-added"> 186         /**</span>
<span class="line-added"> 187          * Loop scope created for a loop exit node if {@link LoopExplosionKind#duplicateLoopExits()}</span>
<span class="line-added"> 188          * is enabled, i.e., code after a loop exit is duplicated per loop exit node.</span>
<span class="line-added"> 189          *</span>
<span class="line-added"> 190          * Special case nested loops: For compilation units with nested loops where inner loops</span>
<span class="line-added"> 191          * continue loops at a level n -1 the partial evaluation algorithm will merge outer loops to</span>
<span class="line-added"> 192          * avoid loop explosion along loop end nodes (which would be the same as</span>
<span class="line-added"> 193          * {@link #LOOP_END_DUPLICATION}.</span>
<span class="line-added"> 194          */</span>
<span class="line-added"> 195         LOOP_EXIT_DUPLICATION</span>
<span class="line-added"> 196     }</span>
<span class="line-added"> 197 </span>
 198     /** Decoding state maintained for each loop in the encoded graph. */
 199     protected static class LoopScope {
 200         public final MethodScope methodScope;
 201         public final LoopScope outer;
 202         public final int loopDepth;
 203         public final int loopIteration;
<span class="line-added"> 204 </span>
<span class="line-added"> 205         /**</span>
<span class="line-added"> 206          * Creation trigger of this particular loop scope, i.e., the reason it was created.</span>
<span class="line-added"> 207          */</span>
<span class="line-added"> 208         final LoopScopeTrigger trigger;</span>
<span class="line-added"> 209         /**</span>
<span class="line-added"> 210          * Upcoming, not yet processed, loop iterations created in the context of code duplication</span>
<span class="line-added"> 211          * along loop exits. Only used when {@link MethodScope#loopExplosion} has</span>
<span class="line-added"> 212          * {@link LoopExplosionKind#duplicateLoopExits()} enabled.</span>
<span class="line-added"> 213          */</span>
<span class="line-added"> 214         public Deque&lt;LoopScope&gt; nextIterationFromLoopExitDuplication;</span>
 215         /**
<span class="line-modified"> 216          * Same as {@link #nextIterationFromLoopExitDuplication} except that upcoming iterations</span>
<span class="line-modified"> 217          * have been created because the duplication of loop ends</span>
<span class="line-added"> 218          * {@link LoopExplosionKind#duplicateLoopEnds()} is enabled.</span>
 219          */
<span class="line-modified"> 220         public Deque&lt;LoopScope&gt; nextIterationFromLoopEndDuplication;</span>
<span class="line-added"> 221         /**</span>
<span class="line-added"> 222          * Same as {@link #nextIterationFromLoopExitDuplication} except that upcoming iterations</span>
<span class="line-added"> 223          * have been created because the unrolling of a loop with constant iteration count</span>
<span class="line-added"> 224          * {@link LoopExplosionKind#unrollLoops()} is enabled.</span>
<span class="line-added"> 225          */</span>
<span class="line-added"> 226         public Deque&lt;LoopScope&gt; nextIterationsFromUnrolling;</span>
 227         /**
 228          * Information about already processed loop iterations for state merging during loop
 229          * explosion. Only used when {@link MethodScope#loopExplosion} is
 230          * {@link LoopExplosionKind#MERGE_EXPLODE}.
 231          */
 232         public final EconomicMap&lt;LoopExplosionState, LoopExplosionState&gt; iterationStates;
 233         public final int loopBeginOrderId;
 234         /**
 235          * The worklist of fixed nodes to process. Since we already the correct processing order
 236          * from the orderId, we just set the orderId bit in the bitset when a node is ready for
 237          * processing. The lowest set bit is the next node to process.
 238          */
 239         public final BitSet nodesToProcess;
 240         /** Nodes that have been created, indexed by the orderId. */
 241         public final Node[] createdNodes;
 242         /**
 243          * Nodes that have been created in outer loop scopes and existed before starting to process
 244          * this loop, indexed by the orderId. Only used when {@link MethodScope#loopExplosion} is
 245          * not {@link LoopExplosionKind#NONE}.
 246          */
 247         public final Node[] initialCreatedNodes;
 248 
 249         protected LoopScope(MethodScope methodScope) {
 250             this.methodScope = methodScope;
 251             this.outer = null;
<span class="line-modified"> 252             this.nextIterationFromLoopExitDuplication = methodScope.loopExplosion.duplicateLoopExits() || methodScope.loopExplosion.mergeLoops() ? new ArrayDeque&lt;&gt;(2) : null;</span>
<span class="line-added"> 253             this.nextIterationFromLoopEndDuplication = methodScope.loopExplosion.duplicateLoopEnds() ? new ArrayDeque&lt;&gt;(2) : null;</span>
<span class="line-added"> 254             this.nextIterationsFromUnrolling = methodScope.loopExplosion.unrollLoops() ? new ArrayDeque&lt;&gt;(2) : null;</span>
 255             this.loopDepth = 0;
 256             this.loopIteration = 0;
 257             this.iterationStates = null;
 258             this.loopBeginOrderId = -1;

 259             int nodeCount = methodScope.encodedGraph.nodeStartOffsets.length;
 260             this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);
 261             this.createdNodes = new Node[nodeCount];
 262             this.initialCreatedNodes = null;
<span class="line-added"> 263             this.trigger = LoopScopeTrigger.START;</span>
 264         }
 265 
<span class="line-modified"> 266         protected LoopScope(MethodScope methodScope, LoopScope outer, int loopDepth, int loopIteration, int loopBeginOrderId, LoopScopeTrigger trigger, Node[] initialCreatedNodes, Node[] createdNodes,</span>
<span class="line-modified"> 267                         Deque&lt;LoopScope&gt; nextIterationFromLoopExitDuplication,</span>
<span class="line-added"> 268                         Deque&lt;LoopScope&gt; nextIterationFromLoopEndDuplication,</span>
<span class="line-added"> 269                         Deque&lt;LoopScope&gt; nextIterationsFromUnrolling, EconomicMap&lt;LoopExplosionState, LoopExplosionState&gt; iterationStates) {</span>
 270             this.methodScope = methodScope;
 271             this.outer = outer;
 272             this.loopDepth = loopDepth;
 273             this.loopIteration = loopIteration;
<span class="line-modified"> 274             this.trigger = trigger;</span>
<span class="line-added"> 275             this.nextIterationFromLoopExitDuplication = nextIterationFromLoopExitDuplication;</span>
<span class="line-added"> 276             this.nextIterationFromLoopEndDuplication = nextIterationFromLoopEndDuplication;</span>
<span class="line-added"> 277             this.nextIterationsFromUnrolling = nextIterationsFromUnrolling;</span>
 278             this.iterationStates = iterationStates;
 279             this.loopBeginOrderId = loopBeginOrderId;
 280             this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);
 281             this.initialCreatedNodes = initialCreatedNodes;
 282             this.createdNodes = createdNodes;
 283         }
 284 
 285         @Override
 286         public String toString() {
<span class="line-modified"> 287             return loopDepth + &quot;,&quot; + loopIteration + (loopBeginOrderId == -1 ? &quot;&quot; : &quot;#&quot; + loopBeginOrderId) + &quot; triggered by &quot; + trigger;</span>
<span class="line-added"> 288         }</span>
<span class="line-added"> 289 </span>
<span class="line-added"> 290         /**</span>
<span class="line-added"> 291          * Determines if iterations generated when decoding this loop have yet to be processed.</span>
<span class="line-added"> 292          *</span>
<span class="line-added"> 293          * @return {@code true} if there are iterations to be decoded, {@code false} else</span>
<span class="line-added"> 294          */</span>
<span class="line-added"> 295         public boolean hasIterationsToProcess() {</span>
<span class="line-added"> 296             return nextIterationFromLoopEndDuplication != null &amp;&amp; !nextIterationFromLoopEndDuplication.isEmpty() ||</span>
<span class="line-added"> 297                             nextIterationFromLoopExitDuplication != null &amp;&amp; !nextIterationFromLoopExitDuplication.isEmpty() ||</span>
<span class="line-added"> 298                             nextIterationsFromUnrolling != null &amp;&amp; !nextIterationsFromUnrolling.isEmpty();</span>
<span class="line-added"> 299         }</span>
<span class="line-added"> 300 </span>
<span class="line-added"> 301         /**</span>
<span class="line-added"> 302          * Return the next iteration yet to be processed that has been created in the context of</span>
<span class="line-added"> 303          * decoding this loop scope.</span>
<span class="line-added"> 304          *</span>
<span class="line-added"> 305          * @param remove determines if the query of the next iteration should remove it from the</span>
<span class="line-added"> 306          *            list of iterations to be processed</span>
<span class="line-added"> 307          * @return the next {@link LoopScope} to be processed that has been created in the context</span>
<span class="line-added"> 308          *         of decoding this loop scope. Note that the order is not necessarily reflecting</span>
<span class="line-added"> 309          *         the number of loop iterations.</span>
<span class="line-added"> 310          */</span>
<span class="line-added"> 311         public LoopScope getNextIterationToProcess(boolean remove) {</span>
<span class="line-added"> 312             if (nextIterationFromLoopEndDuplication != null &amp;&amp; !nextIterationFromLoopEndDuplication.isEmpty()) {</span>
<span class="line-added"> 313                 return remove ? nextIterationFromLoopEndDuplication.removeFirst() : nextIterationFromLoopEndDuplication.peekFirst();</span>
<span class="line-added"> 314             }</span>
<span class="line-added"> 315             if (nextIterationFromLoopExitDuplication != null &amp;&amp; !nextIterationFromLoopExitDuplication.isEmpty()) {</span>
<span class="line-added"> 316                 return remove ? nextIterationFromLoopExitDuplication.removeFirst() : nextIterationFromLoopExitDuplication.peekFirst();</span>
<span class="line-added"> 317             }</span>
<span class="line-added"> 318             if (nextIterationsFromUnrolling != null &amp;&amp; !nextIterationsFromUnrolling.isEmpty()) {</span>
<span class="line-added"> 319                 return remove ? nextIterationsFromUnrolling.removeFirst() : nextIterationsFromUnrolling.peekFirst();</span>
<span class="line-added"> 320             }</span>
<span class="line-added"> 321             return null;</span>
 322         }
 323     }
 324 
 325     protected static class LoopExplosionState {
 326         public final FrameState state;
 327         public final MergeNode merge;
 328         public final int hashCode;
 329 
 330         protected LoopExplosionState(FrameState state, MergeNode merge) {
 331             this.state = state;
 332             this.merge = merge;
 333 
 334             int h = 0;
 335             for (ValueNode value : state.values()) {
 336                 if (value == null) {
 337                     h = h * 31 + 1234;
 338                 } else {
 339                     h = h * 31 + ProxyPlaceholder.unwrap(value).hashCode();
 340                 }
 341             }
</pre>
<hr />
<pre>
 396             this.callTargetOrderId = callTargetOrderId;
 397             this.stateAfterOrderId = stateAfterOrderId;
 398             this.nextOrderId = nextOrderId;
 399             this.nextNextOrderId = nextNextOrderId;
 400             this.exceptionOrderId = exceptionOrderId;
 401             this.exceptionStateOrderId = exceptionStateOrderId;
 402             this.exceptionNextOrderId = exceptionNextOrderId;
 403         }
 404     }
 405 
 406     /**
 407      * A node that is created during {@link LoopExplosionKind#MERGE_EXPLODE loop explosion} that can
 408      * later be replaced by a ProxyNode if {@link LoopDetector loop detection} finds out that the
 409      * value is defined in the loop, but used outside the loop.
 410      */
 411     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
 412     protected static final class ProxyPlaceholder extends FloatingNode implements Canonicalizable {
 413         public static final NodeClass&lt;ProxyPlaceholder&gt; TYPE = NodeClass.create(ProxyPlaceholder.class);
 414 
 415         @Input ValueNode value;
<span class="line-modified"> 416         @Input(InputType.Association) Node proxyPoint;</span>
 417 
 418         public ProxyPlaceholder(ValueNode value, MergeNode proxyPoint) {
 419             super(TYPE, value.stamp(NodeView.DEFAULT));
 420             this.value = value;
 421             this.proxyPoint = proxyPoint;
 422         }
 423 
 424         void setValue(ValueNode value) {
 425             updateUsages(this.value, value);
 426             this.value = value;
 427         }
 428 
 429         @Override
 430         public Node canonical(CanonicalizerTool tool) {
 431             if (tool.allUsagesAvailable()) {
 432                 /* The node is always unnecessary after graph decoding. */
 433                 return value;
 434             } else {
 435                 return this;
 436             }
</pre>
<hr />
<pre>
 486 
 487             firstNode = makeStubNode(methodScope, loopScope, GraphEncoder.FIRST_NODE_ORDER_ID);
 488             startNode.setNext(firstNode);
 489             loopScope.nodesToProcess.set(GraphEncoder.FIRST_NODE_ORDER_ID);
 490         } else {
 491             firstNode = graph.start();
 492             registerNode(loopScope, GraphEncoder.START_NODE_ORDER_ID, firstNode, false, false);
 493             loopScope.nodesToProcess.set(GraphEncoder.START_NODE_ORDER_ID);
 494         }
 495         return loopScope;
 496     }
 497 
 498     protected final void decode(LoopScope initialLoopScope) {
 499         LoopScope loopScope = initialLoopScope;
 500         /* Process (inlined) methods. */
 501         while (loopScope != null) {
 502             MethodScope methodScope = loopScope.methodScope;
 503 
 504             /* Process loops of method. */
 505             while (loopScope != null) {

 506                 /* Process nodes of loop. */
 507                 while (!loopScope.nodesToProcess.isEmpty()) {
 508                     loopScope = processNextNode(methodScope, loopScope);
 509                     methodScope = loopScope.methodScope;
 510                     /*
 511                      * We can have entered a new loop, and we can have entered a new inlined method.
 512                      */
 513                 }
 514 
 515                 /* Finished with a loop. */
<span class="line-modified"> 516                 if (loopScope.hasIterationsToProcess()) {</span>
<span class="line-modified"> 517                     loopScope = loopScope.getNextIterationToProcess(true);</span>


 518                 } else {
 519                     propagateCreatedNodes(loopScope);
 520                     loopScope = loopScope.outer;
 521                 }
 522             }
 523 
 524             /*
 525              * Finished with an inlined method. Perform end-of-method cleanup tasks.
 526              */
<span class="line-modified"> 527             if (methodScope.loopExplosion.mergeLoops()) {</span>
 528                 LoopDetector loopDetector = new LoopDetector(graph, methodScope);
 529                 loopDetector.run();
 530             }
 531             if (methodScope.isInlinedMethod()) {
 532                 finishInlining(methodScope);
 533             }
 534 
 535             /* continue with the caller */
 536             loopScope = methodScope.callerLoopScope;
 537         }
 538     }
 539 
 540     protected void finishInlining(@SuppressWarnings(&quot;unused&quot;) MethodScope inlineScope) {
 541     }
 542 
 543     private static void propagateCreatedNodes(LoopScope loopScope) {
 544         if (loopScope.outer == null || loopScope.createdNodes != loopScope.outer.createdNodes) {
 545             return;
 546         }
 547 
 548         /* Register nodes that were created while decoding the loop to the outside scope. */
 549         for (int i = 0; i &lt; loopScope.createdNodes.length; i++) {
 550             if (loopScope.outer.createdNodes[i] == null) {
 551                 loopScope.outer.createdNodes[i] = loopScope.createdNodes[i];
 552             }
 553         }
 554     }
 555 
<span class="line-added"> 556     public static final boolean DUMP_DURING_FIXED_NODE_PROCESSING = false;</span>
<span class="line-added"> 557 </span>
 558     protected LoopScope processNextNode(MethodScope methodScope, LoopScope loopScope) {
 559         int nodeOrderId = loopScope.nodesToProcess.nextSetBit(0);
 560         loopScope.nodesToProcess.clear(nodeOrderId);
 561 
 562         FixedNode node = (FixedNode) lookupNode(loopScope, nodeOrderId);
<span class="line-added"> 563 </span>
 564         if (node.isDeleted()) {
 565             return loopScope;
 566         }
<span class="line-modified"> 567         if (DUMP_DURING_FIXED_NODE_PROCESSING) {</span>
<span class="line-added"> 568             if (node != null) {</span>
<span class="line-added"> 569                 try {</span>
<span class="line-added"> 570                     debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;Before processing node %s&quot;, node);</span>
<span class="line-added"> 571                 } catch (Throwable t) {</span>
<span class="line-added"> 572                     // swallow here, dumping uninitialized nodes can cause problems</span>
<span class="line-added"> 573                 }</span>
<span class="line-added"> 574             }</span>
<span class="line-added"> 575         }</span>
 576         if ((node instanceof MergeNode ||
<span class="line-modified"> 577                         (node instanceof LoopBeginNode &amp;&amp; (methodScope.loopExplosion.unrollLoops() &amp;&amp;</span>
<span class="line-modified"> 578                                         !methodScope.loopExplosion.mergeLoops()))) &amp;&amp;</span>
 579                         ((AbstractMergeNode) node).forwardEndCount() == 1) {
<span class="line-added"> 580             /*</span>
<span class="line-added"> 581              * In case node is a loop begin and we are unrolling loops we remove the loop begin</span>
<span class="line-added"> 582              * since the loop will be gone after PE.</span>
<span class="line-added"> 583              */</span>
 584             AbstractMergeNode merge = (AbstractMergeNode) node;
 585             EndNode singleEnd = merge.forwardEndAt(0);
 586 
 587             /* Nodes that would use this merge as the guard need to use the previous block. */
 588             registerNode(loopScope, nodeOrderId, AbstractBeginNode.prevBegin(singleEnd), true, false);
 589 
 590             FixedNode next = makeStubNode(methodScope, loopScope, nodeOrderId + GraphEncoder.BEGIN_NEXT_ORDER_ID_OFFSET);
 591             singleEnd.replaceAtPredecessor(next);
 592 
 593             merge.safeDelete();
 594             singleEnd.safeDelete();
 595             return loopScope;
 596         }
 597 
 598         LoopScope successorAddScope = loopScope;
 599         boolean updatePredecessors = true;
 600         if (node instanceof LoopExitNode) {
<span class="line-modified"> 601             if (methodScope.loopExplosion.duplicateLoopExits() || (methodScope.loopExplosion.mergeLoops() &amp;&amp; loopScope.loopDepth &gt; 1)) {</span>
 602                 /*
 603                  * We do not want to merge loop exits of inner loops. Instead, we want to keep
 604                  * exploding the outer loop separately for every loop exit and then merge the outer
 605                  * loop. Therefore, we create a new LoopScope of the outer loop for every loop exit
 606                  * of the inner loop.
 607                  */
 608                 LoopScope outerScope = loopScope.outer;
<span class="line-modified"> 609                 int nextIterationNumber = outerScope.nextIterationFromLoopExitDuplication.isEmpty() ? outerScope.loopIteration + 1</span>
<span class="line-modified"> 610                                 : outerScope.nextIterationFromLoopExitDuplication.getLast().loopIteration + 1;</span>
<span class="line-added"> 611                 successorAddScope = new LoopScope(methodScope, outerScope.outer, outerScope.loopDepth, nextIterationNumber, outerScope.loopBeginOrderId, LoopScopeTrigger.LOOP_EXIT_DUPLICATION,</span>
 612                                 outerScope.initialCreatedNodes == null ? null : Arrays.copyOf(outerScope.initialCreatedNodes, outerScope.initialCreatedNodes.length),
<span class="line-modified"> 613                                 Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),</span>
<span class="line-added"> 614                                 outerScope.nextIterationFromLoopExitDuplication,</span>
<span class="line-added"> 615                                 outerScope.nextIterationFromLoopEndDuplication,</span>
<span class="line-added"> 616                                 outerScope.nextIterationsFromUnrolling,</span>
<span class="line-added"> 617                                 outerScope.iterationStates);</span>
 618                 checkLoopExplosionIteration(methodScope, successorAddScope);
 619 
 620                 /*
 621                  * Nodes that are still unprocessed in the outer scope might be merge nodes that are
 622                  * also reachable from the new exploded scope. Clearing them ensures that we do not
 623                  * merge, but instead keep exploding.
 624                  */
 625                 for (int id = outerScope.nodesToProcess.nextSetBit(0); id &gt;= 0; id = outerScope.nodesToProcess.nextSetBit(id + 1)) {
 626                     successorAddScope.createdNodes[id] = null;
 627                 }
 628 
<span class="line-modified"> 629                 outerScope.nextIterationFromLoopExitDuplication.addLast(successorAddScope);</span>
 630             } else {
 631                 successorAddScope = loopScope.outer;
 632             }
<span class="line-modified"> 633             updatePredecessors = methodScope.loopExplosion.isNoExplosion();</span>
 634         }
 635 
 636         methodScope.reader.setByteIndex(methodScope.encodedGraph.nodeStartOffsets[nodeOrderId]);
 637         int typeId = methodScope.reader.getUVInt();
 638         assert node.getNodeClass() == methodScope.encodedGraph.getNodeClasses()[typeId];
 639         makeFixedNodeInputs(methodScope, loopScope, node);
 640         readProperties(methodScope, node);
 641         makeSuccessorStubs(methodScope, successorAddScope, node, updatePredecessors);
 642 
 643         LoopScope resultScope = loopScope;
 644         if (node instanceof LoopBeginNode) {
<span class="line-modified"> 645             if (methodScope.loopExplosion.useExplosion()) {</span>
 646                 handleLoopExplosionBegin(methodScope, loopScope, (LoopBeginNode) node);
 647             }
 648 
 649         } else if (node instanceof LoopExitNode) {
<span class="line-modified"> 650             if (methodScope.loopExplosion.useExplosion()) {</span>
 651                 handleLoopExplosionProxyNodes(methodScope, loopScope, successorAddScope, (LoopExitNode) node, nodeOrderId);
 652             } else {
 653                 handleProxyNodes(methodScope, loopScope, (LoopExitNode) node);
 654             }
 655 
 656         } else if (node instanceof MergeNode) {
 657             handleMergeNode(((MergeNode) node));

 658         } else if (node instanceof AbstractEndNode) {
 659             LoopScope phiInputScope = loopScope;
 660             LoopScope phiNodeScope = loopScope;
<span class="line-added"> 661             int mergeOrderId = readOrderId(methodScope);</span>
 662 
<span class="line-modified"> 663             boolean requiresMergeOfOuterLoop = methodScope.loopExplosion.unrollLoops() &amp;&amp;</span>
<span class="line-modified"> 664                             methodScope.loopExplosion.duplicateLoopExits() &amp;&amp;</span>
<span class="line-modified"> 665                             (!methodScope.loopExplosion.duplicateLoopEnds()) &amp;&amp;</span>
<span class="line-modified"> 666                             (!methodScope.loopExplosion.mergeLoops()) &amp;&amp;</span>
<span class="line-added"> 667                             node instanceof LoopEndNode &amp;&amp;</span>
<span class="line-added"> 668                             loopScope.trigger == LoopScopeTrigger.LOOP_EXIT_DUPLICATION;</span>
<span class="line-added"> 669 </span>
<span class="line-added"> 670             if (requiresMergeOfOuterLoop) {</span>
<span class="line-added"> 671                 EndNode replacementNode = graph.add(new EndNode());</span>
<span class="line-added"> 672                 node.replaceAtPredecessor(replacementNode);</span>
<span class="line-added"> 673                 node.safeDelete();</span>
<span class="line-added"> 674                 node = replacementNode;</span>
<span class="line-added"> 675                 /*</span>
<span class="line-added"> 676                  * We are in a loop exit duplicated loop scope and see a loop end node, this can</span>
<span class="line-added"> 677                  * only happen if we have a loop end to an outer loop. When duplicating over loop</span>
<span class="line-added"> 678                  * exits we have to merge outer loops for nested inner loops.</span>
<span class="line-added"> 679                  *</span>
<span class="line-added"> 680                  * Therefore, we create a correct outer loop iteration and check if there is already</span>
<span class="line-added"> 681                  * one, if not we create it else we re-use it.</span>
<span class="line-added"> 682                  */</span>
<span class="line-added"> 683                 if (loopScope.nextIterationsFromUnrolling.isEmpty()) {</span>
<span class="line-added"> 684                     // create it</span>
<span class="line-added"> 685                     int nextIterationNumber = loopScope.nextIterationsFromUnrolling.isEmpty() ? loopScope.loopIteration + 1 : loopScope.nextIterationsFromUnrolling.getLast().loopIteration + 1;</span>
<span class="line-added"> 686                     LoopScope outerLoopMergeScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId,</span>
<span class="line-added"> 687                                     LoopScopeTrigger.LOOP_BEGIN_UNROLLING,</span>
<span class="line-added"> 688                                     Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),</span>
<span class="line-added"> 689                                     Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),</span>
<span class="line-added"> 690                                     loopScope.nextIterationFromLoopExitDuplication,</span>
<span class="line-added"> 691                                     loopScope.nextIterationFromLoopEndDuplication,</span>
<span class="line-added"> 692                                     loopScope.nextIterationsFromUnrolling,</span>
<span class="line-added"> 693                                     loopScope.iterationStates);</span>
<span class="line-added"> 694                     checkLoopExplosionIteration(methodScope, outerLoopMergeScope);</span>
<span class="line-added"> 695                     loopScope.nextIterationsFromUnrolling.addLast(outerLoopMergeScope);</span>
<span class="line-added"> 696                     registerNode(outerLoopMergeScope, loopScope.loopBeginOrderId, null, true, true);</span>
<span class="line-added"> 697                     makeStubNode(methodScope, outerLoopMergeScope, loopScope.loopBeginOrderId);</span>
<span class="line-added"> 698                     phiNodeScope = outerLoopMergeScope;</span>
<span class="line-added"> 699                 } else {</span>
<span class="line-added"> 700                     // re-use it</span>
<span class="line-added"> 701                     phiNodeScope = loopScope.nextIterationsFromUnrolling.getLast();</span>
<span class="line-added"> 702                 }</span>
 703 
<span class="line-modified"> 704             } else if (methodScope.loopExplosion.useExplosion() &amp;&amp; node instanceof LoopEndNode) {</span>
<span class="line-added"> 705                 EndNode replacementNode = graph.add(new EndNode());</span>
<span class="line-added"> 706                 node.replaceAtPredecessor(replacementNode);</span>
<span class="line-added"> 707                 node.safeDelete();</span>
<span class="line-added"> 708                 node = replacementNode;</span>
<span class="line-added"> 709                 LoopScopeTrigger trigger = handleLoopExplosionEnd(methodScope, loopScope);</span>
<span class="line-added"> 710                 Deque&lt;LoopScope&gt; phiScope = loopScope.nextIterationsFromUnrolling;</span>
<span class="line-added"> 711                 if (trigger == LoopScopeTrigger.LOOP_END_DUPLICATION) {</span>
<span class="line-added"> 712                     phiScope = loopScope.nextIterationFromLoopEndDuplication;</span>
<span class="line-added"> 713                 }</span>
<span class="line-added"> 714                 phiNodeScope = phiScope.getLast();</span>
<span class="line-added"> 715             }</span>
 716             AbstractMergeNode merge = (AbstractMergeNode) lookupNode(phiNodeScope, mergeOrderId);
 717             if (merge == null) {
 718                 merge = (AbstractMergeNode) makeStubNode(methodScope, phiNodeScope, mergeOrderId);

 719                 if (merge instanceof LoopBeginNode) {
<span class="line-added"> 720                     /*</span>
<span class="line-added"> 721                      * In contrast to the LoopScopeTrigger.START created at the beginning of every</span>
<span class="line-added"> 722                      * PE, we see a real loop here and create the first real loop scope associated</span>
<span class="line-added"> 723                      * with a loop.</span>
<span class="line-added"> 724                      *</span>
<span class="line-added"> 725                      * Creation of a loop scope if we reach a loop begin node. We process a loop</span>
<span class="line-added"> 726                      * begin node (always before encountering a loop end associated with the loop</span>
<span class="line-added"> 727                      * begin) and simply create a normal loop scope. This does not imply an advanced</span>
<span class="line-added"> 728                      * unrolling strategy (however it can later if we see duplicate over loop end or</span>
<span class="line-added"> 729                      * exits). Therefore, we still use the start marker here, we could also use the</span>
<span class="line-added"> 730                      * unrolling marker.</span>
<span class="line-added"> 731                      *</span>
<span class="line-added"> 732                      * If we unroll loops we will later remove the loop begin node and replace it</span>
<span class="line-added"> 733                      * with its forward end (since we do not need to create a loop begin node if we</span>
<span class="line-added"> 734                      * unroll the entire loop and it has a constant trip count).</span>
<span class="line-added"> 735                      */</span>
 736                     assert phiNodeScope == phiInputScope &amp;&amp; phiNodeScope == loopScope;
<span class="line-modified"> 737                     resultScope = new LoopScope(methodScope, loopScope, loopScope.loopDepth + 1, 0, mergeOrderId, LoopScopeTrigger.START,</span>
<span class="line-modified"> 738                                     methodScope.loopExplosion.useExplosion() ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : null,</span>
<span class="line-modified"> 739                                     methodScope.loopExplosion.useExplosion() ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : loopScope.createdNodes, //</span>
<span class="line-modified"> 740                                     methodScope.loopExplosion.duplicateLoopExits() || methodScope.loopExplosion.mergeLoops() ? new ArrayDeque&lt;&gt;(2) : null,</span>
<span class="line-modified"> 741                                     methodScope.loopExplosion.duplicateLoopEnds() ? new ArrayDeque&lt;&gt;(2) : null,</span>
<span class="line-added"> 742                                     methodScope.loopExplosion.unrollLoops() ? new ArrayDeque&lt;&gt;(2) : null, //</span>
<span class="line-added"> 743                                     methodScope.loopExplosion.mergeLoops() ? EconomicMap.create(Equivalence.DEFAULT) : null);</span>
 744                     phiInputScope = resultScope;
 745                     phiNodeScope = resultScope;
 746 
<span class="line-modified"> 747                     if (methodScope.loopExplosion.useExplosion()) {</span>
 748                         registerNode(loopScope, mergeOrderId, null, true, true);
 749                     }
 750                     loopScope.nodesToProcess.clear(mergeOrderId);
 751                     resultScope.nodesToProcess.set(mergeOrderId);
 752                 }
 753             }

 754             handlePhiFunctions(methodScope, phiInputScope, phiNodeScope, (AbstractEndNode) node, merge);

 755         } else if (node instanceof Invoke) {
 756             InvokeData invokeData = readInvokeData(methodScope, nodeOrderId, (Invoke) node);
 757             resultScope = handleInvoke(methodScope, loopScope, invokeData);

 758         } else if (node instanceof ReturnNode || node instanceof UnwindNode) {
 759             methodScope.returnAndUnwindNodes.add((ControlSinkNode) node);
 760         } else {
 761             handleFixedNode(methodScope, loopScope, nodeOrderId, node);
 762         }
<span class="line-modified"> 763         if (DUMP_DURING_FIXED_NODE_PROCESSING) {</span>
<span class="line-added"> 764             if (node != null) {</span>
<span class="line-added"> 765                 try {</span>
<span class="line-added"> 766                     debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;After processing node %s&quot;, node);</span>
<span class="line-added"> 767                 } catch (Throwable t) {</span>
<span class="line-added"> 768                     // swallow here, dumping uninitialized nodes can cause problems</span>
<span class="line-added"> 769                 }</span>
<span class="line-added"> 770             }</span>
<span class="line-added"> 771         }</span>
 772         return resultScope;
 773     }
 774 
 775     protected InvokeData readInvokeData(MethodScope methodScope, int invokeOrderId, Invoke invoke) {
 776         ResolvedJavaType contextType = (ResolvedJavaType) readObject(methodScope);
 777         int callTargetOrderId = readOrderId(methodScope);
 778         int stateAfterOrderId = readOrderId(methodScope);
 779         int nextOrderId = readOrderId(methodScope);
 780 
 781         if (invoke instanceof InvokeWithExceptionNode) {
 782             int nextNextOrderId = readOrderId(methodScope);
 783             int exceptionOrderId = readOrderId(methodScope);
 784             int exceptionStateOrderId = readOrderId(methodScope);
 785             int exceptionNextOrderId = readOrderId(methodScope);
 786             return new InvokeData(invoke, contextType, invokeOrderId, callTargetOrderId, stateAfterOrderId, nextOrderId, nextNextOrderId, exceptionOrderId, exceptionStateOrderId,
 787                             exceptionNextOrderId);
 788         } else {
 789             return new InvokeData(invoke, contextType, invokeOrderId, callTargetOrderId, stateAfterOrderId, nextOrderId, -1, -1, -1, -1);
 790         }
 791     }
</pre>
<hr />
<pre>
 821         if (invokeData.invoke instanceof InvokeWithExceptionNode) {
 822             ((InvokeWithExceptionNode) invokeData.invoke).setExceptionEdge((AbstractBeginNode) makeStubNode(methodScope, loopScope, invokeData.exceptionOrderId));
 823         }
 824     }
 825 
 826     /**
 827      * Hook for subclasses to perform simplifications for a non-loop-header control flow merge.
 828      *
 829      * @param merge The control flow merge.
 830      */
 831     protected void handleMergeNode(MergeNode merge) {
 832     }
 833 
 834     protected void handleLoopExplosionBegin(MethodScope methodScope, LoopScope loopScope, LoopBeginNode loopBegin) {
 835         checkLoopExplosionIteration(methodScope, loopScope);
 836 
 837         List&lt;EndNode&gt; predecessors = loopBegin.forwardEnds().snapshot();
 838         FixedNode successor = loopBegin.next();
 839         FrameState frameState = loopBegin.stateAfter();
 840 
<span class="line-modified"> 841         if (methodScope.loopExplosion.mergeLoops()) {</span>
 842             LoopExplosionState queryState = new LoopExplosionState(frameState, null);
 843             LoopExplosionState existingState = loopScope.iterationStates.get(queryState);
 844             if (existingState != null) {
 845                 loopBegin.replaceAtUsagesAndDelete(existingState.merge);
 846                 successor.safeDelete();
 847                 for (EndNode predecessor : predecessors) {
 848                     existingState.merge.addForwardEnd(predecessor);
 849                 }
 850                 return;
 851             }
 852         }
 853 
 854         MergeNode merge = graph.add(new MergeNode());
 855         methodScope.loopExplosionMerges.add(merge);
 856 
<span class="line-modified"> 857         if (methodScope.loopExplosion.mergeLoops()) {</span>
 858             if (loopScope.iterationStates.size() == 0 &amp;&amp; loopScope.loopDepth == 1) {
 859                 if (methodScope.loopExplosionHead != null) {
 860                     throw new PermanentBailoutException(&quot;Graal implementation restriction: Method with %s loop explosion must not have more than one top-level loop&quot;, LoopExplosionKind.MERGE_EXPLODE);
 861                 }
 862                 methodScope.loopExplosionHead = merge;
 863             }
 864 
 865             List&lt;ValueNode&gt; newFrameStateValues = new ArrayList&lt;&gt;();
 866             for (ValueNode frameStateValue : frameState.values) {
 867                 if (frameStateValue == null || frameStateValue.isConstant() || !graph.isNew(methodScope.methodStartMark, frameStateValue)) {
 868                     newFrameStateValues.add(frameStateValue);
 869 
 870                 } else {
 871                     ProxyPlaceholder newFrameStateValue = graph.unique(new ProxyPlaceholder(frameStateValue, merge));
 872                     newFrameStateValues.add(newFrameStateValue);
 873 
 874                     /*
 875                      * We do not have the orderID of the value anymore, so we need to search through
 876                      * the complete list of nodes to find a match.
 877                      */
</pre>
<hr />
<pre>
 888                             }
 889                         }
 890                     }
 891                 }
 892             }
 893 
 894             FrameState newFrameState = graph.add(new FrameState(frameState.outerFrameState(), frameState.getCode(), frameState.bci, newFrameStateValues, frameState.localsSize(),
 895                             frameState.stackSize(), frameState.rethrowException(), frameState.duringCall(), frameState.monitorIds(), frameState.virtualObjectMappings()));
 896 
 897             frameState.replaceAtUsagesAndDelete(newFrameState);
 898             frameState = newFrameState;
 899         }
 900 
 901         loopBegin.replaceAtUsagesAndDelete(merge);
 902         merge.setStateAfter(frameState);
 903         merge.setNext(successor);
 904         for (EndNode predecessor : predecessors) {
 905             merge.addForwardEnd(predecessor);
 906         }
 907 
<span class="line-modified"> 908         if (methodScope.loopExplosion.mergeLoops()) {</span>
 909             LoopExplosionState explosionState = new LoopExplosionState(frameState, merge);
 910             loopScope.iterationStates.put(explosionState, explosionState);
 911         }
 912     }
 913 
 914     /**
 915      * Hook for subclasses.
 916      *
 917      * @param methodScope The current method.
 918      * @param loopScope The current loop.
 919      */
 920     protected void checkLoopExplosionIteration(MethodScope methodScope, LoopScope loopScope) {
 921         throw shouldNotReachHere(&quot;when subclass uses loop explosion, it needs to implement this method&quot;);
 922     }
 923 
<span class="line-modified"> 924     protected LoopScopeTrigger handleLoopExplosionEnd(MethodScope methodScope, LoopScope loopScope) {</span>
<span class="line-modified"> 925         /*</span>
<span class="line-modified"> 926          * This method is only called if we reach a loop end and we use some kind of loop explosion,</span>
<span class="line-modified"> 927          * i.e., we unroll loops or explode along loop ends.</span>
<span class="line-modified"> 928          */</span>
<span class="line-modified"> 929         LoopScopeTrigger trigger = null;</span>
<span class="line-modified"> 930         Deque&lt;LoopScope&gt; nextIterations = null;</span>
<span class="line-modified"> 931         if (methodScope.loopExplosion.duplicateLoopEnds()) {</span>
<span class="line-modified"> 932             /*</span>
<span class="line-added"> 933              * Loop explosion along loop ends: We see a loop end, however we do not merge all loop</span>
<span class="line-added"> 934              * ends at a common merge node but rather duplicate the rest of the loop for every loop</span>
<span class="line-added"> 935              * end.</span>
<span class="line-added"> 936              */</span>
<span class="line-added"> 937             trigger = LoopScopeTrigger.LOOP_END_DUPLICATION;</span>
<span class="line-added"> 938             nextIterations = loopScope.nextIterationFromLoopEndDuplication;</span>
<span class="line-added"> 939         } else if (loopScope.nextIterationsFromUnrolling.isEmpty()) {</span>
<span class="line-added"> 940             /*</span>
<span class="line-added"> 941              * Regular loop unrolling, i.e., we reach a loop end node of a loop that should be</span>
<span class="line-added"> 942              * unrolled: We create a new successor scope.</span>
<span class="line-added"> 943              */</span>
<span class="line-added"> 944             trigger = LoopScopeTrigger.LOOP_BEGIN_UNROLLING;</span>
<span class="line-added"> 945             nextIterations = loopScope.nextIterationsFromUnrolling;</span>
<span class="line-added"> 946         }</span>
<span class="line-added"> 947         if (trigger != null) {</span>
<span class="line-added"> 948             int nextIterationNumber = nextIterations.isEmpty() ? loopScope.loopIteration + 1 : nextIterations.getLast().loopIteration + 1;</span>
<span class="line-added"> 949             LoopScope nextIterationScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId, trigger,</span>
 950                             Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
<span class="line-modified"> 951                             Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),</span>
<span class="line-added"> 952                             loopScope.nextIterationFromLoopExitDuplication,</span>
<span class="line-added"> 953                             loopScope.nextIterationFromLoopEndDuplication,</span>
<span class="line-added"> 954                             loopScope.nextIterationsFromUnrolling,</span>
<span class="line-added"> 955                             loopScope.iterationStates);</span>
 956             checkLoopExplosionIteration(methodScope, nextIterationScope);
<span class="line-modified"> 957             nextIterations.addLast(nextIterationScope);</span>
 958             registerNode(nextIterationScope, loopScope.loopBeginOrderId, null, true, true);
 959             makeStubNode(methodScope, nextIterationScope, loopScope.loopBeginOrderId);
 960         }
<span class="line-modified"> 961         return trigger;</span>
 962     }
 963 
 964     /**
 965      * Hook for subclasses.
 966      *
 967      * @param methodScope The current method.
 968      * @param loopScope The current loop.
 969      * @param nodeOrderId The orderId of the node.
 970      * @param node The node to be simplified.
 971      */
 972     protected void handleFixedNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId, FixedNode node) {
 973     }
 974 
 975     protected void handleProxyNodes(MethodScope methodScope, LoopScope loopScope, LoopExitNode loopExit) {
 976         assert loopExit.stateAfter() == null;
 977         int stateAfterOrderId = readOrderId(methodScope);
 978         loopExit.setStateAfter((FrameState) ensureNodeCreated(methodScope, loopScope, stateAfterOrderId));
 979 
 980         int numProxies = methodScope.reader.getUVInt();
 981         for (int i = 0; i &lt; numProxies; i++) {
</pre>
<hr />
<pre>
 984             /*
 985              * The ProxyNode transports a value from the loop to the outer scope. We therefore
 986              * register it in the outer scope.
 987              */
 988             if (loopScope.outer.createdNodes != loopScope.createdNodes) {
 989                 registerNode(loopScope.outer, proxyOrderId, proxy, false, false);
 990             }
 991         }
 992     }
 993 
 994     protected void handleLoopExplosionProxyNodes(MethodScope methodScope, LoopScope loopScope, LoopScope outerScope, LoopExitNode loopExit, int loopExitOrderId) {
 995         assert loopExit.stateAfter() == null;
 996         int stateAfterOrderId = readOrderId(methodScope);
 997 
 998         BeginNode begin = graph.add(new BeginNode());
 999 
1000         FixedNode loopExitSuccessor = loopExit.next();
1001         loopExit.replaceAtPredecessor(begin);
1002 
1003         MergeNode loopExitPlaceholder = null;
<span class="line-modified">1004         if (methodScope.loopExplosion.mergeLoops() &amp;&amp; loopScope.loopDepth == 1) {</span>
1005             /*
1006              * This exit might end up as a loop exit of a loop detected after partial evaluation. We
1007              * need to be able to create a FrameState and the necessary proxy nodes in this case.
1008              */
1009             loopExitPlaceholder = graph.add(new MergeNode());
1010             methodScope.loopExplosionMerges.add(loopExitPlaceholder);
1011 
1012             EndNode end = graph.add(new EndNode());
1013             begin.setNext(end);
1014             loopExitPlaceholder.addForwardEnd(end);
1015 
1016             begin = graph.add(new BeginNode());
1017             loopExitPlaceholder.setNext(begin);
1018         }
1019 
1020         /*
1021          * In the original graph, the loop exit is not a merge node. Multiple exploded loop
1022          * iterations now take the same loop exit, so we have to introduce a new merge node to
1023          * handle the merge.
1024          */
</pre>
<hr />
<pre>
1062             ProxyNode proxy = (ProxyNode) ensureNodeCreated(methodScope, loopScope, proxyOrderId);
1063             ValueNode phiInput = proxy.value();
1064 
1065             if (loopExitPlaceholder != null) {
1066                 if (!phiInput.isConstant()) {
1067                     phiInput = graph.unique(new ProxyPlaceholder(phiInput, loopExitPlaceholder));
1068                 }
1069                 registerNode(loopScope, proxyOrderId, phiInput, true, false);
1070             }
1071 
1072             ValueNode replacement;
1073             ValueNode existing = (ValueNode) outerScope.createdNodes[proxyOrderId];
1074             if (existing == null || existing == phiInput) {
1075                 /*
1076                  * We are at the first loop exit, or the proxy carries the same value for all exits.
1077                  * We do not need a phi node yet.
1078                  */
1079                 registerNode(outerScope, proxyOrderId, phiInput, true, false);
1080                 replacement = phiInput;
1081 
<span class="line-modified">1082             } else {</span>
<span class="line-modified">1083                 // Fortify: Suppress Null Dereference false positive</span>
<span class="line-modified">1084                 assert merge != null;</span>
<span class="line-modified">1085 </span>
<span class="line-modified">1086                 if (!merge.isPhiAtMerge(existing)) {</span>
<span class="line-modified">1087                     /* Now we have two different values, so we need to create a phi node. */</span>
<span class="line-modified">1088                     PhiNode phi = proxy.createPhi(merge);</span>
<span class="line-added">1089                     /* Add the inputs from all previous exits. */</span>
<span class="line-added">1090                     for (int j = 0; j &lt; merge.phiPredecessorCount() - 1; j++) {</span>
<span class="line-added">1091                         phi.addInput(existing);</span>
<span class="line-added">1092                     }</span>
<span class="line-added">1093                     /* Add the input from this exit. */</span>
<span class="line-added">1094                     phi.addInput(phiInput);</span>
<span class="line-added">1095                     registerNode(outerScope, proxyOrderId, phi, true, false);</span>
<span class="line-added">1096                     replacement = phi;</span>
<span class="line-added">1097                     phiCreated = true;</span>
<span class="line-added">1098 </span>
1099                 } else {
<span class="line-modified">1100                     /* Phi node has been created before, so just add the new input. */</span>
<span class="line-added">1101                     PhiNode phi = (PhiNode) existing;</span>
<span class="line-added">1102                     phi.addInput(phiInput);</span>
<span class="line-added">1103                     replacement = phi;</span>
1104                 }















1105             }

1106             proxy.replaceAtUsagesAndDelete(replacement);
1107         }
1108 
1109         if (loopExitPlaceholder != null) {
1110             registerNode(loopScope, stateAfterOrderId, null, true, true);
1111             loopExitPlaceholder.setStateAfter((FrameState) ensureNodeCreated(methodScope, loopScope, stateAfterOrderId));
1112         }
1113 
1114         if (merge != null &amp;&amp; (merge.stateAfter() == null || phiCreated)) {
1115             FrameState oldStateAfter = merge.stateAfter();
1116             registerNode(outerScope, stateAfterOrderId, null, true, true);
1117             merge.setStateAfter((FrameState) ensureNodeCreated(methodScope, outerScope, stateAfterOrderId));
1118             if (oldStateAfter != null) {
1119                 oldStateAfter.safeDelete();
1120             }
1121         }
1122         loopExit.safeDelete();
1123         assert loopExitSuccessor.predecessor() == null;
1124         if (merge != null) {
1125             merge.getNodeClass().getSuccessorEdges().update(merge, null, loopExitSuccessor);
</pre>
<hr />
<pre>
1139             int numEnds = ((LoopBeginNode) merge).loopEnds().count();
1140             ((LoopBeginNode) merge).nextEndIndex = numEnds;
1141             ((LoopEndNode) end).endIndex = numEnds - 1;
1142 
1143         } else {
1144             if (merge.ends == null) {
1145                 merge.ends = new NodeInputList&lt;&gt;(merge);
1146             }
1147             merge.addForwardEnd((EndNode) end);
1148         }
1149 
1150         /*
1151          * We create most phi functions lazily. Canonicalization and simplification during decoding
1152          * can lead to dead branches that are not decoded, so we might not need all phi functions
1153          * that the original graph contained. Since we process all predecessors before actually
1154          * processing the merge node, we have the final phi function when processing the merge node.
1155          * The only exception are loop headers of non-exploded loops: since backward branches are
1156          * not processed yet when processing the loop body, we need to create all phi functions
1157          * upfront.
1158          */
<span class="line-modified">1159         boolean lazyPhi = allowLazyPhis() &amp;&amp; (!(merge instanceof LoopBeginNode) || methodScope.loopExplosion.useExplosion());</span>
1160         int numPhis = methodScope.reader.getUVInt();
1161         for (int i = 0; i &lt; numPhis; i++) {
1162             int phiInputOrderId = readOrderId(methodScope);
1163             int phiNodeOrderId = readOrderId(methodScope);
1164 
1165             ValueNode phiInput = (ValueNode) ensureNodeCreated(methodScope, phiInputScope, phiInputOrderId);
1166             ValueNode existing = (ValueNode) lookupNode(phiNodeScope, phiNodeOrderId);
1167 
1168             if (existing != null &amp;&amp; merge.phiPredecessorCount() == 1) {
1169                 /*
1170                  * When exploding loops and the code after the loop (FULL_EXPLODE_UNTIL_RETURN),
1171                  * then an existing value can already be registered: Parsing of the code before the
1172                  * loop registers it when preparing for the later merge. The code after the loop,
1173                  * which starts with a clone of the values that were created before the loop, sees
1174                  * the stale value when processing the merge the first time. We can safely ignore
1175                  * the stale value because it will never be needed to be merged (we are exploding
1176                  * until we hit a return).
1177                  */
<span class="line-modified">1178                 assert methodScope.loopExplosion.duplicateLoopExits() &amp;&amp; phiNodeScope.loopIteration &gt; 0;</span>
1179                 existing = null;
1180             }
1181 
1182             if (lazyPhi &amp;&amp; (existing == null || existing == phiInput)) {
1183                 /* Phi function not yet necessary. */
1184                 registerNode(phiNodeScope, phiNodeOrderId, phiInput, true, false);
1185 
1186             } else if (!merge.isPhiAtMerge(existing)) {
1187                 /*
1188                  * Phi function is necessary. Create it and fill it with existing inputs as well as
1189                  * the new input.
1190                  */
1191                 registerNode(phiNodeScope, phiNodeOrderId, null, true, true);
1192                 PhiNode phi = (PhiNode) ensureNodeCreated(methodScope, phiNodeScope, phiNodeOrderId);
1193 
1194                 phi.setMerge(merge);
1195                 for (int j = 0; j &lt; merge.phiPredecessorCount() - 1; j++) {
1196                     phi.addInput(existing);
1197                 }
1198                 phi.addInput(phiInput);
</pre>
<hr />
<pre>
1513         assert node == null || node.isAlive();
1514         assert allowNull || node != null;
1515         assert allowOverwrite || lookupNode(loopScope, nodeOrderId) == null;
1516         loopScope.createdNodes[nodeOrderId] = node;
1517     }
1518 
1519     protected int readOrderId(MethodScope methodScope) {
1520         return methodScope.reader.getUVInt();
1521     }
1522 
1523     protected Object readObject(MethodScope methodScope) {
1524         return methodScope.encodedGraph.getObject(methodScope.reader.getUVInt());
1525     }
1526 
1527     /**
1528      * Removes unnecessary nodes from the graph after decoding.
1529      *
1530      * @param methodScope The current method.
1531      */
1532     protected void cleanupGraph(MethodScope methodScope) {
<span class="line-added">1533         for (MergeNode merge : graph.getNodes(MergeNode.TYPE)) {</span>
<span class="line-added">1534             for (ProxyPlaceholder placeholder : merge.usages().filter(ProxyPlaceholder.class).snapshot()) {</span>
<span class="line-added">1535                 placeholder.replaceAndDelete(placeholder.value);</span>
<span class="line-added">1536             }</span>
<span class="line-added">1537         }</span>
1538         assert verifyEdges();
1539     }
1540 
1541     protected boolean verifyEdges() {
1542         for (Node node : graph.getNodes()) {
1543             assert node.isAlive();
1544             for (Node i : node.inputs()) {
1545                 assert i.isAlive();
1546                 assert i.usages().contains(node);
1547             }
1548             for (Node s : node.successors()) {
1549                 assert s.isAlive();
1550                 assert s.predecessor() == node;
1551             }
1552 
1553             for (Node usage : node.usages()) {
1554                 assert usage.isAlive();
1555                 assert usage.inputs().contains(node) : node + &quot; / &quot; + usage + &quot; / &quot; + usage.inputs().count();
1556             }
1557             if (node.predecessor() != null) {
</pre>
<hr />
<pre>
1932              * The LoopExit is inserted before the existing merge, i.e., separately for every branch
1933              * that leads to the merge. So for phi functions of the merge, we need to take the input
1934              * that corresponds to our branch.
1935              */
1936             if (realValue instanceof PhiNode &amp;&amp; loopExplosionMerge.isPhiAtMerge(realValue)) {
1937                 value = ((PhiNode) realValue).valueAt(loopExplosionEnd);
1938                 realValue = ProxyPlaceholder.unwrap(value);
1939             }
1940 
1941             if (realValue == null || realValue.isConstant() || loopBeginValues.contains(realValue) || !graph.isNew(methodScope.methodStartMark, realValue)) {
1942                 newValues.add(realValue);
1943             } else {
1944                 /*
1945                  * The node is not in the FrameState of the LoopBegin, i.e., it is a value computed
1946                  * inside the loop.
1947                  */
1948                 GraalError.guarantee(value instanceof ProxyPlaceholder &amp;&amp; ((ProxyPlaceholder) value).proxyPoint == loopExplosionMerge,
1949                                 &quot;Value flowing out of loop, but we are not prepared to insert a ProxyNode&quot;);
1950 
1951                 ProxyPlaceholder proxyPlaceholder = (ProxyPlaceholder) value;
<span class="line-modified">1952                 ValueProxyNode proxy = ProxyNode.forValue(proxyPlaceholder.value, loopExit);</span>
1953                 proxyPlaceholder.setValue(proxy);
1954                 newValues.add(proxy);
1955             }
1956         }
1957 
1958         FrameState newState = new FrameState(oldState.outerFrameState(), oldState.getCode(), oldState.bci, newValues, oldState.localsSize(), oldState.stackSize(), oldState.rethrowException(),
1959                         oldState.duringCall(), oldState.monitorIds(), oldState.virtualObjectMappings());
1960 
1961         assert loopExit.stateAfter() == null;
1962         loopExit.setStateAfter(graph.add(newState));
1963     }
1964 
1965     /**
1966      * Graal does not support irreducible loops (loops with more than one entry point). There are
1967      * two ways to make them reducible: 1) duplicate nodes (peel a loop iteration starting at the
1968      * second entry point until we reach the first entry point), or 2) insert a big outer loop
1969      * covering the whole method and build a state machine for the different loop entry points.
1970      * Since node duplication can lead to an exponential explosion of nodes in the worst case, we
1971      * use the second approach.
1972      *
</pre>
<hr />
<pre>
2000          * loop. There must be exactly one loop variable.
2001          */
2002         int loopVariableIndex = -1;
2003         ValueNode loopValue = null;
2004         ValueNode explosionHeadValue = null;
2005         for (int i = 0; i &lt; loopValues.size(); i++) {
2006             ValueNode curLoopValue = loopValues.get(i);
2007             ValueNode curExplosionHeadValue = explosionHeadValues.get(i);
2008 
2009             if (curLoopValue != curExplosionHeadValue) {
2010                 if (loopVariableIndex != -1) {
2011                     throw bailout(&quot;must have only one variable that is changed in loop. &quot; + loopValue + &quot; != &quot; + explosionHeadValue + &quot; and &quot; + curLoopValue + &quot; != &quot; + curExplosionHeadValue);
2012                 }
2013 
2014                 loopVariableIndex = i;
2015                 loopValue = curLoopValue;
2016                 explosionHeadValue = curExplosionHeadValue;
2017             }
2018         }
2019         assert loopVariableIndex != -1;
<span class="line-added">2020         assert explosionHeadValue != null;</span>
2021 
2022         ValuePhiNode loopVariablePhi;
2023         SortedMap&lt;Integer, AbstractBeginNode&gt; dispatchTable = new TreeMap&lt;&gt;();
2024         AbstractBeginNode unreachableDefaultSuccessor;
2025         if (irreducibleLoopSwitch == null) {
2026             /*
2027              * This is the first irreducible loop. We need to build the initial state machine
2028              * (dispatch for the loop header of the outermost loop).
2029              */
2030             assert !irreducibleLoopHandler.header.isPhiAtMerge(explosionHeadValue);
2031             assert irreducibleLoopHandler.header.phis().isEmpty();
2032 
2033             /* The new phi function for the loop variable. */
2034             loopVariablePhi = graph.addWithoutUnique(new ValuePhiNode(explosionHeadValue.stamp(NodeView.DEFAULT).unrestricted(), irreducibleLoopHandler.header));
2035             for (int i = 0; i &lt; irreducibleLoopHandler.header.phiPredecessorCount(); i++) {
2036                 loopVariablePhi.addInput(explosionHeadValue);
2037             }
2038 
2039             /*
2040              * Build the new FrameState for the loop header. There is only once change in comparison
</pre>
</td>
</tr>
</table>
<center><a href="FrameState.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphEncoder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/InvocationPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InvocationPlugin.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopExplosionPlugin.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/InvocationPlugins.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  29 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  30 import static org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.LateClassPlugins.CLOSED_LATE_CLASS_PLUGIN;
  31 
  32 import java.lang.reflect.Constructor;
  33 import java.lang.reflect.Method;
  34 import java.lang.reflect.Modifier;
  35 import java.lang.reflect.Type;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collections;
  39 import java.util.List;
  40 import java.util.Map;
  41 
  42 import jdk.internal.vm.compiler.collections.EconomicMap;
  43 import jdk.internal.vm.compiler.collections.Equivalence;
  44 import jdk.internal.vm.compiler.collections.MapCursor;
  45 import jdk.internal.vm.compiler.collections.Pair;
  46 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  47 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
  48 import org.graalvm.compiler.api.replacements.MethodSubstitution;
<span class="line-removed">  49 import org.graalvm.compiler.api.replacements.MethodSubstitutionRegistry;</span>
  50 import org.graalvm.compiler.bytecode.BytecodeProvider;
  51 import org.graalvm.compiler.core.common.SuppressFBWarnings;
  52 import org.graalvm.compiler.debug.Assertions;
  53 import org.graalvm.compiler.debug.GraalError;
  54 import org.graalvm.compiler.graph.Node;
  55 import org.graalvm.compiler.graph.iterators.NodeIterable;
  56 import org.graalvm.compiler.nodes.ValueNode;
  57 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;

  58 
  59 import jdk.vm.ci.meta.MetaUtil;
  60 import jdk.vm.ci.meta.ResolvedJavaMethod;
  61 import jdk.vm.ci.meta.ResolvedJavaType;
  62 import jdk.vm.ci.meta.Signature;
  63 
  64 /**
  65  * Manages a set of {@link InvocationPlugin}s.
  66  *
  67  * Most plugins are registered during initialization (i.e., before
  68  * {@link #lookupInvocation(ResolvedJavaMethod)} or {@link #getBindings} is called). These
  69  * registrations can be made with {@link Registration},
  70  * {@link #register(InvocationPlugin, String, String, Type...)},
  71  * {@link #register(InvocationPlugin, Type, String, Type...)} or
  72  * {@link #registerOptional(InvocationPlugin, Type, String, Type...)}. Initialization is not
  73  * thread-safe and so must only be performed by a single thread.
  74  *
  75  * Plugins that are not guaranteed to be made during initialization must use
  76  * {@link LateRegistration}.
  77  */
</pre>
<hr />
<pre>
 158 
 159         /**
 160          * Gets the resolved {@link Class} corresponding to this symbol or {@code null} if
 161          * resolution fails.
 162          */
 163         public Class&lt;?&gt; resolve() {
 164             if (!IS_IN_NATIVE_IMAGE &amp;&amp; resolved == null) {
 165                 Class&lt;?&gt; resolvedOrNull = resolveClass(name, true);
 166                 resolved = resolvedOrNull == null ? MASK_NULL : resolvedOrNull;
 167             }
 168             return resolved == MASK_NULL ? null : resolved;
 169         }
 170 
 171         @Override
 172         public String toString() {
 173             return name;
 174         }
 175     }
 176 
 177     /**
<span class="line-modified"> 178      * Utility for {@linkplain InvocationPlugins#register(InvocationPlugin, Class, String, Class...)</span>
<span class="line-removed"> 179      * registration} of invocation plugins.</span>
 180      */
<span class="line-modified"> 181     public static class Registration implements MethodSubstitutionRegistry {</span>
 182 
 183         private final InvocationPlugins plugins;

 184         private final Type declaringType;
<span class="line-modified"> 185         private final BytecodeProvider methodSubstitutionBytecodeProvider;</span>

 186         private boolean allowOverwrite;
 187 
<span class="line-removed"> 188         @Override</span>
 189         public Class&lt;?&gt; getReceiverType() {
 190             return Receiver.class;
 191         }
 192 




 193         /**
 194          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 195          * given class.
 196          *
 197          * @param plugins where to register the plugins
 198          * @param declaringType the class declaring the methods for which plugins will be registered
 199          *            via this object
 200          */
 201         public Registration(InvocationPlugins plugins, Type declaringType) {
 202             this.plugins = plugins;
 203             this.declaringType = declaringType;
<span class="line-modified"> 204             this.methodSubstitutionBytecodeProvider = null;</span>

 205         }
 206 
 207         /**
 208          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 209          * given class.
 210          *
 211          * @param plugins where to register the plugins
 212          * @param declaringType the class declaring the methods for which plugins will be registered
 213          *            via this object
<span class="line-modified"> 214          * @param methodSubstitutionBytecodeProvider provider used to get the bytecodes to parse for</span>
<span class="line-removed"> 215          *            method substitutions</span>
 216          */
<span class="line-modified"> 217         public Registration(InvocationPlugins plugins, Type declaringType, BytecodeProvider methodSubstitutionBytecodeProvider) {</span>
 218             this.plugins = plugins;
 219             this.declaringType = declaringType;
<span class="line-modified"> 220             this.methodSubstitutionBytecodeProvider = methodSubstitutionBytecodeProvider;</span>

















 221         }
 222 
 223         /**
 224          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 225          * given class.
 226          *
 227          * @param plugins where to register the plugins
 228          * @param declaringClassName the name of the class class declaring the methods for which
 229          *            plugins will be registered via this object
 230          */
 231         public Registration(InvocationPlugins plugins, String declaringClassName) {
 232             this.plugins = plugins;
 233             this.declaringType = new OptionalLazySymbol(declaringClassName);
<span class="line-modified"> 234             this.methodSubstitutionBytecodeProvider = null;</span>

 235         }
 236 
 237         /**
 238          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 239          * given class.
 240          *
 241          * @param plugins where to register the plugins
 242          * @param declaringClassName the name of the class class declaring the methods for which
 243          *            plugins will be registered via this object
<span class="line-modified"> 244          * @param methodSubstitutionBytecodeProvider provider used to get the bytecodes to parse for</span>
<span class="line-removed"> 245          *            method substitutions</span>
 246          */
<span class="line-modified"> 247         public Registration(InvocationPlugins plugins, String declaringClassName, BytecodeProvider methodSubstitutionBytecodeProvider) {</span>
 248             this.plugins = plugins;
 249             this.declaringType = new OptionalLazySymbol(declaringClassName);
<span class="line-modified"> 250             this.methodSubstitutionBytecodeProvider = methodSubstitutionBytecodeProvider;</span>

 251         }
 252 
 253         /**
 254          * Configures this registration to allow or disallow overwriting of invocation plugins.
 255          */
 256         public Registration setAllowOverwrite(boolean allowOverwrite) {
 257             this.allowOverwrite = allowOverwrite;
 258             return this;
 259         }
 260 
 261         /**
 262          * Registers a plugin for a method with no arguments.
 263          *
 264          * @param name the name of the method
 265          * @param plugin the plugin to be registered
 266          */
 267         public void register0(String name, InvocationPlugin plugin) {
 268             plugins.register(plugin, false, allowOverwrite, declaringType, name);
 269         }
 270 
</pre>
<hr />
<pre>
 321         /**
 322          * Registers a plugin for a method with 6 arguments.
 323          *
 324          * @param name the name of the method
 325          * @param plugin the plugin to be registered
 326          */
 327         public void register6(String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, InvocationPlugin plugin) {
 328             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6);
 329         }
 330 
 331         /**
 332          * Registers a plugin for a method with 7 arguments.
 333          *
 334          * @param name the name of the method
 335          * @param plugin the plugin to be registered
 336          */
 337         public void register7(String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, Type arg7, InvocationPlugin plugin) {
 338             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
 339         }
 340 
















































































































 341         /**
 342          * Registers a plugin for an optional method with no arguments.
 343          *
 344          * @param name the name of the method
 345          * @param plugin the plugin to be registered
 346          */
 347         public void registerOptional0(String name, InvocationPlugin plugin) {
 348             plugins.register(plugin, true, allowOverwrite, declaringType, name);
 349         }
 350 
 351         /**
 352          * Registers a plugin for an optional method with 1 argument.
 353          *
 354          * @param name the name of the method
 355          * @param plugin the plugin to be registered
 356          */
 357         public void registerOptional1(String name, Type arg, InvocationPlugin plugin) {
 358             plugins.register(plugin, true, allowOverwrite, declaringType, name, arg);
 359         }
 360 
</pre>
<hr />
<pre>
 381         /**
 382          * Registers a plugin for an optional method with 4 arguments.
 383          *
 384          * @param name the name of the method
 385          * @param plugin the plugin to be registered
 386          */
 387         public void registerOptional4(String name, Type arg1, Type arg2, Type arg3, Type arg4, InvocationPlugin plugin) {
 388             plugins.register(plugin, true, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4);
 389         }
 390 
 391         /**
 392          * Registers a plugin that implements a method based on the bytecode of a substitute method.
 393          *
 394          * @param substituteDeclaringClass the class declaring the substitute method
 395          * @param name the name of both the original and substitute method
 396          * @param argumentTypes the argument types of the method. Element 0 of this array must be
 397          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
 398          *            is non-static. Upon returning, element 0 will have been rewritten to
 399          *            {@code declaringClass}
 400          */
<span class="line-removed"> 401         @Override</span>
 402         public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, Type... argumentTypes) {
 403             registerMethodSubstitution(substituteDeclaringClass, name, name, argumentTypes);
 404         }
 405 
 406         /**
 407          * Registers a plugin that implements a method based on the bytecode of a substitute method.
 408          *
 409          * @param substituteDeclaringClass the class declaring the substitute method
<span class="line-modified"> 410          * @param name the name of both the original method</span>
 411          * @param substituteName the name of the substitute method
 412          * @param argumentTypes the argument types of the method. Element 0 of this array must be
 413          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
 414          *            is non-static. Upon returning, element 0 will have been rewritten to
 415          *            {@code declaringClass}
 416          */
<span class="line-removed"> 417         @Override</span>
 418         public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type... argumentTypes) {
<span class="line-modified"> 419             MethodSubstitutionPlugin plugin = createMethodSubstitution(substituteDeclaringClass, substituteName, argumentTypes);</span>
<span class="line-removed"> 420             plugins.register(plugin, false, allowOverwrite, declaringType, name, argumentTypes);</span>
 421         }
 422 
<span class="line-modified"> 423         public MethodSubstitutionPlugin createMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String substituteName, Type... argumentTypes) {</span>
<span class="line-modified"> 424             assert methodSubstitutionBytecodeProvider != null : &quot;Registration used for method substitutions requires a non-null methodSubstitutionBytecodeProvider&quot;;</span>
<span class="line-modified"> 425             MethodSubstitutionPlugin plugin = new MethodSubstitutionPlugin(methodSubstitutionBytecodeProvider, substituteDeclaringClass, substituteName, argumentTypes);</span>
<span class="line-modified"> 426             return plugin;</span>





























 427         }
 428 











 429     }
 430 
 431     /**
 432      * Utility for registering plugins after Graal may have been initialized. Registrations made via
 433      * this class are not finalized until {@link #close} is called.
 434      */
 435     public static class LateRegistration implements AutoCloseable {
 436 
 437         private InvocationPlugins plugins;
 438         private final List&lt;Binding&gt; bindings = new ArrayList&lt;&gt;();
 439         private final Type declaringType;
 440 
 441         /**
 442          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 443          * given class.
 444          *
 445          * @param plugins where to register the plugins
 446          * @param declaringType the class declaring the methods for which plugins will be registered
 447          *            via this object
 448          */
</pre>
<hr />
<pre>
 502          */
 503         public final String name;
 504 
 505         /**
 506          * A partial
 507          * &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.3&quot;&gt;method
 508          * descriptor&lt;/a&gt; for the associated method. The descriptor includes enclosing {@code &#39;(&#39;}
 509          * and {@code &#39;)&#39;} characters but omits the return type suffix.
 510          */
 511         public final String argumentsDescriptor;
 512 
 513         /**
 514          * Link in a list of bindings.
 515          */
 516         private Binding next;
 517 
 518         Binding(InvocationPlugin data, boolean isStatic, String name, Type... argumentTypes) {
 519             this.plugin = data;
 520             this.isStatic = isStatic;
 521             this.name = name;
<span class="line-modified"> 522             StringBuilder buf = new StringBuilder();</span>
<span class="line-removed"> 523             buf.append(&#39;(&#39;);</span>
<span class="line-removed"> 524             for (int i = isStatic ? 0 : 1; i &lt; argumentTypes.length; i++) {</span>
<span class="line-removed"> 525                 buf.append(MetaUtil.toInternalName(argumentTypes[i].getTypeName()));</span>
<span class="line-removed"> 526             }</span>
<span class="line-removed"> 527             buf.append(&#39;)&#39;);</span>
<span class="line-removed"> 528             this.argumentsDescriptor = buf.toString();</span>
 529             assert !name.equals(&quot;&lt;init&gt;&quot;) || !isStatic : this;
 530         }
 531 
 532         Binding(ResolvedJavaMethod resolved, InvocationPlugin data) {
 533             this.plugin = data;
 534             this.isStatic = resolved.isStatic();
 535             this.name = resolved.getName();
 536             Signature sig = resolved.getSignature();
 537             String desc = sig.toMethodDescriptor();
 538             assert desc.indexOf(&#39;)&#39;) != -1 : desc;
 539             this.argumentsDescriptor = desc.substring(0, desc.indexOf(&#39;)&#39;) + 1);
 540             assert !name.equals(&quot;&lt;init&gt;&quot;) || !isStatic : this;
 541         }
 542 
 543         @Override
 544         public String toString() {
 545             return name + argumentsDescriptor;
 546         }
 547     }
 548 










 549     /**
 550      * Plugin registrations for already resolved methods. If non-null, then {@link #registrations}
 551      * is null and no further registrations can be made.
 552      */
 553     private final UnmodifiableEconomicMap&lt;ResolvedJavaMethod, InvocationPlugin&gt; resolvedRegistrations;
 554 
 555     /**
 556      * Map from class names in {@linkplain MetaUtil#toInternalName(String) internal} form to the
 557      * invocation plugin bindings for the class. Tf non-null, then {@link #resolvedRegistrations}
 558      * will be null.
 559      */
 560     private final EconomicMap&lt;String, ClassPlugins&gt; registrations;
 561 
 562     /**
 563      * Deferred registrations as well as the guard for delimiting the initial registration phase.
 564      * The guard uses double-checked locking which is why this field is {@code volatile}.
 565      */
 566     private volatile List&lt;Runnable&gt; deferredRegistrations = new ArrayList&lt;&gt;();
 567 
 568     /**
</pre>
<hr />
<pre>
 685         if (resolvedRegistrations != null) {
 686             return resolvedRegistrations.get(method);
 687         } else {
 688             if (!method.isBridge()) {
 689                 ResolvedJavaType declaringClass = method.getDeclaringClass();
 690                 flushDeferrables();
 691                 String internalName = declaringClass.getName();
 692                 ClassPlugins classPlugins = registrations.get(internalName);
 693                 InvocationPlugin res = null;
 694                 if (classPlugins != null) {
 695                     res = classPlugins.get(method);
 696                 }
 697                 if (res == null) {
 698                     LateClassPlugins lcp = findLateClassPlugins(internalName);
 699                     if (lcp != null) {
 700                         res = lcp.get(method);
 701                     }
 702                 }
 703                 if (res != null) {
 704                     // A decorator plugin is trusted since it does not replace
<span class="line-modified"> 705                     // the method it intrinsifies.</span>
<span class="line-modified"> 706                     if (res.isDecorator() || canBeIntrinsified(declaringClass)) {</span>


 707                         return res;
 708                     }
 709                 }
 710                 if (testExtensions != null) {
 711                     // Avoid the synchronization in the common case that there
 712                     // are no test extensions.
 713                     synchronized (this) {
 714                         if (testExtensions != null) {
 715                             List&lt;Binding&gt; bindings = testExtensions.get(internalName);
 716                             if (bindings != null) {
 717                                 String name = method.getName();
 718                                 String descriptor = method.getSignature().toMethodDescriptor();
 719                                 for (Binding b : bindings) {
 720                                     if (b.isStatic == method.isStatic() &amp;&amp;
 721                                                     b.name.equals(name) &amp;&amp;
 722                                                     descriptor.startsWith(b.argumentsDescriptor)) {
 723                                         return b.plugin;
 724                                     }
 725                                 }
 726                             }
</pre>
<hr />
<pre>
1006      *
1007      * @param argumentTypes the argument types of the method. Element 0 of this array must be the
1008      *            {@link Class} value for {@link InvocationPlugin.Receiver} iff the method is
1009      *            non-static. Upon returning, element 0 will have been rewritten to
1010      *            {@code declaringClass}
1011      */
1012     public final void registerOptional(InvocationPlugin plugin, Type declaringClass, String name, Type... argumentTypes) {
1013         register(plugin, true, false, declaringClass, name, argumentTypes);
1014     }
1015 
1016     /**
1017      * Gets the plugin for a given method.
1018      *
1019      * @param method the method to lookup
1020      * @return the plugin associated with {@code method} or {@code null} if none exists
1021      */
1022     public InvocationPlugin lookupInvocation(ResolvedJavaMethod method) {
1023         if (parent != null) {
1024             InvocationPlugin plugin = parent.lookupInvocation(method);
1025             if (plugin != null) {
<span class="line-removed">1026                 if (IS_IN_NATIVE_IMAGE &amp;&amp; plugin instanceof MethodSubstitutionPlugin) {</span>
<span class="line-removed">1027                     // Disable method substitutions until GR-13607</span>
<span class="line-removed">1028                     return null;</span>
<span class="line-removed">1029                 }</span>
1030                 return plugin;
1031             }
1032         }
1033         InvocationPlugin invocationPlugin = get(method);
<span class="line-removed">1034         if (IS_IN_NATIVE_IMAGE &amp;&amp; invocationPlugin instanceof MethodSubstitutionPlugin) {</span>
<span class="line-removed">1035             // Disable method substitutions until GR-13607</span>
<span class="line-removed">1036             return null;</span>
<span class="line-removed">1037         }</span>
1038         return invocationPlugin;
1039     }
1040 
1041     /**
1042      * Gets the set of registered invocation plugins.
1043      *
1044      * @return a map from class names in {@linkplain MetaUtil#toInternalName(String) internal} form
1045      *         to the invocation plugin bindings for methods in the class
1046      */
1047     public EconomicMap&lt;String, List&lt;Binding&gt;&gt; getBindings(boolean includeParents) {
1048         return getBindings(includeParents, true);
1049     }
1050 
1051     /**
1052      * Gets the set of registered invocation plugins.
1053      *
1054      * @return a map from class names in {@linkplain MetaUtil#toInternalName(String) internal} form
1055      *         to the invocation plugin bindings for methods in the class
1056      */
1057     private EconomicMap&lt;String, List&lt;Binding&gt;&gt; getBindings(boolean includeParents, boolean flushDeferrables) {
</pre>
<hr />
<pre>
1215                 assert substitute.getAnnotation(MethodSubstitution.class) != null : format(&quot;Substitute method must be annotated with @%s: %s&quot;, MethodSubstitution.class.getSimpleName(), substitute);
1216                 return true;
1217             }
1218             int arguments = parseParameters(binding.argumentsDescriptor).size();
1219             assert arguments &lt; SIGS.length : format(&quot;need to extend %s to support method with %d arguments: %s&quot;, InvocationPlugin.class.getSimpleName(), arguments, binding);
1220             for (Method m : plugin.getClass().getDeclaredMethods()) {
1221                 if (m.getName().equals(&quot;apply&quot;)) {
1222                     Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();
1223                     if (Arrays.equals(SIGS[arguments], parameterTypes)) {
1224                         return true;
1225                     }
1226                 }
1227             }
1228             throw new AssertionError(format(&quot;graph builder plugin for %s not found&quot;, binding));
1229         }
1230 
1231         static boolean checkResolvable(boolean isOptional, Type declaringType, Binding binding) {
1232             if (declaringType instanceof ResolvedJavaSymbol) {
1233                 return checkResolvable(isOptional, ((ResolvedJavaSymbol) declaringType).getResolved(), binding);
1234             }
<span class="line-modified">1235             Class&lt;?&gt; declaringClass = InvocationPlugins.resolveType(declaringType, isOptional);</span>
1236             if (declaringClass == null) {
1237                 return true;
1238             }
1239             if (binding.name.equals(&quot;&lt;init&gt;&quot;)) {
1240                 if (resolveConstructor(declaringClass, binding) == null &amp;&amp; !isOptional) {
1241                     throw new AssertionError(String.format(&quot;Constructor not found: %s%s&quot;, declaringClass.getName(), binding.argumentsDescriptor));
1242                 }
1243             } else {
1244                 if (resolveMethod(declaringClass, binding) == null &amp;&amp; !isOptional) {
<span class="line-modified">1245                     throw new AssertionError(String.format(&quot;Method not found: %s.%s%s&quot;, declaringClass.getName(), binding.name, binding.argumentsDescriptor));</span>
1246                 }
1247             }
1248             return true;
1249         }
1250 
1251         private static boolean checkResolvable(boolean isOptional, ResolvedJavaType declaringType, Binding binding) {
1252             if (resolveJavaMethod(declaringType, binding) == null &amp;&amp; !isOptional) {
1253                 throw new AssertionError(String.format(&quot;Method not found: %s.%s%s&quot;, declaringType.toJavaName(), binding.name, binding.argumentsDescriptor));
1254             }
1255             return true;
1256         }
1257     }
1258 
1259     /**
1260      * Checks a set of nodes added to the graph by an {@link InvocationPlugin}.
1261      *
1262      * @param b the graph builder that applied the plugin
1263      * @param plugin a plugin that was just applied
1264      * @param newNodes the nodes added to the graph by {@code plugin}
1265      * @throws AssertionError if any check fail
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  29 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  30 import static org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.LateClassPlugins.CLOSED_LATE_CLASS_PLUGIN;
  31 
  32 import java.lang.reflect.Constructor;
  33 import java.lang.reflect.Method;
  34 import java.lang.reflect.Modifier;
  35 import java.lang.reflect.Type;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collections;
  39 import java.util.List;
  40 import java.util.Map;
  41 
  42 import jdk.internal.vm.compiler.collections.EconomicMap;
  43 import jdk.internal.vm.compiler.collections.Equivalence;
  44 import jdk.internal.vm.compiler.collections.MapCursor;
  45 import jdk.internal.vm.compiler.collections.Pair;
  46 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  47 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
  48 import org.graalvm.compiler.api.replacements.MethodSubstitution;

  49 import org.graalvm.compiler.bytecode.BytecodeProvider;
  50 import org.graalvm.compiler.core.common.SuppressFBWarnings;
  51 import org.graalvm.compiler.debug.Assertions;
  52 import org.graalvm.compiler.debug.GraalError;
  53 import org.graalvm.compiler.graph.Node;
  54 import org.graalvm.compiler.graph.iterators.NodeIterable;
  55 import org.graalvm.compiler.nodes.ValueNode;
  56 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
<span class="line-added">  57 import org.graalvm.compiler.nodes.spi.Replacements;</span>
  58 
  59 import jdk.vm.ci.meta.MetaUtil;
  60 import jdk.vm.ci.meta.ResolvedJavaMethod;
  61 import jdk.vm.ci.meta.ResolvedJavaType;
  62 import jdk.vm.ci.meta.Signature;
  63 
  64 /**
  65  * Manages a set of {@link InvocationPlugin}s.
  66  *
  67  * Most plugins are registered during initialization (i.e., before
  68  * {@link #lookupInvocation(ResolvedJavaMethod)} or {@link #getBindings} is called). These
  69  * registrations can be made with {@link Registration},
  70  * {@link #register(InvocationPlugin, String, String, Type...)},
  71  * {@link #register(InvocationPlugin, Type, String, Type...)} or
  72  * {@link #registerOptional(InvocationPlugin, Type, String, Type...)}. Initialization is not
  73  * thread-safe and so must only be performed by a single thread.
  74  *
  75  * Plugins that are not guaranteed to be made during initialization must use
  76  * {@link LateRegistration}.
  77  */
</pre>
<hr />
<pre>
 158 
 159         /**
 160          * Gets the resolved {@link Class} corresponding to this symbol or {@code null} if
 161          * resolution fails.
 162          */
 163         public Class&lt;?&gt; resolve() {
 164             if (!IS_IN_NATIVE_IMAGE &amp;&amp; resolved == null) {
 165                 Class&lt;?&gt; resolvedOrNull = resolveClass(name, true);
 166                 resolved = resolvedOrNull == null ? MASK_NULL : resolvedOrNull;
 167             }
 168             return resolved == MASK_NULL ? null : resolved;
 169         }
 170 
 171         @Override
 172         public String toString() {
 173             return name;
 174         }
 175     }
 176 
 177     /**
<span class="line-modified"> 178      * Utility for {@linkplain InvocationPlugins#register registration} of invocation plugins.</span>

 179      */
<span class="line-modified"> 180     public static class Registration {</span>
 181 
 182         private final InvocationPlugins plugins;
<span class="line-added"> 183 </span>
 184         private final Type declaringType;
<span class="line-modified"> 185         private final Replacements replacements;</span>
<span class="line-added"> 186         private final BytecodeProvider bytecodeProvider;</span>
 187         private boolean allowOverwrite;
 188 

 189         public Class&lt;?&gt; getReceiverType() {
 190             return Receiver.class;
 191         }
 192 
<span class="line-added"> 193         public Type getDeclaringType() {</span>
<span class="line-added"> 194             return declaringType;</span>
<span class="line-added"> 195         }</span>
<span class="line-added"> 196 </span>
 197         /**
 198          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 199          * given class.
 200          *
 201          * @param plugins where to register the plugins
 202          * @param declaringType the class declaring the methods for which plugins will be registered
 203          *            via this object
 204          */
 205         public Registration(InvocationPlugins plugins, Type declaringType) {
 206             this.plugins = plugins;
 207             this.declaringType = declaringType;
<span class="line-modified"> 208             this.replacements = null;</span>
<span class="line-added"> 209             this.bytecodeProvider = null;</span>
 210         }
 211 
 212         /**
 213          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 214          * given class.
 215          *
 216          * @param plugins where to register the plugins
 217          * @param declaringType the class declaring the methods for which plugins will be registered
 218          *            via this object
<span class="line-modified"> 219          * @param replacements the current Replacements provider</span>

 220          */
<span class="line-modified"> 221         public Registration(InvocationPlugins plugins, Type declaringType, Replacements replacements) {</span>
 222             this.plugins = plugins;
 223             this.declaringType = declaringType;
<span class="line-modified"> 224             this.replacements = replacements;</span>
<span class="line-added"> 225             this.bytecodeProvider = replacements != null ? replacements.getDefaultReplacementBytecodeProvider() : null;</span>
<span class="line-added"> 226         }</span>
<span class="line-added"> 227 </span>
<span class="line-added"> 228         /**</span>
<span class="line-added"> 229          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a</span>
<span class="line-added"> 230          * given class.</span>
<span class="line-added"> 231          *</span>
<span class="line-added"> 232          * @param plugins where to register the plugins</span>
<span class="line-added"> 233          * @param declaringType the class declaring the methods for which plugins will be registered</span>
<span class="line-added"> 234          *            via this object</span>
<span class="line-added"> 235          * @param replacements the current Replacements provider</span>
<span class="line-added"> 236          */</span>
<span class="line-added"> 237         public Registration(InvocationPlugins plugins, Type declaringType, Replacements replacements, BytecodeProvider bytecodeProvider) {</span>
<span class="line-added"> 238             this.plugins = plugins;</span>
<span class="line-added"> 239             this.declaringType = declaringType;</span>
<span class="line-added"> 240             this.replacements = replacements;</span>
<span class="line-added"> 241             this.bytecodeProvider = bytecodeProvider;</span>
 242         }
 243 
 244         /**
 245          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 246          * given class.
 247          *
 248          * @param plugins where to register the plugins
 249          * @param declaringClassName the name of the class class declaring the methods for which
 250          *            plugins will be registered via this object
 251          */
 252         public Registration(InvocationPlugins plugins, String declaringClassName) {
 253             this.plugins = plugins;
 254             this.declaringType = new OptionalLazySymbol(declaringClassName);
<span class="line-modified"> 255             this.replacements = null;</span>
<span class="line-added"> 256             this.bytecodeProvider = null;</span>
 257         }
 258 
 259         /**
 260          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 261          * given class.
 262          *
 263          * @param plugins where to register the plugins
 264          * @param declaringClassName the name of the class class declaring the methods for which
 265          *            plugins will be registered via this object
<span class="line-modified"> 266          * @param replacements the current Replacements provider</span>

 267          */
<span class="line-modified"> 268         public Registration(InvocationPlugins plugins, String declaringClassName, Replacements replacements) {</span>
 269             this.plugins = plugins;
 270             this.declaringType = new OptionalLazySymbol(declaringClassName);
<span class="line-modified"> 271             this.replacements = replacements;</span>
<span class="line-added"> 272             this.bytecodeProvider = replacements != null ? replacements.getDefaultReplacementBytecodeProvider() : null;</span>
 273         }
 274 
 275         /**
 276          * Configures this registration to allow or disallow overwriting of invocation plugins.
 277          */
 278         public Registration setAllowOverwrite(boolean allowOverwrite) {
 279             this.allowOverwrite = allowOverwrite;
 280             return this;
 281         }
 282 
 283         /**
 284          * Registers a plugin for a method with no arguments.
 285          *
 286          * @param name the name of the method
 287          * @param plugin the plugin to be registered
 288          */
 289         public void register0(String name, InvocationPlugin plugin) {
 290             plugins.register(plugin, false, allowOverwrite, declaringType, name);
 291         }
 292 
</pre>
<hr />
<pre>
 343         /**
 344          * Registers a plugin for a method with 6 arguments.
 345          *
 346          * @param name the name of the method
 347          * @param plugin the plugin to be registered
 348          */
 349         public void register6(String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, InvocationPlugin plugin) {
 350             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6);
 351         }
 352 
 353         /**
 354          * Registers a plugin for a method with 7 arguments.
 355          *
 356          * @param name the name of the method
 357          * @param plugin the plugin to be registered
 358          */
 359         public void register7(String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, Type arg7, InvocationPlugin plugin) {
 360             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
 361         }
 362 
<span class="line-added"> 363         /**</span>
<span class="line-added"> 364          * Registers a plugin for a method with no arguments that is conditionally enabled. This</span>
<span class="line-added"> 365          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added"> 366          *</span>
<span class="line-added"> 367          * @param name the name of the method</span>
<span class="line-added"> 368          * @param plugin the plugin to be registered</span>
<span class="line-added"> 369          */</span>
<span class="line-added"> 370         public void registerConditional0(boolean isEnabled, String name, InvocationPlugin plugin) {</span>
<span class="line-added"> 371             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added"> 372             if (isEnabled) {</span>
<span class="line-added"> 373                 plugins.register(plugin, false, allowOverwrite, declaringType, name);</span>
<span class="line-added"> 374             }</span>
<span class="line-added"> 375         }</span>
<span class="line-added"> 376 </span>
<span class="line-added"> 377         /**</span>
<span class="line-added"> 378          * Registers a plugin for a method with 1 argument that is conditionally enabled. This</span>
<span class="line-added"> 379          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added"> 380          *</span>
<span class="line-added"> 381          * @param name the name of the method</span>
<span class="line-added"> 382          * @param plugin the plugin to be registered</span>
<span class="line-added"> 383          */</span>
<span class="line-added"> 384         public void registerConditional1(boolean isEnabled, String name, Type arg, InvocationPlugin plugin) {</span>
<span class="line-added"> 385             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added"> 386             if (isEnabled) {</span>
<span class="line-added"> 387                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg);</span>
<span class="line-added"> 388             }</span>
<span class="line-added"> 389         }</span>
<span class="line-added"> 390 </span>
<span class="line-added"> 391         /**</span>
<span class="line-added"> 392          * Registers a plugin for a method with 2 arguments that is conditionally enabled. This</span>
<span class="line-added"> 393          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added"> 394          *</span>
<span class="line-added"> 395          * @param name the name of the method</span>
<span class="line-added"> 396          * @param plugin the plugin to be registered</span>
<span class="line-added"> 397          */</span>
<span class="line-added"> 398         public void registerConditional2(boolean isEnabled, String name, Type arg1, Type arg2, InvocationPlugin plugin) {</span>
<span class="line-added"> 399             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added"> 400             if (isEnabled) {</span>
<span class="line-added"> 401                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2);</span>
<span class="line-added"> 402             }</span>
<span class="line-added"> 403         }</span>
<span class="line-added"> 404 </span>
<span class="line-added"> 405         /**</span>
<span class="line-added"> 406          * Registers a plugin for a method with 3 arguments that is conditionally enabled. This</span>
<span class="line-added"> 407          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added"> 408          *</span>
<span class="line-added"> 409          * @param name the name of the method</span>
<span class="line-added"> 410          * @param plugin the plugin to be registered</span>
<span class="line-added"> 411          */</span>
<span class="line-added"> 412         public void registerConditional3(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, InvocationPlugin plugin) {</span>
<span class="line-added"> 413             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added"> 414             if (isEnabled) {</span>
<span class="line-added"> 415                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3);</span>
<span class="line-added"> 416             }</span>
<span class="line-added"> 417         }</span>
<span class="line-added"> 418 </span>
<span class="line-added"> 419         /**</span>
<span class="line-added"> 420          * Registers a plugin for a method with 4 arguments that is conditionally enabled. This</span>
<span class="line-added"> 421          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added"> 422          *</span>
<span class="line-added"> 423          * @param name the name of the method</span>
<span class="line-added"> 424          * @param plugin the plugin to be registered</span>
<span class="line-added"> 425          */</span>
<span class="line-added"> 426         public void registerConditional4(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, Type arg4, InvocationPlugin plugin) {</span>
<span class="line-added"> 427             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added"> 428             if (isEnabled) {</span>
<span class="line-added"> 429                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4);</span>
<span class="line-added"> 430             }</span>
<span class="line-added"> 431         }</span>
<span class="line-added"> 432 </span>
<span class="line-added"> 433         /**</span>
<span class="line-added"> 434          * Registers a plugin for a method with 5 arguments that is conditionally enabled. This</span>
<span class="line-added"> 435          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added"> 436          *</span>
<span class="line-added"> 437          * @param name the name of the method</span>
<span class="line-added"> 438          * @param plugin the plugin to be registered</span>
<span class="line-added"> 439          */</span>
<span class="line-added"> 440         public void registerConditional5(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, InvocationPlugin plugin) {</span>
<span class="line-added"> 441             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added"> 442             if (isEnabled) {</span>
<span class="line-added"> 443                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5);</span>
<span class="line-added"> 444             }</span>
<span class="line-added"> 445         }</span>
<span class="line-added"> 446 </span>
<span class="line-added"> 447         /**</span>
<span class="line-added"> 448          * Registers a plugin for a method with 6 arguments that is conditionally enabled. This</span>
<span class="line-added"> 449          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added"> 450          *</span>
<span class="line-added"> 451          * @param name the name of the method</span>
<span class="line-added"> 452          * @param plugin the plugin to be registered</span>
<span class="line-added"> 453          */</span>
<span class="line-added"> 454         public void registerConditional6(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, InvocationPlugin plugin) {</span>
<span class="line-added"> 455             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added"> 456             if (isEnabled) {</span>
<span class="line-added"> 457                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6);</span>
<span class="line-added"> 458             }</span>
<span class="line-added"> 459         }</span>
<span class="line-added"> 460 </span>
<span class="line-added"> 461         /**</span>
<span class="line-added"> 462          * Registers a plugin for a method with 7 arguments that is conditionally enabled. This</span>
<span class="line-added"> 463          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added"> 464          *</span>
<span class="line-added"> 465          * @param name the name of the method</span>
<span class="line-added"> 466          * @param plugin the plugin to be registered</span>
<span class="line-added"> 467          */</span>
<span class="line-added"> 468         public void registerConditional7(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, Type arg7, InvocationPlugin plugin) {</span>
<span class="line-added"> 469             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added"> 470             if (isEnabled) {</span>
<span class="line-added"> 471                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7);</span>
<span class="line-added"> 472             }</span>
<span class="line-added"> 473         }</span>
<span class="line-added"> 474 </span>
 475         /**
 476          * Registers a plugin for an optional method with no arguments.
 477          *
 478          * @param name the name of the method
 479          * @param plugin the plugin to be registered
 480          */
 481         public void registerOptional0(String name, InvocationPlugin plugin) {
 482             plugins.register(plugin, true, allowOverwrite, declaringType, name);
 483         }
 484 
 485         /**
 486          * Registers a plugin for an optional method with 1 argument.
 487          *
 488          * @param name the name of the method
 489          * @param plugin the plugin to be registered
 490          */
 491         public void registerOptional1(String name, Type arg, InvocationPlugin plugin) {
 492             plugins.register(plugin, true, allowOverwrite, declaringType, name, arg);
 493         }
 494 
</pre>
<hr />
<pre>
 515         /**
 516          * Registers a plugin for an optional method with 4 arguments.
 517          *
 518          * @param name the name of the method
 519          * @param plugin the plugin to be registered
 520          */
 521         public void registerOptional4(String name, Type arg1, Type arg2, Type arg3, Type arg4, InvocationPlugin plugin) {
 522             plugins.register(plugin, true, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4);
 523         }
 524 
 525         /**
 526          * Registers a plugin that implements a method based on the bytecode of a substitute method.
 527          *
 528          * @param substituteDeclaringClass the class declaring the substitute method
 529          * @param name the name of both the original and substitute method
 530          * @param argumentTypes the argument types of the method. Element 0 of this array must be
 531          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
 532          *            is non-static. Upon returning, element 0 will have been rewritten to
 533          *            {@code declaringClass}
 534          */

 535         public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, Type... argumentTypes) {
 536             registerMethodSubstitution(substituteDeclaringClass, name, name, argumentTypes);
 537         }
 538 
 539         /**
 540          * Registers a plugin that implements a method based on the bytecode of a substitute method.
 541          *
 542          * @param substituteDeclaringClass the class declaring the substitute method
<span class="line-modified"> 543          * @param name the name of the original method</span>
 544          * @param substituteName the name of the substitute method
 545          * @param argumentTypes the argument types of the method. Element 0 of this array must be
 546          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
 547          *            is non-static. Upon returning, element 0 will have been rewritten to
 548          *            {@code declaringClass}
 549          */

 550         public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type... argumentTypes) {
<span class="line-modified"> 551             doMethodSubstitutionRegistration(false, true, substituteDeclaringClass, name, substituteName, argumentTypes);</span>

 552         }
 553 
<span class="line-modified"> 554         /**</span>
<span class="line-modified"> 555          * Registers a plugin that implements a method based on the bytecode of a substitute method</span>
<span class="line-modified"> 556          * that is conditinally enabled. This ensures that {@code Replacements} is aware of this</span>
<span class="line-modified"> 557          * plugin.</span>
<span class="line-added"> 558          *</span>
<span class="line-added"> 559          * @param isEnabled whether the plugin is enabled in the current compiler</span>
<span class="line-added"> 560          * @param substituteDeclaringClass the class declaring the substitute method</span>
<span class="line-added"> 561          * @param name the name of both the original and substitute method</span>
<span class="line-added"> 562          * @param argumentTypes the argument types of the method. Element 0 of this array must be</span>
<span class="line-added"> 563          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method</span>
<span class="line-added"> 564          *            is non-static. Upon returning, element 0 will have been rewritten to</span>
<span class="line-added"> 565          *            {@code declaringClass}</span>
<span class="line-added"> 566          */</span>
<span class="line-added"> 567         public void registerConditionalMethodSubstitution(boolean isEnabled, Class&lt;?&gt; substituteDeclaringClass, String name, Type... argumentTypes) {</span>
<span class="line-added"> 568             registerConditionalMethodSubstitution(isEnabled, substituteDeclaringClass, name, name, argumentTypes);</span>
<span class="line-added"> 569         }</span>
<span class="line-added"> 570 </span>
<span class="line-added"> 571         /**</span>
<span class="line-added"> 572          * Registers a plugin that implements a method based on the bytecode of a substitute method</span>
<span class="line-added"> 573          * that is conditinally enabled. This ensures that {@code Replacements} is aware of this</span>
<span class="line-added"> 574          * plugin.</span>
<span class="line-added"> 575          *</span>
<span class="line-added"> 576          * @param isEnabled whether the plugin is enabled in the current compiler</span>
<span class="line-added"> 577          * @param substituteDeclaringClass the class declaring the substitute method</span>
<span class="line-added"> 578          * @param name the name of the original method</span>
<span class="line-added"> 579          * @param substituteName the name of the substitute method</span>
<span class="line-added"> 580          * @param argumentTypes the argument types of the method. Element 0 of this array must be</span>
<span class="line-added"> 581          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method</span>
<span class="line-added"> 582          *            is non-static. Upon returning, element 0 will have been rewritten to</span>
<span class="line-added"> 583          *            {@code declaringClass}</span>
<span class="line-added"> 584          */</span>
<span class="line-added"> 585         public void registerConditionalMethodSubstitution(boolean isEnabled, Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type... argumentTypes) {</span>
<span class="line-added"> 586             doMethodSubstitutionRegistration(true, isEnabled, substituteDeclaringClass, name, substituteName, argumentTypes);</span>
 587         }
 588 
<span class="line-added"> 589         private void doMethodSubstitutionRegistration(boolean isConditional, boolean isEnabled, Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type[] argumentTypes) {</span>
<span class="line-added"> 590             MethodSubstitutionPlugin plugin = new MethodSubstitutionPlugin(this, bytecodeProvider, name, substituteDeclaringClass, substituteName, argumentTypes);</span>
<span class="line-added"> 591             replacements.registerMethodSubstitution(plugin);</span>
<span class="line-added"> 592             if (isConditional) {</span>
<span class="line-added"> 593                 // Notify Replacements about the plugin even if it&#39;s not current enabled</span>
<span class="line-added"> 594                 replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added"> 595             }</span>
<span class="line-added"> 596             if (isEnabled) {</span>
<span class="line-added"> 597                 plugins.register(plugin, false, allowOverwrite, declaringType, name, argumentTypes);</span>
<span class="line-added"> 598             }</span>
<span class="line-added"> 599         }</span>
 600     }
 601 
 602     /**
 603      * Utility for registering plugins after Graal may have been initialized. Registrations made via
 604      * this class are not finalized until {@link #close} is called.
 605      */
 606     public static class LateRegistration implements AutoCloseable {
 607 
 608         private InvocationPlugins plugins;
 609         private final List&lt;Binding&gt; bindings = new ArrayList&lt;&gt;();
 610         private final Type declaringType;
 611 
 612         /**
 613          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 614          * given class.
 615          *
 616          * @param plugins where to register the plugins
 617          * @param declaringType the class declaring the methods for which plugins will be registered
 618          *            via this object
 619          */
</pre>
<hr />
<pre>
 673          */
 674         public final String name;
 675 
 676         /**
 677          * A partial
 678          * &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.3&quot;&gt;method
 679          * descriptor&lt;/a&gt; for the associated method. The descriptor includes enclosing {@code &#39;(&#39;}
 680          * and {@code &#39;)&#39;} characters but omits the return type suffix.
 681          */
 682         public final String argumentsDescriptor;
 683 
 684         /**
 685          * Link in a list of bindings.
 686          */
 687         private Binding next;
 688 
 689         Binding(InvocationPlugin data, boolean isStatic, String name, Type... argumentTypes) {
 690             this.plugin = data;
 691             this.isStatic = isStatic;
 692             this.name = name;
<span class="line-modified"> 693             this.argumentsDescriptor = toArgumentDescriptor(isStatic, argumentTypes);</span>






 694             assert !name.equals(&quot;&lt;init&gt;&quot;) || !isStatic : this;
 695         }
 696 
 697         Binding(ResolvedJavaMethod resolved, InvocationPlugin data) {
 698             this.plugin = data;
 699             this.isStatic = resolved.isStatic();
 700             this.name = resolved.getName();
 701             Signature sig = resolved.getSignature();
 702             String desc = sig.toMethodDescriptor();
 703             assert desc.indexOf(&#39;)&#39;) != -1 : desc;
 704             this.argumentsDescriptor = desc.substring(0, desc.indexOf(&#39;)&#39;) + 1);
 705             assert !name.equals(&quot;&lt;init&gt;&quot;) || !isStatic : this;
 706         }
 707 
 708         @Override
 709         public String toString() {
 710             return name + argumentsDescriptor;
 711         }
 712     }
 713 
<span class="line-added"> 714     static String toArgumentDescriptor(boolean isStatic, Type[] argumentTypes) {</span>
<span class="line-added"> 715         StringBuilder buf = new StringBuilder();</span>
<span class="line-added"> 716         buf.append(&#39;(&#39;);</span>
<span class="line-added"> 717         for (int i = isStatic ? 0 : 1; i &lt; argumentTypes.length; i++) {</span>
<span class="line-added"> 718             buf.append(MetaUtil.toInternalName(argumentTypes[i].getTypeName()));</span>
<span class="line-added"> 719         }</span>
<span class="line-added"> 720         buf.append(&#39;)&#39;);</span>
<span class="line-added"> 721         return buf.toString();</span>
<span class="line-added"> 722     }</span>
<span class="line-added"> 723 </span>
 724     /**
 725      * Plugin registrations for already resolved methods. If non-null, then {@link #registrations}
 726      * is null and no further registrations can be made.
 727      */
 728     private final UnmodifiableEconomicMap&lt;ResolvedJavaMethod, InvocationPlugin&gt; resolvedRegistrations;
 729 
 730     /**
 731      * Map from class names in {@linkplain MetaUtil#toInternalName(String) internal} form to the
 732      * invocation plugin bindings for the class. Tf non-null, then {@link #resolvedRegistrations}
 733      * will be null.
 734      */
 735     private final EconomicMap&lt;String, ClassPlugins&gt; registrations;
 736 
 737     /**
 738      * Deferred registrations as well as the guard for delimiting the initial registration phase.
 739      * The guard uses double-checked locking which is why this field is {@code volatile}.
 740      */
 741     private volatile List&lt;Runnable&gt; deferredRegistrations = new ArrayList&lt;&gt;();
 742 
 743     /**
</pre>
<hr />
<pre>
 860         if (resolvedRegistrations != null) {
 861             return resolvedRegistrations.get(method);
 862         } else {
 863             if (!method.isBridge()) {
 864                 ResolvedJavaType declaringClass = method.getDeclaringClass();
 865                 flushDeferrables();
 866                 String internalName = declaringClass.getName();
 867                 ClassPlugins classPlugins = registrations.get(internalName);
 868                 InvocationPlugin res = null;
 869                 if (classPlugins != null) {
 870                     res = classPlugins.get(method);
 871                 }
 872                 if (res == null) {
 873                     LateClassPlugins lcp = findLateClassPlugins(internalName);
 874                     if (lcp != null) {
 875                         res = lcp.get(method);
 876                     }
 877                 }
 878                 if (res != null) {
 879                     // A decorator plugin is trusted since it does not replace
<span class="line-modified"> 880                     // the method it intrinsifies. A GeneratedInvocationPlugin</span>
<span class="line-modified"> 881                     // is trusted since it only exists for @NodeIntrinsics and</span>
<span class="line-added"> 882                     // @Fold annotated methods (i.e., trusted Graal code).</span>
<span class="line-added"> 883                     if (res.isDecorator() || res instanceof GeneratedInvocationPlugin || canBeIntrinsified(declaringClass)) {</span>
 884                         return res;
 885                     }
 886                 }
 887                 if (testExtensions != null) {
 888                     // Avoid the synchronization in the common case that there
 889                     // are no test extensions.
 890                     synchronized (this) {
 891                         if (testExtensions != null) {
 892                             List&lt;Binding&gt; bindings = testExtensions.get(internalName);
 893                             if (bindings != null) {
 894                                 String name = method.getName();
 895                                 String descriptor = method.getSignature().toMethodDescriptor();
 896                                 for (Binding b : bindings) {
 897                                     if (b.isStatic == method.isStatic() &amp;&amp;
 898                                                     b.name.equals(name) &amp;&amp;
 899                                                     descriptor.startsWith(b.argumentsDescriptor)) {
 900                                         return b.plugin;
 901                                     }
 902                                 }
 903                             }
</pre>
<hr />
<pre>
1183      *
1184      * @param argumentTypes the argument types of the method. Element 0 of this array must be the
1185      *            {@link Class} value for {@link InvocationPlugin.Receiver} iff the method is
1186      *            non-static. Upon returning, element 0 will have been rewritten to
1187      *            {@code declaringClass}
1188      */
1189     public final void registerOptional(InvocationPlugin plugin, Type declaringClass, String name, Type... argumentTypes) {
1190         register(plugin, true, false, declaringClass, name, argumentTypes);
1191     }
1192 
1193     /**
1194      * Gets the plugin for a given method.
1195      *
1196      * @param method the method to lookup
1197      * @return the plugin associated with {@code method} or {@code null} if none exists
1198      */
1199     public InvocationPlugin lookupInvocation(ResolvedJavaMethod method) {
1200         if (parent != null) {
1201             InvocationPlugin plugin = parent.lookupInvocation(method);
1202             if (plugin != null) {




1203                 return plugin;
1204             }
1205         }
1206         InvocationPlugin invocationPlugin = get(method);




1207         return invocationPlugin;
1208     }
1209 
1210     /**
1211      * Gets the set of registered invocation plugins.
1212      *
1213      * @return a map from class names in {@linkplain MetaUtil#toInternalName(String) internal} form
1214      *         to the invocation plugin bindings for methods in the class
1215      */
1216     public EconomicMap&lt;String, List&lt;Binding&gt;&gt; getBindings(boolean includeParents) {
1217         return getBindings(includeParents, true);
1218     }
1219 
1220     /**
1221      * Gets the set of registered invocation plugins.
1222      *
1223      * @return a map from class names in {@linkplain MetaUtil#toInternalName(String) internal} form
1224      *         to the invocation plugin bindings for methods in the class
1225      */
1226     private EconomicMap&lt;String, List&lt;Binding&gt;&gt; getBindings(boolean includeParents, boolean flushDeferrables) {
</pre>
<hr />
<pre>
1384                 assert substitute.getAnnotation(MethodSubstitution.class) != null : format(&quot;Substitute method must be annotated with @%s: %s&quot;, MethodSubstitution.class.getSimpleName(), substitute);
1385                 return true;
1386             }
1387             int arguments = parseParameters(binding.argumentsDescriptor).size();
1388             assert arguments &lt; SIGS.length : format(&quot;need to extend %s to support method with %d arguments: %s&quot;, InvocationPlugin.class.getSimpleName(), arguments, binding);
1389             for (Method m : plugin.getClass().getDeclaredMethods()) {
1390                 if (m.getName().equals(&quot;apply&quot;)) {
1391                     Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();
1392                     if (Arrays.equals(SIGS[arguments], parameterTypes)) {
1393                         return true;
1394                     }
1395                 }
1396             }
1397             throw new AssertionError(format(&quot;graph builder plugin for %s not found&quot;, binding));
1398         }
1399 
1400         static boolean checkResolvable(boolean isOptional, Type declaringType, Binding binding) {
1401             if (declaringType instanceof ResolvedJavaSymbol) {
1402                 return checkResolvable(isOptional, ((ResolvedJavaSymbol) declaringType).getResolved(), binding);
1403             }
<span class="line-modified">1404             Class&lt;?&gt; declaringClass = resolveType(declaringType, isOptional);</span>
1405             if (declaringClass == null) {
1406                 return true;
1407             }
1408             if (binding.name.equals(&quot;&lt;init&gt;&quot;)) {
1409                 if (resolveConstructor(declaringClass, binding) == null &amp;&amp; !isOptional) {
1410                     throw new AssertionError(String.format(&quot;Constructor not found: %s%s&quot;, declaringClass.getName(), binding.argumentsDescriptor));
1411                 }
1412             } else {
1413                 if (resolveMethod(declaringClass, binding) == null &amp;&amp; !isOptional) {
<span class="line-modified">1414                     throw new NoSuchMethodError(String.format(&quot;%s.%s%s&quot;, declaringClass.getName(), binding.name, binding.argumentsDescriptor));</span>
1415                 }
1416             }
1417             return true;
1418         }
1419 
1420         private static boolean checkResolvable(boolean isOptional, ResolvedJavaType declaringType, Binding binding) {
1421             if (resolveJavaMethod(declaringType, binding) == null &amp;&amp; !isOptional) {
1422                 throw new AssertionError(String.format(&quot;Method not found: %s.%s%s&quot;, declaringType.toJavaName(), binding.name, binding.argumentsDescriptor));
1423             }
1424             return true;
1425         }
1426     }
1427 
1428     /**
1429      * Checks a set of nodes added to the graph by an {@link InvocationPlugin}.
1430      *
1431      * @param b the graph builder that applied the plugin
1432      * @param plugin a plugin that was just applied
1433      * @param newNodes the nodes added to the graph by {@code plugin}
1434      * @throws AssertionError if any check fail
</pre>
</td>
</tr>
</table>
<center><a href="InvocationPlugin.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopExplosionPlugin.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/GraphDecoder.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/GraphDecoder.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/GraphDecoder.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/GraphDecoder.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -137,11 +137,11 @@
             } else {
                 reader = null;
                 maxFixedNodeOrderId = 0;
             }
 
-            if (loopExplosion != LoopExplosionKind.NONE) {
+            if (loopExplosion.useExplosion()) {
                 loopExplosionMerges = EconomicSet.create(Equivalence.IDENTITY);
             } else {
                 loopExplosionMerges = null;
             }
         }
@@ -158,21 +158,74 @@
             return position;
         }
 
     }
 
+    /**
+     * Marker to distinguish the reasons for the creation of a loop scope during partial evaluation.
+     */
+    public enum LoopScopeTrigger {
+        /**
+         * Start loop scope: creation triggered manually at the beginning of partial evaluation.
+         */
+        START,
+
+        /**
+         * Loop scope created for the next iteration of a loop if unrolling is enabled in the loop
+         * explosion mode. See {@link LoopExplosionKind#unrollLoops()} for details. Loop unrolling
+         * will merge loop end nodes for each iteration of the original loop.
+         */
+        LOOP_BEGIN_UNROLLING,
+
+        /**
+         * Loop scope created for the next iteration of a loop along a particular loop end node if
+         * {@link LoopExplosionKind#duplicateLoopEnds()} is enabled and loops are exploded. This
+         * means for every loop end we duplicate the next loop iteration of the original loop.
+         */
+        LOOP_END_DUPLICATION,
+
+        /**
+         * Loop scope created for a loop exit node if {@link LoopExplosionKind#duplicateLoopExits()}
+         * is enabled, i.e., code after a loop exit is duplicated per loop exit node.
+         *
+         * Special case nested loops: For compilation units with nested loops where inner loops
+         * continue loops at a level n -1 the partial evaluation algorithm will merge outer loops to
+         * avoid loop explosion along loop end nodes (which would be the same as
+         * {@link #LOOP_END_DUPLICATION}.
+         */
+        LOOP_EXIT_DUPLICATION
+    }
+
     /** Decoding state maintained for each loop in the encoded graph. */
     protected static class LoopScope {
         public final MethodScope methodScope;
         public final LoopScope outer;
         public final int loopDepth;
         public final int loopIteration;
+
+        /**
+         * Creation trigger of this particular loop scope, i.e., the reason it was created.
+         */
+        final LoopScopeTrigger trigger;
+        /**
+         * Upcoming, not yet processed, loop iterations created in the context of code duplication
+         * along loop exits. Only used when {@link MethodScope#loopExplosion} has
+         * {@link LoopExplosionKind#duplicateLoopExits()} enabled.
+         */
+        public Deque<LoopScope> nextIterationFromLoopExitDuplication;
         /**
-         * Upcoming loop iterations during loop explosions that have not been processed yet. Only
-         * used when {@link MethodScope#loopExplosion} is not {@link LoopExplosionKind#NONE}.
+         * Same as {@link #nextIterationFromLoopExitDuplication} except that upcoming iterations
+         * have been created because the duplication of loop ends
+         * {@link LoopExplosionKind#duplicateLoopEnds()} is enabled.
          */
-        public Deque<LoopScope> nextIterations;
+        public Deque<LoopScope> nextIterationFromLoopEndDuplication;
+        /**
+         * Same as {@link #nextIterationFromLoopExitDuplication} except that upcoming iterations
+         * have been created because the unrolling of a loop with constant iteration count
+         * {@link LoopExplosionKind#unrollLoops()} is enabled.
+         */
+        public Deque<LoopScope> nextIterationsFromUnrolling;
         /**
          * Information about already processed loop iterations for state merging during loop
          * explosion. Only used when {@link MethodScope#loopExplosion} is
          * {@link LoopExplosionKind#MERGE_EXPLODE}.
          */
@@ -194,39 +247,80 @@
         public final Node[] initialCreatedNodes;
 
         protected LoopScope(MethodScope methodScope) {
             this.methodScope = methodScope;
             this.outer = null;
-            this.nextIterations = methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN ? new ArrayDeque<>(2) : null;
+            this.nextIterationFromLoopExitDuplication = methodScope.loopExplosion.duplicateLoopExits() || methodScope.loopExplosion.mergeLoops() ? new ArrayDeque<>(2) : null;
+            this.nextIterationFromLoopEndDuplication = methodScope.loopExplosion.duplicateLoopEnds() ? new ArrayDeque<>(2) : null;
+            this.nextIterationsFromUnrolling = methodScope.loopExplosion.unrollLoops() ? new ArrayDeque<>(2) : null;
             this.loopDepth = 0;
             this.loopIteration = 0;
             this.iterationStates = null;
             this.loopBeginOrderId = -1;
-
             int nodeCount = methodScope.encodedGraph.nodeStartOffsets.length;
             this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);
             this.createdNodes = new Node[nodeCount];
             this.initialCreatedNodes = null;
+            this.trigger = LoopScopeTrigger.START;
         }
 
-        protected LoopScope(MethodScope methodScope, LoopScope outer, int loopDepth, int loopIteration, int loopBeginOrderId, Node[] initialCreatedNodes, Node[] createdNodes,
-                        Deque<LoopScope> nextIterations, EconomicMap<LoopExplosionState, LoopExplosionState> iterationStates) {
+        protected LoopScope(MethodScope methodScope, LoopScope outer, int loopDepth, int loopIteration, int loopBeginOrderId, LoopScopeTrigger trigger, Node[] initialCreatedNodes, Node[] createdNodes,
+                        Deque<LoopScope> nextIterationFromLoopExitDuplication,
+                        Deque<LoopScope> nextIterationFromLoopEndDuplication,
+                        Deque<LoopScope> nextIterationsFromUnrolling, EconomicMap<LoopExplosionState, LoopExplosionState> iterationStates) {
             this.methodScope = methodScope;
             this.outer = outer;
             this.loopDepth = loopDepth;
             this.loopIteration = loopIteration;
-            this.nextIterations = nextIterations;
+            this.trigger = trigger;
+            this.nextIterationFromLoopExitDuplication = nextIterationFromLoopExitDuplication;
+            this.nextIterationFromLoopEndDuplication = nextIterationFromLoopEndDuplication;
+            this.nextIterationsFromUnrolling = nextIterationsFromUnrolling;
             this.iterationStates = iterationStates;
             this.loopBeginOrderId = loopBeginOrderId;
             this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);
             this.initialCreatedNodes = initialCreatedNodes;
             this.createdNodes = createdNodes;
         }
 
         @Override
         public String toString() {
-            return loopDepth + "," + loopIteration + (loopBeginOrderId == -1 ? "" : "#" + loopBeginOrderId);
+            return loopDepth + "," + loopIteration + (loopBeginOrderId == -1 ? "" : "#" + loopBeginOrderId) + " triggered by " + trigger;
+        }
+
+        /**
+         * Determines if iterations generated when decoding this loop have yet to be processed.
+         *
+         * @return {@code true} if there are iterations to be decoded, {@code false} else
+         */
+        public boolean hasIterationsToProcess() {
+            return nextIterationFromLoopEndDuplication != null && !nextIterationFromLoopEndDuplication.isEmpty() ||
+                            nextIterationFromLoopExitDuplication != null && !nextIterationFromLoopExitDuplication.isEmpty() ||
+                            nextIterationsFromUnrolling != null && !nextIterationsFromUnrolling.isEmpty();
+        }
+
+        /**
+         * Return the next iteration yet to be processed that has been created in the context of
+         * decoding this loop scope.
+         *
+         * @param remove determines if the query of the next iteration should remove it from the
+         *            list of iterations to be processed
+         * @return the next {@link LoopScope} to be processed that has been created in the context
+         *         of decoding this loop scope. Note that the order is not necessarily reflecting
+         *         the number of loop iterations.
+         */
+        public LoopScope getNextIterationToProcess(boolean remove) {
+            if (nextIterationFromLoopEndDuplication != null && !nextIterationFromLoopEndDuplication.isEmpty()) {
+                return remove ? nextIterationFromLoopEndDuplication.removeFirst() : nextIterationFromLoopEndDuplication.peekFirst();
+            }
+            if (nextIterationFromLoopExitDuplication != null && !nextIterationFromLoopExitDuplication.isEmpty()) {
+                return remove ? nextIterationFromLoopExitDuplication.removeFirst() : nextIterationFromLoopExitDuplication.peekFirst();
+            }
+            if (nextIterationsFromUnrolling != null && !nextIterationsFromUnrolling.isEmpty()) {
+                return remove ? nextIterationsFromUnrolling.removeFirst() : nextIterationsFromUnrolling.peekFirst();
+            }
+            return null;
         }
     }
 
     protected static class LoopExplosionState {
         public final FrameState state;
@@ -317,11 +411,11 @@
     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
     protected static final class ProxyPlaceholder extends FloatingNode implements Canonicalizable {
         public static final NodeClass<ProxyPlaceholder> TYPE = NodeClass.create(ProxyPlaceholder.class);
 
         @Input ValueNode value;
-        @Input(InputType.Unchecked) Node proxyPoint;
+        @Input(InputType.Association) Node proxyPoint;
 
         public ProxyPlaceholder(ValueNode value, MergeNode proxyPoint) {
             super(TYPE, value.stamp(NodeView.DEFAULT));
             this.value = value;
             this.proxyPoint = proxyPoint;
@@ -407,35 +501,32 @@
         while (loopScope != null) {
             MethodScope methodScope = loopScope.methodScope;
 
             /* Process loops of method. */
             while (loopScope != null) {
-
                 /* Process nodes of loop. */
                 while (!loopScope.nodesToProcess.isEmpty()) {
                     loopScope = processNextNode(methodScope, loopScope);
                     methodScope = loopScope.methodScope;
                     /*
                      * We can have entered a new loop, and we can have entered a new inlined method.
                      */
                 }
 
                 /* Finished with a loop. */
-                if (loopScope.nextIterations != null && !loopScope.nextIterations.isEmpty()) {
-                    /* Loop explosion: process the loop iteration. */
-                    assert loopScope.nextIterations.peekFirst().loopIteration == loopScope.loopIteration + 1;
-                    loopScope = loopScope.nextIterations.removeFirst();
+                if (loopScope.hasIterationsToProcess()) {
+                    loopScope = loopScope.getNextIterationToProcess(true);
                 } else {
                     propagateCreatedNodes(loopScope);
                     loopScope = loopScope.outer;
                 }
             }
 
             /*
              * Finished with an inlined method. Perform end-of-method cleanup tasks.
              */
-            if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE) {
+            if (methodScope.loopExplosion.mergeLoops()) {
                 LoopDetector loopDetector = new LoopDetector(graph, methodScope);
                 loopDetector.run();
             }
             if (methodScope.isInlinedMethod()) {
                 finishInlining(methodScope);
@@ -460,23 +551,38 @@
                 loopScope.outer.createdNodes[i] = loopScope.createdNodes[i];
             }
         }
     }
 
+    public static final boolean DUMP_DURING_FIXED_NODE_PROCESSING = false;
+
     protected LoopScope processNextNode(MethodScope methodScope, LoopScope loopScope) {
         int nodeOrderId = loopScope.nodesToProcess.nextSetBit(0);
         loopScope.nodesToProcess.clear(nodeOrderId);
 
         FixedNode node = (FixedNode) lookupNode(loopScope, nodeOrderId);
+
         if (node.isDeleted()) {
             return loopScope;
         }
-
+        if (DUMP_DURING_FIXED_NODE_PROCESSING) {
+            if (node != null) {
+                try {
+                    debug.dump(DebugContext.DETAILED_LEVEL, graph, "Before processing node %s", node);
+                } catch (Throwable t) {
+                    // swallow here, dumping uninitialized nodes can cause problems
+                }
+            }
+        }
         if ((node instanceof MergeNode ||
-                        (node instanceof LoopBeginNode && (methodScope.loopExplosion == LoopExplosionKind.FULL_UNROLL || methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE ||
-                                        methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN))) &&
+                        (node instanceof LoopBeginNode && (methodScope.loopExplosion.unrollLoops() &&
+                                        !methodScope.loopExplosion.mergeLoops()))) &&
                         ((AbstractMergeNode) node).forwardEndCount() == 1) {
+            /*
+             * In case node is a loop begin and we are unrolling loops we remove the loop begin
+             * since the loop will be gone after PE.
+             */
             AbstractMergeNode merge = (AbstractMergeNode) node;
             EndNode singleEnd = merge.forwardEndAt(0);
 
             /* Nodes that would use this merge as the guard need to use the previous block. */
             registerNode(loopScope, nodeOrderId, AbstractBeginNode.prevBegin(singleEnd), true, false);
@@ -490,22 +596,27 @@
         }
 
         LoopScope successorAddScope = loopScope;
         boolean updatePredecessors = true;
         if (node instanceof LoopExitNode) {
-            if (methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN || (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE && loopScope.loopDepth > 1)) {
+            if (methodScope.loopExplosion.duplicateLoopExits() || (methodScope.loopExplosion.mergeLoops() && loopScope.loopDepth > 1)) {
                 /*
                  * We do not want to merge loop exits of inner loops. Instead, we want to keep
                  * exploding the outer loop separately for every loop exit and then merge the outer
                  * loop. Therefore, we create a new LoopScope of the outer loop for every loop exit
                  * of the inner loop.
                  */
                 LoopScope outerScope = loopScope.outer;
-                int nextIterationNumber = outerScope.nextIterations.isEmpty() ? outerScope.loopIteration + 1 : outerScope.nextIterations.getLast().loopIteration + 1;
-                successorAddScope = new LoopScope(methodScope, outerScope.outer, outerScope.loopDepth, nextIterationNumber, outerScope.loopBeginOrderId,
+                int nextIterationNumber = outerScope.nextIterationFromLoopExitDuplication.isEmpty() ? outerScope.loopIteration + 1
+                                : outerScope.nextIterationFromLoopExitDuplication.getLast().loopIteration + 1;
+                successorAddScope = new LoopScope(methodScope, outerScope.outer, outerScope.loopDepth, nextIterationNumber, outerScope.loopBeginOrderId, LoopScopeTrigger.LOOP_EXIT_DUPLICATION,
                                 outerScope.initialCreatedNodes == null ? null : Arrays.copyOf(outerScope.initialCreatedNodes, outerScope.initialCreatedNodes.length),
-                                Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length), outerScope.nextIterations, outerScope.iterationStates);
+                                Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
+                                outerScope.nextIterationFromLoopExitDuplication,
+                                outerScope.nextIterationFromLoopEndDuplication,
+                                outerScope.nextIterationsFromUnrolling,
+                                outerScope.iterationStates);
                 checkLoopExplosionIteration(methodScope, successorAddScope);
 
                 /*
                  * Nodes that are still unprocessed in the outer scope might be merge nodes that are
                  * also reachable from the new exploded scope. Clearing them ensures that we do not
@@ -513,15 +624,15 @@
                  */
                 for (int id = outerScope.nodesToProcess.nextSetBit(0); id >= 0; id = outerScope.nodesToProcess.nextSetBit(id + 1)) {
                     successorAddScope.createdNodes[id] = null;
                 }
 
-                outerScope.nextIterations.addLast(successorAddScope);
+                outerScope.nextIterationFromLoopExitDuplication.addLast(successorAddScope);
             } else {
                 successorAddScope = loopScope.outer;
             }
-            updatePredecessors = methodScope.loopExplosion == LoopExplosionKind.NONE;
+            updatePredecessors = methodScope.loopExplosion.isNoExplosion();
         }
 
         methodScope.reader.setByteIndex(methodScope.encodedGraph.nodeStartOffsets[nodeOrderId]);
         int typeId = methodScope.reader.getUVInt();
         assert node.getNodeClass() == methodScope.encodedGraph.getNodeClasses()[typeId];
@@ -529,68 +640,137 @@
         readProperties(methodScope, node);
         makeSuccessorStubs(methodScope, successorAddScope, node, updatePredecessors);
 
         LoopScope resultScope = loopScope;
         if (node instanceof LoopBeginNode) {
-            if (methodScope.loopExplosion != LoopExplosionKind.NONE) {
+            if (methodScope.loopExplosion.useExplosion()) {
                 handleLoopExplosionBegin(methodScope, loopScope, (LoopBeginNode) node);
             }
 
         } else if (node instanceof LoopExitNode) {
-            if (methodScope.loopExplosion != LoopExplosionKind.NONE) {
+            if (methodScope.loopExplosion.useExplosion()) {
                 handleLoopExplosionProxyNodes(methodScope, loopScope, successorAddScope, (LoopExitNode) node, nodeOrderId);
             } else {
                 handleProxyNodes(methodScope, loopScope, (LoopExitNode) node);
             }
 
         } else if (node instanceof MergeNode) {
             handleMergeNode(((MergeNode) node));
-
         } else if (node instanceof AbstractEndNode) {
             LoopScope phiInputScope = loopScope;
             LoopScope phiNodeScope = loopScope;
+            int mergeOrderId = readOrderId(methodScope);
 
-            if (methodScope.loopExplosion != LoopExplosionKind.NONE && node instanceof LoopEndNode) {
-                node = handleLoopExplosionEnd(methodScope, loopScope, (LoopEndNode) node);
-                phiNodeScope = loopScope.nextIterations.getLast();
-            }
+            boolean requiresMergeOfOuterLoop = methodScope.loopExplosion.unrollLoops() &&
+                            methodScope.loopExplosion.duplicateLoopExits() &&
+                            (!methodScope.loopExplosion.duplicateLoopEnds()) &&
+                            (!methodScope.loopExplosion.mergeLoops()) &&
+                            node instanceof LoopEndNode &&
+                            loopScope.trigger == LoopScopeTrigger.LOOP_EXIT_DUPLICATION;
+
+            if (requiresMergeOfOuterLoop) {
+                EndNode replacementNode = graph.add(new EndNode());
+                node.replaceAtPredecessor(replacementNode);
+                node.safeDelete();
+                node = replacementNode;
+                /*
+                 * We are in a loop exit duplicated loop scope and see a loop end node, this can
+                 * only happen if we have a loop end to an outer loop. When duplicating over loop
+                 * exits we have to merge outer loops for nested inner loops.
+                 *
+                 * Therefore, we create a correct outer loop iteration and check if there is already
+                 * one, if not we create it else we re-use it.
+                 */
+                if (loopScope.nextIterationsFromUnrolling.isEmpty()) {
+                    // create it
+                    int nextIterationNumber = loopScope.nextIterationsFromUnrolling.isEmpty() ? loopScope.loopIteration + 1 : loopScope.nextIterationsFromUnrolling.getLast().loopIteration + 1;
+                    LoopScope outerLoopMergeScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId,
+                                    LoopScopeTrigger.LOOP_BEGIN_UNROLLING,
+                                    Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
+                                    Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
+                                    loopScope.nextIterationFromLoopExitDuplication,
+                                    loopScope.nextIterationFromLoopEndDuplication,
+                                    loopScope.nextIterationsFromUnrolling,
+                                    loopScope.iterationStates);
+                    checkLoopExplosionIteration(methodScope, outerLoopMergeScope);
+                    loopScope.nextIterationsFromUnrolling.addLast(outerLoopMergeScope);
+                    registerNode(outerLoopMergeScope, loopScope.loopBeginOrderId, null, true, true);
+                    makeStubNode(methodScope, outerLoopMergeScope, loopScope.loopBeginOrderId);
+                    phiNodeScope = outerLoopMergeScope;
+                } else {
+                    // re-use it
+                    phiNodeScope = loopScope.nextIterationsFromUnrolling.getLast();
+                }
 
-            int mergeOrderId = readOrderId(methodScope);
+            } else if (methodScope.loopExplosion.useExplosion() && node instanceof LoopEndNode) {
+                EndNode replacementNode = graph.add(new EndNode());
+                node.replaceAtPredecessor(replacementNode);
+                node.safeDelete();
+                node = replacementNode;
+                LoopScopeTrigger trigger = handleLoopExplosionEnd(methodScope, loopScope);
+                Deque<LoopScope> phiScope = loopScope.nextIterationsFromUnrolling;
+                if (trigger == LoopScopeTrigger.LOOP_END_DUPLICATION) {
+                    phiScope = loopScope.nextIterationFromLoopEndDuplication;
+                }
+                phiNodeScope = phiScope.getLast();
+            }
             AbstractMergeNode merge = (AbstractMergeNode) lookupNode(phiNodeScope, mergeOrderId);
             if (merge == null) {
                 merge = (AbstractMergeNode) makeStubNode(methodScope, phiNodeScope, mergeOrderId);
-
                 if (merge instanceof LoopBeginNode) {
+                    /*
+                     * In contrast to the LoopScopeTrigger.START created at the beginning of every
+                     * PE, we see a real loop here and create the first real loop scope associated
+                     * with a loop.
+                     *
+                     * Creation of a loop scope if we reach a loop begin node. We process a loop
+                     * begin node (always before encountering a loop end associated with the loop
+                     * begin) and simply create a normal loop scope. This does not imply an advanced
+                     * unrolling strategy (however it can later if we see duplicate over loop end or
+                     * exits). Therefore, we still use the start marker here, we could also use the
+                     * unrolling marker.
+                     *
+                     * If we unroll loops we will later remove the loop begin node and replace it
+                     * with its forward end (since we do not need to create a loop begin node if we
+                     * unroll the entire loop and it has a constant trip count).
+                     */
                     assert phiNodeScope == phiInputScope && phiNodeScope == loopScope;
-                    resultScope = new LoopScope(methodScope, loopScope, loopScope.loopDepth + 1, 0, mergeOrderId,
-                                    methodScope.loopExplosion != LoopExplosionKind.NONE ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : null,
-                                    methodScope.loopExplosion != LoopExplosionKind.NONE ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : loopScope.createdNodes, //
-                                    methodScope.loopExplosion != LoopExplosionKind.NONE ? new ArrayDeque<>(2) : null, //
-                                    methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE ? EconomicMap.create(Equivalence.DEFAULT) : null);
+                    resultScope = new LoopScope(methodScope, loopScope, loopScope.loopDepth + 1, 0, mergeOrderId, LoopScopeTrigger.START,
+                                    methodScope.loopExplosion.useExplosion() ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : null,
+                                    methodScope.loopExplosion.useExplosion() ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : loopScope.createdNodes, //
+                                    methodScope.loopExplosion.duplicateLoopExits() || methodScope.loopExplosion.mergeLoops() ? new ArrayDeque<>(2) : null,
+                                    methodScope.loopExplosion.duplicateLoopEnds() ? new ArrayDeque<>(2) : null,
+                                    methodScope.loopExplosion.unrollLoops() ? new ArrayDeque<>(2) : null, //
+                                    methodScope.loopExplosion.mergeLoops() ? EconomicMap.create(Equivalence.DEFAULT) : null);
                     phiInputScope = resultScope;
                     phiNodeScope = resultScope;
 
-                    if (methodScope.loopExplosion != LoopExplosionKind.NONE) {
+                    if (methodScope.loopExplosion.useExplosion()) {
                         registerNode(loopScope, mergeOrderId, null, true, true);
                     }
                     loopScope.nodesToProcess.clear(mergeOrderId);
                     resultScope.nodesToProcess.set(mergeOrderId);
                 }
             }
-
             handlePhiFunctions(methodScope, phiInputScope, phiNodeScope, (AbstractEndNode) node, merge);
-
         } else if (node instanceof Invoke) {
             InvokeData invokeData = readInvokeData(methodScope, nodeOrderId, (Invoke) node);
             resultScope = handleInvoke(methodScope, loopScope, invokeData);
-
         } else if (node instanceof ReturnNode || node instanceof UnwindNode) {
             methodScope.returnAndUnwindNodes.add((ControlSinkNode) node);
         } else {
             handleFixedNode(methodScope, loopScope, nodeOrderId, node);
         }
-
+        if (DUMP_DURING_FIXED_NODE_PROCESSING) {
+            if (node != null) {
+                try {
+                    debug.dump(DebugContext.DETAILED_LEVEL, graph, "After processing node %s", node);
+                } catch (Throwable t) {
+                    // swallow here, dumping uninitialized nodes can cause problems
+                }
+            }
+        }
         return resultScope;
     }
 
     protected InvokeData readInvokeData(MethodScope methodScope, int invokeOrderId, Invoke invoke) {
         ResolvedJavaType contextType = (ResolvedJavaType) readObject(methodScope);
@@ -656,11 +836,11 @@
 
         List<EndNode> predecessors = loopBegin.forwardEnds().snapshot();
         FixedNode successor = loopBegin.next();
         FrameState frameState = loopBegin.stateAfter();
 
-        if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE) {
+        if (methodScope.loopExplosion.mergeLoops()) {
             LoopExplosionState queryState = new LoopExplosionState(frameState, null);
             LoopExplosionState existingState = loopScope.iterationStates.get(queryState);
             if (existingState != null) {
                 loopBegin.replaceAtUsagesAndDelete(existingState.merge);
                 successor.safeDelete();
@@ -672,11 +852,11 @@
         }
 
         MergeNode merge = graph.add(new MergeNode());
         methodScope.loopExplosionMerges.add(merge);
 
-        if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE) {
+        if (methodScope.loopExplosion.mergeLoops()) {
             if (loopScope.iterationStates.size() == 0 && loopScope.loopDepth == 1) {
                 if (methodScope.loopExplosionHead != null) {
                     throw new PermanentBailoutException("Graal implementation restriction: Method with %s loop explosion must not have more than one top-level loop", LoopExplosionKind.MERGE_EXPLODE);
                 }
                 methodScope.loopExplosionHead = merge;
@@ -723,11 +903,11 @@
         merge.setNext(successor);
         for (EndNode predecessor : predecessors) {
             merge.addForwardEnd(predecessor);
         }
 
-        if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE) {
+        if (methodScope.loopExplosion.mergeLoops()) {
             LoopExplosionState explosionState = new LoopExplosionState(frameState, merge);
             loopScope.iterationStates.put(explosionState, explosionState);
         }
     }
 
@@ -739,27 +919,48 @@
      */
     protected void checkLoopExplosionIteration(MethodScope methodScope, LoopScope loopScope) {
         throw shouldNotReachHere("when subclass uses loop explosion, it needs to implement this method");
     }
 
-    protected FixedNode handleLoopExplosionEnd(MethodScope methodScope, LoopScope loopScope, LoopEndNode loopEnd) {
-        EndNode replacementNode = graph.add(new EndNode());
-        loopEnd.replaceAtPredecessor(replacementNode);
-        loopEnd.safeDelete();
-
-        assert methodScope.loopExplosion != LoopExplosionKind.NONE;
-        if (methodScope.loopExplosion != LoopExplosionKind.FULL_UNROLL || loopScope.nextIterations.isEmpty()) {
-            int nextIterationNumber = loopScope.nextIterations.isEmpty() ? loopScope.loopIteration + 1 : loopScope.nextIterations.getLast().loopIteration + 1;
-            LoopScope nextIterationScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId,
+    protected LoopScopeTrigger handleLoopExplosionEnd(MethodScope methodScope, LoopScope loopScope) {
+        /*
+         * This method is only called if we reach a loop end and we use some kind of loop explosion,
+         * i.e., we unroll loops or explode along loop ends.
+         */
+        LoopScopeTrigger trigger = null;
+        Deque<LoopScope> nextIterations = null;
+        if (methodScope.loopExplosion.duplicateLoopEnds()) {
+            /*
+             * Loop explosion along loop ends: We see a loop end, however we do not merge all loop
+             * ends at a common merge node but rather duplicate the rest of the loop for every loop
+             * end.
+             */
+            trigger = LoopScopeTrigger.LOOP_END_DUPLICATION;
+            nextIterations = loopScope.nextIterationFromLoopEndDuplication;
+        } else if (loopScope.nextIterationsFromUnrolling.isEmpty()) {
+            /*
+             * Regular loop unrolling, i.e., we reach a loop end node of a loop that should be
+             * unrolled: We create a new successor scope.
+             */
+            trigger = LoopScopeTrigger.LOOP_BEGIN_UNROLLING;
+            nextIterations = loopScope.nextIterationsFromUnrolling;
+        }
+        if (trigger != null) {
+            int nextIterationNumber = nextIterations.isEmpty() ? loopScope.loopIteration + 1 : nextIterations.getLast().loopIteration + 1;
+            LoopScope nextIterationScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId, trigger,
                             Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
-                            Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length), loopScope.nextIterations, loopScope.iterationStates);
+                            Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
+                            loopScope.nextIterationFromLoopExitDuplication,
+                            loopScope.nextIterationFromLoopEndDuplication,
+                            loopScope.nextIterationsFromUnrolling,
+                            loopScope.iterationStates);
             checkLoopExplosionIteration(methodScope, nextIterationScope);
-            loopScope.nextIterations.addLast(nextIterationScope);
+            nextIterations.addLast(nextIterationScope);
             registerNode(nextIterationScope, loopScope.loopBeginOrderId, null, true, true);
             makeStubNode(methodScope, nextIterationScope, loopScope.loopBeginOrderId);
         }
-        return replacementNode;
+        return trigger;
     }
 
     /**
      * Hook for subclasses.
      *
@@ -798,11 +999,11 @@
 
         FixedNode loopExitSuccessor = loopExit.next();
         loopExit.replaceAtPredecessor(begin);
 
         MergeNode loopExitPlaceholder = null;
-        if (methodScope.loopExplosion == LoopExplosionKind.MERGE_EXPLODE && loopScope.loopDepth == 1) {
+        if (methodScope.loopExplosion.mergeLoops() && loopScope.loopDepth == 1) {
             /*
              * This exit might end up as a loop exit of a loop detected after partial evaluation. We
              * need to be able to create a FrameState and the necessary proxy nodes in this case.
              */
             loopExitPlaceholder = graph.add(new MergeNode());
@@ -876,37 +1077,34 @@
                  * We do not need a phi node yet.
                  */
                 registerNode(outerScope, proxyOrderId, phiInput, true, false);
                 replacement = phiInput;
 
-            } else if (!merge.isPhiAtMerge(existing)) {
-                /* Now we have two different values, so we need to create a phi node. */
-                PhiNode phi;
-                if (proxy instanceof ValueProxyNode) {
-                    phi = graph.addWithoutUnique(new ValuePhiNode(proxy.stamp(NodeView.DEFAULT), merge));
-                } else if (proxy instanceof GuardProxyNode) {
-                    phi = graph.addWithoutUnique(new GuardPhiNode(merge));
+            } else {
+                // Fortify: Suppress Null Dereference false positive
+                assert merge != null;
+
+                if (!merge.isPhiAtMerge(existing)) {
+                    /* Now we have two different values, so we need to create a phi node. */
+                    PhiNode phi = proxy.createPhi(merge);
+                    /* Add the inputs from all previous exits. */
+                    for (int j = 0; j < merge.phiPredecessorCount() - 1; j++) {
+                        phi.addInput(existing);
+                    }
+                    /* Add the input from this exit. */
+                    phi.addInput(phiInput);
+                    registerNode(outerScope, proxyOrderId, phi, true, false);
+                    replacement = phi;
+                    phiCreated = true;
+
                 } else {
-                    throw GraalError.shouldNotReachHere();
+                    /* Phi node has been created before, so just add the new input. */
+                    PhiNode phi = (PhiNode) existing;
+                    phi.addInput(phiInput);
+                    replacement = phi;
                 }
-                /* Add the inputs from all previous exits. */
-                for (int j = 0; j < merge.phiPredecessorCount() - 1; j++) {
-                    phi.addInput(existing);
-                }
-                /* Add the input from this exit. */
-                phi.addInput(phiInput);
-                registerNode(outerScope, proxyOrderId, phi, true, false);
-                replacement = phi;
-                phiCreated = true;
-
-            } else {
-                /* Phi node has been created before, so just add the new input. */
-                PhiNode phi = (PhiNode) existing;
-                phi.addInput(phiInput);
-                replacement = phi;
             }
-
             proxy.replaceAtUsagesAndDelete(replacement);
         }
 
         if (loopExitPlaceholder != null) {
             registerNode(loopScope, stateAfterOrderId, null, true, true);
@@ -956,11 +1154,11 @@
          * processing the merge node, we have the final phi function when processing the merge node.
          * The only exception are loop headers of non-exploded loops: since backward branches are
          * not processed yet when processing the loop body, we need to create all phi functions
          * upfront.
          */
-        boolean lazyPhi = allowLazyPhis() && (!(merge instanceof LoopBeginNode) || methodScope.loopExplosion != LoopExplosionKind.NONE);
+        boolean lazyPhi = allowLazyPhis() && (!(merge instanceof LoopBeginNode) || methodScope.loopExplosion.useExplosion());
         int numPhis = methodScope.reader.getUVInt();
         for (int i = 0; i < numPhis; i++) {
             int phiInputOrderId = readOrderId(methodScope);
             int phiNodeOrderId = readOrderId(methodScope);
 
@@ -975,11 +1173,11 @@
                  * which starts with a clone of the values that were created before the loop, sees
                  * the stale value when processing the merge the first time. We can safely ignore
                  * the stale value because it will never be needed to be merged (we are exploding
                  * until we hit a return).
                  */
-                assert methodScope.loopExplosion == LoopExplosionKind.FULL_EXPLODE_UNTIL_RETURN && phiNodeScope.loopIteration > 0;
+                assert methodScope.loopExplosion.duplicateLoopExits() && phiNodeScope.loopIteration > 0;
                 existing = null;
             }
 
             if (lazyPhi && (existing == null || existing == phiInput)) {
                 /* Phi function not yet necessary. */
@@ -1330,10 +1528,15 @@
      * Removes unnecessary nodes from the graph after decoding.
      *
      * @param methodScope The current method.
      */
     protected void cleanupGraph(MethodScope methodScope) {
+        for (MergeNode merge : graph.getNodes(MergeNode.TYPE)) {
+            for (ProxyPlaceholder placeholder : merge.usages().filter(ProxyPlaceholder.class).snapshot()) {
+                placeholder.replaceAndDelete(placeholder.value);
+            }
+        }
         assert verifyEdges();
     }
 
     protected boolean verifyEdges() {
         for (Node node : graph.getNodes()) {
@@ -1744,11 +1947,11 @@
                  */
                 GraalError.guarantee(value instanceof ProxyPlaceholder && ((ProxyPlaceholder) value).proxyPoint == loopExplosionMerge,
                                 "Value flowing out of loop, but we are not prepared to insert a ProxyNode");
 
                 ProxyPlaceholder proxyPlaceholder = (ProxyPlaceholder) value;
-                ValueProxyNode proxy = ProxyNode.forValue(proxyPlaceholder.value, loopExit, graph);
+                ValueProxyNode proxy = ProxyNode.forValue(proxyPlaceholder.value, loopExit);
                 proxyPlaceholder.setValue(proxy);
                 newValues.add(proxy);
             }
         }
 
@@ -1812,10 +2015,11 @@
                 loopValue = curLoopValue;
                 explosionHeadValue = curExplosionHeadValue;
             }
         }
         assert loopVariableIndex != -1;
+        assert explosionHeadValue != null;
 
         ValuePhiNode loopVariablePhi;
         SortedMap<Integer, AbstractBeginNode> dispatchTable = new TreeMap<>();
         AbstractBeginNode unreachableDefaultSuccessor;
         if (irreducibleLoopSwitch == null) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/StructuredGraph.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StartNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ValueNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/StructuredGraph.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 108 
 109         public boolean allowsFloatingGuards() {
 110             return this == FLOATING_GUARDS;
 111         }
 112 
 113         public boolean allowsGuardInsertion() {
 114             return this.ordinal() &lt;= FIXED_DEOPTS.ordinal();
 115         }
 116 
 117         public boolean areFrameStatesAtDeopts() {
 118             return this == AFTER_FSA;
 119         }
 120 
 121         public boolean areFrameStatesAtSideEffects() {
 122             return !this.areFrameStatesAtDeopts();
 123         }
 124 
 125         public boolean areDeoptsFixed() {
 126             return this.ordinal() &gt;= FIXED_DEOPTS.ordinal();
 127         }




 128     }
 129 
 130     /**
 131      * Constants denoting whether or not {@link Assumption}s can be made while processing a graph.
 132      */
 133     public enum AllowAssumptions {
 134         YES,
 135         NO;
 136         public static AllowAssumptions ifTrue(boolean flag) {
 137             return flag ? YES : NO;
 138         }
 139 
 140         public static AllowAssumptions ifNonNull(Assumptions assumptions) {
 141             return assumptions != null ? YES : NO;
 142         }
 143     }
 144 
 145     public static class ScheduleResult {
 146         private final ControlFlowGraph cfg;
 147         private final NodeMap&lt;Block&gt; nodeToBlockMap;
</pre>
<hr />
<pre>
 661             }
 662         };
 663     }
 664 
 665     public boolean hasLoops() {
 666         return hasNode(LoopBeginNode.TYPE);
 667     }
 668 
 669     /**
 670      * Unlinks a node from all its control flow neighbors and then removes it from its graph. The
 671      * node must have no {@linkplain Node#usages() usages}.
 672      *
 673      * @param node the node to be unlinked and removed
 674      */
 675     @SuppressWarnings(&quot;static-method&quot;)
 676     public void removeFixed(FixedWithNextNode node) {
 677         assert node != null;
 678         if (node instanceof AbstractBeginNode) {
 679             ((AbstractBeginNode) node).prepareDelete();
 680         }
<span class="line-modified"> 681         assert node.hasNoUsages() : node + &quot; &quot; + node.usages().count() + &quot;, &quot; + node.usages().first();</span>
 682         GraphUtil.unlinkFixedNode(node);
 683         node.safeDelete();
 684     }
 685 
 686     public void replaceFixed(FixedWithNextNode node, Node replacement) {
 687         if (replacement instanceof FixedWithNextNode) {
 688             replaceFixedWithFixed(node, (FixedWithNextNode) replacement);
 689         } else {
 690             assert replacement != null : &quot;cannot replace &quot; + node + &quot; with null&quot;;
 691             assert replacement instanceof FloatingNode : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 692             replaceFixedWithFloating(node, (FloatingNode) replacement);
 693         }
 694     }
 695 
 696     public void replaceFixedWithFixed(FixedWithNextNode node, FixedWithNextNode replacement) {
 697         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 698         FixedNode next = node.next();
 699         node.setNext(null);
 700         replacement.setNext(next);
 701         node.replaceAndDelete(replacement);
</pre>
<hr />
<pre>
 949                 }
 950             }
 951         }
 952         return true;
 953     }
 954 
 955     private static EconomicSet&lt;ResolvedJavaField&gt; createFieldSet(EconomicSet&lt;ResolvedJavaField&gt; init) {
 956         // Multiple ResolvedJavaField objects can represent the same field so they
 957         // need to be compared with equals().
 958         if (init != null) {
 959             return EconomicSet.create(Equivalence.DEFAULT, init);
 960         }
 961         return EconomicSet.create(Equivalence.DEFAULT);
 962     }
 963 
 964     /**
 965      * Gets an unmodifiable view of the methods that were inlined while constructing this graph.
 966      */
 967     public List&lt;ResolvedJavaMethod&gt; getMethods() {
 968         if (methods != null) {
<span class="line-modified"> 969             assert checkFrameStatesAgainstInlinedMethods();</span>
 970             return Collections.unmodifiableList(methods);
 971         }
 972         return Collections.emptyList();
 973     }
 974 
 975     /**
 976      * Records that {@code method} was used to build this graph.
 977      */
 978     public void recordMethod(ResolvedJavaMethod method) {
 979         if (methods != null) {
 980             methods.add(method);
 981         }
 982     }
 983 
 984     /**
 985      * Updates the {@linkplain #getMethods() methods} used to build this graph with the methods used
 986      * to build another graph.
 987      */
 988     public void updateMethods(StructuredGraph other) {
 989         if (methods != null) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 108 
 109         public boolean allowsFloatingGuards() {
 110             return this == FLOATING_GUARDS;
 111         }
 112 
 113         public boolean allowsGuardInsertion() {
 114             return this.ordinal() &lt;= FIXED_DEOPTS.ordinal();
 115         }
 116 
 117         public boolean areFrameStatesAtDeopts() {
 118             return this == AFTER_FSA;
 119         }
 120 
 121         public boolean areFrameStatesAtSideEffects() {
 122             return !this.areFrameStatesAtDeopts();
 123         }
 124 
 125         public boolean areDeoptsFixed() {
 126             return this.ordinal() &gt;= FIXED_DEOPTS.ordinal();
 127         }
<span class="line-added"> 128 </span>
<span class="line-added"> 129         public boolean requiresValueProxies() {</span>
<span class="line-added"> 130             return this != AFTER_FSA;</span>
<span class="line-added"> 131         }</span>
 132     }
 133 
 134     /**
 135      * Constants denoting whether or not {@link Assumption}s can be made while processing a graph.
 136      */
 137     public enum AllowAssumptions {
 138         YES,
 139         NO;
 140         public static AllowAssumptions ifTrue(boolean flag) {
 141             return flag ? YES : NO;
 142         }
 143 
 144         public static AllowAssumptions ifNonNull(Assumptions assumptions) {
 145             return assumptions != null ? YES : NO;
 146         }
 147     }
 148 
 149     public static class ScheduleResult {
 150         private final ControlFlowGraph cfg;
 151         private final NodeMap&lt;Block&gt; nodeToBlockMap;
</pre>
<hr />
<pre>
 665             }
 666         };
 667     }
 668 
 669     public boolean hasLoops() {
 670         return hasNode(LoopBeginNode.TYPE);
 671     }
 672 
 673     /**
 674      * Unlinks a node from all its control flow neighbors and then removes it from its graph. The
 675      * node must have no {@linkplain Node#usages() usages}.
 676      *
 677      * @param node the node to be unlinked and removed
 678      */
 679     @SuppressWarnings(&quot;static-method&quot;)
 680     public void removeFixed(FixedWithNextNode node) {
 681         assert node != null;
 682         if (node instanceof AbstractBeginNode) {
 683             ((AbstractBeginNode) node).prepareDelete();
 684         }
<span class="line-modified"> 685         assert node.hasNoUsages() : node + &quot; &quot; + node.getUsageCount() + &quot;, &quot; + node.usages().first();</span>
 686         GraphUtil.unlinkFixedNode(node);
 687         node.safeDelete();
 688     }
 689 
 690     public void replaceFixed(FixedWithNextNode node, Node replacement) {
 691         if (replacement instanceof FixedWithNextNode) {
 692             replaceFixedWithFixed(node, (FixedWithNextNode) replacement);
 693         } else {
 694             assert replacement != null : &quot;cannot replace &quot; + node + &quot; with null&quot;;
 695             assert replacement instanceof FloatingNode : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 696             replaceFixedWithFloating(node, (FloatingNode) replacement);
 697         }
 698     }
 699 
 700     public void replaceFixedWithFixed(FixedWithNextNode node, FixedWithNextNode replacement) {
 701         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 702         FixedNode next = node.next();
 703         node.setNext(null);
 704         replacement.setNext(next);
 705         node.replaceAndDelete(replacement);
</pre>
<hr />
<pre>
 953                 }
 954             }
 955         }
 956         return true;
 957     }
 958 
 959     private static EconomicSet&lt;ResolvedJavaField&gt; createFieldSet(EconomicSet&lt;ResolvedJavaField&gt; init) {
 960         // Multiple ResolvedJavaField objects can represent the same field so they
 961         // need to be compared with equals().
 962         if (init != null) {
 963             return EconomicSet.create(Equivalence.DEFAULT, init);
 964         }
 965         return EconomicSet.create(Equivalence.DEFAULT);
 966     }
 967 
 968     /**
 969      * Gets an unmodifiable view of the methods that were inlined while constructing this graph.
 970      */
 971     public List&lt;ResolvedJavaMethod&gt; getMethods() {
 972         if (methods != null) {
<span class="line-modified"> 973             assert isSubstitution || checkFrameStatesAgainstInlinedMethods();</span>
 974             return Collections.unmodifiableList(methods);
 975         }
 976         return Collections.emptyList();
 977     }
 978 
 979     /**
 980      * Records that {@code method} was used to build this graph.
 981      */
 982     public void recordMethod(ResolvedJavaMethod method) {
 983         if (methods != null) {
 984             methods.add(method);
 985         }
 986     }
 987 
 988     /**
 989      * Updates the {@linkplain #getMethods() methods} used to build this graph with the methods used
 990      * to build another graph.
 991      */
 992     public void updateMethods(StructuredGraph other) {
 993         if (methods != null) {
</pre>
</td>
</tr>
</table>
<center><a href="StartNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ValueNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
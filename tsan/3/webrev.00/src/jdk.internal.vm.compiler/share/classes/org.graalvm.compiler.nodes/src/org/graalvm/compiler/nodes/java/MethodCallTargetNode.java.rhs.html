<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/MethodCallTargetNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.java;
 26 
 27 import org.graalvm.compiler.core.common.type.Stamp;
 28 import org.graalvm.compiler.core.common.type.StampFactory;
 29 import org.graalvm.compiler.core.common.type.StampPair;
 30 import org.graalvm.compiler.core.common.type.TypeReference;
 31 import org.graalvm.compiler.graph.IterableNodeType;
 32 import org.graalvm.compiler.graph.Node;
 33 import org.graalvm.compiler.graph.NodeClass;
 34 import org.graalvm.compiler.graph.spi.Simplifiable;
 35 import org.graalvm.compiler.graph.spi.SimplifierTool;
 36 import org.graalvm.compiler.nodeinfo.NodeInfo;
 37 import org.graalvm.compiler.nodeinfo.Verbosity;
<a name="1" id="anc1"></a><span class="line-added"> 38 import org.graalvm.compiler.nodes.BeginNode;</span>
 39 import org.graalvm.compiler.nodes.CallTargetNode;
 40 import org.graalvm.compiler.nodes.FixedGuardNode;
 41 import org.graalvm.compiler.nodes.Invoke;
 42 import org.graalvm.compiler.nodes.LogicNode;
 43 import org.graalvm.compiler.nodes.NodeView;
 44 import org.graalvm.compiler.nodes.PiNode;
 45 import org.graalvm.compiler.nodes.StructuredGraph;
 46 import org.graalvm.compiler.nodes.ValueNode;
<a name="2" id="anc2"></a><span class="line-modified"> 47 import org.graalvm.compiler.nodes.extended.AnchoringNode;</span>
 48 import org.graalvm.compiler.nodes.spi.UncheckedInterfaceProvider;
 49 import org.graalvm.compiler.nodes.type.StampTool;
 50 
 51 import jdk.vm.ci.code.BytecodeFrame;
 52 import jdk.vm.ci.meta.Assumptions;
 53 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 54 import jdk.vm.ci.meta.DeoptimizationAction;
 55 import jdk.vm.ci.meta.DeoptimizationReason;
 56 import jdk.vm.ci.meta.JavaKind;
 57 import jdk.vm.ci.meta.JavaTypeProfile;
 58 import jdk.vm.ci.meta.ResolvedJavaMethod;
 59 import jdk.vm.ci.meta.ResolvedJavaType;
 60 
 61 @NodeInfo
 62 public class MethodCallTargetNode extends CallTargetNode implements IterableNodeType, Simplifiable {
 63     public static final NodeClass&lt;MethodCallTargetNode&gt; TYPE = NodeClass.create(MethodCallTargetNode.class);
 64     protected JavaTypeProfile profile;
 65 
 66     public MethodCallTargetNode(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] arguments, StampPair returnStamp, JavaTypeProfile profile) {
 67         this(TYPE, invokeKind, targetMethod, arguments, returnStamp, profile);
 68     }
 69 
 70     protected MethodCallTargetNode(NodeClass&lt;? extends MethodCallTargetNode&gt; c, InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] arguments, StampPair returnStamp,
 71                     JavaTypeProfile profile) {
 72         super(c, arguments, targetMethod, invokeKind, returnStamp);
 73         this.profile = profile;
 74     }
 75 
 76     /**
 77      * Gets the instruction that produces the receiver object for this invocation, if any.
 78      *
 79      * @return the instruction that produces the receiver object for this invocation if any,
 80      *         {@code null} if this invocation does not take a receiver object
 81      */
 82     public ValueNode receiver() {
 83         return isStatic() ? null : arguments().get(0);
 84     }
 85 
 86     /**
 87      * Checks whether this is an invocation of a static method.
 88      *
 89      * @return {@code true} if the invocation is a static invocation
 90      */
 91     public boolean isStatic() {
 92         return invokeKind() == InvokeKind.Static;
 93     }
 94 
 95     public JavaKind returnKind() {
 96         return targetMethod().getSignature().getReturnKind();
 97     }
 98 
<a name="3" id="anc3"></a>



 99     @Override
100     public boolean verify() {
101         assert getUsageCount() &lt;= 1 : &quot;call target may only be used by a single invoke&quot;;
102         for (Node n : usages()) {
103             assertTrue(n instanceof Invoke, &quot;call target can only be used from an invoke (%s)&quot;, n);
104         }
105         if (invokeKind().isDirect()) {
106             assertTrue(targetMethod().isConcrete(), &quot;special calls or static calls are only allowed for concrete methods (%s)&quot;, targetMethod());
107         }
108         if (invokeKind() == InvokeKind.Static) {
109             assertTrue(targetMethod().isStatic(), &quot;static calls are only allowed for static methods (%s)&quot;, targetMethod());
110         } else {
111             assertFalse(targetMethod().isStatic(), &quot;static calls are only allowed for non-static methods (%s)&quot;, targetMethod());
112         }
113         return super.verify();
114     }
115 
116     @Override
117     public String toString(Verbosity verbosity) {
118         if (verbosity == Verbosity.Long) {
119             return super.toString(Verbosity.Short) + &quot;(&quot; + targetMethod() + &quot;)&quot;;
120         } else {
121             return super.toString(verbosity);
122         }
123     }
124 
125     public static ResolvedJavaMethod findSpecialCallTarget(InvokeKind invokeKind, ValueNode receiver, ResolvedJavaMethod targetMethod, ResolvedJavaType contextType) {
126         if (invokeKind.isDirect()) {
127             return null;
128         }
129 
130         // check for trivial cases (e.g. final methods, nonvirtual methods)
131         if (targetMethod.canBeStaticallyBound()) {
132             return targetMethod;
133         }
134 
135         return devirtualizeCall(invokeKind, targetMethod, contextType, receiver.graph().getAssumptions(), receiver.stamp(NodeView.DEFAULT));
136     }
137 
138     public static ResolvedJavaMethod devirtualizeCall(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ResolvedJavaType contextType, Assumptions assumptions, Stamp receiverStamp) {
139         TypeReference type = StampTool.typeReferenceOrNull(receiverStamp);
140         if (type == null &amp;&amp; invokeKind == InvokeKind.Virtual) {
141             // For virtual calls, we are guaranteed to receive a correct receiver type.
142             type = TypeReference.createTrusted(assumptions, targetMethod.getDeclaringClass());
143         }
144 
145         if (type != null) {
146             /*
147              * either the holder class is exact, or the receiver object has an exact type, or it&#39;s
148              * an array type
149              */
150             ResolvedJavaMethod resolvedMethod = type.getType().resolveConcreteMethod(targetMethod, contextType);
151             if (resolvedMethod != null &amp;&amp; (resolvedMethod.canBeStaticallyBound() || type.isExact() || type.getType().isArray())) {
152                 return resolvedMethod;
153             }
154 
155             AssumptionResult&lt;ResolvedJavaMethod&gt; uniqueConcreteMethod = type.getType().findUniqueConcreteMethod(targetMethod);
156             if (uniqueConcreteMethod != null &amp;&amp; uniqueConcreteMethod.canRecordTo(assumptions)) {
157                 uniqueConcreteMethod.recordTo(assumptions);
158                 return uniqueConcreteMethod.getResult();
159             }
160         }
161         return null;
162     }
163 
164     @Override
165     public void simplify(SimplifierTool tool) {
166         // attempt to devirtualize the call
167         if (invoke().getContextMethod() == null) {
168             // avoid invokes that have placeholder bcis: they do not have a valid contextType
169             assert (invoke().stateAfter() != null &amp;&amp; BytecodeFrame.isPlaceholderBci(invoke().stateAfter().bci)) || BytecodeFrame.isPlaceholderBci(invoke().stateDuring().bci);
170             return;
171         }
172         ResolvedJavaType contextType = (invoke().stateAfter() == null &amp;&amp; invoke().stateDuring() == null) ? null : invoke().getContextType();
173         ResolvedJavaMethod specialCallTarget = findSpecialCallTarget(invokeKind, receiver(), targetMethod, contextType);
174         if (specialCallTarget != null) {
175             this.setTargetMethod(specialCallTarget);
176             setInvokeKind(InvokeKind.Special);
177             return;
178         }
179 
180         Assumptions assumptions = graph().getAssumptions();
181         /*
182          * Even though we are not registering an assumption (see comment below), the optimization is
183          * only valid when speculative optimizations are enabled.
184          */
185         if (invokeKind().isIndirect() &amp;&amp; invokeKind().isInterface() &amp;&amp; assumptions != null) {
186 
187             // check if the type of the receiver can narrow the result
188             ValueNode receiver = receiver();
189 
190             // try to turn a interface call into a virtual call
191             ResolvedJavaType declaredReceiverType = targetMethod().getDeclaringClass();
192 
193             /*
194              * We need to check the invoke kind to avoid recursive simplification for virtual
195              * interface methods calls.
196              */
197             if (declaredReceiverType.isInterface()) {
198                 ResolvedJavaType singleImplementor = declaredReceiverType.getSingleImplementor();
199                 if (singleImplementor != null &amp;&amp; !singleImplementor.equals(declaredReceiverType)) {
200                     TypeReference speculatedType = TypeReference.createTrusted(assumptions, singleImplementor);
201                     if (tryCheckCastSingleImplementor(receiver, speculatedType)) {
202                         return;
203                     }
204                 }
205             }
206 
207             if (receiver instanceof UncheckedInterfaceProvider) {
208                 UncheckedInterfaceProvider uncheckedInterfaceProvider = (UncheckedInterfaceProvider) receiver;
209                 Stamp uncheckedStamp = uncheckedInterfaceProvider.uncheckedStamp();
210                 if (uncheckedStamp != null) {
211                     TypeReference speculatedType = StampTool.typeReferenceOrNull(uncheckedStamp);
212                     if (speculatedType != null) {
213                         tryCheckCastSingleImplementor(receiver, speculatedType);
214                     }
215                 }
216             }
217         }
218     }
219 
220     private boolean tryCheckCastSingleImplementor(ValueNode receiver, TypeReference speculatedType) {
221         ResolvedJavaType singleImplementor = speculatedType.getType();
222         if (singleImplementor != null) {
223             ResolvedJavaMethod singleImplementorMethod = singleImplementor.resolveConcreteMethod(targetMethod(), invoke().getContextType());
224             if (singleImplementorMethod != null) {
225                 /**
226                  * We have an invoke on an interface with a single implementor. We can replace this
227                  * with an invoke virtual.
228                  *
229                  * To do so we need to ensure two properties: 1) the receiver must implement the
230                  * interface (declaredReceiverType). The verifier does not prove this so we need a
231                  * dynamic check. 2) we need to ensure that there is still only one implementor of
232                  * this interface, i.e. that we are calling the right method. We could do this with
233                  * an assumption but as we need an instanceof check anyway we can verify both
234                  * properties by checking of the receiver is an instance of the single implementor.
235                  */
<a name="4" id="anc4"></a><span class="line-modified">236                 AnchoringNode anchor = BeginNode.prevBegin(invoke().asNode());</span>




237                 LogicNode condition = graph().addOrUniqueWithInputs(InstanceOfNode.create(speculatedType, receiver, getProfile(), anchor));
238                 FixedGuardNode guard = graph().add(new FixedGuardNode(condition, DeoptimizationReason.OptimizedTypeCheckViolated, DeoptimizationAction.InvalidateRecompile, false));
239                 graph().addBeforeFixed(invoke().asNode(), guard);
240                 ValueNode valueNode = graph().addOrUnique(new PiNode(receiver, StampFactory.objectNonNull(speculatedType), guard));
241                 arguments().set(0, valueNode);
242                 if (speculatedType.isExact()) {
243                     setInvokeKind(InvokeKind.Special);
244                 } else {
245                     setInvokeKind(InvokeKind.Virtual);
246                 }
247                 setTargetMethod(singleImplementorMethod);
248                 return true;
249             }
250         }
251         return false;
252     }
253 
254     public JavaTypeProfile getProfile() {
255         return profile;
256     }
257 
258     @Override
259     public String targetName() {
260         if (targetMethod() == null) {
261             return &quot;??Invalid!&quot;;
262         }
263         return targetMethod().format(&quot;%h.%n&quot;);
264     }
265 
266     public static MethodCallTargetNode find(StructuredGraph graph, ResolvedJavaMethod method) {
267         for (MethodCallTargetNode target : graph.getNodes(MethodCallTargetNode.TYPE)) {
268             if (target.targetMethod().equals(method)) {
269                 return target;
270             }
271         }
272         return null;
273     }
<a name="5" id="anc5"></a><span class="line-added">274 </span>
<span class="line-added">275     public void setJavaTypeProfile(JavaTypeProfile profile) {</span>
<span class="line-added">276         this.profile = profile;</span>
<span class="line-added">277     }</span>
278 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
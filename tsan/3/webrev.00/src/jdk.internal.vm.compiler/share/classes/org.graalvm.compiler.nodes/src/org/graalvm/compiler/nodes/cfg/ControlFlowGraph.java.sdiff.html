<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/cfg/ControlFlowGraph.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Block.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../debug/StringToBytesNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/cfg/ControlFlowGraph.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.cfg;
 26 
 27 import static org.graalvm.compiler.core.common.cfg.AbstractBlockBase.BLOCK_ID_COMPARATOR;
 28 
 29 import java.util.ArrayList;
 30 import java.util.Arrays;
 31 import java.util.BitSet;
 32 import java.util.List;
 33 
 34 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;
 35 import org.graalvm.compiler.core.common.cfg.CFGVerifier;
 36 import org.graalvm.compiler.core.common.cfg.Loop;
 37 import org.graalvm.compiler.debug.DebugContext;
 38 import org.graalvm.compiler.debug.GraalError;
 39 import org.graalvm.compiler.graph.Node;
 40 import org.graalvm.compiler.graph.NodeMap;

 41 import org.graalvm.compiler.nodes.AbstractBeginNode;
 42 import org.graalvm.compiler.nodes.AbstractEndNode;
 43 import org.graalvm.compiler.nodes.ControlSinkNode;
 44 import org.graalvm.compiler.nodes.ControlSplitNode;
 45 import org.graalvm.compiler.nodes.EndNode;
 46 import org.graalvm.compiler.nodes.FixedNode;
 47 import org.graalvm.compiler.nodes.FixedWithNextNode;
 48 import org.graalvm.compiler.nodes.IfNode;
 49 import org.graalvm.compiler.nodes.LoopBeginNode;
 50 import org.graalvm.compiler.nodes.LoopEndNode;
 51 import org.graalvm.compiler.nodes.LoopExitNode;
 52 import org.graalvm.compiler.nodes.MergeNode;
 53 import org.graalvm.compiler.nodes.StructuredGraph;
 54 
 55 public final class ControlFlowGraph implements AbstractControlFlowGraph&lt;Block&gt; {
 56     /**
 57      * Don&#39;t allow relative frequency values to be become too small or too high as this makes
 58      * frequency calculations over- or underflow the range of a double. This commonly happens with
 59      * infinite loops within infinite loops. The value is chosen a bit lower than half the maximum
 60      * exponent supported by double. That way we can never overflow to infinity when multiplying two
</pre>
<hr />
<pre>
193             this.block = block;
194             this.next = next;
195         }
196 
197         private final Block block;
198         private final DeferredExit next;
199 
200         public Block getBlock() {
201             return block;
202         }
203 
204         public DeferredExit getNext() {
205             return next;
206         }
207 
208     }
209 
210     public static void addDeferredExit(DeferredExit[] deferredExits, Block b) {
211         Loop&lt;Block&gt; outermostExited = b.getDominator().getLoop();
212         Loop&lt;Block&gt; exitBlockLoop = b.getLoop();
<span class="line-modified">213         assert outermostExited != null;</span>
214         while (outermostExited.getParent() != null &amp;&amp; outermostExited.getParent() != exitBlockLoop) {
215             outermostExited = outermostExited.getParent();
216         }
217         int loopIndex = outermostExited.getIndex();
218         deferredExits[loopIndex] = new DeferredExit(b, deferredExits[loopIndex]);
219     }
220 
221     @SuppressWarnings({&quot;unchecked&quot;})
222     public &lt;V&gt; void visitDominatorTreeDeferLoopExits(RecursiveVisitor&lt;V&gt; visitor) {
223         Block[] stack = new Block[getBlocks().length];
224         int tos = 0;
225         BitSet visited = new BitSet(getBlocks().length);
226         int loopCount = getLoops().size();
227         DeferredExit[] deferredExits = new DeferredExit[loopCount];
228         Object[] values = null;
229         int valuesTOS = 0;
230         stack[0] = getStartBlock();
231 
232         while (tos &gt;= 0) {
233             Block cur = stack[tos];
</pre>
<hr />
<pre>
300     }
301 
302     private ControlFlowGraph(StructuredGraph graph) {
303         this.graph = graph;
304         this.nodeToBlock = graph.createNodeMap();
305     }
306 
307     private void computeDominators() {
308         assert reversePostOrder[0].getPredecessorCount() == 0 : &quot;start block has no predecessor and therefore no dominator&quot;;
309         Block[] blocks = reversePostOrder;
310         int curMaxDominatorDepth = 0;
311         for (int i = 1; i &lt; blocks.length; i++) {
312             Block block = blocks[i];
313             assert block.getPredecessorCount() &gt; 0;
314             Block dominator = null;
315             for (Block pred : block.getPredecessors()) {
316                 if (!pred.isLoopEnd()) {
317                     dominator = ((dominator == null) ? pred : commonDominatorRaw(dominator, pred));
318                 }
319             }



320 
321             // Set dominator.
322             block.setDominator(dominator);
323 
324             // Keep dominated linked list sorted by block ID such that predecessor blocks are always
325             // before successor blocks.
326             Block currentDominated = dominator.getFirstDominated();
327             if (currentDominated != null &amp;&amp; currentDominated.getId() &lt; block.getId()) {
328                 while (currentDominated.getDominatedSibling() != null &amp;&amp; currentDominated.getDominatedSibling().getId() &lt; block.getId()) {
329                     currentDominated = currentDominated.getDominatedSibling();
330                 }
331                 block.setDominatedSibling(currentDominated.getDominatedSibling());
332                 currentDominated.setDominatedSibling(block);
333             } else {
334                 block.setDominatedSibling(dominator.getFirstDominated());
335                 dominator.setFirstDominated(block);
336             }
337 
338             curMaxDominatorDepth = Math.max(curMaxDominatorDepth, block.getDominatorDepth());
339         }
</pre>
<hr />
<pre>
396         return reversePostOrder;
397     }
398 
399     @Override
400     public Block getStartBlock() {
401         return reversePostOrder[0];
402     }
403 
404     public Block[] reversePostOrder() {
405         return reversePostOrder;
406     }
407 
408     public NodeMap&lt;Block&gt; getNodeToBlock() {
409         return nodeToBlock;
410     }
411 
412     public Block blockFor(Node node) {
413         return nodeToBlock.get(node);
414     }
415 









416     @Override
417     public List&lt;Loop&lt;Block&gt;&gt; getLoops() {
418         return loops;
419     }
420 
421     public int getMaxDominatorDepth() {
422         return maxDominatorDepth;
423     }
424 
425     private void identifyBlock(Block block) {
426         FixedWithNextNode cur = block.getBeginNode();
427         while (true) {
428             assert cur.isAlive() : cur;
429             assert nodeToBlock.get(cur) == null;
430             nodeToBlock.set(cur, block);
431             FixedNode next = cur.next();
432             if (next instanceof AbstractBeginNode) {
433                 block.endNode = cur;
434                 return;
435             } else if (next instanceof FixedWithNextNode) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.cfg;
 26 
 27 import static org.graalvm.compiler.core.common.cfg.AbstractBlockBase.BLOCK_ID_COMPARATOR;
 28 
 29 import java.util.ArrayList;
 30 import java.util.Arrays;
 31 import java.util.BitSet;
 32 import java.util.List;
 33 
 34 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;
 35 import org.graalvm.compiler.core.common.cfg.CFGVerifier;
 36 import org.graalvm.compiler.core.common.cfg.Loop;
 37 import org.graalvm.compiler.debug.DebugContext;
 38 import org.graalvm.compiler.debug.GraalError;
 39 import org.graalvm.compiler.graph.Node;
 40 import org.graalvm.compiler.graph.NodeMap;
<span class="line-added"> 41 import org.graalvm.compiler.graph.iterators.NodeIterable;</span>
 42 import org.graalvm.compiler.nodes.AbstractBeginNode;
 43 import org.graalvm.compiler.nodes.AbstractEndNode;
 44 import org.graalvm.compiler.nodes.ControlSinkNode;
 45 import org.graalvm.compiler.nodes.ControlSplitNode;
 46 import org.graalvm.compiler.nodes.EndNode;
 47 import org.graalvm.compiler.nodes.FixedNode;
 48 import org.graalvm.compiler.nodes.FixedWithNextNode;
 49 import org.graalvm.compiler.nodes.IfNode;
 50 import org.graalvm.compiler.nodes.LoopBeginNode;
 51 import org.graalvm.compiler.nodes.LoopEndNode;
 52 import org.graalvm.compiler.nodes.LoopExitNode;
 53 import org.graalvm.compiler.nodes.MergeNode;
 54 import org.graalvm.compiler.nodes.StructuredGraph;
 55 
 56 public final class ControlFlowGraph implements AbstractControlFlowGraph&lt;Block&gt; {
 57     /**
 58      * Don&#39;t allow relative frequency values to be become too small or too high as this makes
 59      * frequency calculations over- or underflow the range of a double. This commonly happens with
 60      * infinite loops within infinite loops. The value is chosen a bit lower than half the maximum
 61      * exponent supported by double. That way we can never overflow to infinity when multiplying two
</pre>
<hr />
<pre>
194             this.block = block;
195             this.next = next;
196         }
197 
198         private final Block block;
199         private final DeferredExit next;
200 
201         public Block getBlock() {
202             return block;
203         }
204 
205         public DeferredExit getNext() {
206             return next;
207         }
208 
209     }
210 
211     public static void addDeferredExit(DeferredExit[] deferredExits, Block b) {
212         Loop&lt;Block&gt; outermostExited = b.getDominator().getLoop();
213         Loop&lt;Block&gt; exitBlockLoop = b.getLoop();
<span class="line-modified">214         assert outermostExited != null : &quot;Dominator must be in a loop. Possible cause is a missing loop exit node.&quot;;</span>
215         while (outermostExited.getParent() != null &amp;&amp; outermostExited.getParent() != exitBlockLoop) {
216             outermostExited = outermostExited.getParent();
217         }
218         int loopIndex = outermostExited.getIndex();
219         deferredExits[loopIndex] = new DeferredExit(b, deferredExits[loopIndex]);
220     }
221 
222     @SuppressWarnings({&quot;unchecked&quot;})
223     public &lt;V&gt; void visitDominatorTreeDeferLoopExits(RecursiveVisitor&lt;V&gt; visitor) {
224         Block[] stack = new Block[getBlocks().length];
225         int tos = 0;
226         BitSet visited = new BitSet(getBlocks().length);
227         int loopCount = getLoops().size();
228         DeferredExit[] deferredExits = new DeferredExit[loopCount];
229         Object[] values = null;
230         int valuesTOS = 0;
231         stack[0] = getStartBlock();
232 
233         while (tos &gt;= 0) {
234             Block cur = stack[tos];
</pre>
<hr />
<pre>
301     }
302 
303     private ControlFlowGraph(StructuredGraph graph) {
304         this.graph = graph;
305         this.nodeToBlock = graph.createNodeMap();
306     }
307 
308     private void computeDominators() {
309         assert reversePostOrder[0].getPredecessorCount() == 0 : &quot;start block has no predecessor and therefore no dominator&quot;;
310         Block[] blocks = reversePostOrder;
311         int curMaxDominatorDepth = 0;
312         for (int i = 1; i &lt; blocks.length; i++) {
313             Block block = blocks[i];
314             assert block.getPredecessorCount() &gt; 0;
315             Block dominator = null;
316             for (Block pred : block.getPredecessors()) {
317                 if (!pred.isLoopEnd()) {
318                     dominator = ((dominator == null) ? pred : commonDominatorRaw(dominator, pred));
319                 }
320             }
<span class="line-added">321             // Fortify: Suppress Null Dereference false positive (every block apart from the first</span>
<span class="line-added">322             // is guaranteed to have a predecessor)</span>
<span class="line-added">323             assert dominator != null;</span>
324 
325             // Set dominator.
326             block.setDominator(dominator);
327 
328             // Keep dominated linked list sorted by block ID such that predecessor blocks are always
329             // before successor blocks.
330             Block currentDominated = dominator.getFirstDominated();
331             if (currentDominated != null &amp;&amp; currentDominated.getId() &lt; block.getId()) {
332                 while (currentDominated.getDominatedSibling() != null &amp;&amp; currentDominated.getDominatedSibling().getId() &lt; block.getId()) {
333                     currentDominated = currentDominated.getDominatedSibling();
334                 }
335                 block.setDominatedSibling(currentDominated.getDominatedSibling());
336                 currentDominated.setDominatedSibling(block);
337             } else {
338                 block.setDominatedSibling(dominator.getFirstDominated());
339                 dominator.setFirstDominated(block);
340             }
341 
342             curMaxDominatorDepth = Math.max(curMaxDominatorDepth, block.getDominatorDepth());
343         }
</pre>
<hr />
<pre>
400         return reversePostOrder;
401     }
402 
403     @Override
404     public Block getStartBlock() {
405         return reversePostOrder[0];
406     }
407 
408     public Block[] reversePostOrder() {
409         return reversePostOrder;
410     }
411 
412     public NodeMap&lt;Block&gt; getNodeToBlock() {
413         return nodeToBlock;
414     }
415 
416     public Block blockFor(Node node) {
417         return nodeToBlock.get(node);
418     }
419 
<span class="line-added">420     public Block commonDominatorFor(NodeIterable&lt;? extends Node&gt; nodes) {</span>
<span class="line-added">421         Block commonDom = null;</span>
<span class="line-added">422         for (Node n : nodes) {</span>
<span class="line-added">423             Block b = blockFor(n);</span>
<span class="line-added">424             commonDom = (Block) AbstractControlFlowGraph.commonDominator(commonDom, b);</span>
<span class="line-added">425         }</span>
<span class="line-added">426         return commonDom;</span>
<span class="line-added">427     }</span>
<span class="line-added">428 </span>
429     @Override
430     public List&lt;Loop&lt;Block&gt;&gt; getLoops() {
431         return loops;
432     }
433 
434     public int getMaxDominatorDepth() {
435         return maxDominatorDepth;
436     }
437 
438     private void identifyBlock(Block block) {
439         FixedWithNextNode cur = block.getBeginNode();
440         while (true) {
441             assert cur.isAlive() : cur;
442             assert nodeToBlock.get(cur) == null;
443             nodeToBlock.set(cur, block);
444             FixedNode next = cur.next();
445             if (next instanceof AbstractBeginNode) {
446                 block.endNode = cur;
447                 return;
448             } else if (next instanceof FixedWithNextNode) {
</pre>
</td>
</tr>
</table>
<center><a href="Block.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../debug/StringToBytesNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
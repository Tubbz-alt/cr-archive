<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/GraphBuilderContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.graphbuilderconf;
 26 
 27 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateReprofile;
 28 import static jdk.vm.ci.meta.DeoptimizationReason.NullCheckException;
 29 import static org.graalvm.compiler.core.common.type.StampFactory.objectNonNull;
 30 
 31 import org.graalvm.compiler.bytecode.Bytecode;
 32 import org.graalvm.compiler.bytecode.BytecodeProvider;
 33 import org.graalvm.compiler.core.common.type.AbstractPointerStamp;
 34 import org.graalvm.compiler.core.common.type.Stamp;
 35 import org.graalvm.compiler.core.common.type.StampFactory;
 36 import org.graalvm.compiler.core.common.type.StampPair;
 37 import org.graalvm.compiler.debug.GraalError;
 38 import org.graalvm.compiler.nodes.AbstractBeginNode;
 39 import org.graalvm.compiler.nodes.AbstractMergeNode;
 40 import org.graalvm.compiler.nodes.CallTargetNode;
 41 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 42 import org.graalvm.compiler.nodes.ConstantNode;
 43 import org.graalvm.compiler.nodes.DynamicPiNode;
 44 import org.graalvm.compiler.nodes.FixedGuardNode;
 45 import org.graalvm.compiler.nodes.Invoke;
 46 import org.graalvm.compiler.nodes.LogicNode;
 47 import org.graalvm.compiler.nodes.NodeView;
 48 import org.graalvm.compiler.nodes.PiNode;
 49 import org.graalvm.compiler.nodes.StateSplit;
 50 import org.graalvm.compiler.nodes.StructuredGraph;
 51 import org.graalvm.compiler.nodes.ValueNode;
 52 import org.graalvm.compiler.nodes.calc.IsNullNode;
 53 import org.graalvm.compiler.nodes.calc.NarrowNode;
 54 import org.graalvm.compiler.nodes.calc.SignExtendNode;
 55 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
 56 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
 57 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 58 import org.graalvm.compiler.nodes.type.StampTool;
 59 
 60 import jdk.vm.ci.code.BailoutException;
 61 import jdk.vm.ci.meta.Assumptions;
 62 import jdk.vm.ci.meta.DeoptimizationAction;
 63 import jdk.vm.ci.meta.DeoptimizationReason;
 64 import jdk.vm.ci.meta.JavaKind;
 65 import jdk.vm.ci.meta.JavaType;
 66 import jdk.vm.ci.meta.ResolvedJavaMethod;
 67 
 68 /**
 69  * Used by a {@link GraphBuilderPlugin} to interface with an object that parses the bytecode of a
 70  * single {@linkplain #getMethod() method} as part of building a {@linkplain #getGraph() graph} .
 71  */
 72 public interface GraphBuilderContext extends GraphBuilderTool {
 73 
 74     /**
 75      * Pushes a given value to the frame state stack using an explicit kind. This should be used
 76      * when {@code value.getJavaKind()} is different from the kind that the bytecode instruction
 77      * currently being parsed pushes to the stack.
 78      *
 79      * @param kind the kind to use when type checking this operation
 80      * @param value the value to push to the stack. The value must already have been
 81      *            {@linkplain #append(ValueNode) appended}.
 82      */
 83     void push(JavaKind kind, ValueNode value);
 84 
 85     /**
 86      * Pops a value from the frame state stack using an explicit kind.
 87      *
 88      * @param slotKind the kind to use when type checking this operation
 89      * @return the value on the top of the stack
 90      */
 91     default ValueNode pop(JavaKind slotKind) {
 92         throw GraalError.unimplemented();
 93     }
 94 
 95     /**
 96      * Adds a node and all its inputs to the graph. If the node is in the graph, returns
 97      * immediately. If the node is a {@link StateSplit} with a null
 98      * {@linkplain StateSplit#stateAfter() frame state} , the frame state is initialized.
 99      *
100      * @param value the value to add to the graph and push to the stack. The
101      *            {@code value.getJavaKind()} kind is used when type checking this operation.
102      * @return a node equivalent to {@code value} in the graph
103      */
104     default &lt;T extends ValueNode&gt; T add(T value) {
105         if (value.graph() != null) {
106             assert !(value instanceof StateSplit) || ((StateSplit) value).stateAfter() != null;
107             return value;
108         }
109         return GraphBuilderContextUtil.setStateAfterIfNecessary(this, append(value));
110     }
111 
112     default ValueNode addNonNullCast(ValueNode value) {
113         AbstractPointerStamp valueStamp = (AbstractPointerStamp) value.stamp(NodeView.DEFAULT);
114         if (valueStamp.nonNull()) {
115             return value;
116         } else {
117             LogicNode isNull = add(IsNullNode.create(value));
118             FixedGuardNode fixedGuard = add(new FixedGuardNode(isNull, DeoptimizationReason.NullCheckException, DeoptimizationAction.None, true));
119             Stamp newStamp = valueStamp.improveWith(StampFactory.objectNonNull());
120             return add(PiNode.create(value, newStamp, fixedGuard));
121         }
122     }
123 
124     /**
125      * Adds a node with a non-void kind to the graph, pushes it to the stack. If the returned node
126      * is a {@link StateSplit} with a null {@linkplain StateSplit#stateAfter() frame state}, the
127      * frame state is initialized.
128      *
129      * @param kind the kind to use when type checking this operation
130      * @param value the value to add to the graph and push to the stack
131      * @return a node equivalent to {@code value} in the graph
132      */
133     default &lt;T extends ValueNode&gt; T addPush(JavaKind kind, T value) {
134         T equivalentValue = value.graph() != null ? value : append(value);
135         push(kind, equivalentValue);
136         return GraphBuilderContextUtil.setStateAfterIfNecessary(this, equivalentValue);
137     }
138 
139     /**
140      * Handles an invocation that a plugin determines can replace the original invocation (i.e., the
141      * one for which the plugin was applied). This applies all standard graph builder processing to
142      * the replaced invocation including applying any relevant plugins.
143      *
144      * @param invokeKind the kind of the replacement invocation
145      * @param targetMethod the target of the replacement invocation
146      * @param args the arguments to the replacement invocation
147      * @param forceInlineEverything specifies if all invocations encountered in the scope of
148      *            handling the replaced invoke are to be force inlined
149      */
150     Invoke handleReplacedInvoke(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, boolean forceInlineEverything);
151 
152     void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType);
153 
154     /**
155      * Intrinsifies an invocation of a given method by inlining the bytecodes of a given
156      * substitution method.
157      *
158      * @param bytecodeProvider used to get the bytecodes to parse for the substitution method
159      * @param targetMethod the method being intrinsified
160      * @param substitute the intrinsic implementation
161      * @param receiver the receiver, or null for static methods
162      * @param argsIncludingReceiver the arguments with which to inline the invocation
163      *
164      * @return whether the intrinsification was successful
165      */
166     boolean intrinsify(BytecodeProvider bytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] argsIncludingReceiver);
167 
168     /**
169      * Intrinsifies an invocation of a given method by inlining the graph of a given substitution
170      * method.
171      *
172      * @param targetMethod the method being intrinsified
173      * @param substituteGraph the intrinsic implementation
174      * @param receiver the receiver, or null for static methods
175      * @param argsIncludingReceiver the arguments with which to inline the invocation
176      *
177      * @return whether the intrinsification was successful
178      */
179     boolean intrinsify(ResolvedJavaMethod targetMethod, StructuredGraph substituteGraph, InvocationPlugin.Receiver receiver, ValueNode[] argsIncludingReceiver);
180 
181     /**
182      * Creates a snap shot of the current frame state with the BCI of the instruction after the one
183      * currently being parsed and assigns it to a given {@linkplain StateSplit#hasSideEffect() side
184      * effect} node.
185      *
186      * @param sideEffect a side effect node just appended to the graph
187      */
188     void setStateAfter(StateSplit sideEffect);
189 
190     /**
191      * Gets the parsing context for the method that inlines the method being parsed by this context.
192      */
193     GraphBuilderContext getParent();
194 
195     /**
196      * Gets the first ancestor parsing context that is not parsing a {@linkplain #parsingIntrinsic()
197      * intrinsic}.
198      */
199     default GraphBuilderContext getNonIntrinsicAncestor() {
200         GraphBuilderContext ancestor = getParent();
201         while (ancestor != null &amp;&amp; ancestor.parsingIntrinsic()) {
202             ancestor = ancestor.getParent();
203         }
204         return ancestor;
205     }
206 
207     /**
208      * Gets the code being parsed.
209      */
210     Bytecode getCode();
211 
212     /**
213      * Gets the method being parsed by this context.
214      */
215     ResolvedJavaMethod getMethod();
216 
217     /**
218      * Gets the index of the bytecode instruction currently being parsed.
219      */
220     int bci();
221 
222     /**
223      * Gets the kind of invocation currently being parsed.
224      */
225     InvokeKind getInvokeKind();
226 
227     /**
228      * Gets the return type of the invocation currently being parsed.
229      */
230     JavaType getInvokeReturnType();
231 
232     default StampPair getInvokeReturnStamp(Assumptions assumptions) {
233         JavaType returnType = getInvokeReturnType();
234         return StampFactory.forDeclaredType(assumptions, returnType, false);
235     }
236 
237     /**
238      * Gets the inline depth of this context. A return value of 0 implies that this is the context
239      * for the parse root.
240      */
241     default int getDepth() {
242         GraphBuilderContext parent = getParent();
243         int result = 0;
244         while (parent != null) {
245             result++;
246             parent = parent.getParent();
247         }
248         return result;
249     }
250 
251     /**
252      * Determines if this parsing context is within the bytecode of an intrinsic or a method inlined
253      * by an intrinsic.
254      */
255     @Override
256     default boolean parsingIntrinsic() {
257         return getIntrinsic() != null;
258     }
259 
260     /**
261      * Determines if a graph builder plugin is enabled under current context.
262      */
263     default boolean isPluginEnabled(GraphBuilderPlugin plugin) {
264         return parsingIntrinsic() || !(plugin instanceof GeneratedInvocationPlugin &amp;&amp; ((GeneratedInvocationPlugin) plugin).isGeneratedFromFoldOrNodeIntrinsic());
265     }
266 
267     /**
268      * Gets the intrinsic of the current parsing context or {@code null} if not
269      * {@link #parsingIntrinsic() parsing an intrinsic}.
270      */
271     IntrinsicContext getIntrinsic();
272 
273     BailoutException bailout(String string);
274 
275     default ValueNode nullCheckedValue(ValueNode value) {
276         return nullCheckedValue(value, InvalidateReprofile);
277     }
278 
279     /**
280      * Gets a version of a given value that has a {@linkplain StampTool#isPointerNonNull(ValueNode)
281      * non-null} stamp.
282      */
283     default ValueNode nullCheckedValue(ValueNode value, DeoptimizationAction action) {
284         if (!StampTool.isPointerNonNull(value)) {
285             LogicNode condition = getGraph().unique(IsNullNode.create(value));
286             FixedGuardNode fixedGuard = append(new FixedGuardNode(condition, NullCheckException, action, true));
287             ValueNode nonNullReceiver = getGraph().addOrUniqueWithInputs(PiNode.create(value, objectNonNull(), fixedGuard));
288             // TODO: Propogating the non-null into the frame state would
289             // remove subsequent null-checks on the same value. However,
290             // it currently causes an assertion failure when merging states.
291             //
292             // frameState.replace(value, nonNullReceiver);
293             return nonNullReceiver;
294         }
295         return value;
296     }
297 
298     default void genCheckcastDynamic(ValueNode object, ValueNode javaClass) {
299         LogicNode condition = InstanceOfDynamicNode.create(getAssumptions(), getConstantReflection(), javaClass, object, true);
300         if (condition.isTautology()) {
301             addPush(JavaKind.Object, object);
302         } else {
303             append(condition);
304             FixedGuardNode fixedGuard = add(new FixedGuardNode(condition, DeoptimizationReason.ClassCastException, DeoptimizationAction.InvalidateReprofile, false));
305             addPush(JavaKind.Object, DynamicPiNode.create(getAssumptions(), getConstantReflection(), object, fixedGuard, javaClass));
306         }
307     }
308 
309     @SuppressWarnings(&quot;unused&quot;)
310     default void notifyReplacedCall(ResolvedJavaMethod targetMethod, ConstantNode node) {
311 
312     }
313 
314     /**
315      * Interface whose instances hold inlining information about the current context, in a wider
316      * sense. The wider sense in this case concerns graph building approaches that don&#39;t necessarily
317      * keep a chain of {@link GraphBuilderContext} instances normally available through
318      * {@linkplain #getParent()}. Examples of such approaches are partial evaluation and incremental
319      * inlining.
320      */
321     interface ExternalInliningContext {
322         int getInlinedDepth();
323     }
324 
325     default ExternalInliningContext getExternalInliningContext() {
326         return null;
327     }
328 
329     /**
330      * Adds masking to a given subword value according to a given {@Link JavaKind}, such that the
331      * masked value falls in the range of the given kind. In the cases where the given kind is not a
332      * subword kind, the input value is returned immediately.
333      *
334      * @param value the value to be masked
335      * @param kind the kind that specifies the range of the masked value
336      * @return the masked value
337      */
338     default ValueNode maskSubWordValue(ValueNode value, JavaKind kind) {
339         if (kind == kind.getStackKind()) {
340             return value;
341         }
342         // Subword value
343         ValueNode narrow = append(NarrowNode.create(value, kind.getBitCount(), NodeView.DEFAULT));
344         if (kind.isUnsigned()) {
345             return append(ZeroExtendNode.create(narrow, 32, NodeView.DEFAULT));
346         } else {
347             return append(SignExtendNode.create(narrow, 32, NodeView.DEFAULT));
348         }
349     }
350 
351     /**
352      * @return true if an explicit exception check should be emitted.
353      */
354     default boolean needsExplicitException() {
355         return false;
356     }
357 
358     /**
359      * Generates an exception edge for the current bytecode. When {@link #needsExplicitException()}
360      * returns true, this method should return non-null begin nodes.
361      *
362      * @param exceptionKind the type of exception to be created.
363      * @return a begin node that precedes the actual exception instantiation code.
364      */
365     default AbstractBeginNode genExplicitExceptionEdge(@SuppressWarnings(&quot;ununsed&quot;) BytecodeExceptionKind exceptionKind) {
366         return null;
367     }
368 }
369 
370 class GraphBuilderContextUtil {
371     static &lt;T extends ValueNode&gt; T setStateAfterIfNecessary(GraphBuilderContext b, T value) {
372         if (value instanceof StateSplit) {
373             StateSplit stateSplit = (StateSplit) value;
374             if (stateSplit.stateAfter() == null &amp;&amp; (stateSplit.hasSideEffect() || stateSplit instanceof AbstractMergeNode)) {
375                 b.setStateAfter(stateSplit);
376             }
377         }
378         return value;
379     }
380 }
    </pre>
  </body>
</html>
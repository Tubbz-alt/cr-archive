<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/cfg/ControlFlowGraph.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.cfg;
 26 
 27 import static org.graalvm.compiler.core.common.cfg.AbstractBlockBase.BLOCK_ID_COMPARATOR;
 28 
 29 import java.util.ArrayList;
 30 import java.util.Arrays;
 31 import java.util.BitSet;
 32 import java.util.List;
 33 
 34 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;
 35 import org.graalvm.compiler.core.common.cfg.CFGVerifier;
 36 import org.graalvm.compiler.core.common.cfg.Loop;
 37 import org.graalvm.compiler.debug.DebugContext;
 38 import org.graalvm.compiler.debug.GraalError;
 39 import org.graalvm.compiler.graph.Node;
 40 import org.graalvm.compiler.graph.NodeMap;
 41 import org.graalvm.compiler.graph.iterators.NodeIterable;
 42 import org.graalvm.compiler.nodes.AbstractBeginNode;
 43 import org.graalvm.compiler.nodes.AbstractEndNode;
 44 import org.graalvm.compiler.nodes.ControlSinkNode;
 45 import org.graalvm.compiler.nodes.ControlSplitNode;
 46 import org.graalvm.compiler.nodes.EndNode;
 47 import org.graalvm.compiler.nodes.FixedNode;
 48 import org.graalvm.compiler.nodes.FixedWithNextNode;
 49 import org.graalvm.compiler.nodes.IfNode;
 50 import org.graalvm.compiler.nodes.LoopBeginNode;
 51 import org.graalvm.compiler.nodes.LoopEndNode;
 52 import org.graalvm.compiler.nodes.LoopExitNode;
 53 import org.graalvm.compiler.nodes.MergeNode;
 54 import org.graalvm.compiler.nodes.StructuredGraph;
 55 
 56 public final class ControlFlowGraph implements AbstractControlFlowGraph&lt;Block&gt; {
 57     /**
 58      * Don&#39;t allow relative frequency values to be become too small or too high as this makes
 59      * frequency calculations over- or underflow the range of a double. This commonly happens with
 60      * infinite loops within infinite loops. The value is chosen a bit lower than half the maximum
 61      * exponent supported by double. That way we can never overflow to infinity when multiplying two
 62      * relative frequency values.
 63      */
 64     public static final double MIN_RELATIVE_FREQUENCY = 0x1.0p-500;
 65     public static final double MAX_RELATIVE_FREQUENCY = 1 / MIN_RELATIVE_FREQUENCY;
 66 
 67     public final StructuredGraph graph;
 68 
 69     private NodeMap&lt;Block&gt; nodeToBlock;
 70     private Block[] reversePostOrder;
 71     private List&lt;Loop&lt;Block&gt;&gt; loops;
 72     private int maxDominatorDepth;
 73 
 74     public interface RecursiveVisitor&lt;V&gt; {
 75         V enter(Block b);
 76 
 77         void exit(Block b, V value);
 78     }
 79 
 80     public static ControlFlowGraph compute(StructuredGraph graph, boolean connectBlocks, boolean computeLoops, boolean computeDominators, boolean computePostdominators) {
 81         ControlFlowGraph cfg = new ControlFlowGraph(graph);
 82         cfg.identifyBlocks();
 83         cfg.computeFrequencies();
 84 
 85         if (computeLoops) {
 86             cfg.computeLoopInformation();
 87         }
 88         if (computeDominators) {
 89             cfg.computeDominators();
 90         }
 91         if (computePostdominators) {
 92             cfg.computePostdominators();
 93         }
 94 
 95         // there&#39;s not much to verify when connectBlocks == false
 96         assert !(connectBlocks || computeLoops || computeDominators || computePostdominators) || CFGVerifier.verify(cfg);
 97         return cfg;
 98     }
 99 
100     public String dominatorTreeString() {
101         return dominatorTreeString(getStartBlock());
102     }
103 
104     private static String dominatorTreeString(Block b) {
105         StringBuilder sb = new StringBuilder();
106         sb.append(b);
107         sb.append(&quot;(&quot;);
108         Block firstDominated = b.getFirstDominated();
109         while (firstDominated != null) {
110             if (firstDominated.getDominator().getPostdominator() == firstDominated) {
111                 sb.append(&quot;!&quot;);
112             }
113             sb.append(dominatorTreeString(firstDominated));
114             firstDominated = firstDominated.getDominatedSibling();
115         }
116         sb.append(&quot;) &quot;);
117         return sb.toString();
118     }
119 
120     @SuppressWarnings(&quot;unchecked&quot;)
121     public &lt;V&gt; void visitDominatorTreeDefault(RecursiveVisitor&lt;V&gt; visitor) {
122 
123         Block[] stack = new Block[maxDominatorDepth + 1];
124         Block current = getStartBlock();
125         int tos = 0;
126         Object[] values = null;
127         int valuesTOS = 0;
128 
129         while (tos &gt;= 0) {
130             Block state = stack[tos];
131             if (state == null || state.getDominator() == null || state.getDominator().getPostdominator() != state) {
132                 if (state == null) {
133                     // We enter this block for the first time.
134                     V value = visitor.enter(current);
135                     if (value != null || values != null) {
136                         if (values == null) {
137                             values = new Object[maxDominatorDepth + 1];
138                         }
139                         values[valuesTOS++] = value;
140                     }
141 
142                     Block dominated = skipPostDom(current.getFirstDominated());
143                     if (dominated != null) {
144                         // Descend into dominated.
145                         stack[tos] = dominated;
146                         current = dominated;
147                         stack[++tos] = null;
148                         continue;
149                     }
150                 } else {
151                     Block next = skipPostDom(state.getDominatedSibling());
152                     if (next != null) {
153                         // Descend into dominated.
154                         stack[tos] = next;
155                         current = next;
156                         stack[++tos] = null;
157                         continue;
158                     }
159                 }
160 
161                 // Finished processing all normal dominators.
162                 Block postDom = current.getPostdominator();
163                 if (postDom != null &amp;&amp; postDom.getDominator() == current) {
164                     // Descend into post dominator.
165                     stack[tos] = postDom;
166                     current = postDom;
167                     stack[++tos] = null;
168                     continue;
169                 }
170             }
171 
172             // Finished processing this node, exit and pop from stack.
173             V value = null;
174             if (values != null &amp;&amp; valuesTOS &gt; 0) {
175                 value = (V) values[--valuesTOS];
176             }
177             visitor.exit(current, value);
178             current = current.getDominator();
179             --tos;
180         }
181     }
182 
183     private static Block skipPostDom(Block block) {
184         if (block != null &amp;&amp; block.getDominator().getPostdominator() == block) {
185             // This is an always reached block.
186             return block.getDominatedSibling();
187         }
188         return block;
189     }
190 
191     public static final class DeferredExit {
192 
193         public DeferredExit(Block block, DeferredExit next) {
194             this.block = block;
195             this.next = next;
196         }
197 
198         private final Block block;
199         private final DeferredExit next;
200 
201         public Block getBlock() {
202             return block;
203         }
204 
205         public DeferredExit getNext() {
206             return next;
207         }
208 
209     }
210 
211     public static void addDeferredExit(DeferredExit[] deferredExits, Block b) {
212         Loop&lt;Block&gt; outermostExited = b.getDominator().getLoop();
213         Loop&lt;Block&gt; exitBlockLoop = b.getLoop();
214         assert outermostExited != null : &quot;Dominator must be in a loop. Possible cause is a missing loop exit node.&quot;;
215         while (outermostExited.getParent() != null &amp;&amp; outermostExited.getParent() != exitBlockLoop) {
216             outermostExited = outermostExited.getParent();
217         }
218         int loopIndex = outermostExited.getIndex();
219         deferredExits[loopIndex] = new DeferredExit(b, deferredExits[loopIndex]);
220     }
221 
222     @SuppressWarnings({&quot;unchecked&quot;})
223     public &lt;V&gt; void visitDominatorTreeDeferLoopExits(RecursiveVisitor&lt;V&gt; visitor) {
224         Block[] stack = new Block[getBlocks().length];
225         int tos = 0;
226         BitSet visited = new BitSet(getBlocks().length);
227         int loopCount = getLoops().size();
228         DeferredExit[] deferredExits = new DeferredExit[loopCount];
229         Object[] values = null;
230         int valuesTOS = 0;
231         stack[0] = getStartBlock();
232 
233         while (tos &gt;= 0) {
234             Block cur = stack[tos];
235             int curId = cur.getId();
236             if (visited.get(curId)) {
237                 V value = null;
238                 if (values != null &amp;&amp; valuesTOS &gt; 0) {
239                     value = (V) values[--valuesTOS];
240                 }
241                 visitor.exit(cur, value);
242                 --tos;
243                 if (cur.isLoopHeader()) {
244                     int loopIndex = cur.getLoop().getIndex();
245                     DeferredExit deferredExit = deferredExits[loopIndex];
246                     if (deferredExit != null) {
247                         while (deferredExit != null) {
248                             stack[++tos] = deferredExit.block;
249                             deferredExit = deferredExit.next;
250                         }
251                         deferredExits[loopIndex] = null;
252                     }
253                 }
254             } else {
255                 visited.set(curId);
256                 V value = visitor.enter(cur);
257                 if (value != null || values != null) {
258                     if (values == null) {
259                         values = new Object[maxDominatorDepth + 1];
260                     }
261                     values[valuesTOS++] = value;
262                 }
263 
264                 Block alwaysReached = cur.getPostdominator();
265                 if (alwaysReached != null) {
266                     if (alwaysReached.getDominator() != cur) {
267                         alwaysReached = null;
268                     } else if (isDominatorTreeLoopExit(alwaysReached)) {
269                         addDeferredExit(deferredExits, alwaysReached);
270                     } else {
271                         stack[++tos] = alwaysReached;
272                     }
273                 }
274 
275                 Block b = cur.getFirstDominated();
276                 while (b != null) {
277                     if (b != alwaysReached) {
278                         if (isDominatorTreeLoopExit(b)) {
279                             addDeferredExit(deferredExits, b);
280                         } else {
281                             stack[++tos] = b;
282                         }
283                     }
284                     b = b.getDominatedSibling();
285                 }
286             }
287         }
288     }
289 
290     public &lt;V&gt; void visitDominatorTree(RecursiveVisitor&lt;V&gt; visitor, boolean deferLoopExits) {
291         if (deferLoopExits &amp;&amp; this.getLoops().size() &gt; 0) {
292             visitDominatorTreeDeferLoopExits(visitor);
293         } else {
294             visitDominatorTreeDefault(visitor);
295         }
296     }
297 
298     public static boolean isDominatorTreeLoopExit(Block b) {
299         Block dominator = b.getDominator();
300         return dominator != null &amp;&amp; b.getLoop() != dominator.getLoop() &amp;&amp; (!b.isLoopHeader() || dominator.getLoopDepth() &gt;= b.getLoopDepth());
301     }
302 
303     private ControlFlowGraph(StructuredGraph graph) {
304         this.graph = graph;
305         this.nodeToBlock = graph.createNodeMap();
306     }
307 
308     private void computeDominators() {
309         assert reversePostOrder[0].getPredecessorCount() == 0 : &quot;start block has no predecessor and therefore no dominator&quot;;
310         Block[] blocks = reversePostOrder;
311         int curMaxDominatorDepth = 0;
312         for (int i = 1; i &lt; blocks.length; i++) {
313             Block block = blocks[i];
314             assert block.getPredecessorCount() &gt; 0;
315             Block dominator = null;
316             for (Block pred : block.getPredecessors()) {
317                 if (!pred.isLoopEnd()) {
318                     dominator = ((dominator == null) ? pred : commonDominatorRaw(dominator, pred));
319                 }
320             }
321             // Fortify: Suppress Null Dereference false positive (every block apart from the first
322             // is guaranteed to have a predecessor)
323             assert dominator != null;
324 
325             // Set dominator.
326             block.setDominator(dominator);
327 
328             // Keep dominated linked list sorted by block ID such that predecessor blocks are always
329             // before successor blocks.
330             Block currentDominated = dominator.getFirstDominated();
331             if (currentDominated != null &amp;&amp; currentDominated.getId() &lt; block.getId()) {
332                 while (currentDominated.getDominatedSibling() != null &amp;&amp; currentDominated.getDominatedSibling().getId() &lt; block.getId()) {
333                     currentDominated = currentDominated.getDominatedSibling();
334                 }
335                 block.setDominatedSibling(currentDominated.getDominatedSibling());
336                 currentDominated.setDominatedSibling(block);
337             } else {
338                 block.setDominatedSibling(dominator.getFirstDominated());
339                 dominator.setFirstDominated(block);
340             }
341 
342             curMaxDominatorDepth = Math.max(curMaxDominatorDepth, block.getDominatorDepth());
343         }
344         this.maxDominatorDepth = curMaxDominatorDepth;
345         calcDominatorRanges(getStartBlock(), reversePostOrder.length);
346     }
347 
348     private static void calcDominatorRanges(Block block, int size) {
349         Block[] stack = new Block[size];
350         stack[0] = block;
351         int tos = 0;
352         int myNumber = 0;
353 
354         do {
355             Block cur = stack[tos];
356             Block dominated = cur.getFirstDominated();
357 
358             if (cur.getDominatorNumber() == -1) {
359                 cur.setDominatorNumber(myNumber);
360                 if (dominated != null) {
361                     // Push children onto stack.
362                     do {
363                         stack[++tos] = dominated;
364                         dominated = dominated.getDominatedSibling();
365                     } while (dominated != null);
366                 } else {
367                     cur.setMaxChildDomNumber(myNumber);
368                     --tos;
369                 }
370                 ++myNumber;
371             } else {
372                 cur.setMaxChildDomNumber(dominated.getMaxChildDominatorNumber());
373                 --tos;
374             }
375         } while (tos &gt;= 0);
376     }
377 
378     private static Block commonDominatorRaw(Block a, Block b) {
379         int aDomDepth = a.getDominatorDepth();
380         int bDomDepth = b.getDominatorDepth();
381         if (aDomDepth &gt; bDomDepth) {
382             return commonDominatorRawSameDepth(a.getDominator(aDomDepth - bDomDepth), b);
383         } else {
384             return commonDominatorRawSameDepth(a, b.getDominator(bDomDepth - aDomDepth));
385         }
386     }
387 
388     private static Block commonDominatorRawSameDepth(Block a, Block b) {
389         Block iterA = a;
390         Block iterB = b;
391         while (iterA != iterB) {
392             iterA = iterA.getDominator();
393             iterB = iterB.getDominator();
394         }
395         return iterA;
396     }
397 
398     @Override
399     public Block[] getBlocks() {
400         return reversePostOrder;
401     }
402 
403     @Override
404     public Block getStartBlock() {
405         return reversePostOrder[0];
406     }
407 
408     public Block[] reversePostOrder() {
409         return reversePostOrder;
410     }
411 
412     public NodeMap&lt;Block&gt; getNodeToBlock() {
413         return nodeToBlock;
414     }
415 
416     public Block blockFor(Node node) {
417         return nodeToBlock.get(node);
418     }
419 
420     public Block commonDominatorFor(NodeIterable&lt;? extends Node&gt; nodes) {
421         Block commonDom = null;
422         for (Node n : nodes) {
423             Block b = blockFor(n);
424             commonDom = (Block) AbstractControlFlowGraph.commonDominator(commonDom, b);
425         }
426         return commonDom;
427     }
428 
429     @Override
430     public List&lt;Loop&lt;Block&gt;&gt; getLoops() {
431         return loops;
432     }
433 
434     public int getMaxDominatorDepth() {
435         return maxDominatorDepth;
436     }
437 
438     private void identifyBlock(Block block) {
439         FixedWithNextNode cur = block.getBeginNode();
440         while (true) {
441             assert cur.isAlive() : cur;
442             assert nodeToBlock.get(cur) == null;
443             nodeToBlock.set(cur, block);
444             FixedNode next = cur.next();
445             if (next instanceof AbstractBeginNode) {
446                 block.endNode = cur;
447                 return;
448             } else if (next instanceof FixedWithNextNode) {
449                 cur = (FixedWithNextNode) next;
450             } else {
451                 nodeToBlock.set(next, block);
452                 block.endNode = next;
453                 return;
454             }
455         }
456     }
457 
458     /**
459      * Identify and connect blocks (including loop backward edges). Predecessors need to be in the
460      * order expected when iterating phi inputs.
461      */
462     private void identifyBlocks() {
463         // Find all block headers.
464         int numBlocks = 0;
465         for (AbstractBeginNode begin : graph.getNodes(AbstractBeginNode.TYPE)) {
466             Block block = new Block(begin);
467             identifyBlock(block);
468             numBlocks++;
469         }
470 
471         // Compute reverse post order.
472         int count = 0;
473         NodeMap&lt;Block&gt; nodeMap = this.nodeToBlock;
474         Block[] stack = new Block[numBlocks];
475         int tos = 0;
476         Block startBlock = blockFor(graph.start());
477         stack[0] = startBlock;
478         startBlock.setPredecessors(Block.EMPTY_ARRAY);
479         do {
480             Block block = stack[tos];
481             int id = block.getId();
482             if (id == BLOCK_ID_INITIAL) {
483                 // First time we see this block: push all successors.
484                 FixedNode last = block.getEndNode();
485                 if (last instanceof EndNode) {
486                     EndNode endNode = (EndNode) last;
487                     Block suxBlock = nodeMap.get(endNode.merge());
488                     if (suxBlock.getId() == BLOCK_ID_INITIAL) {
489                         stack[++tos] = suxBlock;
490                     }
491                     block.setSuccessors(new Block[]{suxBlock});
492                 } else if (last instanceof IfNode) {
493                     IfNode ifNode = (IfNode) last;
494                     Block trueSucc = nodeMap.get(ifNode.trueSuccessor());
495                     stack[++tos] = trueSucc;
496                     Block falseSucc = nodeMap.get(ifNode.falseSuccessor());
497                     stack[++tos] = falseSucc;
498                     block.setSuccessors(new Block[]{trueSucc, falseSucc});
499                     Block[] ifPred = new Block[]{block};
500                     trueSucc.setPredecessors(ifPred);
501                     falseSucc.setPredecessors(ifPred);
502                 } else if (last instanceof LoopEndNode) {
503                     LoopEndNode loopEndNode = (LoopEndNode) last;
504                     block.setSuccessors(new Block[]{nodeMap.get(loopEndNode.loopBegin())});
505                     // Nothing to do push onto the stack.
506                 } else if (last instanceof ControlSinkNode) {
507                     block.setSuccessors(Block.EMPTY_ARRAY);
508                 } else {
509                     assert !(last instanceof AbstractEndNode) : &quot;Algorithm only supports EndNode and LoopEndNode.&quot;;
510                     int startTos = tos;
511                     Block[] ifPred = new Block[]{block};
512                     for (Node suxNode : last.successors()) {
513                         Block sux = nodeMap.get(suxNode);
514                         stack[++tos] = sux;
515                         sux.setPredecessors(ifPred);
516                     }
517                     int suxCount = tos - startTos;
518                     Block[] successors = new Block[suxCount];
519                     System.arraycopy(stack, startTos + 1, successors, 0, suxCount);
520                     block.setSuccessors(successors);
521                 }
522                 block.setId(BLOCK_ID_VISITED);
523                 AbstractBeginNode beginNode = block.getBeginNode();
524                 if (beginNode instanceof LoopBeginNode) {
525                     computeLoopPredecessors(nodeMap, block, (LoopBeginNode) beginNode);
526                 } else if (beginNode instanceof MergeNode) {
527                     MergeNode mergeNode = (MergeNode) beginNode;
528                     int forwardEndCount = mergeNode.forwardEndCount();
529                     Block[] predecessors = new Block[forwardEndCount];
530                     for (int i = 0; i &lt; forwardEndCount; ++i) {
531                         predecessors[i] = nodeMap.get(mergeNode.forwardEndAt(i));
532                     }
533                     block.setPredecessors(predecessors);
534                 }
535 
536             } else if (id == BLOCK_ID_VISITED) {
537                 // Second time we see this block: All successors have been processed, so add block
538                 // to result list. Can safely reuse the stack for this.
539                 --tos;
540                 count++;
541                 int index = numBlocks - count;
542                 stack[index] = block;
543                 block.setId(index);
544             } else {
545                 throw GraalError.shouldNotReachHere();
546             }
547         } while (tos &gt;= 0);
548 
549         // Compute reverse postorder and number blocks.
550         assert count == numBlocks : &quot;all blocks must be reachable&quot;;
551         this.reversePostOrder = stack;
552     }
553 
554     private static void computeLoopPredecessors(NodeMap&lt;Block&gt; nodeMap, Block block, LoopBeginNode loopBeginNode) {
555         int forwardEndCount = loopBeginNode.forwardEndCount();
556         LoopEndNode[] loopEnds = loopBeginNode.orderedLoopEnds();
557         Block[] predecessors = new Block[forwardEndCount + loopEnds.length];
558         for (int i = 0; i &lt; forwardEndCount; ++i) {
559             predecessors[i] = nodeMap.get(loopBeginNode.forwardEndAt(i));
560         }
561         for (int i = 0; i &lt; loopEnds.length; ++i) {
562             predecessors[i + forwardEndCount] = nodeMap.get(loopEnds[i]);
563         }
564         block.setPredecessors(predecessors);
565     }
566 
567     /**
568      * Computes the frequencies of all blocks relative to the start block. It uses the probability
569      * information attached to control flow splits to calculate the frequency of a block based on
570      * the frequency of its predecessor and the probability of its incoming control flow branch.
571      */
572     private void computeFrequencies() {
573 
574         for (Block block : reversePostOrder) {
575             Block[] predecessors = block.getPredecessors();
576 
577             double relativeFrequency;
578             if (predecessors.length == 0) {
579                 relativeFrequency = 1D;
580             } else if (predecessors.length == 1) {
581                 Block pred = predecessors[0];
582                 relativeFrequency = pred.relativeFrequency;
583                 if (pred.getSuccessorCount() &gt; 1) {
584                     assert pred.getEndNode() instanceof ControlSplitNode;
585                     ControlSplitNode controlSplit = (ControlSplitNode) pred.getEndNode();
586                     relativeFrequency = multiplyRelativeFrequencies(relativeFrequency, controlSplit.probability(block.getBeginNode()));
587                 }
588             } else {
589                 relativeFrequency = predecessors[0].relativeFrequency;
590                 for (int i = 1; i &lt; predecessors.length; ++i) {
591                     relativeFrequency += predecessors[i].relativeFrequency;
592                 }
593 
594                 if (block.getBeginNode() instanceof LoopBeginNode) {
595                     LoopBeginNode loopBegin = (LoopBeginNode) block.getBeginNode();
596                     relativeFrequency = multiplyRelativeFrequencies(relativeFrequency, loopBegin.loopFrequency());
597                 }
598             }
599             if (relativeFrequency &lt; MIN_RELATIVE_FREQUENCY) {
600                 relativeFrequency = MIN_RELATIVE_FREQUENCY;
601             } else if (relativeFrequency &gt; MAX_RELATIVE_FREQUENCY) {
602                 relativeFrequency = MAX_RELATIVE_FREQUENCY;
603             }
604             block.setRelativeFrequency(relativeFrequency);
605         }
606 
607     }
608 
609     private void computeLoopInformation() {
610         loops = new ArrayList&lt;&gt;();
611         if (graph.hasLoops()) {
612             Block[] stack = new Block[this.reversePostOrder.length];
613             for (Block block : reversePostOrder) {
614                 AbstractBeginNode beginNode = block.getBeginNode();
615                 if (beginNode instanceof LoopBeginNode) {
616                     Loop&lt;Block&gt; parent = block.getLoop();
617                     Loop&lt;Block&gt; loop = new HIRLoop(parent, loops.size(), block);
618                     if (parent != null) {
619                         parent.getChildren().add(loop);
620                     }
621                     loops.add(loop);
622                     block.setLoop(loop);
623                     loop.getBlocks().add(block);
624 
625                     LoopBeginNode loopBegin = (LoopBeginNode) beginNode;
626                     for (LoopEndNode end : loopBegin.loopEnds()) {
627                         Block endBlock = nodeToBlock.get(end);
628                         computeLoopBlocks(endBlock, loop, stack, true);
629                     }
630 
631                     // Note that at this point, due to traversal order, child loops of `loop` have
632                     // not been discovered yet.
633                     for (Block b : loop.getBlocks()) {
634                         for (Block sux : b.getSuccessors()) {
635                             if (sux.getLoop() != loop) {
636                                 assert sux.getLoopDepth() &lt; loop.getDepth();
637                                 loop.getNaturalExits().add(sux);
638                             }
639                         }
640                     }
641                     loop.getNaturalExits().sort(BLOCK_ID_COMPARATOR);
642 
643                     if (!graph.getGuardsStage().areFrameStatesAtDeopts()) {
644                         for (LoopExitNode exit : loopBegin.loopExits()) {
645                             Block exitBlock = nodeToBlock.get(exit);
646                             assert exitBlock.getPredecessorCount() == 1;
647                             computeLoopBlocks(exitBlock.getFirstPredecessor(), loop, stack, true);
648                             loop.getLoopExits().add(exitBlock);
649                         }
650                         loop.getLoopExits().sort(BLOCK_ID_COMPARATOR);
651 
652                         // The following loop can add new blocks to the end of the loop&#39;s block
653                         // list.
654                         int size = loop.getBlocks().size();
655                         for (int i = 0; i &lt; size; ++i) {
656                             Block b = loop.getBlocks().get(i);
657                             for (Block sux : b.getSuccessors()) {
658                                 if (sux.getLoop() != loop) {
659                                     AbstractBeginNode begin = sux.getBeginNode();
660                                     if (!loopBegin.isLoopExit(begin)) {
661                                         assert !(begin instanceof LoopBeginNode);
662                                         assert sux.getLoopDepth() &lt; loop.getDepth();
663                                         graph.getDebug().log(DebugContext.VERBOSE_LEVEL, &quot;Unexpected loop exit with %s, including whole branch in the loop&quot;, sux);
664                                         computeLoopBlocks(sux, loop, stack, false);
665                                     }
666                                 }
667                             }
668                         }
669                     } else {
670                         loop.getLoopExits().addAll(loop.getNaturalExits());
671                     }
672                 }
673             }
674         }
675     }
676 
677     private static void computeLoopBlocks(Block start, Loop&lt;Block&gt; loop, Block[] stack, boolean usePred) {
678         if (start.getLoop() != loop) {
679             start.setLoop(loop);
680             stack[0] = start;
681             loop.getBlocks().add(start);
682             int tos = 0;
683             do {
684                 Block block = stack[tos--];
685 
686                 // Add predecessors or successors to the loop.
687                 for (Block b : (usePred ? block.getPredecessors() : block.getSuccessors())) {
688                     if (b.getLoop() != loop) {
689                         stack[++tos] = b;
690                         b.setLoop(loop);
691                         loop.getBlocks().add(b);
692                     }
693                 }
694             } while (tos &gt;= 0);
695         }
696     }
697 
698     public void computePostdominators() {
699 
700         Block[] reversePostOrderTmp = this.reversePostOrder;
701         outer: for (int j = reversePostOrderTmp.length - 1; j &gt;= 0; --j) {
702             Block block = reversePostOrderTmp[j];
703             if (block.isLoopEnd()) {
704                 // We do not want the loop header registered as the postdominator of the loop end.
705                 continue;
706             }
707             if (block.getSuccessorCount() == 0) {
708                 // No successors =&gt; no postdominator.
709                 continue;
710             }
711             Block firstSucc = block.getSuccessors()[0];
712             if (block.getSuccessorCount() == 1) {
713                 block.postdominator = firstSucc;
714                 continue;
715             }
716             Block postdominator = firstSucc;
717             for (Block sux : block.getSuccessors()) {
718                 postdominator = commonPostdominator(postdominator, sux);
719                 if (postdominator == null) {
720                     // There is a dead end =&gt; no postdominator available.
721                     continue outer;
722                 }
723             }
724             assert !Arrays.asList(block.getSuccessors()).contains(postdominator) : &quot;Block &quot; + block + &quot; has a wrong post dominator: &quot; + postdominator;
725             block.setPostDominator(postdominator);
726         }
727     }
728 
729     private static Block commonPostdominator(Block a, Block b) {
730         Block iterA = a;
731         Block iterB = b;
732         while (iterA != iterB) {
733             if (iterA.getId() &lt; iterB.getId()) {
734                 iterA = iterA.getPostdominator();
735                 if (iterA == null) {
736                     return null;
737                 }
738             } else {
739                 assert iterB.getId() &lt; iterA.getId();
740                 iterB = iterB.getPostdominator();
741                 if (iterB == null) {
742                     return null;
743                 }
744             }
745         }
746         return iterA;
747     }
748 
749     public void setNodeToBlock(NodeMap&lt;Block&gt; nodeMap) {
750         this.nodeToBlock = nodeMap;
751     }
752 
753     /**
754      * Multiplies a and b and clamps the between {@link ControlFlowGraph#MIN_RELATIVE_FREQUENCY} and
755      * {@link ControlFlowGraph#MAX_RELATIVE_FREQUENCY}.
756      */
757     public static double multiplyRelativeFrequencies(double a, double b) {
758         assert !Double.isNaN(a) &amp;&amp; !Double.isNaN(b) &amp;&amp; Double.isFinite(a) &amp;&amp; Double.isFinite(b) : a + &quot; &quot; + b;
759         double r = a * b;
760         if (r &gt; MAX_RELATIVE_FREQUENCY) {
761             return MAX_RELATIVE_FREQUENCY;
762         }
763         if (r &lt; MIN_RELATIVE_FREQUENCY) {
764             return MIN_RELATIVE_FREQUENCY;
765         }
766         return r;
767     }
768 }
    </pre>
  </body>
</html>
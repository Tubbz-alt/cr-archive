<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/IfNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.nodes;
  26 
  27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_1;
  28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_2;
  29 
  30 import java.util.ArrayList;
  31 import java.util.Arrays;
  32 import java.util.Iterator;
  33 import java.util.List;
  34 import java.util.Objects;
  35 
  36 import jdk.internal.vm.compiler.collections.EconomicMap;
  37 import jdk.internal.vm.compiler.collections.Equivalence;
  38 import org.graalvm.compiler.bytecode.BytecodeDisassembler;
  39 import org.graalvm.compiler.bytecode.Bytecodes;
  40 import org.graalvm.compiler.bytecode.Bytes;
  41 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  42 import org.graalvm.compiler.core.common.calc.Condition;
<a name="2" id="anc2"></a>
  43 import org.graalvm.compiler.core.common.type.IntegerStamp;
<a name="3" id="anc3"></a>
  44 import org.graalvm.compiler.core.common.type.Stamp;
  45 import org.graalvm.compiler.core.common.type.StampFactory;
  46 import org.graalvm.compiler.debug.CounterKey;
  47 import org.graalvm.compiler.debug.DebugCloseable;
  48 import org.graalvm.compiler.debug.DebugContext;
  49 import org.graalvm.compiler.debug.GraalError;
<a name="4" id="anc4"></a>
  50 import org.graalvm.compiler.graph.Node;
  51 import org.graalvm.compiler.graph.NodeClass;
  52 import org.graalvm.compiler.graph.NodeSourcePosition;
  53 import org.graalvm.compiler.graph.iterators.NodeIterable;
<a name="5" id="anc5"></a><span class="line-removed">  54 import org.graalvm.compiler.graph.spi.Canonicalizable;</span>
  55 import org.graalvm.compiler.graph.spi.Simplifiable;
  56 import org.graalvm.compiler.graph.spi.SimplifierTool;
  57 import org.graalvm.compiler.nodeinfo.InputType;
  58 import org.graalvm.compiler.nodeinfo.NodeInfo;
<a name="6" id="anc6"></a>
  59 import org.graalvm.compiler.nodes.calc.CompareNode;
  60 import org.graalvm.compiler.nodes.calc.ConditionalNode;
<a name="7" id="anc7"></a>
  61 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  62 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  63 import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;
<a name="8" id="anc8"></a>
  64 import org.graalvm.compiler.nodes.calc.IsNullNode;
<a name="9" id="anc9"></a><span class="line-removed">  65 import org.graalvm.compiler.nodes.calc.NormalizeCompareNode;</span>
  66 import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
  67 import org.graalvm.compiler.nodes.extended.UnboxNode;
  68 import org.graalvm.compiler.nodes.java.InstanceOfNode;
  69 import org.graalvm.compiler.nodes.java.LoadFieldNode;
  70 import org.graalvm.compiler.nodes.spi.LIRLowerable;
  71 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
<a name="10" id="anc10"></a>
  72 import org.graalvm.compiler.nodes.util.GraphUtil;
  73 
<a name="11" id="anc11"></a>
  74 import jdk.vm.ci.meta.Constant;
  75 import jdk.vm.ci.meta.JavaConstant;
  76 import jdk.vm.ci.meta.JavaKind;
  77 import jdk.vm.ci.meta.MetaAccessProvider;
  78 import jdk.vm.ci.meta.PrimitiveConstant;
  79 import jdk.vm.ci.meta.ResolvedJavaMethod;
  80 import jdk.vm.ci.meta.ResolvedJavaType;
  81 import jdk.vm.ci.meta.TriState;
  82 
  83 /**
  84  * The {@code IfNode} represents a branch that can go one of two directions depending on the outcome
  85  * of a comparison.
  86  */
  87 @NodeInfo(cycles = CYCLES_1, size = SIZE_2, sizeRationale = &quot;2 jmps&quot;)
<a name="12" id="anc12"></a><span class="line-modified">  88 public final class IfNode extends ControlSplitNode implements Simplifiable, LIRLowerable {</span>
  89     public static final NodeClass&lt;IfNode&gt; TYPE = NodeClass.create(IfNode.class);
  90 
  91     private static final CounterKey CORRECTED_PROBABILITIES = DebugContext.counter(&quot;CorrectedProbabilities&quot;);
  92 
  93     @Successor AbstractBeginNode trueSuccessor;
  94     @Successor AbstractBeginNode falseSuccessor;
  95     @Input(InputType.Condition) LogicNode condition;
  96     protected double trueSuccessorProbability;
  97 
  98     public LogicNode condition() {
  99         return condition;
 100     }
 101 
 102     public void setCondition(LogicNode x) {
 103         updateUsages(condition, x);
 104         condition = x;
 105     }
 106 
 107     public IfNode(LogicNode condition, FixedNode trueSuccessor, FixedNode falseSuccessor, double trueSuccessorProbability) {
 108         this(condition, BeginNode.begin(trueSuccessor), BeginNode.begin(falseSuccessor), trueSuccessorProbability);
 109     }
 110 
 111     public IfNode(LogicNode condition, AbstractBeginNode trueSuccessor, AbstractBeginNode falseSuccessor, double trueSuccessorProbability) {
 112         super(TYPE, StampFactory.forVoid());
 113         this.condition = condition;
 114         this.falseSuccessor = falseSuccessor;
 115         this.trueSuccessor = trueSuccessor;
 116         setTrueSuccessorProbability(trueSuccessorProbability);
 117     }
 118 
 119     /**
 120      * Gets the true successor.
 121      *
 122      * @return the true successor
 123      */
 124     public AbstractBeginNode trueSuccessor() {
 125         return trueSuccessor;
 126     }
 127 
 128     /**
 129      * Gets the false successor.
 130      *
 131      * @return the false successor
 132      */
 133     public AbstractBeginNode falseSuccessor() {
 134         return falseSuccessor;
 135     }
 136 
 137     public double getTrueSuccessorProbability() {
 138         return this.trueSuccessorProbability;
 139     }
 140 
 141     public void setTrueSuccessor(AbstractBeginNode node) {
 142         updatePredecessor(trueSuccessor, node);
 143         trueSuccessor = node;
 144     }
 145 
 146     public void setFalseSuccessor(AbstractBeginNode node) {
 147         updatePredecessor(falseSuccessor, node);
 148         falseSuccessor = node;
 149     }
 150 
 151     /**
 152      * Gets the node corresponding to the specified outcome of the branch.
 153      *
 154      * @param istrue {@code true} if the true successor is requested, {@code false} otherwise
 155      * @return the corresponding successor
 156      */
 157     public AbstractBeginNode successor(boolean istrue) {
 158         return istrue ? trueSuccessor : falseSuccessor;
 159     }
 160 
 161     public void setTrueSuccessorProbability(double prob) {
 162         assert prob &gt;= -0.000000001 &amp;&amp; prob &lt;= 1.000000001 : &quot;Probability out of bounds: &quot; + prob;
 163         trueSuccessorProbability = Math.min(1.0, Math.max(0.0, prob));
 164     }
 165 
 166     @Override
 167     public double probability(AbstractBeginNode successor) {
 168         return successor == trueSuccessor ? trueSuccessorProbability : 1 - trueSuccessorProbability;
 169     }
 170 
 171     @Override
 172     public void generate(NodeLIRBuilderTool gen) {
 173         gen.emitIf(this);
 174     }
 175 
 176     @Override
 177     public boolean verify() {
 178         assertTrue(condition() != null, &quot;missing condition&quot;);
 179         assertTrue(trueSuccessor() != null, &quot;missing trueSuccessor&quot;);
 180         assertTrue(falseSuccessor() != null, &quot;missing falseSuccessor&quot;);
 181         return super.verify();
 182     }
 183 
 184     private boolean compareCallContext(NodeSourcePosition successorPosition) {
 185         NodeSourcePosition position = getNodeSourcePosition();
 186         NodeSourcePosition successor = successorPosition;
 187         while (position != null) {
 188             assertTrue(Objects.equals(position.getMethod(), successor.getMethod()), &quot;method mismatch&quot;);
 189             position = position.getCaller();
 190             successor = successor.getCaller();
 191         }
 192         assertTrue(successor == null, &quot;successor position has more methods&quot;);
 193         return true;
 194     }
 195 
 196     @Override
 197     public boolean verifySourcePosition() {
 198         NodeSourcePosition sourcePosition = getNodeSourcePosition();
 199         assertTrue(sourcePosition != null, &quot;missing IfNode source position&quot;);
 200 
 201         NodeSourcePosition trueSuccessorPosition = trueSuccessor.getNodeSourcePosition();
 202         assertTrue(trueSuccessorPosition != null, &quot;missing IfNode true successor source position&quot;);
 203 
 204         NodeSourcePosition falseSuccessorPosition = falseSuccessor.getNodeSourcePosition();
 205         assertTrue(falseSuccessorPosition != null, &quot;missing IfNode false successor source position&quot;);
 206 
 207         int bci = sourcePosition.getBCI();
 208         ResolvedJavaMethod method = sourcePosition.getMethod();
 209         int bytecode = BytecodeDisassembler.getBytecodeAt(method, bci);
 210 
 211         if (!Bytecodes.isIfBytecode(bytecode)) {
 212             return true;
 213         }
 214 
 215         byte[] code = (new ResolvedJavaMethodBytecode(method)).getCode();
 216         int targetBCI = bci + Bytes.beS2(code, bci + 1);
 217         int nextBCI = bci + Bytecodes.lengthOf(bytecode);
 218 
 219         // At least one successor should have the correct BCI to indicate any possible negation that
 220         // occurred after bytecode parsing
 221         boolean matchingSuccessorFound = false;
 222         if (trueSuccessorPosition.getBCI() == nextBCI || trueSuccessorPosition.getBCI() == targetBCI) {
 223             assertTrue(compareCallContext(trueSuccessorPosition), &quot;call context different from IfNode in trueSuccessor&quot;);
 224             matchingSuccessorFound = true;
 225         }
 226 
 227         if (falseSuccessorPosition.getBCI() == nextBCI || falseSuccessorPosition.getBCI() == targetBCI) {
 228             assertTrue(compareCallContext(falseSuccessorPosition), &quot;call context different from IfNode in falseSuccessor&quot;);
 229             matchingSuccessorFound = true;
 230         }
 231 
 232         assertTrue(matchingSuccessorFound, &quot;no matching successor position found in IfNode&quot;);
 233         assertTrue(trueSuccessorPosition.getBCI() != falseSuccessorPosition.getBCI(), &quot;successor positions same in IfNode&quot;);
 234 
 235         return true;
 236     }
 237 
 238     public void eliminateNegation() {
 239         AbstractBeginNode oldTrueSuccessor = trueSuccessor;
 240         AbstractBeginNode oldFalseSuccessor = falseSuccessor;
 241         trueSuccessor = oldFalseSuccessor;
 242         falseSuccessor = oldTrueSuccessor;
 243         trueSuccessorProbability = 1 - trueSuccessorProbability;
 244         setCondition(((LogicNegationNode) condition).getValue());
 245     }
 246 
 247     @Override
 248     public void simplify(SimplifierTool tool) {
 249         if (trueSuccessor().next() instanceof DeoptimizeNode) {
 250             if (trueSuccessorProbability != 0) {
 251                 CORRECTED_PROBABILITIES.increment(getDebug());
 252                 trueSuccessorProbability = 0;
 253             }
 254         } else if (falseSuccessor().next() instanceof DeoptimizeNode) {
 255             if (trueSuccessorProbability != 1) {
 256                 CORRECTED_PROBABILITIES.increment(getDebug());
 257                 trueSuccessorProbability = 1;
 258             }
 259         }
 260 
 261         if (condition() instanceof LogicNegationNode) {
 262             eliminateNegation();
 263         }
 264         if (condition() instanceof LogicConstantNode) {
 265             LogicConstantNode c = (LogicConstantNode) condition();
 266             if (c.getValue()) {
 267                 tool.deleteBranch(falseSuccessor());
 268                 tool.addToWorkList(trueSuccessor());
 269                 graph().removeSplit(this, trueSuccessor());
 270             } else {
 271                 tool.deleteBranch(trueSuccessor());
 272                 tool.addToWorkList(falseSuccessor());
 273                 graph().removeSplit(this, falseSuccessor());
 274             }
 275             return;
 276         }
 277         if (tool.allUsagesAvailable() &amp;&amp; trueSuccessor().hasNoUsages() &amp;&amp; falseSuccessor().hasNoUsages()) {
 278 
 279             pushNodesThroughIf(tool);
 280 
 281             if (checkForUnsignedCompare(tool) || removeOrMaterializeIf(tool)) {
 282                 return;
 283             }
 284         }
 285 
 286         if (removeIntermediateMaterialization(tool)) {
 287             return;
 288         }
 289 
<a name="13" id="anc13"></a><span class="line-modified"> 290         if (splitIfAtPhi(tool)) {</span>
 291             return;
 292         }
 293 
<a name="14" id="anc14"></a><span class="line-modified"> 294         if (conditionalNodeOptimization(tool)) {</span>
 295             return;
 296         }
 297 
<a name="15" id="anc15"></a><span class="line-modified"> 298         if (falseSuccessor().hasNoUsages() &amp;&amp; (!(falseSuccessor() instanceof LoopExitNode)) &amp;&amp; falseSuccessor().next() instanceof IfNode) {</span>

 299             AbstractBeginNode intermediateBegin = falseSuccessor();
 300             IfNode nextIf = (IfNode) intermediateBegin.next();
 301             double probabilityB = (1.0 - this.trueSuccessorProbability) * nextIf.trueSuccessorProbability;
 302             if (this.trueSuccessorProbability &lt; probabilityB) {
 303                 // Reordering of those two if statements is beneficial from the point of view of
 304                 // their probabilities.
 305                 if (prepareForSwap(tool, condition(), nextIf.condition())) {
 306                     // Reordering is allowed from (if1 =&gt; begin =&gt; if2) to (if2 =&gt; begin =&gt; if1).
 307                     assert intermediateBegin.next() == nextIf;
 308                     AbstractBeginNode bothFalseBegin = nextIf.falseSuccessor();
 309                     nextIf.setFalseSuccessor(null);
 310                     intermediateBegin.setNext(null);
 311                     this.setFalseSuccessor(null);
 312 
 313                     this.replaceAtPredecessor(nextIf);
 314                     nextIf.setFalseSuccessor(intermediateBegin);
 315                     intermediateBegin.setNext(this);
 316                     this.setFalseSuccessor(bothFalseBegin);
 317 
 318                     NodeSourcePosition intermediateBeginPosition = intermediateBegin.getNodeSourcePosition();
 319                     intermediateBegin.setNodeSourcePosition(bothFalseBegin.getNodeSourcePosition());
 320                     bothFalseBegin.setNodeSourcePosition(intermediateBeginPosition);
 321 
 322                     nextIf.setTrueSuccessorProbability(probabilityB);
 323                     if (probabilityB == 1.0) {
 324                         this.setTrueSuccessorProbability(0.0);
 325                     } else {
 326                         double newProbability = this.trueSuccessorProbability / (1.0 - probabilityB);
 327                         this.setTrueSuccessorProbability(Math.min(1.0, newProbability));
 328                     }
 329                     return;
 330                 }
 331             }
 332         }
 333 
 334         if (tryEliminateBoxedReferenceEquals(tool)) {
 335             return;
 336         }
 337     }
 338 
<a name="16" id="anc16"></a><span class="line-modified"> 339     private boolean isUnboxedFrom(MetaAccessProvider meta, NodeView view, ValueNode x, ValueNode src) {</span>
 340         if (x == src) {
 341             return true;
 342         } else if (x instanceof UnboxNode) {
 343             return isUnboxedFrom(meta, view, ((UnboxNode) x).getValue(), src);
 344         } else if (x instanceof PiNode) {
 345             PiNode pi = (PiNode) x;
 346             return isUnboxedFrom(meta, view, pi.getOriginalNode(), src);
 347         } else if (x instanceof LoadFieldNode) {
 348             LoadFieldNode load = (LoadFieldNode) x;
 349             ResolvedJavaType integerType = meta.lookupJavaType(Integer.class);
 350             if (load.getValue().stamp(view).javaType(meta).equals(integerType)) {
 351                 return isUnboxedFrom(meta, view, load.getValue(), src);
 352             } else {
 353                 return false;
 354             }
 355         } else {
 356             return false;
 357         }
 358     }
 359 
 360     /**
 361      * Attempts to replace the following pattern:
 362      *
 363      * &lt;pre&gt;
 364      * Integer x = ...;
 365      * Integer y = ...;
 366      * if ((x == y) || x.equals(y)) { ... }
 367      * &lt;/pre&gt;
 368      *
 369      * with:
 370      *
 371      * &lt;pre&gt;
 372      * Integer x = ...;
 373      * Integer y = ...;
 374      * if (x.equals(y)) { ... }
 375      * &lt;/pre&gt;
 376      *
 377      * whenever the probability that the reference check will pass is relatively small.
 378      *
 379      * See GR-1315 for more information.
 380      */
 381     private boolean tryEliminateBoxedReferenceEquals(SimplifierTool tool) {
 382         if (!(condition instanceof ObjectEqualsNode)) {
 383             return false;
 384         }
 385 
 386         MetaAccessProvider meta = tool.getMetaAccess();
 387         ObjectEqualsNode equalsCondition = (ObjectEqualsNode) condition;
 388         ValueNode x = equalsCondition.getX();
 389         ValueNode y = equalsCondition.getY();
 390         ResolvedJavaType integerType = meta.lookupJavaType(Integer.class);
 391 
 392         // At least one argument for reference equal must be a boxed primitive.
 393         NodeView view = NodeView.from(tool);
 394         if (!x.stamp(view).javaType(meta).equals(integerType) &amp;&amp; !y.stamp(view).javaType(meta).equals(integerType)) {
 395             return false;
 396         }
 397 
 398         // The reference equality check is usually more efficient compared to a boxing check.
 399         // The success of the reference equals must therefore be relatively rare, otherwise it makes
 400         // no sense to eliminate it.
 401         if (getTrueSuccessorProbability() &gt; 0.4) {
 402             return false;
 403         }
 404 
 405         // True branch must be empty.
 406         if (trueSuccessor instanceof BeginNode || trueSuccessor instanceof LoopExitNode) {
 407             if (trueSuccessor.next() instanceof EndNode) {
 408                 // Empty true branch.
 409             } else {
 410                 return false;
 411             }
 412         } else {
 413             return false;
 414         }
 415 
 416         // False branch must only check the unboxed values.
 417         UnboxNode unbox = null;
 418         FixedGuardNode unboxCheck = null;
 419         for (FixedNode node : falseSuccessor.getBlockNodes()) {
 420             if (!(node instanceof BeginNode || node instanceof UnboxNode || node instanceof FixedGuardNode || node instanceof EndNode ||
 421                             node instanceof LoadFieldNode || node instanceof LoopExitNode)) {
 422                 return false;
 423             }
 424             if (node instanceof UnboxNode) {
 425                 if (unbox == null) {
 426                     unbox = (UnboxNode) node;
 427                 } else {
 428                     return false;
 429                 }
 430             }
 431             if (!(node instanceof FixedGuardNode)) {
 432                 continue;
 433             }
 434             FixedGuardNode fixed = (FixedGuardNode) node;
 435             if (!(fixed.condition() instanceof IntegerEqualsNode)) {
 436                 continue;
 437             }
 438             IntegerEqualsNode equals = (IntegerEqualsNode) fixed.condition();
 439             if ((isUnboxedFrom(meta, view, equals.getX(), x) &amp;&amp; isUnboxedFrom(meta, view, equals.getY(), y)) ||
 440                             (isUnboxedFrom(meta, view, equals.getX(), y) &amp;&amp; isUnboxedFrom(meta, view, equals.getY(), x))) {
 441                 unboxCheck = fixed;
 442             }
 443         }
 444         if (unbox == null || unboxCheck == null) {
 445             return false;
 446         }
 447 
 448         // Falsify the reference check.
 449         setCondition(graph().addOrUniqueWithInputs(LogicConstantNode.contradiction()));
 450 
 451         return true;
 452     }
 453 
<a name="17" id="anc17"></a>































































 454     /**
 455      * Try to optimize this as if it were a {@link ConditionalNode}.
 456      */
 457     private boolean conditionalNodeOptimization(SimplifierTool tool) {
 458         if (trueSuccessor().next() instanceof AbstractEndNode &amp;&amp; falseSuccessor().next() instanceof AbstractEndNode) {
 459             AbstractEndNode trueEnd = (AbstractEndNode) trueSuccessor().next();
 460             AbstractEndNode falseEnd = (AbstractEndNode) falseSuccessor().next();
 461             if (trueEnd.merge() != falseEnd.merge()) {
 462                 return false;
 463             }
 464             if (!(trueEnd.merge() instanceof MergeNode)) {
 465                 return false;
 466             }
 467             MergeNode merge = (MergeNode) trueEnd.merge();
<a name="18" id="anc18"></a><span class="line-modified"> 468             if (merge.usages().count() != 1 || merge.phis().count() != 1) {</span>
 469                 return false;
 470             }
 471 
<a name="19" id="anc19"></a><span class="line-modified"> 472             if (trueSuccessor().anchored().isNotEmpty() || falseSuccessor().anchored().isNotEmpty()) {</span>
 473                 return false;
 474             }
 475 
 476             PhiNode phi = merge.phis().first();
 477             ValueNode falseValue = phi.valueAt(falseEnd);
 478             ValueNode trueValue = phi.valueAt(trueEnd);
 479 
 480             NodeView view = NodeView.from(tool);
 481             ValueNode result = ConditionalNode.canonicalizeConditional(condition, trueValue, falseValue, phi.stamp(view), view);
 482             if (result != null) {
 483                 /*
 484                  * canonicalizeConditional returns possibly new nodes so add them to the graph.
 485                  */
 486                 if (result.graph() == null) {
 487                     result = graph().addOrUniqueWithInputs(result);
 488                 }
 489                 result = proxyReplacement(result);
 490                 /*
 491                  * This optimization can be performed even if multiple values merge at this phi
 492                  * since the two inputs get simplified into one.
 493                  */
 494                 phi.setValueAt(trueEnd, result);
 495                 removeThroughFalseBranch(tool, merge);
 496                 return true;
 497             }
 498         }
 499 
 500         return false;
 501     }
 502 
 503     private void pushNodesThroughIf(SimplifierTool tool) {
 504         assert trueSuccessor().hasNoUsages() &amp;&amp; falseSuccessor().hasNoUsages();
 505         // push similar nodes upwards through the if, thereby deduplicating them
 506         do {
 507             AbstractBeginNode trueSucc = trueSuccessor();
 508             AbstractBeginNode falseSucc = falseSuccessor();
 509             if (trueSucc instanceof BeginNode &amp;&amp; falseSucc instanceof BeginNode &amp;&amp; trueSucc.next() instanceof FixedWithNextNode &amp;&amp; falseSucc.next() instanceof FixedWithNextNode) {
 510                 FixedWithNextNode trueNext = (FixedWithNextNode) trueSucc.next();
 511                 FixedWithNextNode falseNext = (FixedWithNextNode) falseSucc.next();
 512                 NodeClass&lt;?&gt; nodeClass = trueNext.getNodeClass();
 513                 if (trueNext.getClass() == falseNext.getClass()) {
 514                     if (trueNext instanceof AbstractBeginNode) {
 515                         // Cannot do this optimization for begin nodes, because it could
 516                         // move guards above the if that need to stay below a branch.
 517                     } else if (nodeClass.equalInputs(trueNext, falseNext) &amp;&amp; trueNext.valueEquals(falseNext)) {
 518                         falseNext.replaceAtUsages(trueNext);
 519                         graph().removeFixed(falseNext);
 520                         GraphUtil.unlinkFixedNode(trueNext);
 521                         graph().addBeforeFixed(this, trueNext);
 522                         for (Node usage : trueNext.usages().snapshot()) {
 523                             if (usage.isAlive()) {
 524                                 NodeClass&lt;?&gt; usageNodeClass = usage.getNodeClass();
 525                                 if (usageNodeClass.valueNumberable() &amp;&amp; !usageNodeClass.isLeafNode()) {
 526                                     Node newNode = graph().findDuplicate(usage);
 527                                     if (newNode != null) {
 528                                         usage.replaceAtUsagesAndDelete(newNode);
 529                                     }
 530                                 }
 531                                 if (usage.isAlive()) {
 532                                     tool.addToWorkList(usage);
 533                                 }
 534                             }
 535                         }
 536                         continue;
 537                     }
 538                 }
 539             }
 540             break;
 541         } while (true);
 542     }
 543 
 544     /**
 545      * Recognize a couple patterns that can be merged into an unsigned compare.
 546      *
 547      * @param tool
 548      * @return true if a replacement was done.
 549      */
 550     @SuppressWarnings(&quot;try&quot;)
 551     private boolean checkForUnsignedCompare(SimplifierTool tool) {
 552         assert trueSuccessor().hasNoUsages() &amp;&amp; falseSuccessor().hasNoUsages();
 553         if (condition() instanceof IntegerLessThanNode) {
 554             NodeView view = NodeView.from(tool);
 555             IntegerLessThanNode lessThan = (IntegerLessThanNode) condition();
 556             Constant y = lessThan.getY().stamp(view).asConstant();
 557             if (y instanceof PrimitiveConstant &amp;&amp; ((PrimitiveConstant) y).asLong() == 0 &amp;&amp; falseSuccessor().next() instanceof IfNode) {
 558                 IfNode ifNode2 = (IfNode) falseSuccessor().next();
 559                 if (ifNode2.condition() instanceof IntegerLessThanNode) {
 560                     IntegerLessThanNode lessThan2 = (IntegerLessThanNode) ifNode2.condition();
 561                     AbstractBeginNode falseSucc = ifNode2.falseSuccessor();
 562                     AbstractBeginNode trueSucc = ifNode2.trueSuccessor();
 563                     IntegerBelowNode below = null;
 564                     /*
 565                      * Convert x &gt;= 0 &amp;&amp; x &lt; positive which is represented as !(x &lt; 0) &amp;&amp; x &lt;
 566                      * &lt;positive&gt; into an unsigned compare.
 567                      */
 568                     if (lessThan2.getX() == lessThan.getX() &amp;&amp; lessThan2.getY().stamp(view) instanceof IntegerStamp &amp;&amp;
 569                                     ((IntegerStamp) lessThan2.getY().stamp(view)).isPositive() &amp;&amp;
 570                                     sameDestination(trueSuccessor(), ifNode2.falseSuccessor)) {
 571                         below = graph().unique(new IntegerBelowNode(lessThan2.getX(), lessThan2.getY()));
 572                         // swap direction
 573                         AbstractBeginNode tmp = falseSucc;
 574                         falseSucc = trueSucc;
 575                         trueSucc = tmp;
 576                     } else if (lessThan2.getY() == lessThan.getX() &amp;&amp; sameDestination(trueSuccessor(), ifNode2.trueSuccessor)) {
 577                         /*
 578                          * Convert x &gt;= 0 &amp;&amp; x &lt;= positive which is represented as !(x &lt; 0) &amp;&amp;
 579                          * !(&lt;positive&gt; &gt; x), into x &lt;| positive + 1. This can only be done for
 580                          * constants since there isn&#39;t a IntegerBelowEqualThanNode but that doesn&#39;t
 581                          * appear to be interesting.
 582                          */
 583                         JavaConstant positive = lessThan2.getX().asJavaConstant();
 584                         if (positive != null &amp;&amp; positive.asLong() &gt; 0 &amp;&amp; positive.asLong() &lt; positive.getJavaKind().getMaxValue()) {
 585                             ConstantNode newLimit = ConstantNode.forIntegerStamp(lessThan2.getX().stamp(view), positive.asLong() + 1, graph());
 586                             below = graph().unique(new IntegerBelowNode(lessThan.getX(), newLimit));
 587                         }
 588                     }
 589                     if (below != null) {
 590                         try (DebugCloseable position = ifNode2.withNodeSourcePosition()) {
 591                             ifNode2.setTrueSuccessor(null);
 592                             ifNode2.setFalseSuccessor(null);
 593 
 594                             IfNode newIfNode = graph().add(new IfNode(below, falseSucc, trueSucc, 1 - trueSuccessorProbability));
 595                             // Remove the &lt; 0 test.
 596                             tool.deleteBranch(trueSuccessor);
 597                             graph().removeSplit(this, falseSuccessor);
 598 
 599                             // Replace the second test with the new one.
 600                             ifNode2.predecessor().replaceFirstSuccessor(ifNode2, newIfNode);
 601                             ifNode2.safeDelete();
 602                             return true;
 603                         }
 604                     }
 605                 }
<a name="20" id="anc20"></a>











































 606             }
 607         }
 608         return false;
 609     }
 610 
 611     /**
 612      * Check it these two blocks end up at the same place. Meeting at the same merge, or
 613      * deoptimizing in the same way.
 614      */
 615     private static boolean sameDestination(AbstractBeginNode succ1, AbstractBeginNode succ2) {
 616         Node next1 = succ1.next();
 617         Node next2 = succ2.next();
 618         if (next1 instanceof EndNode &amp;&amp; next2 instanceof EndNode) {
 619             EndNode end1 = (EndNode) next1;
 620             EndNode end2 = (EndNode) next2;
 621             if (end1.merge() == end2.merge()) {
 622                 for (PhiNode phi : end1.merge().phis()) {
 623                     if (phi.valueAt(end1) != phi.valueAt(end2)) {
 624                         return false;
 625                     }
 626                 }
 627                 // They go to the same MergeNode and merge the same values
 628                 return true;
 629             }
 630         } else if (next1 instanceof DeoptimizeNode &amp;&amp; next2 instanceof DeoptimizeNode) {
 631             DeoptimizeNode deopt1 = (DeoptimizeNode) next1;
 632             DeoptimizeNode deopt2 = (DeoptimizeNode) next2;
 633             if (deopt1.getReason() == deopt2.getReason() &amp;&amp; deopt1.getAction() == deopt2.getAction()) {
 634                 // Same deoptimization reason and action.
 635                 return true;
 636             }
 637         } else if (next1 instanceof LoopExitNode &amp;&amp; next2 instanceof LoopExitNode) {
 638             LoopExitNode exit1 = (LoopExitNode) next1;
 639             LoopExitNode exit2 = (LoopExitNode) next2;
 640             if (exit1.loopBegin() == exit2.loopBegin() &amp;&amp; exit1.stateAfter() == exit2.stateAfter() &amp;&amp; exit1.stateAfter() == null &amp;&amp; sameDestination(exit1, exit2)) {
 641                 // Exit the same loop and end up at the same place.
 642                 return true;
 643             }
 644         } else if (next1 instanceof ReturnNode &amp;&amp; next2 instanceof ReturnNode) {
 645             ReturnNode exit1 = (ReturnNode) next1;
 646             ReturnNode exit2 = (ReturnNode) next2;
 647             if (exit1.result() == exit2.result()) {
 648                 // Exit the same loop and end up at the same place.
 649                 return true;
 650             }
 651         }
 652         return false;
 653     }
 654 
 655     private static boolean prepareForSwap(SimplifierTool tool, LogicNode a, LogicNode b) {
 656         DebugContext debug = a.getDebug();
 657         if (a instanceof InstanceOfNode) {
 658             InstanceOfNode instanceOfA = (InstanceOfNode) a;
 659             if (b instanceof IsNullNode) {
 660                 IsNullNode isNullNode = (IsNullNode) b;
 661                 if (isNullNode.getValue() == instanceOfA.getValue()) {
 662                     debug.log(&quot;Can swap instanceof and isnull if&quot;);
 663                     return true;
 664                 }
 665             } else if (b instanceof InstanceOfNode) {
 666                 InstanceOfNode instanceOfB = (InstanceOfNode) b;
 667                 if (instanceOfA.getValue() == instanceOfB.getValue() &amp;&amp; !instanceOfA.type().getType().isInterface() &amp;&amp; !instanceOfB.type().getType().isInterface() &amp;&amp;
 668                                 !instanceOfA.type().getType().isAssignableFrom(instanceOfB.type().getType()) &amp;&amp; !instanceOfB.type().getType().isAssignableFrom(instanceOfA.type().getType())) {
 669                     // Two instanceof on the same value with mutually exclusive types.
 670                     debug.log(&quot;Can swap instanceof for types %s and %s&quot;, instanceOfA.type(), instanceOfB.type());
 671                     return true;
 672                 }
 673             }
 674         } else if (a instanceof CompareNode) {
 675             CompareNode compareA = (CompareNode) a;
 676             Condition conditionA = compareA.condition().asCondition();
 677             if (compareA.unorderedIsTrue()) {
 678                 return false;
 679             }
 680             if (b instanceof CompareNode) {
 681                 CompareNode compareB = (CompareNode) b;
 682                 if (compareA == compareB) {
 683                     debug.log(&quot;Same conditions =&gt; do not swap and leave the work for global value numbering.&quot;);
 684                     return false;
 685                 }
 686                 if (compareB.unorderedIsTrue()) {
 687                     return false;
 688                 }
 689                 Condition comparableCondition = null;
 690                 Condition conditionB = compareB.condition().asCondition();
 691                 if (compareB.getX() == compareA.getX() &amp;&amp; compareB.getY() == compareA.getY()) {
 692                     comparableCondition = conditionB;
 693                 } else if (compareB.getX() == compareA.getY() &amp;&amp; compareB.getY() == compareA.getX()) {
 694                     comparableCondition = conditionB.mirror();
 695                 }
 696 
 697                 if (comparableCondition != null) {
 698                     Condition combined = conditionA.join(comparableCondition);
 699                     if (combined == null) {
 700                         // The two conditions are disjoint =&gt; can reorder.
 701                         debug.log(&quot;Can swap disjoint coditions on same values: %s and %s&quot;, conditionA, comparableCondition);
 702                         return true;
 703                     }
 704                 } else if (conditionA == Condition.EQ &amp;&amp; conditionB == Condition.EQ) {
 705                     boolean canSwap = false;
 706                     if ((compareA.getX() == compareB.getX() &amp;&amp; valuesDistinct(tool, compareA.getY(), compareB.getY()))) {
 707                         canSwap = true;
 708                     } else if ((compareA.getX() == compareB.getY() &amp;&amp; valuesDistinct(tool, compareA.getY(), compareB.getX()))) {
 709                         canSwap = true;
 710                     } else if ((compareA.getY() == compareB.getX() &amp;&amp; valuesDistinct(tool, compareA.getX(), compareB.getY()))) {
 711                         canSwap = true;
 712                     } else if ((compareA.getY() == compareB.getY() &amp;&amp; valuesDistinct(tool, compareA.getX(), compareB.getX()))) {
 713                         canSwap = true;
 714                     }
 715 
 716                     if (canSwap) {
 717                         debug.log(&quot;Can swap equality condition with one shared and one disjoint value.&quot;);
 718                         return true;
 719                     }
 720                 }
 721             }
 722         }
 723 
 724         return false;
 725     }
 726 
 727     private static boolean valuesDistinct(SimplifierTool tool, ValueNode a, ValueNode b) {
 728         if (a.isConstant() &amp;&amp; b.isConstant()) {
 729             Boolean equal = tool.getConstantReflection().constantEquals(a.asConstant(), b.asConstant());
 730             if (equal != null) {
 731                 return !equal.booleanValue();
 732             }
 733         }
 734 
 735         NodeView view = NodeView.from(tool);
 736         Stamp stampA = a.stamp(view);
 737         Stamp stampB = b.stamp(view);
 738         return stampA.alwaysDistinct(stampB);
 739     }
 740 
 741     /**
 742      * Tries to remove an empty if construct or replace an if construct with a materialization.
 743      *
 744      * @return true if a transformation was made, false otherwise
 745      */
 746     private boolean removeOrMaterializeIf(SimplifierTool tool) {
 747         assert trueSuccessor().hasNoUsages() &amp;&amp; falseSuccessor().hasNoUsages();
 748         if (trueSuccessor().next() instanceof AbstractEndNode &amp;&amp; falseSuccessor().next() instanceof AbstractEndNode) {
 749             AbstractEndNode trueEnd = (AbstractEndNode) trueSuccessor().next();
 750             AbstractEndNode falseEnd = (AbstractEndNode) falseSuccessor().next();
 751             AbstractMergeNode merge = trueEnd.merge();
 752             if (merge == falseEnd.merge() &amp;&amp; trueSuccessor().anchored().isEmpty() &amp;&amp; falseSuccessor().anchored().isEmpty()) {
 753                 PhiNode singlePhi = null;
 754                 int distinct = 0;
 755                 for (PhiNode phi : merge.phis()) {
 756                     ValueNode trueValue = phi.valueAt(trueEnd);
 757                     ValueNode falseValue = phi.valueAt(falseEnd);
 758                     if (trueValue != falseValue) {
 759                         distinct++;
 760                         singlePhi = phi;
 761                     }
 762                 }
 763                 if (distinct == 0) {
 764                     /*
 765                      * Multiple phis but merging same values for true and false, so simply delete
 766                      * the path
 767                      */
 768                     removeThroughFalseBranch(tool, merge);
 769                     return true;
 770                 } else if (distinct == 1) {
<a name="21" id="anc21"></a>


 771                     ValueNode trueValue = singlePhi.valueAt(trueEnd);
 772                     ValueNode falseValue = singlePhi.valueAt(falseEnd);
 773                     ValueNode conditional = canonicalizeConditionalCascade(tool, trueValue, falseValue);
 774                     if (conditional != null) {
 775                         conditional = proxyReplacement(conditional);
 776                         singlePhi.setValueAt(trueEnd, conditional);
 777                         removeThroughFalseBranch(tool, merge);
 778                         return true;
 779                     }
 780                 }
 781             }
 782         }
 783         if (trueSuccessor().next() instanceof ReturnNode &amp;&amp; falseSuccessor().next() instanceof ReturnNode) {
 784             ReturnNode trueEnd = (ReturnNode) trueSuccessor().next();
 785             ReturnNode falseEnd = (ReturnNode) falseSuccessor().next();
 786             ValueNode trueValue = trueEnd.result();
 787             ValueNode falseValue = falseEnd.result();
 788             ValueNode value = null;
<a name="22" id="anc22"></a>
 789             if (trueValue != null) {
 790                 if (trueValue == falseValue) {
 791                     value = trueValue;
 792                 } else {
 793                     value = canonicalizeConditionalCascade(tool, trueValue, falseValue);
 794                     if (value == null) {
 795                         return false;
 796                     }
<a name="23" id="anc23"></a>
 797                 }
 798             }
<a name="24" id="anc24"></a>










 799             ReturnNode newReturn = graph().add(new ReturnNode(value));
 800             replaceAtPredecessor(newReturn);
 801             GraphUtil.killCFG(this);
 802             return true;
 803         }
 804         return false;
 805     }
 806 
 807     private ValueNode proxyReplacement(ValueNode replacement) {
 808         /*
 809          * Special case: Every empty diamond we collapse to a conditional node can potentially
 810          * contain loop exit nodes on both branches. See the graph below: The two loop exits
 811          * (instanceof begin node) exit the same loop. The resulting phi is defined outside the
 812          * loop, but the resulting conditional node will be inside the loop, so we need to proxy the
 813          * resulting conditional node. Callers of this method ensure that true and false successor
 814          * have no usages, therefore a and b in the graph below can never be proxies themselves.
 815          */
 816         // @formatter:off
 817         //              +--+
 818         //              |If|
 819         //              +--+      +-----+ +-----+
 820         //         +----+  +----+ |  a  | |  b  |
 821         //         |Lex |  |Lex | +----^+ +^----+
 822         //         +----+  +----+      |   |
 823         //           +-------+         +---+
 824         //           | Merge +---------+Phi|
 825         //           +-------+         +---+
 826         // @formatter:on
 827         if (this.graph().hasValueProxies()) {
 828             if (trueSuccessor instanceof LoopExitNode &amp;&amp; falseSuccessor instanceof LoopExitNode) {
 829                 assert ((LoopExitNode) trueSuccessor).loopBegin() == ((LoopExitNode) falseSuccessor).loopBegin();
 830                 /*
 831                  * we can collapse all proxy nodes on one loop exit, the surviving one, which will
 832                  * be the true successor
 833                  */
<a name="25" id="anc25"></a><span class="line-modified"> 834                 if (falseSuccessor.anchored().isEmpty() &amp;&amp; falseSuccessor.usages().isNotEmpty()) {</span>
 835                     for (Node n : falseSuccessor.usages().snapshot()) {
 836                         assert n instanceof ProxyNode;
 837                         ((ProxyNode) n).setProxyPoint((LoopExitNode) trueSuccessor);
 838                     }
 839                 }
 840                 /*
 841                  * The true successor (surviving loop exit) can have usages, namely proxy nodes, the
 842                  * false successor however, must not have usages any more after the code above
 843                  */
<a name="26" id="anc26"></a><span class="line-modified"> 844                 assert trueSuccessor.anchored().isEmpty() &amp;&amp; falseSuccessor.usages().isEmpty();</span>
 845                 return this.graph().addOrUnique(new ValueProxyNode(replacement, (LoopExitNode) trueSuccessor));
 846             }
 847         }
 848         return replacement;
 849     }
 850 
 851     protected void removeThroughFalseBranch(SimplifierTool tool, AbstractMergeNode merge) {
 852         AbstractBeginNode trueBegin = trueSuccessor();
 853         LogicNode conditionNode = condition();
 854         graph().removeSplitPropagate(this, trueBegin);
 855         tool.addToWorkList(trueBegin);
 856         if (conditionNode != null) {
 857             GraphUtil.tryKillUnused(conditionNode);
 858         }
 859         if (merge.isAlive() &amp;&amp; merge.forwardEndCount() &gt; 1) {
 860             for (FixedNode end : merge.forwardEnds()) {
 861                 Node cur = end;
 862                 while (cur != null &amp;&amp; cur.predecessor() instanceof BeginNode) {
 863                     cur = cur.predecessor();
 864                 }
 865                 if (cur != null &amp;&amp; cur.predecessor() instanceof IfNode) {
 866                     tool.addToWorkList(cur.predecessor());
 867                 }
 868             }
 869         }
 870     }
 871 
 872     private ValueNode canonicalizeConditionalViaImplies(ValueNode trueValue, ValueNode falseValue) {
 873         ValueNode collapsedTrue = trueValue;
 874         ValueNode collapsedFalse = falseValue;
 875         boolean simplify = false;
 876         if (trueValue instanceof ConditionalNode) {
 877             TriState result = condition().implies(false, ((ConditionalNode) trueValue).condition());
 878             if (result.isKnown()) {
 879                 simplify = true;
 880                 collapsedTrue = result.toBoolean() ? ((ConditionalNode) trueValue).trueValue() : ((ConditionalNode) trueValue).falseValue();
 881             }
 882         }
 883         if (falseValue instanceof ConditionalNode) {
 884             TriState result = condition().implies(true, ((ConditionalNode) falseValue).condition());
 885             if (result.isKnown()) {
 886                 simplify = true;
 887                 collapsedFalse = result.toBoolean() ? ((ConditionalNode) falseValue).trueValue() : ((ConditionalNode) falseValue).falseValue();
 888             }
 889         }
 890         if (simplify) {
 891             return graph().unique(new ConditionalNode(condition(), collapsedTrue, collapsedFalse));
 892         }
 893         return null;
 894     }
 895 
 896     private ValueNode canonicalizeConditionalCascade(SimplifierTool tool, ValueNode trueValue, ValueNode falseValue) {
 897         if (trueValue.getStackKind() != falseValue.getStackKind()) {
 898             return null;
 899         }
 900         if (trueValue.getStackKind() != JavaKind.Int &amp;&amp; trueValue.getStackKind() != JavaKind.Long) {
 901             return null;
 902         }
 903         if (trueValue.isConstant() &amp;&amp; falseValue.isConstant()) {
 904             return graph().unique(new ConditionalNode(condition(), trueValue, falseValue));
 905         }
 906         ValueNode value = canonicalizeConditionalViaImplies(trueValue, falseValue);
 907         if (value != null) {
 908             return value;
 909         }
 910         if (!graph().isAfterExpandLogic()) {
 911             /*
 912              * !isAfterExpandLogic() =&gt; Cannot spawn NormalizeCompareNodes after lowering in the
 913              * ExpandLogicPhase.
 914              */
 915             ConditionalNode conditional = null;
 916             ValueNode constant = null;
 917             boolean negateCondition;
 918             if (trueValue instanceof ConditionalNode &amp;&amp; falseValue.isConstant()) {
 919                 conditional = (ConditionalNode) trueValue;
 920                 constant = falseValue;
 921                 negateCondition = true;
 922             } else if (falseValue instanceof ConditionalNode &amp;&amp; trueValue.isConstant()) {
 923                 conditional = (ConditionalNode) falseValue;
 924                 constant = trueValue;
 925                 negateCondition = false;
 926             } else {
 927                 return null;
 928             }
 929             boolean negateConditionalCondition = false;
 930             ValueNode otherValue = null;
 931             if (constant == conditional.trueValue()) {
 932                 otherValue = conditional.falseValue();
 933                 negateConditionalCondition = false;
 934             } else if (constant == conditional.falseValue()) {
 935                 otherValue = conditional.trueValue();
 936                 negateConditionalCondition = true;
 937             }
 938             if (otherValue != null &amp;&amp; otherValue.isConstant()) {
 939                 double shortCutProbability = probability(trueSuccessor());
 940                 LogicNode newCondition = LogicNode.or(condition(), negateCondition, conditional.condition(), negateConditionalCondition, shortCutProbability);
 941                 return graph().unique(new ConditionalNode(newCondition, constant, otherValue));
 942             }
 943 
 944             if (constant.isJavaConstant() &amp;&amp; conditional.trueValue().isJavaConstant() &amp;&amp; conditional.falseValue().isJavaConstant() &amp;&amp; condition() instanceof CompareNode &amp;&amp;
 945                             conditional.condition() instanceof CompareNode) {
 946 
<a name="27" id="anc27"></a><span class="line-modified"> 947                 Condition cond1 = ((CompareNode) condition()).condition().asCondition();</span>

 948                 if (negateCondition) {
 949                     cond1 = cond1.negate();
 950                 }
 951                 // cond1 is EQ, NE, LT, or GE
<a name="28" id="anc28"></a><span class="line-modified"> 952                 Condition cond2 = ((CompareNode) conditional.condition()).condition().asCondition();</span>
<span class="line-modified"> 953                 ValueNode x = ((CompareNode) condition()).getX();</span>
<span class="line-modified"> 954                 ValueNode y = ((CompareNode) condition()).getY();</span>
<span class="line-modified"> 955                 ValueNode x2 = ((CompareNode) conditional.condition()).getX();</span>
<span class="line-modified"> 956                 ValueNode y2 = ((CompareNode) conditional.condition()).getY();</span>

 957                 // `x cond1 y ? c1 : (x2 cond2 y2 ? c2 : c3)`
 958                 boolean sameVars = x == x2 &amp;&amp; y == y2;
 959                 if (!sameVars &amp;&amp; x == y2 &amp;&amp; y == x2) {
 960                     sameVars = true;
 961                     cond2 = cond2.mirror();
 962                 }
 963                 if (sameVars) {
<a name="29" id="anc29"></a>
 964                     JavaKind stackKind = conditional.trueValue().stamp(NodeView.from(tool)).getStackKind();
 965                     assert !stackKind.isNumericFloat();
 966 
<a name="30" id="anc30"></a><span class="line-modified"> 967                     ValueNode v1 = constant;</span>
<span class="line-modified"> 968                     ValueNode v2 = conditional.trueValue();</span>
<span class="line-modified"> 969                     ValueNode v3 = conditional.falseValue();</span>
<span class="line-removed"> 970 </span>
<span class="line-removed"> 971                     long c1 = v1.asJavaConstant().asLong();</span>
<span class="line-removed"> 972                     long c2 = v2.asJavaConstant().asLong();</span>
<span class="line-removed"> 973                     long c3 = v3.asJavaConstant().asLong();</span>
<span class="line-removed"> 974 </span>
<span class="line-removed"> 975                     if (cond1 == Condition.LT &amp;&amp; cond2 == Condition.EQ &amp;&amp; c1 == -1 &amp;&amp; c2 == 0 &amp;&amp; c3 == 1) {</span>
<span class="line-removed"> 976                         // x &lt; y ? -1 : (x == y ? 0 : 1) =&gt; x cmp y</span>
<span class="line-removed"> 977                         return graph().unique(new NormalizeCompareNode(x, y, stackKind, false));</span>
<span class="line-removed"> 978                     } else if (cond1 == Condition.LT &amp;&amp; cond2 == Condition.EQ &amp;&amp; c1 == 1 &amp;&amp; c2 == 0 &amp;&amp; c3 == -1) {</span>
<span class="line-removed"> 979                         // x &lt; y ? 1 : (x == y ? 0 : -1) =&gt; y cmp x</span>
<span class="line-removed"> 980                         return graph().unique(new NormalizeCompareNode(y, x, stackKind, false));</span>
<span class="line-removed"> 981                     } else if (cond1 == Condition.EQ &amp;&amp; cond2 == Condition.LT &amp;&amp; c1 == 0 &amp;&amp; c2 == -1 &amp;&amp; c3 == 1) {</span>
<span class="line-removed"> 982                         // x == y ? 0 : (x &lt; y ? -1 : 1) =&gt; x cmp y</span>
<span class="line-removed"> 983                         return graph().unique(new NormalizeCompareNode(x, y, stackKind, false));</span>
<span class="line-removed"> 984                     } else if (cond1 == Condition.EQ &amp;&amp; cond2 == Condition.LT &amp;&amp; c1 == 0 &amp;&amp; c2 == 1 &amp;&amp; c3 == -1) {</span>
<span class="line-removed"> 985                         // x == y ? 0 : (x &lt; y ? 1 : -1) =&gt; y cmp x</span>
<span class="line-removed"> 986                         return graph().unique(new NormalizeCompareNode(y, x, stackKind, false));</span>
<span class="line-removed"> 987                     } else if (cond1 == Condition.EQ &amp;&amp; cond2 == Condition.GT &amp;&amp; c1 == 0 &amp;&amp; c2 == -1 &amp;&amp; c3 == 1) {</span>
<span class="line-removed"> 988                         // x == y ? 0 : (x &gt; y ? -1 : 1) =&gt; y cmp x</span>
<span class="line-removed"> 989                         return graph().unique(new NormalizeCompareNode(y, x, stackKind, false));</span>
<span class="line-removed"> 990                     } else if (cond1 == Condition.EQ &amp;&amp; cond2 == Condition.GT &amp;&amp; c1 == 0 &amp;&amp; c2 == 1 &amp;&amp; c3 == -1) {</span>
<span class="line-removed"> 991                         // x == y ? 0 : (x &gt; y ? 1 : -1) =&gt; x cmp y</span>
<span class="line-removed"> 992                         return graph().unique(new NormalizeCompareNode(x, y, stackKind, false));</span>
<span class="line-removed"> 993                     } else if (cond1 == Condition.LT &amp;&amp; cond2 == Condition.GT &amp;&amp; c1 == 1 &amp;&amp; c2 == -1 &amp;&amp; c3 == 0) {</span>
<span class="line-removed"> 994                         // x &lt; y ? 1 : (x &gt; y ? -1 : 0) =&gt; y cmp x</span>
<span class="line-removed"> 995                         return graph().unique(new NormalizeCompareNode(y, x, stackKind, false));</span>
<span class="line-removed"> 996                     } else if (cond1 == Condition.LT &amp;&amp; cond2 == Condition.GT &amp;&amp; c1 == -1 &amp;&amp; c2 == 1 &amp;&amp; c3 == 0) {</span>
<span class="line-removed"> 997                         // x &lt; y ? -1 : (x &gt; y ? 1 : 0) =&gt; x cmp y</span>
<span class="line-removed"> 998                         return graph().unique(new NormalizeCompareNode(x, y, stackKind, false));</span>
<span class="line-removed"> 999                     }</span>
<span class="line-removed">1000                 }</span>
<span class="line-removed">1001             }</span>
<span class="line-removed">1002         }</span>
<span class="line-removed">1003         return null;</span>
<span class="line-removed">1004     }</span>
1005 
<a name="31" id="anc31"></a><span class="line-modified">1006     /**</span>
<span class="line-modified">1007      * Take an if that is immediately dominated by a merge with a single phi and split off any paths</span>
<span class="line-modified">1008      * where the test would be statically decidable creating a new merge below the approriate side</span>
<span class="line-modified">1009      * of the IfNode. Any undecidable tests will continue to use the original IfNode.</span>
<span class="line-modified">1010      *</span>
<span class="line-removed">1011      * @param tool</span>
<span class="line-removed">1012      */</span>
<span class="line-removed">1013     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-removed">1014     private boolean splitIfAtPhi(SimplifierTool tool) {</span>
<span class="line-removed">1015         if (graph().getGuardsStage().areFrameStatesAtSideEffects()) {</span>
<span class="line-removed">1016             // Disabled until we make sure we have no FrameState-less merges at this stage</span>
<span class="line-removed">1017             return false;</span>
<span class="line-removed">1018         }</span>
<span class="line-removed">1019 </span>
<span class="line-removed">1020         if (!(predecessor() instanceof MergeNode)) {</span>
<span class="line-removed">1021             return false;</span>
<span class="line-removed">1022         }</span>
<span class="line-removed">1023         MergeNode merge = (MergeNode) predecessor();</span>
<span class="line-removed">1024         if (merge.forwardEndCount() == 1) {</span>
<span class="line-removed">1025             // Don&#39;t bother.</span>
<span class="line-removed">1026             return false;</span>
<span class="line-removed">1027         }</span>
<span class="line-removed">1028         if (merge.usages().count() != 1 || merge.phis().count() != 1) {</span>
<span class="line-removed">1029             return false;</span>
<span class="line-removed">1030         }</span>
<span class="line-removed">1031         if (merge.stateAfter() != null) {</span>
<span class="line-removed">1032             /* We&#39;ll get the chance to simplify this after frame state assignment. */</span>
<span class="line-removed">1033             return false;</span>
<span class="line-removed">1034         }</span>
<span class="line-removed">1035         PhiNode phi = merge.phis().first();</span>
<span class="line-removed">1036         if (phi.usages().count() != 1) {</span>
<span class="line-removed">1037             /*</span>
<span class="line-removed">1038              * For simplicity the below code assumes assumes the phi goes dead at the end so skip</span>
<span class="line-removed">1039              * this case.</span>
<span class="line-removed">1040              */</span>
<span class="line-removed">1041             return false;</span>
<span class="line-removed">1042         }</span>
<span class="line-removed">1043 </span>
<span class="line-removed">1044         /*</span>
<span class="line-removed">1045          * Check that the condition uses the phi and that there is only one user of the condition</span>
<span class="line-removed">1046          * expression.</span>
<span class="line-removed">1047          */</span>
<span class="line-removed">1048         if (!conditionUses(condition(), phi)) {</span>
<span class="line-removed">1049             return false;</span>
<span class="line-removed">1050         }</span>
<span class="line-removed">1051 </span>
<span class="line-removed">1052         /*</span>
<span class="line-removed">1053          * We could additionally filter for the case that at least some of the Phi inputs or one of</span>
<span class="line-removed">1054          * the condition inputs are constants but there are cases where a non-constant is</span>
<span class="line-removed">1055          * simplifiable, usually where the stamp allows the question to be answered.</span>
<span class="line-removed">1056          */</span>
<span class="line-removed">1057 </span>
<span class="line-removed">1058         /* Each successor of the if gets a new merge if needed. */</span>
<span class="line-removed">1059         MergeNode trueMerge = null;</span>
<span class="line-removed">1060         MergeNode falseMerge = null;</span>
<span class="line-removed">1061         assert merge.stateAfter() == null;</span>
<span class="line-removed">1062 </span>
<span class="line-removed">1063         for (EndNode end : merge.forwardEnds().snapshot()) {</span>
<span class="line-removed">1064             Node value = phi.valueAt(end);</span>
<span class="line-removed">1065             LogicNode result = computeCondition(tool, condition, phi, value);</span>
<span class="line-removed">1066             if (result instanceof LogicConstantNode) {</span>
<span class="line-removed">1067                 merge.removeEnd(end);</span>
<span class="line-removed">1068                 if (((LogicConstantNode) result).getValue()) {</span>
<span class="line-removed">1069                     if (trueMerge == null) {</span>
<span class="line-removed">1070                         trueMerge = insertMerge(trueSuccessor());</span>
1071                     }
<a name="32" id="anc32"></a><span class="line-modified">1072                     trueMerge.addForwardEnd(end);</span>
<span class="line-modified">1073                 } else {</span>
<span class="line-modified">1074                     if (falseMerge == null) {</span>
<span class="line-modified">1075                         falseMerge = insertMerge(falseSuccessor());</span>

1076                     }
<a name="33" id="anc33"></a><span class="line-modified">1077                     falseMerge.addForwardEnd(end);</span>
<span class="line-modified">1078                 }</span>
<span class="line-modified">1079             } else if (result != condition) {</span>
<span class="line-modified">1080                 // Build a new IfNode using the new condition</span>
<span class="line-modified">1081                 BeginNode trueBegin = graph().add(new BeginNode());</span>
<span class="line-modified">1082                 trueBegin.setNodeSourcePosition(trueSuccessor().getNodeSourcePosition());</span>
<span class="line-modified">1083                 BeginNode falseBegin = graph().add(new BeginNode());</span>
<span class="line-modified">1084                 falseBegin.setNodeSourcePosition(falseSuccessor().getNodeSourcePosition());</span>
<span class="line-modified">1085 </span>
<span class="line-modified">1086                 if (result.graph() == null) {</span>
<span class="line-modified">1087                     result = graph().addOrUniqueWithInputs(result);</span>
<span class="line-modified">1088                     result.setNodeSourcePosition(condition.getNodeSourcePosition());</span>
<span class="line-modified">1089                 }</span>
<span class="line-modified">1090                 IfNode newIfNode = graph().add(new IfNode(result, trueBegin, falseBegin, trueSuccessorProbability));</span>
<span class="line-modified">1091                 newIfNode.setNodeSourcePosition(getNodeSourcePosition());</span>
<span class="line-modified">1092                 merge.removeEnd(end);</span>
<span class="line-modified">1093                 ((FixedWithNextNode) end.predecessor()).setNext(newIfNode);</span>
<span class="line-modified">1094 </span>
<span class="line-modified">1095                 if (trueMerge == null) {</span>
<span class="line-modified">1096                     trueMerge = insertMerge(trueSuccessor());</span>
<span class="line-modified">1097                 }</span>
<span class="line-modified">1098                 trueBegin.setNext(graph().add(new EndNode()));</span>
<span class="line-modified">1099                 trueMerge.addForwardEnd((EndNode) trueBegin.next());</span>
<span class="line-modified">1100 </span>
<span class="line-modified">1101                 if (falseMerge == null) {</span>
<span class="line-modified">1102                     falseMerge = insertMerge(falseSuccessor());</span>
<span class="line-modified">1103                 }</span>
<span class="line-modified">1104                 falseBegin.setNext(graph().add(new EndNode()));</span>
<span class="line-modified">1105                 falseMerge.addForwardEnd((EndNode) falseBegin.next());</span>
<span class="line-modified">1106 </span>
<span class="line-modified">1107                 end.safeDelete();</span>
<span class="line-modified">1108             }</span>
<span class="line-modified">1109         }</span>
<span class="line-modified">1110 </span>
<span class="line-modified">1111         transferProxies(trueSuccessor(), trueMerge);</span>
<span class="line-removed">1112         transferProxies(falseSuccessor(), falseMerge);</span>
<span class="line-removed">1113 </span>
<span class="line-removed">1114         cleanupMerge(merge);</span>
<span class="line-removed">1115         cleanupMerge(trueMerge);</span>
<span class="line-removed">1116         cleanupMerge(falseMerge);</span>
<span class="line-removed">1117 </span>
<span class="line-removed">1118         return true;</span>
<span class="line-removed">1119     }</span>
<span class="line-removed">1120 </span>
<span class="line-removed">1121     /**</span>
<span class="line-removed">1122      * @param condition</span>
<span class="line-removed">1123      * @param phi</span>
<span class="line-removed">1124      * @return true if the passed in {@code condition} uses {@code phi} and the condition is only</span>
<span class="line-removed">1125      *         used once. Since the phi will go dead the condition using it will also have to be</span>
<span class="line-removed">1126      *         dead after the optimization.</span>
<span class="line-removed">1127      */</span>
<span class="line-removed">1128     private static boolean conditionUses(LogicNode condition, PhiNode phi) {</span>
<span class="line-removed">1129         if (condition.usages().count() != 1) {</span>
<span class="line-removed">1130             return false;</span>
<span class="line-removed">1131         }</span>
<span class="line-removed">1132         if (condition instanceof ShortCircuitOrNode) {</span>
<span class="line-removed">1133             if (condition.graph().getGuardsStage().areDeoptsFixed()) {</span>
<span class="line-removed">1134                 /*</span>
<span class="line-removed">1135                  * It can be unsafe to simplify a ShortCircuitOr before deopts are fixed because</span>
<span class="line-removed">1136                  * conversion to guards assumes that all the required conditions are being tested.</span>
<span class="line-removed">1137                  * Simplfying the condition based on context before this happens may lose a</span>
<span class="line-removed">1138                  * condition.</span>
<span class="line-removed">1139                  */</span>
<span class="line-removed">1140                 ShortCircuitOrNode orNode = (ShortCircuitOrNode) condition;</span>
<span class="line-removed">1141                 return (conditionUses(orNode.x, phi) || conditionUses(orNode.y, phi));</span>
<span class="line-removed">1142             }</span>
<span class="line-removed">1143         } else if (condition instanceof Canonicalizable.Unary&lt;?&gt;) {</span>
<span class="line-removed">1144             Canonicalizable.Unary&lt;?&gt; unary = (Canonicalizable.Unary&lt;?&gt;) condition;</span>
<span class="line-removed">1145             return unary.getValue() == phi;</span>
<span class="line-removed">1146         } else if (condition instanceof Canonicalizable.Binary&lt;?&gt;) {</span>
<span class="line-removed">1147             Canonicalizable.Binary&lt;?&gt; binary = (Canonicalizable.Binary&lt;?&gt;) condition;</span>
<span class="line-removed">1148             return binary.getX() == phi || binary.getY() == phi;</span>
<span class="line-removed">1149         }</span>
<span class="line-removed">1150         return false;</span>
<span class="line-removed">1151     }</span>
<span class="line-removed">1152 </span>
<span class="line-removed">1153     /**</span>
<span class="line-removed">1154      * Canonicalize {@code} condition using {@code value} in place of {@code phi}.</span>
<span class="line-removed">1155      *</span>
<span class="line-removed">1156      * @param tool</span>
<span class="line-removed">1157      * @param condition</span>
<span class="line-removed">1158      * @param phi</span>
<span class="line-removed">1159      * @param value</span>
<span class="line-removed">1160      * @return an improved LogicNode or the original condition</span>
<span class="line-removed">1161      */</span>
<span class="line-removed">1162     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">1163     private static LogicNode computeCondition(SimplifierTool tool, LogicNode condition, PhiNode phi, Node value) {</span>
<span class="line-removed">1164         if (condition instanceof ShortCircuitOrNode) {</span>
<span class="line-removed">1165             if (condition.graph().getGuardsStage().areDeoptsFixed() &amp;&amp; !condition.graph().isAfterExpandLogic()) {</span>
<span class="line-removed">1166                 ShortCircuitOrNode orNode = (ShortCircuitOrNode) condition;</span>
<span class="line-removed">1167                 LogicNode resultX = computeCondition(tool, orNode.x, phi, value);</span>
<span class="line-removed">1168                 LogicNode resultY = computeCondition(tool, orNode.y, phi, value);</span>
<span class="line-removed">1169                 if (resultX != orNode.x || resultY != orNode.y) {</span>
<span class="line-removed">1170                     LogicNode result = orNode.canonical(tool, resultX, resultY);</span>
<span class="line-removed">1171                     if (result != orNode) {</span>
<span class="line-removed">1172                         return result;</span>
1173                     }
<a name="34" id="anc34"></a><span class="line-removed">1174                     /*</span>
<span class="line-removed">1175                      * Create a new node to carry the optimized inputs.</span>
<span class="line-removed">1176                      */</span>
<span class="line-removed">1177                     ShortCircuitOrNode newOr = new ShortCircuitOrNode(resultX, orNode.xNegated, resultY,</span>
<span class="line-removed">1178                                     orNode.yNegated, orNode.getShortCircuitProbability());</span>
<span class="line-removed">1179                     return newOr.canonical(tool);</span>
1180                 }
<a name="35" id="anc35"></a><span class="line-removed">1181                 return orNode;</span>
<span class="line-removed">1182             }</span>
<span class="line-removed">1183         } else if (condition instanceof Canonicalizable.Binary&lt;?&gt;) {</span>
<span class="line-removed">1184             Canonicalizable.Binary&lt;Node&gt; compare = (Canonicalizable.Binary&lt;Node&gt;) condition;</span>
<span class="line-removed">1185             if (compare.getX() == phi) {</span>
<span class="line-removed">1186                 return (LogicNode) compare.canonical(tool, value, compare.getY());</span>
<span class="line-removed">1187             } else if (compare.getY() == phi) {</span>
<span class="line-removed">1188                 return (LogicNode) compare.canonical(tool, compare.getX(), value);</span>
<span class="line-removed">1189             }</span>
<span class="line-removed">1190         } else if (condition instanceof Canonicalizable.Unary&lt;?&gt;) {</span>
<span class="line-removed">1191             Canonicalizable.Unary&lt;Node&gt; compare = (Canonicalizable.Unary&lt;Node&gt;) condition;</span>
<span class="line-removed">1192             if (compare.getValue() == phi) {</span>
<span class="line-removed">1193                 return (LogicNode) compare.canonical(tool, value);</span>
<span class="line-removed">1194             }</span>
<span class="line-removed">1195         }</span>
<span class="line-removed">1196         if (condition instanceof Canonicalizable) {</span>
<span class="line-removed">1197             return (LogicNode) ((Canonicalizable) condition).canonical(tool);</span>
<span class="line-removed">1198         }</span>
<span class="line-removed">1199         return condition;</span>
<span class="line-removed">1200     }</span>
<span class="line-removed">1201 </span>
<span class="line-removed">1202     private static void transferProxies(AbstractBeginNode successor, MergeNode falseMerge) {</span>
<span class="line-removed">1203         if (successor instanceof LoopExitNode &amp;&amp; falseMerge != null) {</span>
<span class="line-removed">1204             LoopExitNode loopExitNode = (LoopExitNode) successor;</span>
<span class="line-removed">1205             for (ProxyNode proxy : loopExitNode.proxies().snapshot()) {</span>
<span class="line-removed">1206                 proxy.replaceFirstInput(successor, falseMerge);</span>
1207             }
1208         }
<a name="36" id="anc36"></a>
1209     }
1210 
<a name="37" id="anc37"></a><span class="line-modified">1211     private void cleanupMerge(MergeNode merge) {</span>
<span class="line-modified">1212         if (merge != null &amp;&amp; merge.isAlive()) {</span>
<span class="line-modified">1213             if (merge.forwardEndCount() == 0) {</span>
<span class="line-modified">1214                 GraphUtil.killCFG(merge);</span>
<span class="line-modified">1215             } else if (merge.forwardEndCount() == 1) {</span>
<span class="line-modified">1216                 graph().reduceTrivialMerge(merge);</span>
<span class="line-modified">1217             }</span>

1218         }
1219     }
1220 
<a name="38" id="anc38"></a><span class="line-modified">1221     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-modified">1222     private MergeNode insertMerge(AbstractBeginNode begin) {</span>
<span class="line-modified">1223         MergeNode merge = graph().add(new MergeNode());</span>
<span class="line-modified">1224         if (!begin.anchored().isEmpty()) {</span>
<span class="line-modified">1225             Object before = null;</span>
<span class="line-modified">1226             before = begin.anchored().snapshot();</span>
<span class="line-modified">1227             begin.replaceAtUsages(InputType.Guard, merge);</span>
<span class="line-removed">1228             begin.replaceAtUsages(InputType.Anchor, merge);</span>
<span class="line-removed">1229             assert begin.anchored().isEmpty() : before + &quot; &quot; + begin.anchored().snapshot();</span>
<span class="line-removed">1230         }</span>
<span class="line-removed">1231 </span>
<span class="line-removed">1232         AbstractBeginNode theBegin = begin;</span>
<span class="line-removed">1233         if (begin instanceof LoopExitNode) {</span>
<span class="line-removed">1234             // Insert an extra begin to make it easier.</span>
<span class="line-removed">1235             try (DebugCloseable position = begin.withNodeSourcePosition()) {</span>
<span class="line-removed">1236                 theBegin = graph().add(new BeginNode());</span>
<span class="line-removed">1237                 begin.replaceAtPredecessor(theBegin);</span>
<span class="line-removed">1238                 theBegin.setNext(begin);</span>
<span class="line-removed">1239             }</span>
<span class="line-removed">1240         }</span>
<span class="line-removed">1241         FixedNode next = theBegin.next();</span>
<span class="line-removed">1242         next.replaceAtPredecessor(merge);</span>
<span class="line-removed">1243         theBegin.setNext(graph().add(new EndNode()));</span>
<span class="line-removed">1244         merge.addForwardEnd((EndNode) theBegin.next());</span>
<span class="line-removed">1245         merge.setNext(next);</span>
<span class="line-removed">1246         return merge;</span>
1247     }
1248 
1249     /**
1250      * Tries to connect code that initializes a variable directly with the successors of an if
1251      * construct that switches on the variable. For example, the pseudo code below:
1252      *
1253      * &lt;pre&gt;
1254      * contains(list, e, yes, no) {
1255      *     if (list == null || e == null) {
1256      *         condition = false;
1257      *     } else {
1258      *         condition = false;
1259      *         for (i in list) {
1260      *             if (i.equals(e)) {
1261      *                 condition = true;
1262      *                 break;
1263      *             }
1264      *         }
1265      *     }
1266      *     if (condition) {
1267      *         return yes;
1268      *     } else {
1269      *         return no;
1270      *     }
1271      * }
1272      * &lt;/pre&gt;
1273      *
1274      * will be transformed into:
1275      *
1276      * &lt;pre&gt;
1277      * contains(list, e, yes, no) {
1278      *     if (list == null || e == null) {
1279      *         return no;
1280      *     } else {
1281      *         condition = false;
1282      *         for (i in list) {
1283      *             if (i.equals(e)) {
1284      *                 return yes;
1285      *             }
1286      *         }
1287      *         return no;
1288      *     }
1289      * }
1290      * &lt;/pre&gt;
1291      *
1292      * @return true if a transformation was made, false otherwise
1293      */
1294     private boolean removeIntermediateMaterialization(SimplifierTool tool) {
1295         if (!(predecessor() instanceof AbstractMergeNode) || predecessor() instanceof LoopBeginNode) {
1296             return false;
1297         }
1298         AbstractMergeNode merge = (AbstractMergeNode) predecessor();
1299 
1300         if (!(condition() instanceof CompareNode)) {
1301             return false;
1302         }
1303 
1304         CompareNode compare = (CompareNode) condition();
1305         if (compare.getUsageCount() != 1) {
1306             return false;
1307         }
1308 
1309         // Only consider merges with a single usage that is both a phi and an operand of the
1310         // comparison
1311         NodeIterable&lt;Node&gt; mergeUsages = merge.usages();
1312         if (mergeUsages.count() != 1) {
1313             return false;
1314         }
1315         Node singleUsage = mergeUsages.first();
1316         if (!(singleUsage instanceof ValuePhiNode) || (singleUsage != compare.getX() &amp;&amp; singleUsage != compare.getY())) {
1317             return false;
1318         }
1319 
<a name="39" id="anc39"></a>



1320         // Ensure phi is used by at most the comparison and the merge&#39;s frame state (if any)
1321         ValuePhiNode phi = (ValuePhiNode) singleUsage;
1322         NodeIterable&lt;Node&gt; phiUsages = phi.usages();
<a name="40" id="anc40"></a><span class="line-removed">1323         if (phiUsages.count() &gt; 2) {</span>
<span class="line-removed">1324             return false;</span>
<span class="line-removed">1325         }</span>
1326         for (Node usage : phiUsages) {
<a name="41" id="anc41"></a><span class="line-modified">1327             if (usage != compare &amp;&amp; usage != merge.stateAfter()) {</span>
<span class="line-modified">1328                 return false;</span>





































1329             }
<a name="42" id="anc42"></a>
1330         }
1331 
1332         List&lt;EndNode&gt; mergePredecessors = merge.cfgPredecessors().snapshot();
1333         assert phi.valueCount() == merge.forwardEndCount();
1334 
1335         Constant[] xs = constantValues(compare.getX(), merge, false);
1336         Constant[] ys = constantValues(compare.getY(), merge, false);
1337         if (xs == null || ys == null) {
1338             return false;
1339         }
1340 
<a name="43" id="anc43"></a><span class="line-modified">1341         // Sanity check that both ends are not followed by a merge without frame state.</span>
<span class="line-removed">1342         if (!checkFrameState(trueSuccessor()) &amp;&amp; !checkFrameState(falseSuccessor())) {</span>
1343             return false;
1344         }
1345 
1346         List&lt;EndNode&gt; falseEnds = new ArrayList&lt;&gt;(mergePredecessors.size());
1347         List&lt;EndNode&gt; trueEnds = new ArrayList&lt;&gt;(mergePredecessors.size());
1348         EconomicMap&lt;AbstractEndNode, ValueNode&gt; phiValues = EconomicMap.create(Equivalence.IDENTITY, mergePredecessors.size());
1349 
1350         AbstractBeginNode oldFalseSuccessor = falseSuccessor();
1351         AbstractBeginNode oldTrueSuccessor = trueSuccessor();
1352 
1353         setFalseSuccessor(null);
1354         setTrueSuccessor(null);
1355 
1356         Iterator&lt;EndNode&gt; ends = mergePredecessors.iterator();
1357         for (int i = 0; i &lt; xs.length; i++) {
1358             EndNode end = ends.next();
1359             phiValues.put(end, phi.valueAt(end));
1360             if (compare.condition().foldCondition(xs[i], ys[i], tool.getConstantReflection(), compare.unorderedIsTrue())) {
1361                 trueEnds.add(end);
1362             } else {
1363                 falseEnds.add(end);
1364             }
1365         }
1366         assert !ends.hasNext();
1367         assert falseEnds.size() + trueEnds.size() == xs.length;
1368 
<a name="44" id="anc44"></a><span class="line-modified">1369         connectEnds(falseEnds, phiValues, oldFalseSuccessor, merge, tool);</span>
<span class="line-modified">1370         connectEnds(trueEnds, phiValues, oldTrueSuccessor, merge, tool);</span>
1371 
1372         if (this.trueSuccessorProbability == 0.0) {
1373             for (AbstractEndNode endNode : trueEnds) {
1374                 propagateZeroProbability(endNode);
1375             }
1376         }
1377 
1378         if (this.trueSuccessorProbability == 1.0) {
1379             for (AbstractEndNode endNode : falseEnds) {
1380                 propagateZeroProbability(endNode);
1381             }
1382         }
1383 
1384         /*
1385          * Remove obsolete ends only after processing all ends, otherwise oldTrueSuccessor or
1386          * oldFalseSuccessor might have been removed if it is a LoopExitNode.
1387          */
1388         if (falseEnds.isEmpty()) {
1389             GraphUtil.killCFG(oldFalseSuccessor);
1390         }
1391         if (trueEnds.isEmpty()) {
1392             GraphUtil.killCFG(oldTrueSuccessor);
1393         }
1394         GraphUtil.killCFG(merge);
1395 
1396         assert !merge.isAlive() : merge;
1397         assert !phi.isAlive() : phi;
1398         assert !compare.isAlive() : compare;
1399         assert !this.isAlive() : this;
1400 
1401         return true;
1402     }
1403 
<a name="45" id="anc45"></a><span class="line-modified">1404     private void propagateZeroProbability(FixedNode startNode) {</span>
1405         Node prev = null;
1406         for (FixedNode node : GraphUtil.predecessorIterable(startNode)) {
1407             if (node instanceof IfNode) {
1408                 IfNode ifNode = (IfNode) node;
1409                 if (ifNode.trueSuccessor() == prev) {
1410                     if (ifNode.trueSuccessorProbability == 0.0) {
1411                         return;
1412                     } else if (ifNode.trueSuccessorProbability == 1.0) {
1413                         continue;
1414                     } else {
1415                         ifNode.setTrueSuccessorProbability(0.0);
1416                         return;
1417                     }
1418                 } else if (ifNode.falseSuccessor() == prev) {
1419                     if (ifNode.trueSuccessorProbability == 1.0) {
1420                         return;
1421                     } else if (ifNode.trueSuccessorProbability == 0.0) {
1422                         continue;
1423                     } else {
1424                         ifNode.setTrueSuccessorProbability(1.0);
1425                         return;
1426                     }
1427                 } else {
1428                     throw new GraalError(&quot;Illegal state&quot;);
1429                 }
1430             } else if (node instanceof AbstractMergeNode &amp;&amp; !(node instanceof LoopBeginNode)) {
1431                 for (AbstractEndNode endNode : ((AbstractMergeNode) node).cfgPredecessors()) {
1432                     propagateZeroProbability(endNode);
1433                 }
1434                 return;
1435             }
1436             prev = node;
1437         }
1438     }
1439 
<a name="46" id="anc46"></a><span class="line-removed">1440     private static boolean checkFrameState(FixedNode start) {</span>
<span class="line-removed">1441         FixedNode node = start;</span>
<span class="line-removed">1442         while (true) {</span>
<span class="line-removed">1443             if (node instanceof AbstractMergeNode) {</span>
<span class="line-removed">1444                 AbstractMergeNode mergeNode = (AbstractMergeNode) node;</span>
<span class="line-removed">1445                 if (mergeNode.stateAfter() == null) {</span>
<span class="line-removed">1446                     return false;</span>
<span class="line-removed">1447                 } else {</span>
<span class="line-removed">1448                     return true;</span>
<span class="line-removed">1449                 }</span>
<span class="line-removed">1450             } else if (node instanceof StateSplit) {</span>
<span class="line-removed">1451                 StateSplit stateSplitNode = (StateSplit) node;</span>
<span class="line-removed">1452                 if (stateSplitNode.stateAfter() != null) {</span>
<span class="line-removed">1453                     return true;</span>
<span class="line-removed">1454                 }</span>
<span class="line-removed">1455             }</span>
<span class="line-removed">1456 </span>
<span class="line-removed">1457             if (node instanceof ControlSplitNode) {</span>
<span class="line-removed">1458                 ControlSplitNode controlSplitNode = (ControlSplitNode) node;</span>
<span class="line-removed">1459                 for (Node succ : controlSplitNode.cfgSuccessors()) {</span>
<span class="line-removed">1460                     if (checkFrameState((FixedNode) succ)) {</span>
<span class="line-removed">1461                         return true;</span>
<span class="line-removed">1462                     }</span>
<span class="line-removed">1463                 }</span>
<span class="line-removed">1464                 return false;</span>
<span class="line-removed">1465             } else if (node instanceof FixedWithNextNode) {</span>
<span class="line-removed">1466                 FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) node;</span>
<span class="line-removed">1467                 node = fixedWithNextNode.next();</span>
<span class="line-removed">1468             } else if (node instanceof AbstractEndNode) {</span>
<span class="line-removed">1469                 AbstractEndNode endNode = (AbstractEndNode) node;</span>
<span class="line-removed">1470                 node = endNode.merge();</span>
<span class="line-removed">1471             } else if (node instanceof ControlSinkNode) {</span>
<span class="line-removed">1472                 return true;</span>
<span class="line-removed">1473             } else {</span>
<span class="line-removed">1474                 return false;</span>
<span class="line-removed">1475             }</span>
<span class="line-removed">1476         }</span>
<span class="line-removed">1477     }</span>
<span class="line-removed">1478 </span>
1479     /**
1480      * Connects a set of ends to a given successor, inserting a merge node if there is more than one
1481      * end. If {@code ends} is not empty, then {@code successor} is added to {@code tool}&#39;s
1482      * {@linkplain SimplifierTool#addToWorkList(org.graalvm.compiler.graph.Node) work list}.
1483      *
<a name="47" id="anc47"></a><span class="line-modified">1484      * @param oldMerge the merge being removed</span>
1485      * @param phiValues the values of the phi at the merge, keyed by the merge ends
<a name="48" id="anc48"></a>
1486      */
<a name="49" id="anc49"></a><span class="line-modified">1487     private void connectEnds(List&lt;EndNode&gt; ends, EconomicMap&lt;AbstractEndNode, ValueNode&gt; phiValues, AbstractBeginNode successor, AbstractMergeNode oldMerge, SimplifierTool tool) {</span>
1488         if (!ends.isEmpty()) {
<a name="50" id="anc50"></a>









1489             if (ends.size() == 1) {
1490                 AbstractEndNode end = ends.get(0);
<a name="51" id="anc51"></a>


1491                 ((FixedWithNextNode) end.predecessor()).setNext(successor);
1492                 oldMerge.removeEnd(end);
1493                 GraphUtil.killCFG(end);
1494             } else {
1495                 // Need a new phi in case the frame state is used by more than the merge being
1496                 // removed.
1497                 NodeView view = NodeView.from(tool);
1498                 AbstractMergeNode newMerge = graph().add(new MergeNode());
1499                 PhiNode oldPhi = (PhiNode) oldMerge.usages().first();
1500                 PhiNode newPhi = graph().addWithoutUnique(new ValuePhiNode(oldPhi.stamp(view), newMerge));
1501 
<a name="52" id="anc52"></a>



1502                 for (EndNode end : ends) {
1503                     newPhi.addInput(phiValues.get(end));
1504                     newMerge.addForwardEnd(end);
1505                 }
1506 
1507                 FrameState stateAfter = oldMerge.stateAfter();
1508                 if (stateAfter != null) {
1509                     stateAfter = stateAfter.duplicate();
1510                     stateAfter.replaceFirstInput(oldPhi, newPhi);
1511                     newMerge.setStateAfter(stateAfter);
1512                 }
1513 
1514                 newMerge.setNext(successor);
1515             }
1516             tool.addToWorkList(successor);
1517         }
1518     }
1519 
1520     /**
1521      * Gets an array of constants derived from a node that is either a {@link ConstantNode} or a
1522      * {@link PhiNode} whose input values are all constants. The length of the returned array is
1523      * equal to the number of ends terminating in a given merge node.
1524      *
1525      * @return null if {@code node} is neither a {@link ConstantNode} nor a {@link PhiNode} whose
1526      *         input values are all constants
1527      */
1528     public static Constant[] constantValues(ValueNode node, AbstractMergeNode merge, boolean allowNull) {
1529         if (node.isConstant()) {
1530             Constant[] result = new Constant[merge.forwardEndCount()];
1531             Arrays.fill(result, node.asConstant());
1532             return result;
1533         }
1534 
1535         if (node instanceof PhiNode) {
1536             PhiNode phi = (PhiNode) node;
1537             if (phi.merge() == merge &amp;&amp; phi instanceof ValuePhiNode &amp;&amp; phi.valueCount() == merge.forwardEndCount()) {
1538                 Constant[] result = new Constant[merge.forwardEndCount()];
1539                 int i = 0;
1540                 for (ValueNode n : phi.values()) {
1541                     if (!allowNull &amp;&amp; !n.isConstant()) {
1542                         return null;
1543                     }
1544                     result[i++] = n.asConstant();
1545                 }
1546                 return result;
1547             }
1548         }
1549 
1550         return null;
1551     }
1552 
1553     @Override
1554     public AbstractBeginNode getPrimarySuccessor() {
1555         return null;
1556     }
1557 
1558     public AbstractBeginNode getSuccessor(boolean result) {
1559         return result ? this.trueSuccessor() : this.falseSuccessor();
1560     }
1561 
1562     @Override
1563     public boolean setProbability(AbstractBeginNode successor, double value) {
1564         if (successor == this.trueSuccessor()) {
1565             this.setTrueSuccessorProbability(value);
1566             return true;
1567         } else if (successor == this.falseSuccessor()) {
1568             this.setTrueSuccessorProbability(1.0 - value);
1569             return true;
1570         }
1571         return false;
1572     }
1573 
1574     @Override
1575     public int getSuccessorCount() {
1576         return 2;
1577     }
1578 }
<a name="53" id="anc53"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="53" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/UnsafeAccessNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SwitchNode.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="UnsafeMemoryStoreNode.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/UnsafeAccessNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,10 ***</span>
<span class="line-new-header">--- 25,12 ---</span>
  package org.graalvm.compiler.nodes.extended;
  
  import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_2;
  import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_1;
  
<span class="line-added">+ import java.nio.ByteOrder;</span>
<span class="line-added">+ </span>
  import org.graalvm.compiler.core.common.type.Stamp;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.NodeClass;
  import org.graalvm.compiler.graph.spi.Canonicalizable;
  import org.graalvm.compiler.graph.spi.CanonicalizerTool;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,10 ***</span>
<span class="line-new-header">--- 40,12 ---</span>
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.type.StampTool;
  import jdk.internal.vm.compiler.word.LocationIdentity;
  
  import jdk.vm.ci.meta.Assumptions;
<span class="line-added">+ import jdk.vm.ci.meta.ConstantReflectionProvider;</span>
<span class="line-added">+ import jdk.vm.ci.meta.JavaConstant;</span>
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.ResolvedJavaField;
  import jdk.vm.ci.meta.ResolvedJavaType;
  
  @NodeInfo(cycles = CYCLES_2, size = SIZE_1)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,14 ***</span>
                  long constantOffset = offset().asJavaConstant().asLong();
  
                  // Try to canonicalize to a field access.
                  ResolvedJavaType receiverType = StampTool.typeOrNull(object());
                  if (receiverType != null) {
<span class="line-modified">!                     ResolvedJavaField field = receiverType.findInstanceFieldWithOffset(constantOffset, accessKind());</span>
<span class="line-modified">!                     // No need for checking that the receiver is non-null. The field access includes</span>
<span class="line-modified">!                     // the null check and if a field is found, the offset is so small that this is</span>
<span class="line-modified">!                     // never a valid access of an arbitrary address.</span>
                      if (field != null &amp;&amp; field.getJavaKind() == this.accessKind()) {
                          assert !graph().isAfterFloatingReadPhase() : &quot;cannot add more precise memory location after floating read phase&quot;;
                          // Unsafe accesses never have volatile semantics.
                          // Memory barriers are placed around such an unsafe access at construction
                          // time if necessary, unlike AccessFieldNodes which encapsulate their
<span class="line-new-header">--- 97,18 ---</span>
                  long constantOffset = offset().asJavaConstant().asLong();
  
                  // Try to canonicalize to a field access.
                  ResolvedJavaType receiverType = StampTool.typeOrNull(object());
                  if (receiverType != null) {
<span class="line-modified">!                     ResolvedJavaField field = getStaticFieldUnsafeAccess(tool.getConstantReflection());</span>
<span class="line-modified">!                     if (field == null) {</span>
<span class="line-modified">!                         field = receiverType.findInstanceFieldWithOffset(constantOffset, accessKind());</span>
<span class="line-modified">!                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     // No need for checking that the receiver is non-null. The field access</span>
<span class="line-added">+                     // includes the null check and if a field is found, the offset is so small that</span>
<span class="line-added">+                     // this is never a valid access of an arbitrary address.</span>
                      if (field != null &amp;&amp; field.getJavaKind() == this.accessKind()) {
                          assert !graph().isAfterFloatingReadPhase() : &quot;cannot add more precise memory location after floating read phase&quot;;
                          // Unsafe accesses never have volatile semantics.
                          // Memory barriers are placed around such an unsafe access at construction
                          // time if necessary, unlike AccessFieldNodes which encapsulate their
</pre>
<hr />
<pre>
<span class="line-old-header">*** 126,6 ***</span>
<span class="line-new-header">--- 134,60 ---</span>
      }
  
      protected abstract ValueNode cloneAsFieldAccess(Assumptions assumptions, ResolvedJavaField field, boolean volatileAccess);
  
      protected abstract ValueNode cloneAsArrayAccess(ValueNode location, LocationIdentity identity);
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * In this method we check if the unsafe access is to a static field. This is the case when</span>
<span class="line-added">+      * {@code object} is a constant of type {@link Class} (static field&#39;s declaring class) and</span>
<span class="line-added">+      * {@code offset} is a constant (HotSpot-specific field offset from the declaring class).</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return the static field, if any, that this node is reading</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private ResolvedJavaField getStaticFieldUnsafeAccess(ConstantReflectionProvider constantReflection) {</span>
<span class="line-added">+         if (!object().isJavaConstant() || !offset().isJavaConstant() ||</span>
<span class="line-added">+                         object().isNullConstant() || offset().isNullConstant()) {</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         JavaConstant objectConstant = object().asJavaConstant();</span>
<span class="line-added">+         JavaConstant offsetConstant = offset().asJavaConstant();</span>
<span class="line-added">+         assert objectConstant != null &amp;&amp; offsetConstant != null : &quot;Verified by the check at the beginning.&quot;;</span>
<span class="line-added">+         ResolvedJavaType staticReceiverType = constantReflection.asJavaType(objectConstant);</span>
<span class="line-added">+         if (staticReceiverType == null) {</span>
<span class="line-added">+             // object is not of type Class so it is not a static field</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return findStaticFieldWithOffset(staticReceiverType, offsetConstant.asLong(), accessKind);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static ResolvedJavaField findStaticFieldWithOffset(ResolvedJavaType type, long offset, JavaKind expectedEntryKind) {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             ResolvedJavaField[] declaredFields = type.getStaticFields();</span>
<span class="line-added">+             return findFieldWithOffset(offset, expectedEntryKind, declaredFields);</span>
<span class="line-added">+         } catch (UnsupportedOperationException e) {</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * NOTE GR-18873: this is a copy-paste implementation derived from</span>
<span class="line-added">+      * {@code jdk.vm.ci.hotspot.HotSpotResolvedObjectTypeImpl#findStaticFieldWithOffset}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static ResolvedJavaField findFieldWithOffset(long offset, JavaKind expectedEntryKind, ResolvedJavaField[] declaredFields) {</span>
<span class="line-added">+         for (ResolvedJavaField field : declaredFields) {</span>
<span class="line-added">+             long resolvedFieldOffset = field.getOffset();</span>
<span class="line-added">+             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN &amp;&amp;</span>
<span class="line-added">+                             expectedEntryKind.isPrimitive() &amp;&amp;</span>
<span class="line-added">+                             !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;</span>
<span class="line-added">+                             field.getJavaKind().isPrimitive()) {</span>
<span class="line-added">+                 resolvedFieldOffset += field.getJavaKind().getByteCount() -</span>
<span class="line-added">+                                 Math.min(field.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (resolvedFieldOffset == offset) {</span>
<span class="line-added">+                 return field;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return null;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
  }
</pre>
<center><a href="SwitchNode.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="UnsafeMemoryStoreNode.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
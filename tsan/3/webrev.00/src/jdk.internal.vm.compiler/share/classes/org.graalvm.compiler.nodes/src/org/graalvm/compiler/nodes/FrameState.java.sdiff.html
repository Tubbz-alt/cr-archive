<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/FrameState.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FixedGuardNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphDecoder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/FrameState.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
286             virtualObjectMappings = new NodeInputList&lt;&gt;(this);
287         }
288         virtualObjectMappings.add(virtualObject);
289     }
290 
291     public int virtualObjectMappingCount() {
292         if (virtualObjectMappings == null) {
293             return 0;
294         }
295         return virtualObjectMappings.size();
296     }
297 
298     public EscapeObjectState virtualObjectMappingAt(int i) {
299         return virtualObjectMappings.get(i);
300     }
301 
302     public NodeInputList&lt;EscapeObjectState&gt; virtualObjectMappings() {
303         return virtualObjectMappings;
304     }
305 
<span class="line-removed">306     /**</span>
<span class="line-removed">307      * Gets a copy of this frame state.</span>
<span class="line-removed">308      */</span>
<span class="line-removed">309     public FrameState duplicate(int newBci) {</span>
<span class="line-removed">310         return graph().add(new FrameState(outerFrameState(), code, newBci, values, localsSize, stackSize, rethrowException, duringCall, monitorIds, virtualObjectMappings));</span>
<span class="line-removed">311     }</span>
<span class="line-removed">312 </span>
313     /**
314      * Gets a copy of this frame state.
315      */
316     public FrameState duplicate() {
<span class="line-modified">317         return duplicate(bci);</span>
318     }
319 
320     /**
321      * Duplicates a FrameState, along with a deep copy of all connected VirtualState (outer
322      * FrameStates, VirtualObjectStates, ...).
323      */
324     @Override
325     public FrameState duplicateWithVirtualState() {
326         FrameState newOuterFrameState = outerFrameState();
327         if (newOuterFrameState != null) {
328             newOuterFrameState = newOuterFrameState.duplicateWithVirtualState();
329         }
330         ArrayList&lt;EscapeObjectState&gt; newVirtualMappings = null;
331         if (virtualObjectMappings != null) {
332             newVirtualMappings = new ArrayList&lt;&gt;(virtualObjectMappings.size());
333             for (EscapeObjectState state : virtualObjectMappings) {
334                 newVirtualMappings.add(state.duplicateWithVirtualState());
335             }
336         }
337         return graph().add(new FrameState(newOuterFrameState, code, bci, values, localsSize, stackSize, rethrowException, duringCall, monitorIds, newVirtualMappings));
338     }
339 
340     /**
341      * Creates a copy of this frame state with one stack element of type {@code popKind} popped from
342      * the stack.
343      */
344     public FrameState duplicateModifiedDuringCall(int newBci, JavaKind popKind) {
345         return duplicateModified(graph(), newBci, rethrowException, true, popKind, null, null);
346     }
347 
348     public FrameState duplicateModifiedBeforeCall(int newBci, JavaKind popKind, JavaKind[] pushedSlotKinds, ValueNode[] pushedValues) {
349         return duplicateModified(graph(), newBci, rethrowException, false, popKind, pushedSlotKinds, pushedValues);
350     }
351 
<span class="line-removed">352     /**</span>
<span class="line-removed">353      * Creates a copy of this frame state with one stack element of type {@code popKind} popped from</span>
<span class="line-removed">354      * the stack and the values in {@code pushedValues} pushed on the stack. The</span>
<span class="line-removed">355      * {@code pushedValues} will be formatted correctly in slot encoding: a long or double will be</span>
<span class="line-removed">356      * followed by a null slot.</span>
<span class="line-removed">357      */</span>
<span class="line-removed">358     public FrameState duplicateModified(int newBci, boolean newRethrowException, JavaKind popKind, JavaKind[] pushedSlotKinds, ValueNode[] pushedValues) {</span>
<span class="line-removed">359         return duplicateModified(graph(), newBci, newRethrowException, duringCall, popKind, pushedSlotKinds, pushedValues);</span>
<span class="line-removed">360     }</span>
<span class="line-removed">361 </span>
<span class="line-removed">362     public FrameState duplicateModified(int newBci, boolean newRethrowException, boolean newDuringCall, JavaKind popKind, JavaKind[] pushedSlotKinds, ValueNode[] pushedValues) {</span>
<span class="line-removed">363         return duplicateModified(graph(), newBci, newRethrowException, newDuringCall, popKind, pushedSlotKinds, pushedValues);</span>
<span class="line-removed">364     }</span>
<span class="line-removed">365 </span>
366     /**
367      * Creates a copy of this frame state with the top of stack replaced with with
368      * {@code pushedValue} which must be of type {@code popKind}.
369      */
370     public FrameState duplicateModified(JavaKind popKind, JavaKind pushedSlotKind, ValueNode pushedValue) {
371         assert pushedValue != null &amp;&amp; pushedValue.getStackKind() == popKind;
372         return duplicateModified(graph(), bci, rethrowException, duringCall, popKind, new JavaKind[]{pushedSlotKind}, new ValueNode[]{pushedValue});
373     }
374 




375     /**
376      * Creates a copy of this frame state with one stack element of type popKind popped from the
377      * stack and the values in pushedValues pushed on the stack. The pushedValues will be formatted
378      * correctly in slot encoding: a long or double will be followed by a null slot. The bci will be
379      * changed to newBci.
380      */
381     public FrameState duplicateModified(StructuredGraph graph, int newBci, boolean newRethrowException, boolean newDuringCall, JavaKind popKind, JavaKind[] pushedSlotKinds, ValueNode[] pushedValues) {
382         ArrayList&lt;ValueNode&gt; copy;
383         if (newRethrowException &amp;&amp; !rethrowException &amp;&amp; popKind == JavaKind.Void) {
384             assert popKind == JavaKind.Void;
385             copy = new ArrayList&lt;&gt;(values.subList(0, localsSize));
386         } else {
387             copy = new ArrayList&lt;&gt;(values.subList(0, localsSize + stackSize));
388             if (popKind != JavaKind.Void) {
389                 if (stackAt(stackSize() - 1) == null) {
390                     copy.remove(copy.size() - 1);
391                 }
392                 ValueNode lastSlot = copy.get(copy.size() - 1);
393                 assert lastSlot.getStackKind() == popKind.getStackKind();
394                 copy.remove(copy.size() - 1);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
286             virtualObjectMappings = new NodeInputList&lt;&gt;(this);
287         }
288         virtualObjectMappings.add(virtualObject);
289     }
290 
291     public int virtualObjectMappingCount() {
292         if (virtualObjectMappings == null) {
293             return 0;
294         }
295         return virtualObjectMappings.size();
296     }
297 
298     public EscapeObjectState virtualObjectMappingAt(int i) {
299         return virtualObjectMappings.get(i);
300     }
301 
302     public NodeInputList&lt;EscapeObjectState&gt; virtualObjectMappings() {
303         return virtualObjectMappings;
304     }
305 







306     /**
307      * Gets a copy of this frame state.
308      */
309     public FrameState duplicate() {
<span class="line-modified">310         return graph().add(new FrameState(outerFrameState(), code, bci, values, localsSize, stackSize, rethrowException, duringCall, monitorIds, virtualObjectMappings));</span>
311     }
312 
313     /**
314      * Duplicates a FrameState, along with a deep copy of all connected VirtualState (outer
315      * FrameStates, VirtualObjectStates, ...).
316      */
317     @Override
318     public FrameState duplicateWithVirtualState() {
319         FrameState newOuterFrameState = outerFrameState();
320         if (newOuterFrameState != null) {
321             newOuterFrameState = newOuterFrameState.duplicateWithVirtualState();
322         }
323         ArrayList&lt;EscapeObjectState&gt; newVirtualMappings = null;
324         if (virtualObjectMappings != null) {
325             newVirtualMappings = new ArrayList&lt;&gt;(virtualObjectMappings.size());
326             for (EscapeObjectState state : virtualObjectMappings) {
327                 newVirtualMappings.add(state.duplicateWithVirtualState());
328             }
329         }
330         return graph().add(new FrameState(newOuterFrameState, code, bci, values, localsSize, stackSize, rethrowException, duringCall, monitorIds, newVirtualMappings));
331     }
332 
333     /**
334      * Creates a copy of this frame state with one stack element of type {@code popKind} popped from
335      * the stack.
336      */
337     public FrameState duplicateModifiedDuringCall(int newBci, JavaKind popKind) {
338         return duplicateModified(graph(), newBci, rethrowException, true, popKind, null, null);
339     }
340 
341     public FrameState duplicateModifiedBeforeCall(int newBci, JavaKind popKind, JavaKind[] pushedSlotKinds, ValueNode[] pushedValues) {
342         return duplicateModified(graph(), newBci, rethrowException, false, popKind, pushedSlotKinds, pushedValues);
343     }
344 














345     /**
346      * Creates a copy of this frame state with the top of stack replaced with with
347      * {@code pushedValue} which must be of type {@code popKind}.
348      */
349     public FrameState duplicateModified(JavaKind popKind, JavaKind pushedSlotKind, ValueNode pushedValue) {
350         assert pushedValue != null &amp;&amp; pushedValue.getStackKind() == popKind;
351         return duplicateModified(graph(), bci, rethrowException, duringCall, popKind, new JavaKind[]{pushedSlotKind}, new ValueNode[]{pushedValue});
352     }
353 
<span class="line-added">354     public FrameState duplicateRethrow(ValueNode exceptionObject) {</span>
<span class="line-added">355         return duplicateModified(graph(), bci, true, duringCall, JavaKind.Void, new JavaKind[]{JavaKind.Object}, new ValueNode[]{exceptionObject});</span>
<span class="line-added">356     }</span>
<span class="line-added">357 </span>
358     /**
359      * Creates a copy of this frame state with one stack element of type popKind popped from the
360      * stack and the values in pushedValues pushed on the stack. The pushedValues will be formatted
361      * correctly in slot encoding: a long or double will be followed by a null slot. The bci will be
362      * changed to newBci.
363      */
364     public FrameState duplicateModified(StructuredGraph graph, int newBci, boolean newRethrowException, boolean newDuringCall, JavaKind popKind, JavaKind[] pushedSlotKinds, ValueNode[] pushedValues) {
365         ArrayList&lt;ValueNode&gt; copy;
366         if (newRethrowException &amp;&amp; !rethrowException &amp;&amp; popKind == JavaKind.Void) {
367             assert popKind == JavaKind.Void;
368             copy = new ArrayList&lt;&gt;(values.subList(0, localsSize));
369         } else {
370             copy = new ArrayList&lt;&gt;(values.subList(0, localsSize + stackSize));
371             if (popKind != JavaKind.Void) {
372                 if (stackAt(stackSize() - 1) == null) {
373                     copy.remove(copy.size() - 1);
374                 }
375                 ValueNode lastSlot = copy.get(copy.size() - 1);
376                 assert lastSlot.getStackKind() == popKind.getStackKind();
377                 copy.remove(copy.size() - 1);
</pre>
</td>
</tr>
</table>
<center><a href="FixedGuardNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphDecoder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
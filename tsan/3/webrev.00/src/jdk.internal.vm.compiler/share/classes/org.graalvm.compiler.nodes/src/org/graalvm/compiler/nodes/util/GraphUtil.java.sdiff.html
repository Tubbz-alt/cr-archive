<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/util/GraphUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../type/StampTool.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../virtual/AllocatedObjectNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/util/GraphUtil.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  37 import jdk.internal.vm.compiler.collections.EconomicSet;
  38 import jdk.internal.vm.compiler.collections.Equivalence;
  39 import jdk.internal.vm.compiler.collections.MapCursor;
  40 import org.graalvm.compiler.bytecode.Bytecode;
  41 import org.graalvm.compiler.code.SourceStackTraceBailoutException;
  42 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
  43 import org.graalvm.compiler.core.common.type.ObjectStamp;
  44 import org.graalvm.compiler.debug.DebugContext;
  45 import org.graalvm.compiler.graph.Graph;
  46 import org.graalvm.compiler.graph.Node;
  47 import org.graalvm.compiler.graph.NodeBitMap;
  48 import org.graalvm.compiler.graph.NodeSourcePosition;
  49 import org.graalvm.compiler.graph.NodeStack;
  50 import org.graalvm.compiler.graph.Position;
  51 import org.graalvm.compiler.graph.iterators.NodeIterable;
  52 import org.graalvm.compiler.graph.spi.SimplifierTool;
  53 import org.graalvm.compiler.nodes.AbstractBeginNode;
  54 import org.graalvm.compiler.nodes.AbstractEndNode;
  55 import org.graalvm.compiler.nodes.AbstractMergeNode;
  56 import org.graalvm.compiler.nodes.ConstantNode;

  57 import org.graalvm.compiler.nodes.ControlSplitNode;
  58 import org.graalvm.compiler.nodes.FixedNode;
  59 import org.graalvm.compiler.nodes.FixedWithNextNode;
  60 import org.graalvm.compiler.nodes.FrameState;
  61 import org.graalvm.compiler.nodes.GuardNode;

  62 import org.graalvm.compiler.nodes.LoopBeginNode;
  63 import org.graalvm.compiler.nodes.LoopEndNode;
  64 import org.graalvm.compiler.nodes.LoopExitNode;
  65 import org.graalvm.compiler.nodes.NodeView;
  66 import org.graalvm.compiler.nodes.PhiNode;
  67 import org.graalvm.compiler.nodes.PiNode;
  68 import org.graalvm.compiler.nodes.ProxyNode;
  69 import org.graalvm.compiler.nodes.StateSplit;
  70 import org.graalvm.compiler.nodes.StructuredGraph;
  71 import org.graalvm.compiler.nodes.ValueNode;
  72 import org.graalvm.compiler.nodes.ValuePhiNode;
  73 import org.graalvm.compiler.nodes.ValueProxyNode;
  74 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
  75 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  76 import org.graalvm.compiler.nodes.java.MonitorIdNode;
  77 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
  78 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider.FindLengthMode;
  79 import org.graalvm.compiler.nodes.spi.LimitedValueProxy;
  80 import org.graalvm.compiler.nodes.spi.LoweringProvider;
  81 import org.graalvm.compiler.nodes.spi.ValueProxy;
</pre>
<hr />
<pre>
  88 import org.graalvm.compiler.options.OptionType;
  89 import org.graalvm.compiler.options.OptionValues;
  90 
  91 import jdk.vm.ci.code.BailoutException;
  92 import jdk.vm.ci.code.BytecodePosition;
  93 import jdk.vm.ci.meta.Assumptions;
  94 import jdk.vm.ci.meta.Constant;
  95 import jdk.vm.ci.meta.ConstantReflectionProvider;
  96 import jdk.vm.ci.meta.JavaKind;
  97 import jdk.vm.ci.meta.MetaAccessProvider;
  98 import jdk.vm.ci.meta.ResolvedJavaMethod;
  99 import jdk.vm.ci.meta.ResolvedJavaType;
 100 
 101 public class GraphUtil {
 102 
 103     public static class Options {
 104         @Option(help = &quot;Verify that there are no new unused nodes when performing killCFG&quot;, type = OptionType.Debug)//
 105         public static final OptionKey&lt;Boolean&gt; VerifyKillCFGUnusedNodes = new OptionKey&lt;&gt;(false);
 106     }
 107 


 108     private static void killCFGInner(FixedNode node) {
 109         EconomicSet&lt;Node&gt; markedNodes = EconomicSet.create();
 110         EconomicMap&lt;AbstractMergeNode, List&lt;AbstractEndNode&gt;&gt; unmarkedMerges = EconomicMap.create();
 111 
 112         // Detach this node from CFG
 113         node.replaceAtPredecessor(null);
 114 
 115         markFixedNodes(node, markedNodes, unmarkedMerges);
 116 
 117         fixSurvivingAffectedMerges(markedNodes, unmarkedMerges);
 118 
 119         DebugContext debug = node.getDebug();
 120         debug.dump(DebugContext.DETAILED_LEVEL, node.graph(), &quot;After fixing merges (killCFG %s)&quot;, node);
 121 
 122         // Mark non-fixed nodes
 123         markUsages(markedNodes);
 124 
 125         // Detach marked nodes from non-marked nodes
 126         for (Node marked : markedNodes) {
 127             for (Node input : marked.inputs()) {
</pre>
<hr />
<pre>
 226         }
 227         while (!workStack.isEmpty()) {
 228             Node marked = workStack.pop();
 229             for (Node usage : marked.usages()) {
 230                 if (!markedNodes.contains(usage)) {
 231                     workStack.push(usage);
 232                     markedNodes.add(usage);
 233                 }
 234             }
 235         }
 236     }
 237 
 238     @SuppressWarnings(&quot;try&quot;)
 239     public static void killCFG(FixedNode node) {
 240         DebugContext debug = node.getDebug();
 241         try (DebugContext.Scope scope = debug.scope(&quot;KillCFG&quot;, node)) {
 242             EconomicSet&lt;Node&gt; unusedNodes = null;
 243             EconomicSet&lt;Node&gt; unsafeNodes = null;
 244             Graph.NodeEventScope nodeEventScope = null;
 245             OptionValues options = node.getOptions();
<span class="line-modified"> 246             if (Graph.Options.VerifyGraalGraphEdges.getValue(options)) {</span>


 247                 unsafeNodes = collectUnsafeNodes(node.graph());
 248             }
<span class="line-modified"> 249             if (GraphUtil.Options.VerifyKillCFGUnusedNodes.getValue(options)) {</span>
 250                 EconomicSet&lt;Node&gt; collectedUnusedNodes = unusedNodes = EconomicSet.create(Equivalence.IDENTITY);
 251                 nodeEventScope = node.graph().trackNodeEvents(new Graph.NodeEventListener() {
 252                     @Override
 253                     public void changed(Graph.NodeEvent e, Node n) {
 254                         if (e == Graph.NodeEvent.ZERO_USAGES &amp;&amp; isFloatingNode(n) &amp;&amp; !(n instanceof GuardNode)) {
 255                             collectedUnusedNodes.add(n);
 256                         }
 257                     }
 258                 });
 259             }
 260             debug.dump(DebugContext.VERY_DETAILED_LEVEL, node.graph(), &quot;Before killCFG %s&quot;, node);
 261             killCFGInner(node);
 262             debug.dump(DebugContext.VERY_DETAILED_LEVEL, node.graph(), &quot;After killCFG %s&quot;, node);
<span class="line-modified"> 263             if (Graph.Options.VerifyGraalGraphEdges.getValue(options)) {</span>
 264                 EconomicSet&lt;Node&gt; newUnsafeNodes = collectUnsafeNodes(node.graph());
 265                 newUnsafeNodes.removeAll(unsafeNodes);
 266                 assert newUnsafeNodes.isEmpty() : &quot;New unsafe nodes: &quot; + newUnsafeNodes;
 267             }
<span class="line-modified"> 268             if (GraphUtil.Options.VerifyKillCFGUnusedNodes.getValue(options)) {</span>
 269                 nodeEventScope.close();
 270                 Iterator&lt;Node&gt; iterator = unusedNodes.iterator();
 271                 while (iterator.hasNext()) {
 272                     Node curNode = iterator.next();
 273                     if (curNode.isDeleted()) {
 274                         iterator.remove();
 275                     }
 276                 }
 277                 assert unusedNodes.isEmpty() : &quot;New unused nodes: &quot; + unusedNodes;
 278             }
 279         } catch (Throwable t) {
 280             throw debug.handle(t);
 281         }
 282     }
 283 
 284     /**
 285      * Collects all node in the graph which have non-optional inputs that are null.
 286      */
 287     private static EconomicSet&lt;Node&gt; collectUnsafeNodes(Graph graph) {
 288         EconomicSet&lt;Node&gt; unsafeNodes = EconomicSet.create(Equivalence.IDENTITY);
</pre>
<hr />
<pre>
 723             ValueNode length = arrayLength(input, mode, constantReflection);
 724             if (length == null) {
 725                 return null;
 726             }
 727             assert length.stamp(NodeView.DEFAULT).getStackKind() == JavaKind.Int;
 728 
 729             if (i == 0) {
 730                 assert singleLength == null;
 731                 singleLength = length;
 732             } else if (singleLength == length) {
 733                 /* Nothing to do, still having a single length. */
 734             } else {
 735                 return null;
 736             }
 737         }
 738         return singleLength;
 739     }
 740 
 741     /**
 742      * Tries to find an original value of the given node by traversing through proxies and
<span class="line-modified"> 743      * unambiguous phis. Note that this method will perform an exhaustive search through phis. It is</span>
<span class="line-removed"> 744      * intended to be used during graph building, when phi nodes aren&#39;t yet canonicalized.</span>
 745      *
<span class="line-modified"> 746      * @param value The node whose original value should be determined.</span>
<span class="line-modified"> 747      * @return The original value (which might be the input value itself).</span>




 748      */
<span class="line-modified"> 749     public static ValueNode originalValue(ValueNode value) {</span>
<span class="line-modified"> 750         ValueNode result = originalValueSimple(value);</span>
 751         assert result != null;
 752         return result;
 753     }
 754 
<span class="line-modified"> 755     private static ValueNode originalValueSimple(ValueNode value) {</span>
 756         /* The very simple case: look through proxies. */
 757         ValueNode cur = originalValueForProxy(value);
 758 
 759         while (cur instanceof PhiNode) {
 760             /*
 761              * We found a phi function. Check if we can analyze it without allocating temporary data
 762              * structures.
 763              */
 764             PhiNode phi = (PhiNode) cur;
 765 




 766             ValueNode phiSingleValue = null;
 767             int count = phi.valueCount();
 768             for (int i = 0; i &lt; count; ++i) {
 769                 ValueNode phiCurValue = originalValueForProxy(phi.valueAt(i));
 770                 if (phiCurValue == phi) {
 771                     /* Simple cycle, we can ignore the input value. */
 772                 } else if (phiSingleValue == null) {
 773                     /* The first input. */
 774                     phiSingleValue = phiCurValue;
 775                 } else if (phiSingleValue != phiCurValue) {
 776                     /* Another input that is different from the first input. */
 777 
 778                     if (phiSingleValue instanceof PhiNode || phiCurValue instanceof PhiNode) {
 779                         /*
 780                          * We have two different input values for the phi function, and at least one
 781                          * of the inputs is another phi function. We need to do a complicated
 782                          * exhaustive check.
 783                          */
<span class="line-modified"> 784                         return originalValueForComplicatedPhi(phi, new NodeBitMap(value.graph()));</span>
 785                     } else {
 786                         /*
 787                          * We have two different input values for the phi function, but none of them
 788                          * is another phi function. This phi function cannot be reduce any further,
 789                          * so the phi function is the original value.
 790                          */
 791                         return phi;
 792                     }
 793                 }
 794             }
 795 
 796             /*
 797              * Successfully reduced the phi function to a single input value. The single input value
 798              * can itself be a phi function again, so we might take another loop iteration.
 799              */
 800             assert phiSingleValue != null;
 801             cur = phiSingleValue;
 802         }
 803 
 804         /* We reached a &quot;normal&quot; node, which is the original value. */
 805         assert !(cur instanceof LimitedValueProxy) &amp;&amp; !(cur instanceof PhiNode);
 806         return cur;
 807     }
 808 
 809     private static ValueNode originalValueForProxy(ValueNode value) {
 810         ValueNode cur = value;
 811         while (cur instanceof LimitedValueProxy) {
 812             cur = ((LimitedValueProxy) cur).getOriginalNode();
 813         }
 814         return cur;
 815     }
 816 
 817     /**
 818      * Handling for complicated nestings of phi functions. We need to reduce phi functions
 819      * recursively, and need a temporary map of visited nodes to avoid endless recursion of cycles.




 820      */
<span class="line-modified"> 821     private static ValueNode originalValueForComplicatedPhi(PhiNode phi, NodeBitMap visited) {</span>
 822         if (visited.isMarked(phi)) {
 823             /*
 824              * Found a phi function that was already seen. Either a cycle, or just a second phi
 825              * input to a path we have already processed.
 826              */
 827             return null;
 828         }
 829         visited.mark(phi);
 830 
 831         ValueNode phiSingleValue = null;
 832         int count = phi.valueCount();
 833         for (int i = 0; i &lt; count; ++i) {
 834             ValueNode phiCurValue = originalValueForProxy(phi.valueAt(i));
 835             if (phiCurValue instanceof PhiNode) {
 836                 /* Recursively process a phi function input. */
<span class="line-modified"> 837                 phiCurValue = originalValueForComplicatedPhi((PhiNode) phiCurValue, visited);</span>









 838             }
 839 
 840             if (phiCurValue == null) {
 841                 /* Cycle to a phi function that was already seen. We can ignore this input. */
 842             } else if (phiSingleValue == null) {
 843                 /* The first input. */
 844                 phiSingleValue = phiCurValue;
 845             } else if (phiCurValue != phiSingleValue) {
 846                 /*
 847                  * Another input that is different from the first input. Since we already
 848                  * recursively looked through other phi functions, we now know that this phi
 849                  * function cannot be reduce any further, so the phi function is the original value.
 850                  */
 851                 return phi;
 852             }
 853         }
 854         return phiSingleValue;
 855     }
 856 
 857     public static boolean tryKillUnused(Node node) {
</pre>
<hr />
<pre>
1071                 return;
1072             }
1073             for (int i = 0; i &lt; readLength; i++) {
1074                 LoadIndexedNode load = new LoadIndexedNode(null, sourceAlias, ConstantNode.forInt(i + fromInt, graph), null, elementKind);
1075                 tool.addNode(load);
1076                 newEntryState[i] = load;
1077             }
1078         }
1079         if (readLength &lt; newLengthInt) {
1080             /* Pad the copy with the default value of its elment kind. */
1081             ValueNode defaultValue = ConstantNode.defaultForKind(elementKind, graph);
1082             for (int i = readLength; i &lt; newLengthInt; i++) {
1083                 newEntryState[i] = defaultValue;
1084             }
1085         }
1086         /* Perform the replacement. */
1087         VirtualArrayNode newVirtualArray = virtualArrayProvider.apply(newComponentType, newLengthInt);
1088         tool.createVirtualObject(newVirtualArray, newEntryState, Collections.&lt;MonitorIdNode&gt; emptyList(), false);
1089         tool.replaceWithVirtual(newVirtualArray);
1090     }



















































1091 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  37 import jdk.internal.vm.compiler.collections.EconomicSet;
  38 import jdk.internal.vm.compiler.collections.Equivalence;
  39 import jdk.internal.vm.compiler.collections.MapCursor;
  40 import org.graalvm.compiler.bytecode.Bytecode;
  41 import org.graalvm.compiler.code.SourceStackTraceBailoutException;
  42 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
  43 import org.graalvm.compiler.core.common.type.ObjectStamp;
  44 import org.graalvm.compiler.debug.DebugContext;
  45 import org.graalvm.compiler.graph.Graph;
  46 import org.graalvm.compiler.graph.Node;
  47 import org.graalvm.compiler.graph.NodeBitMap;
  48 import org.graalvm.compiler.graph.NodeSourcePosition;
  49 import org.graalvm.compiler.graph.NodeStack;
  50 import org.graalvm.compiler.graph.Position;
  51 import org.graalvm.compiler.graph.iterators.NodeIterable;
  52 import org.graalvm.compiler.graph.spi.SimplifierTool;
  53 import org.graalvm.compiler.nodes.AbstractBeginNode;
  54 import org.graalvm.compiler.nodes.AbstractEndNode;
  55 import org.graalvm.compiler.nodes.AbstractMergeNode;
  56 import org.graalvm.compiler.nodes.ConstantNode;
<span class="line-added">  57 import org.graalvm.compiler.nodes.ControlSinkNode;</span>
  58 import org.graalvm.compiler.nodes.ControlSplitNode;
  59 import org.graalvm.compiler.nodes.FixedNode;
  60 import org.graalvm.compiler.nodes.FixedWithNextNode;
  61 import org.graalvm.compiler.nodes.FrameState;
  62 import org.graalvm.compiler.nodes.GuardNode;
<span class="line-added">  63 import org.graalvm.compiler.nodes.IfNode;</span>
  64 import org.graalvm.compiler.nodes.LoopBeginNode;
  65 import org.graalvm.compiler.nodes.LoopEndNode;
  66 import org.graalvm.compiler.nodes.LoopExitNode;
  67 import org.graalvm.compiler.nodes.NodeView;
  68 import org.graalvm.compiler.nodes.PhiNode;
  69 import org.graalvm.compiler.nodes.PiNode;
  70 import org.graalvm.compiler.nodes.ProxyNode;
  71 import org.graalvm.compiler.nodes.StateSplit;
  72 import org.graalvm.compiler.nodes.StructuredGraph;
  73 import org.graalvm.compiler.nodes.ValueNode;
  74 import org.graalvm.compiler.nodes.ValuePhiNode;
  75 import org.graalvm.compiler.nodes.ValueProxyNode;
  76 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
  77 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  78 import org.graalvm.compiler.nodes.java.MonitorIdNode;
  79 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
  80 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider.FindLengthMode;
  81 import org.graalvm.compiler.nodes.spi.LimitedValueProxy;
  82 import org.graalvm.compiler.nodes.spi.LoweringProvider;
  83 import org.graalvm.compiler.nodes.spi.ValueProxy;
</pre>
<hr />
<pre>
  90 import org.graalvm.compiler.options.OptionType;
  91 import org.graalvm.compiler.options.OptionValues;
  92 
  93 import jdk.vm.ci.code.BailoutException;
  94 import jdk.vm.ci.code.BytecodePosition;
  95 import jdk.vm.ci.meta.Assumptions;
  96 import jdk.vm.ci.meta.Constant;
  97 import jdk.vm.ci.meta.ConstantReflectionProvider;
  98 import jdk.vm.ci.meta.JavaKind;
  99 import jdk.vm.ci.meta.MetaAccessProvider;
 100 import jdk.vm.ci.meta.ResolvedJavaMethod;
 101 import jdk.vm.ci.meta.ResolvedJavaType;
 102 
 103 public class GraphUtil {
 104 
 105     public static class Options {
 106         @Option(help = &quot;Verify that there are no new unused nodes when performing killCFG&quot;, type = OptionType.Debug)//
 107         public static final OptionKey&lt;Boolean&gt; VerifyKillCFGUnusedNodes = new OptionKey&lt;&gt;(false);
 108     }
 109 
<span class="line-added"> 110     public static final int MAX_FRAMESTATE_SEARCH_DEPTH = 4;</span>
<span class="line-added"> 111 </span>
 112     private static void killCFGInner(FixedNode node) {
 113         EconomicSet&lt;Node&gt; markedNodes = EconomicSet.create();
 114         EconomicMap&lt;AbstractMergeNode, List&lt;AbstractEndNode&gt;&gt; unmarkedMerges = EconomicMap.create();
 115 
 116         // Detach this node from CFG
 117         node.replaceAtPredecessor(null);
 118 
 119         markFixedNodes(node, markedNodes, unmarkedMerges);
 120 
 121         fixSurvivingAffectedMerges(markedNodes, unmarkedMerges);
 122 
 123         DebugContext debug = node.getDebug();
 124         debug.dump(DebugContext.DETAILED_LEVEL, node.graph(), &quot;After fixing merges (killCFG %s)&quot;, node);
 125 
 126         // Mark non-fixed nodes
 127         markUsages(markedNodes);
 128 
 129         // Detach marked nodes from non-marked nodes
 130         for (Node marked : markedNodes) {
 131             for (Node input : marked.inputs()) {
</pre>
<hr />
<pre>
 230         }
 231         while (!workStack.isEmpty()) {
 232             Node marked = workStack.pop();
 233             for (Node usage : marked.usages()) {
 234                 if (!markedNodes.contains(usage)) {
 235                     workStack.push(usage);
 236                     markedNodes.add(usage);
 237                 }
 238             }
 239         }
 240     }
 241 
 242     @SuppressWarnings(&quot;try&quot;)
 243     public static void killCFG(FixedNode node) {
 244         DebugContext debug = node.getDebug();
 245         try (DebugContext.Scope scope = debug.scope(&quot;KillCFG&quot;, node)) {
 246             EconomicSet&lt;Node&gt; unusedNodes = null;
 247             EconomicSet&lt;Node&gt; unsafeNodes = null;
 248             Graph.NodeEventScope nodeEventScope = null;
 249             OptionValues options = node.getOptions();
<span class="line-modified"> 250             boolean verifyGraalGraphEdges = Graph.Options.VerifyGraalGraphEdges.getValue(options);</span>
<span class="line-added"> 251             boolean verifyKillCFGUnusedNodes = GraphUtil.Options.VerifyKillCFGUnusedNodes.getValue(options);</span>
<span class="line-added"> 252             if (verifyGraalGraphEdges) {</span>
 253                 unsafeNodes = collectUnsafeNodes(node.graph());
 254             }
<span class="line-modified"> 255             if (verifyKillCFGUnusedNodes) {</span>
 256                 EconomicSet&lt;Node&gt; collectedUnusedNodes = unusedNodes = EconomicSet.create(Equivalence.IDENTITY);
 257                 nodeEventScope = node.graph().trackNodeEvents(new Graph.NodeEventListener() {
 258                     @Override
 259                     public void changed(Graph.NodeEvent e, Node n) {
 260                         if (e == Graph.NodeEvent.ZERO_USAGES &amp;&amp; isFloatingNode(n) &amp;&amp; !(n instanceof GuardNode)) {
 261                             collectedUnusedNodes.add(n);
 262                         }
 263                     }
 264                 });
 265             }
 266             debug.dump(DebugContext.VERY_DETAILED_LEVEL, node.graph(), &quot;Before killCFG %s&quot;, node);
 267             killCFGInner(node);
 268             debug.dump(DebugContext.VERY_DETAILED_LEVEL, node.graph(), &quot;After killCFG %s&quot;, node);
<span class="line-modified"> 269             if (verifyGraalGraphEdges) {</span>
 270                 EconomicSet&lt;Node&gt; newUnsafeNodes = collectUnsafeNodes(node.graph());
 271                 newUnsafeNodes.removeAll(unsafeNodes);
 272                 assert newUnsafeNodes.isEmpty() : &quot;New unsafe nodes: &quot; + newUnsafeNodes;
 273             }
<span class="line-modified"> 274             if (verifyKillCFGUnusedNodes) {</span>
 275                 nodeEventScope.close();
 276                 Iterator&lt;Node&gt; iterator = unusedNodes.iterator();
 277                 while (iterator.hasNext()) {
 278                     Node curNode = iterator.next();
 279                     if (curNode.isDeleted()) {
 280                         iterator.remove();
 281                     }
 282                 }
 283                 assert unusedNodes.isEmpty() : &quot;New unused nodes: &quot; + unusedNodes;
 284             }
 285         } catch (Throwable t) {
 286             throw debug.handle(t);
 287         }
 288     }
 289 
 290     /**
 291      * Collects all node in the graph which have non-optional inputs that are null.
 292      */
 293     private static EconomicSet&lt;Node&gt; collectUnsafeNodes(Graph graph) {
 294         EconomicSet&lt;Node&gt; unsafeNodes = EconomicSet.create(Equivalence.IDENTITY);
</pre>
<hr />
<pre>
 729             ValueNode length = arrayLength(input, mode, constantReflection);
 730             if (length == null) {
 731                 return null;
 732             }
 733             assert length.stamp(NodeView.DEFAULT).getStackKind() == JavaKind.Int;
 734 
 735             if (i == 0) {
 736                 assert singleLength == null;
 737                 singleLength = length;
 738             } else if (singleLength == length) {
 739                 /* Nothing to do, still having a single length. */
 740             } else {
 741                 return null;
 742             }
 743         }
 744         return singleLength;
 745     }
 746 
 747     /**
 748      * Tries to find an original value of the given node by traversing through proxies and
<span class="line-modified"> 749      * unambiguous phis. Note that this method will perform an exhaustive search through phis.</span>

 750      *
<span class="line-modified"> 751      * @param value the node whose original value should be determined</span>
<span class="line-modified"> 752      * @param abortOnLoopPhi specifies if the traversal through phis should stop and return</span>
<span class="line-added"> 753      *            {@code value} if it hits a {@linkplain PhiNode#isLoopPhi loop phi}. This argument</span>
<span class="line-added"> 754      *            must be {@code true} if used during graph building as loop phi nodes may not yet</span>
<span class="line-added"> 755      *            have all their inputs computed.</span>
<span class="line-added"> 756      * @return the original value (which might be {@code value} itself)</span>
 757      */
<span class="line-modified"> 758     public static ValueNode originalValue(ValueNode value, boolean abortOnLoopPhi) {</span>
<span class="line-modified"> 759         ValueNode result = originalValueSimple(value, abortOnLoopPhi);</span>
 760         assert result != null;
 761         return result;
 762     }
 763 
<span class="line-modified"> 764     private static ValueNode originalValueSimple(ValueNode value, boolean abortOnLoopPhi) {</span>
 765         /* The very simple case: look through proxies. */
 766         ValueNode cur = originalValueForProxy(value);
 767 
 768         while (cur instanceof PhiNode) {
 769             /*
 770              * We found a phi function. Check if we can analyze it without allocating temporary data
 771              * structures.
 772              */
 773             PhiNode phi = (PhiNode) cur;
 774 
<span class="line-added"> 775             if (abortOnLoopPhi &amp;&amp; phi.isLoopPhi()) {</span>
<span class="line-added"> 776                 return value;</span>
<span class="line-added"> 777             }</span>
<span class="line-added"> 778 </span>
 779             ValueNode phiSingleValue = null;
 780             int count = phi.valueCount();
 781             for (int i = 0; i &lt; count; ++i) {
 782                 ValueNode phiCurValue = originalValueForProxy(phi.valueAt(i));
 783                 if (phiCurValue == phi) {
 784                     /* Simple cycle, we can ignore the input value. */
 785                 } else if (phiSingleValue == null) {
 786                     /* The first input. */
 787                     phiSingleValue = phiCurValue;
 788                 } else if (phiSingleValue != phiCurValue) {
 789                     /* Another input that is different from the first input. */
 790 
 791                     if (phiSingleValue instanceof PhiNode || phiCurValue instanceof PhiNode) {
 792                         /*
 793                          * We have two different input values for the phi function, and at least one
 794                          * of the inputs is another phi function. We need to do a complicated
 795                          * exhaustive check.
 796                          */
<span class="line-modified"> 797                         return originalValueForComplicatedPhi(value, phi, new NodeBitMap(value.graph()), abortOnLoopPhi);</span>
 798                     } else {
 799                         /*
 800                          * We have two different input values for the phi function, but none of them
 801                          * is another phi function. This phi function cannot be reduce any further,
 802                          * so the phi function is the original value.
 803                          */
 804                         return phi;
 805                     }
 806                 }
 807             }
 808 
 809             /*
 810              * Successfully reduced the phi function to a single input value. The single input value
 811              * can itself be a phi function again, so we might take another loop iteration.
 812              */
 813             assert phiSingleValue != null;
 814             cur = phiSingleValue;
 815         }
 816 
 817         /* We reached a &quot;normal&quot; node, which is the original value. */
 818         assert !(cur instanceof LimitedValueProxy) &amp;&amp; !(cur instanceof PhiNode);
 819         return cur;
 820     }
 821 
 822     private static ValueNode originalValueForProxy(ValueNode value) {
 823         ValueNode cur = value;
 824         while (cur instanceof LimitedValueProxy) {
 825             cur = ((LimitedValueProxy) cur).getOriginalNode();
 826         }
 827         return cur;
 828     }
 829 
 830     /**
 831      * Handling for complicated nestings of phi functions. We need to reduce phi functions
 832      * recursively, and need a temporary map of visited nodes to avoid endless recursion of cycles.
<span class="line-added"> 833      *</span>
<span class="line-added"> 834      * @param value the node whose original value is being determined</span>
<span class="line-added"> 835      * @param abortOnLoopPhi specifies if the traversal through phis should stop and return</span>
<span class="line-added"> 836      *            {@code value} if it hits a {@linkplain PhiNode#isLoopPhi loop phi}</span>
 837      */
<span class="line-modified"> 838     private static ValueNode originalValueForComplicatedPhi(ValueNode value, PhiNode phi, NodeBitMap visited, boolean abortOnLoopPhi) {</span>
 839         if (visited.isMarked(phi)) {
 840             /*
 841              * Found a phi function that was already seen. Either a cycle, or just a second phi
 842              * input to a path we have already processed.
 843              */
 844             return null;
 845         }
 846         visited.mark(phi);
 847 
 848         ValueNode phiSingleValue = null;
 849         int count = phi.valueCount();
 850         for (int i = 0; i &lt; count; ++i) {
 851             ValueNode phiCurValue = originalValueForProxy(phi.valueAt(i));
 852             if (phiCurValue instanceof PhiNode) {
 853                 /* Recursively process a phi function input. */
<span class="line-modified"> 854                 PhiNode curPhi = (PhiNode) phiCurValue;</span>
<span class="line-added"> 855                 if (abortOnLoopPhi &amp;&amp; curPhi.isLoopPhi()) {</span>
<span class="line-added"> 856                     return value;</span>
<span class="line-added"> 857                 }</span>
<span class="line-added"> 858                 phiCurValue = originalValueForComplicatedPhi(value, curPhi, visited, abortOnLoopPhi);</span>
<span class="line-added"> 859                 if (phiCurValue == value) {</span>
<span class="line-added"> 860                     // Hit a loop phi</span>
<span class="line-added"> 861                     assert abortOnLoopPhi;</span>
<span class="line-added"> 862                     return value;</span>
<span class="line-added"> 863                 }</span>
 864             }
 865 
 866             if (phiCurValue == null) {
 867                 /* Cycle to a phi function that was already seen. We can ignore this input. */
 868             } else if (phiSingleValue == null) {
 869                 /* The first input. */
 870                 phiSingleValue = phiCurValue;
 871             } else if (phiCurValue != phiSingleValue) {
 872                 /*
 873                  * Another input that is different from the first input. Since we already
 874                  * recursively looked through other phi functions, we now know that this phi
 875                  * function cannot be reduce any further, so the phi function is the original value.
 876                  */
 877                 return phi;
 878             }
 879         }
 880         return phiSingleValue;
 881     }
 882 
 883     public static boolean tryKillUnused(Node node) {
</pre>
<hr />
<pre>
1097                 return;
1098             }
1099             for (int i = 0; i &lt; readLength; i++) {
1100                 LoadIndexedNode load = new LoadIndexedNode(null, sourceAlias, ConstantNode.forInt(i + fromInt, graph), null, elementKind);
1101                 tool.addNode(load);
1102                 newEntryState[i] = load;
1103             }
1104         }
1105         if (readLength &lt; newLengthInt) {
1106             /* Pad the copy with the default value of its elment kind. */
1107             ValueNode defaultValue = ConstantNode.defaultForKind(elementKind, graph);
1108             for (int i = readLength; i &lt; newLengthInt; i++) {
1109                 newEntryState[i] = defaultValue;
1110             }
1111         }
1112         /* Perform the replacement. */
1113         VirtualArrayNode newVirtualArray = virtualArrayProvider.apply(newComponentType, newLengthInt);
1114         tool.createVirtualObject(newVirtualArray, newEntryState, Collections.&lt;MonitorIdNode&gt; emptyList(), false);
1115         tool.replaceWithVirtual(newVirtualArray);
1116     }
<span class="line-added">1117 </span>
<span class="line-added">1118     /**</span>
<span class="line-added">1119      * Snippet lowerings may produce patterns without a frame state on the merge. We need to take</span>
<span class="line-added">1120      * extra care when optimizing these patterns.</span>
<span class="line-added">1121      */</span>
<span class="line-added">1122     public static boolean checkFrameState(FixedNode start, int maxDepth) {</span>
<span class="line-added">1123         if (maxDepth == 0) {</span>
<span class="line-added">1124             return false;</span>
<span class="line-added">1125         }</span>
<span class="line-added">1126         FixedNode node = start;</span>
<span class="line-added">1127         while (true) {</span>
<span class="line-added">1128             if (node instanceof AbstractMergeNode) {</span>
<span class="line-added">1129                 AbstractMergeNode mergeNode = (AbstractMergeNode) node;</span>
<span class="line-added">1130                 if (mergeNode.stateAfter() == null) {</span>
<span class="line-added">1131                     return false;</span>
<span class="line-added">1132                 } else {</span>
<span class="line-added">1133                     return true;</span>
<span class="line-added">1134                 }</span>
<span class="line-added">1135             } else if (node instanceof StateSplit) {</span>
<span class="line-added">1136                 StateSplit stateSplitNode = (StateSplit) node;</span>
<span class="line-added">1137                 if (stateSplitNode.stateAfter() != null) {</span>
<span class="line-added">1138                     return true;</span>
<span class="line-added">1139                 }</span>
<span class="line-added">1140             }</span>
<span class="line-added">1141 </span>
<span class="line-added">1142             if (node instanceof ControlSplitNode) {</span>
<span class="line-added">1143                 ControlSplitNode controlSplitNode = (ControlSplitNode) node;</span>
<span class="line-added">1144                 for (Node succ : controlSplitNode.cfgSuccessors()) {</span>
<span class="line-added">1145                     if (checkFrameState((FixedNode) succ, maxDepth - 1)) {</span>
<span class="line-added">1146                         return true;</span>
<span class="line-added">1147                     }</span>
<span class="line-added">1148                 }</span>
<span class="line-added">1149                 return false;</span>
<span class="line-added">1150             } else if (node instanceof FixedWithNextNode) {</span>
<span class="line-added">1151                 FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) node;</span>
<span class="line-added">1152                 node = fixedWithNextNode.next();</span>
<span class="line-added">1153             } else if (node instanceof AbstractEndNode) {</span>
<span class="line-added">1154                 AbstractEndNode endNode = (AbstractEndNode) node;</span>
<span class="line-added">1155                 node = endNode.merge();</span>
<span class="line-added">1156             } else if (node instanceof ControlSinkNode) {</span>
<span class="line-added">1157                 return true;</span>
<span class="line-added">1158             } else {</span>
<span class="line-added">1159                 assert false : &quot;unexpected node&quot;;</span>
<span class="line-added">1160                 return false;</span>
<span class="line-added">1161             }</span>
<span class="line-added">1162         }</span>
<span class="line-added">1163     }</span>
<span class="line-added">1164 </span>
<span class="line-added">1165     public static boolean mayRemoveSplit(IfNode ifNode) {</span>
<span class="line-added">1166         return GraphUtil.checkFrameState(ifNode.trueSuccessor(), MAX_FRAMESTATE_SEARCH_DEPTH) &amp;&amp; GraphUtil.checkFrameState(ifNode.falseSuccessor(), MAX_FRAMESTATE_SEARCH_DEPTH);</span>
<span class="line-added">1167     }</span>
1168 }
</pre>
</td>
</tr>
</table>
<center><a href="../type/StampTool.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../virtual/AllocatedObjectNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/IntegerSwitchNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.extended;
 26 
 27 import java.util.ArrayList;
 28 import java.util.Arrays;
 29 import java.util.Comparator;
 30 import java.util.HashMap;
 31 import java.util.List;
 32 import java.util.Map;
 33 
 34 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 35 import org.graalvm.compiler.core.common.type.IntegerStamp;
 36 import org.graalvm.compiler.core.common.type.PrimitiveStamp;
 37 import org.graalvm.compiler.core.common.type.Stamp;
 38 import org.graalvm.compiler.core.common.type.StampFactory;
 39 import org.graalvm.compiler.graph.NodeClass;
 40 import org.graalvm.compiler.graph.spi.Simplifiable;
 41 import org.graalvm.compiler.graph.spi.SimplifierTool;
 42 import org.graalvm.compiler.nodeinfo.NodeInfo;
 43 import org.graalvm.compiler.nodes.AbstractBeginNode;
 44 import org.graalvm.compiler.nodes.ConstantNode;
 45 import org.graalvm.compiler.nodes.FixedGuardNode;
 46 import org.graalvm.compiler.nodes.FixedWithNextNode;
 47 import org.graalvm.compiler.nodes.LogicNode;
 48 import org.graalvm.compiler.nodes.NodeView;
 49 import org.graalvm.compiler.nodes.ValueNode;
 50 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
 51 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 52 import org.graalvm.compiler.nodes.spi.LIRLowerable;
 53 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
 54 import org.graalvm.compiler.nodes.util.GraphUtil;
 55 
 56 import jdk.vm.ci.meta.DeoptimizationAction;
 57 import jdk.vm.ci.meta.DeoptimizationReason;
 58 import jdk.vm.ci.meta.JavaConstant;
 59 import jdk.vm.ci.meta.JavaKind;
 60 
 61 /**
 62  * The {@code IntegerSwitchNode} represents a switch on integer keys, with a sorted array of key
 63  * values. The actual implementation of the switch will be decided by the backend.
 64  */
 65 @NodeInfo
 66 public final class IntegerSwitchNode extends SwitchNode implements LIRLowerable, Simplifiable {
 67     public static final NodeClass&lt;IntegerSwitchNode&gt; TYPE = NodeClass.create(IntegerSwitchNode.class);
 68 
 69     protected final int[] keys;
 70 
 71     public IntegerSwitchNode(ValueNode value, AbstractBeginNode[] successors, int[] keys, double[] keyProbabilities, int[] keySuccessors) {
 72         super(TYPE, value, successors, keySuccessors, keyProbabilities);
 73         assert keySuccessors.length == keys.length + 1;
 74         assert keySuccessors.length == keyProbabilities.length;
 75         this.keys = keys;
 76         assert value.stamp(NodeView.DEFAULT) instanceof PrimitiveStamp &amp;&amp; value.stamp(NodeView.DEFAULT).getStackKind().isNumericInteger();
 77         assert assertSorted();
 78     }
 79 
 80     private boolean assertSorted() {
 81         for (int i = 1; i &lt; keys.length; i++) {
 82             assert keys[i - 1] &lt; keys[i];
 83         }
 84         return true;
 85     }
 86 
 87     public IntegerSwitchNode(ValueNode value, int successorCount, int[] keys, double[] keyProbabilities, int[] keySuccessors) {
 88         this(value, new AbstractBeginNode[successorCount], keys, keyProbabilities, keySuccessors);
 89     }
 90 
 91     @Override
 92     public boolean isSorted() {
 93         return true;
 94     }
 95 
 96     /**
 97      * Gets the key at the specified index.
 98      *
 99      * @param i the index
100      * @return the key at that index
101      */
102     @Override
103     public JavaConstant keyAt(int i) {
104         return JavaConstant.forInt(keys[i]);
105     }
106 
107     @Override
108     public int keyCount() {
109         return keys.length;
110     }
111 
112     @Override
113     public boolean equalKeys(SwitchNode switchNode) {
114         if (!(switchNode instanceof IntegerSwitchNode)) {
115             return false;
116         }
117         IntegerSwitchNode other = (IntegerSwitchNode) switchNode;
118         return Arrays.equals(keys, other.keys);
119     }
120 
121     @Override
122     public void generate(NodeLIRBuilderTool gen) {
123         gen.emitSwitch(this);
124     }
125 
126     public AbstractBeginNode successorAtKey(int key) {
127         return blockSuccessor(successorIndexAtKey(key));
128     }
129 
130     public int successorIndexAtKey(int key) {
131         for (int i = 0; i &lt; keyCount(); i++) {
132             if (keys[i] == key) {
133                 return keySuccessorIndex(i);
134             }
135         }
136         return keySuccessorIndex(keyCount());
137     }
138 
139     @Override
140     public void simplify(SimplifierTool tool) {
141         NodeView view = NodeView.from(tool);
142         if (blockSuccessorCount() == 1) {
143             tool.addToWorkList(defaultSuccessor());
144             graph().removeSplitPropagate(this, defaultSuccessor());
145         } else if (value() instanceof ConstantNode) {
146             killOtherSuccessors(tool, successorIndexAtKey(value().asJavaConstant().asInt()));
147         } else if (tryOptimizeEnumSwitch(tool)) {
148             return;
149         } else if (tryRemoveUnreachableKeys(tool, value().stamp(view))) {
150             return;
151         }
152     }
153 
154     static final class KeyData {
155         final int key;
156         final double keyProbability;
157         final int keySuccessor;
158 
159         KeyData(int key, double keyProbability, int keySuccessor) {
160             this.key = key;
161             this.keyProbability = keyProbability;
162             this.keySuccessor = keySuccessor;
163         }
164     }
165 
166     /**
167      * Remove unreachable keys from the switch based on the stamp of the value, i.e., based on the
168      * known range of the switch value.
169      */
170     public boolean tryRemoveUnreachableKeys(SimplifierTool tool, Stamp valueStamp) {
171         if (!(valueStamp instanceof IntegerStamp)) {
172             return false;
173         }
174         IntegerStamp integerStamp = (IntegerStamp) valueStamp;
175         if (integerStamp.isUnrestricted()) {
176             return false;
177         }
178 
179         List&lt;KeyData&gt; newKeyDatas = new ArrayList&lt;&gt;(keys.length);
180         ArrayList&lt;AbstractBeginNode&gt; newSuccessors = new ArrayList&lt;&gt;(blockSuccessorCount());
181         for (int i = 0; i &lt; keys.length; i++) {
182             if (integerStamp.contains(keys[i]) &amp;&amp; keySuccessor(i) != defaultSuccessor()) {
183                 newKeyDatas.add(new KeyData(keys[i], keyProbabilities[i], addNewSuccessor(keySuccessor(i), newSuccessors)));
184             }
185         }
186 
187         if (newKeyDatas.size() == keys.length) {
188             /* All keys are reachable. */
189             return false;
190 
191         } else if (newKeyDatas.size() == 0) {
192             if (tool != null) {
193                 tool.addToWorkList(defaultSuccessor());
194             }
195             graph().removeSplitPropagate(this, defaultSuccessor());
196             return true;
197 
198         } else {
199             int newDefaultSuccessor = addNewSuccessor(defaultSuccessor(), newSuccessors);
200             double newDefaultProbability = keyProbabilities[keyProbabilities.length - 1];
201             doReplace(value(), newKeyDatas, newSuccessors, newDefaultSuccessor, newDefaultProbability);
202             return true;
203         }
204     }
205 
206     /**
207      * For switch statements on enum values, the Java compiler has to generate complicated code:
208      * because {@link Enum#ordinal()} can change when recompiling an enum, it cannot be used
209      * directly as the value that is switched on. An intermediate int[] array, which is initialized
210      * once at run time based on the actual {@link Enum#ordinal()} values, is used.
211      *
212      * The {@link ConstantFieldProvider} of Graal already detects the int[] arrays and marks them as
213      * {@link ConstantNode#isDefaultStable() stable}, i.e., the array elements are constant. The
214      * code in this method detects array loads from such a stable array and re-wires the switch to
215      * use the keys from the array elements, so that the array load is unnecessary.
216      */
217     private boolean tryOptimizeEnumSwitch(SimplifierTool tool) {
218         if (!(value() instanceof LoadIndexedNode)) {
219             /* Not the switch pattern we are looking for. */
220             return false;
221         }
222         LoadIndexedNode loadIndexed = (LoadIndexedNode) value();
223         if (loadIndexed.usages().count() &gt; 1) {
224             /*
225              * The array load is necessary for other reasons too, so there is no benefit optimizing
226              * the switch.
227              */
228             return false;
229         }
230         assert loadIndexed.usages().first() == this;
231 
232         ValueNode newValue = loadIndexed.index();
233         JavaConstant arrayConstant = loadIndexed.array().asJavaConstant();
234         if (arrayConstant == null || ((ConstantNode) loadIndexed.array()).getStableDimension() != 1 || !((ConstantNode) loadIndexed.array()).isDefaultStable()) {
235             /*
236              * The array is a constant that we can optimize. We require the array elements to be
237              * constant too, since we put them as literal constants into the switch keys.
238              */
239             return false;
240         }
241 
242         Integer optionalArrayLength = tool.getConstantReflection().readArrayLength(arrayConstant);
243         if (optionalArrayLength == null) {
244             /* Loading a constant value can be denied by the VM. */
245             return false;
246         }
247         int arrayLength = optionalArrayLength;
248 
249         Map&lt;Integer, List&lt;Integer&gt;&gt; reverseArrayMapping = new HashMap&lt;&gt;();
250         for (int i = 0; i &lt; arrayLength; i++) {
251             JavaConstant elementConstant = tool.getConstantReflection().readArrayElement(arrayConstant, i);
252             if (elementConstant == null || elementConstant.getJavaKind() != JavaKind.Int) {
253                 /* Loading a constant value can be denied by the VM. */
254                 return false;
255             }
256             int element = elementConstant.asInt();
257 
258             /*
259              * The value loaded from the array is the old switch key, the index into the array is
260              * the new switch key. We build a mapping from the old switch key to new keys.
261              */
262             reverseArrayMapping.computeIfAbsent(element, e -&gt; new ArrayList&lt;&gt;()).add(i);
263         }
264 
265         /* Build high-level representation of new switch keys. */
266         List&lt;KeyData&gt; newKeyDatas = new ArrayList&lt;&gt;(arrayLength);
267         ArrayList&lt;AbstractBeginNode&gt; newSuccessors = new ArrayList&lt;&gt;(blockSuccessorCount());
268         for (int i = 0; i &lt; keys.length; i++) {
269             List&lt;Integer&gt; newKeys = reverseArrayMapping.get(keys[i]);
270             if (newKeys == null || newKeys.size() == 0) {
271                 /* The switch case is unreachable, we can ignore it. */
272                 continue;
273             }
274 
275             /*
276              * We do not have detailed profiling information about the individual new keys, so we
277              * have to assume they split the probability of the old key.
278              */
279             double newKeyProbability = keyProbabilities[i] / newKeys.size();
280             int newKeySuccessor = addNewSuccessor(keySuccessor(i), newSuccessors);
281 
282             for (int newKey : newKeys) {
283                 newKeyDatas.add(new KeyData(newKey, newKeyProbability, newKeySuccessor));
284             }
285         }
286 
287         int newDefaultSuccessor = addNewSuccessor(defaultSuccessor(), newSuccessors);
288         double newDefaultProbability = keyProbabilities[keyProbabilities.length - 1];
289 
290         /*
291          * We remove the array load, but we still need to preserve exception semantics by keeping
292          * the bounds check. Fortunately the array length is a constant.
293          */
294         LogicNode boundsCheck = graph().unique(new IntegerBelowNode(newValue, ConstantNode.forInt(arrayLength, graph())));
295         graph().addBeforeFixed(this, graph().add(new FixedGuardNode(boundsCheck, DeoptimizationReason.BoundsCheckException, DeoptimizationAction.InvalidateReprofile)));
296 
297         /*
298          * Build the low-level representation of the new switch keys and replace ourself with a new
299          * node.
300          */
301         doReplace(newValue, newKeyDatas, newSuccessors, newDefaultSuccessor, newDefaultProbability);
302 
303         /* The array load is now unnecessary. */
304         assert loadIndexed.hasNoUsages();
305         GraphUtil.removeFixedWithUnusedInputs(loadIndexed);
306 
307         return true;
308     }
309 
310     private static int addNewSuccessor(AbstractBeginNode newSuccessor, ArrayList&lt;AbstractBeginNode&gt; newSuccessors) {
311         int index = newSuccessors.indexOf(newSuccessor);
312         if (index == -1) {
313             index = newSuccessors.size();
314             newSuccessors.add(newSuccessor);
315         }
316         return index;
317     }
318 
319     private void doReplace(ValueNode newValue, List&lt;KeyData&gt; newKeyDatas, ArrayList&lt;AbstractBeginNode&gt; newSuccessors, int newDefaultSuccessor, double newDefaultProbability) {
320         /* Sort the new keys (invariant of the IntegerSwitchNode). */
321         newKeyDatas.sort(Comparator.comparingInt(k -&gt; k.key));
322 
323         /* Create the final data arrays. */
324         int newKeyCount = newKeyDatas.size();
325         int[] newKeys = new int[newKeyCount];
326         double[] newKeyProbabilities = new double[newKeyCount + 1];
327         int[] newKeySuccessors = new int[newKeyCount + 1];
328 
329         for (int i = 0; i &lt; newKeyCount; i++) {
330             KeyData keyData = newKeyDatas.get(i);
331             newKeys[i] = keyData.key;
332             newKeyProbabilities[i] = keyData.keyProbability;
333             newKeySuccessors[i] = keyData.keySuccessor;
334         }
335 
336         newKeySuccessors[newKeyCount] = newDefaultSuccessor;
337         newKeyProbabilities[newKeyCount] = newDefaultProbability;
338 
339         /* Normalize new probabilities so that they sum up to 1. */
340         double totalProbability = 0;
341         for (double probability : newKeyProbabilities) {
342             totalProbability += probability;
343         }
344         if (totalProbability &gt; 0) {
345             for (int i = 0; i &lt; newKeyProbabilities.length; i++) {
346                 newKeyProbabilities[i] /= totalProbability;
347             }
348         } else {
349             for (int i = 0; i &lt; newKeyProbabilities.length; i++) {
350                 newKeyProbabilities[i] = 1.0 / newKeyProbabilities.length;
351             }
352         }
353 
354         /*
355          * Collect dead successors. Successors have to be cleaned before adding the new node to the
356          * graph.
357          */
358         List&lt;AbstractBeginNode&gt; deadSuccessors = successors.filter(s -&gt; !newSuccessors.contains(s)).snapshot();
359         successors.clear();
360 
361         /*
362          * Create the new switch node. This is done before removing dead successors as `killCFG`
363          * could edit some of the inputs (e.g., if `newValue` is a loop-phi of the loop that dies
364          * while removing successors).
365          */
366         AbstractBeginNode[] successorsArray = newSuccessors.toArray(new AbstractBeginNode[newSuccessors.size()]);
367         SwitchNode newSwitch = graph().add(new IntegerSwitchNode(newValue, successorsArray, newKeys, newKeyProbabilities, newKeySuccessors));
368 
369         /* Remove dead successors. */
370         for (AbstractBeginNode successor : deadSuccessors) {
371             GraphUtil.killCFG(successor);
372         }
373 
374         /* Replace ourselves with the new switch */
375         ((FixedWithNextNode) predecessor()).setNext(newSwitch);
376         GraphUtil.killWithUnusedFloatingInputs(this);
377     }
378 
379     @Override
380     public Stamp getValueStampForSuccessor(AbstractBeginNode beginNode) {
381         Stamp result = null;
382         if (beginNode != this.defaultSuccessor()) {
383             for (int i = 0; i &lt; keyCount(); i++) {
384                 if (keySuccessor(i) == beginNode) {
385                     if (result == null) {
386                         result = StampFactory.forConstant(keyAt(i));
387                     } else {
388                         result = result.meet(StampFactory.forConstant(keyAt(i)));
389                     }
390                 }
391             }
392         }
393         return result;
394     }
395 }
    </pre>
  </body>
</html>
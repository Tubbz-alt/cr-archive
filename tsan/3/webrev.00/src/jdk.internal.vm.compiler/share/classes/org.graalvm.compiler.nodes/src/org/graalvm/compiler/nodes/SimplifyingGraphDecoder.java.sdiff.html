<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/SimplifyingGraphDecoder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ProxyNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="StartNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/SimplifyingGraphDecoder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 27 import static org.graalvm.compiler.nodeinfo.InputType.Guard;
 28 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
 29 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
 30 
 31 import java.util.List;
 32 
 33 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 34 import org.graalvm.compiler.core.common.type.Stamp;
 35 import org.graalvm.compiler.debug.DebugCloseable;
 36 import org.graalvm.compiler.graph.Node;
 37 import org.graalvm.compiler.graph.NodeClass;
 38 import org.graalvm.compiler.graph.spi.Canonicalizable;
 39 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 40 import org.graalvm.compiler.nodeinfo.NodeInfo;
 41 import org.graalvm.compiler.nodes.calc.FloatingNode;
 42 import org.graalvm.compiler.nodes.extended.GuardingNode;
 43 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
 44 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 45 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 46 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
<span class="line-modified"> 47 import org.graalvm.compiler.nodes.spi.StampProvider;</span>
 48 import org.graalvm.compiler.nodes.util.GraphUtil;
 49 import org.graalvm.compiler.options.OptionValues;
 50 
 51 import jdk.vm.ci.code.Architecture;
 52 import jdk.vm.ci.meta.Assumptions;
 53 import jdk.vm.ci.meta.ConstantReflectionProvider;
 54 import jdk.vm.ci.meta.MetaAccessProvider;
 55 
 56 /**
 57  * Graph decoder that simplifies nodes during decoding. The standard
 58  * {@link Canonicalizable#canonical node canonicalization} interface is used to canonicalize nodes
 59  * during decoding. Additionally, {@link IfNode branches} and {@link IntegerSwitchNode switches}
 60  * with constant conditions are simplified.
 61  */
 62 public class SimplifyingGraphDecoder extends GraphDecoder {
 63 
<span class="line-modified"> 64     protected final MetaAccessProvider metaAccess;</span>
<span class="line-removed"> 65     protected final ConstantReflectionProvider constantReflection;</span>
<span class="line-removed"> 66     protected final ConstantFieldProvider constantFieldProvider;</span>
<span class="line-removed"> 67     protected final StampProvider stampProvider;</span>
 68     protected final boolean canonicalizeReads;
 69     protected final CanonicalizerTool canonicalizerTool;
 70 
 71     protected class PECanonicalizerTool implements CanonicalizerTool {
 72 
 73         private final Assumptions assumptions;
 74         private final OptionValues options;
 75 
 76         public PECanonicalizerTool(Assumptions assumptions, OptionValues options) {
 77             this.assumptions = assumptions;
 78             this.options = options;
 79         }
 80 
 81         @Override
 82         public OptionValues getOptions() {
 83             return options;
 84         }
 85 
 86         @Override
 87         public MetaAccessProvider getMetaAccess() {
<span class="line-modified"> 88             return metaAccess;</span>
 89         }
 90 
 91         @Override
 92         public ConstantReflectionProvider getConstantReflection() {
<span class="line-modified"> 93             return constantReflection;</span>
 94         }
 95 
 96         @Override
 97         public ConstantFieldProvider getConstantFieldProvider() {
<span class="line-modified"> 98             return constantFieldProvider;</span>
 99         }
100 
101         @Override
102         public boolean canonicalizeReads() {
103             return canonicalizeReads;
104         }
105 
106         @Override
107         public boolean allUsagesAvailable() {
108             return false;
109         }
110 
111         @Override
112         public Assumptions getAssumptions() {
113             return assumptions;
114         }
115 
116         @Override
117         public Integer smallestCompareWidth() {
118             // to be safe, just report null here
119             // there will be more opportunities for this optimization later
120             return null;
121         }
122     }
123 
124     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED, allowedUsageTypes = {Guard})
125     static class CanonicalizeToNullNode extends FloatingNode implements Canonicalizable, GuardingNode {
126         public static final NodeClass&lt;CanonicalizeToNullNode&gt; TYPE = NodeClass.create(CanonicalizeToNullNode.class);
127 
128         protected CanonicalizeToNullNode(Stamp stamp) {
129             super(TYPE, stamp);
130         }
131 
132         @Override
133         public Node canonical(CanonicalizerTool tool) {
134             return null;
135         }
136     }
137 
<span class="line-modified">138     public SimplifyingGraphDecoder(Architecture architecture, StructuredGraph graph, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection,</span>
<span class="line-removed">139                     ConstantFieldProvider constantFieldProvider, StampProvider stampProvider,</span>
<span class="line-removed">140                     boolean canonicalizeReads) {</span>
141         super(architecture, graph);
<span class="line-modified">142         this.metaAccess = metaAccess;</span>
<span class="line-removed">143         this.constantReflection = constantReflection;</span>
<span class="line-removed">144         this.constantFieldProvider = constantFieldProvider;</span>
<span class="line-removed">145         this.stampProvider = stampProvider;</span>
146         this.canonicalizeReads = canonicalizeReads;
147         this.canonicalizerTool = new PECanonicalizerTool(graph.getAssumptions(), graph.getOptions());
148     }
149 
150     @Override
151     protected void cleanupGraph(MethodScope methodScope) {
152         GraphUtil.normalizeLoops(graph);
153         super.cleanupGraph(methodScope);
154 
155         for (Node node : graph.getNewNodes(methodScope.methodStartMark)) {
156             if (node instanceof MergeNode) {
157                 MergeNode mergeNode = (MergeNode) node;
158                 if (mergeNode.forwardEndCount() == 1) {
159                     graph.reduceTrivialMerge(mergeNode);
160                 }
161             } else if (node instanceof BeginNode || node instanceof KillingBeginNode) {
162                 if (!(node.predecessor() instanceof ControlSplitNode) &amp;&amp; node.hasNoUsages()) {
163                     GraphUtil.unlinkFixedNode((AbstractBeginNode) node);
164                     node.safeDelete();
165                 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 27 import static org.graalvm.compiler.nodeinfo.InputType.Guard;
 28 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
 29 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
 30 
 31 import java.util.List;
 32 
 33 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 34 import org.graalvm.compiler.core.common.type.Stamp;
 35 import org.graalvm.compiler.debug.DebugCloseable;
 36 import org.graalvm.compiler.graph.Node;
 37 import org.graalvm.compiler.graph.NodeClass;
 38 import org.graalvm.compiler.graph.spi.Canonicalizable;
 39 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 40 import org.graalvm.compiler.nodeinfo.NodeInfo;
 41 import org.graalvm.compiler.nodes.calc.FloatingNode;
 42 import org.graalvm.compiler.nodes.extended.GuardingNode;
 43 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
 44 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 45 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 46 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
<span class="line-modified"> 47 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 48 import org.graalvm.compiler.nodes.util.GraphUtil;
 49 import org.graalvm.compiler.options.OptionValues;
 50 
 51 import jdk.vm.ci.code.Architecture;
 52 import jdk.vm.ci.meta.Assumptions;
 53 import jdk.vm.ci.meta.ConstantReflectionProvider;
 54 import jdk.vm.ci.meta.MetaAccessProvider;
 55 
 56 /**
 57  * Graph decoder that simplifies nodes during decoding. The standard
 58  * {@link Canonicalizable#canonical node canonicalization} interface is used to canonicalize nodes
 59  * during decoding. Additionally, {@link IfNode branches} and {@link IntegerSwitchNode switches}
 60  * with constant conditions are simplified.
 61  */
 62 public class SimplifyingGraphDecoder extends GraphDecoder {
 63 
<span class="line-modified"> 64     protected final CoreProviders providers;</span>



 65     protected final boolean canonicalizeReads;
 66     protected final CanonicalizerTool canonicalizerTool;
 67 
 68     protected class PECanonicalizerTool implements CanonicalizerTool {
 69 
 70         private final Assumptions assumptions;
 71         private final OptionValues options;
 72 
 73         public PECanonicalizerTool(Assumptions assumptions, OptionValues options) {
 74             this.assumptions = assumptions;
 75             this.options = options;
 76         }
 77 
 78         @Override
 79         public OptionValues getOptions() {
 80             return options;
 81         }
 82 
 83         @Override
 84         public MetaAccessProvider getMetaAccess() {
<span class="line-modified"> 85             return providers.getMetaAccess();</span>
 86         }
 87 
 88         @Override
 89         public ConstantReflectionProvider getConstantReflection() {
<span class="line-modified"> 90             return providers.getConstantReflection();</span>
 91         }
 92 
 93         @Override
 94         public ConstantFieldProvider getConstantFieldProvider() {
<span class="line-modified"> 95             return providers.getConstantFieldProvider();</span>
 96         }
 97 
 98         @Override
 99         public boolean canonicalizeReads() {
100             return canonicalizeReads;
101         }
102 
103         @Override
104         public boolean allUsagesAvailable() {
105             return false;
106         }
107 
108         @Override
109         public Assumptions getAssumptions() {
110             return assumptions;
111         }
112 
113         @Override
114         public Integer smallestCompareWidth() {
115             // to be safe, just report null here
116             // there will be more opportunities for this optimization later
117             return null;
118         }
119     }
120 
121     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED, allowedUsageTypes = {Guard})
122     static class CanonicalizeToNullNode extends FloatingNode implements Canonicalizable, GuardingNode {
123         public static final NodeClass&lt;CanonicalizeToNullNode&gt; TYPE = NodeClass.create(CanonicalizeToNullNode.class);
124 
125         protected CanonicalizeToNullNode(Stamp stamp) {
126             super(TYPE, stamp);
127         }
128 
129         @Override
130         public Node canonical(CanonicalizerTool tool) {
131             return null;
132         }
133     }
134 
<span class="line-modified">135     public SimplifyingGraphDecoder(Architecture architecture, StructuredGraph graph, CoreProviders providers, boolean canonicalizeReads) {</span>


136         super(architecture, graph);
<span class="line-modified">137         this.providers = providers;</span>



138         this.canonicalizeReads = canonicalizeReads;
139         this.canonicalizerTool = new PECanonicalizerTool(graph.getAssumptions(), graph.getOptions());
140     }
141 
142     @Override
143     protected void cleanupGraph(MethodScope methodScope) {
144         GraphUtil.normalizeLoops(graph);
145         super.cleanupGraph(methodScope);
146 
147         for (Node node : graph.getNewNodes(methodScope.methodStartMark)) {
148             if (node instanceof MergeNode) {
149                 MergeNode mergeNode = (MergeNode) node;
150                 if (mergeNode.forwardEndCount() == 1) {
151                     graph.reduceTrivialMerge(mergeNode);
152                 }
153             } else if (node instanceof BeginNode || node instanceof KillingBeginNode) {
154                 if (!(node.predecessor() instanceof ControlSplitNode) &amp;&amp; node.hasNoUsages()) {
155                     GraphUtil.unlinkFixedNode((AbstractBeginNode) node);
156                     node.safeDelete();
157                 }
</pre>
</td>
</tr>
</table>
<center><a href="ProxyNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="StartNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
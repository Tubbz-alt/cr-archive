<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/IntegerConvertNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.calc;
 26 
 27 import java.io.Serializable;
 28 import java.util.function.Function;
 29 
 30 import org.graalvm.compiler.core.common.type.ArithmeticOpTable;
 31 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.IntegerConvertOp;
 32 import org.graalvm.compiler.core.common.type.IntegerStamp;
 33 import org.graalvm.compiler.core.common.type.PrimitiveStamp;
 34 import org.graalvm.compiler.core.common.type.Stamp;
 35 import org.graalvm.compiler.graph.NodeClass;
 36 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 37 import org.graalvm.compiler.nodeinfo.NodeInfo;
 38 import org.graalvm.compiler.nodes.ArithmeticOperation;
 39 import org.graalvm.compiler.nodes.ConstantNode;
 40 import org.graalvm.compiler.nodes.NodeView;
 41 import org.graalvm.compiler.nodes.StructuredGraph;
 42 import org.graalvm.compiler.nodes.ValueNode;
 43 import org.graalvm.compiler.nodes.spi.ArithmeticLIRLowerable;
 44 import org.graalvm.compiler.nodes.spi.StampInverter;
 45 
 46 import jdk.vm.ci.meta.Constant;
 47 import jdk.vm.ci.meta.ConstantReflectionProvider;
 48 
 49 /**
 50  * An {@code IntegerConvert} converts an integer to an integer of different width.
 51  */
 52 @NodeInfo
 53 public abstract class IntegerConvertNode&lt;OP, REV&gt; extends UnaryNode implements ArithmeticOperation, ConvertNode, ArithmeticLIRLowerable, StampInverter {
 54     @SuppressWarnings(&quot;rawtypes&quot;) public static final NodeClass&lt;IntegerConvertNode&gt; TYPE = NodeClass.create(IntegerConvertNode.class);
 55 
 56     protected final SerializableIntegerConvertFunction&lt;OP&gt; getOp;
 57     protected final SerializableIntegerConvertFunction&lt;REV&gt; getReverseOp;
 58 
 59     protected final int inputBits;
 60     protected final int resultBits;
 61 
 62     protected interface SerializableIntegerConvertFunction&lt;T&gt; extends Function&lt;ArithmeticOpTable, IntegerConvertOp&lt;T&gt;&gt;, Serializable {
 63     }
 64 
 65     protected IntegerConvertNode(NodeClass&lt;? extends IntegerConvertNode&lt;OP, REV&gt;&gt; c, SerializableIntegerConvertFunction&lt;OP&gt; getOp, SerializableIntegerConvertFunction&lt;REV&gt; getReverseOp, int inputBits,
 66                     int resultBits, ValueNode input) {
 67         super(c, getOp.apply(ArithmeticOpTable.forStamp(input.stamp(NodeView.DEFAULT))).foldStamp(inputBits, resultBits, input.stamp(NodeView.DEFAULT)), input);
 68         this.getOp = getOp;
 69         this.getReverseOp = getReverseOp;
 70         this.inputBits = inputBits;
 71         this.resultBits = resultBits;
 72         assert ((PrimitiveStamp) input.stamp(NodeView.DEFAULT)).getBits() == inputBits;
 73     }
 74 
 75     public int getInputBits() {
 76         return inputBits;
 77     }
 78 
 79     public int getResultBits() {
 80         return resultBits;
 81     }
 82 
 83     protected final IntegerConvertOp&lt;OP&gt; getOp(ValueNode forValue) {
 84         return getOp.apply(ArithmeticOpTable.forStamp(forValue.stamp(NodeView.DEFAULT)));
 85     }
 86 
 87     @Override
 88     public final IntegerConvertOp&lt;OP&gt; getArithmeticOp() {
 89         return getOp(getValue());
 90     }
 91 
 92     @Override
 93     public Constant convert(Constant c, ConstantReflectionProvider constantReflection) {
 94         return getArithmeticOp().foldConstant(getInputBits(), getResultBits(), c);
 95     }
 96 
 97     @Override
 98     public Constant reverse(Constant c, ConstantReflectionProvider constantReflection) {
 99         IntegerConvertOp&lt;REV&gt; reverse = getReverseOp.apply(ArithmeticOpTable.forStamp(stamp(NodeView.DEFAULT)));
100         return reverse.foldConstant(getResultBits(), getInputBits(), c);
101     }
102 
103     @Override
104     public Stamp foldStamp(Stamp newStamp) {
105         assert newStamp.isCompatible(getValue().stamp(NodeView.DEFAULT));
106         return getArithmeticOp().foldStamp(inputBits, resultBits, newStamp);
107     }
108 
109     @Override
110     public ValueNode canonical(CanonicalizerTool tool, ValueNode forValue) {
111         ValueNode synonym = findSynonym(getOp(forValue), forValue, inputBits, resultBits, stamp(NodeView.DEFAULT));
112         if (synonym != null) {
113             return synonym;
114         }
115         return this;
116     }
117 
118     protected static &lt;T&gt; ValueNode findSynonym(IntegerConvertOp&lt;T&gt; operation, ValueNode value, int inputBits, int resultBits, Stamp stamp) {
119         if (inputBits == resultBits) {
120             return value;
121         } else if (value.isConstant()) {
122             return ConstantNode.forPrimitive(stamp, operation.foldConstant(inputBits, resultBits, value.asConstant()));
123         }
124         return null;
125     }
126 
127     public static ValueNode convert(ValueNode input, Stamp stamp, NodeView view) {
128         return convert(input, stamp, false, view);
129     }
130 
131     public static ValueNode convert(ValueNode input, Stamp stamp, StructuredGraph graph, NodeView view) {
132         ValueNode convert = convert(input, stamp, false, view);
133         if (!convert.isAlive()) {
134             assert !convert.isDeleted();
135             convert = graph.addOrUniqueWithInputs(convert);
136         }
137         return convert;
138     }
139 
140     public static ValueNode convertUnsigned(ValueNode input, Stamp stamp, NodeView view) {
141         return convert(input, stamp, true, view);
142     }
143 
144     public static ValueNode convertUnsigned(ValueNode input, Stamp stamp, StructuredGraph graph, NodeView view) {
145         ValueNode convert = convert(input, stamp, true, view);
146         if (!convert.isAlive()) {
147             assert !convert.isDeleted();
148             convert = graph.addOrUniqueWithInputs(convert);
149         }
150         return convert;
151     }
152 
153     public static ValueNode convert(ValueNode input, Stamp stamp, boolean zeroExtend, NodeView view) {
154         IntegerStamp fromStamp = (IntegerStamp) input.stamp(view);
155         IntegerStamp toStamp = (IntegerStamp) stamp;
156 
157         ValueNode result;
158         if (toStamp.getBits() == fromStamp.getBits()) {
159             result = input;
160         } else if (toStamp.getBits() &lt; fromStamp.getBits()) {
161             result = new NarrowNode(input, fromStamp.getBits(), toStamp.getBits());
162         } else if (zeroExtend) {
163             // toStamp.getBits() &gt; fromStamp.getBits()
164             result = ZeroExtendNode.create(input, toStamp.getBits(), view);
165         } else {
166             // toStamp.getBits() &gt; fromStamp.getBits()
167             result = SignExtendNode.create(input, toStamp.getBits(), view);
168         }
169 
170         IntegerStamp resultStamp = (IntegerStamp) result.stamp(view);
171         assert toStamp.getBits() == resultStamp.getBits();
172         return result;
173     }
174 
175     @Override
176     public Stamp invertStamp(Stamp outStamp) {
177         return getArithmeticOp().invertStamp(inputBits, resultBits, outStamp);
178     }
179 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/spi/Replacements.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NodeLIRBuilderTool.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StampProvider.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/spi/Replacements.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,29 ***</span>
  
  package org.graalvm.compiler.nodes.spi;
  
  import org.graalvm.compiler.api.replacements.MethodSubstitution;
  import org.graalvm.compiler.api.replacements.SnippetTemplateCache;
<span class="line-removed">- import org.graalvm.compiler.bytecode.Bytecode;</span>
  import org.graalvm.compiler.bytecode.BytecodeProvider;
  import org.graalvm.compiler.core.common.CompilationIdentifier;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.graph.NodeSourcePosition;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderPlugin;
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
  import org.graalvm.compiler.options.OptionValues;
  
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  
  /**
   * Interface for managing replacements.
   */
  public interface Replacements {
  
<span class="line-modified">!     OptionValues getOptions();</span>
  
      /**
       * Gets the object managing the various graph builder plugins used by this object when parsing
       * bytecode into a graph.
       */
<span class="line-new-header">--- 24,31 ---</span>
  
  package org.graalvm.compiler.nodes.spi;
  
  import org.graalvm.compiler.api.replacements.MethodSubstitution;
  import org.graalvm.compiler.api.replacements.SnippetTemplateCache;
  import org.graalvm.compiler.bytecode.BytecodeProvider;
  import org.graalvm.compiler.core.common.CompilationIdentifier;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.graph.NodeSourcePosition;
<span class="line-added">+ import org.graalvm.compiler.nodes.Cancellable;</span>
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderPlugin;
<span class="line-added">+ import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;</span>
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
<span class="line-added">+ import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;</span>
  import org.graalvm.compiler.options.OptionValues;
  
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  
  /**
   * Interface for managing replacements.
   */
  public interface Replacements {
  
<span class="line-modified">!     CoreProviders getProviders();</span>
  
      /**
       * Gets the object managing the various graph builder plugins used by this object when parsing
       * bytecode into a graph.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 55,70 ***</span>
      /**
       * Gets the plugin type that intrinsifies calls to {@code method}.
       */
      Class&lt;? extends GraphBuilderPlugin&gt; getIntrinsifyingPlugin(ResolvedJavaMethod method);
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Gets the snippet graph derived from a given method.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param args arguments to the snippet if available, otherwise {@code null}</span>
<span class="line-removed">-      * @param trackNodeSourcePosition</span>
<span class="line-removed">-      * @return the snippet graph, if any, that is derived from {@code method}</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     default StructuredGraph getSnippet(ResolvedJavaMethod method, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>
<span class="line-removed">-         return getSnippet(method, null, args, trackNodeSourcePosition, replaceePosition);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Gets the snippet graph derived from a given method.
       *
       * @param recursiveEntry if the snippet contains a call to this method, it&#39;s considered as
       *            recursive call and won&#39;t be processed for {@linkplain MethodSubstitution
       *            substitutions}.
       * @param args arguments to the snippet if available, otherwise {@code null}
       * @param trackNodeSourcePosition
       * @return the snippet graph, if any, that is derived from {@code method}
       */
<span class="line-modified">!     StructuredGraph getSnippet(ResolvedJavaMethod method, ResolvedJavaMethod recursiveEntry, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition);</span>
  
      /**
       * Registers a method as snippet.
       */
<span class="line-modified">!     void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition);</span>
  
      /**
       * Gets a graph that is a substitution for a given method.
       *
       * @param invokeBci the call site BCI if this request is made for inlining a substitute
       *            otherwise {@code -1}
       * @param trackNodeSourcePosition
       * @return the graph, if any, that is a substitution for {@code method}
       */
<span class="line-modified">!     StructuredGraph getSubstitution(ResolvedJavaMethod method, int invokeBci, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Gets the substitute bytecode for a given method.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @return the bytecode to substitute for {@code method} or {@code null} if there is no</span>
<span class="line-removed">-      *         substitute bytecode for {@code method}</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     Bytecode getSubstitutionBytecode(ResolvedJavaMethod method);</span>
  
      /**
       * Gets a graph produced from the intrinsic for a given method that can be compiled and
       * installed for the method.
       *
       * @param method
       * @param compilationId
       * @param debug
       * @return an intrinsic graph that can be compiled and installed for {@code method} or null
       */
<span class="line-modified">!     StructuredGraph getIntrinsicGraph(ResolvedJavaMethod method, CompilationIdentifier compilationId, DebugContext debug);</span>
  
      /**
       * Determines if there may be a
<span class="line-modified">!      * {@linkplain #getSubstitution(ResolvedJavaMethod, int, boolean, NodeSourcePosition)</span>
       * substitution graph} for a given method.
       *
       * A call to {@link #getSubstitution} may still return {@code null} for {@code method} and
       * {@code invokeBci}. A substitution may be based on an {@link InvocationPlugin} that returns
       * {@code false} for {@link InvocationPlugin#execute} making it impossible to create a
<span class="line-new-header">--- 57,83 ---</span>
      /**
       * Gets the plugin type that intrinsifies calls to {@code method}.
       */
      Class&lt;? extends GraphBuilderPlugin&gt; getIntrinsifyingPlugin(ResolvedJavaMethod method);
  
      /**
       * Gets the snippet graph derived from a given method.
       *
       * @param recursiveEntry if the snippet contains a call to this method, it&#39;s considered as
       *            recursive call and won&#39;t be processed for {@linkplain MethodSubstitution
       *            substitutions}.
       * @param args arguments to the snippet if available, otherwise {@code null}
       * @param trackNodeSourcePosition
<span class="line-added">+      * @param options</span>
       * @return the snippet graph, if any, that is derived from {@code method}
       */
<span class="line-modified">!     StructuredGraph getSnippet(ResolvedJavaMethod method, ResolvedJavaMethod recursiveEntry, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition,</span>
<span class="line-added">+                     OptionValues options);</span>
  
      /**
       * Registers a method as snippet.
       */
<span class="line-modified">!     void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition, OptionValues options);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Gets a graph that is a substitution for a given {@link MethodSubstitutionPlugin plugin} in</span>
<span class="line-added">+      * the {@link org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext</span>
<span class="line-added">+      * context}.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param plugin the plugin being substituted</span>
<span class="line-added">+      * @param original the method being substituted</span>
<span class="line-added">+      * @param context the kind of inlining to be performed for the substitution</span>
<span class="line-added">+      * @param allowAssumptions</span>
<span class="line-added">+      * @param cancellable</span>
<span class="line-added">+      * @param options</span>
<span class="line-added">+      * @return the method substitution graph, if any, that is derived from {@code method}</span>
<span class="line-added">+      */</span>
<span class="line-added">+     StructuredGraph getMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, IntrinsicContext.CompilationContext context,</span>
<span class="line-added">+                     StructuredGraph.AllowAssumptions allowAssumptions, Cancellable cancellable, OptionValues options);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Registers a plugin as a substitution.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     void registerMethodSubstitution(MethodSubstitutionPlugin plugin);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Marks a plugin as conditionally applied. In the contenxt of libgraal conditional plugins</span>
<span class="line-added">+      * can&#39;t be used in during graph encoding for snippets and method substitutions and this is used</span>
<span class="line-added">+      * to detect violations of this restriction.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     void registerConditionalPlugin(InvocationPlugin plugin);</span>
  
      /**
       * Gets a graph that is a substitution for a given method.
       *
       * @param invokeBci the call site BCI if this request is made for inlining a substitute
       *            otherwise {@code -1}
       * @param trackNodeSourcePosition
<span class="line-added">+      * @param options</span>
       * @return the graph, if any, that is a substitution for {@code method}
       */
<span class="line-modified">!     StructuredGraph getSubstitution(ResolvedJavaMethod method, int invokeBci, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition, OptionValues options);</span>
  
      /**
       * Gets a graph produced from the intrinsic for a given method that can be compiled and
       * installed for the method.
       *
       * @param method
       * @param compilationId
       * @param debug
<span class="line-added">+      * @param cancellable</span>
       * @return an intrinsic graph that can be compiled and installed for {@code method} or null
       */
<span class="line-modified">!     StructuredGraph getIntrinsicGraph(ResolvedJavaMethod method, CompilationIdentifier compilationId, DebugContext debug, Cancellable cancellable);</span>
  
      /**
       * Determines if there may be a
<span class="line-modified">!      * {@linkplain #getSubstitution(ResolvedJavaMethod, int, boolean, NodeSourcePosition, OptionValues)</span>
       * substitution graph} for a given method.
       *
       * A call to {@link #getSubstitution} may still return {@code null} for {@code method} and
       * {@code invokeBci}. A substitution may be based on an {@link InvocationPlugin} that returns
       * {@code false} for {@link InvocationPlugin#execute} making it impossible to create a
</pre>
<center><a href="NodeLIRBuilderTool.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StampProvider.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
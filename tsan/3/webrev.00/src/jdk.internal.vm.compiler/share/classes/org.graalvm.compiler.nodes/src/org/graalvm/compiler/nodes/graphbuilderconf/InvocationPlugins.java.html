<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/InvocationPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.nodes.graphbuilderconf;
  26 
  27 import static java.lang.String.format;
  28 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  29 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  30 import static org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.LateClassPlugins.CLOSED_LATE_CLASS_PLUGIN;
  31 
  32 import java.lang.reflect.Constructor;
  33 import java.lang.reflect.Method;
  34 import java.lang.reflect.Modifier;
  35 import java.lang.reflect.Type;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collections;
  39 import java.util.List;
  40 import java.util.Map;
  41 
  42 import jdk.internal.vm.compiler.collections.EconomicMap;
  43 import jdk.internal.vm.compiler.collections.Equivalence;
  44 import jdk.internal.vm.compiler.collections.MapCursor;
  45 import jdk.internal.vm.compiler.collections.Pair;
  46 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  47 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
  48 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  49 import org.graalvm.compiler.bytecode.BytecodeProvider;
  50 import org.graalvm.compiler.core.common.SuppressFBWarnings;
  51 import org.graalvm.compiler.debug.Assertions;
  52 import org.graalvm.compiler.debug.GraalError;
  53 import org.graalvm.compiler.graph.Node;
  54 import org.graalvm.compiler.graph.iterators.NodeIterable;
  55 import org.graalvm.compiler.nodes.ValueNode;
  56 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
  57 import org.graalvm.compiler.nodes.spi.Replacements;
  58 
  59 import jdk.vm.ci.meta.MetaUtil;
  60 import jdk.vm.ci.meta.ResolvedJavaMethod;
  61 import jdk.vm.ci.meta.ResolvedJavaType;
  62 import jdk.vm.ci.meta.Signature;
  63 
  64 /**
  65  * Manages a set of {@link InvocationPlugin}s.
  66  *
  67  * Most plugins are registered during initialization (i.e., before
  68  * {@link #lookupInvocation(ResolvedJavaMethod)} or {@link #getBindings} is called). These
  69  * registrations can be made with {@link Registration},
  70  * {@link #register(InvocationPlugin, String, String, Type...)},
  71  * {@link #register(InvocationPlugin, Type, String, Type...)} or
  72  * {@link #registerOptional(InvocationPlugin, Type, String, Type...)}. Initialization is not
  73  * thread-safe and so must only be performed by a single thread.
  74  *
  75  * Plugins that are not guaranteed to be made during initialization must use
  76  * {@link LateRegistration}.
  77  */
  78 public class InvocationPlugins {
  79 
  80     public static class InvocationPluginReceiver implements InvocationPlugin.Receiver {
  81         private final GraphBuilderContext parser;
  82         private ValueNode[] args;
  83         private ValueNode value;
  84 
  85         public InvocationPluginReceiver(GraphBuilderContext parser) {
  86             this.parser = parser;
  87         }
  88 
  89         @Override
  90         public ValueNode get(boolean performNullCheck) {
  91             assert args != null : &quot;Cannot get the receiver of a static method&quot;;
  92             if (!performNullCheck) {
  93                 return args[0];
  94             }
  95             if (value == null) {
  96                 value = parser.nullCheckedValue(args[0]);
  97                 if (value != args[0]) {
  98                     args[0] = value;
  99                 }
 100             }
 101             return value;
 102         }
 103 
 104         @Override
 105         public boolean isConstant() {
 106             return args[0].isConstant();
 107         }
 108 
 109         public InvocationPluginReceiver init(ResolvedJavaMethod targetMethod, ValueNode[] newArgs) {
 110             if (!targetMethod.isStatic()) {
 111                 this.args = newArgs;
 112                 this.value = null;
 113                 return this;
 114             }
 115             return null;
 116         }
 117     }
 118 
 119     /**
 120      * A symbol for an already resolved method.
 121      */
 122     public static class ResolvedJavaSymbol implements Type {
 123         private final ResolvedJavaType resolved;
 124 
 125         public ResolvedJavaSymbol(ResolvedJavaType type) {
 126             this.resolved = type;
 127         }
 128 
 129         public ResolvedJavaType getResolved() {
 130             return resolved;
 131         }
 132 
 133         @Override
 134         public String toString() {
 135             return resolved.toJavaName();
 136         }
 137     }
 138 
 139     /**
 140      * A symbol that is lazily {@linkplain OptionalLazySymbol#resolve() resolved} to a {@link Type}.
 141      */
 142     static class OptionalLazySymbol implements Type {
 143         private static final Class&lt;?&gt; MASK_NULL = OptionalLazySymbol.class;
 144         private final String name;
 145         private Class&lt;?&gt; resolved;
 146 
 147         OptionalLazySymbol(String name) {
 148             this.name = name;
 149             if (IS_BUILDING_NATIVE_IMAGE) {
 150                 resolve();
 151             }
 152         }
 153 
 154         @Override
 155         public String getTypeName() {
 156             return name;
 157         }
 158 
 159         /**
 160          * Gets the resolved {@link Class} corresponding to this symbol or {@code null} if
 161          * resolution fails.
 162          */
 163         public Class&lt;?&gt; resolve() {
 164             if (!IS_IN_NATIVE_IMAGE &amp;&amp; resolved == null) {
 165                 Class&lt;?&gt; resolvedOrNull = resolveClass(name, true);
 166                 resolved = resolvedOrNull == null ? MASK_NULL : resolvedOrNull;
 167             }
 168             return resolved == MASK_NULL ? null : resolved;
 169         }
 170 
 171         @Override
 172         public String toString() {
 173             return name;
 174         }
 175     }
 176 
 177     /**
 178      * Utility for {@linkplain InvocationPlugins#register registration} of invocation plugins.
 179      */
 180     public static class Registration {
 181 
 182         private final InvocationPlugins plugins;
 183 
 184         private final Type declaringType;
 185         private final Replacements replacements;
 186         private final BytecodeProvider bytecodeProvider;
 187         private boolean allowOverwrite;
 188 
 189         public Class&lt;?&gt; getReceiverType() {
 190             return Receiver.class;
 191         }
 192 
 193         public Type getDeclaringType() {
 194             return declaringType;
 195         }
 196 
 197         /**
 198          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 199          * given class.
 200          *
 201          * @param plugins where to register the plugins
 202          * @param declaringType the class declaring the methods for which plugins will be registered
 203          *            via this object
 204          */
 205         public Registration(InvocationPlugins plugins, Type declaringType) {
 206             this.plugins = plugins;
 207             this.declaringType = declaringType;
 208             this.replacements = null;
 209             this.bytecodeProvider = null;
 210         }
 211 
 212         /**
 213          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 214          * given class.
 215          *
 216          * @param plugins where to register the plugins
 217          * @param declaringType the class declaring the methods for which plugins will be registered
 218          *            via this object
 219          * @param replacements the current Replacements provider
 220          */
 221         public Registration(InvocationPlugins plugins, Type declaringType, Replacements replacements) {
 222             this.plugins = plugins;
 223             this.declaringType = declaringType;
 224             this.replacements = replacements;
 225             this.bytecodeProvider = replacements != null ? replacements.getDefaultReplacementBytecodeProvider() : null;
 226         }
 227 
 228         /**
 229          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 230          * given class.
 231          *
 232          * @param plugins where to register the plugins
 233          * @param declaringType the class declaring the methods for which plugins will be registered
 234          *            via this object
 235          * @param replacements the current Replacements provider
 236          */
 237         public Registration(InvocationPlugins plugins, Type declaringType, Replacements replacements, BytecodeProvider bytecodeProvider) {
 238             this.plugins = plugins;
 239             this.declaringType = declaringType;
 240             this.replacements = replacements;
 241             this.bytecodeProvider = bytecodeProvider;
 242         }
 243 
 244         /**
 245          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 246          * given class.
 247          *
 248          * @param plugins where to register the plugins
 249          * @param declaringClassName the name of the class class declaring the methods for which
 250          *            plugins will be registered via this object
 251          */
 252         public Registration(InvocationPlugins plugins, String declaringClassName) {
 253             this.plugins = plugins;
 254             this.declaringType = new OptionalLazySymbol(declaringClassName);
 255             this.replacements = null;
 256             this.bytecodeProvider = null;
 257         }
 258 
 259         /**
 260          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 261          * given class.
 262          *
 263          * @param plugins where to register the plugins
 264          * @param declaringClassName the name of the class class declaring the methods for which
 265          *            plugins will be registered via this object
 266          * @param replacements the current Replacements provider
 267          */
 268         public Registration(InvocationPlugins plugins, String declaringClassName, Replacements replacements) {
 269             this.plugins = plugins;
 270             this.declaringType = new OptionalLazySymbol(declaringClassName);
 271             this.replacements = replacements;
 272             this.bytecodeProvider = replacements != null ? replacements.getDefaultReplacementBytecodeProvider() : null;
 273         }
 274 
 275         /**
 276          * Configures this registration to allow or disallow overwriting of invocation plugins.
 277          */
 278         public Registration setAllowOverwrite(boolean allowOverwrite) {
 279             this.allowOverwrite = allowOverwrite;
 280             return this;
 281         }
 282 
 283         /**
 284          * Registers a plugin for a method with no arguments.
 285          *
 286          * @param name the name of the method
 287          * @param plugin the plugin to be registered
 288          */
 289         public void register0(String name, InvocationPlugin plugin) {
 290             plugins.register(plugin, false, allowOverwrite, declaringType, name);
 291         }
 292 
 293         /**
 294          * Registers a plugin for a method with 1 argument.
 295          *
 296          * @param name the name of the method
 297          * @param plugin the plugin to be registered
 298          */
 299         public void register1(String name, Type arg, InvocationPlugin plugin) {
 300             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg);
 301         }
 302 
 303         /**
 304          * Registers a plugin for a method with 2 arguments.
 305          *
 306          * @param name the name of the method
 307          * @param plugin the plugin to be registered
 308          */
 309         public void register2(String name, Type arg1, Type arg2, InvocationPlugin plugin) {
 310             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2);
 311         }
 312 
 313         /**
 314          * Registers a plugin for a method with 3 arguments.
 315          *
 316          * @param name the name of the method
 317          * @param plugin the plugin to be registered
 318          */
 319         public void register3(String name, Type arg1, Type arg2, Type arg3, InvocationPlugin plugin) {
 320             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3);
 321         }
 322 
 323         /**
 324          * Registers a plugin for a method with 4 arguments.
 325          *
 326          * @param name the name of the method
 327          * @param plugin the plugin to be registered
 328          */
 329         public void register4(String name, Type arg1, Type arg2, Type arg3, Type arg4, InvocationPlugin plugin) {
 330             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4);
 331         }
 332 
 333         /**
 334          * Registers a plugin for a method with 5 arguments.
 335          *
 336          * @param name the name of the method
 337          * @param plugin the plugin to be registered
 338          */
 339         public void register5(String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, InvocationPlugin plugin) {
 340             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5);
 341         }
 342 
 343         /**
 344          * Registers a plugin for a method with 6 arguments.
 345          *
 346          * @param name the name of the method
 347          * @param plugin the plugin to be registered
 348          */
 349         public void register6(String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, InvocationPlugin plugin) {
 350             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6);
 351         }
 352 
 353         /**
 354          * Registers a plugin for a method with 7 arguments.
 355          *
 356          * @param name the name of the method
 357          * @param plugin the plugin to be registered
 358          */
 359         public void register7(String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, Type arg7, InvocationPlugin plugin) {
 360             plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
 361         }
 362 
 363         /**
 364          * Registers a plugin for a method with no arguments that is conditionally enabled. This
 365          * ensures that {@code Replacements} is aware of this plugin.
 366          *
 367          * @param name the name of the method
 368          * @param plugin the plugin to be registered
 369          */
 370         public void registerConditional0(boolean isEnabled, String name, InvocationPlugin plugin) {
 371             replacements.registerConditionalPlugin(plugin);
 372             if (isEnabled) {
 373                 plugins.register(plugin, false, allowOverwrite, declaringType, name);
 374             }
 375         }
 376 
 377         /**
 378          * Registers a plugin for a method with 1 argument that is conditionally enabled. This
 379          * ensures that {@code Replacements} is aware of this plugin.
 380          *
 381          * @param name the name of the method
 382          * @param plugin the plugin to be registered
 383          */
 384         public void registerConditional1(boolean isEnabled, String name, Type arg, InvocationPlugin plugin) {
 385             replacements.registerConditionalPlugin(plugin);
 386             if (isEnabled) {
 387                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg);
 388             }
 389         }
 390 
 391         /**
 392          * Registers a plugin for a method with 2 arguments that is conditionally enabled. This
 393          * ensures that {@code Replacements} is aware of this plugin.
 394          *
 395          * @param name the name of the method
 396          * @param plugin the plugin to be registered
 397          */
 398         public void registerConditional2(boolean isEnabled, String name, Type arg1, Type arg2, InvocationPlugin plugin) {
 399             replacements.registerConditionalPlugin(plugin);
 400             if (isEnabled) {
 401                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2);
 402             }
 403         }
 404 
 405         /**
 406          * Registers a plugin for a method with 3 arguments that is conditionally enabled. This
 407          * ensures that {@code Replacements} is aware of this plugin.
 408          *
 409          * @param name the name of the method
 410          * @param plugin the plugin to be registered
 411          */
 412         public void registerConditional3(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, InvocationPlugin plugin) {
 413             replacements.registerConditionalPlugin(plugin);
 414             if (isEnabled) {
 415                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3);
 416             }
 417         }
 418 
 419         /**
 420          * Registers a plugin for a method with 4 arguments that is conditionally enabled. This
 421          * ensures that {@code Replacements} is aware of this plugin.
 422          *
 423          * @param name the name of the method
 424          * @param plugin the plugin to be registered
 425          */
 426         public void registerConditional4(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, Type arg4, InvocationPlugin plugin) {
 427             replacements.registerConditionalPlugin(plugin);
 428             if (isEnabled) {
 429                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4);
 430             }
 431         }
 432 
 433         /**
 434          * Registers a plugin for a method with 5 arguments that is conditionally enabled. This
 435          * ensures that {@code Replacements} is aware of this plugin.
 436          *
 437          * @param name the name of the method
 438          * @param plugin the plugin to be registered
 439          */
 440         public void registerConditional5(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, InvocationPlugin plugin) {
 441             replacements.registerConditionalPlugin(plugin);
 442             if (isEnabled) {
 443                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5);
 444             }
 445         }
 446 
 447         /**
 448          * Registers a plugin for a method with 6 arguments that is conditionally enabled. This
 449          * ensures that {@code Replacements} is aware of this plugin.
 450          *
 451          * @param name the name of the method
 452          * @param plugin the plugin to be registered
 453          */
 454         public void registerConditional6(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, InvocationPlugin plugin) {
 455             replacements.registerConditionalPlugin(plugin);
 456             if (isEnabled) {
 457                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6);
 458             }
 459         }
 460 
 461         /**
 462          * Registers a plugin for a method with 7 arguments that is conditionally enabled. This
 463          * ensures that {@code Replacements} is aware of this plugin.
 464          *
 465          * @param name the name of the method
 466          * @param plugin the plugin to be registered
 467          */
 468         public void registerConditional7(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, Type arg7, InvocationPlugin plugin) {
 469             replacements.registerConditionalPlugin(plugin);
 470             if (isEnabled) {
 471                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
 472             }
 473         }
 474 
 475         /**
 476          * Registers a plugin for an optional method with no arguments.
 477          *
 478          * @param name the name of the method
 479          * @param plugin the plugin to be registered
 480          */
 481         public void registerOptional0(String name, InvocationPlugin plugin) {
 482             plugins.register(plugin, true, allowOverwrite, declaringType, name);
 483         }
 484 
 485         /**
 486          * Registers a plugin for an optional method with 1 argument.
 487          *
 488          * @param name the name of the method
 489          * @param plugin the plugin to be registered
 490          */
 491         public void registerOptional1(String name, Type arg, InvocationPlugin plugin) {
 492             plugins.register(plugin, true, allowOverwrite, declaringType, name, arg);
 493         }
 494 
 495         /**
 496          * Registers a plugin for an optional method with 2 arguments.
 497          *
 498          * @param name the name of the method
 499          * @param plugin the plugin to be registered
 500          */
 501         public void registerOptional2(String name, Type arg1, Type arg2, InvocationPlugin plugin) {
 502             plugins.register(plugin, true, allowOverwrite, declaringType, name, arg1, arg2);
 503         }
 504 
 505         /**
 506          * Registers a plugin for an optional method with 3 arguments.
 507          *
 508          * @param name the name of the method
 509          * @param plugin the plugin to be registered
 510          */
 511         public void registerOptional3(String name, Type arg1, Type arg2, Type arg3, InvocationPlugin plugin) {
 512             plugins.register(plugin, true, allowOverwrite, declaringType, name, arg1, arg2, arg3);
 513         }
 514 
 515         /**
 516          * Registers a plugin for an optional method with 4 arguments.
 517          *
 518          * @param name the name of the method
 519          * @param plugin the plugin to be registered
 520          */
 521         public void registerOptional4(String name, Type arg1, Type arg2, Type arg3, Type arg4, InvocationPlugin plugin) {
 522             plugins.register(plugin, true, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4);
 523         }
 524 
 525         /**
 526          * Registers a plugin that implements a method based on the bytecode of a substitute method.
 527          *
 528          * @param substituteDeclaringClass the class declaring the substitute method
 529          * @param name the name of both the original and substitute method
 530          * @param argumentTypes the argument types of the method. Element 0 of this array must be
 531          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
 532          *            is non-static. Upon returning, element 0 will have been rewritten to
 533          *            {@code declaringClass}
 534          */
 535         public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, Type... argumentTypes) {
 536             registerMethodSubstitution(substituteDeclaringClass, name, name, argumentTypes);
 537         }
 538 
 539         /**
 540          * Registers a plugin that implements a method based on the bytecode of a substitute method.
 541          *
 542          * @param substituteDeclaringClass the class declaring the substitute method
 543          * @param name the name of the original method
 544          * @param substituteName the name of the substitute method
 545          * @param argumentTypes the argument types of the method. Element 0 of this array must be
 546          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
 547          *            is non-static. Upon returning, element 0 will have been rewritten to
 548          *            {@code declaringClass}
 549          */
 550         public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type... argumentTypes) {
 551             doMethodSubstitutionRegistration(false, true, substituteDeclaringClass, name, substituteName, argumentTypes);
 552         }
 553 
 554         /**
 555          * Registers a plugin that implements a method based on the bytecode of a substitute method
 556          * that is conditinally enabled. This ensures that {@code Replacements} is aware of this
 557          * plugin.
 558          *
 559          * @param isEnabled whether the plugin is enabled in the current compiler
 560          * @param substituteDeclaringClass the class declaring the substitute method
 561          * @param name the name of both the original and substitute method
 562          * @param argumentTypes the argument types of the method. Element 0 of this array must be
 563          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
 564          *            is non-static. Upon returning, element 0 will have been rewritten to
 565          *            {@code declaringClass}
 566          */
 567         public void registerConditionalMethodSubstitution(boolean isEnabled, Class&lt;?&gt; substituteDeclaringClass, String name, Type... argumentTypes) {
 568             registerConditionalMethodSubstitution(isEnabled, substituteDeclaringClass, name, name, argumentTypes);
 569         }
 570 
 571         /**
 572          * Registers a plugin that implements a method based on the bytecode of a substitute method
 573          * that is conditinally enabled. This ensures that {@code Replacements} is aware of this
 574          * plugin.
 575          *
 576          * @param isEnabled whether the plugin is enabled in the current compiler
 577          * @param substituteDeclaringClass the class declaring the substitute method
 578          * @param name the name of the original method
 579          * @param substituteName the name of the substitute method
 580          * @param argumentTypes the argument types of the method. Element 0 of this array must be
 581          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
 582          *            is non-static. Upon returning, element 0 will have been rewritten to
 583          *            {@code declaringClass}
 584          */
 585         public void registerConditionalMethodSubstitution(boolean isEnabled, Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type... argumentTypes) {
 586             doMethodSubstitutionRegistration(true, isEnabled, substituteDeclaringClass, name, substituteName, argumentTypes);
 587         }
 588 
 589         private void doMethodSubstitutionRegistration(boolean isConditional, boolean isEnabled, Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type[] argumentTypes) {
 590             MethodSubstitutionPlugin plugin = new MethodSubstitutionPlugin(this, bytecodeProvider, name, substituteDeclaringClass, substituteName, argumentTypes);
 591             replacements.registerMethodSubstitution(plugin);
 592             if (isConditional) {
 593                 // Notify Replacements about the plugin even if it&#39;s not current enabled
 594                 replacements.registerConditionalPlugin(plugin);
 595             }
 596             if (isEnabled) {
 597                 plugins.register(plugin, false, allowOverwrite, declaringType, name, argumentTypes);
 598             }
 599         }
 600     }
 601 
 602     /**
 603      * Utility for registering plugins after Graal may have been initialized. Registrations made via
 604      * this class are not finalized until {@link #close} is called.
 605      */
 606     public static class LateRegistration implements AutoCloseable {
 607 
 608         private InvocationPlugins plugins;
 609         private final List&lt;Binding&gt; bindings = new ArrayList&lt;&gt;();
 610         private final Type declaringType;
 611 
 612         /**
 613          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
 614          * given class.
 615          *
 616          * @param plugins where to register the plugins
 617          * @param declaringType the class declaring the methods for which plugins will be registered
 618          *            via this object
 619          */
 620         public LateRegistration(InvocationPlugins plugins, Type declaringType) {
 621             this.plugins = plugins;
 622             this.declaringType = declaringType;
 623         }
 624 
 625         /**
 626          * Registers an invocation plugin for a given method. There must be no plugin currently
 627          * registered for {@code method}.
 628          *
 629          * @param argumentTypes the argument types of the method. Element 0 of this array must be
 630          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
 631          *            is non-static. Upon returning, element 0 will have been rewritten to
 632          *            {@code declaringClass}
 633          */
 634         public void register(InvocationPlugin plugin, String name, Type... argumentTypes) {
 635             assert plugins != null : String.format(&quot;Late registrations of invocation plugins for %s is already closed&quot;, declaringType);
 636             boolean isStatic = argumentTypes.length == 0 || argumentTypes[0] != InvocationPlugin.Receiver.class;
 637             if (!isStatic) {
 638                 argumentTypes[0] = declaringType;
 639             }
 640 
 641             assert isStatic || argumentTypes[0] == declaringType;
 642             Binding binding = new Binding(plugin, isStatic, name, argumentTypes);
 643             bindings.add(binding);
 644 
 645             assert IS_IN_NATIVE_IMAGE || Checks.check(this.plugins, declaringType, binding);
 646             assert IS_IN_NATIVE_IMAGE || Checks.checkResolvable(false, declaringType, binding);
 647         }
 648 
 649         @Override
 650         public void close() {
 651             assert plugins != null : String.format(&quot;Late registrations of invocation plugins for %s is already closed&quot;, declaringType);
 652             plugins.registerLate(declaringType, bindings);
 653             plugins = null;
 654         }
 655     }
 656 
 657     /**
 658      * Associates an {@link InvocationPlugin} with the details of a method it substitutes.
 659      */
 660     public static class Binding {
 661         /**
 662          * The plugin this binding is for.
 663          */
 664         public final InvocationPlugin plugin;
 665 
 666         /**
 667          * Specifies if the associated method is static.
 668          */
 669         public final boolean isStatic;
 670 
 671         /**
 672          * The name of the associated method.
 673          */
 674         public final String name;
 675 
 676         /**
 677          * A partial
 678          * &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.3&quot;&gt;method
 679          * descriptor&lt;/a&gt; for the associated method. The descriptor includes enclosing {@code &#39;(&#39;}
 680          * and {@code &#39;)&#39;} characters but omits the return type suffix.
 681          */
 682         public final String argumentsDescriptor;
 683 
 684         /**
 685          * Link in a list of bindings.
 686          */
 687         private Binding next;
 688 
 689         Binding(InvocationPlugin data, boolean isStatic, String name, Type... argumentTypes) {
 690             this.plugin = data;
 691             this.isStatic = isStatic;
 692             this.name = name;
 693             this.argumentsDescriptor = toArgumentDescriptor(isStatic, argumentTypes);
 694             assert !name.equals(&quot;&lt;init&gt;&quot;) || !isStatic : this;
 695         }
 696 
 697         Binding(ResolvedJavaMethod resolved, InvocationPlugin data) {
 698             this.plugin = data;
 699             this.isStatic = resolved.isStatic();
 700             this.name = resolved.getName();
 701             Signature sig = resolved.getSignature();
 702             String desc = sig.toMethodDescriptor();
 703             assert desc.indexOf(&#39;)&#39;) != -1 : desc;
 704             this.argumentsDescriptor = desc.substring(0, desc.indexOf(&#39;)&#39;) + 1);
 705             assert !name.equals(&quot;&lt;init&gt;&quot;) || !isStatic : this;
 706         }
 707 
 708         @Override
 709         public String toString() {
 710             return name + argumentsDescriptor;
 711         }
 712     }
 713 
 714     static String toArgumentDescriptor(boolean isStatic, Type[] argumentTypes) {
 715         StringBuilder buf = new StringBuilder();
 716         buf.append(&#39;(&#39;);
 717         for (int i = isStatic ? 0 : 1; i &lt; argumentTypes.length; i++) {
 718             buf.append(MetaUtil.toInternalName(argumentTypes[i].getTypeName()));
 719         }
 720         buf.append(&#39;)&#39;);
 721         return buf.toString();
 722     }
 723 
 724     /**
 725      * Plugin registrations for already resolved methods. If non-null, then {@link #registrations}
 726      * is null and no further registrations can be made.
 727      */
 728     private final UnmodifiableEconomicMap&lt;ResolvedJavaMethod, InvocationPlugin&gt; resolvedRegistrations;
 729 
 730     /**
 731      * Map from class names in {@linkplain MetaUtil#toInternalName(String) internal} form to the
 732      * invocation plugin bindings for the class. Tf non-null, then {@link #resolvedRegistrations}
 733      * will be null.
 734      */
 735     private final EconomicMap&lt;String, ClassPlugins&gt; registrations;
 736 
 737     /**
 738      * Deferred registrations as well as the guard for delimiting the initial registration phase.
 739      * The guard uses double-checked locking which is why this field is {@code volatile}.
 740      */
 741     private volatile List&lt;Runnable&gt; deferredRegistrations = new ArrayList&lt;&gt;();
 742 
 743     /**
 744      * Adds a {@link Runnable} for doing registration deferred until the first time
 745      * {@link #get(ResolvedJavaMethod)} or {@link #closeRegistration()} is called on this object.
 746      */
 747     public void defer(Runnable deferrable) {
 748         assert deferredRegistrations != null : &quot;registration is closed&quot;;
 749         deferredRegistrations.add(deferrable);
 750     }
 751 
 752     /**
 753      * Support for registering plugins once this object may be accessed by multiple threads.
 754      */
 755     private volatile LateClassPlugins lateRegistrations;
 756 
 757     /**
 758      * Per-class bindings.
 759      */
 760     static class ClassPlugins {
 761 
 762         /**
 763          * Maps method names to binding lists.
 764          */
 765         final EconomicMap&lt;String, Binding&gt; bindings = EconomicMap.create(Equivalence.DEFAULT);
 766 
 767         /**
 768          * Gets the invocation plugin for a given method.
 769          *
 770          * @return the invocation plugin for {@code method} or {@code null}
 771          */
 772         InvocationPlugin get(ResolvedJavaMethod method) {
 773             assert !method.isBridge();
 774             Binding binding = bindings.get(method.getName());
 775             while (binding != null) {
 776                 if (method.isStatic() == binding.isStatic) {
 777                     if (method.getSignature().toMethodDescriptor().startsWith(binding.argumentsDescriptor)) {
 778                         return binding.plugin;
 779                     }
 780                 }
 781                 binding = binding.next;
 782             }
 783             return null;
 784         }
 785 
 786         public void register(Binding binding, boolean allowOverwrite) {
 787             if (allowOverwrite) {
 788                 if (lookup(binding) != null) {
 789                     register(binding);
 790                     return;
 791                 }
 792             } else {
 793                 assert lookup(binding) == null : &quot;a value is already registered for &quot; + binding;
 794             }
 795             register(binding);
 796         }
 797 
 798         InvocationPlugin lookup(Binding binding) {
 799             Binding b = bindings.get(binding.name);
 800             while (b != null) {
 801                 if (b.isStatic == binding.isStatic &amp;&amp; b.argumentsDescriptor.equals(binding.argumentsDescriptor)) {
 802                     return b.plugin;
 803                 }
 804                 b = b.next;
 805             }
 806             return null;
 807         }
 808 
 809         /**
 810          * Registers {@code binding}.
 811          */
 812         void register(Binding binding) {
 813             Binding head = bindings.get(binding.name);
 814             assert binding.next == null;
 815             binding.next = head;
 816             bindings.put(binding.name, binding);
 817         }
 818     }
 819 
 820     static class LateClassPlugins extends ClassPlugins {
 821         static final String CLOSED_LATE_CLASS_PLUGIN = &quot;-----&quot;;
 822         private final String className;
 823         private final LateClassPlugins next;
 824 
 825         LateClassPlugins(LateClassPlugins next, String className) {
 826             assert next == null || next.className != CLOSED_LATE_CLASS_PLUGIN : &quot;Late registration of invocation plugins is closed&quot;;
 827             this.next = next;
 828             this.className = className;
 829         }
 830     }
 831 
 832     /**
 833      * Registers a binding of a method to an invocation plugin.
 834      *
 835      * @param plugin invocation plugin to be associated with the specified method
 836      * @param isStatic specifies if the method is static
 837      * @param declaringClass the class declaring the method
 838      * @param name the name of the method
 839      * @param argumentTypes the argument types of the method. Element 0 of this array must be
 840      *            {@code declaringClass} iff the method is non-static.
 841      * @return an object representing the method
 842      */
 843     Binding put(InvocationPlugin plugin, boolean isStatic, boolean allowOverwrite, Type declaringClass, String name, Type... argumentTypes) {
 844         assert resolvedRegistrations == null : &quot;registration is closed&quot;;
 845         String internalName = MetaUtil.toInternalName(declaringClass.getTypeName());
 846         assert isStatic || argumentTypes[0] == declaringClass;
 847         assert deferredRegistrations != null : &quot;initial registration is closed - use &quot; + LateRegistration.class.getName() + &quot; for late registrations&quot;;
 848 
 849         ClassPlugins classPlugins = registrations.get(internalName);
 850         if (classPlugins == null) {
 851             classPlugins = new ClassPlugins();
 852             registrations.put(internalName, classPlugins);
 853         }
 854         Binding binding = new Binding(plugin, isStatic, name, argumentTypes);
 855         classPlugins.register(binding, allowOverwrite);
 856         return binding;
 857     }
 858 
 859     InvocationPlugin get(ResolvedJavaMethod method) {
 860         if (resolvedRegistrations != null) {
 861             return resolvedRegistrations.get(method);
 862         } else {
 863             if (!method.isBridge()) {
 864                 ResolvedJavaType declaringClass = method.getDeclaringClass();
 865                 flushDeferrables();
 866                 String internalName = declaringClass.getName();
 867                 ClassPlugins classPlugins = registrations.get(internalName);
 868                 InvocationPlugin res = null;
 869                 if (classPlugins != null) {
 870                     res = classPlugins.get(method);
 871                 }
 872                 if (res == null) {
 873                     LateClassPlugins lcp = findLateClassPlugins(internalName);
 874                     if (lcp != null) {
 875                         res = lcp.get(method);
 876                     }
 877                 }
 878                 if (res != null) {
 879                     // A decorator plugin is trusted since it does not replace
 880                     // the method it intrinsifies. A GeneratedInvocationPlugin
 881                     // is trusted since it only exists for @NodeIntrinsics and
 882                     // @Fold annotated methods (i.e., trusted Graal code).
 883                     if (res.isDecorator() || res instanceof GeneratedInvocationPlugin || canBeIntrinsified(declaringClass)) {
 884                         return res;
 885                     }
 886                 }
 887                 if (testExtensions != null) {
 888                     // Avoid the synchronization in the common case that there
 889                     // are no test extensions.
 890                     synchronized (this) {
 891                         if (testExtensions != null) {
 892                             List&lt;Binding&gt; bindings = testExtensions.get(internalName);
 893                             if (bindings != null) {
 894                                 String name = method.getName();
 895                                 String descriptor = method.getSignature().toMethodDescriptor();
 896                                 for (Binding b : bindings) {
 897                                     if (b.isStatic == method.isStatic() &amp;&amp;
 898                                                     b.name.equals(name) &amp;&amp;
 899                                                     descriptor.startsWith(b.argumentsDescriptor)) {
 900                                         return b.plugin;
 901                                     }
 902                                 }
 903                             }
 904                         }
 905                     }
 906                 }
 907             } else {
 908                 // Supporting plugins for bridge methods would require including
 909                 // the return type in the registered signature. Until needed,
 910                 // this extra complexity is best avoided.
 911             }
 912         }
 913         return null;
 914     }
 915 
 916     /**
 917      * Determines if methods in a given class can have invocation plugins.
 918      *
 919      * @param declaringClass the class to test
 920      */
 921     public boolean canBeIntrinsified(ResolvedJavaType declaringClass) {
 922         return true;
 923     }
 924 
 925     LateClassPlugins findLateClassPlugins(String internalClassName) {
 926         for (LateClassPlugins lcp = lateRegistrations; lcp != null; lcp = lcp.next) {
 927             if (lcp.className.equals(internalClassName)) {
 928                 return lcp;
 929             }
 930         }
 931         return null;
 932     }
 933 
 934     @SuppressWarnings(&quot;serial&quot;)
 935     static class InvocationPluginRegistrationError extends GraalError {
 936         InvocationPluginRegistrationError(Throwable cause) {
 937             super(cause);
 938         }
 939     }
 940 
 941     private void flushDeferrables() {
 942         if (deferredRegistrations != null) {
 943             synchronized (this) {
 944                 if (deferredRegistrations != null) {
 945                     try {
 946                         for (Runnable deferrable : deferredRegistrations) {
 947                             deferrable.run();
 948                         }
 949                         deferredRegistrations = null;
 950                     } catch (InvocationPluginRegistrationError t) {
 951                         throw t;
 952                     } catch (Throwable t) {
 953                         /*
 954                          * Something went wrong during registration but it&#39;s possible we&#39;ll end up
 955                          * coming back into this code. nulling out deferredRegistrations would just
 956                          * cause other things to break and rerunning them would cause errors about
 957                          * already registered plugins, so rethrow the original exception during
 958                          * later invocations.
 959                          */
 960                         deferredRegistrations.clear();
 961                         Runnable rethrow = new Runnable() {
 962                             @Override
 963                             public void run() {
 964                                 throw new InvocationPluginRegistrationError(t);
 965                             }
 966                         };
 967                         deferredRegistrations.add(rethrow);
 968                         rethrow.run();
 969                     }
 970                 }
 971             }
 972         }
 973     }
 974 
 975     private volatile EconomicMap&lt;String, List&lt;Binding&gt;&gt; testExtensions;
 976 
 977     private static int findBinding(List&lt;Binding&gt; list, Binding key) {
 978         for (int i = 0; i &lt; list.size(); i++) {
 979             Binding b = list.get(i);
 980             if (b.isStatic == key.isStatic &amp;&amp; b.name.equals(key.name) &amp;&amp; b.argumentsDescriptor.equals(key.argumentsDescriptor)) {
 981                 return i;
 982             }
 983         }
 984         return -1;
 985     }
 986 
 987     /**
 988      * Extends the plugins in this object with those from {@code other}. The added plugins should be
 989      * {@linkplain #removeTestPlugins(InvocationPlugins) removed} after the test.
 990      *
 991      * This extension mechanism exists only for tests that want to add extra invocation plugins
 992      * after the compiler has been initialized.
 993      *
 994      * @param ignored if non-null, the bindings from {@code other} already in this object prior to
 995      *            calling this method are added to this list. These bindings are not added to this
 996      *            object.
 997      */
 998     public synchronized void addTestPlugins(InvocationPlugins other, List&lt;Pair&lt;String, Binding&gt;&gt; ignored) {
 999         assert resolvedRegistrations == null : &quot;registration is closed&quot;;
1000         EconomicMap&lt;String, List&lt;Binding&gt;&gt; otherBindings = other.getBindings(true, false);
1001         if (otherBindings.isEmpty()) {
1002             return;
1003         }
1004         if (testExtensions == null) {
1005             testExtensions = EconomicMap.create();
1006         }
1007         MapCursor&lt;String, List&lt;Binding&gt;&gt; c = otherBindings.getEntries();
1008         while (c.advance()) {
1009             String declaringClass = c.getKey();
1010             List&lt;Binding&gt; bindings = testExtensions.get(declaringClass);
1011             if (bindings == null) {
1012                 bindings = new ArrayList&lt;&gt;();
1013                 testExtensions.put(declaringClass, bindings);
1014             }
1015             for (Binding b : c.getValue()) {
1016                 int index = findBinding(bindings, b);
1017                 if (index != -1) {
1018                     if (ignored != null) {
1019                         ignored.add(Pair.create(declaringClass, b));
1020                     }
1021                 } else {
1022                     bindings.add(b);
1023                 }
1024             }
1025         }
1026     }
1027 
1028     /**
1029      * Removes the plugins from {@code other} in this object that were added by
1030      * {@link #addTestPlugins}.
1031      */
1032     public synchronized void removeTestPlugins(InvocationPlugins other) {
1033         assert resolvedRegistrations == null : &quot;registration is closed&quot;;
1034         if (testExtensions != null) {
1035             MapCursor&lt;String, List&lt;Binding&gt;&gt; c = other.getBindings(false).getEntries();
1036             while (c.advance()) {
1037                 String declaringClass = c.getKey();
1038                 List&lt;Binding&gt; bindings = testExtensions.get(declaringClass);
1039                 if (bindings != null) {
1040                     for (Binding b : c.getValue()) {
1041                         int index = findBinding(bindings, b);
1042                         if (index != -1) {
1043                             bindings.remove(index);
1044                         }
1045                     }
1046                     if (bindings.isEmpty()) {
1047                         testExtensions.removeKey(declaringClass);
1048                     }
1049                 }
1050             }
1051             if (testExtensions.isEmpty()) {
1052                 testExtensions = null;
1053             }
1054         }
1055     }
1056 
1057     synchronized void registerLate(Type declaringType, List&lt;Binding&gt; bindings) {
1058         String internalName = MetaUtil.toInternalName(declaringType.getTypeName());
1059         assert findLateClassPlugins(internalName) == null : &quot;Cannot have more than one late registration of invocation plugins for &quot; + internalName;
1060         LateClassPlugins lateClassPlugins = new LateClassPlugins(lateRegistrations, internalName);
1061         for (Binding b : bindings) {
1062             lateClassPlugins.register(b);
1063         }
1064         lateRegistrations = lateClassPlugins;
1065     }
1066 
1067     @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;string literal object identity used as sentinel&quot;)
1068     private synchronized boolean closeLateRegistrations() {
1069         if (lateRegistrations == null || lateRegistrations.className != CLOSED_LATE_CLASS_PLUGIN) {
1070             lateRegistrations = new LateClassPlugins(lateRegistrations, CLOSED_LATE_CLASS_PLUGIN);
1071         }
1072         return true;
1073     }
1074 
1075     /**
1076      * Processes deferred registrations and then closes this object for future registration.
1077      */
1078     public void closeRegistration() {
1079         assert closeLateRegistrations();
1080         flushDeferrables();
1081     }
1082 
1083     /**
1084      * Determines if this object currently contains any plugins (in any state of registration). If
1085      * this object has any {@link #defer(Runnable) deferred registrations}, it is assumed that
1086      * executing them will result in at least one plugin being registered.
1087      */
1088     public boolean isEmpty() {
1089         if (parent != null &amp;&amp; !parent.isEmpty()) {
1090             return false;
1091         }
1092         UnmodifiableEconomicMap&lt;ResolvedJavaMethod, InvocationPlugin&gt; resolvedRegs = resolvedRegistrations;
1093         if (resolvedRegs != null) {
1094             if (!resolvedRegs.isEmpty()) {
1095                 return false;
1096             }
1097         }
1098         List&lt;Runnable&gt; deferred = deferredRegistrations;
1099         if (deferred != null) {
1100             if (!deferred.isEmpty()) {
1101                 return false;
1102             }
1103         }
1104         for (LateClassPlugins late = lateRegistrations; late != null; late = late.next) {
1105             if (!late.bindings.isEmpty()) {
1106                 return false;
1107             }
1108         }
1109         return registrations.size() == 0;
1110     }
1111 
1112     /**
1113      * The plugins {@linkplain #lookupInvocation(ResolvedJavaMethod) searched} before searching in
1114      * this object.
1115      */
1116     protected final InvocationPlugins parent;
1117 
1118     /**
1119      * Creates a set of invocation plugins with no parent.
1120      */
1121     public InvocationPlugins() {
1122         this(null);
1123     }
1124 
1125     /**
1126      * Creates a set of invocation plugins.
1127      *
1128      * @param parent if non-null, this object will be searched first when looking up plugins
1129      */
1130     public InvocationPlugins(InvocationPlugins parent) {
1131         InvocationPlugins p = parent;
1132         this.parent = p;
1133         this.registrations = EconomicMap.create();
1134         this.resolvedRegistrations = null;
1135     }
1136 
1137     /**
1138      * Creates a closed set of invocation plugins for a set of resolved methods. Such an object
1139      * cannot have further plugins registered.
1140      */
1141     public InvocationPlugins(Map&lt;ResolvedJavaMethod, InvocationPlugin&gt; plugins, InvocationPlugins parent) {
1142         this.parent = parent;
1143         this.registrations = null;
1144         this.deferredRegistrations = null;
1145         EconomicMap&lt;ResolvedJavaMethod, InvocationPlugin&gt; map = EconomicMap.create(plugins.size());
1146 
1147         for (Map.Entry&lt;ResolvedJavaMethod, InvocationPlugin&gt; entry : plugins.entrySet()) {
1148             map.put(entry.getKey(), entry.getValue());
1149         }
1150         this.resolvedRegistrations = map;
1151     }
1152 
1153     protected void register(InvocationPlugin plugin, boolean isOptional, boolean allowOverwrite, Type declaringClass, String name, Type... argumentTypes) {
1154         boolean isStatic = argumentTypes.length == 0 || argumentTypes[0] != InvocationPlugin.Receiver.class;
1155         if (!isStatic) {
1156             argumentTypes[0] = declaringClass;
1157         }
1158         Binding binding = put(plugin, isStatic, allowOverwrite, declaringClass, name, argumentTypes);
1159         assert IS_IN_NATIVE_IMAGE || Checks.check(this, declaringClass, binding);
1160         assert IS_IN_NATIVE_IMAGE || Checks.checkResolvable(isOptional, declaringClass, binding);
1161     }
1162 
1163     /**
1164      * Registers an invocation plugin for a given method. There must be no plugin currently
1165      * registered for {@code method}.
1166      *
1167      * @param argumentTypes the argument types of the method. Element 0 of this array must be the
1168      *            {@link Class} value for {@link InvocationPlugin.Receiver} iff the method is
1169      *            non-static. Upon returning, element 0 will have been rewritten to
1170      *            {@code declaringClass}
1171      */
1172     public final void register(InvocationPlugin plugin, Type declaringClass, String name, Type... argumentTypes) {
1173         register(plugin, false, false, declaringClass, name, argumentTypes);
1174     }
1175 
1176     public final void register(InvocationPlugin plugin, String declaringClass, String name, Type... argumentTypes) {
1177         register(plugin, false, false, new OptionalLazySymbol(declaringClass), name, argumentTypes);
1178     }
1179 
1180     /**
1181      * Registers an invocation plugin for a given, optional method. There must be no plugin
1182      * currently registered for {@code method}.
1183      *
1184      * @param argumentTypes the argument types of the method. Element 0 of this array must be the
1185      *            {@link Class} value for {@link InvocationPlugin.Receiver} iff the method is
1186      *            non-static. Upon returning, element 0 will have been rewritten to
1187      *            {@code declaringClass}
1188      */
1189     public final void registerOptional(InvocationPlugin plugin, Type declaringClass, String name, Type... argumentTypes) {
1190         register(plugin, true, false, declaringClass, name, argumentTypes);
1191     }
1192 
1193     /**
1194      * Gets the plugin for a given method.
1195      *
1196      * @param method the method to lookup
1197      * @return the plugin associated with {@code method} or {@code null} if none exists
1198      */
1199     public InvocationPlugin lookupInvocation(ResolvedJavaMethod method) {
1200         if (parent != null) {
1201             InvocationPlugin plugin = parent.lookupInvocation(method);
1202             if (plugin != null) {
1203                 return plugin;
1204             }
1205         }
1206         InvocationPlugin invocationPlugin = get(method);
1207         return invocationPlugin;
1208     }
1209 
1210     /**
1211      * Gets the set of registered invocation plugins.
1212      *
1213      * @return a map from class names in {@linkplain MetaUtil#toInternalName(String) internal} form
1214      *         to the invocation plugin bindings for methods in the class
1215      */
1216     public EconomicMap&lt;String, List&lt;Binding&gt;&gt; getBindings(boolean includeParents) {
1217         return getBindings(includeParents, true);
1218     }
1219 
1220     /**
1221      * Gets the set of registered invocation plugins.
1222      *
1223      * @return a map from class names in {@linkplain MetaUtil#toInternalName(String) internal} form
1224      *         to the invocation plugin bindings for methods in the class
1225      */
1226     private EconomicMap&lt;String, List&lt;Binding&gt;&gt; getBindings(boolean includeParents, boolean flushDeferrables) {
1227         EconomicMap&lt;String, List&lt;Binding&gt;&gt; res = EconomicMap.create(Equivalence.DEFAULT);
1228         if (parent != null &amp;&amp; includeParents) {
1229             res.putAll(parent.getBindings(true, flushDeferrables));
1230         }
1231         if (resolvedRegistrations != null) {
1232             UnmodifiableMapCursor&lt;ResolvedJavaMethod, InvocationPlugin&gt; cursor = resolvedRegistrations.getEntries();
1233             while (cursor.advance()) {
1234                 ResolvedJavaMethod method = cursor.getKey();
1235                 InvocationPlugin plugin = cursor.getValue();
1236                 String type = method.getDeclaringClass().getName();
1237                 List&lt;Binding&gt; bindings = res.get(type);
1238                 if (bindings == null) {
1239                     bindings = new ArrayList&lt;&gt;();
1240                     res.put(type, bindings);
1241                 }
1242                 bindings.add(new Binding(method, plugin));
1243             }
1244         } else {
1245             if (flushDeferrables) {
1246                 flushDeferrables();
1247             }
1248             MapCursor&lt;String, ClassPlugins&gt; classes = registrations.getEntries();
1249             while (classes.advance()) {
1250                 String type = classes.getKey();
1251                 ClassPlugins cp = classes.getValue();
1252                 collectBindingsTo(res, type, cp);
1253             }
1254             for (LateClassPlugins lcp = lateRegistrations; lcp != null; lcp = lcp.next) {
1255                 String type = lcp.className;
1256                 collectBindingsTo(res, type, lcp);
1257             }
1258             if (testExtensions != null) {
1259                 // Avoid the synchronization in the common case that there
1260                 // are no test extensions.
1261                 synchronized (this) {
1262                     if (testExtensions != null) {
1263                         MapCursor&lt;String, List&lt;Binding&gt;&gt; c = testExtensions.getEntries();
1264                         while (c.advance()) {
1265                             String name = c.getKey();
1266                             List&lt;Binding&gt; bindings = res.get(name);
1267                             if (bindings == null) {
1268                                 bindings = new ArrayList&lt;&gt;();
1269                                 res.put(name, bindings);
1270                             }
1271                             bindings.addAll(c.getValue());
1272                         }
1273                     }
1274                 }
1275             }
1276         }
1277         return res;
1278     }
1279 
1280     private static void collectBindingsTo(EconomicMap&lt;String, List&lt;Binding&gt;&gt; res, String type, ClassPlugins cp) {
1281         MapCursor&lt;String, Binding&gt; methods = cp.bindings.getEntries();
1282         while (methods.advance()) {
1283             List&lt;Binding&gt; bindings = res.get(type);
1284             if (bindings == null) {
1285                 bindings = new ArrayList&lt;&gt;();
1286                 res.put(type, bindings);
1287             }
1288             for (Binding b = methods.getValue(); b != null; b = b.next) {
1289                 bindings.add(b);
1290             }
1291         }
1292     }
1293 
1294     /**
1295      * Gets the invocation plugins {@linkplain #lookupInvocation(ResolvedJavaMethod) searched}
1296      * before searching in this object.
1297      */
1298     public InvocationPlugins getParent() {
1299         return parent;
1300     }
1301 
1302     @Override
1303     public String toString() {
1304         UnmodifiableMapCursor&lt;String, List&lt;Binding&gt;&gt; entries = getBindings(false, false).getEntries();
1305         List&lt;String&gt; all = new ArrayList&lt;&gt;();
1306         while (entries.advance()) {
1307             String c = MetaUtil.internalNameToJava(entries.getKey(), true, false);
1308             for (Binding b : entries.getValue()) {
1309                 all.add(c + &#39;.&#39; + b);
1310             }
1311         }
1312         Collections.sort(all);
1313         StringBuilder buf = new StringBuilder();
1314         String nl = String.format(&quot;%n&quot;);
1315         for (String s : all) {
1316             if (buf.length() != 0) {
1317                 buf.append(nl);
1318             }
1319             buf.append(s);
1320         }
1321         if (parent != null) {
1322             if (buf.length() != 0) {
1323                 buf.append(nl);
1324             }
1325             buf.append(&quot;// parent&quot;).append(nl).append(parent);
1326         }
1327         return buf.toString();
1328     }
1329 
1330     /**
1331      * Code only used in assertions. Putting this in a separate class reduces class load time.
1332      */
1333     private static class Checks {
1334         private static final int MAX_ARITY = 7;
1335         /**
1336          * The set of all {@link InvocationPlugin#apply} method signatures.
1337          */
1338         static final Class&lt;?&gt;[][] SIGS;
1339 
1340         static {
1341             if (!Assertions.assertionsEnabled() &amp;&amp; !IS_BUILDING_NATIVE_IMAGE) {
1342                 throw new GraalError(&quot;%s must only be used in assertions&quot;, Checks.class.getName());
1343             }
1344             ArrayList&lt;Class&lt;?&gt;[]&gt; sigs = new ArrayList&lt;&gt;(MAX_ARITY);
1345             if (!IS_IN_NATIVE_IMAGE) {
1346                 for (Method method : InvocationPlugin.class.getDeclaredMethods()) {
1347                     if (!Modifier.isStatic(method.getModifiers()) &amp;&amp; method.getName().equals(&quot;apply&quot;)) {
1348                         Class&lt;?&gt;[] sig = method.getParameterTypes();
1349                         assert sig[0] == GraphBuilderContext.class;
1350                         assert sig[1] == ResolvedJavaMethod.class;
1351                         assert sig[2] == InvocationPlugin.Receiver.class;
1352                         assert Arrays.asList(sig).subList(3, sig.length).stream().allMatch(c -&gt; c == ValueNode.class);
1353                         while (sigs.size() &lt; sig.length - 2) {
1354                             sigs.add(null);
1355                         }
1356                         sigs.set(sig.length - 3, sig);
1357                     }
1358                 }
1359                 assert sigs.indexOf(null) == -1 : format(&quot;need to add an apply() method to %s that takes %d %s arguments &quot;, InvocationPlugin.class.getName(), sigs.indexOf(null),
1360                                 ValueNode.class.getSimpleName());
1361             }
1362             SIGS = sigs.toArray(new Class&lt;?&gt;[sigs.size()][]);
1363         }
1364 
1365         static boolean containsBinding(InvocationPlugins p, Type declaringType, Binding key) {
1366             String internalName = MetaUtil.toInternalName(declaringType.getTypeName());
1367             ClassPlugins classPlugins = p.registrations.get(internalName);
1368             return classPlugins != null &amp;&amp; classPlugins.lookup(key) != null;
1369         }
1370 
1371         public static boolean check(InvocationPlugins plugins, Type declaringType, Binding binding) {
1372             InvocationPlugin plugin = binding.plugin;
1373             InvocationPlugins p = plugins.parent;
1374             while (p != null) {
1375                 assert !containsBinding(p, declaringType, binding) : &quot;a plugin is already registered for &quot; + binding;
1376                 p = p.parent;
1377             }
1378             if (plugin instanceof ForeignCallPlugin || plugin instanceof GeneratedInvocationPlugin) {
1379                 return true;
1380             }
1381             if (plugin instanceof MethodSubstitutionPlugin) {
1382                 MethodSubstitutionPlugin msplugin = (MethodSubstitutionPlugin) plugin;
1383                 Method substitute = msplugin.getJavaSubstitute();
1384                 assert substitute.getAnnotation(MethodSubstitution.class) != null : format(&quot;Substitute method must be annotated with @%s: %s&quot;, MethodSubstitution.class.getSimpleName(), substitute);
1385                 return true;
1386             }
1387             int arguments = parseParameters(binding.argumentsDescriptor).size();
1388             assert arguments &lt; SIGS.length : format(&quot;need to extend %s to support method with %d arguments: %s&quot;, InvocationPlugin.class.getSimpleName(), arguments, binding);
1389             for (Method m : plugin.getClass().getDeclaredMethods()) {
1390                 if (m.getName().equals(&quot;apply&quot;)) {
1391                     Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();
1392                     if (Arrays.equals(SIGS[arguments], parameterTypes)) {
1393                         return true;
1394                     }
1395                 }
1396             }
1397             throw new AssertionError(format(&quot;graph builder plugin for %s not found&quot;, binding));
1398         }
1399 
1400         static boolean checkResolvable(boolean isOptional, Type declaringType, Binding binding) {
1401             if (declaringType instanceof ResolvedJavaSymbol) {
1402                 return checkResolvable(isOptional, ((ResolvedJavaSymbol) declaringType).getResolved(), binding);
1403             }
1404             Class&lt;?&gt; declaringClass = resolveType(declaringType, isOptional);
1405             if (declaringClass == null) {
1406                 return true;
1407             }
1408             if (binding.name.equals(&quot;&lt;init&gt;&quot;)) {
1409                 if (resolveConstructor(declaringClass, binding) == null &amp;&amp; !isOptional) {
1410                     throw new AssertionError(String.format(&quot;Constructor not found: %s%s&quot;, declaringClass.getName(), binding.argumentsDescriptor));
1411                 }
1412             } else {
1413                 if (resolveMethod(declaringClass, binding) == null &amp;&amp; !isOptional) {
1414                     throw new NoSuchMethodError(String.format(&quot;%s.%s%s&quot;, declaringClass.getName(), binding.name, binding.argumentsDescriptor));
1415                 }
1416             }
1417             return true;
1418         }
1419 
1420         private static boolean checkResolvable(boolean isOptional, ResolvedJavaType declaringType, Binding binding) {
1421             if (resolveJavaMethod(declaringType, binding) == null &amp;&amp; !isOptional) {
1422                 throw new AssertionError(String.format(&quot;Method not found: %s.%s%s&quot;, declaringType.toJavaName(), binding.name, binding.argumentsDescriptor));
1423             }
1424             return true;
1425         }
1426     }
1427 
1428     /**
1429      * Checks a set of nodes added to the graph by an {@link InvocationPlugin}.
1430      *
1431      * @param b the graph builder that applied the plugin
1432      * @param plugin a plugin that was just applied
1433      * @param newNodes the nodes added to the graph by {@code plugin}
1434      * @throws AssertionError if any check fail
1435      */
1436     public void checkNewNodes(GraphBuilderContext b, InvocationPlugin plugin, NodeIterable&lt;Node&gt; newNodes) {
1437         if (parent != null) {
1438             parent.checkNewNodes(b, plugin, newNodes);
1439         }
1440     }
1441 
1442     /**
1443      * Resolves a name to a class.
1444      *
1445      * @param className the name of the class to resolve
1446      * @param optional if true, resolution failure returns null
1447      * @return the resolved class or null if resolution fails and {@code optional} is true
1448      */
1449     public static Class&lt;?&gt; resolveClass(String className, boolean optional) {
1450         try {
1451             // Need to use the system class loader to handle classes
1452             // loaded by the application class loader which is not
1453             // delegated to by the JVMCI class loader.
1454             ClassLoader cl = ClassLoader.getSystemClassLoader();
1455             return Class.forName(className, false, cl);
1456         } catch (ClassNotFoundException e) {
1457             if (optional) {
1458                 return null;
1459             }
1460             throw new GraalError(&quot;Could not resolve type &quot; + className);
1461         }
1462     }
1463 
1464     /**
1465      * Resolves a {@link Type} to a {@link Class}.
1466      *
1467      * @param type the type to resolve
1468      * @param optional if true, resolution failure returns null
1469      * @return the resolved class or null if resolution fails and {@code optional} is true
1470      */
1471     public static Class&lt;?&gt; resolveType(Type type, boolean optional) {
1472         if (type instanceof Class) {
1473             return (Class&lt;?&gt;) type;
1474         }
1475         if (type instanceof OptionalLazySymbol) {
1476             return ((OptionalLazySymbol) type).resolve();
1477         }
1478         if (IS_IN_NATIVE_IMAGE) {
1479             throw new GraalError(&quot;Unresolved type in native image image:&quot; + type.getTypeName());
1480         }
1481         return resolveClass(type.getTypeName(), optional);
1482     }
1483 
1484     private static List&lt;String&gt; toInternalTypeNames(Class&lt;?&gt;[] types) {
1485         String[] res = new String[types.length];
1486         for (int i = 0; i &lt; types.length; i++) {
1487             res[i] = MetaUtil.toInternalName(types[i].getTypeName());
1488         }
1489         return Arrays.asList(res);
1490     }
1491 
1492     /**
1493      * Resolves a given binding to a method in a given class. If more than one method with the
1494      * parameter types matching {@code binding} is found and the return types of all the matching
1495      * methods form an inheritance chain, the one with the most specific type is returned; otherwise
1496      * {@link NoSuchMethodError} is thrown.
1497      *
1498      * @param declaringClass the class to search for a method matching {@code binding}
1499      * @return the method (if any) in {@code declaringClass} matching {@code binding}
1500      */
1501     public static Method resolveMethod(Class&lt;?&gt; declaringClass, Binding binding) {
1502         if (binding.name.equals(&quot;&lt;init&gt;&quot;)) {
1503             return null;
1504         }
1505         Method[] methods = declaringClass.getDeclaredMethods();
1506         List&lt;String&gt; parameterTypeNames = parseParameters(binding.argumentsDescriptor);
1507         Method match = null;
1508         for (int i = 0; i &lt; methods.length; ++i) {
1509             Method m = methods[i];
1510             if (binding.isStatic == Modifier.isStatic(m.getModifiers()) &amp;&amp;
1511                             m.getName().equals(binding.name) &amp;&amp;
1512                             parameterTypeNames.equals(toInternalTypeNames(m.getParameterTypes()))) {
1513                 if (match == null) {
1514                     match = m;
1515                 } else if (match.getReturnType().isAssignableFrom(m.getReturnType())) {
1516                     // `m` has a more specific return type - choose it
1517                     // (`match` is most likely a bridge method)
1518                     match = m;
1519                 } else {
1520                     if (!m.getReturnType().isAssignableFrom(match.getReturnType())) {
1521                         throw new NoSuchMethodError(String.format(
1522                                         &quot;Found 2 methods with same name and parameter types but unrelated return types:%n %s%n %s&quot;, match, m));
1523                     }
1524                 }
1525             }
1526         }
1527         return match;
1528     }
1529 
1530     /**
1531      * Same as {@link #resolveMethod(Class, Binding)} and
1532      * {@link #resolveConstructor(Class, Binding)} except in terms of {@link ResolvedJavaType} and
1533      * {@link ResolvedJavaMethod}.
1534      */
1535     public static ResolvedJavaMethod resolveJavaMethod(ResolvedJavaType declaringClass, Binding binding) {
1536         ResolvedJavaMethod[] methods = declaringClass.getDeclaredMethods();
1537         if (binding.name.equals(&quot;&lt;init&gt;&quot;)) {
1538             for (ResolvedJavaMethod m : methods) {
1539                 if (m.getName().equals(&quot;&lt;init&gt;&quot;) &amp;&amp; m.getSignature().toMethodDescriptor().startsWith(binding.argumentsDescriptor)) {
1540                     return m;
1541                 }
1542             }
1543             return null;
1544         }
1545 
1546         ResolvedJavaMethod match = null;
1547         for (int i = 0; i &lt; methods.length; ++i) {
1548             ResolvedJavaMethod m = methods[i];
1549             if (binding.isStatic == m.isStatic() &amp;&amp;
1550                             m.getName().equals(binding.name) &amp;&amp;
1551                             m.getSignature().toMethodDescriptor().startsWith(binding.argumentsDescriptor)) {
1552                 if (match == null) {
1553                     match = m;
1554                 } else {
1555                     final ResolvedJavaType matchReturnType = (ResolvedJavaType) match.getSignature().getReturnType(declaringClass);
1556                     final ResolvedJavaType mReturnType = (ResolvedJavaType) m.getSignature().getReturnType(declaringClass);
1557                     if (matchReturnType.isAssignableFrom(mReturnType)) {
1558                         // `m` has a more specific return type - choose it
1559                         // (`match` is most likely a bridge method)
1560                         match = m;
1561                     } else {
1562                         if (!mReturnType.isAssignableFrom(matchReturnType)) {
1563                             throw new NoSuchMethodError(String.format(
1564                                             &quot;Found 2 methods with same name and parameter types but unrelated return types:%n %s%n %s&quot;, match, m));
1565                         }
1566                     }
1567                 }
1568             }
1569         }
1570         return match;
1571     }
1572 
1573     /**
1574      * Resolves a given binding to a constructor in a given class.
1575      *
1576      * @param declaringClass the class to search for a constructor matching {@code binding}
1577      * @return the constructor (if any) in {@code declaringClass} matching binding
1578      */
1579     public static Constructor&lt;?&gt; resolveConstructor(Class&lt;?&gt; declaringClass, Binding binding) {
1580         if (!binding.name.equals(&quot;&lt;init&gt;&quot;)) {
1581             return null;
1582         }
1583         Constructor&lt;?&gt;[] constructors = declaringClass.getDeclaredConstructors();
1584         List&lt;String&gt; parameterTypeNames = parseParameters(binding.argumentsDescriptor);
1585         for (int i = 0; i &lt; constructors.length; ++i) {
1586             Constructor&lt;?&gt; c = constructors[i];
1587             if (parameterTypeNames.equals(toInternalTypeNames(c.getParameterTypes()))) {
1588                 return c;
1589             }
1590         }
1591         return null;
1592     }
1593 
1594     private static List&lt;String&gt; parseParameters(String argumentsDescriptor) {
1595         assert argumentsDescriptor.startsWith(&quot;(&quot;) &amp;&amp; argumentsDescriptor.endsWith(&quot;)&quot;) : argumentsDescriptor;
1596         List&lt;String&gt; res = new ArrayList&lt;&gt;();
1597         int cur = 1;
1598         int end = argumentsDescriptor.length() - 1;
1599         while (cur != end) {
1600             char first;
1601             int start = cur;
1602             do {
1603                 first = argumentsDescriptor.charAt(cur++);
1604             } while (first == &#39;[&#39;);
1605 
1606             switch (first) {
1607                 case &#39;L&#39;:
1608                     int endObject = argumentsDescriptor.indexOf(&#39;;&#39;, cur);
1609                     if (endObject == -1) {
1610                         throw new GraalError(&quot;Invalid object type at index %d in signature: %s&quot;, cur, argumentsDescriptor);
1611                     }
1612                     cur = endObject + 1;
1613                     break;
1614                 case &#39;V&#39;:
1615                 case &#39;I&#39;:
1616                 case &#39;B&#39;:
1617                 case &#39;C&#39;:
1618                 case &#39;D&#39;:
1619                 case &#39;F&#39;:
1620                 case &#39;J&#39;:
1621                 case &#39;S&#39;:
1622                 case &#39;Z&#39;:
1623                     break;
1624                 default:
1625                     throw new GraalError(&quot;Invalid character at index %d in signature: %s&quot;, cur, argumentsDescriptor);
1626             }
1627             res.add(argumentsDescriptor.substring(start, cur));
1628         }
1629         return res;
1630     }
1631 }
    </pre>
  </body>
</html>
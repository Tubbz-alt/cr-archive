<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/InvocationPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InvocationPlugin.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopExplosionPlugin.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/graphbuilderconf/InvocationPlugins.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,19 ***</span>
  import jdk.internal.vm.compiler.collections.MapCursor;
  import jdk.internal.vm.compiler.collections.Pair;
  import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
  import org.graalvm.compiler.api.replacements.MethodSubstitution;
<span class="line-removed">- import org.graalvm.compiler.api.replacements.MethodSubstitutionRegistry;</span>
  import org.graalvm.compiler.bytecode.BytecodeProvider;
  import org.graalvm.compiler.core.common.SuppressFBWarnings;
  import org.graalvm.compiler.debug.Assertions;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.iterators.NodeIterable;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
  
  import jdk.vm.ci.meta.MetaUtil;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.ResolvedJavaType;
  import jdk.vm.ci.meta.Signature;
<span class="line-new-header">--- 44,19 ---</span>
  import jdk.internal.vm.compiler.collections.MapCursor;
  import jdk.internal.vm.compiler.collections.Pair;
  import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
  import org.graalvm.compiler.api.replacements.MethodSubstitution;
  import org.graalvm.compiler.bytecode.BytecodeProvider;
  import org.graalvm.compiler.core.common.SuppressFBWarnings;
  import org.graalvm.compiler.debug.Assertions;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.iterators.NodeIterable;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
<span class="line-added">+ import org.graalvm.compiler.nodes.spi.Replacements;</span>
  
  import jdk.vm.ci.meta.MetaUtil;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.ResolvedJavaType;
  import jdk.vm.ci.meta.Signature;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,25 ***</span>
              return name;
          }
      }
  
      /**
<span class="line-modified">!      * Utility for {@linkplain InvocationPlugins#register(InvocationPlugin, Class, String, Class...)</span>
<span class="line-removed">-      * registration} of invocation plugins.</span>
       */
<span class="line-modified">!     public static class Registration implements MethodSubstitutionRegistry {</span>
  
          private final InvocationPlugins plugins;
          private final Type declaringType;
<span class="line-modified">!         private final BytecodeProvider methodSubstitutionBytecodeProvider;</span>
          private boolean allowOverwrite;
  
<span class="line-removed">-         @Override</span>
          public Class&lt;?&gt; getReceiverType() {
              return Receiver.class;
          }
  
          /**
           * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
           * given class.
           *
           * @param plugins where to register the plugins
<span class="line-new-header">--- 173,29 ---</span>
              return name;
          }
      }
  
      /**
<span class="line-modified">!      * Utility for {@linkplain InvocationPlugins#register registration} of invocation plugins.</span>
       */
<span class="line-modified">!     public static class Registration {</span>
  
          private final InvocationPlugins plugins;
<span class="line-added">+ </span>
          private final Type declaringType;
<span class="line-modified">!         private final Replacements replacements;</span>
<span class="line-added">+         private final BytecodeProvider bytecodeProvider;</span>
          private boolean allowOverwrite;
  
          public Class&lt;?&gt; getReceiverType() {
              return Receiver.class;
          }
  
<span class="line-added">+         public Type getDeclaringType() {</span>
<span class="line-added">+             return declaringType;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          /**
           * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
           * given class.
           *
           * @param plugins where to register the plugins
</pre>
<hr />
<pre>
<span class="line-old-header">*** 199,27 ***</span>
           *            via this object
           */
          public Registration(InvocationPlugins plugins, Type declaringType) {
              this.plugins = plugins;
              this.declaringType = declaringType;
<span class="line-modified">!             this.methodSubstitutionBytecodeProvider = null;</span>
          }
  
          /**
           * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
           * given class.
           *
           * @param plugins where to register the plugins
           * @param declaringType the class declaring the methods for which plugins will be registered
           *            via this object
<span class="line-modified">!          * @param methodSubstitutionBytecodeProvider provider used to get the bytecodes to parse for</span>
<span class="line-removed">-          *            method substitutions</span>
           */
<span class="line-modified">!         public Registration(InvocationPlugins plugins, Type declaringType, BytecodeProvider methodSubstitutionBytecodeProvider) {</span>
              this.plugins = plugins;
              this.declaringType = declaringType;
<span class="line-modified">!             this.methodSubstitutionBytecodeProvider = methodSubstitutionBytecodeProvider;</span>
          }
  
          /**
           * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
           * given class.
<span class="line-new-header">--- 203,44 ---</span>
           *            via this object
           */
          public Registration(InvocationPlugins plugins, Type declaringType) {
              this.plugins = plugins;
              this.declaringType = declaringType;
<span class="line-modified">!             this.replacements = null;</span>
<span class="line-added">+             this.bytecodeProvider = null;</span>
          }
  
          /**
           * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
           * given class.
           *
           * @param plugins where to register the plugins
           * @param declaringType the class declaring the methods for which plugins will be registered
           *            via this object
<span class="line-modified">!          * @param replacements the current Replacements provider</span>
           */
<span class="line-modified">!         public Registration(InvocationPlugins plugins, Type declaringType, Replacements replacements) {</span>
              this.plugins = plugins;
              this.declaringType = declaringType;
<span class="line-modified">!             this.replacements = replacements;</span>
<span class="line-added">+             this.bytecodeProvider = replacements != null ? replacements.getDefaultReplacementBytecodeProvider() : null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Creates an object for registering {@link InvocationPlugin}s for methods declared by a</span>
<span class="line-added">+          * given class.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param plugins where to register the plugins</span>
<span class="line-added">+          * @param declaringType the class declaring the methods for which plugins will be registered</span>
<span class="line-added">+          *            via this object</span>
<span class="line-added">+          * @param replacements the current Replacements provider</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public Registration(InvocationPlugins plugins, Type declaringType, Replacements replacements, BytecodeProvider bytecodeProvider) {</span>
<span class="line-added">+             this.plugins = plugins;</span>
<span class="line-added">+             this.declaringType = declaringType;</span>
<span class="line-added">+             this.replacements = replacements;</span>
<span class="line-added">+             this.bytecodeProvider = bytecodeProvider;</span>
          }
  
          /**
           * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
           * given class.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 229,27 ***</span>
           *            plugins will be registered via this object
           */
          public Registration(InvocationPlugins plugins, String declaringClassName) {
              this.plugins = plugins;
              this.declaringType = new OptionalLazySymbol(declaringClassName);
<span class="line-modified">!             this.methodSubstitutionBytecodeProvider = null;</span>
          }
  
          /**
           * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
           * given class.
           *
           * @param plugins where to register the plugins
           * @param declaringClassName the name of the class class declaring the methods for which
           *            plugins will be registered via this object
<span class="line-modified">!          * @param methodSubstitutionBytecodeProvider provider used to get the bytecodes to parse for</span>
<span class="line-removed">-          *            method substitutions</span>
           */
<span class="line-modified">!         public Registration(InvocationPlugins plugins, String declaringClassName, BytecodeProvider methodSubstitutionBytecodeProvider) {</span>
              this.plugins = plugins;
              this.declaringType = new OptionalLazySymbol(declaringClassName);
<span class="line-modified">!             this.methodSubstitutionBytecodeProvider = methodSubstitutionBytecodeProvider;</span>
          }
  
          /**
           * Configures this registration to allow or disallow overwriting of invocation plugins.
           */
<span class="line-new-header">--- 250,28 ---</span>
           *            plugins will be registered via this object
           */
          public Registration(InvocationPlugins plugins, String declaringClassName) {
              this.plugins = plugins;
              this.declaringType = new OptionalLazySymbol(declaringClassName);
<span class="line-modified">!             this.replacements = null;</span>
<span class="line-added">+             this.bytecodeProvider = null;</span>
          }
  
          /**
           * Creates an object for registering {@link InvocationPlugin}s for methods declared by a
           * given class.
           *
           * @param plugins where to register the plugins
           * @param declaringClassName the name of the class class declaring the methods for which
           *            plugins will be registered via this object
<span class="line-modified">!          * @param replacements the current Replacements provider</span>
           */
<span class="line-modified">!         public Registration(InvocationPlugins plugins, String declaringClassName, Replacements replacements) {</span>
              this.plugins = plugins;
              this.declaringType = new OptionalLazySymbol(declaringClassName);
<span class="line-modified">!             this.replacements = replacements;</span>
<span class="line-added">+             this.bytecodeProvider = replacements != null ? replacements.getDefaultReplacementBytecodeProvider() : null;</span>
          }
  
          /**
           * Configures this registration to allow or disallow overwriting of invocation plugins.
           */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 336,10 ***</span>
<span class="line-new-header">--- 358,122 ---</span>
           */
          public void register7(String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, Type arg7, InvocationPlugin plugin) {
              plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
          }
  
<span class="line-added">+         /**</span>
<span class="line-added">+          * Registers a plugin for a method with no arguments that is conditionally enabled. This</span>
<span class="line-added">+          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param name the name of the method</span>
<span class="line-added">+          * @param plugin the plugin to be registered</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public void registerConditional0(boolean isEnabled, String name, InvocationPlugin plugin) {</span>
<span class="line-added">+             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added">+             if (isEnabled) {</span>
<span class="line-added">+                 plugins.register(plugin, false, allowOverwrite, declaringType, name);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Registers a plugin for a method with 1 argument that is conditionally enabled. This</span>
<span class="line-added">+          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param name the name of the method</span>
<span class="line-added">+          * @param plugin the plugin to be registered</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public void registerConditional1(boolean isEnabled, String name, Type arg, InvocationPlugin plugin) {</span>
<span class="line-added">+             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added">+             if (isEnabled) {</span>
<span class="line-added">+                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Registers a plugin for a method with 2 arguments that is conditionally enabled. This</span>
<span class="line-added">+          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param name the name of the method</span>
<span class="line-added">+          * @param plugin the plugin to be registered</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public void registerConditional2(boolean isEnabled, String name, Type arg1, Type arg2, InvocationPlugin plugin) {</span>
<span class="line-added">+             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added">+             if (isEnabled) {</span>
<span class="line-added">+                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Registers a plugin for a method with 3 arguments that is conditionally enabled. This</span>
<span class="line-added">+          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param name the name of the method</span>
<span class="line-added">+          * @param plugin the plugin to be registered</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public void registerConditional3(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, InvocationPlugin plugin) {</span>
<span class="line-added">+             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added">+             if (isEnabled) {</span>
<span class="line-added">+                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Registers a plugin for a method with 4 arguments that is conditionally enabled. This</span>
<span class="line-added">+          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param name the name of the method</span>
<span class="line-added">+          * @param plugin the plugin to be registered</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public void registerConditional4(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, Type arg4, InvocationPlugin plugin) {</span>
<span class="line-added">+             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added">+             if (isEnabled) {</span>
<span class="line-added">+                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Registers a plugin for a method with 5 arguments that is conditionally enabled. This</span>
<span class="line-added">+          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param name the name of the method</span>
<span class="line-added">+          * @param plugin the plugin to be registered</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public void registerConditional5(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, InvocationPlugin plugin) {</span>
<span class="line-added">+             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added">+             if (isEnabled) {</span>
<span class="line-added">+                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Registers a plugin for a method with 6 arguments that is conditionally enabled. This</span>
<span class="line-added">+          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param name the name of the method</span>
<span class="line-added">+          * @param plugin the plugin to be registered</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public void registerConditional6(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, InvocationPlugin plugin) {</span>
<span class="line-added">+             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added">+             if (isEnabled) {</span>
<span class="line-added">+                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Registers a plugin for a method with 7 arguments that is conditionally enabled. This</span>
<span class="line-added">+          * ensures that {@code Replacements} is aware of this plugin.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param name the name of the method</span>
<span class="line-added">+          * @param plugin the plugin to be registered</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public void registerConditional7(boolean isEnabled, String name, Type arg1, Type arg2, Type arg3, Type arg4, Type arg5, Type arg6, Type arg7, InvocationPlugin plugin) {</span>
<span class="line-added">+             replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added">+             if (isEnabled) {</span>
<span class="line-added">+                 plugins.register(plugin, false, allowOverwrite, declaringType, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          /**
           * Registers a plugin for an optional method with no arguments.
           *
           * @param name the name of the method
           * @param plugin the plugin to be registered
</pre>
<hr />
<pre>
<span class="line-old-header">*** 396,38 ***</span>
           * @param argumentTypes the argument types of the method. Element 0 of this array must be
           *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
           *            is non-static. Upon returning, element 0 will have been rewritten to
           *            {@code declaringClass}
           */
<span class="line-removed">-         @Override</span>
          public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, Type... argumentTypes) {
              registerMethodSubstitution(substituteDeclaringClass, name, name, argumentTypes);
          }
  
          /**
           * Registers a plugin that implements a method based on the bytecode of a substitute method.
           *
           * @param substituteDeclaringClass the class declaring the substitute method
<span class="line-modified">!          * @param name the name of both the original method</span>
           * @param substituteName the name of the substitute method
           * @param argumentTypes the argument types of the method. Element 0 of this array must be
           *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
           *            is non-static. Upon returning, element 0 will have been rewritten to
           *            {@code declaringClass}
           */
<span class="line-removed">-         @Override</span>
          public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type... argumentTypes) {
<span class="line-modified">!             MethodSubstitutionPlugin plugin = createMethodSubstitution(substituteDeclaringClass, substituteName, argumentTypes);</span>
<span class="line-removed">-             plugins.register(plugin, false, allowOverwrite, declaringType, name, argumentTypes);</span>
          }
  
<span class="line-modified">!         public MethodSubstitutionPlugin createMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String substituteName, Type... argumentTypes) {</span>
<span class="line-modified">!             assert methodSubstitutionBytecodeProvider != null : &quot;Registration used for method substitutions requires a non-null methodSubstitutionBytecodeProvider&quot;;</span>
<span class="line-modified">!             MethodSubstitutionPlugin plugin = new MethodSubstitutionPlugin(methodSubstitutionBytecodeProvider, substituteDeclaringClass, substituteName, argumentTypes);</span>
<span class="line-modified">!             return plugin;</span>
          }
  
      }
  
      /**
       * Utility for registering plugins after Graal may have been initialized. Registrations made via
       * this class are not finalized until {@link #close} is called.
<span class="line-new-header">--- 530,75 ---</span>
           * @param argumentTypes the argument types of the method. Element 0 of this array must be
           *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
           *            is non-static. Upon returning, element 0 will have been rewritten to
           *            {@code declaringClass}
           */
          public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, Type... argumentTypes) {
              registerMethodSubstitution(substituteDeclaringClass, name, name, argumentTypes);
          }
  
          /**
           * Registers a plugin that implements a method based on the bytecode of a substitute method.
           *
           * @param substituteDeclaringClass the class declaring the substitute method
<span class="line-modified">!          * @param name the name of the original method</span>
           * @param substituteName the name of the substitute method
           * @param argumentTypes the argument types of the method. Element 0 of this array must be
           *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method
           *            is non-static. Upon returning, element 0 will have been rewritten to
           *            {@code declaringClass}
           */
          public void registerMethodSubstitution(Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type... argumentTypes) {
<span class="line-modified">!             doMethodSubstitutionRegistration(false, true, substituteDeclaringClass, name, substituteName, argumentTypes);</span>
          }
  
<span class="line-modified">!         /**</span>
<span class="line-modified">!          * Registers a plugin that implements a method based on the bytecode of a substitute method</span>
<span class="line-modified">!          * that is conditinally enabled. This ensures that {@code Replacements} is aware of this</span>
<span class="line-modified">!          * plugin.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param isEnabled whether the plugin is enabled in the current compiler</span>
<span class="line-added">+          * @param substituteDeclaringClass the class declaring the substitute method</span>
<span class="line-added">+          * @param name the name of both the original and substitute method</span>
<span class="line-added">+          * @param argumentTypes the argument types of the method. Element 0 of this array must be</span>
<span class="line-added">+          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method</span>
<span class="line-added">+          *            is non-static. Upon returning, element 0 will have been rewritten to</span>
<span class="line-added">+          *            {@code declaringClass}</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public void registerConditionalMethodSubstitution(boolean isEnabled, Class&lt;?&gt; substituteDeclaringClass, String name, Type... argumentTypes) {</span>
<span class="line-added">+             registerConditionalMethodSubstitution(isEnabled, substituteDeclaringClass, name, name, argumentTypes);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Registers a plugin that implements a method based on the bytecode of a substitute method</span>
<span class="line-added">+          * that is conditinally enabled. This ensures that {@code Replacements} is aware of this</span>
<span class="line-added">+          * plugin.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param isEnabled whether the plugin is enabled in the current compiler</span>
<span class="line-added">+          * @param substituteDeclaringClass the class declaring the substitute method</span>
<span class="line-added">+          * @param name the name of the original method</span>
<span class="line-added">+          * @param substituteName the name of the substitute method</span>
<span class="line-added">+          * @param argumentTypes the argument types of the method. Element 0 of this array must be</span>
<span class="line-added">+          *            the {@link Class} value for {@link InvocationPlugin.Receiver} iff the method</span>
<span class="line-added">+          *            is non-static. Upon returning, element 0 will have been rewritten to</span>
<span class="line-added">+          *            {@code declaringClass}</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public void registerConditionalMethodSubstitution(boolean isEnabled, Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type... argumentTypes) {</span>
<span class="line-added">+             doMethodSubstitutionRegistration(true, isEnabled, substituteDeclaringClass, name, substituteName, argumentTypes);</span>
          }
  
<span class="line-added">+         private void doMethodSubstitutionRegistration(boolean isConditional, boolean isEnabled, Class&lt;?&gt; substituteDeclaringClass, String name, String substituteName, Type[] argumentTypes) {</span>
<span class="line-added">+             MethodSubstitutionPlugin plugin = new MethodSubstitutionPlugin(this, bytecodeProvider, name, substituteDeclaringClass, substituteName, argumentTypes);</span>
<span class="line-added">+             replacements.registerMethodSubstitution(plugin);</span>
<span class="line-added">+             if (isConditional) {</span>
<span class="line-added">+                 // Notify Replacements about the plugin even if it&#39;s not current enabled</span>
<span class="line-added">+                 replacements.registerConditionalPlugin(plugin);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (isEnabled) {</span>
<span class="line-added">+                 plugins.register(plugin, false, allowOverwrite, declaringType, name, argumentTypes);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
      }
  
      /**
       * Utility for registering plugins after Graal may have been initialized. Registrations made via
       * this class are not finalized until {@link #close} is called.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 517,17 ***</span>
  
          Binding(InvocationPlugin data, boolean isStatic, String name, Type... argumentTypes) {
              this.plugin = data;
              this.isStatic = isStatic;
              this.name = name;
<span class="line-modified">!             StringBuilder buf = new StringBuilder();</span>
<span class="line-removed">-             buf.append(&#39;(&#39;);</span>
<span class="line-removed">-             for (int i = isStatic ? 0 : 1; i &lt; argumentTypes.length; i++) {</span>
<span class="line-removed">-                 buf.append(MetaUtil.toInternalName(argumentTypes[i].getTypeName()));</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             buf.append(&#39;)&#39;);</span>
<span class="line-removed">-             this.argumentsDescriptor = buf.toString();</span>
              assert !name.equals(&quot;&lt;init&gt;&quot;) || !isStatic : this;
          }
  
          Binding(ResolvedJavaMethod resolved, InvocationPlugin data) {
              this.plugin = data;
<span class="line-new-header">--- 688,11 ---</span>
  
          Binding(InvocationPlugin data, boolean isStatic, String name, Type... argumentTypes) {
              this.plugin = data;
              this.isStatic = isStatic;
              this.name = name;
<span class="line-modified">!             this.argumentsDescriptor = toArgumentDescriptor(isStatic, argumentTypes);</span>
              assert !name.equals(&quot;&lt;init&gt;&quot;) || !isStatic : this;
          }
  
          Binding(ResolvedJavaMethod resolved, InvocationPlugin data) {
              this.plugin = data;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 544,10 ***</span>
<span class="line-new-header">--- 709,20 ---</span>
          public String toString() {
              return name + argumentsDescriptor;
          }
      }
  
<span class="line-added">+     static String toArgumentDescriptor(boolean isStatic, Type[] argumentTypes) {</span>
<span class="line-added">+         StringBuilder buf = new StringBuilder();</span>
<span class="line-added">+         buf.append(&#39;(&#39;);</span>
<span class="line-added">+         for (int i = isStatic ? 0 : 1; i &lt; argumentTypes.length; i++) {</span>
<span class="line-added">+             buf.append(MetaUtil.toInternalName(argumentTypes[i].getTypeName()));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         buf.append(&#39;)&#39;);</span>
<span class="line-added">+         return buf.toString();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Plugin registrations for already resolved methods. If non-null, then {@link #registrations}
       * is null and no further registrations can be made.
       */
      private final UnmodifiableEconomicMap&lt;ResolvedJavaMethod, InvocationPlugin&gt; resolvedRegistrations;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 700,12 ***</span>
                          res = lcp.get(method);
                      }
                  }
                  if (res != null) {
                      // A decorator plugin is trusted since it does not replace
<span class="line-modified">!                     // the method it intrinsifies.</span>
<span class="line-modified">!                     if (res.isDecorator() || canBeIntrinsified(declaringClass)) {</span>
                          return res;
                      }
                  }
                  if (testExtensions != null) {
                      // Avoid the synchronization in the common case that there
<span class="line-new-header">--- 875,14 ---</span>
                          res = lcp.get(method);
                      }
                  }
                  if (res != null) {
                      // A decorator plugin is trusted since it does not replace
<span class="line-modified">!                     // the method it intrinsifies. A GeneratedInvocationPlugin</span>
<span class="line-modified">!                     // is trusted since it only exists for @NodeIntrinsics and</span>
<span class="line-added">+                     // @Fold annotated methods (i.e., trusted Graal code).</span>
<span class="line-added">+                     if (res.isDecorator() || res instanceof GeneratedInvocationPlugin || canBeIntrinsified(declaringClass)) {</span>
                          return res;
                      }
                  }
                  if (testExtensions != null) {
                      // Avoid the synchronization in the common case that there
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1021,22 ***</span>
       */
      public InvocationPlugin lookupInvocation(ResolvedJavaMethod method) {
          if (parent != null) {
              InvocationPlugin plugin = parent.lookupInvocation(method);
              if (plugin != null) {
<span class="line-removed">-                 if (IS_IN_NATIVE_IMAGE &amp;&amp; plugin instanceof MethodSubstitutionPlugin) {</span>
<span class="line-removed">-                     // Disable method substitutions until GR-13607</span>
<span class="line-removed">-                     return null;</span>
<span class="line-removed">-                 }</span>
                  return plugin;
              }
          }
          InvocationPlugin invocationPlugin = get(method);
<span class="line-removed">-         if (IS_IN_NATIVE_IMAGE &amp;&amp; invocationPlugin instanceof MethodSubstitutionPlugin) {</span>
<span class="line-removed">-             // Disable method substitutions until GR-13607</span>
<span class="line-removed">-             return null;</span>
<span class="line-removed">-         }</span>
          return invocationPlugin;
      }
  
      /**
       * Gets the set of registered invocation plugins.
<span class="line-new-header">--- 1198,14 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1230,21 ***</span>
  
          static boolean checkResolvable(boolean isOptional, Type declaringType, Binding binding) {
              if (declaringType instanceof ResolvedJavaSymbol) {
                  return checkResolvable(isOptional, ((ResolvedJavaSymbol) declaringType).getResolved(), binding);
              }
<span class="line-modified">!             Class&lt;?&gt; declaringClass = InvocationPlugins.resolveType(declaringType, isOptional);</span>
              if (declaringClass == null) {
                  return true;
              }
              if (binding.name.equals(&quot;&lt;init&gt;&quot;)) {
                  if (resolveConstructor(declaringClass, binding) == null &amp;&amp; !isOptional) {
                      throw new AssertionError(String.format(&quot;Constructor not found: %s%s&quot;, declaringClass.getName(), binding.argumentsDescriptor));
                  }
              } else {
                  if (resolveMethod(declaringClass, binding) == null &amp;&amp; !isOptional) {
<span class="line-modified">!                     throw new AssertionError(String.format(&quot;Method not found: %s.%s%s&quot;, declaringClass.getName(), binding.name, binding.argumentsDescriptor));</span>
                  }
              }
              return true;
          }
  
<span class="line-new-header">--- 1399,21 ---</span>
  
          static boolean checkResolvable(boolean isOptional, Type declaringType, Binding binding) {
              if (declaringType instanceof ResolvedJavaSymbol) {
                  return checkResolvable(isOptional, ((ResolvedJavaSymbol) declaringType).getResolved(), binding);
              }
<span class="line-modified">!             Class&lt;?&gt; declaringClass = resolveType(declaringType, isOptional);</span>
              if (declaringClass == null) {
                  return true;
              }
              if (binding.name.equals(&quot;&lt;init&gt;&quot;)) {
                  if (resolveConstructor(declaringClass, binding) == null &amp;&amp; !isOptional) {
                      throw new AssertionError(String.format(&quot;Constructor not found: %s%s&quot;, declaringClass.getName(), binding.argumentsDescriptor));
                  }
              } else {
                  if (resolveMethod(declaringClass, binding) == null &amp;&amp; !isOptional) {
<span class="line-modified">!                     throw new NoSuchMethodError(String.format(&quot;%s.%s%s&quot;, declaringClass.getName(), binding.name, binding.argumentsDescriptor));</span>
                  }
              }
              return true;
          }
  
</pre>
<center><a href="InvocationPlugin.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopExplosionPlugin.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
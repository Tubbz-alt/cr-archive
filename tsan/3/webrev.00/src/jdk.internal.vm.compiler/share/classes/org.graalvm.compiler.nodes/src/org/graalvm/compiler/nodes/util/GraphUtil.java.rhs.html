<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/util/GraphUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.nodes.util;
  26 
  27 import java.util.ArrayList;
  28 import java.util.Arrays;
  29 import java.util.Collection;
  30 import java.util.Collections;
  31 import java.util.Iterator;
  32 import java.util.List;
  33 import java.util.Objects;
  34 import java.util.function.BiFunction;
  35 
  36 import jdk.internal.vm.compiler.collections.EconomicMap;
  37 import jdk.internal.vm.compiler.collections.EconomicSet;
  38 import jdk.internal.vm.compiler.collections.Equivalence;
  39 import jdk.internal.vm.compiler.collections.MapCursor;
  40 import org.graalvm.compiler.bytecode.Bytecode;
  41 import org.graalvm.compiler.code.SourceStackTraceBailoutException;
  42 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
  43 import org.graalvm.compiler.core.common.type.ObjectStamp;
  44 import org.graalvm.compiler.debug.DebugContext;
  45 import org.graalvm.compiler.graph.Graph;
  46 import org.graalvm.compiler.graph.Node;
  47 import org.graalvm.compiler.graph.NodeBitMap;
  48 import org.graalvm.compiler.graph.NodeSourcePosition;
  49 import org.graalvm.compiler.graph.NodeStack;
  50 import org.graalvm.compiler.graph.Position;
  51 import org.graalvm.compiler.graph.iterators.NodeIterable;
  52 import org.graalvm.compiler.graph.spi.SimplifierTool;
  53 import org.graalvm.compiler.nodes.AbstractBeginNode;
  54 import org.graalvm.compiler.nodes.AbstractEndNode;
  55 import org.graalvm.compiler.nodes.AbstractMergeNode;
  56 import org.graalvm.compiler.nodes.ConstantNode;
<a name="2" id="anc2"></a><span class="line-added">  57 import org.graalvm.compiler.nodes.ControlSinkNode;</span>
  58 import org.graalvm.compiler.nodes.ControlSplitNode;
  59 import org.graalvm.compiler.nodes.FixedNode;
  60 import org.graalvm.compiler.nodes.FixedWithNextNode;
  61 import org.graalvm.compiler.nodes.FrameState;
  62 import org.graalvm.compiler.nodes.GuardNode;
<a name="3" id="anc3"></a><span class="line-added">  63 import org.graalvm.compiler.nodes.IfNode;</span>
  64 import org.graalvm.compiler.nodes.LoopBeginNode;
  65 import org.graalvm.compiler.nodes.LoopEndNode;
  66 import org.graalvm.compiler.nodes.LoopExitNode;
  67 import org.graalvm.compiler.nodes.NodeView;
  68 import org.graalvm.compiler.nodes.PhiNode;
  69 import org.graalvm.compiler.nodes.PiNode;
  70 import org.graalvm.compiler.nodes.ProxyNode;
  71 import org.graalvm.compiler.nodes.StateSplit;
  72 import org.graalvm.compiler.nodes.StructuredGraph;
  73 import org.graalvm.compiler.nodes.ValueNode;
  74 import org.graalvm.compiler.nodes.ValuePhiNode;
  75 import org.graalvm.compiler.nodes.ValueProxyNode;
  76 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
  77 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  78 import org.graalvm.compiler.nodes.java.MonitorIdNode;
  79 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
  80 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider.FindLengthMode;
  81 import org.graalvm.compiler.nodes.spi.LimitedValueProxy;
  82 import org.graalvm.compiler.nodes.spi.LoweringProvider;
  83 import org.graalvm.compiler.nodes.spi.ValueProxy;
  84 import org.graalvm.compiler.nodes.spi.VirtualizerTool;
  85 import org.graalvm.compiler.nodes.type.StampTool;
  86 import org.graalvm.compiler.nodes.virtual.VirtualArrayNode;
  87 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  88 import org.graalvm.compiler.options.Option;
  89 import org.graalvm.compiler.options.OptionKey;
  90 import org.graalvm.compiler.options.OptionType;
  91 import org.graalvm.compiler.options.OptionValues;
  92 
  93 import jdk.vm.ci.code.BailoutException;
  94 import jdk.vm.ci.code.BytecodePosition;
  95 import jdk.vm.ci.meta.Assumptions;
  96 import jdk.vm.ci.meta.Constant;
  97 import jdk.vm.ci.meta.ConstantReflectionProvider;
  98 import jdk.vm.ci.meta.JavaKind;
  99 import jdk.vm.ci.meta.MetaAccessProvider;
 100 import jdk.vm.ci.meta.ResolvedJavaMethod;
 101 import jdk.vm.ci.meta.ResolvedJavaType;
 102 
 103 public class GraphUtil {
 104 
 105     public static class Options {
 106         @Option(help = &quot;Verify that there are no new unused nodes when performing killCFG&quot;, type = OptionType.Debug)//
 107         public static final OptionKey&lt;Boolean&gt; VerifyKillCFGUnusedNodes = new OptionKey&lt;&gt;(false);
 108     }
 109 
<a name="4" id="anc4"></a><span class="line-added"> 110     public static final int MAX_FRAMESTATE_SEARCH_DEPTH = 4;</span>
<span class="line-added"> 111 </span>
 112     private static void killCFGInner(FixedNode node) {
 113         EconomicSet&lt;Node&gt; markedNodes = EconomicSet.create();
 114         EconomicMap&lt;AbstractMergeNode, List&lt;AbstractEndNode&gt;&gt; unmarkedMerges = EconomicMap.create();
 115 
 116         // Detach this node from CFG
 117         node.replaceAtPredecessor(null);
 118 
 119         markFixedNodes(node, markedNodes, unmarkedMerges);
 120 
 121         fixSurvivingAffectedMerges(markedNodes, unmarkedMerges);
 122 
 123         DebugContext debug = node.getDebug();
 124         debug.dump(DebugContext.DETAILED_LEVEL, node.graph(), &quot;After fixing merges (killCFG %s)&quot;, node);
 125 
 126         // Mark non-fixed nodes
 127         markUsages(markedNodes);
 128 
 129         // Detach marked nodes from non-marked nodes
 130         for (Node marked : markedNodes) {
 131             for (Node input : marked.inputs()) {
 132                 if (!markedNodes.contains(input)) {
 133                     marked.replaceFirstInput(input, null);
 134                     tryKillUnused(input);
 135                 }
 136             }
 137         }
 138         debug.dump(DebugContext.VERY_DETAILED_LEVEL, node.graph(), &quot;After disconnecting non-marked inputs (killCFG %s)&quot;, node);
 139         // Kill marked nodes
 140         for (Node marked : markedNodes) {
 141             if (marked.isAlive()) {
 142                 marked.markDeleted();
 143             }
 144         }
 145     }
 146 
 147     private static void markFixedNodes(FixedNode node, EconomicSet&lt;Node&gt; markedNodes, EconomicMap&lt;AbstractMergeNode, List&lt;AbstractEndNode&gt;&gt; unmarkedMerges) {
 148         NodeStack workStack = new NodeStack();
 149         workStack.push(node);
 150         while (!workStack.isEmpty()) {
 151             Node fixedNode = workStack.pop();
 152             markedNodes.add(fixedNode);
 153             if (fixedNode instanceof AbstractMergeNode) {
 154                 unmarkedMerges.removeKey((AbstractMergeNode) fixedNode);
 155             }
 156             while (fixedNode instanceof FixedWithNextNode) {
 157                 fixedNode = ((FixedWithNextNode) fixedNode).next();
 158                 if (fixedNode != null) {
 159                     markedNodes.add(fixedNode);
 160                 }
 161             }
 162             if (fixedNode instanceof ControlSplitNode) {
 163                 for (Node successor : fixedNode.successors()) {
 164                     workStack.push(successor);
 165                 }
 166             } else if (fixedNode instanceof AbstractEndNode) {
 167                 AbstractEndNode end = (AbstractEndNode) fixedNode;
 168                 AbstractMergeNode merge = end.merge();
 169                 if (merge != null) {
 170                     assert !markedNodes.contains(merge) || (merge instanceof LoopBeginNode &amp;&amp; end instanceof LoopEndNode) : merge;
 171                     if (merge instanceof LoopBeginNode) {
 172                         if (end == ((LoopBeginNode) merge).forwardEnd()) {
 173                             workStack.push(merge);
 174                             continue;
 175                         }
 176                         if (markedNodes.contains(merge)) {
 177                             continue;
 178                         }
 179                     }
 180                     List&lt;AbstractEndNode&gt; endsSeen = unmarkedMerges.get(merge);
 181                     if (endsSeen == null) {
 182                         endsSeen = new ArrayList&lt;&gt;(merge.forwardEndCount());
 183                         unmarkedMerges.put(merge, endsSeen);
 184                     }
 185                     endsSeen.add(end);
 186                     if (!(end instanceof LoopEndNode) &amp;&amp; endsSeen.size() == merge.forwardEndCount()) {
 187                         assert merge.forwardEnds().filter(n -&gt; !markedNodes.contains(n)).isEmpty();
 188                         // all this merge&#39;s forward ends are marked: it needs to be killed
 189                         workStack.push(merge);
 190                     }
 191                 }
 192             }
 193         }
 194     }
 195 
 196     private static void fixSurvivingAffectedMerges(EconomicSet&lt;Node&gt; markedNodes, EconomicMap&lt;AbstractMergeNode, List&lt;AbstractEndNode&gt;&gt; unmarkedMerges) {
 197         MapCursor&lt;AbstractMergeNode, List&lt;AbstractEndNode&gt;&gt; cursor = unmarkedMerges.getEntries();
 198         while (cursor.advance()) {
 199             AbstractMergeNode merge = cursor.getKey();
 200             for (AbstractEndNode end : cursor.getValue()) {
 201                 merge.removeEnd(end);
 202             }
 203             if (merge.phiPredecessorCount() == 1) {
 204                 if (merge instanceof LoopBeginNode) {
 205                     LoopBeginNode loopBegin = (LoopBeginNode) merge;
 206                     assert merge.forwardEndCount() == 1;
 207                     for (LoopExitNode loopExit : loopBegin.loopExits().snapshot()) {
 208                         if (markedNodes.contains(loopExit)) {
 209                             /*
 210                              * disconnect from loop begin so that reduceDegenerateLoopBegin doesn&#39;t
 211                              * transform it into a new beginNode
 212                              */
 213                             loopExit.replaceFirstInput(loopBegin, null);
 214                         }
 215                     }
 216                     merge.graph().reduceDegenerateLoopBegin(loopBegin);
 217                 } else {
 218                     merge.graph().reduceTrivialMerge(merge);
 219                 }
 220             } else {
 221                 assert merge.phiPredecessorCount() &gt; 1 : merge;
 222             }
 223         }
 224     }
 225 
 226     private static void markUsages(EconomicSet&lt;Node&gt; markedNodes) {
 227         NodeStack workStack = new NodeStack(markedNodes.size() + 4);
 228         for (Node marked : markedNodes) {
 229             workStack.push(marked);
 230         }
 231         while (!workStack.isEmpty()) {
 232             Node marked = workStack.pop();
 233             for (Node usage : marked.usages()) {
 234                 if (!markedNodes.contains(usage)) {
 235                     workStack.push(usage);
 236                     markedNodes.add(usage);
 237                 }
 238             }
 239         }
 240     }
 241 
 242     @SuppressWarnings(&quot;try&quot;)
 243     public static void killCFG(FixedNode node) {
 244         DebugContext debug = node.getDebug();
 245         try (DebugContext.Scope scope = debug.scope(&quot;KillCFG&quot;, node)) {
 246             EconomicSet&lt;Node&gt; unusedNodes = null;
 247             EconomicSet&lt;Node&gt; unsafeNodes = null;
 248             Graph.NodeEventScope nodeEventScope = null;
 249             OptionValues options = node.getOptions();
<a name="5" id="anc5"></a><span class="line-modified"> 250             boolean verifyGraalGraphEdges = Graph.Options.VerifyGraalGraphEdges.getValue(options);</span>
<span class="line-added"> 251             boolean verifyKillCFGUnusedNodes = GraphUtil.Options.VerifyKillCFGUnusedNodes.getValue(options);</span>
<span class="line-added"> 252             if (verifyGraalGraphEdges) {</span>
 253                 unsafeNodes = collectUnsafeNodes(node.graph());
 254             }
<a name="6" id="anc6"></a><span class="line-modified"> 255             if (verifyKillCFGUnusedNodes) {</span>
 256                 EconomicSet&lt;Node&gt; collectedUnusedNodes = unusedNodes = EconomicSet.create(Equivalence.IDENTITY);
 257                 nodeEventScope = node.graph().trackNodeEvents(new Graph.NodeEventListener() {
 258                     @Override
 259                     public void changed(Graph.NodeEvent e, Node n) {
 260                         if (e == Graph.NodeEvent.ZERO_USAGES &amp;&amp; isFloatingNode(n) &amp;&amp; !(n instanceof GuardNode)) {
 261                             collectedUnusedNodes.add(n);
 262                         }
 263                     }
 264                 });
 265             }
 266             debug.dump(DebugContext.VERY_DETAILED_LEVEL, node.graph(), &quot;Before killCFG %s&quot;, node);
 267             killCFGInner(node);
 268             debug.dump(DebugContext.VERY_DETAILED_LEVEL, node.graph(), &quot;After killCFG %s&quot;, node);
<a name="7" id="anc7"></a><span class="line-modified"> 269             if (verifyGraalGraphEdges) {</span>
 270                 EconomicSet&lt;Node&gt; newUnsafeNodes = collectUnsafeNodes(node.graph());
 271                 newUnsafeNodes.removeAll(unsafeNodes);
 272                 assert newUnsafeNodes.isEmpty() : &quot;New unsafe nodes: &quot; + newUnsafeNodes;
 273             }
<a name="8" id="anc8"></a><span class="line-modified"> 274             if (verifyKillCFGUnusedNodes) {</span>
 275                 nodeEventScope.close();
 276                 Iterator&lt;Node&gt; iterator = unusedNodes.iterator();
 277                 while (iterator.hasNext()) {
 278                     Node curNode = iterator.next();
 279                     if (curNode.isDeleted()) {
 280                         iterator.remove();
 281                     }
 282                 }
 283                 assert unusedNodes.isEmpty() : &quot;New unused nodes: &quot; + unusedNodes;
 284             }
 285         } catch (Throwable t) {
 286             throw debug.handle(t);
 287         }
 288     }
 289 
 290     /**
 291      * Collects all node in the graph which have non-optional inputs that are null.
 292      */
 293     private static EconomicSet&lt;Node&gt; collectUnsafeNodes(Graph graph) {
 294         EconomicSet&lt;Node&gt; unsafeNodes = EconomicSet.create(Equivalence.IDENTITY);
 295         for (Node n : graph.getNodes()) {
 296             for (Position pos : n.inputPositions()) {
 297                 Node input = pos.get(n);
 298                 if (input == null) {
 299                     if (!pos.isInputOptional()) {
 300                         unsafeNodes.add(n);
 301                     }
 302                 }
 303             }
 304         }
 305         return unsafeNodes;
 306     }
 307 
 308     public static boolean isFloatingNode(Node n) {
 309         return !(n instanceof FixedNode);
 310     }
 311 
 312     private static boolean checkKill(Node node, boolean mayKillGuard) {
 313         node.assertTrue(mayKillGuard || !(node instanceof GuardNode), &quot;must not be a guard node %s&quot;, node);
 314         node.assertTrue(node.isAlive(), &quot;must be alive&quot;);
 315         node.assertTrue(node.hasNoUsages(), &quot;cannot kill node %s because of usages: %s&quot;, node, node.usages());
 316         node.assertTrue(node.predecessor() == null, &quot;cannot kill node %s because of predecessor: %s&quot;, node, node.predecessor());
 317         return true;
 318     }
 319 
 320     public static void killWithUnusedFloatingInputs(Node node) {
 321         killWithUnusedFloatingInputs(node, false);
 322     }
 323 
 324     public static void killWithUnusedFloatingInputs(Node node, boolean mayKillGuard) {
 325         assert checkKill(node, mayKillGuard);
 326         node.markDeleted();
 327         outer: for (Node in : node.inputs()) {
 328             if (in.isAlive()) {
 329                 in.removeUsage(node);
 330                 if (in.hasNoUsages()) {
 331                     node.maybeNotifyZeroUsages(in);
 332                 }
 333                 if (isFloatingNode(in)) {
 334                     if (in.hasNoUsages()) {
 335                         if (in instanceof GuardNode) {
 336                             // Guard nodes are only killed if their anchor dies.
 337                         } else {
 338                             killWithUnusedFloatingInputs(in);
 339                         }
 340                     } else if (in instanceof PhiNode) {
 341                         for (Node use : in.usages()) {
 342                             if (use != in) {
 343                                 continue outer;
 344                             }
 345                         }
 346                         in.replaceAtUsages(null);
 347                         killWithUnusedFloatingInputs(in);
 348                     }
 349                 }
 350             }
 351         }
 352     }
 353 
 354     /**
 355      * Removes all nodes created after the {@code mark}, assuming no &quot;old&quot; nodes point to &quot;new&quot;
 356      * nodes.
 357      */
 358     public static void removeNewNodes(Graph graph, Graph.Mark mark) {
 359         assert checkNoOldToNewEdges(graph, mark);
 360         for (Node n : graph.getNewNodes(mark)) {
 361             n.markDeleted();
 362             for (Node in : n.inputs()) {
 363                 in.removeUsage(n);
 364             }
 365         }
 366     }
 367 
 368     private static boolean checkNoOldToNewEdges(Graph graph, Graph.Mark mark) {
 369         for (Node old : graph.getNodes()) {
 370             if (graph.isNew(mark, old)) {
 371                 break;
 372             }
 373             for (Node n : old.successors()) {
 374                 assert !graph.isNew(mark, n) : old + &quot; -&gt; &quot; + n;
 375             }
 376             for (Node n : old.inputs()) {
 377                 assert !graph.isNew(mark, n) : old + &quot; -&gt; &quot; + n;
 378             }
 379         }
 380         return true;
 381     }
 382 
 383     public static void removeFixedWithUnusedInputs(FixedWithNextNode fixed) {
 384         if (fixed instanceof StateSplit) {
 385             FrameState stateAfter = ((StateSplit) fixed).stateAfter();
 386             if (stateAfter != null) {
 387                 ((StateSplit) fixed).setStateAfter(null);
 388                 if (stateAfter.hasNoUsages()) {
 389                     killWithUnusedFloatingInputs(stateAfter);
 390                 }
 391             }
 392         }
 393         unlinkFixedNode(fixed);
 394         killWithUnusedFloatingInputs(fixed);
 395     }
 396 
 397     public static void unlinkFixedNode(FixedWithNextNode fixed) {
 398         assert fixed.next() != null &amp;&amp; fixed.predecessor() != null &amp;&amp; fixed.isAlive() : fixed;
 399         FixedNode next = fixed.next();
 400         fixed.setNext(null);
 401         fixed.replaceAtPredecessor(next);
 402     }
 403 
 404     public static void checkRedundantPhi(PhiNode phiNode) {
 405         if (phiNode.isDeleted() || phiNode.valueCount() == 1) {
 406             return;
 407         }
 408 
 409         ValueNode singleValue = phiNode.singleValueOrThis();
 410         if (singleValue != phiNode) {
 411             Collection&lt;PhiNode&gt; phiUsages = phiNode.usages().filter(PhiNode.class).snapshot();
 412             Collection&lt;ProxyNode&gt; proxyUsages = phiNode.usages().filter(ProxyNode.class).snapshot();
 413             phiNode.replaceAtUsagesAndDelete(singleValue);
 414             for (PhiNode phi : phiUsages) {
 415                 checkRedundantPhi(phi);
 416             }
 417             for (ProxyNode proxy : proxyUsages) {
 418                 checkRedundantProxy(proxy);
 419             }
 420         }
 421     }
 422 
 423     public static void checkRedundantProxy(ProxyNode vpn) {
 424         if (vpn.isDeleted()) {
 425             return;
 426         }
 427         AbstractBeginNode proxyPoint = vpn.proxyPoint();
 428         if (proxyPoint instanceof LoopExitNode) {
 429             LoopExitNode exit = (LoopExitNode) proxyPoint;
 430             LoopBeginNode loopBegin = exit.loopBegin();
 431             Node vpnValue = vpn.value();
 432             for (ValueNode v : loopBegin.stateAfter().values()) {
 433                 ValueNode v2 = v;
 434                 if (loopBegin.isPhiAtMerge(v2)) {
 435                     v2 = ((PhiNode) v2).valueAt(loopBegin.forwardEnd());
 436                 }
 437                 if (vpnValue == v2) {
 438                     Collection&lt;PhiNode&gt; phiUsages = vpn.usages().filter(PhiNode.class).snapshot();
 439                     Collection&lt;ProxyNode&gt; proxyUsages = vpn.usages().filter(ProxyNode.class).snapshot();
 440                     vpn.replaceAtUsagesAndDelete(vpnValue);
 441                     for (PhiNode phi : phiUsages) {
 442                         checkRedundantPhi(phi);
 443                     }
 444                     for (ProxyNode proxy : proxyUsages) {
 445                         checkRedundantProxy(proxy);
 446                     }
 447                     return;
 448                 }
 449             }
 450         }
 451     }
 452 
 453     /**
 454      * Remove loop header without loop ends. This can happen with degenerated loops like this one:
 455      *
 456      * &lt;pre&gt;
 457      * for (;;) {
 458      *     try {
 459      *         break;
 460      *     } catch (UnresolvedException iioe) {
 461      *     }
 462      * }
 463      * &lt;/pre&gt;
 464      */
 465     public static void normalizeLoops(StructuredGraph graph) {
 466         boolean loopRemoved = false;
 467         for (LoopBeginNode begin : graph.getNodes(LoopBeginNode.TYPE)) {
 468             if (begin.loopEnds().isEmpty()) {
 469                 assert begin.forwardEndCount() == 1;
 470                 graph.reduceDegenerateLoopBegin(begin);
 471                 loopRemoved = true;
 472             } else {
 473                 normalizeLoopBegin(begin);
 474             }
 475         }
 476 
 477         if (loopRemoved) {
 478             /*
 479              * Removing a degenerated loop can make non-loop phi functions unnecessary. Therefore,
 480              * we re-check all phi functions and remove redundant ones.
 481              */
 482             for (Node node : graph.getNodes()) {
 483                 if (node instanceof PhiNode) {
 484                     checkRedundantPhi((PhiNode) node);
 485                 }
 486             }
 487         }
 488     }
 489 
 490     private static void normalizeLoopBegin(LoopBeginNode begin) {
 491         // Delete unnecessary loop phi functions, i.e., phi functions where all inputs are either
 492         // the same or the phi itself.
 493         for (PhiNode phi : begin.phis().snapshot()) {
 494             GraphUtil.checkRedundantPhi(phi);
 495         }
 496         for (LoopExitNode exit : begin.loopExits()) {
 497             for (ProxyNode vpn : exit.proxies().snapshot()) {
 498                 GraphUtil.checkRedundantProxy(vpn);
 499             }
 500         }
 501     }
 502 
 503     /**
 504      * Gets an approximate source code location for a node if possible.
 505      *
 506      * @return the StackTraceElements if an approximate source location is found, null otherwise
 507      */
 508     public static StackTraceElement[] approxSourceStackTraceElement(Node node) {
 509         NodeSourcePosition position = node.getNodeSourcePosition();
 510         if (position != null) {
 511             // use GraphBuilderConfiguration and enable trackNodeSourcePosition to get better source
 512             // positions.
 513             return approxSourceStackTraceElement(position);
 514         }
 515         ArrayList&lt;StackTraceElement&gt; elements = new ArrayList&lt;&gt;();
 516         Node n = node;
 517         while (n != null) {
 518             if (n instanceof MethodCallTargetNode) {
 519                 elements.add(((MethodCallTargetNode) n).targetMethod().asStackTraceElement(-1));
 520                 n = ((MethodCallTargetNode) n).invoke().asNode();
 521             }
 522 
 523             if (n instanceof StateSplit) {
 524                 FrameState state = ((StateSplit) n).stateAfter();
 525                 elements.addAll(Arrays.asList(approxSourceStackTraceElement(state)));
 526                 break;
 527             }
 528             n = n.predecessor();
 529         }
 530         return elements.toArray(new StackTraceElement[elements.size()]);
 531     }
 532 
 533     /**
 534      * Gets an approximate source code location for frame state.
 535      *
 536      * @return the StackTraceElements if an approximate source location is found, null otherwise
 537      */
 538     public static StackTraceElement[] approxSourceStackTraceElement(FrameState frameState) {
 539         ArrayList&lt;StackTraceElement&gt; elements = new ArrayList&lt;&gt;();
 540         FrameState state = frameState;
 541         while (state != null) {
 542             Bytecode code = state.getCode();
 543             if (code != null) {
 544                 elements.add(code.asStackTraceElement(state.bci - 1));
 545             }
 546             state = state.outerFrameState();
 547         }
 548         return elements.toArray(new StackTraceElement[0]);
 549     }
 550 
 551     /**
 552      * Gets approximate stack trace elements for a bytecode position.
 553      */
 554     public static StackTraceElement[] approxSourceStackTraceElement(BytecodePosition bytecodePosition) {
 555         ArrayList&lt;StackTraceElement&gt; elements = new ArrayList&lt;&gt;();
 556         BytecodePosition position = bytecodePosition;
 557         while (position != null) {
 558             ResolvedJavaMethod method = position.getMethod();
 559             if (method != null) {
 560                 elements.add(method.asStackTraceElement(position.getBCI()));
 561             }
 562             position = position.getCaller();
 563         }
 564         return elements.toArray(new StackTraceElement[0]);
 565     }
 566 
 567     /**
 568      * Gets an approximate source code location for a node, encoded as an exception, if possible.
 569      *
 570      * @return the exception with the location
 571      */
 572     public static RuntimeException approxSourceException(Node node, Throwable cause) {
 573         final StackTraceElement[] elements = approxSourceStackTraceElement(node);
 574         return createBailoutException(cause == null ? &quot;&quot; : cause.getMessage(), cause, elements);
 575     }
 576 
 577     /**
 578      * Creates a bailout exception with the given stack trace elements and message.
 579      *
 580      * @param message the message of the exception
 581      * @param elements the stack trace elements
 582      * @return the exception
 583      */
 584     public static BailoutException createBailoutException(String message, Throwable cause, StackTraceElement[] elements) {
 585         return SourceStackTraceBailoutException.create(cause, message, elements);
 586     }
 587 
 588     /**
 589      * Gets an approximate source code location for a node if possible.
 590      *
 591      * @return a file name and source line number in stack trace format (e.g. &quot;String.java:32&quot;) if
 592      *         an approximate source location is found, null otherwise
 593      */
 594     public static String approxSourceLocation(Node node) {
 595         StackTraceElement[] stackTraceElements = approxSourceStackTraceElement(node);
 596         if (stackTraceElements != null &amp;&amp; stackTraceElements.length &gt; 0) {
 597             StackTraceElement top = stackTraceElements[0];
 598             if (top.getFileName() != null &amp;&amp; top.getLineNumber() &gt;= 0) {
 599                 return top.getFileName() + &quot;:&quot; + top.getLineNumber();
 600             }
 601         }
 602         return null;
 603     }
 604 
 605     /**
 606      * Returns a string representation of the given collection of objects.
 607      *
 608      * @param objects The {@link Iterable} that will be used to iterate over the objects.
 609      * @return A string of the format &quot;[a, b, ...]&quot;.
 610      */
 611     public static String toString(Iterable&lt;?&gt; objects) {
 612         StringBuilder str = new StringBuilder();
 613         str.append(&quot;[&quot;);
 614         for (Object o : objects) {
 615             str.append(o).append(&quot;, &quot;);
 616         }
 617         if (str.length() &gt; 1) {
 618             str.setLength(str.length() - 2);
 619         }
 620         str.append(&quot;]&quot;);
 621         return str.toString();
 622     }
 623 
 624     /**
 625      * Gets the original value by iterating through all {@link ValueProxy ValueProxies}.
 626      *
 627      * @param value the start value.
 628      * @return the first non-proxy value encountered
 629      */
 630     public static ValueNode unproxify(ValueNode value) {
 631         if (value instanceof ValueProxy) {
 632             return unproxify((ValueProxy) value);
 633         } else {
 634             return value;
 635         }
 636     }
 637 
 638     /**
 639      * Gets the original value by iterating through all {@link ValueProxy ValueProxies}.
 640      *
 641      * @param value the start value proxy.
 642      * @return the first non-proxy value encountered
 643      */
 644     public static ValueNode unproxify(ValueProxy value) {
 645         if (value != null) {
 646             ValueNode result = value.getOriginalNode();
 647             while (result instanceof ValueProxy) {
 648                 result = ((ValueProxy) result).getOriginalNode();
 649             }
 650             return result;
 651         } else {
 652             return null;
 653         }
 654     }
 655 
 656     public static ValueNode skipPi(ValueNode node) {
 657         ValueNode n = node;
 658         while (n instanceof PiNode) {
 659             PiNode piNode = (PiNode) n;
 660             n = piNode.getOriginalNode();
 661         }
 662         return n;
 663     }
 664 
 665     public static ValueNode skipPiWhileNonNull(ValueNode node) {
 666         ValueNode n = node;
 667         while (n instanceof PiNode) {
 668             PiNode piNode = (PiNode) n;
 669             ObjectStamp originalStamp = (ObjectStamp) piNode.getOriginalNode().stamp(NodeView.DEFAULT);
 670             if (originalStamp.nonNull()) {
 671                 n = piNode.getOriginalNode();
 672             } else {
 673                 break;
 674             }
 675         }
 676         return n;
 677     }
 678 
 679     /**
 680      * Returns the length of the array described by the value parameter, or null if it is not
 681      * available. Details of the different modes are documented in {@link FindLengthMode}.
 682      *
 683      * @param value The start value.
 684      * @param mode The mode as documented in {@link FindLengthMode}.
 685      * @return The array length if one was found, or null otherwise.
 686      */
 687     public static ValueNode arrayLength(ValueNode value, FindLengthMode mode, ConstantReflectionProvider constantReflection) {
 688         Objects.requireNonNull(mode);
 689 
 690         ValueNode current = value;
 691         do {
 692             /*
 693              * PiArrayNode implements ArrayLengthProvider and ValueProxy. We want to treat it as an
 694              * ArrayLengthProvider, therefore we check this case first.
 695              */
 696             if (current instanceof ArrayLengthProvider) {
 697                 return ((ArrayLengthProvider) current).findLength(mode, constantReflection);
 698 
 699             } else if (current instanceof ValuePhiNode) {
 700                 return phiArrayLength((ValuePhiNode) current, mode, constantReflection);
 701 
 702             } else if (current instanceof ValueProxyNode) {
 703                 ValueProxyNode proxy = (ValueProxyNode) current;
 704                 ValueNode length = arrayLength(proxy.getOriginalNode(), mode, constantReflection);
 705                 if (mode == ArrayLengthProvider.FindLengthMode.CANONICALIZE_READ &amp;&amp; length != null &amp;&amp; !length.isConstant()) {
 706                     length = new ValueProxyNode(length, proxy.proxyPoint());
 707                 }
 708                 return length;
 709 
 710             } else if (current instanceof ValueProxy) {
 711                 /* Written as a loop instead of a recursive call to reduce recursion depth. */
 712                 current = ((ValueProxy) current).getOriginalNode();
 713 
 714             } else {
 715                 return null;
 716             }
 717         } while (true);
 718     }
 719 
 720     private static ValueNode phiArrayLength(ValuePhiNode phi, ArrayLengthProvider.FindLengthMode mode, ConstantReflectionProvider constantReflection) {
 721         if (phi.merge() instanceof LoopBeginNode) {
 722             /* Avoid cycle detection by not processing phi functions that could introduce cycles. */
 723             return null;
 724         }
 725 
 726         ValueNode singleLength = null;
 727         for (int i = 0; i &lt; phi.values().count(); i++) {
 728             ValueNode input = phi.values().get(i);
 729             ValueNode length = arrayLength(input, mode, constantReflection);
 730             if (length == null) {
 731                 return null;
 732             }
 733             assert length.stamp(NodeView.DEFAULT).getStackKind() == JavaKind.Int;
 734 
 735             if (i == 0) {
 736                 assert singleLength == null;
 737                 singleLength = length;
 738             } else if (singleLength == length) {
 739                 /* Nothing to do, still having a single length. */
 740             } else {
 741                 return null;
 742             }
 743         }
 744         return singleLength;
 745     }
 746 
 747     /**
 748      * Tries to find an original value of the given node by traversing through proxies and
<a name="9" id="anc9"></a><span class="line-modified"> 749      * unambiguous phis. Note that this method will perform an exhaustive search through phis.</span>

 750      *
<a name="10" id="anc10"></a><span class="line-modified"> 751      * @param value the node whose original value should be determined</span>
<span class="line-modified"> 752      * @param abortOnLoopPhi specifies if the traversal through phis should stop and return</span>
<span class="line-added"> 753      *            {@code value} if it hits a {@linkplain PhiNode#isLoopPhi loop phi}. This argument</span>
<span class="line-added"> 754      *            must be {@code true} if used during graph building as loop phi nodes may not yet</span>
<span class="line-added"> 755      *            have all their inputs computed.</span>
<span class="line-added"> 756      * @return the original value (which might be {@code value} itself)</span>
 757      */
<a name="11" id="anc11"></a><span class="line-modified"> 758     public static ValueNode originalValue(ValueNode value, boolean abortOnLoopPhi) {</span>
<span class="line-modified"> 759         ValueNode result = originalValueSimple(value, abortOnLoopPhi);</span>
 760         assert result != null;
 761         return result;
 762     }
 763 
<a name="12" id="anc12"></a><span class="line-modified"> 764     private static ValueNode originalValueSimple(ValueNode value, boolean abortOnLoopPhi) {</span>
 765         /* The very simple case: look through proxies. */
 766         ValueNode cur = originalValueForProxy(value);
 767 
 768         while (cur instanceof PhiNode) {
 769             /*
 770              * We found a phi function. Check if we can analyze it without allocating temporary data
 771              * structures.
 772              */
 773             PhiNode phi = (PhiNode) cur;
 774 
<a name="13" id="anc13"></a><span class="line-added"> 775             if (abortOnLoopPhi &amp;&amp; phi.isLoopPhi()) {</span>
<span class="line-added"> 776                 return value;</span>
<span class="line-added"> 777             }</span>
<span class="line-added"> 778 </span>
 779             ValueNode phiSingleValue = null;
 780             int count = phi.valueCount();
 781             for (int i = 0; i &lt; count; ++i) {
 782                 ValueNode phiCurValue = originalValueForProxy(phi.valueAt(i));
 783                 if (phiCurValue == phi) {
 784                     /* Simple cycle, we can ignore the input value. */
 785                 } else if (phiSingleValue == null) {
 786                     /* The first input. */
 787                     phiSingleValue = phiCurValue;
 788                 } else if (phiSingleValue != phiCurValue) {
 789                     /* Another input that is different from the first input. */
 790 
 791                     if (phiSingleValue instanceof PhiNode || phiCurValue instanceof PhiNode) {
 792                         /*
 793                          * We have two different input values for the phi function, and at least one
 794                          * of the inputs is another phi function. We need to do a complicated
 795                          * exhaustive check.
 796                          */
<a name="14" id="anc14"></a><span class="line-modified"> 797                         return originalValueForComplicatedPhi(value, phi, new NodeBitMap(value.graph()), abortOnLoopPhi);</span>
 798                     } else {
 799                         /*
 800                          * We have two different input values for the phi function, but none of them
 801                          * is another phi function. This phi function cannot be reduce any further,
 802                          * so the phi function is the original value.
 803                          */
 804                         return phi;
 805                     }
 806                 }
 807             }
 808 
 809             /*
 810              * Successfully reduced the phi function to a single input value. The single input value
 811              * can itself be a phi function again, so we might take another loop iteration.
 812              */
 813             assert phiSingleValue != null;
 814             cur = phiSingleValue;
 815         }
 816 
 817         /* We reached a &quot;normal&quot; node, which is the original value. */
 818         assert !(cur instanceof LimitedValueProxy) &amp;&amp; !(cur instanceof PhiNode);
 819         return cur;
 820     }
 821 
 822     private static ValueNode originalValueForProxy(ValueNode value) {
 823         ValueNode cur = value;
 824         while (cur instanceof LimitedValueProxy) {
 825             cur = ((LimitedValueProxy) cur).getOriginalNode();
 826         }
 827         return cur;
 828     }
 829 
 830     /**
 831      * Handling for complicated nestings of phi functions. We need to reduce phi functions
 832      * recursively, and need a temporary map of visited nodes to avoid endless recursion of cycles.
<a name="15" id="anc15"></a><span class="line-added"> 833      *</span>
<span class="line-added"> 834      * @param value the node whose original value is being determined</span>
<span class="line-added"> 835      * @param abortOnLoopPhi specifies if the traversal through phis should stop and return</span>
<span class="line-added"> 836      *            {@code value} if it hits a {@linkplain PhiNode#isLoopPhi loop phi}</span>
 837      */
<a name="16" id="anc16"></a><span class="line-modified"> 838     private static ValueNode originalValueForComplicatedPhi(ValueNode value, PhiNode phi, NodeBitMap visited, boolean abortOnLoopPhi) {</span>
 839         if (visited.isMarked(phi)) {
 840             /*
 841              * Found a phi function that was already seen. Either a cycle, or just a second phi
 842              * input to a path we have already processed.
 843              */
 844             return null;
 845         }
 846         visited.mark(phi);
 847 
 848         ValueNode phiSingleValue = null;
 849         int count = phi.valueCount();
 850         for (int i = 0; i &lt; count; ++i) {
 851             ValueNode phiCurValue = originalValueForProxy(phi.valueAt(i));
 852             if (phiCurValue instanceof PhiNode) {
 853                 /* Recursively process a phi function input. */
<a name="17" id="anc17"></a><span class="line-modified"> 854                 PhiNode curPhi = (PhiNode) phiCurValue;</span>
<span class="line-added"> 855                 if (abortOnLoopPhi &amp;&amp; curPhi.isLoopPhi()) {</span>
<span class="line-added"> 856                     return value;</span>
<span class="line-added"> 857                 }</span>
<span class="line-added"> 858                 phiCurValue = originalValueForComplicatedPhi(value, curPhi, visited, abortOnLoopPhi);</span>
<span class="line-added"> 859                 if (phiCurValue == value) {</span>
<span class="line-added"> 860                     // Hit a loop phi</span>
<span class="line-added"> 861                     assert abortOnLoopPhi;</span>
<span class="line-added"> 862                     return value;</span>
<span class="line-added"> 863                 }</span>
 864             }
 865 
 866             if (phiCurValue == null) {
 867                 /* Cycle to a phi function that was already seen. We can ignore this input. */
 868             } else if (phiSingleValue == null) {
 869                 /* The first input. */
 870                 phiSingleValue = phiCurValue;
 871             } else if (phiCurValue != phiSingleValue) {
 872                 /*
 873                  * Another input that is different from the first input. Since we already
 874                  * recursively looked through other phi functions, we now know that this phi
 875                  * function cannot be reduce any further, so the phi function is the original value.
 876                  */
 877                 return phi;
 878             }
 879         }
 880         return phiSingleValue;
 881     }
 882 
 883     public static boolean tryKillUnused(Node node) {
 884         if (node.isAlive() &amp;&amp; isFloatingNode(node) &amp;&amp; node.hasNoUsages() &amp;&amp; !(node instanceof GuardNode)) {
 885             killWithUnusedFloatingInputs(node);
 886             return true;
 887         }
 888         return false;
 889     }
 890 
 891     /**
 892      * Returns an iterator that will return the given node followed by all its predecessors, up
 893      * until the point where {@link Node#predecessor()} returns null.
 894      *
 895      * @param start the node at which to start iterating
 896      */
 897     public static NodeIterable&lt;FixedNode&gt; predecessorIterable(final FixedNode start) {
 898         return new NodeIterable&lt;FixedNode&gt;() {
 899             @Override
 900             public Iterator&lt;FixedNode&gt; iterator() {
 901                 return new Iterator&lt;FixedNode&gt;() {
 902                     public FixedNode current = start;
 903 
 904                     @Override
 905                     public boolean hasNext() {
 906                         return current != null;
 907                     }
 908 
 909                     @Override
 910                     public FixedNode next() {
 911                         try {
 912                             return current;
 913                         } finally {
 914                             current = (FixedNode) current.predecessor();
 915                         }
 916                     }
 917                 };
 918             }
 919         };
 920     }
 921 
 922     private static final class DefaultSimplifierTool implements SimplifierTool {
 923         private final MetaAccessProvider metaAccess;
 924         private final ConstantReflectionProvider constantReflection;
 925         private final ConstantFieldProvider constantFieldProvider;
 926         private final boolean canonicalizeReads;
 927         private final Assumptions assumptions;
 928         private final OptionValues options;
 929         private final LoweringProvider loweringProvider;
 930 
 931         DefaultSimplifierTool(MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider, boolean canonicalizeReads,
 932                         Assumptions assumptions, OptionValues options, LoweringProvider loweringProvider) {
 933             this.metaAccess = metaAccess;
 934             this.constantReflection = constantReflection;
 935             this.constantFieldProvider = constantFieldProvider;
 936             this.canonicalizeReads = canonicalizeReads;
 937             this.assumptions = assumptions;
 938             this.options = options;
 939             this.loweringProvider = loweringProvider;
 940         }
 941 
 942         @Override
 943         public MetaAccessProvider getMetaAccess() {
 944             return metaAccess;
 945         }
 946 
 947         @Override
 948         public ConstantReflectionProvider getConstantReflection() {
 949             return constantReflection;
 950         }
 951 
 952         @Override
 953         public ConstantFieldProvider getConstantFieldProvider() {
 954             return constantFieldProvider;
 955         }
 956 
 957         @Override
 958         public boolean canonicalizeReads() {
 959             return canonicalizeReads;
 960         }
 961 
 962         @Override
 963         public boolean allUsagesAvailable() {
 964             return true;
 965         }
 966 
 967         @Override
 968         public void deleteBranch(Node branch) {
 969             FixedNode fixedBranch = (FixedNode) branch;
 970             fixedBranch.predecessor().replaceFirstSuccessor(fixedBranch, null);
 971             GraphUtil.killCFG(fixedBranch);
 972         }
 973 
 974         @Override
 975         public void removeIfUnused(Node node) {
 976             GraphUtil.tryKillUnused(node);
 977         }
 978 
 979         @Override
 980         public void addToWorkList(Node node) {
 981         }
 982 
 983         @Override
 984         public void addToWorkList(Iterable&lt;? extends Node&gt; nodes) {
 985         }
 986 
 987         @Override
 988         public Assumptions getAssumptions() {
 989             return assumptions;
 990         }
 991 
 992         @Override
 993         public OptionValues getOptions() {
 994             return options;
 995         }
 996 
 997         @Override
 998         public Integer smallestCompareWidth() {
 999             if (loweringProvider != null) {
1000                 return loweringProvider.smallestCompareWidth();
1001             } else {
1002                 return null;
1003             }
1004         }
1005     }
1006 
1007     public static SimplifierTool getDefaultSimplifier(MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,
1008                     boolean canonicalizeReads, Assumptions assumptions, OptionValues options) {
1009         return getDefaultSimplifier(metaAccess, constantReflection, constantFieldProvider, canonicalizeReads, assumptions, options, null);
1010     }
1011 
1012     public static SimplifierTool getDefaultSimplifier(MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,
1013                     boolean canonicalizeReads, Assumptions assumptions, OptionValues options, LoweringProvider loweringProvider) {
1014         return new DefaultSimplifierTool(metaAccess, constantReflection, constantFieldProvider, canonicalizeReads, assumptions, options, loweringProvider);
1015     }
1016 
1017     public static Constant foldIfConstantAndRemove(ValueNode node, ValueNode constant) {
1018         assert node.inputs().contains(constant);
1019         if (constant.isConstant()) {
1020             node.replaceFirstInput(constant, null);
1021             Constant result = constant.asConstant();
1022             tryKillUnused(constant);
1023             return result;
1024         }
1025         return null;
1026     }
1027 
1028     /**
1029      * Virtualize an array copy.
1030      *
1031      * @param tool the virtualization tool
1032      * @param source the source array
1033      * @param sourceLength the length of the source array
1034      * @param newLength the length of the new array
1035      * @param from the start index in the source array
1036      * @param newComponentType the component type of the new array
1037      * @param elementKind the kind of the new array elements
1038      * @param graph the node graph
1039      * @param virtualArrayProvider a functional provider that returns a new virtual array given the
1040      *            component type and length
1041      */
1042     public static void virtualizeArrayCopy(VirtualizerTool tool, ValueNode source, ValueNode sourceLength, ValueNode newLength, ValueNode from, ResolvedJavaType newComponentType, JavaKind elementKind,
1043                     StructuredGraph graph, BiFunction&lt;ResolvedJavaType, Integer, VirtualArrayNode&gt; virtualArrayProvider) {
1044 
1045         ValueNode sourceAlias = tool.getAlias(source);
1046         ValueNode replacedSourceLength = tool.getAlias(sourceLength);
1047         ValueNode replacedNewLength = tool.getAlias(newLength);
1048         ValueNode replacedFrom = tool.getAlias(from);
1049         if (!replacedNewLength.isConstant() || !replacedFrom.isConstant() || !replacedSourceLength.isConstant()) {
1050             return;
1051         }
1052 
1053         assert newComponentType != null : &quot;An array copy can be virtualized only if the real type of the resulting array is known statically.&quot;;
1054 
1055         int fromInt = replacedFrom.asJavaConstant().asInt();
1056         int newLengthInt = replacedNewLength.asJavaConstant().asInt();
1057         int sourceLengthInt = replacedSourceLength.asJavaConstant().asInt();
1058         if (sourceAlias instanceof VirtualObjectNode) {
1059             VirtualObjectNode sourceVirtual = (VirtualObjectNode) sourceAlias;
1060             assert sourceLengthInt == sourceVirtual.entryCount();
1061         }
1062 
1063         if (fromInt &lt; 0 || newLengthInt &lt; 0 || fromInt &gt; sourceLengthInt) {
1064             /* Illegal values for either from index, the new length or the source length. */
1065             return;
1066         }
1067 
1068         if (newLengthInt &gt; tool.getMaximumEntryCount()) {
1069             /* The new array size is higher than maximum allowed size of virtualized objects. */
1070             return;
1071         }
1072 
1073         ValueNode[] newEntryState = new ValueNode[newLengthInt];
1074         int readLength = Math.min(newLengthInt, sourceLengthInt - fromInt);
1075 
1076         if (sourceAlias instanceof VirtualObjectNode) {
1077             /* The source array is virtualized, just copy over the values. */
1078             VirtualObjectNode sourceVirtual = (VirtualObjectNode) sourceAlias;
1079             boolean alwaysAssignable = newComponentType.getJavaKind() == JavaKind.Object &amp;&amp; newComponentType.isJavaLangObject();
1080             for (int i = 0; i &lt; readLength; i++) {
1081                 ValueNode entry = tool.getEntry(sourceVirtual, fromInt + i);
1082                 if (!alwaysAssignable) {
1083                     ResolvedJavaType entryType = StampTool.typeOrNull(entry, tool.getMetaAccess());
1084                     if (entryType == null) {
1085                         return;
1086                     }
1087                     if (!newComponentType.isAssignableFrom(entryType)) {
1088                         return;
1089                     }
1090                 }
1091                 newEntryState[i] = entry;
1092             }
1093         } else {
1094             /* The source array is not virtualized, emit index loads. */
1095             ResolvedJavaType sourceType = StampTool.typeOrNull(sourceAlias, tool.getMetaAccess());
1096             if (sourceType == null || !sourceType.isArray() || !newComponentType.isAssignableFrom(sourceType.getElementalType())) {
1097                 return;
1098             }
1099             for (int i = 0; i &lt; readLength; i++) {
1100                 LoadIndexedNode load = new LoadIndexedNode(null, sourceAlias, ConstantNode.forInt(i + fromInt, graph), null, elementKind);
1101                 tool.addNode(load);
1102                 newEntryState[i] = load;
1103             }
1104         }
1105         if (readLength &lt; newLengthInt) {
1106             /* Pad the copy with the default value of its elment kind. */
1107             ValueNode defaultValue = ConstantNode.defaultForKind(elementKind, graph);
1108             for (int i = readLength; i &lt; newLengthInt; i++) {
1109                 newEntryState[i] = defaultValue;
1110             }
1111         }
1112         /* Perform the replacement. */
1113         VirtualArrayNode newVirtualArray = virtualArrayProvider.apply(newComponentType, newLengthInt);
1114         tool.createVirtualObject(newVirtualArray, newEntryState, Collections.&lt;MonitorIdNode&gt; emptyList(), false);
1115         tool.replaceWithVirtual(newVirtualArray);
1116     }
<a name="18" id="anc18"></a><span class="line-added">1117 </span>
<span class="line-added">1118     /**</span>
<span class="line-added">1119      * Snippet lowerings may produce patterns without a frame state on the merge. We need to take</span>
<span class="line-added">1120      * extra care when optimizing these patterns.</span>
<span class="line-added">1121      */</span>
<span class="line-added">1122     public static boolean checkFrameState(FixedNode start, int maxDepth) {</span>
<span class="line-added">1123         if (maxDepth == 0) {</span>
<span class="line-added">1124             return false;</span>
<span class="line-added">1125         }</span>
<span class="line-added">1126         FixedNode node = start;</span>
<span class="line-added">1127         while (true) {</span>
<span class="line-added">1128             if (node instanceof AbstractMergeNode) {</span>
<span class="line-added">1129                 AbstractMergeNode mergeNode = (AbstractMergeNode) node;</span>
<span class="line-added">1130                 if (mergeNode.stateAfter() == null) {</span>
<span class="line-added">1131                     return false;</span>
<span class="line-added">1132                 } else {</span>
<span class="line-added">1133                     return true;</span>
<span class="line-added">1134                 }</span>
<span class="line-added">1135             } else if (node instanceof StateSplit) {</span>
<span class="line-added">1136                 StateSplit stateSplitNode = (StateSplit) node;</span>
<span class="line-added">1137                 if (stateSplitNode.stateAfter() != null) {</span>
<span class="line-added">1138                     return true;</span>
<span class="line-added">1139                 }</span>
<span class="line-added">1140             }</span>
<span class="line-added">1141 </span>
<span class="line-added">1142             if (node instanceof ControlSplitNode) {</span>
<span class="line-added">1143                 ControlSplitNode controlSplitNode = (ControlSplitNode) node;</span>
<span class="line-added">1144                 for (Node succ : controlSplitNode.cfgSuccessors()) {</span>
<span class="line-added">1145                     if (checkFrameState((FixedNode) succ, maxDepth - 1)) {</span>
<span class="line-added">1146                         return true;</span>
<span class="line-added">1147                     }</span>
<span class="line-added">1148                 }</span>
<span class="line-added">1149                 return false;</span>
<span class="line-added">1150             } else if (node instanceof FixedWithNextNode) {</span>
<span class="line-added">1151                 FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) node;</span>
<span class="line-added">1152                 node = fixedWithNextNode.next();</span>
<span class="line-added">1153             } else if (node instanceof AbstractEndNode) {</span>
<span class="line-added">1154                 AbstractEndNode endNode = (AbstractEndNode) node;</span>
<span class="line-added">1155                 node = endNode.merge();</span>
<span class="line-added">1156             } else if (node instanceof ControlSinkNode) {</span>
<span class="line-added">1157                 return true;</span>
<span class="line-added">1158             } else {</span>
<span class="line-added">1159                 assert false : &quot;unexpected node&quot;;</span>
<span class="line-added">1160                 return false;</span>
<span class="line-added">1161             }</span>
<span class="line-added">1162         }</span>
<span class="line-added">1163     }</span>
<span class="line-added">1164 </span>
<span class="line-added">1165     public static boolean mayRemoveSplit(IfNode ifNode) {</span>
<span class="line-added">1166         return GraphUtil.checkFrameState(ifNode.trueSuccessor(), MAX_FRAMESTATE_SEARCH_DEPTH) &amp;&amp; GraphUtil.checkFrameState(ifNode.falseSuccessor(), MAX_FRAMESTATE_SEARCH_DEPTH);</span>
<span class="line-added">1167     }</span>
1168 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
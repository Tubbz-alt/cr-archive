<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/FixedGuardNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes;
 26 
 27 import static org.graalvm.compiler.nodeinfo.InputType.Guard;
 28 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_2;
 29 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_2;
 30 
 31 import org.graalvm.compiler.debug.DebugCloseable;
 32 import org.graalvm.compiler.graph.IterableNodeType;
<a name="2" id="anc2"></a><span class="line-added"> 33 import org.graalvm.compiler.graph.Node;</span>
 34 import org.graalvm.compiler.graph.NodeClass;
 35 import org.graalvm.compiler.graph.NodeSourcePosition;
 36 import org.graalvm.compiler.graph.spi.SimplifierTool;
 37 import org.graalvm.compiler.nodeinfo.NodeInfo;
<a name="3" id="anc3"></a><span class="line-added"> 38 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;</span>
 39 import org.graalvm.compiler.nodes.spi.Lowerable;
 40 import org.graalvm.compiler.nodes.spi.LoweringTool;
<a name="4" id="anc4"></a><span class="line-added"> 41 import org.graalvm.compiler.nodes.spi.SwitchFoldable;</span>
 42 
 43 import jdk.vm.ci.meta.DeoptimizationAction;
 44 import jdk.vm.ci.meta.DeoptimizationReason;
 45 import jdk.vm.ci.meta.SpeculationLog;
 46 
 47 @NodeInfo(nameTemplate = &quot;FixedGuard(!={p#negated}) {p#reason/s}&quot;, allowedUsageTypes = Guard, size = SIZE_2, cycles = CYCLES_2)
<a name="5" id="anc5"></a><span class="line-modified"> 48 public final class FixedGuardNode extends AbstractFixedGuardNode implements Lowerable, IterableNodeType, SwitchFoldable {</span>
 49     public static final NodeClass&lt;FixedGuardNode&gt; TYPE = NodeClass.create(FixedGuardNode.class);
 50 
 51     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action) {
 52         this(condition, deoptReason, action, SpeculationLog.NO_SPECULATION, false);
 53     }
 54 
 55     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, boolean negated) {
 56         this(condition, deoptReason, action, SpeculationLog.NO_SPECULATION, negated);
 57     }
 58 
 59     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, boolean negated, NodeSourcePosition noDeoptSuccessorPosition) {
 60         this(condition, deoptReason, action, SpeculationLog.NO_SPECULATION, negated, noDeoptSuccessorPosition);
 61     }
 62 
 63     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, SpeculationLog.Speculation speculation, boolean negated) {
 64         super(TYPE, condition, deoptReason, action, speculation, negated);
 65     }
 66 
 67     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, SpeculationLog.Speculation speculation, boolean negated,
 68                     NodeSourcePosition noDeoptSuccessorPosition) {
 69         super(TYPE, condition, deoptReason, action, speculation, negated, noDeoptSuccessorPosition);
 70     }
 71 
 72     @Override
 73     public void simplify(SimplifierTool tool) {
 74         super.simplify(tool);
 75 
 76         if (getCondition() instanceof LogicConstantNode) {
 77             LogicConstantNode c = (LogicConstantNode) getCondition();
 78             if (c.getValue() == isNegated()) {
 79                 FixedNode currentNext = this.next();
 80                 if (currentNext != null) {
 81                     tool.deleteBranch(currentNext);
 82                 }
 83 
 84                 DeoptimizeNode deopt = graph().add(new DeoptimizeNode(getAction(), getReason(), getSpeculation()));
 85                 deopt.setStateBefore(stateBefore());
 86                 setNext(deopt);
 87             }
 88             this.replaceAtUsages(null);
 89             graph().removeFixed(this);
 90         } else if (getCondition() instanceof ShortCircuitOrNode) {
 91             ShortCircuitOrNode shortCircuitOr = (ShortCircuitOrNode) getCondition();
 92             if (isNegated() &amp;&amp; hasNoUsages()) {
 93                 graph().addAfterFixed(this,
 94                                 graph().add(new FixedGuardNode(shortCircuitOr.getY(), getReason(), getAction(), getSpeculation(), !shortCircuitOr.isYNegated(), getNoDeoptSuccessorPosition())));
 95                 graph().replaceFixedWithFixed(this,
 96                                 graph().add(new FixedGuardNode(shortCircuitOr.getX(), getReason(), getAction(), getSpeculation(), !shortCircuitOr.isXNegated(), getNoDeoptSuccessorPosition())));
 97             }
 98         }
 99     }
100 
101     @SuppressWarnings(&quot;try&quot;)
102     @Override
103     public void lower(LoweringTool tool) {
104         try (DebugCloseable position = this.withNodeSourcePosition()) {
105             if (graph().getGuardsStage().allowsFloatingGuards()) {
106                 if (getAction() != DeoptimizationAction.None) {
107                     ValueNode guard = tool.createGuard(this, getCondition(), getReason(), getAction(), getSpeculation(), isNegated(), getNoDeoptSuccessorPosition()).asNode();
108                     this.replaceAtUsages(guard);
109                     graph().removeFixed(this);
110                 }
111             } else {
112                 lowerToIf().lower(tool);
113             }
114         }
115     }
116 
117     @Override
118     public boolean canDeoptimize() {
119         return true;
120     }
<a name="6" id="anc6"></a><span class="line-added">121 </span>
<span class="line-added">122     @Override</span>
<span class="line-added">123     public Node getNextSwitchFoldableBranch() {</span>
<span class="line-added">124         return next();</span>
<span class="line-added">125     }</span>
<span class="line-added">126 </span>
<span class="line-added">127     @Override</span>
<span class="line-added">128     public boolean isInSwitch(ValueNode switchValue) {</span>
<span class="line-added">129         return hasNoUsages() &amp;&amp; isNegated() &amp;&amp; SwitchFoldable.maybeIsInSwitch(condition()) &amp;&amp; SwitchFoldable.sameSwitchValue(condition(), switchValue);</span>
<span class="line-added">130     }</span>
<span class="line-added">131 </span>
<span class="line-added">132     @Override</span>
<span class="line-added">133     public void cutOffCascadeNode() {</span>
<span class="line-added">134         /* nop */</span>
<span class="line-added">135     }</span>
<span class="line-added">136 </span>
<span class="line-added">137     @Override</span>
<span class="line-added">138     public void cutOffLowestCascadeNode() {</span>
<span class="line-added">139         setNext(null);</span>
<span class="line-added">140     }</span>
<span class="line-added">141 </span>
<span class="line-added">142     @Override</span>
<span class="line-added">143     public boolean isDefaultSuccessor(AbstractBeginNode beginNode) {</span>
<span class="line-added">144         return beginNode.next() == next();</span>
<span class="line-added">145     }</span>
<span class="line-added">146 </span>
<span class="line-added">147     @Override</span>
<span class="line-added">148     public AbstractBeginNode getDefault() {</span>
<span class="line-added">149         FixedNode defaultNode = next();</span>
<span class="line-added">150         setNext(null);</span>
<span class="line-added">151         return BeginNode.begin(defaultNode);</span>
<span class="line-added">152     }</span>
<span class="line-added">153 </span>
<span class="line-added">154     @Override</span>
<span class="line-added">155     public ValueNode switchValue() {</span>
<span class="line-added">156         if (SwitchFoldable.maybeIsInSwitch(condition())) {</span>
<span class="line-added">157             return ((IntegerEqualsNode) condition()).getX();</span>
<span class="line-added">158         }</span>
<span class="line-added">159         return null;</span>
<span class="line-added">160     }</span>
<span class="line-added">161 </span>
<span class="line-added">162     @Override</span>
<span class="line-added">163     public boolean isNonInitializedProfile() {</span>
<span class="line-added">164         // @formatter:off</span>
<span class="line-added">165         // Checkstyle: stop</span>
<span class="line-added">166         /*</span>
<span class="line-added">167          * These nodes can appear in non initialized cascades. Though they are technically profiled</span>
<span class="line-added">168          * nodes, their presence does not really prevent us from constructing a uniform distribution</span>
<span class="line-added">169          * for the new switch, while keeping these to probability 0. Furthermore, these can be the</span>
<span class="line-added">170          * result of the pattern:</span>
<span class="line-added">171          * if (c) {</span>
<span class="line-added">172          *     CompilerDirectives.transferToInterpreter();</span>
<span class="line-added">173          * }</span>
<span class="line-added">174          * Since we cannot differentiate this case from, say, a guard created because profiling</span>
<span class="line-added">175          * determined that the branch was never taken, and given what we saw before, we will</span>
<span class="line-added">176          * consider all fixedGuards as nodes with no profiles for switch folding purposes.</span>
<span class="line-added">177          */</span>
<span class="line-added">178         // Checkstyle: resume</span>
<span class="line-added">179         // @formatter:on</span>
<span class="line-added">180         return true;</span>
<span class="line-added">181     }</span>
<span class="line-added">182 </span>
<span class="line-added">183     @Override</span>
<span class="line-added">184     public int intKeyAt(int i) {</span>
<span class="line-added">185         assert i == 0;</span>
<span class="line-added">186         return ((IntegerEqualsNode) condition()).getY().asJavaConstant().asInt();</span>
<span class="line-added">187     }</span>
<span class="line-added">188 </span>
<span class="line-added">189     @Override</span>
<span class="line-added">190     public double keyProbability(int i) {</span>
<span class="line-added">191         return 0;</span>
<span class="line-added">192     }</span>
<span class="line-added">193 </span>
<span class="line-added">194     @Override</span>
<span class="line-added">195     public AbstractBeginNode keySuccessor(int i) {</span>
<span class="line-added">196         DeoptimizeNode deopt = new DeoptimizeNode(getAction(), getReason(), getSpeculation());</span>
<span class="line-added">197         deopt.setNodeSourcePosition(getNodeSourcePosition());</span>
<span class="line-added">198         AbstractBeginNode begin = new BeginNode();</span>
<span class="line-added">199         // Link the two nodes, but do not add them to the graph yet, so we do not need to remove</span>
<span class="line-added">200         // them on an abort.</span>
<span class="line-added">201         begin.next = deopt;</span>
<span class="line-added">202         return begin;</span>
<span class="line-added">203     }</span>
<span class="line-added">204 </span>
<span class="line-added">205     @Override</span>
<span class="line-added">206     public double defaultProbability() {</span>
<span class="line-added">207         return 1.0d;</span>
<span class="line-added">208     }</span>
209 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/IntegerConvertNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.calc;
 26 
 27 import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.getArithmeticOpTable;
 28 
 29 import org.graalvm.compiler.core.common.type.ArithmeticOpTable;
 30 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.IntegerConvertOp;
 31 import org.graalvm.compiler.core.common.type.IntegerStamp;
 32 import org.graalvm.compiler.core.common.type.PrimitiveStamp;
 33 import org.graalvm.compiler.core.common.type.Stamp;
 34 import org.graalvm.compiler.graph.NodeClass;
 35 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 36 import org.graalvm.compiler.nodeinfo.NodeInfo;
 37 import org.graalvm.compiler.nodes.ArithmeticOperation;
 38 import org.graalvm.compiler.nodes.ConstantNode;
 39 import org.graalvm.compiler.nodes.NodeView;
 40 import org.graalvm.compiler.nodes.StructuredGraph;
 41 import org.graalvm.compiler.nodes.ValueNode;
 42 import org.graalvm.compiler.nodes.spi.ArithmeticLIRLowerable;
 43 import org.graalvm.compiler.nodes.spi.StampInverter;
 44 
 45 import jdk.vm.ci.meta.Constant;
 46 import jdk.vm.ci.meta.ConstantReflectionProvider;
 47 
 48 /**
 49  * An {@code IntegerConvert} converts an integer to an integer of different width.
 50  */
 51 @NodeInfo
 52 public abstract class IntegerConvertNode&lt;OP, REV&gt; extends UnaryNode implements ArithmeticOperation, ConvertNode, ArithmeticLIRLowerable, StampInverter {
 53     @SuppressWarnings(&quot;rawtypes&quot;) public static final NodeClass&lt;IntegerConvertNode&gt; TYPE = NodeClass.create(IntegerConvertNode.class);
 54 
 55     protected final int inputBits;
 56     protected final int resultBits;
 57 
 58     protected IntegerConvertNode(NodeClass&lt;? extends IntegerConvertNode&lt;OP, REV&gt;&gt; c, IntegerConvertOp&lt;OP&gt; opForStampComputation, int inputBits, int resultBits, ValueNode input) {
 59         super(c, opForStampComputation.foldStamp(inputBits, resultBits, input.stamp(NodeView.DEFAULT)), input);
 60         this.inputBits = inputBits;
 61         this.resultBits = resultBits;
 62         assert PrimitiveStamp.getBits(input.stamp(NodeView.DEFAULT)) == 0 || PrimitiveStamp.getBits(input.stamp(NodeView.DEFAULT)) == inputBits;
 63     }
 64 
 65     public int getInputBits() {
 66         return inputBits;
 67     }
 68 
 69     public int getResultBits() {
 70         return resultBits;
 71     }
 72 
 73     protected abstract IntegerConvertOp&lt;OP&gt; getOp(ArithmeticOpTable table);
 74 
 75     protected abstract IntegerConvertOp&lt;REV&gt; getReverseOp(ArithmeticOpTable table);
 76 
 77     @Override
 78     public final IntegerConvertOp&lt;OP&gt; getArithmeticOp() {
 79         return getOp(getArithmeticOpTable(getValue()));
 80     }
 81 
 82     @Override
 83     public Constant convert(Constant c, ConstantReflectionProvider constantReflection) {
 84         return getArithmeticOp().foldConstant(getInputBits(), getResultBits(), c);
 85     }
 86 
 87     @Override
 88     public Constant reverse(Constant c, ConstantReflectionProvider constantReflection) {
 89         IntegerConvertOp&lt;REV&gt; reverse = getReverseOp(ArithmeticOpTable.forStamp(stamp(NodeView.DEFAULT)));
 90         return reverse.foldConstant(getResultBits(), getInputBits(), c);
 91     }
 92 
 93     @Override
 94     public Stamp foldStamp(Stamp newStamp) {
 95         assert newStamp.isCompatible(getValue().stamp(NodeView.DEFAULT));
 96         return getArithmeticOp().foldStamp(inputBits, resultBits, newStamp);
 97     }
 98 
 99     @Override
100     public ValueNode canonical(CanonicalizerTool tool, ValueNode forValue) {
101         ValueNode synonym = findSynonym(getOp(getArithmeticOpTable(forValue)), forValue, inputBits, resultBits, stamp(NodeView.DEFAULT));
102         if (synonym != null) {
103             return synonym;
104         }
105         return this;
106     }
107 
108     protected static &lt;T&gt; ValueNode findSynonym(IntegerConvertOp&lt;T&gt; operation, ValueNode value, int inputBits, int resultBits, Stamp stamp) {
109         if (inputBits == resultBits) {
110             return value;
111         } else if (value.isConstant()) {
112             return ConstantNode.forPrimitive(stamp, operation.foldConstant(inputBits, resultBits, value.asConstant()));
113         }
114         return null;
115     }
116 
117     public static ValueNode convert(ValueNode input, Stamp stamp, NodeView view) {
118         return convert(input, stamp, false, view);
119     }
120 
121     public static ValueNode convert(ValueNode input, Stamp stamp, StructuredGraph graph, NodeView view) {
122         ValueNode convert = convert(input, stamp, false, view);
123         if (!convert.isAlive()) {
124             assert !convert.isDeleted();
125             convert = graph.addOrUniqueWithInputs(convert);
126         }
127         return convert;
128     }
129 
130     public static ValueNode convertUnsigned(ValueNode input, Stamp stamp, NodeView view) {
131         return convert(input, stamp, true, view);
132     }
133 
134     public static ValueNode convertUnsigned(ValueNode input, Stamp stamp, StructuredGraph graph, NodeView view) {
135         ValueNode convert = convert(input, stamp, true, view);
136         if (!convert.isAlive()) {
137             assert !convert.isDeleted();
138             convert = graph.addOrUniqueWithInputs(convert);
139         }
140         return convert;
141     }
142 
143     public static ValueNode convert(ValueNode input, Stamp stamp, boolean zeroExtend, NodeView view) {
144         IntegerStamp fromStamp = (IntegerStamp) input.stamp(view);
145         IntegerStamp toStamp = (IntegerStamp) stamp;
146 
147         ValueNode result;
148         if (toStamp.getBits() == fromStamp.getBits()) {
149             result = input;
150         } else if (toStamp.getBits() &lt; fromStamp.getBits()) {
151             result = new NarrowNode(input, fromStamp.getBits(), toStamp.getBits());
152         } else if (zeroExtend) {
153             // toStamp.getBits() &gt; fromStamp.getBits()
154             result = ZeroExtendNode.create(input, toStamp.getBits(), view);
155         } else {
156             // toStamp.getBits() &gt; fromStamp.getBits()
157             result = SignExtendNode.create(input, toStamp.getBits(), view);
158         }
159 
160         IntegerStamp resultStamp = (IntegerStamp) result.stamp(view);
161         assert toStamp.getBits() == resultStamp.getBits();
162         return result;
163     }
164 
165     @Override
166     public Stamp invertStamp(Stamp outStamp) {
167         return getArithmeticOp().invertStamp(inputBits, resultBits, outStamp);
168     }
169 }
    </pre>
  </body>
</html>
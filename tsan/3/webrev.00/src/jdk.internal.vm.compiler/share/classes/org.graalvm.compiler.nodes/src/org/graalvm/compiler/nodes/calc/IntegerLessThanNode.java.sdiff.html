<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/IntegerLessThanNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IntegerEqualsNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="IntegerLowerThanNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/IntegerLessThanNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 97         long r = x - y;
 98         // HD 2-12 Overflow iff the arguments have different signs and
 99         // the sign of the result is different than the sign of x
100         return (((x ^ y) &amp; (x ^ r)) &lt; 0) || r &gt; maxValue;
101     }
102 
103     public static class LessThanOp extends LowerOp {
104         @Override
105         protected CompareNode duplicateModified(ValueNode newX, ValueNode newY, boolean unorderedIsTrue, NodeView view) {
106             if (newX.stamp(view) instanceof FloatStamp &amp;&amp; newY.stamp(view) instanceof FloatStamp) {
107                 return new FloatLessThanNode(newX, newY, unorderedIsTrue); // TODO: Is the last arg
108                                                                            // supposed to be true?
109             } else if (newX.stamp(view) instanceof IntegerStamp &amp;&amp; newY.stamp(view) instanceof IntegerStamp) {
110                 return new IntegerLessThanNode(newX, newY);
111             }
112             throw GraalError.shouldNotReachHere();
113         }
114 
115         @Override
116         protected LogicNode optimizeNormalizeCompare(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth,
<span class="line-modified">117                         Constant constant, NormalizeCompareNode normalizeNode, boolean mirrored, NodeView view) {</span>
118             PrimitiveConstant primitive = (PrimitiveConstant) constant;
119             /* @formatter:off
120              * a NC b &lt; c  (not mirrored)
121              * cases for c:
122              *  0         -&gt; a &lt; b
123              *  [MIN, -1] -&gt; false
124              *  1         -&gt; a &lt;= b
125              *  [2, MAX]  -&gt; true
126              * unordered-is-less means unordered-is-true.
127              *
128              * c &lt; a NC b  (mirrored)
129              * cases for c:
130              *  0         -&gt; a &gt; b
131              *  [1, MAX]  -&gt; false
132              *  -1        -&gt; a &gt;= b
133              *  [MIN, -2] -&gt; true
134              * unordered-is-less means unordered-is-false.
135              *
136              *  We can handle mirroring by swapping a &amp; b and negating the constant.
137              *  @formatter:on
138              */
<span class="line-removed">139             ValueNode a = mirrored ? normalizeNode.getY() : normalizeNode.getX();</span>
<span class="line-removed">140             ValueNode b = mirrored ? normalizeNode.getX() : normalizeNode.getY();</span>
141             long cst = mirrored ? -primitive.asLong() : primitive.asLong();
142 
143             if (cst == 0) {
<span class="line-modified">144                 if (normalizeNode.getX().getStackKind() == JavaKind.Double || normalizeNode.getX().getStackKind() == JavaKind.Float) {</span>
<span class="line-removed">145                     return FloatLessThanNode.create(constantReflection, metaAccess, options, smallestCompareWidth, a, b, mirrored ^ normalizeNode.isUnorderedLess, view);</span>
<span class="line-removed">146                 } else {</span>
<span class="line-removed">147                     return IntegerLessThanNode.create(constantReflection, metaAccess, options, smallestCompareWidth, a, b, view);</span>
<span class="line-removed">148                 }</span>
149             } else if (cst == 1) {
150                 // a &lt;= b &lt;=&gt; !(a &gt; b)
<span class="line-modified">151                 LogicNode compare;</span>
<span class="line-modified">152                 if (normalizeNode.getX().getStackKind() == JavaKind.Double || normalizeNode.getX().getStackKind() == JavaKind.Float) {</span>
<span class="line-removed">153                     // since we negate, we have to reverse the unordered result</span>
<span class="line-removed">154                     compare = FloatLessThanNode.create(constantReflection, metaAccess, options, smallestCompareWidth, b, a, mirrored == normalizeNode.isUnorderedLess, view);</span>
<span class="line-removed">155                 } else {</span>
<span class="line-removed">156                     compare = IntegerLessThanNode.create(constantReflection, metaAccess, options, smallestCompareWidth, b, a, view);</span>
<span class="line-removed">157                 }</span>
158                 return LogicNegationNode.create(compare);
159             } else if (cst &lt;= -1) {
160                 return LogicConstantNode.contradiction();
161             } else {
162                 assert cst &gt;= 2;
163                 return LogicConstantNode.tautology();
164             }
165         }
166 
167         @Override
168         protected LogicNode findSynonym(ValueNode forX, ValueNode forY, NodeView view) {
169             LogicNode result = super.findSynonym(forX, forY, view);
170             if (result != null) {
171                 return result;
172             }
173             if (forX.stamp(view) instanceof IntegerStamp &amp;&amp; forY.stamp(view) instanceof IntegerStamp) {
174                 if (IntegerStamp.sameSign((IntegerStamp) forX.stamp(view), (IntegerStamp) forY.stamp(view))) {
175                     return new IntegerBelowNode(forX, forY);
176                 }
177             }
</pre>
</td>
<td>
<hr />
<pre>
 97         long r = x - y;
 98         // HD 2-12 Overflow iff the arguments have different signs and
 99         // the sign of the result is different than the sign of x
100         return (((x ^ y) &amp; (x ^ r)) &lt; 0) || r &gt; maxValue;
101     }
102 
103     public static class LessThanOp extends LowerOp {
104         @Override
105         protected CompareNode duplicateModified(ValueNode newX, ValueNode newY, boolean unorderedIsTrue, NodeView view) {
106             if (newX.stamp(view) instanceof FloatStamp &amp;&amp; newY.stamp(view) instanceof FloatStamp) {
107                 return new FloatLessThanNode(newX, newY, unorderedIsTrue); // TODO: Is the last arg
108                                                                            // supposed to be true?
109             } else if (newX.stamp(view) instanceof IntegerStamp &amp;&amp; newY.stamp(view) instanceof IntegerStamp) {
110                 return new IntegerLessThanNode(newX, newY);
111             }
112             throw GraalError.shouldNotReachHere();
113         }
114 
115         @Override
116         protected LogicNode optimizeNormalizeCompare(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth,
<span class="line-modified">117                         Constant constant, AbstractNormalizeCompareNode normalizeNode, boolean mirrored, NodeView view) {</span>
118             PrimitiveConstant primitive = (PrimitiveConstant) constant;
119             /* @formatter:off
120              * a NC b &lt; c  (not mirrored)
121              * cases for c:
122              *  0         -&gt; a &lt; b
123              *  [MIN, -1] -&gt; false
124              *  1         -&gt; a &lt;= b
125              *  [2, MAX]  -&gt; true
126              * unordered-is-less means unordered-is-true.
127              *
128              * c &lt; a NC b  (mirrored)
129              * cases for c:
130              *  0         -&gt; a &gt; b
131              *  [1, MAX]  -&gt; false
132              *  -1        -&gt; a &gt;= b
133              *  [MIN, -2] -&gt; true
134              * unordered-is-less means unordered-is-false.
135              *
136              *  We can handle mirroring by swapping a &amp; b and negating the constant.
137              *  @formatter:on
138              */


139             long cst = mirrored ? -primitive.asLong() : primitive.asLong();
140 
141             if (cst == 0) {
<span class="line-modified">142                 return normalizeNode.createLowerComparison(mirrored, constantReflection, metaAccess, options, smallestCompareWidth, view);</span>




143             } else if (cst == 1) {
144                 // a &lt;= b &lt;=&gt; !(a &gt; b)
<span class="line-modified">145                 // since we negate, we have to reverse the unordered result</span>
<span class="line-modified">146                 LogicNode compare = normalizeNode.createLowerComparison(!mirrored, constantReflection, metaAccess, options, smallestCompareWidth, view);</span>





147                 return LogicNegationNode.create(compare);
148             } else if (cst &lt;= -1) {
149                 return LogicConstantNode.contradiction();
150             } else {
151                 assert cst &gt;= 2;
152                 return LogicConstantNode.tautology();
153             }
154         }
155 
156         @Override
157         protected LogicNode findSynonym(ValueNode forX, ValueNode forY, NodeView view) {
158             LogicNode result = super.findSynonym(forX, forY, view);
159             if (result != null) {
160                 return result;
161             }
162             if (forX.stamp(view) instanceof IntegerStamp &amp;&amp; forY.stamp(view) instanceof IntegerStamp) {
163                 if (IntegerStamp.sameSign((IntegerStamp) forX.stamp(view), (IntegerStamp) forY.stamp(view))) {
164                     return new IntegerBelowNode(forX, forY);
165                 }
166             }
</pre>
</td>
</tr>
</table>
<center><a href="IntegerEqualsNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="IntegerLowerThanNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
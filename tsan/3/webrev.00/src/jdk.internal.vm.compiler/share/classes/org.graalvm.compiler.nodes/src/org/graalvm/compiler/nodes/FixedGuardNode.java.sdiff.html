<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/FixedGuardNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EntryMarkerNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FrameState.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/FixedGuardNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes;
 26 
 27 import static org.graalvm.compiler.nodeinfo.InputType.Guard;
 28 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_2;
 29 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_2;
 30 
 31 import org.graalvm.compiler.debug.DebugCloseable;
 32 import org.graalvm.compiler.graph.IterableNodeType;

 33 import org.graalvm.compiler.graph.NodeClass;
 34 import org.graalvm.compiler.graph.NodeSourcePosition;
 35 import org.graalvm.compiler.graph.spi.SimplifierTool;
 36 import org.graalvm.compiler.nodeinfo.NodeInfo;

 37 import org.graalvm.compiler.nodes.spi.Lowerable;
 38 import org.graalvm.compiler.nodes.spi.LoweringTool;

 39 
 40 import jdk.vm.ci.meta.DeoptimizationAction;
 41 import jdk.vm.ci.meta.DeoptimizationReason;
 42 import jdk.vm.ci.meta.SpeculationLog;
 43 
 44 @NodeInfo(nameTemplate = &quot;FixedGuard(!={p#negated}) {p#reason/s}&quot;, allowedUsageTypes = Guard, size = SIZE_2, cycles = CYCLES_2)
<span class="line-modified"> 45 public final class FixedGuardNode extends AbstractFixedGuardNode implements Lowerable, IterableNodeType {</span>
 46     public static final NodeClass&lt;FixedGuardNode&gt; TYPE = NodeClass.create(FixedGuardNode.class);
 47 
 48     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action) {
 49         this(condition, deoptReason, action, SpeculationLog.NO_SPECULATION, false);
 50     }
 51 
 52     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, boolean negated) {
 53         this(condition, deoptReason, action, SpeculationLog.NO_SPECULATION, negated);
 54     }
 55 
 56     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, boolean negated, NodeSourcePosition noDeoptSuccessorPosition) {
 57         this(condition, deoptReason, action, SpeculationLog.NO_SPECULATION, negated, noDeoptSuccessorPosition);
 58     }
 59 
 60     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, SpeculationLog.Speculation speculation, boolean negated) {
 61         super(TYPE, condition, deoptReason, action, speculation, negated);
 62     }
 63 
 64     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, SpeculationLog.Speculation speculation, boolean negated,
 65                     NodeSourcePosition noDeoptSuccessorPosition) {
</pre>
<hr />
<pre>
 98     @SuppressWarnings(&quot;try&quot;)
 99     @Override
100     public void lower(LoweringTool tool) {
101         try (DebugCloseable position = this.withNodeSourcePosition()) {
102             if (graph().getGuardsStage().allowsFloatingGuards()) {
103                 if (getAction() != DeoptimizationAction.None) {
104                     ValueNode guard = tool.createGuard(this, getCondition(), getReason(), getAction(), getSpeculation(), isNegated(), getNoDeoptSuccessorPosition()).asNode();
105                     this.replaceAtUsages(guard);
106                     graph().removeFixed(this);
107                 }
108             } else {
109                 lowerToIf().lower(tool);
110             }
111         }
112     }
113 
114     @Override
115     public boolean canDeoptimize() {
116         return true;
117     }
























































































118 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes;
 26 
 27 import static org.graalvm.compiler.nodeinfo.InputType.Guard;
 28 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_2;
 29 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_2;
 30 
 31 import org.graalvm.compiler.debug.DebugCloseable;
 32 import org.graalvm.compiler.graph.IterableNodeType;
<span class="line-added"> 33 import org.graalvm.compiler.graph.Node;</span>
 34 import org.graalvm.compiler.graph.NodeClass;
 35 import org.graalvm.compiler.graph.NodeSourcePosition;
 36 import org.graalvm.compiler.graph.spi.SimplifierTool;
 37 import org.graalvm.compiler.nodeinfo.NodeInfo;
<span class="line-added"> 38 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;</span>
 39 import org.graalvm.compiler.nodes.spi.Lowerable;
 40 import org.graalvm.compiler.nodes.spi.LoweringTool;
<span class="line-added"> 41 import org.graalvm.compiler.nodes.spi.SwitchFoldable;</span>
 42 
 43 import jdk.vm.ci.meta.DeoptimizationAction;
 44 import jdk.vm.ci.meta.DeoptimizationReason;
 45 import jdk.vm.ci.meta.SpeculationLog;
 46 
 47 @NodeInfo(nameTemplate = &quot;FixedGuard(!={p#negated}) {p#reason/s}&quot;, allowedUsageTypes = Guard, size = SIZE_2, cycles = CYCLES_2)
<span class="line-modified"> 48 public final class FixedGuardNode extends AbstractFixedGuardNode implements Lowerable, IterableNodeType, SwitchFoldable {</span>
 49     public static final NodeClass&lt;FixedGuardNode&gt; TYPE = NodeClass.create(FixedGuardNode.class);
 50 
 51     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action) {
 52         this(condition, deoptReason, action, SpeculationLog.NO_SPECULATION, false);
 53     }
 54 
 55     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, boolean negated) {
 56         this(condition, deoptReason, action, SpeculationLog.NO_SPECULATION, negated);
 57     }
 58 
 59     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, boolean negated, NodeSourcePosition noDeoptSuccessorPosition) {
 60         this(condition, deoptReason, action, SpeculationLog.NO_SPECULATION, negated, noDeoptSuccessorPosition);
 61     }
 62 
 63     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, SpeculationLog.Speculation speculation, boolean negated) {
 64         super(TYPE, condition, deoptReason, action, speculation, negated);
 65     }
 66 
 67     public FixedGuardNode(LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, SpeculationLog.Speculation speculation, boolean negated,
 68                     NodeSourcePosition noDeoptSuccessorPosition) {
</pre>
<hr />
<pre>
101     @SuppressWarnings(&quot;try&quot;)
102     @Override
103     public void lower(LoweringTool tool) {
104         try (DebugCloseable position = this.withNodeSourcePosition()) {
105             if (graph().getGuardsStage().allowsFloatingGuards()) {
106                 if (getAction() != DeoptimizationAction.None) {
107                     ValueNode guard = tool.createGuard(this, getCondition(), getReason(), getAction(), getSpeculation(), isNegated(), getNoDeoptSuccessorPosition()).asNode();
108                     this.replaceAtUsages(guard);
109                     graph().removeFixed(this);
110                 }
111             } else {
112                 lowerToIf().lower(tool);
113             }
114         }
115     }
116 
117     @Override
118     public boolean canDeoptimize() {
119         return true;
120     }
<span class="line-added">121 </span>
<span class="line-added">122     @Override</span>
<span class="line-added">123     public Node getNextSwitchFoldableBranch() {</span>
<span class="line-added">124         return next();</span>
<span class="line-added">125     }</span>
<span class="line-added">126 </span>
<span class="line-added">127     @Override</span>
<span class="line-added">128     public boolean isInSwitch(ValueNode switchValue) {</span>
<span class="line-added">129         return hasNoUsages() &amp;&amp; isNegated() &amp;&amp; SwitchFoldable.maybeIsInSwitch(condition()) &amp;&amp; SwitchFoldable.sameSwitchValue(condition(), switchValue);</span>
<span class="line-added">130     }</span>
<span class="line-added">131 </span>
<span class="line-added">132     @Override</span>
<span class="line-added">133     public void cutOffCascadeNode() {</span>
<span class="line-added">134         /* nop */</span>
<span class="line-added">135     }</span>
<span class="line-added">136 </span>
<span class="line-added">137     @Override</span>
<span class="line-added">138     public void cutOffLowestCascadeNode() {</span>
<span class="line-added">139         setNext(null);</span>
<span class="line-added">140     }</span>
<span class="line-added">141 </span>
<span class="line-added">142     @Override</span>
<span class="line-added">143     public boolean isDefaultSuccessor(AbstractBeginNode beginNode) {</span>
<span class="line-added">144         return beginNode.next() == next();</span>
<span class="line-added">145     }</span>
<span class="line-added">146 </span>
<span class="line-added">147     @Override</span>
<span class="line-added">148     public AbstractBeginNode getDefault() {</span>
<span class="line-added">149         FixedNode defaultNode = next();</span>
<span class="line-added">150         setNext(null);</span>
<span class="line-added">151         return BeginNode.begin(defaultNode);</span>
<span class="line-added">152     }</span>
<span class="line-added">153 </span>
<span class="line-added">154     @Override</span>
<span class="line-added">155     public ValueNode switchValue() {</span>
<span class="line-added">156         if (SwitchFoldable.maybeIsInSwitch(condition())) {</span>
<span class="line-added">157             return ((IntegerEqualsNode) condition()).getX();</span>
<span class="line-added">158         }</span>
<span class="line-added">159         return null;</span>
<span class="line-added">160     }</span>
<span class="line-added">161 </span>
<span class="line-added">162     @Override</span>
<span class="line-added">163     public boolean isNonInitializedProfile() {</span>
<span class="line-added">164         // @formatter:off</span>
<span class="line-added">165         // Checkstyle: stop</span>
<span class="line-added">166         /*</span>
<span class="line-added">167          * These nodes can appear in non initialized cascades. Though they are technically profiled</span>
<span class="line-added">168          * nodes, their presence does not really prevent us from constructing a uniform distribution</span>
<span class="line-added">169          * for the new switch, while keeping these to probability 0. Furthermore, these can be the</span>
<span class="line-added">170          * result of the pattern:</span>
<span class="line-added">171          * if (c) {</span>
<span class="line-added">172          *     CompilerDirectives.transferToInterpreter();</span>
<span class="line-added">173          * }</span>
<span class="line-added">174          * Since we cannot differentiate this case from, say, a guard created because profiling</span>
<span class="line-added">175          * determined that the branch was never taken, and given what we saw before, we will</span>
<span class="line-added">176          * consider all fixedGuards as nodes with no profiles for switch folding purposes.</span>
<span class="line-added">177          */</span>
<span class="line-added">178         // Checkstyle: resume</span>
<span class="line-added">179         // @formatter:on</span>
<span class="line-added">180         return true;</span>
<span class="line-added">181     }</span>
<span class="line-added">182 </span>
<span class="line-added">183     @Override</span>
<span class="line-added">184     public int intKeyAt(int i) {</span>
<span class="line-added">185         assert i == 0;</span>
<span class="line-added">186         return ((IntegerEqualsNode) condition()).getY().asJavaConstant().asInt();</span>
<span class="line-added">187     }</span>
<span class="line-added">188 </span>
<span class="line-added">189     @Override</span>
<span class="line-added">190     public double keyProbability(int i) {</span>
<span class="line-added">191         return 0;</span>
<span class="line-added">192     }</span>
<span class="line-added">193 </span>
<span class="line-added">194     @Override</span>
<span class="line-added">195     public AbstractBeginNode keySuccessor(int i) {</span>
<span class="line-added">196         DeoptimizeNode deopt = new DeoptimizeNode(getAction(), getReason(), getSpeculation());</span>
<span class="line-added">197         deopt.setNodeSourcePosition(getNodeSourcePosition());</span>
<span class="line-added">198         AbstractBeginNode begin = new BeginNode();</span>
<span class="line-added">199         // Link the two nodes, but do not add them to the graph yet, so we do not need to remove</span>
<span class="line-added">200         // them on an abort.</span>
<span class="line-added">201         begin.next = deopt;</span>
<span class="line-added">202         return begin;</span>
<span class="line-added">203     }</span>
<span class="line-added">204 </span>
<span class="line-added">205     @Override</span>
<span class="line-added">206     public double defaultProbability() {</span>
<span class="line-added">207         return 1.0d;</span>
<span class="line-added">208     }</span>
209 }
</pre>
</td>
</tr>
</table>
<center><a href="EntryMarkerNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FrameState.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
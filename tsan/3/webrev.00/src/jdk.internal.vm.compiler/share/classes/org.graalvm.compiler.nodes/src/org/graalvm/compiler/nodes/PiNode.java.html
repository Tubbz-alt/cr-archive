<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/PiNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes;
 26 
 27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_0;
 28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_0;
 29 
 30 import org.graalvm.compiler.core.common.type.AbstractPointerStamp;
 31 import org.graalvm.compiler.core.common.type.ObjectStamp;
 32 import org.graalvm.compiler.core.common.type.Stamp;
 33 import org.graalvm.compiler.core.common.type.StampFactory;
 34 import org.graalvm.compiler.core.common.type.TypeReference;
 35 import org.graalvm.compiler.debug.DebugContext;
 36 import org.graalvm.compiler.graph.Node;
 37 import org.graalvm.compiler.graph.NodeClass;
 38 import org.graalvm.compiler.graph.spi.Canonicalizable;
 39 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 40 import org.graalvm.compiler.nodeinfo.NodeInfo;
 41 import org.graalvm.compiler.nodes.extended.GuardingNode;
 42 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 43 import org.graalvm.compiler.nodes.memory.ReadNode;
 44 import org.graalvm.compiler.nodes.spi.LIRLowerable;
 45 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
 46 import org.graalvm.compiler.nodes.spi.ValueProxy;
 47 import org.graalvm.compiler.nodes.spi.Virtualizable;
 48 import org.graalvm.compiler.nodes.spi.VirtualizerTool;
 49 import org.graalvm.compiler.nodes.type.StampTool;
 50 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 51 
 52 import jdk.vm.ci.meta.JavaKind;
 53 import jdk.vm.ci.meta.ResolvedJavaMethod;
 54 import jdk.vm.ci.meta.ResolvedJavaType;
 55 
 56 //JaCoCo Exclude
 57 
 58 /**
 59  * A node that changes the type of its input, usually narrowing it. For example, a {@link PiNode}
 60  * refines the type of a receiver during type-guarded inlining to be the type tested by the guard.
 61  *
 62  * In contrast to a {@link GuardedValueNode}, a {@link PiNode} is useless as soon as the type of its
 63  * input is as narrow or narrower than the {@link PiNode}&#39;s type. The {@link PiNode}, and therefore
 64  * also the scheduling restriction enforced by the guard, will go away.
 65  */
 66 @NodeInfo(cycles = CYCLES_0, size = SIZE_0)
 67 public class PiNode extends FloatingGuardedNode implements LIRLowerable, Virtualizable, Canonicalizable, ValueProxy {
 68 
 69     public static final NodeClass&lt;PiNode&gt; TYPE = NodeClass.create(PiNode.class);
 70     @Input ValueNode object;
 71     protected Stamp piStamp;
 72 
 73     public ValueNode object() {
 74         return object;
 75     }
 76 
 77     protected PiNode(NodeClass&lt;? extends PiNode&gt; c, ValueNode object, Stamp stamp, GuardingNode guard) {
 78         super(c, stamp, guard);
 79         this.object = object;
 80         this.piStamp = stamp;
 81         assert piStamp.isCompatible(object.stamp(NodeView.DEFAULT)) : &quot;Object stamp not compatible to piStamp&quot;;
 82         inferStamp();
 83     }
 84 
 85     public PiNode(ValueNode object, Stamp stamp) {
 86         this(object, stamp, null);
 87     }
 88 
 89     public PiNode(ValueNode object, Stamp stamp, ValueNode guard) {
 90         this(TYPE, object, stamp, (GuardingNode) guard);
 91     }
 92 
 93     public PiNode(ValueNode object, ValueNode guard) {
 94         this(object, AbstractPointerStamp.pointerNonNull(object.stamp(NodeView.DEFAULT)), guard);
 95     }
 96 
 97     public PiNode(ValueNode object, ResolvedJavaType toType, boolean exactType, boolean nonNull) {
 98         this(object, StampFactory.object(exactType ? TypeReference.createExactTrusted(toType) : TypeReference.createWithoutAssumptions(toType),
 99                         nonNull || StampTool.isPointerNonNull(object.stamp(NodeView.DEFAULT))));
100     }
101 
102     public static ValueNode create(ValueNode object, Stamp stamp) {
103         ValueNode value = canonical(object, stamp, null, null);
104         if (value != null) {
105             return value;
106         }
107         return new PiNode(object, stamp);
108     }
109 
110     public static ValueNode create(ValueNode object, Stamp stamp, ValueNode guard) {
111         ValueNode value = canonical(object, stamp, (GuardingNode) guard, null);
112         if (value != null) {
113             return value;
114         }
115         return new PiNode(object, stamp, guard);
116     }
117 
118     public static ValueNode create(ValueNode object, ValueNode guard) {
119         Stamp stamp = AbstractPointerStamp.pointerNonNull(object.stamp(NodeView.DEFAULT));
120         ValueNode value = canonical(object, stamp, (GuardingNode) guard, null);
121         if (value != null) {
122             return value;
123         }
124         return new PiNode(object, stamp, guard);
125     }
126 
127     @SuppressWarnings(&quot;unused&quot;)
128     public static boolean intrinsify(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode object, ValueNode guard) {
129         Stamp stamp = AbstractPointerStamp.pointerNonNull(object.stamp(NodeView.DEFAULT));
130         ValueNode value = canonical(object, stamp, (GuardingNode) guard, null);
131         if (value == null) {
132             value = new PiNode(object, stamp, guard);
133         }
134         b.push(JavaKind.Object, b.append(value));
135         return true;
136     }
137 
138     @SuppressWarnings(&quot;unused&quot;)
139     public static boolean intrinsify(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode object, ResolvedJavaType toType, boolean exactType, boolean nonNull) {
140         Stamp stamp = StampFactory.object(exactType ? TypeReference.createExactTrusted(toType) : TypeReference.createWithoutAssumptions(toType),
141                         nonNull || StampTool.isPointerNonNull(object.stamp(NodeView.DEFAULT)));
142         ValueNode value = canonical(object, stamp, null, null);
143         if (value == null) {
144             value = new PiNode(object, stamp);
145         }
146         b.push(JavaKind.Object, b.append(value));
147         return true;
148     }
149 
150     public final Stamp piStamp() {
151         return piStamp;
152     }
153 
154     public void strengthenPiStamp(Stamp newPiStamp) {
155         assert this.piStamp.join(newPiStamp).equals(newPiStamp) : &quot;stamp can only improve&quot;;
156         this.piStamp = newPiStamp;
157     }
158 
159     @Override
160     public void generate(NodeLIRBuilderTool generator) {
161         if (generator.hasOperand(object)) {
162             generator.setResult(this, generator.operand(object));
163         }
164     }
165 
166     @Override
167     public boolean inferStamp() {
168         return updateStamp(computeStamp());
169     }
170 
171     private Stamp computeStamp() {
172         return piStamp.improveWith(object().stamp(NodeView.DEFAULT));
173     }
174 
175     @Override
176     public void virtualize(VirtualizerTool tool) {
177         ValueNode alias = tool.getAlias(object());
178         if (alias instanceof VirtualObjectNode) {
179             VirtualObjectNode virtual = (VirtualObjectNode) alias;
180             ResolvedJavaType type = StampTool.typeOrNull(this, tool.getMetaAccess());
181             if (type != null &amp;&amp; type.isAssignableFrom(virtual.type())) {
182                 tool.replaceWithVirtual(virtual);
183             } else {
184                 tool.getDebug().log(DebugContext.INFO_LEVEL, &quot;could not virtualize Pi because of type mismatch: %s %s vs %s&quot;, this, type, virtual.type());
185             }
186         }
187     }
188 
189     public static ValueNode canonical(ValueNode object, Stamp stamp, GuardingNode guard, PiNode self) {
190         // Use most up to date stamp.
191         Stamp computedStamp = stamp.improveWith(object.stamp(NodeView.DEFAULT));
192 
193         // The pi node does not give any additional information =&gt; skip it.
194         if (computedStamp.equals(object.stamp(NodeView.DEFAULT))) {
195             return object;
196         }
197 
198         if (guard == null) {
199             // Try to merge the pi node with a load node.
200             if (object instanceof ReadNode &amp;&amp; !object.hasMoreThanOneUsage()) {
201                 ReadNode readNode = (ReadNode) object;
202                 readNode.setStamp(readNode.stamp(NodeView.DEFAULT).improveWith(stamp));
203                 return readNode;
204             }
205         } else {
206             for (Node n : guard.asNode().usages()) {
207                 if (n instanceof PiNode &amp;&amp; n != self) {
208                     PiNode otherPi = (PiNode) n;
209                     assert otherPi.guard == guard;
210                     if (object == otherPi.object() &amp;&amp; computedStamp.equals(otherPi.stamp(NodeView.DEFAULT))) {
211                         /*
212                          * Two PiNodes with the same guard and same result, so return the one with
213                          * the more precise piStamp.
214                          */
215                         Stamp newStamp = stamp.join(otherPi.piStamp);
216                         if (newStamp.equals(otherPi.piStamp)) {
217                             return otherPi;
218                         }
219                     }
220                 }
221             }
222         }
223         return null;
224     }
225 
226     @Override
227     public Node canonical(CanonicalizerTool tool) {
228         Node value = canonical(object(), piStamp(), getGuard(), this);
229         if (value != null) {
230             return value;
231         }
232         return this;
233     }
234 
235     @Override
236     public ValueNode getOriginalNode() {
237         return object;
238     }
239 
240     public void setOriginalNode(ValueNode newNode) {
241         this.updateUsages(object, newNode);
242         this.object = newNode;
243         assert piStamp.isCompatible(object.stamp(NodeView.DEFAULT)) : &quot;New object stamp not compatible to piStamp&quot;;
244     }
245 
246     /**
247      * Casts an object to have an exact, non-null stamp representing {@link Class}.
248      */
249     public static Class&lt;?&gt; asNonNullClass(Object object) {
250         return asNonNullClassIntrinsic(object, Class.class, true, true);
251     }
252 
253     /**
254      * Casts an object to have an exact, non-null stamp representing {@link Class}.
255      */
256     public static Class&lt;?&gt; asNonNullObject(Object object) {
257         return asNonNullClassIntrinsic(object, Object.class, false, true);
258     }
259 
260     @NodeIntrinsic(PiNode.class)
261     private static native Class&lt;?&gt; asNonNullClassIntrinsic(Object object, @ConstantNodeParameter Class&lt;?&gt; toType, @ConstantNodeParameter boolean exactType, @ConstantNodeParameter boolean nonNull);
262 
263     /**
264      * Changes the stamp of an object inside a snippet to be the stamp of the node replaced by the
265      * snippet.
266      */
267     @NodeIntrinsic(PiNode.Placeholder.class)
268     public static native Object piCastToSnippetReplaceeStamp(Object object);
269 
270     /**
271      * Changes the stamp of an object and ensures the newly stamped value is non-null and does not
272      * float above a given guard.
273      */
274     @NodeIntrinsic
275     public static native Object piCastNonNull(Object object, GuardingNode guard);
276 
277     /**
278      * Changes the stamp of an object and ensures the newly stamped value is non-null and does not
279      * float above a given guard.
280      */
281     @NodeIntrinsic
282     public static native Class&lt;?&gt; piCastNonNullClass(Class&lt;?&gt; type, GuardingNode guard);
283 
284     /**
285      * Changes the stamp of an object to represent a given type and to indicate that the object is
286      * not null.
287      */
288     public static Object piCastNonNull(Object object, @ConstantNodeParameter ResolvedJavaType toType) {
289         return piCast(object, toType, false, true);
290     }
291 
292     @NodeIntrinsic
293     public static native Object piCast(Object object, @ConstantNodeParameter ResolvedJavaType toType, @ConstantNodeParameter boolean exactType, @ConstantNodeParameter boolean nonNull);
294 
295     /**
296      * A placeholder node in a snippet that will be replaced with a {@link PiNode} when the snippet
297      * is instantiated.
298      */
299     @NodeInfo(cycles = CYCLES_0, size = SIZE_0)
300     public static class Placeholder extends FloatingGuardedNode {
301 
302         public static final NodeClass&lt;Placeholder&gt; TYPE = NodeClass.create(Placeholder.class);
303         @Input ValueNode object;
304 
305         public ValueNode object() {
306             return object;
307         }
308 
309         protected Placeholder(NodeClass&lt;? extends Placeholder&gt; c, ValueNode object) {
310             super(c, PlaceholderStamp.SINGLETON, null);
311             this.object = object;
312         }
313 
314         public Placeholder(ValueNode object) {
315             this(TYPE, object);
316         }
317 
318         /**
319          * Replaces this node with a {@link PiNode} during snippet instantiation.
320          *
321          * @param snippetReplaceeStamp the stamp of the node being replace by the snippet
322          */
323         public void makeReplacement(Stamp snippetReplaceeStamp) {
324             ValueNode value = graph().maybeAddOrUnique(PiNode.create(object(), snippetReplaceeStamp, null));
325             replaceAndDelete(value);
326         }
327     }
328 
329     /**
330      * A stamp for {@link Placeholder} nodes which are only used in snippets. It is replaced by an
331      * actual stamp when the snippet is instantiated.
332      */
333     public static final class PlaceholderStamp extends ObjectStamp {
334         private static final PlaceholderStamp SINGLETON = new PlaceholderStamp();
335 
336         public static PlaceholderStamp singleton() {
337             return SINGLETON;
338         }
339 
340         private PlaceholderStamp() {
341             super(null, false, false, false);
342         }
343 
344         @Override
345         public int hashCode() {
346             return System.identityHashCode(this);
347         }
348 
349         @Override
350         public boolean equals(Object obj) {
351             return this == obj;
352         }
353 
354         @Override
355         public String toString() {
356             return &quot;PlaceholderStamp&quot;;
357         }
358     }
359 }
    </pre>
  </body>
</html>
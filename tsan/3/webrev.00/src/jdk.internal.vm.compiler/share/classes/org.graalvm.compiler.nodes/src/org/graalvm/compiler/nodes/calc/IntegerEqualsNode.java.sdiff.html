<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/IntegerEqualsNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IntegerDivRemNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="IntegerLessThanNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/IntegerEqualsNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 92         LogicNode value = OP.canonical(constantReflection, metaAccess, options, smallestCompareWidth, CanonicalCondition.EQ, false, x, y, view);
 93         if (value != null) {
 94             return value;
 95         }
 96         return create(x, y, view);
 97     }
 98 
 99     @Override
100     public Node canonical(CanonicalizerTool tool, ValueNode forX, ValueNode forY) {
101         NodeView view = NodeView.from(tool);
102         ValueNode value = OP.canonical(tool.getConstantReflection(), tool.getMetaAccess(), tool.getOptions(), tool.smallestCompareWidth(), CanonicalCondition.EQ, false, forX, forY, view);
103         if (value != null) {
104             return value;
105         }
106         return this;
107     }
108 
109     public static class IntegerEqualsOp extends CompareOp {
110         @Override
111         protected LogicNode optimizeNormalizeCompare(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth,
<span class="line-modified">112                         Constant constant, NormalizeCompareNode normalizeNode, boolean mirrored, NodeView view) {</span>
113             PrimitiveConstant primitive = (PrimitiveConstant) constant;
<span class="line-removed">114             ValueNode a = normalizeNode.getX();</span>
<span class="line-removed">115             ValueNode b = normalizeNode.getY();</span>
116             long cst = primitive.asLong();
<span class="line-removed">117 </span>
118             if (cst == 0) {
<span class="line-modified">119                 if (normalizeNode.getX().getStackKind() == JavaKind.Double || normalizeNode.getX().getStackKind() == JavaKind.Float) {</span>
<span class="line-removed">120                     return FloatEqualsNode.create(constantReflection, metaAccess, options, smallestCompareWidth, a, b, view);</span>
<span class="line-removed">121                 } else {</span>
<span class="line-removed">122                     return IntegerEqualsNode.create(constantReflection, metaAccess, options, smallestCompareWidth, a, b, view);</span>
<span class="line-removed">123                 }</span>
124             } else if (cst == 1) {
<span class="line-modified">125                 if (normalizeNode.getX().getStackKind() == JavaKind.Double || normalizeNode.getX().getStackKind() == JavaKind.Float) {</span>
<span class="line-removed">126                     return FloatLessThanNode.create(b, a, !normalizeNode.isUnorderedLess, view);</span>
<span class="line-removed">127                 } else {</span>
<span class="line-removed">128                     return IntegerLessThanNode.create(constantReflection, metaAccess, options, smallestCompareWidth, b, a, view);</span>
<span class="line-removed">129                 }</span>
130             } else if (cst == -1) {
<span class="line-modified">131                 if (normalizeNode.getX().getStackKind() == JavaKind.Double || normalizeNode.getX().getStackKind() == JavaKind.Float) {</span>
<span class="line-removed">132                     return FloatLessThanNode.create(a, b, normalizeNode.isUnorderedLess, view);</span>
<span class="line-removed">133                 } else {</span>
<span class="line-removed">134                     return IntegerLessThanNode.create(constantReflection, metaAccess, options, smallestCompareWidth, a, b, view);</span>
<span class="line-removed">135                 }</span>
136             } else {
137                 return LogicConstantNode.contradiction();
138             }
139         }
140 
141         @Override
142         protected CompareNode duplicateModified(ValueNode newX, ValueNode newY, boolean unorderedIsTrue, NodeView view) {
143             if (newX.stamp(view) instanceof FloatStamp &amp;&amp; newY.stamp(view) instanceof FloatStamp) {
144                 return new FloatEqualsNode(newX, newY);
145             } else if (newX.stamp(view) instanceof IntegerStamp &amp;&amp; newY.stamp(view) instanceof IntegerStamp) {
146                 return new IntegerEqualsNode(newX, newY);
147             } else if (newX.stamp(view) instanceof AbstractPointerStamp &amp;&amp; newY.stamp(view) instanceof AbstractPointerStamp) {
148                 return new IntegerEqualsNode(newX, newY);
149             }
150             throw GraalError.shouldNotReachHere();
151         }
152 
153         @Override
154         public LogicNode canonical(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth, CanonicalCondition condition,
155                         boolean unorderedIsTrue, ValueNode forX, ValueNode forY, NodeView view) {
</pre>
</td>
<td>
<hr />
<pre>
 92         LogicNode value = OP.canonical(constantReflection, metaAccess, options, smallestCompareWidth, CanonicalCondition.EQ, false, x, y, view);
 93         if (value != null) {
 94             return value;
 95         }
 96         return create(x, y, view);
 97     }
 98 
 99     @Override
100     public Node canonical(CanonicalizerTool tool, ValueNode forX, ValueNode forY) {
101         NodeView view = NodeView.from(tool);
102         ValueNode value = OP.canonical(tool.getConstantReflection(), tool.getMetaAccess(), tool.getOptions(), tool.smallestCompareWidth(), CanonicalCondition.EQ, false, forX, forY, view);
103         if (value != null) {
104             return value;
105         }
106         return this;
107     }
108 
109     public static class IntegerEqualsOp extends CompareOp {
110         @Override
111         protected LogicNode optimizeNormalizeCompare(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth,
<span class="line-modified">112                         Constant constant, AbstractNormalizeCompareNode normalizeNode, boolean mirrored, NodeView view) {</span>
113             PrimitiveConstant primitive = (PrimitiveConstant) constant;


114             long cst = primitive.asLong();

115             if (cst == 0) {
<span class="line-modified">116                 return normalizeNode.createEqualComparison(constantReflection, metaAccess, options, smallestCompareWidth, view);</span>




117             } else if (cst == 1) {
<span class="line-modified">118                 return normalizeNode.createLowerComparison(true, constantReflection, metaAccess, options, smallestCompareWidth, view);</span>




119             } else if (cst == -1) {
<span class="line-modified">120                 return normalizeNode.createLowerComparison(false, constantReflection, metaAccess, options, smallestCompareWidth, view);</span>




121             } else {
122                 return LogicConstantNode.contradiction();
123             }
124         }
125 
126         @Override
127         protected CompareNode duplicateModified(ValueNode newX, ValueNode newY, boolean unorderedIsTrue, NodeView view) {
128             if (newX.stamp(view) instanceof FloatStamp &amp;&amp; newY.stamp(view) instanceof FloatStamp) {
129                 return new FloatEqualsNode(newX, newY);
130             } else if (newX.stamp(view) instanceof IntegerStamp &amp;&amp; newY.stamp(view) instanceof IntegerStamp) {
131                 return new IntegerEqualsNode(newX, newY);
132             } else if (newX.stamp(view) instanceof AbstractPointerStamp &amp;&amp; newY.stamp(view) instanceof AbstractPointerStamp) {
133                 return new IntegerEqualsNode(newX, newY);
134             }
135             throw GraalError.shouldNotReachHere();
136         }
137 
138         @Override
139         public LogicNode canonical(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth, CanonicalCondition condition,
140                         boolean unorderedIsTrue, ValueNode forX, ValueNode forY, NodeView view) {
</pre>
</td>
</tr>
</table>
<center><a href="IntegerDivRemNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="IntegerLessThanNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/StructuredGraph.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.nodes;
  26 
  27 import java.util.ArrayList;
  28 import java.util.Collections;
  29 import java.util.Iterator;
  30 import java.util.List;
  31 import java.util.SortedSet;
  32 import java.util.TreeSet;
  33 import java.util.concurrent.atomic.AtomicLong;
  34 import java.util.function.Consumer;
  35 import java.util.stream.Collectors;
  36 
  37 import jdk.internal.vm.compiler.collections.EconomicMap;
  38 import jdk.internal.vm.compiler.collections.EconomicSet;
  39 import jdk.internal.vm.compiler.collections.Equivalence;
  40 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  41 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  42 import org.graalvm.compiler.api.replacements.Snippet;
  43 import org.graalvm.compiler.core.common.CancellationBailoutException;
  44 import org.graalvm.compiler.core.common.CompilationIdentifier;
  45 import org.graalvm.compiler.core.common.GraalOptions;
  46 import org.graalvm.compiler.core.common.cfg.BlockMap;
  47 import org.graalvm.compiler.core.common.type.Stamp;
  48 import org.graalvm.compiler.debug.DebugContext;
  49 import org.graalvm.compiler.debug.JavaMethodContext;
  50 import org.graalvm.compiler.debug.TTY;
  51 import org.graalvm.compiler.graph.Graph;
  52 import org.graalvm.compiler.graph.Node;
  53 import org.graalvm.compiler.graph.NodeMap;
  54 import org.graalvm.compiler.graph.NodeSourcePosition;
  55 import org.graalvm.compiler.nodes.calc.FloatingNode;
  56 import org.graalvm.compiler.nodes.cfg.Block;
  57 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  58 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  59 import org.graalvm.compiler.nodes.spi.VirtualizableAllocation;
  60 import org.graalvm.compiler.nodes.util.GraphUtil;
  61 import org.graalvm.compiler.options.OptionValues;
  62 
  63 import jdk.vm.ci.code.BytecodeFrame;
  64 import jdk.vm.ci.meta.Assumptions;
  65 import jdk.vm.ci.meta.Assumptions.Assumption;
  66 import jdk.vm.ci.meta.DefaultProfilingInfo;
  67 import jdk.vm.ci.meta.JavaMethod;
  68 import jdk.vm.ci.meta.ProfilingInfo;
  69 import jdk.vm.ci.meta.ResolvedJavaField;
  70 import jdk.vm.ci.meta.ResolvedJavaMethod;
  71 import jdk.vm.ci.meta.SpeculationLog;
  72 import jdk.vm.ci.meta.TriState;
  73 import jdk.vm.ci.runtime.JVMCICompiler;
  74 
  75 /**
  76  * A graph that contains at least one distinguished node : the {@link #start() start} node. This
  77  * node is the start of the control flow of the graph.
  78  */
  79 public final class StructuredGraph extends Graph implements JavaMethodContext {
  80 
  81     /**
  82      * The different stages of the compilation of a {@link Graph} regarding the status of
  83      * {@link GuardNode guards}, {@link DeoptimizingNode deoptimizations} and {@link FrameState
  84      * framestates}. The stage of a graph progresses monotonously.
  85      *
  86      */
  87     public enum GuardsStage {
  88         /**
  89          * During this stage, there can be {@link FloatingNode floating} {@link DeoptimizingNode}
  90          * such as {@link GuardNode GuardNodes}. New {@link DeoptimizingNode DeoptimizingNodes} can
  91          * be introduced without constraints. {@link FrameState} nodes are associated with
  92          * {@link StateSplit} nodes.
  93          */
  94         FLOATING_GUARDS,
  95         /**
  96          * During this stage, all {@link DeoptimizingNode DeoptimizingNodes} must be
  97          * {@link FixedNode fixed} but new {@link DeoptimizingNode DeoptimizingNodes} can still be
  98          * introduced. {@link FrameState} nodes are still associated with {@link StateSplit} nodes.
  99          */
 100         FIXED_DEOPTS,
 101         /**
 102          * During this stage, all {@link DeoptimizingNode DeoptimizingNodes} must be
 103          * {@link FixedNode fixed}. New {@link DeoptimizingNode DeoptimizingNodes} can not be
 104          * introduced any more. {@link FrameState} nodes are now associated with
 105          * {@link DeoptimizingNode} nodes.
 106          */
 107         AFTER_FSA;
 108 
 109         public boolean allowsFloatingGuards() {
 110             return this == FLOATING_GUARDS;
 111         }
 112 
 113         public boolean allowsGuardInsertion() {
 114             return this.ordinal() &lt;= FIXED_DEOPTS.ordinal();
 115         }
 116 
 117         public boolean areFrameStatesAtDeopts() {
 118             return this == AFTER_FSA;
 119         }
 120 
 121         public boolean areFrameStatesAtSideEffects() {
 122             return !this.areFrameStatesAtDeopts();
 123         }
 124 
 125         public boolean areDeoptsFixed() {
 126             return this.ordinal() &gt;= FIXED_DEOPTS.ordinal();
 127         }
<a name="2" id="anc2"></a><span class="line-added"> 128 </span>
<span class="line-added"> 129         public boolean requiresValueProxies() {</span>
<span class="line-added"> 130             return this != AFTER_FSA;</span>
<span class="line-added"> 131         }</span>
 132     }
 133 
 134     /**
 135      * Constants denoting whether or not {@link Assumption}s can be made while processing a graph.
 136      */
 137     public enum AllowAssumptions {
 138         YES,
 139         NO;
 140         public static AllowAssumptions ifTrue(boolean flag) {
 141             return flag ? YES : NO;
 142         }
 143 
 144         public static AllowAssumptions ifNonNull(Assumptions assumptions) {
 145             return assumptions != null ? YES : NO;
 146         }
 147     }
 148 
 149     public static class ScheduleResult {
 150         private final ControlFlowGraph cfg;
 151         private final NodeMap&lt;Block&gt; nodeToBlockMap;
 152         private final BlockMap&lt;List&lt;Node&gt;&gt; blockToNodesMap;
 153 
 154         public ScheduleResult(ControlFlowGraph cfg, NodeMap&lt;Block&gt; nodeToBlockMap, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodesMap) {
 155             this.cfg = cfg;
 156             this.nodeToBlockMap = nodeToBlockMap;
 157             this.blockToNodesMap = blockToNodesMap;
 158         }
 159 
 160         public ControlFlowGraph getCFG() {
 161             return cfg;
 162         }
 163 
 164         public NodeMap&lt;Block&gt; getNodeToBlockMap() {
 165             return nodeToBlockMap;
 166         }
 167 
 168         public BlockMap&lt;List&lt;Node&gt;&gt; getBlockToNodesMap() {
 169             return blockToNodesMap;
 170         }
 171 
 172         public List&lt;Node&gt; nodesFor(Block block) {
 173             return blockToNodesMap.get(block);
 174         }
 175     }
 176 
 177     /**
 178      * Object used to create a {@link StructuredGraph}.
 179      */
 180     public static class Builder {
 181         private String name;
 182         private final Assumptions assumptions;
 183         private SpeculationLog speculationLog;
 184         private ResolvedJavaMethod rootMethod;
 185         private CompilationIdentifier compilationId = CompilationIdentifier.INVALID_COMPILATION_ID;
 186         private int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;
 187         private boolean useProfilingInfo = true;
 188         private boolean recordInlinedMethods = true;
 189         private boolean trackNodeSourcePosition;
 190         private final OptionValues options;
 191         private Cancellable cancellable = null;
 192         private final DebugContext debug;
 193         private NodeSourcePosition callerContext;
 194         private boolean isSubstitution;
 195 
 196         /**
 197          * Creates a builder for a graph.
 198          */
 199         public Builder(OptionValues options, DebugContext debug, AllowAssumptions allowAssumptions) {
 200             this.options = options;
 201             this.debug = debug;
 202             this.assumptions = allowAssumptions == AllowAssumptions.YES ? new Assumptions() : null;
 203             this.trackNodeSourcePosition = Graph.trackNodeSourcePositionDefault(options, debug);
 204         }
 205 
 206         /**
 207          * Creates a builder for a graph that does not support {@link Assumptions}.
 208          */
 209         public Builder(OptionValues options, DebugContext debug) {
 210             this.options = options;
 211             this.debug = debug;
 212             this.assumptions = null;
 213             this.trackNodeSourcePosition = Graph.trackNodeSourcePositionDefault(options, debug);
 214         }
 215 
 216         public String getName() {
 217             return name;
 218         }
 219 
 220         public Builder name(String s) {
 221             this.name = s;
 222             return this;
 223         }
 224 
 225         /**
 226          * @see StructuredGraph#isSubstitution
 227          */
 228         public Builder setIsSubstitution(boolean flag) {
 229             this.isSubstitution = flag;
 230             return this;
 231         }
 232 
 233         public ResolvedJavaMethod getMethod() {
 234             return rootMethod;
 235         }
 236 
 237         public Builder method(ResolvedJavaMethod method) {
 238             this.rootMethod = method;
 239             return this;
 240         }
 241 
 242         public DebugContext getDebug() {
 243             return debug;
 244         }
 245 
 246         public SpeculationLog getSpeculationLog() {
 247             return speculationLog;
 248         }
 249 
 250         public Builder speculationLog(SpeculationLog log) {
 251             this.speculationLog = log;
 252             return this;
 253         }
 254 
 255         public CompilationIdentifier getCompilationId() {
 256             return compilationId;
 257         }
 258 
 259         public Builder compilationId(CompilationIdentifier id) {
 260             this.compilationId = id;
 261             return this;
 262         }
 263 
 264         public Cancellable getCancellable() {
 265             return cancellable;
 266         }
 267 
 268         public Builder cancellable(Cancellable cancel) {
 269             this.cancellable = cancel;
 270             return this;
 271         }
 272 
 273         public int getEntryBCI() {
 274             return entryBCI;
 275         }
 276 
 277         public Builder entryBCI(int bci) {
 278             this.entryBCI = bci;
 279             return this;
 280         }
 281 
 282         public boolean getUseProfilingInfo() {
 283             return useProfilingInfo;
 284         }
 285 
 286         public Builder useProfilingInfo(boolean flag) {
 287             this.useProfilingInfo = flag;
 288             return this;
 289         }
 290 
 291         public boolean getRecordInlinedMethods() {
 292             return recordInlinedMethods;
 293         }
 294 
 295         public Builder recordInlinedMethods(boolean flag) {
 296             this.recordInlinedMethods = flag;
 297             return this;
 298         }
 299 
 300         public Builder trackNodeSourcePosition(boolean flag) {
 301             if (flag) {
 302                 this.trackNodeSourcePosition = true;
 303             }
 304             return this;
 305         }
 306 
 307         public Builder callerContext(NodeSourcePosition context) {
 308             this.callerContext = context;
 309             return this;
 310         }
 311 
 312         public StructuredGraph build() {
 313             List&lt;ResolvedJavaMethod&gt; inlinedMethods = recordInlinedMethods ? new ArrayList&lt;&gt;() : null;
 314             // @formatter:off
 315             return new StructuredGraph(name,
 316                             rootMethod,
 317                             entryBCI,
 318                             assumptions,
 319                             speculationLog,
 320                             useProfilingInfo,
 321                             isSubstitution,
 322                             inlinedMethods,
 323                             trackNodeSourcePosition,
 324                             compilationId,
 325                             options,
 326                             debug,
 327                             cancellable,
 328                             callerContext);
 329             // @formatter:on
 330         }
 331     }
 332 
 333     public static final long INVALID_GRAPH_ID = -1;
 334     private static final AtomicLong uniqueGraphIds = new AtomicLong();
 335 
 336     private StartNode start;
 337     private ResolvedJavaMethod rootMethod;
 338     private final long graphId;
 339     private final CompilationIdentifier compilationId;
 340     private final int entryBCI;
 341     private GuardsStage guardsStage = GuardsStage.FLOATING_GUARDS;
 342     private boolean isAfterFloatingReadPhase = false;
 343     private boolean isAfterFixedReadPhase = false;
 344     private boolean hasValueProxies = true;
 345     private boolean isAfterExpandLogic = false;
 346     private final boolean useProfilingInfo;
 347     private final Cancellable cancellable;
 348     private final boolean isSubstitution;
 349 
 350     /**
 351      * The assumptions made while constructing and transforming this graph.
 352      */
 353     private final Assumptions assumptions;
 354 
 355     private SpeculationLog speculationLog;
 356 
 357     private ScheduleResult lastSchedule;
 358 
 359     private final InliningLog inliningLog;
 360 
 361     /**
 362      * Call stack (context) leading to construction of this graph.
 363      */
 364     private final NodeSourcePosition callerContext;
 365 
 366     /**
 367      * Records the methods that were used while constructing this graph, one entry for each time a
 368      * specific method is used. This will be {@code null} if recording of inlined methods is
 369      * disabled for the graph.
 370      */
 371     private final List&lt;ResolvedJavaMethod&gt; methods;
 372 
 373     /**
 374      * Records the fields that were accessed while constructing this graph.
 375      */
 376     private EconomicSet&lt;ResolvedJavaField&gt; fields = null;
 377 
 378     private enum UnsafeAccessState {
 379         NO_ACCESS,
 380         HAS_ACCESS,
 381         DISABLED
 382     }
 383 
 384     private UnsafeAccessState hasUnsafeAccess = UnsafeAccessState.NO_ACCESS;
 385 
 386     public static final boolean USE_PROFILING_INFO = true;
 387 
 388     public static final boolean NO_PROFILING_INFO = false;
 389 
 390     private StructuredGraph(String name,
 391                     ResolvedJavaMethod method,
 392                     int entryBCI,
 393                     Assumptions assumptions,
 394                     SpeculationLog speculationLog,
 395                     boolean useProfilingInfo,
 396                     boolean isSubstitution,
 397                     List&lt;ResolvedJavaMethod&gt; methods,
 398                     boolean trackNodeSourcePosition,
 399                     CompilationIdentifier compilationId,
 400                     OptionValues options,
 401                     DebugContext debug,
 402                     Cancellable cancellable,
 403                     NodeSourcePosition context) {
 404         super(name, options, debug, trackNodeSourcePosition);
 405         this.setStart(add(new StartNode()));
 406         this.rootMethod = method;
 407         this.graphId = uniqueGraphIds.incrementAndGet();
 408         this.compilationId = compilationId;
 409         this.entryBCI = entryBCI;
 410         this.assumptions = assumptions;
 411         this.methods = methods;
 412         this.speculationLog = speculationLog;
 413         this.useProfilingInfo = useProfilingInfo;
 414         this.isSubstitution = isSubstitution;
 415         assert checkIsSubstitutionInvariants(method, isSubstitution);
 416         this.cancellable = cancellable;
 417         this.inliningLog = new InliningLog(rootMethod, GraalOptions.TraceInlining.getValue(options));
 418         this.callerContext = context;
 419     }
 420 
 421     private static boolean checkIsSubstitutionInvariants(ResolvedJavaMethod method, boolean isSubstitution) {
 422         if (method != null) {
 423             if (method.getAnnotation(Snippet.class) != null || method.getAnnotation(MethodSubstitution.class) != null) {
 424                 assert isSubstitution : &quot;Graph for method &quot; + method.format(&quot;%H.%n(%p)&quot;) +
 425                                 &quot; annotated by &quot; + Snippet.class.getName() + &quot; or &quot; +
 426                                 MethodSubstitution.class.getName() +
 427                                 &quot; must have its `isSubstitution` field set to true&quot;;
 428             }
 429         }
 430         return true;
 431     }
 432 
 433     public void setLastSchedule(ScheduleResult result) {
 434         lastSchedule = result;
 435     }
 436 
 437     public ScheduleResult getLastSchedule() {
 438         return lastSchedule;
 439     }
 440 
 441     public void clearLastSchedule() {
 442         setLastSchedule(null);
 443     }
 444 
 445     @Override
 446     public boolean maybeCompress() {
 447         if (super.maybeCompress()) {
 448             /*
 449              * The schedule contains a NodeMap which is unusable after compression.
 450              */
 451             clearLastSchedule();
 452             return true;
 453         }
 454         return false;
 455     }
 456 
 457     public Stamp getReturnStamp() {
 458         Stamp returnStamp = null;
 459         for (ReturnNode returnNode : getNodes(ReturnNode.TYPE)) {
 460             ValueNode result = returnNode.result();
 461             if (result != null) {
 462                 if (returnStamp == null) {
 463                     returnStamp = result.stamp(NodeView.DEFAULT);
 464                 } else {
 465                     returnStamp = returnStamp.meet(result.stamp(NodeView.DEFAULT));
 466                 }
 467             }
 468         }
 469         return returnStamp;
 470     }
 471 
 472     @Override
 473     public String toString() {
 474         StringBuilder buf = new StringBuilder(getClass().getSimpleName() + &quot;:&quot; + graphId);
 475         String sep = &quot;{&quot;;
 476         if (name != null) {
 477             buf.append(sep);
 478             buf.append(name);
 479             sep = &quot;, &quot;;
 480         }
 481         if (method() != null) {
 482             buf.append(sep);
 483             buf.append(method());
 484             sep = &quot;, &quot;;
 485         }
 486 
 487         if (!sep.equals(&quot;{&quot;)) {
 488             buf.append(&quot;}&quot;);
 489         }
 490         return buf.toString();
 491     }
 492 
 493     public StartNode start() {
 494         return start;
 495     }
 496 
 497     /**
 498      * Gets the root method from which this graph was built.
 499      *
 500      * @return null if this method was not built from a method or the method is not available
 501      */
 502     public ResolvedJavaMethod method() {
 503         return rootMethod;
 504     }
 505 
 506     public int getEntryBCI() {
 507         return entryBCI;
 508     }
 509 
 510     public Cancellable getCancellable() {
 511         return cancellable;
 512     }
 513 
 514     public void checkCancellation() {
 515         if (cancellable != null &amp;&amp; cancellable.isCancelled()) {
 516             CancellationBailoutException.cancelCompilation();
 517         }
 518     }
 519 
 520     public boolean isOSR() {
 521         return entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
 522     }
 523 
 524     public long graphId() {
 525         return graphId;
 526     }
 527 
 528     /**
 529      * @see CompilationIdentifier
 530      */
 531     public CompilationIdentifier compilationId() {
 532         return compilationId;
 533     }
 534 
 535     public void setStart(StartNode start) {
 536         this.start = start;
 537     }
 538 
 539     public InliningLog getInliningLog() {
 540         return inliningLog;
 541     }
 542 
 543     public void logInliningTree() {
 544         if (GraalOptions.TraceInlining.getValue(getOptions())) {
 545             String formattedTree = getInliningLog().formatAsTree(true);
 546             if (formattedTree != null) {
 547                 TTY.println(formattedTree);
 548             }
 549         }
 550     }
 551 
 552     /**
 553      * Creates a copy of this graph.
 554      *
 555      * @param newName the name of the copy, used for debugging purposes (can be null)
 556      * @param duplicationMapCallback consumer of the duplication map created during the copying
 557      * @param debugForCopy the debug context for the graph copy. This must not be the debug for this
 558      *            graph if this graph can be accessed from multiple threads (e.g., it&#39;s in a cache
 559      *            accessed by multiple threads).
 560      */
 561     @Override
 562     protected Graph copy(String newName, Consumer&lt;UnmodifiableEconomicMap&lt;Node, Node&gt;&gt; duplicationMapCallback, DebugContext debugForCopy) {
 563         return copy(newName, duplicationMapCallback, compilationId, debugForCopy);
 564     }
 565 
 566     @SuppressWarnings(&quot;try&quot;)
 567     private StructuredGraph copy(String newName, Consumer&lt;UnmodifiableEconomicMap&lt;Node, Node&gt;&gt; duplicationMapCallback, CompilationIdentifier newCompilationId, DebugContext debugForCopy) {
 568         AllowAssumptions allowAssumptions = AllowAssumptions.ifNonNull(assumptions);
 569         StructuredGraph copy = new StructuredGraph(newName,
 570                         method(),
 571                         entryBCI,
 572                         assumptions == null ? null : new Assumptions(),
 573                         speculationLog,
 574                         useProfilingInfo,
 575                         isSubstitution,
 576                         methods != null ? new ArrayList&lt;&gt;(methods) : null,
 577                         trackNodeSourcePosition,
 578                         newCompilationId,
 579                         getOptions(), debugForCopy, null, callerContext);
 580         if (allowAssumptions == AllowAssumptions.YES &amp;&amp; assumptions != null) {
 581             copy.assumptions.record(assumptions);
 582         }
 583         copy.hasUnsafeAccess = hasUnsafeAccess;
 584         copy.setGuardsStage(getGuardsStage());
 585         copy.isAfterFloatingReadPhase = isAfterFloatingReadPhase;
 586         copy.hasValueProxies = hasValueProxies;
 587         copy.isAfterExpandLogic = isAfterExpandLogic;
 588         copy.trackNodeSourcePosition = trackNodeSourcePosition;
 589         if (fields != null) {
 590             copy.fields = createFieldSet(fields);
 591         }
 592         EconomicMap&lt;Node, Node&gt; replacements = EconomicMap.create(Equivalence.IDENTITY);
 593         replacements.put(start, copy.start);
 594         UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates;
 595         try (InliningLog.UpdateScope scope = copy.getInliningLog().openDefaultUpdateScope()) {
 596             duplicates = copy.addDuplicates(getNodes(), this, this.getNodeCount(), replacements);
 597             if (scope != null) {
 598                 copy.getInliningLog().replaceLog(duplicates, this.getInliningLog());
 599             }
 600         }
 601         if (duplicationMapCallback != null) {
 602             duplicationMapCallback.accept(duplicates);
 603         }
 604         return copy;
 605     }
 606 
 607     /**
 608      * @param debugForCopy the debug context for the graph copy. This must not be the debug for this
 609      *            graph if this graph can be accessed from multiple threads (e.g., it&#39;s in a cache
 610      *            accessed by multiple threads).
 611      */
 612     public StructuredGraph copyWithIdentifier(CompilationIdentifier newCompilationId, DebugContext debugForCopy) {
 613         return copy(name, null, newCompilationId, debugForCopy);
 614     }
 615 
 616     public ParameterNode getParameter(int index) {
 617         for (ParameterNode param : getNodes(ParameterNode.TYPE)) {
 618             if (param.index() == index) {
 619                 return param;
 620             }
 621         }
 622         return null;
 623     }
 624 
 625     public Iterable&lt;Invoke&gt; getInvokes() {
 626         final Iterator&lt;MethodCallTargetNode&gt; callTargets = getNodes(MethodCallTargetNode.TYPE).iterator();
 627         return new Iterable&lt;Invoke&gt;() {
 628 
 629             private Invoke next;
 630 
 631             @Override
 632             public Iterator&lt;Invoke&gt; iterator() {
 633                 return new Iterator&lt;Invoke&gt;() {
 634 
 635                     @Override
 636                     public boolean hasNext() {
 637                         if (next == null) {
 638                             while (callTargets.hasNext()) {
 639                                 Invoke i = callTargets.next().invoke();
 640                                 if (i != null) {
 641                                     next = i;
 642                                     return true;
 643                                 }
 644                             }
 645                             return false;
 646                         } else {
 647                             return true;
 648                         }
 649                     }
 650 
 651                     @Override
 652                     public Invoke next() {
 653                         try {
 654                             return next;
 655                         } finally {
 656                             next = null;
 657                         }
 658                     }
 659 
 660                     @Override
 661                     public void remove() {
 662                         throw new UnsupportedOperationException();
 663                     }
 664                 };
 665             }
 666         };
 667     }
 668 
 669     public boolean hasLoops() {
 670         return hasNode(LoopBeginNode.TYPE);
 671     }
 672 
 673     /**
 674      * Unlinks a node from all its control flow neighbors and then removes it from its graph. The
 675      * node must have no {@linkplain Node#usages() usages}.
 676      *
 677      * @param node the node to be unlinked and removed
 678      */
 679     @SuppressWarnings(&quot;static-method&quot;)
 680     public void removeFixed(FixedWithNextNode node) {
 681         assert node != null;
 682         if (node instanceof AbstractBeginNode) {
 683             ((AbstractBeginNode) node).prepareDelete();
 684         }
<a name="3" id="anc3"></a><span class="line-modified"> 685         assert node.hasNoUsages() : node + &quot; &quot; + node.getUsageCount() + &quot;, &quot; + node.usages().first();</span>
 686         GraphUtil.unlinkFixedNode(node);
 687         node.safeDelete();
 688     }
 689 
 690     public void replaceFixed(FixedWithNextNode node, Node replacement) {
 691         if (replacement instanceof FixedWithNextNode) {
 692             replaceFixedWithFixed(node, (FixedWithNextNode) replacement);
 693         } else {
 694             assert replacement != null : &quot;cannot replace &quot; + node + &quot; with null&quot;;
 695             assert replacement instanceof FloatingNode : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 696             replaceFixedWithFloating(node, (FloatingNode) replacement);
 697         }
 698     }
 699 
 700     public void replaceFixedWithFixed(FixedWithNextNode node, FixedWithNextNode replacement) {
 701         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 702         FixedNode next = node.next();
 703         node.setNext(null);
 704         replacement.setNext(next);
 705         node.replaceAndDelete(replacement);
 706         if (node == start) {
 707             setStart((StartNode) replacement);
 708         }
 709     }
 710 
 711     @SuppressWarnings(&quot;static-method&quot;)
 712     public void replaceFixedWithFloating(FixedWithNextNode node, ValueNode replacement) {
 713         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 714         GraphUtil.unlinkFixedNode(node);
 715         node.replaceAtUsagesAndDelete(replacement);
 716     }
 717 
 718     @SuppressWarnings(&quot;static-method&quot;)
 719     public void removeSplit(ControlSplitNode node, AbstractBeginNode survivingSuccessor) {
 720         assert node != null;
 721         assert node.hasNoUsages();
 722         assert survivingSuccessor != null;
 723         node.clearSuccessors();
 724         node.replaceAtPredecessor(survivingSuccessor);
 725         node.safeDelete();
 726     }
 727 
 728     @SuppressWarnings(&quot;static-method&quot;)
 729     public void removeSplitPropagate(ControlSplitNode node, AbstractBeginNode survivingSuccessor) {
 730         assert node != null;
 731         assert node.hasNoUsages();
 732         assert survivingSuccessor != null;
 733         List&lt;Node&gt; snapshot = node.successors().snapshot();
 734         node.clearSuccessors();
 735         node.replaceAtPredecessor(survivingSuccessor);
 736         node.safeDelete();
 737         for (Node successor : snapshot) {
 738             if (successor != null &amp;&amp; successor.isAlive()) {
 739                 if (successor != survivingSuccessor) {
 740                     GraphUtil.killCFG((FixedNode) successor);
 741                 }
 742             }
 743         }
 744     }
 745 
 746     public void replaceSplit(ControlSplitNode node, Node replacement, AbstractBeginNode survivingSuccessor) {
 747         if (replacement instanceof FixedWithNextNode) {
 748             replaceSplitWithFixed(node, (FixedWithNextNode) replacement, survivingSuccessor);
 749         } else {
 750             assert replacement != null : &quot;cannot replace &quot; + node + &quot; with null&quot;;
 751             assert replacement instanceof FloatingNode : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 752             replaceSplitWithFloating(node, (FloatingNode) replacement, survivingSuccessor);
 753         }
 754     }
 755 
 756     @SuppressWarnings(&quot;static-method&quot;)
 757     public void replaceSplitWithFixed(ControlSplitNode node, FixedWithNextNode replacement, AbstractBeginNode survivingSuccessor) {
 758         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 759         assert survivingSuccessor != null;
 760         node.clearSuccessors();
 761         replacement.setNext(survivingSuccessor);
 762         node.replaceAndDelete(replacement);
 763     }
 764 
 765     @SuppressWarnings(&quot;static-method&quot;)
 766     public void replaceSplitWithFloating(ControlSplitNode node, FloatingNode replacement, AbstractBeginNode survivingSuccessor) {
 767         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 768         assert survivingSuccessor != null;
 769         node.clearSuccessors();
 770         node.replaceAtPredecessor(survivingSuccessor);
 771         node.replaceAtUsagesAndDelete(replacement);
 772     }
 773 
 774     @SuppressWarnings(&quot;static-method&quot;)
 775     public void addAfterFixed(FixedWithNextNode node, FixedNode newNode) {
 776         assert node != null &amp;&amp; newNode != null &amp;&amp; node.isAlive() &amp;&amp; newNode.isAlive() : &quot;cannot add &quot; + newNode + &quot; after &quot; + node;
 777         FixedNode next = node.next();
 778         node.setNext(newNode);
 779         if (next != null) {
 780             assert newNode instanceof FixedWithNextNode;
 781             FixedWithNextNode newFixedWithNext = (FixedWithNextNode) newNode;
 782             assert newFixedWithNext.next() == null;
 783             newFixedWithNext.setNext(next);
 784         }
 785     }
 786 
 787     @SuppressWarnings(&quot;static-method&quot;)
 788     public void addBeforeFixed(FixedNode node, FixedWithNextNode newNode) {
 789         assert node != null &amp;&amp; newNode != null &amp;&amp; node.isAlive() &amp;&amp; newNode.isAlive() : &quot;cannot add &quot; + newNode + &quot; before &quot; + node;
 790         assert node.predecessor() != null &amp;&amp; node.predecessor() instanceof FixedWithNextNode : &quot;cannot add &quot; + newNode + &quot; before &quot; + node;
 791         assert newNode.next() == null : newNode;
 792         assert !(node instanceof AbstractMergeNode);
 793         FixedWithNextNode pred = (FixedWithNextNode) node.predecessor();
 794         pred.setNext(newNode);
 795         newNode.setNext(node);
 796     }
 797 
 798     public void reduceDegenerateLoopBegin(LoopBeginNode begin) {
 799         assert begin.loopEnds().isEmpty() : &quot;Loop begin still has backedges&quot;;
 800         if (begin.forwardEndCount() == 1) { // bypass merge and remove
 801             reduceTrivialMerge(begin);
 802         } else { // convert to merge
 803             AbstractMergeNode merge = this.add(new MergeNode());
 804             for (EndNode end : begin.forwardEnds()) {
 805                 merge.addForwardEnd(end);
 806             }
 807             this.replaceFixedWithFixed(begin, merge);
 808         }
 809     }
 810 
 811     @SuppressWarnings(&quot;static-method&quot;)
 812     public void reduceTrivialMerge(AbstractMergeNode merge) {
 813         assert merge.forwardEndCount() == 1;
 814         assert !(merge instanceof LoopBeginNode) || ((LoopBeginNode) merge).loopEnds().isEmpty();
 815         for (PhiNode phi : merge.phis().snapshot()) {
 816             assert phi.valueCount() == 1;
 817             ValueNode singleValue = phi.valueAt(0);
 818             if (phi.hasUsages()) {
 819                 phi.replaceAtUsagesAndDelete(singleValue);
 820             } else {
 821                 phi.safeDelete();
 822                 if (singleValue != null) {
 823                     GraphUtil.tryKillUnused(singleValue);
 824                 }
 825             }
 826         }
 827         // remove loop exits
 828         if (merge instanceof LoopBeginNode) {
 829             ((LoopBeginNode) merge).removeExits();
 830         }
 831         AbstractEndNode singleEnd = merge.forwardEndAt(0);
 832         FixedNode sux = merge.next();
 833         FrameState stateAfter = merge.stateAfter();
 834         // evacuateGuards
 835         merge.prepareDelete((FixedNode) singleEnd.predecessor());
 836         merge.safeDelete();
 837         if (stateAfter != null) {
 838             GraphUtil.tryKillUnused(stateAfter);
 839         }
 840         if (sux == null) {
 841             singleEnd.replaceAtPredecessor(null);
 842             singleEnd.safeDelete();
 843         } else {
 844             singleEnd.replaceAndDelete(sux);
 845         }
 846     }
 847 
 848     public GuardsStage getGuardsStage() {
 849         return guardsStage;
 850     }
 851 
 852     public void setGuardsStage(GuardsStage guardsStage) {
 853         assert guardsStage.ordinal() &gt;= this.guardsStage.ordinal();
 854         this.guardsStage = guardsStage;
 855     }
 856 
 857     public boolean isAfterFloatingReadPhase() {
 858         return isAfterFloatingReadPhase;
 859     }
 860 
 861     public boolean isAfterFixedReadPhase() {
 862         return isAfterFixedReadPhase;
 863     }
 864 
 865     public void setAfterFloatingReadPhase(boolean state) {
 866         assert state : &quot;cannot &#39;unapply&#39; floating read phase on graph&quot;;
 867         isAfterFloatingReadPhase = state;
 868     }
 869 
 870     public void setAfterFixReadPhase(boolean state) {
 871         assert state : &quot;cannot &#39;unapply&#39; fix reads phase on graph&quot;;
 872         isAfterFixedReadPhase = state;
 873     }
 874 
 875     public boolean hasValueProxies() {
 876         return hasValueProxies;
 877     }
 878 
 879     public void setHasValueProxies(boolean state) {
 880         assert !state : &quot;cannot &#39;unapply&#39; value proxy removal on graph&quot;;
 881         hasValueProxies = state;
 882     }
 883 
 884     public boolean isAfterExpandLogic() {
 885         return isAfterExpandLogic;
 886     }
 887 
 888     public void setAfterExpandLogic() {
 889         isAfterExpandLogic = true;
 890     }
 891 
 892     /**
 893      * Determines if {@link ProfilingInfo} is used during construction of this graph.
 894      */
 895     public boolean useProfilingInfo() {
 896         return useProfilingInfo;
 897     }
 898 
 899     /**
 900      * Returns true if this graph is built without parsing the {@linkplain #method() root method} or
 901      * if the root method is annotated by {@link Snippet} or {@link MethodSubstitution}. This is
 902      * preferred over querying annotations directly as querying annotations can cause class loading.
 903      */
 904     public boolean isSubstitution() {
 905         return isSubstitution;
 906     }
 907 
 908     /**
 909      * Gets the profiling info for the {@linkplain #method() root method} of this graph.
 910      */
 911     public ProfilingInfo getProfilingInfo() {
 912         return getProfilingInfo(method());
 913     }
 914 
 915     /**
 916      * Gets the profiling info for a given method that is or will be part of this graph, taking into
 917      * account {@link #useProfilingInfo()}.
 918      */
 919     public ProfilingInfo getProfilingInfo(ResolvedJavaMethod m) {
 920         if (useProfilingInfo &amp;&amp; m != null) {
 921             return m.getProfilingInfo();
 922         } else {
 923             return DefaultProfilingInfo.get(TriState.UNKNOWN);
 924         }
 925     }
 926 
 927     /**
 928      * Gets the object for recording assumptions while constructing of this graph.
 929      *
 930      * @return {@code null} if assumptions cannot be made for this graph
 931      */
 932     public Assumptions getAssumptions() {
 933         return assumptions;
 934     }
 935 
 936     /**
 937      * Checks that any method referenced from a {@link FrameState} is also in the set of methods
 938      * parsed while building this graph.
 939      */
 940     private boolean checkFrameStatesAgainstInlinedMethods() {
 941         for (FrameState fs : getNodes(FrameState.TYPE)) {
 942             if (!BytecodeFrame.isPlaceholderBci(fs.bci)) {
 943                 ResolvedJavaMethod m = fs.code.getMethod();
 944                 if (!m.equals(rootMethod) &amp;&amp; !methods.contains(m)) {
 945                     SortedSet&lt;String&gt; haystack = new TreeSet&lt;&gt;();
 946                     if (!methods.contains(rootMethod)) {
 947                         haystack.add(rootMethod.format(&quot;%H.%n(%p)&quot;));
 948                     }
 949                     for (ResolvedJavaMethod e : methods) {
 950                         haystack.add(e.format(&quot;%H.%n(%p)&quot;));
 951                     }
 952                     throw new AssertionError(String.format(&quot;Could not find %s from %s in set(%s)&quot;, m.format(&quot;%H.%n(%p)&quot;), fs, haystack.stream().collect(Collectors.joining(System.lineSeparator()))));
 953                 }
 954             }
 955         }
 956         return true;
 957     }
 958 
 959     private static EconomicSet&lt;ResolvedJavaField&gt; createFieldSet(EconomicSet&lt;ResolvedJavaField&gt; init) {
 960         // Multiple ResolvedJavaField objects can represent the same field so they
 961         // need to be compared with equals().
 962         if (init != null) {
 963             return EconomicSet.create(Equivalence.DEFAULT, init);
 964         }
 965         return EconomicSet.create(Equivalence.DEFAULT);
 966     }
 967 
 968     /**
 969      * Gets an unmodifiable view of the methods that were inlined while constructing this graph.
 970      */
 971     public List&lt;ResolvedJavaMethod&gt; getMethods() {
 972         if (methods != null) {
<a name="4" id="anc4"></a><span class="line-modified"> 973             assert isSubstitution || checkFrameStatesAgainstInlinedMethods();</span>
 974             return Collections.unmodifiableList(methods);
 975         }
 976         return Collections.emptyList();
 977     }
 978 
 979     /**
 980      * Records that {@code method} was used to build this graph.
 981      */
 982     public void recordMethod(ResolvedJavaMethod method) {
 983         if (methods != null) {
 984             methods.add(method);
 985         }
 986     }
 987 
 988     /**
 989      * Updates the {@linkplain #getMethods() methods} used to build this graph with the methods used
 990      * to build another graph.
 991      */
 992     public void updateMethods(StructuredGraph other) {
 993         if (methods != null) {
 994             if (other.rootMethod != null) {
 995                 methods.add(other.rootMethod);
 996             }
 997             for (ResolvedJavaMethod m : other.methods) {
 998                 methods.add(m);
 999             }
1000         }
1001     }
1002 
1003     /**
1004      * Gets an unmodifiable view of the fields that were accessed while constructing this graph.
1005      *
1006      * @return {@code null} if no field accesses were recorded
1007      */
1008     public EconomicSet&lt;ResolvedJavaField&gt; getFields() {
1009         return fields;
1010     }
1011 
1012     /**
1013      * Records that {@code field} was accessed in this graph.
1014      */
1015     public void recordField(ResolvedJavaField field) {
1016         assert GraalOptions.GeneratePIC.getValue(getOptions());
1017         if (this.fields == null) {
1018             this.fields = createFieldSet(null);
1019         }
1020         fields.add(field);
1021     }
1022 
1023     /**
1024      * Updates the {@linkplain #getFields() fields} of this graph with the accessed fields of
1025      * another graph.
1026      */
1027     public void updateFields(StructuredGraph other) {
1028         assert this != other;
1029         assert GraalOptions.GeneratePIC.getValue(getOptions());
1030         if (other.fields != null) {
1031             if (this.fields == null) {
1032                 this.fields = createFieldSet(null);
1033             }
1034             this.fields.addAll(other.fields);
1035         }
1036     }
1037 
1038     /**
1039      * Gets the input bytecode {@linkplain ResolvedJavaMethod#getCodeSize() size} from which this
1040      * graph is constructed. This ignores how many bytecodes in each constituent method are actually
1041      * parsed (which may be none for methods whose IR is retrieved from a cache or less than the
1042      * full amount for any given method due to profile guided branch pruning).
1043      */
1044     public int getBytecodeSize() {
1045         int res = 0;
1046         if (rootMethod != null) {
1047             res += rootMethod.getCodeSize();
1048         }
1049         if (methods != null) {
1050             for (ResolvedJavaMethod e : methods) {
1051                 res += e.getCodeSize();
1052             }
1053         }
1054         return res;
1055     }
1056 
1057     @Override
1058     public JavaMethod asJavaMethod() {
1059         return method();
1060     }
1061 
1062     public boolean hasUnsafeAccess() {
1063         return hasUnsafeAccess == UnsafeAccessState.HAS_ACCESS;
1064     }
1065 
1066     public void markUnsafeAccess() {
1067         if (hasUnsafeAccess == UnsafeAccessState.DISABLED) {
1068             return;
1069         }
1070         hasUnsafeAccess = UnsafeAccessState.HAS_ACCESS;
1071     }
1072 
1073     public void disableUnsafeAccessTracking() {
1074         hasUnsafeAccess = UnsafeAccessState.DISABLED;
1075     }
1076 
1077     public boolean isUnsafeAccessTrackingEnabled() {
1078         return hasUnsafeAccess != UnsafeAccessState.DISABLED;
1079     }
1080 
1081     public SpeculationLog getSpeculationLog() {
1082         return speculationLog;
1083     }
1084 
1085     public void clearAllStateAfter() {
1086         for (Node node : getNodes()) {
1087             if (node instanceof StateSplit) {
1088                 FrameState stateAfter = ((StateSplit) node).stateAfter();
1089                 if (stateAfter != null) {
1090                     ((StateSplit) node).setStateAfter(null);
1091                     // 2 nodes referencing the same framestate
1092                     if (stateAfter.isAlive()) {
1093                         GraphUtil.killWithUnusedFloatingInputs(stateAfter);
1094                     }
1095                 }
1096             }
1097         }
1098     }
1099 
1100     public boolean hasVirtualizableAllocation() {
1101         for (Node n : getNodes()) {
1102             if (n instanceof VirtualizableAllocation) {
1103                 return true;
1104             }
1105         }
1106         return false;
1107     }
1108 
1109     @Override
1110     protected void afterRegister(Node node) {
1111         assert hasValueProxies() || !(node instanceof ValueProxyNode);
1112         if (GraalOptions.TraceInlining.getValue(getOptions())) {
1113             if (node instanceof Invokable) {
1114                 ((Invokable) node).updateInliningLogAfterRegister(this);
1115             }
1116         }
1117     }
1118 
1119     public NodeSourcePosition getCallerContext() {
1120         return callerContext;
1121     }
1122 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
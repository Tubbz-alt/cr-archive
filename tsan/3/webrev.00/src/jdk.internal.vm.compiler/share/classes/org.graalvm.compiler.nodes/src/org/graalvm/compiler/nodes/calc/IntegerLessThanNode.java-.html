<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/IntegerLessThanNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.nodes.calc;
 26 
 27 import static org.graalvm.compiler.core.common.calc.CanonicalCondition.LT;
 28 
 29 import org.graalvm.compiler.core.common.NumUtil;
 30 import org.graalvm.compiler.core.common.calc.CanonicalCondition;
 31 import org.graalvm.compiler.core.common.type.FloatStamp;
 32 import org.graalvm.compiler.core.common.type.IntegerStamp;
 33 import org.graalvm.compiler.core.common.type.StampFactory;
 34 import org.graalvm.compiler.debug.GraalError;
 35 import org.graalvm.compiler.graph.Node;
 36 import org.graalvm.compiler.graph.NodeClass;
 37 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 38 import org.graalvm.compiler.nodeinfo.NodeInfo;
 39 import org.graalvm.compiler.nodes.ConstantNode;
 40 import org.graalvm.compiler.nodes.LogicConstantNode;
 41 import org.graalvm.compiler.nodes.LogicNegationNode;
 42 import org.graalvm.compiler.nodes.LogicNode;
 43 import org.graalvm.compiler.nodes.NodeView;
 44 import org.graalvm.compiler.nodes.ValueNode;
 45 import org.graalvm.compiler.options.OptionValues;
 46 
 47 import jdk.vm.ci.code.CodeUtil;
 48 import jdk.vm.ci.meta.Constant;
 49 import jdk.vm.ci.meta.ConstantReflectionProvider;
 50 import jdk.vm.ci.meta.JavaKind;
 51 import jdk.vm.ci.meta.MetaAccessProvider;
 52 import jdk.vm.ci.meta.PrimitiveConstant;
 53 import jdk.vm.ci.meta.TriState;
 54 
 55 @NodeInfo(shortName = &quot;&lt;&quot;)
 56 public final class IntegerLessThanNode extends IntegerLowerThanNode {
 57     public static final NodeClass&lt;IntegerLessThanNode&gt; TYPE = NodeClass.create(IntegerLessThanNode.class);
 58     private static final LessThanOp OP = new LessThanOp();
 59 
 60     public IntegerLessThanNode(ValueNode x, ValueNode y) {
 61         super(TYPE, x, y, OP);
 62         assert !x.getStackKind().isNumericFloat() &amp;&amp; x.getStackKind() != JavaKind.Object;
 63         assert !y.getStackKind().isNumericFloat() &amp;&amp; y.getStackKind() != JavaKind.Object;
 64     }
 65 
 66     public static LogicNode create(ValueNode x, ValueNode y, NodeView view) {
 67         return OP.create(x, y, view);
 68     }
 69 
 70     public static LogicNode create(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth,
 71                     ValueNode x, ValueNode y, NodeView view) {
 72         LogicNode value = OP.canonical(constantReflection, metaAccess, options, smallestCompareWidth, OP.getCondition(), false, x, y, view);
 73         if (value != null) {
 74             return value;
 75         }
 76         return create(x, y, view);
 77     }
 78 
 79     @Override
 80     public Node canonical(CanonicalizerTool tool, ValueNode forX, ValueNode forY) {
 81         NodeView view = NodeView.from(tool);
 82         ValueNode value = OP.canonical(tool.getConstantReflection(), tool.getMetaAccess(), tool.getOptions(), tool.smallestCompareWidth(), OP.getCondition(), false, forX, forY, view);
 83         if (value != null) {
 84             return value;
 85         }
 86         return this;
 87     }
 88 
 89     public static boolean subtractMayUnderflow(long x, long y, long minValue) {
 90         long r = x - y;
 91         // HD 2-12 Overflow iff the arguments have different signs and
 92         // the sign of the result is different than the sign of x
 93         return (((x ^ y) &amp; (x ^ r)) &lt; 0) || r &lt;= minValue;
 94     }
 95 
 96     public static boolean subtractMayOverflow(long x, long y, long maxValue) {
 97         long r = x - y;
 98         // HD 2-12 Overflow iff the arguments have different signs and
 99         // the sign of the result is different than the sign of x
100         return (((x ^ y) &amp; (x ^ r)) &lt; 0) || r &gt; maxValue;
101     }
102 
103     public static class LessThanOp extends LowerOp {
104         @Override
105         protected CompareNode duplicateModified(ValueNode newX, ValueNode newY, boolean unorderedIsTrue, NodeView view) {
106             if (newX.stamp(view) instanceof FloatStamp &amp;&amp; newY.stamp(view) instanceof FloatStamp) {
107                 return new FloatLessThanNode(newX, newY, unorderedIsTrue); // TODO: Is the last arg
108                                                                            // supposed to be true?
109             } else if (newX.stamp(view) instanceof IntegerStamp &amp;&amp; newY.stamp(view) instanceof IntegerStamp) {
110                 return new IntegerLessThanNode(newX, newY);
111             }
112             throw GraalError.shouldNotReachHere();
113         }
114 
115         @Override
116         protected LogicNode optimizeNormalizeCompare(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth,
117                         Constant constant, NormalizeCompareNode normalizeNode, boolean mirrored, NodeView view) {
118             PrimitiveConstant primitive = (PrimitiveConstant) constant;
119             /* @formatter:off
120              * a NC b &lt; c  (not mirrored)
121              * cases for c:
122              *  0         -&gt; a &lt; b
123              *  [MIN, -1] -&gt; false
124              *  1         -&gt; a &lt;= b
125              *  [2, MAX]  -&gt; true
126              * unordered-is-less means unordered-is-true.
127              *
128              * c &lt; a NC b  (mirrored)
129              * cases for c:
130              *  0         -&gt; a &gt; b
131              *  [1, MAX]  -&gt; false
132              *  -1        -&gt; a &gt;= b
133              *  [MIN, -2] -&gt; true
134              * unordered-is-less means unordered-is-false.
135              *
136              *  We can handle mirroring by swapping a &amp; b and negating the constant.
137              *  @formatter:on
138              */
139             ValueNode a = mirrored ? normalizeNode.getY() : normalizeNode.getX();
140             ValueNode b = mirrored ? normalizeNode.getX() : normalizeNode.getY();
141             long cst = mirrored ? -primitive.asLong() : primitive.asLong();
142 
143             if (cst == 0) {
144                 if (normalizeNode.getX().getStackKind() == JavaKind.Double || normalizeNode.getX().getStackKind() == JavaKind.Float) {
145                     return FloatLessThanNode.create(constantReflection, metaAccess, options, smallestCompareWidth, a, b, mirrored ^ normalizeNode.isUnorderedLess, view);
146                 } else {
147                     return IntegerLessThanNode.create(constantReflection, metaAccess, options, smallestCompareWidth, a, b, view);
148                 }
149             } else if (cst == 1) {
150                 // a &lt;= b &lt;=&gt; !(a &gt; b)
151                 LogicNode compare;
152                 if (normalizeNode.getX().getStackKind() == JavaKind.Double || normalizeNode.getX().getStackKind() == JavaKind.Float) {
153                     // since we negate, we have to reverse the unordered result
154                     compare = FloatLessThanNode.create(constantReflection, metaAccess, options, smallestCompareWidth, b, a, mirrored == normalizeNode.isUnorderedLess, view);
155                 } else {
156                     compare = IntegerLessThanNode.create(constantReflection, metaAccess, options, smallestCompareWidth, b, a, view);
157                 }
158                 return LogicNegationNode.create(compare);
159             } else if (cst &lt;= -1) {
160                 return LogicConstantNode.contradiction();
161             } else {
162                 assert cst &gt;= 2;
163                 return LogicConstantNode.tautology();
164             }
165         }
166 
167         @Override
168         protected LogicNode findSynonym(ValueNode forX, ValueNode forY, NodeView view) {
169             LogicNode result = super.findSynonym(forX, forY, view);
170             if (result != null) {
171                 return result;
172             }
173             if (forX.stamp(view) instanceof IntegerStamp &amp;&amp; forY.stamp(view) instanceof IntegerStamp) {
174                 if (IntegerStamp.sameSign((IntegerStamp) forX.stamp(view), (IntegerStamp) forY.stamp(view))) {
175                     return new IntegerBelowNode(forX, forY);
176                 }
177             }
178 
179             // Attempt to optimize the case where we can fold a constant from the left side (either
180             // from an add or sub) into the constant on the right side.
181             if (forY.isConstant()) {
182                 if (forX instanceof SubNode) {
183                     SubNode sub = (SubNode) forX;
184                     ValueNode xx = null;
185                     ValueNode yy = null;
186                     boolean negate = false;
187                     if (forY.asConstant().isDefaultForKind()) {
188                         // (x - y) &lt; 0 when x - y is known not to underflow &lt;=&gt; x &lt; y
189                         xx = sub.getX();
190                         yy = sub.getY();
191                     } else if (forY.isJavaConstant() &amp;&amp; forY.asJavaConstant().asLong() == 1) {
192                         // (x - y) &lt; 1 when x - y is known not to underflow &lt;=&gt; !(y &lt; x)
193                         xx = sub.getY();
194                         yy = sub.getX();
195                         negate = true;
196                     }
197                     if (xx != null) {
198                         assert yy != null;
199                         IntegerStamp xStamp = (IntegerStamp) sub.getX().stamp(view);
200                         IntegerStamp yStamp = (IntegerStamp) sub.getY().stamp(view);
201                         long minValue = CodeUtil.minValue(xStamp.getBits());
202                         long maxValue = CodeUtil.maxValue(xStamp.getBits());
203 
204                         if (!subtractMayUnderflow(xStamp.lowerBound(), yStamp.upperBound(), minValue) &amp;&amp; !subtractMayOverflow(xStamp.upperBound(), yStamp.lowerBound(), maxValue)) {
205                             LogicNode logic = new IntegerLessThanNode(xx, yy);
206                             if (negate) {
207                                 logic = LogicNegationNode.create(logic);
208                             }
209                             return logic;
210                         }
211                     }
212                 } else if (forX instanceof AddNode) {
213 
214                     // (x + xConstant) &lt; forY =&gt; x &lt; (forY - xConstant)
215                     AddNode addNode = (AddNode) forX;
216                     if (addNode.getY().isJavaConstant()) {
217                         IntegerStamp xStamp = (IntegerStamp) addNode.getX().stamp(view);
218                         if (!IntegerStamp.addCanOverflow(xStamp, (IntegerStamp) addNode.getY().stamp(view))) {
219                             long minValue = CodeUtil.minValue(xStamp.getBits());
220                             long maxValue = CodeUtil.maxValue(xStamp.getBits());
221                             long yConstant = forY.asJavaConstant().asLong();
222                             long xConstant = addNode.getY().asJavaConstant().asLong();
223                             if (!subtractMayUnderflow(yConstant, xConstant, minValue) &amp;&amp; !subtractMayOverflow(yConstant, xConstant, maxValue)) {
224                                 long newConstant = yConstant - xConstant;
225                                 return IntegerLessThanNode.create(addNode.getX(), ConstantNode.forIntegerStamp(xStamp, newConstant), view);
226                             }
227                         }
228                     }
229                 }
230             }
231 
232             if (forX.stamp(view) instanceof IntegerStamp) {
233                 assert forY.stamp(view) instanceof IntegerStamp;
234                 int bits = ((IntegerStamp) forX.stamp(view)).getBits();
235                 assert ((IntegerStamp) forY.stamp(view)).getBits() == bits;
236                 LogicNode logic = canonicalizeRangeFlip(forX, forY, bits, true, view);
237                 if (logic != null) {
238                     return logic;
239                 }
240             }
241             return null;
242         }
243 
244         @Override
245         protected CanonicalCondition getCondition() {
246             return LT;
247         }
248 
249         @Override
250         protected IntegerLowerThanNode createNode(ValueNode x, ValueNode y) {
251             return new IntegerLessThanNode(x, y);
252         }
253 
254         @Override
255         protected long upperBound(IntegerStamp stamp) {
256             return stamp.upperBound();
257         }
258 
259         @Override
260         protected long lowerBound(IntegerStamp stamp) {
261             return stamp.lowerBound();
262         }
263 
264         @Override
265         protected int compare(long a, long b) {
266             return Long.compare(a, b);
267         }
268 
269         @Override
270         protected long min(long a, long b) {
271             return Math.min(a, b);
272         }
273 
274         @Override
275         protected long max(long a, long b) {
276             return Math.max(a, b);
277         }
278 
279         @Override
280         protected long cast(long a, int bits) {
281             return CodeUtil.signExtend(a, bits);
282         }
283 
284         @Override
285         protected long minValue(int bits) {
286             return NumUtil.minValue(bits);
287         }
288 
289         @Override
290         protected long maxValue(int bits) {
291             return NumUtil.maxValue(bits);
292         }
293 
294         @Override
295         protected IntegerStamp forInteger(int bits, long min, long max) {
296             return StampFactory.forInteger(bits, cast(min, bits), cast(max, bits));
297         }
298     }
299 
300     @Override
301     public TriState implies(boolean thisNegated, LogicNode other) {
302         if (!thisNegated) {
303             if (other instanceof IntegerLessThanNode) {
304                 ValueNode otherX = ((IntegerLessThanNode) other).getX();
305                 ValueNode otherY = ((IntegerLessThanNode) other).getY();
306                 // x &lt; y =&gt; !y &lt; x
307                 if (getX() == otherY &amp;&amp; getY() == otherX) {
308                     return TriState.FALSE;
309                 }
310             }
311 
312             // x &lt; y =&gt; !x == y
313             // x &lt; y =&gt; !y == x
314             if (other instanceof IntegerEqualsNode) {
315                 ValueNode otherX = ((IntegerEqualsNode) other).getX();
316                 ValueNode otherY = ((IntegerEqualsNode) other).getY();
317                 if ((getX() == otherX &amp;&amp; getY() == otherY) || (getX() == otherY &amp;&amp; getY() == otherX)) {
318                     return TriState.FALSE;
319                 }
320             }
321         }
322         return super.implies(thisNegated, other);
323     }
324 }
    </pre>
  </body>
</html>
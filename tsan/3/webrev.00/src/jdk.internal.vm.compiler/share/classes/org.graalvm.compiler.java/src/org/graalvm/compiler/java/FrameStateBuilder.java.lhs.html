<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/FrameStateBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.java;
 26 
 27 import static org.graalvm.compiler.bytecode.Bytecodes.DUP;
 28 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2;
 29 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X1;
 30 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X2;
 31 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X1;
 32 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X2;
 33 import static org.graalvm.compiler.bytecode.Bytecodes.POP;
 34 import static org.graalvm.compiler.bytecode.Bytecodes.POP2;
 35 import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;
 36 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
 37 import static org.graalvm.compiler.nodes.FrameState.TWO_SLOT_MARKER;
<a name="2" id="anc2"></a>
 38 
 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.List;
 42 import java.util.function.Function;
 43 
 44 import org.graalvm.compiler.bytecode.Bytecode;
 45 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
<a name="3" id="anc3"></a><span class="line-removed"> 46 import org.graalvm.compiler.core.common.GraalOptions;</span>
 47 import org.graalvm.compiler.core.common.PermanentBailoutException;
 48 import org.graalvm.compiler.core.common.type.StampFactory;
 49 import org.graalvm.compiler.core.common.type.StampPair;
 50 import org.graalvm.compiler.debug.DebugContext;
<a name="4" id="anc4"></a>
 51 import org.graalvm.compiler.graph.NodeSourcePosition;
 52 import org.graalvm.compiler.java.BciBlockMapping.BciBlock;
 53 import org.graalvm.compiler.nodeinfo.Verbosity;
 54 import org.graalvm.compiler.nodes.AbstractMergeNode;
 55 import org.graalvm.compiler.nodes.ConstantNode;
 56 import org.graalvm.compiler.nodes.FrameState;
 57 import org.graalvm.compiler.nodes.LoopBeginNode;
 58 import org.graalvm.compiler.nodes.LoopExitNode;
 59 import org.graalvm.compiler.nodes.NodeView;
 60 import org.graalvm.compiler.nodes.ParameterNode;
 61 import org.graalvm.compiler.nodes.PhiNode;
 62 import org.graalvm.compiler.nodes.ProxyNode;
 63 import org.graalvm.compiler.nodes.StateSplit;
 64 import org.graalvm.compiler.nodes.StructuredGraph;
 65 import org.graalvm.compiler.nodes.ValueNode;
 66 import org.graalvm.compiler.nodes.ValuePhiNode;
 67 import org.graalvm.compiler.nodes.calc.FloatingNode;
 68 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 69 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderTool;
 70 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.SideEffectsState;
 71 import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
 72 import org.graalvm.compiler.nodes.java.MonitorIdNode;
<a name="5" id="anc5"></a><span class="line-removed"> 73 import org.graalvm.compiler.nodes.util.GraphUtil;</span>
 74 
 75 import jdk.vm.ci.code.BytecodeFrame;
 76 import jdk.vm.ci.meta.Assumptions;
 77 import jdk.vm.ci.meta.JavaKind;
 78 import jdk.vm.ci.meta.JavaType;
 79 import jdk.vm.ci.meta.ResolvedJavaMethod;
 80 import jdk.vm.ci.meta.ResolvedJavaType;
 81 import jdk.vm.ci.meta.Signature;
 82 
 83 public final class FrameStateBuilder implements SideEffectsState {
 84 
 85     private static final ValueNode[] EMPTY_ARRAY = new ValueNode[0];
 86     private static final MonitorIdNode[] EMPTY_MONITOR_ARRAY = new MonitorIdNode[0];
 87 
 88     private final BytecodeParser parser;
 89     private final GraphBuilderTool tool;
 90     private final Bytecode code;
 91     private int stackSize;
 92     protected final ValueNode[] locals;
 93     protected final ValueNode[] stack;
 94     private ValueNode[] lockedObjects;
 95     private boolean canVerifyKind;
 96 
 97     /**
 98      * @see BytecodeFrame#rethrowException
 99      */
100     private boolean rethrowException;
101 
102     private MonitorIdNode[] monitorIds;
103     private final StructuredGraph graph;
104     private final boolean clearNonLiveLocals;
105     private FrameState outerFrameState;
106     private NodeSourcePosition outerSourcePosition;
107 
108     /**
109      * The closest {@link StateSplit#hasSideEffect() side-effect} predecessors. There will be more
110      * than one when the current block contains no side-effects but merging predecessor blocks do.
111      */
112     private List&lt;StateSplit&gt; sideEffects;
113 
114     /**
115      * Creates a new frame state builder for the given method and the given target graph.
116      *
117      * @param method the method whose frame is simulated
118      * @param graph the target graph of Graal nodes created by the builder
119      */
120     public FrameStateBuilder(GraphBuilderTool tool, ResolvedJavaMethod method, StructuredGraph graph) {
<a name="6" id="anc6"></a><span class="line-modified">121         this(tool, new ResolvedJavaMethodBytecode(method), graph);</span>
122     }
123 
124     /**
125      * Creates a new frame state builder for the given code attribute, method and the given target
<a name="7" id="anc7"></a><span class="line-modified">126      * graph.</span>
127      *
128      * @param code the bytecode in which the frame exists
129      * @param graph the target graph of Graal nodes created by the builder
<a name="8" id="anc8"></a>
130      */
<a name="9" id="anc9"></a><span class="line-modified">131     public FrameStateBuilder(GraphBuilderTool tool, Bytecode code, StructuredGraph graph) {</span>
132         this.tool = tool;
133         if (tool instanceof BytecodeParser) {
134             this.parser = (BytecodeParser) tool;
135         } else {
136             this.parser = null;
137         }
138         this.code = code;
139         this.locals = allocateArray(code.getMaxLocals());
140         this.stack = allocateArray(Math.max(1, code.getMaxStackSize()));
141         this.lockedObjects = allocateArray(0);
142 
143         assert graph != null;
144 
145         this.monitorIds = EMPTY_MONITOR_ARRAY;
146         this.graph = graph;
<a name="10" id="anc10"></a><span class="line-modified">147         this.clearNonLiveLocals = GraalOptions.OptClearNonLiveLocals.getValue(graph.getOptions());</span>
148         this.canVerifyKind = true;
149     }
150 
151     public void disableKindVerification() {
152         canVerifyKind = false;
153     }
154 
155     public void initializeFromArgumentsArray(ValueNode[] arguments) {
156 
157         int javaIndex = 0;
158         int index = 0;
159         if (!getMethod().isStatic()) {
160             // set the receiver
161             locals[javaIndex] = arguments[index];
162             javaIndex = 1;
163             index = 1;
164         }
165         Signature sig = getMethod().getSignature();
166         int max = sig.getParameterCount(false);
167         for (int i = 0; i &lt; max; i++) {
168             JavaKind kind = sig.getParameterKind(i);
169             locals[javaIndex] = arguments[index];
170             javaIndex++;
171             if (kind.needsTwoSlots()) {
172                 locals[javaIndex] = TWO_SLOT_MARKER;
173                 javaIndex++;
174             }
175             index++;
176         }
177     }
178 
179     public void initializeForMethodStart(Assumptions assumptions, boolean eagerResolve, Plugins plugins) {
180 
181         int javaIndex = 0;
182         int index = 0;
183         ResolvedJavaMethod method = getMethod();
184         ResolvedJavaType originalType = method.getDeclaringClass();
185         if (!method.isStatic()) {
186             // add the receiver
187             FloatingNode receiver = null;
188             StampPair receiverStamp = null;
189             if (plugins != null) {
190                 receiverStamp = plugins.getOverridingStamp(tool, originalType, true);
191             }
192             if (receiverStamp == null) {
193                 receiverStamp = StampFactory.forDeclaredType(assumptions, originalType, true);
194             }
195 
196             if (plugins != null) {
197                 for (ParameterPlugin plugin : plugins.getParameterPlugins()) {
198                     receiver = plugin.interceptParameter(tool, index, receiverStamp);
199                     if (receiver != null) {
200                         break;
201                     }
202                 }
203             }
204             if (receiver == null) {
205                 receiver = new ParameterNode(javaIndex, receiverStamp);
206             }
207 
208             locals[javaIndex] = graph.addOrUniqueWithInputs(receiver);
209             javaIndex = 1;
210             index = 1;
211         }
212         Signature sig = method.getSignature();
213         int max = sig.getParameterCount(false);
214         ResolvedJavaType accessingClass = originalType;
215         for (int i = 0; i &lt; max; i++) {
216             JavaType type = sig.getParameterType(i, accessingClass);
217             if (eagerResolve) {
218                 type = type.resolve(accessingClass);
219             }
220             JavaKind kind = type.getJavaKind();
221             StampPair stamp = null;
222             if (plugins != null) {
223                 stamp = plugins.getOverridingStamp(tool, type, false);
224             }
225             if (stamp == null) {
226                 // GR-714: subword inputs cannot be trusted
227                 if (kind.getStackKind() != kind) {
228                     stamp = StampPair.createSingle(StampFactory.forKind(JavaKind.Int));
229                 } else {
230                     stamp = StampFactory.forDeclaredType(assumptions, type, false);
231                 }
232             }
233 
234             FloatingNode param = null;
235             if (plugins != null) {
236                 for (ParameterPlugin plugin : plugins.getParameterPlugins()) {
237                     param = plugin.interceptParameter(tool, index, stamp);
238                     if (param != null) {
239                         break;
240                     }
241                 }
242             }
243             if (param == null) {
244                 param = new ParameterNode(index, stamp);
245             }
246 
247             locals[javaIndex] = graph.addOrUniqueWithInputs(param);
248             javaIndex++;
249             if (kind.needsTwoSlots()) {
250                 locals[javaIndex] = TWO_SLOT_MARKER;
251                 javaIndex++;
252             }
253             index++;
254         }
255     }
256 
257     private FrameStateBuilder(FrameStateBuilder other) {
258         this.parser = other.parser;
259         this.tool = other.tool;
260         this.code = other.code;
261         this.stackSize = other.stackSize;
262         this.locals = other.locals.clone();
263         this.stack = other.stack.clone();
264         this.lockedObjects = other.lockedObjects.length == 0 ? other.lockedObjects : other.lockedObjects.clone();
265         this.rethrowException = other.rethrowException;
266         this.canVerifyKind = other.canVerifyKind;
267 
268         assert locals.length == code.getMaxLocals();
269         assert stack.length == Math.max(1, code.getMaxStackSize());
270 
271         assert other.graph != null;
272         graph = other.graph;
273         clearNonLiveLocals = other.clearNonLiveLocals;
274         monitorIds = other.monitorIds.length == 0 ? other.monitorIds : other.monitorIds.clone();
275 
<a name="11" id="anc11"></a><span class="line-removed">276         assert locals.length == code.getMaxLocals();</span>
<span class="line-removed">277         assert stack.length == Math.max(1, code.getMaxStackSize());</span>
278         assert lockedObjects.length == monitorIds.length;
279     }
280 
281     private static ValueNode[] allocateArray(int length) {
282         return length == 0 ? EMPTY_ARRAY : new ValueNode[length];
283     }
284 
285     public ResolvedJavaMethod getMethod() {
286         return code.getMethod();
287     }
288 
289     @Override
290     public String toString() {
291         StringBuilder sb = new StringBuilder();
292         sb.append(&quot;[locals: [&quot;);
293         for (int i = 0; i &lt; locals.length; i++) {
294             sb.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(locals[i] == null ? &quot;_&quot; : locals[i] == TWO_SLOT_MARKER ? &quot;#&quot; : locals[i].toString(Verbosity.Id));
295         }
296         sb.append(&quot;] stack: [&quot;);
297         for (int i = 0; i &lt; stackSize; i++) {
298             sb.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(stack[i] == null ? &quot;_&quot; : stack[i] == TWO_SLOT_MARKER ? &quot;#&quot; : stack[i].toString(Verbosity.Id));
299         }
300         sb.append(&quot;] locks: [&quot;);
301         for (int i = 0; i &lt; lockedObjects.length; i++) {
302             sb.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(lockedObjects[i].toString(Verbosity.Id)).append(&quot; / &quot;).append(monitorIds[i].toString(Verbosity.Id));
303         }
304         sb.append(&quot;]&quot;);
305         if (rethrowException) {
306             sb.append(&quot; rethrowException&quot;);
307         }
308         sb.append(&quot;]&quot;);
309         return sb.toString();
310     }
311 
312     public FrameState create(int bci, StateSplit forStateSplit) {
313         if (parser != null &amp;&amp; parser.parsingIntrinsic()) {
314             NodeSourcePosition sourcePosition = parser.getGraph().trackNodeSourcePosition() ? createBytecodePosition(bci) : null;
315             return parser.intrinsicContext.createFrameState(parser.getGraph(), this, forStateSplit, sourcePosition);
316         }
317 
318         // Skip intrinsic frames
319         return create(bci, parser != null ? parser.getNonIntrinsicAncestor() : null, false, null, null);
320     }
321 
322     /**
323      * @param pushedValues if non-null, values to {@link #push(JavaKind, ValueNode)} to the stack
324      *            before creating the {@link FrameState}
325      */
326     public FrameState create(int bci, BytecodeParser parent, boolean duringCall, JavaKind[] pushedSlotKinds, ValueNode[] pushedValues) {
327         if (outerFrameState == null &amp;&amp; parent != null) {
328             assert !parent.parsingIntrinsic() : &quot;must already have the next non-intrinsic ancestor&quot;;
329             outerFrameState = parent.getFrameStateBuilder().create(parent.bci(), parent.getNonIntrinsicAncestor(), true, null, null);
330         }
331         if (bci == BytecodeFrame.AFTER_EXCEPTION_BCI &amp;&amp; parent != null) {
<a name="12" id="anc12"></a><span class="line-modified">332             FrameState newFrameState = outerFrameState.duplicateModified(outerFrameState.bci, true, false, JavaKind.Void, new JavaKind[]{JavaKind.Object}, new ValueNode[]{stack[0]});</span>
<span class="line-removed">333             return newFrameState;</span>
334         }
335         if (bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
336             throw shouldNotReachHere();
337         }
338 
339         if (pushedValues != null) {
340             assert pushedSlotKinds.length == pushedValues.length;
341             int stackSizeToRestore = stackSize;
342             for (int i = 0; i &lt; pushedValues.length; i++) {
343                 push(pushedSlotKinds[i], pushedValues[i]);
344             }
345             FrameState res = graph.add(new FrameState(outerFrameState, code, bci, locals, stack, stackSize, lockedObjects, Arrays.asList(monitorIds), rethrowException, duringCall));
346             stackSize = stackSizeToRestore;
347             return res;
348         } else {
349             if (bci == BytecodeFrame.AFTER_EXCEPTION_BCI) {
350                 assert outerFrameState == null;
351                 clearLocals();
352             }
353             return graph.add(new FrameState(outerFrameState, code, bci, locals, stack, stackSize, lockedObjects, Arrays.asList(monitorIds), rethrowException, duringCall));
354         }
355     }
356 
357     public NodeSourcePosition createBytecodePosition(int bci) {
358         BytecodeParser parent = parser.getParent();
359         NodeSourcePosition position = create(bci, parent);
360         return position;
361     }
362 
363     private NodeSourcePosition create(int bci, BytecodeParser parent) {
364         if (outerSourcePosition == null &amp;&amp; parent != null) {
365             outerSourcePosition = parent.getFrameStateBuilder().createBytecodePosition(parent.bci());
366         }
367         if (bci == BytecodeFrame.AFTER_EXCEPTION_BCI &amp;&amp; parent != null) {
368             return FrameState.toSourcePosition(outerFrameState);
369         }
370         if (bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
371             throw shouldNotReachHere();
372         }
373         if (parser.intrinsicContext != null &amp;&amp; (parent == null || parent.intrinsicContext != parser.intrinsicContext)) {
374             // When parsing an intrinsic put in a substitution marker showing the original method as
375             // the caller. This keeps the relationship between the method and the method
376             // substitution clear in resulting NodeSourcePosition.
377             NodeSourcePosition original = new NodeSourcePosition(outerSourcePosition, parser.intrinsicContext.getOriginalMethod(), -1);
378             return NodeSourcePosition.substitution(original, code.getMethod(), bci);
379         } else {
380             return new NodeSourcePosition(outerSourcePosition, code.getMethod(), bci);
381         }
382     }
383 
384     public FrameStateBuilder copy() {
385         return new FrameStateBuilder(this);
386     }
387 
<a name="13" id="anc13"></a><span class="line-modified">388     public boolean isCompatibleWith(FrameStateBuilder other) {</span>














389         assert code.equals(other.code) &amp;&amp; graph == other.graph &amp;&amp; localsSize() == other.localsSize() : &quot;Can only compare frame states of the same method&quot;;
390         assert lockedObjects.length == monitorIds.length &amp;&amp; other.lockedObjects.length == other.monitorIds.length : &quot;mismatch between lockedObjects and monitorIds&quot;;
391 
<a name="14" id="anc14"></a>



392         if (stackSize() != other.stackSize()) {
<a name="15" id="anc15"></a><span class="line-modified">393             return false;</span>
394         }
395         for (int i = 0; i &lt; stackSize(); i++) {
396             ValueNode x = stack[i];
397             ValueNode y = other.stack[i];
398             assert x != null &amp;&amp; y != null;
399             if (x != y &amp;&amp; (x == TWO_SLOT_MARKER || x.isDeleted() || y == TWO_SLOT_MARKER || y.isDeleted() || x.getStackKind() != y.getStackKind())) {
<a name="16" id="anc16"></a><span class="line-modified">400                 return false;</span>
401             }
402         }
403         if (lockedObjects.length != other.lockedObjects.length) {
<a name="17" id="anc17"></a><span class="line-modified">404             return false;</span>
405         }
406         for (int i = 0; i &lt; lockedObjects.length; i++) {
<a name="18" id="anc18"></a><span class="line-modified">407             if (GraphUtil.originalValue(lockedObjects[i]) != GraphUtil.originalValue(other.lockedObjects[i]) || monitorIds[i] != other.monitorIds[i]) {</span>
<span class="line-modified">408                 throw new PermanentBailoutException(&quot;unbalanced monitors&quot;);</span>



409             }
410         }
<a name="19" id="anc19"></a><span class="line-removed">411         return true;</span>
412     }
413 
414     public void merge(AbstractMergeNode block, FrameStateBuilder other) {
<a name="20" id="anc20"></a><span class="line-modified">415         assert isCompatibleWith(other);</span>
416 
417         for (int i = 0; i &lt; localsSize(); i++) {
418             locals[i] = merge(locals[i], other.locals[i], block);
419         }
420         for (int i = 0; i &lt; stackSize(); i++) {
421             stack[i] = merge(stack[i], other.stack[i], block);
422         }
423         for (int i = 0; i &lt; lockedObjects.length; i++) {
424             lockedObjects[i] = merge(lockedObjects[i], other.lockedObjects[i], block);
425             assert monitorIds[i] == other.monitorIds[i];
426         }
427 
428         if (sideEffects == null) {
429             sideEffects = other.sideEffects;
430         } else {
431             if (other.sideEffects != null) {
432                 sideEffects.addAll(other.sideEffects);
433             }
434         }
435     }
436 
437     private ValueNode merge(ValueNode currentValue, ValueNode otherValue, AbstractMergeNode block) {
438         if (currentValue == null || currentValue.isDeleted()) {
439             return null;
440         } else if (block.isPhiAtMerge(currentValue)) {
441             if (otherValue == null || otherValue == TWO_SLOT_MARKER || otherValue.isDeleted() || currentValue.getStackKind() != otherValue.getStackKind()) {
442                 // This phi must be dead anyway, add input of correct stack kind to keep the graph
443                 // invariants.
444                 ((PhiNode) currentValue).addInput(ConstantNode.defaultForKind(currentValue.getStackKind(), graph));
445             } else {
446                 ((PhiNode) currentValue).addInput(otherValue);
447             }
448             return currentValue;
449         } else if (currentValue != otherValue) {
450             if (currentValue == TWO_SLOT_MARKER || otherValue == TWO_SLOT_MARKER) {
451                 return null;
452             } else if (otherValue == null || otherValue.isDeleted() || currentValue.getStackKind() != otherValue.getStackKind()) {
453                 return null;
454             }
455             assert !(block instanceof LoopBeginNode) : String.format(&quot;Phi functions for loop headers are create eagerly for changed locals and all stack slots: %s != %s&quot;, currentValue, otherValue);
456             return createValuePhi(currentValue, otherValue, block);
457         } else {
458             return currentValue;
459         }
460     }
461 
462     private ValuePhiNode createValuePhi(ValueNode currentValue, ValueNode otherValue, AbstractMergeNode block) {
463         ValuePhiNode phi = graph.addWithoutUnique(new ValuePhiNode(currentValue.stamp(NodeView.DEFAULT).unrestricted(), block));
464         for (int i = 0; i &lt; block.phiPredecessorCount(); i++) {
465             phi.addInput(currentValue);
466         }
467         phi.addInput(otherValue);
468         assert phi.valueCount() == block.phiPredecessorCount() + 1;
469         return phi;
470     }
471 
472     public void inferPhiStamps(AbstractMergeNode block) {
473         for (int i = 0; i &lt; localsSize(); i++) {
474             inferPhiStamp(block, locals[i]);
475         }
476         for (int i = 0; i &lt; stackSize(); i++) {
477             inferPhiStamp(block, stack[i]);
478         }
479         for (int i = 0; i &lt; lockedObjects.length; i++) {
480             inferPhiStamp(block, lockedObjects[i]);
481         }
482     }
483 
484     private static void inferPhiStamp(AbstractMergeNode block, ValueNode node) {
485         if (block.isPhiAtMerge(node)) {
486             node.inferStamp();
487         }
488     }
489 
490     public void insertLoopPhis(LocalLiveness liveness, int loopId, LoopBeginNode loopBegin, boolean forcePhis, boolean stampFromValueForForcedPhis) {
491         for (int i = 0; i &lt; localsSize(); i++) {
492             boolean changedInLoop = liveness.localIsChangedInLoop(loopId, i);
493             if (forcePhis || changedInLoop) {
494                 locals[i] = createLoopPhi(loopBegin, locals[i], stampFromValueForForcedPhis &amp;&amp; !changedInLoop);
495             }
496         }
497         for (int i = 0; i &lt; stackSize(); i++) {
498             stack[i] = createLoopPhi(loopBegin, stack[i], false);
499         }
500         for (int i = 0; i &lt; lockedObjects.length; i++) {
501             lockedObjects[i] = createLoopPhi(loopBegin, lockedObjects[i], false);
502         }
503     }
504 
505     public void insertLoopProxies(LoopExitNode loopExit, FrameStateBuilder loopEntryState) {
506         DebugContext debug = graph.getDebug();
507         for (int i = 0; i &lt; localsSize(); i++) {
508             ValueNode value = locals[i];
509             if (value != null &amp;&amp; value != TWO_SLOT_MARKER &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
510                 debug.log(&quot; inserting proxy for %s&quot;, value);
<a name="21" id="anc21"></a><span class="line-modified">511                 locals[i] = ProxyNode.forValue(value, loopExit, graph);</span>
512             }
513         }
514         for (int i = 0; i &lt; stackSize(); i++) {
515             ValueNode value = stack[i];
516             if (value != null &amp;&amp; value != TWO_SLOT_MARKER &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
517                 debug.log(&quot; inserting proxy for %s&quot;, value);
<a name="22" id="anc22"></a><span class="line-modified">518                 stack[i] = ProxyNode.forValue(value, loopExit, graph);</span>
519             }
520         }
521         for (int i = 0; i &lt; lockedObjects.length; i++) {
522             ValueNode value = lockedObjects[i];
523             if (value != null &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
524                 debug.log(&quot; inserting proxy for %s&quot;, value);
<a name="23" id="anc23"></a><span class="line-modified">525                 lockedObjects[i] = ProxyNode.forValue(value, loopExit, graph);</span>
526             }
527         }
528     }
529 
530     public void insertProxies(Function&lt;ValueNode, ValueNode&gt; proxyFunction) {
531         DebugContext debug = graph.getDebug();
532         for (int i = 0; i &lt; localsSize(); i++) {
533             ValueNode value = locals[i];
534             if (value != null &amp;&amp; value != TWO_SLOT_MARKER) {
535                 debug.log(&quot; inserting proxy for %s&quot;, value);
536                 locals[i] = proxyFunction.apply(value);
537             }
538         }
539         for (int i = 0; i &lt; stackSize(); i++) {
540             ValueNode value = stack[i];
541             if (value != null &amp;&amp; value != TWO_SLOT_MARKER) {
542                 debug.log(&quot; inserting proxy for %s&quot;, value);
543                 stack[i] = proxyFunction.apply(value);
544             }
545         }
546         for (int i = 0; i &lt; lockedObjects.length; i++) {
547             ValueNode value = lockedObjects[i];
548             if (value != null) {
549                 debug.log(&quot; inserting proxy for %s&quot;, value);
550                 lockedObjects[i] = proxyFunction.apply(value);
551             }
552         }
553     }
554 
555     private ValueNode createLoopPhi(AbstractMergeNode block, ValueNode value, boolean stampFromValue) {
556         if (value == null || value == TWO_SLOT_MARKER) {
557             return value;
558         }
559         assert !block.isPhiAtMerge(value) : &quot;phi function for this block already created&quot;;
560 
561         ValuePhiNode phi = graph.addWithoutUnique(new ValuePhiNode(stampFromValue ? value.stamp(NodeView.DEFAULT) : value.stamp(NodeView.DEFAULT).unrestricted(), block));
562         phi.addInput(value);
563         return phi;
564     }
565 
566     /**
567      * Adds a locked monitor to this frame state.
568      *
569      * @param object the object whose monitor will be locked.
570      */
571     public void pushLock(ValueNode object, MonitorIdNode monitorId) {
572         assert object.isAlive() &amp;&amp; object.getStackKind() == JavaKind.Object : &quot;unexpected value: &quot; + object;
573         lockedObjects = Arrays.copyOf(lockedObjects, lockedObjects.length + 1);
574         monitorIds = Arrays.copyOf(monitorIds, monitorIds.length + 1);
575         lockedObjects[lockedObjects.length - 1] = object;
576         monitorIds[monitorIds.length - 1] = monitorId;
577         assert lockedObjects.length == monitorIds.length;
578     }
579 
580     /**
581      * Removes a locked monitor from this frame state.
582      *
583      * @return the object whose monitor was removed from the locks list.
584      */
585     public ValueNode popLock() {
586         try {
587             return lockedObjects[lockedObjects.length - 1];
588         } finally {
589             lockedObjects = lockedObjects.length == 1 ? EMPTY_ARRAY : Arrays.copyOf(lockedObjects, lockedObjects.length - 1);
590             monitorIds = monitorIds.length == 1 ? EMPTY_MONITOR_ARRAY : Arrays.copyOf(monitorIds, monitorIds.length - 1);
591             assert lockedObjects.length == monitorIds.length;
592         }
593     }
594 
595     public MonitorIdNode peekMonitorId() {
596         return monitorIds[monitorIds.length - 1];
597     }
598 
599     /**
600      * @return the current lock depth
601      */
602     public int lockDepth(boolean includeParents) {
603         int depth = lockedObjects.length;
604         assert depth == monitorIds.length;
605         if (includeParents &amp;&amp; parser.getParent() != null) {
606             depth += parser.getParent().frameState.lockDepth(true);
607         }
608         return depth;
609     }
610 
611     public boolean contains(ValueNode value) {
612         for (int i = 0; i &lt; localsSize(); i++) {
613             if (locals[i] == value) {
614                 return true;
615             }
616         }
617         for (int i = 0; i &lt; stackSize(); i++) {
618             if (stack[i] == value) {
619                 return true;
620             }
621         }
622         assert lockedObjects.length == monitorIds.length;
623         for (int i = 0; i &lt; lockedObjects.length; i++) {
624             if (lockedObjects[i] == value || monitorIds[i] == value) {
625                 return true;
626             }
627         }
628         return false;
629     }
630 
631     public void clearNonLiveLocals(BciBlock block, LocalLiveness liveness, boolean liveIn) {
632         /*
<a name="24" id="anc24"></a><span class="line-modified">633          * (lstadler) if somebody is tempted to remove/disable this clearing code: it&#39;s possible to</span>
<span class="line-modified">634          * remove it for normal compilations, but not for OSR compilations - otherwise dead object</span>
<span class="line-modified">635          * slots at the OSR entry aren&#39;t cleared. it is also not enough to rely on PiNodes with</span>
<span class="line-removed">636          * Kind.Illegal, because the conflicting branch might not have been parsed.</span>
637          */
<a name="25" id="anc25"></a><span class="line-modified">638         if (!clearNonLiveLocals) {</span>

639             return;
640         }
641         if (liveIn) {
642             for (int i = 0; i &lt; locals.length; i++) {
643                 if (!liveness.localIsLiveIn(block, i)) {
644                     assert locals[i] != TWO_SLOT_MARKER || locals[i - 1] == null : &quot;Clearing of second slot must have cleared the first slot too&quot;;
645                     locals[i] = null;
646                 }
647             }
648         } else {
649             for (int i = 0; i &lt; locals.length; i++) {
650                 if (!liveness.localIsLiveOut(block, i)) {
651                     assert locals[i] != TWO_SLOT_MARKER || locals[i - 1] == null : &quot;Clearing of second slot must have cleared the first slot too&quot;;
652                     locals[i] = null;
653                 }
654             }
655         }
656     }
657 
658     /**
659      * Clears all local variables.
660      */
661     public void clearLocals() {
662         for (int i = 0; i &lt; locals.length; i++) {
663             locals[i] = null;
664         }
665     }
666 
667     /**
668      * @see BytecodeFrame#rethrowException
669      */
670     public boolean rethrowException() {
671         return rethrowException;
672     }
673 
674     /**
675      * @see BytecodeFrame#rethrowException
676      */
677     public void setRethrowException(boolean b) {
678         rethrowException = b;
679     }
680 
681     /**
682      * Returns the size of the local variables.
683      *
684      * @return the size of the local variables
685      */
686     public int localsSize() {
687         return locals.length;
688     }
689 
690     /**
691      * Gets the current size (height) of the stack.
692      */
693     public int stackSize() {
694         return stackSize;
695     }
696 
697     private boolean verifyKind(JavaKind slotKind, ValueNode x) {
698         assert x != null;
699         assert x != TWO_SLOT_MARKER;
700         assert slotKind.getSlotCount() &gt; 0;
701 
702         if (canVerifyKind) {
703             assert x.getStackKind() == slotKind.getStackKind();
704         }
705         return true;
706     }
707 
708     /**
709      * Loads the local variable at the specified index, checking that the returned value is non-null
710      * and that two-stack values are properly handled.
711      *
712      * @param i the index of the local variable to load
713      * @param slotKind the kind of the local variable from the point of view of the bytecodes
714      * @return the instruction that produced the specified local
715      */
716     public ValueNode loadLocal(int i, JavaKind slotKind) {
717         ValueNode x = locals[i];
718         assert verifyKind(slotKind, x);
719         assert slotKind.needsTwoSlots() ? locals[i + 1] == TWO_SLOT_MARKER : (i == locals.length - 1 || locals[i + 1] != TWO_SLOT_MARKER);
720         return x;
721     }
722 
723     /**
724      * Stores a given local variable at the specified index. If the value occupies two slots, then
725      * the next local variable index is also overwritten.
726      *
727      * @param i the index at which to store
728      * @param slotKind the kind of the local variable from the point of view of the bytecodes
729      * @param x the instruction which produces the value for the local
730      */
731     public void storeLocal(int i, JavaKind slotKind, ValueNode x) {
732         assert verifyKind(slotKind, x);
733 
734         if (locals[i] == TWO_SLOT_MARKER) {
735             /* Writing the second slot of a two-slot value invalidates the first slot. */
736             locals[i - 1] = null;
737         }
738         locals[i] = x;
739         if (slotKind.needsTwoSlots()) {
<a name="26" id="anc26"></a>






740             /* Writing a two-slot value: mark the second slot. */
741             locals[i + 1] = TWO_SLOT_MARKER;
742         } else if (i &lt; locals.length - 1 &amp;&amp; locals[i + 1] == TWO_SLOT_MARKER) {
743             /*
744              * Writing a one-slot value to an index previously occupied by a two-slot value: clear
745              * the old marker of the second slot.
746              */
747             locals[i + 1] = null;
748         }
749     }
750 
751     /**
752      * Pushes an instruction onto the stack with the expected type.
753      *
754      * @param slotKind the kind of the stack element from the point of view of the bytecodes
755      * @param x the instruction to push onto the stack
756      */
757     public void push(JavaKind slotKind, ValueNode x) {
758         assert verifyKind(slotKind, x);
759 
760         xpush(x);
761         if (slotKind.needsTwoSlots()) {
762             xpush(TWO_SLOT_MARKER);
763         }
764     }
765 
766     public void pushReturn(JavaKind slotKind, ValueNode x) {
767         if (slotKind != JavaKind.Void) {
768             push(slotKind, x);
769         }
770     }
771 
772     /**
773      * Pops an instruction off the stack with the expected type.
774      *
775      * @param slotKind the kind of the stack element from the point of view of the bytecodes
776      * @return the instruction on the top of the stack
777      */
778     public ValueNode pop(JavaKind slotKind) {
779         if (slotKind.needsTwoSlots()) {
780             ValueNode s = xpop();
<a name="27" id="anc27"></a><span class="line-modified">781             assert s == TWO_SLOT_MARKER;</span>
782         }
783         ValueNode x = xpop();
784         assert verifyKind(slotKind, x);
785         return x;
786     }
787 
788     private void xpush(ValueNode x) {
789         assert x != null;
790         stack[stackSize++] = x;
791     }
792 
793     private ValueNode xpop() {
794         ValueNode result = stack[--stackSize];
795         assert result != null;
796         return result;
797     }
798 
799     private ValueNode xpeek() {
800         ValueNode result = stack[stackSize - 1];
801         assert result != null;
802         return result;
803     }
804 
<a name="28" id="anc28"></a>





805     /**
806      * Pop the specified number of slots off of this stack and return them as an array of
807      * instructions.
808      *
809      * @return an array containing the arguments off of the stack
810      */
811     public ValueNode[] popArguments(int argSize) {
812         ValueNode[] result = allocateArray(argSize);
813         for (int i = argSize - 1; i &gt;= 0; i--) {
814             ValueNode x = xpop();
815             if (x == TWO_SLOT_MARKER) {
816                 /* Ignore second slot of two-slot value. */
817                 x = xpop();
818             }
<a name="29" id="anc29"></a><span class="line-modified">819             assert x != null &amp;&amp; x != TWO_SLOT_MARKER;</span>
820             result[i] = x;
821         }
822         return result;
823     }
824 
825     /**
826      * Clears all values on this stack.
827      */
828     public void clearStack() {
829         stackSize = 0;
830     }
831 
832     /**
833      * Performs a raw stack operation as defined in the Java bytecode specification.
834      *
835      * @param opcode The Java bytecode.
836      */
837     public void stackOp(int opcode) {
838         switch (opcode) {
839             case POP: {
840                 ValueNode w1 = xpop();
841                 assert w1 != TWO_SLOT_MARKER;
842                 break;
843             }
844             case POP2: {
845                 xpop();
846                 ValueNode w2 = xpop();
847                 assert w2 != TWO_SLOT_MARKER;
848                 break;
849             }
850             case DUP: {
851                 ValueNode w1 = xpeek();
852                 assert w1 != TWO_SLOT_MARKER;
853                 xpush(w1);
854                 break;
855             }
856             case DUP_X1: {
857                 ValueNode w1 = xpop();
858                 ValueNode w2 = xpop();
859                 assert w1 != TWO_SLOT_MARKER;
860                 xpush(w1);
861                 xpush(w2);
862                 xpush(w1);
863                 break;
864             }
865             case DUP_X2: {
866                 ValueNode w1 = xpop();
867                 ValueNode w2 = xpop();
868                 ValueNode w3 = xpop();
869                 assert w1 != TWO_SLOT_MARKER;
870                 xpush(w1);
871                 xpush(w3);
872                 xpush(w2);
873                 xpush(w1);
874                 break;
875             }
876             case DUP2: {
877                 ValueNode w1 = xpop();
878                 ValueNode w2 = xpop();
879                 xpush(w2);
880                 xpush(w1);
881                 xpush(w2);
882                 xpush(w1);
883                 break;
884             }
885             case DUP2_X1: {
886                 ValueNode w1 = xpop();
887                 ValueNode w2 = xpop();
888                 ValueNode w3 = xpop();
889                 xpush(w2);
890                 xpush(w1);
891                 xpush(w3);
892                 xpush(w2);
893                 xpush(w1);
894                 break;
895             }
896             case DUP2_X2: {
897                 ValueNode w1 = xpop();
898                 ValueNode w2 = xpop();
899                 ValueNode w3 = xpop();
900                 ValueNode w4 = xpop();
901                 xpush(w2);
902                 xpush(w1);
903                 xpush(w4);
904                 xpush(w3);
905                 xpush(w2);
906                 xpush(w1);
907                 break;
908             }
909             case SWAP: {
910                 ValueNode w1 = xpop();
911                 ValueNode w2 = xpop();
912                 assert w1 != TWO_SLOT_MARKER;
913                 assert w2 != TWO_SLOT_MARKER;
914                 xpush(w1);
915                 xpush(w2);
916                 break;
917             }
918             default:
919                 throw shouldNotReachHere();
920         }
921     }
922 
923     @Override
924     public int hashCode() {
925         int result = hashCode(locals, locals.length);
926         result *= 13;
927         result += hashCode(stack, this.stackSize);
928         return result;
929     }
930 
931     private static int hashCode(Object[] a, int length) {
932         int result = 1;
933         for (int i = 0; i &lt; length; ++i) {
934             Object element = a[i];
935             result = 31 * result + (element == null ? 0 : System.identityHashCode(element));
936         }
937         return result;
938     }
939 
940     private static boolean equals(ValueNode[] a, ValueNode[] b, int length) {
941         for (int i = 0; i &lt; length; ++i) {
942             if (a[i] != b[i]) {
943                 return false;
944             }
945         }
946         return true;
947     }
948 
949     @Override
950     public boolean equals(Object otherObject) {
951         if (otherObject instanceof FrameStateBuilder) {
952             FrameStateBuilder other = (FrameStateBuilder) otherObject;
953             if (!other.code.equals(code)) {
954                 return false;
955             }
956             if (other.stackSize != stackSize) {
957                 return false;
958             }
959             if (other.parser != parser) {
960                 return false;
961             }
962             if (other.tool != tool) {
963                 return false;
964             }
965             if (other.rethrowException != rethrowException) {
966                 return false;
967             }
968             if (other.graph != graph) {
969                 return false;
970             }
971             if (other.locals.length != locals.length) {
972                 return false;
973             }
974             return equals(other.locals, locals, locals.length) &amp;&amp; equals(other.stack, stack, stackSize) &amp;&amp; equals(other.lockedObjects, lockedObjects, lockedObjects.length) &amp;&amp;
975                             equals(other.monitorIds, monitorIds, monitorIds.length);
976         }
977         return false;
978     }
979 
980     @Override
981     public boolean isAfterSideEffect() {
982         return sideEffects != null;
983     }
984 
985     @Override
986     public Iterable&lt;StateSplit&gt; sideEffects() {
987         return sideEffects;
988     }
989 
990     @Override
991     public void addSideEffect(StateSplit sideEffect) {
992         assert sideEffect != null;
993         assert sideEffect.hasSideEffect();
994         if (sideEffects == null) {
995             sideEffects = new ArrayList&lt;&gt;(4);
996         }
997         sideEffects.add(sideEffect);
998     }
<a name="30" id="anc30"></a>












999 }
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
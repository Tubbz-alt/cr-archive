<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/FrameStateBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeParserOptions.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphBuilderPhase.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/FrameStateBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -33,23 +33,24 @@</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.POP;
  import static org.graalvm.compiler.bytecode.Bytecodes.POP2;
  import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;
  import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
  import static org.graalvm.compiler.nodes.FrameState.TWO_SLOT_MARKER;
<span class="udiff-line-added">+ import static org.graalvm.compiler.nodes.util.GraphUtil.originalValue;</span>
  
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.List;
  import java.util.function.Function;
  
  import org.graalvm.compiler.bytecode.Bytecode;
  import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
<span class="udiff-line-removed">- import org.graalvm.compiler.core.common.GraalOptions;</span>
  import org.graalvm.compiler.core.common.PermanentBailoutException;
  import org.graalvm.compiler.core.common.type.StampFactory;
  import org.graalvm.compiler.core.common.type.StampPair;
  import org.graalvm.compiler.debug.DebugContext;
<span class="udiff-line-added">+ import org.graalvm.compiler.debug.GraalError;</span>
  import org.graalvm.compiler.graph.NodeSourcePosition;
  import org.graalvm.compiler.java.BciBlockMapping.BciBlock;
  import org.graalvm.compiler.nodeinfo.Verbosity;
  import org.graalvm.compiler.nodes.AbstractMergeNode;
  import org.graalvm.compiler.nodes.ConstantNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -68,11 +69,10 @@</span>
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderTool;
  import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.SideEffectsState;
  import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
  import org.graalvm.compiler.nodes.java.MonitorIdNode;
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.util.GraphUtil;</span>
  
  import jdk.vm.ci.code.BytecodeFrame;
  import jdk.vm.ci.meta.Assumptions;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.JavaType;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -116,21 +116,22 @@</span>
       *
       * @param method the method whose frame is simulated
       * @param graph the target graph of Graal nodes created by the builder
       */
      public FrameStateBuilder(GraphBuilderTool tool, ResolvedJavaMethod method, StructuredGraph graph) {
<span class="udiff-line-modified-removed">-         this(tool, new ResolvedJavaMethodBytecode(method), graph);</span>
<span class="udiff-line-modified-added">+         this(tool, new ResolvedJavaMethodBytecode(method), graph, false);</span>
      }
  
      /**
       * Creates a new frame state builder for the given code attribute, method and the given target
<span class="udiff-line-modified-removed">-      * graph.</span>
<span class="udiff-line-modified-added">+      * graph. Additionally specifies if nonLiveLocals should be retained.</span>
       *
       * @param code the bytecode in which the frame exists
       * @param graph the target graph of Graal nodes created by the builder
<span class="udiff-line-added">+      * @param shouldRetainLocalVariables specifies if nonLiveLocals should be retained in state.</span>
       */
<span class="udiff-line-modified-removed">-     public FrameStateBuilder(GraphBuilderTool tool, Bytecode code, StructuredGraph graph) {</span>
<span class="udiff-line-modified-added">+     public FrameStateBuilder(GraphBuilderTool tool, Bytecode code, StructuredGraph graph, boolean shouldRetainLocalVariables) {</span>
          this.tool = tool;
          if (tool instanceof BytecodeParser) {
              this.parser = (BytecodeParser) tool;
          } else {
              this.parser = null;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -142,11 +143,11 @@</span>
  
          assert graph != null;
  
          this.monitorIds = EMPTY_MONITOR_ARRAY;
          this.graph = graph;
<span class="udiff-line-modified-removed">-         this.clearNonLiveLocals = GraalOptions.OptClearNonLiveLocals.getValue(graph.getOptions());</span>
<span class="udiff-line-modified-added">+         this.clearNonLiveLocals = !shouldRetainLocalVariables;</span>
          this.canVerifyKind = true;
      }
  
      public void disableKindVerification() {
          canVerifyKind = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -271,12 +272,10 @@</span>
          assert other.graph != null;
          graph = other.graph;
          clearNonLiveLocals = other.clearNonLiveLocals;
          monitorIds = other.monitorIds.length == 0 ? other.monitorIds : other.monitorIds.clone();
  
<span class="udiff-line-removed">-         assert locals.length == code.getMaxLocals();</span>
<span class="udiff-line-removed">-         assert stack.length == Math.max(1, code.getMaxStackSize());</span>
          assert lockedObjects.length == monitorIds.length;
      }
  
      private static ValueNode[] allocateArray(int length) {
          return length == 0 ? EMPTY_ARRAY : new ValueNode[length];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -327,12 +326,11 @@</span>
          if (outerFrameState == null &amp;&amp; parent != null) {
              assert !parent.parsingIntrinsic() : &quot;must already have the next non-intrinsic ancestor&quot;;
              outerFrameState = parent.getFrameStateBuilder().create(parent.bci(), parent.getNonIntrinsicAncestor(), true, null, null);
          }
          if (bci == BytecodeFrame.AFTER_EXCEPTION_BCI &amp;&amp; parent != null) {
<span class="udiff-line-modified-removed">-             FrameState newFrameState = outerFrameState.duplicateModified(outerFrameState.bci, true, false, JavaKind.Void, new JavaKind[]{JavaKind.Object}, new ValueNode[]{stack[0]});</span>
<span class="udiff-line-removed">-             return newFrameState;</span>
<span class="udiff-line-modified-added">+             return outerFrameState.duplicateModified(graph, outerFrameState.bci, true, false, JavaKind.Void, new JavaKind[]{JavaKind.Object}, new ValueNode[]{stack[0]});</span>
          }
          if (bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
              throw shouldNotReachHere();
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -383,38 +381,58 @@</span>
  
      public FrameStateBuilder copy() {
          return new FrameStateBuilder(this);
      }
  
<span class="udiff-line-modified-removed">-     public boolean isCompatibleWith(FrameStateBuilder other) {</span>
<span class="udiff-line-modified-added">+     private String incompatibilityErrorMessage(String reason, FrameStateBuilder other) {</span>
<span class="udiff-line-added">+         return String.format(&quot;Frame states being merged are incompatible: %s%n This frame state: %s%nOther frame state: %s%nParser context: %s&quot;, reason, this, other, parser);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Checks invariants that must hold when merging {@code other} into this frame state.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param other</span>
<span class="udiff-line-added">+      * @throws PermanentBailoutException if the frame states are incompatible with respect to their</span>
<span class="udiff-line-added">+      *             locked objects. This indicates bytecode that has unstructured or unbalanced</span>
<span class="udiff-line-added">+      *             locks.</span>
<span class="udiff-line-added">+      * @throws GraalError if the frame states are incompatible in terms of {@link #rethrowException}</span>
<span class="udiff-line-added">+      *             or stack slots</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void checkCompatibleWith(FrameStateBuilder other) {</span>
          assert code.equals(other.code) &amp;&amp; graph == other.graph &amp;&amp; localsSize() == other.localsSize() : &quot;Can only compare frame states of the same method&quot;;
          assert lockedObjects.length == monitorIds.length &amp;&amp; other.lockedObjects.length == other.monitorIds.length : &quot;mismatch between lockedObjects and monitorIds&quot;;
  
<span class="udiff-line-added">+         if (rethrowException != other.rethrowException) {</span>
<span class="udiff-line-added">+             throw new GraalError(incompatibilityErrorMessage(&quot;mismatch in rethrowException flag&quot;, other));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          if (stackSize() != other.stackSize()) {
<span class="udiff-line-modified-removed">-             return false;</span>
<span class="udiff-line-modified-added">+             throw new GraalError(incompatibilityErrorMessage(&quot;mismatch in stack sizes&quot;, other));</span>
          }
          for (int i = 0; i &lt; stackSize(); i++) {
              ValueNode x = stack[i];
              ValueNode y = other.stack[i];
              assert x != null &amp;&amp; y != null;
              if (x != y &amp;&amp; (x == TWO_SLOT_MARKER || x.isDeleted() || y == TWO_SLOT_MARKER || y.isDeleted() || x.getStackKind() != y.getStackKind())) {
<span class="udiff-line-modified-removed">-                 return false;</span>
<span class="udiff-line-modified-added">+                 throw new GraalError(incompatibilityErrorMessage(&quot;mismatch in stack types&quot;, other));</span>
              }
          }
          if (lockedObjects.length != other.lockedObjects.length) {
<span class="udiff-line-modified-removed">-             return false;</span>
<span class="udiff-line-modified-added">+             throw new PermanentBailoutException(incompatibilityErrorMessage(&quot;unbalanced monitors - locked objects do not match&quot;, other));</span>
          }
          for (int i = 0; i &lt; lockedObjects.length; i++) {
<span class="udiff-line-modified-removed">-             if (GraphUtil.originalValue(lockedObjects[i]) != GraphUtil.originalValue(other.lockedObjects[i]) || monitorIds[i] != other.monitorIds[i]) {</span>
<span class="udiff-line-modified-removed">-                 throw new PermanentBailoutException(&quot;unbalanced monitors&quot;);</span>
<span class="udiff-line-modified-added">+             if (originalValue(lockedObjects[i], false) != originalValue(other.lockedObjects[i], false)) {</span>
<span class="udiff-line-modified-added">+                 throw new PermanentBailoutException(incompatibilityErrorMessage(&quot;unbalanced monitors - locked objects do not match&quot;, other));</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (monitorIds[i] != other.monitorIds[i]) {</span>
<span class="udiff-line-added">+                 throw new PermanentBailoutException(incompatibilityErrorMessage(&quot;unbalanced monitors - monitors do not match&quot;, other));</span>
              }
          }
<span class="udiff-line-removed">-         return true;</span>
      }
  
      public void merge(AbstractMergeNode block, FrameStateBuilder other) {
<span class="udiff-line-modified-removed">-         assert isCompatibleWith(other);</span>
<span class="udiff-line-modified-added">+         checkCompatibleWith(other);</span>
  
          for (int i = 0; i &lt; localsSize(); i++) {
              locals[i] = merge(locals[i], other.locals[i], block);
          }
          for (int i = 0; i &lt; stackSize(); i++) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -506,25 +524,25 @@</span>
          DebugContext debug = graph.getDebug();
          for (int i = 0; i &lt; localsSize(); i++) {
              ValueNode value = locals[i];
              if (value != null &amp;&amp; value != TWO_SLOT_MARKER &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
                  debug.log(&quot; inserting proxy for %s&quot;, value);
<span class="udiff-line-modified-removed">-                 locals[i] = ProxyNode.forValue(value, loopExit, graph);</span>
<span class="udiff-line-modified-added">+                 locals[i] = ProxyNode.forValue(value, loopExit);</span>
              }
          }
          for (int i = 0; i &lt; stackSize(); i++) {
              ValueNode value = stack[i];
              if (value != null &amp;&amp; value != TWO_SLOT_MARKER &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
                  debug.log(&quot; inserting proxy for %s&quot;, value);
<span class="udiff-line-modified-removed">-                 stack[i] = ProxyNode.forValue(value, loopExit, graph);</span>
<span class="udiff-line-modified-added">+                 stack[i] = ProxyNode.forValue(value, loopExit);</span>
              }
          }
          for (int i = 0; i &lt; lockedObjects.length; i++) {
              ValueNode value = lockedObjects[i];
              if (value != null &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
                  debug.log(&quot; inserting proxy for %s&quot;, value);
<span class="udiff-line-modified-removed">-                 lockedObjects[i] = ProxyNode.forValue(value, loopExit, graph);</span>
<span class="udiff-line-modified-added">+                 lockedObjects[i] = ProxyNode.forValue(value, loopExit);</span>
              }
          }
      }
  
      public void insertProxies(Function&lt;ValueNode, ValueNode&gt; proxyFunction) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -628,16 +646,16 @@</span>
          return false;
      }
  
      public void clearNonLiveLocals(BciBlock block, LocalLiveness liveness, boolean liveIn) {
          /*
<span class="udiff-line-modified-removed">-          * (lstadler) if somebody is tempted to remove/disable this clearing code: it&#39;s possible to</span>
<span class="udiff-line-modified-removed">-          * remove it for normal compilations, but not for OSR compilations - otherwise dead object</span>
<span class="udiff-line-modified-removed">-          * slots at the OSR entry aren&#39;t cleared. it is also not enough to rely on PiNodes with</span>
<span class="udiff-line-removed">-          * Kind.Illegal, because the conflicting branch might not have been parsed.</span>
<span class="udiff-line-modified-added">+          * Non-live local clearing is mandatory for the entry block of an OSR compilation so that</span>
<span class="udiff-line-modified-added">+          * dead object slots at the OSR entry are cleared. It&#39;s not sufficient to rely on PiNodes</span>
<span class="udiff-line-modified-added">+          * with Kind.Illegal, because the conflicting branch might not have been parsed.</span>
           */
<span class="udiff-line-modified-removed">-         if (!clearNonLiveLocals) {</span>
<span class="udiff-line-modified-added">+         boolean isOSREntryBlock = graph.isOSR() &amp;&amp; getMethod().equals(graph.method()) &amp;&amp; graph.getEntryBCI() == block.startBci;</span>
<span class="udiff-line-added">+         if (!clearNonLiveLocals &amp;&amp; !isOSREntryBlock) {</span>
              return;
          }
          if (liveIn) {
              for (int i = 0; i &lt; locals.length; i++) {
                  if (!liveness.localIsLiveIn(block, i)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -735,10 +753,17 @@</span>
              /* Writing the second slot of a two-slot value invalidates the first slot. */
              locals[i - 1] = null;
          }
          locals[i] = x;
          if (slotKind.needsTwoSlots()) {
<span class="udiff-line-added">+             if (i &lt; locals.length - 2 &amp;&amp; locals[i + 2] == TWO_SLOT_MARKER) {</span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Writing a two-slot marker to an index previously occupied by a two-slot value:</span>
<span class="udiff-line-added">+                  * clear the old marker of the second slot.</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 locals[i + 2] = null;</span>
<span class="udiff-line-added">+             }</span>
              /* Writing a two-slot value: mark the second slot. */
              locals[i + 1] = TWO_SLOT_MARKER;
          } else if (i &lt; locals.length - 1 &amp;&amp; locals[i + 1] == TWO_SLOT_MARKER) {
              /*
               * Writing a one-slot value to an index previously occupied by a two-slot value: clear
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -776,11 +801,11 @@</span>
       * @return the instruction on the top of the stack
       */
      public ValueNode pop(JavaKind slotKind) {
          if (slotKind.needsTwoSlots()) {
              ValueNode s = xpop();
<span class="udiff-line-modified-removed">-             assert s == TWO_SLOT_MARKER;</span>
<span class="udiff-line-modified-added">+             assert s == TWO_SLOT_MARKER : s;</span>
          }
          ValueNode x = xpop();
          assert verifyKind(slotKind, x);
          return x;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -800,10 +825,16 @@</span>
          ValueNode result = stack[stackSize - 1];
          assert result != null;
          return result;
      }
  
<span class="udiff-line-added">+     public ValueNode peekObject() {</span>
<span class="udiff-line-added">+         ValueNode x = xpeek();</span>
<span class="udiff-line-added">+         assert verifyKind(JavaKind.Object, x);</span>
<span class="udiff-line-added">+         return x;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Pop the specified number of slots off of this stack and return them as an array of
       * instructions.
       *
       * @return an array containing the arguments off of the stack
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -814,11 +845,11 @@</span>
              ValueNode x = xpop();
              if (x == TWO_SLOT_MARKER) {
                  /* Ignore second slot of two-slot value. */
                  x = xpop();
              }
<span class="udiff-line-modified-removed">-             assert x != null &amp;&amp; x != TWO_SLOT_MARKER;</span>
<span class="udiff-line-modified-added">+             assert x != null &amp;&amp; x != TWO_SLOT_MARKER : x;</span>
              result[i] = x;
          }
          return result;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -994,6 +1025,19 @@</span>
          if (sideEffects == null) {
              sideEffects = new ArrayList&lt;&gt;(4);
          }
          sideEffects.add(sideEffect);
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public void replaceValue(ValueNode oldValue, ValueNode newValue) {</span>
<span class="udiff-line-added">+         for (int i = 0; i &lt; locals.length; ++i) {</span>
<span class="udiff-line-added">+             if (locals[i] == oldValue) {</span>
<span class="udiff-line-added">+                 locals[i] = newValue;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         for (int i = 0; i &lt; stack.length; ++i) {</span>
<span class="udiff-line-added">+             if (stack[i] == oldValue) {</span>
<span class="udiff-line-added">+                 stack[i] = newValue;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="BytecodeParserOptions.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphBuilderPhase.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BciBlockMapping.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BciBlockMapping.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BciBlockMapping.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BciBlockMapping.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,31 +24,112 @@
 
 package org.graalvm.compiler.java;
 
 import static org.graalvm.compiler.bytecode.Bytecodes.AALOAD;
 import static org.graalvm.compiler.bytecode.Bytecodes.AASTORE;
+import static org.graalvm.compiler.bytecode.Bytecodes.ACONST_NULL;
+import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD;
+import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_2;
+import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_3;
 import static org.graalvm.compiler.bytecode.Bytecodes.ANEWARRAY;
 import static org.graalvm.compiler.bytecode.Bytecodes.ARETURN;
 import static org.graalvm.compiler.bytecode.Bytecodes.ARRAYLENGTH;
+import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE;
+import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_2;
+import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_3;
 import static org.graalvm.compiler.bytecode.Bytecodes.ATHROW;
 import static org.graalvm.compiler.bytecode.Bytecodes.BALOAD;
 import static org.graalvm.compiler.bytecode.Bytecodes.BASTORE;
+import static org.graalvm.compiler.bytecode.Bytecodes.BIPUSH;
+import static org.graalvm.compiler.bytecode.Bytecodes.BREAKPOINT;
 import static org.graalvm.compiler.bytecode.Bytecodes.CALOAD;
 import static org.graalvm.compiler.bytecode.Bytecodes.CASTORE;
 import static org.graalvm.compiler.bytecode.Bytecodes.CHECKCAST;
+import static org.graalvm.compiler.bytecode.Bytecodes.D2F;
+import static org.graalvm.compiler.bytecode.Bytecodes.D2I;
+import static org.graalvm.compiler.bytecode.Bytecodes.D2L;
+import static org.graalvm.compiler.bytecode.Bytecodes.DADD;
 import static org.graalvm.compiler.bytecode.Bytecodes.DALOAD;
 import static org.graalvm.compiler.bytecode.Bytecodes.DASTORE;
+import static org.graalvm.compiler.bytecode.Bytecodes.DCMPG;
+import static org.graalvm.compiler.bytecode.Bytecodes.DCMPL;
+import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.DDIV;
+import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD;
+import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_2;
+import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_3;
+import static org.graalvm.compiler.bytecode.Bytecodes.DMUL;
+import static org.graalvm.compiler.bytecode.Bytecodes.DNEG;
+import static org.graalvm.compiler.bytecode.Bytecodes.DREM;
 import static org.graalvm.compiler.bytecode.Bytecodes.DRETURN;
+import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE;
+import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_2;
+import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_3;
+import static org.graalvm.compiler.bytecode.Bytecodes.DSUB;
+import static org.graalvm.compiler.bytecode.Bytecodes.DUP;
+import static org.graalvm.compiler.bytecode.Bytecodes.DUP2;
+import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X1;
+import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X2;
+import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X1;
+import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X2;
+import static org.graalvm.compiler.bytecode.Bytecodes.F2D;
+import static org.graalvm.compiler.bytecode.Bytecodes.F2I;
+import static org.graalvm.compiler.bytecode.Bytecodes.F2L;
+import static org.graalvm.compiler.bytecode.Bytecodes.FADD;
 import static org.graalvm.compiler.bytecode.Bytecodes.FALOAD;
 import static org.graalvm.compiler.bytecode.Bytecodes.FASTORE;
+import static org.graalvm.compiler.bytecode.Bytecodes.FCMPG;
+import static org.graalvm.compiler.bytecode.Bytecodes.FCMPL;
+import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_2;
+import static org.graalvm.compiler.bytecode.Bytecodes.FDIV;
+import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD;
+import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_2;
+import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_3;
+import static org.graalvm.compiler.bytecode.Bytecodes.FMUL;
+import static org.graalvm.compiler.bytecode.Bytecodes.FNEG;
+import static org.graalvm.compiler.bytecode.Bytecodes.FREM;
 import static org.graalvm.compiler.bytecode.Bytecodes.FRETURN;
+import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE;
+import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_2;
+import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_3;
+import static org.graalvm.compiler.bytecode.Bytecodes.FSUB;
 import static org.graalvm.compiler.bytecode.Bytecodes.GETFIELD;
 import static org.graalvm.compiler.bytecode.Bytecodes.GETSTATIC;
 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO;
 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO_W;
+import static org.graalvm.compiler.bytecode.Bytecodes.I2B;
+import static org.graalvm.compiler.bytecode.Bytecodes.I2C;
+import static org.graalvm.compiler.bytecode.Bytecodes.I2D;
+import static org.graalvm.compiler.bytecode.Bytecodes.I2F;
+import static org.graalvm.compiler.bytecode.Bytecodes.I2L;
+import static org.graalvm.compiler.bytecode.Bytecodes.I2S;
+import static org.graalvm.compiler.bytecode.Bytecodes.IADD;
 import static org.graalvm.compiler.bytecode.Bytecodes.IALOAD;
+import static org.graalvm.compiler.bytecode.Bytecodes.IAND;
 import static org.graalvm.compiler.bytecode.Bytecodes.IASTORE;
+import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_2;
+import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_3;
+import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_4;
+import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_5;
+import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_M1;
 import static org.graalvm.compiler.bytecode.Bytecodes.IDIV;
 import static org.graalvm.compiler.bytecode.Bytecodes.IFEQ;
 import static org.graalvm.compiler.bytecode.Bytecodes.IFGE;
 import static org.graalvm.compiler.bytecode.Bytecodes.IFGT;
 import static org.graalvm.compiler.bytecode.Bytecodes.IFLE;
@@ -62,39 +143,95 @@
 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGE;
 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGT;
 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLE;
 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLT;
 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPNE;
+import static org.graalvm.compiler.bytecode.Bytecodes.IINC;
+import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD;
+import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_2;
+import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_3;
+import static org.graalvm.compiler.bytecode.Bytecodes.IMUL;
+import static org.graalvm.compiler.bytecode.Bytecodes.INEG;
+import static org.graalvm.compiler.bytecode.Bytecodes.INSTANCEOF;
 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEDYNAMIC;
 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEINTERFACE;
 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESPECIAL;
 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESTATIC;
 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEVIRTUAL;
+import static org.graalvm.compiler.bytecode.Bytecodes.IOR;
 import static org.graalvm.compiler.bytecode.Bytecodes.IREM;
 import static org.graalvm.compiler.bytecode.Bytecodes.IRETURN;
+import static org.graalvm.compiler.bytecode.Bytecodes.ISHL;
+import static org.graalvm.compiler.bytecode.Bytecodes.ISHR;
+import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE;
+import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_2;
+import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_3;
+import static org.graalvm.compiler.bytecode.Bytecodes.ISUB;
+import static org.graalvm.compiler.bytecode.Bytecodes.IUSHR;
+import static org.graalvm.compiler.bytecode.Bytecodes.IXOR;
 import static org.graalvm.compiler.bytecode.Bytecodes.JSR;
 import static org.graalvm.compiler.bytecode.Bytecodes.JSR_W;
+import static org.graalvm.compiler.bytecode.Bytecodes.L2D;
+import static org.graalvm.compiler.bytecode.Bytecodes.L2F;
+import static org.graalvm.compiler.bytecode.Bytecodes.L2I;
+import static org.graalvm.compiler.bytecode.Bytecodes.LADD;
 import static org.graalvm.compiler.bytecode.Bytecodes.LALOAD;
+import static org.graalvm.compiler.bytecode.Bytecodes.LAND;
 import static org.graalvm.compiler.bytecode.Bytecodes.LASTORE;
+import static org.graalvm.compiler.bytecode.Bytecodes.LCMP;
+import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_1;
 import static org.graalvm.compiler.bytecode.Bytecodes.LDC;
 import static org.graalvm.compiler.bytecode.Bytecodes.LDC2_W;
 import static org.graalvm.compiler.bytecode.Bytecodes.LDC_W;
 import static org.graalvm.compiler.bytecode.Bytecodes.LDIV;
+import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD;
+import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_2;
+import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_3;
+import static org.graalvm.compiler.bytecode.Bytecodes.LMUL;
+import static org.graalvm.compiler.bytecode.Bytecodes.LNEG;
 import static org.graalvm.compiler.bytecode.Bytecodes.LOOKUPSWITCH;
+import static org.graalvm.compiler.bytecode.Bytecodes.LOR;
 import static org.graalvm.compiler.bytecode.Bytecodes.LREM;
 import static org.graalvm.compiler.bytecode.Bytecodes.LRETURN;
+import static org.graalvm.compiler.bytecode.Bytecodes.LSHL;
+import static org.graalvm.compiler.bytecode.Bytecodes.LSHR;
+import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE;
+import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_0;
+import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_1;
+import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_2;
+import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_3;
+import static org.graalvm.compiler.bytecode.Bytecodes.LSUB;
+import static org.graalvm.compiler.bytecode.Bytecodes.LUSHR;
+import static org.graalvm.compiler.bytecode.Bytecodes.LXOR;
+import static org.graalvm.compiler.bytecode.Bytecodes.MONITORENTER;
+import static org.graalvm.compiler.bytecode.Bytecodes.MONITOREXIT;
 import static org.graalvm.compiler.bytecode.Bytecodes.MULTIANEWARRAY;
 import static org.graalvm.compiler.bytecode.Bytecodes.NEW;
+import static org.graalvm.compiler.bytecode.Bytecodes.NEWARRAY;
+import static org.graalvm.compiler.bytecode.Bytecodes.NOP;
+import static org.graalvm.compiler.bytecode.Bytecodes.POP;
+import static org.graalvm.compiler.bytecode.Bytecodes.POP2;
 import static org.graalvm.compiler.bytecode.Bytecodes.PUTFIELD;
 import static org.graalvm.compiler.bytecode.Bytecodes.PUTSTATIC;
 import static org.graalvm.compiler.bytecode.Bytecodes.RET;
 import static org.graalvm.compiler.bytecode.Bytecodes.RETURN;
 import static org.graalvm.compiler.bytecode.Bytecodes.SALOAD;
 import static org.graalvm.compiler.bytecode.Bytecodes.SASTORE;
+import static org.graalvm.compiler.bytecode.Bytecodes.SIPUSH;
+import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;
 import static org.graalvm.compiler.bytecode.Bytecodes.TABLESWITCH;
+import static org.graalvm.compiler.bytecode.Bytecodes.WIDE;
 import static org.graalvm.compiler.core.common.GraalOptions.SupportJsrBytecodes;
 
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
@@ -108,18 +245,19 @@
 import org.graalvm.compiler.bytecode.BytecodeSwitch;
 import org.graalvm.compiler.bytecode.BytecodeTableSwitch;
 import org.graalvm.compiler.bytecode.Bytecodes;
 import org.graalvm.compiler.core.common.PermanentBailoutException;
 import org.graalvm.compiler.debug.DebugContext;
+import org.graalvm.compiler.debug.GraalError;
 import org.graalvm.compiler.options.OptionValues;
 
 import jdk.vm.ci.code.BytecodeFrame;
 import jdk.vm.ci.meta.ExceptionHandler;
 
 /**
  * Builds a mapping between bytecodes and basic blocks and builds a conservative control flow graph
- * (CFG). It makes one linear passes over the bytecodes to build the CFG where it detects block
+ * (CFG). It makes one linear pass over the bytecodes to build the CFG where it detects block
  * headers and connects them.
  * <p>
  * It also creates exception dispatch blocks for exception handling. These blocks are between a
  * bytecode that might throw an exception, and the actual exception handler entries, and are later
  * used to create the type checks with the exception handler catch types. If a bytecode is covered
@@ -156,11 +294,11 @@
 
     public static class BciBlock implements Cloneable {
 
         int id;
         final int startBci;
-        int endBci;
+        int endBci; // The bci of the last bytecode in the block
         private boolean isExceptionEntry;
         private boolean isLoopHeader;
         int loopId;
         int loopEnd;
         List<BciBlock> successors;
@@ -475,10 +613,22 @@
         public boolean isExceptionDispatch() {
             return true;
         }
     }
 
+    private static final class TraversalStep {
+        private BciBlock block;
+        private int currentSuccessorIndex;
+        private long loops;
+
+        private TraversalStep(BciBlock block) {
+            this.block = block;
+            this.currentSuccessorIndex = 0;
+            this.loops = 0;
+        }
+    }
+
     /**
      * The blocks found in this method, in reverse postorder.
      */
     private BciBlock[] blocks;
     public final Bytecode code;
@@ -683,20 +833,23 @@
                 case BALOAD:
                 case CALOAD:
                 case SALOAD:
                 case ARRAYLENGTH:
                 case CHECKCAST:
+                case INSTANCEOF:
                 case NEW:
+                case NEWARRAY:
                 case ANEWARRAY:
                 case MULTIANEWARRAY:
                 case PUTSTATIC:
                 case GETSTATIC:
                 case PUTFIELD:
                 case GETFIELD:
                 case LDC:
                 case LDC_W:
-                case LDC2_W: {
+                case LDC2_W:
+                case MONITORENTER: {
                     /*
                      * All bytecodes that can trigger lazy class initialization via a
                      * ClassInitializationPlugin (allocations, static field access) must be listed
                      * because the class initializer is allowed to throw an exception, which
                      * requires proper exception handling.
@@ -705,11 +858,154 @@
                     if (handler != null) {
                         current = null;
                         addSuccessor(blockMap, bci, makeBlock(blockMap, stream.nextBCI()));
                         addSuccessor(blockMap, bci, handler);
                     }
+                    break;
                 }
+
+                case NOP:
+                case ACONST_NULL:
+                case ICONST_M1:
+                case ICONST_0:
+                case ICONST_1:
+                case ICONST_2:
+                case ICONST_3:
+                case ICONST_4:
+                case ICONST_5:
+                case LCONST_0:
+                case LCONST_1:
+                case FCONST_0:
+                case FCONST_1:
+                case FCONST_2:
+                case DCONST_0:
+                case DCONST_1:
+                case BIPUSH:
+                case SIPUSH:
+                case ILOAD:
+                case LLOAD:
+                case FLOAD:
+                case DLOAD:
+                case ALOAD:
+                case ILOAD_0:
+                case ILOAD_1:
+                case ILOAD_2:
+                case ILOAD_3:
+                case LLOAD_0:
+                case LLOAD_1:
+                case LLOAD_2:
+                case LLOAD_3:
+                case FLOAD_0:
+                case FLOAD_1:
+                case FLOAD_2:
+                case FLOAD_3:
+                case DLOAD_0:
+                case DLOAD_1:
+                case DLOAD_2:
+                case DLOAD_3:
+                case ALOAD_0:
+                case ALOAD_1:
+                case ALOAD_2:
+                case ALOAD_3:
+                case ISTORE:
+                case LSTORE:
+                case FSTORE:
+                case DSTORE:
+                case ASTORE:
+                case ISTORE_0:
+                case ISTORE_1:
+                case ISTORE_2:
+                case ISTORE_3:
+                case LSTORE_0:
+                case LSTORE_1:
+                case LSTORE_2:
+                case LSTORE_3:
+                case FSTORE_0:
+                case FSTORE_1:
+                case FSTORE_2:
+                case FSTORE_3:
+                case DSTORE_0:
+                case DSTORE_1:
+                case DSTORE_2:
+                case DSTORE_3:
+                case ASTORE_0:
+                case ASTORE_1:
+                case ASTORE_2:
+                case ASTORE_3:
+                case POP:
+                case POP2:
+                case DUP:
+                case DUP_X1:
+                case DUP_X2:
+                case DUP2:
+                case DUP2_X1:
+                case DUP2_X2:
+                case SWAP:
+                case IADD:
+                case LADD:
+                case FADD:
+                case DADD:
+                case ISUB:
+                case LSUB:
+                case FSUB:
+                case DSUB:
+                case IMUL:
+                case LMUL:
+                case FMUL:
+                case DMUL:
+                case FDIV:
+                case DDIV:
+                case FREM:
+                case DREM:
+                case INEG:
+                case LNEG:
+                case FNEG:
+                case DNEG:
+                case ISHL:
+                case LSHL:
+                case ISHR:
+                case LSHR:
+                case IUSHR:
+                case LUSHR:
+                case IAND:
+                case LAND:
+                case IOR:
+                case LOR:
+                case IXOR:
+                case LXOR:
+                case IINC:
+                case I2L:
+                case I2F:
+                case I2D:
+                case L2I:
+                case L2F:
+                case L2D:
+                case F2I:
+                case F2L:
+                case F2D:
+                case D2I:
+                case D2L:
+                case D2F:
+                case I2B:
+                case I2C:
+                case I2S:
+                case LCMP:
+                case FCMPL:
+                case FCMPG:
+                case DCMPL:
+                case DCMPG:
+                case MONITOREXIT:
+                    // All stack manipulation, comparison, conversion and arithmetic operators
+                    // except for idiv and irem can't throw exceptions so the don't need to connect
+                    // exception edges. MONITOREXIT can't throw exceptions in the context of
+                    // compiled code because of the structured locking requirement in the parser.
+                    break;
+
+                case WIDE:
+                case BREAKPOINT:
+                default:
+                    throw new GraalError("Unhandled bytecode");
             }
             stream.next();
         }
     }
 
@@ -781,11 +1077,11 @@
         if (block.getJsrSuccessor() != null || !scope.isEmpty()) {
             for (int i = 0; i < block.getSuccessorCount(); i++) {
                 BciBlock successor = block.getSuccessor(i);
                 JsrScope nextScope = scope;
                 if (successor == block.getJsrSuccessor()) {
-                    nextScope = scope.push(block.getJsrReturnBci());
+                    nextScope = scope.push(block.getJsrReturnBci(), successor);
                 }
                 if (successor == block.getRetSuccessor()) {
                     nextScope = scope.pop();
                 }
                 if (!successor.getJsrScope().isPrefixOf(nextScope)) {
@@ -811,16 +1107,29 @@
                     }
                 }
             }
         }
         for (BciBlock successor : block.getSuccessors()) {
-            if (!jsrVisited.contains(successor)) {
+            if (!jsrVisited.contains(successor) && shouldFollowEdge(successor, scope)) {
                 createJsrAlternatives(blockMap, successor);
             }
         }
     }
 
+    private static boolean shouldFollowEdge(BciBlock successor, JsrScope scope) {
+        if (successor instanceof ExceptionDispatchBlock && scope.getJsrEntryBlock() != null) {
+            ExceptionDispatchBlock exceptionDispatchBlock = (ExceptionDispatchBlock) successor;
+            int bci = scope.getJsrEntryBlock().startBci;
+            if (exceptionDispatchBlock.handler.getStartBCI() < bci && bci < exceptionDispatchBlock.handler.getEndBCI()) {
+                // Handler covers start of JSR block and the bci before that => don't follow edge.
+                return false;
+            }
+        }
+
+        return true;
+    }
+
     private ExceptionDispatchBlock handleExceptions(BciBlock[] blockMap, int bci) {
         ExceptionDispatchBlock lastHandler = null;
         int dispatchBlocks = 0;
 
         for (int i = exceptionHandlers.length - 1; i >= 0; i--) {
@@ -855,11 +1164,11 @@
             loopChanges = false;
             for (BciBlock b : blocks) {
                 b.visited = false;
             }
 
-            long loop = fixLoopBits(blockMap, blockMap[0]);
+            long loop = fixLoopBits(blockMap[0]);
 
             if (loop != 0) {
                 // There is a path from a loop end to the method entry that does not pass the loop
                 // header.
                 // Therefore, the loop is non reducible (has more than one entry).
@@ -898,12 +1207,11 @@
             }
         }
         assert next == newBlocks.length - 1;
 
         // Add unwind block.
-        int deoptBci = code.getMethod().isSynchronized() ? BytecodeFrame.UNWIND_BCI : BytecodeFrame.AFTER_EXCEPTION_BCI;
-        ExceptionDispatchBlock unwindBlock = new ExceptionDispatchBlock(deoptBci);
+        ExceptionDispatchBlock unwindBlock = new ExceptionDispatchBlock(BytecodeFrame.AFTER_EXCEPTION_BCI);
         unwindBlock.setId(newBlocks.length - 1);
         newBlocks[newBlocks.length - 1] = unwindBlock;
 
         blocks = newBlocks;
     }
@@ -1028,82 +1336,111 @@
         }
         assert Long.bitCount(block.loops) == 1;
     }
 
     /**
-     * Depth-first traversal of the control flow graph. The flag {@linkplain BciBlock#visited} is
-     * used to visit every block only once. The flag {@linkplain BciBlock#active} is used to detect
-     * cycles (backward edges).
+     * Non-recursive depth-first traversal of the control flow graph. The flag
+     * {@linkplain BciBlock#visited} is used to visit every block only once. The flag
+     * {@linkplain BciBlock#active} is used to detect cycles (backward edges)
      */
-    private long computeBlockOrder(BciBlock block) {
-        if (block.visited) {
-            if (block.active) {
-                // Reached block via backward branch.
-                makeLoopHeader(block);
-                // Return cached loop information for this block.
-                return block.loops;
-            } else if (block.isLoopHeader) {
-                return block.loops & ~(1L << block.loopId);
+    private long computeBlockOrder(BciBlock initialBlock) {
+        ArrayDeque<TraversalStep> workStack = new ArrayDeque<>();
+        workStack.push(new TraversalStep(initialBlock));
+        while (true) {
+            TraversalStep step = workStack.peek();
+            BciBlock block = step.block;
+            if (step.currentSuccessorIndex == 0) {
+                block.visited = true;
+                block.active = true;
             } else {
-                return block.loops;
+                BciBlock successor = block.getSuccessor(step.currentSuccessorIndex - 1);
+                if (successor.active) {
+                    // Reached block via backward branch.
+                    step.loops |= (1L << successor.loopId);
+                }
             }
-        }
-
-        block.visited = true;
-        block.active = true;
+            if (step.currentSuccessorIndex < block.successors.size()) {
+                BciBlock successor = block.getSuccessors().get(step.currentSuccessorIndex);
+                if (successor.visited) {
+                    if (successor.active) {
+                        // Reached block via backward branch.
+                        makeLoopHeader(successor);
+                        step.loops |= successor.loops;
+                    } else if (successor.isLoopHeader) {
+                        step.loops |= successor.loops & ~(1L << successor.loopId);
+                    } else {
+                        step.loops |= successor.loops;
+                    }
+                } else {
+                    workStack.push(new TraversalStep(successor));
+                }
+                step.currentSuccessorIndex++;
+            } else {
+                // We processed all the successors of this block.
+                block.loops = step.loops;
+                debug.log("computeBlockOrder(%s) -> %x", block, block.loops);
 
-        long loops = 0;
-        for (BciBlock successor : block.getSuccessors()) {
-            // Recursively process successors.
-            loops |= computeBlockOrder(successor);
-            if (successor.active) {
-                // Reached block via backward branch.
-                loops |= (1L << successor.loopId);
-            }
-        }
+                if (block.isLoopHeader) {
+                    step.loops &= ~(1L << block.loopId);
+                }
 
-        block.loops = loops;
-        debug.log("computeBlockOrder(%s) -> %x", block, block.loops);
+                block.active = false;
+                blocksNotYetAssignedId--;
+                blocks[blocksNotYetAssignedId] = block;
 
-        if (block.isLoopHeader) {
-            loops &= ~(1L << block.loopId);
+                workStack.pop();
+                if (!workStack.isEmpty()) {
+                    workStack.peek().loops |= step.loops;
+                } else {
+                    return step.loops;
+                }
+            }
         }
-
-        block.active = false;
-        blocksNotYetAssignedId--;
-        blocks[blocksNotYetAssignedId] = block;
-
-        return loops;
     }
 
-    private long fixLoopBits(BciBlock[] blockMap, BciBlock block) {
-        if (block.visited) {
-            // Return cached loop information for this block.
-            if (block.isLoopHeader) {
-                return block.loops & ~(1L << block.loopId);
-            } else {
-                return block.loops;
+    private long fixLoopBits(BciBlock initialBlock) {
+        ArrayDeque<TraversalStep> workStack = new ArrayDeque<>();
+        workStack.push(new TraversalStep(initialBlock));
+        while (true) {
+            TraversalStep step = workStack.peek();
+            BciBlock block = step.block;
+            if (step.currentSuccessorIndex == 0) {
+                block.visited = true;
+                step.loops = block.loops;
             }
-        }
+            if (step.currentSuccessorIndex < block.getSuccessors().size()) {
+                BciBlock successor = block.getSuccessors().get(step.currentSuccessorIndex);
+                if (successor.visited) {
+                    // Return cached loop information for this block.
+                    if (successor.isLoopHeader) {
+                        step.loops |= successor.loops & ~(1L << successor.loopId);
+                    } else {
+                        step.loops |= successor.loops;
+                    }
+                } else {
+                    workStack.push(new TraversalStep(successor));
+                }
+                step.currentSuccessorIndex++;
+            } else {
+                if (block.loops != step.loops) {
+                    loopChanges = true;
+                    block.loops = step.loops;
+                    debug.log("fixLoopBits0(%s) -> %x", block, block.loops);
+                }
 
-        block.visited = true;
-        long loops = block.loops;
-        for (BciBlock successor : block.getSuccessors()) {
-            // Recursively process successors.
-            loops |= fixLoopBits(blockMap, successor);
-        }
-        if (block.loops != loops) {
-            loopChanges = true;
-            block.loops = loops;
-            debug.log("fixLoopBits0(%s) -> %x", block, block.loops);
-        }
+                if (block.isLoopHeader) {
+                    step.loops &= ~(1L << block.loopId);
+                }
 
-        if (block.isLoopHeader) {
-            loops &= ~(1L << block.loopId);
+                workStack.pop();
+                if (!workStack.isEmpty()) {
+                    workStack.peek().loops |= step.loops;
+                } else {
+                    return step.loops;
+                }
+            }
         }
-
-        return loops;
     }
 
     public static BciBlockMapping create(BytecodeStream stream, Bytecode code, OptionValues options, DebugContext debug) {
         BciBlockMapping map = new BciBlockMapping(code, debug);
         map.build(stream, options);

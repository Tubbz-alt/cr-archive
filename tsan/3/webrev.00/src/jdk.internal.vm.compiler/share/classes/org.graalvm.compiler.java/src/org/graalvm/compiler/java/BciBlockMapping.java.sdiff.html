<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BciBlockMapping.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/UnwindExceptionToCallerStub.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeParser.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BciBlockMapping.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.java;
  26 
  27 import static org.graalvm.compiler.bytecode.Bytecodes.AALOAD;
  28 import static org.graalvm.compiler.bytecode.Bytecodes.AASTORE;






  29 import static org.graalvm.compiler.bytecode.Bytecodes.ANEWARRAY;
  30 import static org.graalvm.compiler.bytecode.Bytecodes.ARETURN;
  31 import static org.graalvm.compiler.bytecode.Bytecodes.ARRAYLENGTH;





  32 import static org.graalvm.compiler.bytecode.Bytecodes.ATHROW;
  33 import static org.graalvm.compiler.bytecode.Bytecodes.BALOAD;
  34 import static org.graalvm.compiler.bytecode.Bytecodes.BASTORE;


  35 import static org.graalvm.compiler.bytecode.Bytecodes.CALOAD;
  36 import static org.graalvm.compiler.bytecode.Bytecodes.CASTORE;
  37 import static org.graalvm.compiler.bytecode.Bytecodes.CHECKCAST;




  38 import static org.graalvm.compiler.bytecode.Bytecodes.DALOAD;
  39 import static org.graalvm.compiler.bytecode.Bytecodes.DASTORE;













  40 import static org.graalvm.compiler.bytecode.Bytecodes.DRETURN;
















  41 import static org.graalvm.compiler.bytecode.Bytecodes.FALOAD;
  42 import static org.graalvm.compiler.bytecode.Bytecodes.FASTORE;














  43 import static org.graalvm.compiler.bytecode.Bytecodes.FRETURN;






  44 import static org.graalvm.compiler.bytecode.Bytecodes.GETFIELD;
  45 import static org.graalvm.compiler.bytecode.Bytecodes.GETSTATIC;
  46 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO;
  47 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO_W;







  48 import static org.graalvm.compiler.bytecode.Bytecodes.IALOAD;

  49 import static org.graalvm.compiler.bytecode.Bytecodes.IASTORE;







  50 import static org.graalvm.compiler.bytecode.Bytecodes.IDIV;
  51 import static org.graalvm.compiler.bytecode.Bytecodes.IFEQ;
  52 import static org.graalvm.compiler.bytecode.Bytecodes.IFGE;
  53 import static org.graalvm.compiler.bytecode.Bytecodes.IFGT;
  54 import static org.graalvm.compiler.bytecode.Bytecodes.IFLE;
  55 import static org.graalvm.compiler.bytecode.Bytecodes.IFLT;
  56 import static org.graalvm.compiler.bytecode.Bytecodes.IFNE;
  57 import static org.graalvm.compiler.bytecode.Bytecodes.IFNONNULL;
  58 import static org.graalvm.compiler.bytecode.Bytecodes.IFNULL;
  59 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPEQ;
  60 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPNE;
  61 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPEQ;
  62 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGE;
  63 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGT;
  64 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLE;
  65 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLT;
  66 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPNE;









  67 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEDYNAMIC;
  68 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEINTERFACE;
  69 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESPECIAL;
  70 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESTATIC;
  71 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEVIRTUAL;

  72 import static org.graalvm.compiler.bytecode.Bytecodes.IREM;
  73 import static org.graalvm.compiler.bytecode.Bytecodes.IRETURN;










  74 import static org.graalvm.compiler.bytecode.Bytecodes.JSR;
  75 import static org.graalvm.compiler.bytecode.Bytecodes.JSR_W;




  76 import static org.graalvm.compiler.bytecode.Bytecodes.LALOAD;

  77 import static org.graalvm.compiler.bytecode.Bytecodes.LASTORE;



  78 import static org.graalvm.compiler.bytecode.Bytecodes.LDC;
  79 import static org.graalvm.compiler.bytecode.Bytecodes.LDC2_W;
  80 import static org.graalvm.compiler.bytecode.Bytecodes.LDC_W;
  81 import static org.graalvm.compiler.bytecode.Bytecodes.LDIV;







  82 import static org.graalvm.compiler.bytecode.Bytecodes.LOOKUPSWITCH;

  83 import static org.graalvm.compiler.bytecode.Bytecodes.LREM;
  84 import static org.graalvm.compiler.bytecode.Bytecodes.LRETURN;












  85 import static org.graalvm.compiler.bytecode.Bytecodes.MULTIANEWARRAY;
  86 import static org.graalvm.compiler.bytecode.Bytecodes.NEW;




  87 import static org.graalvm.compiler.bytecode.Bytecodes.PUTFIELD;
  88 import static org.graalvm.compiler.bytecode.Bytecodes.PUTSTATIC;
  89 import static org.graalvm.compiler.bytecode.Bytecodes.RET;
  90 import static org.graalvm.compiler.bytecode.Bytecodes.RETURN;
  91 import static org.graalvm.compiler.bytecode.Bytecodes.SALOAD;
  92 import static org.graalvm.compiler.bytecode.Bytecodes.SASTORE;


  93 import static org.graalvm.compiler.bytecode.Bytecodes.TABLESWITCH;

  94 import static org.graalvm.compiler.core.common.GraalOptions.SupportJsrBytecodes;
  95 

  96 import java.util.ArrayList;
  97 import java.util.Arrays;
  98 import java.util.Collection;
  99 import java.util.Iterator;
 100 import java.util.List;
 101 import java.util.TreeSet;
 102 
 103 import jdk.internal.vm.compiler.collections.EconomicMap;
 104 import jdk.internal.vm.compiler.collections.Equivalence;
 105 import org.graalvm.compiler.bytecode.Bytecode;
 106 import org.graalvm.compiler.bytecode.BytecodeLookupSwitch;
 107 import org.graalvm.compiler.bytecode.BytecodeStream;
 108 import org.graalvm.compiler.bytecode.BytecodeSwitch;
 109 import org.graalvm.compiler.bytecode.BytecodeTableSwitch;
 110 import org.graalvm.compiler.bytecode.Bytecodes;
 111 import org.graalvm.compiler.core.common.PermanentBailoutException;
 112 import org.graalvm.compiler.debug.DebugContext;

 113 import org.graalvm.compiler.options.OptionValues;
 114 
 115 import jdk.vm.ci.code.BytecodeFrame;
 116 import jdk.vm.ci.meta.ExceptionHandler;
 117 
 118 /**
 119  * Builds a mapping between bytecodes and basic blocks and builds a conservative control flow graph
<span class="line-modified"> 120  * (CFG). It makes one linear passes over the bytecodes to build the CFG where it detects block</span>
 121  * headers and connects them.
 122  * &lt;p&gt;
 123  * It also creates exception dispatch blocks for exception handling. These blocks are between a
 124  * bytecode that might throw an exception, and the actual exception handler entries, and are later
 125  * used to create the type checks with the exception handler catch types. If a bytecode is covered
 126  * by an exception handler, this bytecode ends the basic block. This guarantees that a) control flow
 127  * cannot be transferred to an exception dispatch block in the middle of a block, and b) that every
 128  * block has at most one exception dispatch block (which is always the last entry in the successor
 129  * list).
 130  * &lt;p&gt;
 131  * If a bytecode is covered by multiple exception handlers, a chain of exception dispatch blocks is
 132  * created so that multiple exception handler types can be checked. The chains are re-used if
 133  * multiple bytecodes are covered by the same exception handlers.
 134  * &lt;p&gt;
 135  * Note that exception unwinds, i.e., bytecodes that can throw an exception but the exception is not
 136  * handled in this method, do not end a basic block. Not modeling the exception unwind block reduces
 137  * the complexity of the CFG, and there is no algorithm yet where the exception unwind block would
 138  * matter.
 139  * &lt;p&gt;
 140  * The class also handles subroutines (jsr and ret bytecodes): subroutines are inlined by
 141  * duplicating the subroutine blocks. This is limited to simple, structured subroutines with a
 142  * maximum subroutine nesting of 4. Otherwise, a bailout is thrown.
 143  * &lt;p&gt;
 144  * Loops in the methods are detected. If a method contains an irreducible loop (a loop with more
 145  * than one entry), a bailout is thrown. This simplifies the compiler later on since only structured
 146  * loops need to be supported.
 147  * &lt;p&gt;
 148  * A data flow analysis computes the live local variables from the point of view of the interpreter.
 149  * The result is used later to prune frame states, i.e., remove local variable entries that are
 150  * guaranteed to be never used again (even in the case of deoptimization).
 151  * &lt;p&gt;
 152  * The algorithms and analysis in this class are conservative and do not use any assumptions or
 153  * profiling information.
 154  */
 155 public final class BciBlockMapping {
 156 
 157     public static class BciBlock implements Cloneable {
 158 
 159         int id;
 160         final int startBci;
<span class="line-modified"> 161         int endBci;</span>
 162         private boolean isExceptionEntry;
 163         private boolean isLoopHeader;
 164         int loopId;
 165         int loopEnd;
 166         List&lt;BciBlock&gt; successors;
 167         private int predecessorCount;
 168 
 169         private boolean visited;
 170         private boolean active;
 171         long loops;
 172         JSRData jsrData;
 173 
 174         public static class JSRData implements Cloneable {
 175             public EconomicMap&lt;JsrScope, BciBlock&gt; jsrAlternatives;
 176             public JsrScope jsrScope = JsrScope.EMPTY_SCOPE;
 177             public BciBlock jsrSuccessor;
 178             public int jsrReturnBci;
 179             public BciBlock retSuccessor;
 180             public boolean endsWithRet = false;
 181 
</pre>
<hr />
<pre>
 460             this.deoptBci = deoptBci;
 461             this.handler = handler;
 462         }
 463 
 464         /**
 465          * Constructor for the method unwind dispatcher.
 466          */
 467         ExceptionDispatchBlock(int deoptBci) {
 468             super(deoptBci);
 469             this.endBci = deoptBci;
 470             this.deoptBci = deoptBci;
 471             this.handler = null;
 472         }
 473 
 474         @Override
 475         public boolean isExceptionDispatch() {
 476             return true;
 477         }
 478     }
 479 












 480     /**
 481      * The blocks found in this method, in reverse postorder.
 482      */
 483     private BciBlock[] blocks;
 484     public final Bytecode code;
 485     public boolean hasJsrBytecodes;
 486 
 487     private final ExceptionHandler[] exceptionHandlers;
 488     private BciBlock startBlock;
 489     private BciBlock[] loopHeaders;
 490 
 491     private static final int LOOP_HEADER_MAX_CAPACITY = Long.SIZE;
 492     private static final int LOOP_HEADER_INITIAL_CAPACITY = 4;
 493 
 494     private int blocksNotYetAssignedId;
 495     private final DebugContext debug;
 496 
 497     /**
 498      * Creates a new BlockMap instance from {@code code}.
 499      */
</pre>
<hr />
<pre>
 668                 case LDIV:
 669                 case LREM:
 670                 case IASTORE:
 671                 case LASTORE:
 672                 case FASTORE:
 673                 case DASTORE:
 674                 case AASTORE:
 675                 case BASTORE:
 676                 case CASTORE:
 677                 case SASTORE:
 678                 case IALOAD:
 679                 case LALOAD:
 680                 case FALOAD:
 681                 case DALOAD:
 682                 case AALOAD:
 683                 case BALOAD:
 684                 case CALOAD:
 685                 case SALOAD:
 686                 case ARRAYLENGTH:
 687                 case CHECKCAST:

 688                 case NEW:

 689                 case ANEWARRAY:
 690                 case MULTIANEWARRAY:
 691                 case PUTSTATIC:
 692                 case GETSTATIC:
 693                 case PUTFIELD:
 694                 case GETFIELD:
 695                 case LDC:
 696                 case LDC_W:
<span class="line-modified"> 697                 case LDC2_W: {</span>

 698                     /*
 699                      * All bytecodes that can trigger lazy class initialization via a
 700                      * ClassInitializationPlugin (allocations, static field access) must be listed
 701                      * because the class initializer is allowed to throw an exception, which
 702                      * requires proper exception handling.
 703                      */
 704                     ExceptionDispatchBlock handler = handleExceptions(blockMap, bci);
 705                     if (handler != null) {
 706                         current = null;
 707                         addSuccessor(blockMap, bci, makeBlock(blockMap, stream.nextBCI()));
 708                         addSuccessor(blockMap, bci, handler);
 709                     }

 710                 }














































































































































 711             }
 712             stream.next();
 713         }
 714     }
 715 
 716     private BciBlock makeBlock(BciBlock[] blockMap, int startBci) {
 717         BciBlock oldBlock = blockMap[startBci];
 718         if (oldBlock == null) {
 719             BciBlock newBlock = new BciBlock(startBci);
 720             blocksNotYetAssignedId++;
 721             blockMap[startBci] = newBlock;
 722             return newBlock;
 723 
 724         } else if (oldBlock.startBci != startBci) {
 725             // Backward branch into the middle of an already processed block.
 726             // Add the correct fall-through successor.
 727             BciBlock newBlock = new BciBlock(startBci);
 728             blocksNotYetAssignedId++;
 729             newBlock.endBci = oldBlock.endBci;
 730             for (BciBlock oldSuccessor : oldBlock.getSuccessors()) {
</pre>
<hr />
<pre>
 766     }
 767 
 768     private final ArrayList&lt;BciBlock&gt; jsrVisited = new ArrayList&lt;&gt;();
 769 
 770     private void createJsrAlternatives(BciBlock[] blockMap, BciBlock block) {
 771         jsrVisited.add(block);
 772         JsrScope scope = block.getJsrScope();
 773 
 774         if (block.endsWithRet()) {
 775             block.setRetSuccessor(blockMap[scope.nextReturnAddress()]);
 776             block.addSuccessor(block.getRetSuccessor());
 777             assert block.getRetSuccessor() != block.getJsrSuccessor();
 778         }
 779         debug.log(&quot;JSR alternatives block %s  sux %s  jsrSux %s  retSux %s  jsrScope %s&quot;, block, block.getSuccessors(), block.getJsrSuccessor(), block.getRetSuccessor(), block.getJsrScope());
 780 
 781         if (block.getJsrSuccessor() != null || !scope.isEmpty()) {
 782             for (int i = 0; i &lt; block.getSuccessorCount(); i++) {
 783                 BciBlock successor = block.getSuccessor(i);
 784                 JsrScope nextScope = scope;
 785                 if (successor == block.getJsrSuccessor()) {
<span class="line-modified"> 786                     nextScope = scope.push(block.getJsrReturnBci());</span>
 787                 }
 788                 if (successor == block.getRetSuccessor()) {
 789                     nextScope = scope.pop();
 790                 }
 791                 if (!successor.getJsrScope().isPrefixOf(nextScope)) {
 792                     throw new JsrNotSupportedBailout(&quot;unstructured control flow  (&quot; + successor.getJsrScope() + &quot; &quot; + nextScope + &quot;)&quot;);
 793                 }
 794                 if (!nextScope.isEmpty()) {
 795                     BciBlock clone;
 796                     if (successor.getJsrAlternatives() != null &amp;&amp; successor.getJsrAlternatives().containsKey(nextScope)) {
 797                         clone = successor.getJsrAlternatives().get(nextScope);
 798                     } else {
 799                         successor.initJsrAlternatives();
 800                         clone = successor.copy();
 801                         blocksNotYetAssignedId++;
 802                         clone.setJsrScope(nextScope);
 803                         successor.getJsrAlternatives().put(nextScope, clone);
 804                     }
 805                     block.getSuccessors().set(i, clone);
 806                     if (successor == block.getJsrSuccessor()) {
 807                         block.setJsrSuccessor(clone);
 808                     }
 809                     if (successor == block.getRetSuccessor()) {
 810                         block.setRetSuccessor(clone);
 811                     }
 812                 }
 813             }
 814         }
 815         for (BciBlock successor : block.getSuccessors()) {
<span class="line-modified"> 816             if (!jsrVisited.contains(successor)) {</span>
 817                 createJsrAlternatives(blockMap, successor);
 818             }
 819         }
 820     }
 821 













 822     private ExceptionDispatchBlock handleExceptions(BciBlock[] blockMap, int bci) {
 823         ExceptionDispatchBlock lastHandler = null;
 824         int dispatchBlocks = 0;
 825 
 826         for (int i = exceptionHandlers.length - 1; i &gt;= 0; i--) {
 827             ExceptionHandler h = exceptionHandlers[i];
 828             if (h.getStartBCI() &lt;= bci &amp;&amp; bci &lt; h.getEndBCI()) {
 829                 if (h.isCatchAll()) {
 830                     // Discard all information about succeeding exception handlers, since they can
 831                     // never be reached.
 832                     dispatchBlocks = 0;
 833                     lastHandler = null;
 834                 }
 835 
 836                 // We do not reuse exception dispatch blocks, because nested exception handlers
 837                 // might have problems reasoning about the correct frame state.
 838                 ExceptionDispatchBlock curHandler = new ExceptionDispatchBlock(h, bci);
 839                 dispatchBlocks++;
 840                 curHandler.addSuccessor(blockMap[h.getHandlerBCI()]);
 841                 if (lastHandler != null) {
 842                     curHandler.addSuccessor(lastHandler);
 843                 }
 844                 lastHandler = curHandler;
 845             }
 846         }
 847         blocksNotYetAssignedId += dispatchBlocks;
 848         return lastHandler;
 849     }
 850 
 851     private boolean loopChanges;
 852 
 853     private void fixLoopBits(BciBlock[] blockMap) {
 854         do {
 855             loopChanges = false;
 856             for (BciBlock b : blocks) {
 857                 b.visited = false;
 858             }
 859 
<span class="line-modified"> 860             long loop = fixLoopBits(blockMap, blockMap[0]);</span>
 861 
 862             if (loop != 0) {
 863                 // There is a path from a loop end to the method entry that does not pass the loop
 864                 // header.
 865                 // Therefore, the loop is non reducible (has more than one entry).
 866                 // We don&#39;t want to compile such methods because the IR only supports structured
 867                 // loops.
 868                 throw new PermanentBailoutException(&quot;Non-reducible loop: %016x&quot;, loop);
 869             }
 870         } while (loopChanges);
 871     }
 872 
 873     private void computeBlockOrder(BciBlock[] blockMap) {
 874         int maxBlocks = blocksNotYetAssignedId;
 875         this.blocks = new BciBlock[blocksNotYetAssignedId];
 876         long loop = computeBlockOrder(blockMap[0]);
 877 
 878         if (loop != 0) {
 879             // There is a path from a loop end to the method entry that does not pass the loop
 880             // header. Therefore, the loop is non reducible (has more than one entry).
</pre>
<hr />
<pre>
 883         }
 884 
 885         // Purge null entries for unreached blocks and sort blocks such that loop bodies are always
 886         // consecutively in the array.
 887         int blockCount = maxBlocks - blocksNotYetAssignedId + 1;
 888         BciBlock[] newBlocks = new BciBlock[blockCount];
 889         int next = 0;
 890         for (int i = 0; i &lt; blocks.length; ++i) {
 891             BciBlock b = blocks[i];
 892             if (b != null) {
 893                 b.setId(next);
 894                 newBlocks[next++] = b;
 895                 if (b.isLoopHeader) {
 896                     next = handleLoopHeader(newBlocks, next, i, b);
 897                 }
 898             }
 899         }
 900         assert next == newBlocks.length - 1;
 901 
 902         // Add unwind block.
<span class="line-modified"> 903         int deoptBci = code.getMethod().isSynchronized() ? BytecodeFrame.UNWIND_BCI : BytecodeFrame.AFTER_EXCEPTION_BCI;</span>
<span class="line-removed"> 904         ExceptionDispatchBlock unwindBlock = new ExceptionDispatchBlock(deoptBci);</span>
 905         unwindBlock.setId(newBlocks.length - 1);
 906         newBlocks[newBlocks.length - 1] = unwindBlock;
 907 
 908         blocks = newBlocks;
 909     }
 910 
 911     private int handleLoopHeader(BciBlock[] newBlocks, int nextStart, int i, BciBlock loopHeader) {
 912         int next = nextStart;
 913         int endOfLoop = nextStart - 1;
 914         for (int j = i + 1; j &lt; blocks.length; ++j) {
 915             BciBlock other = blocks[j];
 916             if (other != null &amp;&amp; (other.loops &amp; (1L &lt;&lt; loopHeader.loopId)) != 0) {
 917                 other.setId(next);
 918                 endOfLoop = next;
 919                 newBlocks[next++] = other;
 920                 blocks[j] = null;
 921                 if (other.isLoopHeader) {
 922                     next = handleLoopHeader(newBlocks, next, j, other);
 923                 }
 924             }
</pre>
<hr />
<pre>
1013                 // checking for correctness.
1014                 throw new PermanentBailoutException(&quot;Too many loops in method&quot;);
1015             }
1016 
1017             assert block.loops == 0;
1018             block.loops = 1L &lt;&lt; nextLoop;
1019             debug.log(&quot;makeLoopHeader(%s) -&gt; %x&quot;, block, block.loops);
1020             if (loopHeaders == null) {
1021                 loopHeaders = new BciBlock[LOOP_HEADER_INITIAL_CAPACITY];
1022             } else if (nextLoop &gt;= loopHeaders.length) {
1023                 loopHeaders = Arrays.copyOf(loopHeaders, LOOP_HEADER_MAX_CAPACITY);
1024             }
1025             loopHeaders[nextLoop] = block;
1026             block.loopId = nextLoop;
1027             nextLoop++;
1028         }
1029         assert Long.bitCount(block.loops) == 1;
1030     }
1031 
1032     /**
<span class="line-modified">1033      * Depth-first traversal of the control flow graph. The flag {@linkplain BciBlock#visited} is</span>
<span class="line-modified">1034      * used to visit every block only once. The flag {@linkplain BciBlock#active} is used to detect</span>
<span class="line-modified">1035      * cycles (backward edges).</span>
1036      */
<span class="line-modified">1037     private long computeBlockOrder(BciBlock block) {</span>
<span class="line-modified">1038         if (block.visited) {</span>
<span class="line-modified">1039             if (block.active) {</span>
<span class="line-modified">1040                 // Reached block via backward branch.</span>
<span class="line-modified">1041                 makeLoopHeader(block);</span>
<span class="line-modified">1042                 // Return cached loop information for this block.</span>
<span class="line-modified">1043                 return block.loops;</span>
<span class="line-modified">1044             } else if (block.isLoopHeader) {</span>
<span class="line-modified">1045                 return block.loops &amp; ~(1L &lt;&lt; block.loopId);</span>
1046             } else {
<span class="line-modified">1047                 return block.loops;</span>




1048             }
<span class="line-modified">1049         }</span>
<span class="line-modified">1050 </span>
<span class="line-modified">1051         block.visited = true;</span>
<span class="line-modified">1052         block.active = true;</span>
















1053 
<span class="line-modified">1054         long loops = 0;</span>
<span class="line-modified">1055         for (BciBlock successor : block.getSuccessors()) {</span>
<span class="line-modified">1056             // Recursively process successors.</span>
<span class="line-removed">1057             loops |= computeBlockOrder(successor);</span>
<span class="line-removed">1058             if (successor.active) {</span>
<span class="line-removed">1059                 // Reached block via backward branch.</span>
<span class="line-removed">1060                 loops |= (1L &lt;&lt; successor.loopId);</span>
<span class="line-removed">1061             }</span>
<span class="line-removed">1062         }</span>
1063 
<span class="line-modified">1064         block.loops = loops;</span>
<span class="line-modified">1065         debug.log(&quot;computeBlockOrder(%s) -&gt; %x&quot;, block, block.loops);</span>

1066 
<span class="line-modified">1067         if (block.isLoopHeader) {</span>
<span class="line-modified">1068             loops &amp;= ~(1L &lt;&lt; block.loopId);</span>





1069         }
<span class="line-removed">1070 </span>
<span class="line-removed">1071         block.active = false;</span>
<span class="line-removed">1072         blocksNotYetAssignedId--;</span>
<span class="line-removed">1073         blocks[blocksNotYetAssignedId] = block;</span>
<span class="line-removed">1074 </span>
<span class="line-removed">1075         return loops;</span>
1076     }
1077 
<span class="line-modified">1078     private long fixLoopBits(BciBlock[] blockMap, BciBlock block) {</span>
<span class="line-modified">1079         if (block.visited) {</span>
<span class="line-modified">1080             // Return cached loop information for this block.</span>
<span class="line-modified">1081             if (block.isLoopHeader) {</span>
<span class="line-modified">1082                 return block.loops &amp; ~(1L &lt;&lt; block.loopId);</span>
<span class="line-modified">1083             } else {</span>
<span class="line-modified">1084                 return block.loops;</span>


1085             }
<span class="line-modified">1086         }</span>


















1087 
<span class="line-modified">1088         block.visited = true;</span>
<span class="line-modified">1089         long loops = block.loops;</span>
<span class="line-modified">1090         for (BciBlock successor : block.getSuccessors()) {</span>
<span class="line-removed">1091             // Recursively process successors.</span>
<span class="line-removed">1092             loops |= fixLoopBits(blockMap, successor);</span>
<span class="line-removed">1093         }</span>
<span class="line-removed">1094         if (block.loops != loops) {</span>
<span class="line-removed">1095             loopChanges = true;</span>
<span class="line-removed">1096             block.loops = loops;</span>
<span class="line-removed">1097             debug.log(&quot;fixLoopBits0(%s) -&gt; %x&quot;, block, block.loops);</span>
<span class="line-removed">1098         }</span>
1099 
<span class="line-modified">1100         if (block.isLoopHeader) {</span>
<span class="line-modified">1101             loops &amp;= ~(1L &lt;&lt; block.loopId);</span>





1102         }
<span class="line-removed">1103 </span>
<span class="line-removed">1104         return loops;</span>
1105     }
1106 
1107     public static BciBlockMapping create(BytecodeStream stream, Bytecode code, OptionValues options, DebugContext debug) {
1108         BciBlockMapping map = new BciBlockMapping(code, debug);
1109         map.build(stream, options);
1110         if (debug.isDumpEnabled(DebugContext.INFO_LEVEL)) {
1111             debug.dump(DebugContext.INFO_LEVEL, map, code.getMethod().format(&quot;After block building %f %R %H.%n(%P)&quot;));
1112         }
1113 
1114         return map;
1115     }
1116 
1117     public BciBlock[] getLoopHeaders() {
1118         return loopHeaders;
1119     }
1120 
1121     public BciBlock getStartBlock() {
1122         return startBlock;
1123     }
1124 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.java;
  26 
  27 import static org.graalvm.compiler.bytecode.Bytecodes.AALOAD;
  28 import static org.graalvm.compiler.bytecode.Bytecodes.AASTORE;
<span class="line-added">  29 import static org.graalvm.compiler.bytecode.Bytecodes.ACONST_NULL;</span>
<span class="line-added">  30 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD;</span>
<span class="line-added">  31 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_0;</span>
<span class="line-added">  32 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_1;</span>
<span class="line-added">  33 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_2;</span>
<span class="line-added">  34 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_3;</span>
  35 import static org.graalvm.compiler.bytecode.Bytecodes.ANEWARRAY;
  36 import static org.graalvm.compiler.bytecode.Bytecodes.ARETURN;
  37 import static org.graalvm.compiler.bytecode.Bytecodes.ARRAYLENGTH;
<span class="line-added">  38 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE;</span>
<span class="line-added">  39 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_0;</span>
<span class="line-added">  40 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_1;</span>
<span class="line-added">  41 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_2;</span>
<span class="line-added">  42 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_3;</span>
  43 import static org.graalvm.compiler.bytecode.Bytecodes.ATHROW;
  44 import static org.graalvm.compiler.bytecode.Bytecodes.BALOAD;
  45 import static org.graalvm.compiler.bytecode.Bytecodes.BASTORE;
<span class="line-added">  46 import static org.graalvm.compiler.bytecode.Bytecodes.BIPUSH;</span>
<span class="line-added">  47 import static org.graalvm.compiler.bytecode.Bytecodes.BREAKPOINT;</span>
  48 import static org.graalvm.compiler.bytecode.Bytecodes.CALOAD;
  49 import static org.graalvm.compiler.bytecode.Bytecodes.CASTORE;
  50 import static org.graalvm.compiler.bytecode.Bytecodes.CHECKCAST;
<span class="line-added">  51 import static org.graalvm.compiler.bytecode.Bytecodes.D2F;</span>
<span class="line-added">  52 import static org.graalvm.compiler.bytecode.Bytecodes.D2I;</span>
<span class="line-added">  53 import static org.graalvm.compiler.bytecode.Bytecodes.D2L;</span>
<span class="line-added">  54 import static org.graalvm.compiler.bytecode.Bytecodes.DADD;</span>
  55 import static org.graalvm.compiler.bytecode.Bytecodes.DALOAD;
  56 import static org.graalvm.compiler.bytecode.Bytecodes.DASTORE;
<span class="line-added">  57 import static org.graalvm.compiler.bytecode.Bytecodes.DCMPG;</span>
<span class="line-added">  58 import static org.graalvm.compiler.bytecode.Bytecodes.DCMPL;</span>
<span class="line-added">  59 import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_0;</span>
<span class="line-added">  60 import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_1;</span>
<span class="line-added">  61 import static org.graalvm.compiler.bytecode.Bytecodes.DDIV;</span>
<span class="line-added">  62 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD;</span>
<span class="line-added">  63 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_0;</span>
<span class="line-added">  64 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_1;</span>
<span class="line-added">  65 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_2;</span>
<span class="line-added">  66 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_3;</span>
<span class="line-added">  67 import static org.graalvm.compiler.bytecode.Bytecodes.DMUL;</span>
<span class="line-added">  68 import static org.graalvm.compiler.bytecode.Bytecodes.DNEG;</span>
<span class="line-added">  69 import static org.graalvm.compiler.bytecode.Bytecodes.DREM;</span>
  70 import static org.graalvm.compiler.bytecode.Bytecodes.DRETURN;
<span class="line-added">  71 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE;</span>
<span class="line-added">  72 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_0;</span>
<span class="line-added">  73 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_1;</span>
<span class="line-added">  74 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_2;</span>
<span class="line-added">  75 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_3;</span>
<span class="line-added">  76 import static org.graalvm.compiler.bytecode.Bytecodes.DSUB;</span>
<span class="line-added">  77 import static org.graalvm.compiler.bytecode.Bytecodes.DUP;</span>
<span class="line-added">  78 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2;</span>
<span class="line-added">  79 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X1;</span>
<span class="line-added">  80 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X2;</span>
<span class="line-added">  81 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X1;</span>
<span class="line-added">  82 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X2;</span>
<span class="line-added">  83 import static org.graalvm.compiler.bytecode.Bytecodes.F2D;</span>
<span class="line-added">  84 import static org.graalvm.compiler.bytecode.Bytecodes.F2I;</span>
<span class="line-added">  85 import static org.graalvm.compiler.bytecode.Bytecodes.F2L;</span>
<span class="line-added">  86 import static org.graalvm.compiler.bytecode.Bytecodes.FADD;</span>
  87 import static org.graalvm.compiler.bytecode.Bytecodes.FALOAD;
  88 import static org.graalvm.compiler.bytecode.Bytecodes.FASTORE;
<span class="line-added">  89 import static org.graalvm.compiler.bytecode.Bytecodes.FCMPG;</span>
<span class="line-added">  90 import static org.graalvm.compiler.bytecode.Bytecodes.FCMPL;</span>
<span class="line-added">  91 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_0;</span>
<span class="line-added">  92 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_1;</span>
<span class="line-added">  93 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_2;</span>
<span class="line-added">  94 import static org.graalvm.compiler.bytecode.Bytecodes.FDIV;</span>
<span class="line-added">  95 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD;</span>
<span class="line-added">  96 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_0;</span>
<span class="line-added">  97 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_1;</span>
<span class="line-added">  98 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_2;</span>
<span class="line-added">  99 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_3;</span>
<span class="line-added"> 100 import static org.graalvm.compiler.bytecode.Bytecodes.FMUL;</span>
<span class="line-added"> 101 import static org.graalvm.compiler.bytecode.Bytecodes.FNEG;</span>
<span class="line-added"> 102 import static org.graalvm.compiler.bytecode.Bytecodes.FREM;</span>
 103 import static org.graalvm.compiler.bytecode.Bytecodes.FRETURN;
<span class="line-added"> 104 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE;</span>
<span class="line-added"> 105 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_0;</span>
<span class="line-added"> 106 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_1;</span>
<span class="line-added"> 107 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_2;</span>
<span class="line-added"> 108 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_3;</span>
<span class="line-added"> 109 import static org.graalvm.compiler.bytecode.Bytecodes.FSUB;</span>
 110 import static org.graalvm.compiler.bytecode.Bytecodes.GETFIELD;
 111 import static org.graalvm.compiler.bytecode.Bytecodes.GETSTATIC;
 112 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO;
 113 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO_W;
<span class="line-added"> 114 import static org.graalvm.compiler.bytecode.Bytecodes.I2B;</span>
<span class="line-added"> 115 import static org.graalvm.compiler.bytecode.Bytecodes.I2C;</span>
<span class="line-added"> 116 import static org.graalvm.compiler.bytecode.Bytecodes.I2D;</span>
<span class="line-added"> 117 import static org.graalvm.compiler.bytecode.Bytecodes.I2F;</span>
<span class="line-added"> 118 import static org.graalvm.compiler.bytecode.Bytecodes.I2L;</span>
<span class="line-added"> 119 import static org.graalvm.compiler.bytecode.Bytecodes.I2S;</span>
<span class="line-added"> 120 import static org.graalvm.compiler.bytecode.Bytecodes.IADD;</span>
 121 import static org.graalvm.compiler.bytecode.Bytecodes.IALOAD;
<span class="line-added"> 122 import static org.graalvm.compiler.bytecode.Bytecodes.IAND;</span>
 123 import static org.graalvm.compiler.bytecode.Bytecodes.IASTORE;
<span class="line-added"> 124 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_0;</span>
<span class="line-added"> 125 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_1;</span>
<span class="line-added"> 126 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_2;</span>
<span class="line-added"> 127 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_3;</span>
<span class="line-added"> 128 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_4;</span>
<span class="line-added"> 129 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_5;</span>
<span class="line-added"> 130 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_M1;</span>
 131 import static org.graalvm.compiler.bytecode.Bytecodes.IDIV;
 132 import static org.graalvm.compiler.bytecode.Bytecodes.IFEQ;
 133 import static org.graalvm.compiler.bytecode.Bytecodes.IFGE;
 134 import static org.graalvm.compiler.bytecode.Bytecodes.IFGT;
 135 import static org.graalvm.compiler.bytecode.Bytecodes.IFLE;
 136 import static org.graalvm.compiler.bytecode.Bytecodes.IFLT;
 137 import static org.graalvm.compiler.bytecode.Bytecodes.IFNE;
 138 import static org.graalvm.compiler.bytecode.Bytecodes.IFNONNULL;
 139 import static org.graalvm.compiler.bytecode.Bytecodes.IFNULL;
 140 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPEQ;
 141 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPNE;
 142 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPEQ;
 143 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGE;
 144 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGT;
 145 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLE;
 146 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLT;
 147 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPNE;
<span class="line-added"> 148 import static org.graalvm.compiler.bytecode.Bytecodes.IINC;</span>
<span class="line-added"> 149 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD;</span>
<span class="line-added"> 150 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_0;</span>
<span class="line-added"> 151 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_1;</span>
<span class="line-added"> 152 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_2;</span>
<span class="line-added"> 153 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_3;</span>
<span class="line-added"> 154 import static org.graalvm.compiler.bytecode.Bytecodes.IMUL;</span>
<span class="line-added"> 155 import static org.graalvm.compiler.bytecode.Bytecodes.INEG;</span>
<span class="line-added"> 156 import static org.graalvm.compiler.bytecode.Bytecodes.INSTANCEOF;</span>
 157 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEDYNAMIC;
 158 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEINTERFACE;
 159 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESPECIAL;
 160 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESTATIC;
 161 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEVIRTUAL;
<span class="line-added"> 162 import static org.graalvm.compiler.bytecode.Bytecodes.IOR;</span>
 163 import static org.graalvm.compiler.bytecode.Bytecodes.IREM;
 164 import static org.graalvm.compiler.bytecode.Bytecodes.IRETURN;
<span class="line-added"> 165 import static org.graalvm.compiler.bytecode.Bytecodes.ISHL;</span>
<span class="line-added"> 166 import static org.graalvm.compiler.bytecode.Bytecodes.ISHR;</span>
<span class="line-added"> 167 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE;</span>
<span class="line-added"> 168 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_0;</span>
<span class="line-added"> 169 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_1;</span>
<span class="line-added"> 170 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_2;</span>
<span class="line-added"> 171 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_3;</span>
<span class="line-added"> 172 import static org.graalvm.compiler.bytecode.Bytecodes.ISUB;</span>
<span class="line-added"> 173 import static org.graalvm.compiler.bytecode.Bytecodes.IUSHR;</span>
<span class="line-added"> 174 import static org.graalvm.compiler.bytecode.Bytecodes.IXOR;</span>
 175 import static org.graalvm.compiler.bytecode.Bytecodes.JSR;
 176 import static org.graalvm.compiler.bytecode.Bytecodes.JSR_W;
<span class="line-added"> 177 import static org.graalvm.compiler.bytecode.Bytecodes.L2D;</span>
<span class="line-added"> 178 import static org.graalvm.compiler.bytecode.Bytecodes.L2F;</span>
<span class="line-added"> 179 import static org.graalvm.compiler.bytecode.Bytecodes.L2I;</span>
<span class="line-added"> 180 import static org.graalvm.compiler.bytecode.Bytecodes.LADD;</span>
 181 import static org.graalvm.compiler.bytecode.Bytecodes.LALOAD;
<span class="line-added"> 182 import static org.graalvm.compiler.bytecode.Bytecodes.LAND;</span>
 183 import static org.graalvm.compiler.bytecode.Bytecodes.LASTORE;
<span class="line-added"> 184 import static org.graalvm.compiler.bytecode.Bytecodes.LCMP;</span>
<span class="line-added"> 185 import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_0;</span>
<span class="line-added"> 186 import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_1;</span>
 187 import static org.graalvm.compiler.bytecode.Bytecodes.LDC;
 188 import static org.graalvm.compiler.bytecode.Bytecodes.LDC2_W;
 189 import static org.graalvm.compiler.bytecode.Bytecodes.LDC_W;
 190 import static org.graalvm.compiler.bytecode.Bytecodes.LDIV;
<span class="line-added"> 191 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD;</span>
<span class="line-added"> 192 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_0;</span>
<span class="line-added"> 193 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_1;</span>
<span class="line-added"> 194 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_2;</span>
<span class="line-added"> 195 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_3;</span>
<span class="line-added"> 196 import static org.graalvm.compiler.bytecode.Bytecodes.LMUL;</span>
<span class="line-added"> 197 import static org.graalvm.compiler.bytecode.Bytecodes.LNEG;</span>
 198 import static org.graalvm.compiler.bytecode.Bytecodes.LOOKUPSWITCH;
<span class="line-added"> 199 import static org.graalvm.compiler.bytecode.Bytecodes.LOR;</span>
 200 import static org.graalvm.compiler.bytecode.Bytecodes.LREM;
 201 import static org.graalvm.compiler.bytecode.Bytecodes.LRETURN;
<span class="line-added"> 202 import static org.graalvm.compiler.bytecode.Bytecodes.LSHL;</span>
<span class="line-added"> 203 import static org.graalvm.compiler.bytecode.Bytecodes.LSHR;</span>
<span class="line-added"> 204 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE;</span>
<span class="line-added"> 205 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_0;</span>
<span class="line-added"> 206 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_1;</span>
<span class="line-added"> 207 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_2;</span>
<span class="line-added"> 208 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_3;</span>
<span class="line-added"> 209 import static org.graalvm.compiler.bytecode.Bytecodes.LSUB;</span>
<span class="line-added"> 210 import static org.graalvm.compiler.bytecode.Bytecodes.LUSHR;</span>
<span class="line-added"> 211 import static org.graalvm.compiler.bytecode.Bytecodes.LXOR;</span>
<span class="line-added"> 212 import static org.graalvm.compiler.bytecode.Bytecodes.MONITORENTER;</span>
<span class="line-added"> 213 import static org.graalvm.compiler.bytecode.Bytecodes.MONITOREXIT;</span>
 214 import static org.graalvm.compiler.bytecode.Bytecodes.MULTIANEWARRAY;
 215 import static org.graalvm.compiler.bytecode.Bytecodes.NEW;
<span class="line-added"> 216 import static org.graalvm.compiler.bytecode.Bytecodes.NEWARRAY;</span>
<span class="line-added"> 217 import static org.graalvm.compiler.bytecode.Bytecodes.NOP;</span>
<span class="line-added"> 218 import static org.graalvm.compiler.bytecode.Bytecodes.POP;</span>
<span class="line-added"> 219 import static org.graalvm.compiler.bytecode.Bytecodes.POP2;</span>
 220 import static org.graalvm.compiler.bytecode.Bytecodes.PUTFIELD;
 221 import static org.graalvm.compiler.bytecode.Bytecodes.PUTSTATIC;
 222 import static org.graalvm.compiler.bytecode.Bytecodes.RET;
 223 import static org.graalvm.compiler.bytecode.Bytecodes.RETURN;
 224 import static org.graalvm.compiler.bytecode.Bytecodes.SALOAD;
 225 import static org.graalvm.compiler.bytecode.Bytecodes.SASTORE;
<span class="line-added"> 226 import static org.graalvm.compiler.bytecode.Bytecodes.SIPUSH;</span>
<span class="line-added"> 227 import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;</span>
 228 import static org.graalvm.compiler.bytecode.Bytecodes.TABLESWITCH;
<span class="line-added"> 229 import static org.graalvm.compiler.bytecode.Bytecodes.WIDE;</span>
 230 import static org.graalvm.compiler.core.common.GraalOptions.SupportJsrBytecodes;
 231 
<span class="line-added"> 232 import java.util.ArrayDeque;</span>
 233 import java.util.ArrayList;
 234 import java.util.Arrays;
 235 import java.util.Collection;
 236 import java.util.Iterator;
 237 import java.util.List;
 238 import java.util.TreeSet;
 239 
 240 import jdk.internal.vm.compiler.collections.EconomicMap;
 241 import jdk.internal.vm.compiler.collections.Equivalence;
 242 import org.graalvm.compiler.bytecode.Bytecode;
 243 import org.graalvm.compiler.bytecode.BytecodeLookupSwitch;
 244 import org.graalvm.compiler.bytecode.BytecodeStream;
 245 import org.graalvm.compiler.bytecode.BytecodeSwitch;
 246 import org.graalvm.compiler.bytecode.BytecodeTableSwitch;
 247 import org.graalvm.compiler.bytecode.Bytecodes;
 248 import org.graalvm.compiler.core.common.PermanentBailoutException;
 249 import org.graalvm.compiler.debug.DebugContext;
<span class="line-added"> 250 import org.graalvm.compiler.debug.GraalError;</span>
 251 import org.graalvm.compiler.options.OptionValues;
 252 
 253 import jdk.vm.ci.code.BytecodeFrame;
 254 import jdk.vm.ci.meta.ExceptionHandler;
 255 
 256 /**
 257  * Builds a mapping between bytecodes and basic blocks and builds a conservative control flow graph
<span class="line-modified"> 258  * (CFG). It makes one linear pass over the bytecodes to build the CFG where it detects block</span>
 259  * headers and connects them.
 260  * &lt;p&gt;
 261  * It also creates exception dispatch blocks for exception handling. These blocks are between a
 262  * bytecode that might throw an exception, and the actual exception handler entries, and are later
 263  * used to create the type checks with the exception handler catch types. If a bytecode is covered
 264  * by an exception handler, this bytecode ends the basic block. This guarantees that a) control flow
 265  * cannot be transferred to an exception dispatch block in the middle of a block, and b) that every
 266  * block has at most one exception dispatch block (which is always the last entry in the successor
 267  * list).
 268  * &lt;p&gt;
 269  * If a bytecode is covered by multiple exception handlers, a chain of exception dispatch blocks is
 270  * created so that multiple exception handler types can be checked. The chains are re-used if
 271  * multiple bytecodes are covered by the same exception handlers.
 272  * &lt;p&gt;
 273  * Note that exception unwinds, i.e., bytecodes that can throw an exception but the exception is not
 274  * handled in this method, do not end a basic block. Not modeling the exception unwind block reduces
 275  * the complexity of the CFG, and there is no algorithm yet where the exception unwind block would
 276  * matter.
 277  * &lt;p&gt;
 278  * The class also handles subroutines (jsr and ret bytecodes): subroutines are inlined by
 279  * duplicating the subroutine blocks. This is limited to simple, structured subroutines with a
 280  * maximum subroutine nesting of 4. Otherwise, a bailout is thrown.
 281  * &lt;p&gt;
 282  * Loops in the methods are detected. If a method contains an irreducible loop (a loop with more
 283  * than one entry), a bailout is thrown. This simplifies the compiler later on since only structured
 284  * loops need to be supported.
 285  * &lt;p&gt;
 286  * A data flow analysis computes the live local variables from the point of view of the interpreter.
 287  * The result is used later to prune frame states, i.e., remove local variable entries that are
 288  * guaranteed to be never used again (even in the case of deoptimization).
 289  * &lt;p&gt;
 290  * The algorithms and analysis in this class are conservative and do not use any assumptions or
 291  * profiling information.
 292  */
 293 public final class BciBlockMapping {
 294 
 295     public static class BciBlock implements Cloneable {
 296 
 297         int id;
 298         final int startBci;
<span class="line-modified"> 299         int endBci; // The bci of the last bytecode in the block</span>
 300         private boolean isExceptionEntry;
 301         private boolean isLoopHeader;
 302         int loopId;
 303         int loopEnd;
 304         List&lt;BciBlock&gt; successors;
 305         private int predecessorCount;
 306 
 307         private boolean visited;
 308         private boolean active;
 309         long loops;
 310         JSRData jsrData;
 311 
 312         public static class JSRData implements Cloneable {
 313             public EconomicMap&lt;JsrScope, BciBlock&gt; jsrAlternatives;
 314             public JsrScope jsrScope = JsrScope.EMPTY_SCOPE;
 315             public BciBlock jsrSuccessor;
 316             public int jsrReturnBci;
 317             public BciBlock retSuccessor;
 318             public boolean endsWithRet = false;
 319 
</pre>
<hr />
<pre>
 598             this.deoptBci = deoptBci;
 599             this.handler = handler;
 600         }
 601 
 602         /**
 603          * Constructor for the method unwind dispatcher.
 604          */
 605         ExceptionDispatchBlock(int deoptBci) {
 606             super(deoptBci);
 607             this.endBci = deoptBci;
 608             this.deoptBci = deoptBci;
 609             this.handler = null;
 610         }
 611 
 612         @Override
 613         public boolean isExceptionDispatch() {
 614             return true;
 615         }
 616     }
 617 
<span class="line-added"> 618     private static final class TraversalStep {</span>
<span class="line-added"> 619         private BciBlock block;</span>
<span class="line-added"> 620         private int currentSuccessorIndex;</span>
<span class="line-added"> 621         private long loops;</span>
<span class="line-added"> 622 </span>
<span class="line-added"> 623         private TraversalStep(BciBlock block) {</span>
<span class="line-added"> 624             this.block = block;</span>
<span class="line-added"> 625             this.currentSuccessorIndex = 0;</span>
<span class="line-added"> 626             this.loops = 0;</span>
<span class="line-added"> 627         }</span>
<span class="line-added"> 628     }</span>
<span class="line-added"> 629 </span>
 630     /**
 631      * The blocks found in this method, in reverse postorder.
 632      */
 633     private BciBlock[] blocks;
 634     public final Bytecode code;
 635     public boolean hasJsrBytecodes;
 636 
 637     private final ExceptionHandler[] exceptionHandlers;
 638     private BciBlock startBlock;
 639     private BciBlock[] loopHeaders;
 640 
 641     private static final int LOOP_HEADER_MAX_CAPACITY = Long.SIZE;
 642     private static final int LOOP_HEADER_INITIAL_CAPACITY = 4;
 643 
 644     private int blocksNotYetAssignedId;
 645     private final DebugContext debug;
 646 
 647     /**
 648      * Creates a new BlockMap instance from {@code code}.
 649      */
</pre>
<hr />
<pre>
 818                 case LDIV:
 819                 case LREM:
 820                 case IASTORE:
 821                 case LASTORE:
 822                 case FASTORE:
 823                 case DASTORE:
 824                 case AASTORE:
 825                 case BASTORE:
 826                 case CASTORE:
 827                 case SASTORE:
 828                 case IALOAD:
 829                 case LALOAD:
 830                 case FALOAD:
 831                 case DALOAD:
 832                 case AALOAD:
 833                 case BALOAD:
 834                 case CALOAD:
 835                 case SALOAD:
 836                 case ARRAYLENGTH:
 837                 case CHECKCAST:
<span class="line-added"> 838                 case INSTANCEOF:</span>
 839                 case NEW:
<span class="line-added"> 840                 case NEWARRAY:</span>
 841                 case ANEWARRAY:
 842                 case MULTIANEWARRAY:
 843                 case PUTSTATIC:
 844                 case GETSTATIC:
 845                 case PUTFIELD:
 846                 case GETFIELD:
 847                 case LDC:
 848                 case LDC_W:
<span class="line-modified"> 849                 case LDC2_W:</span>
<span class="line-added"> 850                 case MONITORENTER: {</span>
 851                     /*
 852                      * All bytecodes that can trigger lazy class initialization via a
 853                      * ClassInitializationPlugin (allocations, static field access) must be listed
 854                      * because the class initializer is allowed to throw an exception, which
 855                      * requires proper exception handling.
 856                      */
 857                     ExceptionDispatchBlock handler = handleExceptions(blockMap, bci);
 858                     if (handler != null) {
 859                         current = null;
 860                         addSuccessor(blockMap, bci, makeBlock(blockMap, stream.nextBCI()));
 861                         addSuccessor(blockMap, bci, handler);
 862                     }
<span class="line-added"> 863                     break;</span>
 864                 }
<span class="line-added"> 865 </span>
<span class="line-added"> 866                 case NOP:</span>
<span class="line-added"> 867                 case ACONST_NULL:</span>
<span class="line-added"> 868                 case ICONST_M1:</span>
<span class="line-added"> 869                 case ICONST_0:</span>
<span class="line-added"> 870                 case ICONST_1:</span>
<span class="line-added"> 871                 case ICONST_2:</span>
<span class="line-added"> 872                 case ICONST_3:</span>
<span class="line-added"> 873                 case ICONST_4:</span>
<span class="line-added"> 874                 case ICONST_5:</span>
<span class="line-added"> 875                 case LCONST_0:</span>
<span class="line-added"> 876                 case LCONST_1:</span>
<span class="line-added"> 877                 case FCONST_0:</span>
<span class="line-added"> 878                 case FCONST_1:</span>
<span class="line-added"> 879                 case FCONST_2:</span>
<span class="line-added"> 880                 case DCONST_0:</span>
<span class="line-added"> 881                 case DCONST_1:</span>
<span class="line-added"> 882                 case BIPUSH:</span>
<span class="line-added"> 883                 case SIPUSH:</span>
<span class="line-added"> 884                 case ILOAD:</span>
<span class="line-added"> 885                 case LLOAD:</span>
<span class="line-added"> 886                 case FLOAD:</span>
<span class="line-added"> 887                 case DLOAD:</span>
<span class="line-added"> 888                 case ALOAD:</span>
<span class="line-added"> 889                 case ILOAD_0:</span>
<span class="line-added"> 890                 case ILOAD_1:</span>
<span class="line-added"> 891                 case ILOAD_2:</span>
<span class="line-added"> 892                 case ILOAD_3:</span>
<span class="line-added"> 893                 case LLOAD_0:</span>
<span class="line-added"> 894                 case LLOAD_1:</span>
<span class="line-added"> 895                 case LLOAD_2:</span>
<span class="line-added"> 896                 case LLOAD_3:</span>
<span class="line-added"> 897                 case FLOAD_0:</span>
<span class="line-added"> 898                 case FLOAD_1:</span>
<span class="line-added"> 899                 case FLOAD_2:</span>
<span class="line-added"> 900                 case FLOAD_3:</span>
<span class="line-added"> 901                 case DLOAD_0:</span>
<span class="line-added"> 902                 case DLOAD_1:</span>
<span class="line-added"> 903                 case DLOAD_2:</span>
<span class="line-added"> 904                 case DLOAD_3:</span>
<span class="line-added"> 905                 case ALOAD_0:</span>
<span class="line-added"> 906                 case ALOAD_1:</span>
<span class="line-added"> 907                 case ALOAD_2:</span>
<span class="line-added"> 908                 case ALOAD_3:</span>
<span class="line-added"> 909                 case ISTORE:</span>
<span class="line-added"> 910                 case LSTORE:</span>
<span class="line-added"> 911                 case FSTORE:</span>
<span class="line-added"> 912                 case DSTORE:</span>
<span class="line-added"> 913                 case ASTORE:</span>
<span class="line-added"> 914                 case ISTORE_0:</span>
<span class="line-added"> 915                 case ISTORE_1:</span>
<span class="line-added"> 916                 case ISTORE_2:</span>
<span class="line-added"> 917                 case ISTORE_3:</span>
<span class="line-added"> 918                 case LSTORE_0:</span>
<span class="line-added"> 919                 case LSTORE_1:</span>
<span class="line-added"> 920                 case LSTORE_2:</span>
<span class="line-added"> 921                 case LSTORE_3:</span>
<span class="line-added"> 922                 case FSTORE_0:</span>
<span class="line-added"> 923                 case FSTORE_1:</span>
<span class="line-added"> 924                 case FSTORE_2:</span>
<span class="line-added"> 925                 case FSTORE_3:</span>
<span class="line-added"> 926                 case DSTORE_0:</span>
<span class="line-added"> 927                 case DSTORE_1:</span>
<span class="line-added"> 928                 case DSTORE_2:</span>
<span class="line-added"> 929                 case DSTORE_3:</span>
<span class="line-added"> 930                 case ASTORE_0:</span>
<span class="line-added"> 931                 case ASTORE_1:</span>
<span class="line-added"> 932                 case ASTORE_2:</span>
<span class="line-added"> 933                 case ASTORE_3:</span>
<span class="line-added"> 934                 case POP:</span>
<span class="line-added"> 935                 case POP2:</span>
<span class="line-added"> 936                 case DUP:</span>
<span class="line-added"> 937                 case DUP_X1:</span>
<span class="line-added"> 938                 case DUP_X2:</span>
<span class="line-added"> 939                 case DUP2:</span>
<span class="line-added"> 940                 case DUP2_X1:</span>
<span class="line-added"> 941                 case DUP2_X2:</span>
<span class="line-added"> 942                 case SWAP:</span>
<span class="line-added"> 943                 case IADD:</span>
<span class="line-added"> 944                 case LADD:</span>
<span class="line-added"> 945                 case FADD:</span>
<span class="line-added"> 946                 case DADD:</span>
<span class="line-added"> 947                 case ISUB:</span>
<span class="line-added"> 948                 case LSUB:</span>
<span class="line-added"> 949                 case FSUB:</span>
<span class="line-added"> 950                 case DSUB:</span>
<span class="line-added"> 951                 case IMUL:</span>
<span class="line-added"> 952                 case LMUL:</span>
<span class="line-added"> 953                 case FMUL:</span>
<span class="line-added"> 954                 case DMUL:</span>
<span class="line-added"> 955                 case FDIV:</span>
<span class="line-added"> 956                 case DDIV:</span>
<span class="line-added"> 957                 case FREM:</span>
<span class="line-added"> 958                 case DREM:</span>
<span class="line-added"> 959                 case INEG:</span>
<span class="line-added"> 960                 case LNEG:</span>
<span class="line-added"> 961                 case FNEG:</span>
<span class="line-added"> 962                 case DNEG:</span>
<span class="line-added"> 963                 case ISHL:</span>
<span class="line-added"> 964                 case LSHL:</span>
<span class="line-added"> 965                 case ISHR:</span>
<span class="line-added"> 966                 case LSHR:</span>
<span class="line-added"> 967                 case IUSHR:</span>
<span class="line-added"> 968                 case LUSHR:</span>
<span class="line-added"> 969                 case IAND:</span>
<span class="line-added"> 970                 case LAND:</span>
<span class="line-added"> 971                 case IOR:</span>
<span class="line-added"> 972                 case LOR:</span>
<span class="line-added"> 973                 case IXOR:</span>
<span class="line-added"> 974                 case LXOR:</span>
<span class="line-added"> 975                 case IINC:</span>
<span class="line-added"> 976                 case I2L:</span>
<span class="line-added"> 977                 case I2F:</span>
<span class="line-added"> 978                 case I2D:</span>
<span class="line-added"> 979                 case L2I:</span>
<span class="line-added"> 980                 case L2F:</span>
<span class="line-added"> 981                 case L2D:</span>
<span class="line-added"> 982                 case F2I:</span>
<span class="line-added"> 983                 case F2L:</span>
<span class="line-added"> 984                 case F2D:</span>
<span class="line-added"> 985                 case D2I:</span>
<span class="line-added"> 986                 case D2L:</span>
<span class="line-added"> 987                 case D2F:</span>
<span class="line-added"> 988                 case I2B:</span>
<span class="line-added"> 989                 case I2C:</span>
<span class="line-added"> 990                 case I2S:</span>
<span class="line-added"> 991                 case LCMP:</span>
<span class="line-added"> 992                 case FCMPL:</span>
<span class="line-added"> 993                 case FCMPG:</span>
<span class="line-added"> 994                 case DCMPL:</span>
<span class="line-added"> 995                 case DCMPG:</span>
<span class="line-added"> 996                 case MONITOREXIT:</span>
<span class="line-added"> 997                     // All stack manipulation, comparison, conversion and arithmetic operators</span>
<span class="line-added"> 998                     // except for idiv and irem can&#39;t throw exceptions so the don&#39;t need to connect</span>
<span class="line-added"> 999                     // exception edges. MONITOREXIT can&#39;t throw exceptions in the context of</span>
<span class="line-added">1000                     // compiled code because of the structured locking requirement in the parser.</span>
<span class="line-added">1001                     break;</span>
<span class="line-added">1002 </span>
<span class="line-added">1003                 case WIDE:</span>
<span class="line-added">1004                 case BREAKPOINT:</span>
<span class="line-added">1005                 default:</span>
<span class="line-added">1006                     throw new GraalError(&quot;Unhandled bytecode&quot;);</span>
1007             }
1008             stream.next();
1009         }
1010     }
1011 
1012     private BciBlock makeBlock(BciBlock[] blockMap, int startBci) {
1013         BciBlock oldBlock = blockMap[startBci];
1014         if (oldBlock == null) {
1015             BciBlock newBlock = new BciBlock(startBci);
1016             blocksNotYetAssignedId++;
1017             blockMap[startBci] = newBlock;
1018             return newBlock;
1019 
1020         } else if (oldBlock.startBci != startBci) {
1021             // Backward branch into the middle of an already processed block.
1022             // Add the correct fall-through successor.
1023             BciBlock newBlock = new BciBlock(startBci);
1024             blocksNotYetAssignedId++;
1025             newBlock.endBci = oldBlock.endBci;
1026             for (BciBlock oldSuccessor : oldBlock.getSuccessors()) {
</pre>
<hr />
<pre>
1062     }
1063 
1064     private final ArrayList&lt;BciBlock&gt; jsrVisited = new ArrayList&lt;&gt;();
1065 
1066     private void createJsrAlternatives(BciBlock[] blockMap, BciBlock block) {
1067         jsrVisited.add(block);
1068         JsrScope scope = block.getJsrScope();
1069 
1070         if (block.endsWithRet()) {
1071             block.setRetSuccessor(blockMap[scope.nextReturnAddress()]);
1072             block.addSuccessor(block.getRetSuccessor());
1073             assert block.getRetSuccessor() != block.getJsrSuccessor();
1074         }
1075         debug.log(&quot;JSR alternatives block %s  sux %s  jsrSux %s  retSux %s  jsrScope %s&quot;, block, block.getSuccessors(), block.getJsrSuccessor(), block.getRetSuccessor(), block.getJsrScope());
1076 
1077         if (block.getJsrSuccessor() != null || !scope.isEmpty()) {
1078             for (int i = 0; i &lt; block.getSuccessorCount(); i++) {
1079                 BciBlock successor = block.getSuccessor(i);
1080                 JsrScope nextScope = scope;
1081                 if (successor == block.getJsrSuccessor()) {
<span class="line-modified">1082                     nextScope = scope.push(block.getJsrReturnBci(), successor);</span>
1083                 }
1084                 if (successor == block.getRetSuccessor()) {
1085                     nextScope = scope.pop();
1086                 }
1087                 if (!successor.getJsrScope().isPrefixOf(nextScope)) {
1088                     throw new JsrNotSupportedBailout(&quot;unstructured control flow  (&quot; + successor.getJsrScope() + &quot; &quot; + nextScope + &quot;)&quot;);
1089                 }
1090                 if (!nextScope.isEmpty()) {
1091                     BciBlock clone;
1092                     if (successor.getJsrAlternatives() != null &amp;&amp; successor.getJsrAlternatives().containsKey(nextScope)) {
1093                         clone = successor.getJsrAlternatives().get(nextScope);
1094                     } else {
1095                         successor.initJsrAlternatives();
1096                         clone = successor.copy();
1097                         blocksNotYetAssignedId++;
1098                         clone.setJsrScope(nextScope);
1099                         successor.getJsrAlternatives().put(nextScope, clone);
1100                     }
1101                     block.getSuccessors().set(i, clone);
1102                     if (successor == block.getJsrSuccessor()) {
1103                         block.setJsrSuccessor(clone);
1104                     }
1105                     if (successor == block.getRetSuccessor()) {
1106                         block.setRetSuccessor(clone);
1107                     }
1108                 }
1109             }
1110         }
1111         for (BciBlock successor : block.getSuccessors()) {
<span class="line-modified">1112             if (!jsrVisited.contains(successor) &amp;&amp; shouldFollowEdge(successor, scope)) {</span>
1113                 createJsrAlternatives(blockMap, successor);
1114             }
1115         }
1116     }
1117 
<span class="line-added">1118     private static boolean shouldFollowEdge(BciBlock successor, JsrScope scope) {</span>
<span class="line-added">1119         if (successor instanceof ExceptionDispatchBlock &amp;&amp; scope.getJsrEntryBlock() != null) {</span>
<span class="line-added">1120             ExceptionDispatchBlock exceptionDispatchBlock = (ExceptionDispatchBlock) successor;</span>
<span class="line-added">1121             int bci = scope.getJsrEntryBlock().startBci;</span>
<span class="line-added">1122             if (exceptionDispatchBlock.handler.getStartBCI() &lt; bci &amp;&amp; bci &lt; exceptionDispatchBlock.handler.getEndBCI()) {</span>
<span class="line-added">1123                 // Handler covers start of JSR block and the bci before that =&gt; don&#39;t follow edge.</span>
<span class="line-added">1124                 return false;</span>
<span class="line-added">1125             }</span>
<span class="line-added">1126         }</span>
<span class="line-added">1127 </span>
<span class="line-added">1128         return true;</span>
<span class="line-added">1129     }</span>
<span class="line-added">1130 </span>
1131     private ExceptionDispatchBlock handleExceptions(BciBlock[] blockMap, int bci) {
1132         ExceptionDispatchBlock lastHandler = null;
1133         int dispatchBlocks = 0;
1134 
1135         for (int i = exceptionHandlers.length - 1; i &gt;= 0; i--) {
1136             ExceptionHandler h = exceptionHandlers[i];
1137             if (h.getStartBCI() &lt;= bci &amp;&amp; bci &lt; h.getEndBCI()) {
1138                 if (h.isCatchAll()) {
1139                     // Discard all information about succeeding exception handlers, since they can
1140                     // never be reached.
1141                     dispatchBlocks = 0;
1142                     lastHandler = null;
1143                 }
1144 
1145                 // We do not reuse exception dispatch blocks, because nested exception handlers
1146                 // might have problems reasoning about the correct frame state.
1147                 ExceptionDispatchBlock curHandler = new ExceptionDispatchBlock(h, bci);
1148                 dispatchBlocks++;
1149                 curHandler.addSuccessor(blockMap[h.getHandlerBCI()]);
1150                 if (lastHandler != null) {
1151                     curHandler.addSuccessor(lastHandler);
1152                 }
1153                 lastHandler = curHandler;
1154             }
1155         }
1156         blocksNotYetAssignedId += dispatchBlocks;
1157         return lastHandler;
1158     }
1159 
1160     private boolean loopChanges;
1161 
1162     private void fixLoopBits(BciBlock[] blockMap) {
1163         do {
1164             loopChanges = false;
1165             for (BciBlock b : blocks) {
1166                 b.visited = false;
1167             }
1168 
<span class="line-modified">1169             long loop = fixLoopBits(blockMap[0]);</span>
1170 
1171             if (loop != 0) {
1172                 // There is a path from a loop end to the method entry that does not pass the loop
1173                 // header.
1174                 // Therefore, the loop is non reducible (has more than one entry).
1175                 // We don&#39;t want to compile such methods because the IR only supports structured
1176                 // loops.
1177                 throw new PermanentBailoutException(&quot;Non-reducible loop: %016x&quot;, loop);
1178             }
1179         } while (loopChanges);
1180     }
1181 
1182     private void computeBlockOrder(BciBlock[] blockMap) {
1183         int maxBlocks = blocksNotYetAssignedId;
1184         this.blocks = new BciBlock[blocksNotYetAssignedId];
1185         long loop = computeBlockOrder(blockMap[0]);
1186 
1187         if (loop != 0) {
1188             // There is a path from a loop end to the method entry that does not pass the loop
1189             // header. Therefore, the loop is non reducible (has more than one entry).
</pre>
<hr />
<pre>
1192         }
1193 
1194         // Purge null entries for unreached blocks and sort blocks such that loop bodies are always
1195         // consecutively in the array.
1196         int blockCount = maxBlocks - blocksNotYetAssignedId + 1;
1197         BciBlock[] newBlocks = new BciBlock[blockCount];
1198         int next = 0;
1199         for (int i = 0; i &lt; blocks.length; ++i) {
1200             BciBlock b = blocks[i];
1201             if (b != null) {
1202                 b.setId(next);
1203                 newBlocks[next++] = b;
1204                 if (b.isLoopHeader) {
1205                     next = handleLoopHeader(newBlocks, next, i, b);
1206                 }
1207             }
1208         }
1209         assert next == newBlocks.length - 1;
1210 
1211         // Add unwind block.
<span class="line-modified">1212         ExceptionDispatchBlock unwindBlock = new ExceptionDispatchBlock(BytecodeFrame.AFTER_EXCEPTION_BCI);</span>

1213         unwindBlock.setId(newBlocks.length - 1);
1214         newBlocks[newBlocks.length - 1] = unwindBlock;
1215 
1216         blocks = newBlocks;
1217     }
1218 
1219     private int handleLoopHeader(BciBlock[] newBlocks, int nextStart, int i, BciBlock loopHeader) {
1220         int next = nextStart;
1221         int endOfLoop = nextStart - 1;
1222         for (int j = i + 1; j &lt; blocks.length; ++j) {
1223             BciBlock other = blocks[j];
1224             if (other != null &amp;&amp; (other.loops &amp; (1L &lt;&lt; loopHeader.loopId)) != 0) {
1225                 other.setId(next);
1226                 endOfLoop = next;
1227                 newBlocks[next++] = other;
1228                 blocks[j] = null;
1229                 if (other.isLoopHeader) {
1230                     next = handleLoopHeader(newBlocks, next, j, other);
1231                 }
1232             }
</pre>
<hr />
<pre>
1321                 // checking for correctness.
1322                 throw new PermanentBailoutException(&quot;Too many loops in method&quot;);
1323             }
1324 
1325             assert block.loops == 0;
1326             block.loops = 1L &lt;&lt; nextLoop;
1327             debug.log(&quot;makeLoopHeader(%s) -&gt; %x&quot;, block, block.loops);
1328             if (loopHeaders == null) {
1329                 loopHeaders = new BciBlock[LOOP_HEADER_INITIAL_CAPACITY];
1330             } else if (nextLoop &gt;= loopHeaders.length) {
1331                 loopHeaders = Arrays.copyOf(loopHeaders, LOOP_HEADER_MAX_CAPACITY);
1332             }
1333             loopHeaders[nextLoop] = block;
1334             block.loopId = nextLoop;
1335             nextLoop++;
1336         }
1337         assert Long.bitCount(block.loops) == 1;
1338     }
1339 
1340     /**
<span class="line-modified">1341      * Non-recursive depth-first traversal of the control flow graph. The flag</span>
<span class="line-modified">1342      * {@linkplain BciBlock#visited} is used to visit every block only once. The flag</span>
<span class="line-modified">1343      * {@linkplain BciBlock#active} is used to detect cycles (backward edges)</span>
1344      */
<span class="line-modified">1345     private long computeBlockOrder(BciBlock initialBlock) {</span>
<span class="line-modified">1346         ArrayDeque&lt;TraversalStep&gt; workStack = new ArrayDeque&lt;&gt;();</span>
<span class="line-modified">1347         workStack.push(new TraversalStep(initialBlock));</span>
<span class="line-modified">1348         while (true) {</span>
<span class="line-modified">1349             TraversalStep step = workStack.peek();</span>
<span class="line-modified">1350             BciBlock block = step.block;</span>
<span class="line-modified">1351             if (step.currentSuccessorIndex == 0) {</span>
<span class="line-modified">1352                 block.visited = true;</span>
<span class="line-modified">1353                 block.active = true;</span>
1354             } else {
<span class="line-modified">1355                 BciBlock successor = block.getSuccessor(step.currentSuccessorIndex - 1);</span>
<span class="line-added">1356                 if (successor.active) {</span>
<span class="line-added">1357                     // Reached block via backward branch.</span>
<span class="line-added">1358                     step.loops |= (1L &lt;&lt; successor.loopId);</span>
<span class="line-added">1359                 }</span>
1360             }
<span class="line-modified">1361             if (step.currentSuccessorIndex &lt; block.successors.size()) {</span>
<span class="line-modified">1362                 BciBlock successor = block.getSuccessors().get(step.currentSuccessorIndex);</span>
<span class="line-modified">1363                 if (successor.visited) {</span>
<span class="line-modified">1364                     if (successor.active) {</span>
<span class="line-added">1365                         // Reached block via backward branch.</span>
<span class="line-added">1366                         makeLoopHeader(successor);</span>
<span class="line-added">1367                         step.loops |= successor.loops;</span>
<span class="line-added">1368                     } else if (successor.isLoopHeader) {</span>
<span class="line-added">1369                         step.loops |= successor.loops &amp; ~(1L &lt;&lt; successor.loopId);</span>
<span class="line-added">1370                     } else {</span>
<span class="line-added">1371                         step.loops |= successor.loops;</span>
<span class="line-added">1372                     }</span>
<span class="line-added">1373                 } else {</span>
<span class="line-added">1374                     workStack.push(new TraversalStep(successor));</span>
<span class="line-added">1375                 }</span>
<span class="line-added">1376                 step.currentSuccessorIndex++;</span>
<span class="line-added">1377             } else {</span>
<span class="line-added">1378                 // We processed all the successors of this block.</span>
<span class="line-added">1379                 block.loops = step.loops;</span>
<span class="line-added">1380                 debug.log(&quot;computeBlockOrder(%s) -&gt; %x&quot;, block, block.loops);</span>
1381 
<span class="line-modified">1382                 if (block.isLoopHeader) {</span>
<span class="line-modified">1383                     step.loops &amp;= ~(1L &lt;&lt; block.loopId);</span>
<span class="line-modified">1384                 }</span>






1385 
<span class="line-modified">1386                 block.active = false;</span>
<span class="line-modified">1387                 blocksNotYetAssignedId--;</span>
<span class="line-added">1388                 blocks[blocksNotYetAssignedId] = block;</span>
1389 
<span class="line-modified">1390                 workStack.pop();</span>
<span class="line-modified">1391                 if (!workStack.isEmpty()) {</span>
<span class="line-added">1392                     workStack.peek().loops |= step.loops;</span>
<span class="line-added">1393                 } else {</span>
<span class="line-added">1394                     return step.loops;</span>
<span class="line-added">1395                 }</span>
<span class="line-added">1396             }</span>
1397         }






1398     }
1399 
<span class="line-modified">1400     private long fixLoopBits(BciBlock initialBlock) {</span>
<span class="line-modified">1401         ArrayDeque&lt;TraversalStep&gt; workStack = new ArrayDeque&lt;&gt;();</span>
<span class="line-modified">1402         workStack.push(new TraversalStep(initialBlock));</span>
<span class="line-modified">1403         while (true) {</span>
<span class="line-modified">1404             TraversalStep step = workStack.peek();</span>
<span class="line-modified">1405             BciBlock block = step.block;</span>
<span class="line-modified">1406             if (step.currentSuccessorIndex == 0) {</span>
<span class="line-added">1407                 block.visited = true;</span>
<span class="line-added">1408                 step.loops = block.loops;</span>
1409             }
<span class="line-modified">1410             if (step.currentSuccessorIndex &lt; block.getSuccessors().size()) {</span>
<span class="line-added">1411                 BciBlock successor = block.getSuccessors().get(step.currentSuccessorIndex);</span>
<span class="line-added">1412                 if (successor.visited) {</span>
<span class="line-added">1413                     // Return cached loop information for this block.</span>
<span class="line-added">1414                     if (successor.isLoopHeader) {</span>
<span class="line-added">1415                         step.loops |= successor.loops &amp; ~(1L &lt;&lt; successor.loopId);</span>
<span class="line-added">1416                     } else {</span>
<span class="line-added">1417                         step.loops |= successor.loops;</span>
<span class="line-added">1418                     }</span>
<span class="line-added">1419                 } else {</span>
<span class="line-added">1420                     workStack.push(new TraversalStep(successor));</span>
<span class="line-added">1421                 }</span>
<span class="line-added">1422                 step.currentSuccessorIndex++;</span>
<span class="line-added">1423             } else {</span>
<span class="line-added">1424                 if (block.loops != step.loops) {</span>
<span class="line-added">1425                     loopChanges = true;</span>
<span class="line-added">1426                     block.loops = step.loops;</span>
<span class="line-added">1427                     debug.log(&quot;fixLoopBits0(%s) -&gt; %x&quot;, block, block.loops);</span>
<span class="line-added">1428                 }</span>
1429 
<span class="line-modified">1430                 if (block.isLoopHeader) {</span>
<span class="line-modified">1431                     step.loops &amp;= ~(1L &lt;&lt; block.loopId);</span>
<span class="line-modified">1432                 }</span>








1433 
<span class="line-modified">1434                 workStack.pop();</span>
<span class="line-modified">1435                 if (!workStack.isEmpty()) {</span>
<span class="line-added">1436                     workStack.peek().loops |= step.loops;</span>
<span class="line-added">1437                 } else {</span>
<span class="line-added">1438                     return step.loops;</span>
<span class="line-added">1439                 }</span>
<span class="line-added">1440             }</span>
1441         }


1442     }
1443 
1444     public static BciBlockMapping create(BytecodeStream stream, Bytecode code, OptionValues options, DebugContext debug) {
1445         BciBlockMapping map = new BciBlockMapping(code, debug);
1446         map.build(stream, options);
1447         if (debug.isDumpEnabled(DebugContext.INFO_LEVEL)) {
1448             debug.dump(DebugContext.INFO_LEVEL, map, code.getMethod().format(&quot;After block building %f %R %H.%n(%P)&quot;));
1449         }
1450 
1451         return map;
1452     }
1453 
1454     public BciBlock[] getLoopHeaders() {
1455         return loopHeaders;
1456     }
1457 
1458     public BciBlock getStartBlock() {
1459         return startBlock;
1460     }
1461 
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/UnwindExceptionToCallerStub.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeParser.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BciBlockMapping.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/UnwindExceptionToCallerStub.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeParser.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BciBlockMapping.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,31 ***</span>
<span class="line-new-header">--- 24,112 ---</span>
  
  package org.graalvm.compiler.java;
  
  import static org.graalvm.compiler.bytecode.Bytecodes.AALOAD;
  import static org.graalvm.compiler.bytecode.Bytecodes.AASTORE;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ACONST_NULL;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_3;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.ANEWARRAY;
  import static org.graalvm.compiler.bytecode.Bytecodes.ARETURN;
  import static org.graalvm.compiler.bytecode.Bytecodes.ARRAYLENGTH;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_3;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.ATHROW;
  import static org.graalvm.compiler.bytecode.Bytecodes.BALOAD;
  import static org.graalvm.compiler.bytecode.Bytecodes.BASTORE;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.BIPUSH;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.BREAKPOINT;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.CALOAD;
  import static org.graalvm.compiler.bytecode.Bytecodes.CASTORE;
  import static org.graalvm.compiler.bytecode.Bytecodes.CHECKCAST;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.D2F;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.D2I;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.D2L;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DADD;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.DALOAD;
  import static org.graalvm.compiler.bytecode.Bytecodes.DASTORE;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DCMPG;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DCMPL;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DDIV;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_3;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DMUL;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DNEG;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DREM;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.DRETURN;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_3;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DSUB;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DUP;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DUP2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.F2D;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.F2I;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.F2L;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FADD;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.FALOAD;
  import static org.graalvm.compiler.bytecode.Bytecodes.FASTORE;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FCMPG;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FCMPL;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FDIV;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_3;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FMUL;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FNEG;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FREM;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.FRETURN;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_3;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.FSUB;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.GETFIELD;
  import static org.graalvm.compiler.bytecode.Bytecodes.GETSTATIC;
  import static org.graalvm.compiler.bytecode.Bytecodes.GOTO;
  import static org.graalvm.compiler.bytecode.Bytecodes.GOTO_W;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.I2B;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.I2C;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.I2D;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.I2F;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.I2L;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.I2S;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.IADD;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.IALOAD;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.IAND;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.IASTORE;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_3;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_4;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_5;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_M1;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.IDIV;
  import static org.graalvm.compiler.bytecode.Bytecodes.IFEQ;
  import static org.graalvm.compiler.bytecode.Bytecodes.IFGE;
  import static org.graalvm.compiler.bytecode.Bytecodes.IFGT;
  import static org.graalvm.compiler.bytecode.Bytecodes.IFLE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,39 ***</span>
<span class="line-new-header">--- 143,95 ---</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGE;
  import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGT;
  import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLE;
  import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLT;
  import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPNE;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.IINC;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_3;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.IMUL;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.INEG;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.INSTANCEOF;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEDYNAMIC;
  import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEINTERFACE;
  import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESPECIAL;
  import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESTATIC;
  import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEVIRTUAL;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.IOR;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.IREM;
  import static org.graalvm.compiler.bytecode.Bytecodes.IRETURN;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ISHL;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ISHR;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_3;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.ISUB;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.IUSHR;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.IXOR;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.JSR;
  import static org.graalvm.compiler.bytecode.Bytecodes.JSR_W;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.L2D;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.L2F;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.L2I;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LADD;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.LALOAD;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LAND;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.LASTORE;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LCMP;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_1;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.LDC;
  import static org.graalvm.compiler.bytecode.Bytecodes.LDC2_W;
  import static org.graalvm.compiler.bytecode.Bytecodes.LDC_W;
  import static org.graalvm.compiler.bytecode.Bytecodes.LDIV;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_3;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LMUL;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LNEG;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.LOOKUPSWITCH;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LOR;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.LREM;
  import static org.graalvm.compiler.bytecode.Bytecodes.LRETURN;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LSHL;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LSHR;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_0;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_1;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_2;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_3;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LSUB;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LUSHR;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.LXOR;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.MONITORENTER;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.MONITOREXIT;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.MULTIANEWARRAY;
  import static org.graalvm.compiler.bytecode.Bytecodes.NEW;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.NEWARRAY;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.NOP;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.POP;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.POP2;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.PUTFIELD;
  import static org.graalvm.compiler.bytecode.Bytecodes.PUTSTATIC;
  import static org.graalvm.compiler.bytecode.Bytecodes.RET;
  import static org.graalvm.compiler.bytecode.Bytecodes.RETURN;
  import static org.graalvm.compiler.bytecode.Bytecodes.SALOAD;
  import static org.graalvm.compiler.bytecode.Bytecodes.SASTORE;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.SIPUSH;</span>
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;</span>
  import static org.graalvm.compiler.bytecode.Bytecodes.TABLESWITCH;
<span class="line-added">+ import static org.graalvm.compiler.bytecode.Bytecodes.WIDE;</span>
  import static org.graalvm.compiler.core.common.GraalOptions.SupportJsrBytecodes;
  
<span class="line-added">+ import java.util.ArrayDeque;</span>
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Collection;
  import java.util.Iterator;
  import java.util.List;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,18 ***</span>
  import org.graalvm.compiler.bytecode.BytecodeSwitch;
  import org.graalvm.compiler.bytecode.BytecodeTableSwitch;
  import org.graalvm.compiler.bytecode.Bytecodes;
  import org.graalvm.compiler.core.common.PermanentBailoutException;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.options.OptionValues;
  
  import jdk.vm.ci.code.BytecodeFrame;
  import jdk.vm.ci.meta.ExceptionHandler;
  
  /**
   * Builds a mapping between bytecodes and basic blocks and builds a conservative control flow graph
<span class="line-modified">!  * (CFG). It makes one linear passes over the bytecodes to build the CFG where it detects block</span>
   * headers and connects them.
   * &lt;p&gt;
   * It also creates exception dispatch blocks for exception handling. These blocks are between a
   * bytecode that might throw an exception, and the actual exception handler entries, and are later
   * used to create the type checks with the exception handler catch types. If a bytecode is covered
<span class="line-new-header">--- 245,19 ---</span>
  import org.graalvm.compiler.bytecode.BytecodeSwitch;
  import org.graalvm.compiler.bytecode.BytecodeTableSwitch;
  import org.graalvm.compiler.bytecode.Bytecodes;
  import org.graalvm.compiler.core.common.PermanentBailoutException;
  import org.graalvm.compiler.debug.DebugContext;
<span class="line-added">+ import org.graalvm.compiler.debug.GraalError;</span>
  import org.graalvm.compiler.options.OptionValues;
  
  import jdk.vm.ci.code.BytecodeFrame;
  import jdk.vm.ci.meta.ExceptionHandler;
  
  /**
   * Builds a mapping between bytecodes and basic blocks and builds a conservative control flow graph
<span class="line-modified">!  * (CFG). It makes one linear pass over the bytecodes to build the CFG where it detects block</span>
   * headers and connects them.
   * &lt;p&gt;
   * It also creates exception dispatch blocks for exception handling. These blocks are between a
   * bytecode that might throw an exception, and the actual exception handler entries, and are later
   * used to create the type checks with the exception handler catch types. If a bytecode is covered
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,11 ***</span>
  
      public static class BciBlock implements Cloneable {
  
          int id;
          final int startBci;
<span class="line-modified">!         int endBci;</span>
          private boolean isExceptionEntry;
          private boolean isLoopHeader;
          int loopId;
          int loopEnd;
          List&lt;BciBlock&gt; successors;
<span class="line-new-header">--- 294,11 ---</span>
  
      public static class BciBlock implements Cloneable {
  
          int id;
          final int startBci;
<span class="line-modified">!         int endBci; // The bci of the last bytecode in the block</span>
          private boolean isExceptionEntry;
          private boolean isLoopHeader;
          int loopId;
          int loopEnd;
          List&lt;BciBlock&gt; successors;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 475,10 ***</span>
<span class="line-new-header">--- 613,22 ---</span>
          public boolean isExceptionDispatch() {
              return true;
          }
      }
  
<span class="line-added">+     private static final class TraversalStep {</span>
<span class="line-added">+         private BciBlock block;</span>
<span class="line-added">+         private int currentSuccessorIndex;</span>
<span class="line-added">+         private long loops;</span>
<span class="line-added">+ </span>
<span class="line-added">+         private TraversalStep(BciBlock block) {</span>
<span class="line-added">+             this.block = block;</span>
<span class="line-added">+             this.currentSuccessorIndex = 0;</span>
<span class="line-added">+             this.loops = 0;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * The blocks found in this method, in reverse postorder.
       */
      private BciBlock[] blocks;
      public final Bytecode code;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 683,20 ***</span>
                  case BALOAD:
                  case CALOAD:
                  case SALOAD:
                  case ARRAYLENGTH:
                  case CHECKCAST:
                  case NEW:
                  case ANEWARRAY:
                  case MULTIANEWARRAY:
                  case PUTSTATIC:
                  case GETSTATIC:
                  case PUTFIELD:
                  case GETFIELD:
                  case LDC:
                  case LDC_W:
<span class="line-modified">!                 case LDC2_W: {</span>
                      /*
                       * All bytecodes that can trigger lazy class initialization via a
                       * ClassInitializationPlugin (allocations, static field access) must be listed
                       * because the class initializer is allowed to throw an exception, which
                       * requires proper exception handling.
<span class="line-new-header">--- 833,23 ---</span>
                  case BALOAD:
                  case CALOAD:
                  case SALOAD:
                  case ARRAYLENGTH:
                  case CHECKCAST:
<span class="line-added">+                 case INSTANCEOF:</span>
                  case NEW:
<span class="line-added">+                 case NEWARRAY:</span>
                  case ANEWARRAY:
                  case MULTIANEWARRAY:
                  case PUTSTATIC:
                  case GETSTATIC:
                  case PUTFIELD:
                  case GETFIELD:
                  case LDC:
                  case LDC_W:
<span class="line-modified">!                 case LDC2_W:</span>
<span class="line-added">+                 case MONITORENTER: {</span>
                      /*
                       * All bytecodes that can trigger lazy class initialization via a
                       * ClassInitializationPlugin (allocations, static field access) must be listed
                       * because the class initializer is allowed to throw an exception, which
                       * requires proper exception handling.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 705,11 ***</span>
<span class="line-new-header">--- 858,154 ---</span>
                      if (handler != null) {
                          current = null;
                          addSuccessor(blockMap, bci, makeBlock(blockMap, stream.nextBCI()));
                          addSuccessor(blockMap, bci, handler);
                      }
<span class="line-added">+                     break;</span>
                  }
<span class="line-added">+ </span>
<span class="line-added">+                 case NOP:</span>
<span class="line-added">+                 case ACONST_NULL:</span>
<span class="line-added">+                 case ICONST_M1:</span>
<span class="line-added">+                 case ICONST_0:</span>
<span class="line-added">+                 case ICONST_1:</span>
<span class="line-added">+                 case ICONST_2:</span>
<span class="line-added">+                 case ICONST_3:</span>
<span class="line-added">+                 case ICONST_4:</span>
<span class="line-added">+                 case ICONST_5:</span>
<span class="line-added">+                 case LCONST_0:</span>
<span class="line-added">+                 case LCONST_1:</span>
<span class="line-added">+                 case FCONST_0:</span>
<span class="line-added">+                 case FCONST_1:</span>
<span class="line-added">+                 case FCONST_2:</span>
<span class="line-added">+                 case DCONST_0:</span>
<span class="line-added">+                 case DCONST_1:</span>
<span class="line-added">+                 case BIPUSH:</span>
<span class="line-added">+                 case SIPUSH:</span>
<span class="line-added">+                 case ILOAD:</span>
<span class="line-added">+                 case LLOAD:</span>
<span class="line-added">+                 case FLOAD:</span>
<span class="line-added">+                 case DLOAD:</span>
<span class="line-added">+                 case ALOAD:</span>
<span class="line-added">+                 case ILOAD_0:</span>
<span class="line-added">+                 case ILOAD_1:</span>
<span class="line-added">+                 case ILOAD_2:</span>
<span class="line-added">+                 case ILOAD_3:</span>
<span class="line-added">+                 case LLOAD_0:</span>
<span class="line-added">+                 case LLOAD_1:</span>
<span class="line-added">+                 case LLOAD_2:</span>
<span class="line-added">+                 case LLOAD_3:</span>
<span class="line-added">+                 case FLOAD_0:</span>
<span class="line-added">+                 case FLOAD_1:</span>
<span class="line-added">+                 case FLOAD_2:</span>
<span class="line-added">+                 case FLOAD_3:</span>
<span class="line-added">+                 case DLOAD_0:</span>
<span class="line-added">+                 case DLOAD_1:</span>
<span class="line-added">+                 case DLOAD_2:</span>
<span class="line-added">+                 case DLOAD_3:</span>
<span class="line-added">+                 case ALOAD_0:</span>
<span class="line-added">+                 case ALOAD_1:</span>
<span class="line-added">+                 case ALOAD_2:</span>
<span class="line-added">+                 case ALOAD_3:</span>
<span class="line-added">+                 case ISTORE:</span>
<span class="line-added">+                 case LSTORE:</span>
<span class="line-added">+                 case FSTORE:</span>
<span class="line-added">+                 case DSTORE:</span>
<span class="line-added">+                 case ASTORE:</span>
<span class="line-added">+                 case ISTORE_0:</span>
<span class="line-added">+                 case ISTORE_1:</span>
<span class="line-added">+                 case ISTORE_2:</span>
<span class="line-added">+                 case ISTORE_3:</span>
<span class="line-added">+                 case LSTORE_0:</span>
<span class="line-added">+                 case LSTORE_1:</span>
<span class="line-added">+                 case LSTORE_2:</span>
<span class="line-added">+                 case LSTORE_3:</span>
<span class="line-added">+                 case FSTORE_0:</span>
<span class="line-added">+                 case FSTORE_1:</span>
<span class="line-added">+                 case FSTORE_2:</span>
<span class="line-added">+                 case FSTORE_3:</span>
<span class="line-added">+                 case DSTORE_0:</span>
<span class="line-added">+                 case DSTORE_1:</span>
<span class="line-added">+                 case DSTORE_2:</span>
<span class="line-added">+                 case DSTORE_3:</span>
<span class="line-added">+                 case ASTORE_0:</span>
<span class="line-added">+                 case ASTORE_1:</span>
<span class="line-added">+                 case ASTORE_2:</span>
<span class="line-added">+                 case ASTORE_3:</span>
<span class="line-added">+                 case POP:</span>
<span class="line-added">+                 case POP2:</span>
<span class="line-added">+                 case DUP:</span>
<span class="line-added">+                 case DUP_X1:</span>
<span class="line-added">+                 case DUP_X2:</span>
<span class="line-added">+                 case DUP2:</span>
<span class="line-added">+                 case DUP2_X1:</span>
<span class="line-added">+                 case DUP2_X2:</span>
<span class="line-added">+                 case SWAP:</span>
<span class="line-added">+                 case IADD:</span>
<span class="line-added">+                 case LADD:</span>
<span class="line-added">+                 case FADD:</span>
<span class="line-added">+                 case DADD:</span>
<span class="line-added">+                 case ISUB:</span>
<span class="line-added">+                 case LSUB:</span>
<span class="line-added">+                 case FSUB:</span>
<span class="line-added">+                 case DSUB:</span>
<span class="line-added">+                 case IMUL:</span>
<span class="line-added">+                 case LMUL:</span>
<span class="line-added">+                 case FMUL:</span>
<span class="line-added">+                 case DMUL:</span>
<span class="line-added">+                 case FDIV:</span>
<span class="line-added">+                 case DDIV:</span>
<span class="line-added">+                 case FREM:</span>
<span class="line-added">+                 case DREM:</span>
<span class="line-added">+                 case INEG:</span>
<span class="line-added">+                 case LNEG:</span>
<span class="line-added">+                 case FNEG:</span>
<span class="line-added">+                 case DNEG:</span>
<span class="line-added">+                 case ISHL:</span>
<span class="line-added">+                 case LSHL:</span>
<span class="line-added">+                 case ISHR:</span>
<span class="line-added">+                 case LSHR:</span>
<span class="line-added">+                 case IUSHR:</span>
<span class="line-added">+                 case LUSHR:</span>
<span class="line-added">+                 case IAND:</span>
<span class="line-added">+                 case LAND:</span>
<span class="line-added">+                 case IOR:</span>
<span class="line-added">+                 case LOR:</span>
<span class="line-added">+                 case IXOR:</span>
<span class="line-added">+                 case LXOR:</span>
<span class="line-added">+                 case IINC:</span>
<span class="line-added">+                 case I2L:</span>
<span class="line-added">+                 case I2F:</span>
<span class="line-added">+                 case I2D:</span>
<span class="line-added">+                 case L2I:</span>
<span class="line-added">+                 case L2F:</span>
<span class="line-added">+                 case L2D:</span>
<span class="line-added">+                 case F2I:</span>
<span class="line-added">+                 case F2L:</span>
<span class="line-added">+                 case F2D:</span>
<span class="line-added">+                 case D2I:</span>
<span class="line-added">+                 case D2L:</span>
<span class="line-added">+                 case D2F:</span>
<span class="line-added">+                 case I2B:</span>
<span class="line-added">+                 case I2C:</span>
<span class="line-added">+                 case I2S:</span>
<span class="line-added">+                 case LCMP:</span>
<span class="line-added">+                 case FCMPL:</span>
<span class="line-added">+                 case FCMPG:</span>
<span class="line-added">+                 case DCMPL:</span>
<span class="line-added">+                 case DCMPG:</span>
<span class="line-added">+                 case MONITOREXIT:</span>
<span class="line-added">+                     // All stack manipulation, comparison, conversion and arithmetic operators</span>
<span class="line-added">+                     // except for idiv and irem can&#39;t throw exceptions so the don&#39;t need to connect</span>
<span class="line-added">+                     // exception edges. MONITOREXIT can&#39;t throw exceptions in the context of</span>
<span class="line-added">+                     // compiled code because of the structured locking requirement in the parser.</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 case WIDE:</span>
<span class="line-added">+                 case BREAKPOINT:</span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     throw new GraalError(&quot;Unhandled bytecode&quot;);</span>
              }
              stream.next();
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 781,11 ***</span>
          if (block.getJsrSuccessor() != null || !scope.isEmpty()) {
              for (int i = 0; i &lt; block.getSuccessorCount(); i++) {
                  BciBlock successor = block.getSuccessor(i);
                  JsrScope nextScope = scope;
                  if (successor == block.getJsrSuccessor()) {
<span class="line-modified">!                     nextScope = scope.push(block.getJsrReturnBci());</span>
                  }
                  if (successor == block.getRetSuccessor()) {
                      nextScope = scope.pop();
                  }
                  if (!successor.getJsrScope().isPrefixOf(nextScope)) {
<span class="line-new-header">--- 1077,11 ---</span>
          if (block.getJsrSuccessor() != null || !scope.isEmpty()) {
              for (int i = 0; i &lt; block.getSuccessorCount(); i++) {
                  BciBlock successor = block.getSuccessor(i);
                  JsrScope nextScope = scope;
                  if (successor == block.getJsrSuccessor()) {
<span class="line-modified">!                     nextScope = scope.push(block.getJsrReturnBci(), successor);</span>
                  }
                  if (successor == block.getRetSuccessor()) {
                      nextScope = scope.pop();
                  }
                  if (!successor.getJsrScope().isPrefixOf(nextScope)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 811,16 ***</span>
                      }
                  }
              }
          }
          for (BciBlock successor : block.getSuccessors()) {
<span class="line-modified">!             if (!jsrVisited.contains(successor)) {</span>
                  createJsrAlternatives(blockMap, successor);
              }
          }
      }
  
      private ExceptionDispatchBlock handleExceptions(BciBlock[] blockMap, int bci) {
          ExceptionDispatchBlock lastHandler = null;
          int dispatchBlocks = 0;
  
          for (int i = exceptionHandlers.length - 1; i &gt;= 0; i--) {
<span class="line-new-header">--- 1107,29 ---</span>
                      }
                  }
              }
          }
          for (BciBlock successor : block.getSuccessors()) {
<span class="line-modified">!             if (!jsrVisited.contains(successor) &amp;&amp; shouldFollowEdge(successor, scope)) {</span>
                  createJsrAlternatives(blockMap, successor);
              }
          }
      }
  
<span class="line-added">+     private static boolean shouldFollowEdge(BciBlock successor, JsrScope scope) {</span>
<span class="line-added">+         if (successor instanceof ExceptionDispatchBlock &amp;&amp; scope.getJsrEntryBlock() != null) {</span>
<span class="line-added">+             ExceptionDispatchBlock exceptionDispatchBlock = (ExceptionDispatchBlock) successor;</span>
<span class="line-added">+             int bci = scope.getJsrEntryBlock().startBci;</span>
<span class="line-added">+             if (exceptionDispatchBlock.handler.getStartBCI() &lt; bci &amp;&amp; bci &lt; exceptionDispatchBlock.handler.getEndBCI()) {</span>
<span class="line-added">+                 // Handler covers start of JSR block and the bci before that =&gt; don&#39;t follow edge.</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private ExceptionDispatchBlock handleExceptions(BciBlock[] blockMap, int bci) {
          ExceptionDispatchBlock lastHandler = null;
          int dispatchBlocks = 0;
  
          for (int i = exceptionHandlers.length - 1; i &gt;= 0; i--) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 855,11 ***</span>
              loopChanges = false;
              for (BciBlock b : blocks) {
                  b.visited = false;
              }
  
<span class="line-modified">!             long loop = fixLoopBits(blockMap, blockMap[0]);</span>
  
              if (loop != 0) {
                  // There is a path from a loop end to the method entry that does not pass the loop
                  // header.
                  // Therefore, the loop is non reducible (has more than one entry).
<span class="line-new-header">--- 1164,11 ---</span>
              loopChanges = false;
              for (BciBlock b : blocks) {
                  b.visited = false;
              }
  
<span class="line-modified">!             long loop = fixLoopBits(blockMap[0]);</span>
  
              if (loop != 0) {
                  // There is a path from a loop end to the method entry that does not pass the loop
                  // header.
                  // Therefore, the loop is non reducible (has more than one entry).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 898,12 ***</span>
              }
          }
          assert next == newBlocks.length - 1;
  
          // Add unwind block.
<span class="line-modified">!         int deoptBci = code.getMethod().isSynchronized() ? BytecodeFrame.UNWIND_BCI : BytecodeFrame.AFTER_EXCEPTION_BCI;</span>
<span class="line-removed">-         ExceptionDispatchBlock unwindBlock = new ExceptionDispatchBlock(deoptBci);</span>
          unwindBlock.setId(newBlocks.length - 1);
          newBlocks[newBlocks.length - 1] = unwindBlock;
  
          blocks = newBlocks;
      }
<span class="line-new-header">--- 1207,11 ---</span>
              }
          }
          assert next == newBlocks.length - 1;
  
          // Add unwind block.
<span class="line-modified">!         ExceptionDispatchBlock unwindBlock = new ExceptionDispatchBlock(BytecodeFrame.AFTER_EXCEPTION_BCI);</span>
          unwindBlock.setId(newBlocks.length - 1);
          newBlocks[newBlocks.length - 1] = unwindBlock;
  
          blocks = newBlocks;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1028,82 ***</span>
          }
          assert Long.bitCount(block.loops) == 1;
      }
  
      /**
<span class="line-modified">!      * Depth-first traversal of the control flow graph. The flag {@linkplain BciBlock#visited} is</span>
<span class="line-modified">!      * used to visit every block only once. The flag {@linkplain BciBlock#active} is used to detect</span>
<span class="line-modified">!      * cycles (backward edges).</span>
       */
<span class="line-modified">!     private long computeBlockOrder(BciBlock block) {</span>
<span class="line-modified">!         if (block.visited) {</span>
<span class="line-modified">!             if (block.active) {</span>
<span class="line-modified">!                 // Reached block via backward branch.</span>
<span class="line-modified">!                 makeLoopHeader(block);</span>
<span class="line-modified">!                 // Return cached loop information for this block.</span>
<span class="line-modified">!                 return block.loops;</span>
<span class="line-modified">!             } else if (block.isLoopHeader) {</span>
<span class="line-modified">!                 return block.loops &amp; ~(1L &lt;&lt; block.loopId);</span>
              } else {
<span class="line-modified">!                 return block.loops;</span>
              }
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         block.visited = true;</span>
<span class="line-modified">!         block.active = true;</span>
  
<span class="line-modified">!         long loops = 0;</span>
<span class="line-modified">!         for (BciBlock successor : block.getSuccessors()) {</span>
<span class="line-modified">!             // Recursively process successors.</span>
<span class="line-removed">-             loops |= computeBlockOrder(successor);</span>
<span class="line-removed">-             if (successor.active) {</span>
<span class="line-removed">-                 // Reached block via backward branch.</span>
<span class="line-removed">-                 loops |= (1L &lt;&lt; successor.loopId);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         block.loops = loops;</span>
<span class="line-modified">!         debug.log(&quot;computeBlockOrder(%s) -&gt; %x&quot;, block, block.loops);</span>
  
<span class="line-modified">!         if (block.isLoopHeader) {</span>
<span class="line-modified">!             loops &amp;= ~(1L &lt;&lt; block.loopId);</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         block.active = false;</span>
<span class="line-removed">-         blocksNotYetAssignedId--;</span>
<span class="line-removed">-         blocks[blocksNotYetAssignedId] = block;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return loops;</span>
      }
  
<span class="line-modified">!     private long fixLoopBits(BciBlock[] blockMap, BciBlock block) {</span>
<span class="line-modified">!         if (block.visited) {</span>
<span class="line-modified">!             // Return cached loop information for this block.</span>
<span class="line-modified">!             if (block.isLoopHeader) {</span>
<span class="line-modified">!                 return block.loops &amp; ~(1L &lt;&lt; block.loopId);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 return block.loops;</span>
              }
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         block.visited = true;</span>
<span class="line-modified">!         long loops = block.loops;</span>
<span class="line-modified">!         for (BciBlock successor : block.getSuccessors()) {</span>
<span class="line-removed">-             // Recursively process successors.</span>
<span class="line-removed">-             loops |= fixLoopBits(blockMap, successor);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (block.loops != loops) {</span>
<span class="line-removed">-             loopChanges = true;</span>
<span class="line-removed">-             block.loops = loops;</span>
<span class="line-removed">-             debug.log(&quot;fixLoopBits0(%s) -&gt; %x&quot;, block, block.loops);</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         if (block.isLoopHeader) {</span>
<span class="line-modified">!             loops &amp;= ~(1L &lt;&lt; block.loopId);</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         return loops;</span>
      }
  
      public static BciBlockMapping create(BytecodeStream stream, Bytecode code, OptionValues options, DebugContext debug) {
          BciBlockMapping map = new BciBlockMapping(code, debug);
          map.build(stream, options);
<span class="line-new-header">--- 1336,111 ---</span>
          }
          assert Long.bitCount(block.loops) == 1;
      }
  
      /**
<span class="line-modified">!      * Non-recursive depth-first traversal of the control flow graph. The flag</span>
<span class="line-modified">!      * {@linkplain BciBlock#visited} is used to visit every block only once. The flag</span>
<span class="line-modified">!      * {@linkplain BciBlock#active} is used to detect cycles (backward edges)</span>
       */
<span class="line-modified">!     private long computeBlockOrder(BciBlock initialBlock) {</span>
<span class="line-modified">!         ArrayDeque&lt;TraversalStep&gt; workStack = new ArrayDeque&lt;&gt;();</span>
<span class="line-modified">!         workStack.push(new TraversalStep(initialBlock));</span>
<span class="line-modified">!         while (true) {</span>
<span class="line-modified">!             TraversalStep step = workStack.peek();</span>
<span class="line-modified">!             BciBlock block = step.block;</span>
<span class="line-modified">!             if (step.currentSuccessorIndex == 0) {</span>
<span class="line-modified">!                 block.visited = true;</span>
<span class="line-modified">!                 block.active = true;</span>
              } else {
<span class="line-modified">!                 BciBlock successor = block.getSuccessor(step.currentSuccessorIndex - 1);</span>
<span class="line-added">+                 if (successor.active) {</span>
<span class="line-added">+                     // Reached block via backward branch.</span>
<span class="line-added">+                     step.loops |= (1L &lt;&lt; successor.loopId);</span>
<span class="line-added">+                 }</span>
              }
<span class="line-modified">!             if (step.currentSuccessorIndex &lt; block.successors.size()) {</span>
<span class="line-modified">!                 BciBlock successor = block.getSuccessors().get(step.currentSuccessorIndex);</span>
<span class="line-modified">!                 if (successor.visited) {</span>
<span class="line-modified">!                     if (successor.active) {</span>
<span class="line-added">+                         // Reached block via backward branch.</span>
<span class="line-added">+                         makeLoopHeader(successor);</span>
<span class="line-added">+                         step.loops |= successor.loops;</span>
<span class="line-added">+                     } else if (successor.isLoopHeader) {</span>
<span class="line-added">+                         step.loops |= successor.loops &amp; ~(1L &lt;&lt; successor.loopId);</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         step.loops |= successor.loops;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     workStack.push(new TraversalStep(successor));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 step.currentSuccessorIndex++;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 // We processed all the successors of this block.</span>
<span class="line-added">+                 block.loops = step.loops;</span>
<span class="line-added">+                 debug.log(&quot;computeBlockOrder(%s) -&gt; %x&quot;, block, block.loops);</span>
  
<span class="line-modified">!                 if (block.isLoopHeader) {</span>
<span class="line-modified">!                     step.loops &amp;= ~(1L &lt;&lt; block.loopId);</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 block.active = false;</span>
<span class="line-modified">!                 blocksNotYetAssignedId--;</span>
<span class="line-added">+                 blocks[blocksNotYetAssignedId] = block;</span>
  
<span class="line-modified">!                 workStack.pop();</span>
<span class="line-modified">!                 if (!workStack.isEmpty()) {</span>
<span class="line-added">+                     workStack.peek().loops |= step.loops;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     return step.loops;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
          }
      }
  
<span class="line-modified">!     private long fixLoopBits(BciBlock initialBlock) {</span>
<span class="line-modified">!         ArrayDeque&lt;TraversalStep&gt; workStack = new ArrayDeque&lt;&gt;();</span>
<span class="line-modified">!         workStack.push(new TraversalStep(initialBlock));</span>
<span class="line-modified">!         while (true) {</span>
<span class="line-modified">!             TraversalStep step = workStack.peek();</span>
<span class="line-modified">!             BciBlock block = step.block;</span>
<span class="line-modified">!             if (step.currentSuccessorIndex == 0) {</span>
<span class="line-added">+                 block.visited = true;</span>
<span class="line-added">+                 step.loops = block.loops;</span>
              }
<span class="line-modified">!             if (step.currentSuccessorIndex &lt; block.getSuccessors().size()) {</span>
<span class="line-added">+                 BciBlock successor = block.getSuccessors().get(step.currentSuccessorIndex);</span>
<span class="line-added">+                 if (successor.visited) {</span>
<span class="line-added">+                     // Return cached loop information for this block.</span>
<span class="line-added">+                     if (successor.isLoopHeader) {</span>
<span class="line-added">+                         step.loops |= successor.loops &amp; ~(1L &lt;&lt; successor.loopId);</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         step.loops |= successor.loops;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     workStack.push(new TraversalStep(successor));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 step.currentSuccessorIndex++;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 if (block.loops != step.loops) {</span>
<span class="line-added">+                     loopChanges = true;</span>
<span class="line-added">+                     block.loops = step.loops;</span>
<span class="line-added">+                     debug.log(&quot;fixLoopBits0(%s) -&gt; %x&quot;, block, block.loops);</span>
<span class="line-added">+                 }</span>
  
<span class="line-modified">!                 if (block.isLoopHeader) {</span>
<span class="line-modified">!                     step.loops &amp;= ~(1L &lt;&lt; block.loopId);</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 workStack.pop();</span>
<span class="line-modified">!                 if (!workStack.isEmpty()) {</span>
<span class="line-added">+                     workStack.peek().loops |= step.loops;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     return step.loops;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
          }
      }
  
      public static BciBlockMapping create(BytecodeStream stream, Bytecode code, OptionValues options, DebugContext debug) {
          BciBlockMapping map = new BciBlockMapping(code, debug);
          map.build(stream, options);
</pre>
<center><a href="../../../../../../org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/UnwindExceptionToCallerStub.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeParser.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
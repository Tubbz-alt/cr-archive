<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BciBlockMapping.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.java;
  26 
  27 import static org.graalvm.compiler.bytecode.Bytecodes.AALOAD;
  28 import static org.graalvm.compiler.bytecode.Bytecodes.AASTORE;
<a name="2" id="anc2"></a><span class="line-added">  29 import static org.graalvm.compiler.bytecode.Bytecodes.ACONST_NULL;</span>
<span class="line-added">  30 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD;</span>
<span class="line-added">  31 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_0;</span>
<span class="line-added">  32 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_1;</span>
<span class="line-added">  33 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_2;</span>
<span class="line-added">  34 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_3;</span>
  35 import static org.graalvm.compiler.bytecode.Bytecodes.ANEWARRAY;
  36 import static org.graalvm.compiler.bytecode.Bytecodes.ARETURN;
  37 import static org.graalvm.compiler.bytecode.Bytecodes.ARRAYLENGTH;
<a name="3" id="anc3"></a><span class="line-added">  38 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE;</span>
<span class="line-added">  39 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_0;</span>
<span class="line-added">  40 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_1;</span>
<span class="line-added">  41 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_2;</span>
<span class="line-added">  42 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_3;</span>
  43 import static org.graalvm.compiler.bytecode.Bytecodes.ATHROW;
  44 import static org.graalvm.compiler.bytecode.Bytecodes.BALOAD;
  45 import static org.graalvm.compiler.bytecode.Bytecodes.BASTORE;
<a name="4" id="anc4"></a><span class="line-added">  46 import static org.graalvm.compiler.bytecode.Bytecodes.BIPUSH;</span>
<span class="line-added">  47 import static org.graalvm.compiler.bytecode.Bytecodes.BREAKPOINT;</span>
  48 import static org.graalvm.compiler.bytecode.Bytecodes.CALOAD;
  49 import static org.graalvm.compiler.bytecode.Bytecodes.CASTORE;
  50 import static org.graalvm.compiler.bytecode.Bytecodes.CHECKCAST;
<a name="5" id="anc5"></a><span class="line-added">  51 import static org.graalvm.compiler.bytecode.Bytecodes.D2F;</span>
<span class="line-added">  52 import static org.graalvm.compiler.bytecode.Bytecodes.D2I;</span>
<span class="line-added">  53 import static org.graalvm.compiler.bytecode.Bytecodes.D2L;</span>
<span class="line-added">  54 import static org.graalvm.compiler.bytecode.Bytecodes.DADD;</span>
  55 import static org.graalvm.compiler.bytecode.Bytecodes.DALOAD;
  56 import static org.graalvm.compiler.bytecode.Bytecodes.DASTORE;
<a name="6" id="anc6"></a><span class="line-added">  57 import static org.graalvm.compiler.bytecode.Bytecodes.DCMPG;</span>
<span class="line-added">  58 import static org.graalvm.compiler.bytecode.Bytecodes.DCMPL;</span>
<span class="line-added">  59 import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_0;</span>
<span class="line-added">  60 import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_1;</span>
<span class="line-added">  61 import static org.graalvm.compiler.bytecode.Bytecodes.DDIV;</span>
<span class="line-added">  62 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD;</span>
<span class="line-added">  63 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_0;</span>
<span class="line-added">  64 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_1;</span>
<span class="line-added">  65 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_2;</span>
<span class="line-added">  66 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_3;</span>
<span class="line-added">  67 import static org.graalvm.compiler.bytecode.Bytecodes.DMUL;</span>
<span class="line-added">  68 import static org.graalvm.compiler.bytecode.Bytecodes.DNEG;</span>
<span class="line-added">  69 import static org.graalvm.compiler.bytecode.Bytecodes.DREM;</span>
  70 import static org.graalvm.compiler.bytecode.Bytecodes.DRETURN;
<a name="7" id="anc7"></a><span class="line-added">  71 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE;</span>
<span class="line-added">  72 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_0;</span>
<span class="line-added">  73 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_1;</span>
<span class="line-added">  74 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_2;</span>
<span class="line-added">  75 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_3;</span>
<span class="line-added">  76 import static org.graalvm.compiler.bytecode.Bytecodes.DSUB;</span>
<span class="line-added">  77 import static org.graalvm.compiler.bytecode.Bytecodes.DUP;</span>
<span class="line-added">  78 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2;</span>
<span class="line-added">  79 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X1;</span>
<span class="line-added">  80 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X2;</span>
<span class="line-added">  81 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X1;</span>
<span class="line-added">  82 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X2;</span>
<span class="line-added">  83 import static org.graalvm.compiler.bytecode.Bytecodes.F2D;</span>
<span class="line-added">  84 import static org.graalvm.compiler.bytecode.Bytecodes.F2I;</span>
<span class="line-added">  85 import static org.graalvm.compiler.bytecode.Bytecodes.F2L;</span>
<span class="line-added">  86 import static org.graalvm.compiler.bytecode.Bytecodes.FADD;</span>
  87 import static org.graalvm.compiler.bytecode.Bytecodes.FALOAD;
  88 import static org.graalvm.compiler.bytecode.Bytecodes.FASTORE;
<a name="8" id="anc8"></a><span class="line-added">  89 import static org.graalvm.compiler.bytecode.Bytecodes.FCMPG;</span>
<span class="line-added">  90 import static org.graalvm.compiler.bytecode.Bytecodes.FCMPL;</span>
<span class="line-added">  91 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_0;</span>
<span class="line-added">  92 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_1;</span>
<span class="line-added">  93 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_2;</span>
<span class="line-added">  94 import static org.graalvm.compiler.bytecode.Bytecodes.FDIV;</span>
<span class="line-added">  95 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD;</span>
<span class="line-added">  96 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_0;</span>
<span class="line-added">  97 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_1;</span>
<span class="line-added">  98 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_2;</span>
<span class="line-added">  99 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_3;</span>
<span class="line-added"> 100 import static org.graalvm.compiler.bytecode.Bytecodes.FMUL;</span>
<span class="line-added"> 101 import static org.graalvm.compiler.bytecode.Bytecodes.FNEG;</span>
<span class="line-added"> 102 import static org.graalvm.compiler.bytecode.Bytecodes.FREM;</span>
 103 import static org.graalvm.compiler.bytecode.Bytecodes.FRETURN;
<a name="9" id="anc9"></a><span class="line-added"> 104 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE;</span>
<span class="line-added"> 105 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_0;</span>
<span class="line-added"> 106 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_1;</span>
<span class="line-added"> 107 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_2;</span>
<span class="line-added"> 108 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_3;</span>
<span class="line-added"> 109 import static org.graalvm.compiler.bytecode.Bytecodes.FSUB;</span>
 110 import static org.graalvm.compiler.bytecode.Bytecodes.GETFIELD;
 111 import static org.graalvm.compiler.bytecode.Bytecodes.GETSTATIC;
 112 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO;
 113 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO_W;
<a name="10" id="anc10"></a><span class="line-added"> 114 import static org.graalvm.compiler.bytecode.Bytecodes.I2B;</span>
<span class="line-added"> 115 import static org.graalvm.compiler.bytecode.Bytecodes.I2C;</span>
<span class="line-added"> 116 import static org.graalvm.compiler.bytecode.Bytecodes.I2D;</span>
<span class="line-added"> 117 import static org.graalvm.compiler.bytecode.Bytecodes.I2F;</span>
<span class="line-added"> 118 import static org.graalvm.compiler.bytecode.Bytecodes.I2L;</span>
<span class="line-added"> 119 import static org.graalvm.compiler.bytecode.Bytecodes.I2S;</span>
<span class="line-added"> 120 import static org.graalvm.compiler.bytecode.Bytecodes.IADD;</span>
 121 import static org.graalvm.compiler.bytecode.Bytecodes.IALOAD;
<a name="11" id="anc11"></a><span class="line-added"> 122 import static org.graalvm.compiler.bytecode.Bytecodes.IAND;</span>
 123 import static org.graalvm.compiler.bytecode.Bytecodes.IASTORE;
<a name="12" id="anc12"></a><span class="line-added"> 124 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_0;</span>
<span class="line-added"> 125 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_1;</span>
<span class="line-added"> 126 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_2;</span>
<span class="line-added"> 127 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_3;</span>
<span class="line-added"> 128 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_4;</span>
<span class="line-added"> 129 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_5;</span>
<span class="line-added"> 130 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_M1;</span>
 131 import static org.graalvm.compiler.bytecode.Bytecodes.IDIV;
 132 import static org.graalvm.compiler.bytecode.Bytecodes.IFEQ;
 133 import static org.graalvm.compiler.bytecode.Bytecodes.IFGE;
 134 import static org.graalvm.compiler.bytecode.Bytecodes.IFGT;
 135 import static org.graalvm.compiler.bytecode.Bytecodes.IFLE;
 136 import static org.graalvm.compiler.bytecode.Bytecodes.IFLT;
 137 import static org.graalvm.compiler.bytecode.Bytecodes.IFNE;
 138 import static org.graalvm.compiler.bytecode.Bytecodes.IFNONNULL;
 139 import static org.graalvm.compiler.bytecode.Bytecodes.IFNULL;
 140 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPEQ;
 141 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPNE;
 142 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPEQ;
 143 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGE;
 144 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGT;
 145 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLE;
 146 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLT;
 147 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPNE;
<a name="13" id="anc13"></a><span class="line-added"> 148 import static org.graalvm.compiler.bytecode.Bytecodes.IINC;</span>
<span class="line-added"> 149 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD;</span>
<span class="line-added"> 150 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_0;</span>
<span class="line-added"> 151 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_1;</span>
<span class="line-added"> 152 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_2;</span>
<span class="line-added"> 153 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_3;</span>
<span class="line-added"> 154 import static org.graalvm.compiler.bytecode.Bytecodes.IMUL;</span>
<span class="line-added"> 155 import static org.graalvm.compiler.bytecode.Bytecodes.INEG;</span>
<span class="line-added"> 156 import static org.graalvm.compiler.bytecode.Bytecodes.INSTANCEOF;</span>
 157 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEDYNAMIC;
 158 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEINTERFACE;
 159 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESPECIAL;
 160 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESTATIC;
 161 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEVIRTUAL;
<a name="14" id="anc14"></a><span class="line-added"> 162 import static org.graalvm.compiler.bytecode.Bytecodes.IOR;</span>
 163 import static org.graalvm.compiler.bytecode.Bytecodes.IREM;
 164 import static org.graalvm.compiler.bytecode.Bytecodes.IRETURN;
<a name="15" id="anc15"></a><span class="line-added"> 165 import static org.graalvm.compiler.bytecode.Bytecodes.ISHL;</span>
<span class="line-added"> 166 import static org.graalvm.compiler.bytecode.Bytecodes.ISHR;</span>
<span class="line-added"> 167 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE;</span>
<span class="line-added"> 168 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_0;</span>
<span class="line-added"> 169 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_1;</span>
<span class="line-added"> 170 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_2;</span>
<span class="line-added"> 171 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_3;</span>
<span class="line-added"> 172 import static org.graalvm.compiler.bytecode.Bytecodes.ISUB;</span>
<span class="line-added"> 173 import static org.graalvm.compiler.bytecode.Bytecodes.IUSHR;</span>
<span class="line-added"> 174 import static org.graalvm.compiler.bytecode.Bytecodes.IXOR;</span>
 175 import static org.graalvm.compiler.bytecode.Bytecodes.JSR;
 176 import static org.graalvm.compiler.bytecode.Bytecodes.JSR_W;
<a name="16" id="anc16"></a><span class="line-added"> 177 import static org.graalvm.compiler.bytecode.Bytecodes.L2D;</span>
<span class="line-added"> 178 import static org.graalvm.compiler.bytecode.Bytecodes.L2F;</span>
<span class="line-added"> 179 import static org.graalvm.compiler.bytecode.Bytecodes.L2I;</span>
<span class="line-added"> 180 import static org.graalvm.compiler.bytecode.Bytecodes.LADD;</span>
 181 import static org.graalvm.compiler.bytecode.Bytecodes.LALOAD;
<a name="17" id="anc17"></a><span class="line-added"> 182 import static org.graalvm.compiler.bytecode.Bytecodes.LAND;</span>
 183 import static org.graalvm.compiler.bytecode.Bytecodes.LASTORE;
<a name="18" id="anc18"></a><span class="line-added"> 184 import static org.graalvm.compiler.bytecode.Bytecodes.LCMP;</span>
<span class="line-added"> 185 import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_0;</span>
<span class="line-added"> 186 import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_1;</span>
 187 import static org.graalvm.compiler.bytecode.Bytecodes.LDC;
 188 import static org.graalvm.compiler.bytecode.Bytecodes.LDC2_W;
 189 import static org.graalvm.compiler.bytecode.Bytecodes.LDC_W;
 190 import static org.graalvm.compiler.bytecode.Bytecodes.LDIV;
<a name="19" id="anc19"></a><span class="line-added"> 191 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD;</span>
<span class="line-added"> 192 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_0;</span>
<span class="line-added"> 193 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_1;</span>
<span class="line-added"> 194 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_2;</span>
<span class="line-added"> 195 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_3;</span>
<span class="line-added"> 196 import static org.graalvm.compiler.bytecode.Bytecodes.LMUL;</span>
<span class="line-added"> 197 import static org.graalvm.compiler.bytecode.Bytecodes.LNEG;</span>
 198 import static org.graalvm.compiler.bytecode.Bytecodes.LOOKUPSWITCH;
<a name="20" id="anc20"></a><span class="line-added"> 199 import static org.graalvm.compiler.bytecode.Bytecodes.LOR;</span>
 200 import static org.graalvm.compiler.bytecode.Bytecodes.LREM;
 201 import static org.graalvm.compiler.bytecode.Bytecodes.LRETURN;
<a name="21" id="anc21"></a><span class="line-added"> 202 import static org.graalvm.compiler.bytecode.Bytecodes.LSHL;</span>
<span class="line-added"> 203 import static org.graalvm.compiler.bytecode.Bytecodes.LSHR;</span>
<span class="line-added"> 204 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE;</span>
<span class="line-added"> 205 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_0;</span>
<span class="line-added"> 206 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_1;</span>
<span class="line-added"> 207 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_2;</span>
<span class="line-added"> 208 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_3;</span>
<span class="line-added"> 209 import static org.graalvm.compiler.bytecode.Bytecodes.LSUB;</span>
<span class="line-added"> 210 import static org.graalvm.compiler.bytecode.Bytecodes.LUSHR;</span>
<span class="line-added"> 211 import static org.graalvm.compiler.bytecode.Bytecodes.LXOR;</span>
<span class="line-added"> 212 import static org.graalvm.compiler.bytecode.Bytecodes.MONITORENTER;</span>
<span class="line-added"> 213 import static org.graalvm.compiler.bytecode.Bytecodes.MONITOREXIT;</span>
 214 import static org.graalvm.compiler.bytecode.Bytecodes.MULTIANEWARRAY;
 215 import static org.graalvm.compiler.bytecode.Bytecodes.NEW;
<a name="22" id="anc22"></a><span class="line-added"> 216 import static org.graalvm.compiler.bytecode.Bytecodes.NEWARRAY;</span>
<span class="line-added"> 217 import static org.graalvm.compiler.bytecode.Bytecodes.NOP;</span>
<span class="line-added"> 218 import static org.graalvm.compiler.bytecode.Bytecodes.POP;</span>
<span class="line-added"> 219 import static org.graalvm.compiler.bytecode.Bytecodes.POP2;</span>
 220 import static org.graalvm.compiler.bytecode.Bytecodes.PUTFIELD;
 221 import static org.graalvm.compiler.bytecode.Bytecodes.PUTSTATIC;
 222 import static org.graalvm.compiler.bytecode.Bytecodes.RET;
 223 import static org.graalvm.compiler.bytecode.Bytecodes.RETURN;
 224 import static org.graalvm.compiler.bytecode.Bytecodes.SALOAD;
 225 import static org.graalvm.compiler.bytecode.Bytecodes.SASTORE;
<a name="23" id="anc23"></a><span class="line-added"> 226 import static org.graalvm.compiler.bytecode.Bytecodes.SIPUSH;</span>
<span class="line-added"> 227 import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;</span>
 228 import static org.graalvm.compiler.bytecode.Bytecodes.TABLESWITCH;
<a name="24" id="anc24"></a><span class="line-added"> 229 import static org.graalvm.compiler.bytecode.Bytecodes.WIDE;</span>
 230 import static org.graalvm.compiler.core.common.GraalOptions.SupportJsrBytecodes;
 231 
<a name="25" id="anc25"></a><span class="line-added"> 232 import java.util.ArrayDeque;</span>
 233 import java.util.ArrayList;
 234 import java.util.Arrays;
 235 import java.util.Collection;
 236 import java.util.Iterator;
 237 import java.util.List;
 238 import java.util.TreeSet;
 239 
 240 import jdk.internal.vm.compiler.collections.EconomicMap;
 241 import jdk.internal.vm.compiler.collections.Equivalence;
 242 import org.graalvm.compiler.bytecode.Bytecode;
 243 import org.graalvm.compiler.bytecode.BytecodeLookupSwitch;
 244 import org.graalvm.compiler.bytecode.BytecodeStream;
 245 import org.graalvm.compiler.bytecode.BytecodeSwitch;
 246 import org.graalvm.compiler.bytecode.BytecodeTableSwitch;
 247 import org.graalvm.compiler.bytecode.Bytecodes;
 248 import org.graalvm.compiler.core.common.PermanentBailoutException;
 249 import org.graalvm.compiler.debug.DebugContext;
<a name="26" id="anc26"></a><span class="line-added"> 250 import org.graalvm.compiler.debug.GraalError;</span>
 251 import org.graalvm.compiler.options.OptionValues;
 252 
 253 import jdk.vm.ci.code.BytecodeFrame;
 254 import jdk.vm.ci.meta.ExceptionHandler;
 255 
 256 /**
 257  * Builds a mapping between bytecodes and basic blocks and builds a conservative control flow graph
<a name="27" id="anc27"></a><span class="line-modified"> 258  * (CFG). It makes one linear pass over the bytecodes to build the CFG where it detects block</span>
 259  * headers and connects them.
 260  * &lt;p&gt;
 261  * It also creates exception dispatch blocks for exception handling. These blocks are between a
 262  * bytecode that might throw an exception, and the actual exception handler entries, and are later
 263  * used to create the type checks with the exception handler catch types. If a bytecode is covered
 264  * by an exception handler, this bytecode ends the basic block. This guarantees that a) control flow
 265  * cannot be transferred to an exception dispatch block in the middle of a block, and b) that every
 266  * block has at most one exception dispatch block (which is always the last entry in the successor
 267  * list).
 268  * &lt;p&gt;
 269  * If a bytecode is covered by multiple exception handlers, a chain of exception dispatch blocks is
 270  * created so that multiple exception handler types can be checked. The chains are re-used if
 271  * multiple bytecodes are covered by the same exception handlers.
 272  * &lt;p&gt;
 273  * Note that exception unwinds, i.e., bytecodes that can throw an exception but the exception is not
 274  * handled in this method, do not end a basic block. Not modeling the exception unwind block reduces
 275  * the complexity of the CFG, and there is no algorithm yet where the exception unwind block would
 276  * matter.
 277  * &lt;p&gt;
 278  * The class also handles subroutines (jsr and ret bytecodes): subroutines are inlined by
 279  * duplicating the subroutine blocks. This is limited to simple, structured subroutines with a
 280  * maximum subroutine nesting of 4. Otherwise, a bailout is thrown.
 281  * &lt;p&gt;
 282  * Loops in the methods are detected. If a method contains an irreducible loop (a loop with more
 283  * than one entry), a bailout is thrown. This simplifies the compiler later on since only structured
 284  * loops need to be supported.
 285  * &lt;p&gt;
 286  * A data flow analysis computes the live local variables from the point of view of the interpreter.
 287  * The result is used later to prune frame states, i.e., remove local variable entries that are
 288  * guaranteed to be never used again (even in the case of deoptimization).
 289  * &lt;p&gt;
 290  * The algorithms and analysis in this class are conservative and do not use any assumptions or
 291  * profiling information.
 292  */
 293 public final class BciBlockMapping {
 294 
 295     public static class BciBlock implements Cloneable {
 296 
 297         int id;
 298         final int startBci;
<a name="28" id="anc28"></a><span class="line-modified"> 299         int endBci; // The bci of the last bytecode in the block</span>
 300         private boolean isExceptionEntry;
 301         private boolean isLoopHeader;
 302         int loopId;
 303         int loopEnd;
 304         List&lt;BciBlock&gt; successors;
 305         private int predecessorCount;
 306 
 307         private boolean visited;
 308         private boolean active;
 309         long loops;
 310         JSRData jsrData;
 311 
 312         public static class JSRData implements Cloneable {
 313             public EconomicMap&lt;JsrScope, BciBlock&gt; jsrAlternatives;
 314             public JsrScope jsrScope = JsrScope.EMPTY_SCOPE;
 315             public BciBlock jsrSuccessor;
 316             public int jsrReturnBci;
 317             public BciBlock retSuccessor;
 318             public boolean endsWithRet = false;
 319 
 320             public JSRData copy() {
 321                 try {
 322                     return (JSRData) this.clone();
 323                 } catch (CloneNotSupportedException e) {
 324                     return null;
 325                 }
 326             }
 327         }
 328 
 329         BciBlock(int startBci) {
 330             this.startBci = startBci;
 331             this.successors = new ArrayList&lt;&gt;();
 332         }
 333 
 334         public int getStartBci() {
 335             return startBci;
 336         }
 337 
 338         public int getEndBci() {
 339             return endBci;
 340         }
 341 
 342         public long getLoops() {
 343             return loops;
 344         }
 345 
 346         public BciBlock exceptionDispatchBlock() {
 347             if (successors.size() &gt; 0 &amp;&amp; successors.get(successors.size() - 1) instanceof ExceptionDispatchBlock) {
 348                 return successors.get(successors.size() - 1);
 349             }
 350             return null;
 351         }
 352 
 353         public int getId() {
 354             return id;
 355         }
 356 
 357         public int getPredecessorCount() {
 358             return this.predecessorCount;
 359         }
 360 
 361         public int numNormalSuccessors() {
 362             if (exceptionDispatchBlock() != null) {
 363                 return successors.size() - 1;
 364             }
 365             return successors.size();
 366         }
 367 
 368         public BciBlock copy() {
 369             try {
 370                 BciBlock block = (BciBlock) super.clone();
 371                 if (block.jsrData != null) {
 372                     block.jsrData = block.jsrData.copy();
 373                 }
 374                 block.successors = new ArrayList&lt;&gt;(successors);
 375                 return block;
 376             } catch (CloneNotSupportedException e) {
 377                 throw new RuntimeException(e);
 378             }
 379         }
 380 
 381         @Override
 382         public String toString() {
 383             StringBuilder sb = new StringBuilder(&quot;B&quot;).append(getId());
 384             sb.append(&#39;[&#39;).append(startBci).append(&quot;..&quot;).append(endBci);
 385             if (isLoopHeader || isExceptionEntry || this instanceof ExceptionDispatchBlock) {
 386                 sb.append(&#39; &#39;);
 387                 if (isLoopHeader) {
 388                     sb.append(&#39;L&#39;);
 389                 }
 390                 if (isExceptionEntry) {
 391                     sb.append(&#39;!&#39;);
 392                 } else if (this instanceof ExceptionDispatchBlock) {
 393                     sb.append(&quot;&lt;!&gt;&quot;);
 394                 }
 395             }
 396             sb.append(&#39;]&#39;);
 397             return sb.toString();
 398         }
 399 
 400         public int getLoopDepth() {
 401             return Long.bitCount(loops);
 402         }
 403 
 404         public boolean isLoopHeader() {
 405             return isLoopHeader;
 406         }
 407 
 408         public boolean isExceptionEntry() {
 409             return isExceptionEntry;
 410         }
 411 
 412         public BciBlock getSuccessor(int index) {
 413             return successors.get(index);
 414         }
 415 
 416         /**
 417          * Get the loop id of the inner most loop.
 418          *
 419          * @return the loop id of the most inner loop or -1 if not part of any loop
 420          */
 421         public int getLoopId() {
 422             long l = loops;
 423             if (l == 0) {
 424                 return -1;
 425             }
 426             int pos = 0;
 427             for (int lMask = 1; (l &amp; lMask) == 0; lMask = lMask &lt;&lt; 1) {
 428                 pos++;
 429             }
 430             return pos;
 431         }
 432 
 433         /**
 434          * Iterate over loop ids.
 435          */
 436         public Iterable&lt;Integer&gt; loopIdIterable() {
 437             return new Iterable&lt;Integer&gt;() {
 438                 @Override
 439                 public Iterator&lt;Integer&gt; iterator() {
 440                     return idIterator(loops);
 441                 }
 442             };
 443         }
 444 
 445         private static Iterator&lt;Integer&gt; idIterator(long field) {
 446             return new Iterator&lt;Integer&gt;() {
 447 
 448                 long l = field;
 449                 int pos = 0;
 450                 int lMask = 1;
 451 
 452                 @Override
 453                 public Integer next() {
 454                     for (; (l &amp; lMask) == 0; lMask = lMask &lt;&lt; 1) {
 455                         pos++;
 456                     }
 457                     l &amp;= ~lMask;
 458                     return pos;
 459                 }
 460 
 461                 @Override
 462                 public boolean hasNext() {
 463                     return l != 0;
 464                 }
 465             };
 466 
 467         }
 468 
 469         public double probability() {
 470             return 1D;
 471         }
 472 
 473         public BciBlock getPostdominator() {
 474             return null;
 475         }
 476 
 477         private JSRData getOrCreateJSRData() {
 478             if (jsrData == null) {
 479                 jsrData = new JSRData();
 480             }
 481             return jsrData;
 482         }
 483 
 484         void setEndsWithRet() {
 485             getOrCreateJSRData().endsWithRet = true;
 486         }
 487 
 488         public JsrScope getJsrScope() {
 489             if (this.jsrData == null) {
 490                 return JsrScope.EMPTY_SCOPE;
 491             } else {
 492                 return jsrData.jsrScope;
 493             }
 494         }
 495 
 496         public boolean endsWithRet() {
 497             if (this.jsrData == null) {
 498                 return false;
 499             } else {
 500                 return jsrData.endsWithRet;
 501             }
 502         }
 503 
 504         void setRetSuccessor(BciBlock bciBlock) {
 505             this.getOrCreateJSRData().retSuccessor = bciBlock;
 506         }
 507 
 508         public BciBlock getRetSuccessor() {
 509             if (this.jsrData == null) {
 510                 return null;
 511             } else {
 512                 return jsrData.retSuccessor;
 513             }
 514         }
 515 
 516         public BciBlock getJsrSuccessor() {
 517             if (this.jsrData == null) {
 518                 return null;
 519             } else {
 520                 return jsrData.jsrSuccessor;
 521             }
 522         }
 523 
 524         public int getJsrReturnBci() {
 525             if (this.jsrData == null) {
 526                 return -1;
 527             } else {
 528                 return jsrData.jsrReturnBci;
 529             }
 530         }
 531 
 532         public EconomicMap&lt;JsrScope, BciBlock&gt; getJsrAlternatives() {
 533             if (this.jsrData == null) {
 534                 return null;
 535             } else {
 536                 return jsrData.jsrAlternatives;
 537             }
 538         }
 539 
 540         public void initJsrAlternatives() {
 541             JSRData data = this.getOrCreateJSRData();
 542             if (data.jsrAlternatives == null) {
 543                 data.jsrAlternatives = EconomicMap.create(Equivalence.DEFAULT);
 544             }
 545         }
 546 
 547         void setJsrScope(JsrScope nextScope) {
 548             this.getOrCreateJSRData().jsrScope = nextScope;
 549         }
 550 
 551         void setJsrSuccessor(BciBlock clone) {
 552             this.getOrCreateJSRData().jsrSuccessor = clone;
 553         }
 554 
 555         void setJsrReturnBci(int bci) {
 556             this.getOrCreateJSRData().jsrReturnBci = bci;
 557         }
 558 
 559         public int getSuccessorCount() {
 560             return successors.size();
 561         }
 562 
 563         public List&lt;BciBlock&gt; getSuccessors() {
 564             return successors;
 565         }
 566 
 567         void setId(int i) {
 568             this.id = i;
 569         }
 570 
 571         public void addSuccessor(BciBlock sux) {
 572             successors.add(sux);
 573             sux.predecessorCount++;
 574         }
 575 
 576         public void clearSucccessors() {
 577             for (BciBlock sux : successors) {
 578                 sux.predecessorCount--;
 579             }
 580             successors.clear();
 581         }
 582 
 583         public boolean isExceptionDispatch() {
 584             return false;
 585         }
 586     }
 587 
 588     public static class ExceptionDispatchBlock extends BciBlock {
 589         public final ExceptionHandler handler;
 590         public final int deoptBci;
 591 
 592         /**
 593          * Constructor for a normal dispatcher.
 594          */
 595         ExceptionDispatchBlock(ExceptionHandler handler, int deoptBci) {
 596             super(handler.getHandlerBCI());
 597             this.endBci = startBci;
 598             this.deoptBci = deoptBci;
 599             this.handler = handler;
 600         }
 601 
 602         /**
 603          * Constructor for the method unwind dispatcher.
 604          */
 605         ExceptionDispatchBlock(int deoptBci) {
 606             super(deoptBci);
 607             this.endBci = deoptBci;
 608             this.deoptBci = deoptBci;
 609             this.handler = null;
 610         }
 611 
 612         @Override
 613         public boolean isExceptionDispatch() {
 614             return true;
 615         }
 616     }
 617 
<a name="29" id="anc29"></a><span class="line-added"> 618     private static final class TraversalStep {</span>
<span class="line-added"> 619         private BciBlock block;</span>
<span class="line-added"> 620         private int currentSuccessorIndex;</span>
<span class="line-added"> 621         private long loops;</span>
<span class="line-added"> 622 </span>
<span class="line-added"> 623         private TraversalStep(BciBlock block) {</span>
<span class="line-added"> 624             this.block = block;</span>
<span class="line-added"> 625             this.currentSuccessorIndex = 0;</span>
<span class="line-added"> 626             this.loops = 0;</span>
<span class="line-added"> 627         }</span>
<span class="line-added"> 628     }</span>
<span class="line-added"> 629 </span>
 630     /**
 631      * The blocks found in this method, in reverse postorder.
 632      */
 633     private BciBlock[] blocks;
 634     public final Bytecode code;
 635     public boolean hasJsrBytecodes;
 636 
 637     private final ExceptionHandler[] exceptionHandlers;
 638     private BciBlock startBlock;
 639     private BciBlock[] loopHeaders;
 640 
 641     private static final int LOOP_HEADER_MAX_CAPACITY = Long.SIZE;
 642     private static final int LOOP_HEADER_INITIAL_CAPACITY = 4;
 643 
 644     private int blocksNotYetAssignedId;
 645     private final DebugContext debug;
 646 
 647     /**
 648      * Creates a new BlockMap instance from {@code code}.
 649      */
 650     private BciBlockMapping(Bytecode code, DebugContext debug) {
 651         this.code = code;
 652         this.debug = debug;
 653         this.exceptionHandlers = code.getExceptionHandlers();
 654     }
 655 
 656     public BciBlock[] getBlocks() {
 657         return this.blocks;
 658     }
 659 
 660     /**
 661      * Builds the block map and conservative CFG and numbers blocks.
 662      */
 663     public void build(BytecodeStream stream, OptionValues options) {
 664         int codeSize = code.getCodeSize();
 665         BciBlock[] blockMap = new BciBlock[codeSize];
 666         makeExceptionEntries(blockMap);
 667         iterateOverBytecodes(blockMap, stream);
 668         if (hasJsrBytecodes) {
 669             if (!SupportJsrBytecodes.getValue(options)) {
 670                 throw new JsrNotSupportedBailout(&quot;jsr/ret parsing disabled&quot;);
 671             }
 672             createJsrAlternatives(blockMap, blockMap[0]);
 673         }
 674         if (debug.isLogEnabled()) {
 675             this.log(blockMap, &quot;Before BlockOrder&quot;);
 676         }
 677         computeBlockOrder(blockMap);
 678         fixLoopBits(blockMap);
 679 
 680         assert verify();
 681 
 682         startBlock = blockMap[0];
 683         if (debug.isLogEnabled()) {
 684             this.log(blockMap, &quot;Before LivenessAnalysis&quot;);
 685         }
 686     }
 687 
 688     private boolean verify() {
 689         for (BciBlock block : blocks) {
 690             assert blocks[block.getId()] == block;
 691             for (int i = 0; i &lt; block.getSuccessorCount(); i++) {
 692                 BciBlock sux = block.getSuccessor(i);
 693                 if (sux instanceof ExceptionDispatchBlock) {
 694                     assert i == block.getSuccessorCount() - 1 : &quot;Only one exception handler allowed, and it must be last in successors list&quot;;
 695                 }
 696             }
 697         }
 698 
 699         return true;
 700     }
 701 
 702     private void makeExceptionEntries(BciBlock[] blockMap) {
 703         // start basic blocks at all exception handler blocks and mark them as exception entries
 704         for (ExceptionHandler h : this.exceptionHandlers) {
 705             BciBlock xhandler = makeBlock(blockMap, h.getHandlerBCI());
 706             xhandler.isExceptionEntry = true;
 707         }
 708     }
 709 
 710     private void iterateOverBytecodes(BciBlock[] blockMap, BytecodeStream stream) {
 711         // iterate over the bytecodes top to bottom.
 712         // mark the entrypoints of basic blocks and build lists of successors for
 713         // all bytecodes that end basic blocks (i.e. goto, ifs, switches, throw, jsr, returns, ret)
 714         BciBlock current = null;
 715         stream.setBCI(0);
 716         while (stream.currentBC() != Bytecodes.END) {
 717             int bci = stream.currentBCI();
 718 
 719             if (current == null || blockMap[bci] != null) {
 720                 BciBlock b = makeBlock(blockMap, bci);
 721                 if (current != null) {
 722                     addSuccessor(blockMap, current.endBci, b);
 723                 }
 724                 current = b;
 725             }
 726             blockMap[bci] = current;
 727             current.endBci = bci;
 728 
 729             switch (stream.currentBC()) {
 730                 case IRETURN: // fall through
 731                 case LRETURN: // fall through
 732                 case FRETURN: // fall through
 733                 case DRETURN: // fall through
 734                 case ARETURN: // fall through
 735                 case RETURN: {
 736                     current = null;
 737                     break;
 738                 }
 739                 case ATHROW: {
 740                     current = null;
 741                     ExceptionDispatchBlock handler = handleExceptions(blockMap, bci);
 742                     if (handler != null) {
 743                         addSuccessor(blockMap, bci, handler);
 744                     }
 745                     break;
 746                 }
 747                 case IFEQ:      // fall through
 748                 case IFNE:      // fall through
 749                 case IFLT:      // fall through
 750                 case IFGE:      // fall through
 751                 case IFGT:      // fall through
 752                 case IFLE:      // fall through
 753                 case IF_ICMPEQ: // fall through
 754                 case IF_ICMPNE: // fall through
 755                 case IF_ICMPLT: // fall through
 756                 case IF_ICMPGE: // fall through
 757                 case IF_ICMPGT: // fall through
 758                 case IF_ICMPLE: // fall through
 759                 case IF_ACMPEQ: // fall through
 760                 case IF_ACMPNE: // fall through
 761                 case IFNULL:    // fall through
 762                 case IFNONNULL: {
 763                     current = null;
 764                     addSuccessor(blockMap, bci, makeBlock(blockMap, stream.readBranchDest()));
 765                     addSuccessor(blockMap, bci, makeBlock(blockMap, stream.nextBCI()));
 766                     break;
 767                 }
 768                 case GOTO:
 769                 case GOTO_W: {
 770                     current = null;
 771                     addSuccessor(blockMap, bci, makeBlock(blockMap, stream.readBranchDest()));
 772                     break;
 773                 }
 774                 case TABLESWITCH: {
 775                     current = null;
 776                     addSwitchSuccessors(blockMap, bci, new BytecodeTableSwitch(stream, bci));
 777                     break;
 778                 }
 779                 case LOOKUPSWITCH: {
 780                     current = null;
 781                     addSwitchSuccessors(blockMap, bci, new BytecodeLookupSwitch(stream, bci));
 782                     break;
 783                 }
 784                 case JSR:
 785                 case JSR_W: {
 786                     hasJsrBytecodes = true;
 787                     int target = stream.readBranchDest();
 788                     if (target == 0) {
 789                         throw new JsrNotSupportedBailout(&quot;jsr target bci 0 not allowed&quot;);
 790                     }
 791                     BciBlock b1 = makeBlock(blockMap, target);
 792                     current.setJsrSuccessor(b1);
 793                     current.setJsrReturnBci(stream.nextBCI());
 794                     current = null;
 795                     addSuccessor(blockMap, bci, b1);
 796                     break;
 797                 }
 798                 case RET: {
 799                     current.setEndsWithRet();
 800                     current = null;
 801                     break;
 802                 }
 803                 case INVOKEINTERFACE:
 804                 case INVOKESPECIAL:
 805                 case INVOKESTATIC:
 806                 case INVOKEVIRTUAL:
 807                 case INVOKEDYNAMIC: {
 808                     current = null;
 809                     addSuccessor(blockMap, bci, makeBlock(blockMap, stream.nextBCI()));
 810                     ExceptionDispatchBlock handler = handleExceptions(blockMap, bci);
 811                     if (handler != null) {
 812                         addSuccessor(blockMap, bci, handler);
 813                     }
 814                     break;
 815                 }
 816                 case IDIV:
 817                 case IREM:
 818                 case LDIV:
 819                 case LREM:
 820                 case IASTORE:
 821                 case LASTORE:
 822                 case FASTORE:
 823                 case DASTORE:
 824                 case AASTORE:
 825                 case BASTORE:
 826                 case CASTORE:
 827                 case SASTORE:
 828                 case IALOAD:
 829                 case LALOAD:
 830                 case FALOAD:
 831                 case DALOAD:
 832                 case AALOAD:
 833                 case BALOAD:
 834                 case CALOAD:
 835                 case SALOAD:
 836                 case ARRAYLENGTH:
 837                 case CHECKCAST:
<a name="30" id="anc30"></a><span class="line-added"> 838                 case INSTANCEOF:</span>
 839                 case NEW:
<a name="31" id="anc31"></a><span class="line-added"> 840                 case NEWARRAY:</span>
 841                 case ANEWARRAY:
 842                 case MULTIANEWARRAY:
 843                 case PUTSTATIC:
 844                 case GETSTATIC:
 845                 case PUTFIELD:
 846                 case GETFIELD:
 847                 case LDC:
 848                 case LDC_W:
<a name="32" id="anc32"></a><span class="line-modified"> 849                 case LDC2_W:</span>
<span class="line-added"> 850                 case MONITORENTER: {</span>
 851                     /*
 852                      * All bytecodes that can trigger lazy class initialization via a
 853                      * ClassInitializationPlugin (allocations, static field access) must be listed
 854                      * because the class initializer is allowed to throw an exception, which
 855                      * requires proper exception handling.
 856                      */
 857                     ExceptionDispatchBlock handler = handleExceptions(blockMap, bci);
 858                     if (handler != null) {
 859                         current = null;
 860                         addSuccessor(blockMap, bci, makeBlock(blockMap, stream.nextBCI()));
 861                         addSuccessor(blockMap, bci, handler);
 862                     }
<a name="33" id="anc33"></a><span class="line-added"> 863                     break;</span>
 864                 }
<a name="34" id="anc34"></a><span class="line-added"> 865 </span>
<span class="line-added"> 866                 case NOP:</span>
<span class="line-added"> 867                 case ACONST_NULL:</span>
<span class="line-added"> 868                 case ICONST_M1:</span>
<span class="line-added"> 869                 case ICONST_0:</span>
<span class="line-added"> 870                 case ICONST_1:</span>
<span class="line-added"> 871                 case ICONST_2:</span>
<span class="line-added"> 872                 case ICONST_3:</span>
<span class="line-added"> 873                 case ICONST_4:</span>
<span class="line-added"> 874                 case ICONST_5:</span>
<span class="line-added"> 875                 case LCONST_0:</span>
<span class="line-added"> 876                 case LCONST_1:</span>
<span class="line-added"> 877                 case FCONST_0:</span>
<span class="line-added"> 878                 case FCONST_1:</span>
<span class="line-added"> 879                 case FCONST_2:</span>
<span class="line-added"> 880                 case DCONST_0:</span>
<span class="line-added"> 881                 case DCONST_1:</span>
<span class="line-added"> 882                 case BIPUSH:</span>
<span class="line-added"> 883                 case SIPUSH:</span>
<span class="line-added"> 884                 case ILOAD:</span>
<span class="line-added"> 885                 case LLOAD:</span>
<span class="line-added"> 886                 case FLOAD:</span>
<span class="line-added"> 887                 case DLOAD:</span>
<span class="line-added"> 888                 case ALOAD:</span>
<span class="line-added"> 889                 case ILOAD_0:</span>
<span class="line-added"> 890                 case ILOAD_1:</span>
<span class="line-added"> 891                 case ILOAD_2:</span>
<span class="line-added"> 892                 case ILOAD_3:</span>
<span class="line-added"> 893                 case LLOAD_0:</span>
<span class="line-added"> 894                 case LLOAD_1:</span>
<span class="line-added"> 895                 case LLOAD_2:</span>
<span class="line-added"> 896                 case LLOAD_3:</span>
<span class="line-added"> 897                 case FLOAD_0:</span>
<span class="line-added"> 898                 case FLOAD_1:</span>
<span class="line-added"> 899                 case FLOAD_2:</span>
<span class="line-added"> 900                 case FLOAD_3:</span>
<span class="line-added"> 901                 case DLOAD_0:</span>
<span class="line-added"> 902                 case DLOAD_1:</span>
<span class="line-added"> 903                 case DLOAD_2:</span>
<span class="line-added"> 904                 case DLOAD_3:</span>
<span class="line-added"> 905                 case ALOAD_0:</span>
<span class="line-added"> 906                 case ALOAD_1:</span>
<span class="line-added"> 907                 case ALOAD_2:</span>
<span class="line-added"> 908                 case ALOAD_3:</span>
<span class="line-added"> 909                 case ISTORE:</span>
<span class="line-added"> 910                 case LSTORE:</span>
<span class="line-added"> 911                 case FSTORE:</span>
<span class="line-added"> 912                 case DSTORE:</span>
<span class="line-added"> 913                 case ASTORE:</span>
<span class="line-added"> 914                 case ISTORE_0:</span>
<span class="line-added"> 915                 case ISTORE_1:</span>
<span class="line-added"> 916                 case ISTORE_2:</span>
<span class="line-added"> 917                 case ISTORE_3:</span>
<span class="line-added"> 918                 case LSTORE_0:</span>
<span class="line-added"> 919                 case LSTORE_1:</span>
<span class="line-added"> 920                 case LSTORE_2:</span>
<span class="line-added"> 921                 case LSTORE_3:</span>
<span class="line-added"> 922                 case FSTORE_0:</span>
<span class="line-added"> 923                 case FSTORE_1:</span>
<span class="line-added"> 924                 case FSTORE_2:</span>
<span class="line-added"> 925                 case FSTORE_3:</span>
<span class="line-added"> 926                 case DSTORE_0:</span>
<span class="line-added"> 927                 case DSTORE_1:</span>
<span class="line-added"> 928                 case DSTORE_2:</span>
<span class="line-added"> 929                 case DSTORE_3:</span>
<span class="line-added"> 930                 case ASTORE_0:</span>
<span class="line-added"> 931                 case ASTORE_1:</span>
<span class="line-added"> 932                 case ASTORE_2:</span>
<span class="line-added"> 933                 case ASTORE_3:</span>
<span class="line-added"> 934                 case POP:</span>
<span class="line-added"> 935                 case POP2:</span>
<span class="line-added"> 936                 case DUP:</span>
<span class="line-added"> 937                 case DUP_X1:</span>
<span class="line-added"> 938                 case DUP_X2:</span>
<span class="line-added"> 939                 case DUP2:</span>
<span class="line-added"> 940                 case DUP2_X1:</span>
<span class="line-added"> 941                 case DUP2_X2:</span>
<span class="line-added"> 942                 case SWAP:</span>
<span class="line-added"> 943                 case IADD:</span>
<span class="line-added"> 944                 case LADD:</span>
<span class="line-added"> 945                 case FADD:</span>
<span class="line-added"> 946                 case DADD:</span>
<span class="line-added"> 947                 case ISUB:</span>
<span class="line-added"> 948                 case LSUB:</span>
<span class="line-added"> 949                 case FSUB:</span>
<span class="line-added"> 950                 case DSUB:</span>
<span class="line-added"> 951                 case IMUL:</span>
<span class="line-added"> 952                 case LMUL:</span>
<span class="line-added"> 953                 case FMUL:</span>
<span class="line-added"> 954                 case DMUL:</span>
<span class="line-added"> 955                 case FDIV:</span>
<span class="line-added"> 956                 case DDIV:</span>
<span class="line-added"> 957                 case FREM:</span>
<span class="line-added"> 958                 case DREM:</span>
<span class="line-added"> 959                 case INEG:</span>
<span class="line-added"> 960                 case LNEG:</span>
<span class="line-added"> 961                 case FNEG:</span>
<span class="line-added"> 962                 case DNEG:</span>
<span class="line-added"> 963                 case ISHL:</span>
<span class="line-added"> 964                 case LSHL:</span>
<span class="line-added"> 965                 case ISHR:</span>
<span class="line-added"> 966                 case LSHR:</span>
<span class="line-added"> 967                 case IUSHR:</span>
<span class="line-added"> 968                 case LUSHR:</span>
<span class="line-added"> 969                 case IAND:</span>
<span class="line-added"> 970                 case LAND:</span>
<span class="line-added"> 971                 case IOR:</span>
<span class="line-added"> 972                 case LOR:</span>
<span class="line-added"> 973                 case IXOR:</span>
<span class="line-added"> 974                 case LXOR:</span>
<span class="line-added"> 975                 case IINC:</span>
<span class="line-added"> 976                 case I2L:</span>
<span class="line-added"> 977                 case I2F:</span>
<span class="line-added"> 978                 case I2D:</span>
<span class="line-added"> 979                 case L2I:</span>
<span class="line-added"> 980                 case L2F:</span>
<span class="line-added"> 981                 case L2D:</span>
<span class="line-added"> 982                 case F2I:</span>
<span class="line-added"> 983                 case F2L:</span>
<span class="line-added"> 984                 case F2D:</span>
<span class="line-added"> 985                 case D2I:</span>
<span class="line-added"> 986                 case D2L:</span>
<span class="line-added"> 987                 case D2F:</span>
<span class="line-added"> 988                 case I2B:</span>
<span class="line-added"> 989                 case I2C:</span>
<span class="line-added"> 990                 case I2S:</span>
<span class="line-added"> 991                 case LCMP:</span>
<span class="line-added"> 992                 case FCMPL:</span>
<span class="line-added"> 993                 case FCMPG:</span>
<span class="line-added"> 994                 case DCMPL:</span>
<span class="line-added"> 995                 case DCMPG:</span>
<span class="line-added"> 996                 case MONITOREXIT:</span>
<span class="line-added"> 997                     // All stack manipulation, comparison, conversion and arithmetic operators</span>
<span class="line-added"> 998                     // except for idiv and irem can&#39;t throw exceptions so the don&#39;t need to connect</span>
<span class="line-added"> 999                     // exception edges. MONITOREXIT can&#39;t throw exceptions in the context of</span>
<span class="line-added">1000                     // compiled code because of the structured locking requirement in the parser.</span>
<span class="line-added">1001                     break;</span>
<span class="line-added">1002 </span>
<span class="line-added">1003                 case WIDE:</span>
<span class="line-added">1004                 case BREAKPOINT:</span>
<span class="line-added">1005                 default:</span>
<span class="line-added">1006                     throw new GraalError(&quot;Unhandled bytecode&quot;);</span>
1007             }
1008             stream.next();
1009         }
1010     }
1011 
1012     private BciBlock makeBlock(BciBlock[] blockMap, int startBci) {
1013         BciBlock oldBlock = blockMap[startBci];
1014         if (oldBlock == null) {
1015             BciBlock newBlock = new BciBlock(startBci);
1016             blocksNotYetAssignedId++;
1017             blockMap[startBci] = newBlock;
1018             return newBlock;
1019 
1020         } else if (oldBlock.startBci != startBci) {
1021             // Backward branch into the middle of an already processed block.
1022             // Add the correct fall-through successor.
1023             BciBlock newBlock = new BciBlock(startBci);
1024             blocksNotYetAssignedId++;
1025             newBlock.endBci = oldBlock.endBci;
1026             for (BciBlock oldSuccessor : oldBlock.getSuccessors()) {
1027                 newBlock.addSuccessor(oldSuccessor);
1028             }
1029 
1030             oldBlock.endBci = startBci - 1;
1031             oldBlock.clearSucccessors();
1032             oldBlock.addSuccessor(newBlock);
1033 
1034             for (int i = startBci; i &lt;= newBlock.endBci; i++) {
1035                 blockMap[i] = newBlock;
1036             }
1037             return newBlock;
1038 
1039         } else {
1040             return oldBlock;
1041         }
1042     }
1043 
1044     private void addSwitchSuccessors(BciBlock[] blockMap, int predBci, BytecodeSwitch bswitch) {
1045         // adds distinct targets to the successor list
1046         Collection&lt;Integer&gt; targets = new TreeSet&lt;&gt;();
1047         for (int i = 0; i &lt; bswitch.numberOfCases(); i++) {
1048             targets.add(bswitch.targetAt(i));
1049         }
1050         targets.add(bswitch.defaultTarget());
1051         for (int targetBci : targets) {
1052             addSuccessor(blockMap, predBci, makeBlock(blockMap, targetBci));
1053         }
1054     }
1055 
1056     private static void addSuccessor(BciBlock[] blockMap, int predBci, BciBlock sux) {
1057         BciBlock predecessor = blockMap[predBci];
1058         if (sux.isExceptionEntry) {
1059             throw new PermanentBailoutException(&quot;Exception handler can be reached by both normal and exceptional control flow&quot;);
1060         }
1061         predecessor.addSuccessor(sux);
1062     }
1063 
1064     private final ArrayList&lt;BciBlock&gt; jsrVisited = new ArrayList&lt;&gt;();
1065 
1066     private void createJsrAlternatives(BciBlock[] blockMap, BciBlock block) {
1067         jsrVisited.add(block);
1068         JsrScope scope = block.getJsrScope();
1069 
1070         if (block.endsWithRet()) {
1071             block.setRetSuccessor(blockMap[scope.nextReturnAddress()]);
1072             block.addSuccessor(block.getRetSuccessor());
1073             assert block.getRetSuccessor() != block.getJsrSuccessor();
1074         }
1075         debug.log(&quot;JSR alternatives block %s  sux %s  jsrSux %s  retSux %s  jsrScope %s&quot;, block, block.getSuccessors(), block.getJsrSuccessor(), block.getRetSuccessor(), block.getJsrScope());
1076 
1077         if (block.getJsrSuccessor() != null || !scope.isEmpty()) {
1078             for (int i = 0; i &lt; block.getSuccessorCount(); i++) {
1079                 BciBlock successor = block.getSuccessor(i);
1080                 JsrScope nextScope = scope;
1081                 if (successor == block.getJsrSuccessor()) {
<a name="35" id="anc35"></a><span class="line-modified">1082                     nextScope = scope.push(block.getJsrReturnBci(), successor);</span>
1083                 }
1084                 if (successor == block.getRetSuccessor()) {
1085                     nextScope = scope.pop();
1086                 }
1087                 if (!successor.getJsrScope().isPrefixOf(nextScope)) {
1088                     throw new JsrNotSupportedBailout(&quot;unstructured control flow  (&quot; + successor.getJsrScope() + &quot; &quot; + nextScope + &quot;)&quot;);
1089                 }
1090                 if (!nextScope.isEmpty()) {
1091                     BciBlock clone;
1092                     if (successor.getJsrAlternatives() != null &amp;&amp; successor.getJsrAlternatives().containsKey(nextScope)) {
1093                         clone = successor.getJsrAlternatives().get(nextScope);
1094                     } else {
1095                         successor.initJsrAlternatives();
1096                         clone = successor.copy();
1097                         blocksNotYetAssignedId++;
1098                         clone.setJsrScope(nextScope);
1099                         successor.getJsrAlternatives().put(nextScope, clone);
1100                     }
1101                     block.getSuccessors().set(i, clone);
1102                     if (successor == block.getJsrSuccessor()) {
1103                         block.setJsrSuccessor(clone);
1104                     }
1105                     if (successor == block.getRetSuccessor()) {
1106                         block.setRetSuccessor(clone);
1107                     }
1108                 }
1109             }
1110         }
1111         for (BciBlock successor : block.getSuccessors()) {
<a name="36" id="anc36"></a><span class="line-modified">1112             if (!jsrVisited.contains(successor) &amp;&amp; shouldFollowEdge(successor, scope)) {</span>
1113                 createJsrAlternatives(blockMap, successor);
1114             }
1115         }
1116     }
1117 
<a name="37" id="anc37"></a><span class="line-added">1118     private static boolean shouldFollowEdge(BciBlock successor, JsrScope scope) {</span>
<span class="line-added">1119         if (successor instanceof ExceptionDispatchBlock &amp;&amp; scope.getJsrEntryBlock() != null) {</span>
<span class="line-added">1120             ExceptionDispatchBlock exceptionDispatchBlock = (ExceptionDispatchBlock) successor;</span>
<span class="line-added">1121             int bci = scope.getJsrEntryBlock().startBci;</span>
<span class="line-added">1122             if (exceptionDispatchBlock.handler.getStartBCI() &lt; bci &amp;&amp; bci &lt; exceptionDispatchBlock.handler.getEndBCI()) {</span>
<span class="line-added">1123                 // Handler covers start of JSR block and the bci before that =&gt; don&#39;t follow edge.</span>
<span class="line-added">1124                 return false;</span>
<span class="line-added">1125             }</span>
<span class="line-added">1126         }</span>
<span class="line-added">1127 </span>
<span class="line-added">1128         return true;</span>
<span class="line-added">1129     }</span>
<span class="line-added">1130 </span>
1131     private ExceptionDispatchBlock handleExceptions(BciBlock[] blockMap, int bci) {
1132         ExceptionDispatchBlock lastHandler = null;
1133         int dispatchBlocks = 0;
1134 
1135         for (int i = exceptionHandlers.length - 1; i &gt;= 0; i--) {
1136             ExceptionHandler h = exceptionHandlers[i];
1137             if (h.getStartBCI() &lt;= bci &amp;&amp; bci &lt; h.getEndBCI()) {
1138                 if (h.isCatchAll()) {
1139                     // Discard all information about succeeding exception handlers, since they can
1140                     // never be reached.
1141                     dispatchBlocks = 0;
1142                     lastHandler = null;
1143                 }
1144 
1145                 // We do not reuse exception dispatch blocks, because nested exception handlers
1146                 // might have problems reasoning about the correct frame state.
1147                 ExceptionDispatchBlock curHandler = new ExceptionDispatchBlock(h, bci);
1148                 dispatchBlocks++;
1149                 curHandler.addSuccessor(blockMap[h.getHandlerBCI()]);
1150                 if (lastHandler != null) {
1151                     curHandler.addSuccessor(lastHandler);
1152                 }
1153                 lastHandler = curHandler;
1154             }
1155         }
1156         blocksNotYetAssignedId += dispatchBlocks;
1157         return lastHandler;
1158     }
1159 
1160     private boolean loopChanges;
1161 
1162     private void fixLoopBits(BciBlock[] blockMap) {
1163         do {
1164             loopChanges = false;
1165             for (BciBlock b : blocks) {
1166                 b.visited = false;
1167             }
1168 
<a name="38" id="anc38"></a><span class="line-modified">1169             long loop = fixLoopBits(blockMap[0]);</span>
1170 
1171             if (loop != 0) {
1172                 // There is a path from a loop end to the method entry that does not pass the loop
1173                 // header.
1174                 // Therefore, the loop is non reducible (has more than one entry).
1175                 // We don&#39;t want to compile such methods because the IR only supports structured
1176                 // loops.
1177                 throw new PermanentBailoutException(&quot;Non-reducible loop: %016x&quot;, loop);
1178             }
1179         } while (loopChanges);
1180     }
1181 
1182     private void computeBlockOrder(BciBlock[] blockMap) {
1183         int maxBlocks = blocksNotYetAssignedId;
1184         this.blocks = new BciBlock[blocksNotYetAssignedId];
1185         long loop = computeBlockOrder(blockMap[0]);
1186 
1187         if (loop != 0) {
1188             // There is a path from a loop end to the method entry that does not pass the loop
1189             // header. Therefore, the loop is non reducible (has more than one entry).
1190             // We don&#39;t want to compile such methods because the IR only supports structured loops.
1191             throw new PermanentBailoutException(&quot;Non-reducible loop&quot;);
1192         }
1193 
1194         // Purge null entries for unreached blocks and sort blocks such that loop bodies are always
1195         // consecutively in the array.
1196         int blockCount = maxBlocks - blocksNotYetAssignedId + 1;
1197         BciBlock[] newBlocks = new BciBlock[blockCount];
1198         int next = 0;
1199         for (int i = 0; i &lt; blocks.length; ++i) {
1200             BciBlock b = blocks[i];
1201             if (b != null) {
1202                 b.setId(next);
1203                 newBlocks[next++] = b;
1204                 if (b.isLoopHeader) {
1205                     next = handleLoopHeader(newBlocks, next, i, b);
1206                 }
1207             }
1208         }
1209         assert next == newBlocks.length - 1;
1210 
1211         // Add unwind block.
<a name="39" id="anc39"></a><span class="line-modified">1212         ExceptionDispatchBlock unwindBlock = new ExceptionDispatchBlock(BytecodeFrame.AFTER_EXCEPTION_BCI);</span>

1213         unwindBlock.setId(newBlocks.length - 1);
1214         newBlocks[newBlocks.length - 1] = unwindBlock;
1215 
1216         blocks = newBlocks;
1217     }
1218 
1219     private int handleLoopHeader(BciBlock[] newBlocks, int nextStart, int i, BciBlock loopHeader) {
1220         int next = nextStart;
1221         int endOfLoop = nextStart - 1;
1222         for (int j = i + 1; j &lt; blocks.length; ++j) {
1223             BciBlock other = blocks[j];
1224             if (other != null &amp;&amp; (other.loops &amp; (1L &lt;&lt; loopHeader.loopId)) != 0) {
1225                 other.setId(next);
1226                 endOfLoop = next;
1227                 newBlocks[next++] = other;
1228                 blocks[j] = null;
1229                 if (other.isLoopHeader) {
1230                     next = handleLoopHeader(newBlocks, next, j, other);
1231                 }
1232             }
1233         }
1234         loopHeader.loopEnd = endOfLoop;
1235         return next;
1236     }
1237 
1238     public void log(BciBlock[] blockMap, String name) {
1239         if (debug.isLogEnabled()) {
1240             debug.log(&quot;%sBlockMap %s: %n%s&quot;, debug.getCurrentScopeName(), name, toString(blockMap, loopHeaders));
1241         }
1242     }
1243 
1244     public static String toString(BciBlock[] blockMap, BciBlock[] loopHeadersMap) {
1245         StringBuilder sb = new StringBuilder();
1246         for (BciBlock b : blockMap) {
1247             if (b == null) {
1248                 continue;
1249             }
1250             sb.append(&quot;B&quot;).append(b.getId()).append(&quot;[&quot;).append(b.startBci).append(&quot;..&quot;).append(b.endBci).append(&quot;]&quot;);
1251             if (b.isLoopHeader) {
1252                 sb.append(&quot; LoopHeader&quot;);
1253             }
1254             if (b.isExceptionEntry) {
1255                 sb.append(&quot; ExceptionEntry&quot;);
1256             }
1257             if (b instanceof ExceptionDispatchBlock) {
1258                 sb.append(&quot; ExceptionDispatch&quot;);
1259             }
1260             if (!b.successors.isEmpty()) {
1261                 sb.append(&quot; Successors=[&quot;);
1262                 for (BciBlock s : b.getSuccessors()) {
1263                     if (sb.charAt(sb.length() - 1) != &#39;[&#39;) {
1264                         sb.append(&quot;, &quot;);
1265                     }
1266                     sb.append(&quot;B&quot;).append(s.getId());
1267                 }
1268                 sb.append(&quot;]&quot;);
1269             }
1270             if (b.loops != 0L) {
1271                 sb.append(&quot; Loops=[&quot;);
1272                 for (int pos : b.loopIdIterable()) {
1273                     if (sb.charAt(sb.length() - 1) == &#39;[&#39;) {
1274                         sb.append(&quot;, &quot;);
1275                     }
1276                     sb.append(&quot;B&quot;).append(loopHeadersMap[pos].getId());
1277                 }
1278                 sb.append(&quot;]&quot;);
1279             }
1280             sb.append(System.lineSeparator());
1281         }
1282         return sb.toString();
1283     }
1284 
1285     @Override
1286     public String toString() {
1287         return toString(blocks, loopHeaders);
1288     }
1289 
1290     /**
1291      * Get the header block for a loop index.
1292      */
1293     public BciBlock getLoopHeader(int index) {
1294         return loopHeaders[index];
1295     }
1296 
1297     /**
1298      * The next available loop number.
1299      */
1300     private int nextLoop;
1301 
1302     /**
1303      * Mark the block as a loop header, using the next available loop number. Also checks for corner
1304      * cases that we don&#39;t want to compile.
1305      */
1306     private void makeLoopHeader(BciBlock block) {
1307         if (!block.isLoopHeader) {
1308             block.isLoopHeader = true;
1309 
1310             if (block.isExceptionEntry) {
1311                 // Loops that are implicitly formed by an exception handler lead to all sorts of
1312                 // corner cases.
1313                 // Don&#39;t compile such methods for now, until we see a concrete case that allows
1314                 // checking for correctness.
1315                 throw new PermanentBailoutException(&quot;Loop formed by an exception handler&quot;);
1316             }
1317             if (nextLoop &gt;= LOOP_HEADER_MAX_CAPACITY) {
1318                 // This restriction can be removed by using a fall-back to a BitSet in case we have
1319                 // more than 64 loops
1320                 // Don&#39;t compile such methods for now, until we see a concrete case that allows
1321                 // checking for correctness.
1322                 throw new PermanentBailoutException(&quot;Too many loops in method&quot;);
1323             }
1324 
1325             assert block.loops == 0;
1326             block.loops = 1L &lt;&lt; nextLoop;
1327             debug.log(&quot;makeLoopHeader(%s) -&gt; %x&quot;, block, block.loops);
1328             if (loopHeaders == null) {
1329                 loopHeaders = new BciBlock[LOOP_HEADER_INITIAL_CAPACITY];
1330             } else if (nextLoop &gt;= loopHeaders.length) {
1331                 loopHeaders = Arrays.copyOf(loopHeaders, LOOP_HEADER_MAX_CAPACITY);
1332             }
1333             loopHeaders[nextLoop] = block;
1334             block.loopId = nextLoop;
1335             nextLoop++;
1336         }
1337         assert Long.bitCount(block.loops) == 1;
1338     }
1339 
1340     /**
<a name="40" id="anc40"></a><span class="line-modified">1341      * Non-recursive depth-first traversal of the control flow graph. The flag</span>
<span class="line-modified">1342      * {@linkplain BciBlock#visited} is used to visit every block only once. The flag</span>
<span class="line-modified">1343      * {@linkplain BciBlock#active} is used to detect cycles (backward edges)</span>
1344      */
<a name="41" id="anc41"></a><span class="line-modified">1345     private long computeBlockOrder(BciBlock initialBlock) {</span>
<span class="line-modified">1346         ArrayDeque&lt;TraversalStep&gt; workStack = new ArrayDeque&lt;&gt;();</span>
<span class="line-modified">1347         workStack.push(new TraversalStep(initialBlock));</span>
<span class="line-modified">1348         while (true) {</span>
<span class="line-modified">1349             TraversalStep step = workStack.peek();</span>
<span class="line-modified">1350             BciBlock block = step.block;</span>
<span class="line-modified">1351             if (step.currentSuccessorIndex == 0) {</span>
<span class="line-modified">1352                 block.visited = true;</span>
<span class="line-modified">1353                 block.active = true;</span>
1354             } else {
<a name="42" id="anc42"></a><span class="line-modified">1355                 BciBlock successor = block.getSuccessor(step.currentSuccessorIndex - 1);</span>
<span class="line-added">1356                 if (successor.active) {</span>
<span class="line-added">1357                     // Reached block via backward branch.</span>
<span class="line-added">1358                     step.loops |= (1L &lt;&lt; successor.loopId);</span>
<span class="line-added">1359                 }</span>
1360             }
<a name="43" id="anc43"></a><span class="line-modified">1361             if (step.currentSuccessorIndex &lt; block.successors.size()) {</span>
<span class="line-modified">1362                 BciBlock successor = block.getSuccessors().get(step.currentSuccessorIndex);</span>
<span class="line-modified">1363                 if (successor.visited) {</span>
<span class="line-modified">1364                     if (successor.active) {</span>
<span class="line-added">1365                         // Reached block via backward branch.</span>
<span class="line-added">1366                         makeLoopHeader(successor);</span>
<span class="line-added">1367                         step.loops |= successor.loops;</span>
<span class="line-added">1368                     } else if (successor.isLoopHeader) {</span>
<span class="line-added">1369                         step.loops |= successor.loops &amp; ~(1L &lt;&lt; successor.loopId);</span>
<span class="line-added">1370                     } else {</span>
<span class="line-added">1371                         step.loops |= successor.loops;</span>
<span class="line-added">1372                     }</span>
<span class="line-added">1373                 } else {</span>
<span class="line-added">1374                     workStack.push(new TraversalStep(successor));</span>
<span class="line-added">1375                 }</span>
<span class="line-added">1376                 step.currentSuccessorIndex++;</span>
<span class="line-added">1377             } else {</span>
<span class="line-added">1378                 // We processed all the successors of this block.</span>
<span class="line-added">1379                 block.loops = step.loops;</span>
<span class="line-added">1380                 debug.log(&quot;computeBlockOrder(%s) -&gt; %x&quot;, block, block.loops);</span>
1381 
<a name="44" id="anc44"></a><span class="line-modified">1382                 if (block.isLoopHeader) {</span>
<span class="line-modified">1383                     step.loops &amp;= ~(1L &lt;&lt; block.loopId);</span>
<span class="line-modified">1384                 }</span>






1385 
<a name="45" id="anc45"></a><span class="line-modified">1386                 block.active = false;</span>
<span class="line-modified">1387                 blocksNotYetAssignedId--;</span>
<span class="line-added">1388                 blocks[blocksNotYetAssignedId] = block;</span>
1389 
<a name="46" id="anc46"></a><span class="line-modified">1390                 workStack.pop();</span>
<span class="line-modified">1391                 if (!workStack.isEmpty()) {</span>
<span class="line-added">1392                     workStack.peek().loops |= step.loops;</span>
<span class="line-added">1393                 } else {</span>
<span class="line-added">1394                     return step.loops;</span>
<span class="line-added">1395                 }</span>
<span class="line-added">1396             }</span>
1397         }
<a name="47" id="anc47"></a>





1398     }
1399 
<a name="48" id="anc48"></a><span class="line-modified">1400     private long fixLoopBits(BciBlock initialBlock) {</span>
<span class="line-modified">1401         ArrayDeque&lt;TraversalStep&gt; workStack = new ArrayDeque&lt;&gt;();</span>
<span class="line-modified">1402         workStack.push(new TraversalStep(initialBlock));</span>
<span class="line-modified">1403         while (true) {</span>
<span class="line-modified">1404             TraversalStep step = workStack.peek();</span>
<span class="line-modified">1405             BciBlock block = step.block;</span>
<span class="line-modified">1406             if (step.currentSuccessorIndex == 0) {</span>
<span class="line-added">1407                 block.visited = true;</span>
<span class="line-added">1408                 step.loops = block.loops;</span>
1409             }
<a name="49" id="anc49"></a><span class="line-modified">1410             if (step.currentSuccessorIndex &lt; block.getSuccessors().size()) {</span>
<span class="line-added">1411                 BciBlock successor = block.getSuccessors().get(step.currentSuccessorIndex);</span>
<span class="line-added">1412                 if (successor.visited) {</span>
<span class="line-added">1413                     // Return cached loop information for this block.</span>
<span class="line-added">1414                     if (successor.isLoopHeader) {</span>
<span class="line-added">1415                         step.loops |= successor.loops &amp; ~(1L &lt;&lt; successor.loopId);</span>
<span class="line-added">1416                     } else {</span>
<span class="line-added">1417                         step.loops |= successor.loops;</span>
<span class="line-added">1418                     }</span>
<span class="line-added">1419                 } else {</span>
<span class="line-added">1420                     workStack.push(new TraversalStep(successor));</span>
<span class="line-added">1421                 }</span>
<span class="line-added">1422                 step.currentSuccessorIndex++;</span>
<span class="line-added">1423             } else {</span>
<span class="line-added">1424                 if (block.loops != step.loops) {</span>
<span class="line-added">1425                     loopChanges = true;</span>
<span class="line-added">1426                     block.loops = step.loops;</span>
<span class="line-added">1427                     debug.log(&quot;fixLoopBits0(%s) -&gt; %x&quot;, block, block.loops);</span>
<span class="line-added">1428                 }</span>
1429 
<a name="50" id="anc50"></a><span class="line-modified">1430                 if (block.isLoopHeader) {</span>
<span class="line-modified">1431                     step.loops &amp;= ~(1L &lt;&lt; block.loopId);</span>
<span class="line-modified">1432                 }</span>








1433 
<a name="51" id="anc51"></a><span class="line-modified">1434                 workStack.pop();</span>
<span class="line-modified">1435                 if (!workStack.isEmpty()) {</span>
<span class="line-added">1436                     workStack.peek().loops |= step.loops;</span>
<span class="line-added">1437                 } else {</span>
<span class="line-added">1438                     return step.loops;</span>
<span class="line-added">1439                 }</span>
<span class="line-added">1440             }</span>
1441         }
<a name="52" id="anc52"></a>

1442     }
1443 
1444     public static BciBlockMapping create(BytecodeStream stream, Bytecode code, OptionValues options, DebugContext debug) {
1445         BciBlockMapping map = new BciBlockMapping(code, debug);
1446         map.build(stream, options);
1447         if (debug.isDumpEnabled(DebugContext.INFO_LEVEL)) {
1448             debug.dump(DebugContext.INFO_LEVEL, map, code.getMethod().format(&quot;After block building %f %R %H.%n(%P)&quot;));
1449         }
1450 
1451         return map;
1452     }
1453 
1454     public BciBlock[] getLoopHeaders() {
1455         return loopHeaders;
1456     }
1457 
1458     public BciBlock getStartBlock() {
1459         return startBlock;
1460     }
1461 
1462     public ExceptionDispatchBlock getUnwindBlock() {
1463         return (ExceptionDispatchBlock) blocks[blocks.length - 1];
1464     }
1465 
1466     public int getLoopCount() {
1467         return nextLoop;
1468     }
1469 
1470     public int getBlockCount() {
1471         return blocks.length;
1472     }
1473 }
<a name="53" id="anc53"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="53" type="hidden" />
</body>
</html>
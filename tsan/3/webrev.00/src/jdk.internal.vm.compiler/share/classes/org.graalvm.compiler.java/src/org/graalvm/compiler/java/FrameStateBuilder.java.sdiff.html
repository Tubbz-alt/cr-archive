<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/FrameStateBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeParserOptions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphBuilderPhase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/FrameStateBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.java;
  26 
  27 import static org.graalvm.compiler.bytecode.Bytecodes.DUP;
  28 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2;
  29 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X1;
  30 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X2;
  31 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X1;
  32 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X2;
  33 import static org.graalvm.compiler.bytecode.Bytecodes.POP;
  34 import static org.graalvm.compiler.bytecode.Bytecodes.POP2;
  35 import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;
  36 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
  37 import static org.graalvm.compiler.nodes.FrameState.TWO_SLOT_MARKER;

  38 
  39 import java.util.ArrayList;
  40 import java.util.Arrays;
  41 import java.util.List;
  42 import java.util.function.Function;
  43 
  44 import org.graalvm.compiler.bytecode.Bytecode;
  45 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
<span class="line-removed">  46 import org.graalvm.compiler.core.common.GraalOptions;</span>
  47 import org.graalvm.compiler.core.common.PermanentBailoutException;
  48 import org.graalvm.compiler.core.common.type.StampFactory;
  49 import org.graalvm.compiler.core.common.type.StampPair;
  50 import org.graalvm.compiler.debug.DebugContext;

  51 import org.graalvm.compiler.graph.NodeSourcePosition;
  52 import org.graalvm.compiler.java.BciBlockMapping.BciBlock;
  53 import org.graalvm.compiler.nodeinfo.Verbosity;
  54 import org.graalvm.compiler.nodes.AbstractMergeNode;
  55 import org.graalvm.compiler.nodes.ConstantNode;
  56 import org.graalvm.compiler.nodes.FrameState;
  57 import org.graalvm.compiler.nodes.LoopBeginNode;
  58 import org.graalvm.compiler.nodes.LoopExitNode;
  59 import org.graalvm.compiler.nodes.NodeView;
  60 import org.graalvm.compiler.nodes.ParameterNode;
  61 import org.graalvm.compiler.nodes.PhiNode;
  62 import org.graalvm.compiler.nodes.ProxyNode;
  63 import org.graalvm.compiler.nodes.StateSplit;
  64 import org.graalvm.compiler.nodes.StructuredGraph;
  65 import org.graalvm.compiler.nodes.ValueNode;
  66 import org.graalvm.compiler.nodes.ValuePhiNode;
  67 import org.graalvm.compiler.nodes.calc.FloatingNode;
  68 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
  69 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderTool;
  70 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.SideEffectsState;
  71 import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
  72 import org.graalvm.compiler.nodes.java.MonitorIdNode;
<span class="line-removed">  73 import org.graalvm.compiler.nodes.util.GraphUtil;</span>
  74 
  75 import jdk.vm.ci.code.BytecodeFrame;
  76 import jdk.vm.ci.meta.Assumptions;
  77 import jdk.vm.ci.meta.JavaKind;
  78 import jdk.vm.ci.meta.JavaType;
  79 import jdk.vm.ci.meta.ResolvedJavaMethod;
  80 import jdk.vm.ci.meta.ResolvedJavaType;
  81 import jdk.vm.ci.meta.Signature;
  82 
  83 public final class FrameStateBuilder implements SideEffectsState {
  84 
  85     private static final ValueNode[] EMPTY_ARRAY = new ValueNode[0];
  86     private static final MonitorIdNode[] EMPTY_MONITOR_ARRAY = new MonitorIdNode[0];
  87 
  88     private final BytecodeParser parser;
  89     private final GraphBuilderTool tool;
  90     private final Bytecode code;
  91     private int stackSize;
  92     protected final ValueNode[] locals;
  93     protected final ValueNode[] stack;
</pre>
<hr />
<pre>
 101 
 102     private MonitorIdNode[] monitorIds;
 103     private final StructuredGraph graph;
 104     private final boolean clearNonLiveLocals;
 105     private FrameState outerFrameState;
 106     private NodeSourcePosition outerSourcePosition;
 107 
 108     /**
 109      * The closest {@link StateSplit#hasSideEffect() side-effect} predecessors. There will be more
 110      * than one when the current block contains no side-effects but merging predecessor blocks do.
 111      */
 112     private List&lt;StateSplit&gt; sideEffects;
 113 
 114     /**
 115      * Creates a new frame state builder for the given method and the given target graph.
 116      *
 117      * @param method the method whose frame is simulated
 118      * @param graph the target graph of Graal nodes created by the builder
 119      */
 120     public FrameStateBuilder(GraphBuilderTool tool, ResolvedJavaMethod method, StructuredGraph graph) {
<span class="line-modified"> 121         this(tool, new ResolvedJavaMethodBytecode(method), graph);</span>
 122     }
 123 
 124     /**
 125      * Creates a new frame state builder for the given code attribute, method and the given target
<span class="line-modified"> 126      * graph.</span>
 127      *
 128      * @param code the bytecode in which the frame exists
 129      * @param graph the target graph of Graal nodes created by the builder

 130      */
<span class="line-modified"> 131     public FrameStateBuilder(GraphBuilderTool tool, Bytecode code, StructuredGraph graph) {</span>
 132         this.tool = tool;
 133         if (tool instanceof BytecodeParser) {
 134             this.parser = (BytecodeParser) tool;
 135         } else {
 136             this.parser = null;
 137         }
 138         this.code = code;
 139         this.locals = allocateArray(code.getMaxLocals());
 140         this.stack = allocateArray(Math.max(1, code.getMaxStackSize()));
 141         this.lockedObjects = allocateArray(0);
 142 
 143         assert graph != null;
 144 
 145         this.monitorIds = EMPTY_MONITOR_ARRAY;
 146         this.graph = graph;
<span class="line-modified"> 147         this.clearNonLiveLocals = GraalOptions.OptClearNonLiveLocals.getValue(graph.getOptions());</span>
 148         this.canVerifyKind = true;
 149     }
 150 
 151     public void disableKindVerification() {
 152         canVerifyKind = false;
 153     }
 154 
 155     public void initializeFromArgumentsArray(ValueNode[] arguments) {
 156 
 157         int javaIndex = 0;
 158         int index = 0;
 159         if (!getMethod().isStatic()) {
 160             // set the receiver
 161             locals[javaIndex] = arguments[index];
 162             javaIndex = 1;
 163             index = 1;
 164         }
 165         Signature sig = getMethod().getSignature();
 166         int max = sig.getParameterCount(false);
 167         for (int i = 0; i &lt; max; i++) {
</pre>
<hr />
<pre>
 256 
 257     private FrameStateBuilder(FrameStateBuilder other) {
 258         this.parser = other.parser;
 259         this.tool = other.tool;
 260         this.code = other.code;
 261         this.stackSize = other.stackSize;
 262         this.locals = other.locals.clone();
 263         this.stack = other.stack.clone();
 264         this.lockedObjects = other.lockedObjects.length == 0 ? other.lockedObjects : other.lockedObjects.clone();
 265         this.rethrowException = other.rethrowException;
 266         this.canVerifyKind = other.canVerifyKind;
 267 
 268         assert locals.length == code.getMaxLocals();
 269         assert stack.length == Math.max(1, code.getMaxStackSize());
 270 
 271         assert other.graph != null;
 272         graph = other.graph;
 273         clearNonLiveLocals = other.clearNonLiveLocals;
 274         monitorIds = other.monitorIds.length == 0 ? other.monitorIds : other.monitorIds.clone();
 275 
<span class="line-removed"> 276         assert locals.length == code.getMaxLocals();</span>
<span class="line-removed"> 277         assert stack.length == Math.max(1, code.getMaxStackSize());</span>
 278         assert lockedObjects.length == monitorIds.length;
 279     }
 280 
 281     private static ValueNode[] allocateArray(int length) {
 282         return length == 0 ? EMPTY_ARRAY : new ValueNode[length];
 283     }
 284 
 285     public ResolvedJavaMethod getMethod() {
 286         return code.getMethod();
 287     }
 288 
 289     @Override
 290     public String toString() {
 291         StringBuilder sb = new StringBuilder();
 292         sb.append(&quot;[locals: [&quot;);
 293         for (int i = 0; i &lt; locals.length; i++) {
 294             sb.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(locals[i] == null ? &quot;_&quot; : locals[i] == TWO_SLOT_MARKER ? &quot;#&quot; : locals[i].toString(Verbosity.Id));
 295         }
 296         sb.append(&quot;] stack: [&quot;);
 297         for (int i = 0; i &lt; stackSize; i++) {
</pre>
<hr />
<pre>
 312     public FrameState create(int bci, StateSplit forStateSplit) {
 313         if (parser != null &amp;&amp; parser.parsingIntrinsic()) {
 314             NodeSourcePosition sourcePosition = parser.getGraph().trackNodeSourcePosition() ? createBytecodePosition(bci) : null;
 315             return parser.intrinsicContext.createFrameState(parser.getGraph(), this, forStateSplit, sourcePosition);
 316         }
 317 
 318         // Skip intrinsic frames
 319         return create(bci, parser != null ? parser.getNonIntrinsicAncestor() : null, false, null, null);
 320     }
 321 
 322     /**
 323      * @param pushedValues if non-null, values to {@link #push(JavaKind, ValueNode)} to the stack
 324      *            before creating the {@link FrameState}
 325      */
 326     public FrameState create(int bci, BytecodeParser parent, boolean duringCall, JavaKind[] pushedSlotKinds, ValueNode[] pushedValues) {
 327         if (outerFrameState == null &amp;&amp; parent != null) {
 328             assert !parent.parsingIntrinsic() : &quot;must already have the next non-intrinsic ancestor&quot;;
 329             outerFrameState = parent.getFrameStateBuilder().create(parent.bci(), parent.getNonIntrinsicAncestor(), true, null, null);
 330         }
 331         if (bci == BytecodeFrame.AFTER_EXCEPTION_BCI &amp;&amp; parent != null) {
<span class="line-modified"> 332             FrameState newFrameState = outerFrameState.duplicateModified(outerFrameState.bci, true, false, JavaKind.Void, new JavaKind[]{JavaKind.Object}, new ValueNode[]{stack[0]});</span>
<span class="line-removed"> 333             return newFrameState;</span>
 334         }
 335         if (bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 336             throw shouldNotReachHere();
 337         }
 338 
 339         if (pushedValues != null) {
 340             assert pushedSlotKinds.length == pushedValues.length;
 341             int stackSizeToRestore = stackSize;
 342             for (int i = 0; i &lt; pushedValues.length; i++) {
 343                 push(pushedSlotKinds[i], pushedValues[i]);
 344             }
 345             FrameState res = graph.add(new FrameState(outerFrameState, code, bci, locals, stack, stackSize, lockedObjects, Arrays.asList(monitorIds), rethrowException, duringCall));
 346             stackSize = stackSizeToRestore;
 347             return res;
 348         } else {
 349             if (bci == BytecodeFrame.AFTER_EXCEPTION_BCI) {
 350                 assert outerFrameState == null;
 351                 clearLocals();
 352             }
 353             return graph.add(new FrameState(outerFrameState, code, bci, locals, stack, stackSize, lockedObjects, Arrays.asList(monitorIds), rethrowException, duringCall));
</pre>
<hr />
<pre>
 368             return FrameState.toSourcePosition(outerFrameState);
 369         }
 370         if (bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 371             throw shouldNotReachHere();
 372         }
 373         if (parser.intrinsicContext != null &amp;&amp; (parent == null || parent.intrinsicContext != parser.intrinsicContext)) {
 374             // When parsing an intrinsic put in a substitution marker showing the original method as
 375             // the caller. This keeps the relationship between the method and the method
 376             // substitution clear in resulting NodeSourcePosition.
 377             NodeSourcePosition original = new NodeSourcePosition(outerSourcePosition, parser.intrinsicContext.getOriginalMethod(), -1);
 378             return NodeSourcePosition.substitution(original, code.getMethod(), bci);
 379         } else {
 380             return new NodeSourcePosition(outerSourcePosition, code.getMethod(), bci);
 381         }
 382     }
 383 
 384     public FrameStateBuilder copy() {
 385         return new FrameStateBuilder(this);
 386     }
 387 
<span class="line-modified"> 388     public boolean isCompatibleWith(FrameStateBuilder other) {</span>














 389         assert code.equals(other.code) &amp;&amp; graph == other.graph &amp;&amp; localsSize() == other.localsSize() : &quot;Can only compare frame states of the same method&quot;;
 390         assert lockedObjects.length == monitorIds.length &amp;&amp; other.lockedObjects.length == other.monitorIds.length : &quot;mismatch between lockedObjects and monitorIds&quot;;
 391 




 392         if (stackSize() != other.stackSize()) {
<span class="line-modified"> 393             return false;</span>
 394         }
 395         for (int i = 0; i &lt; stackSize(); i++) {
 396             ValueNode x = stack[i];
 397             ValueNode y = other.stack[i];
 398             assert x != null &amp;&amp; y != null;
 399             if (x != y &amp;&amp; (x == TWO_SLOT_MARKER || x.isDeleted() || y == TWO_SLOT_MARKER || y.isDeleted() || x.getStackKind() != y.getStackKind())) {
<span class="line-modified"> 400                 return false;</span>
 401             }
 402         }
 403         if (lockedObjects.length != other.lockedObjects.length) {
<span class="line-modified"> 404             return false;</span>
 405         }
 406         for (int i = 0; i &lt; lockedObjects.length; i++) {
<span class="line-modified"> 407             if (GraphUtil.originalValue(lockedObjects[i]) != GraphUtil.originalValue(other.lockedObjects[i]) || monitorIds[i] != other.monitorIds[i]) {</span>
<span class="line-modified"> 408                 throw new PermanentBailoutException(&quot;unbalanced monitors&quot;);</span>



 409             }
 410         }
<span class="line-removed"> 411         return true;</span>
 412     }
 413 
 414     public void merge(AbstractMergeNode block, FrameStateBuilder other) {
<span class="line-modified"> 415         assert isCompatibleWith(other);</span>
 416 
 417         for (int i = 0; i &lt; localsSize(); i++) {
 418             locals[i] = merge(locals[i], other.locals[i], block);
 419         }
 420         for (int i = 0; i &lt; stackSize(); i++) {
 421             stack[i] = merge(stack[i], other.stack[i], block);
 422         }
 423         for (int i = 0; i &lt; lockedObjects.length; i++) {
 424             lockedObjects[i] = merge(lockedObjects[i], other.lockedObjects[i], block);
 425             assert monitorIds[i] == other.monitorIds[i];
 426         }
 427 
 428         if (sideEffects == null) {
 429             sideEffects = other.sideEffects;
 430         } else {
 431             if (other.sideEffects != null) {
 432                 sideEffects.addAll(other.sideEffects);
 433             }
 434         }
 435     }
</pre>
<hr />
<pre>
 491         for (int i = 0; i &lt; localsSize(); i++) {
 492             boolean changedInLoop = liveness.localIsChangedInLoop(loopId, i);
 493             if (forcePhis || changedInLoop) {
 494                 locals[i] = createLoopPhi(loopBegin, locals[i], stampFromValueForForcedPhis &amp;&amp; !changedInLoop);
 495             }
 496         }
 497         for (int i = 0; i &lt; stackSize(); i++) {
 498             stack[i] = createLoopPhi(loopBegin, stack[i], false);
 499         }
 500         for (int i = 0; i &lt; lockedObjects.length; i++) {
 501             lockedObjects[i] = createLoopPhi(loopBegin, lockedObjects[i], false);
 502         }
 503     }
 504 
 505     public void insertLoopProxies(LoopExitNode loopExit, FrameStateBuilder loopEntryState) {
 506         DebugContext debug = graph.getDebug();
 507         for (int i = 0; i &lt; localsSize(); i++) {
 508             ValueNode value = locals[i];
 509             if (value != null &amp;&amp; value != TWO_SLOT_MARKER &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
 510                 debug.log(&quot; inserting proxy for %s&quot;, value);
<span class="line-modified"> 511                 locals[i] = ProxyNode.forValue(value, loopExit, graph);</span>
 512             }
 513         }
 514         for (int i = 0; i &lt; stackSize(); i++) {
 515             ValueNode value = stack[i];
 516             if (value != null &amp;&amp; value != TWO_SLOT_MARKER &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
 517                 debug.log(&quot; inserting proxy for %s&quot;, value);
<span class="line-modified"> 518                 stack[i] = ProxyNode.forValue(value, loopExit, graph);</span>
 519             }
 520         }
 521         for (int i = 0; i &lt; lockedObjects.length; i++) {
 522             ValueNode value = lockedObjects[i];
 523             if (value != null &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
 524                 debug.log(&quot; inserting proxy for %s&quot;, value);
<span class="line-modified"> 525                 lockedObjects[i] = ProxyNode.forValue(value, loopExit, graph);</span>
 526             }
 527         }
 528     }
 529 
 530     public void insertProxies(Function&lt;ValueNode, ValueNode&gt; proxyFunction) {
 531         DebugContext debug = graph.getDebug();
 532         for (int i = 0; i &lt; localsSize(); i++) {
 533             ValueNode value = locals[i];
 534             if (value != null &amp;&amp; value != TWO_SLOT_MARKER) {
 535                 debug.log(&quot; inserting proxy for %s&quot;, value);
 536                 locals[i] = proxyFunction.apply(value);
 537             }
 538         }
 539         for (int i = 0; i &lt; stackSize(); i++) {
 540             ValueNode value = stack[i];
 541             if (value != null &amp;&amp; value != TWO_SLOT_MARKER) {
 542                 debug.log(&quot; inserting proxy for %s&quot;, value);
 543                 stack[i] = proxyFunction.apply(value);
 544             }
 545         }
</pre>
<hr />
<pre>
 613             if (locals[i] == value) {
 614                 return true;
 615             }
 616         }
 617         for (int i = 0; i &lt; stackSize(); i++) {
 618             if (stack[i] == value) {
 619                 return true;
 620             }
 621         }
 622         assert lockedObjects.length == monitorIds.length;
 623         for (int i = 0; i &lt; lockedObjects.length; i++) {
 624             if (lockedObjects[i] == value || monitorIds[i] == value) {
 625                 return true;
 626             }
 627         }
 628         return false;
 629     }
 630 
 631     public void clearNonLiveLocals(BciBlock block, LocalLiveness liveness, boolean liveIn) {
 632         /*
<span class="line-modified"> 633          * (lstadler) if somebody is tempted to remove/disable this clearing code: it&#39;s possible to</span>
<span class="line-modified"> 634          * remove it for normal compilations, but not for OSR compilations - otherwise dead object</span>
<span class="line-modified"> 635          * slots at the OSR entry aren&#39;t cleared. it is also not enough to rely on PiNodes with</span>
<span class="line-removed"> 636          * Kind.Illegal, because the conflicting branch might not have been parsed.</span>
 637          */
<span class="line-modified"> 638         if (!clearNonLiveLocals) {</span>

 639             return;
 640         }
 641         if (liveIn) {
 642             for (int i = 0; i &lt; locals.length; i++) {
 643                 if (!liveness.localIsLiveIn(block, i)) {
 644                     assert locals[i] != TWO_SLOT_MARKER || locals[i - 1] == null : &quot;Clearing of second slot must have cleared the first slot too&quot;;
 645                     locals[i] = null;
 646                 }
 647             }
 648         } else {
 649             for (int i = 0; i &lt; locals.length; i++) {
 650                 if (!liveness.localIsLiveOut(block, i)) {
 651                     assert locals[i] != TWO_SLOT_MARKER || locals[i - 1] == null : &quot;Clearing of second slot must have cleared the first slot too&quot;;
 652                     locals[i] = null;
 653                 }
 654             }
 655         }
 656     }
 657 
 658     /**
</pre>
<hr />
<pre>
 720         return x;
 721     }
 722 
 723     /**
 724      * Stores a given local variable at the specified index. If the value occupies two slots, then
 725      * the next local variable index is also overwritten.
 726      *
 727      * @param i the index at which to store
 728      * @param slotKind the kind of the local variable from the point of view of the bytecodes
 729      * @param x the instruction which produces the value for the local
 730      */
 731     public void storeLocal(int i, JavaKind slotKind, ValueNode x) {
 732         assert verifyKind(slotKind, x);
 733 
 734         if (locals[i] == TWO_SLOT_MARKER) {
 735             /* Writing the second slot of a two-slot value invalidates the first slot. */
 736             locals[i - 1] = null;
 737         }
 738         locals[i] = x;
 739         if (slotKind.needsTwoSlots()) {







 740             /* Writing a two-slot value: mark the second slot. */
 741             locals[i + 1] = TWO_SLOT_MARKER;
 742         } else if (i &lt; locals.length - 1 &amp;&amp; locals[i + 1] == TWO_SLOT_MARKER) {
 743             /*
 744              * Writing a one-slot value to an index previously occupied by a two-slot value: clear
 745              * the old marker of the second slot.
 746              */
 747             locals[i + 1] = null;
 748         }
 749     }
 750 
 751     /**
 752      * Pushes an instruction onto the stack with the expected type.
 753      *
 754      * @param slotKind the kind of the stack element from the point of view of the bytecodes
 755      * @param x the instruction to push onto the stack
 756      */
 757     public void push(JavaKind slotKind, ValueNode x) {
 758         assert verifyKind(slotKind, x);
 759 
</pre>
<hr />
<pre>
 761         if (slotKind.needsTwoSlots()) {
 762             xpush(TWO_SLOT_MARKER);
 763         }
 764     }
 765 
 766     public void pushReturn(JavaKind slotKind, ValueNode x) {
 767         if (slotKind != JavaKind.Void) {
 768             push(slotKind, x);
 769         }
 770     }
 771 
 772     /**
 773      * Pops an instruction off the stack with the expected type.
 774      *
 775      * @param slotKind the kind of the stack element from the point of view of the bytecodes
 776      * @return the instruction on the top of the stack
 777      */
 778     public ValueNode pop(JavaKind slotKind) {
 779         if (slotKind.needsTwoSlots()) {
 780             ValueNode s = xpop();
<span class="line-modified"> 781             assert s == TWO_SLOT_MARKER;</span>
 782         }
 783         ValueNode x = xpop();
 784         assert verifyKind(slotKind, x);
 785         return x;
 786     }
 787 
 788     private void xpush(ValueNode x) {
 789         assert x != null;
 790         stack[stackSize++] = x;
 791     }
 792 
 793     private ValueNode xpop() {
 794         ValueNode result = stack[--stackSize];
 795         assert result != null;
 796         return result;
 797     }
 798 
 799     private ValueNode xpeek() {
 800         ValueNode result = stack[stackSize - 1];
 801         assert result != null;
 802         return result;
 803     }
 804 






 805     /**
 806      * Pop the specified number of slots off of this stack and return them as an array of
 807      * instructions.
 808      *
 809      * @return an array containing the arguments off of the stack
 810      */
 811     public ValueNode[] popArguments(int argSize) {
 812         ValueNode[] result = allocateArray(argSize);
 813         for (int i = argSize - 1; i &gt;= 0; i--) {
 814             ValueNode x = xpop();
 815             if (x == TWO_SLOT_MARKER) {
 816                 /* Ignore second slot of two-slot value. */
 817                 x = xpop();
 818             }
<span class="line-modified"> 819             assert x != null &amp;&amp; x != TWO_SLOT_MARKER;</span>
 820             result[i] = x;
 821         }
 822         return result;
 823     }
 824 
 825     /**
 826      * Clears all values on this stack.
 827      */
 828     public void clearStack() {
 829         stackSize = 0;
 830     }
 831 
 832     /**
 833      * Performs a raw stack operation as defined in the Java bytecode specification.
 834      *
 835      * @param opcode The Java bytecode.
 836      */
 837     public void stackOp(int opcode) {
 838         switch (opcode) {
 839             case POP: {
</pre>
<hr />
<pre>
 979 
 980     @Override
 981     public boolean isAfterSideEffect() {
 982         return sideEffects != null;
 983     }
 984 
 985     @Override
 986     public Iterable&lt;StateSplit&gt; sideEffects() {
 987         return sideEffects;
 988     }
 989 
 990     @Override
 991     public void addSideEffect(StateSplit sideEffect) {
 992         assert sideEffect != null;
 993         assert sideEffect.hasSideEffect();
 994         if (sideEffects == null) {
 995             sideEffects = new ArrayList&lt;&gt;(4);
 996         }
 997         sideEffects.add(sideEffect);
 998     }













 999 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.java;
  26 
  27 import static org.graalvm.compiler.bytecode.Bytecodes.DUP;
  28 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2;
  29 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X1;
  30 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X2;
  31 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X1;
  32 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X2;
  33 import static org.graalvm.compiler.bytecode.Bytecodes.POP;
  34 import static org.graalvm.compiler.bytecode.Bytecodes.POP2;
  35 import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;
  36 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
  37 import static org.graalvm.compiler.nodes.FrameState.TWO_SLOT_MARKER;
<span class="line-added">  38 import static org.graalvm.compiler.nodes.util.GraphUtil.originalValue;</span>
  39 
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
  42 import java.util.List;
  43 import java.util.function.Function;
  44 
  45 import org.graalvm.compiler.bytecode.Bytecode;
  46 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;

  47 import org.graalvm.compiler.core.common.PermanentBailoutException;
  48 import org.graalvm.compiler.core.common.type.StampFactory;
  49 import org.graalvm.compiler.core.common.type.StampPair;
  50 import org.graalvm.compiler.debug.DebugContext;
<span class="line-added">  51 import org.graalvm.compiler.debug.GraalError;</span>
  52 import org.graalvm.compiler.graph.NodeSourcePosition;
  53 import org.graalvm.compiler.java.BciBlockMapping.BciBlock;
  54 import org.graalvm.compiler.nodeinfo.Verbosity;
  55 import org.graalvm.compiler.nodes.AbstractMergeNode;
  56 import org.graalvm.compiler.nodes.ConstantNode;
  57 import org.graalvm.compiler.nodes.FrameState;
  58 import org.graalvm.compiler.nodes.LoopBeginNode;
  59 import org.graalvm.compiler.nodes.LoopExitNode;
  60 import org.graalvm.compiler.nodes.NodeView;
  61 import org.graalvm.compiler.nodes.ParameterNode;
  62 import org.graalvm.compiler.nodes.PhiNode;
  63 import org.graalvm.compiler.nodes.ProxyNode;
  64 import org.graalvm.compiler.nodes.StateSplit;
  65 import org.graalvm.compiler.nodes.StructuredGraph;
  66 import org.graalvm.compiler.nodes.ValueNode;
  67 import org.graalvm.compiler.nodes.ValuePhiNode;
  68 import org.graalvm.compiler.nodes.calc.FloatingNode;
  69 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
  70 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderTool;
  71 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.SideEffectsState;
  72 import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
  73 import org.graalvm.compiler.nodes.java.MonitorIdNode;

  74 
  75 import jdk.vm.ci.code.BytecodeFrame;
  76 import jdk.vm.ci.meta.Assumptions;
  77 import jdk.vm.ci.meta.JavaKind;
  78 import jdk.vm.ci.meta.JavaType;
  79 import jdk.vm.ci.meta.ResolvedJavaMethod;
  80 import jdk.vm.ci.meta.ResolvedJavaType;
  81 import jdk.vm.ci.meta.Signature;
  82 
  83 public final class FrameStateBuilder implements SideEffectsState {
  84 
  85     private static final ValueNode[] EMPTY_ARRAY = new ValueNode[0];
  86     private static final MonitorIdNode[] EMPTY_MONITOR_ARRAY = new MonitorIdNode[0];
  87 
  88     private final BytecodeParser parser;
  89     private final GraphBuilderTool tool;
  90     private final Bytecode code;
  91     private int stackSize;
  92     protected final ValueNode[] locals;
  93     protected final ValueNode[] stack;
</pre>
<hr />
<pre>
 101 
 102     private MonitorIdNode[] monitorIds;
 103     private final StructuredGraph graph;
 104     private final boolean clearNonLiveLocals;
 105     private FrameState outerFrameState;
 106     private NodeSourcePosition outerSourcePosition;
 107 
 108     /**
 109      * The closest {@link StateSplit#hasSideEffect() side-effect} predecessors. There will be more
 110      * than one when the current block contains no side-effects but merging predecessor blocks do.
 111      */
 112     private List&lt;StateSplit&gt; sideEffects;
 113 
 114     /**
 115      * Creates a new frame state builder for the given method and the given target graph.
 116      *
 117      * @param method the method whose frame is simulated
 118      * @param graph the target graph of Graal nodes created by the builder
 119      */
 120     public FrameStateBuilder(GraphBuilderTool tool, ResolvedJavaMethod method, StructuredGraph graph) {
<span class="line-modified"> 121         this(tool, new ResolvedJavaMethodBytecode(method), graph, false);</span>
 122     }
 123 
 124     /**
 125      * Creates a new frame state builder for the given code attribute, method and the given target
<span class="line-modified"> 126      * graph. Additionally specifies if nonLiveLocals should be retained.</span>
 127      *
 128      * @param code the bytecode in which the frame exists
 129      * @param graph the target graph of Graal nodes created by the builder
<span class="line-added"> 130      * @param shouldRetainLocalVariables specifies if nonLiveLocals should be retained in state.</span>
 131      */
<span class="line-modified"> 132     public FrameStateBuilder(GraphBuilderTool tool, Bytecode code, StructuredGraph graph, boolean shouldRetainLocalVariables) {</span>
 133         this.tool = tool;
 134         if (tool instanceof BytecodeParser) {
 135             this.parser = (BytecodeParser) tool;
 136         } else {
 137             this.parser = null;
 138         }
 139         this.code = code;
 140         this.locals = allocateArray(code.getMaxLocals());
 141         this.stack = allocateArray(Math.max(1, code.getMaxStackSize()));
 142         this.lockedObjects = allocateArray(0);
 143 
 144         assert graph != null;
 145 
 146         this.monitorIds = EMPTY_MONITOR_ARRAY;
 147         this.graph = graph;
<span class="line-modified"> 148         this.clearNonLiveLocals = !shouldRetainLocalVariables;</span>
 149         this.canVerifyKind = true;
 150     }
 151 
 152     public void disableKindVerification() {
 153         canVerifyKind = false;
 154     }
 155 
 156     public void initializeFromArgumentsArray(ValueNode[] arguments) {
 157 
 158         int javaIndex = 0;
 159         int index = 0;
 160         if (!getMethod().isStatic()) {
 161             // set the receiver
 162             locals[javaIndex] = arguments[index];
 163             javaIndex = 1;
 164             index = 1;
 165         }
 166         Signature sig = getMethod().getSignature();
 167         int max = sig.getParameterCount(false);
 168         for (int i = 0; i &lt; max; i++) {
</pre>
<hr />
<pre>
 257 
 258     private FrameStateBuilder(FrameStateBuilder other) {
 259         this.parser = other.parser;
 260         this.tool = other.tool;
 261         this.code = other.code;
 262         this.stackSize = other.stackSize;
 263         this.locals = other.locals.clone();
 264         this.stack = other.stack.clone();
 265         this.lockedObjects = other.lockedObjects.length == 0 ? other.lockedObjects : other.lockedObjects.clone();
 266         this.rethrowException = other.rethrowException;
 267         this.canVerifyKind = other.canVerifyKind;
 268 
 269         assert locals.length == code.getMaxLocals();
 270         assert stack.length == Math.max(1, code.getMaxStackSize());
 271 
 272         assert other.graph != null;
 273         graph = other.graph;
 274         clearNonLiveLocals = other.clearNonLiveLocals;
 275         monitorIds = other.monitorIds.length == 0 ? other.monitorIds : other.monitorIds.clone();
 276 


 277         assert lockedObjects.length == monitorIds.length;
 278     }
 279 
 280     private static ValueNode[] allocateArray(int length) {
 281         return length == 0 ? EMPTY_ARRAY : new ValueNode[length];
 282     }
 283 
 284     public ResolvedJavaMethod getMethod() {
 285         return code.getMethod();
 286     }
 287 
 288     @Override
 289     public String toString() {
 290         StringBuilder sb = new StringBuilder();
 291         sb.append(&quot;[locals: [&quot;);
 292         for (int i = 0; i &lt; locals.length; i++) {
 293             sb.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(locals[i] == null ? &quot;_&quot; : locals[i] == TWO_SLOT_MARKER ? &quot;#&quot; : locals[i].toString(Verbosity.Id));
 294         }
 295         sb.append(&quot;] stack: [&quot;);
 296         for (int i = 0; i &lt; stackSize; i++) {
</pre>
<hr />
<pre>
 311     public FrameState create(int bci, StateSplit forStateSplit) {
 312         if (parser != null &amp;&amp; parser.parsingIntrinsic()) {
 313             NodeSourcePosition sourcePosition = parser.getGraph().trackNodeSourcePosition() ? createBytecodePosition(bci) : null;
 314             return parser.intrinsicContext.createFrameState(parser.getGraph(), this, forStateSplit, sourcePosition);
 315         }
 316 
 317         // Skip intrinsic frames
 318         return create(bci, parser != null ? parser.getNonIntrinsicAncestor() : null, false, null, null);
 319     }
 320 
 321     /**
 322      * @param pushedValues if non-null, values to {@link #push(JavaKind, ValueNode)} to the stack
 323      *            before creating the {@link FrameState}
 324      */
 325     public FrameState create(int bci, BytecodeParser parent, boolean duringCall, JavaKind[] pushedSlotKinds, ValueNode[] pushedValues) {
 326         if (outerFrameState == null &amp;&amp; parent != null) {
 327             assert !parent.parsingIntrinsic() : &quot;must already have the next non-intrinsic ancestor&quot;;
 328             outerFrameState = parent.getFrameStateBuilder().create(parent.bci(), parent.getNonIntrinsicAncestor(), true, null, null);
 329         }
 330         if (bci == BytecodeFrame.AFTER_EXCEPTION_BCI &amp;&amp; parent != null) {
<span class="line-modified"> 331             return outerFrameState.duplicateModified(graph, outerFrameState.bci, true, false, JavaKind.Void, new JavaKind[]{JavaKind.Object}, new ValueNode[]{stack[0]});</span>

 332         }
 333         if (bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 334             throw shouldNotReachHere();
 335         }
 336 
 337         if (pushedValues != null) {
 338             assert pushedSlotKinds.length == pushedValues.length;
 339             int stackSizeToRestore = stackSize;
 340             for (int i = 0; i &lt; pushedValues.length; i++) {
 341                 push(pushedSlotKinds[i], pushedValues[i]);
 342             }
 343             FrameState res = graph.add(new FrameState(outerFrameState, code, bci, locals, stack, stackSize, lockedObjects, Arrays.asList(monitorIds), rethrowException, duringCall));
 344             stackSize = stackSizeToRestore;
 345             return res;
 346         } else {
 347             if (bci == BytecodeFrame.AFTER_EXCEPTION_BCI) {
 348                 assert outerFrameState == null;
 349                 clearLocals();
 350             }
 351             return graph.add(new FrameState(outerFrameState, code, bci, locals, stack, stackSize, lockedObjects, Arrays.asList(monitorIds), rethrowException, duringCall));
</pre>
<hr />
<pre>
 366             return FrameState.toSourcePosition(outerFrameState);
 367         }
 368         if (bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 369             throw shouldNotReachHere();
 370         }
 371         if (parser.intrinsicContext != null &amp;&amp; (parent == null || parent.intrinsicContext != parser.intrinsicContext)) {
 372             // When parsing an intrinsic put in a substitution marker showing the original method as
 373             // the caller. This keeps the relationship between the method and the method
 374             // substitution clear in resulting NodeSourcePosition.
 375             NodeSourcePosition original = new NodeSourcePosition(outerSourcePosition, parser.intrinsicContext.getOriginalMethod(), -1);
 376             return NodeSourcePosition.substitution(original, code.getMethod(), bci);
 377         } else {
 378             return new NodeSourcePosition(outerSourcePosition, code.getMethod(), bci);
 379         }
 380     }
 381 
 382     public FrameStateBuilder copy() {
 383         return new FrameStateBuilder(this);
 384     }
 385 
<span class="line-modified"> 386     private String incompatibilityErrorMessage(String reason, FrameStateBuilder other) {</span>
<span class="line-added"> 387         return String.format(&quot;Frame states being merged are incompatible: %s%n This frame state: %s%nOther frame state: %s%nParser context: %s&quot;, reason, this, other, parser);</span>
<span class="line-added"> 388     }</span>
<span class="line-added"> 389 </span>
<span class="line-added"> 390     /**</span>
<span class="line-added"> 391      * Checks invariants that must hold when merging {@code other} into this frame state.</span>
<span class="line-added"> 392      *</span>
<span class="line-added"> 393      * @param other</span>
<span class="line-added"> 394      * @throws PermanentBailoutException if the frame states are incompatible with respect to their</span>
<span class="line-added"> 395      *             locked objects. This indicates bytecode that has unstructured or unbalanced</span>
<span class="line-added"> 396      *             locks.</span>
<span class="line-added"> 397      * @throws GraalError if the frame states are incompatible in terms of {@link #rethrowException}</span>
<span class="line-added"> 398      *             or stack slots</span>
<span class="line-added"> 399      */</span>
<span class="line-added"> 400     public void checkCompatibleWith(FrameStateBuilder other) {</span>
 401         assert code.equals(other.code) &amp;&amp; graph == other.graph &amp;&amp; localsSize() == other.localsSize() : &quot;Can only compare frame states of the same method&quot;;
 402         assert lockedObjects.length == monitorIds.length &amp;&amp; other.lockedObjects.length == other.monitorIds.length : &quot;mismatch between lockedObjects and monitorIds&quot;;
 403 
<span class="line-added"> 404         if (rethrowException != other.rethrowException) {</span>
<span class="line-added"> 405             throw new GraalError(incompatibilityErrorMessage(&quot;mismatch in rethrowException flag&quot;, other));</span>
<span class="line-added"> 406         }</span>
<span class="line-added"> 407 </span>
 408         if (stackSize() != other.stackSize()) {
<span class="line-modified"> 409             throw new GraalError(incompatibilityErrorMessage(&quot;mismatch in stack sizes&quot;, other));</span>
 410         }
 411         for (int i = 0; i &lt; stackSize(); i++) {
 412             ValueNode x = stack[i];
 413             ValueNode y = other.stack[i];
 414             assert x != null &amp;&amp; y != null;
 415             if (x != y &amp;&amp; (x == TWO_SLOT_MARKER || x.isDeleted() || y == TWO_SLOT_MARKER || y.isDeleted() || x.getStackKind() != y.getStackKind())) {
<span class="line-modified"> 416                 throw new GraalError(incompatibilityErrorMessage(&quot;mismatch in stack types&quot;, other));</span>
 417             }
 418         }
 419         if (lockedObjects.length != other.lockedObjects.length) {
<span class="line-modified"> 420             throw new PermanentBailoutException(incompatibilityErrorMessage(&quot;unbalanced monitors - locked objects do not match&quot;, other));</span>
 421         }
 422         for (int i = 0; i &lt; lockedObjects.length; i++) {
<span class="line-modified"> 423             if (originalValue(lockedObjects[i], false) != originalValue(other.lockedObjects[i], false)) {</span>
<span class="line-modified"> 424                 throw new PermanentBailoutException(incompatibilityErrorMessage(&quot;unbalanced monitors - locked objects do not match&quot;, other));</span>
<span class="line-added"> 425             }</span>
<span class="line-added"> 426             if (monitorIds[i] != other.monitorIds[i]) {</span>
<span class="line-added"> 427                 throw new PermanentBailoutException(incompatibilityErrorMessage(&quot;unbalanced monitors - monitors do not match&quot;, other));</span>
 428             }
 429         }

 430     }
 431 
 432     public void merge(AbstractMergeNode block, FrameStateBuilder other) {
<span class="line-modified"> 433         checkCompatibleWith(other);</span>
 434 
 435         for (int i = 0; i &lt; localsSize(); i++) {
 436             locals[i] = merge(locals[i], other.locals[i], block);
 437         }
 438         for (int i = 0; i &lt; stackSize(); i++) {
 439             stack[i] = merge(stack[i], other.stack[i], block);
 440         }
 441         for (int i = 0; i &lt; lockedObjects.length; i++) {
 442             lockedObjects[i] = merge(lockedObjects[i], other.lockedObjects[i], block);
 443             assert monitorIds[i] == other.monitorIds[i];
 444         }
 445 
 446         if (sideEffects == null) {
 447             sideEffects = other.sideEffects;
 448         } else {
 449             if (other.sideEffects != null) {
 450                 sideEffects.addAll(other.sideEffects);
 451             }
 452         }
 453     }
</pre>
<hr />
<pre>
 509         for (int i = 0; i &lt; localsSize(); i++) {
 510             boolean changedInLoop = liveness.localIsChangedInLoop(loopId, i);
 511             if (forcePhis || changedInLoop) {
 512                 locals[i] = createLoopPhi(loopBegin, locals[i], stampFromValueForForcedPhis &amp;&amp; !changedInLoop);
 513             }
 514         }
 515         for (int i = 0; i &lt; stackSize(); i++) {
 516             stack[i] = createLoopPhi(loopBegin, stack[i], false);
 517         }
 518         for (int i = 0; i &lt; lockedObjects.length; i++) {
 519             lockedObjects[i] = createLoopPhi(loopBegin, lockedObjects[i], false);
 520         }
 521     }
 522 
 523     public void insertLoopProxies(LoopExitNode loopExit, FrameStateBuilder loopEntryState) {
 524         DebugContext debug = graph.getDebug();
 525         for (int i = 0; i &lt; localsSize(); i++) {
 526             ValueNode value = locals[i];
 527             if (value != null &amp;&amp; value != TWO_SLOT_MARKER &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
 528                 debug.log(&quot; inserting proxy for %s&quot;, value);
<span class="line-modified"> 529                 locals[i] = ProxyNode.forValue(value, loopExit);</span>
 530             }
 531         }
 532         for (int i = 0; i &lt; stackSize(); i++) {
 533             ValueNode value = stack[i];
 534             if (value != null &amp;&amp; value != TWO_SLOT_MARKER &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
 535                 debug.log(&quot; inserting proxy for %s&quot;, value);
<span class="line-modified"> 536                 stack[i] = ProxyNode.forValue(value, loopExit);</span>
 537             }
 538         }
 539         for (int i = 0; i &lt; lockedObjects.length; i++) {
 540             ValueNode value = lockedObjects[i];
 541             if (value != null &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
 542                 debug.log(&quot; inserting proxy for %s&quot;, value);
<span class="line-modified"> 543                 lockedObjects[i] = ProxyNode.forValue(value, loopExit);</span>
 544             }
 545         }
 546     }
 547 
 548     public void insertProxies(Function&lt;ValueNode, ValueNode&gt; proxyFunction) {
 549         DebugContext debug = graph.getDebug();
 550         for (int i = 0; i &lt; localsSize(); i++) {
 551             ValueNode value = locals[i];
 552             if (value != null &amp;&amp; value != TWO_SLOT_MARKER) {
 553                 debug.log(&quot; inserting proxy for %s&quot;, value);
 554                 locals[i] = proxyFunction.apply(value);
 555             }
 556         }
 557         for (int i = 0; i &lt; stackSize(); i++) {
 558             ValueNode value = stack[i];
 559             if (value != null &amp;&amp; value != TWO_SLOT_MARKER) {
 560                 debug.log(&quot; inserting proxy for %s&quot;, value);
 561                 stack[i] = proxyFunction.apply(value);
 562             }
 563         }
</pre>
<hr />
<pre>
 631             if (locals[i] == value) {
 632                 return true;
 633             }
 634         }
 635         for (int i = 0; i &lt; stackSize(); i++) {
 636             if (stack[i] == value) {
 637                 return true;
 638             }
 639         }
 640         assert lockedObjects.length == monitorIds.length;
 641         for (int i = 0; i &lt; lockedObjects.length; i++) {
 642             if (lockedObjects[i] == value || monitorIds[i] == value) {
 643                 return true;
 644             }
 645         }
 646         return false;
 647     }
 648 
 649     public void clearNonLiveLocals(BciBlock block, LocalLiveness liveness, boolean liveIn) {
 650         /*
<span class="line-modified"> 651          * Non-live local clearing is mandatory for the entry block of an OSR compilation so that</span>
<span class="line-modified"> 652          * dead object slots at the OSR entry are cleared. It&#39;s not sufficient to rely on PiNodes</span>
<span class="line-modified"> 653          * with Kind.Illegal, because the conflicting branch might not have been parsed.</span>

 654          */
<span class="line-modified"> 655         boolean isOSREntryBlock = graph.isOSR() &amp;&amp; getMethod().equals(graph.method()) &amp;&amp; graph.getEntryBCI() == block.startBci;</span>
<span class="line-added"> 656         if (!clearNonLiveLocals &amp;&amp; !isOSREntryBlock) {</span>
 657             return;
 658         }
 659         if (liveIn) {
 660             for (int i = 0; i &lt; locals.length; i++) {
 661                 if (!liveness.localIsLiveIn(block, i)) {
 662                     assert locals[i] != TWO_SLOT_MARKER || locals[i - 1] == null : &quot;Clearing of second slot must have cleared the first slot too&quot;;
 663                     locals[i] = null;
 664                 }
 665             }
 666         } else {
 667             for (int i = 0; i &lt; locals.length; i++) {
 668                 if (!liveness.localIsLiveOut(block, i)) {
 669                     assert locals[i] != TWO_SLOT_MARKER || locals[i - 1] == null : &quot;Clearing of second slot must have cleared the first slot too&quot;;
 670                     locals[i] = null;
 671                 }
 672             }
 673         }
 674     }
 675 
 676     /**
</pre>
<hr />
<pre>
 738         return x;
 739     }
 740 
 741     /**
 742      * Stores a given local variable at the specified index. If the value occupies two slots, then
 743      * the next local variable index is also overwritten.
 744      *
 745      * @param i the index at which to store
 746      * @param slotKind the kind of the local variable from the point of view of the bytecodes
 747      * @param x the instruction which produces the value for the local
 748      */
 749     public void storeLocal(int i, JavaKind slotKind, ValueNode x) {
 750         assert verifyKind(slotKind, x);
 751 
 752         if (locals[i] == TWO_SLOT_MARKER) {
 753             /* Writing the second slot of a two-slot value invalidates the first slot. */
 754             locals[i - 1] = null;
 755         }
 756         locals[i] = x;
 757         if (slotKind.needsTwoSlots()) {
<span class="line-added"> 758             if (i &lt; locals.length - 2 &amp;&amp; locals[i + 2] == TWO_SLOT_MARKER) {</span>
<span class="line-added"> 759                 /*</span>
<span class="line-added"> 760                  * Writing a two-slot marker to an index previously occupied by a two-slot value:</span>
<span class="line-added"> 761                  * clear the old marker of the second slot.</span>
<span class="line-added"> 762                  */</span>
<span class="line-added"> 763                 locals[i + 2] = null;</span>
<span class="line-added"> 764             }</span>
 765             /* Writing a two-slot value: mark the second slot. */
 766             locals[i + 1] = TWO_SLOT_MARKER;
 767         } else if (i &lt; locals.length - 1 &amp;&amp; locals[i + 1] == TWO_SLOT_MARKER) {
 768             /*
 769              * Writing a one-slot value to an index previously occupied by a two-slot value: clear
 770              * the old marker of the second slot.
 771              */
 772             locals[i + 1] = null;
 773         }
 774     }
 775 
 776     /**
 777      * Pushes an instruction onto the stack with the expected type.
 778      *
 779      * @param slotKind the kind of the stack element from the point of view of the bytecodes
 780      * @param x the instruction to push onto the stack
 781      */
 782     public void push(JavaKind slotKind, ValueNode x) {
 783         assert verifyKind(slotKind, x);
 784 
</pre>
<hr />
<pre>
 786         if (slotKind.needsTwoSlots()) {
 787             xpush(TWO_SLOT_MARKER);
 788         }
 789     }
 790 
 791     public void pushReturn(JavaKind slotKind, ValueNode x) {
 792         if (slotKind != JavaKind.Void) {
 793             push(slotKind, x);
 794         }
 795     }
 796 
 797     /**
 798      * Pops an instruction off the stack with the expected type.
 799      *
 800      * @param slotKind the kind of the stack element from the point of view of the bytecodes
 801      * @return the instruction on the top of the stack
 802      */
 803     public ValueNode pop(JavaKind slotKind) {
 804         if (slotKind.needsTwoSlots()) {
 805             ValueNode s = xpop();
<span class="line-modified"> 806             assert s == TWO_SLOT_MARKER : s;</span>
 807         }
 808         ValueNode x = xpop();
 809         assert verifyKind(slotKind, x);
 810         return x;
 811     }
 812 
 813     private void xpush(ValueNode x) {
 814         assert x != null;
 815         stack[stackSize++] = x;
 816     }
 817 
 818     private ValueNode xpop() {
 819         ValueNode result = stack[--stackSize];
 820         assert result != null;
 821         return result;
 822     }
 823 
 824     private ValueNode xpeek() {
 825         ValueNode result = stack[stackSize - 1];
 826         assert result != null;
 827         return result;
 828     }
 829 
<span class="line-added"> 830     public ValueNode peekObject() {</span>
<span class="line-added"> 831         ValueNode x = xpeek();</span>
<span class="line-added"> 832         assert verifyKind(JavaKind.Object, x);</span>
<span class="line-added"> 833         return x;</span>
<span class="line-added"> 834     }</span>
<span class="line-added"> 835 </span>
 836     /**
 837      * Pop the specified number of slots off of this stack and return them as an array of
 838      * instructions.
 839      *
 840      * @return an array containing the arguments off of the stack
 841      */
 842     public ValueNode[] popArguments(int argSize) {
 843         ValueNode[] result = allocateArray(argSize);
 844         for (int i = argSize - 1; i &gt;= 0; i--) {
 845             ValueNode x = xpop();
 846             if (x == TWO_SLOT_MARKER) {
 847                 /* Ignore second slot of two-slot value. */
 848                 x = xpop();
 849             }
<span class="line-modified"> 850             assert x != null &amp;&amp; x != TWO_SLOT_MARKER : x;</span>
 851             result[i] = x;
 852         }
 853         return result;
 854     }
 855 
 856     /**
 857      * Clears all values on this stack.
 858      */
 859     public void clearStack() {
 860         stackSize = 0;
 861     }
 862 
 863     /**
 864      * Performs a raw stack operation as defined in the Java bytecode specification.
 865      *
 866      * @param opcode The Java bytecode.
 867      */
 868     public void stackOp(int opcode) {
 869         switch (opcode) {
 870             case POP: {
</pre>
<hr />
<pre>
1010 
1011     @Override
1012     public boolean isAfterSideEffect() {
1013         return sideEffects != null;
1014     }
1015 
1016     @Override
1017     public Iterable&lt;StateSplit&gt; sideEffects() {
1018         return sideEffects;
1019     }
1020 
1021     @Override
1022     public void addSideEffect(StateSplit sideEffect) {
1023         assert sideEffect != null;
1024         assert sideEffect.hasSideEffect();
1025         if (sideEffects == null) {
1026             sideEffects = new ArrayList&lt;&gt;(4);
1027         }
1028         sideEffects.add(sideEffect);
1029     }
<span class="line-added">1030 </span>
<span class="line-added">1031     public void replaceValue(ValueNode oldValue, ValueNode newValue) {</span>
<span class="line-added">1032         for (int i = 0; i &lt; locals.length; ++i) {</span>
<span class="line-added">1033             if (locals[i] == oldValue) {</span>
<span class="line-added">1034                 locals[i] = newValue;</span>
<span class="line-added">1035             }</span>
<span class="line-added">1036         }</span>
<span class="line-added">1037         for (int i = 0; i &lt; stack.length; ++i) {</span>
<span class="line-added">1038             if (stack[i] == oldValue) {</span>
<span class="line-added">1039                 stack[i] = newValue;</span>
<span class="line-added">1040             }</span>
<span class="line-added">1041         }</span>
<span class="line-added">1042     }</span>
1043 }
</pre>
</td>
</tr>
</table>
<center><a href="BytecodeParserOptions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphBuilderPhase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
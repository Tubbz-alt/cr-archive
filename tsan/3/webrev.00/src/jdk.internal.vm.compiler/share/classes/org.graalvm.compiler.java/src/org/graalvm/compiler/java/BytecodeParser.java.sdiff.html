<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BytecodeParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BciBlockMapping.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeParserOptions.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BytecodeParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.java;
  26 
  27 import static java.lang.String.format;
  28 import static java.lang.reflect.Modifier.STATIC;
  29 import static java.lang.reflect.Modifier.SYNCHRONIZED;

  30 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateRecompile;
  31 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateReprofile;
  32 import static jdk.vm.ci.meta.DeoptimizationAction.None;
  33 import static jdk.vm.ci.meta.DeoptimizationReason.ClassCastException;
<span class="line-removed">  34 import static jdk.vm.ci.meta.DeoptimizationReason.JavaSubroutineMismatch;</span>
  35 import static jdk.vm.ci.meta.DeoptimizationReason.NullCheckException;
  36 import static jdk.vm.ci.meta.DeoptimizationReason.RuntimeConstraint;
<span class="line-removed">  37 import static jdk.vm.ci.meta.DeoptimizationReason.TypeCheckedInliningViolated;</span>
  38 import static jdk.vm.ci.meta.DeoptimizationReason.UnreachedCode;
  39 import static jdk.vm.ci.meta.DeoptimizationReason.Unresolved;
  40 import static jdk.vm.ci.runtime.JVMCICompiler.INVOCATION_ENTRY_BCI;
  41 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  42 import static org.graalvm.compiler.bytecode.Bytecodes.AALOAD;
  43 import static org.graalvm.compiler.bytecode.Bytecodes.AASTORE;
  44 import static org.graalvm.compiler.bytecode.Bytecodes.ACONST_NULL;
  45 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD;
  46 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_0;
  47 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_1;
  48 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_2;
  49 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_3;
  50 import static org.graalvm.compiler.bytecode.Bytecodes.ANEWARRAY;
  51 import static org.graalvm.compiler.bytecode.Bytecodes.ARETURN;
  52 import static org.graalvm.compiler.bytecode.Bytecodes.ARRAYLENGTH;
  53 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE;
  54 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_0;
  55 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_1;
  56 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_2;
  57 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_3;
</pre>
<hr />
<pre>
 238 import static org.graalvm.compiler.bytecode.Bytecodes.RETURN;
 239 import static org.graalvm.compiler.bytecode.Bytecodes.SALOAD;
 240 import static org.graalvm.compiler.bytecode.Bytecodes.SASTORE;
 241 import static org.graalvm.compiler.bytecode.Bytecodes.SIPUSH;
 242 import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;
 243 import static org.graalvm.compiler.bytecode.Bytecodes.TABLESWITCH;
 244 import static org.graalvm.compiler.bytecode.Bytecodes.nameOf;
 245 import static org.graalvm.compiler.core.common.GraalOptions.DeoptALot;
 246 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 247 import static org.graalvm.compiler.core.common.GraalOptions.HotSpotPrintInlining;
 248 import static org.graalvm.compiler.core.common.GraalOptions.PrintProfilingInformation;
 249 import static org.graalvm.compiler.core.common.GraalOptions.StressExplicitExceptionCode;
 250 import static org.graalvm.compiler.core.common.GraalOptions.StressInvokeWithExceptionNode;
 251 import static org.graalvm.compiler.core.common.type.StampFactory.objectNonNull;
 252 import static org.graalvm.compiler.debug.GraalError.guarantee;
 253 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
 254 import static org.graalvm.compiler.java.BytecodeParserOptions.InlinePartialIntrinsicExitDuringParsing;
 255 import static org.graalvm.compiler.java.BytecodeParserOptions.TraceBytecodeParserLevel;
 256 import static org.graalvm.compiler.java.BytecodeParserOptions.TraceInlineDuringParsing;
 257 import static org.graalvm.compiler.java.BytecodeParserOptions.TraceParserPlugins;
<span class="line-removed"> 258 import static org.graalvm.compiler.java.BytecodeParserOptions.UseGuardedIntrinsics;</span>
<span class="line-removed"> 259 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FAST_PATH_PROBABILITY;</span>
 260 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LUDICROUSLY_FAST_PATH_PROBABILITY;
 261 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LUDICROUSLY_SLOW_PATH_PROBABILITY;
 262 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_DURING_PARSING;
 263 import static org.graalvm.compiler.nodes.type.StampTool.isPointerNonNull;
 264 
 265 import java.util.ArrayList;
 266 import java.util.Collections;
 267 import java.util.Comparator;
 268 import java.util.Formatter;
 269 import java.util.List;
 270 import java.util.function.Supplier;
 271 
 272 import jdk.internal.vm.compiler.collections.EconomicMap;
 273 import jdk.internal.vm.compiler.collections.Equivalence;

 274 import org.graalvm.compiler.api.replacements.Fold;

 275 import org.graalvm.compiler.api.replacements.Snippet;
 276 import org.graalvm.compiler.bytecode.Bytecode;
 277 import org.graalvm.compiler.bytecode.BytecodeDisassembler;
 278 import org.graalvm.compiler.bytecode.BytecodeLookupSwitch;
 279 import org.graalvm.compiler.bytecode.BytecodeProvider;
 280 import org.graalvm.compiler.bytecode.BytecodeStream;
 281 import org.graalvm.compiler.bytecode.BytecodeSwitch;
 282 import org.graalvm.compiler.bytecode.BytecodeTableSwitch;
 283 import org.graalvm.compiler.bytecode.Bytecodes;
 284 import org.graalvm.compiler.bytecode.Bytes;
 285 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
 286 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecodeProvider;
 287 import org.graalvm.compiler.core.common.GraalOptions;
 288 import org.graalvm.compiler.core.common.PermanentBailoutException;

 289 import org.graalvm.compiler.core.common.calc.CanonicalCondition;
 290 import org.graalvm.compiler.core.common.calc.Condition;
 291 import org.graalvm.compiler.core.common.calc.Condition.CanonicalizedCondition;
 292 import org.graalvm.compiler.core.common.calc.FloatConvert;
 293 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 294 import org.graalvm.compiler.core.common.type.IntegerStamp;
 295 import org.graalvm.compiler.core.common.type.ObjectStamp;
 296 import org.graalvm.compiler.core.common.type.Stamp;
 297 import org.graalvm.compiler.core.common.type.StampFactory;
 298 import org.graalvm.compiler.core.common.type.StampPair;
 299 import org.graalvm.compiler.core.common.type.TypeReference;
 300 import org.graalvm.compiler.core.common.util.Util;
 301 import org.graalvm.compiler.debug.Assertions;
 302 import org.graalvm.compiler.debug.CounterKey;
 303 import org.graalvm.compiler.debug.DebugCloseable;
 304 import org.graalvm.compiler.debug.DebugContext;
 305 import org.graalvm.compiler.debug.DebugOptions;
 306 import org.graalvm.compiler.debug.GraalError;
 307 import org.graalvm.compiler.debug.Indent;
 308 import org.graalvm.compiler.debug.MethodFilter;
</pre>
<hr />
<pre>
 336 import org.graalvm.compiler.nodes.Invoke;
 337 import org.graalvm.compiler.nodes.InvokeNode;
 338 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 339 import org.graalvm.compiler.nodes.KillingBeginNode;
 340 import org.graalvm.compiler.nodes.LogicConstantNode;
 341 import org.graalvm.compiler.nodes.LogicNegationNode;
 342 import org.graalvm.compiler.nodes.LogicNode;
 343 import org.graalvm.compiler.nodes.LoopBeginNode;
 344 import org.graalvm.compiler.nodes.LoopEndNode;
 345 import org.graalvm.compiler.nodes.LoopExitNode;
 346 import org.graalvm.compiler.nodes.MergeNode;
 347 import org.graalvm.compiler.nodes.NodeView;
 348 import org.graalvm.compiler.nodes.ParameterNode;
 349 import org.graalvm.compiler.nodes.PiNode;
 350 import org.graalvm.compiler.nodes.ReturnNode;
 351 import org.graalvm.compiler.nodes.StartNode;
 352 import org.graalvm.compiler.nodes.StateSplit;
 353 import org.graalvm.compiler.nodes.StructuredGraph;
 354 import org.graalvm.compiler.nodes.UnwindNode;
 355 import org.graalvm.compiler.nodes.ValueNode;

 356 import org.graalvm.compiler.nodes.calc.AddNode;
 357 import org.graalvm.compiler.nodes.calc.AndNode;
 358 import org.graalvm.compiler.nodes.calc.CompareNode;
 359 import org.graalvm.compiler.nodes.calc.ConditionalNode;
 360 import org.graalvm.compiler.nodes.calc.FloatConvertNode;
 361 import org.graalvm.compiler.nodes.calc.FloatDivNode;

 362 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
 363 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
 364 import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;

 365 import org.graalvm.compiler.nodes.calc.IsNullNode;
 366 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 367 import org.graalvm.compiler.nodes.calc.MulNode;
 368 import org.graalvm.compiler.nodes.calc.NarrowNode;
 369 import org.graalvm.compiler.nodes.calc.NegateNode;
<span class="line-removed"> 370 import org.graalvm.compiler.nodes.calc.NormalizeCompareNode;</span>
 371 import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
 372 import org.graalvm.compiler.nodes.calc.OrNode;
 373 import org.graalvm.compiler.nodes.calc.RemNode;
 374 import org.graalvm.compiler.nodes.calc.RightShiftNode;
 375 import org.graalvm.compiler.nodes.calc.SignExtendNode;
 376 import org.graalvm.compiler.nodes.calc.SignedDivNode;
 377 import org.graalvm.compiler.nodes.calc.SignedRemNode;
 378 import org.graalvm.compiler.nodes.calc.SubNode;
 379 import org.graalvm.compiler.nodes.calc.UnsignedRightShiftNode;
 380 import org.graalvm.compiler.nodes.calc.XorNode;
 381 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
 382 import org.graalvm.compiler.nodes.extended.AnchoringNode;
 383 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;
 384 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode;
 385 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;

 386 import org.graalvm.compiler.nodes.extended.GuardingNode;
 387 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
 388 import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
 389 import org.graalvm.compiler.nodes.extended.LoadHubNode;
<span class="line-removed"> 390 import org.graalvm.compiler.nodes.extended.LoadMethodNode;</span>
 391 import org.graalvm.compiler.nodes.extended.MembarNode;
 392 import org.graalvm.compiler.nodes.extended.StateSplitProxyNode;
<span class="line-removed"> 393 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;</span>
 394 import org.graalvm.compiler.nodes.graphbuilderconf.ClassInitializationPlugin;
 395 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 396 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.BytecodeExceptionMode;
 397 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 398 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 399 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo;
 400 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 401 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 402 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.InvocationPluginReceiver;
 403 import org.graalvm.compiler.nodes.graphbuilderconf.InvokeDynamicPlugin;
 404 import org.graalvm.compiler.nodes.graphbuilderconf.NodePlugin;
 405 import org.graalvm.compiler.nodes.graphbuilderconf.ProfilingPlugin;
 406 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 407 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
 408 import org.graalvm.compiler.nodes.java.FinalFieldBarrierNode;
 409 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 410 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 411 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 412 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 413 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 414 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 415 import org.graalvm.compiler.nodes.java.MonitorExitNode;
 416 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 417 import org.graalvm.compiler.nodes.java.NewArrayNode;
 418 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 419 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
 420 import org.graalvm.compiler.nodes.java.RegisterFinalizerNode;
 421 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 422 import org.graalvm.compiler.nodes.java.StoreIndexedNode;


 423 import org.graalvm.compiler.nodes.spi.StampProvider;
 424 import org.graalvm.compiler.nodes.type.StampTool;
 425 import org.graalvm.compiler.nodes.util.GraphUtil;
 426 import org.graalvm.compiler.options.OptionValues;
 427 import org.graalvm.compiler.phases.OptimisticOptimizations;
 428 import org.graalvm.compiler.phases.util.ValueMergeUtil;
 429 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 430 import jdk.internal.vm.compiler.word.LocationIdentity;
 431 
 432 import jdk.vm.ci.code.BailoutException;
 433 import jdk.vm.ci.code.BytecodeFrame;
 434 import jdk.vm.ci.code.CodeUtil;
 435 import jdk.vm.ci.code.site.InfopointReason;
 436 import jdk.vm.ci.meta.Constant;
 437 import jdk.vm.ci.meta.ConstantPool;
 438 import jdk.vm.ci.meta.ConstantReflectionProvider;
 439 import jdk.vm.ci.meta.DeoptimizationAction;
 440 import jdk.vm.ci.meta.DeoptimizationReason;
 441 import jdk.vm.ci.meta.JavaConstant;
 442 import jdk.vm.ci.meta.JavaField;
 443 import jdk.vm.ci.meta.JavaKind;
 444 import jdk.vm.ci.meta.JavaMethod;
 445 import jdk.vm.ci.meta.JavaType;
 446 import jdk.vm.ci.meta.JavaTypeProfile;
<span class="line-removed"> 447 import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;</span>
 448 import jdk.vm.ci.meta.LineNumberTable;
 449 import jdk.vm.ci.meta.MetaAccessProvider;
 450 import jdk.vm.ci.meta.ProfilingInfo;
 451 import jdk.vm.ci.meta.RawConstant;
 452 import jdk.vm.ci.meta.ResolvedJavaField;
 453 import jdk.vm.ci.meta.ResolvedJavaMethod;
 454 import jdk.vm.ci.meta.ResolvedJavaType;
 455 import jdk.vm.ci.meta.Signature;
 456 import jdk.vm.ci.meta.TriState;
 457 
 458 /**
 459  * The {@code GraphBuilder} class parses the bytecode of a method and builds the IR graph.
 460  */
 461 public class BytecodeParser implements GraphBuilderContext {
 462 
 463     /**
 464      * The minimum value to which {@link BytecodeParserOptions#TraceBytecodeParserLevel} must be set
 465      * to trace the bytecode instructions as they are parsed.
 466      */
 467     public static final int TRACELEVEL_INSTRUCTIONS = 1;
</pre>
<hr />
<pre>
 469     /**
 470      * The minimum value to which {@link BytecodeParserOptions#TraceBytecodeParserLevel} must be set
 471      * to emit the frame state for each traced bytecode instruction.
 472      */
 473     public static final int TRACELEVEL_STATE = 2;
 474 
 475     /**
 476      * The minimum value to which {@link BytecodeParserOptions#TraceBytecodeParserLevel} must be set
 477      * to emit the block map for each traced method.
 478      */
 479     public static final int TRACELEVEL_BLOCKMAP = 3;
 480 
 481     /**
 482      * Meters the number of actual bytecodes parsed.
 483      */
 484     public static final CounterKey BytecodesParsed = DebugContext.counter(&quot;BytecodesParsed&quot;);
 485 
 486     protected static final CounterKey EXPLICIT_EXCEPTIONS = DebugContext.counter(&quot;ExplicitExceptions&quot;);
 487 
 488     /**
<span class="line-modified"> 489      * A scoped object for tasks to be performed after parsing an intrinsic such as processing</span>
 490      * {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frames states.
 491      */
<span class="line-modified"> 492     static class IntrinsicScope implements AutoCloseable {</span>

 493         FrameState stateBefore;
 494         final Mark mark;
 495         final BytecodeParser parser;
 496         List&lt;ReturnToCallerData&gt; returnDataList;
 497 
 498         /**
 499          * Creates a scope for root parsing an intrinsic.
 500          *
 501          * @param parser the parsing context of the intrinsic
 502          */
<span class="line-modified"> 503         IntrinsicScope(BytecodeParser parser) {</span>
 504             this.parser = parser;
 505             assert parser.parent == null;
 506             assert parser.bci() == 0;
 507             mark = null;

 508         }
 509 
 510         /**
<span class="line-modified"> 511          * Creates a scope for parsing an intrinsic during graph builder inlining.</span>
 512          *
 513          * @param parser the parsing context of the (non-intrinsic) method calling the intrinsic
 514          * @param args the arguments to the call
 515          */
<span class="line-modified"> 516         IntrinsicScope(BytecodeParser parser, JavaKind[] argSlotKinds, ValueNode[] args) {</span>

 517             assert !parser.parsingIntrinsic();
 518             this.parser = parser;
 519             mark = parser.getGraph().getMark();

 520             stateBefore = parser.frameState.create(parser.bci(), parser.getNonIntrinsicAncestor(), false, argSlotKinds, args);
 521         }
 522 
 523         @Override
 524         public void close() {
<span class="line-modified"> 525             IntrinsicContext intrinsic = parser.intrinsicContext;</span>
<span class="line-removed"> 526             if (intrinsic != null &amp;&amp; intrinsic.isPostParseInlined()) {</span>
<span class="line-removed"> 527                 return;</span>
<span class="line-removed"> 528             }</span>
<span class="line-removed"> 529 </span>
<span class="line-removed"> 530             processPlaceholderFrameStates(intrinsic);</span>
 531         }
 532 
 533         /**
 534          * Fixes up the {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frame states
 535          * added to the graph while parsing/inlining the intrinsic for which this object exists.
 536          */
<span class="line-modified"> 537         private void processPlaceholderFrameStates(IntrinsicContext intrinsic) {</span>
 538             StructuredGraph graph = parser.getGraph();
 539             graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;Before processPlaceholderFrameStates in %s&quot;, parser.method);
<span class="line-removed"> 540             boolean sawInvalidFrameState = false;</span>
 541             for (Node node : graph.getNewNodes(mark)) {
 542                 if (node instanceof FrameState) {
 543                     FrameState frameState = (FrameState) node;
 544                     if (BytecodeFrame.isPlaceholderBci(frameState.bci)) {
 545                         if (frameState.bci == BytecodeFrame.AFTER_BCI) {
 546                             if (parser.getInvokeReturnType() == null) {
 547                                 // A frame state in a root compiled intrinsic.
<span class="line-modified"> 548                                 assert intrinsic.isCompilationRoot();</span>
 549                                 FrameState newFrameState = graph.add(new FrameState(BytecodeFrame.INVALID_FRAMESTATE_BCI));
 550                                 frameState.replaceAndDelete(newFrameState);
 551                             } else {
 552                                 JavaKind returnKind = parser.getInvokeReturnType().getJavaKind();
 553                                 FrameStateBuilder frameStateBuilder = parser.frameState;
 554                                 assert !frameState.rethrowException();
 555                                 if (frameState.stackSize() != 0) {
 556                                     ValueNode returnVal = frameState.stackAt(0);
 557                                     if (!ReturnToCallerData.containsReturnValue(returnDataList, returnVal)) {
<span class="line-modified"> 558                                         throw new GraalError(&quot;AFTER_BCI frame state within an intrinsic has a non-return value on the stack: %s&quot;, returnVal);</span>
 559                                     }
 560 
 561                                     // Swap the top-of-stack value with the return value
 562                                     ValueNode tos = frameStateBuilder.pop(returnKind);
 563                                     assert tos.getStackKind() == returnVal.getStackKind();
 564                                     FrameState newFrameState = frameStateBuilder.create(parser.stream.nextBCI(), parser.getNonIntrinsicAncestor(), false, new JavaKind[]{returnKind},
 565                                                     new ValueNode[]{returnVal});
 566                                     frameState.replaceAndDelete(newFrameState);
 567                                     newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());
 568                                     frameStateBuilder.push(returnKind, tos);
 569                                 } else if (returnKind != JavaKind.Void) {
<span class="line-modified"> 570                                     // If the intrinsic returns a non-void value, then any frame</span>
<span class="line-removed"> 571                                     // state with an empty stack is invalid as it cannot</span>
<span class="line-removed"> 572                                     // be used to deoptimize to just after the call returns.</span>
<span class="line-removed"> 573                                     // These invalid frame states are expected to be removed</span>
<span class="line-removed"> 574                                     // by later compilation stages.</span>
<span class="line-removed"> 575                                     FrameState newFrameState = graph.add(new FrameState(BytecodeFrame.INVALID_FRAMESTATE_BCI));</span>
<span class="line-removed"> 576                                     newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());</span>
<span class="line-removed"> 577                                     frameState.replaceAndDelete(newFrameState);</span>
<span class="line-removed"> 578                                     sawInvalidFrameState = true;</span>
 579                                 } else {
 580                                     // An intrinsic for a void method.
 581                                     FrameState newFrameState = frameStateBuilder.create(parser.stream.nextBCI(), null);
 582                                     newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());
 583                                     frameState.replaceAndDelete(newFrameState);
 584                                 }
 585                             }
 586                         } else if (frameState.bci == BytecodeFrame.BEFORE_BCI) {
 587                             if (stateBefore == null) {
 588                                 stateBefore = graph.start().stateAfter();
 589                             }
 590                             if (stateBefore != frameState) {
 591                                 frameState.replaceAndDelete(stateBefore);
 592                             }
<span class="line-modified"> 593                         } else if (frameState.bci == BytecodeFrame.AFTER_EXCEPTION_BCI) {</span>
 594                             // This is a frame state for the entry point to an exception
 595                             // dispatcher in an intrinsic. For example, the invoke denoting
 596                             // a partial intrinsic exit will have an edge to such a
 597                             // dispatcher if the profile for the original invoke being
 598                             // intrinsified indicates an exception was seen. As per JVM
 599                             // bytecode semantics, the interpreter expects a single
 600                             // value on the stack on entry to an exception handler,
 601                             // namely the exception object.
 602                             assert frameState.rethrowException();
 603                             ValueNode exceptionValue = frameState.stackAt(0);
<span class="line-removed"> 604                             ExceptionObjectNode exceptionObject = (ExceptionObjectNode) GraphUtil.unproxify(exceptionValue);</span>
 605                             FrameStateBuilder dispatchState = parser.frameState.copy();
 606                             dispatchState.clearStack();
 607                             dispatchState.push(JavaKind.Object, exceptionValue);
 608                             dispatchState.setRethrowException(true);
<span class="line-modified"> 609                             FrameState newFrameState = dispatchState.create(parser.bci(), exceptionObject);</span>
<span class="line-modified"> 610                             frameState.replaceAndDelete(newFrameState);</span>
<span class="line-modified"> 611                             newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());</span>








 612                         } else {
<span class="line-modified"> 613                             assert frameState.bci == BytecodeFrame.INVALID_FRAMESTATE_BCI;</span>
 614                         }
 615                     }
 616                 }
 617             }
<span class="line-modified"> 618             if (sawInvalidFrameState) {</span>


































 619                 JavaKind returnKind = parser.getInvokeReturnType().getJavaKind();
<span class="line-modified"> 620                 FrameStateBuilder frameStateBuilder = parser.frameState;</span>
<span class="line-modified"> 621                 ValueNode returnValue = frameStateBuilder.pop(returnKind);</span>
<span class="line-modified"> 622                 StateSplitProxyNode proxy = graph.add(new StateSplitProxyNode(returnValue));</span>
<span class="line-modified"> 623                 parser.lastInstr.setNext(proxy);</span>
<span class="line-modified"> 624                 frameStateBuilder.push(returnKind, proxy);</span>
<span class="line-modified"> 625                 proxy.setStateAfter(parser.createFrameState(parser.stream.nextBCI(), proxy));</span>
<span class="line-modified"> 626                 parser.lastInstr = proxy;</span>




























































































































































 627             }
<span class="line-removed"> 628             graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;After processPlaceholderFrameStates in %s&quot;, parser.method);</span>
 629         }
 630     }
 631 
 632     private static class Target {
<span class="line-modified"> 633         FixedNode fixed;</span>
<span class="line-modified"> 634         FrameStateBuilder state;</span>







 635 
<span class="line-modified"> 636         Target(FixedNode fixed, FrameStateBuilder state) {</span>
<span class="line-modified"> 637             this.fixed = fixed;</span>
 638             this.state = state;

 639         }
 640     }
 641 
 642     @SuppressWarnings(&quot;serial&quot;)
 643     public static class BytecodeParserError extends GraalError {
 644 
 645         public BytecodeParserError(Throwable cause) {
 646             super(cause);
 647         }
 648 
 649         public BytecodeParserError(String msg, Object... args) {
 650             super(msg, args);
 651         }
 652     }
 653 
 654     protected static class ReturnToCallerData {
 655         protected final ValueNode returnValue;
 656         protected final FixedWithNextNode beforeReturnNode;
 657 
 658         protected ReturnToCallerData(ValueNode returnValue, FixedWithNextNode beforeReturnNode) {
</pre>
<hr />
<pre>
 697     private FixedWithNextNode[] firstInstructionArray;
 698     private FrameStateBuilder[] entryStateArray;
 699 
 700     private boolean finalBarrierRequired;
 701     private ValueNode originalReceiver;
 702     private final boolean eagerInitializing;
 703     private final boolean uninitializedIsError;
 704     private final int traceLevel;
 705 
 706     protected BytecodeParser(GraphBuilderPhase.Instance graphBuilderInstance, StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method,
 707                     int entryBCI, IntrinsicContext intrinsicContext) {
 708         this.bytecodeProvider = intrinsicContext == null ? new ResolvedJavaMethodBytecodeProvider() : intrinsicContext.getBytecodeProvider();
 709         this.code = bytecodeProvider.getBytecode(method);
 710         this.method = code.getMethod();
 711         this.graphBuilderInstance = graphBuilderInstance;
 712         this.graph = graph;
 713         this.options = graph.getOptions();
 714         this.debug = graph.getDebug();
 715         this.graphBuilderConfig = graphBuilderInstance.graphBuilderConfig;
 716         this.optimisticOpts = graphBuilderInstance.optimisticOpts;
<span class="line-modified"> 717         this.metaAccess = graphBuilderInstance.metaAccess;</span>
<span class="line-removed"> 718         this.stampProvider = graphBuilderInstance.stampProvider;</span>
<span class="line-removed"> 719         this.constantReflection = graphBuilderInstance.constantReflection;</span>
<span class="line-removed"> 720         this.constantFieldProvider = graphBuilderInstance.constantFieldProvider;</span>
 721         this.stream = new BytecodeStream(code.getCode());
 722         this.profilingInfo = graph.useProfilingInfo() ? code.getProfilingInfo() : null;
 723         this.constantPool = code.getConstantPool();
 724         this.intrinsicContext = intrinsicContext;
 725         this.entryBCI = entryBCI;
 726         this.parent = parent;
 727 
 728         ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
<span class="line-modified"> 729         if (classInitializationPlugin != null &amp;&amp; graphBuilderConfig.eagerResolving()) {</span>
<span class="line-modified"> 730             uninitializedIsError = eagerInitializing = !classInitializationPlugin.supportsLazyInitialization(constantPool);</span>

 731         } else {
 732             eagerInitializing = graphBuilderConfig.eagerResolving();
 733             uninitializedIsError = graphBuilderConfig.unresolvedIsError();
 734         }
 735 
 736         assert code.getCode() != null : &quot;method must contain bytecodes: &quot; + method;
 737 
 738         if (graphBuilderConfig.insertFullInfopoints() &amp;&amp; !parsingIntrinsic()) {
 739             lnt = code.getLineNumberTable();
 740             previousLineNumber = -1;
 741         }
 742 
 743         assert !GraalOptions.TrackNodeSourcePosition.getValue(options) || graph.trackNodeSourcePosition();
 744         if (graphBuilderConfig.trackNodeSourcePosition() || (parent != null &amp;&amp; parent.graph.trackNodeSourcePosition())) {
 745             graph.setTrackNodeSourcePosition();
 746         }
 747 
 748         int level = TraceBytecodeParserLevel.getValue(options);
 749         this.traceLevel = level != 0 ? refineTraceLevel(level) : 0;
 750     }
</pre>
<hr />
<pre>
 761                 return 0;
 762             }
 763         }
 764         return level;
 765     }
 766 
 767     protected GraphBuilderPhase.Instance getGraphBuilderInstance() {
 768         return graphBuilderInstance;
 769     }
 770 
 771     public ValueNode getUnwindValue() {
 772         return unwindValue;
 773     }
 774 
 775     public FixedWithNextNode getBeforeUnwindNode() {
 776         return this.beforeUnwindNode;
 777     }
 778 
 779     @SuppressWarnings(&quot;try&quot;)
 780     protected void buildRootMethod() {
<span class="line-modified"> 781         FrameStateBuilder startFrameState = new FrameStateBuilder(this, code, graph);</span>
 782         startFrameState.initializeForMethodStart(graph.getAssumptions(), graphBuilderConfig.eagerResolving() || intrinsicContext != null, graphBuilderConfig.getPlugins());
 783 
 784         try (IntrinsicScope s = intrinsicContext != null ? new IntrinsicScope(this) : null) {
 785             build(graph.start(), startFrameState);
 786         }
 787 
 788         cleanupFinalGraph();
 789         ComputeLoopFrequenciesClosure.compute(graph);
 790     }
 791 
 792     @SuppressWarnings(&quot;try&quot;)
 793     protected void build(FixedWithNextNode startInstruction, FrameStateBuilder startFrameState) {
 794         if (PrintProfilingInformation.getValue(options) &amp;&amp; profilingInfo != null) {
 795             TTY.println(&quot;Profiling info for &quot; + method.format(&quot;%H.%n(%p)&quot;));
 796             TTY.println(Util.indent(profilingInfo.toString(method, CodeUtil.NEW_LINE), &quot;  &quot;));
 797         }
 798 
 799         try (Indent indent = debug.logAndIndent(&quot;build graph for %s&quot;, method)) {
 800             if (bytecodeProvider.shouldRecordMethodDependencies()) {
 801                 assert getParent() != null || method.equals(graph.method());
</pre>
<hr />
<pre>
 929         GraphUtil.normalizeLoops(graph);
 930 
 931         // Remove dead parameters.
 932         for (ParameterNode param : graph.getNodes(ParameterNode.TYPE)) {
 933             if (param.hasNoUsages()) {
 934                 assert param.inputs().isEmpty();
 935                 param.safeDelete();
 936             }
 937         }
 938 
 939         // Remove redundant begin nodes.
 940         for (BeginNode beginNode : graph.getNodes(BeginNode.TYPE)) {
 941             Node predecessor = beginNode.predecessor();
 942             if (predecessor instanceof ControlSplitNode) {
 943                 // The begin node is necessary.
 944             } else if (!beginNode.hasUsages()) {
 945                 GraphUtil.unlinkFixedNode(beginNode);
 946                 beginNode.safeDelete();
 947             }
 948         }





 949     }
 950 
 951     /**
 952      * Creates the frame state after the start node of a graph for an {@link IntrinsicContext
 953      * intrinsic} that is the parse root (either for root compiling or for post-parse inlining).
 954      */
 955     private FrameState createStateAfterStartOfReplacementGraph() {
 956         assert parent == null;
 957         assert frameState.getMethod().equals(intrinsicContext.getIntrinsicMethod());
 958         assert bci() == 0;
 959         assert frameState.stackSize() == 0;
 960         FrameState stateAfterStart;
 961         if (intrinsicContext.isPostParseInlined()) {
 962             stateAfterStart = graph.add(new FrameState(BytecodeFrame.BEFORE_BCI));
 963         } else {
 964             ResolvedJavaMethod original = intrinsicContext.getOriginalMethod();
 965             ValueNode[] locals;
 966             if (original.getMaxLocals() == frameState.localsSize() || original.isNative()) {
 967                 locals = new ValueNode[original.getMaxLocals()];
 968                 for (int i = 0; i &lt; locals.length; i++) {
</pre>
<hr />
<pre>
1104      */
1105     protected void handleUnresolvedInvoke(JavaMethod javaMethod, InvokeKind invokeKind) {
1106         assert !graphBuilderConfig.unresolvedIsError();
1107         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1108         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1109     }
1110 
1111     /**
1112      * @return the entry point to exception dispatch
1113      */
1114     private AbstractBeginNode handleException(ValueNode exceptionObject, int bci, boolean deoptimizeOnly) {
1115         FixedWithNextNode currentLastInstr = lastInstr;
1116         assert bci == BytecodeFrame.BEFORE_BCI || bci == bci() : &quot;invalid bci&quot;;
1117         debug.log(&quot;Creating exception dispatch edges at %d, exception object=%s, exception seen=%s&quot;, bci, exceptionObject, (profilingInfo == null ? &quot;&quot; : profilingInfo.getExceptionSeen(bci)));
1118 
1119         FrameStateBuilder dispatchState = frameState.copy();
1120         dispatchState.clearStack();
1121 
1122         AbstractBeginNode dispatchBegin;
1123         if (exceptionObject == null) {
<span class="line-modified">1124             ExceptionObjectNode newExceptionObject = graph.add(new ExceptionObjectNode(metaAccess));</span>
<span class="line-modified">1125             dispatchBegin = newExceptionObject;</span>
<span class="line-removed">1126             dispatchState.push(JavaKind.Object, dispatchBegin);</span>
1127             dispatchState.setRethrowException(true);
1128             newExceptionObject.setStateAfter(dispatchState.create(bci, newExceptionObject));

1129         } else {
1130             dispatchBegin = graph.add(new BeginNode());
1131             dispatchState.push(JavaKind.Object, exceptionObject);
1132             dispatchState.setRethrowException(true);
1133         }
1134         this.controlFlowSplit = true;
1135         FixedWithNextNode afterExceptionLoaded = finishInstruction(dispatchBegin, dispatchState);
1136 
1137         if (deoptimizeOnly) {
1138             DeoptimizeNode deoptimizeNode = graph.add(new DeoptimizeNode(DeoptimizationAction.None, DeoptimizationReason.TransferToInterpreter));
1139             afterExceptionLoaded.setNext(BeginNode.begin(deoptimizeNode));
1140         } else {
1141             createHandleExceptionTarget(afterExceptionLoaded, bci, dispatchState);
1142         }
1143         assert currentLastInstr == lastInstr;
1144         return dispatchBegin;
1145     }
1146 
1147     protected void createHandleExceptionTarget(FixedWithNextNode afterExceptionLoaded, int bci, FrameStateBuilder dispatchState) {
1148         FixedWithNextNode afterInstrumentation = afterExceptionLoaded;
1149         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
<span class="line-modified">1150             afterInstrumentation = plugin.instrumentExceptionDispatch(graph, afterInstrumentation);</span>
1151             assert afterInstrumentation.next() == null : &quot;exception dispatch instrumentation will be linked to dispatch block&quot;;
1152         }
1153 
1154         BciBlock dispatchBlock = currentBlock.exceptionDispatchBlock();
1155         /*
1156          * The exception dispatch block is always for the last bytecode of a block, so if we are not
1157          * at the endBci yet, there is no exception handler for this bci and we can unwind
1158          * immediately.
1159          */
1160         if (bci != currentBlock.endBci || dispatchBlock == null) {
1161             dispatchBlock = blockMap.getUnwindBlock();
1162         }
1163 
1164         FixedNode target = createTarget(dispatchBlock, dispatchState);
1165         afterInstrumentation.setNext(target);
1166     }
1167 
1168     protected ValueNode genLoadIndexed(ValueNode array, ValueNode index, GuardingNode boundsCheck, JavaKind kind) {
<span class="line-modified">1169         return LoadIndexedNode.create(graph.getAssumptions(), array, index, boundsCheck, kind, metaAccess, constantReflection);</span>
1170     }
1171 
1172     protected void genStoreIndexed(ValueNode array, ValueNode index, GuardingNode boundsCheck, GuardingNode storeCheck, JavaKind kind, ValueNode value) {
1173         add(new StoreIndexedNode(array, index, boundsCheck, storeCheck, kind, value));
1174     }
1175 
1176     protected ValueNode genIntegerAdd(ValueNode x, ValueNode y) {
1177         return AddNode.create(x, y, NodeView.DEFAULT);
1178     }
1179 
1180     protected ValueNode genIntegerSub(ValueNode x, ValueNode y) {
1181         return SubNode.create(x, y, NodeView.DEFAULT);
1182     }
1183 
1184     protected ValueNode genIntegerMul(ValueNode x, ValueNode y) {
1185         return MulNode.create(x, y, NodeView.DEFAULT);
1186     }
1187 
1188     protected ValueNode genFloatAdd(ValueNode x, ValueNode y) {
1189         return AddNode.create(x, y, NodeView.DEFAULT);
</pre>
<hr />
<pre>
1225         return RightShiftNode.create(x, y, NodeView.DEFAULT);
1226     }
1227 
1228     protected ValueNode genUnsignedRightShift(ValueNode x, ValueNode y) {
1229         return UnsignedRightShiftNode.create(x, y, NodeView.DEFAULT);
1230     }
1231 
1232     protected ValueNode genAnd(ValueNode x, ValueNode y) {
1233         return AndNode.create(x, y, NodeView.DEFAULT);
1234     }
1235 
1236     protected ValueNode genOr(ValueNode x, ValueNode y) {
1237         return OrNode.create(x, y, NodeView.DEFAULT);
1238     }
1239 
1240     protected ValueNode genXor(ValueNode x, ValueNode y) {
1241         return XorNode.create(x, y, NodeView.DEFAULT);
1242     }
1243 
1244     protected ValueNode genNormalizeCompare(ValueNode x, ValueNode y, boolean isUnorderedLess) {
<span class="line-modified">1245         return NormalizeCompareNode.create(x, y, isUnorderedLess, JavaKind.Int, constantReflection);</span>




1246     }
1247 
1248     protected ValueNode genFloatConvert(FloatConvert op, ValueNode input) {
1249         return FloatConvertNode.create(op, input, NodeView.DEFAULT);
1250     }
1251 
1252     protected ValueNode genNarrow(ValueNode input, int bitCount) {
1253         return NarrowNode.create(input, bitCount, NodeView.DEFAULT);
1254     }
1255 
1256     protected ValueNode genSignExtend(ValueNode input, int bitCount) {
1257         return SignExtendNode.create(input, bitCount, NodeView.DEFAULT);
1258     }
1259 
1260     protected ValueNode genZeroExtend(ValueNode input, int bitCount) {
1261         return ZeroExtendNode.create(input, bitCount, NodeView.DEFAULT);
1262     }
1263 
1264     protected void genGoto() {
1265         ProfilingPlugin profilingPlugin = this.graphBuilderConfig.getPlugins().getProfilingPlugin();
1266         if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
1267             FrameState stateBefore = createCurrentFrameState();
1268             int targetBci = currentBlock.getSuccessor(0).startBci;
1269             profilingPlugin.profileGoto(this, method, bci(), targetBci, stateBefore);
1270         }
1271         appendGoto(currentBlock.getSuccessor(0));
1272         assert currentBlock.numNormalSuccessors() == 1;
1273     }
1274 
1275     protected LogicNode genObjectEquals(ValueNode x, ValueNode y) {
<span class="line-modified">1276         return ObjectEqualsNode.create(constantReflection, metaAccess, options, x, y, NodeView.DEFAULT);</span>
1277     }
1278 
1279     protected LogicNode genIntegerEquals(ValueNode x, ValueNode y) {
<span class="line-modified">1280         return IntegerEqualsNode.create(constantReflection, metaAccess, options, null, x, y, NodeView.DEFAULT);</span>
1281     }
1282 
1283     protected LogicNode genIntegerLessThan(ValueNode x, ValueNode y) {
<span class="line-modified">1284         return IntegerLessThanNode.create(constantReflection, metaAccess, options, null, x, y, NodeView.DEFAULT);</span>
1285     }
1286 
1287     protected ValueNode genUnique(ValueNode x) {
1288         return graph.addOrUniqueWithInputs(x);
1289     }
1290 
1291     protected LogicNode genUnique(LogicNode x) {
1292         return graph.addOrUniqueWithInputs(x);
1293     }
1294 
1295     protected ValueNode genIfNode(LogicNode condition, FixedNode trueSuccessor, FixedNode falseSuccessor, double d) {
1296         return new IfNode(condition, trueSuccessor, falseSuccessor, d);
1297     }
1298 
1299     protected void genThrow() {
1300         genInfoPointNode(InfopointReason.BYTECODE_POSITION, null);
1301 
1302         ValueNode exception = maybeEmitExplicitNullCheck(frameState.pop(JavaKind.Object));
1303         if (!StampTool.isPointerNonNull(exception.stamp(NodeView.DEFAULT))) {
1304             FixedGuardNode nullCheck = append(new FixedGuardNode(graph.addOrUniqueWithInputs(IsNullNode.create(exception)), NullCheckException, InvalidateReprofile, true));
1305             exception = graph.maybeAddOrUnique(PiNode.create(exception, exception.stamp(NodeView.DEFAULT).join(objectNonNull()), nullCheck));
1306         }
1307         lastInstr.setNext(handleException(exception, bci(), false));
1308     }
1309 
1310     protected LogicNode createInstanceOf(TypeReference type, ValueNode object) {
1311         return InstanceOfNode.create(type, object);
1312     }
1313 
1314     protected AnchoringNode createAnchor(JavaTypeProfile profile) {
1315         if (profile == null || profile.getNotRecordedProbability() &gt; 0.0) {
1316             return null;
1317         } else {
<span class="line-modified">1318             return append(new ValueAnchorNode(null));</span>
1319         }
1320     }
1321 
1322     protected LogicNode createInstanceOf(TypeReference type, ValueNode object, JavaTypeProfile profile) {
1323         return InstanceOfNode.create(type, object, profile, createAnchor(profile));
1324     }
1325 
1326     protected LogicNode createInstanceOfAllowNull(TypeReference type, ValueNode object, JavaTypeProfile profile) {
1327         return InstanceOfNode.createAllowNull(type, object, profile, createAnchor(profile));
1328     }
1329 
1330     protected ValueNode genConditional(ValueNode x) {
1331         return ConditionalNode.create((LogicNode) x, NodeView.DEFAULT);
1332     }
1333 
1334     protected NewInstanceNode createNewInstance(ResolvedJavaType type, boolean fillContents) {
1335         return new NewInstanceNode(type, fillContents);
1336     }
1337 
1338     protected NewArrayNode createNewArray(ResolvedJavaType elementType, ValueNode length, boolean fillContents) {
</pre>
<hr />
<pre>
1355     }
1356 
1357     protected StateSplitProxyNode genVolatileFieldReadProxy(ValueNode fieldRead) {
1358         return new StateSplitProxyNode(fieldRead);
1359     }
1360 
1361     protected ValueNode maybeEmitExplicitNullCheck(ValueNode receiver) {
1362         if (StampTool.isPointerNonNull(receiver.stamp(NodeView.DEFAULT)) || !needsExplicitNullCheckException(receiver)) {
1363             return receiver;
1364         }
1365         LogicNode condition = genUnique(IsNullNode.create(receiver));
1366         AbstractBeginNode passingSuccessor = emitBytecodeExceptionCheck(condition, false, BytecodeExceptionKind.NULL_POINTER);
1367         return genUnique(PiNode.create(receiver, objectNonNull(), passingSuccessor));
1368     }
1369 
1370     protected GuardingNode maybeEmitExplicitBoundsCheck(ValueNode receiver, ValueNode index) {
1371         if (!needsExplicitBoundsCheckException(receiver, index)) {
1372             return null;
1373         }
1374         ValueNode length = append(genArrayLength(receiver));
<span class="line-modified">1375         LogicNode condition = genUnique(IntegerBelowNode.create(constantReflection, metaAccess, options, null, index, length, NodeView.DEFAULT));</span>
1376         return emitBytecodeExceptionCheck(condition, true, BytecodeExceptionKind.OUT_OF_BOUNDS, index, length);
1377     }
1378 
1379     protected GuardingNode maybeEmitExplicitStoreCheck(ValueNode array, JavaKind elementKind, ValueNode value) {
1380         if (elementKind != JavaKind.Object || StampTool.isPointerAlwaysNull(value) || !needsExplicitStoreCheckException(array, value)) {
1381             return null;
1382         }
<span class="line-modified">1383         ValueNode arrayClass = genUnique(LoadHubNode.create(array, stampProvider, metaAccess, constantReflection));</span>
<span class="line-modified">1384         ValueNode componentHub = append(LoadArrayComponentHubNode.create(arrayClass, stampProvider, metaAccess, constantReflection));</span>
1385         LogicNode condition = genUnique(InstanceOfDynamicNode.create(graph.getAssumptions(), getConstantReflection(), componentHub, value, true));
1386         return emitBytecodeExceptionCheck(condition, true, BytecodeExceptionKind.ARRAY_STORE, value);
1387     }
1388 
1389     protected GuardingNode maybeEmitExplicitDivisionByZeroCheck(ValueNode y) {
1390         if (!((IntegerStamp) y.stamp(NodeView.DEFAULT)).contains(0) || !needsExplicitDivisionByZeroException(y)) {
1391             return null;
1392         }
1393         ConstantNode zero = ConstantNode.defaultForKind(y.getStackKind(), graph);
<span class="line-modified">1394         LogicNode condition = genUnique(IntegerEqualsNode.create(constantReflection, metaAccess, options, null, y, zero, NodeView.DEFAULT));</span>
1395         return emitBytecodeExceptionCheck(condition, false, BytecodeExceptionKind.DIVISION_BY_ZERO);
1396     }
1397 
1398     private AbstractBeginNode emitBytecodeExceptionCheck(LogicNode condition, boolean passingOnTrue, BytecodeExceptionKind exceptionKind, ValueNode... arguments) {
1399         if (passingOnTrue ? condition.isTautology() : condition.isContradiction()) {
1400             return null;
1401         }
1402 
<span class="line-modified">1403         BytecodeExceptionNode exception = graph.add(new BytecodeExceptionNode(metaAccess, exceptionKind, arguments));</span>
1404         AbstractBeginNode passingSuccessor = graph.add(new BeginNode());
1405 
1406         FixedNode trueSuccessor = passingOnTrue ? passingSuccessor : exception;
1407         FixedNode falseSuccessor = passingOnTrue ? exception : passingSuccessor;
1408         append(new IfNode(condition, trueSuccessor, falseSuccessor, passingOnTrue ? LUDICROUSLY_FAST_PATH_PROBABILITY : LUDICROUSLY_SLOW_PATH_PROBABILITY));
1409         lastInstr = passingSuccessor;
1410 
<span class="line-modified">1411         exception.setStateAfter(createFrameState(bci(), exception));</span>
1412         exception.setNext(handleException(exception, bci(), false));
1413         EXPLICIT_EXCEPTIONS.increment(debug);
1414 
1415         return passingSuccessor;
1416     }
1417 
1418     protected ValueNode genArrayLength(ValueNode x) {
<span class="line-modified">1419         return ArrayLengthNode.create(x, constantReflection);</span>
1420     }
1421 
1422     protected void genStoreField(ValueNode receiver, ResolvedJavaField field, ValueNode value) {
1423         StoreFieldNode storeFieldNode = new StoreFieldNode(receiver, field, maskSubWordValue(value, field.getJavaKind()));
1424         append(storeFieldNode);
1425         storeFieldNode.setStateAfter(this.createFrameState(stream.nextBCI(), storeFieldNode));
1426     }
1427 
1428     /**
1429      * Ensure that concrete classes are at least linked before generating an invoke. Interfaces may
1430      * never be linked so simply return true for them.
1431      *
1432      * @param target
1433      * @return true if the declared holder is an interface or is linked
1434      */
1435     private static boolean callTargetIsResolved(JavaMethod target) {
1436         if (target instanceof ResolvedJavaMethod) {
1437             ResolvedJavaMethod resolvedTarget = (ResolvedJavaMethod) target;
1438             ResolvedJavaType resolvedType = resolvedTarget.getDeclaringClass();
1439             return resolvedType.isInterface() || resolvedType.isLinked();
</pre>
<hr />
<pre>
1550             return false;
1551         }
1552 
1553         if (GeneratePIC.getValue(options) &amp;&amp; (invokeDynamicPlugin == null || !invokeDynamicPlugin.supportsDynamicInvoke(this, cpi, opcode))) {
1554             // bail out if static compiler and no dynamic type support
1555             append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1556             return true;
1557         }
1558 
1559         JavaConstant appendix = constantPool.lookupAppendix(cpi, opcode);
1560         ValueNode appendixNode = null;
1561 
1562         if (appendix != null) {
1563             if (invokeDynamicPlugin != null) {
1564                 invokeDynamicPlugin.recordDynamicMethod(this, cpi, opcode, target);
1565 
1566                 // Will perform runtime type checks and static initialization
1567                 FrameState stateBefore = createCurrentFrameState();
1568                 appendixNode = invokeDynamicPlugin.genAppendixNode(this, cpi, opcode, appendix, stateBefore);
1569             } else {
<span class="line-modified">1570                 appendixNode = ConstantNode.forConstant(appendix, metaAccess, graph);</span>
1571             }
1572 
1573             frameState.push(JavaKind.Object, appendixNode);
1574 
1575         } else if (GeneratePIC.getValue(options)) {
1576             // Need to emit runtime guard and perform static initialization.
1577             // Not implemented yet.
1578             append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1579             return true;
1580         }
1581 
1582         boolean hasReceiver = (opcode == INVOKEDYNAMIC) ? false : !target.isStatic();
1583         ValueNode[] args = frameState.popArguments(target.getSignature().getParameterCount(hasReceiver));
1584         if (hasReceiver) {
1585             appendInvoke(InvokeKind.Virtual, target, args);
1586         } else {
1587             appendInvoke(InvokeKind.Static, target, args);
1588         }
1589 
1590         return true;
</pre>
<hr />
<pre>
1612         final JavaType returnType;
1613 
1614         CurrentInvoke(ValueNode[] args, InvokeKind kind, JavaType returnType) {
1615             this.args = args;
1616             this.kind = kind;
1617             this.returnType = returnType;
1618         }
1619     }
1620 
1621     private CurrentInvoke currentInvoke;
1622     protected FrameStateBuilder frameState;
1623     protected BciBlock currentBlock;
1624     protected final BytecodeStream stream;
1625     protected final GraphBuilderConfiguration graphBuilderConfig;
1626     protected final ResolvedJavaMethod method;
1627     protected final Bytecode code;
1628     protected final BytecodeProvider bytecodeProvider;
1629     protected final ProfilingInfo profilingInfo;
1630     protected final OptimisticOptimizations optimisticOpts;
1631     protected final ConstantPool constantPool;
<span class="line-modified">1632     protected final MetaAccessProvider metaAccess;</span>
<span class="line-removed">1633     private final ConstantReflectionProvider constantReflection;</span>
<span class="line-removed">1634     private final ConstantFieldProvider constantFieldProvider;</span>
<span class="line-removed">1635     private final StampProvider stampProvider;</span>
1636     protected final IntrinsicContext intrinsicContext;
1637 
1638     @Override
1639     public InvokeKind getInvokeKind() {
1640         return currentInvoke == null ? null : currentInvoke.kind;
1641     }
1642 
1643     @Override
1644     public JavaType getInvokeReturnType() {
1645         return currentInvoke == null ? null : currentInvoke.returnType;
1646     }
1647 
1648     private boolean forceInliningEverything;
1649 
1650     @Override
1651     public Invoke handleReplacedInvoke(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, boolean inlineEverything) {
1652         boolean previous = forceInliningEverything;
1653         forceInliningEverything = previous || inlineEverything;
1654         try {
1655             return appendInvoke(invokeKind, targetMethod, args);
</pre>
<hr />
<pre>
1667 
1668     protected Invoke appendInvoke(InvokeKind initialInvokeKind, ResolvedJavaMethod initialTargetMethod, ValueNode[] args) {
1669         ResolvedJavaMethod targetMethod = initialTargetMethod;
1670         InvokeKind invokeKind = initialInvokeKind;
1671         if (initialInvokeKind.isIndirect()) {
1672             ResolvedJavaType contextType = this.frameState.getMethod().getDeclaringClass();
1673             ResolvedJavaMethod specialCallTarget = MethodCallTargetNode.findSpecialCallTarget(initialInvokeKind, args[0], initialTargetMethod, contextType);
1674             if (specialCallTarget != null) {
1675                 invokeKind = InvokeKind.Special;
1676                 targetMethod = specialCallTarget;
1677             }
1678         }
1679 
1680         JavaKind resultType = targetMethod.getSignature().getReturnKind();
1681         if (!parsingIntrinsic() &amp;&amp; DeoptALot.getValue(options)) {
1682             append(new DeoptimizeNode(DeoptimizationAction.None, RuntimeConstraint));
1683             frameState.pushReturn(resultType, ConstantNode.defaultForKind(resultType, graph));
1684             return null;
1685         }
1686 
<span class="line-modified">1687         JavaType returnType = targetMethod.getSignature().getReturnType(method.getDeclaringClass());</span>
<span class="line-removed">1688         if (graphBuilderConfig.eagerResolving() || parsingIntrinsic()) {</span>
<span class="line-removed">1689             returnType = returnType.resolve(targetMethod.getDeclaringClass());</span>
<span class="line-removed">1690         }</span>
1691         if (invokeKind.hasReceiver()) {
1692             args[0] = maybeEmitExplicitNullCheck(args[0]);
1693         }
1694 
1695         if (initialInvokeKind == InvokeKind.Special &amp;&amp; !targetMethod.isConstructor()) {
1696             emitCheckForInvokeSuperSpecial(args);
1697         } else if (initialInvokeKind == InvokeKind.Interface &amp;&amp; targetMethod.isPrivate()) {
1698             emitCheckForDeclaringClassChange(targetMethod.getDeclaringClass(), args);
1699         }
1700 
1701         InlineInfo inlineInfo = null;
1702         try {
1703             currentInvoke = new CurrentInvoke(args, invokeKind, returnType);
1704             if (tryNodePluginForInvocation(args, targetMethod)) {
1705                 if (TraceParserPlugins.getValue(options)) {
1706                     traceWithContext(&quot;used node plugin for %s&quot;, targetMethod.format(&quot;%h.%n(%p)&quot;));
1707                 }
1708                 return null;
1709             }
1710 
1711             if (invokeKind.hasReceiver() &amp;&amp; args[0].isNullConstant()) {
1712                 append(new DeoptimizeNode(InvalidateRecompile, NullCheckException));
1713                 return null;
1714             }
1715 
<span class="line-modified">1716             if (!invokeKind.isIndirect() || (UseGuardedIntrinsics.getValue(options) &amp;&amp; !GeneratePIC.getValue(options))) {</span>
<span class="line-modified">1717                 if (tryInvocationPlugin(invokeKind, args, targetMethod, resultType, returnType)) {</span>
1718                     if (TraceParserPlugins.getValue(options)) {
1719                         traceWithContext(&quot;used invocation plugin for %s&quot;, targetMethod.format(&quot;%h.%n(%p)&quot;));
1720                     }
1721                     return null;
1722                 }
1723             }
1724             if (invokeKind.isDirect()) {
1725                 inlineInfo = tryInline(args, targetMethod);
1726                 if (inlineInfo == SUCCESSFULLY_INLINED) {
1727                     return null;
1728                 }
1729             }
1730         } finally {
1731             currentInvoke = null;
1732         }
<span class="line-removed">1733 </span>
1734         int invokeBci = bci();
1735         JavaTypeProfile profile = getProfileForInvoke(invokeKind);
1736         ExceptionEdgeAction edgeAction = getActionForInvokeExceptionEdge(inlineInfo);
1737         boolean partialIntrinsicExit = false;
1738         if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
1739             partialIntrinsicExit = true;
1740             ResolvedJavaMethod originalMethod = intrinsicContext.getOriginalMethod();
1741             BytecodeParser intrinsicCallSiteParser = getNonIntrinsicAncestor();
1742             if (intrinsicCallSiteParser != null) {
1743                 // When exiting a partial intrinsic, the invoke to the original
1744                 // must use the same context as the call to the intrinsic.
1745                 invokeBci = intrinsicCallSiteParser.bci();
1746                 profile = intrinsicCallSiteParser.getProfileForInvoke(invokeKind);
1747                 edgeAction = intrinsicCallSiteParser.getActionForInvokeExceptionEdge(inlineInfo);
1748             } else {
1749                 // We are parsing the intrinsic for the root compilation or for inlining,
1750                 // This call is a partial intrinsic exit, and we do not have profile information
1751                 // for this callsite. We also have to assume that the call needs an exception
1752                 // edge. Finally, we know that this intrinsic is parsed for late inlining,
1753                 // so the bci must be set to unknown, so that the inliner patches it later.
1754                 assert intrinsicContext.isPostParseInlined();
<span class="line-modified">1755                 invokeBci = BytecodeFrame.UNKNOWN_BCI;</span>
1756                 profile = null;
1757                 edgeAction = graph.method().getAnnotation(Snippet.class) == null ? ExceptionEdgeAction.INCLUDE_AND_HANDLE : ExceptionEdgeAction.OMIT;
1758             }
1759 
1760             if (originalMethod.isStatic()) {
1761                 invokeKind = InvokeKind.Static;
1762             } else {
1763                 // The original call to the intrinsic must have been devirtualized
1764                 // otherwise we wouldn&#39;t be here.
1765                 invokeKind = InvokeKind.Special;
1766             }
1767             Signature sig = originalMethod.getSignature();
1768             returnType = sig.getReturnType(method.getDeclaringClass());
1769             resultType = sig.getReturnKind();
1770             assert intrinsicContext.allowPartialIntrinsicArgumentMismatch() || checkPartialIntrinsicExit(intrinsicCallSiteParser == null ? null : intrinsicCallSiteParser.currentInvoke.args, args);
1771             targetMethod = originalMethod;
1772         }
1773         Invoke invoke = createNonInlinedInvoke(edgeAction, invokeBci, args, targetMethod, invokeKind, resultType, returnType, profile);
1774         graph.getInliningLog().addDecision(invoke, false, &quot;GraphBuilderPhase&quot;, null, null, &quot;bytecode parser did not replace invoke&quot;);
1775         if (partialIntrinsicExit) {
</pre>
<hr />
<pre>
1937         final ResolvedJavaMethod targetMethod;
1938         final JavaKind resultType;
1939         final int beforeStackSize;
1940         final boolean needsNullCheck;
1941         final int nodeCount;
1942         final Mark mark;
1943 
1944         InvocationPluginAssertions(InvocationPlugin plugin, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {
1945             guarantee(Assertions.assertionsEnabled(), &quot;%s should only be loaded and instantiated if assertions are enabled&quot;, getClass().getSimpleName());
1946             this.plugin = plugin;
1947             this.targetMethod = targetMethod;
1948             this.args = args;
1949             this.resultType = resultType;
1950             this.beforeStackSize = frameState.stackSize();
1951             this.needsNullCheck = !targetMethod.isStatic() &amp;&amp; args[0].getStackKind() == JavaKind.Object &amp;&amp; !StampTool.isPointerNonNull(args[0].stamp(NodeView.DEFAULT));
1952             this.nodeCount = graph.getNodeCount();
1953             this.mark = graph.getMark();
1954         }
1955 
1956         String error(String format, Object... a) {
<span class="line-modified">1957             return String.format(format, a) + String.format(&quot;%n\tplugin at %s&quot;, plugin.getApplySourceLocation(metaAccess));</span>
1958         }
1959 
1960         boolean check(boolean pluginResult) {
1961             if (pluginResult) {
1962                 /*
1963                  * If lastInstr is null, even if this method has a non-void return type, the method
1964                  * doesn&#39;t return a value, it probably throws an exception.
1965                  */
1966                 int expectedStackSize = beforeStackSize + resultType.getSlotCount();
1967                 assert lastInstr == null || expectedStackSize == frameState.stackSize() : error(&quot;plugin manipulated the stack incorrectly: expected=%d, actual=%d&quot;, expectedStackSize,
1968                                 frameState.stackSize());
1969 
1970                 NodeIterable&lt;Node&gt; newNodes = graph.getNewNodes(mark);
1971                 assert !needsNullCheck || isPointerNonNull(args[0].stamp(NodeView.DEFAULT)) : error(&quot;plugin needs to null check the receiver of %s: receiver=%s&quot;, targetMethod.format(&quot;%H.%n(%p)&quot;),
1972                                 args[0]);
1973                 for (Node n : newNodes) {
1974                     if (n instanceof StateSplit) {
1975                         StateSplit stateSplit = (StateSplit) n;
1976                         assert stateSplit.stateAfter() != null || !stateSplit.hasSideEffect() : error(&quot;%s node added by plugin for %s need to have a non-null frame state: %s&quot;,
1977                                         StateSplit.class.getSimpleName(), targetMethod.format(&quot;%H.%n(%p)&quot;), stateSplit);
1978                     }
1979                 }
1980                 try {
1981                     graphBuilderConfig.getPlugins().getInvocationPlugins().checkNewNodes(BytecodeParser.this, plugin, newNodes);
1982                 } catch (Throwable t) {
1983                     throw new AssertionError(error(&quot;Error in plugin&quot;), t);
1984                 }
1985             } else {
1986                 assert nodeCount == graph.getNodeCount() : error(&quot;plugin that returns false must not create new nodes&quot;);
1987                 assert beforeStackSize == frameState.stackSize() : error(&quot;plugin that returns false must not modify the stack&quot;);
1988             }
1989             return true;
1990         }
1991     }
1992 
<span class="line-removed">1993     protected static class IntrinsicGuard {</span>
<span class="line-removed">1994         final FixedWithNextNode lastInstr;</span>
<span class="line-removed">1995         final Mark mark;</span>
<span class="line-removed">1996         final AbstractBeginNode nonIntrinsicBranch;</span>
<span class="line-removed">1997         final ValueNode receiver;</span>
<span class="line-removed">1998         final JavaTypeProfile profile;</span>
<span class="line-removed">1999 </span>
<span class="line-removed">2000         public IntrinsicGuard(FixedWithNextNode lastInstr, ValueNode receiver, Mark mark, AbstractBeginNode nonIntrinsicBranch, JavaTypeProfile profile) {</span>
<span class="line-removed">2001             this.lastInstr = lastInstr;</span>
<span class="line-removed">2002             this.receiver = receiver;</span>
<span class="line-removed">2003             this.mark = mark;</span>
<span class="line-removed">2004             this.nonIntrinsicBranch = nonIntrinsicBranch;</span>
<span class="line-removed">2005             this.profile = profile;</span>
<span class="line-removed">2006         }</span>
<span class="line-removed">2007     }</span>
<span class="line-removed">2008 </span>
<span class="line-removed">2009     /**</span>
<span class="line-removed">2010      * Weaves a test of the receiver type to ensure the dispatch will select {@code targetMethod}</span>
<span class="line-removed">2011      * and not another method that overrides it. This should only be called if there is an</span>
<span class="line-removed">2012      * {@link InvocationPlugin} for {@code targetMethod} and the invocation is indirect.</span>
<span class="line-removed">2013      *</span>
<span class="line-removed">2014      * The control flow woven around the intrinsic is as follows:</span>
<span class="line-removed">2015      *</span>
<span class="line-removed">2016      * &lt;pre&gt;</span>
<span class="line-removed">2017      *  if (LoadMethod(LoadHub(receiver)) == targetMethod) {</span>
<span class="line-removed">2018      *       &lt;intrinsic for targetMethod&gt;</span>
<span class="line-removed">2019      *  } else {</span>
<span class="line-removed">2020      *       &lt;virtual call to targetMethod&gt;</span>
<span class="line-removed">2021      *  }</span>
<span class="line-removed">2022      * &lt;/pre&gt;</span>
<span class="line-removed">2023      *</span>
<span class="line-removed">2024      * The {@code else} branch is woven by {@link #afterInvocationPluginExecution}.</span>
<span class="line-removed">2025      *</span>
<span class="line-removed">2026      * @return {@code null} if the intrinsic cannot be used otherwise an object to be used by</span>
<span class="line-removed">2027      *         {@link #afterInvocationPluginExecution} to weave code for the non-intrinsic branch</span>
<span class="line-removed">2028      */</span>
<span class="line-removed">2029     protected IntrinsicGuard guardIntrinsic(ValueNode[] args, ResolvedJavaMethod targetMethod, InvocationPluginReceiver pluginReceiver) {</span>
<span class="line-removed">2030         ValueNode intrinsicReceiver = args[0];</span>
<span class="line-removed">2031         ResolvedJavaType receiverType = StampTool.typeOrNull(intrinsicReceiver);</span>
<span class="line-removed">2032         if (receiverType == null) {</span>
<span class="line-removed">2033             // The verifier guarantees it to be at least type declaring targetMethod</span>
<span class="line-removed">2034             receiverType = targetMethod.getDeclaringClass();</span>
<span class="line-removed">2035         }</span>
<span class="line-removed">2036         ResolvedJavaMethod resolvedMethod = receiverType.resolveMethod(targetMethod, method.getDeclaringClass());</span>
<span class="line-removed">2037         if (resolvedMethod == null || resolvedMethod.equals(targetMethod)) {</span>
<span class="line-removed">2038             assert resolvedMethod == null || targetMethod.getDeclaringClass().isAssignableFrom(resolvedMethod.getDeclaringClass());</span>
<span class="line-removed">2039             Mark mark = graph.getMark();</span>
<span class="line-removed">2040             FixedWithNextNode currentLastInstr = lastInstr;</span>
<span class="line-removed">2041             ValueNode nonNullReceiver = pluginReceiver.get();</span>
<span class="line-removed">2042             Stamp methodStamp = stampProvider.createMethodStamp();</span>
<span class="line-removed">2043             LoadHubNode hub = graph.unique(new LoadHubNode(stampProvider, nonNullReceiver));</span>
<span class="line-removed">2044             LoadMethodNode actual = append(new LoadMethodNode(methodStamp, targetMethod, receiverType, method.getDeclaringClass(), hub));</span>
<span class="line-removed">2045             ConstantNode expected = graph.unique(ConstantNode.forConstant(methodStamp, targetMethod.getEncoding(), getMetaAccess()));</span>
<span class="line-removed">2046             LogicNode compare = graph.addOrUniqueWithInputs(CompareNode.createCompareNode(constantReflection, metaAccess, options, null, CanonicalCondition.EQ, actual, expected, NodeView.DEFAULT));</span>
<span class="line-removed">2047 </span>
<span class="line-removed">2048             JavaTypeProfile profile = null;</span>
<span class="line-removed">2049             if (profilingInfo != null &amp;&amp; this.optimisticOpts.useTypeCheckHints(getOptions())) {</span>
<span class="line-removed">2050                 profile = profilingInfo.getTypeProfile(bci());</span>
<span class="line-removed">2051                 if (profile != null) {</span>
<span class="line-removed">2052                     JavaTypeProfile newProfile = adjustProfileForInvocationPlugin(profile, targetMethod);</span>
<span class="line-removed">2053                     if (newProfile != profile) {</span>
<span class="line-removed">2054                         if (newProfile.getTypes().length == 0) {</span>
<span class="line-removed">2055                             // All profiled types select the intrinsic so</span>
<span class="line-removed">2056                             // emit a fixed guard instead of an if-then-else.</span>
<span class="line-removed">2057                             lastInstr = append(new FixedGuardNode(compare, TypeCheckedInliningViolated, InvalidateReprofile, false));</span>
<span class="line-removed">2058                             return new IntrinsicGuard(currentLastInstr, intrinsicReceiver, mark, null, null);</span>
<span class="line-removed">2059                         }</span>
<span class="line-removed">2060                     } else {</span>
<span class="line-removed">2061                         // No profiled types select the intrinsic so emit a virtual call</span>
<span class="line-removed">2062                         return null;</span>
<span class="line-removed">2063                     }</span>
<span class="line-removed">2064                     profile = newProfile;</span>
<span class="line-removed">2065                 }</span>
<span class="line-removed">2066             }</span>
<span class="line-removed">2067 </span>
<span class="line-removed">2068             AbstractBeginNode intrinsicBranch = graph.add(new BeginNode());</span>
<span class="line-removed">2069             AbstractBeginNode nonIntrinsicBranch = graph.add(new BeginNode());</span>
<span class="line-removed">2070             append(new IfNode(compare, intrinsicBranch, nonIntrinsicBranch, FAST_PATH_PROBABILITY));</span>
<span class="line-removed">2071             lastInstr = intrinsicBranch;</span>
<span class="line-removed">2072             return new IntrinsicGuard(currentLastInstr, intrinsicReceiver, mark, nonIntrinsicBranch, profile);</span>
<span class="line-removed">2073         } else {</span>
<span class="line-removed">2074             // Receiver selects an overriding method so emit a virtual call</span>
<span class="line-removed">2075             return null;</span>
<span class="line-removed">2076         }</span>
<span class="line-removed">2077     }</span>
<span class="line-removed">2078 </span>
<span class="line-removed">2079     /**</span>
<span class="line-removed">2080      * Adjusts the profile for an indirect invocation of a virtual method for which there is an</span>
<span class="line-removed">2081      * intrinsic. The adjustment made by this method is to remove all types from the profile that do</span>
<span class="line-removed">2082      * not override {@code targetMethod}.</span>
<span class="line-removed">2083      *</span>
<span class="line-removed">2084      * @param profile the profile to adjust</span>
<span class="line-removed">2085      * @param targetMethod the virtual method for which there is an intrinsic</span>
<span class="line-removed">2086      * @return the adjusted profile or the original {@code profile} object if no adjustment was made</span>
<span class="line-removed">2087      */</span>
<span class="line-removed">2088     protected JavaTypeProfile adjustProfileForInvocationPlugin(JavaTypeProfile profile, ResolvedJavaMethod targetMethod) {</span>
<span class="line-removed">2089         if (profile.getTypes().length &gt; 0) {</span>
<span class="line-removed">2090             List&lt;ProfiledType&gt; retained = new ArrayList&lt;&gt;();</span>
<span class="line-removed">2091             double notRecordedProbability = profile.getNotRecordedProbability();</span>
<span class="line-removed">2092             for (ProfiledType ptype : profile.getTypes()) {</span>
<span class="line-removed">2093                 if (!ptype.getType().resolveMethod(targetMethod, method.getDeclaringClass()).equals(targetMethod)) {</span>
<span class="line-removed">2094                     retained.add(ptype);</span>
<span class="line-removed">2095                 } else {</span>
<span class="line-removed">2096                     notRecordedProbability += ptype.getProbability();</span>
<span class="line-removed">2097                 }</span>
<span class="line-removed">2098             }</span>
<span class="line-removed">2099             if (!retained.isEmpty()) {</span>
<span class="line-removed">2100                 if (retained.size() != profile.getTypes().length) {</span>
<span class="line-removed">2101                     return new JavaTypeProfile(profile.getNullSeen(), notRecordedProbability, retained.toArray(new ProfiledType[retained.size()]));</span>
<span class="line-removed">2102                 }</span>
<span class="line-removed">2103             } else {</span>
<span class="line-removed">2104                 return new JavaTypeProfile(profile.getNullSeen(), notRecordedProbability, new ProfiledType[0]);</span>
<span class="line-removed">2105             }</span>
<span class="line-removed">2106         }</span>
<span class="line-removed">2107         return profile;</span>
<span class="line-removed">2108     }</span>
<span class="line-removed">2109 </span>
<span class="line-removed">2110     /**</span>
<span class="line-removed">2111      * Performs any action required after execution of an invocation plugin. This includes</span>
<span class="line-removed">2112      * {@linkplain InvocationPluginAssertions#check checking} invocation plugin invariants as well</span>
<span class="line-removed">2113      * as weaving the {@code else} branch of the code woven by {@link #guardIntrinsic} if</span>
<span class="line-removed">2114      * {@code guard != null}.</span>
<span class="line-removed">2115      */</span>
<span class="line-removed">2116     protected void afterInvocationPluginExecution(boolean pluginHandledInvoke, InvocationPluginAssertions assertions, IntrinsicGuard intrinsicGuard,</span>
<span class="line-removed">2117                     InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType, JavaType returnType) {</span>
<span class="line-removed">2118         assert assertions.check(pluginHandledInvoke);</span>
<span class="line-removed">2119         if (intrinsicGuard != null) {</span>
<span class="line-removed">2120             if (pluginHandledInvoke) {</span>
<span class="line-removed">2121                 if (intrinsicGuard.nonIntrinsicBranch != null) {</span>
<span class="line-removed">2122                     // Intrinsic emitted: emit a virtual call to the target method and</span>
<span class="line-removed">2123                     // merge it with the intrinsic branch</span>
<span class="line-removed">2124                     EndNode intrinsicEnd = append(new EndNode());</span>
<span class="line-removed">2125 </span>
<span class="line-removed">2126                     FrameStateBuilder intrinsicState = null;</span>
<span class="line-removed">2127                     FrameStateBuilder nonIntrinisicState = null;</span>
<span class="line-removed">2128                     if (resultType != JavaKind.Void) {</span>
<span class="line-removed">2129                         intrinsicState = frameState.copy();</span>
<span class="line-removed">2130                         frameState.pop(resultType);</span>
<span class="line-removed">2131                         nonIntrinisicState = frameState;</span>
<span class="line-removed">2132                     }</span>
<span class="line-removed">2133 </span>
<span class="line-removed">2134                     lastInstr = intrinsicGuard.nonIntrinsicBranch;</span>
<span class="line-removed">2135                     createNonInlinedInvoke(getActionForInvokeExceptionEdge(null), bci(), args, targetMethod, invokeKind, resultType, returnType, intrinsicGuard.profile);</span>
<span class="line-removed">2136 </span>
<span class="line-removed">2137                     EndNode nonIntrinsicEnd = append(new EndNode());</span>
<span class="line-removed">2138                     AbstractMergeNode mergeNode = graph.add(new MergeNode());</span>
<span class="line-removed">2139 </span>
<span class="line-removed">2140                     mergeNode.addForwardEnd(intrinsicEnd);</span>
<span class="line-removed">2141                     if (intrinsicState != null) {</span>
<span class="line-removed">2142                         intrinsicState.merge(mergeNode, nonIntrinisicState);</span>
<span class="line-removed">2143                         frameState = intrinsicState;</span>
<span class="line-removed">2144                     }</span>
<span class="line-removed">2145                     mergeNode.addForwardEnd(nonIntrinsicEnd);</span>
<span class="line-removed">2146                     mergeNode.setStateAfter(frameState.create(stream.nextBCI(), mergeNode));</span>
<span class="line-removed">2147 </span>
<span class="line-removed">2148                     lastInstr = mergeNode;</span>
<span class="line-removed">2149                 }</span>
<span class="line-removed">2150             } else {</span>
<span class="line-removed">2151                 // Intrinsic was not applied: remove intrinsic guard</span>
<span class="line-removed">2152                 // and restore the original receiver node in the arguments array</span>
<span class="line-removed">2153                 intrinsicGuard.lastInstr.setNext(null);</span>
<span class="line-removed">2154                 GraphUtil.removeNewNodes(graph, intrinsicGuard.mark);</span>
<span class="line-removed">2155                 lastInstr = intrinsicGuard.lastInstr;</span>
<span class="line-removed">2156                 args[0] = intrinsicGuard.receiver;</span>
<span class="line-removed">2157             }</span>
<span class="line-removed">2158         }</span>
<span class="line-removed">2159     }</span>
<span class="line-removed">2160 </span>
2161     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">2162     protected boolean tryInvocationPlugin(InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType, JavaType returnType) {</span>
2163         InvocationPlugin plugin = graphBuilderConfig.getPlugins().getInvocationPlugins().lookupInvocation(targetMethod);
2164         if (plugin != null) {
2165 
2166             if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
2167                 // Self recursive intrinsic means the original method should be called.
2168                 return false;
2169             }
2170 
2171             InvocationPluginReceiver pluginReceiver = invocationPluginReceiver.init(targetMethod, args);
<span class="line-modified">2172 </span>
<span class="line-removed">2173             IntrinsicGuard intrinsicGuard = null;</span>
<span class="line-removed">2174             if (invokeKind.isIndirect()) {</span>
<span class="line-removed">2175                 intrinsicGuard = guardIntrinsic(args, targetMethod, pluginReceiver);</span>
<span class="line-removed">2176                 if (intrinsicGuard == null) {</span>
<span class="line-removed">2177                     return false;</span>
<span class="line-removed">2178                 } else if (intrinsicGuard.nonIntrinsicBranch == null) {</span>
<span class="line-removed">2179                     assert lastInstr instanceof FixedGuardNode;</span>
<span class="line-removed">2180                 }</span>
<span class="line-removed">2181             }</span>
2182 
2183             InvocationPluginAssertions assertions = Assertions.assertionsEnabled() ? new InvocationPluginAssertions(plugin, args, targetMethod, resultType) : null;
2184             try (DebugCloseable context = openNodeContext(targetMethod)) {
2185                 if (plugin.execute(this, targetMethod, pluginReceiver, args)) {
<span class="line-modified">2186                     afterInvocationPluginExecution(true, assertions, intrinsicGuard, invokeKind, args, targetMethod, resultType, returnType);</span>
2187                     return !plugin.isDecorator();
2188                 } else {
<span class="line-modified">2189                     afterInvocationPluginExecution(false, assertions, intrinsicGuard, invokeKind, args, targetMethod, resultType, returnType);</span>
2190                 }
2191             }
2192         }
2193         return false;
2194     }
2195 
2196     private boolean tryNodePluginForInvocation(ValueNode[] args, ResolvedJavaMethod targetMethod) {
2197         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
2198             if (plugin.handleInvoke(this, targetMethod, args)) {
2199                 return true;
2200             }
2201         }
2202         return false;
2203     }
2204 
2205     private static final InlineInfo SUCCESSFULLY_INLINED = InlineInfo.createStandardInlineInfo(null);
2206 
2207     /**
2208      * Try to inline a method. If the method was inlined, returns {@link #SUCCESSFULLY_INLINED}.
2209      * Otherwise, it returns the {@link InlineInfo} that lead to the decision to not inline it, or
2210      * {@code null} if there is no {@link InlineInfo} for this method.
2211      */
2212     private InlineInfo tryInline(ValueNode[] args, ResolvedJavaMethod targetMethod) {
2213         boolean canBeInlined = forceInliningEverything || parsingIntrinsic() || targetMethod.canBeInlined();
2214         if (!canBeInlined) {
2215             return null;
2216         }
2217 
2218         if (forceInliningEverything) {
2219             if (inline(targetMethod, targetMethod, null, args)) {
2220                 return SUCCESSFULLY_INLINED;
2221             } else {
2222                 return null;
2223             }
2224         }
2225 
2226         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2227             InlineInfo inlineInfo = plugin.shouldInlineInvoke(this, targetMethod, args);
2228             if (inlineInfo != null) {
<span class="line-modified">2229                 if (inlineInfo.getMethodToInline() != null) {</span>
2230                     if (inline(targetMethod, inlineInfo.getMethodToInline(), inlineInfo.getIntrinsicBytecodeProvider(), args)) {
2231                         return SUCCESSFULLY_INLINED;
2232                     }
2233                     inlineInfo = null;
2234                 }
2235                 /* Do not inline, and do not ask the remaining plugins. */
2236                 return inlineInfo;
2237             }
2238         }
2239 
2240         // There was no inline plugin with a definite answer to whether or not
2241         // to inline. If we&#39;re parsing an intrinsic, then we need to enforce the
2242         // invariant here that methods are always force inlined in intrinsics/snippets.
2243         if (parsingIntrinsic()) {
2244             if (inline(targetMethod, targetMethod, this.bytecodeProvider, args)) {
2245                 return SUCCESSFULLY_INLINED;
2246             }
2247         }
2248         return null;
2249     }
</pre>
<hr />
<pre>
2263             int b4 = Bytes.beU1(bytecode, 4);
2264             if (b4 &gt;= IRETURN &amp;&amp; b4 &lt;= ARETURN) {
2265                 int cpi = Bytes.beU2(bytecode, 2);
2266                 JavaField field = targetMethod.getConstantPool().lookupField(cpi, targetMethod, GETFIELD);
2267                 if (field instanceof ResolvedJavaField) {
2268                     ValueNode receiver = invocationPluginReceiver.init(targetMethod, args).get();
2269                     ResolvedJavaField resolvedField = (ResolvedJavaField) field;
2270                     try (DebugCloseable context = openNodeContext(targetMethod, 1)) {
2271                         genGetField(resolvedField, receiver);
2272                         notifyBeforeInline(targetMethod);
2273                         printInlining(targetMethod, targetMethod, true, &quot;inline accessor method (bytecode parsing)&quot;);
2274                         notifyAfterInline(targetMethod);
2275                     }
2276                     return true;
2277                 }
2278             }
2279         }
2280         return false;
2281     }
2282 
































































































































2283     @Override
2284     public boolean intrinsify(BytecodeProvider intrinsicBytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] args) {
2285         if (receiver != null) {
2286             receiver.get();
2287         }
2288         boolean res = inline(targetMethod, substitute, intrinsicBytecodeProvider, args);
2289         assert res : &quot;failed to inline &quot; + substitute;
2290         return res;
2291     }
2292 
2293     private boolean inline(ResolvedJavaMethod targetMethod, ResolvedJavaMethod inlinedMethod, BytecodeProvider intrinsicBytecodeProvider, ValueNode[] args) {
2294         try (InliningLog.RootScope scope = graph.getInliningLog().openRootScope(targetMethod, bci())) {
2295             IntrinsicContext intrinsic = this.intrinsicContext;
2296 
2297             if (intrinsic == null &amp;&amp; !graphBuilderConfig.insertFullInfopoints() &amp;&amp;
2298                             targetMethod.equals(inlinedMethod) &amp;&amp;
2299                             (targetMethod.getModifiers() &amp; (STATIC | SYNCHRONIZED)) == 0 &amp;&amp;
2300                             tryFastInlineAccessor(args, targetMethod)) {
2301                 return true;
2302             }
</pre>
<hr />
<pre>
2304             if (intrinsic != null &amp;&amp; intrinsic.isCallToOriginal(targetMethod)) {
2305                 if (intrinsic.isCompilationRoot()) {
2306                     // A root compiled intrinsic needs to deoptimize
2307                     // if the slow path is taken. During frame state
2308                     // assignment, the deopt node will get its stateBefore
2309                     // from the start node of the intrinsic
2310                     append(new DeoptimizeNode(InvalidateRecompile, RuntimeConstraint));
2311                     printInlining(targetMethod, inlinedMethod, true, &quot;compilation root (bytecode parsing)&quot;);
2312                     if (scope != null) {
2313                         graph.getInliningLog().addDecision(scope.getInvoke(), true, &quot;GraphBuilderPhase&quot;, null, null, &quot;compilation root&quot;);
2314                     }
2315                     return true;
2316                 } else {
2317                     if (intrinsic.getOriginalMethod().isNative()) {
2318                         printInlining(targetMethod, inlinedMethod, false, &quot;native method (bytecode parsing)&quot;);
2319                         if (scope != null) {
2320                             graph.getInliningLog().addDecision(scope.getInvoke(), false, &quot;GraphBuilderPhase&quot;, null, null, &quot;native method&quot;);
2321                         }
2322                         return false;
2323                     }
<span class="line-modified">2324                     if (canInlinePartialIntrinsicExit() &amp;&amp; InlinePartialIntrinsicExitDuringParsing.getValue(options) &amp;&amp; !IS_BUILDING_NATIVE_IMAGE) {</span>
2325                         // Otherwise inline the original method. Any frame state created
2326                         // during the inlining will exclude frame(s) in the
2327                         // intrinsic method (see FrameStateBuilder.create(int bci)).
2328                         notifyBeforeInline(inlinedMethod);
2329                         printInlining(targetMethod, inlinedMethod, true, &quot;partial intrinsic exit (bytecode parsing)&quot;);
2330                         if (scope != null) {
2331                             graph.getInliningLog().addDecision(scope.getInvoke(), true, &quot;GraphBuilderPhase&quot;, null, null, &quot;partial intrinsic exit&quot;);
2332                         }
2333                         parseAndInlineCallee(intrinsic.getOriginalMethod(), args, null);
2334                         notifyAfterInline(inlinedMethod);
2335                         return true;
2336                     } else {
2337                         printInlining(targetMethod, inlinedMethod, false, &quot;partial intrinsic exit (bytecode parsing)&quot;);
2338                         if (scope != null) {
2339                             graph.getInliningLog().addDecision(scope.getInvoke(), false, &quot;GraphBuilderPhase&quot;, null, null, &quot;partial intrinsic exit&quot;);
2340                         }
2341                         return false;
2342                     }
2343                 }
2344             } else {
</pre>
<hr />
<pre>
2367         }
2368     }
2369 
2370     protected void notifyBeforeInline(ResolvedJavaMethod inlinedMethod) {
2371         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2372             plugin.notifyBeforeInline(inlinedMethod);
2373         }
2374     }
2375 
2376     protected void notifyAfterInline(ResolvedJavaMethod inlinedMethod) {
2377         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2378             plugin.notifyAfterInline(inlinedMethod);
2379         }
2380     }
2381 
2382     /**
2383      * Determines if a partial intrinsic exit (i.e., a call to the original method within an
2384      * intrinsic) can be inlined.
2385      */
2386     protected boolean canInlinePartialIntrinsicExit() {
<span class="line-modified">2387         return true;</span>
2388     }
2389 
2390     private void printInlining(ResolvedJavaMethod targetMethod, ResolvedJavaMethod inlinedMethod, boolean success, String msg) {
2391         if (success) {
2392             if (TraceInlineDuringParsing.getValue(options) || TraceParserPlugins.getValue(options)) {
2393                 if (targetMethod.equals(inlinedMethod)) {
2394                     traceWithContext(&quot;inlining call to %s&quot;, inlinedMethod.format(&quot;%h.%n(%p)&quot;));
2395                 } else {
2396                     traceWithContext(&quot;inlining call to %s as intrinsic for %s&quot;, inlinedMethod.format(&quot;%h.%n(%p)&quot;), targetMethod.format(&quot;%h.%n(%p)&quot;));
2397                 }
2398             }
2399         }
2400         if (HotSpotPrintInlining.getValue(options)) {
2401             if (targetMethod.equals(inlinedMethod)) {
2402                 Util.printInlining(inlinedMethod, bci(), getDepth(), success, &quot;%s&quot;, msg);
2403             } else {
2404                 Util.printInlining(inlinedMethod, bci(), getDepth(), success, &quot;%s intrinsic for %s&quot;, msg, targetMethod.format(&quot;%h.%n(%p)&quot;));
2405             }
2406         }
2407     }
</pre>
<hr />
<pre>
2427         TTY.println(s);
2428     }
2429 
2430     protected RuntimeException throwParserError(Throwable e) {
2431         if (e instanceof BytecodeParserError) {
2432             throw (BytecodeParserError) e;
2433         }
2434         BytecodeParser bp = this;
2435         BytecodeParserError res = new BytecodeParserError(e);
2436         while (bp != null) {
2437             res.addContext(&quot;parsing &quot; + bp.code.asStackTraceElement(bp.bci()));
2438             bp = bp.parent;
2439         }
2440         throw res;
2441     }
2442 
2443     protected void parseAndInlineCallee(ResolvedJavaMethod targetMethod, ValueNode[] args, IntrinsicContext calleeIntrinsicContext) {
2444         FixedWithNextNode calleeBeforeUnwindNode = null;
2445         ValueNode calleeUnwindValue = null;
2446 
<span class="line-modified">2447         try (IntrinsicScope s = calleeIntrinsicContext != null &amp;&amp; !parsingIntrinsic() ? new IntrinsicScope(this, targetMethod.getSignature().toParameterKinds(!targetMethod.isStatic()), args) : null) {</span>


2448             BytecodeParser parser = graphBuilderInstance.createBytecodeParser(graph, this, targetMethod, INVOCATION_ENTRY_BCI, calleeIntrinsicContext);
<span class="line-modified">2449             FrameStateBuilder startFrameState = new FrameStateBuilder(parser, parser.code, graph);</span>

2450             if (!targetMethod.isStatic()) {
2451                 args[0] = nullCheckedValue(args[0]);
2452             }
2453             startFrameState.initializeFromArgumentsArray(args);
2454             parser.build(this.lastInstr, startFrameState);
2455 
<span class="line-modified">2456             if (parser.returnDataList == null) {</span>
<span class="line-removed">2457                 /* Callee does not return. */</span>
<span class="line-removed">2458                 lastInstr = null;</span>
<span class="line-removed">2459             } else {</span>
<span class="line-removed">2460                 ValueNode calleeReturnValue;</span>
<span class="line-removed">2461                 MergeNode returnMergeNode = null;</span>
<span class="line-removed">2462                 if (s != null) {</span>
<span class="line-removed">2463                     s.returnDataList = parser.returnDataList;</span>
<span class="line-removed">2464                 }</span>
<span class="line-removed">2465                 if (parser.returnDataList.size() == 1) {</span>
<span class="line-removed">2466                     /* Callee has a single return, we can continue parsing at that point. */</span>
<span class="line-removed">2467                     ReturnToCallerData singleReturnData = parser.returnDataList.get(0);</span>
<span class="line-removed">2468                     lastInstr = singleReturnData.beforeReturnNode;</span>
<span class="line-removed">2469                     calleeReturnValue = singleReturnData.returnValue;</span>
<span class="line-removed">2470                 } else {</span>
<span class="line-removed">2471                     assert parser.returnDataList.size() &gt; 1;</span>
<span class="line-removed">2472                     /* Callee has multiple returns, we need to insert a control flow merge. */</span>
<span class="line-removed">2473                     returnMergeNode = graph.add(new MergeNode());</span>
<span class="line-removed">2474                     calleeReturnValue = ValueMergeUtil.mergeValueProducers(returnMergeNode, parser.returnDataList, returnData -&gt; returnData.beforeReturnNode, returnData -&gt; returnData.returnValue);</span>
<span class="line-removed">2475                 }</span>
2476 
<span class="line-removed">2477                 if (calleeReturnValue != null) {</span>
<span class="line-removed">2478                     frameState.push(targetMethod.getSignature().getReturnKind().getStackKind(), calleeReturnValue);</span>
<span class="line-removed">2479                 }</span>
<span class="line-removed">2480                 if (returnMergeNode != null) {</span>
<span class="line-removed">2481                     returnMergeNode.setStateAfter(createFrameState(stream.nextBCI(), returnMergeNode));</span>
<span class="line-removed">2482                     lastInstr = finishInstruction(returnMergeNode, frameState);</span>
<span class="line-removed">2483                 }</span>
<span class="line-removed">2484             }</span>
2485             /*
2486              * Propagate any side effects into the caller when parsing intrinsics.
2487              */
2488             if (parser.frameState.isAfterSideEffect() &amp;&amp; parsingIntrinsic()) {
2489                 for (StateSplit sideEffect : parser.frameState.sideEffects()) {
2490                     frameState.addSideEffect(sideEffect);
2491                 }
2492             }
2493 


2494             calleeBeforeUnwindNode = parser.getBeforeUnwindNode();
2495             if (calleeBeforeUnwindNode != null) {
2496                 calleeUnwindValue = parser.getUnwindValue();
2497                 assert calleeUnwindValue != null;
2498             }
2499         }
2500 
2501         /*
2502          * Method handleException will call createTarget, which wires this exception edge to the
2503          * corresponding exception dispatch block in the caller. In the case where it wires to the
2504          * caller&#39;s unwind block, any FrameState created meanwhile, e.g., FrameState for
2505          * LoopExitNode, would be instantiated with AFTER_EXCEPTION_BCI. Such frame states should
2506          * not be fixed by IntrinsicScope.close, as they denote the states of the caller. Thus, the
2507          * following code should be placed outside the IntrinsicScope, so that correctly created
2508          * FrameStates are not replaced.
2509          */
2510         if (calleeBeforeUnwindNode != null) {
2511             calleeBeforeUnwindNode.setNext(handleException(calleeUnwindValue, bci(), false));
2512         }
2513     }
2514 


































2515     public MethodCallTargetNode createMethodCallTarget(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, StampPair returnStamp, JavaTypeProfile profile) {
2516         return new MethodCallTargetNode(invokeKind, targetMethod, args, returnStamp, profile);
2517     }
2518 
2519     protected InvokeNode createInvoke(int invokeBci, CallTargetNode callTarget, JavaKind resultType) {
2520         InvokeNode invoke = append(new InvokeNode(callTarget, invokeBci));
2521         frameState.pushReturn(resultType, invoke);
2522         invoke.setStateAfter(createFrameState(stream.nextBCI(), invoke));
2523         return invoke;
2524     }
2525 
2526     protected InvokeWithExceptionNode createInvokeWithException(int invokeBci, CallTargetNode callTarget, JavaKind resultType, ExceptionEdgeAction exceptionEdgeAction) {
2527         if (currentBlock != null &amp;&amp; stream.nextBCI() &gt; currentBlock.endBci) {
2528             /*
2529              * Clear non-live locals early so that the exception handler entry gets the cleared
2530              * state.
2531              */
2532             frameState.clearNonLiveLocals(currentBlock, liveness, false);
2533         }
2534 
2535         AbstractBeginNode exceptionEdge = handleException(null, bci(), exceptionEdgeAction == ExceptionEdgeAction.INCLUDE_AND_DEOPTIMIZE);
2536         InvokeWithExceptionNode invoke = append(new InvokeWithExceptionNode(callTarget, exceptionEdge, invokeBci));
2537         frameState.pushReturn(resultType, invoke);
2538         invoke.setStateAfter(createFrameState(stream.nextBCI(), invoke));
2539         return invoke;
2540     }
2541 
2542     protected void genReturn(ValueNode returnVal, JavaKind returnKind) {
2543         if (parsingIntrinsic() &amp;&amp; returnVal != null) {
2544 
2545             if (returnVal instanceof StateSplit) {
2546                 StateSplit stateSplit = (StateSplit) returnVal;
2547                 FrameState stateAfter = stateSplit.stateAfter();
2548                 if (stateSplit.hasSideEffect()) {
2549                     assert stateSplit != null;
2550                     if (stateAfter.bci == BytecodeFrame.AFTER_BCI) {
<span class="line-modified">2551                         assert stateAfter.usages().count() == 1;</span>
2552                         assert stateAfter.usages().first() == stateSplit;
2553                         FrameState state;
2554                         if (returnVal.getStackKind() == JavaKind.Illegal) {
2555                             // This should only occur when Fold and NodeIntrinsic plugins are
2556                             // deferred. Their return value might not be a Java type and in that
2557                             // case this can&#39;t be the final AFTER_BCI so just create a FrameState
2558                             // without a return value on the top of stack.
2559                             assert stateSplit instanceof Invoke;
2560                             ResolvedJavaMethod targetMethod = ((Invoke) stateSplit).getTargetMethod();
2561                             assert targetMethod != null &amp;&amp; (targetMethod.getAnnotation(Fold.class) != null || targetMethod.getAnnotation(Node.NodeIntrinsic.class) != null);
2562                             state = new FrameState(BytecodeFrame.AFTER_BCI);
2563                         } else {
2564                             state = new FrameState(BytecodeFrame.AFTER_BCI, returnVal);
2565                         }
2566                         stateAfter.replaceAtUsages(graph.add(state));
2567                         GraphUtil.killWithUnusedFloatingInputs(stateAfter);
2568                     } else {
2569                         /*
2570                          * This must be the return value from within a partial intrinsification.
2571                          */
<span class="line-modified">2572                         assert !BytecodeFrame.isPlaceholderBci(stateAfter.bci);</span>
2573                     }
2574                 } else {
2575                     assert stateAfter == null;
2576                 }
2577             }
2578         }
2579 
2580         ValueNode realReturnVal = processReturnValue(returnVal, returnKind);
2581 
2582         frameState.setRethrowException(false);
2583         frameState.clearStack();
2584         beforeReturn(realReturnVal, returnKind);
2585         if (parent == null) {
2586             append(new ReturnNode(realReturnVal));
2587         } else {
2588             if (returnDataList == null) {
2589                 returnDataList = new ArrayList&lt;&gt;();
2590             }
2591             returnDataList.add(new ReturnToCallerData(realReturnVal, lastInstr));
2592             lastInstr = null;
</pre>
<hr />
<pre>
2614             /*
2615              * Get the receiver from the initial state since bytecode rewriting could do arbitrary
2616              * things to the state of the locals.
2617              */
2618             ValueNode receiver = graph.start().stateAfter().localAt(0);
2619             assert receiver != null &amp;&amp; receiver.getStackKind() == JavaKind.Object;
2620             if (RegisterFinalizerNode.mayHaveFinalizer(receiver, graph.getAssumptions())) {
2621                 append(new RegisterFinalizerNode(receiver));
2622             }
2623         }
2624         genInfoPointNode(InfopointReason.METHOD_END, x);
2625         if (finalBarrierRequired) {
2626             assert originalReceiver != null;
2627             /*
2628              * When compiling an OSR with a final field store, don&#39;t bother tracking the original
2629              * receiver since the receiver cannot be EA&#39;ed.
2630              */
2631             append(new FinalFieldBarrierNode(entryBCI == INVOCATION_ENTRY_BCI ? originalReceiver : null));
2632         }
2633         synchronizedEpilogue(BytecodeFrame.AFTER_BCI, x, kind);



2634     }
2635 
2636     protected MonitorEnterNode createMonitorEnterNode(ValueNode x, MonitorIdNode monitorId) {
2637         return new MonitorEnterNode(x, monitorId);
2638     }
2639 
2640     protected void genMonitorEnter(ValueNode x, int bci) {
2641         MonitorIdNode monitorId = graph.add(new MonitorIdNode(frameState.lockDepth(true)));
2642         MonitorEnterNode monitorEnter = append(createMonitorEnterNode(x, monitorId));
2643         frameState.pushLock(x, monitorId);
2644         monitorEnter.setStateAfter(createFrameState(bci, monitorEnter));
2645     }
2646 
<span class="line-modified">2647     protected void genMonitorExit(ValueNode x, ValueNode escapedReturnValue, int bci) {</span>
2648         if (frameState.lockDepth(false) == 0) {
2649             throw bailout(&quot;unbalanced monitors: too many exits&quot;);
2650         }
2651         MonitorIdNode monitorId = frameState.peekMonitorId();
2652         ValueNode lockedObject = frameState.popLock();
<span class="line-modified">2653         if (GraphUtil.originalValue(lockedObject) != GraphUtil.originalValue(x)) {</span>
<span class="line-modified">2654             throw bailout(String.format(&quot;unbalanced monitors: mismatch at monitorexit, %s != %s&quot;, GraphUtil.originalValue(x), GraphUtil.originalValue(lockedObject)));</span>


2655         }
<span class="line-modified">2656         MonitorExitNode monitorExit = append(new MonitorExitNode(lockedObject, monitorId, escapedReturnValue));</span>
2657         monitorExit.setStateAfter(createFrameState(bci, monitorExit));
2658     }
2659 
2660     protected void genJsr(int dest) {
2661         BciBlock successor = currentBlock.getJsrSuccessor();
2662         assert successor.startBci == dest : successor.startBci + &quot; != &quot; + dest + &quot; @&quot; + bci();
2663         JsrScope scope = currentBlock.getJsrScope();
2664         int nextBci = getStream().nextBCI();
2665         if (!successor.getJsrScope().pop().equals(scope)) {
2666             throw new JsrNotSupportedBailout(&quot;unstructured control flow (internal limitation)&quot;);
2667         }
2668         if (successor.getJsrScope().nextReturnAddress() != nextBci) {
2669             throw new JsrNotSupportedBailout(&quot;unstructured control flow (internal limitation)&quot;);
2670         }
2671         ConstantNode nextBciNode = getJsrConstant(nextBci);
2672         frameState.push(JavaKind.Object, nextBciNode);
2673         appendGoto(successor);
2674     }
2675 
2676     protected void genRet(int localIndex) {
2677         BciBlock successor = currentBlock.getRetSuccessor();
2678         ValueNode local = frameState.loadLocal(localIndex, JavaKind.Object);
2679         JsrScope scope = currentBlock.getJsrScope();
2680         int retAddress = scope.nextReturnAddress();
2681         ConstantNode returnBciNode = getJsrConstant(retAddress);
<span class="line-modified">2682         LogicNode guard = IntegerEqualsNode.create(constantReflection, metaAccess, options, null, local, returnBciNode, NodeView.DEFAULT);</span>
<span class="line-modified">2683         guard = graph.addOrUniqueWithInputs(guard);</span>
<span class="line-modified">2684         append(new FixedGuardNode(guard, JavaSubroutineMismatch, InvalidateReprofile));</span>

2685         if (!successor.getJsrScope().equals(scope.pop())) {
2686             throw new JsrNotSupportedBailout(&quot;unstructured control flow (ret leaves more than one scope)&quot;);
2687         }
2688         appendGoto(successor);
2689     }
2690 
2691     private ConstantNode getJsrConstant(long bci) {
2692         JavaConstant nextBciConstant = new RawConstant(bci);
2693         Stamp nextBciStamp = StampFactory.forConstant(nextBciConstant);
2694         ConstantNode nextBciNode = new ConstantNode(nextBciConstant, nextBciStamp);
2695         return graph.unique(nextBciNode);
2696     }
2697 
2698     protected void genIntegerSwitch(ValueNode value, ArrayList&lt;BciBlock&gt; actualSuccessors, int[] keys, double[] keyProbabilities, int[] keySuccessors) {
2699         if (value.isConstant()) {
2700             JavaConstant constant = (JavaConstant) value.asConstant();
2701             int constantValue = constant.asInt();
2702             for (int i = 0; i &lt; keys.length; ++i) {
2703                 if (keys[i] == constantValue) {
2704                     appendGoto(actualSuccessors.get(keySuccessors[i]));
</pre>
<hr />
<pre>
2714                 switchNode.setBlockSuccessor(i, createBlockTarget(successorProbabilities[i], actualSuccessors.get(i), frameState));
2715             }
2716         }
2717     }
2718 
2719     /**
2720      * Helper function that sums up the probabilities of all keys that lead to a specific successor.
2721      *
2722      * @return an array of size successorCount with the accumulated probability for each successor.
2723      */
2724     private static double[] successorProbabilites(int successorCount, int[] keySuccessors, double[] keyProbabilities) {
2725         double[] probability = new double[successorCount];
2726         for (int i = 0; i &lt; keySuccessors.length; i++) {
2727             probability[keySuccessors[i]] += keyProbabilities[i];
2728         }
2729         return probability;
2730     }
2731 
2732     protected ConstantNode appendConstant(JavaConstant constant) {
2733         assert constant != null;
<span class="line-modified">2734         return ConstantNode.forConstant(constant, metaAccess, graph);</span>
2735     }
2736 
2737     @Override
2738     public &lt;T extends ValueNode&gt; T append(T v) {
2739         assert !graph.trackNodeSourcePosition() || graph.currentNodeSourcePosition() != null || currentBlock == blockMap.getUnwindBlock() || currentBlock instanceof ExceptionDispatchBlock;
2740         if (v.graph() != null) {
2741             return v;
2742         }
2743         T added = graph.addOrUniqueWithInputs(v);
2744         if (added == v) {
2745             updateLastInstruction(v);
2746         }
2747         return added;
2748     }
2749 
2750     private &lt;T extends ValueNode&gt; void updateLastInstruction(T v) {
2751         if (v instanceof FixedNode) {
2752             FixedNode fixedNode = (FixedNode) v;
2753             if (lastInstr != null) {
2754                 lastInstr.setNext(fixedNode);
2755             }
2756             if (fixedNode instanceof FixedWithNextNode) {
2757                 FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) fixedNode;
2758                 assert fixedWithNextNode.next() == null : &quot;cannot append instruction to instruction which isn&#39;t end&quot;;
2759                 lastInstr = fixedWithNextNode;
2760             } else {
2761                 lastInstr = null;
2762             }
2763         }
2764     }
2765 
<span class="line-modified">2766     private Target checkLoopExit(FixedNode target, BciBlock targetBlock, FrameStateBuilder state) {</span>
2767         if (currentBlock != null) {
2768             long exits = currentBlock.loops &amp; ~targetBlock.loops;
2769             if (exits != 0) {
2770                 LoopExitNode firstLoopExit = null;
2771                 LoopExitNode lastLoopExit = null;
2772 
2773                 int pos = 0;
2774                 ArrayList&lt;BciBlock&gt; exitLoops = new ArrayList&lt;&gt;(Long.bitCount(exits));
2775                 do {
2776                     long lMask = 1L &lt;&lt; pos;
2777                     if ((exits &amp; lMask) != 0) {
2778                         exitLoops.add(blockMap.getLoopHeader(pos));
2779                         exits &amp;= ~lMask;
2780                     }
2781                     pos++;
2782                 } while (exits != 0);
2783 
2784                 Collections.sort(exitLoops, new Comparator&lt;BciBlock&gt;() {
2785 
2786                     @Override
2787                     public int compare(BciBlock o1, BciBlock o2) {
2788                         return Long.bitCount(o2.loops) - Long.bitCount(o1.loops);
2789                     }
2790                 });
2791 
2792                 int bci = targetBlock.startBci;
2793                 if (targetBlock instanceof ExceptionDispatchBlock) {
2794                     bci = ((ExceptionDispatchBlock) targetBlock).deoptBci;
2795                 }
<span class="line-modified">2796                 FrameStateBuilder newState = state.copy();</span>
2797                 for (BciBlock loop : exitLoops) {
2798                     LoopBeginNode loopBegin = (LoopBeginNode) getFirstInstruction(loop);
2799                     LoopExitNode loopExit = graph.add(new LoopExitNode(loopBegin));
2800                     if (lastLoopExit != null) {
2801                         lastLoopExit.setNext(loopExit);
2802                     }
2803                     if (firstLoopExit == null) {
2804                         firstLoopExit = loopExit;
2805                     }
2806                     lastLoopExit = loopExit;
2807                     debug.log(&quot;Target %s Exits %s, scanning framestates...&quot;, targetBlock, loop);
2808                     newState.clearNonLiveLocals(targetBlock, liveness, true);
2809                     newState.insertLoopProxies(loopExit, getEntryState(loop));
2810                     loopExit.setStateAfter(newState.create(bci, loopExit));
2811                 }
2812 
<span class="line-modified">2813                 lastLoopExit.setNext(target);</span>
<span class="line-modified">2814                 return new Target(firstLoopExit, newState);</span>









2815             }
2816         }
<span class="line-modified">2817         return new Target(target, state);</span>





























2818     }
2819 
2820     private FrameStateBuilder getEntryState(BciBlock block) {
2821         return entryStateArray[block.id];
2822     }
2823 
2824     private void setEntryState(BciBlock block, FrameStateBuilder entryState) {
2825         this.entryStateArray[block.id] = entryState;
2826     }
2827 
2828     private void setFirstInstruction(BciBlock block, FixedWithNextNode firstInstruction) {
2829         this.firstInstructionArray[block.id] = firstInstruction;
2830     }
2831 
2832     private FixedWithNextNode getFirstInstruction(BciBlock block) {
2833         return firstInstructionArray[block.id];
2834     }
2835 
2836     private FixedNode createTarget(double probability, BciBlock block, FrameStateBuilder stateAfter) {
2837         assert probability &gt;= 0 &amp;&amp; probability &lt;= 1.01 : probability;
</pre>
<hr />
<pre>
2842             return createTarget(block, stateAfter);
2843         }
2844     }
2845 
2846     private FixedNode createTarget(BciBlock block, FrameStateBuilder state) {
2847         return createTarget(block, state, false, false);
2848     }
2849 
2850     @SuppressWarnings(&quot;try&quot;)
2851     private FixedNode createTarget(BciBlock block, FrameStateBuilder state, boolean canReuseInstruction, boolean canReuseState) {
2852         assert block != null &amp;&amp; state != null;
2853         assert !block.isExceptionEntry() || state.stackSize() == 1;
2854 
2855         try (DebugCloseable context = openNodeContext(state, block.startBci)) {
2856             if (getFirstInstruction(block) == null) {
2857                 /*
2858                  * This is the first time we see this block as a branch target. Create and return a
2859                  * placeholder that later can be replaced with a MergeNode when we see this block
2860                  * again.
2861                  */
<span class="line-modified">2862                 FixedNode targetNode;</span>
<span class="line-modified">2863                 if (canReuseInstruction &amp;&amp; (block.getPredecessorCount() == 1 || !controlFlowSplit) &amp;&amp; !block.isLoopHeader() &amp;&amp; (currentBlock.loops &amp; ~block.loops) == 0) {</span>









2864                     setFirstInstruction(block, lastInstr);
2865                     lastInstr = null;
2866                 } else {
2867                     setFirstInstruction(block, graph.add(new BeginNode()));
2868                 }
<span class="line-modified">2869                 targetNode = getFirstInstruction(block);</span>
<span class="line-modified">2870                 Target target = checkLoopExit(targetNode, block, state);</span>
<span class="line-modified">2871                 FixedNode result = target.fixed;</span>
2872                 FrameStateBuilder currentEntryState = target.state == state ? (canReuseState ? state : state.copy()) : target.state;
2873                 setEntryState(block, currentEntryState);
2874                 currentEntryState.clearNonLiveLocals(block, liveness, true);
2875 
<span class="line-modified">2876                 debug.log(&quot;createTarget %s: first visit, result: %s&quot;, block, targetNode);</span>
2877                 return result;
2878             }
2879 
<span class="line-removed">2880             // We already saw this block before, so we have to merge states.</span>
<span class="line-removed">2881             if (!getEntryState(block).isCompatibleWith(state)) {</span>
<span class="line-removed">2882                 throw bailout(String.format(&quot;stacks do not match on merge from %d into %s; bytecodes would not verify:%nexpect: %s%nactual: %s&quot;, bci(), block, getEntryState(block), state));</span>
<span class="line-removed">2883             }</span>
<span class="line-removed">2884 </span>
2885             if (getFirstInstruction(block) instanceof LoopBeginNode) {
2886                 assert (block.isLoopHeader() &amp;&amp; currentBlock.getId() &gt;= block.getId()) : &quot;must be backward branch&quot;;
2887                 /*
2888                  * Backward loop edge. We need to create a special LoopEndNode and merge with the
2889                  * loop begin node created before.
2890                  */
2891                 LoopBeginNode loopBegin = (LoopBeginNode) getFirstInstruction(block);
2892                 LoopEndNode loopEnd = graph.add(new LoopEndNode(loopBegin));
<span class="line-modified">2893                 Target target = checkLoopExit(loopEnd, block, state);</span>
<span class="line-modified">2894                 FixedNode result = target.fixed;</span>
2895                 getEntryState(block).merge(loopBegin, target.state);
2896 
2897                 debug.log(&quot;createTarget %s: merging backward branch to loop header %s, result: %s&quot;, block, loopBegin, result);
2898                 return result;
2899             }
2900             assert currentBlock == null || currentBlock.getId() &lt; block.getId() : &quot;must not be backward branch&quot;;
2901             assert getFirstInstruction(block).next() == null : &quot;bytecodes already parsed for block&quot;;
2902 
2903             if (getFirstInstruction(block) instanceof AbstractBeginNode &amp;&amp; !(getFirstInstruction(block) instanceof AbstractMergeNode)) {
2904                 /*
2905                  * This is the second time we see this block. Create the actual MergeNode and the
2906                  * End Node for the already existing edge.
2907                  */
2908                 AbstractBeginNode beginNode = (AbstractBeginNode) getFirstInstruction(block);
2909 
2910                 // The EndNode for the already existing edge.
2911                 EndNode end = graph.add(new EndNode());
2912                 // The MergeNode that replaces the placeholder.
2913                 AbstractMergeNode mergeNode = graph.add(new MergeNode());
2914                 FixedNode next = beginNode.next();
2915 
2916                 if (beginNode.predecessor() instanceof ControlSplitNode) {
2917                     beginNode.setNext(end);
2918                 } else {
2919                     beginNode.replaceAtPredecessor(end);
2920                     beginNode.safeDelete();
2921                 }
2922 
2923                 mergeNode.addForwardEnd(end);
2924                 mergeNode.setNext(next);
2925 
2926                 setFirstInstruction(block, mergeNode);
2927             }
2928 
2929             AbstractMergeNode mergeNode = (AbstractMergeNode) getFirstInstruction(block);
2930 
2931             // The EndNode for the newly merged edge.
2932             EndNode newEnd = graph.add(new EndNode());
<span class="line-modified">2933             Target target = checkLoopExit(newEnd, block, state);</span>
<span class="line-modified">2934             FixedNode result = target.fixed;</span>
2935             getEntryState(block).merge(mergeNode, target.state);
2936             mergeNode.addForwardEnd(newEnd);
2937 
2938             debug.log(&quot;createTarget %s: merging state, result: %s&quot;, block, result);
2939             return result;
2940         }
2941     }
2942 
2943     /**
2944      * Returns a block begin node with the specified state. If the specified probability is 0, the
2945      * block deoptimizes immediately.
2946      */
2947     private AbstractBeginNode createBlockTarget(double probability, BciBlock block, FrameStateBuilder stateAfter) {
2948         FixedNode target = createTarget(probability, block, stateAfter);
2949         AbstractBeginNode begin = BeginNode.begin(target);
2950 
2951         assert !(target instanceof DeoptimizeNode &amp;&amp; begin instanceof BeginStateSplitNode &amp;&amp;
2952                         ((BeginStateSplitNode) begin).stateAfter() != null) : &quot;We are not allowed to set the stateAfter of the begin node,&quot; +
2953                                         &quot; because we have to deoptimize to a bci _before_ the actual if, so that the interpreter can update the profiling information.&quot;;
2954         return begin;
</pre>
<hr />
<pre>
2979 
2980             if (block != blockMap.getUnwindBlock() &amp;&amp; !(block instanceof ExceptionDispatchBlock)) {
2981                 frameState.setRethrowException(false);
2982             }
2983 
2984             if (firstInstruction instanceof AbstractMergeNode) {
2985                 setMergeStateAfter(block, firstInstruction);
2986             }
2987 
2988             if (block == blockMap.getUnwindBlock()) {
2989                 handleUnwindBlock((ExceptionDispatchBlock) block);
2990             } else if (block instanceof ExceptionDispatchBlock) {
2991                 createExceptionDispatch((ExceptionDispatchBlock) block);
2992             } else {
2993                 iterateBytecodesForBlock(block);
2994             }
2995         }
2996     }
2997 
2998     private void handleUnwindBlock(ExceptionDispatchBlock block) {





2999         if (parent == null) {
<span class="line-removed">3000             finishPrepare(lastInstr, block.deoptBci, frameState);</span>
<span class="line-removed">3001             frameState.setRethrowException(false);</span>
3002             createUnwind();
3003         } else {
<span class="line-modified">3004             ValueNode exception = frameState.pop(JavaKind.Object);</span>
<span class="line-removed">3005             this.unwindValue = exception;</span>
3006             this.beforeUnwindNode = this.lastInstr;
3007         }
3008     }
3009 
3010     private void setMergeStateAfter(BciBlock block, FixedWithNextNode firstInstruction) {
3011         AbstractMergeNode abstractMergeNode = (AbstractMergeNode) firstInstruction;
3012         if (abstractMergeNode.stateAfter() == null) {
3013             int bci = block.startBci;
3014             if (block instanceof ExceptionDispatchBlock) {
3015                 bci = ((ExceptionDispatchBlock) block).deoptBci;
3016             }
3017             abstractMergeNode.setStateAfter(createFrameState(bci, abstractMergeNode));
3018         }
3019     }
3020 
3021     @SuppressWarnings(&quot;try&quot;)
3022     private void createUnwind() {
3023         assert frameState.stackSize() == 1 : frameState;
<span class="line-removed">3024         synchronizedEpilogue(BytecodeFrame.AFTER_EXCEPTION_BCI, null, null);</span>
3025         try (DebugCloseable context = openNodeContext(frameState, BytecodeFrame.UNWIND_BCI)) {
3026             ValueNode exception = frameState.pop(JavaKind.Object);
3027             append(new UnwindNode(exception));
3028         }
3029     }
3030 
3031     @SuppressWarnings(&quot;try&quot;)
3032     private void synchronizedEpilogue(int bci, ValueNode currentReturnValue, JavaKind currentReturnValueKind) {
3033         try (DebugCloseable context = openNodeContext(frameState, bci)) {
3034             if (method.isSynchronized()) {
<span class="line-modified">3035                 if (currentReturnValue != null) {</span>


3036                     frameState.push(currentReturnValueKind, currentReturnValue);
3037                 }
3038                 genMonitorExit(methodSynchronizedObject, currentReturnValue, bci);
3039                 assert !frameState.rethrowException();
<span class="line-removed">3040                 finishPrepare(lastInstr, bci, frameState);</span>
3041             }
3042             if (frameState.lockDepth(false) != 0) {
3043                 throw bailout(&quot;unbalanced monitors: too few exits exiting frame&quot;);
3044             }
3045         }
3046     }
3047 
3048     @SuppressWarnings(&quot;try&quot;)
3049     private void createExceptionDispatch(ExceptionDispatchBlock block) {
3050         try (DebugCloseable context = openNodeContext(frameState, BytecodeFrame.AFTER_EXCEPTION_BCI)) {
3051             lastInstr = finishInstruction(lastInstr, frameState);
3052 
3053             assert frameState.stackSize() == 1 : frameState;
3054             if (block.handler.isCatchAll()) {
3055                 assert block.getSuccessorCount() == 1;
3056                 appendGoto(block.getSuccessor(0));
3057                 return;
3058             }
3059 
3060             JavaType catchType = block.handler.getCatchType();
</pre>
<hr />
<pre>
3102         }
3103     }
3104 
3105     private void appendGoto(BciBlock successor) {
3106         FixedNode targetInstr = createTarget(successor, frameState, true, true);
3107         if (lastInstr != null &amp;&amp; lastInstr != targetInstr) {
3108             lastInstr.setNext(targetInstr);
3109         }
3110     }
3111 
3112     @SuppressWarnings(&quot;try&quot;)
3113     protected void iterateBytecodesForBlock(BciBlock block) {
3114         if (block.isLoopHeader()) {
3115             // Create the loop header block, which later will merge the backward branches of
3116             // the loop.
3117             controlFlowSplit = true;
3118             LoopBeginNode loopBegin = appendLoopBegin(this.lastInstr, block.startBci);
3119             lastInstr = loopBegin;
3120 
3121             // Create phi functions for all local variables and operand stack slots.
<span class="line-modified">3122             frameState.insertLoopPhis(liveness, block.loopId, loopBegin, forceLoopPhis(), stampFromValueForForcedPhis());</span>
3123             loopBegin.setStateAfter(createFrameState(block.startBci, loopBegin));
3124 
3125             /*
3126              * We have seen all forward branches. All subsequent backward branches will merge to the
3127              * loop header. This ensures that the loop header has exactly one non-loop predecessor.
3128              */
3129             setFirstInstruction(block, loopBegin);
3130             /*
3131              * We need to preserve the frame state builder of the loop header so that we can merge
3132              * values for phi functions, so make a copy of it.
3133              */
3134             setEntryState(block, frameState.copy());
3135 
3136             debug.log(&quot;  created loop header %s&quot;, loopBegin);
3137         } else if (lastInstr instanceof MergeNode) {
3138             /*
3139              * All inputs of non-loop phi nodes are known by now. We can infer the stamp for the
3140              * phi, so that parsing continues with more precise type information.
3141              */
3142             frameState.inferPhiStamps((AbstractMergeNode) lastInstr);
</pre>
<hr />
<pre>
3317             b = x;
3318         }
3319         if (canonicalizedCondition.mustNegate()) {
3320             trueSuccessor = falseBlock;
3321             falseSuccessor = trueBlock;
3322         }
3323 
3324         // Create the logic node for the condition.
3325         LogicNode condition = createLogicNode(canonicalizedCondition.getCanonicalCondition(), a, b);
3326 
3327         double probability = -1;
3328         if (condition instanceof IntegerEqualsNode) {
3329             probability = extractInjectedProbability((IntegerEqualsNode) condition);
3330             // the probability coming from here is about the actual condition
3331         }
3332 
3333         if (probability == -1) {
3334             probability = getProfileProbability(canonicalizedCondition.mustNegate());
3335         }
3336 
<span class="line-removed">3337         probability = clampProbability(probability);</span>
3338         genIf(condition, trueSuccessor, falseSuccessor, probability);
3339     }
3340 
3341     protected double getProfileProbability(boolean negate) {
3342         if (profilingInfo == null) {
3343             return 0.5;
3344         }
3345 
3346         assert assertAtIfBytecode();
3347         double probability = profilingInfo.getBranchTakenProbability(bci());
3348 
3349         if (probability &lt; 0) {
3350             assert probability == -1 : &quot;invalid probability&quot;;
3351             debug.log(&quot;missing probability in %s at bci %d&quot;, code, bci());
3352             return 0.5;
3353         }
3354 
3355         if (negate &amp;&amp; shouldComplementProbability()) {
3356             // the probability coming from profile is about the original condition
3357             probability = 1 - probability;
3358         }
<span class="line-modified">3359         return probability;</span>
3360     }
3361 
<span class="line-modified">3362     private static double extractInjectedProbability(IntegerEqualsNode condition) {</span>
3363         // Propagate injected branch probability if any.
3364         IntegerEqualsNode equalsNode = condition;
3365         BranchProbabilityNode probabilityNode = null;
3366         ValueNode other = null;
3367         if (equalsNode.getX() instanceof BranchProbabilityNode) {
3368             probabilityNode = (BranchProbabilityNode) equalsNode.getX();
3369             other = equalsNode.getY();
3370         } else if (equalsNode.getY() instanceof BranchProbabilityNode) {
3371             probabilityNode = (BranchProbabilityNode) equalsNode.getY();
3372             other = equalsNode.getX();
3373         }
3374 
3375         if (probabilityNode != null &amp;&amp; probabilityNode.getProbability().isConstant() &amp;&amp; other != null &amp;&amp; other.isConstant()) {
<span class="line-modified">3376             double probabilityValue = probabilityNode.getProbability().asJavaConstant().asDouble();</span>
3377             return other.asJavaConstant().asInt() == 0 ? 1.0 - probabilityValue : probabilityValue;
3378         }
3379         return -1;
3380     }
3381 
3382     protected void genIf(LogicNode conditionInput, BciBlock trueBlockInput, BciBlock falseBlockInput, double probabilityInput) {
3383         BciBlock trueBlock = trueBlockInput;
3384         BciBlock falseBlock = falseBlockInput;
3385         LogicNode condition = conditionInput;
3386         double probability = probabilityInput;
3387         FrameState stateBefore = null;
3388         ProfilingPlugin profilingPlugin = this.graphBuilderConfig.getPlugins().getProfilingPlugin();
3389         if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3390             stateBefore = createCurrentFrameState();
3391         }
3392 
3393         // Remove a logic negation node.
3394         if (condition instanceof LogicNegationNode) {
3395             LogicNegationNode logicNegationNode = (LogicNegationNode) condition;
3396             BciBlock tmpBlock = trueBlock;
</pre>
<hr />
<pre>
3426                 if (graph.trackNodeSourcePosition()) {
3427                     survivingSuccessorPosition = new NodeSourcePosition(currentPosition.getCaller(), currentPosition.getMethod(), noDeoptBlock.startBci);
3428                 }
3429                 boolean negated = deoptBlock == trueBlock;
3430                 if (!isPotentialCountedLoopExit(condition, deoptBlock)) {
3431                     if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3432                         profilingPlugin.profileGoto(this, method, bci(), noDeoptBlock.startBci, stateBefore);
3433                     }
3434                     append(new FixedGuardNode(condition, UnreachedCode, InvalidateReprofile, negated, survivingSuccessorPosition));
3435                     appendGoto(noDeoptBlock);
3436                 } else {
3437                     this.controlFlowSplit = true;
3438                     FixedNode noDeoptSuccessor = createTarget(noDeoptBlock, frameState, false, true);
3439                     DeoptimizeNode deopt = graph.add(new DeoptimizeNode(InvalidateReprofile, UnreachedCode));
3440                     /*
3441                      * We do not want to `checkLoopExit` here: otherwise the deopt will go to the
3442                      * deoptBlock&#39;s BCI, skipping the branch in the interpreter, and the profile
3443                      * will never see that the branch is taken. This can lead to deopt loops or OSR
3444                      * failure.
3445                      */

3446                     FixedNode deoptSuccessor = BeginNode.begin(deopt);
<span class="line-modified">3447                     ValueNode ifNode = genIfNode(condition, negated ? deoptSuccessor : noDeoptSuccessor, negated ? noDeoptSuccessor : deoptSuccessor, negated ? 1 - probability : probability);</span>
3448                     postProcessIfNode(ifNode);
3449                     append(ifNode);
3450                 }
3451                 return;
3452             }
3453 
3454             if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3455                 profilingPlugin.profileIf(this, method, bci(), condition, trueBlock.startBci, falseBlock.startBci, stateBefore);
3456             }
3457 
3458             int oldBci = stream.currentBCI();
3459             int trueBlockInt = checkPositiveIntConstantPushed(trueBlock);
3460             if (trueBlockInt != -1) {
3461                 int falseBlockInt = checkPositiveIntConstantPushed(falseBlock);
3462                 if (falseBlockInt != -1) {
3463                     if (tryGenConditionalForIf(trueBlock, falseBlock, condition, oldBci, trueBlockInt, falseBlockInt)) {
3464                         return;
3465                     }
3466                 }
3467             }
3468 
3469             this.controlFlowSplit = true;
<span class="line-modified">3470             FixedNode trueSuccessor = createTarget(trueBlock, frameState, false, false);</span>
<span class="line-modified">3471             FixedNode falseSuccessor = createTarget(falseBlock, frameState, false, true);</span>




















3472             ValueNode ifNode = genIfNode(condition, trueSuccessor, falseSuccessor, probability);
3473             postProcessIfNode(ifNode);
3474             append(ifNode);
3475         }
3476     }
3477 
3478     public boolean isPotentialCountedLoopExit(LogicNode condition, BciBlock target) {
3479         if (currentBlock != null) {
3480             long exits = currentBlock.loops &amp; ~target.loops;
3481             if (exits != 0) {
3482                 return condition instanceof CompareNode;
3483             }
3484         }
3485         return false;
3486     }
3487 
3488     /**
3489      * Hook for subclasses to decide whether the IfNode probability should be complemented during
3490      * conversion to Graal IR.
3491      */
</pre>
<hr />
<pre>
3585     }
3586 
3587     private boolean gotoOrFallThroughAfterConstant(BciBlock block) {
3588         stream.setBCI(block.startBci);
3589         int currentBCI = stream.nextBCI();
3590         stream.setBCI(currentBCI);
3591         int currentBC = stream.currentBC();
3592         return stream.currentBCI() &gt; block.endBci || currentBC == Bytecodes.GOTO || currentBC == Bytecodes.GOTO_W;
3593     }
3594 
3595     private boolean returnAfterConstant(BciBlock block) {
3596         stream.setBCI(block.startBci);
3597         int currentBCI = stream.nextBCI();
3598         stream.setBCI(currentBCI);
3599         int currentBC = stream.currentBC();
3600         return currentBC == Bytecodes.IRETURN;
3601     }
3602 
3603     @Override
3604     public StampProvider getStampProvider() {
<span class="line-modified">3605         return stampProvider;</span>
3606     }
3607 
3608     @Override
3609     public MetaAccessProvider getMetaAccess() {
<span class="line-modified">3610         return metaAccess;</span>





3611     }
3612 
3613     @Override
3614     public void push(JavaKind slotKind, ValueNode value) {
3615         assert value.isAlive();
3616         frameState.push(slotKind, value);
3617     }
3618 
3619     @Override
3620     public ValueNode pop(JavaKind slotKind) {
3621         return frameState.pop(slotKind);
3622     }
3623 
3624     @Override
3625     public ConstantReflectionProvider getConstantReflection() {
<span class="line-modified">3626         return constantReflection;</span>
3627     }
3628 
3629     @Override
3630     public ConstantFieldProvider getConstantFieldProvider() {
<span class="line-modified">3631         return constantFieldProvider;</span>
3632     }
3633 
3634     /**
3635      * Gets the graph being processed by this builder.
3636      */
3637     @Override
3638     public StructuredGraph getGraph() {
3639         return graph;
3640     }
3641 
3642     @Override
3643     public BytecodeParser getParent() {
3644         return parent;
3645     }
3646 
3647     @Override
3648     public IntrinsicContext getIntrinsic() {
3649         return intrinsicContext;
3650     }
3651 
</pre>
<hr />
<pre>
3658             if (bp != this) {
3659                 fmt.format(&quot;%n%s&quot;, indent);
3660             }
3661             fmt.format(&quot;%s [bci: %d, intrinsic: %s]&quot;, bp.code.asStackTraceElement(bp.bci()), bp.bci(), bp.parsingIntrinsic());
3662             fmt.format(&quot;%n%s&quot;, new BytecodeDisassembler().disassemble(bp.code, bp.bci(), bp.bci() + 10));
3663             bp = bp.parent;
3664             indent += &quot; &quot;;
3665         }
3666         return fmt.toString();
3667     }
3668 
3669     @Override
3670     public BailoutException bailout(String string) {
3671         FrameState currentFrameState = createFrameState(bci(), null);
3672         StackTraceElement[] elements = GraphUtil.approxSourceStackTraceElement(currentFrameState);
3673         BailoutException bailout = new PermanentBailoutException(string);
3674         throw GraphUtil.createBailoutException(string, bailout, elements);
3675     }
3676 
3677     private FrameState createFrameState(int bci, StateSplit forStateSplit) {

3678         if (currentBlock != null &amp;&amp; bci &gt; currentBlock.endBci) {
3679             frameState.clearNonLiveLocals(currentBlock, liveness, false);
3680         }
3681         return frameState.create(bci, forStateSplit);
3682     }
3683 











3684     @Override
3685     public void setStateAfter(StateSplit sideEffect) {
3686         assert sideEffect.hasSideEffect() || sideEffect instanceof AbstractMergeNode;
3687         FrameState stateAfter = createFrameState(stream.nextBCI(), sideEffect);
3688         sideEffect.setStateAfter(stateAfter);
3689     }
3690 
3691     protected NodeSourcePosition createBytecodePosition() {
3692         NodeSourcePosition bytecodePosition = frameState.createBytecodePosition(bci());
3693         return bytecodePosition;
3694     }
3695 
3696     public void setCurrentFrameState(FrameStateBuilder frameState) {
3697         this.frameState = frameState;
3698     }
3699 
3700     protected final BytecodeStream getStream() {
3701         return stream;
3702     }
3703 
</pre>
<hr />
<pre>
3736         Object con = lookupConstant(cpi, opcode);
3737 
3738         if (con instanceof JavaType) {
3739             // this is a load of class constant which might be unresolved
3740             JavaType type = (JavaType) con;
3741             if (typeIsResolved(type)) {
3742                 frameState.push(JavaKind.Object, appendConstant(getConstantReflection().asJavaClass((ResolvedJavaType) type)));
3743             } else {
3744                 handleUnresolvedLoadConstant(type);
3745             }
3746         } else if (con instanceof JavaConstant) {
3747             JavaConstant constant = (JavaConstant) con;
3748             frameState.push(constant.getJavaKind(), appendConstant(constant));
3749         } else {
3750             throw new Error(&quot;lookupConstant returned an object of incorrect type&quot;);
3751         }
3752     }
3753 
3754     private JavaKind refineComponentType(ValueNode array, JavaKind kind) {
3755         if (kind == JavaKind.Byte) {
<span class="line-modified">3756             JavaType type = array.stamp(NodeView.DEFAULT).javaType(metaAccess);</span>
3757             if (type.isArray()) {
3758                 JavaType componentType = type.getComponentType();
3759                 if (componentType != null) {
3760                     JavaKind refinedKind = componentType.getJavaKind();
3761                     assert refinedKind == JavaKind.Byte || refinedKind == JavaKind.Boolean;
3762                     return refinedKind;
3763                 }
3764             }
3765         }
3766         return kind;
3767     }
3768 
3769     private void genLoadIndexed(JavaKind kind) {
3770         ValueNode index = frameState.pop(JavaKind.Int);
3771         ValueNode array = frameState.pop(JavaKind.Object);
3772 
3773         array = maybeEmitExplicitNullCheck(array);
3774         GuardingNode boundsCheck = maybeEmitExplicitBoundsCheck(array, index);
3775 
3776         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
</pre>
<hr />
<pre>
3901         ValueNode v;
3902         switch (opcode) {
3903             case IAND:
3904             case LAND:
3905                 v = genAnd(x, y);
3906                 break;
3907             case IOR:
3908             case LOR:
3909                 v = genOr(x, y);
3910                 break;
3911             case IXOR:
3912             case LXOR:
3913                 v = genXor(x, y);
3914                 break;
3915             default:
3916                 throw shouldNotReachHere();
3917         }
3918         frameState.push(kind, append(v));
3919     }
3920 
<span class="line-modified">3921     private void genCompareOp(JavaKind kind, boolean isUnorderedLess) {</span>
3922         ValueNode y = frameState.pop(kind);
3923         ValueNode x = frameState.pop(kind);
3924         frameState.push(JavaKind.Int, append(genNormalizeCompare(x, y, isUnorderedLess)));
3925     }
3926 






3927     private void genFloatConvert(FloatConvert op, JavaKind from, JavaKind to) {
3928         ValueNode input = frameState.pop(from);
3929         frameState.push(to, append(genFloatConvert(op, input)));
3930     }
3931 
3932     private void genSignExtend(JavaKind from, JavaKind to) {
3933         ValueNode input = frameState.pop(from);
3934         if (from != from.getStackKind()) {
3935             input = append(genNarrow(input, from.getBitCount()));
3936         }
3937         frameState.push(to, append(genSignExtend(input, to.getBitCount())));
3938     }
3939 
3940     private void genZeroExtend(JavaKind from, JavaKind to) {
3941         ValueNode input = frameState.pop(from);
3942         if (from != from.getStackKind()) {
3943             input = append(genNarrow(input, from.getBitCount()));
3944         }
3945         frameState.push(to, append(genZeroExtend(input, to.getBitCount())));
3946     }
</pre>
<hr />
<pre>
3979     private static void initialize(ResolvedJavaType resolvedType) {
3980         /*
3981          * Since we&#39;re potentially triggering class initialization here, we need synchronization to
3982          * mitigate the potential for class initialization related deadlock being caused by the
3983          * compiler (e.g., https://github.com/graalvm/graal-core/pull/232/files#r90788550).
3984          */
3985         synchronized (BytecodeParser.class) {
3986             resolvedType.initialize();
3987         }
3988     }
3989 
3990     protected JavaType lookupType(int cpi, int bytecode) {
3991         maybeEagerlyResolve(cpi, bytecode);
3992         JavaType result = constantPool.lookupType(cpi, bytecode);
3993         assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaType;
3994         return result;
3995     }
3996 
3997     private String unresolvedMethodAssertionMessage(JavaMethod result) {
3998         String message = result.format(&quot;%H.%n(%P)%R&quot;);
<span class="line-modified">3999         if (JavaVersionUtil.Java8OrEarlier) {</span>
4000             JavaType declaringClass = result.getDeclaringClass();
4001             String className = declaringClass.getName();
4002             switch (className) {
4003                 case &quot;Ljava/nio/ByteBuffer;&quot;:
4004                 case &quot;Ljava/nio/ShortBuffer;&quot;:
4005                 case &quot;Ljava/nio/CharBuffer;&quot;:
4006                 case &quot;Ljava/nio/IntBuffer;&quot;:
4007                 case &quot;Ljava/nio/LongBuffer;&quot;:
4008                 case &quot;Ljava/nio/FloatBuffer;&quot;:
4009                 case &quot;Ljava/nio/DoubleBuffer;&quot;:
4010                 case &quot;Ljava/nio/MappedByteBuffer;&quot;: {
4011                     switch (result.getName()) {
4012                         case &quot;position&quot;:
4013                         case &quot;limit&quot;:
4014                         case &quot;mark&quot;:
4015                         case &quot;reset&quot;:
4016                         case &quot;clear&quot;:
4017                         case &quot;flip&quot;:
4018                         case &quot;rewind&quot;: {
4019                             String returnType = result.getSignature().getReturnType(null).toJavaName();
4020                             if (returnType.equals(declaringClass.toJavaName())) {
4021                                 message += String.format(&quot; [Probably cause: %s was compiled with javac from JDK 9+ using &quot; +
4022                                                 &quot;`-target 8` and `-source 8` options. See https://bugs.openjdk.java.net/browse/JDK-4774077 for details.]&quot;, method.getDeclaringClass().toClassName());
4023                             }
4024                         }
4025                     }
4026                     break;
4027                 }
4028             }
4029         }
4030         return message;
4031     }
4032 
4033     private JavaMethod lookupMethod(int cpi, int opcode) {
4034         maybeEagerlyResolve(cpi, opcode);
<span class="line-modified">4035         JavaMethod result = constantPool.lookupMethod(cpi, opcode);</span>
4036         assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaMethod : unresolvedMethodAssertionMessage(result);
4037         return result;
4038     }
4039 




4040     protected JavaField lookupField(int cpi, int opcode) {
4041         maybeEagerlyResolve(cpi, opcode);
4042         JavaField result = constantPool.lookupField(cpi, method, opcode);
4043         return lookupField(result);
4044     }
4045 
4046     protected JavaField lookupField(JavaField result) {
4047         assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaField : &quot;Not resolved: &quot; + result;
4048         if (parsingIntrinsic() || eagerInitializing) {
4049             if (result instanceof ResolvedJavaField) {
4050                 ResolvedJavaType declaringClass = ((ResolvedJavaField) result).getDeclaringClass();
4051                 if (!declaringClass.isInitialized()) {
4052                     // Even with eager initialization, superinterfaces are not always initialized.
4053                     // See StaticInterfaceFieldTest
4054                     assert !eagerInitializing || declaringClass.isInterface() : &quot;Declaring class not initialized but not an interface? &quot; + declaringClass;
4055                     initialize(declaringClass);
4056                 }
4057             }
4058         }
4059         assert !uninitializedIsError || (result instanceof ResolvedJavaField &amp;&amp; ((ResolvedJavaField) result).getDeclaringClass().isInitialized()) : result;
</pre>
<hr />
<pre>
4070     protected void maybeEagerlyResolve(int cpi, int bytecode) {
4071         if (intrinsicContext != null) {
4072             constantPool.loadReferencedType(cpi, bytecode);
4073         } else if (graphBuilderConfig.eagerResolving()) {
4074             /*
4075              * Since we&#39;re potentially triggering class initialization here, we need synchronization
4076              * to mitigate the potential for class initialization related deadlock being caused by
4077              * the compiler (e.g., https://github.com/graalvm/graal-core/pull/232/files#r90788550).
4078              */
4079             synchronized (BytecodeParser.class) {
4080                 ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4081                 if (classInitializationPlugin != null) {
4082                     classInitializationPlugin.loadReferencedType(this, constantPool, cpi, bytecode);
4083                 } else {
4084                     constantPool.loadReferencedType(cpi, bytecode);
4085                 }
4086             }
4087         }
4088     }
4089 







4090     protected void maybeEagerlyInitialize(ResolvedJavaType resolvedType) {
4091         if (!resolvedType.isInitialized() &amp;&amp; eagerInitializing) {
4092             initialize(resolvedType);
4093         }
4094     }
4095 
4096     private JavaTypeProfile getProfileForTypeCheck(TypeReference type) {
4097         if (parsingIntrinsic() || profilingInfo == null || !optimisticOpts.useTypeCheckHints(getOptions()) || type.isExact()) {
4098             return null;
4099         } else {
4100             return profilingInfo.getTypeProfile(bci());
4101         }
4102     }
4103 
4104     private void genCheckCast(int cpi) {
4105         JavaType type = lookupType(cpi, CHECKCAST);
4106         ValueNode object = frameState.pop(JavaKind.Object);
4107         genCheckCast(type, object);
4108     }
4109 
</pre>
<hr />
<pre>
4161                 castNode = append(PiNode.create(object, StampFactory.object(checkedType, nonNull), guard.asNode()));
4162             }
4163         }
4164         frameState.push(JavaKind.Object, castNode);
4165     }
4166 
4167     private void genInstanceOf(int cpi) {
4168         JavaType type = lookupType(cpi, INSTANCEOF);
4169         ValueNode object = frameState.pop(JavaKind.Object);
4170         genInstanceOf(type, object);
4171     }
4172 
4173     protected void genInstanceOf(JavaType type, ValueNode object) {
4174         if (typeIsResolved(type)) {
4175             genInstanceOf((ResolvedJavaType) type, object);
4176         } else {
4177             handleUnresolvedInstanceOf(type, object);
4178         }
4179     }
4180 

4181     protected void genInstanceOf(ResolvedJavaType resolvedType, ValueNode objectIn) {
4182         ValueNode object = objectIn;
4183         TypeReference checkedType = TypeReference.createTrusted(graph.getAssumptions(), resolvedType);
4184         JavaTypeProfile profile = getProfileForTypeCheck(checkedType);
4185 
4186         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4187             if (plugin.handleInstanceOf(this, object, checkedType.getType(), profile)) {
4188                 return;
4189             }
4190         }
4191 
4192         LogicNode instanceOfNode = null;
4193         if (profile != null) {
4194             if (profile.getNullSeen().isFalse()) {
4195                 object = nullCheckedValue(object);
4196                 ResolvedJavaType singleType = profile.asSingleType();
4197                 if (singleType != null) {
4198                     LogicNode typeCheck = append(createInstanceOf(TypeReference.createExactTrusted(singleType), object, profile));
4199                     if (!typeCheck.isTautology()) {
4200                         append(new FixedGuardNode(typeCheck, DeoptimizationReason.TypeCheckedInliningViolated, DeoptimizationAction.InvalidateReprofile));
4201                     }
4202                     instanceOfNode = LogicConstantNode.forBoolean(checkedType.getType().isAssignableFrom(singleType));
4203                 }
4204             }
4205         }
4206         if (instanceOfNode == null) {
4207             instanceOfNode = createInstanceOf(checkedType, object, null);
4208         }
4209         LogicNode logicNode = genUnique(instanceOfNode);
4210 
4211         int next = getStream().nextBCI();
4212         int value = getStream().readUByte(next);
4213         if (next &lt;= currentBlock.endBci &amp;&amp; (value == Bytecodes.IFEQ || value == Bytecodes.IFNE)) {
4214             getStream().next();
<span class="line-modified">4215             BciBlock firstSucc = currentBlock.getSuccessor(0);</span>
<span class="line-modified">4216             BciBlock secondSucc = currentBlock.getSuccessor(1);</span>
<span class="line-modified">4217             if (firstSucc != secondSucc) {</span>
<span class="line-modified">4218                 boolean negate = value != Bytecodes.IFNE;</span>
<span class="line-modified">4219                 if (negate) {</span>
<span class="line-modified">4220                     BciBlock tmp = firstSucc;</span>
<span class="line-modified">4221                     firstSucc = secondSucc;</span>
<span class="line-modified">4222                     secondSucc = tmp;</span>





4223                 }
<span class="line-removed">4224                 genIf(instanceOfNode, firstSucc, secondSucc, getProfileProbability(negate));</span>
<span class="line-removed">4225             } else {</span>
<span class="line-removed">4226                 appendGoto(firstSucc);</span>
4227             }
4228         } else {
4229             // Most frequent for value is IRETURN, followed by ISTORE.
4230             frameState.push(JavaKind.Int, append(genConditional(logicNode)));
4231         }
4232     }
4233 
4234     protected void genNewInstance(int cpi) {
4235         JavaType type = lookupType(cpi, NEW);
4236         genNewInstance(type);
4237     }
4238 
4239     protected void genNewInstance(JavaType type) {
4240         if (typeIsResolved(type)) {
4241             genNewInstance((ResolvedJavaType) type);
4242         } else {
4243             handleUnresolvedNewInstance(type);
4244         }
4245     }
4246 
</pre>
<hr />
<pre>
4291             case 5:
4292                 return char.class;
4293             case 6:
4294                 return float.class;
4295             case 7:
4296                 return double.class;
4297             case 8:
4298                 return byte.class;
4299             case 9:
4300                 return short.class;
4301             case 10:
4302                 return int.class;
4303             case 11:
4304                 return long.class;
4305             default:
4306                 throw new IllegalArgumentException(&quot;unknown array type code: &quot; + code);
4307         }
4308     }
4309 
4310     private void genNewPrimitiveArray(int typeCode) {
<span class="line-modified">4311         ResolvedJavaType elementType = metaAccess.lookupJavaType(arrayTypeCodeToClass(typeCode));</span>
4312         ValueNode length = frameState.pop(JavaKind.Int);
4313 
4314         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4315             if (plugin.handleNewArray(this, elementType, length)) {
4316                 return;
4317             }
4318         }
4319 
4320         frameState.push(JavaKind.Object, append(createNewArray(elementType, length, true)));
4321     }
4322 
4323     private void genNewObjectArray(int cpi) {
4324         JavaType type = lookupType(cpi, ANEWARRAY);
4325         genNewObjectArray(type);
4326     }
4327 
4328     private void genNewObjectArray(JavaType type) {
4329         if (typeIsResolved(type)) {
4330             genNewObjectArray((ResolvedJavaType) type);
4331         } else {
</pre>
<hr />
<pre>
4475      *
4476      * @param y The dividend.
4477      */
4478     protected boolean needsExplicitDivisionByZeroException(ValueNode y) {
4479         return needsExplicitException();
4480     }
4481 
4482     @Override
4483     public boolean needsExplicitException() {
4484         BytecodeExceptionMode exceptionMode = graphBuilderConfig.getBytecodeExceptionMode();
4485         if (exceptionMode == BytecodeExceptionMode.CheckAll || StressExplicitExceptionCode.getValue(options)) {
4486             return true;
4487         } else if (exceptionMode == BytecodeExceptionMode.Profile &amp;&amp; profilingInfo != null) {
4488             return profilingInfo.getExceptionSeen(bci()) == TriState.TRUE;
4489         }
4490         return false;
4491     }
4492 
4493     @Override
4494     public AbstractBeginNode genExplicitExceptionEdge(BytecodeExceptionKind exceptionKind) {
<span class="line-modified">4495         BytecodeExceptionNode exceptionNode = graph.add(new BytecodeExceptionNode(metaAccess, exceptionKind));</span>
<span class="line-modified">4496         exceptionNode.setStateAfter(createFrameState(bci(), exceptionNode));</span>
4497         AbstractBeginNode exceptionDispatch = handleException(exceptionNode, bci(), false);
4498         exceptionNode.setNext(exceptionDispatch);
4499         return BeginNode.begin(exceptionNode);
4500     }
4501 
4502     protected void genPutField(int cpi, int opcode) {
4503         JavaField field = lookupField(cpi, opcode);
4504         genPutField(field);
4505     }
4506 
4507     protected void genPutField(JavaField field) {
4508         genPutField(field, frameState.pop(field.getJavaKind()));
4509     }
4510 
4511     private void genPutField(JavaField field, ValueNode value) {
4512         ValueNode receiverInput = frameState.pop(JavaKind.Object);
4513 
4514         if (field instanceof ResolvedJavaField) {
4515             ValueNode receiver = maybeEmitExplicitNullCheck(receiverInput);
4516             ResolvedJavaField resolvedField = (ResolvedJavaField) field;
</pre>
<hr />
<pre>
4538         JavaField field = lookupField(cpi, opcode);
4539         genGetStatic(field);
4540     }
4541 
4542     private void genGetStatic(JavaField field) {
4543         ResolvedJavaField resolvedField = resolveStaticFieldAccess(field, null);
4544         if (resolvedField == null) {
4545             return;
4546         }
4547 
4548         if (!parsingIntrinsic() &amp;&amp; GeneratePIC.getValue(getOptions())) {
4549             graph.recordField(resolvedField);
4550         }
4551 
4552         /*
4553          * Javac does not allow use of &quot;$assertionsDisabled&quot; for a field name but Eclipse does, in
4554          * which case a suffix is added to the generated field.
4555          */
4556         if (resolvedField.isSynthetic() &amp;&amp; resolvedField.getName().startsWith(&quot;$assertionsDisabled&quot;)) {
4557             if (parsingIntrinsic()) {
<span class="line-modified">4558                 throw new GraalError(&quot;Cannot use an assertion within the context of an intrinsic.&quot;);</span>
4559             } else if (graphBuilderConfig.omitAssertions()) {
4560                 frameState.push(field.getJavaKind(), ConstantNode.forBoolean(true, graph));
4561                 return;
4562             }
4563         }
4564 
4565         ResolvedJavaType holder = resolvedField.getDeclaringClass();
4566         ClassInitializationPlugin classInitializationPlugin = this.graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4567         if (classInitializationPlugin != null) {
4568             classInitializationPlugin.apply(this, holder, this::createCurrentFrameState);
4569         }
4570 
4571         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4572             if (plugin.handleLoadStaticField(this, resolvedField)) {
4573                 return;
4574             }
4575         }
4576 
4577         ValueNode fieldRead = append(genLoadField(null, resolvedField));
4578         JavaKind fieldKind = resolvedField.getJavaKind();
</pre>
<hr />
<pre>
4682 
4683     private static boolean allPositive(double[] a) {
4684         for (double d : a) {
4685             if (d &lt; 0) {
4686                 return false;
4687             }
4688         }
4689         return true;
4690     }
4691 
4692     static class SuccessorInfo {
4693         final int blockIndex;
4694         int actualIndex;
4695 
4696         SuccessorInfo(int blockSuccessorIndex) {
4697             this.blockIndex = blockSuccessorIndex;
4698             actualIndex = -1;
4699         }
4700     }
4701 



4702     private void genSwitch(BytecodeSwitch bs) {
4703         int bci = bci();
4704         ValueNode value = frameState.pop(JavaKind.Int);
4705 
4706         int nofCases = bs.numberOfCases();
4707         int nofCasesPlusDefault = nofCases + 1;
4708         double[] keyProbabilities = switchProbability(nofCasesPlusDefault, bci);
4709 
4710         EconomicMap&lt;Integer, SuccessorInfo&gt; bciToBlockSuccessorIndex = EconomicMap.create(Equivalence.DEFAULT);
4711         for (int i = 0; i &lt; currentBlock.getSuccessorCount(); i++) {
4712             assert !bciToBlockSuccessorIndex.containsKey(currentBlock.getSuccessor(i).startBci);
4713             bciToBlockSuccessorIndex.put(currentBlock.getSuccessor(i).startBci, new SuccessorInfo(i));
4714         }
4715 
4716         ArrayList&lt;BciBlock&gt; actualSuccessors = new ArrayList&lt;&gt;();
4717         int[] keys = new int[nofCases];
4718         int[] keySuccessors = new int[nofCasesPlusDefault];
<span class="line-modified">4719         int deoptSuccessorIndex = -1;</span>
4720         int nextSuccessorIndex = 0;
4721         boolean constantValue = value.isConstant();
4722         for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
4723             if (i &lt; nofCases) {
4724                 keys[i] = bs.keyAt(i);
4725             }
<span class="line-removed">4726 </span>
4727             if (!constantValue &amp;&amp; isNeverExecutedCode(keyProbabilities[i])) {
<span class="line-modified">4728                 if (deoptSuccessorIndex &lt; 0) {</span>
<span class="line-modified">4729                     deoptSuccessorIndex = nextSuccessorIndex++;</span>
<span class="line-removed">4730                     actualSuccessors.add(null);</span>
<span class="line-removed">4731                 }</span>
<span class="line-removed">4732                 keySuccessors[i] = deoptSuccessorIndex;</span>
4733             } else {
4734                 int targetBci = i &lt; nofCases ? bs.targetAt(i) : bs.defaultTarget();
4735                 SuccessorInfo info = bciToBlockSuccessorIndex.get(targetBci);
4736                 if (info.actualIndex &lt; 0) {
4737                     info.actualIndex = nextSuccessorIndex++;
4738                     actualSuccessors.add(currentBlock.getSuccessor(info.blockIndex));
4739                 }
4740                 keySuccessors[i] = info.actualIndex;
4741             }
4742         }
4743         /*
4744          * When the profile indicates a case is never taken, the above code will cause the case to
4745          * deopt should it be subsequently encountered. However, the case may share code with
4746          * another case that is taken according to the profile.
4747          *
4748          * For example:
4749          * // @formatter:off
4750          * switch (opcode) {
4751          *     case GOTO:
4752          *     case GOTO_W: {
4753          *         // emit goto code
4754          *         break;
4755          *     }
4756          * }
4757          * // @formatter:on
4758          *
4759          * The profile may indicate the GOTO_W case is never taken, and thus a deoptimization stub
4760          * will be emitted. There might be optimization opportunity if additional branching based
4761          * on opcode is within the case block. Specially, if there is only single case that
4762          * reaches a target, we have better chance cutting out unused branches. Otherwise,
4763          * it might be beneficial routing to the same code instead of deopting.
4764          *
4765          * The following code rewires deoptimization stub to existing resolved branch target if
4766          * the target is connected by more than 1 cases.



4767          */
<span class="line-modified">4768         if (deoptSuccessorIndex &gt;= 0) {</span>
<span class="line-modified">4769             int[] connectedCases = new int[nextSuccessorIndex];</span>
4770             for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
<span class="line-modified">4771                 connectedCases[keySuccessors[i]]++;</span>
4772             }
4773 
4774             for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
<span class="line-modified">4775                 if (keySuccessors[i] == deoptSuccessorIndex) {</span>
4776                     int targetBci = i &lt; nofCases ? bs.targetAt(i) : bs.defaultTarget();
4777                     SuccessorInfo info = bciToBlockSuccessorIndex.get(targetBci);
4778                     int rewiredIndex = info.actualIndex;
<span class="line-modified">4779                     if (rewiredIndex &gt;= 0 &amp;&amp; connectedCases[rewiredIndex] &gt; 1) {</span>

4780                         keySuccessors[i] = info.actualIndex;







4781                     }
4782                 }
4783             }
4784         }
4785 
4786         genIntegerSwitch(value, actualSuccessors, keys, keyProbabilities, keySuccessors);
4787 
4788     }
4789 
4790     protected boolean isNeverExecutedCode(double probability) {
4791         return probability == 0 &amp;&amp; optimisticOpts.removeNeverExecutedCode(getOptions());
4792     }
4793 
4794     private double clampProbability(double probability) {
4795         if (!optimisticOpts.removeNeverExecutedCode(getOptions())) {
4796             if (probability == 0) {
4797                 return LUDICROUSLY_SLOW_PATH_PROBABILITY;
4798             } else if (probability == 1) {
4799                 return LUDICROUSLY_FAST_PATH_PROBABILITY;
4800             }
</pre>
<hr />
<pre>
4964             case LUSHR          : genShiftOp(JavaKind.Long, opcode); break;
4965             case LAND           : // fall through
4966             case LOR            : // fall through
4967             case LXOR           : genLogicOp(JavaKind.Long, opcode); break;
4968             case IINC           : genIncrement(); break;
4969             case I2F            : genFloatConvert(FloatConvert.I2F, JavaKind.Int, JavaKind.Float); break;
4970             case I2D            : genFloatConvert(FloatConvert.I2D, JavaKind.Int, JavaKind.Double); break;
4971             case L2F            : genFloatConvert(FloatConvert.L2F, JavaKind.Long, JavaKind.Float); break;
4972             case L2D            : genFloatConvert(FloatConvert.L2D, JavaKind.Long, JavaKind.Double); break;
4973             case F2I            : genFloatConvert(FloatConvert.F2I, JavaKind.Float, JavaKind.Int); break;
4974             case F2L            : genFloatConvert(FloatConvert.F2L, JavaKind.Float, JavaKind.Long); break;
4975             case F2D            : genFloatConvert(FloatConvert.F2D, JavaKind.Float, JavaKind.Double); break;
4976             case D2I            : genFloatConvert(FloatConvert.D2I, JavaKind.Double, JavaKind.Int); break;
4977             case D2L            : genFloatConvert(FloatConvert.D2L, JavaKind.Double, JavaKind.Long); break;
4978             case D2F            : genFloatConvert(FloatConvert.D2F, JavaKind.Double, JavaKind.Float); break;
4979             case L2I            : genNarrow(JavaKind.Long, JavaKind.Int); break;
4980             case I2L            : genSignExtend(JavaKind.Int, JavaKind.Long); break;
4981             case I2B            : genSignExtend(JavaKind.Byte, JavaKind.Int); break;
4982             case I2S            : genSignExtend(JavaKind.Short, JavaKind.Int); break;
4983             case I2C            : genZeroExtend(JavaKind.Char, JavaKind.Int); break;
<span class="line-modified">4984             case LCMP           : genCompareOp(JavaKind.Long, false); break;</span>
<span class="line-modified">4985             case FCMPL          : genCompareOp(JavaKind.Float, true); break;</span>
<span class="line-modified">4986             case FCMPG          : genCompareOp(JavaKind.Float, false); break;</span>
<span class="line-modified">4987             case DCMPL          : genCompareOp(JavaKind.Double, true); break;</span>
<span class="line-modified">4988             case DCMPG          : genCompareOp(JavaKind.Double, false); break;</span>
4989             case IFEQ           : genIfZero(Condition.EQ); break;
4990             case IFNE           : genIfZero(Condition.NE); break;
4991             case IFLT           : genIfZero(Condition.LT); break;
4992             case IFGE           : genIfZero(Condition.GE); break;
4993             case IFGT           : genIfZero(Condition.GT); break;
4994             case IFLE           : genIfZero(Condition.LE); break;
4995             case IF_ICMPEQ      : genIfSame(JavaKind.Int, Condition.EQ); break;
4996             case IF_ICMPNE      : genIfSame(JavaKind.Int, Condition.NE); break;
4997             case IF_ICMPLT      : genIfSame(JavaKind.Int, Condition.LT); break;
4998             case IF_ICMPGE      : genIfSame(JavaKind.Int, Condition.GE); break;
4999             case IF_ICMPGT      : genIfSame(JavaKind.Int, Condition.GT); break;
5000             case IF_ICMPLE      : genIfSame(JavaKind.Int, Condition.LE); break;
5001             case IF_ACMPEQ      : genIfSame(JavaKind.Object, Condition.EQ); break;
5002             case IF_ACMPNE      : genIfSame(JavaKind.Object, Condition.NE); break;
5003             case GOTO           : genGoto(); break;
5004             case JSR            : genJsr(stream.readBranchDest()); break;
5005             case RET            : genRet(stream.readLocalIndex()); break;
5006             case TABLESWITCH    : genSwitch(new BytecodeTableSwitch(getStream(), bci())); break;
5007             case LOOKUPSWITCH   : genSwitch(new BytecodeLookupSwitch(getStream(), bci())); break;
5008             case IRETURN        : genReturn(frameState.pop(JavaKind.Int), JavaKind.Int); break;
</pre>
</td>
<td>
<hr />
<pre>
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.java;
  26 
  27 import static java.lang.String.format;
  28 import static java.lang.reflect.Modifier.STATIC;
  29 import static java.lang.reflect.Modifier.SYNCHRONIZED;
<span class="line-added">  30 import static jdk.vm.ci.code.BytecodeFrame.UNKNOWN_BCI;</span>
  31 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateRecompile;
  32 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateReprofile;
  33 import static jdk.vm.ci.meta.DeoptimizationAction.None;
  34 import static jdk.vm.ci.meta.DeoptimizationReason.ClassCastException;

  35 import static jdk.vm.ci.meta.DeoptimizationReason.NullCheckException;
  36 import static jdk.vm.ci.meta.DeoptimizationReason.RuntimeConstraint;

  37 import static jdk.vm.ci.meta.DeoptimizationReason.UnreachedCode;
  38 import static jdk.vm.ci.meta.DeoptimizationReason.Unresolved;
  39 import static jdk.vm.ci.runtime.JVMCICompiler.INVOCATION_ENTRY_BCI;
  40 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  41 import static org.graalvm.compiler.bytecode.Bytecodes.AALOAD;
  42 import static org.graalvm.compiler.bytecode.Bytecodes.AASTORE;
  43 import static org.graalvm.compiler.bytecode.Bytecodes.ACONST_NULL;
  44 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD;
  45 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_0;
  46 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_1;
  47 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_2;
  48 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_3;
  49 import static org.graalvm.compiler.bytecode.Bytecodes.ANEWARRAY;
  50 import static org.graalvm.compiler.bytecode.Bytecodes.ARETURN;
  51 import static org.graalvm.compiler.bytecode.Bytecodes.ARRAYLENGTH;
  52 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE;
  53 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_0;
  54 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_1;
  55 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_2;
  56 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_3;
</pre>
<hr />
<pre>
 237 import static org.graalvm.compiler.bytecode.Bytecodes.RETURN;
 238 import static org.graalvm.compiler.bytecode.Bytecodes.SALOAD;
 239 import static org.graalvm.compiler.bytecode.Bytecodes.SASTORE;
 240 import static org.graalvm.compiler.bytecode.Bytecodes.SIPUSH;
 241 import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;
 242 import static org.graalvm.compiler.bytecode.Bytecodes.TABLESWITCH;
 243 import static org.graalvm.compiler.bytecode.Bytecodes.nameOf;
 244 import static org.graalvm.compiler.core.common.GraalOptions.DeoptALot;
 245 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 246 import static org.graalvm.compiler.core.common.GraalOptions.HotSpotPrintInlining;
 247 import static org.graalvm.compiler.core.common.GraalOptions.PrintProfilingInformation;
 248 import static org.graalvm.compiler.core.common.GraalOptions.StressExplicitExceptionCode;
 249 import static org.graalvm.compiler.core.common.GraalOptions.StressInvokeWithExceptionNode;
 250 import static org.graalvm.compiler.core.common.type.StampFactory.objectNonNull;
 251 import static org.graalvm.compiler.debug.GraalError.guarantee;
 252 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
 253 import static org.graalvm.compiler.java.BytecodeParserOptions.InlinePartialIntrinsicExitDuringParsing;
 254 import static org.graalvm.compiler.java.BytecodeParserOptions.TraceBytecodeParserLevel;
 255 import static org.graalvm.compiler.java.BytecodeParserOptions.TraceInlineDuringParsing;
 256 import static org.graalvm.compiler.java.BytecodeParserOptions.TraceParserPlugins;


 257 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LUDICROUSLY_FAST_PATH_PROBABILITY;
 258 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LUDICROUSLY_SLOW_PATH_PROBABILITY;
 259 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_DURING_PARSING;
 260 import static org.graalvm.compiler.nodes.type.StampTool.isPointerNonNull;
 261 
 262 import java.util.ArrayList;
 263 import java.util.Collections;
 264 import java.util.Comparator;
 265 import java.util.Formatter;
 266 import java.util.List;
 267 import java.util.function.Supplier;
 268 
 269 import jdk.internal.vm.compiler.collections.EconomicMap;
 270 import jdk.internal.vm.compiler.collections.Equivalence;
<span class="line-added"> 271 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;</span>
 272 import org.graalvm.compiler.api.replacements.Fold;
<span class="line-added"> 273 import org.graalvm.compiler.api.replacements.MethodSubstitution;</span>
 274 import org.graalvm.compiler.api.replacements.Snippet;
 275 import org.graalvm.compiler.bytecode.Bytecode;
 276 import org.graalvm.compiler.bytecode.BytecodeDisassembler;
 277 import org.graalvm.compiler.bytecode.BytecodeLookupSwitch;
 278 import org.graalvm.compiler.bytecode.BytecodeProvider;
 279 import org.graalvm.compiler.bytecode.BytecodeStream;
 280 import org.graalvm.compiler.bytecode.BytecodeSwitch;
 281 import org.graalvm.compiler.bytecode.BytecodeTableSwitch;
 282 import org.graalvm.compiler.bytecode.Bytecodes;
 283 import org.graalvm.compiler.bytecode.Bytes;
 284 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
 285 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecodeProvider;
 286 import org.graalvm.compiler.core.common.GraalOptions;
 287 import org.graalvm.compiler.core.common.PermanentBailoutException;
<span class="line-added"> 288 import org.graalvm.compiler.core.common.RetryableBailoutException;</span>
 289 import org.graalvm.compiler.core.common.calc.CanonicalCondition;
 290 import org.graalvm.compiler.core.common.calc.Condition;
 291 import org.graalvm.compiler.core.common.calc.Condition.CanonicalizedCondition;
 292 import org.graalvm.compiler.core.common.calc.FloatConvert;
 293 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 294 import org.graalvm.compiler.core.common.type.IntegerStamp;
 295 import org.graalvm.compiler.core.common.type.ObjectStamp;
 296 import org.graalvm.compiler.core.common.type.Stamp;
 297 import org.graalvm.compiler.core.common.type.StampFactory;
 298 import org.graalvm.compiler.core.common.type.StampPair;
 299 import org.graalvm.compiler.core.common.type.TypeReference;
 300 import org.graalvm.compiler.core.common.util.Util;
 301 import org.graalvm.compiler.debug.Assertions;
 302 import org.graalvm.compiler.debug.CounterKey;
 303 import org.graalvm.compiler.debug.DebugCloseable;
 304 import org.graalvm.compiler.debug.DebugContext;
 305 import org.graalvm.compiler.debug.DebugOptions;
 306 import org.graalvm.compiler.debug.GraalError;
 307 import org.graalvm.compiler.debug.Indent;
 308 import org.graalvm.compiler.debug.MethodFilter;
</pre>
<hr />
<pre>
 336 import org.graalvm.compiler.nodes.Invoke;
 337 import org.graalvm.compiler.nodes.InvokeNode;
 338 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 339 import org.graalvm.compiler.nodes.KillingBeginNode;
 340 import org.graalvm.compiler.nodes.LogicConstantNode;
 341 import org.graalvm.compiler.nodes.LogicNegationNode;
 342 import org.graalvm.compiler.nodes.LogicNode;
 343 import org.graalvm.compiler.nodes.LoopBeginNode;
 344 import org.graalvm.compiler.nodes.LoopEndNode;
 345 import org.graalvm.compiler.nodes.LoopExitNode;
 346 import org.graalvm.compiler.nodes.MergeNode;
 347 import org.graalvm.compiler.nodes.NodeView;
 348 import org.graalvm.compiler.nodes.ParameterNode;
 349 import org.graalvm.compiler.nodes.PiNode;
 350 import org.graalvm.compiler.nodes.ReturnNode;
 351 import org.graalvm.compiler.nodes.StartNode;
 352 import org.graalvm.compiler.nodes.StateSplit;
 353 import org.graalvm.compiler.nodes.StructuredGraph;
 354 import org.graalvm.compiler.nodes.UnwindNode;
 355 import org.graalvm.compiler.nodes.ValueNode;
<span class="line-added"> 356 import org.graalvm.compiler.nodes.ValuePhiNode;</span>
 357 import org.graalvm.compiler.nodes.calc.AddNode;
 358 import org.graalvm.compiler.nodes.calc.AndNode;
 359 import org.graalvm.compiler.nodes.calc.CompareNode;
 360 import org.graalvm.compiler.nodes.calc.ConditionalNode;
 361 import org.graalvm.compiler.nodes.calc.FloatConvertNode;
 362 import org.graalvm.compiler.nodes.calc.FloatDivNode;
<span class="line-added"> 363 import org.graalvm.compiler.nodes.calc.FloatNormalizeCompareNode;</span>
 364 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
 365 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
 366 import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;
<span class="line-added"> 367 import org.graalvm.compiler.nodes.calc.IntegerNormalizeCompareNode;</span>
 368 import org.graalvm.compiler.nodes.calc.IsNullNode;
 369 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 370 import org.graalvm.compiler.nodes.calc.MulNode;
 371 import org.graalvm.compiler.nodes.calc.NarrowNode;
 372 import org.graalvm.compiler.nodes.calc.NegateNode;

 373 import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
 374 import org.graalvm.compiler.nodes.calc.OrNode;
 375 import org.graalvm.compiler.nodes.calc.RemNode;
 376 import org.graalvm.compiler.nodes.calc.RightShiftNode;
 377 import org.graalvm.compiler.nodes.calc.SignExtendNode;
 378 import org.graalvm.compiler.nodes.calc.SignedDivNode;
 379 import org.graalvm.compiler.nodes.calc.SignedRemNode;
 380 import org.graalvm.compiler.nodes.calc.SubNode;
 381 import org.graalvm.compiler.nodes.calc.UnsignedRightShiftNode;
 382 import org.graalvm.compiler.nodes.calc.XorNode;
 383 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
 384 import org.graalvm.compiler.nodes.extended.AnchoringNode;
 385 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;
 386 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode;
 387 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
<span class="line-added"> 388 import org.graalvm.compiler.nodes.extended.ForeignCallNode;</span>
 389 import org.graalvm.compiler.nodes.extended.GuardingNode;
 390 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
 391 import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
 392 import org.graalvm.compiler.nodes.extended.LoadHubNode;

 393 import org.graalvm.compiler.nodes.extended.MembarNode;
 394 import org.graalvm.compiler.nodes.extended.StateSplitProxyNode;

 395 import org.graalvm.compiler.nodes.graphbuilderconf.ClassInitializationPlugin;
 396 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 397 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.BytecodeExceptionMode;
 398 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 399 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 400 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo;
 401 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 402 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 403 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.InvocationPluginReceiver;
 404 import org.graalvm.compiler.nodes.graphbuilderconf.InvokeDynamicPlugin;
 405 import org.graalvm.compiler.nodes.graphbuilderconf.NodePlugin;
 406 import org.graalvm.compiler.nodes.graphbuilderconf.ProfilingPlugin;
 407 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 408 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
 409 import org.graalvm.compiler.nodes.java.FinalFieldBarrierNode;
 410 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 411 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 412 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 413 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 414 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 415 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 416 import org.graalvm.compiler.nodes.java.MonitorExitNode;
 417 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 418 import org.graalvm.compiler.nodes.java.NewArrayNode;
 419 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 420 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
 421 import org.graalvm.compiler.nodes.java.RegisterFinalizerNode;
 422 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 423 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
<span class="line-added"> 424 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
<span class="line-added"> 425 import org.graalvm.compiler.nodes.spi.Replacements;</span>
 426 import org.graalvm.compiler.nodes.spi.StampProvider;
 427 import org.graalvm.compiler.nodes.type.StampTool;
 428 import org.graalvm.compiler.nodes.util.GraphUtil;
 429 import org.graalvm.compiler.options.OptionValues;
 430 import org.graalvm.compiler.phases.OptimisticOptimizations;
 431 import org.graalvm.compiler.phases.util.ValueMergeUtil;
 432 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 433 import jdk.internal.vm.compiler.word.LocationIdentity;
 434 
 435 import jdk.vm.ci.code.BailoutException;
 436 import jdk.vm.ci.code.BytecodeFrame;
 437 import jdk.vm.ci.code.CodeUtil;
 438 import jdk.vm.ci.code.site.InfopointReason;
 439 import jdk.vm.ci.meta.Constant;
 440 import jdk.vm.ci.meta.ConstantPool;
 441 import jdk.vm.ci.meta.ConstantReflectionProvider;
 442 import jdk.vm.ci.meta.DeoptimizationAction;
 443 import jdk.vm.ci.meta.DeoptimizationReason;
 444 import jdk.vm.ci.meta.JavaConstant;
 445 import jdk.vm.ci.meta.JavaField;
 446 import jdk.vm.ci.meta.JavaKind;
 447 import jdk.vm.ci.meta.JavaMethod;
 448 import jdk.vm.ci.meta.JavaType;
 449 import jdk.vm.ci.meta.JavaTypeProfile;

 450 import jdk.vm.ci.meta.LineNumberTable;
 451 import jdk.vm.ci.meta.MetaAccessProvider;
 452 import jdk.vm.ci.meta.ProfilingInfo;
 453 import jdk.vm.ci.meta.RawConstant;
 454 import jdk.vm.ci.meta.ResolvedJavaField;
 455 import jdk.vm.ci.meta.ResolvedJavaMethod;
 456 import jdk.vm.ci.meta.ResolvedJavaType;
 457 import jdk.vm.ci.meta.Signature;
 458 import jdk.vm.ci.meta.TriState;
 459 
 460 /**
 461  * The {@code GraphBuilder} class parses the bytecode of a method and builds the IR graph.
 462  */
 463 public class BytecodeParser implements GraphBuilderContext {
 464 
 465     /**
 466      * The minimum value to which {@link BytecodeParserOptions#TraceBytecodeParserLevel} must be set
 467      * to trace the bytecode instructions as they are parsed.
 468      */
 469     public static final int TRACELEVEL_INSTRUCTIONS = 1;
</pre>
<hr />
<pre>
 471     /**
 472      * The minimum value to which {@link BytecodeParserOptions#TraceBytecodeParserLevel} must be set
 473      * to emit the frame state for each traced bytecode instruction.
 474      */
 475     public static final int TRACELEVEL_STATE = 2;
 476 
 477     /**
 478      * The minimum value to which {@link BytecodeParserOptions#TraceBytecodeParserLevel} must be set
 479      * to emit the block map for each traced method.
 480      */
 481     public static final int TRACELEVEL_BLOCKMAP = 3;
 482 
 483     /**
 484      * Meters the number of actual bytecodes parsed.
 485      */
 486     public static final CounterKey BytecodesParsed = DebugContext.counter(&quot;BytecodesParsed&quot;);
 487 
 488     protected static final CounterKey EXPLICIT_EXCEPTIONS = DebugContext.counter(&quot;ExplicitExceptions&quot;);
 489 
 490     /**
<span class="line-modified"> 491      * A scoped object for tasks to be performed after inlining during parsing such as processing</span>
 492      * {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frames states.
 493      */
<span class="line-modified"> 494     static class InliningScope implements AutoCloseable {</span>
<span class="line-added"> 495         final ResolvedJavaMethod callee;</span>
 496         FrameState stateBefore;
 497         final Mark mark;
 498         final BytecodeParser parser;
 499         List&lt;ReturnToCallerData&gt; returnDataList;
 500 
 501         /**
 502          * Creates a scope for root parsing an intrinsic.
 503          *
 504          * @param parser the parsing context of the intrinsic
 505          */
<span class="line-modified"> 506         InliningScope(BytecodeParser parser) {</span>
 507             this.parser = parser;
 508             assert parser.parent == null;
 509             assert parser.bci() == 0;
 510             mark = null;
<span class="line-added"> 511             callee = null;</span>
 512         }
 513 
 514         /**
<span class="line-modified"> 515          * Creates a scope for graph builder inlining.</span>
 516          *
 517          * @param parser the parsing context of the (non-intrinsic) method calling the intrinsic
 518          * @param args the arguments to the call
 519          */
<span class="line-modified"> 520         InliningScope(BytecodeParser parser, ResolvedJavaMethod callee, ValueNode[] args) {</span>
<span class="line-added"> 521             this.callee = callee;</span>
 522             assert !parser.parsingIntrinsic();
 523             this.parser = parser;
 524             mark = parser.getGraph().getMark();
<span class="line-added"> 525             JavaKind[] argSlotKinds = callee.getSignature().toParameterKinds(!callee.isStatic());</span>
 526             stateBefore = parser.frameState.create(parser.bci(), parser.getNonIntrinsicAncestor(), false, argSlotKinds, args);
 527         }
 528 
 529         @Override
 530         public void close() {
<span class="line-modified"> 531             processPlaceholderFrameStates(false);</span>





 532         }
 533 
 534         /**
 535          * Fixes up the {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frame states
 536          * added to the graph while parsing/inlining the intrinsic for which this object exists.
 537          */
<span class="line-modified"> 538         protected void processPlaceholderFrameStates(boolean isCompilationRoot) {</span>
 539             StructuredGraph graph = parser.getGraph();
 540             graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;Before processPlaceholderFrameStates in %s&quot;, parser.method);

 541             for (Node node : graph.getNewNodes(mark)) {
 542                 if (node instanceof FrameState) {
 543                     FrameState frameState = (FrameState) node;
 544                     if (BytecodeFrame.isPlaceholderBci(frameState.bci)) {
 545                         if (frameState.bci == BytecodeFrame.AFTER_BCI) {
 546                             if (parser.getInvokeReturnType() == null) {
 547                                 // A frame state in a root compiled intrinsic.
<span class="line-modified"> 548                                 assert isCompilationRoot;</span>
 549                                 FrameState newFrameState = graph.add(new FrameState(BytecodeFrame.INVALID_FRAMESTATE_BCI));
 550                                 frameState.replaceAndDelete(newFrameState);
 551                             } else {
 552                                 JavaKind returnKind = parser.getInvokeReturnType().getJavaKind();
 553                                 FrameStateBuilder frameStateBuilder = parser.frameState;
 554                                 assert !frameState.rethrowException();
 555                                 if (frameState.stackSize() != 0) {
 556                                     ValueNode returnVal = frameState.stackAt(0);
 557                                     if (!ReturnToCallerData.containsReturnValue(returnDataList, returnVal)) {
<span class="line-modified"> 558                                         throw new GraalError(&quot;AFTER_BCI frame state within a sub-parse has a non-return value on the stack: %s&quot;, returnVal);</span>
 559                                     }
 560 
 561                                     // Swap the top-of-stack value with the return value
 562                                     ValueNode tos = frameStateBuilder.pop(returnKind);
 563                                     assert tos.getStackKind() == returnVal.getStackKind();
 564                                     FrameState newFrameState = frameStateBuilder.create(parser.stream.nextBCI(), parser.getNonIntrinsicAncestor(), false, new JavaKind[]{returnKind},
 565                                                     new ValueNode[]{returnVal});
 566                                     frameState.replaceAndDelete(newFrameState);
 567                                     newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());
 568                                     frameStateBuilder.push(returnKind, tos);
 569                                 } else if (returnKind != JavaKind.Void) {
<span class="line-modified"> 570                                     handleReturnMismatch(graph, frameState);</span>








 571                                 } else {
 572                                     // An intrinsic for a void method.
 573                                     FrameState newFrameState = frameStateBuilder.create(parser.stream.nextBCI(), null);
 574                                     newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());
 575                                     frameState.replaceAndDelete(newFrameState);
 576                                 }
 577                             }
 578                         } else if (frameState.bci == BytecodeFrame.BEFORE_BCI) {
 579                             if (stateBefore == null) {
 580                                 stateBefore = graph.start().stateAfter();
 581                             }
 582                             if (stateBefore != frameState) {
 583                                 frameState.replaceAndDelete(stateBefore);
 584                             }
<span class="line-modified"> 585                         } else if (frameState.bci == BytecodeFrame.AFTER_EXCEPTION_BCI || (frameState.bci == BytecodeFrame.UNWIND_BCI &amp;&amp; !callee.isSynchronized())) {</span>
 586                             // This is a frame state for the entry point to an exception
 587                             // dispatcher in an intrinsic. For example, the invoke denoting
 588                             // a partial intrinsic exit will have an edge to such a
 589                             // dispatcher if the profile for the original invoke being
 590                             // intrinsified indicates an exception was seen. As per JVM
 591                             // bytecode semantics, the interpreter expects a single
 592                             // value on the stack on entry to an exception handler,
 593                             // namely the exception object.
 594                             assert frameState.rethrowException();
 595                             ValueNode exceptionValue = frameState.stackAt(0);

 596                             FrameStateBuilder dispatchState = parser.frameState.copy();
 597                             dispatchState.clearStack();
 598                             dispatchState.push(JavaKind.Object, exceptionValue);
 599                             dispatchState.setRethrowException(true);
<span class="line-modified"> 600                             for (Node usage : frameState.usages()) {</span>
<span class="line-modified"> 601                                 FrameState newFrameState = dispatchState.create(parser.bci(), (StateSplit) usage);</span>
<span class="line-modified"> 602                                 frameState.replaceAndDelete(newFrameState);</span>
<span class="line-added"> 603                                 newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());</span>
<span class="line-added"> 604                             }</span>
<span class="line-added"> 605                         } else if (frameState.bci == BytecodeFrame.UNWIND_BCI) {</span>
<span class="line-added"> 606                             if (graph.getGuardsStage().allowsFloatingGuards()) {</span>
<span class="line-added"> 607                                 throw GraalError.shouldNotReachHere(&quot;Cannot handle this UNWIND_BCI&quot;);</span>
<span class="line-added"> 608                             }</span>
<span class="line-added"> 609                             // hope that by construction, there are no fixed guard after this unwind</span>
<span class="line-added"> 610                             // and before an other state split</span>
 611                         } else {
<span class="line-modified"> 612                             assert frameState.bci == BytecodeFrame.INVALID_FRAMESTATE_BCI : frameState.bci;</span>
 613                         }
 614                     }
 615                 }
 616             }
<span class="line-modified"> 617             graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;After processPlaceholderFrameStates in %s&quot;, parser.method);</span>
<span class="line-added"> 618         }</span>
<span class="line-added"> 619 </span>
<span class="line-added"> 620         @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added"> 621         protected void handleReturnMismatch(StructuredGraph g, FrameState fs) {</span>
<span class="line-added"> 622             throw GraalError.shouldNotReachHere(&quot;Unexpected return kind mismatch in &quot; + parser.method + &quot; at FS &quot; + fs);</span>
<span class="line-added"> 623         }</span>
<span class="line-added"> 624     }</span>
<span class="line-added"> 625 </span>
<span class="line-added"> 626     static class IntrinsicScope extends InliningScope {</span>
<span class="line-added"> 627         ArrayList&lt;StateSplit&gt; invalidStateUsers;</span>
<span class="line-added"> 628 </span>
<span class="line-added"> 629         IntrinsicScope(BytecodeParser parser) {</span>
<span class="line-added"> 630             super(parser);</span>
<span class="line-added"> 631         }</span>
<span class="line-added"> 632 </span>
<span class="line-added"> 633         IntrinsicScope(BytecodeParser parser, ResolvedJavaMethod callee, ValueNode[] args) {</span>
<span class="line-added"> 634             super(parser, callee, args);</span>
<span class="line-added"> 635         }</span>
<span class="line-added"> 636 </span>
<span class="line-added"> 637         @SuppressWarnings(&quot;unlikely-arg-type&quot;)</span>
<span class="line-added"> 638         @Override</span>
<span class="line-added"> 639         public void close() {</span>
<span class="line-added"> 640             IntrinsicContext intrinsic = parser.intrinsicContext;</span>
<span class="line-added"> 641             boolean isRootCompilation;</span>
<span class="line-added"> 642             if (intrinsic != null) {</span>
<span class="line-added"> 643                 if (intrinsic.isPostParseInlined()) {</span>
<span class="line-added"> 644                     return;</span>
<span class="line-added"> 645                 }</span>
<span class="line-added"> 646                 isRootCompilation = intrinsic.isCompilationRoot();</span>
<span class="line-added"> 647             } else {</span>
<span class="line-added"> 648                 isRootCompilation = false;</span>
<span class="line-added"> 649             }</span>
<span class="line-added"> 650             processPlaceholderFrameStates(isRootCompilation);</span>
<span class="line-added"> 651             if (invalidStateUsers != null) {</span>
 652                 JavaKind returnKind = parser.getInvokeReturnType().getJavaKind();
<span class="line-modified"> 653                 ValueNode returnValue = parser.frameState.pop(returnKind);</span>
<span class="line-modified"> 654                 if (invalidStateUsers.size() == 1 &amp;&amp; invalidStateUsers.get(0) == parser.lastInstr) {</span>
<span class="line-modified"> 655                     updateSplitFrameState(invalidStateUsers.get(0), returnKind, returnValue);</span>
<span class="line-modified"> 656                 } else if (parser.lastInstr instanceof MergeNode) {</span>
<span class="line-modified"> 657                     ValuePhiNode returnValues = null;</span>
<span class="line-modified"> 658                     MergeNode merge = (MergeNode) parser.lastInstr;</span>
<span class="line-modified"> 659 </span>
<span class="line-added"> 660                     if (returnValue instanceof ValuePhiNode &amp;&amp; ((ValuePhiNode) returnValue).merge() == parser.lastInstr) {</span>
<span class="line-added"> 661                         returnValues = (ValuePhiNode) returnValue;</span>
<span class="line-added"> 662                     }</span>
<span class="line-added"> 663                     if (invalidStateUsers.remove(merge)) {</span>
<span class="line-added"> 664                         updateSplitFrameState(merge, returnKind, returnValue);</span>
<span class="line-added"> 665                     }</span>
<span class="line-added"> 666                     for (EndNode pred : merge.cfgPredecessors()) {</span>
<span class="line-added"> 667                         Node lastPred = pred.predecessor();</span>
<span class="line-added"> 668                         if (invalidStateUsers.remove(lastPred)) {</span>
<span class="line-added"> 669                             ValueNode predReturnValue = returnValue;</span>
<span class="line-added"> 670                             if (returnValues != null) {</span>
<span class="line-added"> 671                                 int index = merge.phiPredecessorIndex(pred);</span>
<span class="line-added"> 672                                 predReturnValue = ((ValuePhiNode) returnValue).valueAt(index);</span>
<span class="line-added"> 673                             }</span>
<span class="line-added"> 674                             updateSplitFrameState((StateSplit) lastPred, returnKind, predReturnValue);</span>
<span class="line-added"> 675                         }</span>
<span class="line-added"> 676                     }</span>
<span class="line-added"> 677                     if (invalidStateUsers.size() != 0) {</span>
<span class="line-added"> 678                         throw new GraalError(&quot;unexpected StateSplit above merge %s&quot;, invalidStateUsers);</span>
<span class="line-added"> 679                     }</span>
<span class="line-added"> 680                 } else {</span>
<span class="line-added"> 681                     throw new GraalError(&quot;unexpected node between return StateSplit and last instruction %s&quot;, parser.lastInstr);</span>
<span class="line-added"> 682                 }</span>
<span class="line-added"> 683                 // Restore the original return value</span>
<span class="line-added"> 684                 parser.frameState.push(returnKind, returnValue);</span>
<span class="line-added"> 685             }</span>
<span class="line-added"> 686             boolean inlinedIntrinsic = parser.getInvokeReturnType() != null;</span>
<span class="line-added"> 687             if (inlinedIntrinsic) {</span>
<span class="line-added"> 688                 for (Node n : parser.graph.getNewNodes(mark)) {</span>
<span class="line-added"> 689                     if (n instanceof FrameState) {</span>
<span class="line-added"> 690                         GraalError.guarantee(((FrameState) n).bci != BytecodeFrame.INVALID_FRAMESTATE_BCI,</span>
<span class="line-added"> 691                                         &quot;Inlined call to intrinsic (callee %s) produced invalid framestate %s. &quot; +</span>
<span class="line-added"> 692                                                         &quot;Such framestates must never be used as deoptimizing targets, thus they cannot be part of a high-tier graph, &quot; +</span>
<span class="line-added"> 693                                                         &quot;and must only be used after framestate assignment. A common error is invalid usage of foreign call nodes in method &quot; +</span>
<span class="line-added"> 694                                                         &quot;substitutions, which can be avoided by ensuring such calls are either replaced with nodes that are snippet &quot; +</span>
<span class="line-added"> 695                                                         &quot;lowered after framestate assignment (see FastNotifyNode.java for example) or by ensuring all foreign use the state after of the &quot; +</span>
<span class="line-added"> 696                                                         &quot;original call instruction.&quot;,</span>
<span class="line-added"> 697                                         callee, n);</span>
<span class="line-added"> 698                     }</span>
<span class="line-added"> 699                 }</span>
<span class="line-added"> 700             } else {</span>
<span class="line-added"> 701 </span>
<span class="line-added"> 702                 /*</span>
<span class="line-added"> 703                  * Special case root compiled method substitutions</span>
<span class="line-added"> 704                  *</span>
<span class="line-added"> 705                  * Root compiled intrinsics with self recursive calls (partial intrinsic exit) must</span>
<span class="line-added"> 706                  * never produce more than one state except the start framestate since we do not</span>
<span class="line-added"> 707                  * compile calls to the original method (or inline them) but deopt</span>
<span class="line-added"> 708                  *</span>
<span class="line-added"> 709                  * See ByteCodeParser::inline and search for compilationRoot</span>
<span class="line-added"> 710                  */</span>
<span class="line-added"> 711                 assert intrinsic == null || intrinsic.isIntrinsicEncoding() || verifyIntrinsicRootCompileEffects();</span>
<span class="line-added"> 712             }</span>
<span class="line-added"> 713         }</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715         private boolean verifyIntrinsicRootCompileEffects() {</span>
<span class="line-added"> 716             int invalidBCIsInRootCompiledIntrinsic = 0;</span>
<span class="line-added"> 717             for (Node n : parser.graph.getNewNodes(mark)) {</span>
<span class="line-added"> 718                 if (n instanceof FrameState) {</span>
<span class="line-added"> 719                     if (((FrameState) n).bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {</span>
<span class="line-added"> 720                         invalidBCIsInRootCompiledIntrinsic++;</span>
<span class="line-added"> 721                     }</span>
<span class="line-added"> 722                 }</span>
<span class="line-added"> 723             }</span>
<span class="line-added"> 724             if (invalidBCIsInRootCompiledIntrinsic &gt; 1) {</span>
<span class="line-added"> 725                 int invalidBCIsToFind = invalidBCIsInRootCompiledIntrinsic;</span>
<span class="line-added"> 726                 List&lt;ReturnNode&gt; returns = parser.getGraph().getNodes(ReturnNode.TYPE).snapshot();</span>
<span class="line-added"> 727                 if (returns.size() &gt; 1) {</span>
<span class="line-added"> 728                     outer: for (ReturnNode ret : returns) {</span>
<span class="line-added"> 729                         for (FixedNode f : GraphUtil.predecessorIterable(ret)) {</span>
<span class="line-added"> 730                             if (f instanceof StateSplit) {</span>
<span class="line-added"> 731                                 StateSplit split = (StateSplit) f;</span>
<span class="line-added"> 732                                 if (split.hasSideEffect()) {</span>
<span class="line-added"> 733                                     assert ((StateSplit) f).stateAfter() != null;</span>
<span class="line-added"> 734                                     if (split.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {</span>
<span class="line-added"> 735                                         invalidBCIsToFind--;</span>
<span class="line-added"> 736                                         continue outer;</span>
<span class="line-added"> 737                                     }</span>
<span class="line-added"> 738                                 }</span>
<span class="line-added"> 739                             }</span>
<span class="line-added"> 740                         }</span>
<span class="line-added"> 741                     }</span>
<span class="line-added"> 742                     GraalError.guarantee(invalidBCIsToFind == 0, &quot;Root compiled intrinsic with invalid states has more than one return. &quot; +</span>
<span class="line-added"> 743                                     &quot;This is allowed, however one path down a sink has more than one state, this is prohibited. &quot; +</span>
<span class="line-added"> 744                                     &quot;Intrinsic %s&quot;, parser.method);</span>
<span class="line-added"> 745                     return true;</span>
<span class="line-added"> 746                 }</span>
<span class="line-added"> 747                 ReturnNode ret = returns.get(0);</span>
<span class="line-added"> 748                 MergeNode merge = null;</span>
<span class="line-added"> 749                 int mergeCount = parser.graph.getNodes(MergeNode.TYPE).count();</span>
<span class="line-added"> 750                 if (mergeCount != 1) {</span>
<span class="line-added"> 751                     throw new GraalError(&quot;Root compiled intrinsic with invalid states %s:Must have exactly one merge node. %d found&quot;, parser.method, mergeCount);</span>
<span class="line-added"> 752                 }</span>
<span class="line-added"> 753                 if (ret.predecessor() instanceof MergeNode) {</span>
<span class="line-added"> 754                     merge = (MergeNode) ret.predecessor();</span>
<span class="line-added"> 755                 }</span>
<span class="line-added"> 756                 if (merge == null) {</span>
<span class="line-added"> 757                     throw new GraalError(&quot;Root compiled intrinsic with invalid state: Unexpected node between return and merge.&quot;);</span>
<span class="line-added"> 758                 }</span>
<span class="line-added"> 759                 //@formatter:off</span>
<span class="line-added"> 760                 GraalError.guarantee(invalidBCIsInRootCompiledIntrinsic &lt;= merge.phiPredecessorCount() + 1 /* merge itself */,</span>
<span class="line-added"> 761                                 &quot;Root compiled intrinsic with invalid states %s must at maximum produce (0,1 or if the last instruction is a merge |merge.predCount|&quot; +</span>
<span class="line-added"> 762                                                 &quot; invalid BCI state, however %d where found.&quot;,</span>
<span class="line-added"> 763                                 parser.method, invalidBCIsInRootCompiledIntrinsic);</span>
<span class="line-added"> 764                 //@formatter:on</span>
<span class="line-added"> 765                 if (merge.stateAfter() != null &amp;&amp; merge.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {</span>
<span class="line-added"> 766                     invalidBCIsToFind--;</span>
<span class="line-added"> 767                 }</span>
<span class="line-added"> 768                 for (EndNode pred : merge.cfgPredecessors()) {</span>
<span class="line-added"> 769                     Node lastPred = pred.predecessor();</span>
<span class="line-added"> 770                     for (FixedNode f : GraphUtil.predecessorIterable((FixedNode) lastPred)) {</span>
<span class="line-added"> 771                         if (f instanceof StateSplit) {</span>
<span class="line-added"> 772                             StateSplit split = (StateSplit) f;</span>
<span class="line-added"> 773                             if (split.hasSideEffect()) {</span>
<span class="line-added"> 774                                 assert ((StateSplit) f).stateAfter() != null;</span>
<span class="line-added"> 775                                 if (split.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {</span>
<span class="line-added"> 776                                     invalidBCIsToFind--;</span>
<span class="line-added"> 777                                 }</span>
<span class="line-added"> 778                             }</span>
<span class="line-added"> 779                         }</span>
<span class="line-added"> 780                     }</span>
<span class="line-added"> 781                 }</span>
<span class="line-added"> 782                 if (invalidBCIsToFind != 0) {</span>
<span class="line-added"> 783                     throw new GraalError(</span>
<span class="line-added"> 784                                     &quot;Invalid BCI state missmatch: This root compiled method substitution %s &quot; +</span>
<span class="line-added"> 785                                                     &quot;uses invalid side-effecting nodes resulting in invalid deoptimization information. &quot; +</span>
<span class="line-added"> 786                                                     &quot;Method substitutions must never have more than one state (the after state) for deoptimization.&quot; +</span>
<span class="line-added"> 787                                                     &quot; Multiple states are only allowed if they are dominated by a control-flow split, there is only&quot; +</span>
<span class="line-added"> 788                                                     &quot; a single effect per branch and a post dominating merge with the same invalid_bci state &quot; +</span>
<span class="line-added"> 789                                                     &quot;(that must only be different in its return value).&quot;,</span>
<span class="line-added"> 790                                     parser.method);</span>
<span class="line-added"> 791                 }</span>
<span class="line-added"> 792             }</span>
<span class="line-added"> 793             return true;</span>
<span class="line-added"> 794         }</span>
<span class="line-added"> 795 </span>
<span class="line-added"> 796         private void updateSplitFrameState(StateSplit split, JavaKind returnKind, ValueNode returnValue) {</span>
<span class="line-added"> 797             parser.frameState.push(returnKind, returnValue);</span>
<span class="line-added"> 798             FrameState oldState = split.stateAfter();</span>
<span class="line-added"> 799             split.setStateAfter(parser.createFrameState(parser.stream.nextBCI(), split));</span>
<span class="line-added"> 800             parser.frameState.pop(returnKind);</span>
<span class="line-added"> 801             if (oldState.hasNoUsages()) {</span>
<span class="line-added"> 802                 oldState.safeDelete();</span>
<span class="line-added"> 803             }</span>
<span class="line-added"> 804         }</span>
<span class="line-added"> 805 </span>
<span class="line-added"> 806         @Override</span>
<span class="line-added"> 807         protected void handleReturnMismatch(StructuredGraph g, FrameState fs) {</span>
<span class="line-added"> 808             if (invalidStateUsers == null) {</span>
<span class="line-added"> 809                 invalidStateUsers = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 810             }</span>
<span class="line-added"> 811             for (Node use : fs.usages()) {</span>
<span class="line-added"> 812                 if (!(use instanceof StateSplit)) {</span>
<span class="line-added"> 813                     throw new GraalError(&quot;Expected StateSplit for return mismatch&quot;);</span>
<span class="line-added"> 814                 }</span>
<span class="line-added"> 815                 invalidStateUsers.add((StateSplit) use);</span>
 816             }

 817         }
 818     }
 819 
 820     private static class Target {
<span class="line-modified"> 821         final FixedNode entry;</span>
<span class="line-modified"> 822         final FixedNode originalEntry;</span>
<span class="line-added"> 823         final FrameStateBuilder state;</span>
<span class="line-added"> 824 </span>
<span class="line-added"> 825         Target(FixedNode entry, FrameStateBuilder state) {</span>
<span class="line-added"> 826             this.entry = entry;</span>
<span class="line-added"> 827             this.state = state;</span>
<span class="line-added"> 828             this.originalEntry = null;</span>
<span class="line-added"> 829         }</span>
 830 
<span class="line-modified"> 831         Target(FixedNode entry, FrameStateBuilder state, FixedNode originalEntry) {</span>
<span class="line-modified"> 832             this.entry = entry;</span>
 833             this.state = state;
<span class="line-added"> 834             this.originalEntry = originalEntry;</span>
 835         }
 836     }
 837 
 838     @SuppressWarnings(&quot;serial&quot;)
 839     public static class BytecodeParserError extends GraalError {
 840 
 841         public BytecodeParserError(Throwable cause) {
 842             super(cause);
 843         }
 844 
 845         public BytecodeParserError(String msg, Object... args) {
 846             super(msg, args);
 847         }
 848     }
 849 
 850     protected static class ReturnToCallerData {
 851         protected final ValueNode returnValue;
 852         protected final FixedWithNextNode beforeReturnNode;
 853 
 854         protected ReturnToCallerData(ValueNode returnValue, FixedWithNextNode beforeReturnNode) {
</pre>
<hr />
<pre>
 893     private FixedWithNextNode[] firstInstructionArray;
 894     private FrameStateBuilder[] entryStateArray;
 895 
 896     private boolean finalBarrierRequired;
 897     private ValueNode originalReceiver;
 898     private final boolean eagerInitializing;
 899     private final boolean uninitializedIsError;
 900     private final int traceLevel;
 901 
 902     protected BytecodeParser(GraphBuilderPhase.Instance graphBuilderInstance, StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method,
 903                     int entryBCI, IntrinsicContext intrinsicContext) {
 904         this.bytecodeProvider = intrinsicContext == null ? new ResolvedJavaMethodBytecodeProvider() : intrinsicContext.getBytecodeProvider();
 905         this.code = bytecodeProvider.getBytecode(method);
 906         this.method = code.getMethod();
 907         this.graphBuilderInstance = graphBuilderInstance;
 908         this.graph = graph;
 909         this.options = graph.getOptions();
 910         this.debug = graph.getDebug();
 911         this.graphBuilderConfig = graphBuilderInstance.graphBuilderConfig;
 912         this.optimisticOpts = graphBuilderInstance.optimisticOpts;
<span class="line-modified"> 913         this.providers = graphBuilderInstance.providers;</span>



 914         this.stream = new BytecodeStream(code.getCode());
 915         this.profilingInfo = graph.useProfilingInfo() ? code.getProfilingInfo() : null;
 916         this.constantPool = code.getConstantPool();
 917         this.intrinsicContext = intrinsicContext;
 918         this.entryBCI = entryBCI;
 919         this.parent = parent;
 920 
 921         ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
<span class="line-modified"> 922         if (classInitializationPlugin != null &amp;&amp; graphBuilderConfig.eagerResolving() &amp;&amp; classInitializationPlugin.supportsLazyInitialization(constantPool)) {</span>
<span class="line-modified"> 923             eagerInitializing = false;</span>
<span class="line-added"> 924             uninitializedIsError = false;</span>
 925         } else {
 926             eagerInitializing = graphBuilderConfig.eagerResolving();
 927             uninitializedIsError = graphBuilderConfig.unresolvedIsError();
 928         }
 929 
 930         assert code.getCode() != null : &quot;method must contain bytecodes: &quot; + method;
 931 
 932         if (graphBuilderConfig.insertFullInfopoints() &amp;&amp; !parsingIntrinsic()) {
 933             lnt = code.getLineNumberTable();
 934             previousLineNumber = -1;
 935         }
 936 
 937         assert !GraalOptions.TrackNodeSourcePosition.getValue(options) || graph.trackNodeSourcePosition();
 938         if (graphBuilderConfig.trackNodeSourcePosition() || (parent != null &amp;&amp; parent.graph.trackNodeSourcePosition())) {
 939             graph.setTrackNodeSourcePosition();
 940         }
 941 
 942         int level = TraceBytecodeParserLevel.getValue(options);
 943         this.traceLevel = level != 0 ? refineTraceLevel(level) : 0;
 944     }
</pre>
<hr />
<pre>
 955                 return 0;
 956             }
 957         }
 958         return level;
 959     }
 960 
 961     protected GraphBuilderPhase.Instance getGraphBuilderInstance() {
 962         return graphBuilderInstance;
 963     }
 964 
 965     public ValueNode getUnwindValue() {
 966         return unwindValue;
 967     }
 968 
 969     public FixedWithNextNode getBeforeUnwindNode() {
 970         return this.beforeUnwindNode;
 971     }
 972 
 973     @SuppressWarnings(&quot;try&quot;)
 974     protected void buildRootMethod() {
<span class="line-modified"> 975         FrameStateBuilder startFrameState = new FrameStateBuilder(this, code, graph, graphBuilderConfig.retainLocalVariables());</span>
 976         startFrameState.initializeForMethodStart(graph.getAssumptions(), graphBuilderConfig.eagerResolving() || intrinsicContext != null, graphBuilderConfig.getPlugins());
 977 
 978         try (IntrinsicScope s = intrinsicContext != null ? new IntrinsicScope(this) : null) {
 979             build(graph.start(), startFrameState);
 980         }
 981 
 982         cleanupFinalGraph();
 983         ComputeLoopFrequenciesClosure.compute(graph);
 984     }
 985 
 986     @SuppressWarnings(&quot;try&quot;)
 987     protected void build(FixedWithNextNode startInstruction, FrameStateBuilder startFrameState) {
 988         if (PrintProfilingInformation.getValue(options) &amp;&amp; profilingInfo != null) {
 989             TTY.println(&quot;Profiling info for &quot; + method.format(&quot;%H.%n(%p)&quot;));
 990             TTY.println(Util.indent(profilingInfo.toString(method, CodeUtil.NEW_LINE), &quot;  &quot;));
 991         }
 992 
 993         try (Indent indent = debug.logAndIndent(&quot;build graph for %s&quot;, method)) {
 994             if (bytecodeProvider.shouldRecordMethodDependencies()) {
 995                 assert getParent() != null || method.equals(graph.method());
</pre>
<hr />
<pre>
1123         GraphUtil.normalizeLoops(graph);
1124 
1125         // Remove dead parameters.
1126         for (ParameterNode param : graph.getNodes(ParameterNode.TYPE)) {
1127             if (param.hasNoUsages()) {
1128                 assert param.inputs().isEmpty();
1129                 param.safeDelete();
1130             }
1131         }
1132 
1133         // Remove redundant begin nodes.
1134         for (BeginNode beginNode : graph.getNodes(BeginNode.TYPE)) {
1135             Node predecessor = beginNode.predecessor();
1136             if (predecessor instanceof ControlSplitNode) {
1137                 // The begin node is necessary.
1138             } else if (!beginNode.hasUsages()) {
1139                 GraphUtil.unlinkFixedNode(beginNode);
1140                 beginNode.safeDelete();
1141             }
1142         }
<span class="line-added">1143         if (graph.isOSR() &amp;&amp; getParent() == null &amp;&amp; graph.getNodes().filter(EntryMarkerNode.class).isEmpty()) {</span>
<span class="line-added">1144             // This should generally be a transient condition because of inconsistent profile</span>
<span class="line-added">1145             // information.</span>
<span class="line-added">1146             throw new RetryableBailoutException(&quot;OSR entry point wasn&#39;t parsed&quot;);</span>
<span class="line-added">1147         }</span>
1148     }
1149 
1150     /**
1151      * Creates the frame state after the start node of a graph for an {@link IntrinsicContext
1152      * intrinsic} that is the parse root (either for root compiling or for post-parse inlining).
1153      */
1154     private FrameState createStateAfterStartOfReplacementGraph() {
1155         assert parent == null;
1156         assert frameState.getMethod().equals(intrinsicContext.getIntrinsicMethod());
1157         assert bci() == 0;
1158         assert frameState.stackSize() == 0;
1159         FrameState stateAfterStart;
1160         if (intrinsicContext.isPostParseInlined()) {
1161             stateAfterStart = graph.add(new FrameState(BytecodeFrame.BEFORE_BCI));
1162         } else {
1163             ResolvedJavaMethod original = intrinsicContext.getOriginalMethod();
1164             ValueNode[] locals;
1165             if (original.getMaxLocals() == frameState.localsSize() || original.isNative()) {
1166                 locals = new ValueNode[original.getMaxLocals()];
1167                 for (int i = 0; i &lt; locals.length; i++) {
</pre>
<hr />
<pre>
1303      */
1304     protected void handleUnresolvedInvoke(JavaMethod javaMethod, InvokeKind invokeKind) {
1305         assert !graphBuilderConfig.unresolvedIsError();
1306         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1307         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1308     }
1309 
1310     /**
1311      * @return the entry point to exception dispatch
1312      */
1313     private AbstractBeginNode handleException(ValueNode exceptionObject, int bci, boolean deoptimizeOnly) {
1314         FixedWithNextNode currentLastInstr = lastInstr;
1315         assert bci == BytecodeFrame.BEFORE_BCI || bci == bci() : &quot;invalid bci&quot;;
1316         debug.log(&quot;Creating exception dispatch edges at %d, exception object=%s, exception seen=%s&quot;, bci, exceptionObject, (profilingInfo == null ? &quot;&quot; : profilingInfo.getExceptionSeen(bci)));
1317 
1318         FrameStateBuilder dispatchState = frameState.copy();
1319         dispatchState.clearStack();
1320 
1321         AbstractBeginNode dispatchBegin;
1322         if (exceptionObject == null) {
<span class="line-modified">1323             ExceptionObjectNode newExceptionObject = graph.add(new ExceptionObjectNode(getMetaAccess()));</span>
<span class="line-modified">1324             dispatchState.push(JavaKind.Object, newExceptionObject);</span>

1325             dispatchState.setRethrowException(true);
1326             newExceptionObject.setStateAfter(dispatchState.create(bci, newExceptionObject));
<span class="line-added">1327             dispatchBegin = newExceptionObject;</span>
1328         } else {
1329             dispatchBegin = graph.add(new BeginNode());
1330             dispatchState.push(JavaKind.Object, exceptionObject);
1331             dispatchState.setRethrowException(true);
1332         }
1333         this.controlFlowSplit = true;
1334         FixedWithNextNode afterExceptionLoaded = finishInstruction(dispatchBegin, dispatchState);
1335 
1336         if (deoptimizeOnly) {
1337             DeoptimizeNode deoptimizeNode = graph.add(new DeoptimizeNode(DeoptimizationAction.None, DeoptimizationReason.TransferToInterpreter));
1338             afterExceptionLoaded.setNext(BeginNode.begin(deoptimizeNode));
1339         } else {
1340             createHandleExceptionTarget(afterExceptionLoaded, bci, dispatchState);
1341         }
1342         assert currentLastInstr == lastInstr;
1343         return dispatchBegin;
1344     }
1345 
1346     protected void createHandleExceptionTarget(FixedWithNextNode afterExceptionLoaded, int bci, FrameStateBuilder dispatchState) {
1347         FixedWithNextNode afterInstrumentation = afterExceptionLoaded;
1348         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
<span class="line-modified">1349             afterInstrumentation = plugin.instrumentExceptionDispatch(graph, afterInstrumentation, () -&gt; dispatchState.create(bci, getNonIntrinsicAncestor(), false, null, null));</span>
1350             assert afterInstrumentation.next() == null : &quot;exception dispatch instrumentation will be linked to dispatch block&quot;;
1351         }
1352 
1353         BciBlock dispatchBlock = currentBlock.exceptionDispatchBlock();
1354         /*
1355          * The exception dispatch block is always for the last bytecode of a block, so if we are not
1356          * at the endBci yet, there is no exception handler for this bci and we can unwind
1357          * immediately.
1358          */
1359         if (bci != currentBlock.endBci || dispatchBlock == null) {
1360             dispatchBlock = blockMap.getUnwindBlock();
1361         }
1362 
1363         FixedNode target = createTarget(dispatchBlock, dispatchState);
1364         afterInstrumentation.setNext(target);
1365     }
1366 
1367     protected ValueNode genLoadIndexed(ValueNode array, ValueNode index, GuardingNode boundsCheck, JavaKind kind) {
<span class="line-modified">1368         return LoadIndexedNode.create(graph.getAssumptions(), array, index, boundsCheck, kind, getMetaAccess(), getConstantReflection());</span>
1369     }
1370 
1371     protected void genStoreIndexed(ValueNode array, ValueNode index, GuardingNode boundsCheck, GuardingNode storeCheck, JavaKind kind, ValueNode value) {
1372         add(new StoreIndexedNode(array, index, boundsCheck, storeCheck, kind, value));
1373     }
1374 
1375     protected ValueNode genIntegerAdd(ValueNode x, ValueNode y) {
1376         return AddNode.create(x, y, NodeView.DEFAULT);
1377     }
1378 
1379     protected ValueNode genIntegerSub(ValueNode x, ValueNode y) {
1380         return SubNode.create(x, y, NodeView.DEFAULT);
1381     }
1382 
1383     protected ValueNode genIntegerMul(ValueNode x, ValueNode y) {
1384         return MulNode.create(x, y, NodeView.DEFAULT);
1385     }
1386 
1387     protected ValueNode genFloatAdd(ValueNode x, ValueNode y) {
1388         return AddNode.create(x, y, NodeView.DEFAULT);
</pre>
<hr />
<pre>
1424         return RightShiftNode.create(x, y, NodeView.DEFAULT);
1425     }
1426 
1427     protected ValueNode genUnsignedRightShift(ValueNode x, ValueNode y) {
1428         return UnsignedRightShiftNode.create(x, y, NodeView.DEFAULT);
1429     }
1430 
1431     protected ValueNode genAnd(ValueNode x, ValueNode y) {
1432         return AndNode.create(x, y, NodeView.DEFAULT);
1433     }
1434 
1435     protected ValueNode genOr(ValueNode x, ValueNode y) {
1436         return OrNode.create(x, y, NodeView.DEFAULT);
1437     }
1438 
1439     protected ValueNode genXor(ValueNode x, ValueNode y) {
1440         return XorNode.create(x, y, NodeView.DEFAULT);
1441     }
1442 
1443     protected ValueNode genNormalizeCompare(ValueNode x, ValueNode y, boolean isUnorderedLess) {
<span class="line-modified">1444         return FloatNormalizeCompareNode.create(x, y, isUnorderedLess, JavaKind.Int, getConstantReflection());</span>
<span class="line-added">1445     }</span>
<span class="line-added">1446 </span>
<span class="line-added">1447     protected ValueNode genIntegerNormalizeCompare(ValueNode x, ValueNode y) {</span>
<span class="line-added">1448         return IntegerNormalizeCompareNode.create(x, y, false, JavaKind.Int, getConstantReflection());</span>
1449     }
1450 
1451     protected ValueNode genFloatConvert(FloatConvert op, ValueNode input) {
1452         return FloatConvertNode.create(op, input, NodeView.DEFAULT);
1453     }
1454 
1455     protected ValueNode genNarrow(ValueNode input, int bitCount) {
1456         return NarrowNode.create(input, bitCount, NodeView.DEFAULT);
1457     }
1458 
1459     protected ValueNode genSignExtend(ValueNode input, int bitCount) {
1460         return SignExtendNode.create(input, bitCount, NodeView.DEFAULT);
1461     }
1462 
1463     protected ValueNode genZeroExtend(ValueNode input, int bitCount) {
1464         return ZeroExtendNode.create(input, bitCount, NodeView.DEFAULT);
1465     }
1466 
1467     protected void genGoto() {
1468         ProfilingPlugin profilingPlugin = this.graphBuilderConfig.getPlugins().getProfilingPlugin();
1469         if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
1470             FrameState stateBefore = createCurrentFrameState();
1471             int targetBci = currentBlock.getSuccessor(0).startBci;
1472             profilingPlugin.profileGoto(this, method, bci(), targetBci, stateBefore);
1473         }
1474         appendGoto(currentBlock.getSuccessor(0));
1475         assert currentBlock.numNormalSuccessors() == 1;
1476     }
1477 
1478     protected LogicNode genObjectEquals(ValueNode x, ValueNode y) {
<span class="line-modified">1479         return ObjectEqualsNode.create(getConstantReflection(), getMetaAccess(), options, x, y, NodeView.DEFAULT);</span>
1480     }
1481 
1482     protected LogicNode genIntegerEquals(ValueNode x, ValueNode y) {
<span class="line-modified">1483         return IntegerEqualsNode.create(getConstantReflection(), getMetaAccess(), options, null, x, y, NodeView.DEFAULT);</span>
1484     }
1485 
1486     protected LogicNode genIntegerLessThan(ValueNode x, ValueNode y) {
<span class="line-modified">1487         return IntegerLessThanNode.create(getConstantReflection(), getMetaAccess(), options, null, x, y, NodeView.DEFAULT);</span>
1488     }
1489 
1490     protected ValueNode genUnique(ValueNode x) {
1491         return graph.addOrUniqueWithInputs(x);
1492     }
1493 
1494     protected LogicNode genUnique(LogicNode x) {
1495         return graph.addOrUniqueWithInputs(x);
1496     }
1497 
1498     protected ValueNode genIfNode(LogicNode condition, FixedNode trueSuccessor, FixedNode falseSuccessor, double d) {
1499         return new IfNode(condition, trueSuccessor, falseSuccessor, d);
1500     }
1501 
1502     protected void genThrow() {
1503         genInfoPointNode(InfopointReason.BYTECODE_POSITION, null);
1504 
1505         ValueNode exception = maybeEmitExplicitNullCheck(frameState.pop(JavaKind.Object));
1506         if (!StampTool.isPointerNonNull(exception.stamp(NodeView.DEFAULT))) {
1507             FixedGuardNode nullCheck = append(new FixedGuardNode(graph.addOrUniqueWithInputs(IsNullNode.create(exception)), NullCheckException, InvalidateReprofile, true));
1508             exception = graph.maybeAddOrUnique(PiNode.create(exception, exception.stamp(NodeView.DEFAULT).join(objectNonNull()), nullCheck));
1509         }
1510         lastInstr.setNext(handleException(exception, bci(), false));
1511     }
1512 
1513     protected LogicNode createInstanceOf(TypeReference type, ValueNode object) {
1514         return InstanceOfNode.create(type, object);
1515     }
1516 
1517     protected AnchoringNode createAnchor(JavaTypeProfile profile) {
1518         if (profile == null || profile.getNotRecordedProbability() &gt; 0.0) {
1519             return null;
1520         } else {
<span class="line-modified">1521             return BeginNode.prevBegin(lastInstr);</span>
1522         }
1523     }
1524 
1525     protected LogicNode createInstanceOf(TypeReference type, ValueNode object, JavaTypeProfile profile) {
1526         return InstanceOfNode.create(type, object, profile, createAnchor(profile));
1527     }
1528 
1529     protected LogicNode createInstanceOfAllowNull(TypeReference type, ValueNode object, JavaTypeProfile profile) {
1530         return InstanceOfNode.createAllowNull(type, object, profile, createAnchor(profile));
1531     }
1532 
1533     protected ValueNode genConditional(ValueNode x) {
1534         return ConditionalNode.create((LogicNode) x, NodeView.DEFAULT);
1535     }
1536 
1537     protected NewInstanceNode createNewInstance(ResolvedJavaType type, boolean fillContents) {
1538         return new NewInstanceNode(type, fillContents);
1539     }
1540 
1541     protected NewArrayNode createNewArray(ResolvedJavaType elementType, ValueNode length, boolean fillContents) {
</pre>
<hr />
<pre>
1558     }
1559 
1560     protected StateSplitProxyNode genVolatileFieldReadProxy(ValueNode fieldRead) {
1561         return new StateSplitProxyNode(fieldRead);
1562     }
1563 
1564     protected ValueNode maybeEmitExplicitNullCheck(ValueNode receiver) {
1565         if (StampTool.isPointerNonNull(receiver.stamp(NodeView.DEFAULT)) || !needsExplicitNullCheckException(receiver)) {
1566             return receiver;
1567         }
1568         LogicNode condition = genUnique(IsNullNode.create(receiver));
1569         AbstractBeginNode passingSuccessor = emitBytecodeExceptionCheck(condition, false, BytecodeExceptionKind.NULL_POINTER);
1570         return genUnique(PiNode.create(receiver, objectNonNull(), passingSuccessor));
1571     }
1572 
1573     protected GuardingNode maybeEmitExplicitBoundsCheck(ValueNode receiver, ValueNode index) {
1574         if (!needsExplicitBoundsCheckException(receiver, index)) {
1575             return null;
1576         }
1577         ValueNode length = append(genArrayLength(receiver));
<span class="line-modified">1578         LogicNode condition = genUnique(IntegerBelowNode.create(getConstantReflection(), getMetaAccess(), options, null, index, length, NodeView.DEFAULT));</span>
1579         return emitBytecodeExceptionCheck(condition, true, BytecodeExceptionKind.OUT_OF_BOUNDS, index, length);
1580     }
1581 
1582     protected GuardingNode maybeEmitExplicitStoreCheck(ValueNode array, JavaKind elementKind, ValueNode value) {
1583         if (elementKind != JavaKind.Object || StampTool.isPointerAlwaysNull(value) || !needsExplicitStoreCheckException(array, value)) {
1584             return null;
1585         }
<span class="line-modified">1586         ValueNode arrayClass = genUnique(LoadHubNode.create(array, getStampProvider(), getMetaAccess(), getConstantReflection()));</span>
<span class="line-modified">1587         ValueNode componentHub = append(LoadArrayComponentHubNode.create(arrayClass, getStampProvider(), getMetaAccess(), getConstantReflection()));</span>
1588         LogicNode condition = genUnique(InstanceOfDynamicNode.create(graph.getAssumptions(), getConstantReflection(), componentHub, value, true));
1589         return emitBytecodeExceptionCheck(condition, true, BytecodeExceptionKind.ARRAY_STORE, value);
1590     }
1591 
1592     protected GuardingNode maybeEmitExplicitDivisionByZeroCheck(ValueNode y) {
1593         if (!((IntegerStamp) y.stamp(NodeView.DEFAULT)).contains(0) || !needsExplicitDivisionByZeroException(y)) {
1594             return null;
1595         }
1596         ConstantNode zero = ConstantNode.defaultForKind(y.getStackKind(), graph);
<span class="line-modified">1597         LogicNode condition = genUnique(IntegerEqualsNode.create(getConstantReflection(), getMetaAccess(), options, null, y, zero, NodeView.DEFAULT));</span>
1598         return emitBytecodeExceptionCheck(condition, false, BytecodeExceptionKind.DIVISION_BY_ZERO);
1599     }
1600 
1601     private AbstractBeginNode emitBytecodeExceptionCheck(LogicNode condition, boolean passingOnTrue, BytecodeExceptionKind exceptionKind, ValueNode... arguments) {
1602         if (passingOnTrue ? condition.isTautology() : condition.isContradiction()) {
1603             return null;
1604         }
1605 
<span class="line-modified">1606         BytecodeExceptionNode exception = graph.add(new BytecodeExceptionNode(getMetaAccess(), exceptionKind, arguments));</span>
1607         AbstractBeginNode passingSuccessor = graph.add(new BeginNode());
1608 
1609         FixedNode trueSuccessor = passingOnTrue ? passingSuccessor : exception;
1610         FixedNode falseSuccessor = passingOnTrue ? exception : passingSuccessor;
1611         append(new IfNode(condition, trueSuccessor, falseSuccessor, passingOnTrue ? LUDICROUSLY_FAST_PATH_PROBABILITY : LUDICROUSLY_SLOW_PATH_PROBABILITY));
1612         lastInstr = passingSuccessor;
1613 
<span class="line-modified">1614         exception.setStateAfter(createBytecodeExceptionFrameState(bci(), exception));</span>
1615         exception.setNext(handleException(exception, bci(), false));
1616         EXPLICIT_EXCEPTIONS.increment(debug);
1617 
1618         return passingSuccessor;
1619     }
1620 
1621     protected ValueNode genArrayLength(ValueNode x) {
<span class="line-modified">1622         return ArrayLengthNode.create(x, getConstantReflection());</span>
1623     }
1624 
1625     protected void genStoreField(ValueNode receiver, ResolvedJavaField field, ValueNode value) {
1626         StoreFieldNode storeFieldNode = new StoreFieldNode(receiver, field, maskSubWordValue(value, field.getJavaKind()));
1627         append(storeFieldNode);
1628         storeFieldNode.setStateAfter(this.createFrameState(stream.nextBCI(), storeFieldNode));
1629     }
1630 
1631     /**
1632      * Ensure that concrete classes are at least linked before generating an invoke. Interfaces may
1633      * never be linked so simply return true for them.
1634      *
1635      * @param target
1636      * @return true if the declared holder is an interface or is linked
1637      */
1638     private static boolean callTargetIsResolved(JavaMethod target) {
1639         if (target instanceof ResolvedJavaMethod) {
1640             ResolvedJavaMethod resolvedTarget = (ResolvedJavaMethod) target;
1641             ResolvedJavaType resolvedType = resolvedTarget.getDeclaringClass();
1642             return resolvedType.isInterface() || resolvedType.isLinked();
</pre>
<hr />
<pre>
1753             return false;
1754         }
1755 
1756         if (GeneratePIC.getValue(options) &amp;&amp; (invokeDynamicPlugin == null || !invokeDynamicPlugin.supportsDynamicInvoke(this, cpi, opcode))) {
1757             // bail out if static compiler and no dynamic type support
1758             append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1759             return true;
1760         }
1761 
1762         JavaConstant appendix = constantPool.lookupAppendix(cpi, opcode);
1763         ValueNode appendixNode = null;
1764 
1765         if (appendix != null) {
1766             if (invokeDynamicPlugin != null) {
1767                 invokeDynamicPlugin.recordDynamicMethod(this, cpi, opcode, target);
1768 
1769                 // Will perform runtime type checks and static initialization
1770                 FrameState stateBefore = createCurrentFrameState();
1771                 appendixNode = invokeDynamicPlugin.genAppendixNode(this, cpi, opcode, appendix, stateBefore);
1772             } else {
<span class="line-modified">1773                 appendixNode = ConstantNode.forConstant(appendix, getMetaAccess(), graph);</span>
1774             }
1775 
1776             frameState.push(JavaKind.Object, appendixNode);
1777 
1778         } else if (GeneratePIC.getValue(options)) {
1779             // Need to emit runtime guard and perform static initialization.
1780             // Not implemented yet.
1781             append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1782             return true;
1783         }
1784 
1785         boolean hasReceiver = (opcode == INVOKEDYNAMIC) ? false : !target.isStatic();
1786         ValueNode[] args = frameState.popArguments(target.getSignature().getParameterCount(hasReceiver));
1787         if (hasReceiver) {
1788             appendInvoke(InvokeKind.Virtual, target, args);
1789         } else {
1790             appendInvoke(InvokeKind.Static, target, args);
1791         }
1792 
1793         return true;
</pre>
<hr />
<pre>
1815         final JavaType returnType;
1816 
1817         CurrentInvoke(ValueNode[] args, InvokeKind kind, JavaType returnType) {
1818             this.args = args;
1819             this.kind = kind;
1820             this.returnType = returnType;
1821         }
1822     }
1823 
1824     private CurrentInvoke currentInvoke;
1825     protected FrameStateBuilder frameState;
1826     protected BciBlock currentBlock;
1827     protected final BytecodeStream stream;
1828     protected final GraphBuilderConfiguration graphBuilderConfig;
1829     protected final ResolvedJavaMethod method;
1830     protected final Bytecode code;
1831     protected final BytecodeProvider bytecodeProvider;
1832     protected final ProfilingInfo profilingInfo;
1833     protected final OptimisticOptimizations optimisticOpts;
1834     protected final ConstantPool constantPool;
<span class="line-modified">1835     protected final CoreProviders providers;</span>



1836     protected final IntrinsicContext intrinsicContext;
1837 
1838     @Override
1839     public InvokeKind getInvokeKind() {
1840         return currentInvoke == null ? null : currentInvoke.kind;
1841     }
1842 
1843     @Override
1844     public JavaType getInvokeReturnType() {
1845         return currentInvoke == null ? null : currentInvoke.returnType;
1846     }
1847 
1848     private boolean forceInliningEverything;
1849 
1850     @Override
1851     public Invoke handleReplacedInvoke(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, boolean inlineEverything) {
1852         boolean previous = forceInliningEverything;
1853         forceInliningEverything = previous || inlineEverything;
1854         try {
1855             return appendInvoke(invokeKind, targetMethod, args);
</pre>
<hr />
<pre>
1867 
1868     protected Invoke appendInvoke(InvokeKind initialInvokeKind, ResolvedJavaMethod initialTargetMethod, ValueNode[] args) {
1869         ResolvedJavaMethod targetMethod = initialTargetMethod;
1870         InvokeKind invokeKind = initialInvokeKind;
1871         if (initialInvokeKind.isIndirect()) {
1872             ResolvedJavaType contextType = this.frameState.getMethod().getDeclaringClass();
1873             ResolvedJavaMethod specialCallTarget = MethodCallTargetNode.findSpecialCallTarget(initialInvokeKind, args[0], initialTargetMethod, contextType);
1874             if (specialCallTarget != null) {
1875                 invokeKind = InvokeKind.Special;
1876                 targetMethod = specialCallTarget;
1877             }
1878         }
1879 
1880         JavaKind resultType = targetMethod.getSignature().getReturnKind();
1881         if (!parsingIntrinsic() &amp;&amp; DeoptALot.getValue(options)) {
1882             append(new DeoptimizeNode(DeoptimizationAction.None, RuntimeConstraint));
1883             frameState.pushReturn(resultType, ConstantNode.defaultForKind(resultType, graph));
1884             return null;
1885         }
1886 
<span class="line-modified">1887         JavaType returnType = maybeEagerlyResolve(targetMethod.getSignature().getReturnType(method.getDeclaringClass()), targetMethod.getDeclaringClass());</span>



1888         if (invokeKind.hasReceiver()) {
1889             args[0] = maybeEmitExplicitNullCheck(args[0]);
1890         }
1891 
1892         if (initialInvokeKind == InvokeKind.Special &amp;&amp; !targetMethod.isConstructor()) {
1893             emitCheckForInvokeSuperSpecial(args);
1894         } else if (initialInvokeKind == InvokeKind.Interface &amp;&amp; targetMethod.isPrivate()) {
1895             emitCheckForDeclaringClassChange(targetMethod.getDeclaringClass(), args);
1896         }
1897 
1898         InlineInfo inlineInfo = null;
1899         try {
1900             currentInvoke = new CurrentInvoke(args, invokeKind, returnType);
1901             if (tryNodePluginForInvocation(args, targetMethod)) {
1902                 if (TraceParserPlugins.getValue(options)) {
1903                     traceWithContext(&quot;used node plugin for %s&quot;, targetMethod.format(&quot;%h.%n(%p)&quot;));
1904                 }
1905                 return null;
1906             }
1907 
1908             if (invokeKind.hasReceiver() &amp;&amp; args[0].isNullConstant()) {
1909                 append(new DeoptimizeNode(InvalidateRecompile, NullCheckException));
1910                 return null;
1911             }
1912 
<span class="line-modified">1913             if (!invokeKind.isIndirect()) {</span>
<span class="line-modified">1914                 if (tryInvocationPlugin(invokeKind, args, targetMethod, resultType)) {</span>
1915                     if (TraceParserPlugins.getValue(options)) {
1916                         traceWithContext(&quot;used invocation plugin for %s&quot;, targetMethod.format(&quot;%h.%n(%p)&quot;));
1917                     }
1918                     return null;
1919                 }
1920             }
1921             if (invokeKind.isDirect()) {
1922                 inlineInfo = tryInline(args, targetMethod);
1923                 if (inlineInfo == SUCCESSFULLY_INLINED) {
1924                     return null;
1925                 }
1926             }
1927         } finally {
1928             currentInvoke = null;
1929         }

1930         int invokeBci = bci();
1931         JavaTypeProfile profile = getProfileForInvoke(invokeKind);
1932         ExceptionEdgeAction edgeAction = getActionForInvokeExceptionEdge(inlineInfo);
1933         boolean partialIntrinsicExit = false;
1934         if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
1935             partialIntrinsicExit = true;
1936             ResolvedJavaMethod originalMethod = intrinsicContext.getOriginalMethod();
1937             BytecodeParser intrinsicCallSiteParser = getNonIntrinsicAncestor();
1938             if (intrinsicCallSiteParser != null) {
1939                 // When exiting a partial intrinsic, the invoke to the original
1940                 // must use the same context as the call to the intrinsic.
1941                 invokeBci = intrinsicCallSiteParser.bci();
1942                 profile = intrinsicCallSiteParser.getProfileForInvoke(invokeKind);
1943                 edgeAction = intrinsicCallSiteParser.getActionForInvokeExceptionEdge(inlineInfo);
1944             } else {
1945                 // We are parsing the intrinsic for the root compilation or for inlining,
1946                 // This call is a partial intrinsic exit, and we do not have profile information
1947                 // for this callsite. We also have to assume that the call needs an exception
1948                 // edge. Finally, we know that this intrinsic is parsed for late inlining,
1949                 // so the bci must be set to unknown, so that the inliner patches it later.
1950                 assert intrinsicContext.isPostParseInlined();
<span class="line-modified">1951                 invokeBci = UNKNOWN_BCI;</span>
1952                 profile = null;
1953                 edgeAction = graph.method().getAnnotation(Snippet.class) == null ? ExceptionEdgeAction.INCLUDE_AND_HANDLE : ExceptionEdgeAction.OMIT;
1954             }
1955 
1956             if (originalMethod.isStatic()) {
1957                 invokeKind = InvokeKind.Static;
1958             } else {
1959                 // The original call to the intrinsic must have been devirtualized
1960                 // otherwise we wouldn&#39;t be here.
1961                 invokeKind = InvokeKind.Special;
1962             }
1963             Signature sig = originalMethod.getSignature();
1964             returnType = sig.getReturnType(method.getDeclaringClass());
1965             resultType = sig.getReturnKind();
1966             assert intrinsicContext.allowPartialIntrinsicArgumentMismatch() || checkPartialIntrinsicExit(intrinsicCallSiteParser == null ? null : intrinsicCallSiteParser.currentInvoke.args, args);
1967             targetMethod = originalMethod;
1968         }
1969         Invoke invoke = createNonInlinedInvoke(edgeAction, invokeBci, args, targetMethod, invokeKind, resultType, returnType, profile);
1970         graph.getInliningLog().addDecision(invoke, false, &quot;GraphBuilderPhase&quot;, null, null, &quot;bytecode parser did not replace invoke&quot;);
1971         if (partialIntrinsicExit) {
</pre>
<hr />
<pre>
2133         final ResolvedJavaMethod targetMethod;
2134         final JavaKind resultType;
2135         final int beforeStackSize;
2136         final boolean needsNullCheck;
2137         final int nodeCount;
2138         final Mark mark;
2139 
2140         InvocationPluginAssertions(InvocationPlugin plugin, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {
2141             guarantee(Assertions.assertionsEnabled(), &quot;%s should only be loaded and instantiated if assertions are enabled&quot;, getClass().getSimpleName());
2142             this.plugin = plugin;
2143             this.targetMethod = targetMethod;
2144             this.args = args;
2145             this.resultType = resultType;
2146             this.beforeStackSize = frameState.stackSize();
2147             this.needsNullCheck = !targetMethod.isStatic() &amp;&amp; args[0].getStackKind() == JavaKind.Object &amp;&amp; !StampTool.isPointerNonNull(args[0].stamp(NodeView.DEFAULT));
2148             this.nodeCount = graph.getNodeCount();
2149             this.mark = graph.getMark();
2150         }
2151 
2152         String error(String format, Object... a) {
<span class="line-modified">2153             return String.format(format, a) + String.format(&quot;%n\tplugin at %s&quot;, plugin.getApplySourceLocation(getMetaAccess()));</span>
2154         }
2155 
2156         boolean check(boolean pluginResult) {
2157             if (pluginResult) {
2158                 /*
2159                  * If lastInstr is null, even if this method has a non-void return type, the method
2160                  * doesn&#39;t return a value, it probably throws an exception.
2161                  */
2162                 int expectedStackSize = beforeStackSize + resultType.getSlotCount();
2163                 assert lastInstr == null || expectedStackSize == frameState.stackSize() : error(&quot;plugin manipulated the stack incorrectly: expected=%d, actual=%d&quot;, expectedStackSize,
2164                                 frameState.stackSize());
2165 
2166                 NodeIterable&lt;Node&gt; newNodes = graph.getNewNodes(mark);
2167                 assert !needsNullCheck || isPointerNonNull(args[0].stamp(NodeView.DEFAULT)) : error(&quot;plugin needs to null check the receiver of %s: receiver=%s&quot;, targetMethod.format(&quot;%H.%n(%p)&quot;),
2168                                 args[0]);
2169                 for (Node n : newNodes) {
2170                     if (n instanceof StateSplit) {
2171                         StateSplit stateSplit = (StateSplit) n;
2172                         assert stateSplit.stateAfter() != null || !stateSplit.hasSideEffect() : error(&quot;%s node added by plugin for %s need to have a non-null frame state: %s&quot;,
2173                                         StateSplit.class.getSimpleName(), targetMethod.format(&quot;%H.%n(%p)&quot;), stateSplit);
2174                     }
2175                 }
2176                 try {
2177                     graphBuilderConfig.getPlugins().getInvocationPlugins().checkNewNodes(BytecodeParser.this, plugin, newNodes);
2178                 } catch (Throwable t) {
2179                     throw new AssertionError(error(&quot;Error in plugin&quot;), t);
2180                 }
2181             } else {
2182                 assert nodeCount == graph.getNodeCount() : error(&quot;plugin that returns false must not create new nodes&quot;);
2183                 assert beforeStackSize == frameState.stackSize() : error(&quot;plugin that returns false must not modify the stack&quot;);
2184             }
2185             return true;
2186         }
2187     }
2188 








































































































































































2189     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">2190     protected boolean tryInvocationPlugin(InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {</span>
2191         InvocationPlugin plugin = graphBuilderConfig.getPlugins().getInvocationPlugins().lookupInvocation(targetMethod);
2192         if (plugin != null) {
2193 
2194             if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
2195                 // Self recursive intrinsic means the original method should be called.
2196                 return false;
2197             }
2198 
2199             InvocationPluginReceiver pluginReceiver = invocationPluginReceiver.init(targetMethod, args);
<span class="line-modified">2200             assert invokeKind.isDirect() : &quot;Cannot apply invocation plugin on an indirect call site.&quot;;</span>









2201 
2202             InvocationPluginAssertions assertions = Assertions.assertionsEnabled() ? new InvocationPluginAssertions(plugin, args, targetMethod, resultType) : null;
2203             try (DebugCloseable context = openNodeContext(targetMethod)) {
2204                 if (plugin.execute(this, targetMethod, pluginReceiver, args)) {
<span class="line-modified">2205                     assert assertions.check(true);</span>
2206                     return !plugin.isDecorator();
2207                 } else {
<span class="line-modified">2208                     assert assertions.check(false);</span>
2209                 }
2210             }
2211         }
2212         return false;
2213     }
2214 
2215     private boolean tryNodePluginForInvocation(ValueNode[] args, ResolvedJavaMethod targetMethod) {
2216         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
2217             if (plugin.handleInvoke(this, targetMethod, args)) {
2218                 return true;
2219             }
2220         }
2221         return false;
2222     }
2223 
2224     private static final InlineInfo SUCCESSFULLY_INLINED = InlineInfo.createStandardInlineInfo(null);
2225 
2226     /**
2227      * Try to inline a method. If the method was inlined, returns {@link #SUCCESSFULLY_INLINED}.
2228      * Otherwise, it returns the {@link InlineInfo} that lead to the decision to not inline it, or
2229      * {@code null} if there is no {@link InlineInfo} for this method.
2230      */
2231     private InlineInfo tryInline(ValueNode[] args, ResolvedJavaMethod targetMethod) {
2232         boolean canBeInlined = forceInliningEverything || parsingIntrinsic() || targetMethod.canBeInlined();
2233         if (!canBeInlined) {
2234             return null;
2235         }
2236 
2237         if (forceInliningEverything) {
2238             if (inline(targetMethod, targetMethod, null, args)) {
2239                 return SUCCESSFULLY_INLINED;
2240             } else {
2241                 return null;
2242             }
2243         }
2244 
2245         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2246             InlineInfo inlineInfo = plugin.shouldInlineInvoke(this, targetMethod, args);
2247             if (inlineInfo != null) {
<span class="line-modified">2248                 if (inlineInfo.allowsInlining()) {</span>
2249                     if (inline(targetMethod, inlineInfo.getMethodToInline(), inlineInfo.getIntrinsicBytecodeProvider(), args)) {
2250                         return SUCCESSFULLY_INLINED;
2251                     }
2252                     inlineInfo = null;
2253                 }
2254                 /* Do not inline, and do not ask the remaining plugins. */
2255                 return inlineInfo;
2256             }
2257         }
2258 
2259         // There was no inline plugin with a definite answer to whether or not
2260         // to inline. If we&#39;re parsing an intrinsic, then we need to enforce the
2261         // invariant here that methods are always force inlined in intrinsics/snippets.
2262         if (parsingIntrinsic()) {
2263             if (inline(targetMethod, targetMethod, this.bytecodeProvider, args)) {
2264                 return SUCCESSFULLY_INLINED;
2265             }
2266         }
2267         return null;
2268     }
</pre>
<hr />
<pre>
2282             int b4 = Bytes.beU1(bytecode, 4);
2283             if (b4 &gt;= IRETURN &amp;&amp; b4 &lt;= ARETURN) {
2284                 int cpi = Bytes.beU2(bytecode, 2);
2285                 JavaField field = targetMethod.getConstantPool().lookupField(cpi, targetMethod, GETFIELD);
2286                 if (field instanceof ResolvedJavaField) {
2287                     ValueNode receiver = invocationPluginReceiver.init(targetMethod, args).get();
2288                     ResolvedJavaField resolvedField = (ResolvedJavaField) field;
2289                     try (DebugCloseable context = openNodeContext(targetMethod, 1)) {
2290                         genGetField(resolvedField, receiver);
2291                         notifyBeforeInline(targetMethod);
2292                         printInlining(targetMethod, targetMethod, true, &quot;inline accessor method (bytecode parsing)&quot;);
2293                         notifyAfterInline(targetMethod);
2294                     }
2295                     return true;
2296                 }
2297             }
2298         }
2299         return false;
2300     }
2301 
<span class="line-added">2302     /**</span>
<span class="line-added">2303      * Inline a method substitution graph. This is necessary for libgraal as substitutions only</span>
<span class="line-added">2304      * exist as encoded graphs and can&#39;t be parsed directly into the caller.</span>
<span class="line-added">2305      */</span>
<span class="line-added">2306     @Override</span>
<span class="line-added">2307     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-added">2308     public boolean intrinsify(ResolvedJavaMethod targetMethod, StructuredGraph substituteGraph, InvocationPlugin.Receiver receiver, ValueNode[] args) {</span>
<span class="line-added">2309         if (receiver != null) {</span>
<span class="line-added">2310             receiver.get();</span>
<span class="line-added">2311         }</span>
<span class="line-added">2312 </span>
<span class="line-added">2313         InvokeWithExceptionNode withException = null;</span>
<span class="line-added">2314         FixedWithNextNode replacee = lastInstr;</span>
<span class="line-added">2315         try (DebugContext.Scope a = debug.scope(&quot;instantiate&quot;, substituteGraph)) {</span>
<span class="line-added">2316             // Inline the snippet nodes, replacing parameters with the given args in the process</span>
<span class="line-added">2317             StartNode entryPointNode = substituteGraph.start();</span>
<span class="line-added">2318             FixedNode firstCFGNode = entryPointNode.next();</span>
<span class="line-added">2319             StructuredGraph replaceeGraph = replacee.graph();</span>
<span class="line-added">2320             Mark mark = replaceeGraph.getMark();</span>
<span class="line-added">2321             try (InliningScope inlineScope = new IntrinsicScope(this, targetMethod, args)) {</span>
<span class="line-added">2322 </span>
<span class="line-added">2323                 EconomicMap&lt;Node, Node&gt; replacementsMap = EconomicMap.create(Equivalence.IDENTITY);</span>
<span class="line-added">2324                 for (ParameterNode param : substituteGraph.getNodes().filter(ParameterNode.class)) {</span>
<span class="line-added">2325                     replacementsMap.put(param, args[param.index()]);</span>
<span class="line-added">2326                 }</span>
<span class="line-added">2327                 replacementsMap.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));</span>
<span class="line-added">2328 </span>
<span class="line-added">2329                 debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;Before inlining method substitution %s&quot;, substituteGraph.method());</span>
<span class="line-added">2330                 UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineMethodSubstitution(replaceeGraph, substituteGraph, replacementsMap);</span>
<span class="line-added">2331 </span>
<span class="line-added">2332                 FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);</span>
<span class="line-added">2333                 replacee.setNext(firstCFGNodeDuplicate);</span>
<span class="line-added">2334                 debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After inlining method substitution %s&quot;, substituteGraph.method());</span>
<span class="line-added">2335 </span>
<span class="line-added">2336                 // Handle partial intrinsic exits</span>
<span class="line-added">2337                 for (Node node : graph.getNewNodes(mark)) {</span>
<span class="line-added">2338                     if (node instanceof Invoke) {</span>
<span class="line-added">2339                         Invoke invoke = (Invoke) node;</span>
<span class="line-added">2340                         if (invoke.bci() == BytecodeFrame.UNKNOWN_BCI) {</span>
<span class="line-added">2341                             invoke.replaceBci(bci());</span>
<span class="line-added">2342                         }</span>
<span class="line-added">2343                         if (node instanceof InvokeWithExceptionNode) {</span>
<span class="line-added">2344                             // The graphs for MethodSubsitutions are produced assuming that</span>
<span class="line-added">2345                             // exceptions</span>
<span class="line-added">2346                             // must be dispatched. If the calling context doesn&#39;t want exception</span>
<span class="line-added">2347                             // then</span>
<span class="line-added">2348                             // convert back into a normal InvokeNode.</span>
<span class="line-added">2349                             assert withException == null : &quot;only one invoke expected&quot;;</span>
<span class="line-added">2350                             withException = (InvokeWithExceptionNode) node;</span>
<span class="line-added">2351                             BytecodeParser intrinsicCallSiteParser = getNonIntrinsicAncestor();</span>
<span class="line-added">2352                             if (intrinsicCallSiteParser != null &amp;&amp; intrinsicCallSiteParser.getActionForInvokeExceptionEdge(null) == ExceptionEdgeAction.OMIT) {</span>
<span class="line-added">2353                                 InvokeNode newInvoke = graph.add(new InvokeNode(withException));</span>
<span class="line-added">2354                                 newInvoke.setStateDuring(withException.stateDuring());</span>
<span class="line-added">2355                                 newInvoke.setStateAfter(withException.stateAfter());</span>
<span class="line-added">2356                                 withException.killExceptionEdge();</span>
<span class="line-added">2357                                 AbstractBeginNode next = withException.killKillingBegin();</span>
<span class="line-added">2358                                 FixedWithNextNode pred = (FixedWithNextNode) withException.predecessor();</span>
<span class="line-added">2359                                 pred.setNext(newInvoke);</span>
<span class="line-added">2360                                 withException.setNext(null);</span>
<span class="line-added">2361                                 newInvoke.setNext(next);</span>
<span class="line-added">2362                                 withException.replaceAndDelete(newInvoke);</span>
<span class="line-added">2363                             } else {</span>
<span class="line-added">2364                                 // Disconnnect exception edge</span>
<span class="line-added">2365                                 withException.killExceptionEdge();</span>
<span class="line-added">2366                             }</span>
<span class="line-added">2367                         }</span>
<span class="line-added">2368                     } else if (node instanceof ForeignCallNode) {</span>
<span class="line-added">2369                         ForeignCallNode call = (ForeignCallNode) node;</span>
<span class="line-added">2370                         if (call.getBci() == BytecodeFrame.UNKNOWN_BCI) {</span>
<span class="line-added">2371                             call.setBci(bci());</span>
<span class="line-added">2372                             if (call.stateAfter() != null &amp;&amp; call.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {</span>
<span class="line-added">2373                                 call.setStateAfter(inlineScope.stateBefore);</span>
<span class="line-added">2374                             }</span>
<span class="line-added">2375                         }</span>
<span class="line-added">2376                     }</span>
<span class="line-added">2377                 }</span>
<span class="line-added">2378 </span>
<span class="line-added">2379                 ArrayList&lt;ReturnToCallerData&gt; calleeReturnDataList = new ArrayList&lt;&gt;();</span>
<span class="line-added">2380                 for (ReturnNode n : substituteGraph.getNodes().filter(ReturnNode.class)) {</span>
<span class="line-added">2381                     ReturnNode returnNode = (ReturnNode) duplicates.get(n);</span>
<span class="line-added">2382                     FixedWithNextNode predecessor = (FixedWithNextNode) returnNode.predecessor();</span>
<span class="line-added">2383                     calleeReturnDataList.add(new ReturnToCallerData(returnNode.result(), predecessor));</span>
<span class="line-added">2384                     predecessor.setNext(null);</span>
<span class="line-added">2385                     returnNode.safeDelete();</span>
<span class="line-added">2386                 }</span>
<span class="line-added">2387 </span>
<span class="line-added">2388                 // Merge multiple returns</span>
<span class="line-added">2389                 processCalleeReturn(targetMethod, inlineScope, calleeReturnDataList);</span>
<span class="line-added">2390 </span>
<span class="line-added">2391                 // Exiting this scope causes processing of the placeholder frame states.</span>
<span class="line-added">2392             }</span>
<span class="line-added">2393 </span>
<span class="line-added">2394             if (withException != null &amp;&amp; withException.isAlive()) {</span>
<span class="line-added">2395                 // Connect exception edge into main graph</span>
<span class="line-added">2396                 AbstractBeginNode exceptionEdge = handleException(null, bci(), false);</span>
<span class="line-added">2397                 withException.setExceptionEdge(exceptionEdge);</span>
<span class="line-added">2398             }</span>
<span class="line-added">2399 </span>
<span class="line-added">2400             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);</span>
<span class="line-added">2401             return true;</span>
<span class="line-added">2402         } catch (Throwable t) {</span>
<span class="line-added">2403             throw debug.handle(t);</span>
<span class="line-added">2404         }</span>
<span class="line-added">2405     }</span>
<span class="line-added">2406 </span>
<span class="line-added">2407     private static UnmodifiableEconomicMap&lt;Node, Node&gt; inlineMethodSubstitution(StructuredGraph replaceeGraph, StructuredGraph snippet,</span>
<span class="line-added">2408                     EconomicMap&lt;Node, Node&gt; replacementsMap) {</span>
<span class="line-added">2409         try (InliningLog.UpdateScope scope = replaceeGraph.getInliningLog().openUpdateScope((oldNode, newNode) -&gt; {</span>
<span class="line-added">2410             InliningLog log = replaceeGraph.getInliningLog();</span>
<span class="line-added">2411             if (oldNode == null) {</span>
<span class="line-added">2412                 log.trackNewCallsite(newNode);</span>
<span class="line-added">2413             }</span>
<span class="line-added">2414         })) {</span>
<span class="line-added">2415             StartNode entryPointNode = snippet.start();</span>
<span class="line-added">2416             ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(snippet.getNodeCount());</span>
<span class="line-added">2417             for (Node node : snippet.getNodes()) {</span>
<span class="line-added">2418                 if (node != entryPointNode &amp;&amp; node != entryPointNode.stateAfter()) {</span>
<span class="line-added">2419                     nodes.add(node);</span>
<span class="line-added">2420                 }</span>
<span class="line-added">2421             }</span>
<span class="line-added">2422             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = replaceeGraph.addDuplicates(nodes, snippet, snippet.getNodeCount(), replacementsMap);</span>
<span class="line-added">2423             if (scope != null) {</span>
<span class="line-added">2424                 replaceeGraph.getInliningLog().addLog(duplicates, snippet.getInliningLog());</span>
<span class="line-added">2425             }</span>
<span class="line-added">2426             return duplicates;</span>
<span class="line-added">2427         }</span>
<span class="line-added">2428     }</span>
<span class="line-added">2429 </span>
2430     @Override
2431     public boolean intrinsify(BytecodeProvider intrinsicBytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] args) {
2432         if (receiver != null) {
2433             receiver.get();
2434         }
2435         boolean res = inline(targetMethod, substitute, intrinsicBytecodeProvider, args);
2436         assert res : &quot;failed to inline &quot; + substitute;
2437         return res;
2438     }
2439 
2440     private boolean inline(ResolvedJavaMethod targetMethod, ResolvedJavaMethod inlinedMethod, BytecodeProvider intrinsicBytecodeProvider, ValueNode[] args) {
2441         try (InliningLog.RootScope scope = graph.getInliningLog().openRootScope(targetMethod, bci())) {
2442             IntrinsicContext intrinsic = this.intrinsicContext;
2443 
2444             if (intrinsic == null &amp;&amp; !graphBuilderConfig.insertFullInfopoints() &amp;&amp;
2445                             targetMethod.equals(inlinedMethod) &amp;&amp;
2446                             (targetMethod.getModifiers() &amp; (STATIC | SYNCHRONIZED)) == 0 &amp;&amp;
2447                             tryFastInlineAccessor(args, targetMethod)) {
2448                 return true;
2449             }
</pre>
<hr />
<pre>
2451             if (intrinsic != null &amp;&amp; intrinsic.isCallToOriginal(targetMethod)) {
2452                 if (intrinsic.isCompilationRoot()) {
2453                     // A root compiled intrinsic needs to deoptimize
2454                     // if the slow path is taken. During frame state
2455                     // assignment, the deopt node will get its stateBefore
2456                     // from the start node of the intrinsic
2457                     append(new DeoptimizeNode(InvalidateRecompile, RuntimeConstraint));
2458                     printInlining(targetMethod, inlinedMethod, true, &quot;compilation root (bytecode parsing)&quot;);
2459                     if (scope != null) {
2460                         graph.getInliningLog().addDecision(scope.getInvoke(), true, &quot;GraphBuilderPhase&quot;, null, null, &quot;compilation root&quot;);
2461                     }
2462                     return true;
2463                 } else {
2464                     if (intrinsic.getOriginalMethod().isNative()) {
2465                         printInlining(targetMethod, inlinedMethod, false, &quot;native method (bytecode parsing)&quot;);
2466                         if (scope != null) {
2467                             graph.getInliningLog().addDecision(scope.getInvoke(), false, &quot;GraphBuilderPhase&quot;, null, null, &quot;native method&quot;);
2468                         }
2469                         return false;
2470                     }
<span class="line-modified">2471                     if (canInlinePartialIntrinsicExit()) {</span>
2472                         // Otherwise inline the original method. Any frame state created
2473                         // during the inlining will exclude frame(s) in the
2474                         // intrinsic method (see FrameStateBuilder.create(int bci)).
2475                         notifyBeforeInline(inlinedMethod);
2476                         printInlining(targetMethod, inlinedMethod, true, &quot;partial intrinsic exit (bytecode parsing)&quot;);
2477                         if (scope != null) {
2478                             graph.getInliningLog().addDecision(scope.getInvoke(), true, &quot;GraphBuilderPhase&quot;, null, null, &quot;partial intrinsic exit&quot;);
2479                         }
2480                         parseAndInlineCallee(intrinsic.getOriginalMethod(), args, null);
2481                         notifyAfterInline(inlinedMethod);
2482                         return true;
2483                     } else {
2484                         printInlining(targetMethod, inlinedMethod, false, &quot;partial intrinsic exit (bytecode parsing)&quot;);
2485                         if (scope != null) {
2486                             graph.getInliningLog().addDecision(scope.getInvoke(), false, &quot;GraphBuilderPhase&quot;, null, null, &quot;partial intrinsic exit&quot;);
2487                         }
2488                         return false;
2489                     }
2490                 }
2491             } else {
</pre>
<hr />
<pre>
2514         }
2515     }
2516 
2517     protected void notifyBeforeInline(ResolvedJavaMethod inlinedMethod) {
2518         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2519             plugin.notifyBeforeInline(inlinedMethod);
2520         }
2521     }
2522 
2523     protected void notifyAfterInline(ResolvedJavaMethod inlinedMethod) {
2524         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2525             plugin.notifyAfterInline(inlinedMethod);
2526         }
2527     }
2528 
2529     /**
2530      * Determines if a partial intrinsic exit (i.e., a call to the original method within an
2531      * intrinsic) can be inlined.
2532      */
2533     protected boolean canInlinePartialIntrinsicExit() {
<span class="line-modified">2534         return InlinePartialIntrinsicExitDuringParsing.getValue(options) &amp;&amp; !IS_BUILDING_NATIVE_IMAGE &amp;&amp; method.getAnnotation(Snippet.class) == null;</span>
2535     }
2536 
2537     private void printInlining(ResolvedJavaMethod targetMethod, ResolvedJavaMethod inlinedMethod, boolean success, String msg) {
2538         if (success) {
2539             if (TraceInlineDuringParsing.getValue(options) || TraceParserPlugins.getValue(options)) {
2540                 if (targetMethod.equals(inlinedMethod)) {
2541                     traceWithContext(&quot;inlining call to %s&quot;, inlinedMethod.format(&quot;%h.%n(%p)&quot;));
2542                 } else {
2543                     traceWithContext(&quot;inlining call to %s as intrinsic for %s&quot;, inlinedMethod.format(&quot;%h.%n(%p)&quot;), targetMethod.format(&quot;%h.%n(%p)&quot;));
2544                 }
2545             }
2546         }
2547         if (HotSpotPrintInlining.getValue(options)) {
2548             if (targetMethod.equals(inlinedMethod)) {
2549                 Util.printInlining(inlinedMethod, bci(), getDepth(), success, &quot;%s&quot;, msg);
2550             } else {
2551                 Util.printInlining(inlinedMethod, bci(), getDepth(), success, &quot;%s intrinsic for %s&quot;, msg, targetMethod.format(&quot;%h.%n(%p)&quot;));
2552             }
2553         }
2554     }
</pre>
<hr />
<pre>
2574         TTY.println(s);
2575     }
2576 
2577     protected RuntimeException throwParserError(Throwable e) {
2578         if (e instanceof BytecodeParserError) {
2579             throw (BytecodeParserError) e;
2580         }
2581         BytecodeParser bp = this;
2582         BytecodeParserError res = new BytecodeParserError(e);
2583         while (bp != null) {
2584             res.addContext(&quot;parsing &quot; + bp.code.asStackTraceElement(bp.bci()));
2585             bp = bp.parent;
2586         }
2587         throw res;
2588     }
2589 
2590     protected void parseAndInlineCallee(ResolvedJavaMethod targetMethod, ValueNode[] args, IntrinsicContext calleeIntrinsicContext) {
2591         FixedWithNextNode calleeBeforeUnwindNode = null;
2592         ValueNode calleeUnwindValue = null;
2593 
<span class="line-modified">2594         try (InliningScope s = parsingIntrinsic() ? null</span>
<span class="line-added">2595                         : (calleeIntrinsicContext != null ? new IntrinsicScope(this, targetMethod, args)</span>
<span class="line-added">2596                                         : new InliningScope(this, targetMethod, args))) {</span>
2597             BytecodeParser parser = graphBuilderInstance.createBytecodeParser(graph, this, targetMethod, INVOCATION_ENTRY_BCI, calleeIntrinsicContext);
<span class="line-modified">2598             boolean targetIsSubstitution = targetMethod.isAnnotationPresent(MethodSubstitution.class);</span>
<span class="line-added">2599             FrameStateBuilder startFrameState = new FrameStateBuilder(parser, parser.code, graph, graphBuilderConfig.retainLocalVariables() &amp;&amp; !targetIsSubstitution);</span>
2600             if (!targetMethod.isStatic()) {
2601                 args[0] = nullCheckedValue(args[0]);
2602             }
2603             startFrameState.initializeFromArgumentsArray(args);
2604             parser.build(this.lastInstr, startFrameState);
2605 
<span class="line-modified">2606             List&lt;ReturnToCallerData&gt; calleeReturnDataList = parser.returnDataList;</span>



















2607 








2608             /*
2609              * Propagate any side effects into the caller when parsing intrinsics.
2610              */
2611             if (parser.frameState.isAfterSideEffect() &amp;&amp; parsingIntrinsic()) {
2612                 for (StateSplit sideEffect : parser.frameState.sideEffects()) {
2613                     frameState.addSideEffect(sideEffect);
2614                 }
2615             }
2616 
<span class="line-added">2617             processCalleeReturn(targetMethod, s, calleeReturnDataList);</span>
<span class="line-added">2618 </span>
2619             calleeBeforeUnwindNode = parser.getBeforeUnwindNode();
2620             if (calleeBeforeUnwindNode != null) {
2621                 calleeUnwindValue = parser.getUnwindValue();
2622                 assert calleeUnwindValue != null;
2623             }
2624         }
2625 
2626         /*
2627          * Method handleException will call createTarget, which wires this exception edge to the
2628          * corresponding exception dispatch block in the caller. In the case where it wires to the
2629          * caller&#39;s unwind block, any FrameState created meanwhile, e.g., FrameState for
2630          * LoopExitNode, would be instantiated with AFTER_EXCEPTION_BCI. Such frame states should
2631          * not be fixed by IntrinsicScope.close, as they denote the states of the caller. Thus, the
2632          * following code should be placed outside the IntrinsicScope, so that correctly created
2633          * FrameStates are not replaced.
2634          */
2635         if (calleeBeforeUnwindNode != null) {
2636             calleeBeforeUnwindNode.setNext(handleException(calleeUnwindValue, bci(), false));
2637         }
2638     }
2639 
<span class="line-added">2640     private ValueNode processCalleeReturn(ResolvedJavaMethod targetMethod, InliningScope inliningScope, List&lt;ReturnToCallerData&gt; calleeReturnDataList) {</span>
<span class="line-added">2641         if (calleeReturnDataList == null) {</span>
<span class="line-added">2642             /* Callee does not return. */</span>
<span class="line-added">2643             lastInstr = null;</span>
<span class="line-added">2644         } else {</span>
<span class="line-added">2645             ValueNode calleeReturnValue;</span>
<span class="line-added">2646             MergeNode returnMergeNode = null;</span>
<span class="line-added">2647             if (inliningScope != null) {</span>
<span class="line-added">2648                 inliningScope.returnDataList = calleeReturnDataList;</span>
<span class="line-added">2649             }</span>
<span class="line-added">2650             if (calleeReturnDataList.size() == 1) {</span>
<span class="line-added">2651                 /* Callee has a single return, we can continue parsing at that point. */</span>
<span class="line-added">2652                 ReturnToCallerData singleReturnData = calleeReturnDataList.get(0);</span>
<span class="line-added">2653                 lastInstr = singleReturnData.beforeReturnNode;</span>
<span class="line-added">2654                 calleeReturnValue = singleReturnData.returnValue;</span>
<span class="line-added">2655             } else {</span>
<span class="line-added">2656                 assert calleeReturnDataList.size() &gt; 1;</span>
<span class="line-added">2657                 /* Callee has multiple returns, we need to insert a control flow merge. */</span>
<span class="line-added">2658                 returnMergeNode = graph.add(new MergeNode());</span>
<span class="line-added">2659                 calleeReturnValue = ValueMergeUtil.mergeValueProducers(returnMergeNode, calleeReturnDataList, returnData -&gt; returnData.beforeReturnNode, returnData -&gt; returnData.returnValue);</span>
<span class="line-added">2660             }</span>
<span class="line-added">2661 </span>
<span class="line-added">2662             if (calleeReturnValue != null) {</span>
<span class="line-added">2663                 frameState.push(targetMethod.getSignature().getReturnKind().getStackKind(), calleeReturnValue);</span>
<span class="line-added">2664             }</span>
<span class="line-added">2665             if (returnMergeNode != null) {</span>
<span class="line-added">2666                 returnMergeNode.setStateAfter(createFrameState(stream.nextBCI(), returnMergeNode));</span>
<span class="line-added">2667                 lastInstr = finishInstruction(returnMergeNode, frameState);</span>
<span class="line-added">2668             }</span>
<span class="line-added">2669             return calleeReturnValue;</span>
<span class="line-added">2670         }</span>
<span class="line-added">2671         return null;</span>
<span class="line-added">2672     }</span>
<span class="line-added">2673 </span>
2674     public MethodCallTargetNode createMethodCallTarget(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, StampPair returnStamp, JavaTypeProfile profile) {
2675         return new MethodCallTargetNode(invokeKind, targetMethod, args, returnStamp, profile);
2676     }
2677 
2678     protected InvokeNode createInvoke(int invokeBci, CallTargetNode callTarget, JavaKind resultType) {
2679         InvokeNode invoke = append(new InvokeNode(callTarget, invokeBci));
2680         frameState.pushReturn(resultType, invoke);
2681         invoke.setStateAfter(createFrameState(stream.nextBCI(), invoke));
2682         return invoke;
2683     }
2684 
2685     protected InvokeWithExceptionNode createInvokeWithException(int invokeBci, CallTargetNode callTarget, JavaKind resultType, ExceptionEdgeAction exceptionEdgeAction) {
2686         if (currentBlock != null &amp;&amp; stream.nextBCI() &gt; currentBlock.endBci) {
2687             /*
2688              * Clear non-live locals early so that the exception handler entry gets the cleared
2689              * state.
2690              */
2691             frameState.clearNonLiveLocals(currentBlock, liveness, false);
2692         }
2693 
2694         AbstractBeginNode exceptionEdge = handleException(null, bci(), exceptionEdgeAction == ExceptionEdgeAction.INCLUDE_AND_DEOPTIMIZE);
2695         InvokeWithExceptionNode invoke = append(new InvokeWithExceptionNode(callTarget, exceptionEdge, invokeBci));
2696         frameState.pushReturn(resultType, invoke);
2697         invoke.setStateAfter(createFrameState(stream.nextBCI(), invoke));
2698         return invoke;
2699     }
2700 
2701     protected void genReturn(ValueNode returnVal, JavaKind returnKind) {
2702         if (parsingIntrinsic() &amp;&amp; returnVal != null) {
2703 
2704             if (returnVal instanceof StateSplit) {
2705                 StateSplit stateSplit = (StateSplit) returnVal;
2706                 FrameState stateAfter = stateSplit.stateAfter();
2707                 if (stateSplit.hasSideEffect()) {
2708                     assert stateSplit != null;
2709                     if (stateAfter.bci == BytecodeFrame.AFTER_BCI) {
<span class="line-modified">2710                         assert stateAfter.hasExactlyOneUsage();</span>
2711                         assert stateAfter.usages().first() == stateSplit;
2712                         FrameState state;
2713                         if (returnVal.getStackKind() == JavaKind.Illegal) {
2714                             // This should only occur when Fold and NodeIntrinsic plugins are
2715                             // deferred. Their return value might not be a Java type and in that
2716                             // case this can&#39;t be the final AFTER_BCI so just create a FrameState
2717                             // without a return value on the top of stack.
2718                             assert stateSplit instanceof Invoke;
2719                             ResolvedJavaMethod targetMethod = ((Invoke) stateSplit).getTargetMethod();
2720                             assert targetMethod != null &amp;&amp; (targetMethod.getAnnotation(Fold.class) != null || targetMethod.getAnnotation(Node.NodeIntrinsic.class) != null);
2721                             state = new FrameState(BytecodeFrame.AFTER_BCI);
2722                         } else {
2723                             state = new FrameState(BytecodeFrame.AFTER_BCI, returnVal);
2724                         }
2725                         stateAfter.replaceAtUsages(graph.add(state));
2726                         GraphUtil.killWithUnusedFloatingInputs(stateAfter);
2727                     } else {
2728                         /*
2729                          * This must be the return value from within a partial intrinsification.
2730                          */
<span class="line-modified">2731                         assert !BytecodeFrame.isPlaceholderBci(stateAfter.bci) || intrinsicContext.isDeferredInvoke(stateSplit);</span>
2732                     }
2733                 } else {
2734                     assert stateAfter == null;
2735                 }
2736             }
2737         }
2738 
2739         ValueNode realReturnVal = processReturnValue(returnVal, returnKind);
2740 
2741         frameState.setRethrowException(false);
2742         frameState.clearStack();
2743         beforeReturn(realReturnVal, returnKind);
2744         if (parent == null) {
2745             append(new ReturnNode(realReturnVal));
2746         } else {
2747             if (returnDataList == null) {
2748                 returnDataList = new ArrayList&lt;&gt;();
2749             }
2750             returnDataList.add(new ReturnToCallerData(realReturnVal, lastInstr));
2751             lastInstr = null;
</pre>
<hr />
<pre>
2773             /*
2774              * Get the receiver from the initial state since bytecode rewriting could do arbitrary
2775              * things to the state of the locals.
2776              */
2777             ValueNode receiver = graph.start().stateAfter().localAt(0);
2778             assert receiver != null &amp;&amp; receiver.getStackKind() == JavaKind.Object;
2779             if (RegisterFinalizerNode.mayHaveFinalizer(receiver, graph.getAssumptions())) {
2780                 append(new RegisterFinalizerNode(receiver));
2781             }
2782         }
2783         genInfoPointNode(InfopointReason.METHOD_END, x);
2784         if (finalBarrierRequired) {
2785             assert originalReceiver != null;
2786             /*
2787              * When compiling an OSR with a final field store, don&#39;t bother tracking the original
2788              * receiver since the receiver cannot be EA&#39;ed.
2789              */
2790             append(new FinalFieldBarrierNode(entryBCI == INVOCATION_ENTRY_BCI ? originalReceiver : null));
2791         }
2792         synchronizedEpilogue(BytecodeFrame.AFTER_BCI, x, kind);
<span class="line-added">2793         if (method.isSynchronized()) {</span>
<span class="line-added">2794             finishPrepare(lastInstr, BytecodeFrame.AFTER_BCI, frameState);</span>
<span class="line-added">2795         }</span>
2796     }
2797 
2798     protected MonitorEnterNode createMonitorEnterNode(ValueNode x, MonitorIdNode monitorId) {
2799         return new MonitorEnterNode(x, monitorId);
2800     }
2801 
2802     protected void genMonitorEnter(ValueNode x, int bci) {
2803         MonitorIdNode monitorId = graph.add(new MonitorIdNode(frameState.lockDepth(true)));
2804         MonitorEnterNode monitorEnter = append(createMonitorEnterNode(x, monitorId));
2805         frameState.pushLock(x, monitorId);
2806         monitorEnter.setStateAfter(createFrameState(bci, monitorEnter));
2807     }
2808 
<span class="line-modified">2809     protected void genMonitorExit(ValueNode x, ValueNode escapedValue, int bci) {</span>
2810         if (frameState.lockDepth(false) == 0) {
2811             throw bailout(&quot;unbalanced monitors: too many exits&quot;);
2812         }
2813         MonitorIdNode monitorId = frameState.peekMonitorId();
2814         ValueNode lockedObject = frameState.popLock();
<span class="line-modified">2815         ValueNode originalLockedObject = GraphUtil.originalValue(lockedObject, false);</span>
<span class="line-modified">2816         ValueNode originalX = GraphUtil.originalValue(x, false);</span>
<span class="line-added">2817         if (originalLockedObject != originalX) {</span>
<span class="line-added">2818             throw bailout(String.format(&quot;unbalanced monitors: mismatch at monitorexit, %s != %s&quot;, originalLockedObject, originalX));</span>
2819         }
<span class="line-modified">2820         MonitorExitNode monitorExit = append(new MonitorExitNode(lockedObject, monitorId, escapedValue));</span>
2821         monitorExit.setStateAfter(createFrameState(bci, monitorExit));
2822     }
2823 
2824     protected void genJsr(int dest) {
2825         BciBlock successor = currentBlock.getJsrSuccessor();
2826         assert successor.startBci == dest : successor.startBci + &quot; != &quot; + dest + &quot; @&quot; + bci();
2827         JsrScope scope = currentBlock.getJsrScope();
2828         int nextBci = getStream().nextBCI();
2829         if (!successor.getJsrScope().pop().equals(scope)) {
2830             throw new JsrNotSupportedBailout(&quot;unstructured control flow (internal limitation)&quot;);
2831         }
2832         if (successor.getJsrScope().nextReturnAddress() != nextBci) {
2833             throw new JsrNotSupportedBailout(&quot;unstructured control flow (internal limitation)&quot;);
2834         }
2835         ConstantNode nextBciNode = getJsrConstant(nextBci);
2836         frameState.push(JavaKind.Object, nextBciNode);
2837         appendGoto(successor);
2838     }
2839 
2840     protected void genRet(int localIndex) {
2841         BciBlock successor = currentBlock.getRetSuccessor();
2842         ValueNode local = frameState.loadLocal(localIndex, JavaKind.Object);
2843         JsrScope scope = currentBlock.getJsrScope();
2844         int retAddress = scope.nextReturnAddress();
2845         ConstantNode returnBciNode = getJsrConstant(retAddress);
<span class="line-modified">2846         LogicNode guard = IntegerEqualsNode.create(getConstantReflection(), getMetaAccess(), options, null, local, returnBciNode, NodeView.DEFAULT);</span>
<span class="line-modified">2847         if (!guard.isTautology()) {</span>
<span class="line-modified">2848             throw new JsrNotSupportedBailout(&quot;cannot statically decide jsr return address &quot; + local);</span>
<span class="line-added">2849         }</span>
2850         if (!successor.getJsrScope().equals(scope.pop())) {
2851             throw new JsrNotSupportedBailout(&quot;unstructured control flow (ret leaves more than one scope)&quot;);
2852         }
2853         appendGoto(successor);
2854     }
2855 
2856     private ConstantNode getJsrConstant(long bci) {
2857         JavaConstant nextBciConstant = new RawConstant(bci);
2858         Stamp nextBciStamp = StampFactory.forConstant(nextBciConstant);
2859         ConstantNode nextBciNode = new ConstantNode(nextBciConstant, nextBciStamp);
2860         return graph.unique(nextBciNode);
2861     }
2862 
2863     protected void genIntegerSwitch(ValueNode value, ArrayList&lt;BciBlock&gt; actualSuccessors, int[] keys, double[] keyProbabilities, int[] keySuccessors) {
2864         if (value.isConstant()) {
2865             JavaConstant constant = (JavaConstant) value.asConstant();
2866             int constantValue = constant.asInt();
2867             for (int i = 0; i &lt; keys.length; ++i) {
2868                 if (keys[i] == constantValue) {
2869                     appendGoto(actualSuccessors.get(keySuccessors[i]));
</pre>
<hr />
<pre>
2879                 switchNode.setBlockSuccessor(i, createBlockTarget(successorProbabilities[i], actualSuccessors.get(i), frameState));
2880             }
2881         }
2882     }
2883 
2884     /**
2885      * Helper function that sums up the probabilities of all keys that lead to a specific successor.
2886      *
2887      * @return an array of size successorCount with the accumulated probability for each successor.
2888      */
2889     private static double[] successorProbabilites(int successorCount, int[] keySuccessors, double[] keyProbabilities) {
2890         double[] probability = new double[successorCount];
2891         for (int i = 0; i &lt; keySuccessors.length; i++) {
2892             probability[keySuccessors[i]] += keyProbabilities[i];
2893         }
2894         return probability;
2895     }
2896 
2897     protected ConstantNode appendConstant(JavaConstant constant) {
2898         assert constant != null;
<span class="line-modified">2899         return ConstantNode.forConstant(constant, getMetaAccess(), graph);</span>
2900     }
2901 
2902     @Override
2903     public &lt;T extends ValueNode&gt; T append(T v) {
2904         assert !graph.trackNodeSourcePosition() || graph.currentNodeSourcePosition() != null || currentBlock == blockMap.getUnwindBlock() || currentBlock instanceof ExceptionDispatchBlock;
2905         if (v.graph() != null) {
2906             return v;
2907         }
2908         T added = graph.addOrUniqueWithInputs(v);
2909         if (added == v) {
2910             updateLastInstruction(v);
2911         }
2912         return added;
2913     }
2914 
2915     private &lt;T extends ValueNode&gt; void updateLastInstruction(T v) {
2916         if (v instanceof FixedNode) {
2917             FixedNode fixedNode = (FixedNode) v;
2918             if (lastInstr != null) {
2919                 lastInstr.setNext(fixedNode);
2920             }
2921             if (fixedNode instanceof FixedWithNextNode) {
2922                 FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) fixedNode;
2923                 assert fixedWithNextNode.next() == null : &quot;cannot append instruction to instruction which isn&#39;t end&quot;;
2924                 lastInstr = fixedWithNextNode;
2925             } else {
2926                 lastInstr = null;
2927             }
2928         }
2929     }
2930 
<span class="line-modified">2931     private Target checkLoopExit(Target target, BciBlock targetBlock) {</span>
2932         if (currentBlock != null) {
2933             long exits = currentBlock.loops &amp; ~targetBlock.loops;
2934             if (exits != 0) {
2935                 LoopExitNode firstLoopExit = null;
2936                 LoopExitNode lastLoopExit = null;
2937 
2938                 int pos = 0;
2939                 ArrayList&lt;BciBlock&gt; exitLoops = new ArrayList&lt;&gt;(Long.bitCount(exits));
2940                 do {
2941                     long lMask = 1L &lt;&lt; pos;
2942                     if ((exits &amp; lMask) != 0) {
2943                         exitLoops.add(blockMap.getLoopHeader(pos));
2944                         exits &amp;= ~lMask;
2945                     }
2946                     pos++;
2947                 } while (exits != 0);
2948 
2949                 Collections.sort(exitLoops, new Comparator&lt;BciBlock&gt;() {
2950 
2951                     @Override
2952                     public int compare(BciBlock o1, BciBlock o2) {
2953                         return Long.bitCount(o2.loops) - Long.bitCount(o1.loops);
2954                     }
2955                 });
2956 
2957                 int bci = targetBlock.startBci;
2958                 if (targetBlock instanceof ExceptionDispatchBlock) {
2959                     bci = ((ExceptionDispatchBlock) targetBlock).deoptBci;
2960                 }
<span class="line-modified">2961                 FrameStateBuilder newState = target.state.copy();</span>
2962                 for (BciBlock loop : exitLoops) {
2963                     LoopBeginNode loopBegin = (LoopBeginNode) getFirstInstruction(loop);
2964                     LoopExitNode loopExit = graph.add(new LoopExitNode(loopBegin));
2965                     if (lastLoopExit != null) {
2966                         lastLoopExit.setNext(loopExit);
2967                     }
2968                     if (firstLoopExit == null) {
2969                         firstLoopExit = loopExit;
2970                     }
2971                     lastLoopExit = loopExit;
2972                     debug.log(&quot;Target %s Exits %s, scanning framestates...&quot;, targetBlock, loop);
2973                     newState.clearNonLiveLocals(targetBlock, liveness, true);
2974                     newState.insertLoopProxies(loopExit, getEntryState(loop));
2975                     loopExit.setStateAfter(newState.create(bci, loopExit));
2976                 }
2977 
<span class="line-modified">2978                 // Fortify: Suppress Null Dereference false positive</span>
<span class="line-modified">2979                 assert lastLoopExit != null;</span>
<span class="line-added">2980 </span>
<span class="line-added">2981                 if (target.originalEntry == null) {</span>
<span class="line-added">2982                     lastLoopExit.setNext(target.entry);</span>
<span class="line-added">2983                     return new Target(firstLoopExit, newState, target.entry);</span>
<span class="line-added">2984                 } else {</span>
<span class="line-added">2985                     target.originalEntry.replaceAtPredecessor(firstLoopExit);</span>
<span class="line-added">2986                     lastLoopExit.setNext(target.originalEntry);</span>
<span class="line-added">2987                     return new Target(target.entry, newState, target.originalEntry);</span>
<span class="line-added">2988                 }</span>
2989             }
2990         }
<span class="line-modified">2991         return target;</span>
<span class="line-added">2992     }</span>
<span class="line-added">2993 </span>
<span class="line-added">2994     private Target checkUnwind(FixedNode target, BciBlock targetBlock, FrameStateBuilder state) {</span>
<span class="line-added">2995         if (targetBlock != blockMap.getUnwindBlock()) {</span>
<span class="line-added">2996             return new Target(target, state);</span>
<span class="line-added">2997         }</span>
<span class="line-added">2998         FrameStateBuilder newState = state;</span>
<span class="line-added">2999         newState = newState.copy();</span>
<span class="line-added">3000         newState.setRethrowException(false);</span>
<span class="line-added">3001         if (!method.isSynchronized()) {</span>
<span class="line-added">3002             return new Target(target, newState);</span>
<span class="line-added">3003         }</span>
<span class="line-added">3004         FixedWithNextNode originalLast = lastInstr;</span>
<span class="line-added">3005         FrameStateBuilder originalState = frameState;</span>
<span class="line-added">3006         BeginNode holder = new BeginNode();</span>
<span class="line-added">3007         lastInstr = graph.add(holder);</span>
<span class="line-added">3008         frameState = newState;</span>
<span class="line-added">3009         assert frameState.stackSize() == 1;</span>
<span class="line-added">3010         ValueNode exception = frameState.peekObject();</span>
<span class="line-added">3011         synchronizedEpilogue(BytecodeFrame.AFTER_EXCEPTION_BCI, exception, JavaKind.Void);</span>
<span class="line-added">3012         lastInstr.setNext(target);</span>
<span class="line-added">3013 </span>
<span class="line-added">3014         lastInstr = originalLast;</span>
<span class="line-added">3015         frameState = originalState;</span>
<span class="line-added">3016 </span>
<span class="line-added">3017         FixedNode result = holder.next();</span>
<span class="line-added">3018         holder.setNext(null);</span>
<span class="line-added">3019         holder.safeDelete();</span>
<span class="line-added">3020         return new Target(result, newState, target);</span>
3021     }
3022 
3023     private FrameStateBuilder getEntryState(BciBlock block) {
3024         return entryStateArray[block.id];
3025     }
3026 
3027     private void setEntryState(BciBlock block, FrameStateBuilder entryState) {
3028         this.entryStateArray[block.id] = entryState;
3029     }
3030 
3031     private void setFirstInstruction(BciBlock block, FixedWithNextNode firstInstruction) {
3032         this.firstInstructionArray[block.id] = firstInstruction;
3033     }
3034 
3035     private FixedWithNextNode getFirstInstruction(BciBlock block) {
3036         return firstInstructionArray[block.id];
3037     }
3038 
3039     private FixedNode createTarget(double probability, BciBlock block, FrameStateBuilder stateAfter) {
3040         assert probability &gt;= 0 &amp;&amp; probability &lt;= 1.01 : probability;
</pre>
<hr />
<pre>
3045             return createTarget(block, stateAfter);
3046         }
3047     }
3048 
3049     private FixedNode createTarget(BciBlock block, FrameStateBuilder state) {
3050         return createTarget(block, state, false, false);
3051     }
3052 
3053     @SuppressWarnings(&quot;try&quot;)
3054     private FixedNode createTarget(BciBlock block, FrameStateBuilder state, boolean canReuseInstruction, boolean canReuseState) {
3055         assert block != null &amp;&amp; state != null;
3056         assert !block.isExceptionEntry() || state.stackSize() == 1;
3057 
3058         try (DebugCloseable context = openNodeContext(state, block.startBci)) {
3059             if (getFirstInstruction(block) == null) {
3060                 /*
3061                  * This is the first time we see this block as a branch target. Create and return a
3062                  * placeholder that later can be replaced with a MergeNode when we see this block
3063                  * again.
3064                  */
<span class="line-modified">3065                 if (canReuseInstruction &amp;&amp; (block.getPredecessorCount() == 1 || !controlFlowSplit) &amp;&amp; !block.isLoopHeader() &amp;&amp; (currentBlock.loops &amp; ~block.loops) == 0 &amp;&amp;</span>
<span class="line-modified">3066                                 currentBlock.getJsrScope() == block.getJsrScope()) {</span>
<span class="line-added">3067                     /*</span>
<span class="line-added">3068                      * If we know that no BeginNode is necessary, then we can avoid allocating and</span>
<span class="line-added">3069                      * later removing that node. This is strictly a performance optimization:</span>
<span class="line-added">3070                      * unnecessary BeginNode are allowed and will be removed later on. We need to be</span>
<span class="line-added">3071                      * careful though because the predecessor information is not always enough: when</span>
<span class="line-added">3072                      * the loop level changes, we always need a BeginNode. Also, JSR scope changes</span>
<span class="line-added">3073                      * required a BeginNode because the predecessors coming from RET bytecodes are</span>
<span class="line-added">3074                      * not reflected in the predecessor count.</span>
<span class="line-added">3075                      */</span>
3076                     setFirstInstruction(block, lastInstr);
3077                     lastInstr = null;
3078                 } else {
3079                     setFirstInstruction(block, graph.add(new BeginNode()));
3080                 }
<span class="line-modified">3081                 Target target = checkUnwind(getFirstInstruction(block), block, state);</span>
<span class="line-modified">3082                 target = checkLoopExit(target, block);</span>
<span class="line-modified">3083                 FixedNode result = target.entry;</span>
3084                 FrameStateBuilder currentEntryState = target.state == state ? (canReuseState ? state : state.copy()) : target.state;
3085                 setEntryState(block, currentEntryState);
3086                 currentEntryState.clearNonLiveLocals(block, liveness, true);
3087 
<span class="line-modified">3088                 debug.log(&quot;createTarget %s: first visit, result: %s&quot;, block, result);</span>
3089                 return result;
3090             }
3091 





3092             if (getFirstInstruction(block) instanceof LoopBeginNode) {
3093                 assert (block.isLoopHeader() &amp;&amp; currentBlock.getId() &gt;= block.getId()) : &quot;must be backward branch&quot;;
3094                 /*
3095                  * Backward loop edge. We need to create a special LoopEndNode and merge with the
3096                  * loop begin node created before.
3097                  */
3098                 LoopBeginNode loopBegin = (LoopBeginNode) getFirstInstruction(block);
3099                 LoopEndNode loopEnd = graph.add(new LoopEndNode(loopBegin));
<span class="line-modified">3100                 Target target = checkLoopExit(new Target(loopEnd, state), block);</span>
<span class="line-modified">3101                 FixedNode result = target.entry;</span>
3102                 getEntryState(block).merge(loopBegin, target.state);
3103 
3104                 debug.log(&quot;createTarget %s: merging backward branch to loop header %s, result: %s&quot;, block, loopBegin, result);
3105                 return result;
3106             }
3107             assert currentBlock == null || currentBlock.getId() &lt; block.getId() : &quot;must not be backward branch&quot;;
3108             assert getFirstInstruction(block).next() == null : &quot;bytecodes already parsed for block&quot;;
3109 
3110             if (getFirstInstruction(block) instanceof AbstractBeginNode &amp;&amp; !(getFirstInstruction(block) instanceof AbstractMergeNode)) {
3111                 /*
3112                  * This is the second time we see this block. Create the actual MergeNode and the
3113                  * End Node for the already existing edge.
3114                  */
3115                 AbstractBeginNode beginNode = (AbstractBeginNode) getFirstInstruction(block);
3116 
3117                 // The EndNode for the already existing edge.
3118                 EndNode end = graph.add(new EndNode());
3119                 // The MergeNode that replaces the placeholder.
3120                 AbstractMergeNode mergeNode = graph.add(new MergeNode());
3121                 FixedNode next = beginNode.next();
3122 
3123                 if (beginNode.predecessor() instanceof ControlSplitNode) {
3124                     beginNode.setNext(end);
3125                 } else {
3126                     beginNode.replaceAtPredecessor(end);
3127                     beginNode.safeDelete();
3128                 }
3129 
3130                 mergeNode.addForwardEnd(end);
3131                 mergeNode.setNext(next);
3132 
3133                 setFirstInstruction(block, mergeNode);
3134             }
3135 
3136             AbstractMergeNode mergeNode = (AbstractMergeNode) getFirstInstruction(block);
3137 
3138             // The EndNode for the newly merged edge.
3139             EndNode newEnd = graph.add(new EndNode());
<span class="line-modified">3140             Target target = checkLoopExit(checkUnwind(newEnd, block, state), block);</span>
<span class="line-modified">3141             FixedNode result = target.entry;</span>
3142             getEntryState(block).merge(mergeNode, target.state);
3143             mergeNode.addForwardEnd(newEnd);
3144 
3145             debug.log(&quot;createTarget %s: merging state, result: %s&quot;, block, result);
3146             return result;
3147         }
3148     }
3149 
3150     /**
3151      * Returns a block begin node with the specified state. If the specified probability is 0, the
3152      * block deoptimizes immediately.
3153      */
3154     private AbstractBeginNode createBlockTarget(double probability, BciBlock block, FrameStateBuilder stateAfter) {
3155         FixedNode target = createTarget(probability, block, stateAfter);
3156         AbstractBeginNode begin = BeginNode.begin(target);
3157 
3158         assert !(target instanceof DeoptimizeNode &amp;&amp; begin instanceof BeginStateSplitNode &amp;&amp;
3159                         ((BeginStateSplitNode) begin).stateAfter() != null) : &quot;We are not allowed to set the stateAfter of the begin node,&quot; +
3160                                         &quot; because we have to deoptimize to a bci _before_ the actual if, so that the interpreter can update the profiling information.&quot;;
3161         return begin;
</pre>
<hr />
<pre>
3186 
3187             if (block != blockMap.getUnwindBlock() &amp;&amp; !(block instanceof ExceptionDispatchBlock)) {
3188                 frameState.setRethrowException(false);
3189             }
3190 
3191             if (firstInstruction instanceof AbstractMergeNode) {
3192                 setMergeStateAfter(block, firstInstruction);
3193             }
3194 
3195             if (block == blockMap.getUnwindBlock()) {
3196                 handleUnwindBlock((ExceptionDispatchBlock) block);
3197             } else if (block instanceof ExceptionDispatchBlock) {
3198                 createExceptionDispatch((ExceptionDispatchBlock) block);
3199             } else {
3200                 iterateBytecodesForBlock(block);
3201             }
3202         }
3203     }
3204 
3205     private void handleUnwindBlock(ExceptionDispatchBlock block) {
<span class="line-added">3206         if (frameState.lockDepth(false) != 0) {</span>
<span class="line-added">3207             throw bailout(&quot;unbalanced monitors: too few exits exiting frame&quot;);</span>
<span class="line-added">3208         }</span>
<span class="line-added">3209         assert !frameState.rethrowException();</span>
<span class="line-added">3210         finishPrepare(lastInstr, block.deoptBci, frameState);</span>
3211         if (parent == null) {


3212             createUnwind();
3213         } else {
<span class="line-modified">3214             this.unwindValue = frameState.pop(JavaKind.Object);</span>

3215             this.beforeUnwindNode = this.lastInstr;
3216         }
3217     }
3218 
3219     private void setMergeStateAfter(BciBlock block, FixedWithNextNode firstInstruction) {
3220         AbstractMergeNode abstractMergeNode = (AbstractMergeNode) firstInstruction;
3221         if (abstractMergeNode.stateAfter() == null) {
3222             int bci = block.startBci;
3223             if (block instanceof ExceptionDispatchBlock) {
3224                 bci = ((ExceptionDispatchBlock) block).deoptBci;
3225             }
3226             abstractMergeNode.setStateAfter(createFrameState(bci, abstractMergeNode));
3227         }
3228     }
3229 
3230     @SuppressWarnings(&quot;try&quot;)
3231     private void createUnwind() {
3232         assert frameState.stackSize() == 1 : frameState;

3233         try (DebugCloseable context = openNodeContext(frameState, BytecodeFrame.UNWIND_BCI)) {
3234             ValueNode exception = frameState.pop(JavaKind.Object);
3235             append(new UnwindNode(exception));
3236         }
3237     }
3238 
3239     @SuppressWarnings(&quot;try&quot;)
3240     private void synchronizedEpilogue(int bci, ValueNode currentReturnValue, JavaKind currentReturnValueKind) {
3241         try (DebugCloseable context = openNodeContext(frameState, bci)) {
3242             if (method.isSynchronized()) {
<span class="line-modified">3243                 if (currentReturnValueKind != JavaKind.Void) {</span>
<span class="line-added">3244                     // we are making a state that should look like the state after the return:</span>
<span class="line-added">3245                     // push the return value on the stack</span>
3246                     frameState.push(currentReturnValueKind, currentReturnValue);
3247                 }
3248                 genMonitorExit(methodSynchronizedObject, currentReturnValue, bci);
3249                 assert !frameState.rethrowException();

3250             }
3251             if (frameState.lockDepth(false) != 0) {
3252                 throw bailout(&quot;unbalanced monitors: too few exits exiting frame&quot;);
3253             }
3254         }
3255     }
3256 
3257     @SuppressWarnings(&quot;try&quot;)
3258     private void createExceptionDispatch(ExceptionDispatchBlock block) {
3259         try (DebugCloseable context = openNodeContext(frameState, BytecodeFrame.AFTER_EXCEPTION_BCI)) {
3260             lastInstr = finishInstruction(lastInstr, frameState);
3261 
3262             assert frameState.stackSize() == 1 : frameState;
3263             if (block.handler.isCatchAll()) {
3264                 assert block.getSuccessorCount() == 1;
3265                 appendGoto(block.getSuccessor(0));
3266                 return;
3267             }
3268 
3269             JavaType catchType = block.handler.getCatchType();
</pre>
<hr />
<pre>
3311         }
3312     }
3313 
3314     private void appendGoto(BciBlock successor) {
3315         FixedNode targetInstr = createTarget(successor, frameState, true, true);
3316         if (lastInstr != null &amp;&amp; lastInstr != targetInstr) {
3317             lastInstr.setNext(targetInstr);
3318         }
3319     }
3320 
3321     @SuppressWarnings(&quot;try&quot;)
3322     protected void iterateBytecodesForBlock(BciBlock block) {
3323         if (block.isLoopHeader()) {
3324             // Create the loop header block, which later will merge the backward branches of
3325             // the loop.
3326             controlFlowSplit = true;
3327             LoopBeginNode loopBegin = appendLoopBegin(this.lastInstr, block.startBci);
3328             lastInstr = loopBegin;
3329 
3330             // Create phi functions for all local variables and operand stack slots.
<span class="line-modified">3331             frameState.insertLoopPhis(liveness, block.loopId, loopBegin, forceLoopPhis() || this.graphBuilderConfig.replaceLocalsWithConstants(), stampFromValueForForcedPhis());</span>
3332             loopBegin.setStateAfter(createFrameState(block.startBci, loopBegin));
3333 
3334             /*
3335              * We have seen all forward branches. All subsequent backward branches will merge to the
3336              * loop header. This ensures that the loop header has exactly one non-loop predecessor.
3337              */
3338             setFirstInstruction(block, loopBegin);
3339             /*
3340              * We need to preserve the frame state builder of the loop header so that we can merge
3341              * values for phi functions, so make a copy of it.
3342              */
3343             setEntryState(block, frameState.copy());
3344 
3345             debug.log(&quot;  created loop header %s&quot;, loopBegin);
3346         } else if (lastInstr instanceof MergeNode) {
3347             /*
3348              * All inputs of non-loop phi nodes are known by now. We can infer the stamp for the
3349              * phi, so that parsing continues with more precise type information.
3350              */
3351             frameState.inferPhiStamps((AbstractMergeNode) lastInstr);
</pre>
<hr />
<pre>
3526             b = x;
3527         }
3528         if (canonicalizedCondition.mustNegate()) {
3529             trueSuccessor = falseBlock;
3530             falseSuccessor = trueBlock;
3531         }
3532 
3533         // Create the logic node for the condition.
3534         LogicNode condition = createLogicNode(canonicalizedCondition.getCanonicalCondition(), a, b);
3535 
3536         double probability = -1;
3537         if (condition instanceof IntegerEqualsNode) {
3538             probability = extractInjectedProbability((IntegerEqualsNode) condition);
3539             // the probability coming from here is about the actual condition
3540         }
3541 
3542         if (probability == -1) {
3543             probability = getProfileProbability(canonicalizedCondition.mustNegate());
3544         }
3545 

3546         genIf(condition, trueSuccessor, falseSuccessor, probability);
3547     }
3548 
3549     protected double getProfileProbability(boolean negate) {
3550         if (profilingInfo == null) {
3551             return 0.5;
3552         }
3553 
3554         assert assertAtIfBytecode();
3555         double probability = profilingInfo.getBranchTakenProbability(bci());
3556 
3557         if (probability &lt; 0) {
3558             assert probability == -1 : &quot;invalid probability&quot;;
3559             debug.log(&quot;missing probability in %s at bci %d&quot;, code, bci());
3560             return 0.5;
3561         }
3562 
3563         if (negate &amp;&amp; shouldComplementProbability()) {
3564             // the probability coming from profile is about the original condition
3565             probability = 1 - probability;
3566         }
<span class="line-modified">3567         return clampProbability(probability);</span>
3568     }
3569 
<span class="line-modified">3570     private double extractInjectedProbability(IntegerEqualsNode condition) {</span>
3571         // Propagate injected branch probability if any.
3572         IntegerEqualsNode equalsNode = condition;
3573         BranchProbabilityNode probabilityNode = null;
3574         ValueNode other = null;
3575         if (equalsNode.getX() instanceof BranchProbabilityNode) {
3576             probabilityNode = (BranchProbabilityNode) equalsNode.getX();
3577             other = equalsNode.getY();
3578         } else if (equalsNode.getY() instanceof BranchProbabilityNode) {
3579             probabilityNode = (BranchProbabilityNode) equalsNode.getY();
3580             other = equalsNode.getX();
3581         }
3582 
3583         if (probabilityNode != null &amp;&amp; probabilityNode.getProbability().isConstant() &amp;&amp; other != null &amp;&amp; other.isConstant()) {
<span class="line-modified">3584             double probabilityValue = clampProbability(probabilityNode.getProbability().asJavaConstant().asDouble());</span>
3585             return other.asJavaConstant().asInt() == 0 ? 1.0 - probabilityValue : probabilityValue;
3586         }
3587         return -1;
3588     }
3589 
3590     protected void genIf(LogicNode conditionInput, BciBlock trueBlockInput, BciBlock falseBlockInput, double probabilityInput) {
3591         BciBlock trueBlock = trueBlockInput;
3592         BciBlock falseBlock = falseBlockInput;
3593         LogicNode condition = conditionInput;
3594         double probability = probabilityInput;
3595         FrameState stateBefore = null;
3596         ProfilingPlugin profilingPlugin = this.graphBuilderConfig.getPlugins().getProfilingPlugin();
3597         if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3598             stateBefore = createCurrentFrameState();
3599         }
3600 
3601         // Remove a logic negation node.
3602         if (condition instanceof LogicNegationNode) {
3603             LogicNegationNode logicNegationNode = (LogicNegationNode) condition;
3604             BciBlock tmpBlock = trueBlock;
</pre>
<hr />
<pre>
3634                 if (graph.trackNodeSourcePosition()) {
3635                     survivingSuccessorPosition = new NodeSourcePosition(currentPosition.getCaller(), currentPosition.getMethod(), noDeoptBlock.startBci);
3636                 }
3637                 boolean negated = deoptBlock == trueBlock;
3638                 if (!isPotentialCountedLoopExit(condition, deoptBlock)) {
3639                     if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3640                         profilingPlugin.profileGoto(this, method, bci(), noDeoptBlock.startBci, stateBefore);
3641                     }
3642                     append(new FixedGuardNode(condition, UnreachedCode, InvalidateReprofile, negated, survivingSuccessorPosition));
3643                     appendGoto(noDeoptBlock);
3644                 } else {
3645                     this.controlFlowSplit = true;
3646                     FixedNode noDeoptSuccessor = createTarget(noDeoptBlock, frameState, false, true);
3647                     DeoptimizeNode deopt = graph.add(new DeoptimizeNode(InvalidateReprofile, UnreachedCode));
3648                     /*
3649                      * We do not want to `checkLoopExit` here: otherwise the deopt will go to the
3650                      * deoptBlock&#39;s BCI, skipping the branch in the interpreter, and the profile
3651                      * will never see that the branch is taken. This can lead to deopt loops or OSR
3652                      * failure.
3653                      */
<span class="line-added">3654                     double calculatedProbability = negated ? BranchProbabilityNode.DEOPT_PROBABILITY : 1.0 - BranchProbabilityNode.DEOPT_PROBABILITY;</span>
3655                     FixedNode deoptSuccessor = BeginNode.begin(deopt);
<span class="line-modified">3656                     ValueNode ifNode = genIfNode(condition, negated ? deoptSuccessor : noDeoptSuccessor, negated ? noDeoptSuccessor : deoptSuccessor, calculatedProbability);</span>
3657                     postProcessIfNode(ifNode);
3658                     append(ifNode);
3659                 }
3660                 return;
3661             }
3662 
3663             if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3664                 profilingPlugin.profileIf(this, method, bci(), condition, trueBlock.startBci, falseBlock.startBci, stateBefore);
3665             }
3666 
3667             int oldBci = stream.currentBCI();
3668             int trueBlockInt = checkPositiveIntConstantPushed(trueBlock);
3669             if (trueBlockInt != -1) {
3670                 int falseBlockInt = checkPositiveIntConstantPushed(falseBlock);
3671                 if (falseBlockInt != -1) {
3672                     if (tryGenConditionalForIf(trueBlock, falseBlock, condition, oldBci, trueBlockInt, falseBlockInt)) {
3673                         return;
3674                     }
3675                 }
3676             }
3677 
3678             this.controlFlowSplit = true;
<span class="line-modified">3679             FixedNode falseSuccessor = createTarget(falseBlock, frameState, false, false);</span>
<span class="line-modified">3680             FixedNode trueSuccessor = createTarget(trueBlock, frameState, false, true);</span>
<span class="line-added">3681 </span>
<span class="line-added">3682             if (this.graphBuilderConfig.replaceLocalsWithConstants() &amp;&amp; condition instanceof CompareNode) {</span>
<span class="line-added">3683                 CompareNode compareNode = (CompareNode) condition;</span>
<span class="line-added">3684                 if (compareNode.condition() == CanonicalCondition.EQ) {</span>
<span class="line-added">3685                     ValueNode constantNode = null;</span>
<span class="line-added">3686                     ValueNode nonConstantNode = null;</span>
<span class="line-added">3687                     if (compareNode.getX() instanceof ConstantNode) {</span>
<span class="line-added">3688                         constantNode = compareNode.getX();</span>
<span class="line-added">3689                         nonConstantNode = compareNode.getY();</span>
<span class="line-added">3690                     } else if (compareNode.getY() instanceof ConstantNode) {</span>
<span class="line-added">3691                         constantNode = compareNode.getY();</span>
<span class="line-added">3692                         nonConstantNode = compareNode.getX();</span>
<span class="line-added">3693                     }</span>
<span class="line-added">3694 </span>
<span class="line-added">3695                     if (constantNode != null &amp;&amp; nonConstantNode != null) {</span>
<span class="line-added">3696                         this.getEntryState(trueBlock).replaceValue(nonConstantNode, constantNode);</span>
<span class="line-added">3697                     }</span>
<span class="line-added">3698                 }</span>
<span class="line-added">3699             }</span>
<span class="line-added">3700 </span>
3701             ValueNode ifNode = genIfNode(condition, trueSuccessor, falseSuccessor, probability);
3702             postProcessIfNode(ifNode);
3703             append(ifNode);
3704         }
3705     }
3706 
3707     public boolean isPotentialCountedLoopExit(LogicNode condition, BciBlock target) {
3708         if (currentBlock != null) {
3709             long exits = currentBlock.loops &amp; ~target.loops;
3710             if (exits != 0) {
3711                 return condition instanceof CompareNode;
3712             }
3713         }
3714         return false;
3715     }
3716 
3717     /**
3718      * Hook for subclasses to decide whether the IfNode probability should be complemented during
3719      * conversion to Graal IR.
3720      */
</pre>
<hr />
<pre>
3814     }
3815 
3816     private boolean gotoOrFallThroughAfterConstant(BciBlock block) {
3817         stream.setBCI(block.startBci);
3818         int currentBCI = stream.nextBCI();
3819         stream.setBCI(currentBCI);
3820         int currentBC = stream.currentBC();
3821         return stream.currentBCI() &gt; block.endBci || currentBC == Bytecodes.GOTO || currentBC == Bytecodes.GOTO_W;
3822     }
3823 
3824     private boolean returnAfterConstant(BciBlock block) {
3825         stream.setBCI(block.startBci);
3826         int currentBCI = stream.nextBCI();
3827         stream.setBCI(currentBCI);
3828         int currentBC = stream.currentBC();
3829         return currentBC == Bytecodes.IRETURN;
3830     }
3831 
3832     @Override
3833     public StampProvider getStampProvider() {
<span class="line-modified">3834         return providers.getStampProvider();</span>
3835     }
3836 
3837     @Override
3838     public MetaAccessProvider getMetaAccess() {
<span class="line-modified">3839         return providers.getMetaAccess();</span>
<span class="line-added">3840     }</span>
<span class="line-added">3841 </span>
<span class="line-added">3842     @Override</span>
<span class="line-added">3843     public Replacements getReplacements() {</span>
<span class="line-added">3844         return providers.getReplacements();</span>
3845     }
3846 
3847     @Override
3848     public void push(JavaKind slotKind, ValueNode value) {
3849         assert value.isAlive();
3850         frameState.push(slotKind, value);
3851     }
3852 
3853     @Override
3854     public ValueNode pop(JavaKind slotKind) {
3855         return frameState.pop(slotKind);
3856     }
3857 
3858     @Override
3859     public ConstantReflectionProvider getConstantReflection() {
<span class="line-modified">3860         return providers.getConstantReflection();</span>
3861     }
3862 
3863     @Override
3864     public ConstantFieldProvider getConstantFieldProvider() {
<span class="line-modified">3865         return providers.getConstantFieldProvider();</span>
3866     }
3867 
3868     /**
3869      * Gets the graph being processed by this builder.
3870      */
3871     @Override
3872     public StructuredGraph getGraph() {
3873         return graph;
3874     }
3875 
3876     @Override
3877     public BytecodeParser getParent() {
3878         return parent;
3879     }
3880 
3881     @Override
3882     public IntrinsicContext getIntrinsic() {
3883         return intrinsicContext;
3884     }
3885 
</pre>
<hr />
<pre>
3892             if (bp != this) {
3893                 fmt.format(&quot;%n%s&quot;, indent);
3894             }
3895             fmt.format(&quot;%s [bci: %d, intrinsic: %s]&quot;, bp.code.asStackTraceElement(bp.bci()), bp.bci(), bp.parsingIntrinsic());
3896             fmt.format(&quot;%n%s&quot;, new BytecodeDisassembler().disassemble(bp.code, bp.bci(), bp.bci() + 10));
3897             bp = bp.parent;
3898             indent += &quot; &quot;;
3899         }
3900         return fmt.toString();
3901     }
3902 
3903     @Override
3904     public BailoutException bailout(String string) {
3905         FrameState currentFrameState = createFrameState(bci(), null);
3906         StackTraceElement[] elements = GraphUtil.approxSourceStackTraceElement(currentFrameState);
3907         BailoutException bailout = new PermanentBailoutException(string);
3908         throw GraphUtil.createBailoutException(string, bailout, elements);
3909     }
3910 
3911     private FrameState createFrameState(int bci, StateSplit forStateSplit) {
<span class="line-added">3912         assert !(forStateSplit instanceof BytecodeExceptionNode);</span>
3913         if (currentBlock != null &amp;&amp; bci &gt; currentBlock.endBci) {
3914             frameState.clearNonLiveLocals(currentBlock, liveness, false);
3915         }
3916         return frameState.create(bci, forStateSplit);
3917     }
3918 
<span class="line-added">3919     private FrameState createBytecodeExceptionFrameState(int bci, BytecodeExceptionNode bytecodeException) {</span>
<span class="line-added">3920         FrameStateBuilder copy = frameState.copy();</span>
<span class="line-added">3921         copy.clearStack();</span>
<span class="line-added">3922         if (currentBlock != null) {</span>
<span class="line-added">3923             copy.clearNonLiveLocals(currentBlock, liveness, false);</span>
<span class="line-added">3924         }</span>
<span class="line-added">3925         copy.setRethrowException(true);</span>
<span class="line-added">3926         copy.push(JavaKind.Object, bytecodeException);</span>
<span class="line-added">3927         return copy.create(bci, bytecodeException);</span>
<span class="line-added">3928     }</span>
<span class="line-added">3929 </span>
3930     @Override
3931     public void setStateAfter(StateSplit sideEffect) {
3932         assert sideEffect.hasSideEffect() || sideEffect instanceof AbstractMergeNode;
3933         FrameState stateAfter = createFrameState(stream.nextBCI(), sideEffect);
3934         sideEffect.setStateAfter(stateAfter);
3935     }
3936 
3937     protected NodeSourcePosition createBytecodePosition() {
3938         NodeSourcePosition bytecodePosition = frameState.createBytecodePosition(bci());
3939         return bytecodePosition;
3940     }
3941 
3942     public void setCurrentFrameState(FrameStateBuilder frameState) {
3943         this.frameState = frameState;
3944     }
3945 
3946     protected final BytecodeStream getStream() {
3947         return stream;
3948     }
3949 
</pre>
<hr />
<pre>
3982         Object con = lookupConstant(cpi, opcode);
3983 
3984         if (con instanceof JavaType) {
3985             // this is a load of class constant which might be unresolved
3986             JavaType type = (JavaType) con;
3987             if (typeIsResolved(type)) {
3988                 frameState.push(JavaKind.Object, appendConstant(getConstantReflection().asJavaClass((ResolvedJavaType) type)));
3989             } else {
3990                 handleUnresolvedLoadConstant(type);
3991             }
3992         } else if (con instanceof JavaConstant) {
3993             JavaConstant constant = (JavaConstant) con;
3994             frameState.push(constant.getJavaKind(), appendConstant(constant));
3995         } else {
3996             throw new Error(&quot;lookupConstant returned an object of incorrect type&quot;);
3997         }
3998     }
3999 
4000     private JavaKind refineComponentType(ValueNode array, JavaKind kind) {
4001         if (kind == JavaKind.Byte) {
<span class="line-modified">4002             JavaType type = array.stamp(NodeView.DEFAULT).javaType(getMetaAccess());</span>
4003             if (type.isArray()) {
4004                 JavaType componentType = type.getComponentType();
4005                 if (componentType != null) {
4006                     JavaKind refinedKind = componentType.getJavaKind();
4007                     assert refinedKind == JavaKind.Byte || refinedKind == JavaKind.Boolean;
4008                     return refinedKind;
4009                 }
4010             }
4011         }
4012         return kind;
4013     }
4014 
4015     private void genLoadIndexed(JavaKind kind) {
4016         ValueNode index = frameState.pop(JavaKind.Int);
4017         ValueNode array = frameState.pop(JavaKind.Object);
4018 
4019         array = maybeEmitExplicitNullCheck(array);
4020         GuardingNode boundsCheck = maybeEmitExplicitBoundsCheck(array, index);
4021 
4022         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
</pre>
<hr />
<pre>
4147         ValueNode v;
4148         switch (opcode) {
4149             case IAND:
4150             case LAND:
4151                 v = genAnd(x, y);
4152                 break;
4153             case IOR:
4154             case LOR:
4155                 v = genOr(x, y);
4156                 break;
4157             case IXOR:
4158             case LXOR:
4159                 v = genXor(x, y);
4160                 break;
4161             default:
4162                 throw shouldNotReachHere();
4163         }
4164         frameState.push(kind, append(v));
4165     }
4166 
<span class="line-modified">4167     private void genFloatCompareOp(JavaKind kind, boolean isUnorderedLess) {</span>
4168         ValueNode y = frameState.pop(kind);
4169         ValueNode x = frameState.pop(kind);
4170         frameState.push(JavaKind.Int, append(genNormalizeCompare(x, y, isUnorderedLess)));
4171     }
4172 
<span class="line-added">4173     private void genIntegerCompareOp(JavaKind kind) {</span>
<span class="line-added">4174         ValueNode y = frameState.pop(kind);</span>
<span class="line-added">4175         ValueNode x = frameState.pop(kind);</span>
<span class="line-added">4176         frameState.push(JavaKind.Int, append(genIntegerNormalizeCompare(x, y)));</span>
<span class="line-added">4177     }</span>
<span class="line-added">4178 </span>
4179     private void genFloatConvert(FloatConvert op, JavaKind from, JavaKind to) {
4180         ValueNode input = frameState.pop(from);
4181         frameState.push(to, append(genFloatConvert(op, input)));
4182     }
4183 
4184     private void genSignExtend(JavaKind from, JavaKind to) {
4185         ValueNode input = frameState.pop(from);
4186         if (from != from.getStackKind()) {
4187             input = append(genNarrow(input, from.getBitCount()));
4188         }
4189         frameState.push(to, append(genSignExtend(input, to.getBitCount())));
4190     }
4191 
4192     private void genZeroExtend(JavaKind from, JavaKind to) {
4193         ValueNode input = frameState.pop(from);
4194         if (from != from.getStackKind()) {
4195             input = append(genNarrow(input, from.getBitCount()));
4196         }
4197         frameState.push(to, append(genZeroExtend(input, to.getBitCount())));
4198     }
</pre>
<hr />
<pre>
4231     private static void initialize(ResolvedJavaType resolvedType) {
4232         /*
4233          * Since we&#39;re potentially triggering class initialization here, we need synchronization to
4234          * mitigate the potential for class initialization related deadlock being caused by the
4235          * compiler (e.g., https://github.com/graalvm/graal-core/pull/232/files#r90788550).
4236          */
4237         synchronized (BytecodeParser.class) {
4238             resolvedType.initialize();
4239         }
4240     }
4241 
4242     protected JavaType lookupType(int cpi, int bytecode) {
4243         maybeEagerlyResolve(cpi, bytecode);
4244         JavaType result = constantPool.lookupType(cpi, bytecode);
4245         assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaType;
4246         return result;
4247     }
4248 
4249     private String unresolvedMethodAssertionMessage(JavaMethod result) {
4250         String message = result.format(&quot;%H.%n(%P)%R&quot;);
<span class="line-modified">4251         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
4252             JavaType declaringClass = result.getDeclaringClass();
4253             String className = declaringClass.getName();
4254             switch (className) {
4255                 case &quot;Ljava/nio/ByteBuffer;&quot;:
4256                 case &quot;Ljava/nio/ShortBuffer;&quot;:
4257                 case &quot;Ljava/nio/CharBuffer;&quot;:
4258                 case &quot;Ljava/nio/IntBuffer;&quot;:
4259                 case &quot;Ljava/nio/LongBuffer;&quot;:
4260                 case &quot;Ljava/nio/FloatBuffer;&quot;:
4261                 case &quot;Ljava/nio/DoubleBuffer;&quot;:
4262                 case &quot;Ljava/nio/MappedByteBuffer;&quot;: {
4263                     switch (result.getName()) {
4264                         case &quot;position&quot;:
4265                         case &quot;limit&quot;:
4266                         case &quot;mark&quot;:
4267                         case &quot;reset&quot;:
4268                         case &quot;clear&quot;:
4269                         case &quot;flip&quot;:
4270                         case &quot;rewind&quot;: {
4271                             String returnType = result.getSignature().getReturnType(null).toJavaName();
4272                             if (returnType.equals(declaringClass.toJavaName())) {
4273                                 message += String.format(&quot; [Probably cause: %s was compiled with javac from JDK 9+ using &quot; +
4274                                                 &quot;`-target 8` and `-source 8` options. See https://bugs.openjdk.java.net/browse/JDK-4774077 for details.]&quot;, method.getDeclaringClass().toClassName());
4275                             }
4276                         }
4277                     }
4278                     break;
4279                 }
4280             }
4281         }
4282         return message;
4283     }
4284 
4285     private JavaMethod lookupMethod(int cpi, int opcode) {
4286         maybeEagerlyResolve(cpi, opcode);
<span class="line-modified">4287         JavaMethod result = lookupMethodInPool(cpi, opcode);</span>
4288         assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaMethod : unresolvedMethodAssertionMessage(result);
4289         return result;
4290     }
4291 
<span class="line-added">4292     protected JavaMethod lookupMethodInPool(int cpi, int opcode) {</span>
<span class="line-added">4293         return constantPool.lookupMethod(cpi, opcode);</span>
<span class="line-added">4294     }</span>
<span class="line-added">4295 </span>
4296     protected JavaField lookupField(int cpi, int opcode) {
4297         maybeEagerlyResolve(cpi, opcode);
4298         JavaField result = constantPool.lookupField(cpi, method, opcode);
4299         return lookupField(result);
4300     }
4301 
4302     protected JavaField lookupField(JavaField result) {
4303         assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaField : &quot;Not resolved: &quot; + result;
4304         if (parsingIntrinsic() || eagerInitializing) {
4305             if (result instanceof ResolvedJavaField) {
4306                 ResolvedJavaType declaringClass = ((ResolvedJavaField) result).getDeclaringClass();
4307                 if (!declaringClass.isInitialized()) {
4308                     // Even with eager initialization, superinterfaces are not always initialized.
4309                     // See StaticInterfaceFieldTest
4310                     assert !eagerInitializing || declaringClass.isInterface() : &quot;Declaring class not initialized but not an interface? &quot; + declaringClass;
4311                     initialize(declaringClass);
4312                 }
4313             }
4314         }
4315         assert !uninitializedIsError || (result instanceof ResolvedJavaField &amp;&amp; ((ResolvedJavaField) result).getDeclaringClass().isInitialized()) : result;
</pre>
<hr />
<pre>
4326     protected void maybeEagerlyResolve(int cpi, int bytecode) {
4327         if (intrinsicContext != null) {
4328             constantPool.loadReferencedType(cpi, bytecode);
4329         } else if (graphBuilderConfig.eagerResolving()) {
4330             /*
4331              * Since we&#39;re potentially triggering class initialization here, we need synchronization
4332              * to mitigate the potential for class initialization related deadlock being caused by
4333              * the compiler (e.g., https://github.com/graalvm/graal-core/pull/232/files#r90788550).
4334              */
4335             synchronized (BytecodeParser.class) {
4336                 ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4337                 if (classInitializationPlugin != null) {
4338                     classInitializationPlugin.loadReferencedType(this, constantPool, cpi, bytecode);
4339                 } else {
4340                     constantPool.loadReferencedType(cpi, bytecode);
4341                 }
4342             }
4343         }
4344     }
4345 
<span class="line-added">4346     protected JavaType maybeEagerlyResolve(JavaType type, ResolvedJavaType accessingClass) {</span>
<span class="line-added">4347         if (graphBuilderConfig.eagerResolving() || parsingIntrinsic()) {</span>
<span class="line-added">4348             return type.resolve(accessingClass);</span>
<span class="line-added">4349         }</span>
<span class="line-added">4350         return type;</span>
<span class="line-added">4351     }</span>
<span class="line-added">4352 </span>
4353     protected void maybeEagerlyInitialize(ResolvedJavaType resolvedType) {
4354         if (!resolvedType.isInitialized() &amp;&amp; eagerInitializing) {
4355             initialize(resolvedType);
4356         }
4357     }
4358 
4359     private JavaTypeProfile getProfileForTypeCheck(TypeReference type) {
4360         if (parsingIntrinsic() || profilingInfo == null || !optimisticOpts.useTypeCheckHints(getOptions()) || type.isExact()) {
4361             return null;
4362         } else {
4363             return profilingInfo.getTypeProfile(bci());
4364         }
4365     }
4366 
4367     private void genCheckCast(int cpi) {
4368         JavaType type = lookupType(cpi, CHECKCAST);
4369         ValueNode object = frameState.pop(JavaKind.Object);
4370         genCheckCast(type, object);
4371     }
4372 
</pre>
<hr />
<pre>
4424                 castNode = append(PiNode.create(object, StampFactory.object(checkedType, nonNull), guard.asNode()));
4425             }
4426         }
4427         frameState.push(JavaKind.Object, castNode);
4428     }
4429 
4430     private void genInstanceOf(int cpi) {
4431         JavaType type = lookupType(cpi, INSTANCEOF);
4432         ValueNode object = frameState.pop(JavaKind.Object);
4433         genInstanceOf(type, object);
4434     }
4435 
4436     protected void genInstanceOf(JavaType type, ValueNode object) {
4437         if (typeIsResolved(type)) {
4438             genInstanceOf((ResolvedJavaType) type, object);
4439         } else {
4440             handleUnresolvedInstanceOf(type, object);
4441         }
4442     }
4443 
<span class="line-added">4444     @SuppressWarnings(&quot;try&quot;)</span>
4445     protected void genInstanceOf(ResolvedJavaType resolvedType, ValueNode objectIn) {
4446         ValueNode object = objectIn;
4447         TypeReference checkedType = TypeReference.createTrusted(graph.getAssumptions(), resolvedType);
4448         JavaTypeProfile profile = getProfileForTypeCheck(checkedType);
4449 
4450         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4451             if (plugin.handleInstanceOf(this, object, checkedType.getType(), profile)) {
4452                 return;
4453             }
4454         }
4455 
4456         LogicNode instanceOfNode = null;
4457         if (profile != null) {
4458             if (profile.getNullSeen().isFalse()) {
4459                 object = nullCheckedValue(object);
4460                 ResolvedJavaType singleType = profile.asSingleType();
4461                 if (singleType != null) {
4462                     LogicNode typeCheck = append(createInstanceOf(TypeReference.createExactTrusted(singleType), object, profile));
4463                     if (!typeCheck.isTautology()) {
4464                         append(new FixedGuardNode(typeCheck, DeoptimizationReason.TypeCheckedInliningViolated, DeoptimizationAction.InvalidateReprofile));
4465                     }
4466                     instanceOfNode = LogicConstantNode.forBoolean(checkedType.getType().isAssignableFrom(singleType));
4467                 }
4468             }
4469         }
4470         if (instanceOfNode == null) {
4471             instanceOfNode = createInstanceOf(checkedType, object, null);
4472         }
4473         LogicNode logicNode = genUnique(instanceOfNode);
4474 
4475         int next = getStream().nextBCI();
4476         int value = getStream().readUByte(next);
4477         if (next &lt;= currentBlock.endBci &amp;&amp; (value == Bytecodes.IFEQ || value == Bytecodes.IFNE)) {
4478             getStream().next();
<span class="line-modified">4479             try (DebugCloseable context = openNodeContext()) {</span>
<span class="line-modified">4480                 BciBlock firstSucc = currentBlock.getSuccessor(0);</span>
<span class="line-modified">4481                 BciBlock secondSucc = currentBlock.getSuccessor(1);</span>
<span class="line-modified">4482                 if (firstSucc != secondSucc) {</span>
<span class="line-modified">4483                     boolean negate = value != Bytecodes.IFNE;</span>
<span class="line-modified">4484                     if (negate) {</span>
<span class="line-modified">4485                         BciBlock tmp = firstSucc;</span>
<span class="line-modified">4486                         firstSucc = secondSucc;</span>
<span class="line-added">4487                         secondSucc = tmp;</span>
<span class="line-added">4488                     }</span>
<span class="line-added">4489                     genIf(instanceOfNode, firstSucc, secondSucc, getProfileProbability(negate));</span>
<span class="line-added">4490                 } else {</span>
<span class="line-added">4491                     appendGoto(firstSucc);</span>
4492                 }



4493             }
4494         } else {
4495             // Most frequent for value is IRETURN, followed by ISTORE.
4496             frameState.push(JavaKind.Int, append(genConditional(logicNode)));
4497         }
4498     }
4499 
4500     protected void genNewInstance(int cpi) {
4501         JavaType type = lookupType(cpi, NEW);
4502         genNewInstance(type);
4503     }
4504 
4505     protected void genNewInstance(JavaType type) {
4506         if (typeIsResolved(type)) {
4507             genNewInstance((ResolvedJavaType) type);
4508         } else {
4509             handleUnresolvedNewInstance(type);
4510         }
4511     }
4512 
</pre>
<hr />
<pre>
4557             case 5:
4558                 return char.class;
4559             case 6:
4560                 return float.class;
4561             case 7:
4562                 return double.class;
4563             case 8:
4564                 return byte.class;
4565             case 9:
4566                 return short.class;
4567             case 10:
4568                 return int.class;
4569             case 11:
4570                 return long.class;
4571             default:
4572                 throw new IllegalArgumentException(&quot;unknown array type code: &quot; + code);
4573         }
4574     }
4575 
4576     private void genNewPrimitiveArray(int typeCode) {
<span class="line-modified">4577         ResolvedJavaType elementType = getMetaAccess().lookupJavaType(arrayTypeCodeToClass(typeCode));</span>
4578         ValueNode length = frameState.pop(JavaKind.Int);
4579 
4580         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4581             if (plugin.handleNewArray(this, elementType, length)) {
4582                 return;
4583             }
4584         }
4585 
4586         frameState.push(JavaKind.Object, append(createNewArray(elementType, length, true)));
4587     }
4588 
4589     private void genNewObjectArray(int cpi) {
4590         JavaType type = lookupType(cpi, ANEWARRAY);
4591         genNewObjectArray(type);
4592     }
4593 
4594     private void genNewObjectArray(JavaType type) {
4595         if (typeIsResolved(type)) {
4596             genNewObjectArray((ResolvedJavaType) type);
4597         } else {
</pre>
<hr />
<pre>
4741      *
4742      * @param y The dividend.
4743      */
4744     protected boolean needsExplicitDivisionByZeroException(ValueNode y) {
4745         return needsExplicitException();
4746     }
4747 
4748     @Override
4749     public boolean needsExplicitException() {
4750         BytecodeExceptionMode exceptionMode = graphBuilderConfig.getBytecodeExceptionMode();
4751         if (exceptionMode == BytecodeExceptionMode.CheckAll || StressExplicitExceptionCode.getValue(options)) {
4752             return true;
4753         } else if (exceptionMode == BytecodeExceptionMode.Profile &amp;&amp; profilingInfo != null) {
4754             return profilingInfo.getExceptionSeen(bci()) == TriState.TRUE;
4755         }
4756         return false;
4757     }
4758 
4759     @Override
4760     public AbstractBeginNode genExplicitExceptionEdge(BytecodeExceptionKind exceptionKind) {
<span class="line-modified">4761         BytecodeExceptionNode exceptionNode = graph.add(new BytecodeExceptionNode(getMetaAccess(), exceptionKind));</span>
<span class="line-modified">4762         exceptionNode.setStateAfter(createBytecodeExceptionFrameState(bci(), exceptionNode));</span>
4763         AbstractBeginNode exceptionDispatch = handleException(exceptionNode, bci(), false);
4764         exceptionNode.setNext(exceptionDispatch);
4765         return BeginNode.begin(exceptionNode);
4766     }
4767 
4768     protected void genPutField(int cpi, int opcode) {
4769         JavaField field = lookupField(cpi, opcode);
4770         genPutField(field);
4771     }
4772 
4773     protected void genPutField(JavaField field) {
4774         genPutField(field, frameState.pop(field.getJavaKind()));
4775     }
4776 
4777     private void genPutField(JavaField field, ValueNode value) {
4778         ValueNode receiverInput = frameState.pop(JavaKind.Object);
4779 
4780         if (field instanceof ResolvedJavaField) {
4781             ValueNode receiver = maybeEmitExplicitNullCheck(receiverInput);
4782             ResolvedJavaField resolvedField = (ResolvedJavaField) field;
</pre>
<hr />
<pre>
4804         JavaField field = lookupField(cpi, opcode);
4805         genGetStatic(field);
4806     }
4807 
4808     private void genGetStatic(JavaField field) {
4809         ResolvedJavaField resolvedField = resolveStaticFieldAccess(field, null);
4810         if (resolvedField == null) {
4811             return;
4812         }
4813 
4814         if (!parsingIntrinsic() &amp;&amp; GeneratePIC.getValue(getOptions())) {
4815             graph.recordField(resolvedField);
4816         }
4817 
4818         /*
4819          * Javac does not allow use of &quot;$assertionsDisabled&quot; for a field name but Eclipse does, in
4820          * which case a suffix is added to the generated field.
4821          */
4822         if (resolvedField.isSynthetic() &amp;&amp; resolvedField.getName().startsWith(&quot;$assertionsDisabled&quot;)) {
4823             if (parsingIntrinsic()) {
<span class="line-modified">4824                 throw new GraalError(&quot;Cannot use an assertion within the context of an intrinsic: &quot; + resolvedField);</span>
4825             } else if (graphBuilderConfig.omitAssertions()) {
4826                 frameState.push(field.getJavaKind(), ConstantNode.forBoolean(true, graph));
4827                 return;
4828             }
4829         }
4830 
4831         ResolvedJavaType holder = resolvedField.getDeclaringClass();
4832         ClassInitializationPlugin classInitializationPlugin = this.graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4833         if (classInitializationPlugin != null) {
4834             classInitializationPlugin.apply(this, holder, this::createCurrentFrameState);
4835         }
4836 
4837         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4838             if (plugin.handleLoadStaticField(this, resolvedField)) {
4839                 return;
4840             }
4841         }
4842 
4843         ValueNode fieldRead = append(genLoadField(null, resolvedField));
4844         JavaKind fieldKind = resolvedField.getJavaKind();
</pre>
<hr />
<pre>
4948 
4949     private static boolean allPositive(double[] a) {
4950         for (double d : a) {
4951             if (d &lt; 0) {
4952                 return false;
4953             }
4954         }
4955         return true;
4956     }
4957 
4958     static class SuccessorInfo {
4959         final int blockIndex;
4960         int actualIndex;
4961 
4962         SuccessorInfo(int blockSuccessorIndex) {
4963             this.blockIndex = blockSuccessorIndex;
4964             actualIndex = -1;
4965         }
4966     }
4967 
<span class="line-added">4968     private static final int SWITCH_DEOPT_UNSEEN = -2;</span>
<span class="line-added">4969     private static final int SWITCH_DEOPT_SEEN = -1;</span>
<span class="line-added">4970 </span>
4971     private void genSwitch(BytecodeSwitch bs) {
4972         int bci = bci();
4973         ValueNode value = frameState.pop(JavaKind.Int);
4974 
4975         int nofCases = bs.numberOfCases();
4976         int nofCasesPlusDefault = nofCases + 1;
4977         double[] keyProbabilities = switchProbability(nofCasesPlusDefault, bci);
4978 
4979         EconomicMap&lt;Integer, SuccessorInfo&gt; bciToBlockSuccessorIndex = EconomicMap.create(Equivalence.DEFAULT);
4980         for (int i = 0; i &lt; currentBlock.getSuccessorCount(); i++) {
4981             assert !bciToBlockSuccessorIndex.containsKey(currentBlock.getSuccessor(i).startBci);
4982             bciToBlockSuccessorIndex.put(currentBlock.getSuccessor(i).startBci, new SuccessorInfo(i));
4983         }
4984 
4985         ArrayList&lt;BciBlock&gt; actualSuccessors = new ArrayList&lt;&gt;();
4986         int[] keys = new int[nofCases];
4987         int[] keySuccessors = new int[nofCasesPlusDefault];
<span class="line-modified">4988         int deoptSuccessorIndex = SWITCH_DEOPT_UNSEEN;</span>
4989         int nextSuccessorIndex = 0;
4990         boolean constantValue = value.isConstant();
4991         for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
4992             if (i &lt; nofCases) {
4993                 keys[i] = bs.keyAt(i);
4994             }

4995             if (!constantValue &amp;&amp; isNeverExecutedCode(keyProbabilities[i])) {
<span class="line-modified">4996                 deoptSuccessorIndex = SWITCH_DEOPT_SEEN;</span>
<span class="line-modified">4997                 keySuccessors[i] = SWITCH_DEOPT_SEEN;</span>



4998             } else {
4999                 int targetBci = i &lt; nofCases ? bs.targetAt(i) : bs.defaultTarget();
5000                 SuccessorInfo info = bciToBlockSuccessorIndex.get(targetBci);
5001                 if (info.actualIndex &lt; 0) {
5002                     info.actualIndex = nextSuccessorIndex++;
5003                     actualSuccessors.add(currentBlock.getSuccessor(info.blockIndex));
5004                 }
5005                 keySuccessors[i] = info.actualIndex;
5006             }
5007         }
5008         /*
5009          * When the profile indicates a case is never taken, the above code will cause the case to
5010          * deopt should it be subsequently encountered. However, the case may share code with
5011          * another case that is taken according to the profile.
5012          *
5013          * For example:
5014          * // @formatter:off
5015          * switch (opcode) {
5016          *     case GOTO:
5017          *     case GOTO_W: {
5018          *         // emit goto code
5019          *         break;
5020          *     }
5021          * }
5022          * // @formatter:on
5023          *
5024          * The profile may indicate the GOTO_W case is never taken, and thus a deoptimization stub
5025          * will be emitted. There might be optimization opportunity if additional branching based
5026          * on opcode is within the case block. Specially, if there is only single case that
5027          * reaches a target, we have better chance cutting out unused branches. Otherwise,
5028          * it might be beneficial routing to the same code instead of deopting.
5029          *
5030          * The following code rewires deoptimization stub to existing resolved branch target if
5031          * the target is connected by more than 1 cases.
<span class="line-added">5032          *</span>
<span class="line-added">5033          * If this operation rewires every deoptimization seen to an existing branch, care is</span>
<span class="line-added">5034          * taken that we do not spawn a branch that will never be taken.</span>
5035          */
<span class="line-modified">5036         if (deoptSuccessorIndex == SWITCH_DEOPT_SEEN) {</span>
<span class="line-modified">5037             int[] connectedCases = new int[nextSuccessorIndex + 1];</span>
5038             for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
<span class="line-modified">5039                 connectedCases[keySuccessors[i] + 1]++;</span>
5040             }
5041 
5042             for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
<span class="line-modified">5043                 if (keySuccessors[i] == SWITCH_DEOPT_SEEN) {</span>
5044                     int targetBci = i &lt; nofCases ? bs.targetAt(i) : bs.defaultTarget();
5045                     SuccessorInfo info = bciToBlockSuccessorIndex.get(targetBci);
5046                     int rewiredIndex = info.actualIndex;
<span class="line-modified">5047                     if (rewiredIndex &gt;= 0 &amp;&amp; connectedCases[rewiredIndex + 1] &gt; 1) {</span>
<span class="line-added">5048                         // Rewire</span>
5049                         keySuccessors[i] = info.actualIndex;
<span class="line-added">5050                     } else {</span>
<span class="line-added">5051                         if (deoptSuccessorIndex == SWITCH_DEOPT_SEEN) {</span>
<span class="line-added">5052                             // Spawn deopt successor if needed.</span>
<span class="line-added">5053                             deoptSuccessorIndex = nextSuccessorIndex++;</span>
<span class="line-added">5054                             actualSuccessors.add(null);</span>
<span class="line-added">5055                         }</span>
<span class="line-added">5056                         keySuccessors[i] = deoptSuccessorIndex;</span>
5057                     }
5058                 }
5059             }
5060         }
5061 
5062         genIntegerSwitch(value, actualSuccessors, keys, keyProbabilities, keySuccessors);
5063 
5064     }
5065 
5066     protected boolean isNeverExecutedCode(double probability) {
5067         return probability == 0 &amp;&amp; optimisticOpts.removeNeverExecutedCode(getOptions());
5068     }
5069 
5070     private double clampProbability(double probability) {
5071         if (!optimisticOpts.removeNeverExecutedCode(getOptions())) {
5072             if (probability == 0) {
5073                 return LUDICROUSLY_SLOW_PATH_PROBABILITY;
5074             } else if (probability == 1) {
5075                 return LUDICROUSLY_FAST_PATH_PROBABILITY;
5076             }
</pre>
<hr />
<pre>
5240             case LUSHR          : genShiftOp(JavaKind.Long, opcode); break;
5241             case LAND           : // fall through
5242             case LOR            : // fall through
5243             case LXOR           : genLogicOp(JavaKind.Long, opcode); break;
5244             case IINC           : genIncrement(); break;
5245             case I2F            : genFloatConvert(FloatConvert.I2F, JavaKind.Int, JavaKind.Float); break;
5246             case I2D            : genFloatConvert(FloatConvert.I2D, JavaKind.Int, JavaKind.Double); break;
5247             case L2F            : genFloatConvert(FloatConvert.L2F, JavaKind.Long, JavaKind.Float); break;
5248             case L2D            : genFloatConvert(FloatConvert.L2D, JavaKind.Long, JavaKind.Double); break;
5249             case F2I            : genFloatConvert(FloatConvert.F2I, JavaKind.Float, JavaKind.Int); break;
5250             case F2L            : genFloatConvert(FloatConvert.F2L, JavaKind.Float, JavaKind.Long); break;
5251             case F2D            : genFloatConvert(FloatConvert.F2D, JavaKind.Float, JavaKind.Double); break;
5252             case D2I            : genFloatConvert(FloatConvert.D2I, JavaKind.Double, JavaKind.Int); break;
5253             case D2L            : genFloatConvert(FloatConvert.D2L, JavaKind.Double, JavaKind.Long); break;
5254             case D2F            : genFloatConvert(FloatConvert.D2F, JavaKind.Double, JavaKind.Float); break;
5255             case L2I            : genNarrow(JavaKind.Long, JavaKind.Int); break;
5256             case I2L            : genSignExtend(JavaKind.Int, JavaKind.Long); break;
5257             case I2B            : genSignExtend(JavaKind.Byte, JavaKind.Int); break;
5258             case I2S            : genSignExtend(JavaKind.Short, JavaKind.Int); break;
5259             case I2C            : genZeroExtend(JavaKind.Char, JavaKind.Int); break;
<span class="line-modified">5260             case LCMP           : genIntegerCompareOp(JavaKind.Long); break;</span>
<span class="line-modified">5261             case FCMPL          : genFloatCompareOp(JavaKind.Float, true); break;</span>
<span class="line-modified">5262             case FCMPG          : genFloatCompareOp(JavaKind.Float, false); break;</span>
<span class="line-modified">5263             case DCMPL          : genFloatCompareOp(JavaKind.Double, true); break;</span>
<span class="line-modified">5264             case DCMPG          : genFloatCompareOp(JavaKind.Double, false); break;</span>
5265             case IFEQ           : genIfZero(Condition.EQ); break;
5266             case IFNE           : genIfZero(Condition.NE); break;
5267             case IFLT           : genIfZero(Condition.LT); break;
5268             case IFGE           : genIfZero(Condition.GE); break;
5269             case IFGT           : genIfZero(Condition.GT); break;
5270             case IFLE           : genIfZero(Condition.LE); break;
5271             case IF_ICMPEQ      : genIfSame(JavaKind.Int, Condition.EQ); break;
5272             case IF_ICMPNE      : genIfSame(JavaKind.Int, Condition.NE); break;
5273             case IF_ICMPLT      : genIfSame(JavaKind.Int, Condition.LT); break;
5274             case IF_ICMPGE      : genIfSame(JavaKind.Int, Condition.GE); break;
5275             case IF_ICMPGT      : genIfSame(JavaKind.Int, Condition.GT); break;
5276             case IF_ICMPLE      : genIfSame(JavaKind.Int, Condition.LE); break;
5277             case IF_ACMPEQ      : genIfSame(JavaKind.Object, Condition.EQ); break;
5278             case IF_ACMPNE      : genIfSame(JavaKind.Object, Condition.NE); break;
5279             case GOTO           : genGoto(); break;
5280             case JSR            : genJsr(stream.readBranchDest()); break;
5281             case RET            : genRet(stream.readLocalIndex()); break;
5282             case TABLESWITCH    : genSwitch(new BytecodeTableSwitch(getStream(), bci())); break;
5283             case LOOKUPSWITCH   : genSwitch(new BytecodeLookupSwitch(getStream(), bci())); break;
5284             case IRETURN        : genReturn(frameState.pop(JavaKind.Int), JavaKind.Int); break;
</pre>
</td>
</tr>
</table>
<center><a href="BciBlockMapping.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeParserOptions.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
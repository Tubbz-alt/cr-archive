<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BciBlockMapping.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.java;
  26 
  27 import static org.graalvm.compiler.bytecode.Bytecodes.AALOAD;
  28 import static org.graalvm.compiler.bytecode.Bytecodes.AASTORE;
  29 import static org.graalvm.compiler.bytecode.Bytecodes.ACONST_NULL;
  30 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD;
  31 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_0;
  32 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_1;
  33 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_2;
  34 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_3;
  35 import static org.graalvm.compiler.bytecode.Bytecodes.ANEWARRAY;
  36 import static org.graalvm.compiler.bytecode.Bytecodes.ARETURN;
  37 import static org.graalvm.compiler.bytecode.Bytecodes.ARRAYLENGTH;
  38 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE;
  39 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_0;
  40 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_1;
  41 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_2;
  42 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_3;
  43 import static org.graalvm.compiler.bytecode.Bytecodes.ATHROW;
  44 import static org.graalvm.compiler.bytecode.Bytecodes.BALOAD;
  45 import static org.graalvm.compiler.bytecode.Bytecodes.BASTORE;
  46 import static org.graalvm.compiler.bytecode.Bytecodes.BIPUSH;
  47 import static org.graalvm.compiler.bytecode.Bytecodes.BREAKPOINT;
  48 import static org.graalvm.compiler.bytecode.Bytecodes.CALOAD;
  49 import static org.graalvm.compiler.bytecode.Bytecodes.CASTORE;
  50 import static org.graalvm.compiler.bytecode.Bytecodes.CHECKCAST;
  51 import static org.graalvm.compiler.bytecode.Bytecodes.D2F;
  52 import static org.graalvm.compiler.bytecode.Bytecodes.D2I;
  53 import static org.graalvm.compiler.bytecode.Bytecodes.D2L;
  54 import static org.graalvm.compiler.bytecode.Bytecodes.DADD;
  55 import static org.graalvm.compiler.bytecode.Bytecodes.DALOAD;
  56 import static org.graalvm.compiler.bytecode.Bytecodes.DASTORE;
  57 import static org.graalvm.compiler.bytecode.Bytecodes.DCMPG;
  58 import static org.graalvm.compiler.bytecode.Bytecodes.DCMPL;
  59 import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_0;
  60 import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_1;
  61 import static org.graalvm.compiler.bytecode.Bytecodes.DDIV;
  62 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD;
  63 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_0;
  64 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_1;
  65 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_2;
  66 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_3;
  67 import static org.graalvm.compiler.bytecode.Bytecodes.DMUL;
  68 import static org.graalvm.compiler.bytecode.Bytecodes.DNEG;
  69 import static org.graalvm.compiler.bytecode.Bytecodes.DREM;
  70 import static org.graalvm.compiler.bytecode.Bytecodes.DRETURN;
  71 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE;
  72 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_0;
  73 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_1;
  74 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_2;
  75 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_3;
  76 import static org.graalvm.compiler.bytecode.Bytecodes.DSUB;
  77 import static org.graalvm.compiler.bytecode.Bytecodes.DUP;
  78 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2;
  79 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X1;
  80 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X2;
  81 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X1;
  82 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X2;
  83 import static org.graalvm.compiler.bytecode.Bytecodes.F2D;
  84 import static org.graalvm.compiler.bytecode.Bytecodes.F2I;
  85 import static org.graalvm.compiler.bytecode.Bytecodes.F2L;
  86 import static org.graalvm.compiler.bytecode.Bytecodes.FADD;
  87 import static org.graalvm.compiler.bytecode.Bytecodes.FALOAD;
  88 import static org.graalvm.compiler.bytecode.Bytecodes.FASTORE;
  89 import static org.graalvm.compiler.bytecode.Bytecodes.FCMPG;
  90 import static org.graalvm.compiler.bytecode.Bytecodes.FCMPL;
  91 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_0;
  92 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_1;
  93 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_2;
  94 import static org.graalvm.compiler.bytecode.Bytecodes.FDIV;
  95 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD;
  96 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_0;
  97 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_1;
  98 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_2;
  99 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_3;
 100 import static org.graalvm.compiler.bytecode.Bytecodes.FMUL;
 101 import static org.graalvm.compiler.bytecode.Bytecodes.FNEG;
 102 import static org.graalvm.compiler.bytecode.Bytecodes.FREM;
 103 import static org.graalvm.compiler.bytecode.Bytecodes.FRETURN;
 104 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE;
 105 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_0;
 106 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_1;
 107 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_2;
 108 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_3;
 109 import static org.graalvm.compiler.bytecode.Bytecodes.FSUB;
 110 import static org.graalvm.compiler.bytecode.Bytecodes.GETFIELD;
 111 import static org.graalvm.compiler.bytecode.Bytecodes.GETSTATIC;
 112 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO;
 113 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO_W;
 114 import static org.graalvm.compiler.bytecode.Bytecodes.I2B;
 115 import static org.graalvm.compiler.bytecode.Bytecodes.I2C;
 116 import static org.graalvm.compiler.bytecode.Bytecodes.I2D;
 117 import static org.graalvm.compiler.bytecode.Bytecodes.I2F;
 118 import static org.graalvm.compiler.bytecode.Bytecodes.I2L;
 119 import static org.graalvm.compiler.bytecode.Bytecodes.I2S;
 120 import static org.graalvm.compiler.bytecode.Bytecodes.IADD;
 121 import static org.graalvm.compiler.bytecode.Bytecodes.IALOAD;
 122 import static org.graalvm.compiler.bytecode.Bytecodes.IAND;
 123 import static org.graalvm.compiler.bytecode.Bytecodes.IASTORE;
 124 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_0;
 125 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_1;
 126 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_2;
 127 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_3;
 128 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_4;
 129 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_5;
 130 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_M1;
 131 import static org.graalvm.compiler.bytecode.Bytecodes.IDIV;
 132 import static org.graalvm.compiler.bytecode.Bytecodes.IFEQ;
 133 import static org.graalvm.compiler.bytecode.Bytecodes.IFGE;
 134 import static org.graalvm.compiler.bytecode.Bytecodes.IFGT;
 135 import static org.graalvm.compiler.bytecode.Bytecodes.IFLE;
 136 import static org.graalvm.compiler.bytecode.Bytecodes.IFLT;
 137 import static org.graalvm.compiler.bytecode.Bytecodes.IFNE;
 138 import static org.graalvm.compiler.bytecode.Bytecodes.IFNONNULL;
 139 import static org.graalvm.compiler.bytecode.Bytecodes.IFNULL;
 140 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPEQ;
 141 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPNE;
 142 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPEQ;
 143 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGE;
 144 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGT;
 145 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLE;
 146 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLT;
 147 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPNE;
 148 import static org.graalvm.compiler.bytecode.Bytecodes.IINC;
 149 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD;
 150 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_0;
 151 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_1;
 152 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_2;
 153 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_3;
 154 import static org.graalvm.compiler.bytecode.Bytecodes.IMUL;
 155 import static org.graalvm.compiler.bytecode.Bytecodes.INEG;
 156 import static org.graalvm.compiler.bytecode.Bytecodes.INSTANCEOF;
 157 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEDYNAMIC;
 158 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEINTERFACE;
 159 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESPECIAL;
 160 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESTATIC;
 161 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEVIRTUAL;
 162 import static org.graalvm.compiler.bytecode.Bytecodes.IOR;
 163 import static org.graalvm.compiler.bytecode.Bytecodes.IREM;
 164 import static org.graalvm.compiler.bytecode.Bytecodes.IRETURN;
 165 import static org.graalvm.compiler.bytecode.Bytecodes.ISHL;
 166 import static org.graalvm.compiler.bytecode.Bytecodes.ISHR;
 167 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE;
 168 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_0;
 169 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_1;
 170 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_2;
 171 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_3;
 172 import static org.graalvm.compiler.bytecode.Bytecodes.ISUB;
 173 import static org.graalvm.compiler.bytecode.Bytecodes.IUSHR;
 174 import static org.graalvm.compiler.bytecode.Bytecodes.IXOR;
 175 import static org.graalvm.compiler.bytecode.Bytecodes.JSR;
 176 import static org.graalvm.compiler.bytecode.Bytecodes.JSR_W;
 177 import static org.graalvm.compiler.bytecode.Bytecodes.L2D;
 178 import static org.graalvm.compiler.bytecode.Bytecodes.L2F;
 179 import static org.graalvm.compiler.bytecode.Bytecodes.L2I;
 180 import static org.graalvm.compiler.bytecode.Bytecodes.LADD;
 181 import static org.graalvm.compiler.bytecode.Bytecodes.LALOAD;
 182 import static org.graalvm.compiler.bytecode.Bytecodes.LAND;
 183 import static org.graalvm.compiler.bytecode.Bytecodes.LASTORE;
 184 import static org.graalvm.compiler.bytecode.Bytecodes.LCMP;
 185 import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_0;
 186 import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_1;
 187 import static org.graalvm.compiler.bytecode.Bytecodes.LDC;
 188 import static org.graalvm.compiler.bytecode.Bytecodes.LDC2_W;
 189 import static org.graalvm.compiler.bytecode.Bytecodes.LDC_W;
 190 import static org.graalvm.compiler.bytecode.Bytecodes.LDIV;
 191 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD;
 192 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_0;
 193 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_1;
 194 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_2;
 195 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_3;
 196 import static org.graalvm.compiler.bytecode.Bytecodes.LMUL;
 197 import static org.graalvm.compiler.bytecode.Bytecodes.LNEG;
 198 import static org.graalvm.compiler.bytecode.Bytecodes.LOOKUPSWITCH;
 199 import static org.graalvm.compiler.bytecode.Bytecodes.LOR;
 200 import static org.graalvm.compiler.bytecode.Bytecodes.LREM;
 201 import static org.graalvm.compiler.bytecode.Bytecodes.LRETURN;
 202 import static org.graalvm.compiler.bytecode.Bytecodes.LSHL;
 203 import static org.graalvm.compiler.bytecode.Bytecodes.LSHR;
 204 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE;
 205 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_0;
 206 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_1;
 207 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_2;
 208 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_3;
 209 import static org.graalvm.compiler.bytecode.Bytecodes.LSUB;
 210 import static org.graalvm.compiler.bytecode.Bytecodes.LUSHR;
 211 import static org.graalvm.compiler.bytecode.Bytecodes.LXOR;
 212 import static org.graalvm.compiler.bytecode.Bytecodes.MONITORENTER;
 213 import static org.graalvm.compiler.bytecode.Bytecodes.MONITOREXIT;
 214 import static org.graalvm.compiler.bytecode.Bytecodes.MULTIANEWARRAY;
 215 import static org.graalvm.compiler.bytecode.Bytecodes.NEW;
 216 import static org.graalvm.compiler.bytecode.Bytecodes.NEWARRAY;
 217 import static org.graalvm.compiler.bytecode.Bytecodes.NOP;
 218 import static org.graalvm.compiler.bytecode.Bytecodes.POP;
 219 import static org.graalvm.compiler.bytecode.Bytecodes.POP2;
 220 import static org.graalvm.compiler.bytecode.Bytecodes.PUTFIELD;
 221 import static org.graalvm.compiler.bytecode.Bytecodes.PUTSTATIC;
 222 import static org.graalvm.compiler.bytecode.Bytecodes.RET;
 223 import static org.graalvm.compiler.bytecode.Bytecodes.RETURN;
 224 import static org.graalvm.compiler.bytecode.Bytecodes.SALOAD;
 225 import static org.graalvm.compiler.bytecode.Bytecodes.SASTORE;
 226 import static org.graalvm.compiler.bytecode.Bytecodes.SIPUSH;
 227 import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;
 228 import static org.graalvm.compiler.bytecode.Bytecodes.TABLESWITCH;
 229 import static org.graalvm.compiler.bytecode.Bytecodes.WIDE;
 230 import static org.graalvm.compiler.core.common.GraalOptions.SupportJsrBytecodes;
 231 
 232 import java.util.ArrayDeque;
 233 import java.util.ArrayList;
 234 import java.util.Arrays;
 235 import java.util.Collection;
 236 import java.util.Iterator;
 237 import java.util.List;
 238 import java.util.TreeSet;
 239 
 240 import jdk.internal.vm.compiler.collections.EconomicMap;
 241 import jdk.internal.vm.compiler.collections.Equivalence;
 242 import org.graalvm.compiler.bytecode.Bytecode;
 243 import org.graalvm.compiler.bytecode.BytecodeLookupSwitch;
 244 import org.graalvm.compiler.bytecode.BytecodeStream;
 245 import org.graalvm.compiler.bytecode.BytecodeSwitch;
 246 import org.graalvm.compiler.bytecode.BytecodeTableSwitch;
 247 import org.graalvm.compiler.bytecode.Bytecodes;
 248 import org.graalvm.compiler.core.common.PermanentBailoutException;
 249 import org.graalvm.compiler.debug.DebugContext;
 250 import org.graalvm.compiler.debug.GraalError;
 251 import org.graalvm.compiler.options.OptionValues;
 252 
 253 import jdk.vm.ci.code.BytecodeFrame;
 254 import jdk.vm.ci.meta.ExceptionHandler;
 255 
 256 /**
 257  * Builds a mapping between bytecodes and basic blocks and builds a conservative control flow graph
 258  * (CFG). It makes one linear pass over the bytecodes to build the CFG where it detects block
 259  * headers and connects them.
 260  * &lt;p&gt;
 261  * It also creates exception dispatch blocks for exception handling. These blocks are between a
 262  * bytecode that might throw an exception, and the actual exception handler entries, and are later
 263  * used to create the type checks with the exception handler catch types. If a bytecode is covered
 264  * by an exception handler, this bytecode ends the basic block. This guarantees that a) control flow
 265  * cannot be transferred to an exception dispatch block in the middle of a block, and b) that every
 266  * block has at most one exception dispatch block (which is always the last entry in the successor
 267  * list).
 268  * &lt;p&gt;
 269  * If a bytecode is covered by multiple exception handlers, a chain of exception dispatch blocks is
 270  * created so that multiple exception handler types can be checked. The chains are re-used if
 271  * multiple bytecodes are covered by the same exception handlers.
 272  * &lt;p&gt;
 273  * Note that exception unwinds, i.e., bytecodes that can throw an exception but the exception is not
 274  * handled in this method, do not end a basic block. Not modeling the exception unwind block reduces
 275  * the complexity of the CFG, and there is no algorithm yet where the exception unwind block would
 276  * matter.
 277  * &lt;p&gt;
 278  * The class also handles subroutines (jsr and ret bytecodes): subroutines are inlined by
 279  * duplicating the subroutine blocks. This is limited to simple, structured subroutines with a
 280  * maximum subroutine nesting of 4. Otherwise, a bailout is thrown.
 281  * &lt;p&gt;
 282  * Loops in the methods are detected. If a method contains an irreducible loop (a loop with more
 283  * than one entry), a bailout is thrown. This simplifies the compiler later on since only structured
 284  * loops need to be supported.
 285  * &lt;p&gt;
 286  * A data flow analysis computes the live local variables from the point of view of the interpreter.
 287  * The result is used later to prune frame states, i.e., remove local variable entries that are
 288  * guaranteed to be never used again (even in the case of deoptimization).
 289  * &lt;p&gt;
 290  * The algorithms and analysis in this class are conservative and do not use any assumptions or
 291  * profiling information.
 292  */
 293 public final class BciBlockMapping {
 294 
 295     public static class BciBlock implements Cloneable {
 296 
 297         int id;
 298         final int startBci;
 299         int endBci; // The bci of the last bytecode in the block
 300         private boolean isExceptionEntry;
 301         private boolean isLoopHeader;
 302         int loopId;
 303         int loopEnd;
 304         List&lt;BciBlock&gt; successors;
 305         private int predecessorCount;
 306 
 307         private boolean visited;
 308         private boolean active;
 309         long loops;
 310         JSRData jsrData;
 311 
 312         public static class JSRData implements Cloneable {
 313             public EconomicMap&lt;JsrScope, BciBlock&gt; jsrAlternatives;
 314             public JsrScope jsrScope = JsrScope.EMPTY_SCOPE;
 315             public BciBlock jsrSuccessor;
 316             public int jsrReturnBci;
 317             public BciBlock retSuccessor;
 318             public boolean endsWithRet = false;
 319 
 320             public JSRData copy() {
 321                 try {
 322                     return (JSRData) this.clone();
 323                 } catch (CloneNotSupportedException e) {
 324                     return null;
 325                 }
 326             }
 327         }
 328 
 329         BciBlock(int startBci) {
 330             this.startBci = startBci;
 331             this.successors = new ArrayList&lt;&gt;();
 332         }
 333 
 334         public int getStartBci() {
 335             return startBci;
 336         }
 337 
 338         public int getEndBci() {
 339             return endBci;
 340         }
 341 
 342         public long getLoops() {
 343             return loops;
 344         }
 345 
 346         public BciBlock exceptionDispatchBlock() {
 347             if (successors.size() &gt; 0 &amp;&amp; successors.get(successors.size() - 1) instanceof ExceptionDispatchBlock) {
 348                 return successors.get(successors.size() - 1);
 349             }
 350             return null;
 351         }
 352 
 353         public int getId() {
 354             return id;
 355         }
 356 
 357         public int getPredecessorCount() {
 358             return this.predecessorCount;
 359         }
 360 
 361         public int numNormalSuccessors() {
 362             if (exceptionDispatchBlock() != null) {
 363                 return successors.size() - 1;
 364             }
 365             return successors.size();
 366         }
 367 
 368         public BciBlock copy() {
 369             try {
 370                 BciBlock block = (BciBlock) super.clone();
 371                 if (block.jsrData != null) {
 372                     block.jsrData = block.jsrData.copy();
 373                 }
 374                 block.successors = new ArrayList&lt;&gt;(successors);
 375                 return block;
 376             } catch (CloneNotSupportedException e) {
 377                 throw new RuntimeException(e);
 378             }
 379         }
 380 
 381         @Override
 382         public String toString() {
 383             StringBuilder sb = new StringBuilder(&quot;B&quot;).append(getId());
 384             sb.append(&#39;[&#39;).append(startBci).append(&quot;..&quot;).append(endBci);
 385             if (isLoopHeader || isExceptionEntry || this instanceof ExceptionDispatchBlock) {
 386                 sb.append(&#39; &#39;);
 387                 if (isLoopHeader) {
 388                     sb.append(&#39;L&#39;);
 389                 }
 390                 if (isExceptionEntry) {
 391                     sb.append(&#39;!&#39;);
 392                 } else if (this instanceof ExceptionDispatchBlock) {
 393                     sb.append(&quot;&lt;!&gt;&quot;);
 394                 }
 395             }
 396             sb.append(&#39;]&#39;);
 397             return sb.toString();
 398         }
 399 
 400         public int getLoopDepth() {
 401             return Long.bitCount(loops);
 402         }
 403 
 404         public boolean isLoopHeader() {
 405             return isLoopHeader;
 406         }
 407 
 408         public boolean isExceptionEntry() {
 409             return isExceptionEntry;
 410         }
 411 
 412         public BciBlock getSuccessor(int index) {
 413             return successors.get(index);
 414         }
 415 
 416         /**
 417          * Get the loop id of the inner most loop.
 418          *
 419          * @return the loop id of the most inner loop or -1 if not part of any loop
 420          */
 421         public int getLoopId() {
 422             long l = loops;
 423             if (l == 0) {
 424                 return -1;
 425             }
 426             int pos = 0;
 427             for (int lMask = 1; (l &amp; lMask) == 0; lMask = lMask &lt;&lt; 1) {
 428                 pos++;
 429             }
 430             return pos;
 431         }
 432 
 433         /**
 434          * Iterate over loop ids.
 435          */
 436         public Iterable&lt;Integer&gt; loopIdIterable() {
 437             return new Iterable&lt;Integer&gt;() {
 438                 @Override
 439                 public Iterator&lt;Integer&gt; iterator() {
 440                     return idIterator(loops);
 441                 }
 442             };
 443         }
 444 
 445         private static Iterator&lt;Integer&gt; idIterator(long field) {
 446             return new Iterator&lt;Integer&gt;() {
 447 
 448                 long l = field;
 449                 int pos = 0;
 450                 int lMask = 1;
 451 
 452                 @Override
 453                 public Integer next() {
 454                     for (; (l &amp; lMask) == 0; lMask = lMask &lt;&lt; 1) {
 455                         pos++;
 456                     }
 457                     l &amp;= ~lMask;
 458                     return pos;
 459                 }
 460 
 461                 @Override
 462                 public boolean hasNext() {
 463                     return l != 0;
 464                 }
 465             };
 466 
 467         }
 468 
 469         public double probability() {
 470             return 1D;
 471         }
 472 
 473         public BciBlock getPostdominator() {
 474             return null;
 475         }
 476 
 477         private JSRData getOrCreateJSRData() {
 478             if (jsrData == null) {
 479                 jsrData = new JSRData();
 480             }
 481             return jsrData;
 482         }
 483 
 484         void setEndsWithRet() {
 485             getOrCreateJSRData().endsWithRet = true;
 486         }
 487 
 488         public JsrScope getJsrScope() {
 489             if (this.jsrData == null) {
 490                 return JsrScope.EMPTY_SCOPE;
 491             } else {
 492                 return jsrData.jsrScope;
 493             }
 494         }
 495 
 496         public boolean endsWithRet() {
 497             if (this.jsrData == null) {
 498                 return false;
 499             } else {
 500                 return jsrData.endsWithRet;
 501             }
 502         }
 503 
 504         void setRetSuccessor(BciBlock bciBlock) {
 505             this.getOrCreateJSRData().retSuccessor = bciBlock;
 506         }
 507 
 508         public BciBlock getRetSuccessor() {
 509             if (this.jsrData == null) {
 510                 return null;
 511             } else {
 512                 return jsrData.retSuccessor;
 513             }
 514         }
 515 
 516         public BciBlock getJsrSuccessor() {
 517             if (this.jsrData == null) {
 518                 return null;
 519             } else {
 520                 return jsrData.jsrSuccessor;
 521             }
 522         }
 523 
 524         public int getJsrReturnBci() {
 525             if (this.jsrData == null) {
 526                 return -1;
 527             } else {
 528                 return jsrData.jsrReturnBci;
 529             }
 530         }
 531 
 532         public EconomicMap&lt;JsrScope, BciBlock&gt; getJsrAlternatives() {
 533             if (this.jsrData == null) {
 534                 return null;
 535             } else {
 536                 return jsrData.jsrAlternatives;
 537             }
 538         }
 539 
 540         public void initJsrAlternatives() {
 541             JSRData data = this.getOrCreateJSRData();
 542             if (data.jsrAlternatives == null) {
 543                 data.jsrAlternatives = EconomicMap.create(Equivalence.DEFAULT);
 544             }
 545         }
 546 
 547         void setJsrScope(JsrScope nextScope) {
 548             this.getOrCreateJSRData().jsrScope = nextScope;
 549         }
 550 
 551         void setJsrSuccessor(BciBlock clone) {
 552             this.getOrCreateJSRData().jsrSuccessor = clone;
 553         }
 554 
 555         void setJsrReturnBci(int bci) {
 556             this.getOrCreateJSRData().jsrReturnBci = bci;
 557         }
 558 
 559         public int getSuccessorCount() {
 560             return successors.size();
 561         }
 562 
 563         public List&lt;BciBlock&gt; getSuccessors() {
 564             return successors;
 565         }
 566 
 567         void setId(int i) {
 568             this.id = i;
 569         }
 570 
 571         public void addSuccessor(BciBlock sux) {
 572             successors.add(sux);
 573             sux.predecessorCount++;
 574         }
 575 
 576         public void clearSucccessors() {
 577             for (BciBlock sux : successors) {
 578                 sux.predecessorCount--;
 579             }
 580             successors.clear();
 581         }
 582 
 583         public boolean isExceptionDispatch() {
 584             return false;
 585         }
 586     }
 587 
 588     public static class ExceptionDispatchBlock extends BciBlock {
 589         public final ExceptionHandler handler;
 590         public final int deoptBci;
 591 
 592         /**
 593          * Constructor for a normal dispatcher.
 594          */
 595         ExceptionDispatchBlock(ExceptionHandler handler, int deoptBci) {
 596             super(handler.getHandlerBCI());
 597             this.endBci = startBci;
 598             this.deoptBci = deoptBci;
 599             this.handler = handler;
 600         }
 601 
 602         /**
 603          * Constructor for the method unwind dispatcher.
 604          */
 605         ExceptionDispatchBlock(int deoptBci) {
 606             super(deoptBci);
 607             this.endBci = deoptBci;
 608             this.deoptBci = deoptBci;
 609             this.handler = null;
 610         }
 611 
 612         @Override
 613         public boolean isExceptionDispatch() {
 614             return true;
 615         }
 616     }
 617 
 618     private static final class TraversalStep {
 619         private BciBlock block;
 620         private int currentSuccessorIndex;
 621         private long loops;
 622 
 623         private TraversalStep(BciBlock block) {
 624             this.block = block;
 625             this.currentSuccessorIndex = 0;
 626             this.loops = 0;
 627         }
 628     }
 629 
 630     /**
 631      * The blocks found in this method, in reverse postorder.
 632      */
 633     private BciBlock[] blocks;
 634     public final Bytecode code;
 635     public boolean hasJsrBytecodes;
 636 
 637     private final ExceptionHandler[] exceptionHandlers;
 638     private BciBlock startBlock;
 639     private BciBlock[] loopHeaders;
 640 
 641     private static final int LOOP_HEADER_MAX_CAPACITY = Long.SIZE;
 642     private static final int LOOP_HEADER_INITIAL_CAPACITY = 4;
 643 
 644     private int blocksNotYetAssignedId;
 645     private final DebugContext debug;
 646 
 647     /**
 648      * Creates a new BlockMap instance from {@code code}.
 649      */
 650     private BciBlockMapping(Bytecode code, DebugContext debug) {
 651         this.code = code;
 652         this.debug = debug;
 653         this.exceptionHandlers = code.getExceptionHandlers();
 654     }
 655 
 656     public BciBlock[] getBlocks() {
 657         return this.blocks;
 658     }
 659 
 660     /**
 661      * Builds the block map and conservative CFG and numbers blocks.
 662      */
 663     public void build(BytecodeStream stream, OptionValues options) {
 664         int codeSize = code.getCodeSize();
 665         BciBlock[] blockMap = new BciBlock[codeSize];
 666         makeExceptionEntries(blockMap);
 667         iterateOverBytecodes(blockMap, stream);
 668         if (hasJsrBytecodes) {
 669             if (!SupportJsrBytecodes.getValue(options)) {
 670                 throw new JsrNotSupportedBailout(&quot;jsr/ret parsing disabled&quot;);
 671             }
 672             createJsrAlternatives(blockMap, blockMap[0]);
 673         }
 674         if (debug.isLogEnabled()) {
 675             this.log(blockMap, &quot;Before BlockOrder&quot;);
 676         }
 677         computeBlockOrder(blockMap);
 678         fixLoopBits(blockMap);
 679 
 680         assert verify();
 681 
 682         startBlock = blockMap[0];
 683         if (debug.isLogEnabled()) {
 684             this.log(blockMap, &quot;Before LivenessAnalysis&quot;);
 685         }
 686     }
 687 
 688     private boolean verify() {
 689         for (BciBlock block : blocks) {
 690             assert blocks[block.getId()] == block;
 691             for (int i = 0; i &lt; block.getSuccessorCount(); i++) {
 692                 BciBlock sux = block.getSuccessor(i);
 693                 if (sux instanceof ExceptionDispatchBlock) {
 694                     assert i == block.getSuccessorCount() - 1 : &quot;Only one exception handler allowed, and it must be last in successors list&quot;;
 695                 }
 696             }
 697         }
 698 
 699         return true;
 700     }
 701 
 702     private void makeExceptionEntries(BciBlock[] blockMap) {
 703         // start basic blocks at all exception handler blocks and mark them as exception entries
 704         for (ExceptionHandler h : this.exceptionHandlers) {
 705             BciBlock xhandler = makeBlock(blockMap, h.getHandlerBCI());
 706             xhandler.isExceptionEntry = true;
 707         }
 708     }
 709 
 710     private void iterateOverBytecodes(BciBlock[] blockMap, BytecodeStream stream) {
 711         // iterate over the bytecodes top to bottom.
 712         // mark the entrypoints of basic blocks and build lists of successors for
 713         // all bytecodes that end basic blocks (i.e. goto, ifs, switches, throw, jsr, returns, ret)
 714         BciBlock current = null;
 715         stream.setBCI(0);
 716         while (stream.currentBC() != Bytecodes.END) {
 717             int bci = stream.currentBCI();
 718 
 719             if (current == null || blockMap[bci] != null) {
 720                 BciBlock b = makeBlock(blockMap, bci);
 721                 if (current != null) {
 722                     addSuccessor(blockMap, current.endBci, b);
 723                 }
 724                 current = b;
 725             }
 726             blockMap[bci] = current;
 727             current.endBci = bci;
 728 
 729             switch (stream.currentBC()) {
 730                 case IRETURN: // fall through
 731                 case LRETURN: // fall through
 732                 case FRETURN: // fall through
 733                 case DRETURN: // fall through
 734                 case ARETURN: // fall through
 735                 case RETURN: {
 736                     current = null;
 737                     break;
 738                 }
 739                 case ATHROW: {
 740                     current = null;
 741                     ExceptionDispatchBlock handler = handleExceptions(blockMap, bci);
 742                     if (handler != null) {
 743                         addSuccessor(blockMap, bci, handler);
 744                     }
 745                     break;
 746                 }
 747                 case IFEQ:      // fall through
 748                 case IFNE:      // fall through
 749                 case IFLT:      // fall through
 750                 case IFGE:      // fall through
 751                 case IFGT:      // fall through
 752                 case IFLE:      // fall through
 753                 case IF_ICMPEQ: // fall through
 754                 case IF_ICMPNE: // fall through
 755                 case IF_ICMPLT: // fall through
 756                 case IF_ICMPGE: // fall through
 757                 case IF_ICMPGT: // fall through
 758                 case IF_ICMPLE: // fall through
 759                 case IF_ACMPEQ: // fall through
 760                 case IF_ACMPNE: // fall through
 761                 case IFNULL:    // fall through
 762                 case IFNONNULL: {
 763                     current = null;
 764                     addSuccessor(blockMap, bci, makeBlock(blockMap, stream.readBranchDest()));
 765                     addSuccessor(blockMap, bci, makeBlock(blockMap, stream.nextBCI()));
 766                     break;
 767                 }
 768                 case GOTO:
 769                 case GOTO_W: {
 770                     current = null;
 771                     addSuccessor(blockMap, bci, makeBlock(blockMap, stream.readBranchDest()));
 772                     break;
 773                 }
 774                 case TABLESWITCH: {
 775                     current = null;
 776                     addSwitchSuccessors(blockMap, bci, new BytecodeTableSwitch(stream, bci));
 777                     break;
 778                 }
 779                 case LOOKUPSWITCH: {
 780                     current = null;
 781                     addSwitchSuccessors(blockMap, bci, new BytecodeLookupSwitch(stream, bci));
 782                     break;
 783                 }
 784                 case JSR:
 785                 case JSR_W: {
 786                     hasJsrBytecodes = true;
 787                     int target = stream.readBranchDest();
 788                     if (target == 0) {
 789                         throw new JsrNotSupportedBailout(&quot;jsr target bci 0 not allowed&quot;);
 790                     }
 791                     BciBlock b1 = makeBlock(blockMap, target);
 792                     current.setJsrSuccessor(b1);
 793                     current.setJsrReturnBci(stream.nextBCI());
 794                     current = null;
 795                     addSuccessor(blockMap, bci, b1);
 796                     break;
 797                 }
 798                 case RET: {
 799                     current.setEndsWithRet();
 800                     current = null;
 801                     break;
 802                 }
 803                 case INVOKEINTERFACE:
 804                 case INVOKESPECIAL:
 805                 case INVOKESTATIC:
 806                 case INVOKEVIRTUAL:
 807                 case INVOKEDYNAMIC: {
 808                     current = null;
 809                     addSuccessor(blockMap, bci, makeBlock(blockMap, stream.nextBCI()));
 810                     ExceptionDispatchBlock handler = handleExceptions(blockMap, bci);
 811                     if (handler != null) {
 812                         addSuccessor(blockMap, bci, handler);
 813                     }
 814                     break;
 815                 }
 816                 case IDIV:
 817                 case IREM:
 818                 case LDIV:
 819                 case LREM:
 820                 case IASTORE:
 821                 case LASTORE:
 822                 case FASTORE:
 823                 case DASTORE:
 824                 case AASTORE:
 825                 case BASTORE:
 826                 case CASTORE:
 827                 case SASTORE:
 828                 case IALOAD:
 829                 case LALOAD:
 830                 case FALOAD:
 831                 case DALOAD:
 832                 case AALOAD:
 833                 case BALOAD:
 834                 case CALOAD:
 835                 case SALOAD:
 836                 case ARRAYLENGTH:
 837                 case CHECKCAST:
 838                 case INSTANCEOF:
 839                 case NEW:
 840                 case NEWARRAY:
 841                 case ANEWARRAY:
 842                 case MULTIANEWARRAY:
 843                 case PUTSTATIC:
 844                 case GETSTATIC:
 845                 case PUTFIELD:
 846                 case GETFIELD:
 847                 case LDC:
 848                 case LDC_W:
 849                 case LDC2_W:
 850                 case MONITORENTER: {
 851                     /*
 852                      * All bytecodes that can trigger lazy class initialization via a
 853                      * ClassInitializationPlugin (allocations, static field access) must be listed
 854                      * because the class initializer is allowed to throw an exception, which
 855                      * requires proper exception handling.
 856                      */
 857                     ExceptionDispatchBlock handler = handleExceptions(blockMap, bci);
 858                     if (handler != null) {
 859                         current = null;
 860                         addSuccessor(blockMap, bci, makeBlock(blockMap, stream.nextBCI()));
 861                         addSuccessor(blockMap, bci, handler);
 862                     }
 863                     break;
 864                 }
 865 
 866                 case NOP:
 867                 case ACONST_NULL:
 868                 case ICONST_M1:
 869                 case ICONST_0:
 870                 case ICONST_1:
 871                 case ICONST_2:
 872                 case ICONST_3:
 873                 case ICONST_4:
 874                 case ICONST_5:
 875                 case LCONST_0:
 876                 case LCONST_1:
 877                 case FCONST_0:
 878                 case FCONST_1:
 879                 case FCONST_2:
 880                 case DCONST_0:
 881                 case DCONST_1:
 882                 case BIPUSH:
 883                 case SIPUSH:
 884                 case ILOAD:
 885                 case LLOAD:
 886                 case FLOAD:
 887                 case DLOAD:
 888                 case ALOAD:
 889                 case ILOAD_0:
 890                 case ILOAD_1:
 891                 case ILOAD_2:
 892                 case ILOAD_3:
 893                 case LLOAD_0:
 894                 case LLOAD_1:
 895                 case LLOAD_2:
 896                 case LLOAD_3:
 897                 case FLOAD_0:
 898                 case FLOAD_1:
 899                 case FLOAD_2:
 900                 case FLOAD_3:
 901                 case DLOAD_0:
 902                 case DLOAD_1:
 903                 case DLOAD_2:
 904                 case DLOAD_3:
 905                 case ALOAD_0:
 906                 case ALOAD_1:
 907                 case ALOAD_2:
 908                 case ALOAD_3:
 909                 case ISTORE:
 910                 case LSTORE:
 911                 case FSTORE:
 912                 case DSTORE:
 913                 case ASTORE:
 914                 case ISTORE_0:
 915                 case ISTORE_1:
 916                 case ISTORE_2:
 917                 case ISTORE_3:
 918                 case LSTORE_0:
 919                 case LSTORE_1:
 920                 case LSTORE_2:
 921                 case LSTORE_3:
 922                 case FSTORE_0:
 923                 case FSTORE_1:
 924                 case FSTORE_2:
 925                 case FSTORE_3:
 926                 case DSTORE_0:
 927                 case DSTORE_1:
 928                 case DSTORE_2:
 929                 case DSTORE_3:
 930                 case ASTORE_0:
 931                 case ASTORE_1:
 932                 case ASTORE_2:
 933                 case ASTORE_3:
 934                 case POP:
 935                 case POP2:
 936                 case DUP:
 937                 case DUP_X1:
 938                 case DUP_X2:
 939                 case DUP2:
 940                 case DUP2_X1:
 941                 case DUP2_X2:
 942                 case SWAP:
 943                 case IADD:
 944                 case LADD:
 945                 case FADD:
 946                 case DADD:
 947                 case ISUB:
 948                 case LSUB:
 949                 case FSUB:
 950                 case DSUB:
 951                 case IMUL:
 952                 case LMUL:
 953                 case FMUL:
 954                 case DMUL:
 955                 case FDIV:
 956                 case DDIV:
 957                 case FREM:
 958                 case DREM:
 959                 case INEG:
 960                 case LNEG:
 961                 case FNEG:
 962                 case DNEG:
 963                 case ISHL:
 964                 case LSHL:
 965                 case ISHR:
 966                 case LSHR:
 967                 case IUSHR:
 968                 case LUSHR:
 969                 case IAND:
 970                 case LAND:
 971                 case IOR:
 972                 case LOR:
 973                 case IXOR:
 974                 case LXOR:
 975                 case IINC:
 976                 case I2L:
 977                 case I2F:
 978                 case I2D:
 979                 case L2I:
 980                 case L2F:
 981                 case L2D:
 982                 case F2I:
 983                 case F2L:
 984                 case F2D:
 985                 case D2I:
 986                 case D2L:
 987                 case D2F:
 988                 case I2B:
 989                 case I2C:
 990                 case I2S:
 991                 case LCMP:
 992                 case FCMPL:
 993                 case FCMPG:
 994                 case DCMPL:
 995                 case DCMPG:
 996                 case MONITOREXIT:
 997                     // All stack manipulation, comparison, conversion and arithmetic operators
 998                     // except for idiv and irem can&#39;t throw exceptions so the don&#39;t need to connect
 999                     // exception edges. MONITOREXIT can&#39;t throw exceptions in the context of
1000                     // compiled code because of the structured locking requirement in the parser.
1001                     break;
1002 
1003                 case WIDE:
1004                 case BREAKPOINT:
1005                 default:
1006                     throw new GraalError(&quot;Unhandled bytecode&quot;);
1007             }
1008             stream.next();
1009         }
1010     }
1011 
1012     private BciBlock makeBlock(BciBlock[] blockMap, int startBci) {
1013         BciBlock oldBlock = blockMap[startBci];
1014         if (oldBlock == null) {
1015             BciBlock newBlock = new BciBlock(startBci);
1016             blocksNotYetAssignedId++;
1017             blockMap[startBci] = newBlock;
1018             return newBlock;
1019 
1020         } else if (oldBlock.startBci != startBci) {
1021             // Backward branch into the middle of an already processed block.
1022             // Add the correct fall-through successor.
1023             BciBlock newBlock = new BciBlock(startBci);
1024             blocksNotYetAssignedId++;
1025             newBlock.endBci = oldBlock.endBci;
1026             for (BciBlock oldSuccessor : oldBlock.getSuccessors()) {
1027                 newBlock.addSuccessor(oldSuccessor);
1028             }
1029 
1030             oldBlock.endBci = startBci - 1;
1031             oldBlock.clearSucccessors();
1032             oldBlock.addSuccessor(newBlock);
1033 
1034             for (int i = startBci; i &lt;= newBlock.endBci; i++) {
1035                 blockMap[i] = newBlock;
1036             }
1037             return newBlock;
1038 
1039         } else {
1040             return oldBlock;
1041         }
1042     }
1043 
1044     private void addSwitchSuccessors(BciBlock[] blockMap, int predBci, BytecodeSwitch bswitch) {
1045         // adds distinct targets to the successor list
1046         Collection&lt;Integer&gt; targets = new TreeSet&lt;&gt;();
1047         for (int i = 0; i &lt; bswitch.numberOfCases(); i++) {
1048             targets.add(bswitch.targetAt(i));
1049         }
1050         targets.add(bswitch.defaultTarget());
1051         for (int targetBci : targets) {
1052             addSuccessor(blockMap, predBci, makeBlock(blockMap, targetBci));
1053         }
1054     }
1055 
1056     private static void addSuccessor(BciBlock[] blockMap, int predBci, BciBlock sux) {
1057         BciBlock predecessor = blockMap[predBci];
1058         if (sux.isExceptionEntry) {
1059             throw new PermanentBailoutException(&quot;Exception handler can be reached by both normal and exceptional control flow&quot;);
1060         }
1061         predecessor.addSuccessor(sux);
1062     }
1063 
1064     private final ArrayList&lt;BciBlock&gt; jsrVisited = new ArrayList&lt;&gt;();
1065 
1066     private void createJsrAlternatives(BciBlock[] blockMap, BciBlock block) {
1067         jsrVisited.add(block);
1068         JsrScope scope = block.getJsrScope();
1069 
1070         if (block.endsWithRet()) {
1071             block.setRetSuccessor(blockMap[scope.nextReturnAddress()]);
1072             block.addSuccessor(block.getRetSuccessor());
1073             assert block.getRetSuccessor() != block.getJsrSuccessor();
1074         }
1075         debug.log(&quot;JSR alternatives block %s  sux %s  jsrSux %s  retSux %s  jsrScope %s&quot;, block, block.getSuccessors(), block.getJsrSuccessor(), block.getRetSuccessor(), block.getJsrScope());
1076 
1077         if (block.getJsrSuccessor() != null || !scope.isEmpty()) {
1078             for (int i = 0; i &lt; block.getSuccessorCount(); i++) {
1079                 BciBlock successor = block.getSuccessor(i);
1080                 JsrScope nextScope = scope;
1081                 if (successor == block.getJsrSuccessor()) {
1082                     nextScope = scope.push(block.getJsrReturnBci(), successor);
1083                 }
1084                 if (successor == block.getRetSuccessor()) {
1085                     nextScope = scope.pop();
1086                 }
1087                 if (!successor.getJsrScope().isPrefixOf(nextScope)) {
1088                     throw new JsrNotSupportedBailout(&quot;unstructured control flow  (&quot; + successor.getJsrScope() + &quot; &quot; + nextScope + &quot;)&quot;);
1089                 }
1090                 if (!nextScope.isEmpty()) {
1091                     BciBlock clone;
1092                     if (successor.getJsrAlternatives() != null &amp;&amp; successor.getJsrAlternatives().containsKey(nextScope)) {
1093                         clone = successor.getJsrAlternatives().get(nextScope);
1094                     } else {
1095                         successor.initJsrAlternatives();
1096                         clone = successor.copy();
1097                         blocksNotYetAssignedId++;
1098                         clone.setJsrScope(nextScope);
1099                         successor.getJsrAlternatives().put(nextScope, clone);
1100                     }
1101                     block.getSuccessors().set(i, clone);
1102                     if (successor == block.getJsrSuccessor()) {
1103                         block.setJsrSuccessor(clone);
1104                     }
1105                     if (successor == block.getRetSuccessor()) {
1106                         block.setRetSuccessor(clone);
1107                     }
1108                 }
1109             }
1110         }
1111         for (BciBlock successor : block.getSuccessors()) {
1112             if (!jsrVisited.contains(successor) &amp;&amp; shouldFollowEdge(successor, scope)) {
1113                 createJsrAlternatives(blockMap, successor);
1114             }
1115         }
1116     }
1117 
1118     private static boolean shouldFollowEdge(BciBlock successor, JsrScope scope) {
1119         if (successor instanceof ExceptionDispatchBlock &amp;&amp; scope.getJsrEntryBlock() != null) {
1120             ExceptionDispatchBlock exceptionDispatchBlock = (ExceptionDispatchBlock) successor;
1121             int bci = scope.getJsrEntryBlock().startBci;
1122             if (exceptionDispatchBlock.handler.getStartBCI() &lt; bci &amp;&amp; bci &lt; exceptionDispatchBlock.handler.getEndBCI()) {
1123                 // Handler covers start of JSR block and the bci before that =&gt; don&#39;t follow edge.
1124                 return false;
1125             }
1126         }
1127 
1128         return true;
1129     }
1130 
1131     private ExceptionDispatchBlock handleExceptions(BciBlock[] blockMap, int bci) {
1132         ExceptionDispatchBlock lastHandler = null;
1133         int dispatchBlocks = 0;
1134 
1135         for (int i = exceptionHandlers.length - 1; i &gt;= 0; i--) {
1136             ExceptionHandler h = exceptionHandlers[i];
1137             if (h.getStartBCI() &lt;= bci &amp;&amp; bci &lt; h.getEndBCI()) {
1138                 if (h.isCatchAll()) {
1139                     // Discard all information about succeeding exception handlers, since they can
1140                     // never be reached.
1141                     dispatchBlocks = 0;
1142                     lastHandler = null;
1143                 }
1144 
1145                 // We do not reuse exception dispatch blocks, because nested exception handlers
1146                 // might have problems reasoning about the correct frame state.
1147                 ExceptionDispatchBlock curHandler = new ExceptionDispatchBlock(h, bci);
1148                 dispatchBlocks++;
1149                 curHandler.addSuccessor(blockMap[h.getHandlerBCI()]);
1150                 if (lastHandler != null) {
1151                     curHandler.addSuccessor(lastHandler);
1152                 }
1153                 lastHandler = curHandler;
1154             }
1155         }
1156         blocksNotYetAssignedId += dispatchBlocks;
1157         return lastHandler;
1158     }
1159 
1160     private boolean loopChanges;
1161 
1162     private void fixLoopBits(BciBlock[] blockMap) {
1163         do {
1164             loopChanges = false;
1165             for (BciBlock b : blocks) {
1166                 b.visited = false;
1167             }
1168 
1169             long loop = fixLoopBits(blockMap[0]);
1170 
1171             if (loop != 0) {
1172                 // There is a path from a loop end to the method entry that does not pass the loop
1173                 // header.
1174                 // Therefore, the loop is non reducible (has more than one entry).
1175                 // We don&#39;t want to compile such methods because the IR only supports structured
1176                 // loops.
1177                 throw new PermanentBailoutException(&quot;Non-reducible loop: %016x&quot;, loop);
1178             }
1179         } while (loopChanges);
1180     }
1181 
1182     private void computeBlockOrder(BciBlock[] blockMap) {
1183         int maxBlocks = blocksNotYetAssignedId;
1184         this.blocks = new BciBlock[blocksNotYetAssignedId];
1185         long loop = computeBlockOrder(blockMap[0]);
1186 
1187         if (loop != 0) {
1188             // There is a path from a loop end to the method entry that does not pass the loop
1189             // header. Therefore, the loop is non reducible (has more than one entry).
1190             // We don&#39;t want to compile such methods because the IR only supports structured loops.
1191             throw new PermanentBailoutException(&quot;Non-reducible loop&quot;);
1192         }
1193 
1194         // Purge null entries for unreached blocks and sort blocks such that loop bodies are always
1195         // consecutively in the array.
1196         int blockCount = maxBlocks - blocksNotYetAssignedId + 1;
1197         BciBlock[] newBlocks = new BciBlock[blockCount];
1198         int next = 0;
1199         for (int i = 0; i &lt; blocks.length; ++i) {
1200             BciBlock b = blocks[i];
1201             if (b != null) {
1202                 b.setId(next);
1203                 newBlocks[next++] = b;
1204                 if (b.isLoopHeader) {
1205                     next = handleLoopHeader(newBlocks, next, i, b);
1206                 }
1207             }
1208         }
1209         assert next == newBlocks.length - 1;
1210 
1211         // Add unwind block.
1212         ExceptionDispatchBlock unwindBlock = new ExceptionDispatchBlock(BytecodeFrame.AFTER_EXCEPTION_BCI);
1213         unwindBlock.setId(newBlocks.length - 1);
1214         newBlocks[newBlocks.length - 1] = unwindBlock;
1215 
1216         blocks = newBlocks;
1217     }
1218 
1219     private int handleLoopHeader(BciBlock[] newBlocks, int nextStart, int i, BciBlock loopHeader) {
1220         int next = nextStart;
1221         int endOfLoop = nextStart - 1;
1222         for (int j = i + 1; j &lt; blocks.length; ++j) {
1223             BciBlock other = blocks[j];
1224             if (other != null &amp;&amp; (other.loops &amp; (1L &lt;&lt; loopHeader.loopId)) != 0) {
1225                 other.setId(next);
1226                 endOfLoop = next;
1227                 newBlocks[next++] = other;
1228                 blocks[j] = null;
1229                 if (other.isLoopHeader) {
1230                     next = handleLoopHeader(newBlocks, next, j, other);
1231                 }
1232             }
1233         }
1234         loopHeader.loopEnd = endOfLoop;
1235         return next;
1236     }
1237 
1238     public void log(BciBlock[] blockMap, String name) {
1239         if (debug.isLogEnabled()) {
1240             debug.log(&quot;%sBlockMap %s: %n%s&quot;, debug.getCurrentScopeName(), name, toString(blockMap, loopHeaders));
1241         }
1242     }
1243 
1244     public static String toString(BciBlock[] blockMap, BciBlock[] loopHeadersMap) {
1245         StringBuilder sb = new StringBuilder();
1246         for (BciBlock b : blockMap) {
1247             if (b == null) {
1248                 continue;
1249             }
1250             sb.append(&quot;B&quot;).append(b.getId()).append(&quot;[&quot;).append(b.startBci).append(&quot;..&quot;).append(b.endBci).append(&quot;]&quot;);
1251             if (b.isLoopHeader) {
1252                 sb.append(&quot; LoopHeader&quot;);
1253             }
1254             if (b.isExceptionEntry) {
1255                 sb.append(&quot; ExceptionEntry&quot;);
1256             }
1257             if (b instanceof ExceptionDispatchBlock) {
1258                 sb.append(&quot; ExceptionDispatch&quot;);
1259             }
1260             if (!b.successors.isEmpty()) {
1261                 sb.append(&quot; Successors=[&quot;);
1262                 for (BciBlock s : b.getSuccessors()) {
1263                     if (sb.charAt(sb.length() - 1) != &#39;[&#39;) {
1264                         sb.append(&quot;, &quot;);
1265                     }
1266                     sb.append(&quot;B&quot;).append(s.getId());
1267                 }
1268                 sb.append(&quot;]&quot;);
1269             }
1270             if (b.loops != 0L) {
1271                 sb.append(&quot; Loops=[&quot;);
1272                 for (int pos : b.loopIdIterable()) {
1273                     if (sb.charAt(sb.length() - 1) == &#39;[&#39;) {
1274                         sb.append(&quot;, &quot;);
1275                     }
1276                     sb.append(&quot;B&quot;).append(loopHeadersMap[pos].getId());
1277                 }
1278                 sb.append(&quot;]&quot;);
1279             }
1280             sb.append(System.lineSeparator());
1281         }
1282         return sb.toString();
1283     }
1284 
1285     @Override
1286     public String toString() {
1287         return toString(blocks, loopHeaders);
1288     }
1289 
1290     /**
1291      * Get the header block for a loop index.
1292      */
1293     public BciBlock getLoopHeader(int index) {
1294         return loopHeaders[index];
1295     }
1296 
1297     /**
1298      * The next available loop number.
1299      */
1300     private int nextLoop;
1301 
1302     /**
1303      * Mark the block as a loop header, using the next available loop number. Also checks for corner
1304      * cases that we don&#39;t want to compile.
1305      */
1306     private void makeLoopHeader(BciBlock block) {
1307         if (!block.isLoopHeader) {
1308             block.isLoopHeader = true;
1309 
1310             if (block.isExceptionEntry) {
1311                 // Loops that are implicitly formed by an exception handler lead to all sorts of
1312                 // corner cases.
1313                 // Don&#39;t compile such methods for now, until we see a concrete case that allows
1314                 // checking for correctness.
1315                 throw new PermanentBailoutException(&quot;Loop formed by an exception handler&quot;);
1316             }
1317             if (nextLoop &gt;= LOOP_HEADER_MAX_CAPACITY) {
1318                 // This restriction can be removed by using a fall-back to a BitSet in case we have
1319                 // more than 64 loops
1320                 // Don&#39;t compile such methods for now, until we see a concrete case that allows
1321                 // checking for correctness.
1322                 throw new PermanentBailoutException(&quot;Too many loops in method&quot;);
1323             }
1324 
1325             assert block.loops == 0;
1326             block.loops = 1L &lt;&lt; nextLoop;
1327             debug.log(&quot;makeLoopHeader(%s) -&gt; %x&quot;, block, block.loops);
1328             if (loopHeaders == null) {
1329                 loopHeaders = new BciBlock[LOOP_HEADER_INITIAL_CAPACITY];
1330             } else if (nextLoop &gt;= loopHeaders.length) {
1331                 loopHeaders = Arrays.copyOf(loopHeaders, LOOP_HEADER_MAX_CAPACITY);
1332             }
1333             loopHeaders[nextLoop] = block;
1334             block.loopId = nextLoop;
1335             nextLoop++;
1336         }
1337         assert Long.bitCount(block.loops) == 1;
1338     }
1339 
1340     /**
1341      * Non-recursive depth-first traversal of the control flow graph. The flag
1342      * {@linkplain BciBlock#visited} is used to visit every block only once. The flag
1343      * {@linkplain BciBlock#active} is used to detect cycles (backward edges)
1344      */
1345     private long computeBlockOrder(BciBlock initialBlock) {
1346         ArrayDeque&lt;TraversalStep&gt; workStack = new ArrayDeque&lt;&gt;();
1347         workStack.push(new TraversalStep(initialBlock));
1348         while (true) {
1349             TraversalStep step = workStack.peek();
1350             BciBlock block = step.block;
1351             if (step.currentSuccessorIndex == 0) {
1352                 block.visited = true;
1353                 block.active = true;
1354             } else {
1355                 BciBlock successor = block.getSuccessor(step.currentSuccessorIndex - 1);
1356                 if (successor.active) {
1357                     // Reached block via backward branch.
1358                     step.loops |= (1L &lt;&lt; successor.loopId);
1359                 }
1360             }
1361             if (step.currentSuccessorIndex &lt; block.successors.size()) {
1362                 BciBlock successor = block.getSuccessors().get(step.currentSuccessorIndex);
1363                 if (successor.visited) {
1364                     if (successor.active) {
1365                         // Reached block via backward branch.
1366                         makeLoopHeader(successor);
1367                         step.loops |= successor.loops;
1368                     } else if (successor.isLoopHeader) {
1369                         step.loops |= successor.loops &amp; ~(1L &lt;&lt; successor.loopId);
1370                     } else {
1371                         step.loops |= successor.loops;
1372                     }
1373                 } else {
1374                     workStack.push(new TraversalStep(successor));
1375                 }
1376                 step.currentSuccessorIndex++;
1377             } else {
1378                 // We processed all the successors of this block.
1379                 block.loops = step.loops;
1380                 debug.log(&quot;computeBlockOrder(%s) -&gt; %x&quot;, block, block.loops);
1381 
1382                 if (block.isLoopHeader) {
1383                     step.loops &amp;= ~(1L &lt;&lt; block.loopId);
1384                 }
1385 
1386                 block.active = false;
1387                 blocksNotYetAssignedId--;
1388                 blocks[blocksNotYetAssignedId] = block;
1389 
1390                 workStack.pop();
1391                 if (!workStack.isEmpty()) {
1392                     workStack.peek().loops |= step.loops;
1393                 } else {
1394                     return step.loops;
1395                 }
1396             }
1397         }
1398     }
1399 
1400     private long fixLoopBits(BciBlock initialBlock) {
1401         ArrayDeque&lt;TraversalStep&gt; workStack = new ArrayDeque&lt;&gt;();
1402         workStack.push(new TraversalStep(initialBlock));
1403         while (true) {
1404             TraversalStep step = workStack.peek();
1405             BciBlock block = step.block;
1406             if (step.currentSuccessorIndex == 0) {
1407                 block.visited = true;
1408                 step.loops = block.loops;
1409             }
1410             if (step.currentSuccessorIndex &lt; block.getSuccessors().size()) {
1411                 BciBlock successor = block.getSuccessors().get(step.currentSuccessorIndex);
1412                 if (successor.visited) {
1413                     // Return cached loop information for this block.
1414                     if (successor.isLoopHeader) {
1415                         step.loops |= successor.loops &amp; ~(1L &lt;&lt; successor.loopId);
1416                     } else {
1417                         step.loops |= successor.loops;
1418                     }
1419                 } else {
1420                     workStack.push(new TraversalStep(successor));
1421                 }
1422                 step.currentSuccessorIndex++;
1423             } else {
1424                 if (block.loops != step.loops) {
1425                     loopChanges = true;
1426                     block.loops = step.loops;
1427                     debug.log(&quot;fixLoopBits0(%s) -&gt; %x&quot;, block, block.loops);
1428                 }
1429 
1430                 if (block.isLoopHeader) {
1431                     step.loops &amp;= ~(1L &lt;&lt; block.loopId);
1432                 }
1433 
1434                 workStack.pop();
1435                 if (!workStack.isEmpty()) {
1436                     workStack.peek().loops |= step.loops;
1437                 } else {
1438                     return step.loops;
1439                 }
1440             }
1441         }
1442     }
1443 
1444     public static BciBlockMapping create(BytecodeStream stream, Bytecode code, OptionValues options, DebugContext debug) {
1445         BciBlockMapping map = new BciBlockMapping(code, debug);
1446         map.build(stream, options);
1447         if (debug.isDumpEnabled(DebugContext.INFO_LEVEL)) {
1448             debug.dump(DebugContext.INFO_LEVEL, map, code.getMethod().format(&quot;After block building %f %R %H.%n(%P)&quot;));
1449         }
1450 
1451         return map;
1452     }
1453 
1454     public BciBlock[] getLoopHeaders() {
1455         return loopHeaders;
1456     }
1457 
1458     public BciBlock getStartBlock() {
1459         return startBlock;
1460     }
1461 
1462     public ExceptionDispatchBlock getUnwindBlock() {
1463         return (ExceptionDispatchBlock) blocks[blocks.length - 1];
1464     }
1465 
1466     public int getLoopCount() {
1467         return nextLoop;
1468     }
1469 
1470     public int getBlockCount() {
1471         return blocks.length;
1472     }
1473 }
    </pre>
  </body>
</html>
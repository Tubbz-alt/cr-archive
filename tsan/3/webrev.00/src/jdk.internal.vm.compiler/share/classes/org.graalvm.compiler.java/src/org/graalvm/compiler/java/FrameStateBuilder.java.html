<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/FrameStateBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.java;
  26 
  27 import static org.graalvm.compiler.bytecode.Bytecodes.DUP;
  28 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2;
  29 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X1;
  30 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X2;
  31 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X1;
  32 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X2;
  33 import static org.graalvm.compiler.bytecode.Bytecodes.POP;
  34 import static org.graalvm.compiler.bytecode.Bytecodes.POP2;
  35 import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;
  36 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
  37 import static org.graalvm.compiler.nodes.FrameState.TWO_SLOT_MARKER;
  38 import static org.graalvm.compiler.nodes.util.GraphUtil.originalValue;
  39 
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
  42 import java.util.List;
  43 import java.util.function.Function;
  44 
  45 import org.graalvm.compiler.bytecode.Bytecode;
  46 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  47 import org.graalvm.compiler.core.common.PermanentBailoutException;
  48 import org.graalvm.compiler.core.common.type.StampFactory;
  49 import org.graalvm.compiler.core.common.type.StampPair;
  50 import org.graalvm.compiler.debug.DebugContext;
  51 import org.graalvm.compiler.debug.GraalError;
  52 import org.graalvm.compiler.graph.NodeSourcePosition;
  53 import org.graalvm.compiler.java.BciBlockMapping.BciBlock;
  54 import org.graalvm.compiler.nodeinfo.Verbosity;
  55 import org.graalvm.compiler.nodes.AbstractMergeNode;
  56 import org.graalvm.compiler.nodes.ConstantNode;
  57 import org.graalvm.compiler.nodes.FrameState;
  58 import org.graalvm.compiler.nodes.LoopBeginNode;
  59 import org.graalvm.compiler.nodes.LoopExitNode;
  60 import org.graalvm.compiler.nodes.NodeView;
  61 import org.graalvm.compiler.nodes.ParameterNode;
  62 import org.graalvm.compiler.nodes.PhiNode;
  63 import org.graalvm.compiler.nodes.ProxyNode;
  64 import org.graalvm.compiler.nodes.StateSplit;
  65 import org.graalvm.compiler.nodes.StructuredGraph;
  66 import org.graalvm.compiler.nodes.ValueNode;
  67 import org.graalvm.compiler.nodes.ValuePhiNode;
  68 import org.graalvm.compiler.nodes.calc.FloatingNode;
  69 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
  70 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderTool;
  71 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.SideEffectsState;
  72 import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
  73 import org.graalvm.compiler.nodes.java.MonitorIdNode;
  74 
  75 import jdk.vm.ci.code.BytecodeFrame;
  76 import jdk.vm.ci.meta.Assumptions;
  77 import jdk.vm.ci.meta.JavaKind;
  78 import jdk.vm.ci.meta.JavaType;
  79 import jdk.vm.ci.meta.ResolvedJavaMethod;
  80 import jdk.vm.ci.meta.ResolvedJavaType;
  81 import jdk.vm.ci.meta.Signature;
  82 
  83 public final class FrameStateBuilder implements SideEffectsState {
  84 
  85     private static final ValueNode[] EMPTY_ARRAY = new ValueNode[0];
  86     private static final MonitorIdNode[] EMPTY_MONITOR_ARRAY = new MonitorIdNode[0];
  87 
  88     private final BytecodeParser parser;
  89     private final GraphBuilderTool tool;
  90     private final Bytecode code;
  91     private int stackSize;
  92     protected final ValueNode[] locals;
  93     protected final ValueNode[] stack;
  94     private ValueNode[] lockedObjects;
  95     private boolean canVerifyKind;
  96 
  97     /**
  98      * @see BytecodeFrame#rethrowException
  99      */
 100     private boolean rethrowException;
 101 
 102     private MonitorIdNode[] monitorIds;
 103     private final StructuredGraph graph;
 104     private final boolean clearNonLiveLocals;
 105     private FrameState outerFrameState;
 106     private NodeSourcePosition outerSourcePosition;
 107 
 108     /**
 109      * The closest {@link StateSplit#hasSideEffect() side-effect} predecessors. There will be more
 110      * than one when the current block contains no side-effects but merging predecessor blocks do.
 111      */
 112     private List&lt;StateSplit&gt; sideEffects;
 113 
 114     /**
 115      * Creates a new frame state builder for the given method and the given target graph.
 116      *
 117      * @param method the method whose frame is simulated
 118      * @param graph the target graph of Graal nodes created by the builder
 119      */
 120     public FrameStateBuilder(GraphBuilderTool tool, ResolvedJavaMethod method, StructuredGraph graph) {
 121         this(tool, new ResolvedJavaMethodBytecode(method), graph, false);
 122     }
 123 
 124     /**
 125      * Creates a new frame state builder for the given code attribute, method and the given target
 126      * graph. Additionally specifies if nonLiveLocals should be retained.
 127      *
 128      * @param code the bytecode in which the frame exists
 129      * @param graph the target graph of Graal nodes created by the builder
 130      * @param shouldRetainLocalVariables specifies if nonLiveLocals should be retained in state.
 131      */
 132     public FrameStateBuilder(GraphBuilderTool tool, Bytecode code, StructuredGraph graph, boolean shouldRetainLocalVariables) {
 133         this.tool = tool;
 134         if (tool instanceof BytecodeParser) {
 135             this.parser = (BytecodeParser) tool;
 136         } else {
 137             this.parser = null;
 138         }
 139         this.code = code;
 140         this.locals = allocateArray(code.getMaxLocals());
 141         this.stack = allocateArray(Math.max(1, code.getMaxStackSize()));
 142         this.lockedObjects = allocateArray(0);
 143 
 144         assert graph != null;
 145 
 146         this.monitorIds = EMPTY_MONITOR_ARRAY;
 147         this.graph = graph;
 148         this.clearNonLiveLocals = !shouldRetainLocalVariables;
 149         this.canVerifyKind = true;
 150     }
 151 
 152     public void disableKindVerification() {
 153         canVerifyKind = false;
 154     }
 155 
 156     public void initializeFromArgumentsArray(ValueNode[] arguments) {
 157 
 158         int javaIndex = 0;
 159         int index = 0;
 160         if (!getMethod().isStatic()) {
 161             // set the receiver
 162             locals[javaIndex] = arguments[index];
 163             javaIndex = 1;
 164             index = 1;
 165         }
 166         Signature sig = getMethod().getSignature();
 167         int max = sig.getParameterCount(false);
 168         for (int i = 0; i &lt; max; i++) {
 169             JavaKind kind = sig.getParameterKind(i);
 170             locals[javaIndex] = arguments[index];
 171             javaIndex++;
 172             if (kind.needsTwoSlots()) {
 173                 locals[javaIndex] = TWO_SLOT_MARKER;
 174                 javaIndex++;
 175             }
 176             index++;
 177         }
 178     }
 179 
 180     public void initializeForMethodStart(Assumptions assumptions, boolean eagerResolve, Plugins plugins) {
 181 
 182         int javaIndex = 0;
 183         int index = 0;
 184         ResolvedJavaMethod method = getMethod();
 185         ResolvedJavaType originalType = method.getDeclaringClass();
 186         if (!method.isStatic()) {
 187             // add the receiver
 188             FloatingNode receiver = null;
 189             StampPair receiverStamp = null;
 190             if (plugins != null) {
 191                 receiverStamp = plugins.getOverridingStamp(tool, originalType, true);
 192             }
 193             if (receiverStamp == null) {
 194                 receiverStamp = StampFactory.forDeclaredType(assumptions, originalType, true);
 195             }
 196 
 197             if (plugins != null) {
 198                 for (ParameterPlugin plugin : plugins.getParameterPlugins()) {
 199                     receiver = plugin.interceptParameter(tool, index, receiverStamp);
 200                     if (receiver != null) {
 201                         break;
 202                     }
 203                 }
 204             }
 205             if (receiver == null) {
 206                 receiver = new ParameterNode(javaIndex, receiverStamp);
 207             }
 208 
 209             locals[javaIndex] = graph.addOrUniqueWithInputs(receiver);
 210             javaIndex = 1;
 211             index = 1;
 212         }
 213         Signature sig = method.getSignature();
 214         int max = sig.getParameterCount(false);
 215         ResolvedJavaType accessingClass = originalType;
 216         for (int i = 0; i &lt; max; i++) {
 217             JavaType type = sig.getParameterType(i, accessingClass);
 218             if (eagerResolve) {
 219                 type = type.resolve(accessingClass);
 220             }
 221             JavaKind kind = type.getJavaKind();
 222             StampPair stamp = null;
 223             if (plugins != null) {
 224                 stamp = plugins.getOverridingStamp(tool, type, false);
 225             }
 226             if (stamp == null) {
 227                 // GR-714: subword inputs cannot be trusted
 228                 if (kind.getStackKind() != kind) {
 229                     stamp = StampPair.createSingle(StampFactory.forKind(JavaKind.Int));
 230                 } else {
 231                     stamp = StampFactory.forDeclaredType(assumptions, type, false);
 232                 }
 233             }
 234 
 235             FloatingNode param = null;
 236             if (plugins != null) {
 237                 for (ParameterPlugin plugin : plugins.getParameterPlugins()) {
 238                     param = plugin.interceptParameter(tool, index, stamp);
 239                     if (param != null) {
 240                         break;
 241                     }
 242                 }
 243             }
 244             if (param == null) {
 245                 param = new ParameterNode(index, stamp);
 246             }
 247 
 248             locals[javaIndex] = graph.addOrUniqueWithInputs(param);
 249             javaIndex++;
 250             if (kind.needsTwoSlots()) {
 251                 locals[javaIndex] = TWO_SLOT_MARKER;
 252                 javaIndex++;
 253             }
 254             index++;
 255         }
 256     }
 257 
 258     private FrameStateBuilder(FrameStateBuilder other) {
 259         this.parser = other.parser;
 260         this.tool = other.tool;
 261         this.code = other.code;
 262         this.stackSize = other.stackSize;
 263         this.locals = other.locals.clone();
 264         this.stack = other.stack.clone();
 265         this.lockedObjects = other.lockedObjects.length == 0 ? other.lockedObjects : other.lockedObjects.clone();
 266         this.rethrowException = other.rethrowException;
 267         this.canVerifyKind = other.canVerifyKind;
 268 
 269         assert locals.length == code.getMaxLocals();
 270         assert stack.length == Math.max(1, code.getMaxStackSize());
 271 
 272         assert other.graph != null;
 273         graph = other.graph;
 274         clearNonLiveLocals = other.clearNonLiveLocals;
 275         monitorIds = other.monitorIds.length == 0 ? other.monitorIds : other.monitorIds.clone();
 276 
 277         assert lockedObjects.length == monitorIds.length;
 278     }
 279 
 280     private static ValueNode[] allocateArray(int length) {
 281         return length == 0 ? EMPTY_ARRAY : new ValueNode[length];
 282     }
 283 
 284     public ResolvedJavaMethod getMethod() {
 285         return code.getMethod();
 286     }
 287 
 288     @Override
 289     public String toString() {
 290         StringBuilder sb = new StringBuilder();
 291         sb.append(&quot;[locals: [&quot;);
 292         for (int i = 0; i &lt; locals.length; i++) {
 293             sb.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(locals[i] == null ? &quot;_&quot; : locals[i] == TWO_SLOT_MARKER ? &quot;#&quot; : locals[i].toString(Verbosity.Id));
 294         }
 295         sb.append(&quot;] stack: [&quot;);
 296         for (int i = 0; i &lt; stackSize; i++) {
 297             sb.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(stack[i] == null ? &quot;_&quot; : stack[i] == TWO_SLOT_MARKER ? &quot;#&quot; : stack[i].toString(Verbosity.Id));
 298         }
 299         sb.append(&quot;] locks: [&quot;);
 300         for (int i = 0; i &lt; lockedObjects.length; i++) {
 301             sb.append(i == 0 ? &quot;&quot; : &quot;,&quot;).append(lockedObjects[i].toString(Verbosity.Id)).append(&quot; / &quot;).append(monitorIds[i].toString(Verbosity.Id));
 302         }
 303         sb.append(&quot;]&quot;);
 304         if (rethrowException) {
 305             sb.append(&quot; rethrowException&quot;);
 306         }
 307         sb.append(&quot;]&quot;);
 308         return sb.toString();
 309     }
 310 
 311     public FrameState create(int bci, StateSplit forStateSplit) {
 312         if (parser != null &amp;&amp; parser.parsingIntrinsic()) {
 313             NodeSourcePosition sourcePosition = parser.getGraph().trackNodeSourcePosition() ? createBytecodePosition(bci) : null;
 314             return parser.intrinsicContext.createFrameState(parser.getGraph(), this, forStateSplit, sourcePosition);
 315         }
 316 
 317         // Skip intrinsic frames
 318         return create(bci, parser != null ? parser.getNonIntrinsicAncestor() : null, false, null, null);
 319     }
 320 
 321     /**
 322      * @param pushedValues if non-null, values to {@link #push(JavaKind, ValueNode)} to the stack
 323      *            before creating the {@link FrameState}
 324      */
 325     public FrameState create(int bci, BytecodeParser parent, boolean duringCall, JavaKind[] pushedSlotKinds, ValueNode[] pushedValues) {
 326         if (outerFrameState == null &amp;&amp; parent != null) {
 327             assert !parent.parsingIntrinsic() : &quot;must already have the next non-intrinsic ancestor&quot;;
 328             outerFrameState = parent.getFrameStateBuilder().create(parent.bci(), parent.getNonIntrinsicAncestor(), true, null, null);
 329         }
 330         if (bci == BytecodeFrame.AFTER_EXCEPTION_BCI &amp;&amp; parent != null) {
 331             return outerFrameState.duplicateModified(graph, outerFrameState.bci, true, false, JavaKind.Void, new JavaKind[]{JavaKind.Object}, new ValueNode[]{stack[0]});
 332         }
 333         if (bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 334             throw shouldNotReachHere();
 335         }
 336 
 337         if (pushedValues != null) {
 338             assert pushedSlotKinds.length == pushedValues.length;
 339             int stackSizeToRestore = stackSize;
 340             for (int i = 0; i &lt; pushedValues.length; i++) {
 341                 push(pushedSlotKinds[i], pushedValues[i]);
 342             }
 343             FrameState res = graph.add(new FrameState(outerFrameState, code, bci, locals, stack, stackSize, lockedObjects, Arrays.asList(monitorIds), rethrowException, duringCall));
 344             stackSize = stackSizeToRestore;
 345             return res;
 346         } else {
 347             if (bci == BytecodeFrame.AFTER_EXCEPTION_BCI) {
 348                 assert outerFrameState == null;
 349                 clearLocals();
 350             }
 351             return graph.add(new FrameState(outerFrameState, code, bci, locals, stack, stackSize, lockedObjects, Arrays.asList(monitorIds), rethrowException, duringCall));
 352         }
 353     }
 354 
 355     public NodeSourcePosition createBytecodePosition(int bci) {
 356         BytecodeParser parent = parser.getParent();
 357         NodeSourcePosition position = create(bci, parent);
 358         return position;
 359     }
 360 
 361     private NodeSourcePosition create(int bci, BytecodeParser parent) {
 362         if (outerSourcePosition == null &amp;&amp; parent != null) {
 363             outerSourcePosition = parent.getFrameStateBuilder().createBytecodePosition(parent.bci());
 364         }
 365         if (bci == BytecodeFrame.AFTER_EXCEPTION_BCI &amp;&amp; parent != null) {
 366             return FrameState.toSourcePosition(outerFrameState);
 367         }
 368         if (bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 369             throw shouldNotReachHere();
 370         }
 371         if (parser.intrinsicContext != null &amp;&amp; (parent == null || parent.intrinsicContext != parser.intrinsicContext)) {
 372             // When parsing an intrinsic put in a substitution marker showing the original method as
 373             // the caller. This keeps the relationship between the method and the method
 374             // substitution clear in resulting NodeSourcePosition.
 375             NodeSourcePosition original = new NodeSourcePosition(outerSourcePosition, parser.intrinsicContext.getOriginalMethod(), -1);
 376             return NodeSourcePosition.substitution(original, code.getMethod(), bci);
 377         } else {
 378             return new NodeSourcePosition(outerSourcePosition, code.getMethod(), bci);
 379         }
 380     }
 381 
 382     public FrameStateBuilder copy() {
 383         return new FrameStateBuilder(this);
 384     }
 385 
 386     private String incompatibilityErrorMessage(String reason, FrameStateBuilder other) {
 387         return String.format(&quot;Frame states being merged are incompatible: %s%n This frame state: %s%nOther frame state: %s%nParser context: %s&quot;, reason, this, other, parser);
 388     }
 389 
 390     /**
 391      * Checks invariants that must hold when merging {@code other} into this frame state.
 392      *
 393      * @param other
 394      * @throws PermanentBailoutException if the frame states are incompatible with respect to their
 395      *             locked objects. This indicates bytecode that has unstructured or unbalanced
 396      *             locks.
 397      * @throws GraalError if the frame states are incompatible in terms of {@link #rethrowException}
 398      *             or stack slots
 399      */
 400     public void checkCompatibleWith(FrameStateBuilder other) {
 401         assert code.equals(other.code) &amp;&amp; graph == other.graph &amp;&amp; localsSize() == other.localsSize() : &quot;Can only compare frame states of the same method&quot;;
 402         assert lockedObjects.length == monitorIds.length &amp;&amp; other.lockedObjects.length == other.monitorIds.length : &quot;mismatch between lockedObjects and monitorIds&quot;;
 403 
 404         if (rethrowException != other.rethrowException) {
 405             throw new GraalError(incompatibilityErrorMessage(&quot;mismatch in rethrowException flag&quot;, other));
 406         }
 407 
 408         if (stackSize() != other.stackSize()) {
 409             throw new GraalError(incompatibilityErrorMessage(&quot;mismatch in stack sizes&quot;, other));
 410         }
 411         for (int i = 0; i &lt; stackSize(); i++) {
 412             ValueNode x = stack[i];
 413             ValueNode y = other.stack[i];
 414             assert x != null &amp;&amp; y != null;
 415             if (x != y &amp;&amp; (x == TWO_SLOT_MARKER || x.isDeleted() || y == TWO_SLOT_MARKER || y.isDeleted() || x.getStackKind() != y.getStackKind())) {
 416                 throw new GraalError(incompatibilityErrorMessage(&quot;mismatch in stack types&quot;, other));
 417             }
 418         }
 419         if (lockedObjects.length != other.lockedObjects.length) {
 420             throw new PermanentBailoutException(incompatibilityErrorMessage(&quot;unbalanced monitors - locked objects do not match&quot;, other));
 421         }
 422         for (int i = 0; i &lt; lockedObjects.length; i++) {
 423             if (originalValue(lockedObjects[i], false) != originalValue(other.lockedObjects[i], false)) {
 424                 throw new PermanentBailoutException(incompatibilityErrorMessage(&quot;unbalanced monitors - locked objects do not match&quot;, other));
 425             }
 426             if (monitorIds[i] != other.monitorIds[i]) {
 427                 throw new PermanentBailoutException(incompatibilityErrorMessage(&quot;unbalanced monitors - monitors do not match&quot;, other));
 428             }
 429         }
 430     }
 431 
 432     public void merge(AbstractMergeNode block, FrameStateBuilder other) {
 433         checkCompatibleWith(other);
 434 
 435         for (int i = 0; i &lt; localsSize(); i++) {
 436             locals[i] = merge(locals[i], other.locals[i], block);
 437         }
 438         for (int i = 0; i &lt; stackSize(); i++) {
 439             stack[i] = merge(stack[i], other.stack[i], block);
 440         }
 441         for (int i = 0; i &lt; lockedObjects.length; i++) {
 442             lockedObjects[i] = merge(lockedObjects[i], other.lockedObjects[i], block);
 443             assert monitorIds[i] == other.monitorIds[i];
 444         }
 445 
 446         if (sideEffects == null) {
 447             sideEffects = other.sideEffects;
 448         } else {
 449             if (other.sideEffects != null) {
 450                 sideEffects.addAll(other.sideEffects);
 451             }
 452         }
 453     }
 454 
 455     private ValueNode merge(ValueNode currentValue, ValueNode otherValue, AbstractMergeNode block) {
 456         if (currentValue == null || currentValue.isDeleted()) {
 457             return null;
 458         } else if (block.isPhiAtMerge(currentValue)) {
 459             if (otherValue == null || otherValue == TWO_SLOT_MARKER || otherValue.isDeleted() || currentValue.getStackKind() != otherValue.getStackKind()) {
 460                 // This phi must be dead anyway, add input of correct stack kind to keep the graph
 461                 // invariants.
 462                 ((PhiNode) currentValue).addInput(ConstantNode.defaultForKind(currentValue.getStackKind(), graph));
 463             } else {
 464                 ((PhiNode) currentValue).addInput(otherValue);
 465             }
 466             return currentValue;
 467         } else if (currentValue != otherValue) {
 468             if (currentValue == TWO_SLOT_MARKER || otherValue == TWO_SLOT_MARKER) {
 469                 return null;
 470             } else if (otherValue == null || otherValue.isDeleted() || currentValue.getStackKind() != otherValue.getStackKind()) {
 471                 return null;
 472             }
 473             assert !(block instanceof LoopBeginNode) : String.format(&quot;Phi functions for loop headers are create eagerly for changed locals and all stack slots: %s != %s&quot;, currentValue, otherValue);
 474             return createValuePhi(currentValue, otherValue, block);
 475         } else {
 476             return currentValue;
 477         }
 478     }
 479 
 480     private ValuePhiNode createValuePhi(ValueNode currentValue, ValueNode otherValue, AbstractMergeNode block) {
 481         ValuePhiNode phi = graph.addWithoutUnique(new ValuePhiNode(currentValue.stamp(NodeView.DEFAULT).unrestricted(), block));
 482         for (int i = 0; i &lt; block.phiPredecessorCount(); i++) {
 483             phi.addInput(currentValue);
 484         }
 485         phi.addInput(otherValue);
 486         assert phi.valueCount() == block.phiPredecessorCount() + 1;
 487         return phi;
 488     }
 489 
 490     public void inferPhiStamps(AbstractMergeNode block) {
 491         for (int i = 0; i &lt; localsSize(); i++) {
 492             inferPhiStamp(block, locals[i]);
 493         }
 494         for (int i = 0; i &lt; stackSize(); i++) {
 495             inferPhiStamp(block, stack[i]);
 496         }
 497         for (int i = 0; i &lt; lockedObjects.length; i++) {
 498             inferPhiStamp(block, lockedObjects[i]);
 499         }
 500     }
 501 
 502     private static void inferPhiStamp(AbstractMergeNode block, ValueNode node) {
 503         if (block.isPhiAtMerge(node)) {
 504             node.inferStamp();
 505         }
 506     }
 507 
 508     public void insertLoopPhis(LocalLiveness liveness, int loopId, LoopBeginNode loopBegin, boolean forcePhis, boolean stampFromValueForForcedPhis) {
 509         for (int i = 0; i &lt; localsSize(); i++) {
 510             boolean changedInLoop = liveness.localIsChangedInLoop(loopId, i);
 511             if (forcePhis || changedInLoop) {
 512                 locals[i] = createLoopPhi(loopBegin, locals[i], stampFromValueForForcedPhis &amp;&amp; !changedInLoop);
 513             }
 514         }
 515         for (int i = 0; i &lt; stackSize(); i++) {
 516             stack[i] = createLoopPhi(loopBegin, stack[i], false);
 517         }
 518         for (int i = 0; i &lt; lockedObjects.length; i++) {
 519             lockedObjects[i] = createLoopPhi(loopBegin, lockedObjects[i], false);
 520         }
 521     }
 522 
 523     public void insertLoopProxies(LoopExitNode loopExit, FrameStateBuilder loopEntryState) {
 524         DebugContext debug = graph.getDebug();
 525         for (int i = 0; i &lt; localsSize(); i++) {
 526             ValueNode value = locals[i];
 527             if (value != null &amp;&amp; value != TWO_SLOT_MARKER &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
 528                 debug.log(&quot; inserting proxy for %s&quot;, value);
 529                 locals[i] = ProxyNode.forValue(value, loopExit);
 530             }
 531         }
 532         for (int i = 0; i &lt; stackSize(); i++) {
 533             ValueNode value = stack[i];
 534             if (value != null &amp;&amp; value != TWO_SLOT_MARKER &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
 535                 debug.log(&quot; inserting proxy for %s&quot;, value);
 536                 stack[i] = ProxyNode.forValue(value, loopExit);
 537             }
 538         }
 539         for (int i = 0; i &lt; lockedObjects.length; i++) {
 540             ValueNode value = lockedObjects[i];
 541             if (value != null &amp;&amp; (!loopEntryState.contains(value) || loopExit.loopBegin().isPhiAtMerge(value))) {
 542                 debug.log(&quot; inserting proxy for %s&quot;, value);
 543                 lockedObjects[i] = ProxyNode.forValue(value, loopExit);
 544             }
 545         }
 546     }
 547 
 548     public void insertProxies(Function&lt;ValueNode, ValueNode&gt; proxyFunction) {
 549         DebugContext debug = graph.getDebug();
 550         for (int i = 0; i &lt; localsSize(); i++) {
 551             ValueNode value = locals[i];
 552             if (value != null &amp;&amp; value != TWO_SLOT_MARKER) {
 553                 debug.log(&quot; inserting proxy for %s&quot;, value);
 554                 locals[i] = proxyFunction.apply(value);
 555             }
 556         }
 557         for (int i = 0; i &lt; stackSize(); i++) {
 558             ValueNode value = stack[i];
 559             if (value != null &amp;&amp; value != TWO_SLOT_MARKER) {
 560                 debug.log(&quot; inserting proxy for %s&quot;, value);
 561                 stack[i] = proxyFunction.apply(value);
 562             }
 563         }
 564         for (int i = 0; i &lt; lockedObjects.length; i++) {
 565             ValueNode value = lockedObjects[i];
 566             if (value != null) {
 567                 debug.log(&quot; inserting proxy for %s&quot;, value);
 568                 lockedObjects[i] = proxyFunction.apply(value);
 569             }
 570         }
 571     }
 572 
 573     private ValueNode createLoopPhi(AbstractMergeNode block, ValueNode value, boolean stampFromValue) {
 574         if (value == null || value == TWO_SLOT_MARKER) {
 575             return value;
 576         }
 577         assert !block.isPhiAtMerge(value) : &quot;phi function for this block already created&quot;;
 578 
 579         ValuePhiNode phi = graph.addWithoutUnique(new ValuePhiNode(stampFromValue ? value.stamp(NodeView.DEFAULT) : value.stamp(NodeView.DEFAULT).unrestricted(), block));
 580         phi.addInput(value);
 581         return phi;
 582     }
 583 
 584     /**
 585      * Adds a locked monitor to this frame state.
 586      *
 587      * @param object the object whose monitor will be locked.
 588      */
 589     public void pushLock(ValueNode object, MonitorIdNode monitorId) {
 590         assert object.isAlive() &amp;&amp; object.getStackKind() == JavaKind.Object : &quot;unexpected value: &quot; + object;
 591         lockedObjects = Arrays.copyOf(lockedObjects, lockedObjects.length + 1);
 592         monitorIds = Arrays.copyOf(monitorIds, monitorIds.length + 1);
 593         lockedObjects[lockedObjects.length - 1] = object;
 594         monitorIds[monitorIds.length - 1] = monitorId;
 595         assert lockedObjects.length == monitorIds.length;
 596     }
 597 
 598     /**
 599      * Removes a locked monitor from this frame state.
 600      *
 601      * @return the object whose monitor was removed from the locks list.
 602      */
 603     public ValueNode popLock() {
 604         try {
 605             return lockedObjects[lockedObjects.length - 1];
 606         } finally {
 607             lockedObjects = lockedObjects.length == 1 ? EMPTY_ARRAY : Arrays.copyOf(lockedObjects, lockedObjects.length - 1);
 608             monitorIds = monitorIds.length == 1 ? EMPTY_MONITOR_ARRAY : Arrays.copyOf(monitorIds, monitorIds.length - 1);
 609             assert lockedObjects.length == monitorIds.length;
 610         }
 611     }
 612 
 613     public MonitorIdNode peekMonitorId() {
 614         return monitorIds[monitorIds.length - 1];
 615     }
 616 
 617     /**
 618      * @return the current lock depth
 619      */
 620     public int lockDepth(boolean includeParents) {
 621         int depth = lockedObjects.length;
 622         assert depth == monitorIds.length;
 623         if (includeParents &amp;&amp; parser.getParent() != null) {
 624             depth += parser.getParent().frameState.lockDepth(true);
 625         }
 626         return depth;
 627     }
 628 
 629     public boolean contains(ValueNode value) {
 630         for (int i = 0; i &lt; localsSize(); i++) {
 631             if (locals[i] == value) {
 632                 return true;
 633             }
 634         }
 635         for (int i = 0; i &lt; stackSize(); i++) {
 636             if (stack[i] == value) {
 637                 return true;
 638             }
 639         }
 640         assert lockedObjects.length == monitorIds.length;
 641         for (int i = 0; i &lt; lockedObjects.length; i++) {
 642             if (lockedObjects[i] == value || monitorIds[i] == value) {
 643                 return true;
 644             }
 645         }
 646         return false;
 647     }
 648 
 649     public void clearNonLiveLocals(BciBlock block, LocalLiveness liveness, boolean liveIn) {
 650         /*
 651          * Non-live local clearing is mandatory for the entry block of an OSR compilation so that
 652          * dead object slots at the OSR entry are cleared. It&#39;s not sufficient to rely on PiNodes
 653          * with Kind.Illegal, because the conflicting branch might not have been parsed.
 654          */
 655         boolean isOSREntryBlock = graph.isOSR() &amp;&amp; getMethod().equals(graph.method()) &amp;&amp; graph.getEntryBCI() == block.startBci;
 656         if (!clearNonLiveLocals &amp;&amp; !isOSREntryBlock) {
 657             return;
 658         }
 659         if (liveIn) {
 660             for (int i = 0; i &lt; locals.length; i++) {
 661                 if (!liveness.localIsLiveIn(block, i)) {
 662                     assert locals[i] != TWO_SLOT_MARKER || locals[i - 1] == null : &quot;Clearing of second slot must have cleared the first slot too&quot;;
 663                     locals[i] = null;
 664                 }
 665             }
 666         } else {
 667             for (int i = 0; i &lt; locals.length; i++) {
 668                 if (!liveness.localIsLiveOut(block, i)) {
 669                     assert locals[i] != TWO_SLOT_MARKER || locals[i - 1] == null : &quot;Clearing of second slot must have cleared the first slot too&quot;;
 670                     locals[i] = null;
 671                 }
 672             }
 673         }
 674     }
 675 
 676     /**
 677      * Clears all local variables.
 678      */
 679     public void clearLocals() {
 680         for (int i = 0; i &lt; locals.length; i++) {
 681             locals[i] = null;
 682         }
 683     }
 684 
 685     /**
 686      * @see BytecodeFrame#rethrowException
 687      */
 688     public boolean rethrowException() {
 689         return rethrowException;
 690     }
 691 
 692     /**
 693      * @see BytecodeFrame#rethrowException
 694      */
 695     public void setRethrowException(boolean b) {
 696         rethrowException = b;
 697     }
 698 
 699     /**
 700      * Returns the size of the local variables.
 701      *
 702      * @return the size of the local variables
 703      */
 704     public int localsSize() {
 705         return locals.length;
 706     }
 707 
 708     /**
 709      * Gets the current size (height) of the stack.
 710      */
 711     public int stackSize() {
 712         return stackSize;
 713     }
 714 
 715     private boolean verifyKind(JavaKind slotKind, ValueNode x) {
 716         assert x != null;
 717         assert x != TWO_SLOT_MARKER;
 718         assert slotKind.getSlotCount() &gt; 0;
 719 
 720         if (canVerifyKind) {
 721             assert x.getStackKind() == slotKind.getStackKind();
 722         }
 723         return true;
 724     }
 725 
 726     /**
 727      * Loads the local variable at the specified index, checking that the returned value is non-null
 728      * and that two-stack values are properly handled.
 729      *
 730      * @param i the index of the local variable to load
 731      * @param slotKind the kind of the local variable from the point of view of the bytecodes
 732      * @return the instruction that produced the specified local
 733      */
 734     public ValueNode loadLocal(int i, JavaKind slotKind) {
 735         ValueNode x = locals[i];
 736         assert verifyKind(slotKind, x);
 737         assert slotKind.needsTwoSlots() ? locals[i + 1] == TWO_SLOT_MARKER : (i == locals.length - 1 || locals[i + 1] != TWO_SLOT_MARKER);
 738         return x;
 739     }
 740 
 741     /**
 742      * Stores a given local variable at the specified index. If the value occupies two slots, then
 743      * the next local variable index is also overwritten.
 744      *
 745      * @param i the index at which to store
 746      * @param slotKind the kind of the local variable from the point of view of the bytecodes
 747      * @param x the instruction which produces the value for the local
 748      */
 749     public void storeLocal(int i, JavaKind slotKind, ValueNode x) {
 750         assert verifyKind(slotKind, x);
 751 
 752         if (locals[i] == TWO_SLOT_MARKER) {
 753             /* Writing the second slot of a two-slot value invalidates the first slot. */
 754             locals[i - 1] = null;
 755         }
 756         locals[i] = x;
 757         if (slotKind.needsTwoSlots()) {
 758             if (i &lt; locals.length - 2 &amp;&amp; locals[i + 2] == TWO_SLOT_MARKER) {
 759                 /*
 760                  * Writing a two-slot marker to an index previously occupied by a two-slot value:
 761                  * clear the old marker of the second slot.
 762                  */
 763                 locals[i + 2] = null;
 764             }
 765             /* Writing a two-slot value: mark the second slot. */
 766             locals[i + 1] = TWO_SLOT_MARKER;
 767         } else if (i &lt; locals.length - 1 &amp;&amp; locals[i + 1] == TWO_SLOT_MARKER) {
 768             /*
 769              * Writing a one-slot value to an index previously occupied by a two-slot value: clear
 770              * the old marker of the second slot.
 771              */
 772             locals[i + 1] = null;
 773         }
 774     }
 775 
 776     /**
 777      * Pushes an instruction onto the stack with the expected type.
 778      *
 779      * @param slotKind the kind of the stack element from the point of view of the bytecodes
 780      * @param x the instruction to push onto the stack
 781      */
 782     public void push(JavaKind slotKind, ValueNode x) {
 783         assert verifyKind(slotKind, x);
 784 
 785         xpush(x);
 786         if (slotKind.needsTwoSlots()) {
 787             xpush(TWO_SLOT_MARKER);
 788         }
 789     }
 790 
 791     public void pushReturn(JavaKind slotKind, ValueNode x) {
 792         if (slotKind != JavaKind.Void) {
 793             push(slotKind, x);
 794         }
 795     }
 796 
 797     /**
 798      * Pops an instruction off the stack with the expected type.
 799      *
 800      * @param slotKind the kind of the stack element from the point of view of the bytecodes
 801      * @return the instruction on the top of the stack
 802      */
 803     public ValueNode pop(JavaKind slotKind) {
 804         if (slotKind.needsTwoSlots()) {
 805             ValueNode s = xpop();
 806             assert s == TWO_SLOT_MARKER : s;
 807         }
 808         ValueNode x = xpop();
 809         assert verifyKind(slotKind, x);
 810         return x;
 811     }
 812 
 813     private void xpush(ValueNode x) {
 814         assert x != null;
 815         stack[stackSize++] = x;
 816     }
 817 
 818     private ValueNode xpop() {
 819         ValueNode result = stack[--stackSize];
 820         assert result != null;
 821         return result;
 822     }
 823 
 824     private ValueNode xpeek() {
 825         ValueNode result = stack[stackSize - 1];
 826         assert result != null;
 827         return result;
 828     }
 829 
 830     public ValueNode peekObject() {
 831         ValueNode x = xpeek();
 832         assert verifyKind(JavaKind.Object, x);
 833         return x;
 834     }
 835 
 836     /**
 837      * Pop the specified number of slots off of this stack and return them as an array of
 838      * instructions.
 839      *
 840      * @return an array containing the arguments off of the stack
 841      */
 842     public ValueNode[] popArguments(int argSize) {
 843         ValueNode[] result = allocateArray(argSize);
 844         for (int i = argSize - 1; i &gt;= 0; i--) {
 845             ValueNode x = xpop();
 846             if (x == TWO_SLOT_MARKER) {
 847                 /* Ignore second slot of two-slot value. */
 848                 x = xpop();
 849             }
 850             assert x != null &amp;&amp; x != TWO_SLOT_MARKER : x;
 851             result[i] = x;
 852         }
 853         return result;
 854     }
 855 
 856     /**
 857      * Clears all values on this stack.
 858      */
 859     public void clearStack() {
 860         stackSize = 0;
 861     }
 862 
 863     /**
 864      * Performs a raw stack operation as defined in the Java bytecode specification.
 865      *
 866      * @param opcode The Java bytecode.
 867      */
 868     public void stackOp(int opcode) {
 869         switch (opcode) {
 870             case POP: {
 871                 ValueNode w1 = xpop();
 872                 assert w1 != TWO_SLOT_MARKER;
 873                 break;
 874             }
 875             case POP2: {
 876                 xpop();
 877                 ValueNode w2 = xpop();
 878                 assert w2 != TWO_SLOT_MARKER;
 879                 break;
 880             }
 881             case DUP: {
 882                 ValueNode w1 = xpeek();
 883                 assert w1 != TWO_SLOT_MARKER;
 884                 xpush(w1);
 885                 break;
 886             }
 887             case DUP_X1: {
 888                 ValueNode w1 = xpop();
 889                 ValueNode w2 = xpop();
 890                 assert w1 != TWO_SLOT_MARKER;
 891                 xpush(w1);
 892                 xpush(w2);
 893                 xpush(w1);
 894                 break;
 895             }
 896             case DUP_X2: {
 897                 ValueNode w1 = xpop();
 898                 ValueNode w2 = xpop();
 899                 ValueNode w3 = xpop();
 900                 assert w1 != TWO_SLOT_MARKER;
 901                 xpush(w1);
 902                 xpush(w3);
 903                 xpush(w2);
 904                 xpush(w1);
 905                 break;
 906             }
 907             case DUP2: {
 908                 ValueNode w1 = xpop();
 909                 ValueNode w2 = xpop();
 910                 xpush(w2);
 911                 xpush(w1);
 912                 xpush(w2);
 913                 xpush(w1);
 914                 break;
 915             }
 916             case DUP2_X1: {
 917                 ValueNode w1 = xpop();
 918                 ValueNode w2 = xpop();
 919                 ValueNode w3 = xpop();
 920                 xpush(w2);
 921                 xpush(w1);
 922                 xpush(w3);
 923                 xpush(w2);
 924                 xpush(w1);
 925                 break;
 926             }
 927             case DUP2_X2: {
 928                 ValueNode w1 = xpop();
 929                 ValueNode w2 = xpop();
 930                 ValueNode w3 = xpop();
 931                 ValueNode w4 = xpop();
 932                 xpush(w2);
 933                 xpush(w1);
 934                 xpush(w4);
 935                 xpush(w3);
 936                 xpush(w2);
 937                 xpush(w1);
 938                 break;
 939             }
 940             case SWAP: {
 941                 ValueNode w1 = xpop();
 942                 ValueNode w2 = xpop();
 943                 assert w1 != TWO_SLOT_MARKER;
 944                 assert w2 != TWO_SLOT_MARKER;
 945                 xpush(w1);
 946                 xpush(w2);
 947                 break;
 948             }
 949             default:
 950                 throw shouldNotReachHere();
 951         }
 952     }
 953 
 954     @Override
 955     public int hashCode() {
 956         int result = hashCode(locals, locals.length);
 957         result *= 13;
 958         result += hashCode(stack, this.stackSize);
 959         return result;
 960     }
 961 
 962     private static int hashCode(Object[] a, int length) {
 963         int result = 1;
 964         for (int i = 0; i &lt; length; ++i) {
 965             Object element = a[i];
 966             result = 31 * result + (element == null ? 0 : System.identityHashCode(element));
 967         }
 968         return result;
 969     }
 970 
 971     private static boolean equals(ValueNode[] a, ValueNode[] b, int length) {
 972         for (int i = 0; i &lt; length; ++i) {
 973             if (a[i] != b[i]) {
 974                 return false;
 975             }
 976         }
 977         return true;
 978     }
 979 
 980     @Override
 981     public boolean equals(Object otherObject) {
 982         if (otherObject instanceof FrameStateBuilder) {
 983             FrameStateBuilder other = (FrameStateBuilder) otherObject;
 984             if (!other.code.equals(code)) {
 985                 return false;
 986             }
 987             if (other.stackSize != stackSize) {
 988                 return false;
 989             }
 990             if (other.parser != parser) {
 991                 return false;
 992             }
 993             if (other.tool != tool) {
 994                 return false;
 995             }
 996             if (other.rethrowException != rethrowException) {
 997                 return false;
 998             }
 999             if (other.graph != graph) {
1000                 return false;
1001             }
1002             if (other.locals.length != locals.length) {
1003                 return false;
1004             }
1005             return equals(other.locals, locals, locals.length) &amp;&amp; equals(other.stack, stack, stackSize) &amp;&amp; equals(other.lockedObjects, lockedObjects, lockedObjects.length) &amp;&amp;
1006                             equals(other.monitorIds, monitorIds, monitorIds.length);
1007         }
1008         return false;
1009     }
1010 
1011     @Override
1012     public boolean isAfterSideEffect() {
1013         return sideEffects != null;
1014     }
1015 
1016     @Override
1017     public Iterable&lt;StateSplit&gt; sideEffects() {
1018         return sideEffects;
1019     }
1020 
1021     @Override
1022     public void addSideEffect(StateSplit sideEffect) {
1023         assert sideEffect != null;
1024         assert sideEffect.hasSideEffect();
1025         if (sideEffects == null) {
1026             sideEffects = new ArrayList&lt;&gt;(4);
1027         }
1028         sideEffects.add(sideEffect);
1029     }
1030 
1031     public void replaceValue(ValueNode oldValue, ValueNode newValue) {
1032         for (int i = 0; i &lt; locals.length; ++i) {
1033             if (locals[i] == oldValue) {
1034                 locals[i] = newValue;
1035             }
1036         }
1037         for (int i = 0; i &lt; stack.length; ++i) {
1038             if (stack[i] == oldValue) {
1039                 stack[i] = newValue;
1040             }
1041         }
1042     }
1043 }
    </pre>
  </body>
</html>
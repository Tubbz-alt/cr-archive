<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BytecodeParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BciBlockMapping.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeParserOptions.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BytecodeParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,18 +25,17 @@</span>
  package org.graalvm.compiler.java;
  
  import static java.lang.String.format;
  import static java.lang.reflect.Modifier.STATIC;
  import static java.lang.reflect.Modifier.SYNCHRONIZED;
<span class="udiff-line-added">+ import static jdk.vm.ci.code.BytecodeFrame.UNKNOWN_BCI;</span>
  import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateRecompile;
  import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateReprofile;
  import static jdk.vm.ci.meta.DeoptimizationAction.None;
  import static jdk.vm.ci.meta.DeoptimizationReason.ClassCastException;
<span class="udiff-line-removed">- import static jdk.vm.ci.meta.DeoptimizationReason.JavaSubroutineMismatch;</span>
  import static jdk.vm.ci.meta.DeoptimizationReason.NullCheckException;
  import static jdk.vm.ci.meta.DeoptimizationReason.RuntimeConstraint;
<span class="udiff-line-removed">- import static jdk.vm.ci.meta.DeoptimizationReason.TypeCheckedInliningViolated;</span>
  import static jdk.vm.ci.meta.DeoptimizationReason.UnreachedCode;
  import static jdk.vm.ci.meta.DeoptimizationReason.Unresolved;
  import static jdk.vm.ci.runtime.JVMCICompiler.INVOCATION_ENTRY_BCI;
  import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  import static org.graalvm.compiler.bytecode.Bytecodes.AALOAD;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -253,12 +252,10 @@</span>
  import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
  import static org.graalvm.compiler.java.BytecodeParserOptions.InlinePartialIntrinsicExitDuringParsing;
  import static org.graalvm.compiler.java.BytecodeParserOptions.TraceBytecodeParserLevel;
  import static org.graalvm.compiler.java.BytecodeParserOptions.TraceInlineDuringParsing;
  import static org.graalvm.compiler.java.BytecodeParserOptions.TraceParserPlugins;
<span class="udiff-line-removed">- import static org.graalvm.compiler.java.BytecodeParserOptions.UseGuardedIntrinsics;</span>
<span class="udiff-line-removed">- import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FAST_PATH_PROBABILITY;</span>
  import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LUDICROUSLY_FAST_PATH_PROBABILITY;
  import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LUDICROUSLY_SLOW_PATH_PROBABILITY;
  import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_DURING_PARSING;
  import static org.graalvm.compiler.nodes.type.StampTool.isPointerNonNull;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -269,11 +266,13 @@</span>
  import java.util.List;
  import java.util.function.Supplier;
  
  import jdk.internal.vm.compiler.collections.EconomicMap;
  import jdk.internal.vm.compiler.collections.Equivalence;
<span class="udiff-line-added">+ import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;</span>
  import org.graalvm.compiler.api.replacements.Fold;
<span class="udiff-line-added">+ import org.graalvm.compiler.api.replacements.MethodSubstitution;</span>
  import org.graalvm.compiler.api.replacements.Snippet;
  import org.graalvm.compiler.bytecode.Bytecode;
  import org.graalvm.compiler.bytecode.BytecodeDisassembler;
  import org.graalvm.compiler.bytecode.BytecodeLookupSwitch;
  import org.graalvm.compiler.bytecode.BytecodeProvider;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -284,10 +283,11 @@</span>
  import org.graalvm.compiler.bytecode.Bytes;
  import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecodeProvider;
  import org.graalvm.compiler.core.common.GraalOptions;
  import org.graalvm.compiler.core.common.PermanentBailoutException;
<span class="udiff-line-added">+ import org.graalvm.compiler.core.common.RetryableBailoutException;</span>
  import org.graalvm.compiler.core.common.calc.CanonicalCondition;
  import org.graalvm.compiler.core.common.calc.Condition;
  import org.graalvm.compiler.core.common.calc.Condition.CanonicalizedCondition;
  import org.graalvm.compiler.core.common.calc.FloatConvert;
  import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -351,25 +351,27 @@</span>
  import org.graalvm.compiler.nodes.StartNode;
  import org.graalvm.compiler.nodes.StateSplit;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.UnwindNode;
  import org.graalvm.compiler.nodes.ValueNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.ValuePhiNode;</span>
  import org.graalvm.compiler.nodes.calc.AddNode;
  import org.graalvm.compiler.nodes.calc.AndNode;
  import org.graalvm.compiler.nodes.calc.CompareNode;
  import org.graalvm.compiler.nodes.calc.ConditionalNode;
  import org.graalvm.compiler.nodes.calc.FloatConvertNode;
  import org.graalvm.compiler.nodes.calc.FloatDivNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.calc.FloatNormalizeCompareNode;</span>
  import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.calc.IntegerNormalizeCompareNode;</span>
  import org.graalvm.compiler.nodes.calc.IsNullNode;
  import org.graalvm.compiler.nodes.calc.LeftShiftNode;
  import org.graalvm.compiler.nodes.calc.MulNode;
  import org.graalvm.compiler.nodes.calc.NarrowNode;
  import org.graalvm.compiler.nodes.calc.NegateNode;
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.calc.NormalizeCompareNode;</span>
  import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
  import org.graalvm.compiler.nodes.calc.OrNode;
  import org.graalvm.compiler.nodes.calc.RemNode;
  import org.graalvm.compiler.nodes.calc.RightShiftNode;
  import org.graalvm.compiler.nodes.calc.SignExtendNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -381,18 +383,17 @@</span>
  import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  import org.graalvm.compiler.nodes.extended.AnchoringNode;
  import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;
  import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode;
  import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.extended.ForeignCallNode;</span>
  import org.graalvm.compiler.nodes.extended.GuardingNode;
  import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
  import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
  import org.graalvm.compiler.nodes.extended.LoadHubNode;
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.extended.LoadMethodNode;</span>
  import org.graalvm.compiler.nodes.extended.MembarNode;
  import org.graalvm.compiler.nodes.extended.StateSplitProxyNode;
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.extended.ValueAnchorNode;</span>
  import org.graalvm.compiler.nodes.graphbuilderconf.ClassInitializationPlugin;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.BytecodeExceptionMode;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
  import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -418,10 +419,12 @@</span>
  import org.graalvm.compiler.nodes.java.NewInstanceNode;
  import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
  import org.graalvm.compiler.nodes.java.RegisterFinalizerNode;
  import org.graalvm.compiler.nodes.java.StoreFieldNode;
  import org.graalvm.compiler.nodes.java.StoreIndexedNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.spi.Replacements;</span>
  import org.graalvm.compiler.nodes.spi.StampProvider;
  import org.graalvm.compiler.nodes.type.StampTool;
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.OptimisticOptimizations;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -442,11 +445,10 @@</span>
  import jdk.vm.ci.meta.JavaField;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.JavaMethod;
  import jdk.vm.ci.meta.JavaType;
  import jdk.vm.ci.meta.JavaTypeProfile;
<span class="udiff-line-removed">- import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;</span>
  import jdk.vm.ci.meta.LineNumberTable;
  import jdk.vm.ci.meta.MetaAccessProvider;
  import jdk.vm.ci.meta.ProfilingInfo;
  import jdk.vm.ci.meta.RawConstant;
  import jdk.vm.ci.meta.ResolvedJavaField;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -484,80 +486,78 @@</span>
      public static final CounterKey BytecodesParsed = DebugContext.counter(&quot;BytecodesParsed&quot;);
  
      protected static final CounterKey EXPLICIT_EXCEPTIONS = DebugContext.counter(&quot;ExplicitExceptions&quot;);
  
      /**
<span class="udiff-line-modified-removed">-      * A scoped object for tasks to be performed after parsing an intrinsic such as processing</span>
<span class="udiff-line-modified-added">+      * A scoped object for tasks to be performed after inlining during parsing such as processing</span>
       * {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frames states.
       */
<span class="udiff-line-modified-removed">-     static class IntrinsicScope implements AutoCloseable {</span>
<span class="udiff-line-modified-added">+     static class InliningScope implements AutoCloseable {</span>
<span class="udiff-line-added">+         final ResolvedJavaMethod callee;</span>
          FrameState stateBefore;
          final Mark mark;
          final BytecodeParser parser;
          List&lt;ReturnToCallerData&gt; returnDataList;
  
          /**
           * Creates a scope for root parsing an intrinsic.
           *
           * @param parser the parsing context of the intrinsic
           */
<span class="udiff-line-modified-removed">-         IntrinsicScope(BytecodeParser parser) {</span>
<span class="udiff-line-modified-added">+         InliningScope(BytecodeParser parser) {</span>
              this.parser = parser;
              assert parser.parent == null;
              assert parser.bci() == 0;
              mark = null;
<span class="udiff-line-added">+             callee = null;</span>
          }
  
          /**
<span class="udiff-line-modified-removed">-          * Creates a scope for parsing an intrinsic during graph builder inlining.</span>
<span class="udiff-line-modified-added">+          * Creates a scope for graph builder inlining.</span>
           *
           * @param parser the parsing context of the (non-intrinsic) method calling the intrinsic
           * @param args the arguments to the call
           */
<span class="udiff-line-modified-removed">-         IntrinsicScope(BytecodeParser parser, JavaKind[] argSlotKinds, ValueNode[] args) {</span>
<span class="udiff-line-modified-added">+         InliningScope(BytecodeParser parser, ResolvedJavaMethod callee, ValueNode[] args) {</span>
<span class="udiff-line-added">+             this.callee = callee;</span>
              assert !parser.parsingIntrinsic();
              this.parser = parser;
              mark = parser.getGraph().getMark();
<span class="udiff-line-added">+             JavaKind[] argSlotKinds = callee.getSignature().toParameterKinds(!callee.isStatic());</span>
              stateBefore = parser.frameState.create(parser.bci(), parser.getNonIntrinsicAncestor(), false, argSlotKinds, args);
          }
  
          @Override
          public void close() {
<span class="udiff-line-modified-removed">-             IntrinsicContext intrinsic = parser.intrinsicContext;</span>
<span class="udiff-line-removed">-             if (intrinsic != null &amp;&amp; intrinsic.isPostParseInlined()) {</span>
<span class="udiff-line-removed">-                 return;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             processPlaceholderFrameStates(intrinsic);</span>
<span class="udiff-line-modified-added">+             processPlaceholderFrameStates(false);</span>
          }
  
          /**
           * Fixes up the {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frame states
           * added to the graph while parsing/inlining the intrinsic for which this object exists.
           */
<span class="udiff-line-modified-removed">-         private void processPlaceholderFrameStates(IntrinsicContext intrinsic) {</span>
<span class="udiff-line-modified-added">+         protected void processPlaceholderFrameStates(boolean isCompilationRoot) {</span>
              StructuredGraph graph = parser.getGraph();
              graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;Before processPlaceholderFrameStates in %s&quot;, parser.method);
<span class="udiff-line-removed">-             boolean sawInvalidFrameState = false;</span>
              for (Node node : graph.getNewNodes(mark)) {
                  if (node instanceof FrameState) {
                      FrameState frameState = (FrameState) node;
                      if (BytecodeFrame.isPlaceholderBci(frameState.bci)) {
                          if (frameState.bci == BytecodeFrame.AFTER_BCI) {
                              if (parser.getInvokeReturnType() == null) {
                                  // A frame state in a root compiled intrinsic.
<span class="udiff-line-modified-removed">-                                 assert intrinsic.isCompilationRoot();</span>
<span class="udiff-line-modified-added">+                                 assert isCompilationRoot;</span>
                                  FrameState newFrameState = graph.add(new FrameState(BytecodeFrame.INVALID_FRAMESTATE_BCI));
                                  frameState.replaceAndDelete(newFrameState);
                              } else {
                                  JavaKind returnKind = parser.getInvokeReturnType().getJavaKind();
                                  FrameStateBuilder frameStateBuilder = parser.frameState;
                                  assert !frameState.rethrowException();
                                  if (frameState.stackSize() != 0) {
                                      ValueNode returnVal = frameState.stackAt(0);
                                      if (!ReturnToCallerData.containsReturnValue(returnDataList, returnVal)) {
<span class="udiff-line-modified-removed">-                                         throw new GraalError(&quot;AFTER_BCI frame state within an intrinsic has a non-return value on the stack: %s&quot;, returnVal);</span>
<span class="udiff-line-modified-added">+                                         throw new GraalError(&quot;AFTER_BCI frame state within a sub-parse has a non-return value on the stack: %s&quot;, returnVal);</span>
                                      }
  
                                      // Swap the top-of-stack value with the return value
                                      ValueNode tos = frameStateBuilder.pop(returnKind);
                                      assert tos.getStackKind() == returnVal.getStackKind();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -565,19 +565,11 @@</span>
                                                      new ValueNode[]{returnVal});
                                      frameState.replaceAndDelete(newFrameState);
                                      newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());
                                      frameStateBuilder.push(returnKind, tos);
                                  } else if (returnKind != JavaKind.Void) {
<span class="udiff-line-modified-removed">-                                     // If the intrinsic returns a non-void value, then any frame</span>
<span class="udiff-line-removed">-                                     // state with an empty stack is invalid as it cannot</span>
<span class="udiff-line-removed">-                                     // be used to deoptimize to just after the call returns.</span>
<span class="udiff-line-removed">-                                     // These invalid frame states are expected to be removed</span>
<span class="udiff-line-removed">-                                     // by later compilation stages.</span>
<span class="udiff-line-removed">-                                     FrameState newFrameState = graph.add(new FrameState(BytecodeFrame.INVALID_FRAMESTATE_BCI));</span>
<span class="udiff-line-removed">-                                     newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());</span>
<span class="udiff-line-removed">-                                     frameState.replaceAndDelete(newFrameState);</span>
<span class="udiff-line-removed">-                                     sawInvalidFrameState = true;</span>
<span class="udiff-line-modified-added">+                                     handleReturnMismatch(graph, frameState);</span>
                                  } else {
                                      // An intrinsic for a void method.
                                      FrameState newFrameState = frameStateBuilder.create(parser.stream.nextBCI(), null);
                                      newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());
                                      frameState.replaceAndDelete(newFrameState);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -588,56 +580,260 @@</span>
                                  stateBefore = graph.start().stateAfter();
                              }
                              if (stateBefore != frameState) {
                                  frameState.replaceAndDelete(stateBefore);
                              }
<span class="udiff-line-modified-removed">-                         } else if (frameState.bci == BytecodeFrame.AFTER_EXCEPTION_BCI) {</span>
<span class="udiff-line-modified-added">+                         } else if (frameState.bci == BytecodeFrame.AFTER_EXCEPTION_BCI || (frameState.bci == BytecodeFrame.UNWIND_BCI &amp;&amp; !callee.isSynchronized())) {</span>
                              // This is a frame state for the entry point to an exception
                              // dispatcher in an intrinsic. For example, the invoke denoting
                              // a partial intrinsic exit will have an edge to such a
                              // dispatcher if the profile for the original invoke being
                              // intrinsified indicates an exception was seen. As per JVM
                              // bytecode semantics, the interpreter expects a single
                              // value on the stack on entry to an exception handler,
                              // namely the exception object.
                              assert frameState.rethrowException();
                              ValueNode exceptionValue = frameState.stackAt(0);
<span class="udiff-line-removed">-                             ExceptionObjectNode exceptionObject = (ExceptionObjectNode) GraphUtil.unproxify(exceptionValue);</span>
                              FrameStateBuilder dispatchState = parser.frameState.copy();
                              dispatchState.clearStack();
                              dispatchState.push(JavaKind.Object, exceptionValue);
                              dispatchState.setRethrowException(true);
<span class="udiff-line-modified-removed">-                             FrameState newFrameState = dispatchState.create(parser.bci(), exceptionObject);</span>
<span class="udiff-line-modified-removed">-                             frameState.replaceAndDelete(newFrameState);</span>
<span class="udiff-line-modified-removed">-                             newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());</span>
<span class="udiff-line-modified-added">+                             for (Node usage : frameState.usages()) {</span>
<span class="udiff-line-modified-added">+                                 FrameState newFrameState = dispatchState.create(parser.bci(), (StateSplit) usage);</span>
<span class="udiff-line-modified-added">+                                 frameState.replaceAndDelete(newFrameState);</span>
<span class="udiff-line-added">+                                 newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         } else if (frameState.bci == BytecodeFrame.UNWIND_BCI) {</span>
<span class="udiff-line-added">+                             if (graph.getGuardsStage().allowsFloatingGuards()) {</span>
<span class="udiff-line-added">+                                 throw GraalError.shouldNotReachHere(&quot;Cannot handle this UNWIND_BCI&quot;);</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                             // hope that by construction, there are no fixed guard after this unwind</span>
<span class="udiff-line-added">+                             // and before an other state split</span>
                          } else {
<span class="udiff-line-modified-removed">-                             assert frameState.bci == BytecodeFrame.INVALID_FRAMESTATE_BCI;</span>
<span class="udiff-line-modified-added">+                             assert frameState.bci == BytecodeFrame.INVALID_FRAMESTATE_BCI : frameState.bci;</span>
                          }
                      }
                  }
              }
<span class="udiff-line-modified-removed">-             if (sawInvalidFrameState) {</span>
<span class="udiff-line-modified-added">+             graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;After processPlaceholderFrameStates in %s&quot;, parser.method);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @SuppressWarnings(&quot;unused&quot;)</span>
<span class="udiff-line-added">+         protected void handleReturnMismatch(StructuredGraph g, FrameState fs) {</span>
<span class="udiff-line-added">+             throw GraalError.shouldNotReachHere(&quot;Unexpected return kind mismatch in &quot; + parser.method + &quot; at FS &quot; + fs);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static class IntrinsicScope extends InliningScope {</span>
<span class="udiff-line-added">+         ArrayList&lt;StateSplit&gt; invalidStateUsers;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         IntrinsicScope(BytecodeParser parser) {</span>
<span class="udiff-line-added">+             super(parser);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         IntrinsicScope(BytecodeParser parser, ResolvedJavaMethod callee, ValueNode[] args) {</span>
<span class="udiff-line-added">+             super(parser, callee, args);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @SuppressWarnings(&quot;unlikely-arg-type&quot;)</span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public void close() {</span>
<span class="udiff-line-added">+             IntrinsicContext intrinsic = parser.intrinsicContext;</span>
<span class="udiff-line-added">+             boolean isRootCompilation;</span>
<span class="udiff-line-added">+             if (intrinsic != null) {</span>
<span class="udiff-line-added">+                 if (intrinsic.isPostParseInlined()) {</span>
<span class="udiff-line-added">+                     return;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 isRootCompilation = intrinsic.isCompilationRoot();</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 isRootCompilation = false;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             processPlaceholderFrameStates(isRootCompilation);</span>
<span class="udiff-line-added">+             if (invalidStateUsers != null) {</span>
                  JavaKind returnKind = parser.getInvokeReturnType().getJavaKind();
<span class="udiff-line-modified-removed">-                 FrameStateBuilder frameStateBuilder = parser.frameState;</span>
<span class="udiff-line-modified-removed">-                 ValueNode returnValue = frameStateBuilder.pop(returnKind);</span>
<span class="udiff-line-modified-removed">-                 StateSplitProxyNode proxy = graph.add(new StateSplitProxyNode(returnValue));</span>
<span class="udiff-line-modified-removed">-                 parser.lastInstr.setNext(proxy);</span>
<span class="udiff-line-modified-removed">-                 frameStateBuilder.push(returnKind, proxy);</span>
<span class="udiff-line-modified-removed">-                 proxy.setStateAfter(parser.createFrameState(parser.stream.nextBCI(), proxy));</span>
<span class="udiff-line-modified-removed">-                 parser.lastInstr = proxy;</span>
<span class="udiff-line-modified-added">+                 ValueNode returnValue = parser.frameState.pop(returnKind);</span>
<span class="udiff-line-modified-added">+                 if (invalidStateUsers.size() == 1 &amp;&amp; invalidStateUsers.get(0) == parser.lastInstr) {</span>
<span class="udiff-line-modified-added">+                     updateSplitFrameState(invalidStateUsers.get(0), returnKind, returnValue);</span>
<span class="udiff-line-modified-added">+                 } else if (parser.lastInstr instanceof MergeNode) {</span>
<span class="udiff-line-modified-added">+                     ValuePhiNode returnValues = null;</span>
<span class="udiff-line-modified-added">+                     MergeNode merge = (MergeNode) parser.lastInstr;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+                     if (returnValue instanceof ValuePhiNode &amp;&amp; ((ValuePhiNode) returnValue).merge() == parser.lastInstr) {</span>
<span class="udiff-line-added">+                         returnValues = (ValuePhiNode) returnValue;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     if (invalidStateUsers.remove(merge)) {</span>
<span class="udiff-line-added">+                         updateSplitFrameState(merge, returnKind, returnValue);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     for (EndNode pred : merge.cfgPredecessors()) {</span>
<span class="udiff-line-added">+                         Node lastPred = pred.predecessor();</span>
<span class="udiff-line-added">+                         if (invalidStateUsers.remove(lastPred)) {</span>
<span class="udiff-line-added">+                             ValueNode predReturnValue = returnValue;</span>
<span class="udiff-line-added">+                             if (returnValues != null) {</span>
<span class="udiff-line-added">+                                 int index = merge.phiPredecessorIndex(pred);</span>
<span class="udiff-line-added">+                                 predReturnValue = ((ValuePhiNode) returnValue).valueAt(index);</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                             updateSplitFrameState((StateSplit) lastPred, returnKind, predReturnValue);</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     if (invalidStateUsers.size() != 0) {</span>
<span class="udiff-line-added">+                         throw new GraalError(&quot;unexpected StateSplit above merge %s&quot;, invalidStateUsers);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     throw new GraalError(&quot;unexpected node between return StateSplit and last instruction %s&quot;, parser.lastInstr);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 // Restore the original return value</span>
<span class="udiff-line-added">+                 parser.frameState.push(returnKind, returnValue);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             boolean inlinedIntrinsic = parser.getInvokeReturnType() != null;</span>
<span class="udiff-line-added">+             if (inlinedIntrinsic) {</span>
<span class="udiff-line-added">+                 for (Node n : parser.graph.getNewNodes(mark)) {</span>
<span class="udiff-line-added">+                     if (n instanceof FrameState) {</span>
<span class="udiff-line-added">+                         GraalError.guarantee(((FrameState) n).bci != BytecodeFrame.INVALID_FRAMESTATE_BCI,</span>
<span class="udiff-line-added">+                                         &quot;Inlined call to intrinsic (callee %s) produced invalid framestate %s. &quot; +</span>
<span class="udiff-line-added">+                                                         &quot;Such framestates must never be used as deoptimizing targets, thus they cannot be part of a high-tier graph, &quot; +</span>
<span class="udiff-line-added">+                                                         &quot;and must only be used after framestate assignment. A common error is invalid usage of foreign call nodes in method &quot; +</span>
<span class="udiff-line-added">+                                                         &quot;substitutions, which can be avoided by ensuring such calls are either replaced with nodes that are snippet &quot; +</span>
<span class="udiff-line-added">+                                                         &quot;lowered after framestate assignment (see FastNotifyNode.java for example) or by ensuring all foreign use the state after of the &quot; +</span>
<span class="udiff-line-added">+                                                         &quot;original call instruction.&quot;,</span>
<span class="udiff-line-added">+                                         callee, n);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 /*</span>
<span class="udiff-line-added">+                  * Special case root compiled method substitutions</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * Root compiled intrinsics with self recursive calls (partial intrinsic exit) must</span>
<span class="udiff-line-added">+                  * never produce more than one state except the start framestate since we do not</span>
<span class="udiff-line-added">+                  * compile calls to the original method (or inline them) but deopt</span>
<span class="udiff-line-added">+                  *</span>
<span class="udiff-line-added">+                  * See ByteCodeParser::inline and search for compilationRoot</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 assert intrinsic == null || intrinsic.isIntrinsicEncoding() || verifyIntrinsicRootCompileEffects();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private boolean verifyIntrinsicRootCompileEffects() {</span>
<span class="udiff-line-added">+             int invalidBCIsInRootCompiledIntrinsic = 0;</span>
<span class="udiff-line-added">+             for (Node n : parser.graph.getNewNodes(mark)) {</span>
<span class="udiff-line-added">+                 if (n instanceof FrameState) {</span>
<span class="udiff-line-added">+                     if (((FrameState) n).bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {</span>
<span class="udiff-line-added">+                         invalidBCIsInRootCompiledIntrinsic++;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (invalidBCIsInRootCompiledIntrinsic &gt; 1) {</span>
<span class="udiff-line-added">+                 int invalidBCIsToFind = invalidBCIsInRootCompiledIntrinsic;</span>
<span class="udiff-line-added">+                 List&lt;ReturnNode&gt; returns = parser.getGraph().getNodes(ReturnNode.TYPE).snapshot();</span>
<span class="udiff-line-added">+                 if (returns.size() &gt; 1) {</span>
<span class="udiff-line-added">+                     outer: for (ReturnNode ret : returns) {</span>
<span class="udiff-line-added">+                         for (FixedNode f : GraphUtil.predecessorIterable(ret)) {</span>
<span class="udiff-line-added">+                             if (f instanceof StateSplit) {</span>
<span class="udiff-line-added">+                                 StateSplit split = (StateSplit) f;</span>
<span class="udiff-line-added">+                                 if (split.hasSideEffect()) {</span>
<span class="udiff-line-added">+                                     assert ((StateSplit) f).stateAfter() != null;</span>
<span class="udiff-line-added">+                                     if (split.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {</span>
<span class="udiff-line-added">+                                         invalidBCIsToFind--;</span>
<span class="udiff-line-added">+                                         continue outer;</span>
<span class="udiff-line-added">+                                     }</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     GraalError.guarantee(invalidBCIsToFind == 0, &quot;Root compiled intrinsic with invalid states has more than one return. &quot; +</span>
<span class="udiff-line-added">+                                     &quot;This is allowed, however one path down a sink has more than one state, this is prohibited. &quot; +</span>
<span class="udiff-line-added">+                                     &quot;Intrinsic %s&quot;, parser.method);</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 ReturnNode ret = returns.get(0);</span>
<span class="udiff-line-added">+                 MergeNode merge = null;</span>
<span class="udiff-line-added">+                 int mergeCount = parser.graph.getNodes(MergeNode.TYPE).count();</span>
<span class="udiff-line-added">+                 if (mergeCount != 1) {</span>
<span class="udiff-line-added">+                     throw new GraalError(&quot;Root compiled intrinsic with invalid states %s:Must have exactly one merge node. %d found&quot;, parser.method, mergeCount);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 if (ret.predecessor() instanceof MergeNode) {</span>
<span class="udiff-line-added">+                     merge = (MergeNode) ret.predecessor();</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 if (merge == null) {</span>
<span class="udiff-line-added">+                     throw new GraalError(&quot;Root compiled intrinsic with invalid state: Unexpected node between return and merge.&quot;);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 //@formatter:off</span>
<span class="udiff-line-added">+                 GraalError.guarantee(invalidBCIsInRootCompiledIntrinsic &lt;= merge.phiPredecessorCount() + 1 /* merge itself */,</span>
<span class="udiff-line-added">+                                 &quot;Root compiled intrinsic with invalid states %s must at maximum produce (0,1 or if the last instruction is a merge |merge.predCount|&quot; +</span>
<span class="udiff-line-added">+                                                 &quot; invalid BCI state, however %d where found.&quot;,</span>
<span class="udiff-line-added">+                                 parser.method, invalidBCIsInRootCompiledIntrinsic);</span>
<span class="udiff-line-added">+                 //@formatter:on</span>
<span class="udiff-line-added">+                 if (merge.stateAfter() != null &amp;&amp; merge.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {</span>
<span class="udiff-line-added">+                     invalidBCIsToFind--;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 for (EndNode pred : merge.cfgPredecessors()) {</span>
<span class="udiff-line-added">+                     Node lastPred = pred.predecessor();</span>
<span class="udiff-line-added">+                     for (FixedNode f : GraphUtil.predecessorIterable((FixedNode) lastPred)) {</span>
<span class="udiff-line-added">+                         if (f instanceof StateSplit) {</span>
<span class="udiff-line-added">+                             StateSplit split = (StateSplit) f;</span>
<span class="udiff-line-added">+                             if (split.hasSideEffect()) {</span>
<span class="udiff-line-added">+                                 assert ((StateSplit) f).stateAfter() != null;</span>
<span class="udiff-line-added">+                                 if (split.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {</span>
<span class="udiff-line-added">+                                     invalidBCIsToFind--;</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 if (invalidBCIsToFind != 0) {</span>
<span class="udiff-line-added">+                     throw new GraalError(</span>
<span class="udiff-line-added">+                                     &quot;Invalid BCI state missmatch: This root compiled method substitution %s &quot; +</span>
<span class="udiff-line-added">+                                                     &quot;uses invalid side-effecting nodes resulting in invalid deoptimization information. &quot; +</span>
<span class="udiff-line-added">+                                                     &quot;Method substitutions must never have more than one state (the after state) for deoptimization.&quot; +</span>
<span class="udiff-line-added">+                                                     &quot; Multiple states are only allowed if they are dominated by a control-flow split, there is only&quot; +</span>
<span class="udiff-line-added">+                                                     &quot; a single effect per branch and a post dominating merge with the same invalid_bci state &quot; +</span>
<span class="udiff-line-added">+                                                     &quot;(that must only be different in its return value).&quot;,</span>
<span class="udiff-line-added">+                                     parser.method);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private void updateSplitFrameState(StateSplit split, JavaKind returnKind, ValueNode returnValue) {</span>
<span class="udiff-line-added">+             parser.frameState.push(returnKind, returnValue);</span>
<span class="udiff-line-added">+             FrameState oldState = split.stateAfter();</span>
<span class="udiff-line-added">+             split.setStateAfter(parser.createFrameState(parser.stream.nextBCI(), split));</span>
<span class="udiff-line-added">+             parser.frameState.pop(returnKind);</span>
<span class="udiff-line-added">+             if (oldState.hasNoUsages()) {</span>
<span class="udiff-line-added">+                 oldState.safeDelete();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         protected void handleReturnMismatch(StructuredGraph g, FrameState fs) {</span>
<span class="udiff-line-added">+             if (invalidStateUsers == null) {</span>
<span class="udiff-line-added">+                 invalidStateUsers = new ArrayList&lt;&gt;();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             for (Node use : fs.usages()) {</span>
<span class="udiff-line-added">+                 if (!(use instanceof StateSplit)) {</span>
<span class="udiff-line-added">+                     throw new GraalError(&quot;Expected StateSplit for return mismatch&quot;);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 invalidStateUsers.add((StateSplit) use);</span>
              }
<span class="udiff-line-removed">-             graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;After processPlaceholderFrameStates in %s&quot;, parser.method);</span>
          }
      }
  
      private static class Target {
<span class="udiff-line-modified-removed">-         FixedNode fixed;</span>
<span class="udiff-line-modified-removed">-         FrameStateBuilder state;</span>
<span class="udiff-line-modified-added">+         final FixedNode entry;</span>
<span class="udiff-line-modified-added">+         final FixedNode originalEntry;</span>
<span class="udiff-line-added">+         final FrameStateBuilder state;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Target(FixedNode entry, FrameStateBuilder state) {</span>
<span class="udiff-line-added">+             this.entry = entry;</span>
<span class="udiff-line-added">+             this.state = state;</span>
<span class="udiff-line-added">+             this.originalEntry = null;</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-         Target(FixedNode fixed, FrameStateBuilder state) {</span>
<span class="udiff-line-modified-removed">-             this.fixed = fixed;</span>
<span class="udiff-line-modified-added">+         Target(FixedNode entry, FrameStateBuilder state, FixedNode originalEntry) {</span>
<span class="udiff-line-modified-added">+             this.entry = entry;</span>
              this.state = state;
<span class="udiff-line-added">+             this.originalEntry = originalEntry;</span>
          }
      }
  
      @SuppressWarnings(&quot;serial&quot;)
      public static class BytecodeParserError extends GraalError {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -712,24 +908,22 @@</span>
          this.graph = graph;
          this.options = graph.getOptions();
          this.debug = graph.getDebug();
          this.graphBuilderConfig = graphBuilderInstance.graphBuilderConfig;
          this.optimisticOpts = graphBuilderInstance.optimisticOpts;
<span class="udiff-line-modified-removed">-         this.metaAccess = graphBuilderInstance.metaAccess;</span>
<span class="udiff-line-removed">-         this.stampProvider = graphBuilderInstance.stampProvider;</span>
<span class="udiff-line-removed">-         this.constantReflection = graphBuilderInstance.constantReflection;</span>
<span class="udiff-line-removed">-         this.constantFieldProvider = graphBuilderInstance.constantFieldProvider;</span>
<span class="udiff-line-modified-added">+         this.providers = graphBuilderInstance.providers;</span>
          this.stream = new BytecodeStream(code.getCode());
          this.profilingInfo = graph.useProfilingInfo() ? code.getProfilingInfo() : null;
          this.constantPool = code.getConstantPool();
          this.intrinsicContext = intrinsicContext;
          this.entryBCI = entryBCI;
          this.parent = parent;
  
          ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
<span class="udiff-line-modified-removed">-         if (classInitializationPlugin != null &amp;&amp; graphBuilderConfig.eagerResolving()) {</span>
<span class="udiff-line-modified-removed">-             uninitializedIsError = eagerInitializing = !classInitializationPlugin.supportsLazyInitialization(constantPool);</span>
<span class="udiff-line-modified-added">+         if (classInitializationPlugin != null &amp;&amp; graphBuilderConfig.eagerResolving() &amp;&amp; classInitializationPlugin.supportsLazyInitialization(constantPool)) {</span>
<span class="udiff-line-modified-added">+             eagerInitializing = false;</span>
<span class="udiff-line-added">+             uninitializedIsError = false;</span>
          } else {
              eagerInitializing = graphBuilderConfig.eagerResolving();
              uninitializedIsError = graphBuilderConfig.unresolvedIsError();
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -776,11 +970,11 @@</span>
          return this.beforeUnwindNode;
      }
  
      @SuppressWarnings(&quot;try&quot;)
      protected void buildRootMethod() {
<span class="udiff-line-modified-removed">-         FrameStateBuilder startFrameState = new FrameStateBuilder(this, code, graph);</span>
<span class="udiff-line-modified-added">+         FrameStateBuilder startFrameState = new FrameStateBuilder(this, code, graph, graphBuilderConfig.retainLocalVariables());</span>
          startFrameState.initializeForMethodStart(graph.getAssumptions(), graphBuilderConfig.eagerResolving() || intrinsicContext != null, graphBuilderConfig.getPlugins());
  
          try (IntrinsicScope s = intrinsicContext != null ? new IntrinsicScope(this) : null) {
              build(graph.start(), startFrameState);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -944,10 +1138,15 @@</span>
              } else if (!beginNode.hasUsages()) {
                  GraphUtil.unlinkFixedNode(beginNode);
                  beginNode.safeDelete();
              }
          }
<span class="udiff-line-added">+         if (graph.isOSR() &amp;&amp; getParent() == null &amp;&amp; graph.getNodes().filter(EntryMarkerNode.class).isEmpty()) {</span>
<span class="udiff-line-added">+             // This should generally be a transient condition because of inconsistent profile</span>
<span class="udiff-line-added">+             // information.</span>
<span class="udiff-line-added">+             throw new RetryableBailoutException(&quot;OSR entry point wasn&#39;t parsed&quot;);</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /**
       * Creates the frame state after the start node of a graph for an {@link IntrinsicContext
       * intrinsic} that is the parse root (either for root compiling or for post-parse inlining).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1119,15 +1318,15 @@</span>
          FrameStateBuilder dispatchState = frameState.copy();
          dispatchState.clearStack();
  
          AbstractBeginNode dispatchBegin;
          if (exceptionObject == null) {
<span class="udiff-line-modified-removed">-             ExceptionObjectNode newExceptionObject = graph.add(new ExceptionObjectNode(metaAccess));</span>
<span class="udiff-line-modified-removed">-             dispatchBegin = newExceptionObject;</span>
<span class="udiff-line-removed">-             dispatchState.push(JavaKind.Object, dispatchBegin);</span>
<span class="udiff-line-modified-added">+             ExceptionObjectNode newExceptionObject = graph.add(new ExceptionObjectNode(getMetaAccess()));</span>
<span class="udiff-line-modified-added">+             dispatchState.push(JavaKind.Object, newExceptionObject);</span>
              dispatchState.setRethrowException(true);
              newExceptionObject.setStateAfter(dispatchState.create(bci, newExceptionObject));
<span class="udiff-line-added">+             dispatchBegin = newExceptionObject;</span>
          } else {
              dispatchBegin = graph.add(new BeginNode());
              dispatchState.push(JavaKind.Object, exceptionObject);
              dispatchState.setRethrowException(true);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1145,11 +1344,11 @@</span>
      }
  
      protected void createHandleExceptionTarget(FixedWithNextNode afterExceptionLoaded, int bci, FrameStateBuilder dispatchState) {
          FixedWithNextNode afterInstrumentation = afterExceptionLoaded;
          for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
<span class="udiff-line-modified-removed">-             afterInstrumentation = plugin.instrumentExceptionDispatch(graph, afterInstrumentation);</span>
<span class="udiff-line-modified-added">+             afterInstrumentation = plugin.instrumentExceptionDispatch(graph, afterInstrumentation, () -&gt; dispatchState.create(bci, getNonIntrinsicAncestor(), false, null, null));</span>
              assert afterInstrumentation.next() == null : &quot;exception dispatch instrumentation will be linked to dispatch block&quot;;
          }
  
          BciBlock dispatchBlock = currentBlock.exceptionDispatchBlock();
          /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1164,11 +1363,11 @@</span>
          FixedNode target = createTarget(dispatchBlock, dispatchState);
          afterInstrumentation.setNext(target);
      }
  
      protected ValueNode genLoadIndexed(ValueNode array, ValueNode index, GuardingNode boundsCheck, JavaKind kind) {
<span class="udiff-line-modified-removed">-         return LoadIndexedNode.create(graph.getAssumptions(), array, index, boundsCheck, kind, metaAccess, constantReflection);</span>
<span class="udiff-line-modified-added">+         return LoadIndexedNode.create(graph.getAssumptions(), array, index, boundsCheck, kind, getMetaAccess(), getConstantReflection());</span>
      }
  
      protected void genStoreIndexed(ValueNode array, ValueNode index, GuardingNode boundsCheck, GuardingNode storeCheck, JavaKind kind, ValueNode value) {
          add(new StoreIndexedNode(array, index, boundsCheck, storeCheck, kind, value));
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1240,11 +1439,15 @@</span>
      protected ValueNode genXor(ValueNode x, ValueNode y) {
          return XorNode.create(x, y, NodeView.DEFAULT);
      }
  
      protected ValueNode genNormalizeCompare(ValueNode x, ValueNode y, boolean isUnorderedLess) {
<span class="udiff-line-modified-removed">-         return NormalizeCompareNode.create(x, y, isUnorderedLess, JavaKind.Int, constantReflection);</span>
<span class="udiff-line-modified-added">+         return FloatNormalizeCompareNode.create(x, y, isUnorderedLess, JavaKind.Int, getConstantReflection());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     protected ValueNode genIntegerNormalizeCompare(ValueNode x, ValueNode y) {</span>
<span class="udiff-line-added">+         return IntegerNormalizeCompareNode.create(x, y, false, JavaKind.Int, getConstantReflection());</span>
      }
  
      protected ValueNode genFloatConvert(FloatConvert op, ValueNode input) {
          return FloatConvertNode.create(op, input, NodeView.DEFAULT);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1271,19 +1474,19 @@</span>
          appendGoto(currentBlock.getSuccessor(0));
          assert currentBlock.numNormalSuccessors() == 1;
      }
  
      protected LogicNode genObjectEquals(ValueNode x, ValueNode y) {
<span class="udiff-line-modified-removed">-         return ObjectEqualsNode.create(constantReflection, metaAccess, options, x, y, NodeView.DEFAULT);</span>
<span class="udiff-line-modified-added">+         return ObjectEqualsNode.create(getConstantReflection(), getMetaAccess(), options, x, y, NodeView.DEFAULT);</span>
      }
  
      protected LogicNode genIntegerEquals(ValueNode x, ValueNode y) {
<span class="udiff-line-modified-removed">-         return IntegerEqualsNode.create(constantReflection, metaAccess, options, null, x, y, NodeView.DEFAULT);</span>
<span class="udiff-line-modified-added">+         return IntegerEqualsNode.create(getConstantReflection(), getMetaAccess(), options, null, x, y, NodeView.DEFAULT);</span>
      }
  
      protected LogicNode genIntegerLessThan(ValueNode x, ValueNode y) {
<span class="udiff-line-modified-removed">-         return IntegerLessThanNode.create(constantReflection, metaAccess, options, null, x, y, NodeView.DEFAULT);</span>
<span class="udiff-line-modified-added">+         return IntegerLessThanNode.create(getConstantReflection(), getMetaAccess(), options, null, x, y, NodeView.DEFAULT);</span>
      }
  
      protected ValueNode genUnique(ValueNode x) {
          return graph.addOrUniqueWithInputs(x);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1313,11 +1516,11 @@</span>
  
      protected AnchoringNode createAnchor(JavaTypeProfile profile) {
          if (profile == null || profile.getNotRecordedProbability() &gt; 0.0) {
              return null;
          } else {
<span class="udiff-line-modified-removed">-             return append(new ValueAnchorNode(null));</span>
<span class="udiff-line-modified-added">+             return BeginNode.prevBegin(lastInstr);</span>
          }
      }
  
      protected LogicNode createInstanceOf(TypeReference type, ValueNode object, JavaTypeProfile profile) {
          return InstanceOfNode.create(type, object, profile, createAnchor(profile));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1370,55 +1573,55 @@</span>
      protected GuardingNode maybeEmitExplicitBoundsCheck(ValueNode receiver, ValueNode index) {
          if (!needsExplicitBoundsCheckException(receiver, index)) {
              return null;
          }
          ValueNode length = append(genArrayLength(receiver));
<span class="udiff-line-modified-removed">-         LogicNode condition = genUnique(IntegerBelowNode.create(constantReflection, metaAccess, options, null, index, length, NodeView.DEFAULT));</span>
<span class="udiff-line-modified-added">+         LogicNode condition = genUnique(IntegerBelowNode.create(getConstantReflection(), getMetaAccess(), options, null, index, length, NodeView.DEFAULT));</span>
          return emitBytecodeExceptionCheck(condition, true, BytecodeExceptionKind.OUT_OF_BOUNDS, index, length);
      }
  
      protected GuardingNode maybeEmitExplicitStoreCheck(ValueNode array, JavaKind elementKind, ValueNode value) {
          if (elementKind != JavaKind.Object || StampTool.isPointerAlwaysNull(value) || !needsExplicitStoreCheckException(array, value)) {
              return null;
          }
<span class="udiff-line-modified-removed">-         ValueNode arrayClass = genUnique(LoadHubNode.create(array, stampProvider, metaAccess, constantReflection));</span>
<span class="udiff-line-modified-removed">-         ValueNode componentHub = append(LoadArrayComponentHubNode.create(arrayClass, stampProvider, metaAccess, constantReflection));</span>
<span class="udiff-line-modified-added">+         ValueNode arrayClass = genUnique(LoadHubNode.create(array, getStampProvider(), getMetaAccess(), getConstantReflection()));</span>
<span class="udiff-line-modified-added">+         ValueNode componentHub = append(LoadArrayComponentHubNode.create(arrayClass, getStampProvider(), getMetaAccess(), getConstantReflection()));</span>
          LogicNode condition = genUnique(InstanceOfDynamicNode.create(graph.getAssumptions(), getConstantReflection(), componentHub, value, true));
          return emitBytecodeExceptionCheck(condition, true, BytecodeExceptionKind.ARRAY_STORE, value);
      }
  
      protected GuardingNode maybeEmitExplicitDivisionByZeroCheck(ValueNode y) {
          if (!((IntegerStamp) y.stamp(NodeView.DEFAULT)).contains(0) || !needsExplicitDivisionByZeroException(y)) {
              return null;
          }
          ConstantNode zero = ConstantNode.defaultForKind(y.getStackKind(), graph);
<span class="udiff-line-modified-removed">-         LogicNode condition = genUnique(IntegerEqualsNode.create(constantReflection, metaAccess, options, null, y, zero, NodeView.DEFAULT));</span>
<span class="udiff-line-modified-added">+         LogicNode condition = genUnique(IntegerEqualsNode.create(getConstantReflection(), getMetaAccess(), options, null, y, zero, NodeView.DEFAULT));</span>
          return emitBytecodeExceptionCheck(condition, false, BytecodeExceptionKind.DIVISION_BY_ZERO);
      }
  
      private AbstractBeginNode emitBytecodeExceptionCheck(LogicNode condition, boolean passingOnTrue, BytecodeExceptionKind exceptionKind, ValueNode... arguments) {
          if (passingOnTrue ? condition.isTautology() : condition.isContradiction()) {
              return null;
          }
  
<span class="udiff-line-modified-removed">-         BytecodeExceptionNode exception = graph.add(new BytecodeExceptionNode(metaAccess, exceptionKind, arguments));</span>
<span class="udiff-line-modified-added">+         BytecodeExceptionNode exception = graph.add(new BytecodeExceptionNode(getMetaAccess(), exceptionKind, arguments));</span>
          AbstractBeginNode passingSuccessor = graph.add(new BeginNode());
  
          FixedNode trueSuccessor = passingOnTrue ? passingSuccessor : exception;
          FixedNode falseSuccessor = passingOnTrue ? exception : passingSuccessor;
          append(new IfNode(condition, trueSuccessor, falseSuccessor, passingOnTrue ? LUDICROUSLY_FAST_PATH_PROBABILITY : LUDICROUSLY_SLOW_PATH_PROBABILITY));
          lastInstr = passingSuccessor;
  
<span class="udiff-line-modified-removed">-         exception.setStateAfter(createFrameState(bci(), exception));</span>
<span class="udiff-line-modified-added">+         exception.setStateAfter(createBytecodeExceptionFrameState(bci(), exception));</span>
          exception.setNext(handleException(exception, bci(), false));
          EXPLICIT_EXCEPTIONS.increment(debug);
  
          return passingSuccessor;
      }
  
      protected ValueNode genArrayLength(ValueNode x) {
<span class="udiff-line-modified-removed">-         return ArrayLengthNode.create(x, constantReflection);</span>
<span class="udiff-line-modified-added">+         return ArrayLengthNode.create(x, getConstantReflection());</span>
      }
  
      protected void genStoreField(ValueNode receiver, ResolvedJavaField field, ValueNode value) {
          StoreFieldNode storeFieldNode = new StoreFieldNode(receiver, field, maskSubWordValue(value, field.getJavaKind()));
          append(storeFieldNode);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1565,11 +1768,11 @@</span>
  
                  // Will perform runtime type checks and static initialization
                  FrameState stateBefore = createCurrentFrameState();
                  appendixNode = invokeDynamicPlugin.genAppendixNode(this, cpi, opcode, appendix, stateBefore);
              } else {
<span class="udiff-line-modified-removed">-                 appendixNode = ConstantNode.forConstant(appendix, metaAccess, graph);</span>
<span class="udiff-line-modified-added">+                 appendixNode = ConstantNode.forConstant(appendix, getMetaAccess(), graph);</span>
              }
  
              frameState.push(JavaKind.Object, appendixNode);
  
          } else if (GeneratePIC.getValue(options)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1627,14 +1830,11 @@</span>
      protected final Bytecode code;
      protected final BytecodeProvider bytecodeProvider;
      protected final ProfilingInfo profilingInfo;
      protected final OptimisticOptimizations optimisticOpts;
      protected final ConstantPool constantPool;
<span class="udiff-line-modified-removed">-     protected final MetaAccessProvider metaAccess;</span>
<span class="udiff-line-removed">-     private final ConstantReflectionProvider constantReflection;</span>
<span class="udiff-line-removed">-     private final ConstantFieldProvider constantFieldProvider;</span>
<span class="udiff-line-removed">-     private final StampProvider stampProvider;</span>
<span class="udiff-line-modified-added">+     protected final CoreProviders providers;</span>
      protected final IntrinsicContext intrinsicContext;
  
      @Override
      public InvokeKind getInvokeKind() {
          return currentInvoke == null ? null : currentInvoke.kind;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1682,14 +1882,11 @@</span>
              append(new DeoptimizeNode(DeoptimizationAction.None, RuntimeConstraint));
              frameState.pushReturn(resultType, ConstantNode.defaultForKind(resultType, graph));
              return null;
          }
  
<span class="udiff-line-modified-removed">-         JavaType returnType = targetMethod.getSignature().getReturnType(method.getDeclaringClass());</span>
<span class="udiff-line-removed">-         if (graphBuilderConfig.eagerResolving() || parsingIntrinsic()) {</span>
<span class="udiff-line-removed">-             returnType = returnType.resolve(targetMethod.getDeclaringClass());</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         JavaType returnType = maybeEagerlyResolve(targetMethod.getSignature().getReturnType(method.getDeclaringClass()), targetMethod.getDeclaringClass());</span>
          if (invokeKind.hasReceiver()) {
              args[0] = maybeEmitExplicitNullCheck(args[0]);
          }
  
          if (initialInvokeKind == InvokeKind.Special &amp;&amp; !targetMethod.isConstructor()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1711,12 +1908,12 @@</span>
              if (invokeKind.hasReceiver() &amp;&amp; args[0].isNullConstant()) {
                  append(new DeoptimizeNode(InvalidateRecompile, NullCheckException));
                  return null;
              }
  
<span class="udiff-line-modified-removed">-             if (!invokeKind.isIndirect() || (UseGuardedIntrinsics.getValue(options) &amp;&amp; !GeneratePIC.getValue(options))) {</span>
<span class="udiff-line-modified-removed">-                 if (tryInvocationPlugin(invokeKind, args, targetMethod, resultType, returnType)) {</span>
<span class="udiff-line-modified-added">+             if (!invokeKind.isIndirect()) {</span>
<span class="udiff-line-modified-added">+                 if (tryInvocationPlugin(invokeKind, args, targetMethod, resultType)) {</span>
                      if (TraceParserPlugins.getValue(options)) {
                          traceWithContext(&quot;used invocation plugin for %s&quot;, targetMethod.format(&quot;%h.%n(%p)&quot;));
                      }
                      return null;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1728,11 +1925,10 @@</span>
                  }
              }
          } finally {
              currentInvoke = null;
          }
<span class="udiff-line-removed">- </span>
          int invokeBci = bci();
          JavaTypeProfile profile = getProfileForInvoke(invokeKind);
          ExceptionEdgeAction edgeAction = getActionForInvokeExceptionEdge(inlineInfo);
          boolean partialIntrinsicExit = false;
          if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1750,11 +1946,11 @@</span>
                  // This call is a partial intrinsic exit, and we do not have profile information
                  // for this callsite. We also have to assume that the call needs an exception
                  // edge. Finally, we know that this intrinsic is parsed for late inlining,
                  // so the bci must be set to unknown, so that the inliner patches it later.
                  assert intrinsicContext.isPostParseInlined();
<span class="udiff-line-modified-removed">-                 invokeBci = BytecodeFrame.UNKNOWN_BCI;</span>
<span class="udiff-line-modified-added">+                 invokeBci = UNKNOWN_BCI;</span>
                  profile = null;
                  edgeAction = graph.method().getAnnotation(Snippet.class) == null ? ExceptionEdgeAction.INCLUDE_AND_HANDLE : ExceptionEdgeAction.OMIT;
              }
  
              if (originalMethod.isStatic()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1952,11 +2148,11 @@</span>
              this.nodeCount = graph.getNodeCount();
              this.mark = graph.getMark();
          }
  
          String error(String format, Object... a) {
<span class="udiff-line-modified-removed">-             return String.format(format, a) + String.format(&quot;%n\tplugin at %s&quot;, plugin.getApplySourceLocation(metaAccess));</span>
<span class="udiff-line-modified-added">+             return String.format(format, a) + String.format(&quot;%n\tplugin at %s&quot;, plugin.getApplySourceLocation(getMetaAccess()));</span>
          }
  
          boolean check(boolean pluginResult) {
              if (pluginResult) {
                  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1988,207 +2184,30 @@</span>
              }
              return true;
          }
      }
  
<span class="udiff-line-removed">-     protected static class IntrinsicGuard {</span>
<span class="udiff-line-removed">-         final FixedWithNextNode lastInstr;</span>
<span class="udiff-line-removed">-         final Mark mark;</span>
<span class="udiff-line-removed">-         final AbstractBeginNode nonIntrinsicBranch;</span>
<span class="udiff-line-removed">-         final ValueNode receiver;</span>
<span class="udiff-line-removed">-         final JavaTypeProfile profile;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         public IntrinsicGuard(FixedWithNextNode lastInstr, ValueNode receiver, Mark mark, AbstractBeginNode nonIntrinsicBranch, JavaTypeProfile profile) {</span>
<span class="udiff-line-removed">-             this.lastInstr = lastInstr;</span>
<span class="udiff-line-removed">-             this.receiver = receiver;</span>
<span class="udiff-line-removed">-             this.mark = mark;</span>
<span class="udiff-line-removed">-             this.nonIntrinsicBranch = nonIntrinsicBranch;</span>
<span class="udiff-line-removed">-             this.profile = profile;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Weaves a test of the receiver type to ensure the dispatch will select {@code targetMethod}</span>
<span class="udiff-line-removed">-      * and not another method that overrides it. This should only be called if there is an</span>
<span class="udiff-line-removed">-      * {@link InvocationPlugin} for {@code targetMethod} and the invocation is indirect.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * The control flow woven around the intrinsic is as follows:</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * &lt;pre&gt;</span>
<span class="udiff-line-removed">-      *  if (LoadMethod(LoadHub(receiver)) == targetMethod) {</span>
<span class="udiff-line-removed">-      *       &lt;intrinsic for targetMethod&gt;</span>
<span class="udiff-line-removed">-      *  } else {</span>
<span class="udiff-line-removed">-      *       &lt;virtual call to targetMethod&gt;</span>
<span class="udiff-line-removed">-      *  }</span>
<span class="udiff-line-removed">-      * &lt;/pre&gt;</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * The {@code else} branch is woven by {@link #afterInvocationPluginExecution}.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @return {@code null} if the intrinsic cannot be used otherwise an object to be used by</span>
<span class="udiff-line-removed">-      *         {@link #afterInvocationPluginExecution} to weave code for the non-intrinsic branch</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     protected IntrinsicGuard guardIntrinsic(ValueNode[] args, ResolvedJavaMethod targetMethod, InvocationPluginReceiver pluginReceiver) {</span>
<span class="udiff-line-removed">-         ValueNode intrinsicReceiver = args[0];</span>
<span class="udiff-line-removed">-         ResolvedJavaType receiverType = StampTool.typeOrNull(intrinsicReceiver);</span>
<span class="udiff-line-removed">-         if (receiverType == null) {</span>
<span class="udiff-line-removed">-             // The verifier guarantees it to be at least type declaring targetMethod</span>
<span class="udiff-line-removed">-             receiverType = targetMethod.getDeclaringClass();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         ResolvedJavaMethod resolvedMethod = receiverType.resolveMethod(targetMethod, method.getDeclaringClass());</span>
<span class="udiff-line-removed">-         if (resolvedMethod == null || resolvedMethod.equals(targetMethod)) {</span>
<span class="udiff-line-removed">-             assert resolvedMethod == null || targetMethod.getDeclaringClass().isAssignableFrom(resolvedMethod.getDeclaringClass());</span>
<span class="udiff-line-removed">-             Mark mark = graph.getMark();</span>
<span class="udiff-line-removed">-             FixedWithNextNode currentLastInstr = lastInstr;</span>
<span class="udiff-line-removed">-             ValueNode nonNullReceiver = pluginReceiver.get();</span>
<span class="udiff-line-removed">-             Stamp methodStamp = stampProvider.createMethodStamp();</span>
<span class="udiff-line-removed">-             LoadHubNode hub = graph.unique(new LoadHubNode(stampProvider, nonNullReceiver));</span>
<span class="udiff-line-removed">-             LoadMethodNode actual = append(new LoadMethodNode(methodStamp, targetMethod, receiverType, method.getDeclaringClass(), hub));</span>
<span class="udiff-line-removed">-             ConstantNode expected = graph.unique(ConstantNode.forConstant(methodStamp, targetMethod.getEncoding(), getMetaAccess()));</span>
<span class="udiff-line-removed">-             LogicNode compare = graph.addOrUniqueWithInputs(CompareNode.createCompareNode(constantReflection, metaAccess, options, null, CanonicalCondition.EQ, actual, expected, NodeView.DEFAULT));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             JavaTypeProfile profile = null;</span>
<span class="udiff-line-removed">-             if (profilingInfo != null &amp;&amp; this.optimisticOpts.useTypeCheckHints(getOptions())) {</span>
<span class="udiff-line-removed">-                 profile = profilingInfo.getTypeProfile(bci());</span>
<span class="udiff-line-removed">-                 if (profile != null) {</span>
<span class="udiff-line-removed">-                     JavaTypeProfile newProfile = adjustProfileForInvocationPlugin(profile, targetMethod);</span>
<span class="udiff-line-removed">-                     if (newProfile != profile) {</span>
<span class="udiff-line-removed">-                         if (newProfile.getTypes().length == 0) {</span>
<span class="udiff-line-removed">-                             // All profiled types select the intrinsic so</span>
<span class="udiff-line-removed">-                             // emit a fixed guard instead of an if-then-else.</span>
<span class="udiff-line-removed">-                             lastInstr = append(new FixedGuardNode(compare, TypeCheckedInliningViolated, InvalidateReprofile, false));</span>
<span class="udiff-line-removed">-                             return new IntrinsicGuard(currentLastInstr, intrinsicReceiver, mark, null, null);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         // No profiled types select the intrinsic so emit a virtual call</span>
<span class="udiff-line-removed">-                         return null;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     profile = newProfile;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             AbstractBeginNode intrinsicBranch = graph.add(new BeginNode());</span>
<span class="udiff-line-removed">-             AbstractBeginNode nonIntrinsicBranch = graph.add(new BeginNode());</span>
<span class="udiff-line-removed">-             append(new IfNode(compare, intrinsicBranch, nonIntrinsicBranch, FAST_PATH_PROBABILITY));</span>
<span class="udiff-line-removed">-             lastInstr = intrinsicBranch;</span>
<span class="udiff-line-removed">-             return new IntrinsicGuard(currentLastInstr, intrinsicReceiver, mark, nonIntrinsicBranch, profile);</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             // Receiver selects an overriding method so emit a virtual call</span>
<span class="udiff-line-removed">-             return null;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Adjusts the profile for an indirect invocation of a virtual method for which there is an</span>
<span class="udiff-line-removed">-      * intrinsic. The adjustment made by this method is to remove all types from the profile that do</span>
<span class="udiff-line-removed">-      * not override {@code targetMethod}.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param profile the profile to adjust</span>
<span class="udiff-line-removed">-      * @param targetMethod the virtual method for which there is an intrinsic</span>
<span class="udiff-line-removed">-      * @return the adjusted profile or the original {@code profile} object if no adjustment was made</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     protected JavaTypeProfile adjustProfileForInvocationPlugin(JavaTypeProfile profile, ResolvedJavaMethod targetMethod) {</span>
<span class="udiff-line-removed">-         if (profile.getTypes().length &gt; 0) {</span>
<span class="udiff-line-removed">-             List&lt;ProfiledType&gt; retained = new ArrayList&lt;&gt;();</span>
<span class="udiff-line-removed">-             double notRecordedProbability = profile.getNotRecordedProbability();</span>
<span class="udiff-line-removed">-             for (ProfiledType ptype : profile.getTypes()) {</span>
<span class="udiff-line-removed">-                 if (!ptype.getType().resolveMethod(targetMethod, method.getDeclaringClass()).equals(targetMethod)) {</span>
<span class="udiff-line-removed">-                     retained.add(ptype);</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     notRecordedProbability += ptype.getProbability();</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if (!retained.isEmpty()) {</span>
<span class="udiff-line-removed">-                 if (retained.size() != profile.getTypes().length) {</span>
<span class="udiff-line-removed">-                     return new JavaTypeProfile(profile.getNullSeen(), notRecordedProbability, retained.toArray(new ProfiledType[retained.size()]));</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 return new JavaTypeProfile(profile.getNullSeen(), notRecordedProbability, new ProfiledType[0]);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return profile;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Performs any action required after execution of an invocation plugin. This includes</span>
<span class="udiff-line-removed">-      * {@linkplain InvocationPluginAssertions#check checking} invocation plugin invariants as well</span>
<span class="udiff-line-removed">-      * as weaving the {@code else} branch of the code woven by {@link #guardIntrinsic} if</span>
<span class="udiff-line-removed">-      * {@code guard != null}.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     protected void afterInvocationPluginExecution(boolean pluginHandledInvoke, InvocationPluginAssertions assertions, IntrinsicGuard intrinsicGuard,</span>
<span class="udiff-line-removed">-                     InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType, JavaType returnType) {</span>
<span class="udiff-line-removed">-         assert assertions.check(pluginHandledInvoke);</span>
<span class="udiff-line-removed">-         if (intrinsicGuard != null) {</span>
<span class="udiff-line-removed">-             if (pluginHandledInvoke) {</span>
<span class="udiff-line-removed">-                 if (intrinsicGuard.nonIntrinsicBranch != null) {</span>
<span class="udiff-line-removed">-                     // Intrinsic emitted: emit a virtual call to the target method and</span>
<span class="udiff-line-removed">-                     // merge it with the intrinsic branch</span>
<span class="udiff-line-removed">-                     EndNode intrinsicEnd = append(new EndNode());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     FrameStateBuilder intrinsicState = null;</span>
<span class="udiff-line-removed">-                     FrameStateBuilder nonIntrinisicState = null;</span>
<span class="udiff-line-removed">-                     if (resultType != JavaKind.Void) {</span>
<span class="udiff-line-removed">-                         intrinsicState = frameState.copy();</span>
<span class="udiff-line-removed">-                         frameState.pop(resultType);</span>
<span class="udiff-line-removed">-                         nonIntrinisicState = frameState;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     lastInstr = intrinsicGuard.nonIntrinsicBranch;</span>
<span class="udiff-line-removed">-                     createNonInlinedInvoke(getActionForInvokeExceptionEdge(null), bci(), args, targetMethod, invokeKind, resultType, returnType, intrinsicGuard.profile);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     EndNode nonIntrinsicEnd = append(new EndNode());</span>
<span class="udiff-line-removed">-                     AbstractMergeNode mergeNode = graph.add(new MergeNode());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     mergeNode.addForwardEnd(intrinsicEnd);</span>
<span class="udiff-line-removed">-                     if (intrinsicState != null) {</span>
<span class="udiff-line-removed">-                         intrinsicState.merge(mergeNode, nonIntrinisicState);</span>
<span class="udiff-line-removed">-                         frameState = intrinsicState;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     mergeNode.addForwardEnd(nonIntrinsicEnd);</span>
<span class="udiff-line-removed">-                     mergeNode.setStateAfter(frameState.create(stream.nextBCI(), mergeNode));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     lastInstr = mergeNode;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 // Intrinsic was not applied: remove intrinsic guard</span>
<span class="udiff-line-removed">-                 // and restore the original receiver node in the arguments array</span>
<span class="udiff-line-removed">-                 intrinsicGuard.lastInstr.setNext(null);</span>
<span class="udiff-line-removed">-                 GraphUtil.removeNewNodes(graph, intrinsicGuard.mark);</span>
<span class="udiff-line-removed">-                 lastInstr = intrinsicGuard.lastInstr;</span>
<span class="udiff-line-removed">-                 args[0] = intrinsicGuard.receiver;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      @SuppressWarnings(&quot;try&quot;)
<span class="udiff-line-modified-removed">-     protected boolean tryInvocationPlugin(InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType, JavaType returnType) {</span>
<span class="udiff-line-modified-added">+     protected boolean tryInvocationPlugin(InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {</span>
          InvocationPlugin plugin = graphBuilderConfig.getPlugins().getInvocationPlugins().lookupInvocation(targetMethod);
          if (plugin != null) {
  
              if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
                  // Self recursive intrinsic means the original method should be called.
                  return false;
              }
  
              InvocationPluginReceiver pluginReceiver = invocationPluginReceiver.init(targetMethod, args);
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-             IntrinsicGuard intrinsicGuard = null;</span>
<span class="udiff-line-removed">-             if (invokeKind.isIndirect()) {</span>
<span class="udiff-line-removed">-                 intrinsicGuard = guardIntrinsic(args, targetMethod, pluginReceiver);</span>
<span class="udiff-line-removed">-                 if (intrinsicGuard == null) {</span>
<span class="udiff-line-removed">-                     return false;</span>
<span class="udiff-line-removed">-                 } else if (intrinsicGuard.nonIntrinsicBranch == null) {</span>
<span class="udiff-line-removed">-                     assert lastInstr instanceof FixedGuardNode;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+             assert invokeKind.isDirect() : &quot;Cannot apply invocation plugin on an indirect call site.&quot;;</span>
  
              InvocationPluginAssertions assertions = Assertions.assertionsEnabled() ? new InvocationPluginAssertions(plugin, args, targetMethod, resultType) : null;
              try (DebugCloseable context = openNodeContext(targetMethod)) {
                  if (plugin.execute(this, targetMethod, pluginReceiver, args)) {
<span class="udiff-line-modified-removed">-                     afterInvocationPluginExecution(true, assertions, intrinsicGuard, invokeKind, args, targetMethod, resultType, returnType);</span>
<span class="udiff-line-modified-added">+                     assert assertions.check(true);</span>
                      return !plugin.isDecorator();
                  } else {
<span class="udiff-line-modified-removed">-                     afterInvocationPluginExecution(false, assertions, intrinsicGuard, invokeKind, args, targetMethod, resultType, returnType);</span>
<span class="udiff-line-modified-added">+                     assert assertions.check(false);</span>
                  }
              }
          }
          return false;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2224,11 +2243,11 @@</span>
          }
  
          for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
              InlineInfo inlineInfo = plugin.shouldInlineInvoke(this, targetMethod, args);
              if (inlineInfo != null) {
<span class="udiff-line-modified-removed">-                 if (inlineInfo.getMethodToInline() != null) {</span>
<span class="udiff-line-modified-added">+                 if (inlineInfo.allowsInlining()) {</span>
                      if (inline(targetMethod, inlineInfo.getMethodToInline(), inlineInfo.getIntrinsicBytecodeProvider(), args)) {
                          return SUCCESSFULLY_INLINED;
                      }
                      inlineInfo = null;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2278,10 +2297,138 @@</span>
              }
          }
          return false;
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Inline a method substitution graph. This is necessary for libgraal as substitutions only</span>
<span class="udiff-line-added">+      * exist as encoded graphs and can&#39;t be parsed directly into the caller.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     @SuppressWarnings(&quot;try&quot;)</span>
<span class="udiff-line-added">+     public boolean intrinsify(ResolvedJavaMethod targetMethod, StructuredGraph substituteGraph, InvocationPlugin.Receiver receiver, ValueNode[] args) {</span>
<span class="udiff-line-added">+         if (receiver != null) {</span>
<span class="udiff-line-added">+             receiver.get();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         InvokeWithExceptionNode withException = null;</span>
<span class="udiff-line-added">+         FixedWithNextNode replacee = lastInstr;</span>
<span class="udiff-line-added">+         try (DebugContext.Scope a = debug.scope(&quot;instantiate&quot;, substituteGraph)) {</span>
<span class="udiff-line-added">+             // Inline the snippet nodes, replacing parameters with the given args in the process</span>
<span class="udiff-line-added">+             StartNode entryPointNode = substituteGraph.start();</span>
<span class="udiff-line-added">+             FixedNode firstCFGNode = entryPointNode.next();</span>
<span class="udiff-line-added">+             StructuredGraph replaceeGraph = replacee.graph();</span>
<span class="udiff-line-added">+             Mark mark = replaceeGraph.getMark();</span>
<span class="udiff-line-added">+             try (InliningScope inlineScope = new IntrinsicScope(this, targetMethod, args)) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 EconomicMap&lt;Node, Node&gt; replacementsMap = EconomicMap.create(Equivalence.IDENTITY);</span>
<span class="udiff-line-added">+                 for (ParameterNode param : substituteGraph.getNodes().filter(ParameterNode.class)) {</span>
<span class="udiff-line-added">+                     replacementsMap.put(param, args[param.index()]);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 replacementsMap.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;Before inlining method substitution %s&quot;, substituteGraph.method());</span>
<span class="udiff-line-added">+                 UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineMethodSubstitution(replaceeGraph, substituteGraph, replacementsMap);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);</span>
<span class="udiff-line-added">+                 replacee.setNext(firstCFGNodeDuplicate);</span>
<span class="udiff-line-added">+                 debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After inlining method substitution %s&quot;, substituteGraph.method());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Handle partial intrinsic exits</span>
<span class="udiff-line-added">+                 for (Node node : graph.getNewNodes(mark)) {</span>
<span class="udiff-line-added">+                     if (node instanceof Invoke) {</span>
<span class="udiff-line-added">+                         Invoke invoke = (Invoke) node;</span>
<span class="udiff-line-added">+                         if (invoke.bci() == BytecodeFrame.UNKNOWN_BCI) {</span>
<span class="udiff-line-added">+                             invoke.replaceBci(bci());</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         if (node instanceof InvokeWithExceptionNode) {</span>
<span class="udiff-line-added">+                             // The graphs for MethodSubsitutions are produced assuming that</span>
<span class="udiff-line-added">+                             // exceptions</span>
<span class="udiff-line-added">+                             // must be dispatched. If the calling context doesn&#39;t want exception</span>
<span class="udiff-line-added">+                             // then</span>
<span class="udiff-line-added">+                             // convert back into a normal InvokeNode.</span>
<span class="udiff-line-added">+                             assert withException == null : &quot;only one invoke expected&quot;;</span>
<span class="udiff-line-added">+                             withException = (InvokeWithExceptionNode) node;</span>
<span class="udiff-line-added">+                             BytecodeParser intrinsicCallSiteParser = getNonIntrinsicAncestor();</span>
<span class="udiff-line-added">+                             if (intrinsicCallSiteParser != null &amp;&amp; intrinsicCallSiteParser.getActionForInvokeExceptionEdge(null) == ExceptionEdgeAction.OMIT) {</span>
<span class="udiff-line-added">+                                 InvokeNode newInvoke = graph.add(new InvokeNode(withException));</span>
<span class="udiff-line-added">+                                 newInvoke.setStateDuring(withException.stateDuring());</span>
<span class="udiff-line-added">+                                 newInvoke.setStateAfter(withException.stateAfter());</span>
<span class="udiff-line-added">+                                 withException.killExceptionEdge();</span>
<span class="udiff-line-added">+                                 AbstractBeginNode next = withException.killKillingBegin();</span>
<span class="udiff-line-added">+                                 FixedWithNextNode pred = (FixedWithNextNode) withException.predecessor();</span>
<span class="udiff-line-added">+                                 pred.setNext(newInvoke);</span>
<span class="udiff-line-added">+                                 withException.setNext(null);</span>
<span class="udiff-line-added">+                                 newInvoke.setNext(next);</span>
<span class="udiff-line-added">+                                 withException.replaceAndDelete(newInvoke);</span>
<span class="udiff-line-added">+                             } else {</span>
<span class="udiff-line-added">+                                 // Disconnnect exception edge</span>
<span class="udiff-line-added">+                                 withException.killExceptionEdge();</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     } else if (node instanceof ForeignCallNode) {</span>
<span class="udiff-line-added">+                         ForeignCallNode call = (ForeignCallNode) node;</span>
<span class="udiff-line-added">+                         if (call.getBci() == BytecodeFrame.UNKNOWN_BCI) {</span>
<span class="udiff-line-added">+                             call.setBci(bci());</span>
<span class="udiff-line-added">+                             if (call.stateAfter() != null &amp;&amp; call.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {</span>
<span class="udiff-line-added">+                                 call.setStateAfter(inlineScope.stateBefore);</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 ArrayList&lt;ReturnToCallerData&gt; calleeReturnDataList = new ArrayList&lt;&gt;();</span>
<span class="udiff-line-added">+                 for (ReturnNode n : substituteGraph.getNodes().filter(ReturnNode.class)) {</span>
<span class="udiff-line-added">+                     ReturnNode returnNode = (ReturnNode) duplicates.get(n);</span>
<span class="udiff-line-added">+                     FixedWithNextNode predecessor = (FixedWithNextNode) returnNode.predecessor();</span>
<span class="udiff-line-added">+                     calleeReturnDataList.add(new ReturnToCallerData(returnNode.result(), predecessor));</span>
<span class="udiff-line-added">+                     predecessor.setNext(null);</span>
<span class="udiff-line-added">+                     returnNode.safeDelete();</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Merge multiple returns</span>
<span class="udiff-line-added">+                 processCalleeReturn(targetMethod, inlineScope, calleeReturnDataList);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // Exiting this scope causes processing of the placeholder frame states.</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (withException != null &amp;&amp; withException.isAlive()) {</span>
<span class="udiff-line-added">+                 // Connect exception edge into main graph</span>
<span class="udiff-line-added">+                 AbstractBeginNode exceptionEdge = handleException(null, bci(), false);</span>
<span class="udiff-line-added">+                 withException.setExceptionEdge(exceptionEdge);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         } catch (Throwable t) {</span>
<span class="udiff-line-added">+             throw debug.handle(t);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static UnmodifiableEconomicMap&lt;Node, Node&gt; inlineMethodSubstitution(StructuredGraph replaceeGraph, StructuredGraph snippet,</span>
<span class="udiff-line-added">+                     EconomicMap&lt;Node, Node&gt; replacementsMap) {</span>
<span class="udiff-line-added">+         try (InliningLog.UpdateScope scope = replaceeGraph.getInliningLog().openUpdateScope((oldNode, newNode) -&gt; {</span>
<span class="udiff-line-added">+             InliningLog log = replaceeGraph.getInliningLog();</span>
<span class="udiff-line-added">+             if (oldNode == null) {</span>
<span class="udiff-line-added">+                 log.trackNewCallsite(newNode);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         })) {</span>
<span class="udiff-line-added">+             StartNode entryPointNode = snippet.start();</span>
<span class="udiff-line-added">+             ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(snippet.getNodeCount());</span>
<span class="udiff-line-added">+             for (Node node : snippet.getNodes()) {</span>
<span class="udiff-line-added">+                 if (node != entryPointNode &amp;&amp; node != entryPointNode.stateAfter()) {</span>
<span class="udiff-line-added">+                     nodes.add(node);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = replaceeGraph.addDuplicates(nodes, snippet, snippet.getNodeCount(), replacementsMap);</span>
<span class="udiff-line-added">+             if (scope != null) {</span>
<span class="udiff-line-added">+                 replaceeGraph.getInliningLog().addLog(duplicates, snippet.getInliningLog());</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return duplicates;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @Override
      public boolean intrinsify(BytecodeProvider intrinsicBytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] args) {
          if (receiver != null) {
              receiver.get();
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2319,11 +2466,11 @@</span>
                          if (scope != null) {
                              graph.getInliningLog().addDecision(scope.getInvoke(), false, &quot;GraphBuilderPhase&quot;, null, null, &quot;native method&quot;);
                          }
                          return false;
                      }
<span class="udiff-line-modified-removed">-                     if (canInlinePartialIntrinsicExit() &amp;&amp; InlinePartialIntrinsicExitDuringParsing.getValue(options) &amp;&amp; !IS_BUILDING_NATIVE_IMAGE) {</span>
<span class="udiff-line-modified-added">+                     if (canInlinePartialIntrinsicExit()) {</span>
                          // Otherwise inline the original method. Any frame state created
                          // during the inlining will exclude frame(s) in the
                          // intrinsic method (see FrameStateBuilder.create(int bci)).
                          notifyBeforeInline(inlinedMethod);
                          printInlining(targetMethod, inlinedMethod, true, &quot;partial intrinsic exit (bytecode parsing)&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2382,11 +2529,11 @@</span>
      /**
       * Determines if a partial intrinsic exit (i.e., a call to the original method within an
       * intrinsic) can be inlined.
       */
      protected boolean canInlinePartialIntrinsicExit() {
<span class="udiff-line-modified-removed">-         return true;</span>
<span class="udiff-line-modified-added">+         return InlinePartialIntrinsicExitDuringParsing.getValue(options) &amp;&amp; !IS_BUILDING_NATIVE_IMAGE &amp;&amp; method.getAnnotation(Snippet.class) == null;</span>
      }
  
      private void printInlining(ResolvedJavaMethod targetMethod, ResolvedJavaMethod inlinedMethod, boolean success, String msg) {
          if (success) {
              if (TraceInlineDuringParsing.getValue(options) || TraceParserPlugins.getValue(options)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2442,57 +2589,35 @@</span>
  
      protected void parseAndInlineCallee(ResolvedJavaMethod targetMethod, ValueNode[] args, IntrinsicContext calleeIntrinsicContext) {
          FixedWithNextNode calleeBeforeUnwindNode = null;
          ValueNode calleeUnwindValue = null;
  
<span class="udiff-line-modified-removed">-         try (IntrinsicScope s = calleeIntrinsicContext != null &amp;&amp; !parsingIntrinsic() ? new IntrinsicScope(this, targetMethod.getSignature().toParameterKinds(!targetMethod.isStatic()), args) : null) {</span>
<span class="udiff-line-modified-added">+         try (InliningScope s = parsingIntrinsic() ? null</span>
<span class="udiff-line-added">+                         : (calleeIntrinsicContext != null ? new IntrinsicScope(this, targetMethod, args)</span>
<span class="udiff-line-added">+                                         : new InliningScope(this, targetMethod, args))) {</span>
              BytecodeParser parser = graphBuilderInstance.createBytecodeParser(graph, this, targetMethod, INVOCATION_ENTRY_BCI, calleeIntrinsicContext);
<span class="udiff-line-modified-removed">-             FrameStateBuilder startFrameState = new FrameStateBuilder(parser, parser.code, graph);</span>
<span class="udiff-line-modified-added">+             boolean targetIsSubstitution = targetMethod.isAnnotationPresent(MethodSubstitution.class);</span>
<span class="udiff-line-added">+             FrameStateBuilder startFrameState = new FrameStateBuilder(parser, parser.code, graph, graphBuilderConfig.retainLocalVariables() &amp;&amp; !targetIsSubstitution);</span>
              if (!targetMethod.isStatic()) {
                  args[0] = nullCheckedValue(args[0]);
              }
              startFrameState.initializeFromArgumentsArray(args);
              parser.build(this.lastInstr, startFrameState);
  
<span class="udiff-line-modified-removed">-             if (parser.returnDataList == null) {</span>
<span class="udiff-line-removed">-                 /* Callee does not return. */</span>
<span class="udiff-line-removed">-                 lastInstr = null;</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 ValueNode calleeReturnValue;</span>
<span class="udiff-line-removed">-                 MergeNode returnMergeNode = null;</span>
<span class="udiff-line-removed">-                 if (s != null) {</span>
<span class="udiff-line-removed">-                     s.returnDataList = parser.returnDataList;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 if (parser.returnDataList.size() == 1) {</span>
<span class="udiff-line-removed">-                     /* Callee has a single return, we can continue parsing at that point. */</span>
<span class="udiff-line-removed">-                     ReturnToCallerData singleReturnData = parser.returnDataList.get(0);</span>
<span class="udiff-line-removed">-                     lastInstr = singleReturnData.beforeReturnNode;</span>
<span class="udiff-line-removed">-                     calleeReturnValue = singleReturnData.returnValue;</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     assert parser.returnDataList.size() &gt; 1;</span>
<span class="udiff-line-removed">-                     /* Callee has multiple returns, we need to insert a control flow merge. */</span>
<span class="udiff-line-removed">-                     returnMergeNode = graph.add(new MergeNode());</span>
<span class="udiff-line-removed">-                     calleeReturnValue = ValueMergeUtil.mergeValueProducers(returnMergeNode, parser.returnDataList, returnData -&gt; returnData.beforeReturnNode, returnData -&gt; returnData.returnValue);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+             List&lt;ReturnToCallerData&gt; calleeReturnDataList = parser.returnDataList;</span>
  
<span class="udiff-line-removed">-                 if (calleeReturnValue != null) {</span>
<span class="udiff-line-removed">-                     frameState.push(targetMethod.getSignature().getReturnKind().getStackKind(), calleeReturnValue);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 if (returnMergeNode != null) {</span>
<span class="udiff-line-removed">-                     returnMergeNode.setStateAfter(createFrameState(stream.nextBCI(), returnMergeNode));</span>
<span class="udiff-line-removed">-                     lastInstr = finishInstruction(returnMergeNode, frameState);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
              /*
               * Propagate any side effects into the caller when parsing intrinsics.
               */
              if (parser.frameState.isAfterSideEffect() &amp;&amp; parsingIntrinsic()) {
                  for (StateSplit sideEffect : parser.frameState.sideEffects()) {
                      frameState.addSideEffect(sideEffect);
                  }
              }
  
<span class="udiff-line-added">+             processCalleeReturn(targetMethod, s, calleeReturnDataList);</span>
<span class="udiff-line-added">+ </span>
              calleeBeforeUnwindNode = parser.getBeforeUnwindNode();
              if (calleeBeforeUnwindNode != null) {
                  calleeUnwindValue = parser.getUnwindValue();
                  assert calleeUnwindValue != null;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2510,10 +2635,44 @@</span>
          if (calleeBeforeUnwindNode != null) {
              calleeBeforeUnwindNode.setNext(handleException(calleeUnwindValue, bci(), false));
          }
      }
  
<span class="udiff-line-added">+     private ValueNode processCalleeReturn(ResolvedJavaMethod targetMethod, InliningScope inliningScope, List&lt;ReturnToCallerData&gt; calleeReturnDataList) {</span>
<span class="udiff-line-added">+         if (calleeReturnDataList == null) {</span>
<span class="udiff-line-added">+             /* Callee does not return. */</span>
<span class="udiff-line-added">+             lastInstr = null;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             ValueNode calleeReturnValue;</span>
<span class="udiff-line-added">+             MergeNode returnMergeNode = null;</span>
<span class="udiff-line-added">+             if (inliningScope != null) {</span>
<span class="udiff-line-added">+                 inliningScope.returnDataList = calleeReturnDataList;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (calleeReturnDataList.size() == 1) {</span>
<span class="udiff-line-added">+                 /* Callee has a single return, we can continue parsing at that point. */</span>
<span class="udiff-line-added">+                 ReturnToCallerData singleReturnData = calleeReturnDataList.get(0);</span>
<span class="udiff-line-added">+                 lastInstr = singleReturnData.beforeReturnNode;</span>
<span class="udiff-line-added">+                 calleeReturnValue = singleReturnData.returnValue;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 assert calleeReturnDataList.size() &gt; 1;</span>
<span class="udiff-line-added">+                 /* Callee has multiple returns, we need to insert a control flow merge. */</span>
<span class="udiff-line-added">+                 returnMergeNode = graph.add(new MergeNode());</span>
<span class="udiff-line-added">+                 calleeReturnValue = ValueMergeUtil.mergeValueProducers(returnMergeNode, calleeReturnDataList, returnData -&gt; returnData.beforeReturnNode, returnData -&gt; returnData.returnValue);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (calleeReturnValue != null) {</span>
<span class="udiff-line-added">+                 frameState.push(targetMethod.getSignature().getReturnKind().getStackKind(), calleeReturnValue);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (returnMergeNode != null) {</span>
<span class="udiff-line-added">+                 returnMergeNode.setStateAfter(createFrameState(stream.nextBCI(), returnMergeNode));</span>
<span class="udiff-line-added">+                 lastInstr = finishInstruction(returnMergeNode, frameState);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return calleeReturnValue;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return null;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      public MethodCallTargetNode createMethodCallTarget(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, StampPair returnStamp, JavaTypeProfile profile) {
          return new MethodCallTargetNode(invokeKind, targetMethod, args, returnStamp, profile);
      }
  
      protected InvokeNode createInvoke(int invokeBci, CallTargetNode callTarget, JavaKind resultType) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2546,11 +2705,11 @@</span>
                  StateSplit stateSplit = (StateSplit) returnVal;
                  FrameState stateAfter = stateSplit.stateAfter();
                  if (stateSplit.hasSideEffect()) {
                      assert stateSplit != null;
                      if (stateAfter.bci == BytecodeFrame.AFTER_BCI) {
<span class="udiff-line-modified-removed">-                         assert stateAfter.usages().count() == 1;</span>
<span class="udiff-line-modified-added">+                         assert stateAfter.hasExactlyOneUsage();</span>
                          assert stateAfter.usages().first() == stateSplit;
                          FrameState state;
                          if (returnVal.getStackKind() == JavaKind.Illegal) {
                              // This should only occur when Fold and NodeIntrinsic plugins are
                              // deferred. Their return value might not be a Java type and in that
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2567,11 +2726,11 @@</span>
                          GraphUtil.killWithUnusedFloatingInputs(stateAfter);
                      } else {
                          /*
                           * This must be the return value from within a partial intrinsification.
                           */
<span class="udiff-line-modified-removed">-                         assert !BytecodeFrame.isPlaceholderBci(stateAfter.bci);</span>
<span class="udiff-line-modified-added">+                         assert !BytecodeFrame.isPlaceholderBci(stateAfter.bci) || intrinsicContext.isDeferredInvoke(stateSplit);</span>
                      }
                  } else {
                      assert stateAfter == null;
                  }
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2629,10 +2788,13 @@</span>
               * receiver since the receiver cannot be EA&#39;ed.
               */
              append(new FinalFieldBarrierNode(entryBCI == INVOCATION_ENTRY_BCI ? originalReceiver : null));
          }
          synchronizedEpilogue(BytecodeFrame.AFTER_BCI, x, kind);
<span class="udiff-line-added">+         if (method.isSynchronized()) {</span>
<span class="udiff-line-added">+             finishPrepare(lastInstr, BytecodeFrame.AFTER_BCI, frameState);</span>
<span class="udiff-line-added">+         }</span>
      }
  
      protected MonitorEnterNode createMonitorEnterNode(ValueNode x, MonitorIdNode monitorId) {
          return new MonitorEnterNode(x, monitorId);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2642,20 +2804,22 @@</span>
          MonitorEnterNode monitorEnter = append(createMonitorEnterNode(x, monitorId));
          frameState.pushLock(x, monitorId);
          monitorEnter.setStateAfter(createFrameState(bci, monitorEnter));
      }
  
<span class="udiff-line-modified-removed">-     protected void genMonitorExit(ValueNode x, ValueNode escapedReturnValue, int bci) {</span>
<span class="udiff-line-modified-added">+     protected void genMonitorExit(ValueNode x, ValueNode escapedValue, int bci) {</span>
          if (frameState.lockDepth(false) == 0) {
              throw bailout(&quot;unbalanced monitors: too many exits&quot;);
          }
          MonitorIdNode monitorId = frameState.peekMonitorId();
          ValueNode lockedObject = frameState.popLock();
<span class="udiff-line-modified-removed">-         if (GraphUtil.originalValue(lockedObject) != GraphUtil.originalValue(x)) {</span>
<span class="udiff-line-modified-removed">-             throw bailout(String.format(&quot;unbalanced monitors: mismatch at monitorexit, %s != %s&quot;, GraphUtil.originalValue(x), GraphUtil.originalValue(lockedObject)));</span>
<span class="udiff-line-modified-added">+         ValueNode originalLockedObject = GraphUtil.originalValue(lockedObject, false);</span>
<span class="udiff-line-modified-added">+         ValueNode originalX = GraphUtil.originalValue(x, false);</span>
<span class="udiff-line-added">+         if (originalLockedObject != originalX) {</span>
<span class="udiff-line-added">+             throw bailout(String.format(&quot;unbalanced monitors: mismatch at monitorexit, %s != %s&quot;, originalLockedObject, originalX));</span>
          }
<span class="udiff-line-modified-removed">-         MonitorExitNode monitorExit = append(new MonitorExitNode(lockedObject, monitorId, escapedReturnValue));</span>
<span class="udiff-line-modified-added">+         MonitorExitNode monitorExit = append(new MonitorExitNode(lockedObject, monitorId, escapedValue));</span>
          monitorExit.setStateAfter(createFrameState(bci, monitorExit));
      }
  
      protected void genJsr(int dest) {
          BciBlock successor = currentBlock.getJsrSuccessor();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2677,13 +2841,14 @@</span>
          BciBlock successor = currentBlock.getRetSuccessor();
          ValueNode local = frameState.loadLocal(localIndex, JavaKind.Object);
          JsrScope scope = currentBlock.getJsrScope();
          int retAddress = scope.nextReturnAddress();
          ConstantNode returnBciNode = getJsrConstant(retAddress);
<span class="udiff-line-modified-removed">-         LogicNode guard = IntegerEqualsNode.create(constantReflection, metaAccess, options, null, local, returnBciNode, NodeView.DEFAULT);</span>
<span class="udiff-line-modified-removed">-         guard = graph.addOrUniqueWithInputs(guard);</span>
<span class="udiff-line-modified-removed">-         append(new FixedGuardNode(guard, JavaSubroutineMismatch, InvalidateReprofile));</span>
<span class="udiff-line-modified-added">+         LogicNode guard = IntegerEqualsNode.create(getConstantReflection(), getMetaAccess(), options, null, local, returnBciNode, NodeView.DEFAULT);</span>
<span class="udiff-line-modified-added">+         if (!guard.isTautology()) {</span>
<span class="udiff-line-modified-added">+             throw new JsrNotSupportedBailout(&quot;cannot statically decide jsr return address &quot; + local);</span>
<span class="udiff-line-added">+         }</span>
          if (!successor.getJsrScope().equals(scope.pop())) {
              throw new JsrNotSupportedBailout(&quot;unstructured control flow (ret leaves more than one scope)&quot;);
          }
          appendGoto(successor);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2729,11 +2894,11 @@</span>
          return probability;
      }
  
      protected ConstantNode appendConstant(JavaConstant constant) {
          assert constant != null;
<span class="udiff-line-modified-removed">-         return ConstantNode.forConstant(constant, metaAccess, graph);</span>
<span class="udiff-line-modified-added">+         return ConstantNode.forConstant(constant, getMetaAccess(), graph);</span>
      }
  
      @Override
      public &lt;T extends ValueNode&gt; T append(T v) {
          assert !graph.trackNodeSourcePosition() || graph.currentNodeSourcePosition() != null || currentBlock == blockMap.getUnwindBlock() || currentBlock instanceof ExceptionDispatchBlock;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2761,11 +2926,11 @@</span>
                  lastInstr = null;
              }
          }
      }
  
<span class="udiff-line-modified-removed">-     private Target checkLoopExit(FixedNode target, BciBlock targetBlock, FrameStateBuilder state) {</span>
<span class="udiff-line-modified-added">+     private Target checkLoopExit(Target target, BciBlock targetBlock) {</span>
          if (currentBlock != null) {
              long exits = currentBlock.loops &amp; ~targetBlock.loops;
              if (exits != 0) {
                  LoopExitNode firstLoopExit = null;
                  LoopExitNode lastLoopExit = null;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2791,11 +2956,11 @@</span>
  
                  int bci = targetBlock.startBci;
                  if (targetBlock instanceof ExceptionDispatchBlock) {
                      bci = ((ExceptionDispatchBlock) targetBlock).deoptBci;
                  }
<span class="udiff-line-modified-removed">-                 FrameStateBuilder newState = state.copy();</span>
<span class="udiff-line-modified-added">+                 FrameStateBuilder newState = target.state.copy();</span>
                  for (BciBlock loop : exitLoops) {
                      LoopBeginNode loopBegin = (LoopBeginNode) getFirstInstruction(loop);
                      LoopExitNode loopExit = graph.add(new LoopExitNode(loopBegin));
                      if (lastLoopExit != null) {
                          lastLoopExit.setNext(loopExit);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2808,15 +2973,53 @@</span>
                      newState.clearNonLiveLocals(targetBlock, liveness, true);
                      newState.insertLoopProxies(loopExit, getEntryState(loop));
                      loopExit.setStateAfter(newState.create(bci, loopExit));
                  }
  
<span class="udiff-line-modified-removed">-                 lastLoopExit.setNext(target);</span>
<span class="udiff-line-modified-removed">-                 return new Target(firstLoopExit, newState);</span>
<span class="udiff-line-modified-added">+                 // Fortify: Suppress Null Dereference false positive</span>
<span class="udiff-line-modified-added">+                 assert lastLoopExit != null;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (target.originalEntry == null) {</span>
<span class="udiff-line-added">+                     lastLoopExit.setNext(target.entry);</span>
<span class="udiff-line-added">+                     return new Target(firstLoopExit, newState, target.entry);</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     target.originalEntry.replaceAtPredecessor(firstLoopExit);</span>
<span class="udiff-line-added">+                     lastLoopExit.setNext(target.originalEntry);</span>
<span class="udiff-line-added">+                     return new Target(target.entry, newState, target.originalEntry);</span>
<span class="udiff-line-added">+                 }</span>
              }
          }
<span class="udiff-line-modified-removed">-         return new Target(target, state);</span>
<span class="udiff-line-modified-added">+         return target;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private Target checkUnwind(FixedNode target, BciBlock targetBlock, FrameStateBuilder state) {</span>
<span class="udiff-line-added">+         if (targetBlock != blockMap.getUnwindBlock()) {</span>
<span class="udiff-line-added">+             return new Target(target, state);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         FrameStateBuilder newState = state;</span>
<span class="udiff-line-added">+         newState = newState.copy();</span>
<span class="udiff-line-added">+         newState.setRethrowException(false);</span>
<span class="udiff-line-added">+         if (!method.isSynchronized()) {</span>
<span class="udiff-line-added">+             return new Target(target, newState);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         FixedWithNextNode originalLast = lastInstr;</span>
<span class="udiff-line-added">+         FrameStateBuilder originalState = frameState;</span>
<span class="udiff-line-added">+         BeginNode holder = new BeginNode();</span>
<span class="udiff-line-added">+         lastInstr = graph.add(holder);</span>
<span class="udiff-line-added">+         frameState = newState;</span>
<span class="udiff-line-added">+         assert frameState.stackSize() == 1;</span>
<span class="udiff-line-added">+         ValueNode exception = frameState.peekObject();</span>
<span class="udiff-line-added">+         synchronizedEpilogue(BytecodeFrame.AFTER_EXCEPTION_BCI, exception, JavaKind.Void);</span>
<span class="udiff-line-added">+         lastInstr.setNext(target);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         lastInstr = originalLast;</span>
<span class="udiff-line-added">+         frameState = originalState;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         FixedNode result = holder.next();</span>
<span class="udiff-line-added">+         holder.setNext(null);</span>
<span class="udiff-line-added">+         holder.safeDelete();</span>
<span class="udiff-line-added">+         return new Target(result, newState, target);</span>
      }
  
      private FrameStateBuilder getEntryState(BciBlock block) {
          return entryStateArray[block.id];
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2857,43 +3060,47 @@</span>
                  /*
                   * This is the first time we see this block as a branch target. Create and return a
                   * placeholder that later can be replaced with a MergeNode when we see this block
                   * again.
                   */
<span class="udiff-line-modified-removed">-                 FixedNode targetNode;</span>
<span class="udiff-line-modified-removed">-                 if (canReuseInstruction &amp;&amp; (block.getPredecessorCount() == 1 || !controlFlowSplit) &amp;&amp; !block.isLoopHeader() &amp;&amp; (currentBlock.loops &amp; ~block.loops) == 0) {</span>
<span class="udiff-line-modified-added">+                 if (canReuseInstruction &amp;&amp; (block.getPredecessorCount() == 1 || !controlFlowSplit) &amp;&amp; !block.isLoopHeader() &amp;&amp; (currentBlock.loops &amp; ~block.loops) == 0 &amp;&amp;</span>
<span class="udiff-line-modified-added">+                                 currentBlock.getJsrScope() == block.getJsrScope()) {</span>
<span class="udiff-line-added">+                     /*</span>
<span class="udiff-line-added">+                      * If we know that no BeginNode is necessary, then we can avoid allocating and</span>
<span class="udiff-line-added">+                      * later removing that node. This is strictly a performance optimization:</span>
<span class="udiff-line-added">+                      * unnecessary BeginNode are allowed and will be removed later on. We need to be</span>
<span class="udiff-line-added">+                      * careful though because the predecessor information is not always enough: when</span>
<span class="udiff-line-added">+                      * the loop level changes, we always need a BeginNode. Also, JSR scope changes</span>
<span class="udiff-line-added">+                      * required a BeginNode because the predecessors coming from RET bytecodes are</span>
<span class="udiff-line-added">+                      * not reflected in the predecessor count.</span>
<span class="udiff-line-added">+                      */</span>
                      setFirstInstruction(block, lastInstr);
                      lastInstr = null;
                  } else {
                      setFirstInstruction(block, graph.add(new BeginNode()));
                  }
<span class="udiff-line-modified-removed">-                 targetNode = getFirstInstruction(block);</span>
<span class="udiff-line-modified-removed">-                 Target target = checkLoopExit(targetNode, block, state);</span>
<span class="udiff-line-modified-removed">-                 FixedNode result = target.fixed;</span>
<span class="udiff-line-modified-added">+                 Target target = checkUnwind(getFirstInstruction(block), block, state);</span>
<span class="udiff-line-modified-added">+                 target = checkLoopExit(target, block);</span>
<span class="udiff-line-modified-added">+                 FixedNode result = target.entry;</span>
                  FrameStateBuilder currentEntryState = target.state == state ? (canReuseState ? state : state.copy()) : target.state;
                  setEntryState(block, currentEntryState);
                  currentEntryState.clearNonLiveLocals(block, liveness, true);
  
<span class="udiff-line-modified-removed">-                 debug.log(&quot;createTarget %s: first visit, result: %s&quot;, block, targetNode);</span>
<span class="udiff-line-modified-added">+                 debug.log(&quot;createTarget %s: first visit, result: %s&quot;, block, result);</span>
                  return result;
              }
  
<span class="udiff-line-removed">-             // We already saw this block before, so we have to merge states.</span>
<span class="udiff-line-removed">-             if (!getEntryState(block).isCompatibleWith(state)) {</span>
<span class="udiff-line-removed">-                 throw bailout(String.format(&quot;stacks do not match on merge from %d into %s; bytecodes would not verify:%nexpect: %s%nactual: %s&quot;, bci(), block, getEntryState(block), state));</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
              if (getFirstInstruction(block) instanceof LoopBeginNode) {
                  assert (block.isLoopHeader() &amp;&amp; currentBlock.getId() &gt;= block.getId()) : &quot;must be backward branch&quot;;
                  /*
                   * Backward loop edge. We need to create a special LoopEndNode and merge with the
                   * loop begin node created before.
                   */
                  LoopBeginNode loopBegin = (LoopBeginNode) getFirstInstruction(block);
                  LoopEndNode loopEnd = graph.add(new LoopEndNode(loopBegin));
<span class="udiff-line-modified-removed">-                 Target target = checkLoopExit(loopEnd, block, state);</span>
<span class="udiff-line-modified-removed">-                 FixedNode result = target.fixed;</span>
<span class="udiff-line-modified-added">+                 Target target = checkLoopExit(new Target(loopEnd, state), block);</span>
<span class="udiff-line-modified-added">+                 FixedNode result = target.entry;</span>
                  getEntryState(block).merge(loopBegin, target.state);
  
                  debug.log(&quot;createTarget %s: merging backward branch to loop header %s, result: %s&quot;, block, loopBegin, result);
                  return result;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2928,12 +3135,12 @@</span>
  
              AbstractMergeNode mergeNode = (AbstractMergeNode) getFirstInstruction(block);
  
              // The EndNode for the newly merged edge.
              EndNode newEnd = graph.add(new EndNode());
<span class="udiff-line-modified-removed">-             Target target = checkLoopExit(newEnd, block, state);</span>
<span class="udiff-line-modified-removed">-             FixedNode result = target.fixed;</span>
<span class="udiff-line-modified-added">+             Target target = checkLoopExit(checkUnwind(newEnd, block, state), block);</span>
<span class="udiff-line-modified-added">+             FixedNode result = target.entry;</span>
              getEntryState(block).merge(mergeNode, target.state);
              mergeNode.addForwardEnd(newEnd);
  
              debug.log(&quot;createTarget %s: merging state, result: %s&quot;, block, result);
              return result;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2994,17 +3201,19 @@</span>
              }
          }
      }
  
      private void handleUnwindBlock(ExceptionDispatchBlock block) {
<span class="udiff-line-added">+         if (frameState.lockDepth(false) != 0) {</span>
<span class="udiff-line-added">+             throw bailout(&quot;unbalanced monitors: too few exits exiting frame&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assert !frameState.rethrowException();</span>
<span class="udiff-line-added">+         finishPrepare(lastInstr, block.deoptBci, frameState);</span>
          if (parent == null) {
<span class="udiff-line-removed">-             finishPrepare(lastInstr, block.deoptBci, frameState);</span>
<span class="udiff-line-removed">-             frameState.setRethrowException(false);</span>
              createUnwind();
          } else {
<span class="udiff-line-modified-removed">-             ValueNode exception = frameState.pop(JavaKind.Object);</span>
<span class="udiff-line-removed">-             this.unwindValue = exception;</span>
<span class="udiff-line-modified-added">+             this.unwindValue = frameState.pop(JavaKind.Object);</span>
              this.beforeUnwindNode = this.lastInstr;
          }
      }
  
      private void setMergeStateAfter(BciBlock block, FixedWithNextNode firstInstruction) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3019,27 +3228,27 @@</span>
      }
  
      @SuppressWarnings(&quot;try&quot;)
      private void createUnwind() {
          assert frameState.stackSize() == 1 : frameState;
<span class="udiff-line-removed">-         synchronizedEpilogue(BytecodeFrame.AFTER_EXCEPTION_BCI, null, null);</span>
          try (DebugCloseable context = openNodeContext(frameState, BytecodeFrame.UNWIND_BCI)) {
              ValueNode exception = frameState.pop(JavaKind.Object);
              append(new UnwindNode(exception));
          }
      }
  
      @SuppressWarnings(&quot;try&quot;)
      private void synchronizedEpilogue(int bci, ValueNode currentReturnValue, JavaKind currentReturnValueKind) {
          try (DebugCloseable context = openNodeContext(frameState, bci)) {
              if (method.isSynchronized()) {
<span class="udiff-line-modified-removed">-                 if (currentReturnValue != null) {</span>
<span class="udiff-line-modified-added">+                 if (currentReturnValueKind != JavaKind.Void) {</span>
<span class="udiff-line-added">+                     // we are making a state that should look like the state after the return:</span>
<span class="udiff-line-added">+                     // push the return value on the stack</span>
                      frameState.push(currentReturnValueKind, currentReturnValue);
                  }
                  genMonitorExit(methodSynchronizedObject, currentReturnValue, bci);
                  assert !frameState.rethrowException();
<span class="udiff-line-removed">-                 finishPrepare(lastInstr, bci, frameState);</span>
              }
              if (frameState.lockDepth(false) != 0) {
                  throw bailout(&quot;unbalanced monitors: too few exits exiting frame&quot;);
              }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3117,11 +3326,11 @@</span>
              controlFlowSplit = true;
              LoopBeginNode loopBegin = appendLoopBegin(this.lastInstr, block.startBci);
              lastInstr = loopBegin;
  
              // Create phi functions for all local variables and operand stack slots.
<span class="udiff-line-modified-removed">-             frameState.insertLoopPhis(liveness, block.loopId, loopBegin, forceLoopPhis(), stampFromValueForForcedPhis());</span>
<span class="udiff-line-modified-added">+             frameState.insertLoopPhis(liveness, block.loopId, loopBegin, forceLoopPhis() || this.graphBuilderConfig.replaceLocalsWithConstants(), stampFromValueForForcedPhis());</span>
              loopBegin.setStateAfter(createFrameState(block.startBci, loopBegin));
  
              /*
               * We have seen all forward branches. All subsequent backward branches will merge to the
               * loop header. This ensures that the loop header has exactly one non-loop predecessor.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3332,11 +3541,10 @@</span>
  
          if (probability == -1) {
              probability = getProfileProbability(canonicalizedCondition.mustNegate());
          }
  
<span class="udiff-line-removed">-         probability = clampProbability(probability);</span>
          genIf(condition, trueSuccessor, falseSuccessor, probability);
      }
  
      protected double getProfileProbability(boolean negate) {
          if (profilingInfo == null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3354,14 +3562,14 @@</span>
  
          if (negate &amp;&amp; shouldComplementProbability()) {
              // the probability coming from profile is about the original condition
              probability = 1 - probability;
          }
<span class="udiff-line-modified-removed">-         return probability;</span>
<span class="udiff-line-modified-added">+         return clampProbability(probability);</span>
      }
  
<span class="udiff-line-modified-removed">-     private static double extractInjectedProbability(IntegerEqualsNode condition) {</span>
<span class="udiff-line-modified-added">+     private double extractInjectedProbability(IntegerEqualsNode condition) {</span>
          // Propagate injected branch probability if any.
          IntegerEqualsNode equalsNode = condition;
          BranchProbabilityNode probabilityNode = null;
          ValueNode other = null;
          if (equalsNode.getX() instanceof BranchProbabilityNode) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3371,11 +3579,11 @@</span>
              probabilityNode = (BranchProbabilityNode) equalsNode.getY();
              other = equalsNode.getX();
          }
  
          if (probabilityNode != null &amp;&amp; probabilityNode.getProbability().isConstant() &amp;&amp; other != null &amp;&amp; other.isConstant()) {
<span class="udiff-line-modified-removed">-             double probabilityValue = probabilityNode.getProbability().asJavaConstant().asDouble();</span>
<span class="udiff-line-modified-added">+             double probabilityValue = clampProbability(probabilityNode.getProbability().asJavaConstant().asDouble());</span>
              return other.asJavaConstant().asInt() == 0 ? 1.0 - probabilityValue : probabilityValue;
          }
          return -1;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3441,12 +3649,13 @@</span>
                       * We do not want to `checkLoopExit` here: otherwise the deopt will go to the
                       * deoptBlock&#39;s BCI, skipping the branch in the interpreter, and the profile
                       * will never see that the branch is taken. This can lead to deopt loops or OSR
                       * failure.
                       */
<span class="udiff-line-added">+                     double calculatedProbability = negated ? BranchProbabilityNode.DEOPT_PROBABILITY : 1.0 - BranchProbabilityNode.DEOPT_PROBABILITY;</span>
                      FixedNode deoptSuccessor = BeginNode.begin(deopt);
<span class="udiff-line-modified-removed">-                     ValueNode ifNode = genIfNode(condition, negated ? deoptSuccessor : noDeoptSuccessor, negated ? noDeoptSuccessor : deoptSuccessor, negated ? 1 - probability : probability);</span>
<span class="udiff-line-modified-added">+                     ValueNode ifNode = genIfNode(condition, negated ? deoptSuccessor : noDeoptSuccessor, negated ? noDeoptSuccessor : deoptSuccessor, calculatedProbability);</span>
                      postProcessIfNode(ifNode);
                      append(ifNode);
                  }
                  return;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3465,12 +3674,32 @@</span>
                      }
                  }
              }
  
              this.controlFlowSplit = true;
<span class="udiff-line-modified-removed">-             FixedNode trueSuccessor = createTarget(trueBlock, frameState, false, false);</span>
<span class="udiff-line-modified-removed">-             FixedNode falseSuccessor = createTarget(falseBlock, frameState, false, true);</span>
<span class="udiff-line-modified-added">+             FixedNode falseSuccessor = createTarget(falseBlock, frameState, false, false);</span>
<span class="udiff-line-modified-added">+             FixedNode trueSuccessor = createTarget(trueBlock, frameState, false, true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (this.graphBuilderConfig.replaceLocalsWithConstants() &amp;&amp; condition instanceof CompareNode) {</span>
<span class="udiff-line-added">+                 CompareNode compareNode = (CompareNode) condition;</span>
<span class="udiff-line-added">+                 if (compareNode.condition() == CanonicalCondition.EQ) {</span>
<span class="udiff-line-added">+                     ValueNode constantNode = null;</span>
<span class="udiff-line-added">+                     ValueNode nonConstantNode = null;</span>
<span class="udiff-line-added">+                     if (compareNode.getX() instanceof ConstantNode) {</span>
<span class="udiff-line-added">+                         constantNode = compareNode.getX();</span>
<span class="udiff-line-added">+                         nonConstantNode = compareNode.getY();</span>
<span class="udiff-line-added">+                     } else if (compareNode.getY() instanceof ConstantNode) {</span>
<span class="udiff-line-added">+                         constantNode = compareNode.getY();</span>
<span class="udiff-line-added">+                         nonConstantNode = compareNode.getX();</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (constantNode != null &amp;&amp; nonConstantNode != null) {</span>
<span class="udiff-line-added">+                         this.getEntryState(trueBlock).replaceValue(nonConstantNode, constantNode);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              ValueNode ifNode = genIfNode(condition, trueSuccessor, falseSuccessor, probability);
              postProcessIfNode(ifNode);
              append(ifNode);
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3600,16 +3829,21 @@</span>
          return currentBC == Bytecodes.IRETURN;
      }
  
      @Override
      public StampProvider getStampProvider() {
<span class="udiff-line-modified-removed">-         return stampProvider;</span>
<span class="udiff-line-modified-added">+         return providers.getStampProvider();</span>
      }
  
      @Override
      public MetaAccessProvider getMetaAccess() {
<span class="udiff-line-modified-removed">-         return metaAccess;</span>
<span class="udiff-line-modified-added">+         return providers.getMetaAccess();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public Replacements getReplacements() {</span>
<span class="udiff-line-added">+         return providers.getReplacements();</span>
      }
  
      @Override
      public void push(JavaKind slotKind, ValueNode value) {
          assert value.isAlive();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3621,16 +3855,16 @@</span>
          return frameState.pop(slotKind);
      }
  
      @Override
      public ConstantReflectionProvider getConstantReflection() {
<span class="udiff-line-modified-removed">-         return constantReflection;</span>
<span class="udiff-line-modified-added">+         return providers.getConstantReflection();</span>
      }
  
      @Override
      public ConstantFieldProvider getConstantFieldProvider() {
<span class="udiff-line-modified-removed">-         return constantFieldProvider;</span>
<span class="udiff-line-modified-added">+         return providers.getConstantFieldProvider();</span>
      }
  
      /**
       * Gets the graph being processed by this builder.
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3673,16 +3907,28 @@</span>
          BailoutException bailout = new PermanentBailoutException(string);
          throw GraphUtil.createBailoutException(string, bailout, elements);
      }
  
      private FrameState createFrameState(int bci, StateSplit forStateSplit) {
<span class="udiff-line-added">+         assert !(forStateSplit instanceof BytecodeExceptionNode);</span>
          if (currentBlock != null &amp;&amp; bci &gt; currentBlock.endBci) {
              frameState.clearNonLiveLocals(currentBlock, liveness, false);
          }
          return frameState.create(bci, forStateSplit);
      }
  
<span class="udiff-line-added">+     private FrameState createBytecodeExceptionFrameState(int bci, BytecodeExceptionNode bytecodeException) {</span>
<span class="udiff-line-added">+         FrameStateBuilder copy = frameState.copy();</span>
<span class="udiff-line-added">+         copy.clearStack();</span>
<span class="udiff-line-added">+         if (currentBlock != null) {</span>
<span class="udiff-line-added">+             copy.clearNonLiveLocals(currentBlock, liveness, false);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         copy.setRethrowException(true);</span>
<span class="udiff-line-added">+         copy.push(JavaKind.Object, bytecodeException);</span>
<span class="udiff-line-added">+         return copy.create(bci, bytecodeException);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @Override
      public void setStateAfter(StateSplit sideEffect) {
          assert sideEffect.hasSideEffect() || sideEffect instanceof AbstractMergeNode;
          FrameState stateAfter = createFrameState(stream.nextBCI(), sideEffect);
          sideEffect.setStateAfter(stateAfter);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3751,11 +3997,11 @@</span>
          }
      }
  
      private JavaKind refineComponentType(ValueNode array, JavaKind kind) {
          if (kind == JavaKind.Byte) {
<span class="udiff-line-modified-removed">-             JavaType type = array.stamp(NodeView.DEFAULT).javaType(metaAccess);</span>
<span class="udiff-line-modified-added">+             JavaType type = array.stamp(NodeView.DEFAULT).javaType(getMetaAccess());</span>
              if (type.isArray()) {
                  JavaType componentType = type.getComponentType();
                  if (componentType != null) {
                      JavaKind refinedKind = componentType.getJavaKind();
                      assert refinedKind == JavaKind.Byte || refinedKind == JavaKind.Boolean;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3916,16 +4162,22 @@</span>
                  throw shouldNotReachHere();
          }
          frameState.push(kind, append(v));
      }
  
<span class="udiff-line-modified-removed">-     private void genCompareOp(JavaKind kind, boolean isUnorderedLess) {</span>
<span class="udiff-line-modified-added">+     private void genFloatCompareOp(JavaKind kind, boolean isUnorderedLess) {</span>
          ValueNode y = frameState.pop(kind);
          ValueNode x = frameState.pop(kind);
          frameState.push(JavaKind.Int, append(genNormalizeCompare(x, y, isUnorderedLess)));
      }
  
<span class="udiff-line-added">+     private void genIntegerCompareOp(JavaKind kind) {</span>
<span class="udiff-line-added">+         ValueNode y = frameState.pop(kind);</span>
<span class="udiff-line-added">+         ValueNode x = frameState.pop(kind);</span>
<span class="udiff-line-added">+         frameState.push(JavaKind.Int, append(genIntegerNormalizeCompare(x, y)));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      private void genFloatConvert(FloatConvert op, JavaKind from, JavaKind to) {
          ValueNode input = frameState.pop(from);
          frameState.push(to, append(genFloatConvert(op, input)));
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3994,11 +4246,11 @@</span>
          return result;
      }
  
      private String unresolvedMethodAssertionMessage(JavaMethod result) {
          String message = result.format(&quot;%H.%n(%P)%R&quot;);
<span class="udiff-line-modified-removed">-         if (JavaVersionUtil.Java8OrEarlier) {</span>
<span class="udiff-line-modified-added">+         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
              JavaType declaringClass = result.getDeclaringClass();
              String className = declaringClass.getName();
              switch (className) {
                  case &quot;Ljava/nio/ByteBuffer;&quot;:
                  case &quot;Ljava/nio/ShortBuffer;&quot;:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4030,15 +4282,19 @@</span>
          return message;
      }
  
      private JavaMethod lookupMethod(int cpi, int opcode) {
          maybeEagerlyResolve(cpi, opcode);
<span class="udiff-line-modified-removed">-         JavaMethod result = constantPool.lookupMethod(cpi, opcode);</span>
<span class="udiff-line-modified-added">+         JavaMethod result = lookupMethodInPool(cpi, opcode);</span>
          assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaMethod : unresolvedMethodAssertionMessage(result);
          return result;
      }
  
<span class="udiff-line-added">+     protected JavaMethod lookupMethodInPool(int cpi, int opcode) {</span>
<span class="udiff-line-added">+         return constantPool.lookupMethod(cpi, opcode);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      protected JavaField lookupField(int cpi, int opcode) {
          maybeEagerlyResolve(cpi, opcode);
          JavaField result = constantPool.lookupField(cpi, method, opcode);
          return lookupField(result);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4085,10 +4341,17 @@</span>
                  }
              }
          }
      }
  
<span class="udiff-line-added">+     protected JavaType maybeEagerlyResolve(JavaType type, ResolvedJavaType accessingClass) {</span>
<span class="udiff-line-added">+         if (graphBuilderConfig.eagerResolving() || parsingIntrinsic()) {</span>
<span class="udiff-line-added">+             return type.resolve(accessingClass);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return type;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      protected void maybeEagerlyInitialize(ResolvedJavaType resolvedType) {
          if (!resolvedType.isInitialized() &amp;&amp; eagerInitializing) {
              initialize(resolvedType);
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4176,10 +4439,11 @@</span>
          } else {
              handleUnresolvedInstanceOf(type, object);
          }
      }
  
<span class="udiff-line-added">+     @SuppressWarnings(&quot;try&quot;)</span>
      protected void genInstanceOf(ResolvedJavaType resolvedType, ValueNode objectIn) {
          ValueNode object = objectIn;
          TypeReference checkedType = TypeReference.createTrusted(graph.getAssumptions(), resolvedType);
          JavaTypeProfile profile = getProfileForTypeCheck(checkedType);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4210,22 +4474,24 @@</span>
  
          int next = getStream().nextBCI();
          int value = getStream().readUByte(next);
          if (next &lt;= currentBlock.endBci &amp;&amp; (value == Bytecodes.IFEQ || value == Bytecodes.IFNE)) {
              getStream().next();
<span class="udiff-line-modified-removed">-             BciBlock firstSucc = currentBlock.getSuccessor(0);</span>
<span class="udiff-line-modified-removed">-             BciBlock secondSucc = currentBlock.getSuccessor(1);</span>
<span class="udiff-line-modified-removed">-             if (firstSucc != secondSucc) {</span>
<span class="udiff-line-modified-removed">-                 boolean negate = value != Bytecodes.IFNE;</span>
<span class="udiff-line-modified-removed">-                 if (negate) {</span>
<span class="udiff-line-modified-removed">-                     BciBlock tmp = firstSucc;</span>
<span class="udiff-line-modified-removed">-                     firstSucc = secondSucc;</span>
<span class="udiff-line-modified-removed">-                     secondSucc = tmp;</span>
<span class="udiff-line-modified-added">+             try (DebugCloseable context = openNodeContext()) {</span>
<span class="udiff-line-modified-added">+                 BciBlock firstSucc = currentBlock.getSuccessor(0);</span>
<span class="udiff-line-modified-added">+                 BciBlock secondSucc = currentBlock.getSuccessor(1);</span>
<span class="udiff-line-modified-added">+                 if (firstSucc != secondSucc) {</span>
<span class="udiff-line-modified-added">+                     boolean negate = value != Bytecodes.IFNE;</span>
<span class="udiff-line-modified-added">+                     if (negate) {</span>
<span class="udiff-line-modified-added">+                         BciBlock tmp = firstSucc;</span>
<span class="udiff-line-modified-added">+                         firstSucc = secondSucc;</span>
<span class="udiff-line-added">+                         secondSucc = tmp;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     genIf(instanceOfNode, firstSucc, secondSucc, getProfileProbability(negate));</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     appendGoto(firstSucc);</span>
                  }
<span class="udiff-line-removed">-                 genIf(instanceOfNode, firstSucc, secondSucc, getProfileProbability(negate));</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 appendGoto(firstSucc);</span>
              }
          } else {
              // Most frequent for value is IRETURN, followed by ISTORE.
              frameState.push(JavaKind.Int, append(genConditional(logicNode)));
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4306,11 +4572,11 @@</span>
                  throw new IllegalArgumentException(&quot;unknown array type code: &quot; + code);
          }
      }
  
      private void genNewPrimitiveArray(int typeCode) {
<span class="udiff-line-modified-removed">-         ResolvedJavaType elementType = metaAccess.lookupJavaType(arrayTypeCodeToClass(typeCode));</span>
<span class="udiff-line-modified-added">+         ResolvedJavaType elementType = getMetaAccess().lookupJavaType(arrayTypeCodeToClass(typeCode));</span>
          ValueNode length = frameState.pop(JavaKind.Int);
  
          for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
              if (plugin.handleNewArray(this, elementType, length)) {
                  return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4490,12 +4756,12 @@</span>
          return false;
      }
  
      @Override
      public AbstractBeginNode genExplicitExceptionEdge(BytecodeExceptionKind exceptionKind) {
<span class="udiff-line-modified-removed">-         BytecodeExceptionNode exceptionNode = graph.add(new BytecodeExceptionNode(metaAccess, exceptionKind));</span>
<span class="udiff-line-modified-removed">-         exceptionNode.setStateAfter(createFrameState(bci(), exceptionNode));</span>
<span class="udiff-line-modified-added">+         BytecodeExceptionNode exceptionNode = graph.add(new BytecodeExceptionNode(getMetaAccess(), exceptionKind));</span>
<span class="udiff-line-modified-added">+         exceptionNode.setStateAfter(createBytecodeExceptionFrameState(bci(), exceptionNode));</span>
          AbstractBeginNode exceptionDispatch = handleException(exceptionNode, bci(), false);
          exceptionNode.setNext(exceptionDispatch);
          return BeginNode.begin(exceptionNode);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4553,11 +4819,11 @@</span>
           * Javac does not allow use of &quot;$assertionsDisabled&quot; for a field name but Eclipse does, in
           * which case a suffix is added to the generated field.
           */
          if (resolvedField.isSynthetic() &amp;&amp; resolvedField.getName().startsWith(&quot;$assertionsDisabled&quot;)) {
              if (parsingIntrinsic()) {
<span class="udiff-line-modified-removed">-                 throw new GraalError(&quot;Cannot use an assertion within the context of an intrinsic.&quot;);</span>
<span class="udiff-line-modified-added">+                 throw new GraalError(&quot;Cannot use an assertion within the context of an intrinsic: &quot; + resolvedField);</span>
              } else if (graphBuilderConfig.omitAssertions()) {
                  frameState.push(field.getJavaKind(), ConstantNode.forBoolean(true, graph));
                  return;
              }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4697,10 +4963,13 @@</span>
              this.blockIndex = blockSuccessorIndex;
              actualIndex = -1;
          }
      }
  
<span class="udiff-line-added">+     private static final int SWITCH_DEOPT_UNSEEN = -2;</span>
<span class="udiff-line-added">+     private static final int SWITCH_DEOPT_SEEN = -1;</span>
<span class="udiff-line-added">+ </span>
      private void genSwitch(BytecodeSwitch bs) {
          int bci = bci();
          ValueNode value = frameState.pop(JavaKind.Int);
  
          int nofCases = bs.numberOfCases();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4714,24 +4983,20 @@</span>
          }
  
          ArrayList&lt;BciBlock&gt; actualSuccessors = new ArrayList&lt;&gt;();
          int[] keys = new int[nofCases];
          int[] keySuccessors = new int[nofCasesPlusDefault];
<span class="udiff-line-modified-removed">-         int deoptSuccessorIndex = -1;</span>
<span class="udiff-line-modified-added">+         int deoptSuccessorIndex = SWITCH_DEOPT_UNSEEN;</span>
          int nextSuccessorIndex = 0;
          boolean constantValue = value.isConstant();
          for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
              if (i &lt; nofCases) {
                  keys[i] = bs.keyAt(i);
              }
<span class="udiff-line-removed">- </span>
              if (!constantValue &amp;&amp; isNeverExecutedCode(keyProbabilities[i])) {
<span class="udiff-line-modified-removed">-                 if (deoptSuccessorIndex &lt; 0) {</span>
<span class="udiff-line-modified-removed">-                     deoptSuccessorIndex = nextSuccessorIndex++;</span>
<span class="udiff-line-removed">-                     actualSuccessors.add(null);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 keySuccessors[i] = deoptSuccessorIndex;</span>
<span class="udiff-line-modified-added">+                 deoptSuccessorIndex = SWITCH_DEOPT_SEEN;</span>
<span class="udiff-line-modified-added">+                 keySuccessors[i] = SWITCH_DEOPT_SEEN;</span>
              } else {
                  int targetBci = i &lt; nofCases ? bs.targetAt(i) : bs.defaultTarget();
                  SuccessorInfo info = bciToBlockSuccessorIndex.get(targetBci);
                  if (info.actualIndex &lt; 0) {
                      info.actualIndex = nextSuccessorIndex++;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4762,24 +5027,35 @@</span>
           * reaches a target, we have better chance cutting out unused branches. Otherwise,
           * it might be beneficial routing to the same code instead of deopting.
           *
           * The following code rewires deoptimization stub to existing resolved branch target if
           * the target is connected by more than 1 cases.
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * If this operation rewires every deoptimization seen to an existing branch, care is</span>
<span class="udiff-line-added">+          * taken that we do not spawn a branch that will never be taken.</span>
           */
<span class="udiff-line-modified-removed">-         if (deoptSuccessorIndex &gt;= 0) {</span>
<span class="udiff-line-modified-removed">-             int[] connectedCases = new int[nextSuccessorIndex];</span>
<span class="udiff-line-modified-added">+         if (deoptSuccessorIndex == SWITCH_DEOPT_SEEN) {</span>
<span class="udiff-line-modified-added">+             int[] connectedCases = new int[nextSuccessorIndex + 1];</span>
              for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
<span class="udiff-line-modified-removed">-                 connectedCases[keySuccessors[i]]++;</span>
<span class="udiff-line-modified-added">+                 connectedCases[keySuccessors[i] + 1]++;</span>
              }
  
              for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
<span class="udiff-line-modified-removed">-                 if (keySuccessors[i] == deoptSuccessorIndex) {</span>
<span class="udiff-line-modified-added">+                 if (keySuccessors[i] == SWITCH_DEOPT_SEEN) {</span>
                      int targetBci = i &lt; nofCases ? bs.targetAt(i) : bs.defaultTarget();
                      SuccessorInfo info = bciToBlockSuccessorIndex.get(targetBci);
                      int rewiredIndex = info.actualIndex;
<span class="udiff-line-modified-removed">-                     if (rewiredIndex &gt;= 0 &amp;&amp; connectedCases[rewiredIndex] &gt; 1) {</span>
<span class="udiff-line-modified-added">+                     if (rewiredIndex &gt;= 0 &amp;&amp; connectedCases[rewiredIndex + 1] &gt; 1) {</span>
<span class="udiff-line-added">+                         // Rewire</span>
                          keySuccessors[i] = info.actualIndex;
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         if (deoptSuccessorIndex == SWITCH_DEOPT_SEEN) {</span>
<span class="udiff-line-added">+                             // Spawn deopt successor if needed.</span>
<span class="udiff-line-added">+                             deoptSuccessorIndex = nextSuccessorIndex++;</span>
<span class="udiff-line-added">+                             actualSuccessors.add(null);</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         keySuccessors[i] = deoptSuccessorIndex;</span>
                      }
                  }
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4979,15 +5255,15 @@</span>
              case L2I            : genNarrow(JavaKind.Long, JavaKind.Int); break;
              case I2L            : genSignExtend(JavaKind.Int, JavaKind.Long); break;
              case I2B            : genSignExtend(JavaKind.Byte, JavaKind.Int); break;
              case I2S            : genSignExtend(JavaKind.Short, JavaKind.Int); break;
              case I2C            : genZeroExtend(JavaKind.Char, JavaKind.Int); break;
<span class="udiff-line-modified-removed">-             case LCMP           : genCompareOp(JavaKind.Long, false); break;</span>
<span class="udiff-line-modified-removed">-             case FCMPL          : genCompareOp(JavaKind.Float, true); break;</span>
<span class="udiff-line-modified-removed">-             case FCMPG          : genCompareOp(JavaKind.Float, false); break;</span>
<span class="udiff-line-modified-removed">-             case DCMPL          : genCompareOp(JavaKind.Double, true); break;</span>
<span class="udiff-line-modified-removed">-             case DCMPG          : genCompareOp(JavaKind.Double, false); break;</span>
<span class="udiff-line-modified-added">+             case LCMP           : genIntegerCompareOp(JavaKind.Long); break;</span>
<span class="udiff-line-modified-added">+             case FCMPL          : genFloatCompareOp(JavaKind.Float, true); break;</span>
<span class="udiff-line-modified-added">+             case FCMPG          : genFloatCompareOp(JavaKind.Float, false); break;</span>
<span class="udiff-line-modified-added">+             case DCMPL          : genFloatCompareOp(JavaKind.Double, true); break;</span>
<span class="udiff-line-modified-added">+             case DCMPG          : genFloatCompareOp(JavaKind.Double, false); break;</span>
              case IFEQ           : genIfZero(Condition.EQ); break;
              case IFNE           : genIfZero(Condition.NE); break;
              case IFLT           : genIfZero(Condition.LT); break;
              case IFGE           : genIfZero(Condition.GE); break;
              case IFGT           : genIfZero(Condition.GT); break;
</pre>
<center><a href="BciBlockMapping.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeParserOptions.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
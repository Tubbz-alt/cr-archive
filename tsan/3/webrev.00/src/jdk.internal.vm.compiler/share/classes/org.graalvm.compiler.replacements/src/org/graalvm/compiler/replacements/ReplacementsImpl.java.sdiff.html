<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/ReplacementsImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PEGraphDecoder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SnippetCounter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/ReplacementsImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements;
 26 
 27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
 28 import static org.graalvm.compiler.core.common.GraalOptions.UseSnippetGraphCache;
 29 import static org.graalvm.compiler.debug.DebugContext.DEFAULT_LOG_STREAM;

 30 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
 31 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineIntrinsicsDuringParsing;
 32 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;

 33 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;
 34 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION;
 35 import static org.graalvm.compiler.phases.common.DeadCodeEliminationPhase.Optionality.Required;
 36 
 37 import java.util.Collections;
 38 import java.util.List;
 39 import java.util.concurrent.ConcurrentHashMap;
 40 import java.util.concurrent.ConcurrentMap;
 41 import java.util.concurrent.atomic.AtomicInteger;
 42 
 43 import jdk.internal.vm.compiler.collections.EconomicMap;
 44 import jdk.internal.vm.compiler.collections.Equivalence;
 45 import org.graalvm.compiler.api.replacements.Fold;
 46 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 47 import org.graalvm.compiler.api.replacements.Snippet;
 48 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 49 import org.graalvm.compiler.api.replacements.SnippetTemplateCache;
 50 import org.graalvm.compiler.bytecode.Bytecode;
 51 import org.graalvm.compiler.bytecode.BytecodeProvider;
 52 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
 53 import org.graalvm.compiler.core.common.CompilationIdentifier;
 54 import org.graalvm.compiler.core.common.GraalOptions;
<span class="line-removed"> 55 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;</span>
 56 import org.graalvm.compiler.debug.DebugCloseable;
 57 import org.graalvm.compiler.debug.DebugContext;
 58 import org.graalvm.compiler.debug.DebugContext.Description;
 59 import org.graalvm.compiler.debug.DebugHandlersFactory;
 60 import org.graalvm.compiler.debug.GraalError;
 61 import org.graalvm.compiler.debug.TimerKey;
 62 import org.graalvm.compiler.graph.Node;
 63 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 64 import org.graalvm.compiler.graph.NodeSourcePosition;
 65 import org.graalvm.compiler.java.GraphBuilderPhase;
 66 import org.graalvm.compiler.java.GraphBuilderPhase.Instance;

 67 import org.graalvm.compiler.nodes.CallTargetNode;

 68 import org.graalvm.compiler.nodes.Invoke;
 69 import org.graalvm.compiler.nodes.StateSplit;
 70 import org.graalvm.compiler.nodes.StructuredGraph;
 71 import org.graalvm.compiler.nodes.ValueNode;
 72 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedInvocationPlugin;
 73 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 74 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 75 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 76 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderPlugin;
 77 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 78 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 79 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 80 import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
 81 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 82 import org.graalvm.compiler.nodes.spi.Replacements;
<span class="line-removed"> 83 import org.graalvm.compiler.nodes.spi.StampProvider;</span>
<span class="line-removed"> 84 import org.graalvm.compiler.options.Option;</span>
<span class="line-removed"> 85 import org.graalvm.compiler.options.OptionKey;</span>
<span class="line-removed"> 86 import org.graalvm.compiler.options.OptionType;</span>
 87 import org.graalvm.compiler.options.OptionValues;
 88 import org.graalvm.compiler.phases.OptimisticOptimizations;
 89 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
<span class="line-removed"> 90 import org.graalvm.compiler.loop.phases.ConvertDeoptimizeToGuardPhase;</span>
 91 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
<span class="line-removed"> 92 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 93 import org.graalvm.compiler.phases.util.Providers;
 94 import org.graalvm.compiler.word.Word;
 95 import org.graalvm.compiler.word.WordOperationPlugin;
 96 
 97 import jdk.vm.ci.code.TargetDescription;
<span class="line-removed"> 98 import jdk.vm.ci.meta.ConstantReflectionProvider;</span>
 99 import jdk.vm.ci.meta.MetaAccessProvider;
100 import jdk.vm.ci.meta.ResolvedJavaMethod;
101 import jdk.vm.ci.meta.ResolvedJavaType;
102 
103 public class ReplacementsImpl implements Replacements, InlineInvokePlugin {
104 
<span class="line-modified">105     public static class Options {</span>
<span class="line-removed">106         // @formatter:off</span>
<span class="line-removed">107         @Option(help = &quot;This is a testing option to exercise the SymbolicSnippetEncoder&quot;, type = OptionType.Expert)</span>
<span class="line-removed">108         public static final OptionKey&lt;Boolean&gt; UseEncodedSnippets = new OptionKey&lt;&gt;(false);</span>
<span class="line-removed">109         // @formatter:on</span>
<span class="line-removed">110     }</span>
<span class="line-removed">111 </span>
<span class="line-removed">112     protected final OptionValues options;</span>
<span class="line-removed">113 </span>
114     public Providers getProviders() {
115         return providers;
116     }
117 
118     public void setProviders(Providers providers) {
119         this.providers = providers.copyWith(this);
120     }
121 
122     protected Providers providers;
123     public final SnippetReflectionProvider snippetReflection;
124     public final TargetDescription target;
125     private GraphBuilderConfiguration.Plugins graphBuilderPlugins;
126     private final DebugHandlersFactory debugHandlersFactory;
127 
<span class="line-removed">128     @Override</span>
<span class="line-removed">129     public OptionValues getOptions() {</span>
<span class="line-removed">130         return options;</span>
<span class="line-removed">131     }</span>
<span class="line-removed">132 </span>
133     /**
134      * The preprocessed replacement graphs.
135      */
136     protected final ConcurrentMap&lt;ResolvedJavaMethod, StructuredGraph&gt; graphs;
137 
138     /**
139      * The default {@link BytecodeProvider} to use for accessing the bytecode of a replacement if
140      * the replacement doesn&#39;t provide another {@link BytecodeProvider}.
141      */
142     protected final BytecodeProvider defaultBytecodeProvider;
143 
144     public void setGraphBuilderPlugins(GraphBuilderConfiguration.Plugins plugins) {
145         assert this.graphBuilderPlugins == null;
146         this.graphBuilderPlugins = plugins;
147     }
148 
149     @Override
150     public GraphBuilderConfiguration.Plugins getGraphBuilderPlugins() {
151         return graphBuilderPlugins;
152     }
</pre>
<hr />
<pre>
156         if (method.getAnnotation(Node.NodeIntrinsic.class) != null || method.getAnnotation(Fold.class) != null) {
157             return GeneratedInvocationPlugin.class;
158         }
159         if (method.getAnnotation(Word.Operation.class) != null) {
160             return WordOperationPlugin.class;
161         }
162         return null;
163     }
164 
165     private static final int MAX_GRAPH_INLINING_DEPTH = 100; // more than enough
166 
167     /**
168      * Determines whether a given method should be inlined based on whether it has a substitution or
169      * whether the inlining context is already within a substitution.
170      *
171      * @return an object specifying how {@code method} is to be inlined or null if it should not be
172      *         inlined based on substitution related criteria
173      */
174     @Override
175     public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
<span class="line-modified">176         Bytecode subst = getSubstitutionBytecode(method);</span>
<span class="line-modified">177         if (subst != null) {</span>
178             if (b.parsingIntrinsic() || InlineDuringParsing.getValue(b.getOptions()) || InlineIntrinsicsDuringParsing.getValue(b.getOptions())) {
179                 // Forced inlining of intrinsics
<span class="line-modified">180                 return createIntrinsicInlineInfo(subst.getMethod(), method, subst.getOrigin());</span>
181             }
182             return null;
183         }
184         if (b.parsingIntrinsic()) {
185             assert b.getDepth() &lt; MAX_GRAPH_INLINING_DEPTH : &quot;inlining limit exceeded&quot;;
186 
187             // Force inlining when parsing replacements
<span class="line-modified">188             return createIntrinsicInlineInfo(method, null, defaultBytecodeProvider);</span>
189         } else {
190             assert IS_BUILDING_NATIVE_IMAGE || method.getAnnotation(NodeIntrinsic.class) == null : String.format(&quot;@%s method %s must only be called from within a replacement%n%s&quot;,
191                             NodeIntrinsic.class.getSimpleName(),
192                             method.format(&quot;%h.%n&quot;), b);
193         }
194         return null;
195     }
196 
197     @Override
198     public void notifyNotInlined(GraphBuilderContext b, ResolvedJavaMethod method, Invoke invoke) {
199         if (b.parsingIntrinsic()) {
200             IntrinsicContext intrinsic = b.getIntrinsic();
201             if (!intrinsic.isCallToOriginal(method)) {
202                 Class&lt;? extends GraphBuilderPlugin&gt; pluginClass = getIntrinsifyingPlugin(method);
203                 if (pluginClass != null) {
204                     String methodDesc = method.format(&quot;%H.%n(%p)&quot;);
205                     throw new GraalError(&quot;Call to %s should have been intrinsified by a %s. &quot; +
206                                     &quot;This is typically caused by Eclipse failing to run an annotation &quot; +
207                                     &quot;processor. This can usually be fixed by forcing Eclipse to rebuild &quot; +
208                                     &quot;the source file in which %s is declared&quot;,
209                                     methodDesc, pluginClass.getSimpleName(), methodDesc);
210                 }
211                 throw new GraalError(&quot;All non-recursive calls in the intrinsic %s must be inlined or intrinsified: found call to %s&quot;,
212                                 intrinsic.getIntrinsicMethod().format(&quot;%H.%n(%p)&quot;), method.format(&quot;%h.%n(%p)&quot;));
213             }
214         }
215     }
216 
217     // This map is key&#39;ed by a class name instead of a Class object so that
218     // it is stable across VM executions (in support of replay compilation).
219     private final EconomicMap&lt;String, SnippetTemplateCache&gt; snippetTemplateCache;
220 
<span class="line-modified">221     public ReplacementsImpl(OptionValues options, DebugHandlersFactory debugHandlersFactory, Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider,</span>
222                     TargetDescription target) {
<span class="line-removed">223         this.options = options;</span>
224         this.providers = providers.copyWith(this);
225         this.snippetReflection = snippetReflection;
226         this.target = target;
227         this.graphs = new ConcurrentHashMap&lt;&gt;();
228         this.snippetTemplateCache = EconomicMap.create(Equivalence.DEFAULT);
229         this.defaultBytecodeProvider = bytecodeProvider;
230         this.debugHandlersFactory = debugHandlersFactory;
231 
232     }
233 
234     private static final TimerKey SnippetPreparationTime = DebugContext.timer(&quot;SnippetPreparationTime&quot;);
235 
236     private static final AtomicInteger nextDebugContextId = new AtomicInteger();
237 
<span class="line-modified">238     public DebugContext openDebugContext(String idPrefix, ResolvedJavaMethod method) {</span>
<span class="line-modified">239         DebugContext outer = DebugContext.forCurrentThread();</span>
<span class="line-modified">240         Description description = new Description(method, idPrefix + nextDebugContextId.incrementAndGet());</span>
<span class="line-modified">241         List&lt;DebugHandlersFactory&gt; factories = debugHandlersFactory == null ? Collections.emptyList() : Collections.singletonList(debugHandlersFactory);</span>
<span class="line-modified">242         return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, factories);</span>



243     }
244 
245     @Override
246     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">247     public StructuredGraph getSnippet(ResolvedJavaMethod method, ResolvedJavaMethod recursiveEntry, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>

248         assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
249         assert method.hasBytecodes() : &quot;Snippet must not be abstract or native&quot;;
250 
251         StructuredGraph graph = UseSnippetGraphCache.getValue(options) ? graphs.get(method) : null;
252         if (graph == null || (trackNodeSourcePosition &amp;&amp; !graph.trackNodeSourcePosition())) {
<span class="line-modified">253             try (DebugContext debug = openDebugContext(&quot;Snippet_&quot;, method);</span>
254                             DebugCloseable a = SnippetPreparationTime.start(debug)) {
<span class="line-modified">255                 StructuredGraph newGraph = makeGraph(debug, defaultBytecodeProvider, method, args, recursiveEntry, trackNodeSourcePosition, replaceePosition);</span>
256                 DebugContext.counter(&quot;SnippetNodeCount[%#s]&quot;, method).add(newGraph.getDebug(), newGraph.getNodeCount());
257                 if (!UseSnippetGraphCache.getValue(options) || args != null) {
258                     return newGraph;
259                 }
260                 newGraph.freeze();
261                 if (graph != null) {
262                     graphs.replace(method, graph, newGraph);
263                 } else {
264                     graphs.putIfAbsent(method, newGraph);
265                 }
266                 graph = graphs.get(method);
267             }
268         }
269         assert !trackNodeSourcePosition || graph.trackNodeSourcePosition();
270         return graph;
271     }
272 
273     @Override
<span class="line-modified">274     public void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition) {</span>
275         // No initialization needed as snippet graphs are created on demand in getSnippet
276     }
277 
















278     @Override
279     public boolean hasSubstitution(ResolvedJavaMethod method, int invokeBci) {
280         InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
281         return plugin != null &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0);
282     }
283 
284     @Override
285     public BytecodeProvider getDefaultReplacementBytecodeProvider() {
286         return defaultBytecodeProvider;
287     }
288 
<span class="line-modified">289     @Override</span>
<span class="line-removed">290     public Bytecode getSubstitutionBytecode(ResolvedJavaMethod method) {</span>
291         InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
292         if (plugin instanceof MethodSubstitutionPlugin) {
293             MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;
<span class="line-modified">294             ResolvedJavaMethod substitute = msPlugin.getSubstitute(providers.getMetaAccess());</span>
<span class="line-removed">295             return msPlugin.getBytecodeProvider().getBytecode(substitute);</span>
296         }
297         return null;
298     }
299 
300     @Override
<span class="line-modified">301     public StructuredGraph getSubstitution(ResolvedJavaMethod method, int invokeBci, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>
302         StructuredGraph result;
303         InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
304         if (plugin != null &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0)) {
305             MetaAccessProvider metaAccess = providers.getMetaAccess();
306             if (plugin instanceof MethodSubstitutionPlugin) {
307                 MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;
308                 ResolvedJavaMethod substitute = msPlugin.getSubstitute(metaAccess);
309                 StructuredGraph graph = UseSnippetGraphCache.getValue(options) ? graphs.get(substitute) : null;
310                 if (graph == null || graph.trackNodeSourcePosition() != trackNodeSourcePosition) {
<span class="line-modified">311                     try (DebugContext debug = openDebugContext(&quot;Substitution_&quot;, method)) {</span>
<span class="line-modified">312                         graph = makeGraph(debug, msPlugin.getBytecodeProvider(), substitute, null, method, trackNodeSourcePosition, replaceePosition);</span>
313                         if (!UseSnippetGraphCache.getValue(options)) {
314                             return graph;
315                         }
316                         graph.freeze();
317                         graphs.putIfAbsent(substitute, graph);
318                         graph = graphs.get(substitute);
319                     }
320                 }
321                 assert graph.isFrozen();
322                 result = graph;
323             } else {
324                 Bytecode code = new ResolvedJavaMethodBytecode(method);
<span class="line-modified">325                 ConstantReflectionProvider constantReflection = providers.getConstantReflection();</span>
<span class="line-modified">326                 ConstantFieldProvider constantFieldProvider = providers.getConstantFieldProvider();</span>
<span class="line-removed">327                 StampProvider stampProvider = providers.getStampProvider();</span>
<span class="line-removed">328                 try (DebugContext debug = openDebugContext(&quot;Substitution_&quot;, method)) {</span>
<span class="line-removed">329                     result = new IntrinsicGraphBuilder(options, debug, metaAccess, constantReflection, constantFieldProvider, stampProvider, code, invokeBci).buildGraph(plugin);</span>
330                 }
331             }
332         } else {
333             result = null;
334         }
335         return result;
336     }
337 
338     @SuppressWarnings(&quot;try&quot;)
339     @Override
<span class="line-modified">340     public StructuredGraph getIntrinsicGraph(ResolvedJavaMethod method, CompilationIdentifier compilationId, DebugContext debug) {</span>
<span class="line-modified">341         Bytecode subst = getSubstitutionBytecode(method);</span>
<span class="line-modified">342         if (subst != null) {</span>
<span class="line-modified">343             ResolvedJavaMethod substMethod = subst.getMethod();</span>
344             assert !substMethod.equals(method);
<span class="line-modified">345             BytecodeProvider bytecodeProvider = subst.getOrigin();</span>
346             // @formatter:off
<span class="line-modified">347             StructuredGraph graph = new StructuredGraph.Builder(options, debug, StructuredGraph.AllowAssumptions.YES).</span>
348                     method(substMethod).
349                     compilationId(compilationId).
350                     recordInlinedMethods(bytecodeProvider.shouldRecordMethodDependencies()).
351                     setIsSubstitution(true).
352                     build();
353             // @formatter:on
354             try (DebugContext.Scope scope = debug.scope(&quot;GetIntrinsicGraph&quot;, graph)) {
355                 Plugins plugins = new Plugins(getGraphBuilderPlugins());
356                 GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);
357                 IntrinsicContext initialReplacementContext = new IntrinsicContext(method, substMethod, bytecodeProvider, ROOT_COMPILATION);
<span class="line-modified">358                 new GraphBuilderPhase.Instance(providers.getMetaAccess(), providers.getStampProvider(), providers.getConstantReflection(), providers.getConstantFieldProvider(), config,</span>
<span class="line-removed">359                                 OptimisticOptimizations.NONE, initialReplacementContext).apply(graph);</span>
360                 assert !graph.isFrozen();
361                 return graph;
362             } catch (Throwable e) {
363                 debug.handle(e);
364             }
365         }
366         return null;
367     }
368 
369     /**
370      * Creates a preprocessed graph for a snippet or method substitution.
371      *
372      * @param bytecodeProvider how to access the bytecode of {@code method}
373      * @param method the snippet or method substitution for which a graph will be created
374      * @param args
375      * @param original the original method if {@code method} is a {@linkplain MethodSubstitution
376      *            substitution} otherwise null
<span class="line-modified">377      * @param trackNodeSourcePosition</span>



378      */
379     public StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, ResolvedJavaMethod method, Object[] args, ResolvedJavaMethod original, boolean trackNodeSourcePosition,
<span class="line-modified">380                     NodeSourcePosition replaceePosition) {</span>
<span class="line-modified">381         return createGraphMaker(method, original).makeGraph(debug, bytecodeProvider, args, trackNodeSourcePosition, replaceePosition);</span>


















382     }
383 
384     /**
385      * Can be overridden to return an object that specializes various parts of graph preprocessing.
386      */
387     protected GraphMaker createGraphMaker(ResolvedJavaMethod substitute, ResolvedJavaMethod original) {
388         return new GraphMaker(this, substitute, original);
389     }
390 
391     /**
392      * Creates and preprocesses a graph for a replacement.
393      */
394     public static class GraphMaker {
395 
396         /** The replacements object that the graphs are created for. */
397         protected final ReplacementsImpl replacements;
398 
399         /**
400          * The method for which a graph is being created.
401          */
402         protected final ResolvedJavaMethod method;
403 
404         /**
405          * The original method which {@link #method} is substituting. Calls to {@link #method} or
406          * {@link #substitutedMethod} will be replaced with a forced inline of
407          * {@link #substitutedMethod}.
408          */
409         protected final ResolvedJavaMethod substitutedMethod;
410 
411         public GraphMaker(ReplacementsImpl replacements, ResolvedJavaMethod substitute, ResolvedJavaMethod substitutedMethod) {
412             this.replacements = replacements;
413             this.method = substitute;
414             this.substitutedMethod = substitutedMethod;
415         }
416 
417         @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">418         public StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>

419             try (DebugContext.Scope s = debug.scope(&quot;BuildSnippetGraph&quot;, method)) {
420                 assert method.hasBytecodes() : method;
<span class="line-modified">421                 StructuredGraph graph = buildInitialGraph(debug, bytecodeProvider, method, args, trackNodeSourcePosition, replaceePosition);</span>
422 
423                 finalizeGraph(graph);
424 
425                 debug.dump(DebugContext.INFO_LEVEL, graph, &quot;%s: Final&quot;, method.getName());
426 
427                 return graph;
428             } catch (Throwable e) {
429                 throw debug.handle(e);
430             }
431         }
432 
433         /**
434          * Does final processing of a snippet graph.
435          */
436         protected void finalizeGraph(StructuredGraph graph) {
<span class="line-modified">437             if (!GraalOptions.SnippetCounters.getValue(replacements.options) || graph.getNodes().filter(SnippetCounterNode.class).isEmpty()) {</span>
438                 int sideEffectCount = 0;
439                 assert (sideEffectCount = graph.getNodes().filter(e -&gt; hasSideEffect(e)).count()) &gt;= 0;
440                 new ConvertDeoptimizeToGuardPhase().apply(graph, null);
441                 assert sideEffectCount == graph.getNodes().filter(e -&gt; hasSideEffect(e)).count() : &quot;deleted side effecting node&quot;;
442 
443                 new DeadCodeEliminationPhase(Required).apply(graph);
444             } else {
445                 // ConvertDeoptimizeToGuardPhase will eliminate snippet counters on paths
446                 // that terminate in a deopt so we disable it if the graph contains
447                 // snippet counters. The trade off is that we miss out on guard
448                 // coalescing opportunities.
449             }
450         }
451 
452         /**
453          * Filter nodes which have side effects and shouldn&#39;t be deleted from snippets when
454          * converting deoptimizations to guards. Currently this only allows exception constructors
455          * to be eliminated to cover the case when Java assertions are in the inlined code.
456          *
457          * @param node
</pre>
<hr />
<pre>
461             if (node instanceof StateSplit) {
462                 if (((StateSplit) node).hasSideEffect()) {
463                     if (node instanceof Invoke) {
464                         CallTargetNode callTarget = ((Invoke) node).callTarget();
465                         if (callTarget instanceof MethodCallTargetNode) {
466                             ResolvedJavaMethod targetMethod = ((MethodCallTargetNode) callTarget).targetMethod();
467                             if (targetMethod.isConstructor()) {
468                                 ResolvedJavaType throwableType = replacements.providers.getMetaAccess().lookupJavaType(Throwable.class);
469                                 return !throwableType.isAssignableFrom(targetMethod.getDeclaringClass());
470                             }
471                         }
472                     }
473                     // Not an exception constructor call
474                     return true;
475                 }
476             }
477             // Not a StateSplit
478             return false;
479         }
480 























481         /**
482          * Builds the initial graph for a replacement.
483          */
484         @SuppressWarnings(&quot;try&quot;)
485         protected StructuredGraph buildInitialGraph(DebugContext debug, BytecodeProvider bytecodeProvider, final ResolvedJavaMethod methodToParse, Object[] args, boolean trackNodeSourcePosition,
<span class="line-modified">486                         NodeSourcePosition replaceePosition) {</span>
487             // @formatter:off
488             // Replacements cannot have optimistic assumptions since they have
489             // to be valid for the entire run of the VM.
<span class="line-modified">490             final StructuredGraph graph = new StructuredGraph.Builder(replacements.options, debug).</span>
491                             method(methodToParse).
492                             trackNodeSourcePosition(trackNodeSourcePosition).
493                             callerContext(replaceePosition).
494                             setIsSubstitution(true).
495                             build();
496             // @formatter:on
497 
498             // Replacements are not user code so they do not participate in unsafe access
499             // tracking
500             graph.disableUnsafeAccessTracking();
501 
502             try (DebugContext.Scope s = debug.scope(&quot;buildInitialGraph&quot;, graph)) {
503                 MetaAccessProvider metaAccess = replacements.providers.getMetaAccess();
504 
505                 Plugins plugins = new Plugins(replacements.graphBuilderPlugins);
506                 GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);
507                 if (args != null) {
508                     plugins.prependParameterPlugin(new ConstantBindingParameterPlugin(args, metaAccess, replacements.snippetReflection));
509                 }
510 
511                 IntrinsicContext initialIntrinsicContext = null;
512                 Snippet snippetAnnotation = method.getAnnotation(Snippet.class);
513                 MethodSubstitution methodAnnotation = method.getAnnotation(MethodSubstitution.class);
514                 if (methodAnnotation == null &amp;&amp; snippetAnnotation == null) {
515                     // Post-parse inlined intrinsic
<span class="line-modified">516                     initialIntrinsicContext = new IntrinsicContext(substitutedMethod, method, bytecodeProvider, INLINE_AFTER_PARSING);</span>
517                 } else {
518                     // Snippet
519                     ResolvedJavaMethod original = substitutedMethod != null ? substitutedMethod : method;
<span class="line-modified">520                     initialIntrinsicContext = new IntrinsicContext(original, method, bytecodeProvider, INLINE_AFTER_PARSING,</span>
521                                     snippetAnnotation != null ? snippetAnnotation.allowPartialIntrinsicArgumentMismatch() : true);
522                 }
523 
<span class="line-modified">524                 createGraphBuilder(metaAccess, replacements.providers.getStampProvider(), replacements.providers.getConstantReflection(), replacements.providers.getConstantFieldProvider(), config,</span>
<span class="line-removed">525                                 OptimisticOptimizations.NONE, initialIntrinsicContext).apply(graph);</span>
526 
<span class="line-modified">527                 new CanonicalizerPhase().apply(graph, new PhaseContext(replacements.providers));</span>
528             } catch (Throwable e) {
529                 throw debug.handle(e);
530             }
531             return graph;
532         }
533 
<span class="line-modified">534         protected Instance createGraphBuilder(MetaAccessProvider metaAccess, StampProvider stampProvider, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,</span>
<span class="line-modified">535                         GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-removed">536             return new GraphBuilderPhase.Instance(metaAccess, stampProvider, constantReflection, constantFieldProvider, graphBuilderConfig, optimisticOpts,</span>
<span class="line-removed">537                             initialIntrinsicContext);</span>
538         }
539     }
540 
541     @Override
542     public void registerSnippetTemplateCache(SnippetTemplateCache templates) {
543         assert snippetTemplateCache.get(templates.getClass().getName()) == null;
544         snippetTemplateCache.put(templates.getClass().getName(), templates);
545     }
546 
547     @Override
548     public &lt;T extends SnippetTemplateCache&gt; T getSnippetTemplateCache(Class&lt;T&gt; templatesClass) {
549         SnippetTemplateCache ret = snippetTemplateCache.get(templatesClass.getName());
550         return templatesClass.cast(ret);
551     }
552 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements;
 26 
 27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
 28 import static org.graalvm.compiler.core.common.GraalOptions.UseSnippetGraphCache;
 29 import static org.graalvm.compiler.debug.DebugContext.DEFAULT_LOG_STREAM;
<span class="line-added"> 30 import static org.graalvm.compiler.debug.DebugOptions.DebugStubsAndSnippets;</span>
 31 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
 32 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineIntrinsicsDuringParsing;
 33 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;
<span class="line-added"> 34 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createMethodSubstitutionInlineInfo;</span>
 35 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;
 36 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION;
 37 import static org.graalvm.compiler.phases.common.DeadCodeEliminationPhase.Optionality.Required;
 38 
 39 import java.util.Collections;
 40 import java.util.List;
 41 import java.util.concurrent.ConcurrentHashMap;
 42 import java.util.concurrent.ConcurrentMap;
 43 import java.util.concurrent.atomic.AtomicInteger;
 44 
 45 import jdk.internal.vm.compiler.collections.EconomicMap;
 46 import jdk.internal.vm.compiler.collections.Equivalence;
 47 import org.graalvm.compiler.api.replacements.Fold;
 48 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 49 import org.graalvm.compiler.api.replacements.Snippet;
 50 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 51 import org.graalvm.compiler.api.replacements.SnippetTemplateCache;
 52 import org.graalvm.compiler.bytecode.Bytecode;
 53 import org.graalvm.compiler.bytecode.BytecodeProvider;
 54 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
 55 import org.graalvm.compiler.core.common.CompilationIdentifier;
 56 import org.graalvm.compiler.core.common.GraalOptions;

 57 import org.graalvm.compiler.debug.DebugCloseable;
 58 import org.graalvm.compiler.debug.DebugContext;
 59 import org.graalvm.compiler.debug.DebugContext.Description;
 60 import org.graalvm.compiler.debug.DebugHandlersFactory;
 61 import org.graalvm.compiler.debug.GraalError;
 62 import org.graalvm.compiler.debug.TimerKey;
 63 import org.graalvm.compiler.graph.Node;
 64 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 65 import org.graalvm.compiler.graph.NodeSourcePosition;
 66 import org.graalvm.compiler.java.GraphBuilderPhase;
 67 import org.graalvm.compiler.java.GraphBuilderPhase.Instance;
<span class="line-added"> 68 import org.graalvm.compiler.loop.phases.ConvertDeoptimizeToGuardPhase;</span>
 69 import org.graalvm.compiler.nodes.CallTargetNode;
<span class="line-added"> 70 import org.graalvm.compiler.nodes.Cancellable;</span>
 71 import org.graalvm.compiler.nodes.Invoke;
 72 import org.graalvm.compiler.nodes.StateSplit;
 73 import org.graalvm.compiler.nodes.StructuredGraph;
 74 import org.graalvm.compiler.nodes.ValueNode;
 75 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedInvocationPlugin;
 76 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 77 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 78 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 79 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderPlugin;
 80 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 81 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 82 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 83 import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
 84 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 85 import org.graalvm.compiler.nodes.spi.Replacements;




 86 import org.graalvm.compiler.options.OptionValues;
 87 import org.graalvm.compiler.phases.OptimisticOptimizations;
 88 import org.graalvm.compiler.phases.common.CanonicalizerPhase;

 89 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;

 90 import org.graalvm.compiler.phases.util.Providers;
 91 import org.graalvm.compiler.word.Word;
 92 import org.graalvm.compiler.word.WordOperationPlugin;
 93 
 94 import jdk.vm.ci.code.TargetDescription;

 95 import jdk.vm.ci.meta.MetaAccessProvider;
 96 import jdk.vm.ci.meta.ResolvedJavaMethod;
 97 import jdk.vm.ci.meta.ResolvedJavaType;
 98 
 99 public class ReplacementsImpl implements Replacements, InlineInvokePlugin {
100 
<span class="line-modified">101     @Override</span>








102     public Providers getProviders() {
103         return providers;
104     }
105 
106     public void setProviders(Providers providers) {
107         this.providers = providers.copyWith(this);
108     }
109 
110     protected Providers providers;
111     public final SnippetReflectionProvider snippetReflection;
112     public final TargetDescription target;
113     private GraphBuilderConfiguration.Plugins graphBuilderPlugins;
114     private final DebugHandlersFactory debugHandlersFactory;
115 





116     /**
117      * The preprocessed replacement graphs.
118      */
119     protected final ConcurrentMap&lt;ResolvedJavaMethod, StructuredGraph&gt; graphs;
120 
121     /**
122      * The default {@link BytecodeProvider} to use for accessing the bytecode of a replacement if
123      * the replacement doesn&#39;t provide another {@link BytecodeProvider}.
124      */
125     protected final BytecodeProvider defaultBytecodeProvider;
126 
127     public void setGraphBuilderPlugins(GraphBuilderConfiguration.Plugins plugins) {
128         assert this.graphBuilderPlugins == null;
129         this.graphBuilderPlugins = plugins;
130     }
131 
132     @Override
133     public GraphBuilderConfiguration.Plugins getGraphBuilderPlugins() {
134         return graphBuilderPlugins;
135     }
</pre>
<hr />
<pre>
139         if (method.getAnnotation(Node.NodeIntrinsic.class) != null || method.getAnnotation(Fold.class) != null) {
140             return GeneratedInvocationPlugin.class;
141         }
142         if (method.getAnnotation(Word.Operation.class) != null) {
143             return WordOperationPlugin.class;
144         }
145         return null;
146     }
147 
148     private static final int MAX_GRAPH_INLINING_DEPTH = 100; // more than enough
149 
150     /**
151      * Determines whether a given method should be inlined based on whether it has a substitution or
152      * whether the inlining context is already within a substitution.
153      *
154      * @return an object specifying how {@code method} is to be inlined or null if it should not be
155      *         inlined based on substitution related criteria
156      */
157     @Override
158     public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
<span class="line-modified">159         MethodSubstitutionPlugin msPlugin = getMethodSubstitution(method);</span>
<span class="line-modified">160         if (msPlugin != null) {</span>
161             if (b.parsingIntrinsic() || InlineDuringParsing.getValue(b.getOptions()) || InlineIntrinsicsDuringParsing.getValue(b.getOptions())) {
162                 // Forced inlining of intrinsics
<span class="line-modified">163                 return createMethodSubstitutionInlineInfo(method, msPlugin);</span>
164             }
165             return null;
166         }
167         if (b.parsingIntrinsic()) {
168             assert b.getDepth() &lt; MAX_GRAPH_INLINING_DEPTH : &quot;inlining limit exceeded&quot;;
169 
170             // Force inlining when parsing replacements
<span class="line-modified">171             return createIntrinsicInlineInfo(method, defaultBytecodeProvider);</span>
172         } else {
173             assert IS_BUILDING_NATIVE_IMAGE || method.getAnnotation(NodeIntrinsic.class) == null : String.format(&quot;@%s method %s must only be called from within a replacement%n%s&quot;,
174                             NodeIntrinsic.class.getSimpleName(),
175                             method.format(&quot;%h.%n&quot;), b);
176         }
177         return null;
178     }
179 
180     @Override
181     public void notifyNotInlined(GraphBuilderContext b, ResolvedJavaMethod method, Invoke invoke) {
182         if (b.parsingIntrinsic()) {
183             IntrinsicContext intrinsic = b.getIntrinsic();
184             if (!intrinsic.isCallToOriginal(method)) {
185                 Class&lt;? extends GraphBuilderPlugin&gt; pluginClass = getIntrinsifyingPlugin(method);
186                 if (pluginClass != null) {
187                     String methodDesc = method.format(&quot;%H.%n(%p)&quot;);
188                     throw new GraalError(&quot;Call to %s should have been intrinsified by a %s. &quot; +
189                                     &quot;This is typically caused by Eclipse failing to run an annotation &quot; +
190                                     &quot;processor. This can usually be fixed by forcing Eclipse to rebuild &quot; +
191                                     &quot;the source file in which %s is declared&quot;,
192                                     methodDesc, pluginClass.getSimpleName(), methodDesc);
193                 }
194                 throw new GraalError(&quot;All non-recursive calls in the intrinsic %s must be inlined or intrinsified: found call to %s&quot;,
195                                 intrinsic.getIntrinsicMethod().format(&quot;%H.%n(%p)&quot;), method.format(&quot;%h.%n(%p)&quot;));
196             }
197         }
198     }
199 
200     // This map is key&#39;ed by a class name instead of a Class object so that
201     // it is stable across VM executions (in support of replay compilation).
202     private final EconomicMap&lt;String, SnippetTemplateCache&gt; snippetTemplateCache;
203 
<span class="line-modified">204     public ReplacementsImpl(DebugHandlersFactory debugHandlersFactory, Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider,</span>
205                     TargetDescription target) {

206         this.providers = providers.copyWith(this);
207         this.snippetReflection = snippetReflection;
208         this.target = target;
209         this.graphs = new ConcurrentHashMap&lt;&gt;();
210         this.snippetTemplateCache = EconomicMap.create(Equivalence.DEFAULT);
211         this.defaultBytecodeProvider = bytecodeProvider;
212         this.debugHandlersFactory = debugHandlersFactory;
213 
214     }
215 
216     private static final TimerKey SnippetPreparationTime = DebugContext.timer(&quot;SnippetPreparationTime&quot;);
217 
218     private static final AtomicInteger nextDebugContextId = new AtomicInteger();
219 
<span class="line-modified">220     public DebugContext openDebugContext(String idPrefix, ResolvedJavaMethod method, OptionValues options) {</span>
<span class="line-modified">221         if (DebugStubsAndSnippets.getValue(options)) {</span>
<span class="line-modified">222             DebugContext outer = DebugContext.forCurrentThread();</span>
<span class="line-modified">223             Description description = new Description(method, idPrefix + nextDebugContextId.incrementAndGet());</span>
<span class="line-modified">224             List&lt;DebugHandlersFactory&gt; factories = debugHandlersFactory == null ? Collections.emptyList() : Collections.singletonList(debugHandlersFactory);</span>
<span class="line-added">225             return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, factories);</span>
<span class="line-added">226         }</span>
<span class="line-added">227         return DebugContext.disabled(options);</span>
228     }
229 
230     @Override
231     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">232     public StructuredGraph getSnippet(ResolvedJavaMethod method, ResolvedJavaMethod recursiveEntry, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition,</span>
<span class="line-added">233                     OptionValues options) {</span>
234         assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
235         assert method.hasBytecodes() : &quot;Snippet must not be abstract or native&quot;;
236 
237         StructuredGraph graph = UseSnippetGraphCache.getValue(options) ? graphs.get(method) : null;
238         if (graph == null || (trackNodeSourcePosition &amp;&amp; !graph.trackNodeSourcePosition())) {
<span class="line-modified">239             try (DebugContext debug = openDebugContext(&quot;Snippet_&quot;, method, options);</span>
240                             DebugCloseable a = SnippetPreparationTime.start(debug)) {
<span class="line-modified">241                 StructuredGraph newGraph = makeGraph(debug, defaultBytecodeProvider, method, args, recursiveEntry, trackNodeSourcePosition, replaceePosition, INLINE_AFTER_PARSING);</span>
242                 DebugContext.counter(&quot;SnippetNodeCount[%#s]&quot;, method).add(newGraph.getDebug(), newGraph.getNodeCount());
243                 if (!UseSnippetGraphCache.getValue(options) || args != null) {
244                     return newGraph;
245                 }
246                 newGraph.freeze();
247                 if (graph != null) {
248                     graphs.replace(method, graph, newGraph);
249                 } else {
250                     graphs.putIfAbsent(method, newGraph);
251                 }
252                 graph = graphs.get(method);
253             }
254         }
255         assert !trackNodeSourcePosition || graph.trackNodeSourcePosition();
256         return graph;
257     }
258 
259     @Override
<span class="line-modified">260     public void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition, OptionValues options) {</span>
261         // No initialization needed as snippet graphs are created on demand in getSnippet
262     }
263 
<span class="line-added">264     @Override</span>
<span class="line-added">265     public StructuredGraph getMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, IntrinsicContext.CompilationContext context,</span>
<span class="line-added">266                     StructuredGraph.AllowAssumptions allowAssumptions, Cancellable cancellable, OptionValues options) {</span>
<span class="line-added">267         // Method substitutions are parsed by the BytecodeParser.</span>
<span class="line-added">268         return null;</span>
<span class="line-added">269     }</span>
<span class="line-added">270 </span>
<span class="line-added">271     @Override</span>
<span class="line-added">272     public void registerMethodSubstitution(MethodSubstitutionPlugin plugin) {</span>
<span class="line-added">273         // No initialization needed as method substitutions are parsed by the BytecodeParser.</span>
<span class="line-added">274     }</span>
<span class="line-added">275 </span>
<span class="line-added">276     @Override</span>
<span class="line-added">277     public void registerConditionalPlugin(InvocationPlugin plugin) {</span>
<span class="line-added">278     }</span>
<span class="line-added">279 </span>
280     @Override
281     public boolean hasSubstitution(ResolvedJavaMethod method, int invokeBci) {
282         InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
283         return plugin != null &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0);
284     }
285 
286     @Override
287     public BytecodeProvider getDefaultReplacementBytecodeProvider() {
288         return defaultBytecodeProvider;
289     }
290 
<span class="line-modified">291     protected MethodSubstitutionPlugin getMethodSubstitution(ResolvedJavaMethod method) {</span>

292         InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
293         if (plugin instanceof MethodSubstitutionPlugin) {
294             MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;
<span class="line-modified">295             return msPlugin;</span>

296         }
297         return null;
298     }
299 
300     @Override
<span class="line-modified">301     public StructuredGraph getSubstitution(ResolvedJavaMethod method, int invokeBci, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition, OptionValues options) {</span>
302         StructuredGraph result;
303         InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
304         if (plugin != null &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0)) {
305             MetaAccessProvider metaAccess = providers.getMetaAccess();
306             if (plugin instanceof MethodSubstitutionPlugin) {
307                 MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;
308                 ResolvedJavaMethod substitute = msPlugin.getSubstitute(metaAccess);
309                 StructuredGraph graph = UseSnippetGraphCache.getValue(options) ? graphs.get(substitute) : null;
310                 if (graph == null || graph.trackNodeSourcePosition() != trackNodeSourcePosition) {
<span class="line-modified">311                     try (DebugContext debug = openDebugContext(&quot;Substitution_&quot;, method, options)) {</span>
<span class="line-modified">312                         graph = makeGraph(debug, msPlugin.getBytecodeProvider(), substitute, null, method, trackNodeSourcePosition, replaceePosition, INLINE_AFTER_PARSING);</span>
313                         if (!UseSnippetGraphCache.getValue(options)) {
314                             return graph;
315                         }
316                         graph.freeze();
317                         graphs.putIfAbsent(substitute, graph);
318                         graph = graphs.get(substitute);
319                     }
320                 }
321                 assert graph.isFrozen();
322                 result = graph;
323             } else {
324                 Bytecode code = new ResolvedJavaMethodBytecode(method);
<span class="line-modified">325                 try (DebugContext debug = openDebugContext(&quot;Substitution_&quot;, method, options)) {</span>
<span class="line-modified">326                     result = new IntrinsicGraphBuilder(options, debug, providers, code, invokeBci).buildGraph(plugin);</span>



327                 }
328             }
329         } else {
330             result = null;
331         }
332         return result;
333     }
334 
335     @SuppressWarnings(&quot;try&quot;)
336     @Override
<span class="line-modified">337     public StructuredGraph getIntrinsicGraph(ResolvedJavaMethod method, CompilationIdentifier compilationId, DebugContext debug, Cancellable cancellable) {</span>
<span class="line-modified">338         MethodSubstitutionPlugin msPlugin = getMethodSubstitution(method);</span>
<span class="line-modified">339         if (msPlugin != null) {</span>
<span class="line-modified">340             ResolvedJavaMethod substMethod = msPlugin.getSubstitute(providers.getMetaAccess());</span>
341             assert !substMethod.equals(method);
<span class="line-modified">342             BytecodeProvider bytecodeProvider = msPlugin.getBytecodeProvider();</span>
343             // @formatter:off
<span class="line-modified">344             StructuredGraph graph = new StructuredGraph.Builder(debug.getOptions(), debug, StructuredGraph.AllowAssumptions.YES).</span>
345                     method(substMethod).
346                     compilationId(compilationId).
347                     recordInlinedMethods(bytecodeProvider.shouldRecordMethodDependencies()).
348                     setIsSubstitution(true).
349                     build();
350             // @formatter:on
351             try (DebugContext.Scope scope = debug.scope(&quot;GetIntrinsicGraph&quot;, graph)) {
352                 Plugins plugins = new Plugins(getGraphBuilderPlugins());
353                 GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);
354                 IntrinsicContext initialReplacementContext = new IntrinsicContext(method, substMethod, bytecodeProvider, ROOT_COMPILATION);
<span class="line-modified">355                 new GraphBuilderPhase.Instance(providers, config, OptimisticOptimizations.NONE, initialReplacementContext).apply(graph);</span>

356                 assert !graph.isFrozen();
357                 return graph;
358             } catch (Throwable e) {
359                 debug.handle(e);
360             }
361         }
362         return null;
363     }
364 
365     /**
366      * Creates a preprocessed graph for a snippet or method substitution.
367      *
368      * @param bytecodeProvider how to access the bytecode of {@code method}
369      * @param method the snippet or method substitution for which a graph will be created
370      * @param args
371      * @param original the original method if {@code method} is a {@linkplain MethodSubstitution
372      *            substitution} otherwise null
<span class="line-modified">373      * @param trackNodeSourcePosition record source information</span>
<span class="line-added">374      * @param context</span>
<span class="line-added">375      *            {@link org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext</span>
<span class="line-added">376      *            compilation context} for the graph</span>
377      */
378     public StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, ResolvedJavaMethod method, Object[] args, ResolvedJavaMethod original, boolean trackNodeSourcePosition,
<span class="line-modified">379                     NodeSourcePosition replaceePosition, IntrinsicContext.CompilationContext context) {</span>
<span class="line-modified">380         return createGraphMaker(method, original).makeGraph(debug, bytecodeProvider, args, trackNodeSourcePosition, replaceePosition, context);</span>
<span class="line-added">381     }</span>
<span class="line-added">382 </span>
<span class="line-added">383     /**</span>
<span class="line-added">384      * Creates a preprocessed graph for a snippet or method substitution with a context of .</span>
<span class="line-added">385      * {@link org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext#INLINE_AFTER_PARSING}</span>
<span class="line-added">386      * .</span>
<span class="line-added">387      *</span>
<span class="line-added">388      *</span>
<span class="line-added">389      * @param bytecodeProvider how to access the bytecode of {@code method}</span>
<span class="line-added">390      * @param method the snippet or method substitution for which a graph will be created</span>
<span class="line-added">391      * @param args</span>
<span class="line-added">392      * @param original the original method if {@code method} is a {@linkplain MethodSubstitution</span>
<span class="line-added">393      *            substitution} otherwise null</span>
<span class="line-added">394      * @param trackNodeSourcePosition record source information</span>
<span class="line-added">395      */</span>
<span class="line-added">396     public final StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, ResolvedJavaMethod method, Object[] args, ResolvedJavaMethod original,</span>
<span class="line-added">397                     boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>
<span class="line-added">398         return makeGraph(debug, bytecodeProvider, method, args, original, trackNodeSourcePosition, replaceePosition, INLINE_AFTER_PARSING);</span>
399     }
400 
401     /**
402      * Can be overridden to return an object that specializes various parts of graph preprocessing.
403      */
404     protected GraphMaker createGraphMaker(ResolvedJavaMethod substitute, ResolvedJavaMethod original) {
405         return new GraphMaker(this, substitute, original);
406     }
407 
408     /**
409      * Creates and preprocesses a graph for a replacement.
410      */
411     public static class GraphMaker {
412 
413         /** The replacements object that the graphs are created for. */
414         protected final ReplacementsImpl replacements;
415 
416         /**
417          * The method for which a graph is being created.
418          */
419         protected final ResolvedJavaMethod method;
420 
421         /**
422          * The original method which {@link #method} is substituting. Calls to {@link #method} or
423          * {@link #substitutedMethod} will be replaced with a forced inline of
424          * {@link #substitutedMethod}.
425          */
426         protected final ResolvedJavaMethod substitutedMethod;
427 
428         public GraphMaker(ReplacementsImpl replacements, ResolvedJavaMethod substitute, ResolvedJavaMethod substitutedMethod) {
429             this.replacements = replacements;
430             this.method = substitute;
431             this.substitutedMethod = substitutedMethod;
432         }
433 
434         @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">435         public StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition,</span>
<span class="line-added">436                         IntrinsicContext.CompilationContext context) {</span>
437             try (DebugContext.Scope s = debug.scope(&quot;BuildSnippetGraph&quot;, method)) {
438                 assert method.hasBytecodes() : method;
<span class="line-modified">439                 StructuredGraph graph = buildInitialGraph(debug, bytecodeProvider, method, args, trackNodeSourcePosition, replaceePosition, context);</span>
440 
441                 finalizeGraph(graph);
442 
443                 debug.dump(DebugContext.INFO_LEVEL, graph, &quot;%s: Final&quot;, method.getName());
444 
445                 return graph;
446             } catch (Throwable e) {
447                 throw debug.handle(e);
448             }
449         }
450 
451         /**
452          * Does final processing of a snippet graph.
453          */
454         protected void finalizeGraph(StructuredGraph graph) {
<span class="line-modified">455             if (!GraalOptions.SnippetCounters.getValue(graph.getOptions()) || graph.getNodes().filter(SnippetCounterNode.class).isEmpty()) {</span>
456                 int sideEffectCount = 0;
457                 assert (sideEffectCount = graph.getNodes().filter(e -&gt; hasSideEffect(e)).count()) &gt;= 0;
458                 new ConvertDeoptimizeToGuardPhase().apply(graph, null);
459                 assert sideEffectCount == graph.getNodes().filter(e -&gt; hasSideEffect(e)).count() : &quot;deleted side effecting node&quot;;
460 
461                 new DeadCodeEliminationPhase(Required).apply(graph);
462             } else {
463                 // ConvertDeoptimizeToGuardPhase will eliminate snippet counters on paths
464                 // that terminate in a deopt so we disable it if the graph contains
465                 // snippet counters. The trade off is that we miss out on guard
466                 // coalescing opportunities.
467             }
468         }
469 
470         /**
471          * Filter nodes which have side effects and shouldn&#39;t be deleted from snippets when
472          * converting deoptimizations to guards. Currently this only allows exception constructors
473          * to be eliminated to cover the case when Java assertions are in the inlined code.
474          *
475          * @param node
</pre>
<hr />
<pre>
479             if (node instanceof StateSplit) {
480                 if (((StateSplit) node).hasSideEffect()) {
481                     if (node instanceof Invoke) {
482                         CallTargetNode callTarget = ((Invoke) node).callTarget();
483                         if (callTarget instanceof MethodCallTargetNode) {
484                             ResolvedJavaMethod targetMethod = ((MethodCallTargetNode) callTarget).targetMethod();
485                             if (targetMethod.isConstructor()) {
486                                 ResolvedJavaType throwableType = replacements.providers.getMetaAccess().lookupJavaType(Throwable.class);
487                                 return !throwableType.isAssignableFrom(targetMethod.getDeclaringClass());
488                             }
489                         }
490                     }
491                     // Not an exception constructor call
492                     return true;
493                 }
494             }
495             // Not a StateSplit
496             return false;
497         }
498 
<span class="line-added">499         static class EncodedIntrinsicContext extends IntrinsicContext {</span>
<span class="line-added">500             EncodedIntrinsicContext(ResolvedJavaMethod method, ResolvedJavaMethod intrinsic, BytecodeProvider bytecodeProvider, CompilationContext compilationContext,</span>
<span class="line-added">501                             boolean allowPartialIntrinsicArgumentMismatch) {</span>
<span class="line-added">502                 super(method, intrinsic, bytecodeProvider, compilationContext, allowPartialIntrinsicArgumentMismatch);</span>
<span class="line-added">503             }</span>
<span class="line-added">504 </span>
<span class="line-added">505             @Override</span>
<span class="line-added">506             public boolean isDeferredInvoke(StateSplit stateSplit) {</span>
<span class="line-added">507                 if (stateSplit instanceof Invoke) {</span>
<span class="line-added">508                     Invoke invoke = (Invoke) stateSplit;</span>
<span class="line-added">509                     ResolvedJavaMethod method = invoke.callTarget().targetMethod();</span>
<span class="line-added">510                     if (method.getAnnotation(Fold.class) != null) {</span>
<span class="line-added">511                         return true;</span>
<span class="line-added">512                     }</span>
<span class="line-added">513                     Node.NodeIntrinsic annotation = method.getAnnotation(Node.NodeIntrinsic.class);</span>
<span class="line-added">514                     if (annotation != null &amp;&amp; !annotation.hasSideEffect()) {</span>
<span class="line-added">515                         return true;</span>
<span class="line-added">516                     }</span>
<span class="line-added">517                 }</span>
<span class="line-added">518                 return false;</span>
<span class="line-added">519             }</span>
<span class="line-added">520         }</span>
<span class="line-added">521 </span>
522         /**
523          * Builds the initial graph for a replacement.
524          */
525         @SuppressWarnings(&quot;try&quot;)
526         protected StructuredGraph buildInitialGraph(DebugContext debug, BytecodeProvider bytecodeProvider, final ResolvedJavaMethod methodToParse, Object[] args, boolean trackNodeSourcePosition,
<span class="line-modified">527                         NodeSourcePosition replaceePosition, IntrinsicContext.CompilationContext context) {</span>
528             // @formatter:off
529             // Replacements cannot have optimistic assumptions since they have
530             // to be valid for the entire run of the VM.
<span class="line-modified">531             final StructuredGraph graph = new StructuredGraph.Builder(debug.getOptions(), debug).</span>
532                             method(methodToParse).
533                             trackNodeSourcePosition(trackNodeSourcePosition).
534                             callerContext(replaceePosition).
535                             setIsSubstitution(true).
536                             build();
537             // @formatter:on
538 
539             // Replacements are not user code so they do not participate in unsafe access
540             // tracking
541             graph.disableUnsafeAccessTracking();
542 
543             try (DebugContext.Scope s = debug.scope(&quot;buildInitialGraph&quot;, graph)) {
544                 MetaAccessProvider metaAccess = replacements.providers.getMetaAccess();
545 
546                 Plugins plugins = new Plugins(replacements.graphBuilderPlugins);
547                 GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);
548                 if (args != null) {
549                     plugins.prependParameterPlugin(new ConstantBindingParameterPlugin(args, metaAccess, replacements.snippetReflection));
550                 }
551 
552                 IntrinsicContext initialIntrinsicContext = null;
553                 Snippet snippetAnnotation = method.getAnnotation(Snippet.class);
554                 MethodSubstitution methodAnnotation = method.getAnnotation(MethodSubstitution.class);
555                 if (methodAnnotation == null &amp;&amp; snippetAnnotation == null) {
556                     // Post-parse inlined intrinsic
<span class="line-modified">557                     initialIntrinsicContext = new EncodedIntrinsicContext(substitutedMethod, method, bytecodeProvider, context, false);</span>
558                 } else {
559                     // Snippet
560                     ResolvedJavaMethod original = substitutedMethod != null ? substitutedMethod : method;
<span class="line-modified">561                     initialIntrinsicContext = new EncodedIntrinsicContext(original, method, bytecodeProvider, context,</span>
562                                     snippetAnnotation != null ? snippetAnnotation.allowPartialIntrinsicArgumentMismatch() : true);
563                 }
564 
<span class="line-modified">565                 createGraphBuilder(replacements.providers, config, OptimisticOptimizations.NONE, initialIntrinsicContext).apply(graph);</span>

566 
<span class="line-modified">567                 CanonicalizerPhase.create().apply(graph, replacements.providers);</span>
568             } catch (Throwable e) {
569                 throw debug.handle(e);
570             }
571             return graph;
572         }
573 
<span class="line-modified">574         protected Instance createGraphBuilder(Providers providers, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-modified">575             return new GraphBuilderPhase.Instance(providers, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);</span>


576         }
577     }
578 
579     @Override
580     public void registerSnippetTemplateCache(SnippetTemplateCache templates) {
581         assert snippetTemplateCache.get(templates.getClass().getName()) == null;
582         snippetTemplateCache.put(templates.getClass().getName(), templates);
583     }
584 
585     @Override
586     public &lt;T extends SnippetTemplateCache&gt; T getSnippetTemplateCache(Class&lt;T&gt; templatesClass) {
587         SnippetTemplateCache ret = snippetTemplateCache.get(templatesClass.getName());
588         return templatesClass.cast(ret);
589     }
590 }
</pre>
</td>
</tr>
</table>
<center><a href="PEGraphDecoder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SnippetCounter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
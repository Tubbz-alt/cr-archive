<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/GraphKit.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DefaultJavaLoweringProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="InlineDuringParsingPlugin.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/GraphKit.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 51 import org.graalvm.compiler.nodes.EndNode;
 52 import org.graalvm.compiler.nodes.FixedNode;
 53 import org.graalvm.compiler.nodes.FixedWithNextNode;
 54 import org.graalvm.compiler.nodes.IfNode;
 55 import org.graalvm.compiler.nodes.InvokeNode;
 56 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 57 import org.graalvm.compiler.nodes.KillingBeginNode;
 58 import org.graalvm.compiler.nodes.LogicNode;
 59 import org.graalvm.compiler.nodes.MergeNode;
 60 import org.graalvm.compiler.nodes.NodeView;
 61 import org.graalvm.compiler.nodes.StructuredGraph;
 62 import org.graalvm.compiler.nodes.UnwindNode;
 63 import org.graalvm.compiler.nodes.ValueNode;
 64 import org.graalvm.compiler.nodes.calc.FloatingNode;
 65 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 66 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 67 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderTool;
 68 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 69 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
 70 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;

 71 import org.graalvm.compiler.nodes.spi.StampProvider;
 72 import org.graalvm.compiler.nodes.type.StampTool;
 73 import org.graalvm.compiler.phases.OptimisticOptimizations;
 74 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 75 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase.Optionality;
 76 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 77 import org.graalvm.compiler.phases.util.Providers;
 78 import org.graalvm.compiler.word.WordTypes;
 79 import jdk.internal.vm.compiler.word.LocationIdentity;
 80 
 81 import jdk.vm.ci.code.BytecodeFrame;
 82 import jdk.vm.ci.meta.ConstantReflectionProvider;
 83 import jdk.vm.ci.meta.JavaKind;
 84 import jdk.vm.ci.meta.JavaType;
 85 import jdk.vm.ci.meta.MetaAccessProvider;
 86 import jdk.vm.ci.meta.ResolvedJavaMethod;
 87 import jdk.vm.ci.meta.ResolvedJavaType;
 88 import jdk.vm.ci.meta.Signature;
 89 
 90 /**
</pre>
<hr />
<pre>
134     @Override
135     public StructuredGraph getGraph() {
136         return graph;
137     }
138 
139     @Override
140     public ConstantReflectionProvider getConstantReflection() {
141         return providers.getConstantReflection();
142     }
143 
144     @Override
145     public ConstantFieldProvider getConstantFieldProvider() {
146         return providers.getConstantFieldProvider();
147     }
148 
149     @Override
150     public MetaAccessProvider getMetaAccess() {
151         return providers.getMetaAccess();
152     }
153 





154     @Override
155     public StampProvider getStampProvider() {
156         return providers.getStampProvider();
157     }
158 
159     @Override
160     public boolean parsingIntrinsic() {
161         return true;
162     }
163 
164     /**
165      * Ensures a floating node is added to or already present in the graph via {@link Graph#unique}.
166      *
167      * @return a node similar to {@code node} if one exists, otherwise {@code node}
168      */
169     public &lt;T extends FloatingNode &amp; ValueNumberable&gt; T unique(T node) {
170         return graph.unique(changeToWord(node));
171     }
172 
173     public &lt;T extends ValueNode&gt; T add(T node) {
</pre>
<hr />
<pre>
338      * Recursively {@linkplain #inline inlines} all invocations currently in the graph.
339      */
340     public void inlineInvokes(String reason, String phase) {
341         while (!graph.getNodes().filter(InvokeNode.class).isEmpty()) {
342             for (InvokeNode invoke : graph.getNodes().filter(InvokeNode.class).snapshot()) {
343                 inline(invoke, reason, phase);
344             }
345         }
346 
347         // Clean up all code that is now dead after inlining.
348         new DeadCodeEliminationPhase().apply(graph);
349     }
350 
351     /**
352      * Inlines a given invocation to a method. The graph of the inlined method is processed in the
353      * same manner as for snippets and method substitutions.
354      */
355     public void inline(InvokeNode invoke, String reason, String phase) {
356         ResolvedJavaMethod method = ((MethodCallTargetNode) invoke.callTarget()).targetMethod();
357 
<span class="line-removed">358         MetaAccessProvider metaAccess = providers.getMetaAccess();</span>
359         Plugins plugins = new Plugins(graphBuilderPlugins);
360         GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);
361 
362         StructuredGraph calleeGraph;
363         if (IS_IN_NATIVE_IMAGE) {
<span class="line-modified">364             calleeGraph = providers.getReplacements().getSnippet(method, null, false, null);</span>
365         } else {
366             calleeGraph = new StructuredGraph.Builder(invoke.getOptions(), invoke.getDebug()).method(method).trackNodeSourcePosition(invoke.graph().trackNodeSourcePosition()).setIsSubstitution(
367                             true).build();
368             IntrinsicContext initialReplacementContext = new IntrinsicContext(method, method, providers.getReplacements().getDefaultReplacementBytecodeProvider(), INLINE_AFTER_PARSING);
<span class="line-modified">369             GraphBuilderPhase.Instance instance = createGraphBuilderInstance(metaAccess, providers.getStampProvider(), providers.getConstantReflection(), providers.getConstantFieldProvider(), config,</span>
<span class="line-removed">370                             OptimisticOptimizations.NONE,</span>
<span class="line-removed">371                             initialReplacementContext);</span>
372             instance.apply(calleeGraph);
373         }
374 
375         // Remove all frame states from inlinee
376         calleeGraph.clearAllStateAfter();
377         new DeadCodeEliminationPhase(Optionality.Required).apply(calleeGraph);
378 
379         InliningUtil.inline(invoke, calleeGraph, false, method, reason, phase);
380     }
381 
<span class="line-modified">382     protected GraphBuilderPhase.Instance createGraphBuilderInstance(MetaAccessProvider metaAccess, StampProvider stampProvider, ConstantReflectionProvider constantReflection,</span>
<span class="line-modified">383                     ConstantFieldProvider constantFieldProvider, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-modified">384         return new GraphBuilderPhase.Instance(metaAccess, stampProvider, constantReflection, constantFieldProvider, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);</span>
385     }
386 
387     protected void pushStructure(Structure structure) {
388         structures.add(structure);
389     }
390 
391     protected &lt;T extends Structure&gt; T getTopStructure(Class&lt;T&gt; expectedClass) {
392         return expectedClass.cast(structures.get(structures.size() - 1));
393     }
394 
395     protected void popStructure() {
396         structures.remove(structures.size() - 1);
397     }
398 
399     protected enum IfState {
400         CONDITION,
401         THEN_PART,
402         ELSE_PART,
403         FINISHED
404     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 51 import org.graalvm.compiler.nodes.EndNode;
 52 import org.graalvm.compiler.nodes.FixedNode;
 53 import org.graalvm.compiler.nodes.FixedWithNextNode;
 54 import org.graalvm.compiler.nodes.IfNode;
 55 import org.graalvm.compiler.nodes.InvokeNode;
 56 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 57 import org.graalvm.compiler.nodes.KillingBeginNode;
 58 import org.graalvm.compiler.nodes.LogicNode;
 59 import org.graalvm.compiler.nodes.MergeNode;
 60 import org.graalvm.compiler.nodes.NodeView;
 61 import org.graalvm.compiler.nodes.StructuredGraph;
 62 import org.graalvm.compiler.nodes.UnwindNode;
 63 import org.graalvm.compiler.nodes.ValueNode;
 64 import org.graalvm.compiler.nodes.calc.FloatingNode;
 65 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 66 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 67 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderTool;
 68 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 69 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
 70 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
<span class="line-added"> 71 import org.graalvm.compiler.nodes.spi.Replacements;</span>
 72 import org.graalvm.compiler.nodes.spi.StampProvider;
 73 import org.graalvm.compiler.nodes.type.StampTool;
 74 import org.graalvm.compiler.phases.OptimisticOptimizations;
 75 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 76 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase.Optionality;
 77 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 78 import org.graalvm.compiler.phases.util.Providers;
 79 import org.graalvm.compiler.word.WordTypes;
 80 import jdk.internal.vm.compiler.word.LocationIdentity;
 81 
 82 import jdk.vm.ci.code.BytecodeFrame;
 83 import jdk.vm.ci.meta.ConstantReflectionProvider;
 84 import jdk.vm.ci.meta.JavaKind;
 85 import jdk.vm.ci.meta.JavaType;
 86 import jdk.vm.ci.meta.MetaAccessProvider;
 87 import jdk.vm.ci.meta.ResolvedJavaMethod;
 88 import jdk.vm.ci.meta.ResolvedJavaType;
 89 import jdk.vm.ci.meta.Signature;
 90 
 91 /**
</pre>
<hr />
<pre>
135     @Override
136     public StructuredGraph getGraph() {
137         return graph;
138     }
139 
140     @Override
141     public ConstantReflectionProvider getConstantReflection() {
142         return providers.getConstantReflection();
143     }
144 
145     @Override
146     public ConstantFieldProvider getConstantFieldProvider() {
147         return providers.getConstantFieldProvider();
148     }
149 
150     @Override
151     public MetaAccessProvider getMetaAccess() {
152         return providers.getMetaAccess();
153     }
154 
<span class="line-added">155     @Override</span>
<span class="line-added">156     public Replacements getReplacements() {</span>
<span class="line-added">157         return providers.getReplacements();</span>
<span class="line-added">158     }</span>
<span class="line-added">159 </span>
160     @Override
161     public StampProvider getStampProvider() {
162         return providers.getStampProvider();
163     }
164 
165     @Override
166     public boolean parsingIntrinsic() {
167         return true;
168     }
169 
170     /**
171      * Ensures a floating node is added to or already present in the graph via {@link Graph#unique}.
172      *
173      * @return a node similar to {@code node} if one exists, otherwise {@code node}
174      */
175     public &lt;T extends FloatingNode &amp; ValueNumberable&gt; T unique(T node) {
176         return graph.unique(changeToWord(node));
177     }
178 
179     public &lt;T extends ValueNode&gt; T add(T node) {
</pre>
<hr />
<pre>
344      * Recursively {@linkplain #inline inlines} all invocations currently in the graph.
345      */
346     public void inlineInvokes(String reason, String phase) {
347         while (!graph.getNodes().filter(InvokeNode.class).isEmpty()) {
348             for (InvokeNode invoke : graph.getNodes().filter(InvokeNode.class).snapshot()) {
349                 inline(invoke, reason, phase);
350             }
351         }
352 
353         // Clean up all code that is now dead after inlining.
354         new DeadCodeEliminationPhase().apply(graph);
355     }
356 
357     /**
358      * Inlines a given invocation to a method. The graph of the inlined method is processed in the
359      * same manner as for snippets and method substitutions.
360      */
361     public void inline(InvokeNode invoke, String reason, String phase) {
362         ResolvedJavaMethod method = ((MethodCallTargetNode) invoke.callTarget()).targetMethod();
363 

364         Plugins plugins = new Plugins(graphBuilderPlugins);
365         GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);
366 
367         StructuredGraph calleeGraph;
368         if (IS_IN_NATIVE_IMAGE) {
<span class="line-modified">369             calleeGraph = providers.getReplacements().getSnippet(method, null, null, false, null, invoke.getOptions());</span>
370         } else {
371             calleeGraph = new StructuredGraph.Builder(invoke.getOptions(), invoke.getDebug()).method(method).trackNodeSourcePosition(invoke.graph().trackNodeSourcePosition()).setIsSubstitution(
372                             true).build();
373             IntrinsicContext initialReplacementContext = new IntrinsicContext(method, method, providers.getReplacements().getDefaultReplacementBytecodeProvider(), INLINE_AFTER_PARSING);
<span class="line-modified">374             GraphBuilderPhase.Instance instance = createGraphBuilderInstance(providers, config, OptimisticOptimizations.NONE, initialReplacementContext);</span>


375             instance.apply(calleeGraph);
376         }
377 
378         // Remove all frame states from inlinee
379         calleeGraph.clearAllStateAfter();
380         new DeadCodeEliminationPhase(Optionality.Required).apply(calleeGraph);
381 
382         InliningUtil.inline(invoke, calleeGraph, false, method, reason, phase);
383     }
384 
<span class="line-modified">385     protected GraphBuilderPhase.Instance createGraphBuilderInstance(Providers theProviders, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts,</span>
<span class="line-modified">386                     IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-modified">387         return new GraphBuilderPhase.Instance(theProviders, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);</span>
388     }
389 
390     protected void pushStructure(Structure structure) {
391         structures.add(structure);
392     }
393 
394     protected &lt;T extends Structure&gt; T getTopStructure(Class&lt;T&gt; expectedClass) {
395         return expectedClass.cast(structures.get(structures.size() - 1));
396     }
397 
398     protected void popStructure() {
399         structures.remove(structures.size() - 1);
400     }
401 
402     protected enum IfState {
403         CONDITION,
404         THEN_PART,
405         ELSE_PART,
406         FINISHED
407     }
</pre>
</td>
</tr>
</table>
<center><a href="DefaultJavaLoweringProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="InlineDuringParsingPlugin.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
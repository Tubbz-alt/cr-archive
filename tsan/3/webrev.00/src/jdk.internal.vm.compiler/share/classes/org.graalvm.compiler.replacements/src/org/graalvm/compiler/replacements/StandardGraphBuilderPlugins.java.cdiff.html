<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/StandardGraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SnippetTemplate.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="arraycopy/ArrayCopyCallNode.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/StandardGraphBuilderPlugins.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,20 ***</span>
  import static jdk.vm.ci.code.MemoryBarriers.LOAD_LOAD;
  import static jdk.vm.ci.code.MemoryBarriers.LOAD_STORE;
  import static jdk.vm.ci.code.MemoryBarriers.STORE_LOAD;
  import static jdk.vm.ci.code.MemoryBarriers.STORE_STORE;
  import static org.graalvm.compiler.nodes.NamedLocationIdentity.OFF_HEAP_LOCATION;
<span class="line-removed">- import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java11OrEarlier;</span>
<span class="line-removed">- import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java8OrEarlier;</span>
  
  import java.lang.reflect.Array;
  import java.lang.reflect.Field;
  import java.util.Arrays;
  
  import org.graalvm.compiler.api.directives.GraalDirectives;
  import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
<span class="line-removed">- import org.graalvm.compiler.bytecode.BytecodeProvider;</span>
  import org.graalvm.compiler.core.common.calc.Condition;
  import org.graalvm.compiler.core.common.calc.Condition.CanonicalizedCondition;
  import org.graalvm.compiler.core.common.calc.UnsignedMath;
  import org.graalvm.compiler.core.common.type.ObjectStamp;
  import org.graalvm.compiler.core.common.type.Stamp;
<span class="line-new-header">--- 31,17 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,10 ***</span>
<span class="line-new-header">--- 82,11 ---</span>
  import org.graalvm.compiler.nodes.calc.UnsignedRemNode;
  import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  import org.graalvm.compiler.nodes.debug.BindToRegisterNode;
  import org.graalvm.compiler.nodes.debug.BlackholeNode;
  import org.graalvm.compiler.nodes.debug.ControlFlowAnchorNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.debug.SideEffectNode;</span>
  import org.graalvm.compiler.nodes.debug.SpillRegistersNode;
  import org.graalvm.compiler.nodes.extended.BoxNode;
  import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;
  import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
  import org.graalvm.compiler.nodes.extended.GetClassNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,10 ***</span>
<span class="line-new-header">--- 113,11 ---</span>
  import org.graalvm.compiler.nodes.java.RegisterFinalizerNode;
  import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
  import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
  import org.graalvm.compiler.nodes.memory.HeapAccess;
  import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.spi.Replacements;</span>
  import org.graalvm.compiler.nodes.type.StampTool;
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.nodes.virtual.EnsureVirtualizedNode;
  import org.graalvm.compiler.replacements.nodes.ProfileBooleanNode;
  import org.graalvm.compiler.replacements.nodes.ReverseBytesNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,10 ***</span>
<span class="line-new-header">--- 130,11 ---</span>
  import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactOverflowNode;
  import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactSplitNode;
  import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactNode;
  import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactOverflowNode;
  import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactSplitNode;
<span class="line-added">+ import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
  import org.graalvm.compiler.serviceprovider.SpeculationReasonGroup;
  import jdk.internal.vm.compiler.word.LocationIdentity;
  
  import jdk.vm.ci.code.BytecodePosition;
  import jdk.vm.ci.meta.DeoptimizationAction;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,54 ***</span>
  /**
   * Provides non-runtime specific {@link InvocationPlugin}s.
   */
  public class StandardGraphBuilderPlugins {
  
<span class="line-modified">!     public static void registerInvocationPlugins(MetaAccessProvider metaAccess, SnippetReflectionProvider snippetReflection, InvocationPlugins plugins, BytecodeProvider bytecodeProvider,</span>
<span class="line-modified">!                     boolean allowDeoptimization, boolean explicitUnsafeNullChecks) {</span>
          registerObjectPlugins(plugins);
          registerClassPlugins(plugins);
          registerMathPlugins(plugins, allowDeoptimization);
          registerStrictMathPlugins(plugins);
          registerUnsignedMathPlugins(plugins);
<span class="line-modified">!         registerStringPlugins(plugins, bytecodeProvider, snippetReflection);</span>
          registerCharacterPlugins(plugins);
          registerShortPlugins(plugins);
          registerIntegerLongPlugins(plugins, JavaKind.Int);
          registerIntegerLongPlugins(plugins, JavaKind.Long);
          registerFloatPlugins(plugins);
          registerDoublePlugins(plugins);
<span class="line-modified">!         registerArraysPlugins(plugins, bytecodeProvider);</span>
<span class="line-modified">!         registerArrayPlugins(plugins, bytecodeProvider);</span>
<span class="line-modified">!         registerUnsafePlugins(plugins, bytecodeProvider, explicitUnsafeNullChecks);</span>
          registerEdgesPlugins(metaAccess, plugins);
          registerGraalDirectivesPlugins(plugins);
          registerBoxingPlugins(plugins);
<span class="line-modified">!         registerJMHBlackholePlugins(plugins, bytecodeProvider);</span>
<span class="line-modified">!         registerJFRThrowablePlugins(plugins, bytecodeProvider);</span>
<span class="line-modified">!         registerMethodHandleImplPlugins(plugins, snippetReflection, bytecodeProvider);</span>
<span class="line-modified">!         registerJcovCollectPlugins(plugins, bytecodeProvider);</span>
      }
  
      private static final Field STRING_VALUE_FIELD;
      private static final Field STRING_CODER_FIELD;
  
      static {
          Field coder = null;
          try {
              STRING_VALUE_FIELD = String.class.getDeclaredField(&quot;value&quot;);
<span class="line-modified">!             if (!Java8OrEarlier) {</span>
                  coder = String.class.getDeclaredField(&quot;coder&quot;);
              }
          } catch (NoSuchFieldException e) {
              throw new GraalError(e);
          }
          STRING_CODER_FIELD = coder;
      }
  
<span class="line-modified">!     private static void registerStringPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider, SnippetReflectionProvider snippetReflection) {</span>
<span class="line-modified">!         final Registration r = new Registration(plugins, String.class, bytecodeProvider);</span>
          r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
                  if (receiver.isConstant()) {
                      String s = snippetReflection.asObject(String.class, (JavaConstant) receiver.get().asConstant());
<span class="line-new-header">--- 153,56 ---</span>
  /**
   * Provides non-runtime specific {@link InvocationPlugin}s.
   */
  public class StandardGraphBuilderPlugins {
  
<span class="line-modified">!     public static void registerInvocationPlugins(MetaAccessProvider metaAccess, SnippetReflectionProvider snippetReflection, InvocationPlugins plugins, Replacements replacements,</span>
<span class="line-modified">!                     boolean allowDeoptimization, boolean explicitUnsafeNullChecks, boolean arrayEqualsSubstitution) {</span>
          registerObjectPlugins(plugins);
          registerClassPlugins(plugins);
          registerMathPlugins(plugins, allowDeoptimization);
          registerStrictMathPlugins(plugins);
          registerUnsignedMathPlugins(plugins);
<span class="line-modified">!         registerStringPlugins(plugins, replacements, snippetReflection, arrayEqualsSubstitution);</span>
          registerCharacterPlugins(plugins);
          registerShortPlugins(plugins);
          registerIntegerLongPlugins(plugins, JavaKind.Int);
          registerIntegerLongPlugins(plugins, JavaKind.Long);
          registerFloatPlugins(plugins);
          registerDoublePlugins(plugins);
<span class="line-modified">!         if (arrayEqualsSubstitution) {</span>
<span class="line-modified">!             registerArraysPlugins(plugins, replacements);</span>
<span class="line-modified">!         }</span>
<span class="line-added">+         registerArrayPlugins(plugins, replacements);</span>
<span class="line-added">+         registerUnsafePlugins(plugins, replacements, explicitUnsafeNullChecks);</span>
          registerEdgesPlugins(metaAccess, plugins);
          registerGraalDirectivesPlugins(plugins);
          registerBoxingPlugins(plugins);
<span class="line-modified">!         registerJMHBlackholePlugins(plugins, replacements);</span>
<span class="line-modified">!         registerJFRThrowablePlugins(plugins, replacements);</span>
<span class="line-modified">!         registerMethodHandleImplPlugins(plugins, snippetReflection, replacements);</span>
<span class="line-modified">!         registerJcovCollectPlugins(plugins, replacements);</span>
      }
  
      private static final Field STRING_VALUE_FIELD;
      private static final Field STRING_CODER_FIELD;
  
      static {
          Field coder = null;
          try {
              STRING_VALUE_FIELD = String.class.getDeclaredField(&quot;value&quot;);
<span class="line-modified">!             if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
                  coder = String.class.getDeclaredField(&quot;coder&quot;);
              }
          } catch (NoSuchFieldException e) {
              throw new GraalError(e);
          }
          STRING_CODER_FIELD = coder;
      }
  
<span class="line-modified">!     private static void registerStringPlugins(InvocationPlugins plugins, Replacements replacements, SnippetReflectionProvider snippetReflection, boolean arrayEqualsSubstitution) {</span>
<span class="line-modified">!         final Registration r = new Registration(plugins, String.class, replacements);</span>
          r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
                  if (receiver.isConstant()) {
                      String s = snippetReflection.asObject(String.class, (JavaConstant) receiver.get().asConstant());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,13 ***</span>
                      }
                  }
                  return false;
              }
          });
  
<span class="line-modified">!         if (Java8OrEarlier) {</span>
<span class="line-modified">!             r.registerMethodSubstitution(StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);</span>
  
              r.register7(&quot;indexOf&quot;, char[].class, int.class, int.class, char[].class, int.class, int.class, int.class, new StringIndexOfConstantPlugin());
  
              Registration sr = new Registration(plugins, StringSubstitutions.class);
              sr.register1(&quot;getValue&quot;, String.class, new InvocationPlugin() {
<span class="line-new-header">--- 212,29 ---</span>
                      }
                  }
                  return false;
              }
          });
<span class="line-added">+         r.register1(&quot;intern&quot;, Receiver.class, new InvocationPlugin() {</span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {</span>
<span class="line-added">+                 if (receiver.isConstant()) {</span>
<span class="line-added">+                     String s = snippetReflection.asObject(String.class, (JavaConstant) receiver.get().asConstant());</span>
<span class="line-added">+                     if (s != null) {</span>
<span class="line-added">+                         JavaConstant interned = snippetReflection.forObject(s.intern());</span>
<span class="line-added">+                         b.addPush(JavaKind.Object, b.add(ConstantNode.forConstant(interned, b.getMetaAccess(), b.getGraph())));</span>
<span class="line-added">+                         return true;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         });</span>
  
<span class="line-modified">!         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
<span class="line-modified">!             if (arrayEqualsSubstitution) {</span>
<span class="line-added">+                 r.registerMethodSubstitution(StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);</span>
<span class="line-added">+             }</span>
  
              r.register7(&quot;indexOf&quot;, char[].class, int.class, int.class, char[].class, int.class, int.class, int.class, new StringIndexOfConstantPlugin());
  
              Registration sr = new Registration(plugins, StringSubstitutions.class);
              sr.register1(&quot;getValue&quot;, String.class, new InvocationPlugin() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,12 ***</span>
                                      b.getOptions(), b.getAssumptions(), value, field, false, false));
                      return true;
                  }
              });
          } else {
<span class="line-modified">!             r.registerMethodSubstitution(JDK9StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);</span>
<span class="line-modified">!             Registration utf16sub = new Registration(plugins, StringUTF16Substitutions.class, bytecodeProvider);</span>
              utf16sub.register2(&quot;getCharDirect&quot;, byte[].class, int.class, new InvocationPlugin() {
                  @Override
                  public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2) {
                      b.addPush(JavaKind.Char, new JavaReadNode(JavaKind.Char, new IndexAddressNode(arg1, arg2, JavaKind.Byte), NamedLocationIdentity.getArrayLocation(JavaKind.Byte),
                                      HeapAccess.BarrierType.NONE, false));
<span class="line-new-header">--- 245,14 ---</span>
                                      b.getOptions(), b.getAssumptions(), value, field, false, false));
                      return true;
                  }
              });
          } else {
<span class="line-modified">!             if (arrayEqualsSubstitution) {</span>
<span class="line-modified">!                 r.registerMethodSubstitution(JDK9StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             Registration utf16sub = new Registration(plugins, StringUTF16Substitutions.class, replacements);</span>
              utf16sub.register2(&quot;getCharDirect&quot;, byte[].class, int.class, new InvocationPlugin() {
                  @Override
                  public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2) {
                      b.addPush(JavaKind.Char, new JavaReadNode(JavaKind.Char, new IndexAddressNode(arg1, arg2, JavaKind.Byte), NamedLocationIdentity.getArrayLocation(JavaKind.Byte),
                                      HeapAccess.BarrierType.NONE, false));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,14 ***</span>
                                      HeapAccess.BarrierType.NONE, false));
                      return true;
                  }
              });
  
<span class="line-modified">!             final Registration latin1r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, bytecodeProvider);</span>
              latin1r.register5(&quot;indexOf&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringLatin1IndexOfConstantPlugin());
  
<span class="line-modified">!             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, bytecodeProvider);</span>
              utf16r.register5(&quot;indexOfUnsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringUTF16IndexOfConstantPlugin());
              utf16r.setAllowOverwrite(true);
              utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChar&quot;, byte[].class, int.class);
              utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;putChar&quot;, byte[].class, int.class, int.class);
  
<span class="line-new-header">--- 266,14 ---</span>
                                      HeapAccess.BarrierType.NONE, false));
                      return true;
                  }
              });
  
<span class="line-modified">!             final Registration latin1r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, replacements);</span>
              latin1r.register5(&quot;indexOf&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringLatin1IndexOfConstantPlugin());
  
<span class="line-modified">!             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);</span>
              utf16r.register5(&quot;indexOfUnsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringUTF16IndexOfConstantPlugin());
              utf16r.setAllowOverwrite(true);
              utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChar&quot;, byte[].class, int.class);
              utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;putChar&quot;, byte[].class, int.class, int.class);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,22 ***</span>
                  }
              });
          }
      }
  
<span class="line-modified">!     private static void registerArraysPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Arrays.class, bytecodeProvider);</span>
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, boolean[].class, boolean[].class);
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, byte[].class, byte[].class);
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, short[].class, short[].class);
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, char[].class, char[].class);
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, int[].class, int[].class);
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, long[].class, long[].class);
      }
  
<span class="line-modified">!     private static void registerArrayPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Array.class, bytecodeProvider);</span>
          r.register2(&quot;newInstance&quot;, Class.class, int.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unused, ValueNode componentType, ValueNode length) {
                  b.addPush(JavaKind.Object, new DynamicNewArrayNode(componentType, length, true));
                  return true;
<span class="line-new-header">--- 297,22 ---</span>
                  }
              });
          }
      }
  
<span class="line-modified">!     private static void registerArraysPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Arrays.class, replacements);</span>
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, boolean[].class, boolean[].class);
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, byte[].class, byte[].class);
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, short[].class, short[].class);
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, char[].class, char[].class);
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, int[].class, int[].class);
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, long[].class, long[].class);
      }
  
<span class="line-modified">!     private static void registerArrayPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Array.class, replacements);</span>
          r.register2(&quot;newInstance&quot;, Class.class, int.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unused, ValueNode componentType, ValueNode length) {
                  b.addPush(JavaKind.Object, new DynamicNewArrayNode(componentType, length, true));
                  return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 366,39 ***</span>
          }
      }
  
      private static UnsafeCompareAndExchangePluginsRegistrar unsafeCompareAndExchangePluginsRegistrar = new UnsafeCompareAndExchangePluginsRegistrar();
  
<span class="line-modified">!     public static void registerPlatformSpecificUnsafePlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider, boolean explicitUnsafeNullChecks, JavaKind[] supportedCasKinds) {</span>
          registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
<span class="line-modified">!         if (!Java8OrEarlier) {</span>
<span class="line-modified">!             registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, bytecodeProvider), false, explicitUnsafeNullChecks);</span>
          }
  
      }
  
      private static void registerPlatformSpecificUnsafePlugins(JavaKind[] supportedCasKinds, Registration r, boolean java8OrEarlier, boolean explicitUnsafeNullChecks) {
          if (java8OrEarlier) {
              unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSwap&quot;, explicitUnsafeNullChecks, new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, true);
          } else {
<span class="line-modified">!             unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSet&quot;, explicitUnsafeNullChecks, supportedCasKinds, Java11OrEarlier);</span>
<span class="line-modified">!             unsafeCompareAndExchangePluginsRegistrar.register(r, &quot;compareAndExchange&quot;, explicitUnsafeNullChecks, supportedCasKinds, Java11OrEarlier);</span>
          }
      }
  
<span class="line-modified">!     private static void registerUnsafePlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider, boolean explicitUnsafeNullChecks) {</span>
          registerUnsafePlugins(new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
<span class="line-modified">!         if (!Java8OrEarlier) {</span>
<span class="line-modified">!             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, bytecodeProvider), false, explicitUnsafeNullChecks);</span>
          }
      }
  
      private static void registerUnsafePlugins(Registration r, boolean sunMiscUnsafe, boolean explicitUnsafeNullChecks) {
          for (JavaKind kind : JavaKind.values()) {
              if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
                  Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
<span class="line-modified">!                 String kindName = (kind == JavaKind.Object &amp;&amp; !sunMiscUnsafe &amp;&amp; !Java11OrEarlier) ? &quot;Reference&quot; : kind.name();</span>
                  String getName = &quot;get&quot; + kindName;
                  String putName = &quot;put&quot; + kindName;
                  // Object-based accesses
                  r.register3(getName, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
                  r.register4(putName, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
<span class="line-new-header">--- 386,39 ---</span>
          }
      }
  
      private static UnsafeCompareAndExchangePluginsRegistrar unsafeCompareAndExchangePluginsRegistrar = new UnsafeCompareAndExchangePluginsRegistrar();
  
<span class="line-modified">!     public static void registerPlatformSpecificUnsafePlugins(InvocationPlugins plugins, Replacements replacements, boolean explicitUnsafeNullChecks, JavaKind[] supportedCasKinds) {</span>
          registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
<span class="line-modified">!         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified">!             registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements), false, explicitUnsafeNullChecks);</span>
          }
  
      }
  
      private static void registerPlatformSpecificUnsafePlugins(JavaKind[] supportedCasKinds, Registration r, boolean java8OrEarlier, boolean explicitUnsafeNullChecks) {
          if (java8OrEarlier) {
              unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSwap&quot;, explicitUnsafeNullChecks, new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, true);
          } else {
<span class="line-modified">!             unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSet&quot;, explicitUnsafeNullChecks, supportedCasKinds, JavaVersionUtil.JAVA_SPEC &lt;= 11);</span>
<span class="line-modified">!             unsafeCompareAndExchangePluginsRegistrar.register(r, &quot;compareAndExchange&quot;, explicitUnsafeNullChecks, supportedCasKinds, JavaVersionUtil.JAVA_SPEC &lt;= 11);</span>
          }
      }
  
<span class="line-modified">!     private static void registerUnsafePlugins(InvocationPlugins plugins, Replacements replacements, boolean explicitUnsafeNullChecks) {</span>
          registerUnsafePlugins(new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
<span class="line-modified">!         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified">!             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements), false, explicitUnsafeNullChecks);</span>
          }
      }
  
      private static void registerUnsafePlugins(Registration r, boolean sunMiscUnsafe, boolean explicitUnsafeNullChecks) {
          for (JavaKind kind : JavaKind.values()) {
              if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
                  Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
<span class="line-modified">!                 String kindName = (kind == JavaKind.Object &amp;&amp; !sunMiscUnsafe &amp;&amp; !(JavaVersionUtil.JAVA_SPEC &lt;= 11)) ? &quot;Reference&quot; : kind.name();</span>
                  String getName = &quot;get&quot; + kindName;
                  String putName = &quot;put&quot; + kindName;
                  // Object-based accesses
                  r.register3(getName, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
                  r.register4(putName, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 820,11 ***</span>
          });
          r.register1(&quot;getClass&quot;, Receiver.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
                  ValueNode object = receiver.get();
<span class="line-modified">!                 ValueNode folded = GetClassNode.tryFold(b.getMetaAccess(), b.getConstantReflection(), NodeView.DEFAULT, GraphUtil.originalValue(object));</span>
                  if (folded != null) {
                      b.addPush(JavaKind.Object, folded);
                  } else {
                      Stamp stamp = StampFactory.objectNonNull(TypeReference.createTrusted(b.getAssumptions(), b.getMetaAccess().lookupJavaType(Class.class)));
                      b.addPush(JavaKind.Object, new GetClassNode(stamp, object));
<span class="line-new-header">--- 840,11 ---</span>
          });
          r.register1(&quot;getClass&quot;, Receiver.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
                  ValueNode object = receiver.get();
<span class="line-modified">!                 ValueNode folded = GetClassNode.tryFold(b.getMetaAccess(), b.getConstantReflection(), NodeView.DEFAULT, GraphUtil.originalValue(object, true));</span>
                  if (folded != null) {
                      b.addPush(JavaKind.Object, folded);
                  } else {
                      Stamp stamp = StampFactory.objectNonNull(TypeReference.createTrusted(b.getAssumptions(), b.getMetaAccess().lookupJavaType(Class.class)));
                      b.addPush(JavaKind.Object, new GetClassNode(stamp, object));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1092,15 ***</span>
<span class="line-new-header">--- 1112,24 ---</span>
              return true;
          }
  
          @Override
          public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset) {
<span class="line-added">+             // Opaque mode does not directly impose any ordering constraints with respect to other</span>
<span class="line-added">+             // variables beyond Plain mode.</span>
<span class="line-added">+             if (accessKind == AccessKind.OPAQUE &amp;&amp; StampTool.isPointerAlwaysNull(object)) {</span>
<span class="line-added">+                 // OFF_HEAP_LOCATION accesses are not floatable =&gt; no membars needed for opaque.</span>
<span class="line-added">+                 return apply(b, targetMethod, unsafe, offset);</span>
<span class="line-added">+             }</span>
              // Emits a null-check for the otherwise unused receiver
              unsafe.get();
              if (accessKind.emitBarriers) {
                  b.add(new MembarNode(accessKind.preReadBarriers));
              }
<span class="line-added">+             // Raw accesses can be turned into floatable field accesses, the membars preserve the</span>
<span class="line-added">+             // access mode. In the case of opaque access, and only for opaque, the location of the</span>
<span class="line-added">+             // wrapping membars can be refined to the field location.</span>
              createUnsafeAccess(object, b, (obj, loc) -&gt; new RawLoadNode(obj, offset, unsafeAccessKind, loc));
              if (accessKind.emitBarriers) {
                  b.add(new MembarNode(accessKind.postReadBarriers));
              }
              return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1129,16 ***</span>
<span class="line-new-header">--- 1158,25 ---</span>
              return true;
          }
  
          @Override
          public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode value) {
<span class="line-added">+             // Opaque mode does not directly impose any ordering constraints with respect to other</span>
<span class="line-added">+             // variables beyond Plain mode.</span>
<span class="line-added">+             if (accessKind == AccessKind.OPAQUE &amp;&amp; StampTool.isPointerAlwaysNull(object)) {</span>
<span class="line-added">+                 // OFF_HEAP_LOCATION accesses are not floatable =&gt; no membars needed for opaque.</span>
<span class="line-added">+                 return apply(b, targetMethod, unsafe, offset, value);</span>
<span class="line-added">+             }</span>
              // Emits a null-check for the otherwise unused receiver
              unsafe.get();
              if (accessKind.emitBarriers) {
                  b.add(new MembarNode(accessKind.preWriteBarriers));
              }
              ValueNode maskedValue = b.maskSubWordValue(value, unsafeAccessKind);
<span class="line-added">+             // Raw accesses can be turned into floatable field accesses, the membars preserve the</span>
<span class="line-added">+             // access mode. In the case of opaque access, and only for opaque, the location of the</span>
<span class="line-added">+             // wrapping membars can be refined to the field location.</span>
              createUnsafeAccess(object, b, (obj, loc) -&gt; new RawStoreNode(obj, offset, maskedValue, unsafeAccessKind, loc));
              if (accessKind.emitBarriers) {
                  b.add(new MembarNode(accessKind.postWriteBarriers));
              }
              return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1212,11 ***</span>
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
                  b.add(new ControlFlowAnchorNode());
                  return true;
              }
          });
<span class="line-modified">! </span>
          r.register2(&quot;injectBranchProbability&quot;, double.class, boolean.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode probability, ValueNode condition) {
                  b.addPush(JavaKind.Boolean, new BranchProbabilityNode(probability, condition));
                  return true;
<span class="line-new-header">--- 1250,24 ---</span>
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
                  b.add(new ControlFlowAnchorNode());
                  return true;
              }
          });
<span class="line-modified">!         r.register0(&quot;sideEffect&quot;, new InvocationPlugin() {</span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {</span>
<span class="line-added">+                 b.add(new SideEffectNode());</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         });</span>
<span class="line-added">+         r.register1(&quot;sideEffect&quot;, int.class, new InvocationPlugin() {</span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode a) {</span>
<span class="line-added">+                 b.addPush(JavaKind.Int, new SideEffectNode(a));</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         });</span>
          r.register2(&quot;injectBranchProbability&quot;, double.class, boolean.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode probability, ValueNode condition) {
                  b.addPush(JavaKind.Boolean, new BranchProbabilityNode(probability, condition));
                  return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1285,11 ***</span>
                  return true;
              }
          });
      }
  
<span class="line-modified">!     private static void registerJMHBlackholePlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
          InvocationPlugin blackholePlugin = new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver blackhole, ValueNode value) {
                  blackhole.get();
                  b.add(new BlackholeNode(value));
<span class="line-new-header">--- 1336,11 ---</span>
                  return true;
              }
          });
      }
  
<span class="line-modified">!     private static void registerJMHBlackholePlugins(InvocationPlugins plugins, Replacements replacements) {</span>
          InvocationPlugin blackholePlugin = new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver blackhole, ValueNode value) {
                  blackhole.get();
                  b.add(new BlackholeNode(value));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1301,23 ***</span>
                  return true;
              }
          };
          String[] names = {&quot;org.openjdk.jmh.infra.Blackhole&quot;, &quot;org.openjdk.jmh.logic.BlackHole&quot;};
          for (String name : names) {
<span class="line-modified">!             Registration r = new Registration(plugins, name, bytecodeProvider);</span>
              for (JavaKind kind : JavaKind.values()) {
                  if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
                      Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
                      r.registerOptional2(&quot;consume&quot;, Receiver.class, javaClass, blackholePlugin);
                  }
              }
              r.registerOptional2(&quot;consume&quot;, Receiver.class, Object[].class, blackholePlugin);
          }
      }
  
<span class="line-modified">!     private static void registerJFRThrowablePlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, &quot;oracle.jrockit.jfr.jdkevents.ThrowableTracer&quot;, bytecodeProvider);</span>
          r.register2(&quot;traceThrowable&quot;, Throwable.class, String.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode throwable, ValueNode message) {
                  b.add(new VirtualizableInvokeMacroNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), throwable, message));
                  return true;
<span class="line-new-header">--- 1352,23 ---</span>
                  return true;
              }
          };
          String[] names = {&quot;org.openjdk.jmh.infra.Blackhole&quot;, &quot;org.openjdk.jmh.logic.BlackHole&quot;};
          for (String name : names) {
<span class="line-modified">!             Registration r = new Registration(plugins, name, replacements);</span>
              for (JavaKind kind : JavaKind.values()) {
                  if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
                      Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
                      r.registerOptional2(&quot;consume&quot;, Receiver.class, javaClass, blackholePlugin);
                  }
              }
              r.registerOptional2(&quot;consume&quot;, Receiver.class, Object[].class, blackholePlugin);
          }
      }
  
<span class="line-modified">!     private static void registerJFRThrowablePlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, &quot;oracle.jrockit.jfr.jdkevents.ThrowableTracer&quot;, replacements);</span>
          r.register2(&quot;traceThrowable&quot;, Throwable.class, String.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode throwable, ValueNode message) {
                  b.add(new VirtualizableInvokeMacroNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), throwable, message));
                  return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1328,12 ***</span>
                  return true;
              }
          });
      }
  
<span class="line-modified">!     private static void registerMethodHandleImplPlugins(InvocationPlugins plugins, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, &quot;java.lang.invoke.MethodHandleImpl&quot;, bytecodeProvider);</span>
          // In later JDKs this no longer exists and the usage is replace by Class.cast which is
          // already an intrinsic
          r.registerOptional2(&quot;castReference&quot;, Class.class, Object.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode javaClass, ValueNode object) {
<span class="line-new-header">--- 1379,12 ---</span>
                  return true;
              }
          });
      }
  
<span class="line-modified">!     private static void registerMethodHandleImplPlugins(InvocationPlugins plugins, SnippetReflectionProvider snippetReflection, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, &quot;java.lang.invoke.MethodHandleImpl&quot;, replacements);</span>
          // In later JDKs this no longer exists and the usage is replace by Class.cast which is
          // already an intrinsic
          r.registerOptional2(&quot;castReference&quot;, Class.class, Object.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode javaClass, ValueNode object) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1393,12 ***</span>
  
      /**
       * Registers a plugin to ignore {@code com.sun.tdk.jcov.runtime.Collect.hit} within an
       * intrinsic.
       */
<span class="line-modified">!     private static void registerJcovCollectPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, &quot;com.sun.tdk.jcov.runtime.Collect&quot;, bytecodeProvider);</span>
          r.register1(&quot;hit&quot;, int.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
                  if (b.parsingIntrinsic()) {
                      return true;
<span class="line-new-header">--- 1444,12 ---</span>
  
      /**
       * Registers a plugin to ignore {@code com.sun.tdk.jcov.runtime.Collect.hit} within an
       * intrinsic.
       */
<span class="line-modified">!     private static void registerJcovCollectPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, &quot;com.sun.tdk.jcov.runtime.Collect&quot;, replacements);</span>
          r.register1(&quot;hit&quot;, int.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
                  if (b.parsingIntrinsic()) {
                      return true;
</pre>
<center><a href="SnippetTemplate.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="arraycopy/ArrayCopyCallNode.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
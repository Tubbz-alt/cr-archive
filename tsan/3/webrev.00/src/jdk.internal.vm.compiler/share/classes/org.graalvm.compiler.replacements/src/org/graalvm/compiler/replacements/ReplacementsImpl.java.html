<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/ReplacementsImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements;
 26 
 27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
 28 import static org.graalvm.compiler.core.common.GraalOptions.UseSnippetGraphCache;
 29 import static org.graalvm.compiler.debug.DebugContext.DEFAULT_LOG_STREAM;
 30 import static org.graalvm.compiler.debug.DebugOptions.DebugStubsAndSnippets;
 31 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
 32 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineIntrinsicsDuringParsing;
 33 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;
 34 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createMethodSubstitutionInlineInfo;
 35 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;
 36 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION;
 37 import static org.graalvm.compiler.phases.common.DeadCodeEliminationPhase.Optionality.Required;
 38 
 39 import java.util.Collections;
 40 import java.util.List;
 41 import java.util.concurrent.ConcurrentHashMap;
 42 import java.util.concurrent.ConcurrentMap;
 43 import java.util.concurrent.atomic.AtomicInteger;
 44 
 45 import jdk.internal.vm.compiler.collections.EconomicMap;
 46 import jdk.internal.vm.compiler.collections.Equivalence;
 47 import org.graalvm.compiler.api.replacements.Fold;
 48 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 49 import org.graalvm.compiler.api.replacements.Snippet;
 50 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 51 import org.graalvm.compiler.api.replacements.SnippetTemplateCache;
 52 import org.graalvm.compiler.bytecode.Bytecode;
 53 import org.graalvm.compiler.bytecode.BytecodeProvider;
 54 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
 55 import org.graalvm.compiler.core.common.CompilationIdentifier;
 56 import org.graalvm.compiler.core.common.GraalOptions;
 57 import org.graalvm.compiler.debug.DebugCloseable;
 58 import org.graalvm.compiler.debug.DebugContext;
 59 import org.graalvm.compiler.debug.DebugContext.Description;
 60 import org.graalvm.compiler.debug.DebugHandlersFactory;
 61 import org.graalvm.compiler.debug.GraalError;
 62 import org.graalvm.compiler.debug.TimerKey;
 63 import org.graalvm.compiler.graph.Node;
 64 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 65 import org.graalvm.compiler.graph.NodeSourcePosition;
 66 import org.graalvm.compiler.java.GraphBuilderPhase;
 67 import org.graalvm.compiler.java.GraphBuilderPhase.Instance;
 68 import org.graalvm.compiler.loop.phases.ConvertDeoptimizeToGuardPhase;
 69 import org.graalvm.compiler.nodes.CallTargetNode;
 70 import org.graalvm.compiler.nodes.Cancellable;
 71 import org.graalvm.compiler.nodes.Invoke;
 72 import org.graalvm.compiler.nodes.StateSplit;
 73 import org.graalvm.compiler.nodes.StructuredGraph;
 74 import org.graalvm.compiler.nodes.ValueNode;
 75 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedInvocationPlugin;
 76 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 77 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 78 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 79 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderPlugin;
 80 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 81 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 82 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 83 import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
 84 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 85 import org.graalvm.compiler.nodes.spi.Replacements;
 86 import org.graalvm.compiler.options.OptionValues;
 87 import org.graalvm.compiler.phases.OptimisticOptimizations;
 88 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 89 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 90 import org.graalvm.compiler.phases.util.Providers;
 91 import org.graalvm.compiler.word.Word;
 92 import org.graalvm.compiler.word.WordOperationPlugin;
 93 
 94 import jdk.vm.ci.code.TargetDescription;
 95 import jdk.vm.ci.meta.MetaAccessProvider;
 96 import jdk.vm.ci.meta.ResolvedJavaMethod;
 97 import jdk.vm.ci.meta.ResolvedJavaType;
 98 
 99 public class ReplacementsImpl implements Replacements, InlineInvokePlugin {
100 
101     @Override
102     public Providers getProviders() {
103         return providers;
104     }
105 
106     public void setProviders(Providers providers) {
107         this.providers = providers.copyWith(this);
108     }
109 
110     protected Providers providers;
111     public final SnippetReflectionProvider snippetReflection;
112     public final TargetDescription target;
113     private GraphBuilderConfiguration.Plugins graphBuilderPlugins;
114     private final DebugHandlersFactory debugHandlersFactory;
115 
116     /**
117      * The preprocessed replacement graphs.
118      */
119     protected final ConcurrentMap&lt;ResolvedJavaMethod, StructuredGraph&gt; graphs;
120 
121     /**
122      * The default {@link BytecodeProvider} to use for accessing the bytecode of a replacement if
123      * the replacement doesn&#39;t provide another {@link BytecodeProvider}.
124      */
125     protected final BytecodeProvider defaultBytecodeProvider;
126 
127     public void setGraphBuilderPlugins(GraphBuilderConfiguration.Plugins plugins) {
128         assert this.graphBuilderPlugins == null;
129         this.graphBuilderPlugins = plugins;
130     }
131 
132     @Override
133     public GraphBuilderConfiguration.Plugins getGraphBuilderPlugins() {
134         return graphBuilderPlugins;
135     }
136 
137     @Override
138     public Class&lt;? extends GraphBuilderPlugin&gt; getIntrinsifyingPlugin(ResolvedJavaMethod method) {
139         if (method.getAnnotation(Node.NodeIntrinsic.class) != null || method.getAnnotation(Fold.class) != null) {
140             return GeneratedInvocationPlugin.class;
141         }
142         if (method.getAnnotation(Word.Operation.class) != null) {
143             return WordOperationPlugin.class;
144         }
145         return null;
146     }
147 
148     private static final int MAX_GRAPH_INLINING_DEPTH = 100; // more than enough
149 
150     /**
151      * Determines whether a given method should be inlined based on whether it has a substitution or
152      * whether the inlining context is already within a substitution.
153      *
154      * @return an object specifying how {@code method} is to be inlined or null if it should not be
155      *         inlined based on substitution related criteria
156      */
157     @Override
158     public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
159         MethodSubstitutionPlugin msPlugin = getMethodSubstitution(method);
160         if (msPlugin != null) {
161             if (b.parsingIntrinsic() || InlineDuringParsing.getValue(b.getOptions()) || InlineIntrinsicsDuringParsing.getValue(b.getOptions())) {
162                 // Forced inlining of intrinsics
163                 return createMethodSubstitutionInlineInfo(method, msPlugin);
164             }
165             return null;
166         }
167         if (b.parsingIntrinsic()) {
168             assert b.getDepth() &lt; MAX_GRAPH_INLINING_DEPTH : &quot;inlining limit exceeded&quot;;
169 
170             // Force inlining when parsing replacements
171             return createIntrinsicInlineInfo(method, defaultBytecodeProvider);
172         } else {
173             assert IS_BUILDING_NATIVE_IMAGE || method.getAnnotation(NodeIntrinsic.class) == null : String.format(&quot;@%s method %s must only be called from within a replacement%n%s&quot;,
174                             NodeIntrinsic.class.getSimpleName(),
175                             method.format(&quot;%h.%n&quot;), b);
176         }
177         return null;
178     }
179 
180     @Override
181     public void notifyNotInlined(GraphBuilderContext b, ResolvedJavaMethod method, Invoke invoke) {
182         if (b.parsingIntrinsic()) {
183             IntrinsicContext intrinsic = b.getIntrinsic();
184             if (!intrinsic.isCallToOriginal(method)) {
185                 Class&lt;? extends GraphBuilderPlugin&gt; pluginClass = getIntrinsifyingPlugin(method);
186                 if (pluginClass != null) {
187                     String methodDesc = method.format(&quot;%H.%n(%p)&quot;);
188                     throw new GraalError(&quot;Call to %s should have been intrinsified by a %s. &quot; +
189                                     &quot;This is typically caused by Eclipse failing to run an annotation &quot; +
190                                     &quot;processor. This can usually be fixed by forcing Eclipse to rebuild &quot; +
191                                     &quot;the source file in which %s is declared&quot;,
192                                     methodDesc, pluginClass.getSimpleName(), methodDesc);
193                 }
194                 throw new GraalError(&quot;All non-recursive calls in the intrinsic %s must be inlined or intrinsified: found call to %s&quot;,
195                                 intrinsic.getIntrinsicMethod().format(&quot;%H.%n(%p)&quot;), method.format(&quot;%h.%n(%p)&quot;));
196             }
197         }
198     }
199 
200     // This map is key&#39;ed by a class name instead of a Class object so that
201     // it is stable across VM executions (in support of replay compilation).
202     private final EconomicMap&lt;String, SnippetTemplateCache&gt; snippetTemplateCache;
203 
204     public ReplacementsImpl(DebugHandlersFactory debugHandlersFactory, Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider,
205                     TargetDescription target) {
206         this.providers = providers.copyWith(this);
207         this.snippetReflection = snippetReflection;
208         this.target = target;
209         this.graphs = new ConcurrentHashMap&lt;&gt;();
210         this.snippetTemplateCache = EconomicMap.create(Equivalence.DEFAULT);
211         this.defaultBytecodeProvider = bytecodeProvider;
212         this.debugHandlersFactory = debugHandlersFactory;
213 
214     }
215 
216     private static final TimerKey SnippetPreparationTime = DebugContext.timer(&quot;SnippetPreparationTime&quot;);
217 
218     private static final AtomicInteger nextDebugContextId = new AtomicInteger();
219 
220     public DebugContext openDebugContext(String idPrefix, ResolvedJavaMethod method, OptionValues options) {
221         if (DebugStubsAndSnippets.getValue(options)) {
222             DebugContext outer = DebugContext.forCurrentThread();
223             Description description = new Description(method, idPrefix + nextDebugContextId.incrementAndGet());
224             List&lt;DebugHandlersFactory&gt; factories = debugHandlersFactory == null ? Collections.emptyList() : Collections.singletonList(debugHandlersFactory);
225             return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, factories);
226         }
227         return DebugContext.disabled(options);
228     }
229 
230     @Override
231     @SuppressWarnings(&quot;try&quot;)
232     public StructuredGraph getSnippet(ResolvedJavaMethod method, ResolvedJavaMethod recursiveEntry, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition,
233                     OptionValues options) {
234         assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
235         assert method.hasBytecodes() : &quot;Snippet must not be abstract or native&quot;;
236 
237         StructuredGraph graph = UseSnippetGraphCache.getValue(options) ? graphs.get(method) : null;
238         if (graph == null || (trackNodeSourcePosition &amp;&amp; !graph.trackNodeSourcePosition())) {
239             try (DebugContext debug = openDebugContext(&quot;Snippet_&quot;, method, options);
240                             DebugCloseable a = SnippetPreparationTime.start(debug)) {
241                 StructuredGraph newGraph = makeGraph(debug, defaultBytecodeProvider, method, args, recursiveEntry, trackNodeSourcePosition, replaceePosition, INLINE_AFTER_PARSING);
242                 DebugContext.counter(&quot;SnippetNodeCount[%#s]&quot;, method).add(newGraph.getDebug(), newGraph.getNodeCount());
243                 if (!UseSnippetGraphCache.getValue(options) || args != null) {
244                     return newGraph;
245                 }
246                 newGraph.freeze();
247                 if (graph != null) {
248                     graphs.replace(method, graph, newGraph);
249                 } else {
250                     graphs.putIfAbsent(method, newGraph);
251                 }
252                 graph = graphs.get(method);
253             }
254         }
255         assert !trackNodeSourcePosition || graph.trackNodeSourcePosition();
256         return graph;
257     }
258 
259     @Override
260     public void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition, OptionValues options) {
261         // No initialization needed as snippet graphs are created on demand in getSnippet
262     }
263 
264     @Override
265     public StructuredGraph getMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, IntrinsicContext.CompilationContext context,
266                     StructuredGraph.AllowAssumptions allowAssumptions, Cancellable cancellable, OptionValues options) {
267         // Method substitutions are parsed by the BytecodeParser.
268         return null;
269     }
270 
271     @Override
272     public void registerMethodSubstitution(MethodSubstitutionPlugin plugin) {
273         // No initialization needed as method substitutions are parsed by the BytecodeParser.
274     }
275 
276     @Override
277     public void registerConditionalPlugin(InvocationPlugin plugin) {
278     }
279 
280     @Override
281     public boolean hasSubstitution(ResolvedJavaMethod method, int invokeBci) {
282         InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
283         return plugin != null &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0);
284     }
285 
286     @Override
287     public BytecodeProvider getDefaultReplacementBytecodeProvider() {
288         return defaultBytecodeProvider;
289     }
290 
291     protected MethodSubstitutionPlugin getMethodSubstitution(ResolvedJavaMethod method) {
292         InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
293         if (plugin instanceof MethodSubstitutionPlugin) {
294             MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;
295             return msPlugin;
296         }
297         return null;
298     }
299 
300     @Override
301     public StructuredGraph getSubstitution(ResolvedJavaMethod method, int invokeBci, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition, OptionValues options) {
302         StructuredGraph result;
303         InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
304         if (plugin != null &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0)) {
305             MetaAccessProvider metaAccess = providers.getMetaAccess();
306             if (plugin instanceof MethodSubstitutionPlugin) {
307                 MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;
308                 ResolvedJavaMethod substitute = msPlugin.getSubstitute(metaAccess);
309                 StructuredGraph graph = UseSnippetGraphCache.getValue(options) ? graphs.get(substitute) : null;
310                 if (graph == null || graph.trackNodeSourcePosition() != trackNodeSourcePosition) {
311                     try (DebugContext debug = openDebugContext(&quot;Substitution_&quot;, method, options)) {
312                         graph = makeGraph(debug, msPlugin.getBytecodeProvider(), substitute, null, method, trackNodeSourcePosition, replaceePosition, INLINE_AFTER_PARSING);
313                         if (!UseSnippetGraphCache.getValue(options)) {
314                             return graph;
315                         }
316                         graph.freeze();
317                         graphs.putIfAbsent(substitute, graph);
318                         graph = graphs.get(substitute);
319                     }
320                 }
321                 assert graph.isFrozen();
322                 result = graph;
323             } else {
324                 Bytecode code = new ResolvedJavaMethodBytecode(method);
325                 try (DebugContext debug = openDebugContext(&quot;Substitution_&quot;, method, options)) {
326                     result = new IntrinsicGraphBuilder(options, debug, providers, code, invokeBci).buildGraph(plugin);
327                 }
328             }
329         } else {
330             result = null;
331         }
332         return result;
333     }
334 
335     @SuppressWarnings(&quot;try&quot;)
336     @Override
337     public StructuredGraph getIntrinsicGraph(ResolvedJavaMethod method, CompilationIdentifier compilationId, DebugContext debug, Cancellable cancellable) {
338         MethodSubstitutionPlugin msPlugin = getMethodSubstitution(method);
339         if (msPlugin != null) {
340             ResolvedJavaMethod substMethod = msPlugin.getSubstitute(providers.getMetaAccess());
341             assert !substMethod.equals(method);
342             BytecodeProvider bytecodeProvider = msPlugin.getBytecodeProvider();
343             // @formatter:off
344             StructuredGraph graph = new StructuredGraph.Builder(debug.getOptions(), debug, StructuredGraph.AllowAssumptions.YES).
345                     method(substMethod).
346                     compilationId(compilationId).
347                     recordInlinedMethods(bytecodeProvider.shouldRecordMethodDependencies()).
348                     setIsSubstitution(true).
349                     build();
350             // @formatter:on
351             try (DebugContext.Scope scope = debug.scope(&quot;GetIntrinsicGraph&quot;, graph)) {
352                 Plugins plugins = new Plugins(getGraphBuilderPlugins());
353                 GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);
354                 IntrinsicContext initialReplacementContext = new IntrinsicContext(method, substMethod, bytecodeProvider, ROOT_COMPILATION);
355                 new GraphBuilderPhase.Instance(providers, config, OptimisticOptimizations.NONE, initialReplacementContext).apply(graph);
356                 assert !graph.isFrozen();
357                 return graph;
358             } catch (Throwable e) {
359                 debug.handle(e);
360             }
361         }
362         return null;
363     }
364 
365     /**
366      * Creates a preprocessed graph for a snippet or method substitution.
367      *
368      * @param bytecodeProvider how to access the bytecode of {@code method}
369      * @param method the snippet or method substitution for which a graph will be created
370      * @param args
371      * @param original the original method if {@code method} is a {@linkplain MethodSubstitution
372      *            substitution} otherwise null
373      * @param trackNodeSourcePosition record source information
374      * @param context
375      *            {@link org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext
376      *            compilation context} for the graph
377      */
378     public StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, ResolvedJavaMethod method, Object[] args, ResolvedJavaMethod original, boolean trackNodeSourcePosition,
379                     NodeSourcePosition replaceePosition, IntrinsicContext.CompilationContext context) {
380         return createGraphMaker(method, original).makeGraph(debug, bytecodeProvider, args, trackNodeSourcePosition, replaceePosition, context);
381     }
382 
383     /**
384      * Creates a preprocessed graph for a snippet or method substitution with a context of .
385      * {@link org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext#INLINE_AFTER_PARSING}
386      * .
387      *
388      *
389      * @param bytecodeProvider how to access the bytecode of {@code method}
390      * @param method the snippet or method substitution for which a graph will be created
391      * @param args
392      * @param original the original method if {@code method} is a {@linkplain MethodSubstitution
393      *            substitution} otherwise null
394      * @param trackNodeSourcePosition record source information
395      */
396     public final StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, ResolvedJavaMethod method, Object[] args, ResolvedJavaMethod original,
397                     boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {
398         return makeGraph(debug, bytecodeProvider, method, args, original, trackNodeSourcePosition, replaceePosition, INLINE_AFTER_PARSING);
399     }
400 
401     /**
402      * Can be overridden to return an object that specializes various parts of graph preprocessing.
403      */
404     protected GraphMaker createGraphMaker(ResolvedJavaMethod substitute, ResolvedJavaMethod original) {
405         return new GraphMaker(this, substitute, original);
406     }
407 
408     /**
409      * Creates and preprocesses a graph for a replacement.
410      */
411     public static class GraphMaker {
412 
413         /** The replacements object that the graphs are created for. */
414         protected final ReplacementsImpl replacements;
415 
416         /**
417          * The method for which a graph is being created.
418          */
419         protected final ResolvedJavaMethod method;
420 
421         /**
422          * The original method which {@link #method} is substituting. Calls to {@link #method} or
423          * {@link #substitutedMethod} will be replaced with a forced inline of
424          * {@link #substitutedMethod}.
425          */
426         protected final ResolvedJavaMethod substitutedMethod;
427 
428         public GraphMaker(ReplacementsImpl replacements, ResolvedJavaMethod substitute, ResolvedJavaMethod substitutedMethod) {
429             this.replacements = replacements;
430             this.method = substitute;
431             this.substitutedMethod = substitutedMethod;
432         }
433 
434         @SuppressWarnings(&quot;try&quot;)
435         public StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition,
436                         IntrinsicContext.CompilationContext context) {
437             try (DebugContext.Scope s = debug.scope(&quot;BuildSnippetGraph&quot;, method)) {
438                 assert method.hasBytecodes() : method;
439                 StructuredGraph graph = buildInitialGraph(debug, bytecodeProvider, method, args, trackNodeSourcePosition, replaceePosition, context);
440 
441                 finalizeGraph(graph);
442 
443                 debug.dump(DebugContext.INFO_LEVEL, graph, &quot;%s: Final&quot;, method.getName());
444 
445                 return graph;
446             } catch (Throwable e) {
447                 throw debug.handle(e);
448             }
449         }
450 
451         /**
452          * Does final processing of a snippet graph.
453          */
454         protected void finalizeGraph(StructuredGraph graph) {
455             if (!GraalOptions.SnippetCounters.getValue(graph.getOptions()) || graph.getNodes().filter(SnippetCounterNode.class).isEmpty()) {
456                 int sideEffectCount = 0;
457                 assert (sideEffectCount = graph.getNodes().filter(e -&gt; hasSideEffect(e)).count()) &gt;= 0;
458                 new ConvertDeoptimizeToGuardPhase().apply(graph, null);
459                 assert sideEffectCount == graph.getNodes().filter(e -&gt; hasSideEffect(e)).count() : &quot;deleted side effecting node&quot;;
460 
461                 new DeadCodeEliminationPhase(Required).apply(graph);
462             } else {
463                 // ConvertDeoptimizeToGuardPhase will eliminate snippet counters on paths
464                 // that terminate in a deopt so we disable it if the graph contains
465                 // snippet counters. The trade off is that we miss out on guard
466                 // coalescing opportunities.
467             }
468         }
469 
470         /**
471          * Filter nodes which have side effects and shouldn&#39;t be deleted from snippets when
472          * converting deoptimizations to guards. Currently this only allows exception constructors
473          * to be eliminated to cover the case when Java assertions are in the inlined code.
474          *
475          * @param node
476          * @return true for nodes that have side effects and are unsafe to delete
477          */
478         private boolean hasSideEffect(Node node) {
479             if (node instanceof StateSplit) {
480                 if (((StateSplit) node).hasSideEffect()) {
481                     if (node instanceof Invoke) {
482                         CallTargetNode callTarget = ((Invoke) node).callTarget();
483                         if (callTarget instanceof MethodCallTargetNode) {
484                             ResolvedJavaMethod targetMethod = ((MethodCallTargetNode) callTarget).targetMethod();
485                             if (targetMethod.isConstructor()) {
486                                 ResolvedJavaType throwableType = replacements.providers.getMetaAccess().lookupJavaType(Throwable.class);
487                                 return !throwableType.isAssignableFrom(targetMethod.getDeclaringClass());
488                             }
489                         }
490                     }
491                     // Not an exception constructor call
492                     return true;
493                 }
494             }
495             // Not a StateSplit
496             return false;
497         }
498 
499         static class EncodedIntrinsicContext extends IntrinsicContext {
500             EncodedIntrinsicContext(ResolvedJavaMethod method, ResolvedJavaMethod intrinsic, BytecodeProvider bytecodeProvider, CompilationContext compilationContext,
501                             boolean allowPartialIntrinsicArgumentMismatch) {
502                 super(method, intrinsic, bytecodeProvider, compilationContext, allowPartialIntrinsicArgumentMismatch);
503             }
504 
505             @Override
506             public boolean isDeferredInvoke(StateSplit stateSplit) {
507                 if (stateSplit instanceof Invoke) {
508                     Invoke invoke = (Invoke) stateSplit;
509                     ResolvedJavaMethod method = invoke.callTarget().targetMethod();
510                     if (method.getAnnotation(Fold.class) != null) {
511                         return true;
512                     }
513                     Node.NodeIntrinsic annotation = method.getAnnotation(Node.NodeIntrinsic.class);
514                     if (annotation != null &amp;&amp; !annotation.hasSideEffect()) {
515                         return true;
516                     }
517                 }
518                 return false;
519             }
520         }
521 
522         /**
523          * Builds the initial graph for a replacement.
524          */
525         @SuppressWarnings(&quot;try&quot;)
526         protected StructuredGraph buildInitialGraph(DebugContext debug, BytecodeProvider bytecodeProvider, final ResolvedJavaMethod methodToParse, Object[] args, boolean trackNodeSourcePosition,
527                         NodeSourcePosition replaceePosition, IntrinsicContext.CompilationContext context) {
528             // @formatter:off
529             // Replacements cannot have optimistic assumptions since they have
530             // to be valid for the entire run of the VM.
531             final StructuredGraph graph = new StructuredGraph.Builder(debug.getOptions(), debug).
532                             method(methodToParse).
533                             trackNodeSourcePosition(trackNodeSourcePosition).
534                             callerContext(replaceePosition).
535                             setIsSubstitution(true).
536                             build();
537             // @formatter:on
538 
539             // Replacements are not user code so they do not participate in unsafe access
540             // tracking
541             graph.disableUnsafeAccessTracking();
542 
543             try (DebugContext.Scope s = debug.scope(&quot;buildInitialGraph&quot;, graph)) {
544                 MetaAccessProvider metaAccess = replacements.providers.getMetaAccess();
545 
546                 Plugins plugins = new Plugins(replacements.graphBuilderPlugins);
547                 GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);
548                 if (args != null) {
549                     plugins.prependParameterPlugin(new ConstantBindingParameterPlugin(args, metaAccess, replacements.snippetReflection));
550                 }
551 
552                 IntrinsicContext initialIntrinsicContext = null;
553                 Snippet snippetAnnotation = method.getAnnotation(Snippet.class);
554                 MethodSubstitution methodAnnotation = method.getAnnotation(MethodSubstitution.class);
555                 if (methodAnnotation == null &amp;&amp; snippetAnnotation == null) {
556                     // Post-parse inlined intrinsic
557                     initialIntrinsicContext = new EncodedIntrinsicContext(substitutedMethod, method, bytecodeProvider, context, false);
558                 } else {
559                     // Snippet
560                     ResolvedJavaMethod original = substitutedMethod != null ? substitutedMethod : method;
561                     initialIntrinsicContext = new EncodedIntrinsicContext(original, method, bytecodeProvider, context,
562                                     snippetAnnotation != null ? snippetAnnotation.allowPartialIntrinsicArgumentMismatch() : true);
563                 }
564 
565                 createGraphBuilder(replacements.providers, config, OptimisticOptimizations.NONE, initialIntrinsicContext).apply(graph);
566 
567                 CanonicalizerPhase.create().apply(graph, replacements.providers);
568             } catch (Throwable e) {
569                 throw debug.handle(e);
570             }
571             return graph;
572         }
573 
574         protected Instance createGraphBuilder(Providers providers, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {
575             return new GraphBuilderPhase.Instance(providers, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);
576         }
577     }
578 
579     @Override
580     public void registerSnippetTemplateCache(SnippetTemplateCache templates) {
581         assert snippetTemplateCache.get(templates.getClass().getName()) == null;
582         snippetTemplateCache.put(templates.getClass().getName(), templates);
583     }
584 
585     @Override
586     public &lt;T extends SnippetTemplateCache&gt; T getSnippetTemplateCache(Class&lt;T&gt; templatesClass) {
587         SnippetTemplateCache ret = snippetTemplateCache.get(templatesClass.getName());
588         return templatesClass.cast(ret);
589     }
590 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/DefaultJavaLoweringProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ConstantStringIndexOfSnippets.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphKit.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/DefaultJavaLoweringProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  29 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_READ;
  30 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_WRITE;
  31 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateReprofile;
  32 import static jdk.vm.ci.meta.DeoptimizationReason.BoundsCheckException;
  33 import static jdk.vm.ci.meta.DeoptimizationReason.NullCheckException;
  34 import static org.graalvm.compiler.core.common.SpeculativeExecutionAttacksMitigations.Options.UseIndexMasking;
  35 import static org.graalvm.compiler.nodes.NamedLocationIdentity.ARRAY_LENGTH_LOCATION;
  36 import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.branchlessMax;
  37 import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.branchlessMin;
  38 import static org.graalvm.compiler.nodes.java.ArrayLengthNode.readArrayLength;
  39 import static org.graalvm.compiler.nodes.util.GraphUtil.skipPiWhileNonNull;
  40 
  41 import java.nio.ByteOrder;
  42 import java.util.ArrayList;
  43 import java.util.BitSet;
  44 import java.util.List;
  45 
  46 import org.graalvm.compiler.api.directives.GraalDirectives;
  47 import org.graalvm.compiler.api.replacements.Snippet;
  48 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;

  49 import org.graalvm.compiler.core.common.LIRKind;
  50 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;

  51 import org.graalvm.compiler.core.common.type.IntegerStamp;
  52 import org.graalvm.compiler.core.common.type.ObjectStamp;
  53 import org.graalvm.compiler.core.common.type.Stamp;
  54 import org.graalvm.compiler.core.common.type.StampFactory;
  55 import org.graalvm.compiler.core.common.type.TypeReference;
  56 import org.graalvm.compiler.debug.DebugCloseable;
  57 import org.graalvm.compiler.debug.DebugHandlersFactory;
  58 import org.graalvm.compiler.debug.GraalError;
  59 import org.graalvm.compiler.graph.Node;
  60 import org.graalvm.compiler.nodeinfo.InputType;
  61 import org.graalvm.compiler.nodes.CompressionNode.CompressionOp;
  62 import org.graalvm.compiler.nodes.ConstantNode;

  63 import org.graalvm.compiler.nodes.FieldLocationIdentity;
  64 import org.graalvm.compiler.nodes.FixedNode;


  65 import org.graalvm.compiler.nodes.LogicNode;

  66 import org.graalvm.compiler.nodes.NamedLocationIdentity;
  67 import org.graalvm.compiler.nodes.NodeView;

  68 import org.graalvm.compiler.nodes.PiNode;
  69 import org.graalvm.compiler.nodes.StructuredGraph;
  70 import org.graalvm.compiler.nodes.ValueNode;

  71 import org.graalvm.compiler.nodes.calc.AddNode;
  72 import org.graalvm.compiler.nodes.calc.ConditionalNode;
  73 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  74 import org.graalvm.compiler.nodes.calc.IntegerConvertNode;
  75 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  76 import org.graalvm.compiler.nodes.calc.IsNullNode;
  77 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
  78 import org.graalvm.compiler.nodes.calc.NarrowNode;
  79 import org.graalvm.compiler.nodes.calc.RightShiftNode;
  80 import org.graalvm.compiler.nodes.calc.SignExtendNode;
  81 import org.graalvm.compiler.nodes.calc.SubNode;
  82 import org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode;
  83 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  84 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
  85 import org.graalvm.compiler.nodes.extended.BoxNode;
  86 import org.graalvm.compiler.nodes.extended.FixedValueAnchorNode;
  87 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  88 import org.graalvm.compiler.nodes.extended.GuardedUnsafeLoadNode;
  89 import org.graalvm.compiler.nodes.extended.GuardingNode;
  90 import org.graalvm.compiler.nodes.extended.JavaReadNode;
  91 import org.graalvm.compiler.nodes.extended.JavaWriteNode;
  92 import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
  93 import org.graalvm.compiler.nodes.extended.LoadHubNode;

  94 import org.graalvm.compiler.nodes.extended.MembarNode;
  95 import org.graalvm.compiler.nodes.extended.RawLoadNode;
  96 import org.graalvm.compiler.nodes.extended.RawStoreNode;
  97 import org.graalvm.compiler.nodes.extended.UnboxNode;
  98 import org.graalvm.compiler.nodes.extended.UnsafeMemoryLoadNode;
  99 import org.graalvm.compiler.nodes.extended.UnsafeMemoryStoreNode;
 100 import org.graalvm.compiler.nodes.java.AbstractNewObjectNode;
 101 import org.graalvm.compiler.nodes.java.AccessIndexedNode;
 102 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 103 import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
 104 import org.graalvm.compiler.nodes.java.FinalFieldBarrierNode;
 105 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 106 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 107 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 108 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 109 import org.graalvm.compiler.nodes.java.LogicCompareAndSwapNode;
 110 import org.graalvm.compiler.nodes.java.LoweredAtomicReadAndWriteNode;
 111 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 112 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 113 import org.graalvm.compiler.nodes.java.NewArrayNode;
 114 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 115 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
 116 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 117 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 118 import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
 119 import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
 120 import org.graalvm.compiler.nodes.java.ValueCompareAndSwapNode;
 121 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
 122 import org.graalvm.compiler.nodes.memory.ReadNode;

 123 import org.graalvm.compiler.nodes.memory.WriteNode;
 124 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 125 import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;
 126 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;

 127 import org.graalvm.compiler.nodes.spi.Lowerable;
 128 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 129 import org.graalvm.compiler.nodes.spi.LoweringTool;
 130 import org.graalvm.compiler.nodes.type.StampTool;
 131 import org.graalvm.compiler.nodes.util.GraphUtil;
 132 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
 133 import org.graalvm.compiler.nodes.virtual.CommitAllocationNode;
 134 import org.graalvm.compiler.nodes.virtual.VirtualArrayNode;
 135 import org.graalvm.compiler.nodes.virtual.VirtualInstanceNode;
 136 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 137 import org.graalvm.compiler.options.OptionValues;
 138 import org.graalvm.compiler.phases.util.Providers;
 139 import org.graalvm.compiler.replacements.SnippetLowerableMemoryNode.SnippetLowering;
 140 import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode;
 141 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode;
 142 import jdk.internal.vm.compiler.word.LocationIdentity;
 143 
 144 import jdk.vm.ci.code.CodeUtil;
 145 import jdk.vm.ci.code.MemoryBarriers;
 146 import jdk.vm.ci.code.TargetDescription;
 147 import jdk.vm.ci.meta.DeoptimizationAction;
 148 import jdk.vm.ci.meta.DeoptimizationReason;

 149 import jdk.vm.ci.meta.JavaKind;
 150 import jdk.vm.ci.meta.MetaAccessProvider;
 151 import jdk.vm.ci.meta.ResolvedJavaField;
 152 import jdk.vm.ci.meta.ResolvedJavaMethod;
 153 import jdk.vm.ci.meta.ResolvedJavaType;
 154 import jdk.vm.ci.meta.SpeculationLog;
 155 
 156 /**
 157  * VM-independent lowerings for standard Java nodes. VM-specific methods are abstract and must be
 158  * implemented by VM-specific subclasses.
 159  */
 160 public abstract class DefaultJavaLoweringProvider implements LoweringProvider {
 161 
 162     protected final MetaAccessProvider metaAccess;
 163     protected final ForeignCallsProvider foreignCalls;
 164     protected final TargetDescription target;
 165     private final boolean useCompressedOops;
 166     private final ResolvedJavaType objectArrayType;
 167 
 168     private BoxingSnippets.Templates boxingSnippets;
</pre>
<hr />
<pre>
 193     @Override
 194     @SuppressWarnings(&quot;try&quot;)
 195     public void lower(Node n, LoweringTool tool) {
 196         assert n instanceof Lowerable;
 197         StructuredGraph graph = (StructuredGraph) n.graph();
 198         try (DebugCloseable context = n.withNodeSourcePosition()) {
 199             if (n instanceof LoadFieldNode) {
 200                 lowerLoadFieldNode((LoadFieldNode) n, tool);
 201             } else if (n instanceof StoreFieldNode) {
 202                 lowerStoreFieldNode((StoreFieldNode) n, tool);
 203             } else if (n instanceof LoadIndexedNode) {
 204                 lowerLoadIndexedNode((LoadIndexedNode) n, tool);
 205             } else if (n instanceof StoreIndexedNode) {
 206                 lowerStoreIndexedNode((StoreIndexedNode) n, tool);
 207             } else if (n instanceof IndexAddressNode) {
 208                 lowerIndexAddressNode((IndexAddressNode) n);
 209             } else if (n instanceof ArrayLengthNode) {
 210                 lowerArrayLengthNode((ArrayLengthNode) n, tool);
 211             } else if (n instanceof LoadHubNode) {
 212                 lowerLoadHubNode((LoadHubNode) n, tool);


 213             } else if (n instanceof LoadArrayComponentHubNode) {
 214                 lowerLoadArrayComponentHubNode((LoadArrayComponentHubNode) n);
 215             } else if (n instanceof MonitorEnterNode) {
 216                 lowerMonitorEnterNode((MonitorEnterNode) n, tool, graph);
 217             } else if (n instanceof UnsafeCompareAndSwapNode) {
 218                 lowerCompareAndSwapNode((UnsafeCompareAndSwapNode) n);
 219             } else if (n instanceof UnsafeCompareAndExchangeNode) {
 220                 lowerCompareAndExchangeNode((UnsafeCompareAndExchangeNode) n);
 221             } else if (n instanceof AtomicReadAndWriteNode) {
 222                 lowerAtomicReadAndWriteNode((AtomicReadAndWriteNode) n);
 223             } else if (n instanceof RawLoadNode) {
 224                 lowerUnsafeLoadNode((RawLoadNode) n, tool);
 225             } else if (n instanceof UnsafeMemoryLoadNode) {
 226                 lowerUnsafeMemoryLoadNode((UnsafeMemoryLoadNode) n);
 227             } else if (n instanceof RawStoreNode) {
 228                 lowerUnsafeStoreNode((RawStoreNode) n);
 229             } else if (n instanceof UnsafeMemoryStoreNode) {
 230                 lowerUnsafeMemoryStoreNode((UnsafeMemoryStoreNode) n);
 231             } else if (n instanceof JavaReadNode) {
 232                 lowerJavaReadNode((JavaReadNode) n);
</pre>
<hr />
<pre>
 369         if (offset &gt;= 0) {
 370             return createOffsetAddress(graph, object, offset);
 371         } else {
 372             return null;
 373         }
 374     }
 375 
 376     protected abstract JavaKind getStorageKind(ResolvedJavaField field);
 377 
 378     protected void lowerLoadFieldNode(LoadFieldNode loadField, LoweringTool tool) {
 379         assert loadField.getStackKind() != JavaKind.Illegal;
 380         StructuredGraph graph = loadField.graph();
 381         ResolvedJavaField field = loadField.field();
 382         ValueNode object = loadField.isStatic() ? staticFieldBase(graph, field) : loadField.object();
 383         object = createNullCheckedValue(object, loadField, tool);
 384         Stamp loadStamp = loadStamp(loadField.stamp(NodeView.DEFAULT), getStorageKind(field));
 385 
 386         AddressNode address = createFieldAddress(graph, object, field);
 387         assert address != null : &quot;Field that is loaded must not be eliminated: &quot; + field.getDeclaringClass().toJavaName(true) + &quot;.&quot; + field.getName();
 388 
<span class="line-modified"> 389         ReadNode memoryRead = graph.add(new ReadNode(address, fieldLocationIdentity(field), loadStamp, fieldLoadBarrierType(field)));</span>





 390         ValueNode readValue = implicitLoadConvert(graph, getStorageKind(field), memoryRead);
 391         loadField.replaceAtUsages(readValue);
 392         graph.replaceFixed(loadField, memoryRead);
 393 
<span class="line-modified"> 394         if (loadField.isVolatile()) {</span>
 395             MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_READ));
 396             graph.addBeforeFixed(memoryRead, preMembar);
 397             MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_READ));
 398             graph.addAfterFixed(memoryRead, postMembar);
 399         }
 400     }
 401 
 402     protected void lowerStoreFieldNode(StoreFieldNode storeField, LoweringTool tool) {
 403         StructuredGraph graph = storeField.graph();
 404         ResolvedJavaField field = storeField.field();
 405         ValueNode object = storeField.isStatic() ? staticFieldBase(graph, field) : storeField.object();
 406         object = createNullCheckedValue(object, storeField, tool);
 407         ValueNode value = implicitStoreConvert(graph, getStorageKind(storeField.field()), storeField.value());
 408         AddressNode address = createFieldAddress(graph, object, field);
 409         assert address != null;
 410 
<span class="line-modified"> 411         WriteNode memoryWrite = graph.add(new WriteNode(address, fieldLocationIdentity(field), value, fieldStoreBarrierType(storeField.field())));</span>
 412         memoryWrite.setStateAfter(storeField.stateAfter());
 413         graph.replaceFixedWithFixed(storeField, memoryWrite);
 414 
<span class="line-modified"> 415         if (storeField.isVolatile()) {</span>
 416             MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_WRITE));
 417             graph.addBeforeFixed(memoryWrite, preMembar);
 418             MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_WRITE));
 419             graph.addAfterFixed(memoryWrite, postMembar);
 420         }
 421     }
 422 
 423     public static final IntegerStamp POSITIVE_ARRAY_INDEX_STAMP = StampFactory.forInteger(32, 0, Integer.MAX_VALUE - 1);
 424 
 425     /**
 426      * Create a PiNode on the index proving that the index is positive. On some platforms this is
 427      * important to allow the index to be used as an int in the address mode.
 428      */
 429     public AddressNode createArrayIndexAddress(StructuredGraph graph, ValueNode array, JavaKind elementKind, ValueNode index, GuardingNode boundsCheck) {
 430         ValueNode positiveIndex = graph.maybeAddOrUnique(PiNode.create(index, POSITIVE_ARRAY_INDEX_STAMP, boundsCheck != null ? boundsCheck.asNode() : null));
 431         return createArrayAddress(graph, array, elementKind, positiveIndex);
 432     }
 433 
 434     public AddressNode createArrayAddress(StructuredGraph graph, ValueNode array, JavaKind elementKind, ValueNode index) {




 435         ValueNode wordIndex;
 436         if (target.wordSize &gt; 4) {
 437             wordIndex = graph.unique(new SignExtendNode(index, target.wordSize * 8));
 438         } else {
 439             assert target.wordSize == 4 : &quot;unsupported word size&quot;;
 440             wordIndex = index;
 441         }
 442 
 443         int shift = CodeUtil.log2(metaAccess.getArrayIndexScale(elementKind));
 444         ValueNode scaledIndex = graph.unique(new LeftShiftNode(wordIndex, ConstantNode.forInt(shift, graph)));
 445 
<span class="line-modified"> 446         int base = metaAccess.getArrayBaseOffset(elementKind);</span>
 447         ValueNode offset = graph.unique(new AddNode(scaledIndex, ConstantNode.forIntegerKind(target.wordJavaKind, base, graph)));
 448 
 449         return graph.unique(new OffsetAddressNode(array, offset));
 450     }
 451 
 452     protected void lowerIndexAddressNode(IndexAddressNode indexAddress) {
<span class="line-modified"> 453         AddressNode lowered = createArrayAddress(indexAddress.graph(), indexAddress.getArray(), indexAddress.getElementKind(), indexAddress.getIndex());</span>
 454         indexAddress.replaceAndDelete(lowered);
 455     }
 456 
 457     protected void lowerLoadIndexedNode(LoadIndexedNode loadIndexed, LoweringTool tool) {
 458         StructuredGraph graph = loadIndexed.graph();
 459         ValueNode array = loadIndexed.array();
 460         array = createNullCheckedValue(array, loadIndexed, tool);
 461         JavaKind elementKind = loadIndexed.elementKind();
 462         Stamp loadStamp = loadStamp(loadIndexed.stamp(NodeView.DEFAULT), elementKind);
 463 
 464         GuardingNode boundsCheck = getBoundsCheck(loadIndexed, array, tool);
 465         ValueNode index = loadIndexed.index();
 466         if (UseIndexMasking.getValue(graph.getOptions())) {
 467             index = proxyIndex(loadIndexed, index, array, tool);
 468         }
 469         AddressNode address = createArrayIndexAddress(graph, array, elementKind, index, boundsCheck);
 470 
 471         ReadNode memoryRead = graph.add(new ReadNode(address, NamedLocationIdentity.getArrayLocation(elementKind), loadStamp, BarrierType.NONE));
 472         memoryRead.setGuard(boundsCheck);
 473         ValueNode readValue = implicitLoadConvert(graph, elementKind, memoryRead);
</pre>
<hr />
<pre>
 496                 ResolvedJavaType elementType = arrayType.getType().getComponentType();
 497                 if (!elementType.isJavaLangObject()) {
 498                     TypeReference typeReference = TypeReference.createTrusted(storeIndexed.graph().getAssumptions(), elementType);
 499                     LogicNode typeTest = graph.addOrUniqueWithInputs(InstanceOfNode.create(typeReference, value));
 500                     condition = LogicNode.or(graph.unique(IsNullNode.create(value)), typeTest, GraalDirectives.UNLIKELY_PROBABILITY);
 501                 }
 502             } else {
 503                 /*
 504                  * The guard on the read hub should be the null check of the array that was
 505                  * introduced earlier.
 506                  */
 507                 ValueNode arrayClass = createReadHub(graph, array, tool);
 508                 ValueNode componentHub = createReadArrayComponentHub(graph, arrayClass, storeIndexed);
 509                 LogicNode typeTest = graph.unique(InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), componentHub, value, false));
 510                 condition = LogicNode.or(graph.unique(IsNullNode.create(value)), typeTest, GraalDirectives.UNLIKELY_PROBABILITY);
 511             }
 512         }
 513 
 514         AddressNode address = createArrayIndexAddress(graph, array, elementKind, storeIndexed.index(), boundsCheck);
 515         WriteNode memoryWrite = graph.add(new WriteNode(address, NamedLocationIdentity.getArrayLocation(elementKind), implicitStoreConvert(graph, elementKind, value),
<span class="line-modified"> 516                         arrayStoreBarrierType(storeIndexed.elementKind())));</span>
 517         memoryWrite.setGuard(boundsCheck);
 518         if (condition != null) {
 519             tool.createGuard(storeIndexed, condition, DeoptimizationReason.ArrayStoreException, DeoptimizationAction.InvalidateReprofile);
 520         }
 521         memoryWrite.setStateAfter(storeIndexed.stateAfter());
 522         graph.replaceFixedWithFixed(storeIndexed, memoryWrite);
 523     }
 524 
 525     protected void lowerArrayLengthNode(ArrayLengthNode arrayLengthNode, LoweringTool tool) {
 526         arrayLengthNode.replaceAtUsages(createReadArrayLength(arrayLengthNode.array(), arrayLengthNode, tool));
 527         StructuredGraph graph = arrayLengthNode.graph();
 528         graph.removeFixed(arrayLengthNode);
 529     }
 530 
 531     /**
 532      * Creates a read node that read the array length and is guarded by a null-check.
 533      *
 534      * The created node is placed before {@code before} in the CFG.
 535      */
 536     protected ReadNode createReadArrayLength(ValueNode array, FixedNode before, LoweringTool tool) {
 537         StructuredGraph graph = array.graph();
 538         ValueNode canonicalArray = this.createNullCheckedValue(skipPiWhileNonNull(array), before, tool);
 539         AddressNode address = createOffsetAddress(graph, canonicalArray, arrayLengthOffset());
 540         ReadNode readArrayLength = graph.add(new ReadNode(address, ARRAY_LENGTH_LOCATION, StampFactory.positiveInt(), BarrierType.NONE));
 541         graph.addBeforeFixed(before, readArrayLength);
 542         return readArrayLength;
 543     }
 544 
 545     protected void lowerLoadHubNode(LoadHubNode loadHub, LoweringTool tool) {
 546         StructuredGraph graph = loadHub.graph();
 547         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
 548             return;
 549         }
 550         if (graph.getGuardsStage().allowsFloatingGuards()) {
 551             return;
 552         }
 553         ValueNode hub = createReadHub(graph, loadHub.getValue(), tool);
 554         loadHub.replaceAtUsagesAndDelete(hub);
 555     }
 556 






























 557     protected void lowerLoadArrayComponentHubNode(LoadArrayComponentHubNode loadHub) {
 558         StructuredGraph graph = loadHub.graph();
 559         ValueNode hub = createReadArrayComponentHub(graph, loadHub.getValue(), loadHub);
 560         graph.replaceFixed(loadHub, hub);
 561     }
 562 
 563     protected void lowerMonitorEnterNode(MonitorEnterNode monitorEnter, LoweringTool tool, StructuredGraph graph) {
 564         ValueNode object = createNullCheckedValue(monitorEnter.object(), monitorEnter, tool);
 565         ValueNode hub = graph.addOrUnique(LoadHubNode.create(object, tool.getStampProvider(), tool.getMetaAccess(), tool.getConstantReflection()));
 566         RawMonitorEnterNode rawMonitorEnter = graph.add(new RawMonitorEnterNode(object, hub, monitorEnter.getMonitorId()));
 567         rawMonitorEnter.setStateBefore(monitorEnter.stateBefore());
 568         rawMonitorEnter.setStateAfter(monitorEnter.stateAfter());
 569         graph.replaceFixedWithFixed(monitorEnter, rawMonitorEnter);
 570     }
 571 
 572     protected void lowerCompareAndSwapNode(UnsafeCompareAndSwapNode cas) {
 573         StructuredGraph graph = cas.graph();
 574         JavaKind valueKind = cas.getValueKind();
 575 
 576         ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
 577         ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
 578 
 579         AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
 580         BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);
<span class="line-modified"> 581         LogicCompareAndSwapNode atomicNode = graph.add(new LogicCompareAndSwapNode(address, cas.getLocationIdentity(), expectedValue, newValue, barrierType));</span>
 582         atomicNode.setStateAfter(cas.stateAfter());
 583         graph.replaceFixedWithFixed(cas, atomicNode);
 584     }
 585 
 586     protected void lowerCompareAndExchangeNode(UnsafeCompareAndExchangeNode cas) {
 587         StructuredGraph graph = cas.graph();
 588         JavaKind valueKind = cas.getValueKind();
 589 
 590         ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
 591         ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
 592 
 593         AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
 594         BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);
<span class="line-modified"> 595         ValueCompareAndSwapNode atomicNode = graph.add(new ValueCompareAndSwapNode(address, expectedValue, newValue, cas.getLocationIdentity(), barrierType));</span>
 596         ValueNode coercedNode = implicitLoadConvert(graph, valueKind, atomicNode, true);
 597         atomicNode.setStateAfter(cas.stateAfter());
 598         cas.replaceAtUsages(coercedNode);
 599         graph.replaceFixedWithFixed(cas, atomicNode);
 600     }
 601 
 602     protected void lowerAtomicReadAndWriteNode(AtomicReadAndWriteNode n) {
 603         StructuredGraph graph = n.graph();
 604         JavaKind valueKind = n.getValueKind();
 605 
 606         ValueNode newValue = implicitStoreConvert(graph, valueKind, n.newValue());
 607 
 608         AddressNode address = graph.unique(new OffsetAddressNode(n.object(), n.offset()));
 609         BarrierType barrierType = guessStoreBarrierType(n.object(), n.newValue());
 610         LIRKind lirAccessKind = LIRKind.fromJavaKind(target.arch, valueKind);
<span class="line-modified"> 611         LoweredAtomicReadAndWriteNode memoryRead = graph.add(new LoweredAtomicReadAndWriteNode(address, n.getLocationIdentity(), newValue, lirAccessKind, barrierType));</span>
 612         memoryRead.setStateAfter(n.stateAfter());
 613 
 614         ValueNode readValue = implicitLoadConvert(graph, valueKind, memoryRead);
 615         n.stateAfter().replaceFirstInput(n, memoryRead);
 616         n.replaceAtUsages(readValue);
 617         graph.replaceFixedWithFixed(n, memoryRead);
 618     }
 619 
 620     /**
 621      * @param tool utility for performing the lowering
 622      */
 623     protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {

 624         StructuredGraph graph = load.graph();
 625         if (load instanceof GuardedUnsafeLoadNode) {
 626             GuardedUnsafeLoadNode guardedLoad = (GuardedUnsafeLoadNode) load;
 627             GuardingNode guard = guardedLoad.getGuard();
 628             if (guard == null) {
 629                 // can float freely if the guard folded away
<span class="line-modified"> 630                 ReadNode memoryRead = createUnsafeRead(graph, load, null);</span>
 631                 memoryRead.setForceFixed(false);
 632                 graph.replaceFixedWithFixed(load, memoryRead);
 633             } else {
 634                 // must be guarded, but flows below the guard
<span class="line-modified"> 635                 ReadNode memoryRead = createUnsafeRead(graph, load, guard);</span>
 636                 graph.replaceFixedWithFixed(load, memoryRead);
 637             }
 638         } else {
 639             // never had a guarding condition so it must be fixed, creation of the read will force
 640             // it to be fixed
<span class="line-modified"> 641             ReadNode memoryRead = createUnsafeRead(graph, load, null);</span>
 642             graph.replaceFixedWithFixed(load, memoryRead);
 643         }
 644     }
 645 
 646     protected AddressNode createUnsafeAddress(StructuredGraph graph, ValueNode object, ValueNode offset) {
 647         if (object.isConstant() &amp;&amp; object.asConstant().isDefaultForKind()) {
 648             return graph.addOrUniqueWithInputs(OffsetAddressNode.create(offset));
 649         } else {
 650             return graph.unique(new OffsetAddressNode(object, offset));
 651         }
 652     }
 653 
<span class="line-modified"> 654     protected ReadNode createUnsafeRead(StructuredGraph graph, RawLoadNode load, GuardingNode guard) {</span>
 655         boolean compressible = load.accessKind() == JavaKind.Object;
 656         JavaKind readKind = load.accessKind();
 657         Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, compressible);
 658         AddressNode address = createUnsafeAddress(graph, load.object(), load.offset());
<span class="line-modified"> 659         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, BarrierType.NONE));</span>
 660         if (guard == null) {
 661             // An unsafe read must not float otherwise it may float above
 662             // a test guaranteeing the read is safe.
 663             memoryRead.setForceFixed(true);
 664         } else {
 665             memoryRead.setGuard(guard);
 666         }
 667         ValueNode readValue = performBooleanCoercionIfNecessary(implicitLoadConvert(graph, readKind, memoryRead, compressible), readKind);
 668         load.replaceAtUsages(readValue);
 669         return memoryRead;
 670     }
 671 
 672     protected void lowerUnsafeMemoryLoadNode(UnsafeMemoryLoadNode load) {
 673         StructuredGraph graph = load.graph();
 674         JavaKind readKind = load.getKind();
 675         assert readKind != JavaKind.Object;
 676         Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, false);
 677         AddressNode address = graph.addOrUniqueWithInputs(OffsetAddressNode.create(load.getAddress()));
 678         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, BarrierType.NONE));
 679         // An unsafe read must not float otherwise it may float above
</pre>
<hr />
<pre>
 682         ValueNode readValue = performBooleanCoercionIfNecessary(implicitLoadConvert(graph, readKind, memoryRead, false), readKind);
 683         load.replaceAtUsages(readValue);
 684         graph.replaceFixedWithFixed(load, memoryRead);
 685     }
 686 
 687     private static ValueNode performBooleanCoercionIfNecessary(ValueNode readValue, JavaKind readKind) {
 688         if (readKind == JavaKind.Boolean) {
 689             StructuredGraph graph = readValue.graph();
 690             IntegerEqualsNode eq = graph.addOrUnique(new IntegerEqualsNode(readValue, ConstantNode.forInt(0, graph)));
 691             return graph.addOrUnique(new ConditionalNode(eq, ConstantNode.forBoolean(false, graph), ConstantNode.forBoolean(true, graph)));
 692         }
 693         return readValue;
 694     }
 695 
 696     protected void lowerUnsafeStoreNode(RawStoreNode store) {
 697         StructuredGraph graph = store.graph();
 698         boolean compressible = store.value().getStackKind() == JavaKind.Object;
 699         JavaKind valueKind = store.accessKind();
 700         ValueNode value = implicitStoreConvert(graph, valueKind, store.value(), compressible);
 701         AddressNode address = createUnsafeAddress(graph, store.object(), store.offset());
<span class="line-modified"> 702         WriteNode write = graph.add(new WriteNode(address, store.getLocationIdentity(), value, unsafeStoreBarrierType(store)));</span>
 703         write.setStateAfter(store.stateAfter());
 704         graph.replaceFixedWithFixed(store, write);
 705     }
 706 
 707     protected void lowerUnsafeMemoryStoreNode(UnsafeMemoryStoreNode store) {
 708         StructuredGraph graph = store.graph();
 709         assert store.getValue().getStackKind() != JavaKind.Object;
 710         JavaKind valueKind = store.getKind();
 711         ValueNode value = implicitStoreConvert(graph, valueKind, store.getValue(), false);
 712         AddressNode address = graph.addOrUniqueWithInputs(OffsetAddressNode.create(store.getAddress()));
<span class="line-modified"> 713         WriteNode write = graph.add(new WriteNode(address, store.getLocationIdentity(), value, BarrierType.NONE));</span>
 714         write.setStateAfter(store.stateAfter());
 715         graph.replaceFixedWithFixed(store, write);
 716     }
 717 
 718     protected void lowerJavaReadNode(JavaReadNode read) {
 719         StructuredGraph graph = read.graph();
 720         JavaKind valueKind = read.getReadKind();
 721         Stamp loadStamp = loadStamp(read.stamp(NodeView.DEFAULT), valueKind, read.isCompressible());
 722 
 723         ReadNode memoryRead = graph.add(new ReadNode(read.getAddress(), read.getLocationIdentity(), loadStamp, read.getBarrierType()));
 724         GuardingNode guard = read.getGuard();
 725         ValueNode readValue = implicitLoadConvert(graph, valueKind, memoryRead, read.isCompressible());
 726         if (guard == null) {
 727             // An unsafe read must not float otherwise it may float above
 728             // a test guaranteeing the read is safe.
 729             memoryRead.setForceFixed(true);
 730         } else {
 731             memoryRead.setGuard(guard);
 732         }
 733         read.replaceAtUsages(readValue);
 734         graph.replaceFixed(read, memoryRead);
 735     }
 736 
 737     protected void lowerJavaWriteNode(JavaWriteNode write) {
 738         StructuredGraph graph = write.graph();
 739         ValueNode value = implicitStoreConvert(graph, write.getWriteKind(), write.value(), write.isCompressible());
<span class="line-modified"> 740         WriteNode memoryWrite = graph.add(new WriteNode(write.getAddress(), write.getLocationIdentity(), value, write.getBarrierType()));</span>
 741         memoryWrite.setStateAfter(write.stateAfter());
 742         graph.replaceFixedWithFixed(write, memoryWrite);
 743         memoryWrite.setGuard(write.getGuard());
 744     }
 745 
 746     @SuppressWarnings(&quot;try&quot;)
 747     protected void lowerCommitAllocationNode(CommitAllocationNode commit, LoweringTool tool) {
 748         StructuredGraph graph = commit.graph();
 749         if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {
 750             List&lt;AbstractNewObjectNode&gt; recursiveLowerings = new ArrayList&lt;&gt;();
 751 
 752             ValueNode[] allocations = new ValueNode[commit.getVirtualObjects().size()];
 753             BitSet omittedValues = new BitSet();
 754             int valuePos = 0;
 755             for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 756                 VirtualObjectNode virtual = commit.getVirtualObjects().get(objIndex);
 757                 try (DebugCloseable nsp = graph.withNodeSourcePosition(virtual)) {
 758                     int entryCount = virtual.entryCount();
 759                     AbstractNewObjectNode newObject;
 760                     if (virtual instanceof VirtualInstanceNode) {
 761                         newObject = graph.add(createNewInstanceFromVirtual(virtual));
 762                     } else {
 763                         newObject = graph.add(createNewArrayFromVirtual(virtual, ConstantNode.forInt(entryCount, graph)));
 764                     }


 765 
 766                     recursiveLowerings.add(newObject);
 767                     graph.addBeforeFixed(commit, newObject);
 768                     allocations[objIndex] = newObject;
 769                     for (int i = 0; i &lt; entryCount; i++) {
 770                         ValueNode value = commit.getValues().get(valuePos);
 771                         if (value instanceof VirtualObjectNode) {
 772                             value = allocations[commit.getVirtualObjects().indexOf(value)];
 773                         }
 774                         if (value == null) {
 775                             omittedValues.set(valuePos);
 776                         } else if (!(value.isConstant() &amp;&amp; value.asConstant().isDefaultForKind())) {
 777                             // Constant.illegal is always the defaultForKind, so it is skipped
 778                             JavaKind valueKind = value.getStackKind();
 779                             JavaKind entryKind = virtual.entryKind(i);
 780 
 781                             // Truffle requires some leniency in terms of what can be put where:
 782                             assert valueKind.getStackKind() == entryKind.getStackKind() ||
 783                                             (valueKind == JavaKind.Long || valueKind == JavaKind.Double || (valueKind == JavaKind.Int &amp;&amp; virtual instanceof VirtualArrayNode));
 784                             AddressNode address = null;
 785                             BarrierType barrierType = null;
 786                             if (virtual instanceof VirtualInstanceNode) {
 787                                 ResolvedJavaField field = ((VirtualInstanceNode) virtual).field(i);
 788                                 long offset = fieldOffset(field);
 789                                 if (offset &gt;= 0) {
 790                                     address = createOffsetAddress(graph, newObject, offset);
 791                                     barrierType = fieldInitializationBarrier(entryKind);
 792                                 }
 793                             } else {
 794                                 address = createOffsetAddress(graph, newObject, metaAccess.getArrayBaseOffset(entryKind) + i * metaAccess.getArrayIndexScale(entryKind));
 795                                 barrierType = arrayInitializationBarrier(entryKind);
 796                             }
 797                             if (address != null) {
<span class="line-modified"> 798                                 WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, entryKind, value), barrierType);</span>
 799                                 graph.addAfterFixed(newObject, graph.add(write));
 800                             }
 801                         }
 802                         valuePos++;
 803                     }
 804                 }
 805             }
 806             valuePos = 0;
 807 
 808             for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 809                 VirtualObjectNode virtual = commit.getVirtualObjects().get(objIndex);
 810                 try (DebugCloseable nsp = graph.withNodeSourcePosition(virtual)) {
 811                     int entryCount = virtual.entryCount();
 812                     ValueNode newObject = allocations[objIndex];
 813                     for (int i = 0; i &lt; entryCount; i++) {
 814                         if (omittedValues.get(valuePos)) {
 815                             ValueNode value = commit.getValues().get(valuePos);
 816                             assert value instanceof VirtualObjectNode;
 817                             ValueNode allocValue = allocations[commit.getVirtualObjects().indexOf(value)];
 818                             if (!(allocValue.isConstant() &amp;&amp; allocValue.asConstant().isDefaultForKind())) {
 819                                 assert virtual.entryKind(i) == JavaKind.Object &amp;&amp; allocValue.getStackKind() == JavaKind.Object;
 820                                 AddressNode address;
 821                                 BarrierType barrierType;
 822                                 if (virtual instanceof VirtualInstanceNode) {
 823                                     VirtualInstanceNode virtualInstance = (VirtualInstanceNode) virtual;
 824                                     address = createFieldAddress(graph, newObject, virtualInstance.field(i));
<span class="line-modified"> 825                                     barrierType = BarrierType.IMPRECISE;</span>
 826                                 } else {
 827                                     address = createArrayAddress(graph, newObject, virtual.entryKind(i), ConstantNode.forInt(i, graph));
<span class="line-modified"> 828                                     barrierType = BarrierType.PRECISE;</span>
 829                                 }
 830                                 if (address != null) {
<span class="line-modified"> 831                                     WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, JavaKind.Object, allocValue), barrierType);</span>
 832                                     graph.addBeforeFixed(commit, graph.add(write));
 833                                 }
 834                             }
 835                         }
 836                         valuePos++;
 837                     }
 838                 }
 839             }
 840 
 841             finishAllocatedObjects(tool, commit, allocations);
 842             graph.removeFixed(commit);
 843 
 844             for (AbstractNewObjectNode recursiveLowering : recursiveLowerings) {
 845                 recursiveLowering.lower(tool);
 846             }
 847         }
 848 
 849     }
 850 
 851     public NewInstanceNode createNewInstanceFromVirtual(VirtualObjectNode virtual) {
</pre>
<hr />
<pre>
 922         int barrier = MemoryBarriers.STORE_STORE;
 923         outer: for (VirtualObjectNode vobj : commit.getVirtualObjects()) {
 924             for (ResolvedJavaField field : vobj.type().getInstanceFields(true)) {
 925                 if (field.isFinal()) {
 926                     barrier = barrier | MemoryBarriers.LOAD_STORE;
 927                     break outer;
 928                 }
 929             }
 930         }
 931         graph.addAfterFixed(commit, graph.add(new MembarNode(barrier, LocationIdentity.init())));
 932     }
 933 
 934     /**
 935      * @param field the field whose barrier type should be returned
 936      */
 937     protected BarrierType fieldLoadBarrierType(ResolvedJavaField field) {
 938         return BarrierType.NONE;
 939     }
 940 
 941     protected BarrierType fieldStoreBarrierType(ResolvedJavaField field) {
<span class="line-modified"> 942         if (field.getJavaKind() == JavaKind.Object) {</span>
<span class="line-modified"> 943             return BarrierType.IMPRECISE;</span>
 944         }
 945         return BarrierType.NONE;
 946     }
 947 
 948     protected BarrierType arrayStoreBarrierType(JavaKind elementKind) {
 949         if (elementKind == JavaKind.Object) {
<span class="line-modified"> 950             return BarrierType.PRECISE;</span>
 951         }
 952         return BarrierType.NONE;
 953     }
 954 
 955     public BarrierType fieldInitializationBarrier(JavaKind entryKind) {
<span class="line-modified"> 956         return entryKind == JavaKind.Object ? BarrierType.IMPRECISE : BarrierType.NONE;</span>
 957     }
 958 
 959     public BarrierType arrayInitializationBarrier(JavaKind entryKind) {
<span class="line-modified"> 960         return entryKind == JavaKind.Object ? BarrierType.PRECISE : BarrierType.NONE;</span>
 961     }
 962 
 963     private BarrierType unsafeStoreBarrierType(RawStoreNode store) {
 964         if (!store.needsBarrier()) {
 965             return BarrierType.NONE;
 966         }
 967         return guessStoreBarrierType(store.object(), store.value());
 968     }
 969 
 970     private BarrierType guessStoreBarrierType(ValueNode object, ValueNode value) {
 971         if (value.getStackKind() == JavaKind.Object &amp;&amp; object.getStackKind() == JavaKind.Object) {
 972             ResolvedJavaType type = StampTool.typeOrNull(object);
 973             // Array types must use a precise barrier, so if the type is unknown or is a supertype
 974             // of Object[] then treat it as an array.
<span class="line-modified"> 975             if (type == null || type.isArray() || type.isAssignableFrom(objectArrayType)) {</span>
<span class="line-modified"> 976                 return BarrierType.PRECISE;</span>


 977             } else {
<span class="line-modified"> 978                 return BarrierType.IMPRECISE;</span>
 979             }
 980         }
 981         return BarrierType.NONE;
 982     }
 983 
 984     public abstract int fieldOffset(ResolvedJavaField field);
 985 
 986     public FieldLocationIdentity fieldLocationIdentity(ResolvedJavaField field) {
 987         return new FieldLocationIdentity(field);
 988     }
 989 
 990     public abstract ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField field);
 991 
 992     public abstract int arrayLengthOffset();
 993 
 994     public Stamp loadStamp(Stamp stamp, JavaKind kind) {
 995         return loadStamp(stamp, kind, true);
 996     }
 997 
 998     private boolean useCompressedOops(JavaKind kind, boolean compressible) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  29 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_READ;
  30 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_WRITE;
  31 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateReprofile;
  32 import static jdk.vm.ci.meta.DeoptimizationReason.BoundsCheckException;
  33 import static jdk.vm.ci.meta.DeoptimizationReason.NullCheckException;
  34 import static org.graalvm.compiler.core.common.SpeculativeExecutionAttacksMitigations.Options.UseIndexMasking;
  35 import static org.graalvm.compiler.nodes.NamedLocationIdentity.ARRAY_LENGTH_LOCATION;
  36 import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.branchlessMax;
  37 import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.branchlessMin;
  38 import static org.graalvm.compiler.nodes.java.ArrayLengthNode.readArrayLength;
  39 import static org.graalvm.compiler.nodes.util.GraphUtil.skipPiWhileNonNull;
  40 
  41 import java.nio.ByteOrder;
  42 import java.util.ArrayList;
  43 import java.util.BitSet;
  44 import java.util.List;
  45 
  46 import org.graalvm.compiler.api.directives.GraalDirectives;
  47 import org.graalvm.compiler.api.replacements.Snippet;
  48 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
<span class="line-added">  49 import org.graalvm.compiler.core.common.GraalOptions;</span>
  50 import org.graalvm.compiler.core.common.LIRKind;
  51 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
<span class="line-added">  52 import org.graalvm.compiler.core.common.type.AbstractPointerStamp;</span>
  53 import org.graalvm.compiler.core.common.type.IntegerStamp;
  54 import org.graalvm.compiler.core.common.type.ObjectStamp;
  55 import org.graalvm.compiler.core.common.type.Stamp;
  56 import org.graalvm.compiler.core.common.type.StampFactory;
  57 import org.graalvm.compiler.core.common.type.TypeReference;
  58 import org.graalvm.compiler.debug.DebugCloseable;
  59 import org.graalvm.compiler.debug.DebugHandlersFactory;
  60 import org.graalvm.compiler.debug.GraalError;
  61 import org.graalvm.compiler.graph.Node;
  62 import org.graalvm.compiler.nodeinfo.InputType;
  63 import org.graalvm.compiler.nodes.CompressionNode.CompressionOp;
  64 import org.graalvm.compiler.nodes.ConstantNode;
<span class="line-added">  65 import org.graalvm.compiler.nodes.EndNode;</span>
  66 import org.graalvm.compiler.nodes.FieldLocationIdentity;
  67 import org.graalvm.compiler.nodes.FixedNode;
<span class="line-added">  68 import org.graalvm.compiler.nodes.FixedWithNextNode;</span>
<span class="line-added">  69 import org.graalvm.compiler.nodes.IfNode;</span>
  70 import org.graalvm.compiler.nodes.LogicNode;
<span class="line-added">  71 import org.graalvm.compiler.nodes.MergeNode;</span>
  72 import org.graalvm.compiler.nodes.NamedLocationIdentity;
  73 import org.graalvm.compiler.nodes.NodeView;
<span class="line-added">  74 import org.graalvm.compiler.nodes.PhiNode;</span>
  75 import org.graalvm.compiler.nodes.PiNode;
  76 import org.graalvm.compiler.nodes.StructuredGraph;
  77 import org.graalvm.compiler.nodes.ValueNode;
<span class="line-added">  78 import org.graalvm.compiler.nodes.ValuePhiNode;</span>
  79 import org.graalvm.compiler.nodes.calc.AddNode;
  80 import org.graalvm.compiler.nodes.calc.ConditionalNode;
  81 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  82 import org.graalvm.compiler.nodes.calc.IntegerConvertNode;
  83 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  84 import org.graalvm.compiler.nodes.calc.IsNullNode;
  85 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
  86 import org.graalvm.compiler.nodes.calc.NarrowNode;
  87 import org.graalvm.compiler.nodes.calc.RightShiftNode;
  88 import org.graalvm.compiler.nodes.calc.SignExtendNode;
  89 import org.graalvm.compiler.nodes.calc.SubNode;
  90 import org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode;
  91 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  92 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
  93 import org.graalvm.compiler.nodes.extended.BoxNode;
  94 import org.graalvm.compiler.nodes.extended.FixedValueAnchorNode;
  95 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  96 import org.graalvm.compiler.nodes.extended.GuardedUnsafeLoadNode;
  97 import org.graalvm.compiler.nodes.extended.GuardingNode;
  98 import org.graalvm.compiler.nodes.extended.JavaReadNode;
  99 import org.graalvm.compiler.nodes.extended.JavaWriteNode;
 100 import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
 101 import org.graalvm.compiler.nodes.extended.LoadHubNode;
<span class="line-added"> 102 import org.graalvm.compiler.nodes.extended.LoadHubOrNullNode;</span>
 103 import org.graalvm.compiler.nodes.extended.MembarNode;
 104 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 105 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 106 import org.graalvm.compiler.nodes.extended.UnboxNode;
 107 import org.graalvm.compiler.nodes.extended.UnsafeMemoryLoadNode;
 108 import org.graalvm.compiler.nodes.extended.UnsafeMemoryStoreNode;
 109 import org.graalvm.compiler.nodes.java.AbstractNewObjectNode;
 110 import org.graalvm.compiler.nodes.java.AccessIndexedNode;
 111 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 112 import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
 113 import org.graalvm.compiler.nodes.java.FinalFieldBarrierNode;
 114 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 115 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 116 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 117 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 118 import org.graalvm.compiler.nodes.java.LogicCompareAndSwapNode;
 119 import org.graalvm.compiler.nodes.java.LoweredAtomicReadAndWriteNode;
 120 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 121 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 122 import org.graalvm.compiler.nodes.java.NewArrayNode;
 123 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 124 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
 125 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 126 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 127 import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
 128 import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
 129 import org.graalvm.compiler.nodes.java.ValueCompareAndSwapNode;
 130 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
 131 import org.graalvm.compiler.nodes.memory.ReadNode;
<span class="line-added"> 132 import org.graalvm.compiler.nodes.memory.VolatileReadNode;</span>
 133 import org.graalvm.compiler.nodes.memory.WriteNode;
 134 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 135 import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;
 136 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<span class="line-added"> 137 import org.graalvm.compiler.nodes.spi.GCProvider;</span>
 138 import org.graalvm.compiler.nodes.spi.Lowerable;
 139 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 140 import org.graalvm.compiler.nodes.spi.LoweringTool;
 141 import org.graalvm.compiler.nodes.type.StampTool;
 142 import org.graalvm.compiler.nodes.util.GraphUtil;
 143 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
 144 import org.graalvm.compiler.nodes.virtual.CommitAllocationNode;
 145 import org.graalvm.compiler.nodes.virtual.VirtualArrayNode;
 146 import org.graalvm.compiler.nodes.virtual.VirtualInstanceNode;
 147 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 148 import org.graalvm.compiler.options.OptionValues;
 149 import org.graalvm.compiler.phases.util.Providers;
 150 import org.graalvm.compiler.replacements.SnippetLowerableMemoryNode.SnippetLowering;
 151 import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode;
 152 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode;
 153 import jdk.internal.vm.compiler.word.LocationIdentity;
 154 
 155 import jdk.vm.ci.code.CodeUtil;
 156 import jdk.vm.ci.code.MemoryBarriers;
 157 import jdk.vm.ci.code.TargetDescription;
 158 import jdk.vm.ci.meta.DeoptimizationAction;
 159 import jdk.vm.ci.meta.DeoptimizationReason;
<span class="line-added"> 160 import jdk.vm.ci.meta.JavaConstant;</span>
 161 import jdk.vm.ci.meta.JavaKind;
 162 import jdk.vm.ci.meta.MetaAccessProvider;
 163 import jdk.vm.ci.meta.ResolvedJavaField;
 164 import jdk.vm.ci.meta.ResolvedJavaMethod;
 165 import jdk.vm.ci.meta.ResolvedJavaType;
 166 import jdk.vm.ci.meta.SpeculationLog;
 167 
 168 /**
 169  * VM-independent lowerings for standard Java nodes. VM-specific methods are abstract and must be
 170  * implemented by VM-specific subclasses.
 171  */
 172 public abstract class DefaultJavaLoweringProvider implements LoweringProvider {
 173 
 174     protected final MetaAccessProvider metaAccess;
 175     protected final ForeignCallsProvider foreignCalls;
 176     protected final TargetDescription target;
 177     private final boolean useCompressedOops;
 178     private final ResolvedJavaType objectArrayType;
 179 
 180     private BoxingSnippets.Templates boxingSnippets;
</pre>
<hr />
<pre>
 205     @Override
 206     @SuppressWarnings(&quot;try&quot;)
 207     public void lower(Node n, LoweringTool tool) {
 208         assert n instanceof Lowerable;
 209         StructuredGraph graph = (StructuredGraph) n.graph();
 210         try (DebugCloseable context = n.withNodeSourcePosition()) {
 211             if (n instanceof LoadFieldNode) {
 212                 lowerLoadFieldNode((LoadFieldNode) n, tool);
 213             } else if (n instanceof StoreFieldNode) {
 214                 lowerStoreFieldNode((StoreFieldNode) n, tool);
 215             } else if (n instanceof LoadIndexedNode) {
 216                 lowerLoadIndexedNode((LoadIndexedNode) n, tool);
 217             } else if (n instanceof StoreIndexedNode) {
 218                 lowerStoreIndexedNode((StoreIndexedNode) n, tool);
 219             } else if (n instanceof IndexAddressNode) {
 220                 lowerIndexAddressNode((IndexAddressNode) n);
 221             } else if (n instanceof ArrayLengthNode) {
 222                 lowerArrayLengthNode((ArrayLengthNode) n, tool);
 223             } else if (n instanceof LoadHubNode) {
 224                 lowerLoadHubNode((LoadHubNode) n, tool);
<span class="line-added"> 225             } else if (n instanceof LoadHubOrNullNode) {</span>
<span class="line-added"> 226                 lowerLoadHubOrNullNode((LoadHubOrNullNode) n, tool);</span>
 227             } else if (n instanceof LoadArrayComponentHubNode) {
 228                 lowerLoadArrayComponentHubNode((LoadArrayComponentHubNode) n);
 229             } else if (n instanceof MonitorEnterNode) {
 230                 lowerMonitorEnterNode((MonitorEnterNode) n, tool, graph);
 231             } else if (n instanceof UnsafeCompareAndSwapNode) {
 232                 lowerCompareAndSwapNode((UnsafeCompareAndSwapNode) n);
 233             } else if (n instanceof UnsafeCompareAndExchangeNode) {
 234                 lowerCompareAndExchangeNode((UnsafeCompareAndExchangeNode) n);
 235             } else if (n instanceof AtomicReadAndWriteNode) {
 236                 lowerAtomicReadAndWriteNode((AtomicReadAndWriteNode) n);
 237             } else if (n instanceof RawLoadNode) {
 238                 lowerUnsafeLoadNode((RawLoadNode) n, tool);
 239             } else if (n instanceof UnsafeMemoryLoadNode) {
 240                 lowerUnsafeMemoryLoadNode((UnsafeMemoryLoadNode) n);
 241             } else if (n instanceof RawStoreNode) {
 242                 lowerUnsafeStoreNode((RawStoreNode) n);
 243             } else if (n instanceof UnsafeMemoryStoreNode) {
 244                 lowerUnsafeMemoryStoreNode((UnsafeMemoryStoreNode) n);
 245             } else if (n instanceof JavaReadNode) {
 246                 lowerJavaReadNode((JavaReadNode) n);
</pre>
<hr />
<pre>
 383         if (offset &gt;= 0) {
 384             return createOffsetAddress(graph, object, offset);
 385         } else {
 386             return null;
 387         }
 388     }
 389 
 390     protected abstract JavaKind getStorageKind(ResolvedJavaField field);
 391 
 392     protected void lowerLoadFieldNode(LoadFieldNode loadField, LoweringTool tool) {
 393         assert loadField.getStackKind() != JavaKind.Illegal;
 394         StructuredGraph graph = loadField.graph();
 395         ResolvedJavaField field = loadField.field();
 396         ValueNode object = loadField.isStatic() ? staticFieldBase(graph, field) : loadField.object();
 397         object = createNullCheckedValue(object, loadField, tool);
 398         Stamp loadStamp = loadStamp(loadField.stamp(NodeView.DEFAULT), getStorageKind(field));
 399 
 400         AddressNode address = createFieldAddress(graph, object, field);
 401         assert address != null : &quot;Field that is loaded must not be eliminated: &quot; + field.getDeclaringClass().toJavaName(true) + &quot;.&quot; + field.getName();
 402 
<span class="line-modified"> 403         ReadNode memoryRead = null;</span>
<span class="line-added"> 404         if (loadField.isVolatile() &amp;&amp; GraalOptions.LateMembars.getValue(graph.getOptions())) {</span>
<span class="line-added"> 405             memoryRead = graph.add(new VolatileReadNode(address, fieldLocationIdentity(field), loadStamp, fieldLoadBarrierType(field)));</span>
<span class="line-added"> 406         } else {</span>
<span class="line-added"> 407             memoryRead = graph.add(new ReadNode(address, fieldLocationIdentity(field), loadStamp, fieldLoadBarrierType(field)));</span>
<span class="line-added"> 408         }</span>
 409         ValueNode readValue = implicitLoadConvert(graph, getStorageKind(field), memoryRead);
 410         loadField.replaceAtUsages(readValue);
 411         graph.replaceFixed(loadField, memoryRead);
 412 
<span class="line-modified"> 413         if (loadField.isVolatile() &amp;&amp; !GraalOptions.LateMembars.getValue(graph.getOptions())) {</span>
 414             MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_READ));
 415             graph.addBeforeFixed(memoryRead, preMembar);
 416             MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_READ));
 417             graph.addAfterFixed(memoryRead, postMembar);
 418         }
 419     }
 420 
 421     protected void lowerStoreFieldNode(StoreFieldNode storeField, LoweringTool tool) {
 422         StructuredGraph graph = storeField.graph();
 423         ResolvedJavaField field = storeField.field();
 424         ValueNode object = storeField.isStatic() ? staticFieldBase(graph, field) : storeField.object();
 425         object = createNullCheckedValue(object, storeField, tool);
 426         ValueNode value = implicitStoreConvert(graph, getStorageKind(storeField.field()), storeField.value());
 427         AddressNode address = createFieldAddress(graph, object, field);
 428         assert address != null;
 429 
<span class="line-modified"> 430         WriteNode memoryWrite = graph.add(new WriteNode(address, fieldLocationIdentity(field), value, fieldStoreBarrierType(storeField.field()), storeField.isVolatile()));</span>
 431         memoryWrite.setStateAfter(storeField.stateAfter());
 432         graph.replaceFixedWithFixed(storeField, memoryWrite);
 433 
<span class="line-modified"> 434         if (storeField.isVolatile() &amp;&amp; !GraalOptions.LateMembars.getValue(graph.getOptions())) {</span>
 435             MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_WRITE));
 436             graph.addBeforeFixed(memoryWrite, preMembar);
 437             MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_WRITE));
 438             graph.addAfterFixed(memoryWrite, postMembar);
 439         }
 440     }
 441 
 442     public static final IntegerStamp POSITIVE_ARRAY_INDEX_STAMP = StampFactory.forInteger(32, 0, Integer.MAX_VALUE - 1);
 443 
 444     /**
 445      * Create a PiNode on the index proving that the index is positive. On some platforms this is
 446      * important to allow the index to be used as an int in the address mode.
 447      */
 448     public AddressNode createArrayIndexAddress(StructuredGraph graph, ValueNode array, JavaKind elementKind, ValueNode index, GuardingNode boundsCheck) {
 449         ValueNode positiveIndex = graph.maybeAddOrUnique(PiNode.create(index, POSITIVE_ARRAY_INDEX_STAMP, boundsCheck != null ? boundsCheck.asNode() : null));
 450         return createArrayAddress(graph, array, elementKind, positiveIndex);
 451     }
 452 
 453     public AddressNode createArrayAddress(StructuredGraph graph, ValueNode array, JavaKind elementKind, ValueNode index) {
<span class="line-added"> 454         return createArrayAddress(graph, array, elementKind, elementKind, index);</span>
<span class="line-added"> 455     }</span>
<span class="line-added"> 456 </span>
<span class="line-added"> 457     public AddressNode createArrayAddress(StructuredGraph graph, ValueNode array, JavaKind arrayKind, JavaKind elementKind, ValueNode index) {</span>
 458         ValueNode wordIndex;
 459         if (target.wordSize &gt; 4) {
 460             wordIndex = graph.unique(new SignExtendNode(index, target.wordSize * 8));
 461         } else {
 462             assert target.wordSize == 4 : &quot;unsupported word size&quot;;
 463             wordIndex = index;
 464         }
 465 
 466         int shift = CodeUtil.log2(metaAccess.getArrayIndexScale(elementKind));
 467         ValueNode scaledIndex = graph.unique(new LeftShiftNode(wordIndex, ConstantNode.forInt(shift, graph)));
 468 
<span class="line-modified"> 469         int base = metaAccess.getArrayBaseOffset(arrayKind);</span>
 470         ValueNode offset = graph.unique(new AddNode(scaledIndex, ConstantNode.forIntegerKind(target.wordJavaKind, base, graph)));
 471 
 472         return graph.unique(new OffsetAddressNode(array, offset));
 473     }
 474 
 475     protected void lowerIndexAddressNode(IndexAddressNode indexAddress) {
<span class="line-modified"> 476         AddressNode lowered = createArrayAddress(indexAddress.graph(), indexAddress.getArray(), indexAddress.getArrayKind(), indexAddress.getElementKind(), indexAddress.getIndex());</span>
 477         indexAddress.replaceAndDelete(lowered);
 478     }
 479 
 480     protected void lowerLoadIndexedNode(LoadIndexedNode loadIndexed, LoweringTool tool) {
 481         StructuredGraph graph = loadIndexed.graph();
 482         ValueNode array = loadIndexed.array();
 483         array = createNullCheckedValue(array, loadIndexed, tool);
 484         JavaKind elementKind = loadIndexed.elementKind();
 485         Stamp loadStamp = loadStamp(loadIndexed.stamp(NodeView.DEFAULT), elementKind);
 486 
 487         GuardingNode boundsCheck = getBoundsCheck(loadIndexed, array, tool);
 488         ValueNode index = loadIndexed.index();
 489         if (UseIndexMasking.getValue(graph.getOptions())) {
 490             index = proxyIndex(loadIndexed, index, array, tool);
 491         }
 492         AddressNode address = createArrayIndexAddress(graph, array, elementKind, index, boundsCheck);
 493 
 494         ReadNode memoryRead = graph.add(new ReadNode(address, NamedLocationIdentity.getArrayLocation(elementKind), loadStamp, BarrierType.NONE));
 495         memoryRead.setGuard(boundsCheck);
 496         ValueNode readValue = implicitLoadConvert(graph, elementKind, memoryRead);
</pre>
<hr />
<pre>
 519                 ResolvedJavaType elementType = arrayType.getType().getComponentType();
 520                 if (!elementType.isJavaLangObject()) {
 521                     TypeReference typeReference = TypeReference.createTrusted(storeIndexed.graph().getAssumptions(), elementType);
 522                     LogicNode typeTest = graph.addOrUniqueWithInputs(InstanceOfNode.create(typeReference, value));
 523                     condition = LogicNode.or(graph.unique(IsNullNode.create(value)), typeTest, GraalDirectives.UNLIKELY_PROBABILITY);
 524                 }
 525             } else {
 526                 /*
 527                  * The guard on the read hub should be the null check of the array that was
 528                  * introduced earlier.
 529                  */
 530                 ValueNode arrayClass = createReadHub(graph, array, tool);
 531                 ValueNode componentHub = createReadArrayComponentHub(graph, arrayClass, storeIndexed);
 532                 LogicNode typeTest = graph.unique(InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), componentHub, value, false));
 533                 condition = LogicNode.or(graph.unique(IsNullNode.create(value)), typeTest, GraalDirectives.UNLIKELY_PROBABILITY);
 534             }
 535         }
 536 
 537         AddressNode address = createArrayIndexAddress(graph, array, elementKind, storeIndexed.index(), boundsCheck);
 538         WriteNode memoryWrite = graph.add(new WriteNode(address, NamedLocationIdentity.getArrayLocation(elementKind), implicitStoreConvert(graph, elementKind, value),
<span class="line-modified"> 539                         arrayStoreBarrierType(storeIndexed.elementKind()), false));</span>
 540         memoryWrite.setGuard(boundsCheck);
 541         if (condition != null) {
 542             tool.createGuard(storeIndexed, condition, DeoptimizationReason.ArrayStoreException, DeoptimizationAction.InvalidateReprofile);
 543         }
 544         memoryWrite.setStateAfter(storeIndexed.stateAfter());
 545         graph.replaceFixedWithFixed(storeIndexed, memoryWrite);
 546     }
 547 
 548     protected void lowerArrayLengthNode(ArrayLengthNode arrayLengthNode, LoweringTool tool) {
 549         arrayLengthNode.replaceAtUsages(createReadArrayLength(arrayLengthNode.array(), arrayLengthNode, tool));
 550         StructuredGraph graph = arrayLengthNode.graph();
 551         graph.removeFixed(arrayLengthNode);
 552     }
 553 
 554     /**
 555      * Creates a read node that read the array length and is guarded by a null-check.
 556      *
 557      * The created node is placed before {@code before} in the CFG.
 558      */
 559     protected ReadNode createReadArrayLength(ValueNode array, FixedNode before, LoweringTool tool) {
 560         StructuredGraph graph = array.graph();
 561         ValueNode canonicalArray = this.createNullCheckedValue(skipPiWhileNonNull(array), before, tool);
 562         AddressNode address = createOffsetAddress(graph, canonicalArray, arrayLengthOffset());
 563         ReadNode readArrayLength = graph.add(new ReadNode(address, ARRAY_LENGTH_LOCATION, StampFactory.positiveInt(), BarrierType.NONE));
 564         graph.addBeforeFixed(before, readArrayLength);
 565         return readArrayLength;
 566     }
 567 
 568     protected void lowerLoadHubNode(LoadHubNode loadHub, LoweringTool tool) {
 569         StructuredGraph graph = loadHub.graph();
 570         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
 571             return;
 572         }
 573         if (graph.getGuardsStage().allowsFloatingGuards()) {
 574             return;
 575         }
 576         ValueNode hub = createReadHub(graph, loadHub.getValue(), tool);
 577         loadHub.replaceAtUsagesAndDelete(hub);
 578     }
 579 
<span class="line-added"> 580     protected void lowerLoadHubOrNullNode(LoadHubOrNullNode loadHubOrNullNode, LoweringTool tool) {</span>
<span class="line-added"> 581         StructuredGraph graph = loadHubOrNullNode.graph();</span>
<span class="line-added"> 582         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {</span>
<span class="line-added"> 583             return;</span>
<span class="line-added"> 584         }</span>
<span class="line-added"> 585         if (graph.getGuardsStage().allowsFloatingGuards()) {</span>
<span class="line-added"> 586             return;</span>
<span class="line-added"> 587         }</span>
<span class="line-added"> 588         final FixedWithNextNode predecessor = tool.lastFixedNode();</span>
<span class="line-added"> 589         final ValueNode value = loadHubOrNullNode.getValue();</span>
<span class="line-added"> 590         AbstractPointerStamp stamp = (AbstractPointerStamp) value.stamp(NodeView.DEFAULT);</span>
<span class="line-added"> 591         final LogicNode isNull = graph.addOrUniqueWithInputs(IsNullNode.create(value));</span>
<span class="line-added"> 592         final EndNode trueEnd = graph.add(new EndNode());</span>
<span class="line-added"> 593         final EndNode falseEnd = graph.add(new EndNode());</span>
<span class="line-added"> 594         final IfNode ifNode = graph.add(new IfNode(isNull, trueEnd, falseEnd, 0.5));</span>
<span class="line-added"> 595         final MergeNode merge = graph.add(new MergeNode());</span>
<span class="line-added"> 596         merge.addForwardEnd(trueEnd);</span>
<span class="line-added"> 597         merge.addForwardEnd(falseEnd);</span>
<span class="line-added"> 598         final AbstractPointerStamp hubStamp = (AbstractPointerStamp) loadHubOrNullNode.stamp(NodeView.DEFAULT);</span>
<span class="line-added"> 599         ValueNode nullHub = ConstantNode.forConstant(hubStamp.asAlwaysNull(), JavaConstant.NULL_POINTER, tool.getMetaAccess(), graph);</span>
<span class="line-added"> 600         final ValueNode nonNullValue = graph.addOrUniqueWithInputs(PiNode.create(value, stamp.asNonNull(), ifNode.falseSuccessor()));</span>
<span class="line-added"> 601         ValueNode hub = createReadHub(graph, nonNullValue, tool);</span>
<span class="line-added"> 602         ValueNode[] values = new ValueNode[]{nullHub, hub};</span>
<span class="line-added"> 603         final PhiNode hubPhi = graph.unique(new ValuePhiNode(hubStamp, merge, values));</span>
<span class="line-added"> 604         final FixedNode oldNext = predecessor.next();</span>
<span class="line-added"> 605         predecessor.setNext(ifNode);</span>
<span class="line-added"> 606         merge.setNext(oldNext);</span>
<span class="line-added"> 607         loadHubOrNullNode.replaceAtUsagesAndDelete(hubPhi);</span>
<span class="line-added"> 608     }</span>
<span class="line-added"> 609 </span>
 610     protected void lowerLoadArrayComponentHubNode(LoadArrayComponentHubNode loadHub) {
 611         StructuredGraph graph = loadHub.graph();
 612         ValueNode hub = createReadArrayComponentHub(graph, loadHub.getValue(), loadHub);
 613         graph.replaceFixed(loadHub, hub);
 614     }
 615 
 616     protected void lowerMonitorEnterNode(MonitorEnterNode monitorEnter, LoweringTool tool, StructuredGraph graph) {
 617         ValueNode object = createNullCheckedValue(monitorEnter.object(), monitorEnter, tool);
 618         ValueNode hub = graph.addOrUnique(LoadHubNode.create(object, tool.getStampProvider(), tool.getMetaAccess(), tool.getConstantReflection()));
 619         RawMonitorEnterNode rawMonitorEnter = graph.add(new RawMonitorEnterNode(object, hub, monitorEnter.getMonitorId()));
 620         rawMonitorEnter.setStateBefore(monitorEnter.stateBefore());
 621         rawMonitorEnter.setStateAfter(monitorEnter.stateAfter());
 622         graph.replaceFixedWithFixed(monitorEnter, rawMonitorEnter);
 623     }
 624 
 625     protected void lowerCompareAndSwapNode(UnsafeCompareAndSwapNode cas) {
 626         StructuredGraph graph = cas.graph();
 627         JavaKind valueKind = cas.getValueKind();
 628 
 629         ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
 630         ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
 631 
 632         AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
 633         BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);
<span class="line-modified"> 634         LogicCompareAndSwapNode atomicNode = graph.add(new LogicCompareAndSwapNode(address, cas.getKilledLocationIdentity(), expectedValue, newValue, barrierType));</span>
 635         atomicNode.setStateAfter(cas.stateAfter());
 636         graph.replaceFixedWithFixed(cas, atomicNode);
 637     }
 638 
 639     protected void lowerCompareAndExchangeNode(UnsafeCompareAndExchangeNode cas) {
 640         StructuredGraph graph = cas.graph();
 641         JavaKind valueKind = cas.getValueKind();
 642 
 643         ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
 644         ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
 645 
 646         AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
 647         BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);
<span class="line-modified"> 648         ValueCompareAndSwapNode atomicNode = graph.add(new ValueCompareAndSwapNode(address, expectedValue, newValue, cas.getKilledLocationIdentity(), barrierType));</span>
 649         ValueNode coercedNode = implicitLoadConvert(graph, valueKind, atomicNode, true);
 650         atomicNode.setStateAfter(cas.stateAfter());
 651         cas.replaceAtUsages(coercedNode);
 652         graph.replaceFixedWithFixed(cas, atomicNode);
 653     }
 654 
 655     protected void lowerAtomicReadAndWriteNode(AtomicReadAndWriteNode n) {
 656         StructuredGraph graph = n.graph();
 657         JavaKind valueKind = n.getValueKind();
 658 
 659         ValueNode newValue = implicitStoreConvert(graph, valueKind, n.newValue());
 660 
 661         AddressNode address = graph.unique(new OffsetAddressNode(n.object(), n.offset()));
 662         BarrierType barrierType = guessStoreBarrierType(n.object(), n.newValue());
 663         LIRKind lirAccessKind = LIRKind.fromJavaKind(target.arch, valueKind);
<span class="line-modified"> 664         LoweredAtomicReadAndWriteNode memoryRead = graph.add(new LoweredAtomicReadAndWriteNode(address, n.getKilledLocationIdentity(), newValue, lirAccessKind, barrierType));</span>
 665         memoryRead.setStateAfter(n.stateAfter());
 666 
 667         ValueNode readValue = implicitLoadConvert(graph, valueKind, memoryRead);
 668         n.stateAfter().replaceFirstInput(n, memoryRead);
 669         n.replaceAtUsages(readValue);
 670         graph.replaceFixedWithFixed(n, memoryRead);
 671     }
 672 
 673     /**
 674      * @param tool utility for performing the lowering
 675      */
 676     protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {
<span class="line-added"> 677         GCProvider gc = tool.getProviders().getGC();</span>
 678         StructuredGraph graph = load.graph();
 679         if (load instanceof GuardedUnsafeLoadNode) {
 680             GuardedUnsafeLoadNode guardedLoad = (GuardedUnsafeLoadNode) load;
 681             GuardingNode guard = guardedLoad.getGuard();
 682             if (guard == null) {
 683                 // can float freely if the guard folded away
<span class="line-modified"> 684                 ReadNode memoryRead = createUnsafeRead(gc, graph, load, null);</span>
 685                 memoryRead.setForceFixed(false);
 686                 graph.replaceFixedWithFixed(load, memoryRead);
 687             } else {
 688                 // must be guarded, but flows below the guard
<span class="line-modified"> 689                 ReadNode memoryRead = createUnsafeRead(gc, graph, load, guard);</span>
 690                 graph.replaceFixedWithFixed(load, memoryRead);
 691             }
 692         } else {
 693             // never had a guarding condition so it must be fixed, creation of the read will force
 694             // it to be fixed
<span class="line-modified"> 695             ReadNode memoryRead = createUnsafeRead(gc, graph, load, null);</span>
 696             graph.replaceFixedWithFixed(load, memoryRead);
 697         }
 698     }
 699 
 700     protected AddressNode createUnsafeAddress(StructuredGraph graph, ValueNode object, ValueNode offset) {
 701         if (object.isConstant() &amp;&amp; object.asConstant().isDefaultForKind()) {
 702             return graph.addOrUniqueWithInputs(OffsetAddressNode.create(offset));
 703         } else {
 704             return graph.unique(new OffsetAddressNode(object, offset));
 705         }
 706     }
 707 
<span class="line-modified"> 708     protected ReadNode createUnsafeRead(GCProvider gc, StructuredGraph graph, RawLoadNode load, GuardingNode guard) {</span>
 709         boolean compressible = load.accessKind() == JavaKind.Object;
 710         JavaKind readKind = load.accessKind();
 711         Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, compressible);
 712         AddressNode address = createUnsafeAddress(graph, load.object(), load.offset());
<span class="line-modified"> 713         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, gc.getBarrierSet().readBarrierType(load)));</span>
 714         if (guard == null) {
 715             // An unsafe read must not float otherwise it may float above
 716             // a test guaranteeing the read is safe.
 717             memoryRead.setForceFixed(true);
 718         } else {
 719             memoryRead.setGuard(guard);
 720         }
 721         ValueNode readValue = performBooleanCoercionIfNecessary(implicitLoadConvert(graph, readKind, memoryRead, compressible), readKind);
 722         load.replaceAtUsages(readValue);
 723         return memoryRead;
 724     }
 725 
 726     protected void lowerUnsafeMemoryLoadNode(UnsafeMemoryLoadNode load) {
 727         StructuredGraph graph = load.graph();
 728         JavaKind readKind = load.getKind();
 729         assert readKind != JavaKind.Object;
 730         Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, false);
 731         AddressNode address = graph.addOrUniqueWithInputs(OffsetAddressNode.create(load.getAddress()));
 732         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, BarrierType.NONE));
 733         // An unsafe read must not float otherwise it may float above
</pre>
<hr />
<pre>
 736         ValueNode readValue = performBooleanCoercionIfNecessary(implicitLoadConvert(graph, readKind, memoryRead, false), readKind);
 737         load.replaceAtUsages(readValue);
 738         graph.replaceFixedWithFixed(load, memoryRead);
 739     }
 740 
 741     private static ValueNode performBooleanCoercionIfNecessary(ValueNode readValue, JavaKind readKind) {
 742         if (readKind == JavaKind.Boolean) {
 743             StructuredGraph graph = readValue.graph();
 744             IntegerEqualsNode eq = graph.addOrUnique(new IntegerEqualsNode(readValue, ConstantNode.forInt(0, graph)));
 745             return graph.addOrUnique(new ConditionalNode(eq, ConstantNode.forBoolean(false, graph), ConstantNode.forBoolean(true, graph)));
 746         }
 747         return readValue;
 748     }
 749 
 750     protected void lowerUnsafeStoreNode(RawStoreNode store) {
 751         StructuredGraph graph = store.graph();
 752         boolean compressible = store.value().getStackKind() == JavaKind.Object;
 753         JavaKind valueKind = store.accessKind();
 754         ValueNode value = implicitStoreConvert(graph, valueKind, store.value(), compressible);
 755         AddressNode address = createUnsafeAddress(graph, store.object(), store.offset());
<span class="line-modified"> 756         WriteNode write = graph.add(new WriteNode(address, store.getKilledLocationIdentity(), value, unsafeStoreBarrierType(store), false));</span>
 757         write.setStateAfter(store.stateAfter());
 758         graph.replaceFixedWithFixed(store, write);
 759     }
 760 
 761     protected void lowerUnsafeMemoryStoreNode(UnsafeMemoryStoreNode store) {
 762         StructuredGraph graph = store.graph();
 763         assert store.getValue().getStackKind() != JavaKind.Object;
 764         JavaKind valueKind = store.getKind();
 765         ValueNode value = implicitStoreConvert(graph, valueKind, store.getValue(), false);
 766         AddressNode address = graph.addOrUniqueWithInputs(OffsetAddressNode.create(store.getAddress()));
<span class="line-modified"> 767         WriteNode write = graph.add(new WriteNode(address, store.getKilledLocationIdentity(), value, BarrierType.NONE, false));</span>
 768         write.setStateAfter(store.stateAfter());
 769         graph.replaceFixedWithFixed(store, write);
 770     }
 771 
 772     protected void lowerJavaReadNode(JavaReadNode read) {
 773         StructuredGraph graph = read.graph();
 774         JavaKind valueKind = read.getReadKind();
 775         Stamp loadStamp = loadStamp(read.stamp(NodeView.DEFAULT), valueKind, read.isCompressible());
 776 
 777         ReadNode memoryRead = graph.add(new ReadNode(read.getAddress(), read.getLocationIdentity(), loadStamp, read.getBarrierType()));
 778         GuardingNode guard = read.getGuard();
 779         ValueNode readValue = implicitLoadConvert(graph, valueKind, memoryRead, read.isCompressible());
 780         if (guard == null) {
 781             // An unsafe read must not float otherwise it may float above
 782             // a test guaranteeing the read is safe.
 783             memoryRead.setForceFixed(true);
 784         } else {
 785             memoryRead.setGuard(guard);
 786         }
 787         read.replaceAtUsages(readValue);
 788         graph.replaceFixed(read, memoryRead);
 789     }
 790 
 791     protected void lowerJavaWriteNode(JavaWriteNode write) {
 792         StructuredGraph graph = write.graph();
 793         ValueNode value = implicitStoreConvert(graph, write.getWriteKind(), write.value(), write.isCompressible());
<span class="line-modified"> 794         WriteNode memoryWrite = graph.add(new WriteNode(write.getAddress(), write.getKilledLocationIdentity(), value, write.getBarrierType(), false));</span>
 795         memoryWrite.setStateAfter(write.stateAfter());
 796         graph.replaceFixedWithFixed(write, memoryWrite);
 797         memoryWrite.setGuard(write.getGuard());
 798     }
 799 
 800     @SuppressWarnings(&quot;try&quot;)
 801     protected void lowerCommitAllocationNode(CommitAllocationNode commit, LoweringTool tool) {
 802         StructuredGraph graph = commit.graph();
 803         if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {
 804             List&lt;AbstractNewObjectNode&gt; recursiveLowerings = new ArrayList&lt;&gt;();
 805 
 806             ValueNode[] allocations = new ValueNode[commit.getVirtualObjects().size()];
 807             BitSet omittedValues = new BitSet();
 808             int valuePos = 0;
 809             for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 810                 VirtualObjectNode virtual = commit.getVirtualObjects().get(objIndex);
 811                 try (DebugCloseable nsp = graph.withNodeSourcePosition(virtual)) {
 812                     int entryCount = virtual.entryCount();
 813                     AbstractNewObjectNode newObject;
 814                     if (virtual instanceof VirtualInstanceNode) {
 815                         newObject = graph.add(createNewInstanceFromVirtual(virtual));
 816                     } else {
 817                         newObject = graph.add(createNewArrayFromVirtual(virtual, ConstantNode.forInt(entryCount, graph)));
 818                     }
<span class="line-added"> 819                     // The final STORE_STORE barrier will be emitted by finishAllocatedObjects</span>
<span class="line-added"> 820                     newObject.clearEmitMemoryBarrier();</span>
 821 
 822                     recursiveLowerings.add(newObject);
 823                     graph.addBeforeFixed(commit, newObject);
 824                     allocations[objIndex] = newObject;
 825                     for (int i = 0; i &lt; entryCount; i++) {
 826                         ValueNode value = commit.getValues().get(valuePos);
 827                         if (value instanceof VirtualObjectNode) {
 828                             value = allocations[commit.getVirtualObjects().indexOf(value)];
 829                         }
 830                         if (value == null) {
 831                             omittedValues.set(valuePos);
 832                         } else if (!(value.isConstant() &amp;&amp; value.asConstant().isDefaultForKind())) {
 833                             // Constant.illegal is always the defaultForKind, so it is skipped
 834                             JavaKind valueKind = value.getStackKind();
 835                             JavaKind entryKind = virtual.entryKind(i);
 836 
 837                             // Truffle requires some leniency in terms of what can be put where:
 838                             assert valueKind.getStackKind() == entryKind.getStackKind() ||
 839                                             (valueKind == JavaKind.Long || valueKind == JavaKind.Double || (valueKind == JavaKind.Int &amp;&amp; virtual instanceof VirtualArrayNode));
 840                             AddressNode address = null;
 841                             BarrierType barrierType = null;
 842                             if (virtual instanceof VirtualInstanceNode) {
 843                                 ResolvedJavaField field = ((VirtualInstanceNode) virtual).field(i);
 844                                 long offset = fieldOffset(field);
 845                                 if (offset &gt;= 0) {
 846                                     address = createOffsetAddress(graph, newObject, offset);
 847                                     barrierType = fieldInitializationBarrier(entryKind);
 848                                 }
 849                             } else {
 850                                 address = createOffsetAddress(graph, newObject, metaAccess.getArrayBaseOffset(entryKind) + i * metaAccess.getArrayIndexScale(entryKind));
 851                                 barrierType = arrayInitializationBarrier(entryKind);
 852                             }
 853                             if (address != null) {
<span class="line-modified"> 854                                 WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, entryKind, value), barrierType, false);</span>
 855                                 graph.addAfterFixed(newObject, graph.add(write));
 856                             }
 857                         }
 858                         valuePos++;
 859                     }
 860                 }
 861             }
 862             valuePos = 0;
 863 
 864             for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 865                 VirtualObjectNode virtual = commit.getVirtualObjects().get(objIndex);
 866                 try (DebugCloseable nsp = graph.withNodeSourcePosition(virtual)) {
 867                     int entryCount = virtual.entryCount();
 868                     ValueNode newObject = allocations[objIndex];
 869                     for (int i = 0; i &lt; entryCount; i++) {
 870                         if (omittedValues.get(valuePos)) {
 871                             ValueNode value = commit.getValues().get(valuePos);
 872                             assert value instanceof VirtualObjectNode;
 873                             ValueNode allocValue = allocations[commit.getVirtualObjects().indexOf(value)];
 874                             if (!(allocValue.isConstant() &amp;&amp; allocValue.asConstant().isDefaultForKind())) {
 875                                 assert virtual.entryKind(i) == JavaKind.Object &amp;&amp; allocValue.getStackKind() == JavaKind.Object;
 876                                 AddressNode address;
 877                                 BarrierType barrierType;
 878                                 if (virtual instanceof VirtualInstanceNode) {
 879                                     VirtualInstanceNode virtualInstance = (VirtualInstanceNode) virtual;
 880                                     address = createFieldAddress(graph, newObject, virtualInstance.field(i));
<span class="line-modified"> 881                                     barrierType = fieldStoreBarrierType(virtualInstance.field(i));</span>
 882                                 } else {
 883                                     address = createArrayAddress(graph, newObject, virtual.entryKind(i), ConstantNode.forInt(i, graph));
<span class="line-modified"> 884                                     barrierType = arrayStoreBarrierType(virtual.entryKind(i));</span>
 885                                 }
 886                                 if (address != null) {
<span class="line-modified"> 887                                     WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, JavaKind.Object, allocValue), barrierType, false);</span>
 888                                     graph.addBeforeFixed(commit, graph.add(write));
 889                                 }
 890                             }
 891                         }
 892                         valuePos++;
 893                     }
 894                 }
 895             }
 896 
 897             finishAllocatedObjects(tool, commit, allocations);
 898             graph.removeFixed(commit);
 899 
 900             for (AbstractNewObjectNode recursiveLowering : recursiveLowerings) {
 901                 recursiveLowering.lower(tool);
 902             }
 903         }
 904 
 905     }
 906 
 907     public NewInstanceNode createNewInstanceFromVirtual(VirtualObjectNode virtual) {
</pre>
<hr />
<pre>
 978         int barrier = MemoryBarriers.STORE_STORE;
 979         outer: for (VirtualObjectNode vobj : commit.getVirtualObjects()) {
 980             for (ResolvedJavaField field : vobj.type().getInstanceFields(true)) {
 981                 if (field.isFinal()) {
 982                     barrier = barrier | MemoryBarriers.LOAD_STORE;
 983                     break outer;
 984                 }
 985             }
 986         }
 987         graph.addAfterFixed(commit, graph.add(new MembarNode(barrier, LocationIdentity.init())));
 988     }
 989 
 990     /**
 991      * @param field the field whose barrier type should be returned
 992      */
 993     protected BarrierType fieldLoadBarrierType(ResolvedJavaField field) {
 994         return BarrierType.NONE;
 995     }
 996 
 997     protected BarrierType fieldStoreBarrierType(ResolvedJavaField field) {
<span class="line-modified"> 998         if (getStorageKind(field) == JavaKind.Object) {</span>
<span class="line-modified"> 999             return BarrierType.FIELD;</span>
1000         }
1001         return BarrierType.NONE;
1002     }
1003 
1004     protected BarrierType arrayStoreBarrierType(JavaKind elementKind) {
1005         if (elementKind == JavaKind.Object) {
<span class="line-modified">1006             return BarrierType.ARRAY;</span>
1007         }
1008         return BarrierType.NONE;
1009     }
1010 
1011     public BarrierType fieldInitializationBarrier(JavaKind entryKind) {
<span class="line-modified">1012         return entryKind == JavaKind.Object ? BarrierType.FIELD : BarrierType.NONE;</span>
1013     }
1014 
1015     public BarrierType arrayInitializationBarrier(JavaKind entryKind) {
<span class="line-modified">1016         return entryKind == JavaKind.Object ? BarrierType.ARRAY : BarrierType.NONE;</span>
1017     }
1018 
1019     private BarrierType unsafeStoreBarrierType(RawStoreNode store) {
1020         if (!store.needsBarrier()) {
1021             return BarrierType.NONE;
1022         }
1023         return guessStoreBarrierType(store.object(), store.value());
1024     }
1025 
1026     private BarrierType guessStoreBarrierType(ValueNode object, ValueNode value) {
1027         if (value.getStackKind() == JavaKind.Object &amp;&amp; object.getStackKind() == JavaKind.Object) {
1028             ResolvedJavaType type = StampTool.typeOrNull(object);
1029             // Array types must use a precise barrier, so if the type is unknown or is a supertype
1030             // of Object[] then treat it as an array.
<span class="line-modified">1031             if (type != null &amp;&amp; type.isArray()) {</span>
<span class="line-modified">1032                 return BarrierType.ARRAY;</span>
<span class="line-added">1033             } else if (type == null || type.isAssignableFrom(objectArrayType)) {</span>
<span class="line-added">1034                 return BarrierType.UNKNOWN;</span>
1035             } else {
<span class="line-modified">1036                 return BarrierType.FIELD;</span>
1037             }
1038         }
1039         return BarrierType.NONE;
1040     }
1041 
1042     public abstract int fieldOffset(ResolvedJavaField field);
1043 
1044     public FieldLocationIdentity fieldLocationIdentity(ResolvedJavaField field) {
1045         return new FieldLocationIdentity(field);
1046     }
1047 
1048     public abstract ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField field);
1049 
1050     public abstract int arrayLengthOffset();
1051 
1052     public Stamp loadStamp(Stamp stamp, JavaKind kind) {
1053         return loadStamp(stamp, kind, true);
1054     }
1055 
1056     private boolean useCompressedOops(JavaKind kind, boolean compressible) {
</pre>
</td>
</tr>
</table>
<center><a href="ConstantStringIndexOfSnippets.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphKit.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
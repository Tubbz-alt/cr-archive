<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/nodes/MacroNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BitCountNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MacroStateSplitNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/nodes/MacroNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 24 
 25 package org.graalvm.compiler.replacements.nodes;
 26 
 27 import static jdk.vm.ci.code.BytecodeFrame.isPlaceholderBci;
 28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
 29 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_UNKNOWN;
 30 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_UNKNOWN;
 31 
 32 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 33 import org.graalvm.compiler.api.replacements.Snippet;
 34 import org.graalvm.compiler.core.common.type.StampPair;
 35 import org.graalvm.compiler.debug.DebugCloseable;
 36 import org.graalvm.compiler.debug.DebugContext;
 37 import org.graalvm.compiler.debug.GraalError;
 38 import org.graalvm.compiler.graph.Node;
 39 import org.graalvm.compiler.graph.NodeClass;
 40 import org.graalvm.compiler.graph.NodeInputList;
 41 import org.graalvm.compiler.nodeinfo.NodeInfo;
 42 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 43 import org.graalvm.compiler.nodes.FixedNode;
<span class="line-removed"> 44 import org.graalvm.compiler.nodes.Invokable;</span>
 45 import org.graalvm.compiler.nodes.FixedWithNextNode;
 46 import org.graalvm.compiler.nodes.FrameState;

 47 import org.graalvm.compiler.nodes.InvokeNode;
 48 import org.graalvm.compiler.nodes.StructuredGraph;
 49 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
 50 import org.graalvm.compiler.nodes.ValueNode;
 51 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;

 52 import org.graalvm.compiler.nodes.spi.Lowerable;
 53 import org.graalvm.compiler.nodes.spi.LoweringTool;
 54 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 55 import org.graalvm.compiler.phases.common.FrameStateAssignmentPhase;
 56 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 57 import org.graalvm.compiler.phases.common.LoweringPhase;
 58 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 59 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
<span class="line-modified"> 60 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 61 
 62 import jdk.vm.ci.meta.JavaKind;
 63 import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="line-removed"> 64 import jdk.internal.vm.compiler.word.LocationIdentity;</span>
 65 
 66 /**
 67  * Macro nodes can be used to temporarily replace an invoke. They can, for example, be used to
 68  * implement constant folding for known JDK functions like {@link Class#isInterface()}.&lt;br/&gt;
 69  * &lt;br/&gt;
 70  * During lowering, multiple sources are queried in order to look for a replacement:
 71  * &lt;ul&gt;
 72  * &lt;li&gt;If {@link #getLoweredSnippetGraph(LoweringTool)} returns a non-null result, this graph is
 73  * used as a replacement.&lt;/li&gt;
 74  * &lt;li&gt;If a {@link MethodSubstitution} for the target method is found, this substitution is used as
 75  * a replacement.&lt;/li&gt;
 76  * &lt;li&gt;Otherwise, the macro node is replaced with an {@link InvokeNode}. Note that this is only
 77  * possible if the macro node is a {@link MacroStateSplitNode}.&lt;/li&gt;
 78  * &lt;/ul&gt;
 79  */
 80 //@formatter:off
 81 @NodeInfo(cycles = CYCLES_UNKNOWN,
 82           cyclesRationale = &quot;If this node is not optimized away it will be lowered to a call, which we cannot estimate&quot;,
 83           size = SIZE_UNKNOWN,
 84           sizeRationale = &quot;If this node is not optimized away it will be lowered to a call, which we cannot estimate&quot;)
</pre>
<hr />
<pre>
143     public FixedNode asFixedNode() {
144         return this;
145     }
146 
147     /**
148      * Gets a snippet to be used for lowering this macro node. The returned graph (if non-null) must
149      * have been {@linkplain #lowerReplacement(StructuredGraph, LoweringTool) lowered}.
150      */
151     @SuppressWarnings(&quot;unused&quot;)
152     protected StructuredGraph getLoweredSnippetGraph(LoweringTool tool) {
153         return null;
154     }
155 
156     /**
157      * Applies {@linkplain LoweringPhase lowering} to a replacement graph.
158      *
159      * @param replacementGraph a replacement (i.e., snippet or method substitution) graph
160      */
161     @SuppressWarnings(&quot;try&quot;)
162     protected StructuredGraph lowerReplacement(final StructuredGraph replacementGraph, LoweringTool tool) {
<span class="line-modified">163         final PhaseContext c = new PhaseContext(tool.getMetaAccess(), tool.getConstantReflection(), tool.getConstantFieldProvider(), tool.getLowerer(), tool.getReplacements(),</span>
<span class="line-removed">164                         tool.getStampProvider(), null);</span>
165         if (!graph().hasValueProxies()) {
166             new RemoveValueProxyPhase().apply(replacementGraph);
167         }
168         GuardsStage guardsStage = graph().getGuardsStage();
169         if (!guardsStage.allowsFloatingGuards()) {
170             new GuardLoweringPhase().apply(replacementGraph, null);
171             if (guardsStage.areFrameStatesAtDeopts()) {
172                 new FrameStateAssignmentPhase().apply(replacementGraph);
173             }
174         }
175         DebugContext debug = replacementGraph.getDebug();
176         try (DebugContext.Scope s = debug.scope(&quot;LoweringSnippetTemplate&quot;, replacementGraph)) {
<span class="line-modified">177             new LoweringPhase(new CanonicalizerPhase(), tool.getLoweringStage()).apply(replacementGraph, c);</span>
178         } catch (Throwable e) {
179             throw debug.handle(e);
180         }
181         return replacementGraph;
182     }
183 
184     @Override
185     public void lower(LoweringTool tool) {
186         StructuredGraph replacementGraph = getLoweredSnippetGraph(tool);
187 
188         InvokeNode invoke = replaceWithInvoke();
189         assert invoke.verify();
190 
191         if (replacementGraph != null) {
192             // Pull out the receiver null check so that a replaced
193             // receiver can be lowered if necessary
194             if (!targetMethod.isStatic()) {
195                 ValueNode nonNullReceiver = InliningUtil.nonNullReceiver(invoke);
196                 if (nonNullReceiver instanceof Lowerable) {
197                     ((Lowerable) nonNullReceiver).lower(tool);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 24 
 25 package org.graalvm.compiler.replacements.nodes;
 26 
 27 import static jdk.vm.ci.code.BytecodeFrame.isPlaceholderBci;
 28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
 29 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_UNKNOWN;
 30 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_UNKNOWN;
 31 
 32 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 33 import org.graalvm.compiler.api.replacements.Snippet;
 34 import org.graalvm.compiler.core.common.type.StampPair;
 35 import org.graalvm.compiler.debug.DebugCloseable;
 36 import org.graalvm.compiler.debug.DebugContext;
 37 import org.graalvm.compiler.debug.GraalError;
 38 import org.graalvm.compiler.graph.Node;
 39 import org.graalvm.compiler.graph.NodeClass;
 40 import org.graalvm.compiler.graph.NodeInputList;
 41 import org.graalvm.compiler.nodeinfo.NodeInfo;
 42 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 43 import org.graalvm.compiler.nodes.FixedNode;

 44 import org.graalvm.compiler.nodes.FixedWithNextNode;
 45 import org.graalvm.compiler.nodes.FrameState;
<span class="line-added"> 46 import org.graalvm.compiler.nodes.Invokable;</span>
 47 import org.graalvm.compiler.nodes.InvokeNode;
 48 import org.graalvm.compiler.nodes.StructuredGraph;
 49 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
 50 import org.graalvm.compiler.nodes.ValueNode;
 51 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
<span class="line-added"> 52 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 53 import org.graalvm.compiler.nodes.spi.Lowerable;
 54 import org.graalvm.compiler.nodes.spi.LoweringTool;
 55 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 56 import org.graalvm.compiler.phases.common.FrameStateAssignmentPhase;
 57 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 58 import org.graalvm.compiler.phases.common.LoweringPhase;
 59 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 60 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
<span class="line-modified"> 61 import jdk.internal.vm.compiler.word.LocationIdentity;</span>
 62 
 63 import jdk.vm.ci.meta.JavaKind;
 64 import jdk.vm.ci.meta.ResolvedJavaMethod;

 65 
 66 /**
 67  * Macro nodes can be used to temporarily replace an invoke. They can, for example, be used to
 68  * implement constant folding for known JDK functions like {@link Class#isInterface()}.&lt;br/&gt;
 69  * &lt;br/&gt;
 70  * During lowering, multiple sources are queried in order to look for a replacement:
 71  * &lt;ul&gt;
 72  * &lt;li&gt;If {@link #getLoweredSnippetGraph(LoweringTool)} returns a non-null result, this graph is
 73  * used as a replacement.&lt;/li&gt;
 74  * &lt;li&gt;If a {@link MethodSubstitution} for the target method is found, this substitution is used as
 75  * a replacement.&lt;/li&gt;
 76  * &lt;li&gt;Otherwise, the macro node is replaced with an {@link InvokeNode}. Note that this is only
 77  * possible if the macro node is a {@link MacroStateSplitNode}.&lt;/li&gt;
 78  * &lt;/ul&gt;
 79  */
 80 //@formatter:off
 81 @NodeInfo(cycles = CYCLES_UNKNOWN,
 82           cyclesRationale = &quot;If this node is not optimized away it will be lowered to a call, which we cannot estimate&quot;,
 83           size = SIZE_UNKNOWN,
 84           sizeRationale = &quot;If this node is not optimized away it will be lowered to a call, which we cannot estimate&quot;)
</pre>
<hr />
<pre>
143     public FixedNode asFixedNode() {
144         return this;
145     }
146 
147     /**
148      * Gets a snippet to be used for lowering this macro node. The returned graph (if non-null) must
149      * have been {@linkplain #lowerReplacement(StructuredGraph, LoweringTool) lowered}.
150      */
151     @SuppressWarnings(&quot;unused&quot;)
152     protected StructuredGraph getLoweredSnippetGraph(LoweringTool tool) {
153         return null;
154     }
155 
156     /**
157      * Applies {@linkplain LoweringPhase lowering} to a replacement graph.
158      *
159      * @param replacementGraph a replacement (i.e., snippet or method substitution) graph
160      */
161     @SuppressWarnings(&quot;try&quot;)
162     protected StructuredGraph lowerReplacement(final StructuredGraph replacementGraph, LoweringTool tool) {
<span class="line-modified">163         final CoreProviders c = tool.getProviders();</span>

164         if (!graph().hasValueProxies()) {
165             new RemoveValueProxyPhase().apply(replacementGraph);
166         }
167         GuardsStage guardsStage = graph().getGuardsStage();
168         if (!guardsStage.allowsFloatingGuards()) {
169             new GuardLoweringPhase().apply(replacementGraph, null);
170             if (guardsStage.areFrameStatesAtDeopts()) {
171                 new FrameStateAssignmentPhase().apply(replacementGraph);
172             }
173         }
174         DebugContext debug = replacementGraph.getDebug();
175         try (DebugContext.Scope s = debug.scope(&quot;LoweringSnippetTemplate&quot;, replacementGraph)) {
<span class="line-modified">176             new LoweringPhase(CanonicalizerPhase.create(), tool.getLoweringStage()).apply(replacementGraph, c);</span>
177         } catch (Throwable e) {
178             throw debug.handle(e);
179         }
180         return replacementGraph;
181     }
182 
183     @Override
184     public void lower(LoweringTool tool) {
185         StructuredGraph replacementGraph = getLoweredSnippetGraph(tool);
186 
187         InvokeNode invoke = replaceWithInvoke();
188         assert invoke.verify();
189 
190         if (replacementGraph != null) {
191             // Pull out the receiver null check so that a replaced
192             // receiver can be lowered if necessary
193             if (!targetMethod.isStatic()) {
194                 ValueNode nonNullReceiver = InliningUtil.nonNullReceiver(invoke);
195                 if (nonNullReceiver instanceof Lowerable) {
196                     ((Lowerable) nonNullReceiver).lower(tool);
</pre>
</td>
</tr>
</table>
<center><a href="BitCountNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MacroStateSplitNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/ReplacementsImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PEGraphDecoder.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SnippetCounter.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/ReplacementsImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,13 ***</span>
<span class="line-new-header">--- 25,15 ---</span>
  package org.graalvm.compiler.replacements;
  
  import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  import static org.graalvm.compiler.core.common.GraalOptions.UseSnippetGraphCache;
  import static org.graalvm.compiler.debug.DebugContext.DEFAULT_LOG_STREAM;
<span class="line-added">+ import static org.graalvm.compiler.debug.DebugOptions.DebugStubsAndSnippets;</span>
  import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
  import static org.graalvm.compiler.java.BytecodeParserOptions.InlineIntrinsicsDuringParsing;
  import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;
<span class="line-added">+ import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createMethodSubstitutionInlineInfo;</span>
  import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;
  import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION;
  import static org.graalvm.compiler.phases.common.DeadCodeEliminationPhase.Optionality.Required;
  
  import java.util.Collections;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,11 ***</span>
  import org.graalvm.compiler.bytecode.Bytecode;
  import org.graalvm.compiler.bytecode.BytecodeProvider;
  import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  import org.graalvm.compiler.core.common.CompilationIdentifier;
  import org.graalvm.compiler.core.common.GraalOptions;
<span class="line-removed">- import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;</span>
  import org.graalvm.compiler.debug.DebugCloseable;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.debug.DebugContext.Description;
  import org.graalvm.compiler.debug.DebugHandlersFactory;
  import org.graalvm.compiler.debug.GraalError;
<span class="line-new-header">--- 52,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,11 ***</span>
<span class="line-new-header">--- 63,13 ---</span>
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.Node.NodeIntrinsic;
  import org.graalvm.compiler.graph.NodeSourcePosition;
  import org.graalvm.compiler.java.GraphBuilderPhase;
  import org.graalvm.compiler.java.GraphBuilderPhase.Instance;
<span class="line-added">+ import org.graalvm.compiler.loop.phases.ConvertDeoptimizeToGuardPhase;</span>
  import org.graalvm.compiler.nodes.CallTargetNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.Cancellable;</span>
  import org.graalvm.compiler.nodes.Invoke;
  import org.graalvm.compiler.nodes.StateSplit;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedInvocationPlugin;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,41 ***</span>
  import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
  import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
  import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  import org.graalvm.compiler.nodes.spi.Replacements;
<span class="line-removed">- import org.graalvm.compiler.nodes.spi.StampProvider;</span>
<span class="line-removed">- import org.graalvm.compiler.options.Option;</span>
<span class="line-removed">- import org.graalvm.compiler.options.OptionKey;</span>
<span class="line-removed">- import org.graalvm.compiler.options.OptionType;</span>
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.OptimisticOptimizations;
  import org.graalvm.compiler.phases.common.CanonicalizerPhase;
<span class="line-removed">- import org.graalvm.compiler.loop.phases.ConvertDeoptimizeToGuardPhase;</span>
  import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
<span class="line-removed">- import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
  import org.graalvm.compiler.phases.util.Providers;
  import org.graalvm.compiler.word.Word;
  import org.graalvm.compiler.word.WordOperationPlugin;
  
  import jdk.vm.ci.code.TargetDescription;
<span class="line-removed">- import jdk.vm.ci.meta.ConstantReflectionProvider;</span>
  import jdk.vm.ci.meta.MetaAccessProvider;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.ResolvedJavaType;
  
  public class ReplacementsImpl implements Replacements, InlineInvokePlugin {
  
<span class="line-modified">!     public static class Options {</span>
<span class="line-removed">-         // @formatter:off</span>
<span class="line-removed">-         @Option(help = &quot;This is a testing option to exercise the SymbolicSnippetEncoder&quot;, type = OptionType.Expert)</span>
<span class="line-removed">-         public static final OptionKey&lt;Boolean&gt; UseEncodedSnippets = new OptionKey&lt;&gt;(false);</span>
<span class="line-removed">-         // @formatter:on</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     protected final OptionValues options;</span>
<span class="line-removed">- </span>
      public Providers getProviders() {
          return providers;
      }
  
      public void setProviders(Providers providers) {
<span class="line-new-header">--- 81,26 ---</span>
  import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
  import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
  import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  import org.graalvm.compiler.nodes.spi.Replacements;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.OptimisticOptimizations;
  import org.graalvm.compiler.phases.common.CanonicalizerPhase;
  import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
  import org.graalvm.compiler.phases.util.Providers;
  import org.graalvm.compiler.word.Word;
  import org.graalvm.compiler.word.WordOperationPlugin;
  
  import jdk.vm.ci.code.TargetDescription;
  import jdk.vm.ci.meta.MetaAccessProvider;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.ResolvedJavaType;
  
  public class ReplacementsImpl implements Replacements, InlineInvokePlugin {
  
<span class="line-modified">!     @Override</span>
      public Providers getProviders() {
          return providers;
      }
  
      public void setProviders(Providers providers) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 123,15 ***</span>
      public final SnippetReflectionProvider snippetReflection;
      public final TargetDescription target;
      private GraphBuilderConfiguration.Plugins graphBuilderPlugins;
      private final DebugHandlersFactory debugHandlersFactory;
  
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     public OptionValues getOptions() {</span>
<span class="line-removed">-         return options;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * The preprocessed replacement graphs.
       */
      protected final ConcurrentMap&lt;ResolvedJavaMethod, StructuredGraph&gt; graphs;
  
<span class="line-new-header">--- 111,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,23 ***</span>
       * @return an object specifying how {@code method} is to be inlined or null if it should not be
       *         inlined based on substitution related criteria
       */
      @Override
      public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
<span class="line-modified">!         Bytecode subst = getSubstitutionBytecode(method);</span>
<span class="line-modified">!         if (subst != null) {</span>
              if (b.parsingIntrinsic() || InlineDuringParsing.getValue(b.getOptions()) || InlineIntrinsicsDuringParsing.getValue(b.getOptions())) {
                  // Forced inlining of intrinsics
<span class="line-modified">!                 return createIntrinsicInlineInfo(subst.getMethod(), method, subst.getOrigin());</span>
              }
              return null;
          }
          if (b.parsingIntrinsic()) {
              assert b.getDepth() &lt; MAX_GRAPH_INLINING_DEPTH : &quot;inlining limit exceeded&quot;;
  
              // Force inlining when parsing replacements
<span class="line-modified">!             return createIntrinsicInlineInfo(method, null, defaultBytecodeProvider);</span>
          } else {
              assert IS_BUILDING_NATIVE_IMAGE || method.getAnnotation(NodeIntrinsic.class) == null : String.format(&quot;@%s method %s must only be called from within a replacement%n%s&quot;,
                              NodeIntrinsic.class.getSimpleName(),
                              method.format(&quot;%h.%n&quot;), b);
          }
<span class="line-new-header">--- 154,23 ---</span>
       * @return an object specifying how {@code method} is to be inlined or null if it should not be
       *         inlined based on substitution related criteria
       */
      @Override
      public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
<span class="line-modified">!         MethodSubstitutionPlugin msPlugin = getMethodSubstitution(method);</span>
<span class="line-modified">!         if (msPlugin != null) {</span>
              if (b.parsingIntrinsic() || InlineDuringParsing.getValue(b.getOptions()) || InlineIntrinsicsDuringParsing.getValue(b.getOptions())) {
                  // Forced inlining of intrinsics
<span class="line-modified">!                 return createMethodSubstitutionInlineInfo(method, msPlugin);</span>
              }
              return null;
          }
          if (b.parsingIntrinsic()) {
              assert b.getDepth() &lt; MAX_GRAPH_INLINING_DEPTH : &quot;inlining limit exceeded&quot;;
  
              // Force inlining when parsing replacements
<span class="line-modified">!             return createIntrinsicInlineInfo(method, defaultBytecodeProvider);</span>
          } else {
              assert IS_BUILDING_NATIVE_IMAGE || method.getAnnotation(NodeIntrinsic.class) == null : String.format(&quot;@%s method %s must only be called from within a replacement%n%s&quot;,
                              NodeIntrinsic.class.getSimpleName(),
                              method.format(&quot;%h.%n&quot;), b);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 216,13 ***</span>
  
      // This map is key&#39;ed by a class name instead of a Class object so that
      // it is stable across VM executions (in support of replay compilation).
      private final EconomicMap&lt;String, SnippetTemplateCache&gt; snippetTemplateCache;
  
<span class="line-modified">!     public ReplacementsImpl(OptionValues options, DebugHandlersFactory debugHandlersFactory, Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider,</span>
                      TargetDescription target) {
<span class="line-removed">-         this.options = options;</span>
          this.providers = providers.copyWith(this);
          this.snippetReflection = snippetReflection;
          this.target = target;
          this.graphs = new ConcurrentHashMap&lt;&gt;();
          this.snippetTemplateCache = EconomicMap.create(Equivalence.DEFAULT);
<span class="line-new-header">--- 199,12 ---</span>
  
      // This map is key&#39;ed by a class name instead of a Class object so that
      // it is stable across VM executions (in support of replay compilation).
      private final EconomicMap&lt;String, SnippetTemplateCache&gt; snippetTemplateCache;
  
<span class="line-modified">!     public ReplacementsImpl(DebugHandlersFactory debugHandlersFactory, Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider,</span>
                      TargetDescription target) {
          this.providers = providers.copyWith(this);
          this.snippetReflection = snippetReflection;
          this.target = target;
          this.graphs = new ConcurrentHashMap&lt;&gt;();
          this.snippetTemplateCache = EconomicMap.create(Equivalence.DEFAULT);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,28 ***</span>
  
      private static final TimerKey SnippetPreparationTime = DebugContext.timer(&quot;SnippetPreparationTime&quot;);
  
      private static final AtomicInteger nextDebugContextId = new AtomicInteger();
  
<span class="line-modified">!     public DebugContext openDebugContext(String idPrefix, ResolvedJavaMethod method) {</span>
<span class="line-modified">!         DebugContext outer = DebugContext.forCurrentThread();</span>
<span class="line-modified">!         Description description = new Description(method, idPrefix + nextDebugContextId.incrementAndGet());</span>
<span class="line-modified">!         List&lt;DebugHandlersFactory&gt; factories = debugHandlersFactory == null ? Collections.emptyList() : Collections.singletonList(debugHandlersFactory);</span>
<span class="line-modified">!         return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, factories);</span>
      }
  
      @Override
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     public StructuredGraph getSnippet(ResolvedJavaMethod method, ResolvedJavaMethod recursiveEntry, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>
          assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
          assert method.hasBytecodes() : &quot;Snippet must not be abstract or native&quot;;
  
          StructuredGraph graph = UseSnippetGraphCache.getValue(options) ? graphs.get(method) : null;
          if (graph == null || (trackNodeSourcePosition &amp;&amp; !graph.trackNodeSourcePosition())) {
<span class="line-modified">!             try (DebugContext debug = openDebugContext(&quot;Snippet_&quot;, method);</span>
                              DebugCloseable a = SnippetPreparationTime.start(debug)) {
<span class="line-modified">!                 StructuredGraph newGraph = makeGraph(debug, defaultBytecodeProvider, method, args, recursiveEntry, trackNodeSourcePosition, replaceePosition);</span>
                  DebugContext.counter(&quot;SnippetNodeCount[%#s]&quot;, method).add(newGraph.getDebug(), newGraph.getNodeCount());
                  if (!UseSnippetGraphCache.getValue(options) || args != null) {
                      return newGraph;
                  }
                  newGraph.freeze();
<span class="line-new-header">--- 215,32 ---</span>
  
      private static final TimerKey SnippetPreparationTime = DebugContext.timer(&quot;SnippetPreparationTime&quot;);
  
      private static final AtomicInteger nextDebugContextId = new AtomicInteger();
  
<span class="line-modified">!     public DebugContext openDebugContext(String idPrefix, ResolvedJavaMethod method, OptionValues options) {</span>
<span class="line-modified">!         if (DebugStubsAndSnippets.getValue(options)) {</span>
<span class="line-modified">!             DebugContext outer = DebugContext.forCurrentThread();</span>
<span class="line-modified">!             Description description = new Description(method, idPrefix + nextDebugContextId.incrementAndGet());</span>
<span class="line-modified">!             List&lt;DebugHandlersFactory&gt; factories = debugHandlersFactory == null ? Collections.emptyList() : Collections.singletonList(debugHandlersFactory);</span>
<span class="line-added">+             return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, factories);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return DebugContext.disabled(options);</span>
      }
  
      @Override
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     public StructuredGraph getSnippet(ResolvedJavaMethod method, ResolvedJavaMethod recursiveEntry, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition,</span>
<span class="line-added">+                     OptionValues options) {</span>
          assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
          assert method.hasBytecodes() : &quot;Snippet must not be abstract or native&quot;;
  
          StructuredGraph graph = UseSnippetGraphCache.getValue(options) ? graphs.get(method) : null;
          if (graph == null || (trackNodeSourcePosition &amp;&amp; !graph.trackNodeSourcePosition())) {
<span class="line-modified">!             try (DebugContext debug = openDebugContext(&quot;Snippet_&quot;, method, options);</span>
                              DebugCloseable a = SnippetPreparationTime.start(debug)) {
<span class="line-modified">!                 StructuredGraph newGraph = makeGraph(debug, defaultBytecodeProvider, method, args, recursiveEntry, trackNodeSourcePosition, replaceePosition, INLINE_AFTER_PARSING);</span>
                  DebugContext.counter(&quot;SnippetNodeCount[%#s]&quot;, method).add(newGraph.getDebug(), newGraph.getNodeCount());
                  if (!UseSnippetGraphCache.getValue(options) || args != null) {
                      return newGraph;
                  }
                  newGraph.freeze();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,14 ***</span>
          assert !trackNodeSourcePosition || graph.trackNodeSourcePosition();
          return graph;
      }
  
      @Override
<span class="line-modified">!     public void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition) {</span>
          // No initialization needed as snippet graphs are created on demand in getSnippet
      }
  
      @Override
      public boolean hasSubstitution(ResolvedJavaMethod method, int invokeBci) {
          InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
          return plugin != null &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0);
      }
<span class="line-new-header">--- 255,30 ---</span>
          assert !trackNodeSourcePosition || graph.trackNodeSourcePosition();
          return graph;
      }
  
      @Override
<span class="line-modified">!     public void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition, OptionValues options) {</span>
          // No initialization needed as snippet graphs are created on demand in getSnippet
      }
  
<span class="line-added">+     @Override</span>
<span class="line-added">+     public StructuredGraph getMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, IntrinsicContext.CompilationContext context,</span>
<span class="line-added">+                     StructuredGraph.AllowAssumptions allowAssumptions, Cancellable cancellable, OptionValues options) {</span>
<span class="line-added">+         // Method substitutions are parsed by the BytecodeParser.</span>
<span class="line-added">+         return null;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void registerMethodSubstitution(MethodSubstitutionPlugin plugin) {</span>
<span class="line-added">+         // No initialization needed as method substitutions are parsed by the BytecodeParser.</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void registerConditionalPlugin(InvocationPlugin plugin) {</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public boolean hasSubstitution(ResolvedJavaMethod method, int invokeBci) {
          InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
          return plugin != null &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 284,34 ***</span>
      @Override
      public BytecodeProvider getDefaultReplacementBytecodeProvider() {
          return defaultBytecodeProvider;
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-removed">-     public Bytecode getSubstitutionBytecode(ResolvedJavaMethod method) {</span>
          InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
          if (plugin instanceof MethodSubstitutionPlugin) {
              MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;
<span class="line-modified">!             ResolvedJavaMethod substitute = msPlugin.getSubstitute(providers.getMetaAccess());</span>
<span class="line-removed">-             return msPlugin.getBytecodeProvider().getBytecode(substitute);</span>
          }
          return null;
      }
  
      @Override
<span class="line-modified">!     public StructuredGraph getSubstitution(ResolvedJavaMethod method, int invokeBci, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>
          StructuredGraph result;
          InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
          if (plugin != null &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0)) {
              MetaAccessProvider metaAccess = providers.getMetaAccess();
              if (plugin instanceof MethodSubstitutionPlugin) {
                  MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;
                  ResolvedJavaMethod substitute = msPlugin.getSubstitute(metaAccess);
                  StructuredGraph graph = UseSnippetGraphCache.getValue(options) ? graphs.get(substitute) : null;
                  if (graph == null || graph.trackNodeSourcePosition() != trackNodeSourcePosition) {
<span class="line-modified">!                     try (DebugContext debug = openDebugContext(&quot;Substitution_&quot;, method)) {</span>
<span class="line-modified">!                         graph = makeGraph(debug, msPlugin.getBytecodeProvider(), substitute, null, method, trackNodeSourcePosition, replaceePosition);</span>
                          if (!UseSnippetGraphCache.getValue(options)) {
                              return graph;
                          }
                          graph.freeze();
                          graphs.putIfAbsent(substitute, graph);
<span class="line-new-header">--- 286,32 ---</span>
      @Override
      public BytecodeProvider getDefaultReplacementBytecodeProvider() {
          return defaultBytecodeProvider;
      }
  
<span class="line-modified">!     protected MethodSubstitutionPlugin getMethodSubstitution(ResolvedJavaMethod method) {</span>
          InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
          if (plugin instanceof MethodSubstitutionPlugin) {
              MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;
<span class="line-modified">!             return msPlugin;</span>
          }
          return null;
      }
  
      @Override
<span class="line-modified">!     public StructuredGraph getSubstitution(ResolvedJavaMethod method, int invokeBci, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition, OptionValues options) {</span>
          StructuredGraph result;
          InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
          if (plugin != null &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0)) {
              MetaAccessProvider metaAccess = providers.getMetaAccess();
              if (plugin instanceof MethodSubstitutionPlugin) {
                  MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;
                  ResolvedJavaMethod substitute = msPlugin.getSubstitute(metaAccess);
                  StructuredGraph graph = UseSnippetGraphCache.getValue(options) ? graphs.get(substitute) : null;
                  if (graph == null || graph.trackNodeSourcePosition() != trackNodeSourcePosition) {
<span class="line-modified">!                     try (DebugContext debug = openDebugContext(&quot;Substitution_&quot;, method, options)) {</span>
<span class="line-modified">!                         graph = makeGraph(debug, msPlugin.getBytecodeProvider(), substitute, null, method, trackNodeSourcePosition, replaceePosition, INLINE_AFTER_PARSING);</span>
                          if (!UseSnippetGraphCache.getValue(options)) {
                              return graph;
                          }
                          graph.freeze();
                          graphs.putIfAbsent(substitute, graph);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,45 ***</span>
                  }
                  assert graph.isFrozen();
                  result = graph;
              } else {
                  Bytecode code = new ResolvedJavaMethodBytecode(method);
<span class="line-modified">!                 ConstantReflectionProvider constantReflection = providers.getConstantReflection();</span>
<span class="line-modified">!                 ConstantFieldProvider constantFieldProvider = providers.getConstantFieldProvider();</span>
<span class="line-removed">-                 StampProvider stampProvider = providers.getStampProvider();</span>
<span class="line-removed">-                 try (DebugContext debug = openDebugContext(&quot;Substitution_&quot;, method)) {</span>
<span class="line-removed">-                     result = new IntrinsicGraphBuilder(options, debug, metaAccess, constantReflection, constantFieldProvider, stampProvider, code, invokeBci).buildGraph(plugin);</span>
                  }
              }
          } else {
              result = null;
          }
          return result;
      }
  
      @SuppressWarnings(&quot;try&quot;)
      @Override
<span class="line-modified">!     public StructuredGraph getIntrinsicGraph(ResolvedJavaMethod method, CompilationIdentifier compilationId, DebugContext debug) {</span>
<span class="line-modified">!         Bytecode subst = getSubstitutionBytecode(method);</span>
<span class="line-modified">!         if (subst != null) {</span>
<span class="line-modified">!             ResolvedJavaMethod substMethod = subst.getMethod();</span>
              assert !substMethod.equals(method);
<span class="line-modified">!             BytecodeProvider bytecodeProvider = subst.getOrigin();</span>
              // @formatter:off
<span class="line-modified">!             StructuredGraph graph = new StructuredGraph.Builder(options, debug, StructuredGraph.AllowAssumptions.YES).</span>
                      method(substMethod).
                      compilationId(compilationId).
                      recordInlinedMethods(bytecodeProvider.shouldRecordMethodDependencies()).
                      setIsSubstitution(true).
                      build();
              // @formatter:on
              try (DebugContext.Scope scope = debug.scope(&quot;GetIntrinsicGraph&quot;, graph)) {
                  Plugins plugins = new Plugins(getGraphBuilderPlugins());
                  GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);
                  IntrinsicContext initialReplacementContext = new IntrinsicContext(method, substMethod, bytecodeProvider, ROOT_COMPILATION);
<span class="line-modified">!                 new GraphBuilderPhase.Instance(providers.getMetaAccess(), providers.getStampProvider(), providers.getConstantReflection(), providers.getConstantFieldProvider(), config,</span>
<span class="line-removed">-                                 OptimisticOptimizations.NONE, initialReplacementContext).apply(graph);</span>
                  assert !graph.isFrozen();
                  return graph;
              } catch (Throwable e) {
                  debug.handle(e);
              }
<span class="line-new-header">--- 320,41 ---</span>
                  }
                  assert graph.isFrozen();
                  result = graph;
              } else {
                  Bytecode code = new ResolvedJavaMethodBytecode(method);
<span class="line-modified">!                 try (DebugContext debug = openDebugContext(&quot;Substitution_&quot;, method, options)) {</span>
<span class="line-modified">!                     result = new IntrinsicGraphBuilder(options, debug, providers, code, invokeBci).buildGraph(plugin);</span>
                  }
              }
          } else {
              result = null;
          }
          return result;
      }
  
      @SuppressWarnings(&quot;try&quot;)
      @Override
<span class="line-modified">!     public StructuredGraph getIntrinsicGraph(ResolvedJavaMethod method, CompilationIdentifier compilationId, DebugContext debug, Cancellable cancellable) {</span>
<span class="line-modified">!         MethodSubstitutionPlugin msPlugin = getMethodSubstitution(method);</span>
<span class="line-modified">!         if (msPlugin != null) {</span>
<span class="line-modified">!             ResolvedJavaMethod substMethod = msPlugin.getSubstitute(providers.getMetaAccess());</span>
              assert !substMethod.equals(method);
<span class="line-modified">!             BytecodeProvider bytecodeProvider = msPlugin.getBytecodeProvider();</span>
              // @formatter:off
<span class="line-modified">!             StructuredGraph graph = new StructuredGraph.Builder(debug.getOptions(), debug, StructuredGraph.AllowAssumptions.YES).</span>
                      method(substMethod).
                      compilationId(compilationId).
                      recordInlinedMethods(bytecodeProvider.shouldRecordMethodDependencies()).
                      setIsSubstitution(true).
                      build();
              // @formatter:on
              try (DebugContext.Scope scope = debug.scope(&quot;GetIntrinsicGraph&quot;, graph)) {
                  Plugins plugins = new Plugins(getGraphBuilderPlugins());
                  GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);
                  IntrinsicContext initialReplacementContext = new IntrinsicContext(method, substMethod, bytecodeProvider, ROOT_COMPILATION);
<span class="line-modified">!                 new GraphBuilderPhase.Instance(providers, config, OptimisticOptimizations.NONE, initialReplacementContext).apply(graph);</span>
                  assert !graph.isFrozen();
                  return graph;
              } catch (Throwable e) {
                  debug.handle(e);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 372,15 ***</span>
       * @param bytecodeProvider how to access the bytecode of {@code method}
       * @param method the snippet or method substitution for which a graph will be created
       * @param args
       * @param original the original method if {@code method} is a {@linkplain MethodSubstitution
       *            substitution} otherwise null
<span class="line-modified">!      * @param trackNodeSourcePosition</span>
       */
      public StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, ResolvedJavaMethod method, Object[] args, ResolvedJavaMethod original, boolean trackNodeSourcePosition,
<span class="line-modified">!                     NodeSourcePosition replaceePosition) {</span>
<span class="line-modified">!         return createGraphMaker(method, original).makeGraph(debug, bytecodeProvider, args, trackNodeSourcePosition, replaceePosition);</span>
      }
  
      /**
       * Can be overridden to return an object that specializes various parts of graph preprocessing.
       */
<span class="line-new-header">--- 368,36 ---</span>
       * @param bytecodeProvider how to access the bytecode of {@code method}
       * @param method the snippet or method substitution for which a graph will be created
       * @param args
       * @param original the original method if {@code method} is a {@linkplain MethodSubstitution
       *            substitution} otherwise null
<span class="line-modified">!      * @param trackNodeSourcePosition record source information</span>
<span class="line-added">+      * @param context</span>
<span class="line-added">+      *            {@link org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext</span>
<span class="line-added">+      *            compilation context} for the graph</span>
       */
      public StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, ResolvedJavaMethod method, Object[] args, ResolvedJavaMethod original, boolean trackNodeSourcePosition,
<span class="line-modified">!                     NodeSourcePosition replaceePosition, IntrinsicContext.CompilationContext context) {</span>
<span class="line-modified">!         return createGraphMaker(method, original).makeGraph(debug, bytecodeProvider, args, trackNodeSourcePosition, replaceePosition, context);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Creates a preprocessed graph for a snippet or method substitution with a context of .</span>
<span class="line-added">+      * {@link org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext#INLINE_AFTER_PARSING}</span>
<span class="line-added">+      * .</span>
<span class="line-added">+      *</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param bytecodeProvider how to access the bytecode of {@code method}</span>
<span class="line-added">+      * @param method the snippet or method substitution for which a graph will be created</span>
<span class="line-added">+      * @param args</span>
<span class="line-added">+      * @param original the original method if {@code method} is a {@linkplain MethodSubstitution</span>
<span class="line-added">+      *            substitution} otherwise null</span>
<span class="line-added">+      * @param trackNodeSourcePosition record source information</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public final StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, ResolvedJavaMethod method, Object[] args, ResolvedJavaMethod original,</span>
<span class="line-added">+                     boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>
<span class="line-added">+         return makeGraph(debug, bytecodeProvider, method, args, original, trackNodeSourcePosition, replaceePosition, INLINE_AFTER_PARSING);</span>
      }
  
      /**
       * Can be overridden to return an object that specializes various parts of graph preprocessing.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 413,14 ***</span>
              this.method = substitute;
              this.substitutedMethod = substitutedMethod;
          }
  
          @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!         public StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>
              try (DebugContext.Scope s = debug.scope(&quot;BuildSnippetGraph&quot;, method)) {
                  assert method.hasBytecodes() : method;
<span class="line-modified">!                 StructuredGraph graph = buildInitialGraph(debug, bytecodeProvider, method, args, trackNodeSourcePosition, replaceePosition);</span>
  
                  finalizeGraph(graph);
  
                  debug.dump(DebugContext.INFO_LEVEL, graph, &quot;%s: Final&quot;, method.getName());
  
<span class="line-new-header">--- 430,15 ---</span>
              this.method = substitute;
              this.substitutedMethod = substitutedMethod;
          }
  
          @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!         public StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition,</span>
<span class="line-added">+                         IntrinsicContext.CompilationContext context) {</span>
              try (DebugContext.Scope s = debug.scope(&quot;BuildSnippetGraph&quot;, method)) {
                  assert method.hasBytecodes() : method;
<span class="line-modified">!                 StructuredGraph graph = buildInitialGraph(debug, bytecodeProvider, method, args, trackNodeSourcePosition, replaceePosition, context);</span>
  
                  finalizeGraph(graph);
  
                  debug.dump(DebugContext.INFO_LEVEL, graph, &quot;%s: Final&quot;, method.getName());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 432,11 ***</span>
  
          /**
           * Does final processing of a snippet graph.
           */
          protected void finalizeGraph(StructuredGraph graph) {
<span class="line-modified">!             if (!GraalOptions.SnippetCounters.getValue(replacements.options) || graph.getNodes().filter(SnippetCounterNode.class).isEmpty()) {</span>
                  int sideEffectCount = 0;
                  assert (sideEffectCount = graph.getNodes().filter(e -&gt; hasSideEffect(e)).count()) &gt;= 0;
                  new ConvertDeoptimizeToGuardPhase().apply(graph, null);
                  assert sideEffectCount == graph.getNodes().filter(e -&gt; hasSideEffect(e)).count() : &quot;deleted side effecting node&quot;;
  
<span class="line-new-header">--- 450,11 ---</span>
  
          /**
           * Does final processing of a snippet graph.
           */
          protected void finalizeGraph(StructuredGraph graph) {
<span class="line-modified">!             if (!GraalOptions.SnippetCounters.getValue(graph.getOptions()) || graph.getNodes().filter(SnippetCounterNode.class).isEmpty()) {</span>
                  int sideEffectCount = 0;
                  assert (sideEffectCount = graph.getNodes().filter(e -&gt; hasSideEffect(e)).count()) &gt;= 0;
                  new ConvertDeoptimizeToGuardPhase().apply(graph, null);
                  assert sideEffectCount == graph.getNodes().filter(e -&gt; hasSideEffect(e)).count() : &quot;deleted side effecting node&quot;;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 476,20 ***</span>
              }
              // Not a StateSplit
              return false;
          }
  
          /**
           * Builds the initial graph for a replacement.
           */
          @SuppressWarnings(&quot;try&quot;)
          protected StructuredGraph buildInitialGraph(DebugContext debug, BytecodeProvider bytecodeProvider, final ResolvedJavaMethod methodToParse, Object[] args, boolean trackNodeSourcePosition,
<span class="line-modified">!                         NodeSourcePosition replaceePosition) {</span>
              // @formatter:off
              // Replacements cannot have optimistic assumptions since they have
              // to be valid for the entire run of the VM.
<span class="line-modified">!             final StructuredGraph graph = new StructuredGraph.Builder(replacements.options, debug).</span>
                              method(methodToParse).
                              trackNodeSourcePosition(trackNodeSourcePosition).
                              callerContext(replaceePosition).
                              setIsSubstitution(true).
                              build();
<span class="line-new-header">--- 494,43 ---</span>
              }
              // Not a StateSplit
              return false;
          }
  
<span class="line-added">+         static class EncodedIntrinsicContext extends IntrinsicContext {</span>
<span class="line-added">+             EncodedIntrinsicContext(ResolvedJavaMethod method, ResolvedJavaMethod intrinsic, BytecodeProvider bytecodeProvider, CompilationContext compilationContext,</span>
<span class="line-added">+                             boolean allowPartialIntrinsicArgumentMismatch) {</span>
<span class="line-added">+                 super(method, intrinsic, bytecodeProvider, compilationContext, allowPartialIntrinsicArgumentMismatch);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public boolean isDeferredInvoke(StateSplit stateSplit) {</span>
<span class="line-added">+                 if (stateSplit instanceof Invoke) {</span>
<span class="line-added">+                     Invoke invoke = (Invoke) stateSplit;</span>
<span class="line-added">+                     ResolvedJavaMethod method = invoke.callTarget().targetMethod();</span>
<span class="line-added">+                     if (method.getAnnotation(Fold.class) != null) {</span>
<span class="line-added">+                         return true;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     Node.NodeIntrinsic annotation = method.getAnnotation(Node.NodeIntrinsic.class);</span>
<span class="line-added">+                     if (annotation != null &amp;&amp; !annotation.hasSideEffect()) {</span>
<span class="line-added">+                         return true;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          /**
           * Builds the initial graph for a replacement.
           */
          @SuppressWarnings(&quot;try&quot;)
          protected StructuredGraph buildInitialGraph(DebugContext debug, BytecodeProvider bytecodeProvider, final ResolvedJavaMethod methodToParse, Object[] args, boolean trackNodeSourcePosition,
<span class="line-modified">!                         NodeSourcePosition replaceePosition, IntrinsicContext.CompilationContext context) {</span>
              // @formatter:off
              // Replacements cannot have optimistic assumptions since they have
              // to be valid for the entire run of the VM.
<span class="line-modified">!             final StructuredGraph graph = new StructuredGraph.Builder(debug.getOptions(), debug).</span>
                              method(methodToParse).
                              trackNodeSourcePosition(trackNodeSourcePosition).
                              callerContext(replaceePosition).
                              setIsSubstitution(true).
                              build();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 511,32 ***</span>
                  IntrinsicContext initialIntrinsicContext = null;
                  Snippet snippetAnnotation = method.getAnnotation(Snippet.class);
                  MethodSubstitution methodAnnotation = method.getAnnotation(MethodSubstitution.class);
                  if (methodAnnotation == null &amp;&amp; snippetAnnotation == null) {
                      // Post-parse inlined intrinsic
<span class="line-modified">!                     initialIntrinsicContext = new IntrinsicContext(substitutedMethod, method, bytecodeProvider, INLINE_AFTER_PARSING);</span>
                  } else {
                      // Snippet
                      ResolvedJavaMethod original = substitutedMethod != null ? substitutedMethod : method;
<span class="line-modified">!                     initialIntrinsicContext = new IntrinsicContext(original, method, bytecodeProvider, INLINE_AFTER_PARSING,</span>
                                      snippetAnnotation != null ? snippetAnnotation.allowPartialIntrinsicArgumentMismatch() : true);
                  }
  
<span class="line-modified">!                 createGraphBuilder(metaAccess, replacements.providers.getStampProvider(), replacements.providers.getConstantReflection(), replacements.providers.getConstantFieldProvider(), config,</span>
<span class="line-removed">-                                 OptimisticOptimizations.NONE, initialIntrinsicContext).apply(graph);</span>
  
<span class="line-modified">!                 new CanonicalizerPhase().apply(graph, new PhaseContext(replacements.providers));</span>
              } catch (Throwable e) {
                  throw debug.handle(e);
              }
              return graph;
          }
  
<span class="line-modified">!         protected Instance createGraphBuilder(MetaAccessProvider metaAccess, StampProvider stampProvider, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,</span>
<span class="line-modified">!                         GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-removed">-             return new GraphBuilderPhase.Instance(metaAccess, stampProvider, constantReflection, constantFieldProvider, graphBuilderConfig, optimisticOpts,</span>
<span class="line-removed">-                             initialIntrinsicContext);</span>
          }
      }
  
      @Override
      public void registerSnippetTemplateCache(SnippetTemplateCache templates) {
<span class="line-new-header">--- 552,29 ---</span>
                  IntrinsicContext initialIntrinsicContext = null;
                  Snippet snippetAnnotation = method.getAnnotation(Snippet.class);
                  MethodSubstitution methodAnnotation = method.getAnnotation(MethodSubstitution.class);
                  if (methodAnnotation == null &amp;&amp; snippetAnnotation == null) {
                      // Post-parse inlined intrinsic
<span class="line-modified">!                     initialIntrinsicContext = new EncodedIntrinsicContext(substitutedMethod, method, bytecodeProvider, context, false);</span>
                  } else {
                      // Snippet
                      ResolvedJavaMethod original = substitutedMethod != null ? substitutedMethod : method;
<span class="line-modified">!                     initialIntrinsicContext = new EncodedIntrinsicContext(original, method, bytecodeProvider, context,</span>
                                      snippetAnnotation != null ? snippetAnnotation.allowPartialIntrinsicArgumentMismatch() : true);
                  }
  
<span class="line-modified">!                 createGraphBuilder(replacements.providers, config, OptimisticOptimizations.NONE, initialIntrinsicContext).apply(graph);</span>
  
<span class="line-modified">!                 CanonicalizerPhase.create().apply(graph, replacements.providers);</span>
              } catch (Throwable e) {
                  throw debug.handle(e);
              }
              return graph;
          }
  
<span class="line-modified">!         protected Instance createGraphBuilder(Providers providers, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-modified">!             return new GraphBuilderPhase.Instance(providers, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);</span>
          }
      }
  
      @Override
      public void registerSnippetTemplateCache(SnippetTemplateCache templates) {
</pre>
<center><a href="PEGraphDecoder.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SnippetCounter.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
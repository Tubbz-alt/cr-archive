<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SnippetCounterNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="StandardGraphBuilderPlugins.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 102 import org.graalvm.compiler.nodes.PiNode.PlaceholderStamp;
 103 import org.graalvm.compiler.nodes.ReturnNode;
 104 import org.graalvm.compiler.nodes.StartNode;
 105 import org.graalvm.compiler.nodes.StateSplit;
 106 import org.graalvm.compiler.nodes.StructuredGraph;
 107 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
 108 import org.graalvm.compiler.nodes.ValueNode;
 109 import org.graalvm.compiler.nodes.ValueNodeUtil;
 110 import org.graalvm.compiler.nodes.calc.FloatingNode;
 111 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 112 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 113 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 114 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 115 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
 116 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;
 117 import org.graalvm.compiler.nodes.memory.MemoryMap;
 118 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
 119 import org.graalvm.compiler.nodes.memory.MemoryNode;
 120 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
 121 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;

 122 import org.graalvm.compiler.nodes.spi.LoweringTool;
 123 import org.graalvm.compiler.nodes.spi.MemoryProxy;
 124 import org.graalvm.compiler.nodes.util.GraphUtil;
 125 import org.graalvm.compiler.options.Option;
 126 import org.graalvm.compiler.options.OptionKey;
 127 import org.graalvm.compiler.options.OptionValues;
 128 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 129 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 130 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 131 import org.graalvm.compiler.phases.common.FloatingReadPhase.MemoryMapImpl;
 132 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 133 import org.graalvm.compiler.phases.common.LoweringPhase;
 134 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 135 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
<span class="line-removed"> 136 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 137 import org.graalvm.compiler.phases.util.Providers;
 138 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
 139 import org.graalvm.compiler.replacements.nodes.LoadSnippetVarargParameterNode;
 140 import org.graalvm.util.CollectionsUtil;
 141 import jdk.internal.vm.compiler.word.LocationIdentity;
 142 import jdk.internal.vm.compiler.word.WordBase;
 143 
 144 import jdk.vm.ci.code.TargetDescription;
 145 import jdk.vm.ci.meta.Constant;
 146 import jdk.vm.ci.meta.ConstantReflectionProvider;
 147 import jdk.vm.ci.meta.JavaConstant;
 148 import jdk.vm.ci.meta.JavaKind;
 149 import jdk.vm.ci.meta.Local;
 150 import jdk.vm.ci.meta.LocalVariableTable;
 151 import jdk.vm.ci.meta.MetaAccessProvider;
 152 import jdk.vm.ci.meta.ResolvedJavaMethod;
 153 import jdk.vm.ci.meta.ResolvedJavaMethod.Parameter;
 154 import jdk.vm.ci.meta.ResolvedJavaType;
 155 import jdk.vm.ci.meta.Signature;
 156 
</pre>
<hr />
<pre>
 616         protected final Providers providers;
 617         protected final SnippetReflectionProvider snippetReflection;
 618         protected final Iterable&lt;DebugHandlersFactory&gt; factories;
 619         protected final TargetDescription target;
 620         private final Map&lt;CacheKey, SnippetTemplate&gt; templates;
 621 
 622         protected AbstractTemplates(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, Providers providers, SnippetReflectionProvider snippetReflection, TargetDescription target) {
 623             this.options = options;
 624             this.providers = providers;
 625             this.snippetReflection = snippetReflection;
 626             this.target = target;
 627             this.factories = factories;
 628             if (Options.UseSnippetTemplateCache.getValue(options)) {
 629                 int size = Options.MaxTemplatesPerSnippet.getValue(options);
 630                 this.templates = Collections.synchronizedMap(new LRUCache&lt;&gt;(size, size));
 631             } else {
 632                 this.templates = null;
 633             }
 634         }
 635 




 636         public static Method findMethod(Class&lt;? extends Snippets&gt; declaringClass, String methodName, Method except) {
 637             for (Method m : declaringClass.getDeclaredMethods()) {
 638                 if (m.getName().equals(methodName) &amp;&amp; !m.equals(except)) {
 639                     return m;
 640                 }
 641             }
 642             return null;
 643         }
 644 
 645         public static ResolvedJavaMethod findMethod(MetaAccessProvider metaAccess, Class&lt;?&gt; declaringClass, String methodName) {
 646             ResolvedJavaType type = metaAccess.lookupJavaType(declaringClass);
 647             ResolvedJavaMethod result = null;
 648             for (ResolvedJavaMethod m : type.getDeclaredMethods()) {
 649                 if (m.getName().equals(methodName)) {
 650                     if (!Assertions.assertionsEnabled()) {
 651                         return m;
 652                     } else {
 653                         assert result == null : &quot;multiple definitions found&quot;;
 654                         result = m;
 655                     }
</pre>
<hr />
<pre>
 658             if (result == null) {
 659                 throw new GraalError(&quot;Could not find method in &quot; + declaringClass + &quot; named &quot; + methodName);
 660             }
 661             return result;
 662         }
 663 
 664         protected SnippetInfo snippet(Class&lt;? extends Snippets&gt; declaringClass, String methodName, LocationIdentity... initialPrivateLocations) {
 665             return snippet(declaringClass, methodName, null, null, initialPrivateLocations);
 666         }
 667 
 668         /**
 669          * Finds the unique method in {@code declaringClass} named {@code methodName} annotated by
 670          * {@link Snippet} and returns a {@link SnippetInfo} value describing it. There must be
 671          * exactly one snippet method in {@code declaringClass} with a given name.
 672          */
 673         protected SnippetInfo snippet(Class&lt;? extends Snippets&gt; declaringClass, String methodName, ResolvedJavaMethod original, Object receiver, LocationIdentity... initialPrivateLocations) {
 674             assert methodName != null;
 675             ResolvedJavaMethod javaMethod = findMethod(providers.getMetaAccess(), declaringClass, methodName);
 676             assert javaMethod != null : &quot;did not find @&quot; + Snippet.class.getSimpleName() + &quot; method in &quot; + declaringClass + &quot; named &quot; + methodName;
 677             assert javaMethod.getAnnotation(Snippet.class) != null : javaMethod + &quot; must be annotated with @&quot; + Snippet.class.getSimpleName();
<span class="line-modified"> 678             providers.getReplacements().registerSnippet(javaMethod, original, receiver, GraalOptions.TrackNodeSourcePosition.getValue(options));</span>
 679             LocationIdentity[] privateLocations = GraalOptions.SnippetCounters.getValue(options) ? SnippetCounterNode.addSnippetCounters(initialPrivateLocations) : initialPrivateLocations;
 680             if (GraalOptions.EagerSnippets.getValue(options)) {
 681                 return new EagerSnippetInfo(javaMethod, original, privateLocations, receiver);
 682             } else {
 683                 return new LazySnippetInfo(javaMethod, original, privateLocations, receiver);
 684             }
 685         }
 686 
 687         static final AtomicInteger nextSnippetTemplateId = new AtomicInteger();
 688 
 689         private DebugContext openDebugContext(DebugContext outer, Arguments args) {
 690             if (DebugStubsAndSnippets.getValue(options)) {
 691                 Description description = new Description(args.cacheKey.method, &quot;SnippetTemplate_&quot; + nextSnippetTemplateId.incrementAndGet());
 692                 return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, factories);
 693             }
<span class="line-modified"> 694             return DebugContext.DISABLED;</span>
 695         }
 696 
 697         /**
 698          * Gets a template for a given key, creating it first if necessary.
 699          */
 700         @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 701         protected SnippetTemplate template(ValueNode replacee, final Arguments args) {</span>
 702             StructuredGraph graph = replacee.graph();
 703             DebugContext outer = graph.getDebug();
 704             SnippetTemplate template = Options.UseSnippetTemplateCache.getValue(options) &amp;&amp; args.cacheable ? templates.get(args.cacheKey) : null;
 705             if (template == null || (graph.trackNodeSourcePosition() &amp;&amp; !template.snippet.trackNodeSourcePosition())) {
 706                 try (DebugContext debug = openDebugContext(outer, args)) {
 707                     try (DebugCloseable a = SnippetTemplateCreationTime.start(debug); DebugContext.Scope s = debug.scope(&quot;SnippetSpecialization&quot;, args.info.method)) {
 708                         SnippetTemplates.increment(debug);
 709                         OptionValues snippetOptions = new OptionValues(options, GraalOptions.TraceInlining, GraalOptions.TraceInliningForStubsAndSnippets.getValue(options));
 710                         template = new SnippetTemplate(snippetOptions, debug, providers, snippetReflection, args, graph.trackNodeSourcePosition(), replacee);
 711                         if (Options.UseSnippetTemplateCache.getValue(snippetOptions) &amp;&amp; args.cacheable) {
 712                             templates.put(args.cacheKey, template);
 713                         }
 714                     } catch (Throwable e) {
 715                         throw debug.handle(e);
 716                     }
 717                 }
 718             }
 719             return template;
 720         }
 721     }
</pre>
<hr />
<pre>
 747             if (p != null) {
 748                 return true;
 749             }
 750         }
 751         return false;
 752     }
 753 
 754     private final SnippetReflectionProvider snippetReflection;
 755 
 756     /**
 757      * Creates a snippet template.
 758      */
 759     @SuppressWarnings(&quot;try&quot;)
 760     protected SnippetTemplate(OptionValues options, DebugContext debug, final Providers providers, SnippetReflectionProvider snippetReflection, Arguments args, boolean trackNodeSourcePosition,
 761                     Node replacee) {
 762         this.snippetReflection = snippetReflection;
 763         this.info = args.info;
 764 
 765         Object[] constantArgs = getConstantArgs(args);
 766         boolean shouldTrackNodeSourcePosition1 = trackNodeSourcePosition || (providers.getCodeCache() != null &amp;&amp; providers.getCodeCache().shouldDebugNonSafepoints());
<span class="line-modified"> 767         StructuredGraph snippetGraph = providers.getReplacements().getSnippet(args.info.method, args.info.original, constantArgs, shouldTrackNodeSourcePosition1, replacee.getNodeSourcePosition());</span>

 768 
 769         ResolvedJavaMethod method = snippetGraph.method();
 770         Signature signature = method.getSignature();
 771 
<span class="line-removed"> 772         PhaseContext phaseContext = new PhaseContext(providers);</span>
<span class="line-removed"> 773 </span>
 774         // Copy snippet graph, replacing constant parameters with given arguments
 775         final StructuredGraph snippetCopy = new StructuredGraph.Builder(options, debug).name(snippetGraph.name).method(snippetGraph.method()).trackNodeSourcePosition(
 776                         snippetGraph.trackNodeSourcePosition()).setIsSubstitution(true).build();
 777         assert !GraalOptions.TrackNodeSourcePosition.getValue(options) || snippetCopy.trackNodeSourcePosition();
 778         try (DebugContext.Scope scope = debug.scope(&quot;SpecializeSnippet&quot;, snippetCopy)) {
 779             if (!snippetGraph.isUnsafeAccessTrackingEnabled()) {
 780                 snippetCopy.disableUnsafeAccessTracking();
 781             }
 782 
 783             EconomicMap&lt;Node, Node&gt; nodeReplacements = EconomicMap.create(Equivalence.IDENTITY);
 784             nodeReplacements.put(snippetGraph.start(), snippetCopy.start());
 785 
 786             MetaAccessProvider metaAccess = providers.getMetaAccess();
 787             assert checkTemplate(metaAccess, args, method, signature);
 788 
 789             int parameterCount = args.info.getParameterCount();
 790             VarargsPlaceholderNode[] placeholders = new VarargsPlaceholderNode[parameterCount];
 791 
 792             for (int i = 0; i &lt; parameterCount; i++) {
 793                 ParameterNode parameter = snippetGraph.getParameter(i);
</pre>
<hr />
<pre>
 862                                 /*
 863                                  * The template lowering doesn&#39;t really treat this as an array so
 864                                  * you can&#39;t store back into the varargs. Allocate your own array if
 865                                  * you really need this and EA should eliminate it.
 866                                  */
 867                                 throw new GraalError(&quot;Can&#39;t store into VarargsParameter array&quot;);
 868                             }
 869                         }
 870                     }
 871                 } else {
 872                     ParameterNode local = snippetCopy.getParameter(i);
 873                     if (local == null) {
 874                         // Parameter value was eliminated
 875                         parameters[i] = UNUSED_PARAMETER;
 876                     } else {
 877                         parameters[i] = local;
 878                     }
 879                 }
 880             }
 881 
<span class="line-modified"> 882             explodeLoops(snippetCopy, phaseContext);</span>
 883 
 884             GuardsStage guardsStage = args.cacheKey.guardsStage;
 885             // Perform lowering on the snippet
 886             if (!guardsStage.allowsFloatingGuards()) {
 887                 new GuardLoweringPhase().apply(snippetCopy, null);
 888             }
 889             snippetCopy.setGuardsStage(guardsStage);
 890             try (DebugContext.Scope s = debug.scope(&quot;LoweringSnippetTemplate&quot;, snippetCopy)) {
<span class="line-modified"> 891                 new LoweringPhase(new CanonicalizerPhase(), args.cacheKey.loweringStage).apply(snippetCopy, phaseContext);</span>
 892             } catch (Throwable e) {
 893                 throw debug.handle(e);
 894             }
 895 
 896             ArrayList&lt;StateSplit&gt; curSideEffectNodes = new ArrayList&lt;&gt;();
 897             ArrayList&lt;DeoptimizingNode&gt; curDeoptNodes = new ArrayList&lt;&gt;();
 898             ArrayList&lt;ValueNode&gt; curPlaceholderStampedNodes = new ArrayList&lt;&gt;();
 899             for (Node node : snippetCopy.getNodes()) {
 900                 if (node instanceof ValueNode) {
 901                     ValueNode valueNode = (ValueNode) node;
 902                     if (valueNode.stamp(NodeView.DEFAULT) == PlaceholderStamp.singleton()) {
 903                         curPlaceholderStampedNodes.add(valueNode);
 904                     }
 905                 }
 906 
 907                 if (node instanceof StateSplit) {
 908                     StateSplit stateSplit = (StateSplit) node;
 909                     FrameState frameState = stateSplit.stateAfter();
 910                     if (stateSplit.hasSideEffect()) {
 911                         curSideEffectNodes.add((StateSplit) node);
 912                     }
 913                     if (frameState != null) {
 914                         stateSplit.setStateAfter(null);
 915                     }
 916                 }
 917                 if (node instanceof DeoptimizingNode) {
 918                     DeoptimizingNode deoptNode = (DeoptimizingNode) node;
 919                     if (deoptNode.canDeoptimize()) {
 920                         curDeoptNodes.add(deoptNode);
 921                     }
 922                 }
 923             }
 924 
 925             new DeadCodeEliminationPhase(Required).apply(snippetCopy);
 926 
 927             assert checkAllVarargPlaceholdersAreDeleted(parameterCount, placeholders);
 928 
 929             new FloatingReadPhase(true, true).apply(snippetCopy);
<span class="line-modified"> 930             new RemoveValueProxyPhase().apply(snippetCopy);</span>



 931 
 932             MemoryAnchorNode anchor = snippetCopy.add(new MemoryAnchorNode());
 933             snippetCopy.start().replaceAtUsages(InputType.Memory, anchor);
 934 
 935             this.snippet = snippetCopy;
 936 
 937             StartNode entryPointNode = snippet.start();
 938             if (anchor.hasNoUsages()) {
 939                 anchor.safeDelete();
 940                 this.memoryAnchor = null;
 941             } else {
 942                 // Find out if all the return memory maps point to the anchor (i.e., there&#39;s no kill
 943                 // anywhere)
 944                 boolean needsMemoryMaps = false;
 945                 for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 946                     MemoryMapNode memoryMap = retNode.getMemoryMap();
 947                     if (memoryMap.getLocations().size() &gt; 1 || memoryMap.getLastLocationAccess(LocationIdentity.any()) != anchor) {
 948                         needsMemoryMaps = true;
 949                         break;
 950                     }
 951                 }
 952                 boolean needsAnchor;
 953                 if (needsMemoryMaps) {
 954                     needsAnchor = true;
 955                 } else {
 956                     // Check that all those memory maps where the only usages of the anchor
 957                     needsAnchor = anchor.usages().filter(isNotA(MemoryMapNode.class)).isNotEmpty();
 958                     // Remove the useless memory map
 959                     MemoryMapNode memoryMap = null;
 960                     for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 961                         if (memoryMap == null) {
 962                             memoryMap = retNode.getMemoryMap();
 963                         } else {
 964                             assert memoryMap == retNode.getMemoryMap();
 965                         }
 966                         retNode.setMemoryMap(null);
 967                     }
<span class="line-modified"> 968                     memoryMap.safeDelete();</span>


 969                 }
 970                 if (needsAnchor) {
 971                     snippetCopy.addAfterFixed(snippetCopy.start(), anchor);
 972                     this.memoryAnchor = anchor;
 973                 } else {
 974                     anchor.safeDelete();
 975                     this.memoryAnchor = null;
 976                 }
 977             }
 978             debug.dump(DebugContext.INFO_LEVEL, snippet, &quot;SnippetTemplate after fixing memory anchoring&quot;);
 979 
 980             List&lt;ReturnNode&gt; returnNodes = snippet.getNodes(ReturnNode.TYPE).snapshot();
 981             if (returnNodes.isEmpty()) {
 982                 this.returnNode = null;
 983             } else if (returnNodes.size() == 1) {
 984                 this.returnNode = returnNodes.get(0);
 985             } else {
 986                 AbstractMergeNode merge = snippet.add(new MergeNode());
 987                 List&lt;MemoryMapNode&gt; memMaps = new ArrayList&lt;&gt;();
 988                 for (ReturnNode retNode : returnNodes) {
</pre>
<hr />
<pre>
1025                 DebugContext.counter(&quot;SnippetTemplateNodeCount[%#s]&quot;, args).add(debug, nodes.size());
1026             }
1027             debug.dump(DebugContext.INFO_LEVEL, snippet, &quot;SnippetTemplate final state&quot;);
1028             this.snippet.freeze();
1029 
1030         } catch (Throwable ex) {
1031             throw debug.handle(ex);
1032         }
1033     }
1034 
1035     private static boolean verifyIntrinsicsProcessed(StructuredGraph snippetCopy) {
1036         for (MethodCallTargetNode target : snippetCopy.getNodes(MethodCallTargetNode.TYPE)) {
1037             ResolvedJavaMethod targetMethod = target.targetMethod();
1038             if (targetMethod != null) {
1039                 assert targetMethod.getAnnotation(Fold.class) == null &amp;&amp; targetMethod.getAnnotation(NodeIntrinsic.class) == null : &quot;plugin should have been processed&quot;;
1040             }
1041         }
1042         return true;
1043     }
1044 
<span class="line-modified">1045     public static void explodeLoops(final StructuredGraph snippetCopy, PhaseContext phaseContext) {</span>
1046         // Do any required loop explosion
1047         boolean exploded = false;
1048         do {
1049             exploded = false;
1050             ExplodeLoopNode explodeLoop = snippetCopy.getNodes().filter(ExplodeLoopNode.class).first();
1051             if (explodeLoop != null) { // Earlier canonicalization may have removed the loop
1052                 // altogether
1053                 LoopBeginNode loopBegin = explodeLoop.findLoopBegin();
1054                 if (loopBegin != null) {
1055                     LoopEx loop = new LoopsData(snippetCopy).loop(loopBegin);
1056                     Mark mark = snippetCopy.getMark();
<span class="line-modified">1057                     LoopTransformations.fullUnroll(loop, phaseContext, new CanonicalizerPhase());</span>
<span class="line-modified">1058                     new CanonicalizerPhase().applyIncremental(snippetCopy, phaseContext, mark, false);</span>






1059                     loop.deleteUnusedNodes();
1060                 }
1061                 GraphUtil.removeFixedWithUnusedInputs(explodeLoop);
1062                 exploded = true;
1063             }
1064         } while (exploded);
1065     }
1066 
1067     protected Object[] getConstantArgs(Arguments args) {
1068         Object[] constantArgs = args.values.clone();
1069         for (int i = 0; i &lt; args.info.getParameterCount(); i++) {
1070             if (!args.info.isConstantParameter(i)) {
1071                 constantArgs[i] = null;
1072             } else {
1073                 assert constantArgs[i] != null : &quot;Can&#39;t pass raw null through as argument&quot;;
1074             }
1075         }
1076         return constantArgs;
1077     }
1078 
</pre>
<hr />
<pre>
1256     private boolean assertSnippetKills(ValueNode replacee) {
1257         if (!replacee.graph().isAfterFloatingReadPhase()) {
1258             // no floating reads yet, ignore locations created while lowering
1259             return true;
1260         }
1261         if (returnNode == null) {
1262             // The snippet terminates control flow
1263             return true;
1264         }
1265         MemoryMapNode memoryMap = returnNode.getMemoryMap();
1266         if (memoryMap == null || memoryMap.isEmpty()) {
1267             // there are no kills in the snippet graph
1268             return true;
1269         }
1270 
1271         EconomicSet&lt;LocationIdentity&gt; kills = EconomicSet.create(Equivalence.DEFAULT);
1272         kills.addAll(memoryMap.getLocations());
1273 
1274         if (replacee instanceof MemoryCheckpoint.Single) {
1275             // check if some node in snippet graph also kills the same location
<span class="line-modified">1276             LocationIdentity locationIdentity = ((MemoryCheckpoint.Single) replacee).getLocationIdentity();</span>
1277             if (locationIdentity.isAny()) {
1278                 assert !(memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) : replacee + &quot; kills ANY_LOCATION, but snippet does not&quot;;
1279                 // if the replacee kills ANY_LOCATION, the snippet can kill arbitrary locations
1280                 return true;
1281             }
1282             assert kills.contains(locationIdentity) : replacee + &quot; kills &quot; + locationIdentity + &quot;, but snippet doesn&#39;t contain a kill to this location&quot;;
1283             kills.remove(locationIdentity);
1284         }
1285         assert !(replacee instanceof MemoryCheckpoint.Multi) : replacee + &quot; multi not supported (yet)&quot;;
1286 
1287         // remove ANY_LOCATION if it&#39;s just a kill by the start node
1288         if (memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) {
1289             kills.remove(any());
1290         }
1291 
1292         // node can only lower to a ANY_LOCATION kill if the replacee also kills ANY_LOCATION
1293         assert !kills.contains(any()) : &quot;snippet graph contains a kill to ANY_LOCATION, but replacee (&quot; + replacee + &quot;) doesn&#39;t kill ANY_LOCATION.  kills: &quot; + kills;
1294 
1295         /*
1296          * Kills to private locations are safe, since there can be no floating read to these
</pre>
<hr />
<pre>
1467     @SuppressWarnings(&quot;try&quot;)
1468     public UnmodifiableEconomicMap&lt;Node, Node&gt; instantiate(MetaAccessProvider metaAccess, FixedNode replacee, UsageReplacer replacer, Arguments args, boolean killReplacee) {
1469         DebugContext debug = replacee.getDebug();
1470         assert assertSnippetKills(replacee);
1471         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1472             args.info.instantiationCounter.increment(debug);
1473             // Inline the snippet nodes, replacing parameters with the given args in the process
1474             StartNode entryPointNode = snippet.start();
1475             FixedNode firstCFGNode = entryPointNode.next();
1476             StructuredGraph replaceeGraph = replacee.graph();
1477             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1478             replacements.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));
1479             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1480 
1481             // Re-wire the control flow graph around the replacee
1482             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1483             replacee.replaceAtPredecessor(firstCFGNodeDuplicate);
1484 
1485             rewireFrameStates(replacee, duplicates);
1486 
<span class="line-removed">1487             if (replacee instanceof DeoptimizingNode) {</span>
<span class="line-removed">1488                 DeoptimizingNode replaceeDeopt = (DeoptimizingNode) replacee;</span>
<span class="line-removed">1489 </span>
<span class="line-removed">1490                 FrameState stateBefore = null;</span>
<span class="line-removed">1491                 FrameState stateDuring = null;</span>
<span class="line-removed">1492                 FrameState stateAfter = null;</span>
<span class="line-removed">1493                 if (replaceeDeopt.canDeoptimize()) {</span>
<span class="line-removed">1494                     if (replaceeDeopt instanceof DeoptimizingNode.DeoptBefore) {</span>
<span class="line-removed">1495                         stateBefore = ((DeoptimizingNode.DeoptBefore) replaceeDeopt).stateBefore();</span>
<span class="line-removed">1496                     }</span>
<span class="line-removed">1497                     if (replaceeDeopt instanceof DeoptimizingNode.DeoptDuring) {</span>
<span class="line-removed">1498                         stateDuring = ((DeoptimizingNode.DeoptDuring) replaceeDeopt).stateDuring();</span>
<span class="line-removed">1499                     }</span>
<span class="line-removed">1500                     if (replaceeDeopt instanceof DeoptimizingNode.DeoptAfter) {</span>
<span class="line-removed">1501                         stateAfter = ((DeoptimizingNode.DeoptAfter) replaceeDeopt).stateAfter();</span>
<span class="line-removed">1502                     }</span>
<span class="line-removed">1503                 }</span>
<span class="line-removed">1504 </span>
<span class="line-removed">1505                 for (DeoptimizingNode deoptNode : deoptNodes) {</span>
<span class="line-removed">1506                     DeoptimizingNode deoptDup = (DeoptimizingNode) duplicates.get(deoptNode.asNode());</span>
<span class="line-removed">1507                     if (deoptDup.canDeoptimize()) {</span>
<span class="line-removed">1508                         if (deoptDup instanceof DeoptimizingNode.DeoptBefore) {</span>
<span class="line-removed">1509                             ((DeoptimizingNode.DeoptBefore) deoptDup).setStateBefore(stateBefore);</span>
<span class="line-removed">1510                         }</span>
<span class="line-removed">1511                         if (deoptDup instanceof DeoptimizingNode.DeoptDuring) {</span>
<span class="line-removed">1512                             DeoptimizingNode.DeoptDuring deoptDupDuring = (DeoptimizingNode.DeoptDuring) deoptDup;</span>
<span class="line-removed">1513                             if (stateDuring != null) {</span>
<span class="line-removed">1514                                 deoptDupDuring.setStateDuring(stateDuring);</span>
<span class="line-removed">1515                             } else if (stateAfter != null) {</span>
<span class="line-removed">1516                                 deoptDupDuring.computeStateDuring(stateAfter);</span>
<span class="line-removed">1517                             } else if (stateBefore != null) {</span>
<span class="line-removed">1518                                 assert !deoptDupDuring.hasSideEffect() : &quot;can&#39;t use stateBefore as stateDuring for state split &quot; + deoptDupDuring;</span>
<span class="line-removed">1519                                 deoptDupDuring.setStateDuring(stateBefore);</span>
<span class="line-removed">1520                             }</span>
<span class="line-removed">1521                         }</span>
<span class="line-removed">1522                         if (deoptDup instanceof DeoptimizingNode.DeoptAfter) {</span>
<span class="line-removed">1523                             DeoptimizingNode.DeoptAfter deoptDupAfter = (DeoptimizingNode.DeoptAfter) deoptDup;</span>
<span class="line-removed">1524                             if (stateAfter != null) {</span>
<span class="line-removed">1525                                 deoptDupAfter.setStateAfter(stateAfter);</span>
<span class="line-removed">1526                             } else {</span>
<span class="line-removed">1527                                 assert !deoptDupAfter.hasSideEffect() : &quot;can&#39;t use stateBefore as stateAfter for state split &quot; + deoptDupAfter;</span>
<span class="line-removed">1528                                 deoptDupAfter.setStateAfter(stateBefore);</span>
<span class="line-removed">1529                             }</span>
<span class="line-removed">1530 </span>
<span class="line-removed">1531                         }</span>
<span class="line-removed">1532                     }</span>
<span class="line-removed">1533                 }</span>
<span class="line-removed">1534             }</span>
<span class="line-removed">1535 </span>
1536             updateStamps(replacee, duplicates);
1537 
1538             rewireMemoryGraph(replacee, duplicates);
1539 
1540             // Replace all usages of the replacee with the value returned by the snippet
1541             ValueNode returnValue = null;
1542             if (returnNode != null &amp;&amp; !(replacee instanceof ControlSinkNode)) {
1543                 ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1544                 returnValue = returnDuplicate.result();
1545                 if (returnValue == null &amp;&amp; replacee.usages().isNotEmpty() &amp;&amp; replacee instanceof MemoryCheckpoint) {
1546                     replacer.replace(replacee, null);
1547                 } else {
1548                     assert returnValue != null || replacee.hasNoUsages();
1549                     replacer.replace(replacee, returnValue);
1550                 }
1551                 if (returnDuplicate.isAlive()) {
1552                     FixedNode next = null;
1553                     if (replacee instanceof FixedWithNextNode) {
1554                         FixedWithNextNode fwn = (FixedWithNextNode) replacee;
1555                         next = fwn.next();
</pre>
<hr />
<pre>
1639         DebugContext debug = replacee.getDebug();
1640         assert assertSnippetKills(replacee);
1641         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1642             args.info.instantiationCounter.increment(debug);
1643 
1644             // Inline the snippet nodes, replacing parameters with the given args in the process
1645             StartNode entryPointNode = snippet.start();
1646             FixedNode firstCFGNode = entryPointNode.next();
1647             StructuredGraph replaceeGraph = replacee.graph();
1648             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1649             replacements.put(entryPointNode, tool.getCurrentGuardAnchor().asNode());
1650             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1651 
1652             FixedWithNextNode lastFixedNode = tool.lastFixedNode();
1653             assert lastFixedNode != null &amp;&amp; lastFixedNode.isAlive() : replaceeGraph + &quot; lastFixed=&quot; + lastFixedNode;
1654             FixedNode next = lastFixedNode.next();
1655             lastFixedNode.setNext(null);
1656             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1657             replaceeGraph.addAfterFixed(lastFixedNode, firstCFGNodeDuplicate);
1658 
<span class="line-modified">1659             rewireFrameStates(replacee, duplicates);</span>

1660             updateStamps(replacee, duplicates);
1661 
1662             rewireMemoryGraph(replacee, duplicates);
1663 
1664             // Replace all usages of the replacee with the value returned by the snippet
1665             ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1666             ValueNode returnValue = returnDuplicate.result();
1667             assert returnValue != null || replacee.hasNoUsages();
1668             replacer.replace(replacee, returnValue);
1669 
1670             if (returnDuplicate.isAlive()) {
1671                 returnDuplicate.replaceAndDelete(next);
1672             }
1673 
1674             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1675         }
1676     }
1677 
1678     /**
1679      * Replaces a given floating node with this specialized snippet.
</pre>
<hr />
<pre>
1693             args.info.instantiationCounter.increment(debug);
1694 
1695             // Inline the snippet nodes, replacing parameters with the given args in the process
1696             StartNode entryPointNode = snippet.start();
1697             assert entryPointNode.next() == (memoryAnchor == null ? returnNode : memoryAnchor) : entryPointNode.next();
1698             StructuredGraph replaceeGraph = replacee.graph();
1699             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1700             MemoryAnchorNode anchorDuplicate = null;
1701             if (memoryAnchor != null) {
1702                 anchorDuplicate = replaceeGraph.add(new MemoryAnchorNode());
1703                 replacements.put(memoryAnchor, anchorDuplicate);
1704             }
1705             List&lt;Node&gt; floatingNodes = new ArrayList&lt;&gt;(nodes.size() - 2);
1706             for (Node n : nodes) {
1707                 if (n != entryPointNode &amp;&amp; n != returnNode) {
1708                     floatingNodes.add(n);
1709                 }
1710             }
1711             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1712 
<span class="line-modified">1713             rewireFrameStates(replacee, duplicates);</span>

1714             updateStamps(replacee, duplicates);
1715 
1716             rewireMemoryGraph(replacee, duplicates);
1717             assert anchorDuplicate == null || anchorDuplicate.isDeleted();
1718 
1719             // Replace all usages of the replacee with the value returned by the snippet
1720             ValueNode returnValue = (ValueNode) duplicates.get(returnNode.result());
1721             replacer.replace(replacee, returnValue);
1722 
1723             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1724         }
1725     }
1726 
1727     protected void rewireFrameStates(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
<span class="line-modified">1728         if (replacee instanceof StateSplit) {</span>
1729             for (StateSplit sideEffectNode : sideEffectNodes) {
1730                 assert ((StateSplit) replacee).hasSideEffect();
1731                 Node sideEffectDup = duplicates.get(sideEffectNode.asNode());
1732                 ((StateSplit) sideEffectDup).setStateAfter(((StateSplit) replacee).stateAfter());
1733             }




















































1734         }
1735     }
1736 
1737     @Override
1738     public String toString() {
1739         StringBuilder buf = new StringBuilder(snippet.toString()).append(&#39;(&#39;);
1740         String sep = &quot;&quot;;
1741         for (int i = 0; i &lt; parameters.length; i++) {
1742             String name = &quot;[&quot; + i + &quot;]&quot;;
1743             Object value = parameters[i];
1744             buf.append(sep);
1745             sep = &quot;, &quot;;
1746             if (value == null) {
1747                 buf.append(&quot;&lt;null&gt; &quot;).append(name);
1748             } else if (value.equals(UNUSED_PARAMETER)) {
1749                 buf.append(&quot;&lt;unused&gt; &quot;).append(name);
1750             } else if (value.equals(CONSTANT_PARAMETER)) {
1751                 buf.append(&quot;&lt;constant&gt; &quot;).append(name);
1752             } else if (value instanceof ParameterNode) {
1753                 ParameterNode param = (ParameterNode) value;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 102 import org.graalvm.compiler.nodes.PiNode.PlaceholderStamp;
 103 import org.graalvm.compiler.nodes.ReturnNode;
 104 import org.graalvm.compiler.nodes.StartNode;
 105 import org.graalvm.compiler.nodes.StateSplit;
 106 import org.graalvm.compiler.nodes.StructuredGraph;
 107 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
 108 import org.graalvm.compiler.nodes.ValueNode;
 109 import org.graalvm.compiler.nodes.ValueNodeUtil;
 110 import org.graalvm.compiler.nodes.calc.FloatingNode;
 111 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 112 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 113 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 114 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 115 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
 116 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;
 117 import org.graalvm.compiler.nodes.memory.MemoryMap;
 118 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
 119 import org.graalvm.compiler.nodes.memory.MemoryNode;
 120 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
 121 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
<span class="line-added"> 122 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 123 import org.graalvm.compiler.nodes.spi.LoweringTool;
 124 import org.graalvm.compiler.nodes.spi.MemoryProxy;
 125 import org.graalvm.compiler.nodes.util.GraphUtil;
 126 import org.graalvm.compiler.options.Option;
 127 import org.graalvm.compiler.options.OptionKey;
 128 import org.graalvm.compiler.options.OptionValues;
 129 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 130 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 131 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 132 import org.graalvm.compiler.phases.common.FloatingReadPhase.MemoryMapImpl;
 133 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 134 import org.graalvm.compiler.phases.common.LoweringPhase;
 135 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 136 import org.graalvm.compiler.phases.common.inlining.InliningUtil;

 137 import org.graalvm.compiler.phases.util.Providers;
 138 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
 139 import org.graalvm.compiler.replacements.nodes.LoadSnippetVarargParameterNode;
 140 import org.graalvm.util.CollectionsUtil;
 141 import jdk.internal.vm.compiler.word.LocationIdentity;
 142 import jdk.internal.vm.compiler.word.WordBase;
 143 
 144 import jdk.vm.ci.code.TargetDescription;
 145 import jdk.vm.ci.meta.Constant;
 146 import jdk.vm.ci.meta.ConstantReflectionProvider;
 147 import jdk.vm.ci.meta.JavaConstant;
 148 import jdk.vm.ci.meta.JavaKind;
 149 import jdk.vm.ci.meta.Local;
 150 import jdk.vm.ci.meta.LocalVariableTable;
 151 import jdk.vm.ci.meta.MetaAccessProvider;
 152 import jdk.vm.ci.meta.ResolvedJavaMethod;
 153 import jdk.vm.ci.meta.ResolvedJavaMethod.Parameter;
 154 import jdk.vm.ci.meta.ResolvedJavaType;
 155 import jdk.vm.ci.meta.Signature;
 156 
</pre>
<hr />
<pre>
 616         protected final Providers providers;
 617         protected final SnippetReflectionProvider snippetReflection;
 618         protected final Iterable&lt;DebugHandlersFactory&gt; factories;
 619         protected final TargetDescription target;
 620         private final Map&lt;CacheKey, SnippetTemplate&gt; templates;
 621 
 622         protected AbstractTemplates(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, Providers providers, SnippetReflectionProvider snippetReflection, TargetDescription target) {
 623             this.options = options;
 624             this.providers = providers;
 625             this.snippetReflection = snippetReflection;
 626             this.target = target;
 627             this.factories = factories;
 628             if (Options.UseSnippetTemplateCache.getValue(options)) {
 629                 int size = Options.MaxTemplatesPerSnippet.getValue(options);
 630                 this.templates = Collections.synchronizedMap(new LRUCache&lt;&gt;(size, size));
 631             } else {
 632                 this.templates = null;
 633             }
 634         }
 635 
<span class="line-added"> 636         public Providers getProviders() {</span>
<span class="line-added"> 637             return providers;</span>
<span class="line-added"> 638         }</span>
<span class="line-added"> 639 </span>
 640         public static Method findMethod(Class&lt;? extends Snippets&gt; declaringClass, String methodName, Method except) {
 641             for (Method m : declaringClass.getDeclaredMethods()) {
 642                 if (m.getName().equals(methodName) &amp;&amp; !m.equals(except)) {
 643                     return m;
 644                 }
 645             }
 646             return null;
 647         }
 648 
 649         public static ResolvedJavaMethod findMethod(MetaAccessProvider metaAccess, Class&lt;?&gt; declaringClass, String methodName) {
 650             ResolvedJavaType type = metaAccess.lookupJavaType(declaringClass);
 651             ResolvedJavaMethod result = null;
 652             for (ResolvedJavaMethod m : type.getDeclaredMethods()) {
 653                 if (m.getName().equals(methodName)) {
 654                     if (!Assertions.assertionsEnabled()) {
 655                         return m;
 656                     } else {
 657                         assert result == null : &quot;multiple definitions found&quot;;
 658                         result = m;
 659                     }
</pre>
<hr />
<pre>
 662             if (result == null) {
 663                 throw new GraalError(&quot;Could not find method in &quot; + declaringClass + &quot; named &quot; + methodName);
 664             }
 665             return result;
 666         }
 667 
 668         protected SnippetInfo snippet(Class&lt;? extends Snippets&gt; declaringClass, String methodName, LocationIdentity... initialPrivateLocations) {
 669             return snippet(declaringClass, methodName, null, null, initialPrivateLocations);
 670         }
 671 
 672         /**
 673          * Finds the unique method in {@code declaringClass} named {@code methodName} annotated by
 674          * {@link Snippet} and returns a {@link SnippetInfo} value describing it. There must be
 675          * exactly one snippet method in {@code declaringClass} with a given name.
 676          */
 677         protected SnippetInfo snippet(Class&lt;? extends Snippets&gt; declaringClass, String methodName, ResolvedJavaMethod original, Object receiver, LocationIdentity... initialPrivateLocations) {
 678             assert methodName != null;
 679             ResolvedJavaMethod javaMethod = findMethod(providers.getMetaAccess(), declaringClass, methodName);
 680             assert javaMethod != null : &quot;did not find @&quot; + Snippet.class.getSimpleName() + &quot; method in &quot; + declaringClass + &quot; named &quot; + methodName;
 681             assert javaMethod.getAnnotation(Snippet.class) != null : javaMethod + &quot; must be annotated with @&quot; + Snippet.class.getSimpleName();
<span class="line-modified"> 682             providers.getReplacements().registerSnippet(javaMethod, original, receiver, GraalOptions.TrackNodeSourcePosition.getValue(options), options);</span>
 683             LocationIdentity[] privateLocations = GraalOptions.SnippetCounters.getValue(options) ? SnippetCounterNode.addSnippetCounters(initialPrivateLocations) : initialPrivateLocations;
 684             if (GraalOptions.EagerSnippets.getValue(options)) {
 685                 return new EagerSnippetInfo(javaMethod, original, privateLocations, receiver);
 686             } else {
 687                 return new LazySnippetInfo(javaMethod, original, privateLocations, receiver);
 688             }
 689         }
 690 
 691         static final AtomicInteger nextSnippetTemplateId = new AtomicInteger();
 692 
 693         private DebugContext openDebugContext(DebugContext outer, Arguments args) {
 694             if (DebugStubsAndSnippets.getValue(options)) {
 695                 Description description = new Description(args.cacheKey.method, &quot;SnippetTemplate_&quot; + nextSnippetTemplateId.incrementAndGet());
 696                 return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, factories);
 697             }
<span class="line-modified"> 698             return DebugContext.disabled(options);</span>
 699         }
 700 
 701         /**
 702          * Gets a template for a given key, creating it first if necessary.
 703          */
 704         @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 705         public SnippetTemplate template(ValueNode replacee, final Arguments args) {</span>
 706             StructuredGraph graph = replacee.graph();
 707             DebugContext outer = graph.getDebug();
 708             SnippetTemplate template = Options.UseSnippetTemplateCache.getValue(options) &amp;&amp; args.cacheable ? templates.get(args.cacheKey) : null;
 709             if (template == null || (graph.trackNodeSourcePosition() &amp;&amp; !template.snippet.trackNodeSourcePosition())) {
 710                 try (DebugContext debug = openDebugContext(outer, args)) {
 711                     try (DebugCloseable a = SnippetTemplateCreationTime.start(debug); DebugContext.Scope s = debug.scope(&quot;SnippetSpecialization&quot;, args.info.method)) {
 712                         SnippetTemplates.increment(debug);
 713                         OptionValues snippetOptions = new OptionValues(options, GraalOptions.TraceInlining, GraalOptions.TraceInliningForStubsAndSnippets.getValue(options));
 714                         template = new SnippetTemplate(snippetOptions, debug, providers, snippetReflection, args, graph.trackNodeSourcePosition(), replacee);
 715                         if (Options.UseSnippetTemplateCache.getValue(snippetOptions) &amp;&amp; args.cacheable) {
 716                             templates.put(args.cacheKey, template);
 717                         }
 718                     } catch (Throwable e) {
 719                         throw debug.handle(e);
 720                     }
 721                 }
 722             }
 723             return template;
 724         }
 725     }
</pre>
<hr />
<pre>
 751             if (p != null) {
 752                 return true;
 753             }
 754         }
 755         return false;
 756     }
 757 
 758     private final SnippetReflectionProvider snippetReflection;
 759 
 760     /**
 761      * Creates a snippet template.
 762      */
 763     @SuppressWarnings(&quot;try&quot;)
 764     protected SnippetTemplate(OptionValues options, DebugContext debug, final Providers providers, SnippetReflectionProvider snippetReflection, Arguments args, boolean trackNodeSourcePosition,
 765                     Node replacee) {
 766         this.snippetReflection = snippetReflection;
 767         this.info = args.info;
 768 
 769         Object[] constantArgs = getConstantArgs(args);
 770         boolean shouldTrackNodeSourcePosition1 = trackNodeSourcePosition || (providers.getCodeCache() != null &amp;&amp; providers.getCodeCache().shouldDebugNonSafepoints());
<span class="line-modified"> 771         StructuredGraph snippetGraph = providers.getReplacements().getSnippet(args.info.method, args.info.original, constantArgs, shouldTrackNodeSourcePosition1, replacee.getNodeSourcePosition(),</span>
<span class="line-added"> 772                         options);</span>
 773 
 774         ResolvedJavaMethod method = snippetGraph.method();
 775         Signature signature = method.getSignature();
 776 


 777         // Copy snippet graph, replacing constant parameters with given arguments
 778         final StructuredGraph snippetCopy = new StructuredGraph.Builder(options, debug).name(snippetGraph.name).method(snippetGraph.method()).trackNodeSourcePosition(
 779                         snippetGraph.trackNodeSourcePosition()).setIsSubstitution(true).build();
 780         assert !GraalOptions.TrackNodeSourcePosition.getValue(options) || snippetCopy.trackNodeSourcePosition();
 781         try (DebugContext.Scope scope = debug.scope(&quot;SpecializeSnippet&quot;, snippetCopy)) {
 782             if (!snippetGraph.isUnsafeAccessTrackingEnabled()) {
 783                 snippetCopy.disableUnsafeAccessTracking();
 784             }
 785 
 786             EconomicMap&lt;Node, Node&gt; nodeReplacements = EconomicMap.create(Equivalence.IDENTITY);
 787             nodeReplacements.put(snippetGraph.start(), snippetCopy.start());
 788 
 789             MetaAccessProvider metaAccess = providers.getMetaAccess();
 790             assert checkTemplate(metaAccess, args, method, signature);
 791 
 792             int parameterCount = args.info.getParameterCount();
 793             VarargsPlaceholderNode[] placeholders = new VarargsPlaceholderNode[parameterCount];
 794 
 795             for (int i = 0; i &lt; parameterCount; i++) {
 796                 ParameterNode parameter = snippetGraph.getParameter(i);
</pre>
<hr />
<pre>
 865                                 /*
 866                                  * The template lowering doesn&#39;t really treat this as an array so
 867                                  * you can&#39;t store back into the varargs. Allocate your own array if
 868                                  * you really need this and EA should eliminate it.
 869                                  */
 870                                 throw new GraalError(&quot;Can&#39;t store into VarargsParameter array&quot;);
 871                             }
 872                         }
 873                     }
 874                 } else {
 875                     ParameterNode local = snippetCopy.getParameter(i);
 876                     if (local == null) {
 877                         // Parameter value was eliminated
 878                         parameters[i] = UNUSED_PARAMETER;
 879                     } else {
 880                         parameters[i] = local;
 881                     }
 882                 }
 883             }
 884 
<span class="line-modified"> 885             explodeLoops(snippetCopy, providers);</span>
 886 
 887             GuardsStage guardsStage = args.cacheKey.guardsStage;
 888             // Perform lowering on the snippet
 889             if (!guardsStage.allowsFloatingGuards()) {
 890                 new GuardLoweringPhase().apply(snippetCopy, null);
 891             }
 892             snippetCopy.setGuardsStage(guardsStage);
 893             try (DebugContext.Scope s = debug.scope(&quot;LoweringSnippetTemplate&quot;, snippetCopy)) {
<span class="line-modified"> 894                 new LoweringPhase(CanonicalizerPhase.create(), args.cacheKey.loweringStage).apply(snippetCopy, providers);</span>
 895             } catch (Throwable e) {
 896                 throw debug.handle(e);
 897             }
 898 
 899             ArrayList&lt;StateSplit&gt; curSideEffectNodes = new ArrayList&lt;&gt;();
 900             ArrayList&lt;DeoptimizingNode&gt; curDeoptNodes = new ArrayList&lt;&gt;();
 901             ArrayList&lt;ValueNode&gt; curPlaceholderStampedNodes = new ArrayList&lt;&gt;();
 902             for (Node node : snippetCopy.getNodes()) {
 903                 if (node instanceof ValueNode) {
 904                     ValueNode valueNode = (ValueNode) node;
 905                     if (valueNode.stamp(NodeView.DEFAULT) == PlaceholderStamp.singleton()) {
 906                         curPlaceholderStampedNodes.add(valueNode);
 907                     }
 908                 }
 909 
 910                 if (node instanceof StateSplit) {
 911                     StateSplit stateSplit = (StateSplit) node;
 912                     FrameState frameState = stateSplit.stateAfter();
 913                     if (stateSplit.hasSideEffect()) {
 914                         curSideEffectNodes.add((StateSplit) node);
 915                     }
 916                     if (frameState != null) {
 917                         stateSplit.setStateAfter(null);
 918                     }
 919                 }
 920                 if (node instanceof DeoptimizingNode) {
 921                     DeoptimizingNode deoptNode = (DeoptimizingNode) node;
 922                     if (deoptNode.canDeoptimize()) {
 923                         curDeoptNodes.add(deoptNode);
 924                     }
 925                 }
 926             }
 927 
 928             new DeadCodeEliminationPhase(Required).apply(snippetCopy);
 929 
 930             assert checkAllVarargPlaceholdersAreDeleted(parameterCount, placeholders);
 931 
 932             new FloatingReadPhase(true, true).apply(snippetCopy);
<span class="line-modified"> 933 </span>
<span class="line-added"> 934             if (!guardsStage.requiresValueProxies()) {</span>
<span class="line-added"> 935                 new RemoveValueProxyPhase().apply(snippetCopy);</span>
<span class="line-added"> 936             }</span>
 937 
 938             MemoryAnchorNode anchor = snippetCopy.add(new MemoryAnchorNode());
 939             snippetCopy.start().replaceAtUsages(InputType.Memory, anchor);
 940 
 941             this.snippet = snippetCopy;
 942 
 943             StartNode entryPointNode = snippet.start();
 944             if (anchor.hasNoUsages()) {
 945                 anchor.safeDelete();
 946                 this.memoryAnchor = null;
 947             } else {
 948                 // Find out if all the return memory maps point to the anchor (i.e., there&#39;s no kill
 949                 // anywhere)
 950                 boolean needsMemoryMaps = false;
 951                 for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 952                     MemoryMapNode memoryMap = retNode.getMemoryMap();
 953                     if (memoryMap.getLocations().size() &gt; 1 || memoryMap.getLastLocationAccess(LocationIdentity.any()) != anchor) {
 954                         needsMemoryMaps = true;
 955                         break;
 956                     }
 957                 }
 958                 boolean needsAnchor;
 959                 if (needsMemoryMaps) {
 960                     needsAnchor = true;
 961                 } else {
 962                     // Check that all those memory maps where the only usages of the anchor
 963                     needsAnchor = anchor.usages().filter(isNotA(MemoryMapNode.class)).isNotEmpty();
 964                     // Remove the useless memory map
 965                     MemoryMapNode memoryMap = null;
 966                     for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 967                         if (memoryMap == null) {
 968                             memoryMap = retNode.getMemoryMap();
 969                         } else {
 970                             assert memoryMap == retNode.getMemoryMap();
 971                         }
 972                         retNode.setMemoryMap(null);
 973                     }
<span class="line-modified"> 974                     if (memoryMap != null) {</span>
<span class="line-added"> 975                         memoryMap.safeDelete();</span>
<span class="line-added"> 976                     }</span>
 977                 }
 978                 if (needsAnchor) {
 979                     snippetCopy.addAfterFixed(snippetCopy.start(), anchor);
 980                     this.memoryAnchor = anchor;
 981                 } else {
 982                     anchor.safeDelete();
 983                     this.memoryAnchor = null;
 984                 }
 985             }
 986             debug.dump(DebugContext.INFO_LEVEL, snippet, &quot;SnippetTemplate after fixing memory anchoring&quot;);
 987 
 988             List&lt;ReturnNode&gt; returnNodes = snippet.getNodes(ReturnNode.TYPE).snapshot();
 989             if (returnNodes.isEmpty()) {
 990                 this.returnNode = null;
 991             } else if (returnNodes.size() == 1) {
 992                 this.returnNode = returnNodes.get(0);
 993             } else {
 994                 AbstractMergeNode merge = snippet.add(new MergeNode());
 995                 List&lt;MemoryMapNode&gt; memMaps = new ArrayList&lt;&gt;();
 996                 for (ReturnNode retNode : returnNodes) {
</pre>
<hr />
<pre>
1033                 DebugContext.counter(&quot;SnippetTemplateNodeCount[%#s]&quot;, args).add(debug, nodes.size());
1034             }
1035             debug.dump(DebugContext.INFO_LEVEL, snippet, &quot;SnippetTemplate final state&quot;);
1036             this.snippet.freeze();
1037 
1038         } catch (Throwable ex) {
1039             throw debug.handle(ex);
1040         }
1041     }
1042 
1043     private static boolean verifyIntrinsicsProcessed(StructuredGraph snippetCopy) {
1044         for (MethodCallTargetNode target : snippetCopy.getNodes(MethodCallTargetNode.TYPE)) {
1045             ResolvedJavaMethod targetMethod = target.targetMethod();
1046             if (targetMethod != null) {
1047                 assert targetMethod.getAnnotation(Fold.class) == null &amp;&amp; targetMethod.getAnnotation(NodeIntrinsic.class) == null : &quot;plugin should have been processed&quot;;
1048             }
1049         }
1050         return true;
1051     }
1052 
<span class="line-modified">1053     public static void explodeLoops(final StructuredGraph snippetCopy, CoreProviders providers) {</span>
1054         // Do any required loop explosion
1055         boolean exploded = false;
1056         do {
1057             exploded = false;
1058             ExplodeLoopNode explodeLoop = snippetCopy.getNodes().filter(ExplodeLoopNode.class).first();
1059             if (explodeLoop != null) { // Earlier canonicalization may have removed the loop
1060                 // altogether
1061                 LoopBeginNode loopBegin = explodeLoop.findLoopBegin();
1062                 if (loopBegin != null) {
1063                     LoopEx loop = new LoopsData(snippetCopy).loop(loopBegin);
1064                     Mark mark = snippetCopy.getMark();
<span class="line-modified">1065                     CanonicalizerPhase canonicalizer = null;</span>
<span class="line-modified">1066                     if (GraalOptions.ImmutableCode.getValue(snippetCopy.getOptions())) {</span>
<span class="line-added">1067                         canonicalizer = CanonicalizerPhase.createWithoutReadCanonicalization();</span>
<span class="line-added">1068                     } else {</span>
<span class="line-added">1069                         canonicalizer = CanonicalizerPhase.create();</span>
<span class="line-added">1070                     }</span>
<span class="line-added">1071                     LoopTransformations.fullUnroll(loop, providers, canonicalizer);</span>
<span class="line-added">1072                     CanonicalizerPhase.create().applyIncremental(snippetCopy, providers, mark, false);</span>
1073                     loop.deleteUnusedNodes();
1074                 }
1075                 GraphUtil.removeFixedWithUnusedInputs(explodeLoop);
1076                 exploded = true;
1077             }
1078         } while (exploded);
1079     }
1080 
1081     protected Object[] getConstantArgs(Arguments args) {
1082         Object[] constantArgs = args.values.clone();
1083         for (int i = 0; i &lt; args.info.getParameterCount(); i++) {
1084             if (!args.info.isConstantParameter(i)) {
1085                 constantArgs[i] = null;
1086             } else {
1087                 assert constantArgs[i] != null : &quot;Can&#39;t pass raw null through as argument&quot;;
1088             }
1089         }
1090         return constantArgs;
1091     }
1092 
</pre>
<hr />
<pre>
1270     private boolean assertSnippetKills(ValueNode replacee) {
1271         if (!replacee.graph().isAfterFloatingReadPhase()) {
1272             // no floating reads yet, ignore locations created while lowering
1273             return true;
1274         }
1275         if (returnNode == null) {
1276             // The snippet terminates control flow
1277             return true;
1278         }
1279         MemoryMapNode memoryMap = returnNode.getMemoryMap();
1280         if (memoryMap == null || memoryMap.isEmpty()) {
1281             // there are no kills in the snippet graph
1282             return true;
1283         }
1284 
1285         EconomicSet&lt;LocationIdentity&gt; kills = EconomicSet.create(Equivalence.DEFAULT);
1286         kills.addAll(memoryMap.getLocations());
1287 
1288         if (replacee instanceof MemoryCheckpoint.Single) {
1289             // check if some node in snippet graph also kills the same location
<span class="line-modified">1290             LocationIdentity locationIdentity = ((MemoryCheckpoint.Single) replacee).getKilledLocationIdentity();</span>
1291             if (locationIdentity.isAny()) {
1292                 assert !(memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) : replacee + &quot; kills ANY_LOCATION, but snippet does not&quot;;
1293                 // if the replacee kills ANY_LOCATION, the snippet can kill arbitrary locations
1294                 return true;
1295             }
1296             assert kills.contains(locationIdentity) : replacee + &quot; kills &quot; + locationIdentity + &quot;, but snippet doesn&#39;t contain a kill to this location&quot;;
1297             kills.remove(locationIdentity);
1298         }
1299         assert !(replacee instanceof MemoryCheckpoint.Multi) : replacee + &quot; multi not supported (yet)&quot;;
1300 
1301         // remove ANY_LOCATION if it&#39;s just a kill by the start node
1302         if (memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) {
1303             kills.remove(any());
1304         }
1305 
1306         // node can only lower to a ANY_LOCATION kill if the replacee also kills ANY_LOCATION
1307         assert !kills.contains(any()) : &quot;snippet graph contains a kill to ANY_LOCATION, but replacee (&quot; + replacee + &quot;) doesn&#39;t kill ANY_LOCATION.  kills: &quot; + kills;
1308 
1309         /*
1310          * Kills to private locations are safe, since there can be no floating read to these
</pre>
<hr />
<pre>
1481     @SuppressWarnings(&quot;try&quot;)
1482     public UnmodifiableEconomicMap&lt;Node, Node&gt; instantiate(MetaAccessProvider metaAccess, FixedNode replacee, UsageReplacer replacer, Arguments args, boolean killReplacee) {
1483         DebugContext debug = replacee.getDebug();
1484         assert assertSnippetKills(replacee);
1485         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1486             args.info.instantiationCounter.increment(debug);
1487             // Inline the snippet nodes, replacing parameters with the given args in the process
1488             StartNode entryPointNode = snippet.start();
1489             FixedNode firstCFGNode = entryPointNode.next();
1490             StructuredGraph replaceeGraph = replacee.graph();
1491             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1492             replacements.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));
1493             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1494 
1495             // Re-wire the control flow graph around the replacee
1496             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1497             replacee.replaceAtPredecessor(firstCFGNodeDuplicate);
1498 
1499             rewireFrameStates(replacee, duplicates);
1500 

















































1501             updateStamps(replacee, duplicates);
1502 
1503             rewireMemoryGraph(replacee, duplicates);
1504 
1505             // Replace all usages of the replacee with the value returned by the snippet
1506             ValueNode returnValue = null;
1507             if (returnNode != null &amp;&amp; !(replacee instanceof ControlSinkNode)) {
1508                 ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1509                 returnValue = returnDuplicate.result();
1510                 if (returnValue == null &amp;&amp; replacee.usages().isNotEmpty() &amp;&amp; replacee instanceof MemoryCheckpoint) {
1511                     replacer.replace(replacee, null);
1512                 } else {
1513                     assert returnValue != null || replacee.hasNoUsages();
1514                     replacer.replace(replacee, returnValue);
1515                 }
1516                 if (returnDuplicate.isAlive()) {
1517                     FixedNode next = null;
1518                     if (replacee instanceof FixedWithNextNode) {
1519                         FixedWithNextNode fwn = (FixedWithNextNode) replacee;
1520                         next = fwn.next();
</pre>
<hr />
<pre>
1604         DebugContext debug = replacee.getDebug();
1605         assert assertSnippetKills(replacee);
1606         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1607             args.info.instantiationCounter.increment(debug);
1608 
1609             // Inline the snippet nodes, replacing parameters with the given args in the process
1610             StartNode entryPointNode = snippet.start();
1611             FixedNode firstCFGNode = entryPointNode.next();
1612             StructuredGraph replaceeGraph = replacee.graph();
1613             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1614             replacements.put(entryPointNode, tool.getCurrentGuardAnchor().asNode());
1615             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1616 
1617             FixedWithNextNode lastFixedNode = tool.lastFixedNode();
1618             assert lastFixedNode != null &amp;&amp; lastFixedNode.isAlive() : replaceeGraph + &quot; lastFixed=&quot; + lastFixedNode;
1619             FixedNode next = lastFixedNode.next();
1620             lastFixedNode.setNext(null);
1621             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1622             replaceeGraph.addAfterFixed(lastFixedNode, firstCFGNodeDuplicate);
1623 
<span class="line-modified">1624             // floating nodes are not state-splits not need to re-wire frame states</span>
<span class="line-added">1625             assert !(replacee instanceof StateSplit);</span>
1626             updateStamps(replacee, duplicates);
1627 
1628             rewireMemoryGraph(replacee, duplicates);
1629 
1630             // Replace all usages of the replacee with the value returned by the snippet
1631             ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1632             ValueNode returnValue = returnDuplicate.result();
1633             assert returnValue != null || replacee.hasNoUsages();
1634             replacer.replace(replacee, returnValue);
1635 
1636             if (returnDuplicate.isAlive()) {
1637                 returnDuplicate.replaceAndDelete(next);
1638             }
1639 
1640             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1641         }
1642     }
1643 
1644     /**
1645      * Replaces a given floating node with this specialized snippet.
</pre>
<hr />
<pre>
1659             args.info.instantiationCounter.increment(debug);
1660 
1661             // Inline the snippet nodes, replacing parameters with the given args in the process
1662             StartNode entryPointNode = snippet.start();
1663             assert entryPointNode.next() == (memoryAnchor == null ? returnNode : memoryAnchor) : entryPointNode.next();
1664             StructuredGraph replaceeGraph = replacee.graph();
1665             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1666             MemoryAnchorNode anchorDuplicate = null;
1667             if (memoryAnchor != null) {
1668                 anchorDuplicate = replaceeGraph.add(new MemoryAnchorNode());
1669                 replacements.put(memoryAnchor, anchorDuplicate);
1670             }
1671             List&lt;Node&gt; floatingNodes = new ArrayList&lt;&gt;(nodes.size() - 2);
1672             for (Node n : nodes) {
1673                 if (n != entryPointNode &amp;&amp; n != returnNode) {
1674                     floatingNodes.add(n);
1675                 }
1676             }
1677             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1678 
<span class="line-modified">1679             // floating nodes are not state-splits not need to re-wire frame states</span>
<span class="line-added">1680             assert !(replacee instanceof StateSplit);</span>
1681             updateStamps(replacee, duplicates);
1682 
1683             rewireMemoryGraph(replacee, duplicates);
1684             assert anchorDuplicate == null || anchorDuplicate.isDeleted();
1685 
1686             // Replace all usages of the replacee with the value returned by the snippet
1687             ValueNode returnValue = (ValueNode) duplicates.get(returnNode.result());
1688             replacer.replace(replacee, returnValue);
1689 
1690             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1691         }
1692     }
1693 
1694     protected void rewireFrameStates(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
<span class="line-modified">1695         if (replacee.graph().getGuardsStage().areFrameStatesAtSideEffects() &amp;&amp; replacee instanceof StateSplit) {</span>
1696             for (StateSplit sideEffectNode : sideEffectNodes) {
1697                 assert ((StateSplit) replacee).hasSideEffect();
1698                 Node sideEffectDup = duplicates.get(sideEffectNode.asNode());
1699                 ((StateSplit) sideEffectDup).setStateAfter(((StateSplit) replacee).stateAfter());
1700             }
<span class="line-added">1701         } else if (replacee.graph().getGuardsStage().areFrameStatesAtDeopts() &amp;&amp; replacee instanceof DeoptimizingNode) {</span>
<span class="line-added">1702             DeoptimizingNode replaceeDeopt = (DeoptimizingNode) replacee;</span>
<span class="line-added">1703 </span>
<span class="line-added">1704             FrameState stateBefore = null;</span>
<span class="line-added">1705             FrameState stateDuring = null;</span>
<span class="line-added">1706             FrameState stateAfter = null;</span>
<span class="line-added">1707             if (replaceeDeopt.canDeoptimize()) {</span>
<span class="line-added">1708                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptBefore) {</span>
<span class="line-added">1709                     stateBefore = ((DeoptimizingNode.DeoptBefore) replaceeDeopt).stateBefore();</span>
<span class="line-added">1710                 }</span>
<span class="line-added">1711                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptDuring) {</span>
<span class="line-added">1712                     stateDuring = ((DeoptimizingNode.DeoptDuring) replaceeDeopt).stateDuring();</span>
<span class="line-added">1713                 }</span>
<span class="line-added">1714                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptAfter) {</span>
<span class="line-added">1715                     stateAfter = ((DeoptimizingNode.DeoptAfter) replaceeDeopt).stateAfter();</span>
<span class="line-added">1716                 }</span>
<span class="line-added">1717             }</span>
<span class="line-added">1718 </span>
<span class="line-added">1719             for (DeoptimizingNode deoptNode : deoptNodes) {</span>
<span class="line-added">1720                 DeoptimizingNode deoptDup = (DeoptimizingNode) duplicates.get(deoptNode.asNode());</span>
<span class="line-added">1721                 if (deoptDup.canDeoptimize()) {</span>
<span class="line-added">1722                     if (deoptDup instanceof DeoptimizingNode.DeoptBefore) {</span>
<span class="line-added">1723                         ((DeoptimizingNode.DeoptBefore) deoptDup).setStateBefore(stateBefore);</span>
<span class="line-added">1724                     }</span>
<span class="line-added">1725                     if (deoptDup instanceof DeoptimizingNode.DeoptDuring) {</span>
<span class="line-added">1726                         // compute a state &quot;during&quot; for a DeoptDuring inside the snippet depending</span>
<span class="line-added">1727                         // on what kind of states we had on the node we are replacing.</span>
<span class="line-added">1728                         // If the original node had a state &quot;during&quot; already, we just use that,</span>
<span class="line-added">1729                         // otherwise we need to find a strategy to compute a state during based on</span>
<span class="line-added">1730                         // some other state (before or after).</span>
<span class="line-added">1731                         DeoptimizingNode.DeoptDuring deoptDupDuring = (DeoptimizingNode.DeoptDuring) deoptDup;</span>
<span class="line-added">1732                         if (stateDuring != null) {</span>
<span class="line-added">1733                             deoptDupDuring.setStateDuring(stateDuring);</span>
<span class="line-added">1734                         } else if (stateAfter != null) {</span>
<span class="line-added">1735                             deoptDupDuring.computeStateDuring(stateAfter);</span>
<span class="line-added">1736                         } else if (stateBefore != null) {</span>
<span class="line-added">1737                             assert !deoptDupDuring.hasSideEffect() : &quot;can&#39;t use stateBefore as stateDuring for state split &quot; + deoptDupDuring;</span>
<span class="line-added">1738                             deoptDupDuring.setStateDuring(stateBefore);</span>
<span class="line-added">1739                         }</span>
<span class="line-added">1740                     }</span>
<span class="line-added">1741                     if (deoptDup instanceof DeoptimizingNode.DeoptAfter) {</span>
<span class="line-added">1742                         DeoptimizingNode.DeoptAfter deoptDupAfter = (DeoptimizingNode.DeoptAfter) deoptDup;</span>
<span class="line-added">1743                         if (stateAfter != null) {</span>
<span class="line-added">1744                             deoptDupAfter.setStateAfter(stateAfter);</span>
<span class="line-added">1745                         } else {</span>
<span class="line-added">1746                             assert !deoptDupAfter.hasSideEffect() : &quot;can&#39;t use stateBefore as stateAfter for state split &quot; + deoptDupAfter;</span>
<span class="line-added">1747                             deoptDupAfter.setStateAfter(stateBefore);</span>
<span class="line-added">1748                         }</span>
<span class="line-added">1749 </span>
<span class="line-added">1750                     }</span>
<span class="line-added">1751                 }</span>
<span class="line-added">1752             }</span>
1753         }
1754     }
1755 
1756     @Override
1757     public String toString() {
1758         StringBuilder buf = new StringBuilder(snippet.toString()).append(&#39;(&#39;);
1759         String sep = &quot;&quot;;
1760         for (int i = 0; i &lt; parameters.length; i++) {
1761             String name = &quot;[&quot; + i + &quot;]&quot;;
1762             Object value = parameters[i];
1763             buf.append(sep);
1764             sep = &quot;, &quot;;
1765             if (value == null) {
1766                 buf.append(&quot;&lt;null&gt; &quot;).append(name);
1767             } else if (value.equals(UNUSED_PARAMETER)) {
1768                 buf.append(&quot;&lt;unused&gt; &quot;).append(name);
1769             } else if (value.equals(CONSTANT_PARAMETER)) {
1770                 buf.append(&quot;&lt;constant&gt; &quot;).append(name);
1771             } else if (value instanceof ParameterNode) {
1772                 ParameterNode param = (ParameterNode) value;
</pre>
</td>
</tr>
</table>
<center><a href="SnippetCounterNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="StandardGraphBuilderPlugins.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
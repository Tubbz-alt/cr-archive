<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/DefaultJavaLoweringProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ConstantStringIndexOfSnippets.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphKit.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/DefaultJavaLoweringProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,12 ***</span>
<span class="line-new-header">--- 44,14 ---</span>
  import java.util.List;
  
  import org.graalvm.compiler.api.directives.GraalDirectives;
  import org.graalvm.compiler.api.replacements.Snippet;
  import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
<span class="line-added">+ import org.graalvm.compiler.core.common.GraalOptions;</span>
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
<span class="line-added">+ import org.graalvm.compiler.core.common.type.AbstractPointerStamp;</span>
  import org.graalvm.compiler.core.common.type.IntegerStamp;
  import org.graalvm.compiler.core.common.type.ObjectStamp;
  import org.graalvm.compiler.core.common.type.Stamp;
  import org.graalvm.compiler.core.common.type.StampFactory;
  import org.graalvm.compiler.core.common.type.TypeReference;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,18 ***</span>
<span class="line-new-header">--- 60,24 ---</span>
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.nodeinfo.InputType;
  import org.graalvm.compiler.nodes.CompressionNode.CompressionOp;
  import org.graalvm.compiler.nodes.ConstantNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.EndNode;</span>
  import org.graalvm.compiler.nodes.FieldLocationIdentity;
  import org.graalvm.compiler.nodes.FixedNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.FixedWithNextNode;</span>
<span class="line-added">+ import org.graalvm.compiler.nodes.IfNode;</span>
  import org.graalvm.compiler.nodes.LogicNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.MergeNode;</span>
  import org.graalvm.compiler.nodes.NamedLocationIdentity;
  import org.graalvm.compiler.nodes.NodeView;
<span class="line-added">+ import org.graalvm.compiler.nodes.PhiNode;</span>
  import org.graalvm.compiler.nodes.PiNode;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.ValuePhiNode;</span>
  import org.graalvm.compiler.nodes.calc.AddNode;
  import org.graalvm.compiler.nodes.calc.ConditionalNode;
  import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  import org.graalvm.compiler.nodes.calc.IntegerConvertNode;
  import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,10 ***</span>
<span class="line-new-header">--- 97,11 ---</span>
  import org.graalvm.compiler.nodes.extended.GuardingNode;
  import org.graalvm.compiler.nodes.extended.JavaReadNode;
  import org.graalvm.compiler.nodes.extended.JavaWriteNode;
  import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
  import org.graalvm.compiler.nodes.extended.LoadHubNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.extended.LoadHubOrNullNode;</span>
  import org.graalvm.compiler.nodes.extended.MembarNode;
  import org.graalvm.compiler.nodes.extended.RawLoadNode;
  import org.graalvm.compiler.nodes.extended.RawStoreNode;
  import org.graalvm.compiler.nodes.extended.UnboxNode;
  import org.graalvm.compiler.nodes.extended.UnsafeMemoryLoadNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,14 ***</span>
<span class="line-new-header">--- 127,16 ---</span>
  import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
  import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
  import org.graalvm.compiler.nodes.java.ValueCompareAndSwapNode;
  import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
  import org.graalvm.compiler.nodes.memory.ReadNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.memory.VolatileReadNode;</span>
  import org.graalvm.compiler.nodes.memory.WriteNode;
  import org.graalvm.compiler.nodes.memory.address.AddressNode;
  import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;
  import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.spi.GCProvider;</span>
  import org.graalvm.compiler.nodes.spi.Lowerable;
  import org.graalvm.compiler.nodes.spi.LoweringProvider;
  import org.graalvm.compiler.nodes.spi.LoweringTool;
  import org.graalvm.compiler.nodes.type.StampTool;
  import org.graalvm.compiler.nodes.util.GraphUtil;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,10 ***</span>
<span class="line-new-header">--- 155,11 ---</span>
  import jdk.vm.ci.code.CodeUtil;
  import jdk.vm.ci.code.MemoryBarriers;
  import jdk.vm.ci.code.TargetDescription;
  import jdk.vm.ci.meta.DeoptimizationAction;
  import jdk.vm.ci.meta.DeoptimizationReason;
<span class="line-added">+ import jdk.vm.ci.meta.JavaConstant;</span>
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.MetaAccessProvider;
  import jdk.vm.ci.meta.ResolvedJavaField;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.ResolvedJavaType;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,10 ***</span>
<span class="line-new-header">--- 220,12 ---</span>
                  lowerIndexAddressNode((IndexAddressNode) n);
              } else if (n instanceof ArrayLengthNode) {
                  lowerArrayLengthNode((ArrayLengthNode) n, tool);
              } else if (n instanceof LoadHubNode) {
                  lowerLoadHubNode((LoadHubNode) n, tool);
<span class="line-added">+             } else if (n instanceof LoadHubOrNullNode) {</span>
<span class="line-added">+                 lowerLoadHubOrNullNode((LoadHubOrNullNode) n, tool);</span>
              } else if (n instanceof LoadArrayComponentHubNode) {
                  lowerLoadArrayComponentHubNode((LoadArrayComponentHubNode) n);
              } else if (n instanceof MonitorEnterNode) {
                  lowerMonitorEnterNode((MonitorEnterNode) n, tool, graph);
              } else if (n instanceof UnsafeCompareAndSwapNode) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,16 ***</span>
          Stamp loadStamp = loadStamp(loadField.stamp(NodeView.DEFAULT), getStorageKind(field));
  
          AddressNode address = createFieldAddress(graph, object, field);
          assert address != null : &quot;Field that is loaded must not be eliminated: &quot; + field.getDeclaringClass().toJavaName(true) + &quot;.&quot; + field.getName();
  
<span class="line-modified">!         ReadNode memoryRead = graph.add(new ReadNode(address, fieldLocationIdentity(field), loadStamp, fieldLoadBarrierType(field)));</span>
          ValueNode readValue = implicitLoadConvert(graph, getStorageKind(field), memoryRead);
          loadField.replaceAtUsages(readValue);
          graph.replaceFixed(loadField, memoryRead);
  
<span class="line-modified">!         if (loadField.isVolatile()) {</span>
              MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_READ));
              graph.addBeforeFixed(memoryRead, preMembar);
              MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_READ));
              graph.addAfterFixed(memoryRead, postMembar);
          }
<span class="line-new-header">--- 398,21 ---</span>
          Stamp loadStamp = loadStamp(loadField.stamp(NodeView.DEFAULT), getStorageKind(field));
  
          AddressNode address = createFieldAddress(graph, object, field);
          assert address != null : &quot;Field that is loaded must not be eliminated: &quot; + field.getDeclaringClass().toJavaName(true) + &quot;.&quot; + field.getName();
  
<span class="line-modified">!         ReadNode memoryRead = null;</span>
<span class="line-added">+         if (loadField.isVolatile() &amp;&amp; GraalOptions.LateMembars.getValue(graph.getOptions())) {</span>
<span class="line-added">+             memoryRead = graph.add(new VolatileReadNode(address, fieldLocationIdentity(field), loadStamp, fieldLoadBarrierType(field)));</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             memoryRead = graph.add(new ReadNode(address, fieldLocationIdentity(field), loadStamp, fieldLoadBarrierType(field)));</span>
<span class="line-added">+         }</span>
          ValueNode readValue = implicitLoadConvert(graph, getStorageKind(field), memoryRead);
          loadField.replaceAtUsages(readValue);
          graph.replaceFixed(loadField, memoryRead);
  
<span class="line-modified">!         if (loadField.isVolatile() &amp;&amp; !GraalOptions.LateMembars.getValue(graph.getOptions())) {</span>
              MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_READ));
              graph.addBeforeFixed(memoryRead, preMembar);
              MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_READ));
              graph.addAfterFixed(memoryRead, postMembar);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 406,15 ***</span>
          object = createNullCheckedValue(object, storeField, tool);
          ValueNode value = implicitStoreConvert(graph, getStorageKind(storeField.field()), storeField.value());
          AddressNode address = createFieldAddress(graph, object, field);
          assert address != null;
  
<span class="line-modified">!         WriteNode memoryWrite = graph.add(new WriteNode(address, fieldLocationIdentity(field), value, fieldStoreBarrierType(storeField.field())));</span>
          memoryWrite.setStateAfter(storeField.stateAfter());
          graph.replaceFixedWithFixed(storeField, memoryWrite);
  
<span class="line-modified">!         if (storeField.isVolatile()) {</span>
              MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_WRITE));
              graph.addBeforeFixed(memoryWrite, preMembar);
              MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_WRITE));
              graph.addAfterFixed(memoryWrite, postMembar);
          }
<span class="line-new-header">--- 425,15 ---</span>
          object = createNullCheckedValue(object, storeField, tool);
          ValueNode value = implicitStoreConvert(graph, getStorageKind(storeField.field()), storeField.value());
          AddressNode address = createFieldAddress(graph, object, field);
          assert address != null;
  
<span class="line-modified">!         WriteNode memoryWrite = graph.add(new WriteNode(address, fieldLocationIdentity(field), value, fieldStoreBarrierType(storeField.field()), storeField.isVolatile()));</span>
          memoryWrite.setStateAfter(storeField.stateAfter());
          graph.replaceFixedWithFixed(storeField, memoryWrite);
  
<span class="line-modified">!         if (storeField.isVolatile() &amp;&amp; !GraalOptions.LateMembars.getValue(graph.getOptions())) {</span>
              MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_WRITE));
              graph.addBeforeFixed(memoryWrite, preMembar);
              MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_WRITE));
              graph.addAfterFixed(memoryWrite, postMembar);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,10 ***</span>
<span class="line-new-header">--- 449,14 ---</span>
          ValueNode positiveIndex = graph.maybeAddOrUnique(PiNode.create(index, POSITIVE_ARRAY_INDEX_STAMP, boundsCheck != null ? boundsCheck.asNode() : null));
          return createArrayAddress(graph, array, elementKind, positiveIndex);
      }
  
      public AddressNode createArrayAddress(StructuredGraph graph, ValueNode array, JavaKind elementKind, ValueNode index) {
<span class="line-added">+         return createArrayAddress(graph, array, elementKind, elementKind, index);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public AddressNode createArrayAddress(StructuredGraph graph, ValueNode array, JavaKind arrayKind, JavaKind elementKind, ValueNode index) {</span>
          ValueNode wordIndex;
          if (target.wordSize &gt; 4) {
              wordIndex = graph.unique(new SignExtendNode(index, target.wordSize * 8));
          } else {
              assert target.wordSize == 4 : &quot;unsupported word size&quot;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 441,18 ***</span>
          }
  
          int shift = CodeUtil.log2(metaAccess.getArrayIndexScale(elementKind));
          ValueNode scaledIndex = graph.unique(new LeftShiftNode(wordIndex, ConstantNode.forInt(shift, graph)));
  
<span class="line-modified">!         int base = metaAccess.getArrayBaseOffset(elementKind);</span>
          ValueNode offset = graph.unique(new AddNode(scaledIndex, ConstantNode.forIntegerKind(target.wordJavaKind, base, graph)));
  
          return graph.unique(new OffsetAddressNode(array, offset));
      }
  
      protected void lowerIndexAddressNode(IndexAddressNode indexAddress) {
<span class="line-modified">!         AddressNode lowered = createArrayAddress(indexAddress.graph(), indexAddress.getArray(), indexAddress.getElementKind(), indexAddress.getIndex());</span>
          indexAddress.replaceAndDelete(lowered);
      }
  
      protected void lowerLoadIndexedNode(LoadIndexedNode loadIndexed, LoweringTool tool) {
          StructuredGraph graph = loadIndexed.graph();
<span class="line-new-header">--- 464,18 ---</span>
          }
  
          int shift = CodeUtil.log2(metaAccess.getArrayIndexScale(elementKind));
          ValueNode scaledIndex = graph.unique(new LeftShiftNode(wordIndex, ConstantNode.forInt(shift, graph)));
  
<span class="line-modified">!         int base = metaAccess.getArrayBaseOffset(arrayKind);</span>
          ValueNode offset = graph.unique(new AddNode(scaledIndex, ConstantNode.forIntegerKind(target.wordJavaKind, base, graph)));
  
          return graph.unique(new OffsetAddressNode(array, offset));
      }
  
      protected void lowerIndexAddressNode(IndexAddressNode indexAddress) {
<span class="line-modified">!         AddressNode lowered = createArrayAddress(indexAddress.graph(), indexAddress.getArray(), indexAddress.getArrayKind(), indexAddress.getElementKind(), indexAddress.getIndex());</span>
          indexAddress.replaceAndDelete(lowered);
      }
  
      protected void lowerLoadIndexedNode(LoadIndexedNode loadIndexed, LoweringTool tool) {
          StructuredGraph graph = loadIndexed.graph();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 511,11 ***</span>
              }
          }
  
          AddressNode address = createArrayIndexAddress(graph, array, elementKind, storeIndexed.index(), boundsCheck);
          WriteNode memoryWrite = graph.add(new WriteNode(address, NamedLocationIdentity.getArrayLocation(elementKind), implicitStoreConvert(graph, elementKind, value),
<span class="line-modified">!                         arrayStoreBarrierType(storeIndexed.elementKind())));</span>
          memoryWrite.setGuard(boundsCheck);
          if (condition != null) {
              tool.createGuard(storeIndexed, condition, DeoptimizationReason.ArrayStoreException, DeoptimizationAction.InvalidateReprofile);
          }
          memoryWrite.setStateAfter(storeIndexed.stateAfter());
<span class="line-new-header">--- 534,11 ---</span>
              }
          }
  
          AddressNode address = createArrayIndexAddress(graph, array, elementKind, storeIndexed.index(), boundsCheck);
          WriteNode memoryWrite = graph.add(new WriteNode(address, NamedLocationIdentity.getArrayLocation(elementKind), implicitStoreConvert(graph, elementKind, value),
<span class="line-modified">!                         arrayStoreBarrierType(storeIndexed.elementKind()), false));</span>
          memoryWrite.setGuard(boundsCheck);
          if (condition != null) {
              tool.createGuard(storeIndexed, condition, DeoptimizationReason.ArrayStoreException, DeoptimizationAction.InvalidateReprofile);
          }
          memoryWrite.setStateAfter(storeIndexed.stateAfter());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 552,10 ***</span>
<span class="line-new-header">--- 575,40 ---</span>
          }
          ValueNode hub = createReadHub(graph, loadHub.getValue(), tool);
          loadHub.replaceAtUsagesAndDelete(hub);
      }
  
<span class="line-added">+     protected void lowerLoadHubOrNullNode(LoadHubOrNullNode loadHubOrNullNode, LoweringTool tool) {</span>
<span class="line-added">+         StructuredGraph graph = loadHubOrNullNode.graph();</span>
<span class="line-added">+         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (graph.getGuardsStage().allowsFloatingGuards()) {</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         final FixedWithNextNode predecessor = tool.lastFixedNode();</span>
<span class="line-added">+         final ValueNode value = loadHubOrNullNode.getValue();</span>
<span class="line-added">+         AbstractPointerStamp stamp = (AbstractPointerStamp) value.stamp(NodeView.DEFAULT);</span>
<span class="line-added">+         final LogicNode isNull = graph.addOrUniqueWithInputs(IsNullNode.create(value));</span>
<span class="line-added">+         final EndNode trueEnd = graph.add(new EndNode());</span>
<span class="line-added">+         final EndNode falseEnd = graph.add(new EndNode());</span>
<span class="line-added">+         final IfNode ifNode = graph.add(new IfNode(isNull, trueEnd, falseEnd, 0.5));</span>
<span class="line-added">+         final MergeNode merge = graph.add(new MergeNode());</span>
<span class="line-added">+         merge.addForwardEnd(trueEnd);</span>
<span class="line-added">+         merge.addForwardEnd(falseEnd);</span>
<span class="line-added">+         final AbstractPointerStamp hubStamp = (AbstractPointerStamp) loadHubOrNullNode.stamp(NodeView.DEFAULT);</span>
<span class="line-added">+         ValueNode nullHub = ConstantNode.forConstant(hubStamp.asAlwaysNull(), JavaConstant.NULL_POINTER, tool.getMetaAccess(), graph);</span>
<span class="line-added">+         final ValueNode nonNullValue = graph.addOrUniqueWithInputs(PiNode.create(value, stamp.asNonNull(), ifNode.falseSuccessor()));</span>
<span class="line-added">+         ValueNode hub = createReadHub(graph, nonNullValue, tool);</span>
<span class="line-added">+         ValueNode[] values = new ValueNode[]{nullHub, hub};</span>
<span class="line-added">+         final PhiNode hubPhi = graph.unique(new ValuePhiNode(hubStamp, merge, values));</span>
<span class="line-added">+         final FixedNode oldNext = predecessor.next();</span>
<span class="line-added">+         predecessor.setNext(ifNode);</span>
<span class="line-added">+         merge.setNext(oldNext);</span>
<span class="line-added">+         loadHubOrNullNode.replaceAtUsagesAndDelete(hubPhi);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      protected void lowerLoadArrayComponentHubNode(LoadArrayComponentHubNode loadHub) {
          StructuredGraph graph = loadHub.graph();
          ValueNode hub = createReadArrayComponentHub(graph, loadHub.getValue(), loadHub);
          graph.replaceFixed(loadHub, hub);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,11 ***</span>
          ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
          ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
  
          AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
          BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);
<span class="line-modified">!         LogicCompareAndSwapNode atomicNode = graph.add(new LogicCompareAndSwapNode(address, cas.getLocationIdentity(), expectedValue, newValue, barrierType));</span>
          atomicNode.setStateAfter(cas.stateAfter());
          graph.replaceFixedWithFixed(cas, atomicNode);
      }
  
      protected void lowerCompareAndExchangeNode(UnsafeCompareAndExchangeNode cas) {
<span class="line-new-header">--- 629,11 ---</span>
          ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
          ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
  
          AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
          BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);
<span class="line-modified">!         LogicCompareAndSwapNode atomicNode = graph.add(new LogicCompareAndSwapNode(address, cas.getKilledLocationIdentity(), expectedValue, newValue, barrierType));</span>
          atomicNode.setStateAfter(cas.stateAfter());
          graph.replaceFixedWithFixed(cas, atomicNode);
      }
  
      protected void lowerCompareAndExchangeNode(UnsafeCompareAndExchangeNode cas) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,11 ***</span>
          ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
          ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
  
          AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
          BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);
<span class="line-modified">!         ValueCompareAndSwapNode atomicNode = graph.add(new ValueCompareAndSwapNode(address, expectedValue, newValue, cas.getLocationIdentity(), barrierType));</span>
          ValueNode coercedNode = implicitLoadConvert(graph, valueKind, atomicNode, true);
          atomicNode.setStateAfter(cas.stateAfter());
          cas.replaceAtUsages(coercedNode);
          graph.replaceFixedWithFixed(cas, atomicNode);
      }
<span class="line-new-header">--- 643,11 ---</span>
          ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
          ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
  
          AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
          BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);
<span class="line-modified">!         ValueCompareAndSwapNode atomicNode = graph.add(new ValueCompareAndSwapNode(address, expectedValue, newValue, cas.getKilledLocationIdentity(), barrierType));</span>
          ValueNode coercedNode = implicitLoadConvert(graph, valueKind, atomicNode, true);
          atomicNode.setStateAfter(cas.stateAfter());
          cas.replaceAtUsages(coercedNode);
          graph.replaceFixedWithFixed(cas, atomicNode);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 606,11 ***</span>
          ValueNode newValue = implicitStoreConvert(graph, valueKind, n.newValue());
  
          AddressNode address = graph.unique(new OffsetAddressNode(n.object(), n.offset()));
          BarrierType barrierType = guessStoreBarrierType(n.object(), n.newValue());
          LIRKind lirAccessKind = LIRKind.fromJavaKind(target.arch, valueKind);
<span class="line-modified">!         LoweredAtomicReadAndWriteNode memoryRead = graph.add(new LoweredAtomicReadAndWriteNode(address, n.getLocationIdentity(), newValue, lirAccessKind, barrierType));</span>
          memoryRead.setStateAfter(n.stateAfter());
  
          ValueNode readValue = implicitLoadConvert(graph, valueKind, memoryRead);
          n.stateAfter().replaceFirstInput(n, memoryRead);
          n.replaceAtUsages(readValue);
<span class="line-new-header">--- 659,11 ---</span>
          ValueNode newValue = implicitStoreConvert(graph, valueKind, n.newValue());
  
          AddressNode address = graph.unique(new OffsetAddressNode(n.object(), n.offset()));
          BarrierType barrierType = guessStoreBarrierType(n.object(), n.newValue());
          LIRKind lirAccessKind = LIRKind.fromJavaKind(target.arch, valueKind);
<span class="line-modified">!         LoweredAtomicReadAndWriteNode memoryRead = graph.add(new LoweredAtomicReadAndWriteNode(address, n.getKilledLocationIdentity(), newValue, lirAccessKind, barrierType));</span>
          memoryRead.setStateAfter(n.stateAfter());
  
          ValueNode readValue = implicitLoadConvert(graph, valueKind, memoryRead);
          n.stateAfter().replaceFirstInput(n, memoryRead);
          n.replaceAtUsages(readValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 619,28 ***</span>
  
      /**
       * @param tool utility for performing the lowering
       */
      protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {
          StructuredGraph graph = load.graph();
          if (load instanceof GuardedUnsafeLoadNode) {
              GuardedUnsafeLoadNode guardedLoad = (GuardedUnsafeLoadNode) load;
              GuardingNode guard = guardedLoad.getGuard();
              if (guard == null) {
                  // can float freely if the guard folded away
<span class="line-modified">!                 ReadNode memoryRead = createUnsafeRead(graph, load, null);</span>
                  memoryRead.setForceFixed(false);
                  graph.replaceFixedWithFixed(load, memoryRead);
              } else {
                  // must be guarded, but flows below the guard
<span class="line-modified">!                 ReadNode memoryRead = createUnsafeRead(graph, load, guard);</span>
                  graph.replaceFixedWithFixed(load, memoryRead);
              }
          } else {
              // never had a guarding condition so it must be fixed, creation of the read will force
              // it to be fixed
<span class="line-modified">!             ReadNode memoryRead = createUnsafeRead(graph, load, null);</span>
              graph.replaceFixedWithFixed(load, memoryRead);
          }
      }
  
      protected AddressNode createUnsafeAddress(StructuredGraph graph, ValueNode object, ValueNode offset) {
<span class="line-new-header">--- 672,29 ---</span>
  
      /**
       * @param tool utility for performing the lowering
       */
      protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {
<span class="line-added">+         GCProvider gc = tool.getProviders().getGC();</span>
          StructuredGraph graph = load.graph();
          if (load instanceof GuardedUnsafeLoadNode) {
              GuardedUnsafeLoadNode guardedLoad = (GuardedUnsafeLoadNode) load;
              GuardingNode guard = guardedLoad.getGuard();
              if (guard == null) {
                  // can float freely if the guard folded away
<span class="line-modified">!                 ReadNode memoryRead = createUnsafeRead(gc, graph, load, null);</span>
                  memoryRead.setForceFixed(false);
                  graph.replaceFixedWithFixed(load, memoryRead);
              } else {
                  // must be guarded, but flows below the guard
<span class="line-modified">!                 ReadNode memoryRead = createUnsafeRead(gc, graph, load, guard);</span>
                  graph.replaceFixedWithFixed(load, memoryRead);
              }
          } else {
              // never had a guarding condition so it must be fixed, creation of the read will force
              // it to be fixed
<span class="line-modified">!             ReadNode memoryRead = createUnsafeRead(gc, graph, load, null);</span>
              graph.replaceFixedWithFixed(load, memoryRead);
          }
      }
  
      protected AddressNode createUnsafeAddress(StructuredGraph graph, ValueNode object, ValueNode offset) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 649,16 ***</span>
          } else {
              return graph.unique(new OffsetAddressNode(object, offset));
          }
      }
  
<span class="line-modified">!     protected ReadNode createUnsafeRead(StructuredGraph graph, RawLoadNode load, GuardingNode guard) {</span>
          boolean compressible = load.accessKind() == JavaKind.Object;
          JavaKind readKind = load.accessKind();
          Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, compressible);
          AddressNode address = createUnsafeAddress(graph, load.object(), load.offset());
<span class="line-modified">!         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, BarrierType.NONE));</span>
          if (guard == null) {
              // An unsafe read must not float otherwise it may float above
              // a test guaranteeing the read is safe.
              memoryRead.setForceFixed(true);
          } else {
<span class="line-new-header">--- 703,16 ---</span>
          } else {
              return graph.unique(new OffsetAddressNode(object, offset));
          }
      }
  
<span class="line-modified">!     protected ReadNode createUnsafeRead(GCProvider gc, StructuredGraph graph, RawLoadNode load, GuardingNode guard) {</span>
          boolean compressible = load.accessKind() == JavaKind.Object;
          JavaKind readKind = load.accessKind();
          Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, compressible);
          AddressNode address = createUnsafeAddress(graph, load.object(), load.offset());
<span class="line-modified">!         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, gc.getBarrierSet().readBarrierType(load)));</span>
          if (guard == null) {
              // An unsafe read must not float otherwise it may float above
              // a test guaranteeing the read is safe.
              memoryRead.setForceFixed(true);
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 697,22 ***</span>
          StructuredGraph graph = store.graph();
          boolean compressible = store.value().getStackKind() == JavaKind.Object;
          JavaKind valueKind = store.accessKind();
          ValueNode value = implicitStoreConvert(graph, valueKind, store.value(), compressible);
          AddressNode address = createUnsafeAddress(graph, store.object(), store.offset());
<span class="line-modified">!         WriteNode write = graph.add(new WriteNode(address, store.getLocationIdentity(), value, unsafeStoreBarrierType(store)));</span>
          write.setStateAfter(store.stateAfter());
          graph.replaceFixedWithFixed(store, write);
      }
  
      protected void lowerUnsafeMemoryStoreNode(UnsafeMemoryStoreNode store) {
          StructuredGraph graph = store.graph();
          assert store.getValue().getStackKind() != JavaKind.Object;
          JavaKind valueKind = store.getKind();
          ValueNode value = implicitStoreConvert(graph, valueKind, store.getValue(), false);
          AddressNode address = graph.addOrUniqueWithInputs(OffsetAddressNode.create(store.getAddress()));
<span class="line-modified">!         WriteNode write = graph.add(new WriteNode(address, store.getLocationIdentity(), value, BarrierType.NONE));</span>
          write.setStateAfter(store.stateAfter());
          graph.replaceFixedWithFixed(store, write);
      }
  
      protected void lowerJavaReadNode(JavaReadNode read) {
<span class="line-new-header">--- 751,22 ---</span>
          StructuredGraph graph = store.graph();
          boolean compressible = store.value().getStackKind() == JavaKind.Object;
          JavaKind valueKind = store.accessKind();
          ValueNode value = implicitStoreConvert(graph, valueKind, store.value(), compressible);
          AddressNode address = createUnsafeAddress(graph, store.object(), store.offset());
<span class="line-modified">!         WriteNode write = graph.add(new WriteNode(address, store.getKilledLocationIdentity(), value, unsafeStoreBarrierType(store), false));</span>
          write.setStateAfter(store.stateAfter());
          graph.replaceFixedWithFixed(store, write);
      }
  
      protected void lowerUnsafeMemoryStoreNode(UnsafeMemoryStoreNode store) {
          StructuredGraph graph = store.graph();
          assert store.getValue().getStackKind() != JavaKind.Object;
          JavaKind valueKind = store.getKind();
          ValueNode value = implicitStoreConvert(graph, valueKind, store.getValue(), false);
          AddressNode address = graph.addOrUniqueWithInputs(OffsetAddressNode.create(store.getAddress()));
<span class="line-modified">!         WriteNode write = graph.add(new WriteNode(address, store.getKilledLocationIdentity(), value, BarrierType.NONE, false));</span>
          write.setStateAfter(store.stateAfter());
          graph.replaceFixedWithFixed(store, write);
      }
  
      protected void lowerJavaReadNode(JavaReadNode read) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 735,11 ***</span>
      }
  
      protected void lowerJavaWriteNode(JavaWriteNode write) {
          StructuredGraph graph = write.graph();
          ValueNode value = implicitStoreConvert(graph, write.getWriteKind(), write.value(), write.isCompressible());
<span class="line-modified">!         WriteNode memoryWrite = graph.add(new WriteNode(write.getAddress(), write.getLocationIdentity(), value, write.getBarrierType()));</span>
          memoryWrite.setStateAfter(write.stateAfter());
          graph.replaceFixedWithFixed(write, memoryWrite);
          memoryWrite.setGuard(write.getGuard());
      }
  
<span class="line-new-header">--- 789,11 ---</span>
      }
  
      protected void lowerJavaWriteNode(JavaWriteNode write) {
          StructuredGraph graph = write.graph();
          ValueNode value = implicitStoreConvert(graph, write.getWriteKind(), write.value(), write.isCompressible());
<span class="line-modified">!         WriteNode memoryWrite = graph.add(new WriteNode(write.getAddress(), write.getKilledLocationIdentity(), value, write.getBarrierType(), false));</span>
          memoryWrite.setStateAfter(write.stateAfter());
          graph.replaceFixedWithFixed(write, memoryWrite);
          memoryWrite.setGuard(write.getGuard());
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 760,10 ***</span>
<span class="line-new-header">--- 814,12 ---</span>
                      if (virtual instanceof VirtualInstanceNode) {
                          newObject = graph.add(createNewInstanceFromVirtual(virtual));
                      } else {
                          newObject = graph.add(createNewArrayFromVirtual(virtual, ConstantNode.forInt(entryCount, graph)));
                      }
<span class="line-added">+                     // The final STORE_STORE barrier will be emitted by finishAllocatedObjects</span>
<span class="line-added">+                     newObject.clearEmitMemoryBarrier();</span>
  
                      recursiveLowerings.add(newObject);
                      graph.addBeforeFixed(commit, newObject);
                      allocations[objIndex] = newObject;
                      for (int i = 0; i &lt; entryCount; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 793,11 ***</span>
                              } else {
                                  address = createOffsetAddress(graph, newObject, metaAccess.getArrayBaseOffset(entryKind) + i * metaAccess.getArrayIndexScale(entryKind));
                                  barrierType = arrayInitializationBarrier(entryKind);
                              }
                              if (address != null) {
<span class="line-modified">!                                 WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, entryKind, value), barrierType);</span>
                                  graph.addAfterFixed(newObject, graph.add(write));
                              }
                          }
                          valuePos++;
                      }
<span class="line-new-header">--- 849,11 ---</span>
                              } else {
                                  address = createOffsetAddress(graph, newObject, metaAccess.getArrayBaseOffset(entryKind) + i * metaAccess.getArrayIndexScale(entryKind));
                                  barrierType = arrayInitializationBarrier(entryKind);
                              }
                              if (address != null) {
<span class="line-modified">!                                 WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, entryKind, value), barrierType, false);</span>
                                  graph.addAfterFixed(newObject, graph.add(write));
                              }
                          }
                          valuePos++;
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 820,17 ***</span>
                                  AddressNode address;
                                  BarrierType barrierType;
                                  if (virtual instanceof VirtualInstanceNode) {
                                      VirtualInstanceNode virtualInstance = (VirtualInstanceNode) virtual;
                                      address = createFieldAddress(graph, newObject, virtualInstance.field(i));
<span class="line-modified">!                                     barrierType = BarrierType.IMPRECISE;</span>
                                  } else {
                                      address = createArrayAddress(graph, newObject, virtual.entryKind(i), ConstantNode.forInt(i, graph));
<span class="line-modified">!                                     barrierType = BarrierType.PRECISE;</span>
                                  }
                                  if (address != null) {
<span class="line-modified">!                                     WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, JavaKind.Object, allocValue), barrierType);</span>
                                      graph.addBeforeFixed(commit, graph.add(write));
                                  }
                              }
                          }
                          valuePos++;
<span class="line-new-header">--- 876,17 ---</span>
                                  AddressNode address;
                                  BarrierType barrierType;
                                  if (virtual instanceof VirtualInstanceNode) {
                                      VirtualInstanceNode virtualInstance = (VirtualInstanceNode) virtual;
                                      address = createFieldAddress(graph, newObject, virtualInstance.field(i));
<span class="line-modified">!                                     barrierType = fieldStoreBarrierType(virtualInstance.field(i));</span>
                                  } else {
                                      address = createArrayAddress(graph, newObject, virtual.entryKind(i), ConstantNode.forInt(i, graph));
<span class="line-modified">!                                     barrierType = arrayStoreBarrierType(virtual.entryKind(i));</span>
                                  }
                                  if (address != null) {
<span class="line-modified">!                                     WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, JavaKind.Object, allocValue), barrierType, false);</span>
                                      graph.addBeforeFixed(commit, graph.add(write));
                                  }
                              }
                          }
                          valuePos++;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 937,29 ***</span>
      protected BarrierType fieldLoadBarrierType(ResolvedJavaField field) {
          return BarrierType.NONE;
      }
  
      protected BarrierType fieldStoreBarrierType(ResolvedJavaField field) {
<span class="line-modified">!         if (field.getJavaKind() == JavaKind.Object) {</span>
<span class="line-modified">!             return BarrierType.IMPRECISE;</span>
          }
          return BarrierType.NONE;
      }
  
      protected BarrierType arrayStoreBarrierType(JavaKind elementKind) {
          if (elementKind == JavaKind.Object) {
<span class="line-modified">!             return BarrierType.PRECISE;</span>
          }
          return BarrierType.NONE;
      }
  
      public BarrierType fieldInitializationBarrier(JavaKind entryKind) {
<span class="line-modified">!         return entryKind == JavaKind.Object ? BarrierType.IMPRECISE : BarrierType.NONE;</span>
      }
  
      public BarrierType arrayInitializationBarrier(JavaKind entryKind) {
<span class="line-modified">!         return entryKind == JavaKind.Object ? BarrierType.PRECISE : BarrierType.NONE;</span>
      }
  
      private BarrierType unsafeStoreBarrierType(RawStoreNode store) {
          if (!store.needsBarrier()) {
              return BarrierType.NONE;
<span class="line-new-header">--- 993,29 ---</span>
      protected BarrierType fieldLoadBarrierType(ResolvedJavaField field) {
          return BarrierType.NONE;
      }
  
      protected BarrierType fieldStoreBarrierType(ResolvedJavaField field) {
<span class="line-modified">!         if (getStorageKind(field) == JavaKind.Object) {</span>
<span class="line-modified">!             return BarrierType.FIELD;</span>
          }
          return BarrierType.NONE;
      }
  
      protected BarrierType arrayStoreBarrierType(JavaKind elementKind) {
          if (elementKind == JavaKind.Object) {
<span class="line-modified">!             return BarrierType.ARRAY;</span>
          }
          return BarrierType.NONE;
      }
  
      public BarrierType fieldInitializationBarrier(JavaKind entryKind) {
<span class="line-modified">!         return entryKind == JavaKind.Object ? BarrierType.FIELD : BarrierType.NONE;</span>
      }
  
      public BarrierType arrayInitializationBarrier(JavaKind entryKind) {
<span class="line-modified">!         return entryKind == JavaKind.Object ? BarrierType.ARRAY : BarrierType.NONE;</span>
      }
  
      private BarrierType unsafeStoreBarrierType(RawStoreNode store) {
          if (!store.needsBarrier()) {
              return BarrierType.NONE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 970,14 ***</span>
      private BarrierType guessStoreBarrierType(ValueNode object, ValueNode value) {
          if (value.getStackKind() == JavaKind.Object &amp;&amp; object.getStackKind() == JavaKind.Object) {
              ResolvedJavaType type = StampTool.typeOrNull(object);
              // Array types must use a precise barrier, so if the type is unknown or is a supertype
              // of Object[] then treat it as an array.
<span class="line-modified">!             if (type == null || type.isArray() || type.isAssignableFrom(objectArrayType)) {</span>
<span class="line-modified">!                 return BarrierType.PRECISE;</span>
              } else {
<span class="line-modified">!                 return BarrierType.IMPRECISE;</span>
              }
          }
          return BarrierType.NONE;
      }
  
<span class="line-new-header">--- 1026,16 ---</span>
      private BarrierType guessStoreBarrierType(ValueNode object, ValueNode value) {
          if (value.getStackKind() == JavaKind.Object &amp;&amp; object.getStackKind() == JavaKind.Object) {
              ResolvedJavaType type = StampTool.typeOrNull(object);
              // Array types must use a precise barrier, so if the type is unknown or is a supertype
              // of Object[] then treat it as an array.
<span class="line-modified">!             if (type != null &amp;&amp; type.isArray()) {</span>
<span class="line-modified">!                 return BarrierType.ARRAY;</span>
<span class="line-added">+             } else if (type == null || type.isAssignableFrom(objectArrayType)) {</span>
<span class="line-added">+                 return BarrierType.UNKNOWN;</span>
              } else {
<span class="line-modified">!                 return BarrierType.FIELD;</span>
              }
          }
          return BarrierType.NONE;
      }
  
</pre>
<center><a href="ConstantStringIndexOfSnippets.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphKit.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/StandardGraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.replacements;
  26 
  27 import static jdk.vm.ci.code.MemoryBarriers.JMM_POST_VOLATILE_READ;
  28 import static jdk.vm.ci.code.MemoryBarriers.JMM_POST_VOLATILE_WRITE;
  29 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_READ;
  30 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_WRITE;
  31 import static jdk.vm.ci.code.MemoryBarriers.LOAD_LOAD;
  32 import static jdk.vm.ci.code.MemoryBarriers.LOAD_STORE;
  33 import static jdk.vm.ci.code.MemoryBarriers.STORE_LOAD;
  34 import static jdk.vm.ci.code.MemoryBarriers.STORE_STORE;
  35 import static org.graalvm.compiler.nodes.NamedLocationIdentity.OFF_HEAP_LOCATION;
  36 import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java11OrEarlier;
  37 import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java8OrEarlier;
  38 
  39 import java.lang.reflect.Array;
  40 import java.lang.reflect.Field;
  41 import java.util.Arrays;
  42 
  43 import org.graalvm.compiler.api.directives.GraalDirectives;
  44 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  45 import org.graalvm.compiler.bytecode.BytecodeProvider;
  46 import org.graalvm.compiler.core.common.calc.Condition;
  47 import org.graalvm.compiler.core.common.calc.Condition.CanonicalizedCondition;
  48 import org.graalvm.compiler.core.common.calc.UnsignedMath;
  49 import org.graalvm.compiler.core.common.type.ObjectStamp;
  50 import org.graalvm.compiler.core.common.type.Stamp;
  51 import org.graalvm.compiler.core.common.type.StampFactory;
  52 import org.graalvm.compiler.core.common.type.TypeReference;
  53 import org.graalvm.compiler.debug.GraalError;
  54 import org.graalvm.compiler.graph.Edges;
  55 import org.graalvm.compiler.graph.Node;
  56 import org.graalvm.compiler.graph.NodeList;
  57 import org.graalvm.compiler.nodes.AbstractBeginNode;
  58 import org.graalvm.compiler.nodes.BeginNode;
  59 import org.graalvm.compiler.nodes.ConstantNode;
  60 import org.graalvm.compiler.nodes.DeoptimizeNode;
  61 import org.graalvm.compiler.nodes.EndNode;
  62 import org.graalvm.compiler.nodes.FixedGuardNode;
  63 import org.graalvm.compiler.nodes.FixedWithNextNode;
  64 import org.graalvm.compiler.nodes.IfNode;
  65 import org.graalvm.compiler.nodes.LogicNode;
  66 import org.graalvm.compiler.nodes.MergeNode;
  67 import org.graalvm.compiler.nodes.NamedLocationIdentity;
  68 import org.graalvm.compiler.nodes.NodeView;
  69 import org.graalvm.compiler.nodes.StateSplit;
  70 import org.graalvm.compiler.nodes.StructuredGraph;
  71 import org.graalvm.compiler.nodes.ValueNode;
  72 import org.graalvm.compiler.nodes.ValuePhiNode;
  73 import org.graalvm.compiler.nodes.calc.AbsNode;
  74 import org.graalvm.compiler.nodes.calc.CompareNode;
  75 import org.graalvm.compiler.nodes.calc.ConditionalNode;
  76 import org.graalvm.compiler.nodes.calc.FloatEqualsNode;
  77 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  78 import org.graalvm.compiler.nodes.calc.IsNullNode;
  79 import org.graalvm.compiler.nodes.calc.NarrowNode;
  80 import org.graalvm.compiler.nodes.calc.ReinterpretNode;
  81 import org.graalvm.compiler.nodes.calc.RightShiftNode;
  82 import org.graalvm.compiler.nodes.calc.SignExtendNode;
  83 import org.graalvm.compiler.nodes.calc.SqrtNode;
  84 import org.graalvm.compiler.nodes.calc.UnsignedDivNode;
  85 import org.graalvm.compiler.nodes.calc.UnsignedRemNode;
  86 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  87 import org.graalvm.compiler.nodes.debug.BindToRegisterNode;
  88 import org.graalvm.compiler.nodes.debug.BlackholeNode;
  89 import org.graalvm.compiler.nodes.debug.ControlFlowAnchorNode;
  90 import org.graalvm.compiler.nodes.debug.SpillRegistersNode;
  91 import org.graalvm.compiler.nodes.extended.BoxNode;
  92 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;
  93 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
  94 import org.graalvm.compiler.nodes.extended.GetClassNode;
  95 import org.graalvm.compiler.nodes.extended.GuardingNode;
  96 import org.graalvm.compiler.nodes.extended.JavaReadNode;
  97 import org.graalvm.compiler.nodes.extended.JavaWriteNode;
  98 import org.graalvm.compiler.nodes.extended.MembarNode;
  99 import org.graalvm.compiler.nodes.extended.OpaqueNode;
 100 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 101 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 102 import org.graalvm.compiler.nodes.extended.UnboxNode;
 103 import org.graalvm.compiler.nodes.extended.UnsafeMemoryLoadNode;
 104 import org.graalvm.compiler.nodes.extended.UnsafeMemoryStoreNode;
 105 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 106 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 107 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 108 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 109 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 110 import org.graalvm.compiler.nodes.java.ClassIsAssignableFromNode;
 111 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
 112 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
 113 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 114 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 115 import org.graalvm.compiler.nodes.java.RegisterFinalizerNode;
 116 import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
 117 import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
 118 import org.graalvm.compiler.nodes.memory.HeapAccess;
 119 import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;
 120 import org.graalvm.compiler.nodes.type.StampTool;
 121 import org.graalvm.compiler.nodes.util.GraphUtil;
 122 import org.graalvm.compiler.nodes.virtual.EnsureVirtualizedNode;
 123 import org.graalvm.compiler.replacements.nodes.ProfileBooleanNode;
 124 import org.graalvm.compiler.replacements.nodes.ReverseBytesNode;
 125 import org.graalvm.compiler.replacements.nodes.VirtualizableInvokeMacroNode;
 126 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactNode;
 127 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactOverflowNode;
 128 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactSplitNode;
 129 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerExactArithmeticSplitNode;
 130 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactNode;
 131 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactOverflowNode;
 132 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactSplitNode;
 133 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactNode;
 134 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactOverflowNode;
 135 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactSplitNode;
 136 import org.graalvm.compiler.serviceprovider.SpeculationReasonGroup;
 137 import jdk.internal.vm.compiler.word.LocationIdentity;
 138 
 139 import jdk.vm.ci.code.BytecodePosition;
 140 import jdk.vm.ci.meta.DeoptimizationAction;
 141 import jdk.vm.ci.meta.DeoptimizationReason;
 142 import jdk.vm.ci.meta.JavaConstant;
 143 import jdk.vm.ci.meta.JavaKind;
 144 import jdk.vm.ci.meta.MetaAccessProvider;
 145 import jdk.vm.ci.meta.ResolvedJavaField;
 146 import jdk.vm.ci.meta.ResolvedJavaMethod;
 147 import jdk.vm.ci.meta.ResolvedJavaType;
 148 import jdk.vm.ci.meta.SpeculationLog;
 149 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 150 import jdk.vm.ci.meta.SpeculationLog.SpeculationReason;
 151 import sun.misc.Unsafe;
 152 
 153 /**
 154  * Provides non-runtime specific {@link InvocationPlugin}s.
 155  */
 156 public class StandardGraphBuilderPlugins {
 157 
 158     public static void registerInvocationPlugins(MetaAccessProvider metaAccess, SnippetReflectionProvider snippetReflection, InvocationPlugins plugins, BytecodeProvider bytecodeProvider,
 159                     boolean allowDeoptimization, boolean explicitUnsafeNullChecks) {
 160         registerObjectPlugins(plugins);
 161         registerClassPlugins(plugins);
 162         registerMathPlugins(plugins, allowDeoptimization);
 163         registerStrictMathPlugins(plugins);
 164         registerUnsignedMathPlugins(plugins);
 165         registerStringPlugins(plugins, bytecodeProvider, snippetReflection);
 166         registerCharacterPlugins(plugins);
 167         registerShortPlugins(plugins);
 168         registerIntegerLongPlugins(plugins, JavaKind.Int);
 169         registerIntegerLongPlugins(plugins, JavaKind.Long);
 170         registerFloatPlugins(plugins);
 171         registerDoublePlugins(plugins);
 172         registerArraysPlugins(plugins, bytecodeProvider);
 173         registerArrayPlugins(plugins, bytecodeProvider);
 174         registerUnsafePlugins(plugins, bytecodeProvider, explicitUnsafeNullChecks);
 175         registerEdgesPlugins(metaAccess, plugins);
 176         registerGraalDirectivesPlugins(plugins);
 177         registerBoxingPlugins(plugins);
 178         registerJMHBlackholePlugins(plugins, bytecodeProvider);
 179         registerJFRThrowablePlugins(plugins, bytecodeProvider);
 180         registerMethodHandleImplPlugins(plugins, snippetReflection, bytecodeProvider);
 181         registerJcovCollectPlugins(plugins, bytecodeProvider);
 182     }
 183 
 184     private static final Field STRING_VALUE_FIELD;
 185     private static final Field STRING_CODER_FIELD;
 186 
 187     static {
 188         Field coder = null;
 189         try {
 190             STRING_VALUE_FIELD = String.class.getDeclaredField(&quot;value&quot;);
 191             if (!Java8OrEarlier) {
 192                 coder = String.class.getDeclaredField(&quot;coder&quot;);
 193             }
 194         } catch (NoSuchFieldException e) {
 195             throw new GraalError(e);
 196         }
 197         STRING_CODER_FIELD = coder;
 198     }
 199 
 200     private static void registerStringPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider, SnippetReflectionProvider snippetReflection) {
 201         final Registration r = new Registration(plugins, String.class, bytecodeProvider);
 202         r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {
 203             @Override
 204             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 205                 if (receiver.isConstant()) {
 206                     String s = snippetReflection.asObject(String.class, (JavaConstant) receiver.get().asConstant());
 207                     if (s != null) {
 208                         b.addPush(JavaKind.Int, b.add(ConstantNode.forInt(s.hashCode())));
 209                         return true;
 210                     }
 211                 }
 212                 return false;
 213             }
 214         });
 215 
 216         if (Java8OrEarlier) {
 217             r.registerMethodSubstitution(StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);
 218 
 219             r.register7(&quot;indexOf&quot;, char[].class, int.class, int.class, char[].class, int.class, int.class, int.class, new StringIndexOfConstantPlugin());
 220 
 221             Registration sr = new Registration(plugins, StringSubstitutions.class);
 222             sr.register1(&quot;getValue&quot;, String.class, new InvocationPlugin() {
 223                 @Override
 224                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 225                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_VALUE_FIELD);
 226                     b.addPush(JavaKind.Object, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 227                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 228                     return true;
 229                 }
 230             });
 231         } else {
 232             r.registerMethodSubstitution(JDK9StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);
 233             Registration utf16sub = new Registration(plugins, StringUTF16Substitutions.class, bytecodeProvider);
 234             utf16sub.register2(&quot;getCharDirect&quot;, byte[].class, int.class, new InvocationPlugin() {
 235                 @Override
 236                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2) {
 237                     b.addPush(JavaKind.Char, new JavaReadNode(JavaKind.Char, new IndexAddressNode(arg1, arg2, JavaKind.Byte), NamedLocationIdentity.getArrayLocation(JavaKind.Byte),
 238                                     HeapAccess.BarrierType.NONE, false));
 239                     return true;
 240                 }
 241             });
 242             utf16sub.register3(&quot;putCharDirect&quot;, byte[].class, int.class, int.class, new InvocationPlugin() {
 243                 @Override
 244                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3) {
 245                     b.add(new JavaWriteNode(JavaKind.Char, new IndexAddressNode(arg1, arg2, JavaKind.Byte), NamedLocationIdentity.getArrayLocation(JavaKind.Byte), arg3,
 246                                     HeapAccess.BarrierType.NONE, false));
 247                     return true;
 248                 }
 249             });
 250 
 251             final Registration latin1r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, bytecodeProvider);
 252             latin1r.register5(&quot;indexOf&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringLatin1IndexOfConstantPlugin());
 253 
 254             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, bytecodeProvider);
 255             utf16r.register5(&quot;indexOfUnsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringUTF16IndexOfConstantPlugin());
 256             utf16r.setAllowOverwrite(true);
 257             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChar&quot;, byte[].class, int.class);
 258             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;putChar&quot;, byte[].class, int.class, int.class);
 259 
 260             Registration sr = new Registration(plugins, JDK9StringSubstitutions.class);
 261             sr.register1(&quot;getValue&quot;, String.class, new InvocationPlugin() {
 262                 @Override
 263                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 264                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_VALUE_FIELD);
 265                     b.addPush(JavaKind.Object, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 266                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 267                     return true;
 268                 }
 269             });
 270             sr.register1(&quot;getCoder&quot;, String.class, new InvocationPlugin() {
 271                 @Override
 272                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 273                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_CODER_FIELD);
 274                     b.addPush(JavaKind.Int, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 275                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 276                     return true;
 277                 }
 278             });
 279         }
 280     }
 281 
 282     private static void registerArraysPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {
 283         Registration r = new Registration(plugins, Arrays.class, bytecodeProvider);
 284         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, boolean[].class, boolean[].class);
 285         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, byte[].class, byte[].class);
 286         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, short[].class, short[].class);
 287         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, char[].class, char[].class);
 288         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, int[].class, int[].class);
 289         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, long[].class, long[].class);
 290     }
 291 
 292     private static void registerArrayPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {
 293         Registration r = new Registration(plugins, Array.class, bytecodeProvider);
 294         r.register2(&quot;newInstance&quot;, Class.class, int.class, new InvocationPlugin() {
 295             @Override
 296             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unused, ValueNode componentType, ValueNode length) {
 297                 b.addPush(JavaKind.Object, new DynamicNewArrayNode(componentType, length, true));
 298                 return true;
 299             }
 300         });
 301         r.registerMethodSubstitution(ArraySubstitutions.class, &quot;getLength&quot;, Object.class);
 302     }
 303 
 304     /**
 305      * The intrinsic for {@link Math#sqrt(double)} is shared with {@link StrictMath#sqrt(double)}.
 306      *
 307      * @see &quot;http://hg.openjdk.java.net/jdk/jdk/file/621efe32eb0b/src/hotspot/share/oops/method.cpp#l1504&quot;
 308      */
 309     static final class MathSqrtPlugin implements InvocationPlugin {
 310         @Override
 311         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 312             b.push(JavaKind.Double, b.append(SqrtNode.create(value, NodeView.DEFAULT)));
 313             return true;
 314         }
 315     }
 316 
 317     private abstract static class UnsafeCompareAndUpdatePluginsRegistrar {
 318         public void register(Registration r, String casPrefix, boolean explicitUnsafeNullChecks, JavaKind[] compareAndSwapTypes, boolean java11OrEarlier) {
 319             for (JavaKind kind : compareAndSwapTypes) {
 320                 Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
 321                 String kindName = (kind == JavaKind.Object &amp;&amp; !java11OrEarlier) ? &quot;Reference&quot; : kind.name();
 322                 r.register5(casPrefix + kindName, Receiver.class, Object.class, long.class, javaClass, javaClass, new UnsafeAccessPlugin(returnKind(kind), explicitUnsafeNullChecks) {
 323                     @Override
 324                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode expected, ValueNode x) {
 325                         // Emits a null-check for the otherwise unused receiver
 326                         unsafe.get();
 327                         createUnsafeAccess(object, b, (obj, loc) -&gt; UnsafeCompareAndUpdatePluginsRegistrar.this.createNode(obj, offset, expected, x, kind, loc));
 328                         return true;
 329                     }
 330                 });
 331             }
 332         }
 333 
 334         public abstract FixedWithNextNode createNode(ValueNode object, ValueNode offset, ValueNode expected, ValueNode newValue, JavaKind kind, LocationIdentity identity);
 335 
 336         public abstract JavaKind returnKind(JavaKind accessKind);
 337     }
 338 
 339     private static class UnsafeCompareAndSwapPluginsRegistrar extends UnsafeCompareAndUpdatePluginsRegistrar {
 340         @Override
 341         public FixedWithNextNode createNode(ValueNode object, ValueNode offset, ValueNode expected, ValueNode newValue, JavaKind kind, LocationIdentity identity) {
 342             return new UnsafeCompareAndSwapNode(object, offset, expected, newValue, kind, identity);
 343         }
 344 
 345         @Override
 346         public JavaKind returnKind(JavaKind accessKind) {
 347             return JavaKind.Boolean.getStackKind();
 348         }
 349     }
 350 
 351     private static UnsafeCompareAndSwapPluginsRegistrar unsafeCompareAndSwapPluginsRegistrar = new UnsafeCompareAndSwapPluginsRegistrar();
 352 
 353     private static class UnsafeCompareAndExchangePluginsRegistrar extends UnsafeCompareAndUpdatePluginsRegistrar {
 354         @Override
 355         public FixedWithNextNode createNode(ValueNode object, ValueNode offset, ValueNode expected, ValueNode newValue, JavaKind kind, LocationIdentity identity) {
 356             return new UnsafeCompareAndExchangeNode(object, offset, expected, newValue, kind, identity);
 357         }
 358 
 359         @Override
 360         public JavaKind returnKind(JavaKind accessKind) {
 361             if (accessKind.isNumericInteger()) {
 362                 return accessKind.getStackKind();
 363             } else {
 364                 return accessKind;
 365             }
 366         }
 367     }
 368 
 369     private static UnsafeCompareAndExchangePluginsRegistrar unsafeCompareAndExchangePluginsRegistrar = new UnsafeCompareAndExchangePluginsRegistrar();
 370 
 371     public static void registerPlatformSpecificUnsafePlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider, boolean explicitUnsafeNullChecks, JavaKind[] supportedCasKinds) {
 372         registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
 373         if (!Java8OrEarlier) {
 374             registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, bytecodeProvider), false, explicitUnsafeNullChecks);
 375         }
 376 
 377     }
 378 
 379     private static void registerPlatformSpecificUnsafePlugins(JavaKind[] supportedCasKinds, Registration r, boolean java8OrEarlier, boolean explicitUnsafeNullChecks) {
 380         if (java8OrEarlier) {
 381             unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSwap&quot;, explicitUnsafeNullChecks, new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, true);
 382         } else {
 383             unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSet&quot;, explicitUnsafeNullChecks, supportedCasKinds, Java11OrEarlier);
 384             unsafeCompareAndExchangePluginsRegistrar.register(r, &quot;compareAndExchange&quot;, explicitUnsafeNullChecks, supportedCasKinds, Java11OrEarlier);
 385         }
 386     }
 387 
 388     private static void registerUnsafePlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider, boolean explicitUnsafeNullChecks) {
 389         registerUnsafePlugins(new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
 390         if (!Java8OrEarlier) {
 391             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, bytecodeProvider), false, explicitUnsafeNullChecks);
 392         }
 393     }
 394 
 395     private static void registerUnsafePlugins(Registration r, boolean sunMiscUnsafe, boolean explicitUnsafeNullChecks) {
 396         for (JavaKind kind : JavaKind.values()) {
 397             if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
 398                 Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
 399                 String kindName = (kind == JavaKind.Object &amp;&amp; !sunMiscUnsafe &amp;&amp; !Java11OrEarlier) ? &quot;Reference&quot; : kind.name();
 400                 String getName = &quot;get&quot; + kindName;
 401                 String putName = &quot;put&quot; + kindName;
 402                 // Object-based accesses
 403                 r.register3(getName, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
 404                 r.register4(putName, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
 405                 // Volatile object-based accesses
 406                 r.register3(getName + &quot;Volatile&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.VOLATILE, explicitUnsafeNullChecks));
 407                 r.register4(putName + &quot;Volatile&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.VOLATILE, explicitUnsafeNullChecks));
 408                 // Ordered object-based accesses
 409                 if (sunMiscUnsafe) {
 410                     if (kind == JavaKind.Int || kind == JavaKind.Long || kind == JavaKind.Object) {
 411                         r.register4(&quot;putOrdered&quot; + kindName, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 412                     }
 413                 } else {
 414                     r.register4(&quot;put&quot; + kindName + &quot;Release&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 415                     r.register3(&quot;get&quot; + kindName + &quot;Acquire&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 416                     r.register4(&quot;put&quot; + kindName + &quot;Opaque&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.OPAQUE, explicitUnsafeNullChecks));
 417                     r.register3(&quot;get&quot; + kindName + &quot;Opaque&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.OPAQUE, explicitUnsafeNullChecks));
 418                 }
 419                 if (kind != JavaKind.Boolean &amp;&amp; kind != JavaKind.Object) {
 420                     // Raw accesses to memory addresses
 421                     r.register2(getName, Receiver.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
 422                     r.register3(putName, Receiver.class, long.class, kind.toJavaClass(), new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
 423                 }
 424             }
 425         }
 426 
 427         // Accesses to native memory addresses.
 428         r.register2(&quot;getAddress&quot;, Receiver.class, long.class, new UnsafeGetPlugin(JavaKind.Long, explicitUnsafeNullChecks));
 429         r.register3(&quot;putAddress&quot;, Receiver.class, long.class, long.class, new UnsafePutPlugin(JavaKind.Long, explicitUnsafeNullChecks));
 430 
 431         r.register2(&quot;allocateInstance&quot;, Receiver.class, Class.class, new InvocationPlugin() {
 432 
 433             @Override
 434             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode clazz) {
 435                 // Emits a null-check for the otherwise unused receiver
 436                 unsafe.get();
 437                 b.addPush(JavaKind.Object, new DynamicNewInstanceNode(b.nullCheckedValue(clazz, DeoptimizationAction.None), true));
 438                 return true;
 439             }
 440 
 441         });
 442 
 443         r.register1(&quot;loadFence&quot;, Receiver.class, new UnsafeFencePlugin(LOAD_LOAD | LOAD_STORE));
 444         r.register1(&quot;storeFence&quot;, Receiver.class, new UnsafeFencePlugin(STORE_STORE | LOAD_STORE));
 445         r.register1(&quot;fullFence&quot;, Receiver.class, new UnsafeFencePlugin(LOAD_LOAD | STORE_STORE | LOAD_STORE | STORE_LOAD));
 446     }
 447 
 448     private static void registerIntegerLongPlugins(InvocationPlugins plugins, JavaKind kind) {
 449         Class&lt;?&gt; declaringClass = kind.toBoxedJavaClass();
 450         Class&lt;?&gt; type = kind.toJavaClass();
 451         Registration r = new Registration(plugins, declaringClass);
 452         r.register1(&quot;reverseBytes&quot;, type, new InvocationPlugin() {
 453             @Override
 454             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 455                 b.push(kind, b.append(new ReverseBytesNode(value).canonical(null)));
 456                 return true;
 457             }
 458         });
 459         r.register2(&quot;divideUnsigned&quot;, type, type, new InvocationPlugin() {
 460             @Override
 461             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode dividend, ValueNode divisor) {
 462                 b.push(kind, b.append(UnsignedDivNode.create(dividend, divisor, null, NodeView.DEFAULT)));
 463                 return true;
 464             }
 465         });
 466         r.register2(&quot;remainderUnsigned&quot;, type, type, new InvocationPlugin() {
 467             @Override
 468             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode dividend, ValueNode divisor) {
 469                 b.push(kind, b.append(UnsignedRemNode.create(dividend, divisor, null, NodeView.DEFAULT)));
 470                 return true;
 471             }
 472         });
 473     }
 474 
 475     private static void registerCharacterPlugins(InvocationPlugins plugins) {
 476         Registration r = new Registration(plugins, Character.class);
 477         r.register1(&quot;reverseBytes&quot;, char.class, new InvocationPlugin() {
 478             @Override
 479             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 480                 // return (char) (Integer.reverse(i) &gt;&gt; 16);
 481                 ReverseBytesNode reverse = b.add(new ReverseBytesNode(value));
 482                 RightShiftNode rightShift = b.add(new RightShiftNode(reverse, b.add(ConstantNode.forInt(16))));
 483                 ZeroExtendNode charCast = b.add(new ZeroExtendNode(b.add(new NarrowNode(rightShift, 16)), 32));
 484                 b.push(JavaKind.Char, b.append(charCast.canonical(null)));
 485                 return true;
 486             }
 487         });
 488     }
 489 
 490     private static void registerShortPlugins(InvocationPlugins plugins) {
 491         Registration r = new Registration(plugins, Short.class);
 492         r.register1(&quot;reverseBytes&quot;, short.class, new InvocationPlugin() {
 493             @Override
 494             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 495                 // return (short) (Integer.reverse(i) &gt;&gt; 16);
 496                 ReverseBytesNode reverse = b.add(new ReverseBytesNode(value));
 497                 RightShiftNode rightShift = b.add(new RightShiftNode(reverse, b.add(ConstantNode.forInt(16))));
 498                 SignExtendNode charCast = b.add(new SignExtendNode(b.add(new NarrowNode(rightShift, 16)), 32));
 499                 b.push(JavaKind.Short, b.append(charCast.canonical(null)));
 500                 return true;
 501             }
 502         });
 503     }
 504 
 505     private static void registerFloatPlugins(InvocationPlugins plugins) {
 506         Registration r = new Registration(plugins, Float.class);
 507         r.register1(&quot;floatToRawIntBits&quot;, float.class, new InvocationPlugin() {
 508             @Override
 509             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 510                 b.push(JavaKind.Int, b.append(ReinterpretNode.create(JavaKind.Int, value, NodeView.DEFAULT)));
 511                 return true;
 512             }
 513         });
 514         r.register1(&quot;floatToIntBits&quot;, float.class, new InvocationPlugin() {
 515             @Override
 516             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 517                 LogicNode notNan = b.append(FloatEqualsNode.create(value, value, NodeView.DEFAULT));
 518                 ValueNode raw = b.append(ReinterpretNode.create(JavaKind.Int, value, NodeView.DEFAULT));
 519                 ValueNode result = b.append(ConditionalNode.create(notNan, raw, ConstantNode.forInt(0x7fc00000), NodeView.DEFAULT));
 520                 b.push(JavaKind.Int, result);
 521                 return true;
 522             }
 523         });
 524         r.register1(&quot;intBitsToFloat&quot;, int.class, new InvocationPlugin() {
 525             @Override
 526             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 527                 b.push(JavaKind.Float, b.append(ReinterpretNode.create(JavaKind.Float, value, NodeView.DEFAULT)));
 528                 return true;
 529             }
 530         });
 531     }
 532 
 533     private static void registerDoublePlugins(InvocationPlugins plugins) {
 534         Registration r = new Registration(plugins, Double.class);
 535         r.register1(&quot;doubleToRawLongBits&quot;, double.class, new InvocationPlugin() {
 536             @Override
 537             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 538                 b.push(JavaKind.Long, b.append(ReinterpretNode.create(JavaKind.Long, value, NodeView.DEFAULT)));
 539                 return true;
 540             }
 541         });
 542         r.register1(&quot;doubleToLongBits&quot;, double.class, new InvocationPlugin() {
 543             @Override
 544             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 545                 LogicNode notNan = b.append(FloatEqualsNode.create(value, value, NodeView.DEFAULT));
 546                 ValueNode raw = b.append(ReinterpretNode.create(JavaKind.Long, value, NodeView.DEFAULT));
 547                 ValueNode result = b.append(ConditionalNode.create(notNan, raw, ConstantNode.forLong(0x7ff8000000000000L), NodeView.DEFAULT));
 548                 b.push(JavaKind.Long, result);
 549                 return true;
 550             }
 551         });
 552         r.register1(&quot;longBitsToDouble&quot;, long.class, new InvocationPlugin() {
 553             @Override
 554             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 555                 b.push(JavaKind.Double, b.append(ReinterpretNode.create(JavaKind.Double, value, NodeView.DEFAULT)));
 556                 return true;
 557             }
 558         });
 559     }
 560 
 561     public enum IntegerExactOp {
 562         INTEGER_ADD_EXACT,
 563         INTEGER_INCREMENT_EXACT,
 564         INTEGER_SUBTRACT_EXACT,
 565         INTEGER_DECREMENT_EXACT,
 566         INTEGER_MULTIPLY_EXACT
 567     }
 568 
 569     private static GuardingNode createIntegerExactArithmeticGuardNode(GraphBuilderContext b, ValueNode x, ValueNode y, IntegerExactOp op) {
 570         LogicNode overflowCheck;
 571         switch (op) {
 572             case INTEGER_ADD_EXACT:
 573             case INTEGER_INCREMENT_EXACT: {
 574                 overflowCheck = new IntegerAddExactOverflowNode(x, y);
 575                 break;
 576             }
 577             case INTEGER_SUBTRACT_EXACT:
 578             case INTEGER_DECREMENT_EXACT: {
 579                 overflowCheck = new IntegerSubExactOverflowNode(x, y);
 580                 break;
 581             }
 582             case INTEGER_MULTIPLY_EXACT: {
 583                 overflowCheck = new IntegerMulExactOverflowNode(x, y);
 584                 break;
 585             }
 586             default:
 587                 throw GraalError.shouldNotReachHere(&quot;Unknown integer exact operation.&quot;);
 588         }
 589         return b.add(new FixedGuardNode(overflowCheck, DeoptimizationReason.ArithmeticException, DeoptimizationAction.InvalidateRecompile, true));
 590     }
 591 
 592     private static ValueNode createIntegerExactArithmeticNode(GraphBuilderContext b, ValueNode x, ValueNode y, IntegerExactOp op) {
 593         switch (op) {
 594             case INTEGER_ADD_EXACT:
 595             case INTEGER_INCREMENT_EXACT:
 596                 return new IntegerAddExactNode(x, y, createIntegerExactArithmeticGuardNode(b, x, y, op));
 597             case INTEGER_SUBTRACT_EXACT:
 598             case INTEGER_DECREMENT_EXACT:
 599                 return new IntegerSubExactNode(x, y, createIntegerExactArithmeticGuardNode(b, x, y, op));
 600             case INTEGER_MULTIPLY_EXACT:
 601                 return new IntegerMulExactNode(x, y, createIntegerExactArithmeticGuardNode(b, x, y, op));
 602             default:
 603                 throw GraalError.shouldNotReachHere(&quot;Unknown integer exact operation.&quot;);
 604         }
 605     }
 606 
 607     private static IntegerExactArithmeticSplitNode createIntegerExactSplit(ValueNode x, ValueNode y, AbstractBeginNode exceptionEdge, IntegerExactOp op) {
 608         switch (op) {
 609             case INTEGER_ADD_EXACT:
 610             case INTEGER_INCREMENT_EXACT:
 611                 return new IntegerAddExactSplitNode(x.stamp(NodeView.DEFAULT).unrestricted(), x, y, null, exceptionEdge);
 612             case INTEGER_SUBTRACT_EXACT:
 613             case INTEGER_DECREMENT_EXACT:
 614                 return new IntegerSubExactSplitNode(x.stamp(NodeView.DEFAULT).unrestricted(), x, y, null, exceptionEdge);
 615             case INTEGER_MULTIPLY_EXACT:
 616                 return new IntegerMulExactSplitNode(x.stamp(NodeView.DEFAULT).unrestricted(), x, y, null, exceptionEdge);
 617             default:
 618                 throw GraalError.shouldNotReachHere(&quot;Unknown integer exact operation.&quot;);
 619         }
 620     }
 621 
 622     private static void createIntegerExactOperation(GraphBuilderContext b, JavaKind kind, ValueNode x, ValueNode y, IntegerExactOp op) {
 623         if (b.needsExplicitException()) {
 624             BytecodeExceptionKind exceptionKind = kind == JavaKind.Int ? BytecodeExceptionKind.INTEGER_EXACT_OVERFLOW : BytecodeExceptionKind.LONG_EXACT_OVERFLOW;
 625             AbstractBeginNode exceptionEdge = b.genExplicitExceptionEdge(exceptionKind);
 626             IntegerExactArithmeticSplitNode split = b.addPush(kind, createIntegerExactSplit(x, y, exceptionEdge, op));
 627             split.setNext(b.add(new BeginNode()));
 628         } else {
 629             b.addPush(kind, createIntegerExactArithmeticNode(b, x, y, op));
 630         }
 631     }
 632 
 633     private static void registerMathPlugins(InvocationPlugins plugins, boolean allowDeoptimization) {
 634         Registration r = new Registration(plugins, Math.class);
 635         if (allowDeoptimization) {
 636             for (JavaKind kind : new JavaKind[]{JavaKind.Int, JavaKind.Long}) {
 637                 Class&lt;?&gt; type = kind.toJavaClass();
 638                 r.register1(&quot;decrementExact&quot;, type, new InvocationPlugin() {
 639                     @Override
 640                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x) {
 641                         ConstantNode y = b.add(ConstantNode.forIntegerKind(kind, 1));
 642                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_DECREMENT_EXACT);
 643                         return true;
 644                     }
 645                 });
 646 
 647                 r.register1(&quot;incrementExact&quot;, type, new InvocationPlugin() {
 648                     @Override
 649                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x) {
 650                         ConstantNode y = b.add(ConstantNode.forIntegerKind(kind, 1));
 651                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_INCREMENT_EXACT);
 652                         return true;
 653                     }
 654                 });
 655                 r.register2(&quot;addExact&quot;, type, type, new InvocationPlugin() {
 656                     @Override
 657                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
 658                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_ADD_EXACT);
 659                         return true;
 660                     }
 661                 });
 662                 r.register2(&quot;subtractExact&quot;, type, type, new InvocationPlugin() {
 663                     @Override
 664                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
 665                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_SUBTRACT_EXACT);
 666                         return true;
 667                     }
 668                 });
 669 
 670                 r.register2(&quot;multiplyExact&quot;, type, type, new InvocationPlugin() {
 671                     @Override
 672                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
 673                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_MULTIPLY_EXACT);
 674                         return true;
 675                     }
 676                 });
 677             }
 678         }
 679         r.register1(&quot;abs&quot;, Float.TYPE, new InvocationPlugin() {
 680 
 681             @Override
 682             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 683                 b.push(JavaKind.Float, b.append(new AbsNode(value).canonical(null)));
 684                 return true;
 685             }
 686         });
 687         r.register1(&quot;abs&quot;, Double.TYPE, new InvocationPlugin() {
 688             @Override
 689             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 690                 b.push(JavaKind.Double, b.append(new AbsNode(value).canonical(null)));
 691                 return true;
 692             }
 693         });
 694         r.register1(&quot;sqrt&quot;, Double.TYPE, new MathSqrtPlugin());
 695     }
 696 
 697     private static void registerStrictMathPlugins(InvocationPlugins plugins) {
 698         Registration r = new Registration(plugins, StrictMath.class);
 699         r.register1(&quot;sqrt&quot;, Double.TYPE, new MathSqrtPlugin());
 700     }
 701 
 702     public static final class StringIndexOfConstantPlugin implements InvocationPlugin {
 703         @Override
 704         public boolean inlineOnly() {
 705             return true;
 706         }
 707 
 708         @Override
 709         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode source, ValueNode sourceOffset, ValueNode sourceCount,
 710                         ValueNode target, ValueNode targetOffset, ValueNode targetCount, ValueNode origFromIndex) {
 711             if (target.isConstant()) {
 712                 b.addPush(JavaKind.Int, new StringIndexOfNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), source, sourceOffset, sourceCount,
 713                                 target, targetOffset, targetCount, origFromIndex));
 714                 return true;
 715             }
 716             return false;
 717         }
 718     }
 719 
 720     public static final class StringLatin1IndexOfConstantPlugin implements InvocationPlugin {
 721         @Override
 722         public boolean inlineOnly() {
 723             return true;
 724         }
 725 
 726         @Override
 727         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver,
 728                         ValueNode source, ValueNode sourceCount, ValueNode target, ValueNode targetCount, ValueNode origFromIndex) {
 729             if (target.isConstant()) {
 730                 b.addPush(JavaKind.Int, new StringLatin1IndexOfNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()),
 731                                 source, sourceCount, target, targetCount, origFromIndex));
 732                 return true;
 733             }
 734             return false;
 735         }
 736     }
 737 
 738     public static final class StringUTF16IndexOfConstantPlugin implements InvocationPlugin {
 739         @Override
 740         public boolean inlineOnly() {
 741             return true;
 742         }
 743 
 744         @Override
 745         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver,
 746                         ValueNode source, ValueNode sourceCount, ValueNode target, ValueNode targetCount, ValueNode origFromIndex) {
 747             if (target.isConstant()) {
 748                 b.addPush(JavaKind.Int, new StringUTF16IndexOfNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()),
 749                                 source, sourceCount, target, targetCount, origFromIndex));
 750                 return true;
 751             }
 752             return false;
 753         }
 754     }
 755 
 756     public static class UnsignedMathPlugin implements InvocationPlugin {
 757         private final Condition condition;
 758 
 759         public UnsignedMathPlugin(Condition condition) {
 760             this.condition = condition;
 761         }
 762 
 763         @Override
 764         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
 765             CanonicalizedCondition canonical = condition.canonicalize();
 766             StructuredGraph graph = b.getGraph();
 767 
 768             ValueNode lhs = canonical.mustMirror() ? y : x;
 769             ValueNode rhs = canonical.mustMirror() ? x : y;
 770 
 771             ValueNode trueValue = ConstantNode.forBoolean(!canonical.mustNegate(), graph);
 772             ValueNode falseValue = ConstantNode.forBoolean(canonical.mustNegate(), graph);
 773 
 774             LogicNode compare = CompareNode.createCompareNode(graph, b.getConstantReflection(), b.getMetaAccess(), b.getOptions(), null, canonical.getCanonicalCondition(), lhs, rhs, NodeView.DEFAULT);
 775             b.addPush(JavaKind.Boolean, new ConditionalNode(compare, trueValue, falseValue));
 776             return true;
 777         }
 778     }
 779 
 780     private static void registerUnsignedMathPlugins(InvocationPlugins plugins) {
 781         Registration r = new Registration(plugins, UnsignedMath.class);
 782         r.register2(&quot;aboveThan&quot;, int.class, int.class, new UnsignedMathPlugin(Condition.AT));
 783         r.register2(&quot;aboveThan&quot;, long.class, long.class, new UnsignedMathPlugin(Condition.AT));
 784         r.register2(&quot;belowThan&quot;, int.class, int.class, new UnsignedMathPlugin(Condition.BT));
 785         r.register2(&quot;belowThan&quot;, long.class, long.class, new UnsignedMathPlugin(Condition.BT));
 786         r.register2(&quot;aboveOrEqual&quot;, int.class, int.class, new UnsignedMathPlugin(Condition.AE));
 787         r.register2(&quot;aboveOrEqual&quot;, long.class, long.class, new UnsignedMathPlugin(Condition.AE));
 788         r.register2(&quot;belowOrEqual&quot;, int.class, int.class, new UnsignedMathPlugin(Condition.BE));
 789         r.register2(&quot;belowOrEqual&quot;, long.class, long.class, new UnsignedMathPlugin(Condition.BE));
 790     }
 791 
 792     protected static void registerBoxingPlugins(InvocationPlugins plugins) {
 793         for (JavaKind kind : JavaKind.values()) {
 794             if (kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) {
 795                 new BoxPlugin(kind).register(plugins);
 796                 new UnboxPlugin(kind).register(plugins);
 797             }
 798         }
 799     }
 800 
 801     private static void registerObjectPlugins(InvocationPlugins plugins) {
 802         Registration r = new Registration(plugins, Object.class);
 803         r.register1(&quot;&lt;init&gt;&quot;, Receiver.class, new InvocationPlugin() {
 804             @Override
 805             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 806                 /*
 807                  * Object.&lt;init&gt; is a common instrumentation point so only perform this rewrite if
 808                  * the current definition is the normal empty method with a single return bytecode.
 809                  * The finalizer registration will instead be performed by the BytecodeParser.
 810                  */
 811                 if (targetMethod.getCodeSize() == 1) {
 812                     ValueNode object = receiver.get();
 813                     if (RegisterFinalizerNode.mayHaveFinalizer(object, b.getAssumptions())) {
 814                         b.add(new RegisterFinalizerNode(object));
 815                     }
 816                     return true;
 817                 }
 818                 return false;
 819             }
 820         });
 821         r.register1(&quot;getClass&quot;, Receiver.class, new InvocationPlugin() {
 822             @Override
 823             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 824                 ValueNode object = receiver.get();
 825                 ValueNode folded = GetClassNode.tryFold(b.getMetaAccess(), b.getConstantReflection(), NodeView.DEFAULT, GraphUtil.originalValue(object));
 826                 if (folded != null) {
 827                     b.addPush(JavaKind.Object, folded);
 828                 } else {
 829                     Stamp stamp = StampFactory.objectNonNull(TypeReference.createTrusted(b.getAssumptions(), b.getMetaAccess().lookupJavaType(Class.class)));
 830                     b.addPush(JavaKind.Object, new GetClassNode(stamp, object));
 831                 }
 832                 return true;
 833             }
 834         });
 835     }
 836 
 837     private static void registerClassPlugins(InvocationPlugins plugins) {
 838         Registration r = new Registration(plugins, Class.class);
 839         r.register2(&quot;isInstance&quot;, Receiver.class, Object.class, new InvocationPlugin() {
 840             @Override
 841             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver type, ValueNode object) {
 842                 LogicNode condition = b.append(InstanceOfDynamicNode.create(b.getAssumptions(), b.getConstantReflection(), type.get(), object, false));
 843                 b.push(JavaKind.Boolean, b.append(new ConditionalNode(condition).canonical(null)));
 844                 return true;
 845             }
 846         });
 847         r.register2(&quot;isAssignableFrom&quot;, Receiver.class, Class.class, new InvocationPlugin() {
 848             @Override
 849             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver type, ValueNode otherType) {
 850                 ClassIsAssignableFromNode condition = b.append(new ClassIsAssignableFromNode(type.get(), otherType));
 851                 b.push(JavaKind.Boolean, b.append(new ConditionalNode(condition).canonical(null)));
 852                 return true;
 853             }
 854         });
 855 
 856         r.register2(&quot;cast&quot;, Receiver.class, Object.class, new InvocationPlugin() {
 857             @Override
 858             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
 859                 b.genCheckcastDynamic(object, receiver.get());
 860                 return true;
 861             }
 862 
 863             @Override
 864             public boolean inlineOnly() {
 865                 return true;
 866             }
 867         });
 868     }
 869 
 870     /**
 871      * Substitutions for improving the performance of some critical methods in {@link Edges}. These
 872      * substitutions improve the performance by forcing the relevant methods to be inlined
 873      * (intrinsification being a special form of inlining) and removing a checked cast.
 874      */
 875     private static void registerEdgesPlugins(MetaAccessProvider metaAccess, InvocationPlugins plugins) {
 876         Registration r = new Registration(plugins, Edges.class);
 877         for (Class&lt;?&gt; c : new Class&lt;?&gt;[]{Node.class, NodeList.class}) {
 878             r.register2(&quot;get&quot; + c.getSimpleName() + &quot;Unsafe&quot;, Node.class, long.class, new InvocationPlugin() {
 879                 @Override
 880                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode node, ValueNode offset) {
 881                     ObjectStamp stamp = StampFactory.object(TypeReference.createTrusted(b.getAssumptions(), metaAccess.lookupJavaType(c)));
 882                     RawLoadNode value = b.add(new RawLoadNode(stamp, node, offset, LocationIdentity.any(), JavaKind.Object));
 883                     b.addPush(JavaKind.Object, value);
 884                     return true;
 885                 }
 886             });
 887             r.register3(&quot;put&quot; + c.getSimpleName() + &quot;Unsafe&quot;, Node.class, long.class, c, new InvocationPlugin() {
 888                 @Override
 889                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode node, ValueNode offset, ValueNode value) {
 890                     b.add(new RawStoreNode(node, offset, value, JavaKind.Object, LocationIdentity.any()));
 891                     return true;
 892                 }
 893             });
 894         }
 895     }
 896 
 897     public static class BoxPlugin implements InvocationPlugin {
 898 
 899         private final JavaKind kind;
 900 
 901         BoxPlugin(JavaKind kind) {
 902             this.kind = kind;
 903         }
 904 
 905         @Override
 906         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 907             if (b.parsingIntrinsic()) {
 908                 ResolvedJavaMethod rootMethod = b.getGraph().method();
 909                 if (b.getMetaAccess().lookupJavaType(BoxingSnippets.class).isAssignableFrom(rootMethod.getDeclaringClass())) {
 910                     // Disable invocation plugins for boxing snippets so that the
 911                     // original JDK methods are inlined
 912                     return false;
 913                 }
 914             }
 915             ResolvedJavaType resultType = b.getMetaAccess().lookupJavaType(kind.toBoxedJavaClass());
 916             b.addPush(JavaKind.Object, new BoxNode(value, resultType, kind));
 917             return true;
 918         }
 919 
 920         void register(InvocationPlugins plugins) {
 921             plugins.register(this, kind.toBoxedJavaClass(), &quot;valueOf&quot;, kind.toJavaClass());
 922         }
 923     }
 924 
 925     public static class UnboxPlugin implements InvocationPlugin {
 926 
 927         private final JavaKind kind;
 928 
 929         UnboxPlugin(JavaKind kind) {
 930             this.kind = kind;
 931         }
 932 
 933         @Override
 934         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 935             if (b.parsingIntrinsic()) {
 936                 ResolvedJavaMethod rootMethod = b.getGraph().method();
 937                 if (b.getMetaAccess().lookupJavaType(BoxingSnippets.class).isAssignableFrom(rootMethod.getDeclaringClass())) {
 938                     // Disable invocation plugins for unboxing snippets so that the
 939                     // original JDK methods are inlined
 940                     return false;
 941                 }
 942             }
 943             ValueNode valueNode = UnboxNode.create(b.getMetaAccess(), b.getConstantReflection(), receiver.get(), kind);
 944             b.addPush(kind, valueNode);
 945             return true;
 946         }
 947 
 948         void register(InvocationPlugins plugins) {
 949             String name = kind.toJavaClass().getSimpleName() + &quot;Value&quot;;
 950             plugins.register(this, kind.toBoxedJavaClass(), name, Receiver.class);
 951         }
 952     }
 953 
 954     /**
 955      * The new memory order modes (JDK9+) are defined with cumulative effect, from weakest to
 956      * strongest: Plain, Opaque, Release/Acquire, and Volatile. The existing Plain and Volatile
 957      * modes are defined compatibly with their pre-JDK 9 forms. Any guaranteed property of a weaker
 958      * mode, plus more, holds for a stronger mode. (Conversely, implementations are allowed to use a
 959      * stronger mode than requested for any access.) In JDK 9, these are provided without a full
 960      * formal specification.
 961      */
 962     enum AccessKind {
 963         PLAIN(0, 0, 0, 0, false),
 964         /**
 965          * Opaque accesses are wrapped by dummy membars to avoid floating/hoisting, this is stronger
 966          * than required since Opaque mode does not directly impose any ordering constraints with
 967          * respect to other variables beyond Plain mode.
 968          */
 969         OPAQUE(0, 0, 0, 0, true),
 970         RELEASE_ACQUIRE(0, LOAD_LOAD | LOAD_STORE, LOAD_STORE | STORE_STORE, 0, true),
 971         VOLATILE(JMM_PRE_VOLATILE_READ, JMM_POST_VOLATILE_READ, JMM_PRE_VOLATILE_WRITE, JMM_POST_VOLATILE_WRITE, true);
 972 
 973         public final boolean emitBarriers;
 974         public final int preReadBarriers;
 975         public final int postReadBarriers;
 976         public final int preWriteBarriers;
 977         public final int postWriteBarriers;
 978 
 979         AccessKind(int preReadBarriers, int postReadBarriers, int preWriteBarriers, int postWriteBarriers, boolean emitBarriers) {
 980             this.emitBarriers = emitBarriers;
 981             this.preReadBarriers = preReadBarriers;
 982             this.postReadBarriers = postReadBarriers;
 983             this.preWriteBarriers = preWriteBarriers;
 984             this.postWriteBarriers = postWriteBarriers;
 985         }
 986     }
 987 
 988     /**
 989      * Unsafe access relative to null object is an access to off-heap memory. As linear pointer
 990      * compression uses non-zero null, here null object must be replaced with zero constant.
 991      */
 992     public abstract static class UnsafeAccessPlugin implements InvocationPlugin {
 993         @FunctionalInterface
 994         public interface UnsafeNodeConstructor {
 995             FixedWithNextNode create(ValueNode value, LocationIdentity location);
 996         }
 997 
 998         protected final JavaKind unsafeAccessKind;
 999         private final boolean explicitUnsafeNullChecks;
1000 
1001         public UnsafeAccessPlugin(JavaKind kind, boolean explicitUnsafeNullChecks) {
1002             unsafeAccessKind = kind;
1003             this.explicitUnsafeNullChecks = explicitUnsafeNullChecks;
1004         }
1005 
1006         private static FixedWithNextNode createObjectAccessNode(ValueNode value, UnsafeNodeConstructor nodeConstructor) {
1007             return nodeConstructor.create(value, LocationIdentity.ANY_LOCATION);
1008         }
1009 
1010         private static FixedWithNextNode createMemoryAccessNode(StructuredGraph graph, UnsafeNodeConstructor nodeConstructor) {
1011             return nodeConstructor.create(ConstantNode.forLong(0L, graph), OFF_HEAP_LOCATION);
1012         }
1013 
1014         private static boolean isLoad(ValueNode node) {
1015             return node.getStackKind() != JavaKind.Void;
1016         }
1017 
1018         private void setResult(ValueNode node, GraphBuilderContext b) {
1019             if (isLoad(node)) {
1020                 b.addPush(unsafeAccessKind, node);
1021             } else {
1022                 b.add(node);
1023             }
1024         }
1025 
1026         protected final void createUnsafeAccess(ValueNode value, GraphBuilderContext b, UnsafeNodeConstructor nodeConstructor) {
1027             StructuredGraph graph = b.getGraph();
1028             graph.markUnsafeAccess();
1029             /* For unsafe access object pointers can only be stored in the heap */
1030             if (unsafeAccessKind == JavaKind.Object) {
1031                 setResult(createObjectAccessNode(value, nodeConstructor), b);
1032             } else if (StampTool.isPointerAlwaysNull(value)) {
1033                 setResult(createMemoryAccessNode(graph, nodeConstructor), b);
1034             } else if (!explicitUnsafeNullChecks || StampTool.isPointerNonNull(value)) {
1035                 setResult(createObjectAccessNode(value, nodeConstructor), b);
1036             } else {
1037                 FixedWithNextNode objectAccess = graph.add(createObjectAccessNode(value, nodeConstructor));
1038                 FixedWithNextNode memoryAccess = graph.add(createMemoryAccessNode(graph, nodeConstructor));
1039                 FixedWithNextNode[] accessNodes = new FixedWithNextNode[]{objectAccess, memoryAccess};
1040 
1041                 LogicNode condition = graph.addOrUniqueWithInputs(IsNullNode.create(value));
1042                 b.add(new IfNode(condition, memoryAccess, objectAccess, 0.5));
1043 
1044                 MergeNode merge = b.append(new MergeNode());
1045                 for (FixedWithNextNode node : accessNodes) {
1046                     EndNode endNode = graph.add(new EndNode());
1047                     node.setNext(endNode);
1048                     if (node instanceof StateSplit) {
1049                         if (isLoad(node)) {
1050                             /*
1051                              * Temporarily push the access node so that the frame state has the node
1052                              * on the expression stack.
1053                              */
1054                             b.push(unsafeAccessKind, node);
1055                         }
1056                         b.setStateAfter((StateSplit) node);
1057                         if (isLoad(node)) {
1058                             ValueNode popped = b.pop(unsafeAccessKind);
1059                             assert popped == node;
1060                         }
1061                     }
1062                     merge.addForwardEnd(endNode);
1063                 }
1064 
1065                 if (isLoad(objectAccess)) {
1066                     ValuePhiNode phi = new ValuePhiNode(objectAccess.stamp(NodeView.DEFAULT), merge, accessNodes);
1067                     b.push(unsafeAccessKind, graph.addOrUnique(phi));
1068                 }
1069                 b.setStateAfter(merge);
1070             }
1071         }
1072     }
1073 
1074     public static class UnsafeGetPlugin extends UnsafeAccessPlugin {
1075         private final AccessKind accessKind;
1076 
1077         public UnsafeGetPlugin(JavaKind returnKind, boolean explicitUnsafeNullChecks) {
1078             this(returnKind, AccessKind.PLAIN, explicitUnsafeNullChecks);
1079         }
1080 
1081         public UnsafeGetPlugin(JavaKind kind, AccessKind accessKind, boolean explicitUnsafeNullChecks) {
1082             super(kind, explicitUnsafeNullChecks);
1083             this.accessKind = accessKind;
1084         }
1085 
1086         @Override
1087         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode address) {
1088             // Emits a null-check for the otherwise unused receiver
1089             unsafe.get();
1090             b.addPush(unsafeAccessKind, new UnsafeMemoryLoadNode(address, unsafeAccessKind, OFF_HEAP_LOCATION));
1091             b.getGraph().markUnsafeAccess();
1092             return true;
1093         }
1094 
1095         @Override
1096         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset) {
1097             // Emits a null-check for the otherwise unused receiver
1098             unsafe.get();
1099             if (accessKind.emitBarriers) {
1100                 b.add(new MembarNode(accessKind.preReadBarriers));
1101             }
1102             createUnsafeAccess(object, b, (obj, loc) -&gt; new RawLoadNode(obj, offset, unsafeAccessKind, loc));
1103             if (accessKind.emitBarriers) {
1104                 b.add(new MembarNode(accessKind.postReadBarriers));
1105             }
1106             return true;
1107         }
1108     }
1109 
1110     public static class UnsafePutPlugin extends UnsafeAccessPlugin {
1111         private final AccessKind accessKind;
1112 
1113         public UnsafePutPlugin(JavaKind kind, boolean explicitUnsafeNullChecks) {
1114             this(kind, AccessKind.PLAIN, explicitUnsafeNullChecks);
1115         }
1116 
1117         private UnsafePutPlugin(JavaKind kind, AccessKind accessKind, boolean explicitUnsafeNullChecks) {
1118             super(kind, explicitUnsafeNullChecks);
1119             this.accessKind = accessKind;
1120         }
1121 
1122         @Override
1123         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode address, ValueNode value) {
1124             assert !accessKind.emitBarriers : &quot;Barriers for address based Unsafe put is not supported.&quot;;
1125             // Emits a null-check for the otherwise unused receiver
1126             unsafe.get();
1127             b.add(new UnsafeMemoryStoreNode(address, value, unsafeAccessKind, OFF_HEAP_LOCATION));
1128             b.getGraph().markUnsafeAccess();
1129             return true;
1130         }
1131 
1132         @Override
1133         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode value) {
1134             // Emits a null-check for the otherwise unused receiver
1135             unsafe.get();
1136             if (accessKind.emitBarriers) {
1137                 b.add(new MembarNode(accessKind.preWriteBarriers));
1138             }
1139             ValueNode maskedValue = b.maskSubWordValue(value, unsafeAccessKind);
1140             createUnsafeAccess(object, b, (obj, loc) -&gt; new RawStoreNode(obj, offset, maskedValue, unsafeAccessKind, loc));
1141             if (accessKind.emitBarriers) {
1142                 b.add(new MembarNode(accessKind.postWriteBarriers));
1143             }
1144             return true;
1145         }
1146     }
1147 
1148     public static class UnsafeFencePlugin implements InvocationPlugin {
1149 
1150         private final int barriers;
1151 
1152         public UnsafeFencePlugin(int barriers) {
1153             this.barriers = barriers;
1154         }
1155 
1156         @Override
1157         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe) {
1158             // Emits a null-check for the otherwise unused receiver
1159             unsafe.get();
1160             b.add(new MembarNode(barriers));
1161             return true;
1162         }
1163     }
1164 
1165     private static final SpeculationReasonGroup DIRECTIVE_SPECULATIONS = new SpeculationReasonGroup(&quot;GraalDirective&quot;, BytecodePosition.class);
1166 
1167     private static void registerGraalDirectivesPlugins(InvocationPlugins plugins) {
1168         Registration r = new Registration(plugins, GraalDirectives.class);
1169         r.register0(&quot;deoptimize&quot;, new InvocationPlugin() {
1170             @Override
1171             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1172                 b.add(new DeoptimizeNode(DeoptimizationAction.None, DeoptimizationReason.TransferToInterpreter));
1173                 return true;
1174             }
1175         });
1176 
1177         r.register0(&quot;deoptimizeAndInvalidate&quot;, new InvocationPlugin() {
1178             @Override
1179             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1180                 b.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TransferToInterpreter));
1181                 return true;
1182             }
1183         });
1184 
1185         r.register0(&quot;deoptimizeAndInvalidateWithSpeculation&quot;, new InvocationPlugin() {
1186             @Override
1187             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1188                 GraalError.guarantee(b.getGraph().getSpeculationLog() != null, &quot;A speculation log is needed to use `deoptimizeAndInvalidateWithSpeculation`&quot;);
1189                 BytecodePosition pos = new BytecodePosition(null, b.getMethod(), b.bci());
1190                 SpeculationReason reason = DIRECTIVE_SPECULATIONS.createSpeculationReason(pos);
1191                 Speculation speculation;
1192                 if (b.getGraph().getSpeculationLog().maySpeculate(reason)) {
1193                     speculation = b.getGraph().getSpeculationLog().speculate(reason);
1194                 } else {
1195                     speculation = SpeculationLog.NO_SPECULATION;
1196                 }
1197                 b.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TransferToInterpreter, speculation));
1198                 return true;
1199             }
1200         });
1201 
1202         r.register0(&quot;inCompiledCode&quot;, new InvocationPlugin() {
1203             @Override
1204             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1205                 b.addPush(JavaKind.Boolean, ConstantNode.forBoolean(true));
1206                 return true;
1207             }
1208         });
1209 
1210         r.register0(&quot;controlFlowAnchor&quot;, new InvocationPlugin() {
1211             @Override
1212             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1213                 b.add(new ControlFlowAnchorNode());
1214                 return true;
1215             }
1216         });
1217 
1218         r.register2(&quot;injectBranchProbability&quot;, double.class, boolean.class, new InvocationPlugin() {
1219             @Override
1220             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode probability, ValueNode condition) {
1221                 b.addPush(JavaKind.Boolean, new BranchProbabilityNode(probability, condition));
1222                 return true;
1223             }
1224         });
1225 
1226         InvocationPlugin blackholePlugin = new InvocationPlugin() {
1227             @Override
1228             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1229                 b.add(new BlackholeNode(value));
1230                 return true;
1231             }
1232         };
1233 
1234         InvocationPlugin bindToRegisterPlugin = new InvocationPlugin() {
1235             @Override
1236             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1237                 b.add(new BindToRegisterNode(value));
1238                 return true;
1239             }
1240         };
1241         for (JavaKind kind : JavaKind.values()) {
1242             if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
1243                 Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
1244                 r.register1(&quot;blackhole&quot;, javaClass, blackholePlugin);
1245                 r.register1(&quot;bindToRegister&quot;, javaClass, bindToRegisterPlugin);
1246 
1247                 r.register1(&quot;opaque&quot;, javaClass, new InvocationPlugin() {
1248                     @Override
1249                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1250                         b.addPush(kind, new OpaqueNode(value));
1251                         return true;
1252                     }
1253                 });
1254             }
1255         }
1256 
1257         InvocationPlugin spillPlugin = new InvocationPlugin() {
1258             @Override
1259             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1260                 b.add(new SpillRegistersNode());
1261                 return true;
1262             }
1263         };
1264         r.register0(&quot;spillRegisters&quot;, spillPlugin);
1265 
1266         r.register1(&quot;guardingNonNull&quot;, Object.class, new InvocationPlugin() {
1267             @Override
1268             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1269                 b.addPush(value.getStackKind(), b.nullCheckedValue(value));
1270                 return true;
1271             }
1272         });
1273 
1274         r.register1(&quot;ensureVirtualized&quot;, Object.class, new InvocationPlugin() {
1275             @Override
1276             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1277                 b.add(new EnsureVirtualizedNode(object, false));
1278                 return true;
1279             }
1280         });
1281         r.register1(&quot;ensureVirtualizedHere&quot;, Object.class, new InvocationPlugin() {
1282             @Override
1283             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1284                 b.add(new EnsureVirtualizedNode(object, true));
1285                 return true;
1286             }
1287         });
1288     }
1289 
1290     private static void registerJMHBlackholePlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {
1291         InvocationPlugin blackholePlugin = new InvocationPlugin() {
1292             @Override
1293             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver blackhole, ValueNode value) {
1294                 blackhole.get();
1295                 b.add(new BlackholeNode(value));
1296                 return true;
1297             }
1298 
1299             @Override
1300             public boolean isDecorator() {
1301                 return true;
1302             }
1303         };
1304         String[] names = {&quot;org.openjdk.jmh.infra.Blackhole&quot;, &quot;org.openjdk.jmh.logic.BlackHole&quot;};
1305         for (String name : names) {
1306             Registration r = new Registration(plugins, name, bytecodeProvider);
1307             for (JavaKind kind : JavaKind.values()) {
1308                 if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
1309                     Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
1310                     r.registerOptional2(&quot;consume&quot;, Receiver.class, javaClass, blackholePlugin);
1311                 }
1312             }
1313             r.registerOptional2(&quot;consume&quot;, Receiver.class, Object[].class, blackholePlugin);
1314         }
1315     }
1316 
1317     private static void registerJFRThrowablePlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {
1318         Registration r = new Registration(plugins, &quot;oracle.jrockit.jfr.jdkevents.ThrowableTracer&quot;, bytecodeProvider);
1319         r.register2(&quot;traceThrowable&quot;, Throwable.class, String.class, new InvocationPlugin() {
1320             @Override
1321             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode throwable, ValueNode message) {
1322                 b.add(new VirtualizableInvokeMacroNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), throwable, message));
1323                 return true;
1324             }
1325 
1326             @Override
1327             public boolean inlineOnly() {
1328                 return true;
1329             }
1330         });
1331     }
1332 
1333     private static void registerMethodHandleImplPlugins(InvocationPlugins plugins, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider) {
1334         Registration r = new Registration(plugins, &quot;java.lang.invoke.MethodHandleImpl&quot;, bytecodeProvider);
1335         // In later JDKs this no longer exists and the usage is replace by Class.cast which is
1336         // already an intrinsic
1337         r.registerOptional2(&quot;castReference&quot;, Class.class, Object.class, new InvocationPlugin() {
1338             @Override
1339             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode javaClass, ValueNode object) {
1340                 b.genCheckcastDynamic(object, javaClass);
1341                 return true;
1342             }
1343 
1344             @Override
1345             public boolean inlineOnly() {
1346                 return true;
1347             }
1348         });
1349         r.register2(&quot;profileBoolean&quot;, boolean.class, int[].class, new InvocationPlugin() {
1350             @Override
1351             public boolean inlineOnly() {
1352                 return true;
1353             }
1354 
1355             @Override
1356             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode result, ValueNode counters) {
1357                 if (result.isConstant()) {
1358                     b.push(JavaKind.Boolean, result);
1359                     return true;
1360                 }
1361                 if (counters.isConstant()) {
1362                     ValueNode newResult = result;
1363                     int[] ctrs = snippetReflection.asObject(int[].class, (JavaConstant) counters.asConstant());
1364                     if (ctrs != null &amp;&amp; ctrs.length == 2) {
1365                         int falseCount = ctrs[0];
1366                         int trueCount = ctrs[1];
1367                         int totalCount = trueCount + falseCount;
1368 
1369                         if (totalCount == 0) {
1370                             b.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TransferToInterpreter));
1371                         } else if (falseCount == 0 || trueCount == 0) {
1372                             boolean expected = falseCount == 0;
1373                             LogicNode condition = b.add(
1374                                             IntegerEqualsNode.create(b.getConstantReflection(), b.getMetaAccess(), b.getOptions(), null, result, b.add(ConstantNode.forBoolean(!expected)),
1375                                                             NodeView.DEFAULT));
1376                             b.append(new FixedGuardNode(condition, DeoptimizationReason.UnreachedCode, DeoptimizationAction.InvalidateReprofile, true));
1377                             newResult = b.add(ConstantNode.forBoolean(expected));
1378                         } else {
1379                             // We cannot use BranchProbabilityNode here since there&#39;s no guarantee
1380                             // the result of MethodHandleImpl.profileBoolean() is used as the
1381                             // test in an `if` statement (as required by BranchProbabilityNode).
1382                         }
1383                     }
1384                     b.addPush(JavaKind.Boolean, newResult);
1385                     return true;
1386                 }
1387                 b.addPush(JavaKind.Boolean,
1388                                 new ProfileBooleanNode(snippetReflection, b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), result, counters));
1389                 return true;
1390             }
1391         });
1392     }
1393 
1394     /**
1395      * Registers a plugin to ignore {@code com.sun.tdk.jcov.runtime.Collect.hit} within an
1396      * intrinsic.
1397      */
1398     private static void registerJcovCollectPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {
1399         Registration r = new Registration(plugins, &quot;com.sun.tdk.jcov.runtime.Collect&quot;, bytecodeProvider);
1400         r.register1(&quot;hit&quot;, int.class, new InvocationPlugin() {
1401             @Override
1402             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1403                 if (b.parsingIntrinsic()) {
1404                     return true;
1405                 }
1406                 return false;
1407             }
1408         });
1409     }
1410 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/classfile/ClassfileBytecodeProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.classfile;
 26 
 27 import java.io.DataInputStream;
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 
 31 import jdk.internal.vm.compiler.collections.EconomicMap;
 32 import jdk.internal.vm.compiler.collections.Equivalence;
 33 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 34 import org.graalvm.compiler.bytecode.Bytecode;
 35 import org.graalvm.compiler.bytecode.BytecodeProvider;
 36 import org.graalvm.compiler.serviceprovider.GraalServices;
 37 
 38 import jdk.vm.ci.meta.JavaKind;
 39 import jdk.vm.ci.meta.MetaAccessProvider;
 40 import jdk.vm.ci.meta.ResolvedJavaField;
 41 import jdk.vm.ci.meta.ResolvedJavaMethod;
 42 import jdk.vm.ci.meta.ResolvedJavaType;
 43 
 44 /**
 45  * A {@link BytecodeProvider} that provides bytecode properties of a {@link ResolvedJavaMethod} as
 46  * parsed from a class file. This avoids all {@linkplain java.lang.instrument.Instrumentation
 47  * instrumentation} and any bytecode rewriting performed by the VM.
 48  *
 49  * This mechanism retrieves class files based on the name and {@link ClassLoader} of existing
 50  * {@link Class} instances. It bypasses all VM parsing and verification of the class file and
 51  * assumes the class files are well formed. As such, it should only be used for classes from a
 52  * trusted source such as the boot class (or module) path.
 53  *
 54  * A combination of {@link Class#forName(String)} and an existing {@link MetaAccessProvider} is used
 55  * to resolve constant pool references. This opens up the opportunity for linkage errors if the
 56  * referee is structurally changed through redefinition (e.g., a referred to method is renamed or
 57  * deleted). This will result in an appropriate {@link LinkageError} being thrown. The only way to
 58  * avoid this is to have a completely isolated {@code jdk.vm.ci.meta} implementation for parsing
 59  * snippet/intrinsic bytecodes.
 60  */
 61 public final class ClassfileBytecodeProvider implements BytecodeProvider {
 62 
 63     private final ClassLoader loader;
 64     private final EconomicMap&lt;Class&lt;?&gt;, Classfile&gt; classfiles = EconomicMap.create(Equivalence.IDENTITY);
 65     private final EconomicMap&lt;String, Class&lt;?&gt;&gt; classes = EconomicMap.create();
 66     private final EconomicMap&lt;ResolvedJavaType, FieldsCache&gt; fields = EconomicMap.create();
 67     private final EconomicMap&lt;ResolvedJavaType, MethodsCache&gt; methods = EconomicMap.create();
 68     final MetaAccessProvider metaAccess;
 69     final SnippetReflectionProvider snippetReflection;
 70 
 71     public ClassfileBytecodeProvider(MetaAccessProvider metaAccess, SnippetReflectionProvider snippetReflection) {
 72         this.metaAccess = metaAccess;
 73         this.snippetReflection = snippetReflection;
 74         ClassLoader cl = getClass().getClassLoader();
 75         this.loader = cl == null ? ClassLoader.getSystemClassLoader() : cl;
 76     }
 77 
 78     public ClassfileBytecodeProvider(MetaAccessProvider metaAccess, SnippetReflectionProvider snippetReflection, ClassLoader loader) {
 79         this.metaAccess = metaAccess;
 80         this.snippetReflection = snippetReflection;
 81         this.loader = loader;
 82     }
 83 
 84     @Override
 85     public Bytecode getBytecode(ResolvedJavaMethod method) {
 86         Classfile classfile = getClassfile(resolveToClass(method.getDeclaringClass().getName()));
 87         return classfile.getCode(method.getName(), method.getSignature().toMethodDescriptor());
 88     }
 89 
 90     @Override
 91     public boolean supportsInvokedynamic() {
 92         return false;
 93     }
 94 
 95     @Override
 96     public boolean shouldRecordMethodDependencies() {
 97         return false;
 98     }
 99 
100     /**
101      * Gets a {@link Classfile} created by parsing the class file bytes for {@code c}.
102      *
103      * @throws NoClassDefFoundError if the class file cannot be found
104      */
105     private synchronized Classfile getClassfile(Class&lt;?&gt; c) {
106         assert !c.isPrimitive() &amp;&amp; !c.isArray() : c;
107         Classfile classfile = classfiles.get(c);
108         if (classfile == null) {
109             try {
110                 ResolvedJavaType type = metaAccess.lookupJavaType(c);
<a name="2" id="anc2"></a><span class="line-modified">111                 InputStream in = GraalServices.getClassfileAsStream(c);</span>
<span class="line-modified">112                 if (in != null) {</span>
<span class="line-modified">113                     DataInputStream stream = new DataInputStream(in);</span>
<span class="line-modified">114                     classfile = new Classfile(type, stream, this);</span>
<span class="line-modified">115                     classfiles.put(c, classfile);</span>
<span class="line-modified">116                     return classfile;</span>

117                 }
118                 throw new NoClassDefFoundError(c.getName());
119             } catch (IOException e) {
120                 throw (NoClassDefFoundError) new NoClassDefFoundError(c.getName()).initCause(e);
121             }
122         }
123         return classfile;
124     }
125 
126     synchronized Class&lt;?&gt; resolveToClass(String descriptor) {
127         Class&lt;?&gt; c = classes.get(descriptor);
128         if (c == null) {
129             if (descriptor.length() == 1) {
130                 c = JavaKind.fromPrimitiveOrVoidTypeChar(descriptor.charAt(0)).toJavaClass();
131             } else {
132                 int dimensions = 0;
133                 while (descriptor.charAt(dimensions) == &#39;[&#39;) {
134                     dimensions++;
135                 }
136                 String name;
137                 if (dimensions == 0 &amp;&amp; descriptor.startsWith(&quot;L&quot;) &amp;&amp; descriptor.endsWith(&quot;;&quot;)) {
138                     name = descriptor.substring(1, descriptor.length() - 1).replace(&#39;/&#39;, &#39;.&#39;);
139                 } else {
140                     name = descriptor.replace(&#39;/&#39;, &#39;.&#39;);
141                 }
142                 try {
143                     c = Class.forName(name, true, loader);
144                     classes.put(descriptor, c);
145                 } catch (ClassNotFoundException e) {
146                     throw new NoClassDefFoundError(descriptor);
147                 }
148             }
149         }
150         return c;
151     }
152 
153     /**
154      * Name and type of a field.
155      */
156     static final class FieldKey {
157         final String name;
158         final String type;
159 
160         FieldKey(String name, String type) {
161             this.name = name;
162             this.type = type;
163         }
164 
165         @Override
166         public String toString() {
167             return name + &quot;:&quot; + type;
168         }
169 
170         @Override
171         public boolean equals(Object obj) {
172             if (obj instanceof FieldKey) {
173                 FieldKey that = (FieldKey) obj;
174                 return that.name.equals(this.name) &amp;&amp; that.type.equals(this.type);
175             }
176             return false;
177         }
178 
179         @Override
180         public int hashCode() {
181             return name.hashCode() ^ type.hashCode();
182         }
183     }
184 
185     /**
186      * Name and descriptor of a method.
187      */
188     static final class MethodKey {
189         final String name;
190         final String descriptor;
191 
192         MethodKey(String name, String descriptor) {
193             this.name = name;
194             this.descriptor = descriptor;
195         }
196 
197         @Override
198         public String toString() {
199             return name + &quot;:&quot; + descriptor;
200         }
201 
202         @Override
203         public boolean equals(Object obj) {
204             if (obj instanceof MethodKey) {
205                 MethodKey that = (MethodKey) obj;
206                 return that.name.equals(this.name) &amp;&amp; that.descriptor.equals(this.descriptor);
207             }
208             return false;
209         }
210 
211         @Override
212         public int hashCode() {
213             return name.hashCode() ^ descriptor.hashCode();
214         }
215     }
216 
217     /**
218      * Method cache for a {@link ResolvedJavaType}.
219      */
220     static final class MethodsCache {
221 
222         volatile EconomicMap&lt;MethodKey, ResolvedJavaMethod&gt; constructors;
223         volatile EconomicMap&lt;MethodKey, ResolvedJavaMethod&gt; methods;
224 
225         ResolvedJavaMethod lookup(ResolvedJavaType type, String name, String descriptor) {
226             MethodKey key = new MethodKey(name, descriptor);
227 
228             if (name.equals(&quot;&lt;clinit&gt;&quot;)) {
229                 // No need to cache &lt;clinit&gt; as it will be looked up at most once
230                 return type.getClassInitializer();
231             }
232             if (!name.equals(&quot;&lt;init&gt;&quot;)) {
233                 if (methods == null) {
234                     // Racy initialization is safe since `methods` is volatile
235                     methods = createMethodMap(type.getDeclaredMethods());
236                 }
237 
238                 return methods.get(key);
239             } else {
240                 if (constructors == null) {
241                     // Racy initialization is safe since instanceFields is volatile
242                     constructors = createMethodMap(type.getDeclaredConstructors());
243                 }
244                 return constructors.get(key);
245             }
246         }
247 
248         private static EconomicMap&lt;MethodKey, ResolvedJavaMethod&gt; createMethodMap(ResolvedJavaMethod[] methodArray) {
249             EconomicMap&lt;MethodKey, ResolvedJavaMethod&gt; map = EconomicMap.create();
250             for (ResolvedJavaMethod m : methodArray) {
251                 map.put(new MethodKey(m.getName(), m.getSignature().toMethodDescriptor()), m);
252             }
253             return map;
254         }
255     }
256 
257     /**
258      * Field cache for a {@link ResolvedJavaType}.
259      */
260     static final class FieldsCache {
261 
262         volatile EconomicMap&lt;FieldKey, ResolvedJavaField&gt; instanceFields;
263         volatile EconomicMap&lt;FieldKey, ResolvedJavaField&gt; staticFields;
264 
265         ResolvedJavaField lookup(ResolvedJavaType type, String name, String fieldType, boolean isStatic) {
266             FieldKey key = new FieldKey(name, fieldType);
267             if (isStatic) {
268                 if (staticFields == null) {
269                     // Racy initialization is safe since staticFields is volatile
270                     staticFields = createFieldMap(type.getStaticFields());
271                 }
272                 return staticFields.get(key);
273             } else {
274                 if (instanceFields == null) {
275                     // Racy initialization is safe since instanceFields is volatile
276                     instanceFields = createFieldMap(type.getInstanceFields(false));
277                 }
278                 return instanceFields.get(key);
279             }
280         }
281 
282         private static EconomicMap&lt;FieldKey, ResolvedJavaField&gt; createFieldMap(ResolvedJavaField[] fieldArray) {
283             EconomicMap&lt;FieldKey, ResolvedJavaField&gt; map = EconomicMap.create();
284             for (ResolvedJavaField f : fieldArray) {
285                 map.put(new FieldKey(f.getName(), f.getType().getName()), f);
286             }
287             return map;
288         }
289     }
290 
291     /**
292      * Gets the methods cache for {@code type}.
293      *
294      * Synchronized since the cache is lazily created.
295      */
296     private synchronized MethodsCache getMethods(ResolvedJavaType type) {
297         MethodsCache methodsCache = methods.get(type);
298         if (methodsCache == null) {
299             methodsCache = new MethodsCache();
300             methods.put(type, methodsCache);
301         }
302         return methodsCache;
303     }
304 
305     /**
306      * Gets the fields cache for {@code type}.
307      *
308      * Synchronized since the cache is lazily created.
309      */
310     private synchronized FieldsCache getFields(ResolvedJavaType type) {
311         FieldsCache fieldsCache = fields.get(type);
312         if (fieldsCache == null) {
313             fieldsCache = new FieldsCache();
314             fields.put(type, fieldsCache);
315         }
316         return fieldsCache;
317     }
318 
319     ResolvedJavaField findField(ResolvedJavaType type, String name, String fieldType, boolean isStatic) {
320         return getFields(type).lookup(type, name, fieldType, isStatic);
321     }
322 
323     ResolvedJavaMethod findMethod(ResolvedJavaType type, String name, String descriptor, boolean isStatic) {
324         ResolvedJavaMethod method = getMethods(type).lookup(type, name, descriptor);
325         if (method != null &amp;&amp; method.isStatic() == isStatic) {
326             return method;
327         }
328         return null;
329     }
330 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
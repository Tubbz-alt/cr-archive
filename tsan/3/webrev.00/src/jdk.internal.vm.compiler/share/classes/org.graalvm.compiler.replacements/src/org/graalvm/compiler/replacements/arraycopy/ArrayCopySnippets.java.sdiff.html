<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/arraycopy/ArrayCopySnippets.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayCopyNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CheckcastArrayCopyCallNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/arraycopy/ArrayCopySnippets.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.arraycopy;
 26 
 27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;

 28 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FREQUENT_PROBABILITY;
 29 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LIKELY_PROBABILITY;
 30 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.NOT_FREQUENT_PROBABILITY;
 31 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.SLOW_PATH_PROBABILITY;

 32 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.probability;
 33 
 34 import java.util.EnumMap;
 35 
 36 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
 37 import org.graalvm.compiler.api.directives.GraalDirectives;
 38 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
 39 import org.graalvm.compiler.api.replacements.Snippet;
 40 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
 41 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 42 import org.graalvm.compiler.debug.DebugHandlersFactory;
 43 import org.graalvm.compiler.debug.GraalError;
 44 import org.graalvm.compiler.graph.Node;
 45 import org.graalvm.compiler.nodes.CallTargetNode;
 46 import org.graalvm.compiler.nodes.DeoptimizeNode;
 47 import org.graalvm.compiler.nodes.InvokeNode;
 48 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 49 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 50 import org.graalvm.compiler.nodes.NodeView;
 51 import org.graalvm.compiler.nodes.PiNode;

 52 import org.graalvm.compiler.nodes.StructuredGraph;
<span class="line-modified"> 53 import org.graalvm.compiler.nodes.ValueNode;</span>
<span class="line-modified"> 54 import org.graalvm.compiler.nodes.extended.RawLoadNode;</span>
 55 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 56 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 57 import org.graalvm.compiler.nodes.spi.LoweringTool;
 58 import org.graalvm.compiler.nodes.type.StampTool;
 59 import org.graalvm.compiler.nodes.util.GraphUtil;
 60 import org.graalvm.compiler.options.OptionValues;
 61 import org.graalvm.compiler.phases.util.Providers;
 62 import org.graalvm.compiler.replacements.ReplacementsUtil;
 63 import org.graalvm.compiler.replacements.SnippetCounter;
 64 import org.graalvm.compiler.replacements.SnippetCounter.Group;
 65 import org.graalvm.compiler.replacements.SnippetCounter.Group.Factory;
 66 import org.graalvm.compiler.replacements.SnippetIntegerHistogram;
 67 import org.graalvm.compiler.replacements.SnippetTemplate;
 68 import org.graalvm.compiler.replacements.SnippetTemplate.Arguments;
 69 import org.graalvm.compiler.replacements.SnippetTemplate.SnippetInfo;
 70 import org.graalvm.compiler.replacements.Snippets;
 71 import org.graalvm.compiler.replacements.nodes.BasicArrayCopyNode;
<span class="line-removed"> 72 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;</span>
 73 import org.graalvm.compiler.word.Word;
 74 import jdk.internal.vm.compiler.word.LocationIdentity;
 75 import jdk.internal.vm.compiler.word.Pointer;
 76 
 77 import jdk.vm.ci.code.TargetDescription;
 78 import jdk.vm.ci.meta.DeoptimizationAction;
 79 import jdk.vm.ci.meta.DeoptimizationReason;
 80 import jdk.vm.ci.meta.JavaKind;
 81 import jdk.vm.ci.meta.MetaAccessProvider;
 82 import jdk.vm.ci.meta.ResolvedJavaMethod;
 83 import jdk.vm.ci.meta.ResolvedJavaType;
 84 
 85 public abstract class ArrayCopySnippets implements Snippets {
 86 
 87     private enum ArrayCopyTypeCheck {
 88         UNDEFINED_ARRAY_TYPE_CHECK,
 89         // either we know that both objects are arrays and have the same type,
 90         // or we apply generic array copy snippet, which enforces type check
 91         NO_ARRAY_TYPE_CHECK,
 92         // can be used when we know that one of the objects is a primitive array
 93         HUB_BASED_ARRAY_TYPE_CHECK,
 94         // can be used when we know that one of the objects is an object array
 95         LAYOUT_HELPER_BASED_ARRAY_TYPE_CHECK
 96     }
 97 
 98     /** Marker value for the {@link InjectedParameter} injected parameter. */
 99     static final MetaAccessProvider INJECTED_META_ACCESS = null;
100 
101     public abstract Pointer loadHub(Object nonNullSrc);
102 
103     public abstract Pointer getDestElemClass(Pointer destKlass);
104 
105     public abstract Word getSuperCheckOffset(Pointer destElemKlass);
106 
107     public abstract int getReadLayoutHelper(Pointer srcHub);
108 
109     protected abstract int heapWordSize();
110 
<span class="line-modified">111     @Snippet</span>
<span class="line-removed">112     public void arraycopyZeroLengthSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck,</span>
<span class="line-removed">113                     @ConstantParameter Counters counters) {</span>
<span class="line-removed">114         Object nonNullSrc = GraalDirectives.guardingNonNull(src);</span>
<span class="line-removed">115         Object nonNullDest = GraalDirectives.guardingNonNull(dest);</span>
<span class="line-removed">116         this.checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);</span>
<span class="line-removed">117         checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);</span>
<span class="line-removed">118         counters.zeroLengthStaticCounter.inc();</span>
<span class="line-removed">119     }</span>
<span class="line-removed">120 </span>
121     @Snippet
122     public void arraycopyExactSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck,
<span class="line-modified">123                     @ConstantParameter JavaKind elementKind, @ConstantParameter LocationIdentity locationIdentity,</span>
124                     @ConstantParameter SnippetCounter elementKindCounter, @ConstantParameter SnippetCounter elementKindCopiedCounter, @ConstantParameter Counters counters) {
125         Object nonNullSrc = GraalDirectives.guardingNonNull(src);
126         Object nonNullDest = GraalDirectives.guardingNonNull(dest);
127         checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);
128         checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);
129         incrementLengthCounter(length, counters);
130 
131         elementKindCounter.inc();
132         elementKindCopiedCounter.add(length);
<span class="line-modified">133         ArrayCopyCallNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, elementKind, locationIdentity, heapWordSize());</span>

134     }
135 

136     @Snippet
<span class="line-modified">137     public void arraycopyUnrolledSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck,</span>
<span class="line-modified">138                     @ConstantParameter JavaKind elementKind, @ConstantParameter LocationIdentity locationIdentity, @ConstantParameter int unrolledLength, @ConstantParameter Counters counters) {</span>

139         Object nonNullSrc = GraalDirectives.guardingNonNull(src);
140         Object nonNullDest = GraalDirectives.guardingNonNull(dest);
141         checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);
142         checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);
143         incrementLengthCounter(length, counters);
144 
<span class="line-modified">145         unrolledArraycopyWork(nonNullSrc, srcPos, nonNullDest, destPos, unrolledLength, elementKind, locationIdentity);</span>



146     }
147 
148     @Snippet
<span class="line-modified">149     public void arraycopyCheckcastSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck,</span>
<span class="line-modified">150                     @ConstantParameter Counters counters, @ConstantParameter SnippetInfo workSnippet, @ConstantParameter JavaKind elementKind) {</span>
151         Object nonNullSrc = GraalDirectives.guardingNonNull(src);
152         Object nonNullDest = GraalDirectives.guardingNonNull(dest);
153         checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);
154         checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);
155         incrementLengthCounter(length, counters);
156 
<span class="line-modified">157         ArrayCopyWithSlowPathNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, workSnippet, elementKind);</span>
158     }
159 
160     @Snippet
161     public void arraycopyGenericSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck, @ConstantParameter Counters counters,
162                     @ConstantParameter SnippetInfo workSnippet, @ConstantParameter JavaKind elementKind) {
163         Object nonNullSrc = GraalDirectives.guardingNonNull(src);
164         Object nonNullDest = GraalDirectives.guardingNonNull(dest);
165         checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);
166         checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);
167         incrementLengthCounter(length, counters);
168 
<span class="line-modified">169         ArrayCopyWithSlowPathNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, workSnippet, elementKind);</span>
170     }
171 
172     @Snippet
173     public static void arraycopyNativeSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter Counters counters) {
174         // all checks are done in the native method, so no need to emit additional checks here
175         incrementLengthCounter(length, counters);
176         counters.systemArraycopyCounter.inc();
177         counters.systemArraycopyCopiedCounter.add(length);
178 
179         System.arraycopy(src, srcPos, dest, destPos, length);
180     }
181 
<span class="line-modified">182     private static void unrolledArraycopyWork(Object nonNullSrc, int srcPos, Object nonNullDest, int destPos, int length, JavaKind elementKind, LocationIdentity arrayLocation) {</span>



183         int scale = ReplacementsUtil.arrayIndexScale(INJECTED_META_ACCESS, elementKind);
184         int arrayBaseOffset = ReplacementsUtil.getArrayBaseOffset(INJECTED_META_ACCESS, elementKind);
<span class="line-removed">185 </span>
186         long sourceOffset = arrayBaseOffset + (long) srcPos * scale;
187         long destOffset = arrayBaseOffset + (long) destPos * scale;
<span class="line-removed">188         long position = 0;</span>
<span class="line-removed">189         long delta = scale;</span>
<span class="line-removed">190         if (probability(NOT_FREQUENT_PROBABILITY, nonNullSrc == nonNullDest &amp;&amp; srcPos &lt; destPos)) {</span>
<span class="line-removed">191             // bad aliased case so we need to copy the array from back to front</span>
<span class="line-removed">192             position = (long) (length - 1) * scale;</span>
<span class="line-removed">193             delta = -delta;</span>
<span class="line-removed">194         }</span>
195 
<span class="line-modified">196         // the length was already checked before - we can emit unconditional instructions</span>
<span class="line-modified">197         ExplodeLoopNode.explodeLoop();</span>
<span class="line-modified">198         for (int iteration = 0; iteration &lt; length; iteration++) {</span>
<span class="line-modified">199             Object value = RawLoadNode.load(nonNullSrc, sourceOffset + position, elementKind, arrayLocation);</span>
<span class="line-modified">200             RawStoreNode.storeObject(nonNullDest, destOffset + position, value, elementKind, arrayLocation, false);</span>
<span class="line-modified">201             position += delta;</span>






202         }
203     }
204 

205     @Snippet(allowPartialIntrinsicArgumentMismatch = true)
<span class="line-modified">206     public void checkcastArraycopyWithSlowPathWork(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter Counters counters) {</span>


207         if (probability(FREQUENT_PROBABILITY, length &gt; 0)) {
208             Object nonNullSrc = PiNode.asNonNullObject(src);
209             Object nonNullDest = PiNode.asNonNullObject(dest);
210             Pointer srcKlass = loadHub(nonNullSrc);
211             Pointer destKlass = loadHub(nonNullDest);
<span class="line-modified">212             if (probability(LIKELY_PROBABILITY, srcKlass == destKlass)) {</span>
213                 // no storecheck required.
214                 counters.objectCheckcastSameTypeCounter.inc();
215                 counters.objectCheckcastSameTypeCopiedCounter.add(length);
216                 ArrayCopyCallNode.arraycopyObjectKillsAny(nonNullSrc, srcPos, nonNullDest, destPos, length, heapWordSize());
217             } else {
218                 Pointer destElemKlass = getDestElemClass(destKlass);
219                 Word superCheckOffset = getSuperCheckOffset(destElemKlass);
220 
221                 counters.objectCheckcastDifferentTypeCounter.inc();
222                 counters.objectCheckcastDifferentTypeCopiedCounter.add(length);
223 
<span class="line-modified">224                 int copiedElements = CheckcastArrayCopyCallNode.checkcastArraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, superCheckOffset, destElemKlass, false);</span>
<span class="line-removed">225                 if (probability(SLOW_PATH_PROBABILITY, copiedElements != 0)) {</span>
<span class="line-removed">226                     /*</span>
<span class="line-removed">227                      * the stub doesn&#39;t throw the ArrayStoreException, but returns the number of</span>
<span class="line-removed">228                      * copied elements (xor&#39;d with -1).</span>
<span class="line-removed">229                      */</span>
<span class="line-removed">230                     copiedElements ^= -1;</span>
<span class="line-removed">231                     System.arraycopy(nonNullSrc, srcPos + copiedElements, nonNullDest, destPos + copiedElements, length - copiedElements);</span>
<span class="line-removed">232                 }</span>
233             }
234         }
235     }
236 

237     @Snippet(allowPartialIntrinsicArgumentMismatch = true)
<span class="line-modified">238     public void genericArraycopyWithSlowPathWork(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter Counters counters) {</span>


239         // The length &gt; 0 check should not be placed here because generic array copy stub should
240         // enforce type check. This is fine performance-wise because this snippet is rarely used.
241         counters.genericArraycopyDifferentTypeCounter.inc();
242         counters.genericArraycopyDifferentTypeCopiedCounter.add(length);
243         int copiedElements = GenericArrayCopyCallNode.genericArraycopy(src, srcPos, dest, destPos, length);
244         if (probability(SLOW_PATH_PROBABILITY, copiedElements != 0)) {
245             /*
246              * the stub doesn&#39;t throw the ArrayStoreException, but returns the number of copied
247              * elements (xor&#39;d with -1).
248              */
249             copiedElements ^= -1;
250             System.arraycopy(src, srcPos + copiedElements, dest, destPos + copiedElements, length - copiedElements);
251         }
252     }
253 
254     private static void incrementLengthCounter(int length, Counters counters) {
255         if (!IS_BUILDING_NATIVE_IMAGE) {
256             counters.lengthHistogram.inc(length);
257         }
258     }
259 



260     private static void checkLimits(Object src, int srcPos, Object dest, int destPos, int length, Counters counters) {
<span class="line-modified">261         if (probability(SLOW_PATH_PROBABILITY, srcPos &lt; 0) ||</span>
<span class="line-modified">262                         probability(SLOW_PATH_PROBABILITY, destPos &lt; 0) ||</span>
<span class="line-modified">263                         probability(SLOW_PATH_PROBABILITY, length &lt; 0) ||</span>
<span class="line-modified">264                         probability(SLOW_PATH_PROBABILITY, srcPos &gt; ArrayLengthNode.arrayLength(src) - length) ||</span>
<span class="line-modified">265                         probability(SLOW_PATH_PROBABILITY, destPos &gt; ArrayLengthNode.arrayLength(dest) - length)) {</span>












266             counters.checkAIOOBECounter.inc();
267             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);
268         }
269         counters.checkSuccessCounter.inc();
270     }
271 
272     private void checkArrayTypes(Object nonNullSrc, Object nonNullDest, ArrayCopyTypeCheck arrayTypeCheck) {
273         if (arrayTypeCheck == ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK) {
274             // nothing to do
275         } else if (arrayTypeCheck == ArrayCopyTypeCheck.HUB_BASED_ARRAY_TYPE_CHECK) {
276             Pointer srcHub = loadHub(nonNullSrc);
277             Pointer destHub = loadHub(nonNullDest);
<span class="line-modified">278             if (probability(SLOW_PATH_PROBABILITY, srcHub != destHub)) {</span>
279                 DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);
280             }
281         } else if (arrayTypeCheck == ArrayCopyTypeCheck.LAYOUT_HELPER_BASED_ARRAY_TYPE_CHECK) {
282             Pointer srcHub = loadHub(nonNullSrc);
283             Pointer destHub = loadHub(nonNullDest);
<span class="line-modified">284             if (probability(SLOW_PATH_PROBABILITY, getReadLayoutHelper(srcHub) != getReadLayoutHelper(destHub))) {</span>
285                 DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);
286             }
287         } else {
288             ReplacementsUtil.staticAssert(false, &quot;unknown array type check &quot;, arrayTypeCheck);
289         }
290     }
291 
292     static class Counters {
293         final SnippetCounter checkSuccessCounter;
294         final SnippetCounter checkAIOOBECounter;
295 
296         final SnippetCounter zeroLengthStaticCounter;
297         final SnippetIntegerHistogram lengthHistogram;
298 
299         final SnippetCounter systemArraycopyCounter;
300         final SnippetCounter systemArraycopyCopiedCounter;
301 
302         final SnippetCounter genericArraycopyDifferentTypeCopiedCounter;
303         final SnippetCounter genericArraycopyDifferentTypeCounter;
304 
</pre>
<hr />
<pre>
335 
336             createArraycopyCounter(JavaKind.Byte, callCounters, copiedElementsCounters);
337             createArraycopyCounter(JavaKind.Boolean, callCounters, copiedElementsCounters);
338             createArraycopyCounter(JavaKind.Char, callCounters, copiedElementsCounters);
339             createArraycopyCounter(JavaKind.Short, callCounters, copiedElementsCounters);
340             createArraycopyCounter(JavaKind.Int, callCounters, copiedElementsCounters);
341             createArraycopyCounter(JavaKind.Long, callCounters, copiedElementsCounters);
342             createArraycopyCounter(JavaKind.Float, callCounters, copiedElementsCounters);
343             createArraycopyCounter(JavaKind.Double, callCounters, copiedElementsCounters);
344             createArraycopyCounter(JavaKind.Object, callCounters, copiedElementsCounters);
345         }
346 
347         void createArraycopyCounter(JavaKind kind, Group counters, Group copiedCounters) {
348             arraycopyCallCounters.put(kind, new SnippetCounter(counters, kind + &quot;[] stub&quot;, &quot;arraycopy call for &quot; + kind + &quot;[] arrays&quot;));
349             arraycopyCallCopiedCounters.put(kind, new SnippetCounter(copiedCounters, kind + &quot;[] stub&quot;, &quot;arraycopy call for &quot; + kind + &quot;[] arrays&quot;));
350         }
351     }
352 
353     public static class Templates extends SnippetTemplate.AbstractTemplates {
354         private final SnippetInfo arraycopyGenericSnippet;
<span class="line-removed">355         private final SnippetInfo arraycopyUnrolledSnippet;</span>
356         private final SnippetInfo arraycopyExactSnippet;
<span class="line-modified">357         private final SnippetInfo arraycopyZeroLengthSnippet;</span>
358         private final SnippetInfo arraycopyCheckcastSnippet;
359         private final SnippetInfo arraycopyNativeSnippet;
360         private final SnippetInfo checkcastArraycopyWithSlowPathWork;
361         private final SnippetInfo genericArraycopyWithSlowPathWork;

362 
363         private ResolvedJavaMethod originalArraycopy;
364         private final Counters counters;

365 
366         public Templates(ArrayCopySnippets receiver, OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, Factory factory, Providers providers,
367                         SnippetReflectionProvider snippetReflection, TargetDescription target) {
368             super(options, factories, providers, snippetReflection, target);
369             this.counters = new Counters(factory);
370 
371             arraycopyGenericSnippet = snippet(receiver, &quot;arraycopyGenericSnippet&quot;);
<span class="line-removed">372             arraycopyUnrolledSnippet = snippet(receiver, &quot;arraycopyUnrolledSnippet&quot;);</span>
373             arraycopyExactSnippet = snippet(receiver, &quot;arraycopyExactSnippet&quot;);
<span class="line-modified">374             arraycopyZeroLengthSnippet = snippet(receiver, &quot;arraycopyZeroLengthSnippet&quot;);</span>
375             arraycopyCheckcastSnippet = snippet(receiver, &quot;arraycopyCheckcastSnippet&quot;);
376             arraycopyNativeSnippet = snippet(null, &quot;arraycopyNativeSnippet&quot;);
377             checkcastArraycopyWithSlowPathWork = snippet(receiver, &quot;checkcastArraycopyWithSlowPathWork&quot;);
378             genericArraycopyWithSlowPathWork = snippet(receiver, &quot;genericArraycopyWithSlowPathWork&quot;);

379         }
380 
381         protected SnippetInfo snippet(ArrayCopySnippets receiver, String methodName) {
382             SnippetInfo info = snippet(ArrayCopySnippets.class, methodName, originalArraycopy(), receiver, LocationIdentity.any());
383             return info;
384         }
385 
386         public void lower(ArrayCopyNode arraycopy, LoweringTool tool) {
387             JavaKind elementKind = selectComponentKind(arraycopy);
388             SnippetInfo snippetInfo;
389             ArrayCopyTypeCheck arrayTypeCheck;
390 
391             ResolvedJavaType srcType = StampTool.typeOrNull(arraycopy.getSource().stamp(NodeView.DEFAULT));
392             ResolvedJavaType destType = StampTool.typeOrNull(arraycopy.getDestination().stamp(NodeView.DEFAULT));
393             if (!canBeArray(srcType) || !canBeArray(destType)) {
394                 // at least one of the objects is definitely not an array - use the native call
395                 // right away as the copying will fail anyways
396                 snippetInfo = arraycopyNativeSnippet;
397                 arrayTypeCheck = ArrayCopyTypeCheck.UNDEFINED_ARRAY_TYPE_CHECK;
398             } else {
399                 ResolvedJavaType srcComponentType = srcType == null ? null : srcType.getComponentType();
400                 ResolvedJavaType destComponentType = destType == null ? null : destType.getComponentType();
401 
402                 if (arraycopy.isExact()) {
403                     // there is a sufficient type match - we don&#39;t need any additional type checks
<span class="line-modified">404                     snippetInfo = arraycopyExactSnippet;</span>
405                     arrayTypeCheck = ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK;
406                 } else if (srcComponentType == null &amp;&amp; destComponentType == null) {
407                     // we don&#39;t know anything about the types - use the generic copying
408                     snippetInfo = arraycopyGenericSnippet;
409                     // no need for additional type check to avoid duplicated work
410                     arrayTypeCheck = ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK;




411                 } else if (srcComponentType != null &amp;&amp; destComponentType != null) {
412                     if (!srcComponentType.isPrimitive() &amp;&amp; !destComponentType.isPrimitive()) {
413                         // it depends on the array content if the copy succeeds - we need
414                         // a type check for every store
415                         snippetInfo = arraycopyCheckcastSnippet;
416                         arrayTypeCheck = ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK;
417                     } else {
418                         // one object is an object array, the other one is a primitive array.
419                         // this copy will always fail - use the native call right away
420                         assert !srcComponentType.equals(destComponentType) : &quot;must be handled by arraycopy.isExact()&quot;;
421                         snippetInfo = arraycopyNativeSnippet;
422                         arrayTypeCheck = ArrayCopyTypeCheck.UNDEFINED_ARRAY_TYPE_CHECK;
423                     }
424                 } else {
425                     ResolvedJavaType nonNullComponentType = srcComponentType != null ? srcComponentType : destComponentType;
426                     if (nonNullComponentType.isPrimitive()) {
427                         // one involved object is a primitive array - it is sufficient to directly
428                         // compare the hub.
<span class="line-modified">429                         snippetInfo = arraycopyExactSnippet;</span>
430                         arrayTypeCheck = ArrayCopyTypeCheck.HUB_BASED_ARRAY_TYPE_CHECK;
431                         elementKind = nonNullComponentType.getJavaKind();
432                     } else {
433                         // one involved object is an object array - the other array&#39;s element type
434                         // may be primitive or object, hence we compare the layout helper.
435                         snippetInfo = arraycopyCheckcastSnippet;
436                         arrayTypeCheck = ArrayCopyTypeCheck.LAYOUT_HELPER_BASED_ARRAY_TYPE_CHECK;
437                     }
438                 }
439             }
440 
<span class="line-modified">441             // a few special cases that are easier to handle when all other variables already have a</span>
<span class="line-modified">442             // value</span>
<span class="line-removed">443             if (snippetInfo != arraycopyNativeSnippet &amp;&amp; snippetInfo != arraycopyGenericSnippet &amp;&amp; arraycopy.getLength().isConstant() &amp;&amp; arraycopy.getLength().asJavaConstant().asLong() == 0) {</span>
<span class="line-removed">444                 // Copying 0 element between object arrays with conflicting types will not throw an</span>
<span class="line-removed">445                 // exception - once we pass the preliminary element type checks that we are not</span>
<span class="line-removed">446                 // mixing arrays of different basic types, ArrayStoreException is only thrown when</span>
<span class="line-removed">447                 // an *astore would have thrown it. Therefore, copying null between object arrays</span>
<span class="line-removed">448                 // with conflicting types will also succeed (we do not optimize for such case here).</span>
<span class="line-removed">449                 snippetInfo = arraycopyZeroLengthSnippet;</span>
<span class="line-removed">450             } else if (snippetInfo == arraycopyExactSnippet &amp;&amp; shouldUnroll(arraycopy.getLength())) {</span>
<span class="line-removed">451                 snippetInfo = arraycopyUnrolledSnippet;</span>
452             }
453 
454             // create the snippet
455             Arguments args = new Arguments(snippetInfo, arraycopy.graph().getGuardsStage(), tool.getLoweringStage());
456             args.add(&quot;src&quot;, arraycopy.getSource());
457             args.add(&quot;srcPos&quot;, arraycopy.getSourcePosition());
458             args.add(&quot;dest&quot;, arraycopy.getDestination());
459             args.add(&quot;destPos&quot;, arraycopy.getDestinationPosition());
460             args.add(&quot;length&quot;, arraycopy.getLength());
461             if (snippetInfo != arraycopyNativeSnippet) {
462                 assert arrayTypeCheck != ArrayCopyTypeCheck.UNDEFINED_ARRAY_TYPE_CHECK;
463                 args.addConst(&quot;arrayTypeCheck&quot;, arrayTypeCheck);
464             }
465             Object locationIdentity = arraycopy.killsAnyLocation() ? LocationIdentity.any() : NamedLocationIdentity.getArrayLocation(elementKind);
<span class="line-modified">466             if (snippetInfo == arraycopyUnrolledSnippet) {</span>
<span class="line-removed">467                 args.addConst(&quot;elementKind&quot;, elementKind != null ? elementKind : JavaKind.Illegal);</span>
<span class="line-removed">468                 args.addConst(&quot;locationIdentity&quot;, locationIdentity);</span>
<span class="line-removed">469                 args.addConst(&quot;unrolledLength&quot;, arraycopy.getLength().asJavaConstant().asInt());</span>
<span class="line-removed">470             }</span>
<span class="line-removed">471             if (snippetInfo == arraycopyExactSnippet) {</span>
472                 assert elementKind != null;

473                 args.addConst(&quot;elementKind&quot;, elementKind);
474                 args.addConst(&quot;locationIdentity&quot;, locationIdentity);
475                 args.addConst(&quot;elementKindCounter&quot;, counters.arraycopyCallCounters.get(elementKind));
476                 args.addConst(&quot;elementKindCopiedCounter&quot;, counters.arraycopyCallCopiedCounters.get(elementKind));
477             }
478             args.addConst(&quot;counters&quot;, counters);
479             if (snippetInfo == arraycopyCheckcastSnippet) {
480                 args.addConst(&quot;workSnippet&quot;, checkcastArraycopyWithSlowPathWork);
481                 args.addConst(&quot;elementKind&quot;, JavaKind.Illegal);
482             }
483             if (snippetInfo == arraycopyGenericSnippet) {
484                 args.addConst(&quot;workSnippet&quot;, genericArraycopyWithSlowPathWork);
485                 args.addConst(&quot;elementKind&quot;, JavaKind.Illegal);
486             }
487 
488             instantiate(args, arraycopy);
489         }
490 
<span class="line-modified">491         public void lower(ArrayCopyWithSlowPathNode arraycopy, LoweringTool tool) {</span>
492             StructuredGraph graph = arraycopy.graph();
<span class="line-modified">493             if (!graph.getGuardsStage().areFrameStatesAtDeopts()) {</span>
<span class="line-modified">494                 // if an arraycopy contains a slow path, we can&#39;t lower it right away</span>
<span class="line-modified">495                 return;</span>








496             }
497 
498             SnippetInfo snippetInfo = arraycopy.getSnippet();
499             Arguments args = new Arguments(snippetInfo, graph.getGuardsStage(), tool.getLoweringStage());
500             args.add(&quot;src&quot;, arraycopy.getSource());
501             args.add(&quot;srcPos&quot;, arraycopy.getSourcePosition());
502             args.add(&quot;dest&quot;, arraycopy.getDestination());
503             args.add(&quot;destPos&quot;, arraycopy.getDestinationPosition());
504             args.add(&quot;length&quot;, arraycopy.getLength());






505             args.addConst(&quot;counters&quot;, counters);
506             instantiate(args, arraycopy);
507         }
508 
509         private static boolean canBeArray(ResolvedJavaType type) {
510             return type == null || type.isJavaLangObject() || type.isArray();
511         }
512 
513         public static JavaKind selectComponentKind(BasicArrayCopyNode arraycopy) {
514             ResolvedJavaType srcType = StampTool.typeOrNull(arraycopy.getSource().stamp(NodeView.DEFAULT));
515             ResolvedJavaType destType = StampTool.typeOrNull(arraycopy.getDestination().stamp(NodeView.DEFAULT));
516 
517             if (srcType == null || !srcType.isArray() || destType == null || !destType.isArray()) {
518                 return null;
519             }
520             if (!destType.getComponentType().isAssignableFrom(srcType.getComponentType())) {
521                 return null;
522             }
523             if (!arraycopy.isExact()) {
524                 return null;
525             }
526             return srcType.getComponentType().getJavaKind();
527         }
528 
<span class="line-removed">529         private static boolean shouldUnroll(ValueNode length) {</span>
<span class="line-removed">530             return length.isConstant() &amp;&amp; length.asJavaConstant().asInt() &lt;= 8 &amp;&amp; length.asJavaConstant().asInt() != 0;</span>
<span class="line-removed">531         }</span>
<span class="line-removed">532 </span>
533         /**
534          * Instantiate the snippet template and fix up the FrameState of any Invokes of
535          * System.arraycopy and propagate the captured bci in the ArrayCopySlowPathNode.
536          *
537          * @param args
538          * @param arraycopy
539          */
540         private void instantiate(Arguments args, BasicArrayCopyNode arraycopy) {
541             StructuredGraph graph = arraycopy.graph();
542             SnippetTemplate template = template(arraycopy, args);
543             UnmodifiableEconomicMap&lt;Node, Node&gt; replacements = template.instantiate(providers.getMetaAccess(), arraycopy, SnippetTemplate.DEFAULT_REPLACER, args, false);
544             for (Node originalNode : replacements.getKeys()) {
545                 if (originalNode instanceof InvokeNode) {
546                     InvokeNode invoke = (InvokeNode) replacements.get(originalNode);
547                     assert invoke.asNode().graph() == graph;
548                     CallTargetNode call = invoke.callTarget();
549 
550                     if (!call.targetMethod().equals(originalArraycopy)) {
551                         throw new GraalError(&quot;unexpected invoke %s in snippet&quot;, call.targetMethod());
552                     }
553                     // Here we need to fix the bci of the invoke
<span class="line-modified">554                     InvokeNode newInvoke = invoke.replaceWithNewBci(arraycopy.getBci());</span>
<span class="line-modified">555                     newInvoke.setStateDuring(null);</span>
<span class="line-modified">556                     newInvoke.setStateAfter(null);</span>
557                     if (arraycopy.stateDuring() != null) {
<span class="line-modified">558                         newInvoke.setStateDuring(arraycopy.stateDuring());</span>
559                     } else {
560                         assert arraycopy.stateAfter() != null : arraycopy;
<span class="line-modified">561                         newInvoke.setStateAfter(arraycopy.stateAfter());</span>
562                     }
563                 } else if (originalNode instanceof InvokeWithExceptionNode) {
564                     throw new GraalError(&quot;unexpected invoke with exception %s in snippet&quot;, originalNode);
<span class="line-modified">565                 } else if (originalNode instanceof ArrayCopyWithSlowPathNode) {</span>
<span class="line-modified">566                     ArrayCopyWithSlowPathNode slowPath = (ArrayCopyWithSlowPathNode) replacements.get(originalNode);</span>
567                     assert arraycopy.stateAfter() != null : arraycopy;
568                     assert slowPath.stateAfter() == arraycopy.stateAfter();
569                     slowPath.setBci(arraycopy.getBci());
570                 }
571             }
572             GraphUtil.killCFG(arraycopy);
573         }
574 
575         private ResolvedJavaMethod originalArraycopy() throws GraalError {
576             if (originalArraycopy == null) {
577                 try {
578                     originalArraycopy = findMethod(providers.getMetaAccess(), System.class, &quot;arraycopy&quot;);
579                 } catch (SecurityException e) {
580                     throw new GraalError(e);
581                 }
582             }
583             return originalArraycopy;
584         }




585     }
586 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.arraycopy;
 26 
 27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
<span class="line-added"> 28 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;</span>
 29 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FREQUENT_PROBABILITY;
 30 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LIKELY_PROBABILITY;
 31 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.NOT_FREQUENT_PROBABILITY;
 32 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.SLOW_PATH_PROBABILITY;
<span class="line-added"> 33 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.DEOPT_PROBABILITY;</span>
 34 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.probability;
 35 
 36 import java.util.EnumMap;
 37 
 38 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
 39 import org.graalvm.compiler.api.directives.GraalDirectives;
 40 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
 41 import org.graalvm.compiler.api.replacements.Snippet;
 42 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
 43 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 44 import org.graalvm.compiler.debug.DebugHandlersFactory;
 45 import org.graalvm.compiler.debug.GraalError;
 46 import org.graalvm.compiler.graph.Node;
 47 import org.graalvm.compiler.nodes.CallTargetNode;
 48 import org.graalvm.compiler.nodes.DeoptimizeNode;
 49 import org.graalvm.compiler.nodes.InvokeNode;
 50 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 51 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 52 import org.graalvm.compiler.nodes.NodeView;
 53 import org.graalvm.compiler.nodes.PiNode;
<span class="line-added"> 54 import org.graalvm.compiler.nodes.SnippetAnchorNode;</span>
 55 import org.graalvm.compiler.nodes.StructuredGraph;
<span class="line-modified"> 56 import org.graalvm.compiler.nodes.extended.GuardedUnsafeLoadNode;</span>
<span class="line-modified"> 57 import org.graalvm.compiler.nodes.extended.GuardingNode;</span>
 58 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 59 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 60 import org.graalvm.compiler.nodes.spi.LoweringTool;
 61 import org.graalvm.compiler.nodes.type.StampTool;
 62 import org.graalvm.compiler.nodes.util.GraphUtil;
 63 import org.graalvm.compiler.options.OptionValues;
 64 import org.graalvm.compiler.phases.util.Providers;
 65 import org.graalvm.compiler.replacements.ReplacementsUtil;
 66 import org.graalvm.compiler.replacements.SnippetCounter;
 67 import org.graalvm.compiler.replacements.SnippetCounter.Group;
 68 import org.graalvm.compiler.replacements.SnippetCounter.Group.Factory;
 69 import org.graalvm.compiler.replacements.SnippetIntegerHistogram;
 70 import org.graalvm.compiler.replacements.SnippetTemplate;
 71 import org.graalvm.compiler.replacements.SnippetTemplate.Arguments;
 72 import org.graalvm.compiler.replacements.SnippetTemplate.SnippetInfo;
 73 import org.graalvm.compiler.replacements.Snippets;
 74 import org.graalvm.compiler.replacements.nodes.BasicArrayCopyNode;

 75 import org.graalvm.compiler.word.Word;
 76 import jdk.internal.vm.compiler.word.LocationIdentity;
 77 import jdk.internal.vm.compiler.word.Pointer;
 78 
 79 import jdk.vm.ci.code.TargetDescription;
 80 import jdk.vm.ci.meta.DeoptimizationAction;
 81 import jdk.vm.ci.meta.DeoptimizationReason;
 82 import jdk.vm.ci.meta.JavaKind;
 83 import jdk.vm.ci.meta.MetaAccessProvider;
 84 import jdk.vm.ci.meta.ResolvedJavaMethod;
 85 import jdk.vm.ci.meta.ResolvedJavaType;
 86 
 87 public abstract class ArrayCopySnippets implements Snippets {
 88 
 89     private enum ArrayCopyTypeCheck {
 90         UNDEFINED_ARRAY_TYPE_CHECK,
 91         // either we know that both objects are arrays and have the same type,
 92         // or we apply generic array copy snippet, which enforces type check
 93         NO_ARRAY_TYPE_CHECK,
 94         // can be used when we know that one of the objects is a primitive array
 95         HUB_BASED_ARRAY_TYPE_CHECK,
 96         // can be used when we know that one of the objects is an object array
 97         LAYOUT_HELPER_BASED_ARRAY_TYPE_CHECK
 98     }
 99 
100     /** Marker value for the {@link InjectedParameter} injected parameter. */
101     static final MetaAccessProvider INJECTED_META_ACCESS = null;
102 
103     public abstract Pointer loadHub(Object nonNullSrc);
104 
105     public abstract Pointer getDestElemClass(Pointer destKlass);
106 
107     public abstract Word getSuperCheckOffset(Pointer destElemKlass);
108 
109     public abstract int getReadLayoutHelper(Pointer srcHub);
110 
111     protected abstract int heapWordSize();
112 
<span class="line-modified">113     @SuppressWarnings(&quot;unused&quot;)</span>









114     @Snippet
115     public void arraycopyExactSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck,
<span class="line-modified">116                     @ConstantParameter SnippetInfo workSnippet, @ConstantParameter JavaKind elementKind, @ConstantParameter LocationIdentity locationIdentity,</span>
117                     @ConstantParameter SnippetCounter elementKindCounter, @ConstantParameter SnippetCounter elementKindCopiedCounter, @ConstantParameter Counters counters) {
118         Object nonNullSrc = GraalDirectives.guardingNonNull(src);
119         Object nonNullDest = GraalDirectives.guardingNonNull(dest);
120         checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);
121         checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);
122         incrementLengthCounter(length, counters);
123 
124         elementKindCounter.inc();
125         elementKindCopiedCounter.add(length);
<span class="line-modified">126 </span>
<span class="line-added">127         ArrayCopyWithDelayedLoweringNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, workSnippet, elementKind);</span>
128     }
129 
<span class="line-added">130     @SuppressWarnings(&quot;unused&quot;)</span>
131     @Snippet
<span class="line-modified">132     public void arraycopyExactStubCallSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck,</span>
<span class="line-modified">133                     @ConstantParameter SnippetInfo workSnippet, @ConstantParameter JavaKind elementKind, @ConstantParameter LocationIdentity locationIdentity,</span>
<span class="line-added">134                     @ConstantParameter SnippetCounter elementKindCounter, @ConstantParameter SnippetCounter elementKindCopiedCounter, @ConstantParameter Counters counters) {</span>
135         Object nonNullSrc = GraalDirectives.guardingNonNull(src);
136         Object nonNullDest = GraalDirectives.guardingNonNull(dest);
137         checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);
138         checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);
139         incrementLengthCounter(length, counters);
140 
<span class="line-modified">141         elementKindCounter.inc();</span>
<span class="line-added">142         elementKindCopiedCounter.add(length);</span>
<span class="line-added">143 </span>
<span class="line-added">144         ArrayCopyCallNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, elementKind, locationIdentity, heapWordSize());</span>
145     }
146 
147     @Snippet
<span class="line-modified">148     public void arraycopyCheckcastSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck, @ConstantParameter Counters counters,</span>
<span class="line-modified">149                     @ConstantParameter SnippetInfo workSnippet, @ConstantParameter JavaKind elementKind) {</span>
150         Object nonNullSrc = GraalDirectives.guardingNonNull(src);
151         Object nonNullDest = GraalDirectives.guardingNonNull(dest);
152         checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);
153         checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);
154         incrementLengthCounter(length, counters);
155 
<span class="line-modified">156         ArrayCopyWithDelayedLoweringNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, workSnippet, elementKind);</span>
157     }
158 
159     @Snippet
160     public void arraycopyGenericSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck, @ConstantParameter Counters counters,
161                     @ConstantParameter SnippetInfo workSnippet, @ConstantParameter JavaKind elementKind) {
162         Object nonNullSrc = GraalDirectives.guardingNonNull(src);
163         Object nonNullDest = GraalDirectives.guardingNonNull(dest);
164         checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);
165         checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);
166         incrementLengthCounter(length, counters);
167 
<span class="line-modified">168         ArrayCopyWithDelayedLoweringNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, workSnippet, elementKind);</span>
169     }
170 
171     @Snippet
172     public static void arraycopyNativeSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter Counters counters) {
173         // all checks are done in the native method, so no need to emit additional checks here
174         incrementLengthCounter(length, counters);
175         counters.systemArraycopyCounter.inc();
176         counters.systemArraycopyCopiedCounter.add(length);
177 
178         System.arraycopy(src, srcPos, dest, destPos, length);
179     }
180 
<span class="line-modified">181     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added">182     @Snippet(allowPartialIntrinsicArgumentMismatch = true)</span>
<span class="line-added">183     public void exactArraycopyWithSlowPathWork(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter JavaKind elementKind, @ConstantParameter LocationIdentity arrayLocation,</span>
<span class="line-added">184                     @ConstantParameter Counters counters) {</span>
185         int scale = ReplacementsUtil.arrayIndexScale(INJECTED_META_ACCESS, elementKind);
186         int arrayBaseOffset = ReplacementsUtil.getArrayBaseOffset(INJECTED_META_ACCESS, elementKind);

187         long sourceOffset = arrayBaseOffset + (long) srcPos * scale;
188         long destOffset = arrayBaseOffset + (long) destPos * scale;







189 
<span class="line-modified">190         GuardingNode anchor = SnippetAnchorNode.anchor();</span>
<span class="line-modified">191         if (probability(NOT_FREQUENT_PROBABILITY, src == dest &amp;&amp; srcPos &lt; destPos)) {</span>
<span class="line-modified">192             // bad aliased case so we need to copy the array from back to front</span>
<span class="line-modified">193             for (int position = length - 1; position &gt;= 0; position--) {</span>
<span class="line-modified">194                 Object value = GuardedUnsafeLoadNode.guardedLoad(src, sourceOffset + ((long) position) * scale, elementKind, arrayLocation, anchor);</span>
<span class="line-modified">195                 RawStoreNode.storeObject(dest, destOffset + ((long) position) * scale, value, elementKind, arrayLocation, true);</span>
<span class="line-added">196             }</span>
<span class="line-added">197         } else {</span>
<span class="line-added">198             for (int position = 0; position &lt; length; position++) {</span>
<span class="line-added">199                 Object value = GuardedUnsafeLoadNode.guardedLoad(src, sourceOffset + ((long) position) * scale, elementKind, arrayLocation, anchor);</span>
<span class="line-added">200                 RawStoreNode.storeObject(dest, destOffset + ((long) position) * scale, value, elementKind, arrayLocation, true);</span>
<span class="line-added">201             }</span>
202         }
203     }
204 
<span class="line-added">205     @SuppressWarnings(&quot;unused&quot;)</span>
206     @Snippet(allowPartialIntrinsicArgumentMismatch = true)
<span class="line-modified">207     public void checkcastArraycopyWithSlowPathWork(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter JavaKind elementKind,</span>
<span class="line-added">208                     @ConstantParameter LocationIdentity arrayLocation,</span>
<span class="line-added">209                     @ConstantParameter Counters counters) {</span>
210         if (probability(FREQUENT_PROBABILITY, length &gt; 0)) {
211             Object nonNullSrc = PiNode.asNonNullObject(src);
212             Object nonNullDest = PiNode.asNonNullObject(dest);
213             Pointer srcKlass = loadHub(nonNullSrc);
214             Pointer destKlass = loadHub(nonNullDest);
<span class="line-modified">215             if (probability(LIKELY_PROBABILITY, srcKlass == destKlass) || probability(LIKELY_PROBABILITY, nonNullDest.getClass() == Object[].class)) {</span>
216                 // no storecheck required.
217                 counters.objectCheckcastSameTypeCounter.inc();
218                 counters.objectCheckcastSameTypeCopiedCounter.add(length);
219                 ArrayCopyCallNode.arraycopyObjectKillsAny(nonNullSrc, srcPos, nonNullDest, destPos, length, heapWordSize());
220             } else {
221                 Pointer destElemKlass = getDestElemClass(destKlass);
222                 Word superCheckOffset = getSuperCheckOffset(destElemKlass);
223 
224                 counters.objectCheckcastDifferentTypeCounter.inc();
225                 counters.objectCheckcastDifferentTypeCopiedCounter.add(length);
226 
<span class="line-modified">227                 System.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length);</span>








228             }
229         }
230     }
231 
<span class="line-added">232     @SuppressWarnings(&quot;unused&quot;)</span>
233     @Snippet(allowPartialIntrinsicArgumentMismatch = true)
<span class="line-modified">234     public void genericArraycopyWithSlowPathWork(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter JavaKind elementKind,</span>
<span class="line-added">235                     @ConstantParameter LocationIdentity arrayLocation,</span>
<span class="line-added">236                     @ConstantParameter Counters counters) {</span>
237         // The length &gt; 0 check should not be placed here because generic array copy stub should
238         // enforce type check. This is fine performance-wise because this snippet is rarely used.
239         counters.genericArraycopyDifferentTypeCounter.inc();
240         counters.genericArraycopyDifferentTypeCopiedCounter.add(length);
241         int copiedElements = GenericArrayCopyCallNode.genericArraycopy(src, srcPos, dest, destPos, length);
242         if (probability(SLOW_PATH_PROBABILITY, copiedElements != 0)) {
243             /*
244              * the stub doesn&#39;t throw the ArrayStoreException, but returns the number of copied
245              * elements (xor&#39;d with -1).
246              */
247             copiedElements ^= -1;
248             System.arraycopy(src, srcPos + copiedElements, dest, destPos + copiedElements, length - copiedElements);
249         }
250     }
251 
252     private static void incrementLengthCounter(int length, Counters counters) {
253         if (!IS_BUILDING_NATIVE_IMAGE) {
254             counters.lengthHistogram.inc(length);
255         }
256     }
257 
<span class="line-added">258     /**</span>
<span class="line-added">259      * Writing this as individual if statements to avoid a merge without a frame state.</span>
<span class="line-added">260      */</span>
261     private static void checkLimits(Object src, int srcPos, Object dest, int destPos, int length, Counters counters) {
<span class="line-modified">262         if (probability(DEOPT_PROBABILITY, srcPos &lt; 0)) {</span>
<span class="line-modified">263             counters.checkAIOOBECounter.inc();</span>
<span class="line-modified">264             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);</span>
<span class="line-modified">265         }</span>
<span class="line-modified">266         if (probability(DEOPT_PROBABILITY, destPos &lt; 0)) {</span>
<span class="line-added">267             counters.checkAIOOBECounter.inc();</span>
<span class="line-added">268             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);</span>
<span class="line-added">269         }</span>
<span class="line-added">270         if (probability(DEOPT_PROBABILITY, length &lt; 0)) {</span>
<span class="line-added">271             counters.checkAIOOBECounter.inc();</span>
<span class="line-added">272             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);</span>
<span class="line-added">273         }</span>
<span class="line-added">274         if (probability(DEOPT_PROBABILITY, srcPos &gt; ArrayLengthNode.arrayLength(src) - length)) {</span>
<span class="line-added">275             counters.checkAIOOBECounter.inc();</span>
<span class="line-added">276             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);</span>
<span class="line-added">277         }</span>
<span class="line-added">278         if (probability(DEOPT_PROBABILITY, destPos &gt; ArrayLengthNode.arrayLength(dest) - length)) {</span>
279             counters.checkAIOOBECounter.inc();
280             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);
281         }
282         counters.checkSuccessCounter.inc();
283     }
284 
285     private void checkArrayTypes(Object nonNullSrc, Object nonNullDest, ArrayCopyTypeCheck arrayTypeCheck) {
286         if (arrayTypeCheck == ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK) {
287             // nothing to do
288         } else if (arrayTypeCheck == ArrayCopyTypeCheck.HUB_BASED_ARRAY_TYPE_CHECK) {
289             Pointer srcHub = loadHub(nonNullSrc);
290             Pointer destHub = loadHub(nonNullDest);
<span class="line-modified">291             if (probability(DEOPT_PROBABILITY, srcHub != destHub)) {</span>
292                 DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);
293             }
294         } else if (arrayTypeCheck == ArrayCopyTypeCheck.LAYOUT_HELPER_BASED_ARRAY_TYPE_CHECK) {
295             Pointer srcHub = loadHub(nonNullSrc);
296             Pointer destHub = loadHub(nonNullDest);
<span class="line-modified">297             if (probability(DEOPT_PROBABILITY, getReadLayoutHelper(srcHub) != getReadLayoutHelper(destHub))) {</span>
298                 DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);
299             }
300         } else {
301             ReplacementsUtil.staticAssert(false, &quot;unknown array type check &quot;, arrayTypeCheck);
302         }
303     }
304 
305     static class Counters {
306         final SnippetCounter checkSuccessCounter;
307         final SnippetCounter checkAIOOBECounter;
308 
309         final SnippetCounter zeroLengthStaticCounter;
310         final SnippetIntegerHistogram lengthHistogram;
311 
312         final SnippetCounter systemArraycopyCounter;
313         final SnippetCounter systemArraycopyCopiedCounter;
314 
315         final SnippetCounter genericArraycopyDifferentTypeCopiedCounter;
316         final SnippetCounter genericArraycopyDifferentTypeCounter;
317 
</pre>
<hr />
<pre>
348 
349             createArraycopyCounter(JavaKind.Byte, callCounters, copiedElementsCounters);
350             createArraycopyCounter(JavaKind.Boolean, callCounters, copiedElementsCounters);
351             createArraycopyCounter(JavaKind.Char, callCounters, copiedElementsCounters);
352             createArraycopyCounter(JavaKind.Short, callCounters, copiedElementsCounters);
353             createArraycopyCounter(JavaKind.Int, callCounters, copiedElementsCounters);
354             createArraycopyCounter(JavaKind.Long, callCounters, copiedElementsCounters);
355             createArraycopyCounter(JavaKind.Float, callCounters, copiedElementsCounters);
356             createArraycopyCounter(JavaKind.Double, callCounters, copiedElementsCounters);
357             createArraycopyCounter(JavaKind.Object, callCounters, copiedElementsCounters);
358         }
359 
360         void createArraycopyCounter(JavaKind kind, Group counters, Group copiedCounters) {
361             arraycopyCallCounters.put(kind, new SnippetCounter(counters, kind + &quot;[] stub&quot;, &quot;arraycopy call for &quot; + kind + &quot;[] arrays&quot;));
362             arraycopyCallCopiedCounters.put(kind, new SnippetCounter(copiedCounters, kind + &quot;[] stub&quot;, &quot;arraycopy call for &quot; + kind + &quot;[] arrays&quot;));
363         }
364     }
365 
366     public static class Templates extends SnippetTemplate.AbstractTemplates {
367         private final SnippetInfo arraycopyGenericSnippet;

368         private final SnippetInfo arraycopyExactSnippet;
<span class="line-modified">369         private final SnippetInfo arraycopyExactStubCallSnippet;</span>
370         private final SnippetInfo arraycopyCheckcastSnippet;
371         private final SnippetInfo arraycopyNativeSnippet;
372         private final SnippetInfo checkcastArraycopyWithSlowPathWork;
373         private final SnippetInfo genericArraycopyWithSlowPathWork;
<span class="line-added">374         private final SnippetInfo exactArraycopyWithSlowPathWork;</span>
375 
376         private ResolvedJavaMethod originalArraycopy;
377         private final Counters counters;
<span class="line-added">378         private boolean expandArraycopyLoop;</span>
379 
380         public Templates(ArrayCopySnippets receiver, OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, Factory factory, Providers providers,
381                         SnippetReflectionProvider snippetReflection, TargetDescription target) {
382             super(options, factories, providers, snippetReflection, target);
383             this.counters = new Counters(factory);
384 
385             arraycopyGenericSnippet = snippet(receiver, &quot;arraycopyGenericSnippet&quot;);

386             arraycopyExactSnippet = snippet(receiver, &quot;arraycopyExactSnippet&quot;);
<span class="line-modified">387             arraycopyExactStubCallSnippet = snippet(receiver, &quot;arraycopyExactStubCallSnippet&quot;);</span>
388             arraycopyCheckcastSnippet = snippet(receiver, &quot;arraycopyCheckcastSnippet&quot;);
389             arraycopyNativeSnippet = snippet(null, &quot;arraycopyNativeSnippet&quot;);
390             checkcastArraycopyWithSlowPathWork = snippet(receiver, &quot;checkcastArraycopyWithSlowPathWork&quot;);
391             genericArraycopyWithSlowPathWork = snippet(receiver, &quot;genericArraycopyWithSlowPathWork&quot;);
<span class="line-added">392             exactArraycopyWithSlowPathWork = snippet(receiver, &quot;exactArraycopyWithSlowPathWork&quot;);</span>
393         }
394 
395         protected SnippetInfo snippet(ArrayCopySnippets receiver, String methodName) {
396             SnippetInfo info = snippet(ArrayCopySnippets.class, methodName, originalArraycopy(), receiver, LocationIdentity.any());
397             return info;
398         }
399 
400         public void lower(ArrayCopyNode arraycopy, LoweringTool tool) {
401             JavaKind elementKind = selectComponentKind(arraycopy);
402             SnippetInfo snippetInfo;
403             ArrayCopyTypeCheck arrayTypeCheck;
404 
405             ResolvedJavaType srcType = StampTool.typeOrNull(arraycopy.getSource().stamp(NodeView.DEFAULT));
406             ResolvedJavaType destType = StampTool.typeOrNull(arraycopy.getDestination().stamp(NodeView.DEFAULT));
407             if (!canBeArray(srcType) || !canBeArray(destType)) {
408                 // at least one of the objects is definitely not an array - use the native call
409                 // right away as the copying will fail anyways
410                 snippetInfo = arraycopyNativeSnippet;
411                 arrayTypeCheck = ArrayCopyTypeCheck.UNDEFINED_ARRAY_TYPE_CHECK;
412             } else {
413                 ResolvedJavaType srcComponentType = srcType == null ? null : srcType.getComponentType();
414                 ResolvedJavaType destComponentType = destType == null ? null : destType.getComponentType();
415 
416                 if (arraycopy.isExact()) {
417                     // there is a sufficient type match - we don&#39;t need any additional type checks
<span class="line-modified">418                     snippetInfo = arraycopyExactStubCallSnippet;</span>
419                     arrayTypeCheck = ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK;
420                 } else if (srcComponentType == null &amp;&amp; destComponentType == null) {
421                     // we don&#39;t know anything about the types - use the generic copying
422                     snippetInfo = arraycopyGenericSnippet;
423                     // no need for additional type check to avoid duplicated work
424                     arrayTypeCheck = ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK;
<span class="line-added">425                 } else if (GeneratePIC.getValue(options)) {</span>
<span class="line-added">426                     // use generic copying for AOT compilation</span>
<span class="line-added">427                     snippetInfo = arraycopyGenericSnippet;</span>
<span class="line-added">428                     arrayTypeCheck = ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK;</span>
429                 } else if (srcComponentType != null &amp;&amp; destComponentType != null) {
430                     if (!srcComponentType.isPrimitive() &amp;&amp; !destComponentType.isPrimitive()) {
431                         // it depends on the array content if the copy succeeds - we need
432                         // a type check for every store
433                         snippetInfo = arraycopyCheckcastSnippet;
434                         arrayTypeCheck = ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK;
435                     } else {
436                         // one object is an object array, the other one is a primitive array.
437                         // this copy will always fail - use the native call right away
438                         assert !srcComponentType.equals(destComponentType) : &quot;must be handled by arraycopy.isExact()&quot;;
439                         snippetInfo = arraycopyNativeSnippet;
440                         arrayTypeCheck = ArrayCopyTypeCheck.UNDEFINED_ARRAY_TYPE_CHECK;
441                     }
442                 } else {
443                     ResolvedJavaType nonNullComponentType = srcComponentType != null ? srcComponentType : destComponentType;
444                     if (nonNullComponentType.isPrimitive()) {
445                         // one involved object is a primitive array - it is sufficient to directly
446                         // compare the hub.
<span class="line-modified">447                         snippetInfo = arraycopyExactStubCallSnippet;</span>
448                         arrayTypeCheck = ArrayCopyTypeCheck.HUB_BASED_ARRAY_TYPE_CHECK;
449                         elementKind = nonNullComponentType.getJavaKind();
450                     } else {
451                         // one involved object is an object array - the other array&#39;s element type
452                         // may be primitive or object, hence we compare the layout helper.
453                         snippetInfo = arraycopyCheckcastSnippet;
454                         arrayTypeCheck = ArrayCopyTypeCheck.LAYOUT_HELPER_BASED_ARRAY_TYPE_CHECK;
455                     }
456                 }
457             }
458 
<span class="line-modified">459             if (this.expandArraycopyLoop &amp;&amp; snippetInfo == arraycopyExactStubCallSnippet) {</span>
<span class="line-modified">460                 snippetInfo = arraycopyExactSnippet;</span>









461             }
462 
463             // create the snippet
464             Arguments args = new Arguments(snippetInfo, arraycopy.graph().getGuardsStage(), tool.getLoweringStage());
465             args.add(&quot;src&quot;, arraycopy.getSource());
466             args.add(&quot;srcPos&quot;, arraycopy.getSourcePosition());
467             args.add(&quot;dest&quot;, arraycopy.getDestination());
468             args.add(&quot;destPos&quot;, arraycopy.getDestinationPosition());
469             args.add(&quot;length&quot;, arraycopy.getLength());
470             if (snippetInfo != arraycopyNativeSnippet) {
471                 assert arrayTypeCheck != ArrayCopyTypeCheck.UNDEFINED_ARRAY_TYPE_CHECK;
472                 args.addConst(&quot;arrayTypeCheck&quot;, arrayTypeCheck);
473             }
474             Object locationIdentity = arraycopy.killsAnyLocation() ? LocationIdentity.any() : NamedLocationIdentity.getArrayLocation(elementKind);
<span class="line-modified">475             if (snippetInfo == arraycopyExactStubCallSnippet || snippetInfo == arraycopyExactSnippet) {</span>





476                 assert elementKind != null;
<span class="line-added">477                 args.addConst(&quot;workSnippet&quot;, exactArraycopyWithSlowPathWork);</span>
478                 args.addConst(&quot;elementKind&quot;, elementKind);
479                 args.addConst(&quot;locationIdentity&quot;, locationIdentity);
480                 args.addConst(&quot;elementKindCounter&quot;, counters.arraycopyCallCounters.get(elementKind));
481                 args.addConst(&quot;elementKindCopiedCounter&quot;, counters.arraycopyCallCopiedCounters.get(elementKind));
482             }
483             args.addConst(&quot;counters&quot;, counters);
484             if (snippetInfo == arraycopyCheckcastSnippet) {
485                 args.addConst(&quot;workSnippet&quot;, checkcastArraycopyWithSlowPathWork);
486                 args.addConst(&quot;elementKind&quot;, JavaKind.Illegal);
487             }
488             if (snippetInfo == arraycopyGenericSnippet) {
489                 args.addConst(&quot;workSnippet&quot;, genericArraycopyWithSlowPathWork);
490                 args.addConst(&quot;elementKind&quot;, JavaKind.Illegal);
491             }
492 
493             instantiate(args, arraycopy);
494         }
495 
<span class="line-modified">496         public void lower(ArrayCopyWithDelayedLoweringNode arraycopy, LoweringTool tool) {</span>
497             StructuredGraph graph = arraycopy.graph();
<span class="line-modified">498 </span>
<span class="line-modified">499             if (arraycopy.getSnippet() == exactArraycopyWithSlowPathWork &amp;&amp; this.expandArraycopyLoop) {</span>
<span class="line-modified">500                 if (!graph.getGuardsStage().areDeoptsFixed()) {</span>
<span class="line-added">501                     // Don&#39;t lower until floating guards are fixed.</span>
<span class="line-added">502                     return;</span>
<span class="line-added">503                 }</span>
<span class="line-added">504             } else {</span>
<span class="line-added">505                 if (!graph.getGuardsStage().areFrameStatesAtDeopts()) {</span>
<span class="line-added">506                     // Don&#39;t lower until frame states are assigned to deoptimization points.</span>
<span class="line-added">507                     return;</span>
<span class="line-added">508                 }</span>
509             }
510 
511             SnippetInfo snippetInfo = arraycopy.getSnippet();
512             Arguments args = new Arguments(snippetInfo, graph.getGuardsStage(), tool.getLoweringStage());
513             args.add(&quot;src&quot;, arraycopy.getSource());
514             args.add(&quot;srcPos&quot;, arraycopy.getSourcePosition());
515             args.add(&quot;dest&quot;, arraycopy.getDestination());
516             args.add(&quot;destPos&quot;, arraycopy.getDestinationPosition());
517             args.add(&quot;length&quot;, arraycopy.getLength());
<span class="line-added">518 </span>
<span class="line-added">519             JavaKind elementKind = arraycopy.getElementKind();</span>
<span class="line-added">520             args.addConst(&quot;elementKind&quot;, (elementKind == null) ? JavaKind.Illegal : elementKind);</span>
<span class="line-added">521 </span>
<span class="line-added">522             Object locationIdentity = (elementKind == null) ? LocationIdentity.any() : NamedLocationIdentity.getArrayLocation(arraycopy.getElementKind());</span>
<span class="line-added">523             args.addConst(&quot;arrayLocation&quot;, locationIdentity);</span>
524             args.addConst(&quot;counters&quot;, counters);
525             instantiate(args, arraycopy);
526         }
527 
528         private static boolean canBeArray(ResolvedJavaType type) {
529             return type == null || type.isJavaLangObject() || type.isArray();
530         }
531 
532         public static JavaKind selectComponentKind(BasicArrayCopyNode arraycopy) {
533             ResolvedJavaType srcType = StampTool.typeOrNull(arraycopy.getSource().stamp(NodeView.DEFAULT));
534             ResolvedJavaType destType = StampTool.typeOrNull(arraycopy.getDestination().stamp(NodeView.DEFAULT));
535 
536             if (srcType == null || !srcType.isArray() || destType == null || !destType.isArray()) {
537                 return null;
538             }
539             if (!destType.getComponentType().isAssignableFrom(srcType.getComponentType())) {
540                 return null;
541             }
542             if (!arraycopy.isExact()) {
543                 return null;
544             }
545             return srcType.getComponentType().getJavaKind();
546         }
547 




548         /**
549          * Instantiate the snippet template and fix up the FrameState of any Invokes of
550          * System.arraycopy and propagate the captured bci in the ArrayCopySlowPathNode.
551          *
552          * @param args
553          * @param arraycopy
554          */
555         private void instantiate(Arguments args, BasicArrayCopyNode arraycopy) {
556             StructuredGraph graph = arraycopy.graph();
557             SnippetTemplate template = template(arraycopy, args);
558             UnmodifiableEconomicMap&lt;Node, Node&gt; replacements = template.instantiate(providers.getMetaAccess(), arraycopy, SnippetTemplate.DEFAULT_REPLACER, args, false);
559             for (Node originalNode : replacements.getKeys()) {
560                 if (originalNode instanceof InvokeNode) {
561                     InvokeNode invoke = (InvokeNode) replacements.get(originalNode);
562                     assert invoke.asNode().graph() == graph;
563                     CallTargetNode call = invoke.callTarget();
564 
565                     if (!call.targetMethod().equals(originalArraycopy)) {
566                         throw new GraalError(&quot;unexpected invoke %s in snippet&quot;, call.targetMethod());
567                     }
568                     // Here we need to fix the bci of the invoke
<span class="line-modified">569                     invoke.replaceBci(arraycopy.getBci());</span>
<span class="line-modified">570                     invoke.setStateDuring(null);</span>
<span class="line-modified">571                     invoke.setStateAfter(null);</span>
572                     if (arraycopy.stateDuring() != null) {
<span class="line-modified">573                         invoke.setStateDuring(arraycopy.stateDuring());</span>
574                     } else {
575                         assert arraycopy.stateAfter() != null : arraycopy;
<span class="line-modified">576                         invoke.setStateAfter(arraycopy.stateAfter());</span>
577                     }
578                 } else if (originalNode instanceof InvokeWithExceptionNode) {
579                     throw new GraalError(&quot;unexpected invoke with exception %s in snippet&quot;, originalNode);
<span class="line-modified">580                 } else if (originalNode instanceof ArrayCopyWithDelayedLoweringNode) {</span>
<span class="line-modified">581                     ArrayCopyWithDelayedLoweringNode slowPath = (ArrayCopyWithDelayedLoweringNode) replacements.get(originalNode);</span>
582                     assert arraycopy.stateAfter() != null : arraycopy;
583                     assert slowPath.stateAfter() == arraycopy.stateAfter();
584                     slowPath.setBci(arraycopy.getBci());
585                 }
586             }
587             GraphUtil.killCFG(arraycopy);
588         }
589 
590         private ResolvedJavaMethod originalArraycopy() throws GraalError {
591             if (originalArraycopy == null) {
592                 try {
593                     originalArraycopy = findMethod(providers.getMetaAccess(), System.class, &quot;arraycopy&quot;);
594                 } catch (SecurityException e) {
595                     throw new GraalError(e);
596                 }
597             }
598             return originalArraycopy;
599         }
<span class="line-added">600 </span>
<span class="line-added">601         public void setExpandArraycopyLoop(boolean b) {</span>
<span class="line-added">602             this.expandArraycopyLoop = b;</span>
<span class="line-added">603         }</span>
604     }
605 }
</pre>
</td>
</tr>
</table>
<center><a href="ArrayCopyNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CheckcastArrayCopyCallNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/gc/SerialWriteBarrierSnippets.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.gc;
 26 
 27 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.NOT_FREQUENT_PROBABILITY;
 28 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.probability;
 29 import static org.graalvm.compiler.replacements.SnippetTemplate.DEFAULT_REPLACER;
 30 
 31 import org.graalvm.compiler.api.replacements.Snippet;
 32 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
 33 import org.graalvm.compiler.nodes.gc.SerialArrayRangeWriteBarrier;
 34 import org.graalvm.compiler.nodes.gc.SerialWriteBarrier;
 35 import org.graalvm.compiler.nodes.memory.address.AddressNode.Address;
 36 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 37 import org.graalvm.compiler.nodes.spi.LoweringTool;
 38 import org.graalvm.compiler.replacements.SnippetCounter;
 39 import org.graalvm.compiler.replacements.SnippetCounter.Group;
 40 import org.graalvm.compiler.replacements.SnippetTemplate.AbstractTemplates;
 41 import org.graalvm.compiler.replacements.SnippetTemplate.Arguments;
 42 import org.graalvm.compiler.replacements.SnippetTemplate.SnippetInfo;
 43 import org.graalvm.compiler.replacements.Snippets;
 44 import org.graalvm.compiler.replacements.nodes.AssertionNode;
 45 import org.graalvm.compiler.word.Word;
 46 import jdk.internal.vm.compiler.word.Pointer;
 47 
 48 public abstract class SerialWriteBarrierSnippets extends WriteBarrierSnippets implements Snippets {
 49     static class Counters {
 50         Counters(SnippetCounter.Group.Factory factory) {
 51             Group countersWriteBarriers = factory.createSnippetCounterGroup(&quot;Serial WriteBarriers&quot;);
 52             serialWriteBarrierCounter = new SnippetCounter(countersWriteBarriers, &quot;serialWriteBarrier&quot;, &quot;Number of Serial Write Barriers&quot;);
 53         }
 54 
 55         final SnippetCounter serialWriteBarrierCounter;
 56     }
 57 
 58     @Snippet
 59     public void serialImpreciseWriteBarrier(Object object, @ConstantParameter Counters counters, @ConstantParameter boolean verifyOnly) {
 60         if (verifyBarrier()) {
 61             verifyNotArray(object);
 62         }
 63         serialWriteBarrier(Word.objectToTrackedPointer(object), counters, verifyOnly);
 64     }
 65 
 66     @Snippet
 67     public void serialPreciseWriteBarrier(Address address, @ConstantParameter Counters counters, @ConstantParameter boolean verifyOnly) {
 68         serialWriteBarrier(Word.fromAddress(address), counters, verifyOnly);
 69     }
 70 
 71     @Snippet
 72     public void serialArrayRangeWriteBarrier(Address address, int length, @ConstantParameter int elementStride) {
 73         if (probability(NOT_FREQUENT_PROBABILITY, length == 0)) {
 74             return;
 75         }
 76 
 77         int cardShift = cardTableShift();
 78         Word cardTableAddress = cardTableAddress();
 79         Word start = cardTableAddress.add(getPointerToFirstArrayElement(address, length, elementStride).unsignedShiftRight(cardShift));
 80         Word end = cardTableAddress.add(getPointerToLastArrayElement(address, length, elementStride).unsignedShiftRight(cardShift));
 81 
 82         Word cur = start;
 83         do {
 84             cur.writeByte(0, dirtyCardValue(), GC_CARD_LOCATION);
 85             cur = cur.add(1);
 86         } while (cur.belowOrEqual(end));
 87     }
 88 
 89     private void serialWriteBarrier(Pointer ptr, Counters counters, boolean verifyOnly) {
 90         if (!verifyOnly) {
 91             counters.serialWriteBarrierCounter.inc();
 92         }
 93 
 94         Word base = cardTableAddress().add(ptr.unsignedShiftRight(cardTableShift()));
 95         if (verifyOnly) {
 96             byte cardValue = base.readByte(0, GC_CARD_LOCATION);
 97             AssertionNode.assertion(false, cardValue == dirtyCardValue(), &quot;card must be dirty&quot;);
 98         } else {
 99             base.writeByte(0, dirtyCardValue(), GC_CARD_LOCATION);
100         }
101     }
102 
103     protected abstract Word cardTableAddress();
104 
105     protected abstract int cardTableShift();
106 
107     protected abstract boolean verifyBarrier();
108 
109     protected abstract byte dirtyCardValue();
110 
111     public static class SerialWriteBarrierLowerer {
112         private final Counters counters;
113 
114         public SerialWriteBarrierLowerer(Group.Factory factory) {
115             this.counters = new Counters(factory);
116         }
117 
118         public void lower(AbstractTemplates templates, SnippetInfo preciseSnippet, SnippetInfo impreciseSnippet, SerialWriteBarrier barrier, LoweringTool tool) {
119             Arguments args;
120             if (barrier.usePrecise()) {
121                 args = new Arguments(preciseSnippet, barrier.graph().getGuardsStage(), tool.getLoweringStage());
122                 args.add(&quot;address&quot;, barrier.getAddress());
123             } else {
124                 args = new Arguments(impreciseSnippet, barrier.graph().getGuardsStage(), tool.getLoweringStage());
125                 OffsetAddressNode address = (OffsetAddressNode) barrier.getAddress();
126                 args.add(&quot;object&quot;, address.getBase());
127             }
128             args.addConst(&quot;counters&quot;, counters);
129             args.addConst(&quot;verifyOnly&quot;, barrier.getVerifyOnly());
130 
131             templates.template(barrier, args).instantiate(templates.getProviders().getMetaAccess(), barrier, DEFAULT_REPLACER, args);
132         }
133 
134         public void lower(AbstractTemplates templates, SnippetInfo snippet, SerialArrayRangeWriteBarrier barrier, LoweringTool tool) {
135             Arguments args = new Arguments(snippet, barrier.graph().getGuardsStage(), tool.getLoweringStage());
136             args.add(&quot;address&quot;, barrier.getAddress());
137             args.add(&quot;length&quot;, barrier.getLength());
138             args.addConst(&quot;elementStride&quot;, barrier.getElementStride());
139 
140             templates.template(barrier, args).instantiate(templates.getProviders().getMetaAccess(), barrier, DEFAULT_REPLACER, args);
141         }
142     }
143 }
    </pre>
  </body>
</html>
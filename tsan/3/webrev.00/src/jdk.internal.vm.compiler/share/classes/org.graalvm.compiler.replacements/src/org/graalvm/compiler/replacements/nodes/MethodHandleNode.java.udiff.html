<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/nodes/MethodHandleNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MacroStateSplitNode.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ReadRegisterNode.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/nodes/MethodHandleNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -204,11 +204,12 @@</span>
                      ResolvedJavaMethod original,
                      int bci,
                      StampPair returnStamp, ValueNode[] arguments) {
          ValueNode methodHandleNode = getReceiver(arguments);
          if (methodHandleNode.isConstant()) {
<span class="udiff-line-modified-removed">-             return getTargetInvokeNode(adder, intrinsicMethod, bci, returnStamp, arguments, methodHandleAccess.resolveInvokeBasicTarget(methodHandleNode.asJavaConstant(), true), original);</span>
<span class="udiff-line-modified-added">+             return getTargetInvokeNode(adder, intrinsicMethod, methodHandleAccess, bci, returnStamp, arguments, methodHandleAccess.resolveInvokeBasicTarget(methodHandleNode.asJavaConstant(), true),</span>
<span class="udiff-line-added">+                             original);</span>
          }
          return null;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -225,11 +226,11 @@</span>
                      ResolvedJavaMethod original,
                      int bci,
                      StampPair returnStamp, ValueNode[] arguments) {
          ValueNode memberNameNode = getMemberName(arguments);
          if (memberNameNode.isConstant()) {
<span class="udiff-line-modified-removed">-             return getTargetInvokeNode(adder, intrinsicMethod, bci, returnStamp, arguments, methodHandleAccess.resolveLinkToTarget(memberNameNode.asJavaConstant()), original);</span>
<span class="udiff-line-modified-added">+             return getTargetInvokeNode(adder, intrinsicMethod, methodHandleAccess, bci, returnStamp, arguments, methodHandleAccess.resolveLinkToTarget(memberNameNode.asJavaConstant()), original);</span>
          }
          return null;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -239,13 +240,14 @@</span>
       * @param adder
       * @param target the target, already loaded from the member name node
       *
       * @return invoke node for the member name target
       */
<span class="udiff-line-modified-removed">-     private static InvokeNode getTargetInvokeNode(GraphAdder adder, IntrinsicMethod intrinsicMethod, int bci, StampPair returnStamp, ValueNode[] originalArguments, ResolvedJavaMethod target,</span>
<span class="udiff-line-modified-added">+     private static InvokeNode getTargetInvokeNode(GraphAdder adder, IntrinsicMethod intrinsicMethod, MethodHandleAccessProvider methodHandleAccess, int bci, StampPair returnStamp,</span>
<span class="udiff-line-added">+                     ValueNode[] originalArguments, ResolvedJavaMethod target,</span>
                      ResolvedJavaMethod original) {
<span class="udiff-line-modified-removed">-         if (target == null) {</span>
<span class="udiff-line-modified-added">+         if (target == null || !isConsistentInfo(methodHandleAccess, original, target)) {</span>
              return null;
          }
  
          // In lambda forms we erase signature types to avoid resolving issues
          // involving class loaders. When we optimize a method handle invoke
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -255,11 +257,11 @@</span>
          final boolean isStatic = target.isStatic();
          final int receiverSkip = isStatic ? 0 : 1;
  
          Assumptions assumptions = adder.getAssumptions();
          ResolvedJavaMethod realTarget = null;
<span class="udiff-line-modified-removed">-         if (target.canBeStaticallyBound()) {</span>
<span class="udiff-line-modified-added">+         if (target.canBeStaticallyBound() || intrinsicMethod == IntrinsicMethod.LINK_TO_SPECIAL) {</span>
              realTarget = target;
          } else {
              ResolvedJavaType targetType = target.getDeclaringClass();
              // Try to bind based on the declaredType
              AssumptionResult&lt;ResolvedJavaMethod&gt; concreteMethod = targetType.findUniqueConcreteMethod(target);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -388,6 +390,86 @@</span>
              return new InvokeNode(callTarget, bci, StampFactory.forVoid());
          } else {
              return new InvokeNode(callTarget, bci);
          }
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Checks basic type consistency of low level method handle intrinsics.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param original declared method</span>
<span class="udiff-line-added">+      * @param target resolved method</span>
<span class="udiff-line-added">+      * @return true if original is type consistent with target</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static boolean isConsistentInfo(MethodHandleAccessProvider methodHandleAccess, ResolvedJavaMethod original, ResolvedJavaMethod target) {</span>
<span class="udiff-line-added">+         IntrinsicMethod originalIntrinsicMethod = methodHandleAccess.lookupMethodHandleIntrinsic(original);</span>
<span class="udiff-line-added">+         assert originalIntrinsicMethod == IntrinsicMethod.INVOKE_BASIC ||</span>
<span class="udiff-line-added">+                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_STATIC ||</span>
<span class="udiff-line-added">+                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_SPECIAL ||</span>
<span class="udiff-line-added">+                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_VIRTUAL ||</span>
<span class="udiff-line-added">+                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_INTERFACE;</span>
<span class="udiff-line-added">+         IntrinsicMethod targetIntrinsicMethod = methodHandleAccess.lookupMethodHandleIntrinsic(target);</span>
<span class="udiff-line-added">+         Signature originalSignature = original.getSignature();</span>
<span class="udiff-line-added">+         Signature targetSignature = target.getSignature();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         boolean invokeThroughMHIntrinsic = originalIntrinsicMethod != null &amp;&amp; targetIntrinsicMethod == null;</span>
<span class="udiff-line-added">+         if (!invokeThroughMHIntrinsic) {</span>
<span class="udiff-line-added">+             return (original.getName().equals(target.getName())) &amp;&amp; (originalSignature.equals(targetSignature));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Linkers have appendix argument which is not passed to callee.</span>
<span class="udiff-line-added">+         int hasAppendix = (originalIntrinsicMethod == IntrinsicMethod.LINK_TO_STATIC ||</span>
<span class="udiff-line-added">+                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_SPECIAL ||</span>
<span class="udiff-line-added">+                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_VIRTUAL ||</span>
<span class="udiff-line-added">+                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_INTERFACE) ? 1 : 0;</span>
<span class="udiff-line-added">+         if (originalSignature.getParameterCount(original.hasReceiver()) != (targetSignature.getParameterCount(target.hasReceiver()) + hasAppendix)) {</span>
<span class="udiff-line-added">+             return false; // parameter count mismatch</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         int senderBase = 0;</span>
<span class="udiff-line-added">+         int receiverBase = 0;</span>
<span class="udiff-line-added">+         switch (originalIntrinsicMethod) {</span>
<span class="udiff-line-added">+             case LINK_TO_VIRTUAL:</span>
<span class="udiff-line-added">+             case LINK_TO_INTERFACE:</span>
<span class="udiff-line-added">+             case LINK_TO_SPECIAL: {</span>
<span class="udiff-line-added">+                 if (target.isStatic()) {</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 if (originalSignature.getParameterKind(0).isPrimitive()) {</span>
<span class="udiff-line-added">+                     return false; // receiver should be an oop</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 senderBase = 1; // skip receiver</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             case LINK_TO_STATIC: {</span>
<span class="udiff-line-added">+                 if (target.hasReceiver()) {</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             case INVOKE_BASIC: {</span>
<span class="udiff-line-added">+                 if (target.isStatic()) {</span>
<span class="udiff-line-added">+                     if (targetSignature.getParameterKind(0).isPrimitive()) {</span>
<span class="udiff-line-added">+                         return false; // receiver should be an oop</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     receiverBase = 1; // skip receiver</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             default:</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assert (targetSignature.getParameterCount(false) - receiverBase) == (originalSignature.getParameterCount(false) - senderBase - hasAppendix) : &quot;argument count mismatch&quot;;</span>
<span class="udiff-line-added">+         int argCount = targetSignature.getParameterCount(false) - receiverBase;</span>
<span class="udiff-line-added">+         for (int i = 0; i &lt; argCount; i++) {</span>
<span class="udiff-line-added">+             if (originalSignature.getParameterKind(senderBase + i).getStackKind() != targetSignature.getParameterKind(receiverBase + i).getStackKind()) {</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // Only check the return type if the symbolic info has non-void return type.</span>
<span class="udiff-line-added">+         // I.e. the return value of the resolved method can be dropped.</span>
<span class="udiff-line-added">+         if (originalSignature.getReturnKind() != JavaKind.Void &amp;&amp;</span>
<span class="udiff-line-added">+                         originalSignature.getReturnKind().getStackKind() != targetSignature.getReturnKind().getStackKind()) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return true; // no mismatch found</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="MacroStateSplitNode.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ReadRegisterNode.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/arraycopy/ArrayCopySnippets.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayCopyNode.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CheckcastArrayCopyCallNode.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/arraycopy/ArrayCopySnippets.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,14 +23,16 @@</span>
  
  
  package org.graalvm.compiler.replacements.arraycopy;
  
  import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
<span class="udiff-line-added">+ import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;</span>
  import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FREQUENT_PROBABILITY;
  import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LIKELY_PROBABILITY;
  import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.NOT_FREQUENT_PROBABILITY;
  import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.SLOW_PATH_PROBABILITY;
<span class="udiff-line-added">+ import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.DEOPT_PROBABILITY;</span>
  import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.probability;
  
  import java.util.EnumMap;
  
  import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -47,13 +49,14 @@</span>
  import org.graalvm.compiler.nodes.InvokeNode;
  import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
  import org.graalvm.compiler.nodes.NamedLocationIdentity;
  import org.graalvm.compiler.nodes.NodeView;
  import org.graalvm.compiler.nodes.PiNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.SnippetAnchorNode;</span>
  import org.graalvm.compiler.nodes.StructuredGraph;
<span class="udiff-line-modified-removed">- import org.graalvm.compiler.nodes.ValueNode;</span>
<span class="udiff-line-modified-removed">- import org.graalvm.compiler.nodes.extended.RawLoadNode;</span>
<span class="udiff-line-modified-added">+ import org.graalvm.compiler.nodes.extended.GuardedUnsafeLoadNode;</span>
<span class="udiff-line-modified-added">+ import org.graalvm.compiler.nodes.extended.GuardingNode;</span>
  import org.graalvm.compiler.nodes.extended.RawStoreNode;
  import org.graalvm.compiler.nodes.java.ArrayLengthNode;
  import org.graalvm.compiler.nodes.spi.LoweringTool;
  import org.graalvm.compiler.nodes.type.StampTool;
  import org.graalvm.compiler.nodes.util.GraphUtil;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -67,11 +70,10 @@</span>
  import org.graalvm.compiler.replacements.SnippetTemplate;
  import org.graalvm.compiler.replacements.SnippetTemplate.Arguments;
  import org.graalvm.compiler.replacements.SnippetTemplate.SnippetInfo;
  import org.graalvm.compiler.replacements.Snippets;
  import org.graalvm.compiler.replacements.nodes.BasicArrayCopyNode;
<span class="udiff-line-removed">- import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;</span>
  import org.graalvm.compiler.word.Word;
  import jdk.internal.vm.compiler.word.LocationIdentity;
  import jdk.internal.vm.compiler.word.Pointer;
  
  import jdk.vm.ci.code.TargetDescription;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106,57 +108,54 @@</span>
  
      public abstract int getReadLayoutHelper(Pointer srcHub);
  
      protected abstract int heapWordSize();
  
<span class="udiff-line-modified-removed">-     @Snippet</span>
<span class="udiff-line-removed">-     public void arraycopyZeroLengthSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck,</span>
<span class="udiff-line-removed">-                     @ConstantParameter Counters counters) {</span>
<span class="udiff-line-removed">-         Object nonNullSrc = GraalDirectives.guardingNonNull(src);</span>
<span class="udiff-line-removed">-         Object nonNullDest = GraalDirectives.guardingNonNull(dest);</span>
<span class="udiff-line-removed">-         this.checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);</span>
<span class="udiff-line-removed">-         checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);</span>
<span class="udiff-line-removed">-         counters.zeroLengthStaticCounter.inc();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+     @SuppressWarnings(&quot;unused&quot;)</span>
      @Snippet
      public void arraycopyExactSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck,
<span class="udiff-line-modified-removed">-                     @ConstantParameter JavaKind elementKind, @ConstantParameter LocationIdentity locationIdentity,</span>
<span class="udiff-line-modified-added">+                     @ConstantParameter SnippetInfo workSnippet, @ConstantParameter JavaKind elementKind, @ConstantParameter LocationIdentity locationIdentity,</span>
                      @ConstantParameter SnippetCounter elementKindCounter, @ConstantParameter SnippetCounter elementKindCopiedCounter, @ConstantParameter Counters counters) {
          Object nonNullSrc = GraalDirectives.guardingNonNull(src);
          Object nonNullDest = GraalDirectives.guardingNonNull(dest);
          checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);
          checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);
          incrementLengthCounter(length, counters);
  
          elementKindCounter.inc();
          elementKindCopiedCounter.add(length);
<span class="udiff-line-modified-removed">-         ArrayCopyCallNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, elementKind, locationIdentity, heapWordSize());</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+         ArrayCopyWithDelayedLoweringNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, workSnippet, elementKind);</span>
      }
  
<span class="udiff-line-added">+     @SuppressWarnings(&quot;unused&quot;)</span>
      @Snippet
<span class="udiff-line-modified-removed">-     public void arraycopyUnrolledSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck,</span>
<span class="udiff-line-modified-removed">-                     @ConstantParameter JavaKind elementKind, @ConstantParameter LocationIdentity locationIdentity, @ConstantParameter int unrolledLength, @ConstantParameter Counters counters) {</span>
<span class="udiff-line-modified-added">+     public void arraycopyExactStubCallSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck,</span>
<span class="udiff-line-modified-added">+                     @ConstantParameter SnippetInfo workSnippet, @ConstantParameter JavaKind elementKind, @ConstantParameter LocationIdentity locationIdentity,</span>
<span class="udiff-line-added">+                     @ConstantParameter SnippetCounter elementKindCounter, @ConstantParameter SnippetCounter elementKindCopiedCounter, @ConstantParameter Counters counters) {</span>
          Object nonNullSrc = GraalDirectives.guardingNonNull(src);
          Object nonNullDest = GraalDirectives.guardingNonNull(dest);
          checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);
          checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);
          incrementLengthCounter(length, counters);
  
<span class="udiff-line-modified-removed">-         unrolledArraycopyWork(nonNullSrc, srcPos, nonNullDest, destPos, unrolledLength, elementKind, locationIdentity);</span>
<span class="udiff-line-modified-added">+         elementKindCounter.inc();</span>
<span class="udiff-line-added">+         elementKindCopiedCounter.add(length);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ArrayCopyCallNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, elementKind, locationIdentity, heapWordSize());</span>
      }
  
      @Snippet
<span class="udiff-line-modified-removed">-     public void arraycopyCheckcastSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck,</span>
<span class="udiff-line-modified-removed">-                     @ConstantParameter Counters counters, @ConstantParameter SnippetInfo workSnippet, @ConstantParameter JavaKind elementKind) {</span>
<span class="udiff-line-modified-added">+     public void arraycopyCheckcastSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck, @ConstantParameter Counters counters,</span>
<span class="udiff-line-modified-added">+                     @ConstantParameter SnippetInfo workSnippet, @ConstantParameter JavaKind elementKind) {</span>
          Object nonNullSrc = GraalDirectives.guardingNonNull(src);
          Object nonNullDest = GraalDirectives.guardingNonNull(dest);
          checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);
          checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);
          incrementLengthCounter(length, counters);
  
<span class="udiff-line-modified-removed">-         ArrayCopyWithSlowPathNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, workSnippet, elementKind);</span>
<span class="udiff-line-modified-added">+         ArrayCopyWithDelayedLoweringNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, workSnippet, elementKind);</span>
      }
  
      @Snippet
      public void arraycopyGenericSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter ArrayCopyTypeCheck arrayTypeCheck, @ConstantParameter Counters counters,
                      @ConstantParameter SnippetInfo workSnippet, @ConstantParameter JavaKind elementKind) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -164,11 +163,11 @@</span>
          Object nonNullDest = GraalDirectives.guardingNonNull(dest);
          checkArrayTypes(nonNullSrc, nonNullDest, arrayTypeCheck);
          checkLimits(nonNullSrc, srcPos, nonNullDest, destPos, length, counters);
          incrementLengthCounter(length, counters);
  
<span class="udiff-line-modified-removed">-         ArrayCopyWithSlowPathNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, workSnippet, elementKind);</span>
<span class="udiff-line-modified-added">+         ArrayCopyWithDelayedLoweringNode.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, workSnippet, elementKind);</span>
      }
  
      @Snippet
      public static void arraycopyNativeSnippet(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter Counters counters) {
          // all checks are done in the native method, so no need to emit additional checks here
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -177,41 +176,45 @@</span>
          counters.systemArraycopyCopiedCounter.add(length);
  
          System.arraycopy(src, srcPos, dest, destPos, length);
      }
  
<span class="udiff-line-modified-removed">-     private static void unrolledArraycopyWork(Object nonNullSrc, int srcPos, Object nonNullDest, int destPos, int length, JavaKind elementKind, LocationIdentity arrayLocation) {</span>
<span class="udiff-line-modified-added">+     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="udiff-line-added">+     @Snippet(allowPartialIntrinsicArgumentMismatch = true)</span>
<span class="udiff-line-added">+     public void exactArraycopyWithSlowPathWork(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter JavaKind elementKind, @ConstantParameter LocationIdentity arrayLocation,</span>
<span class="udiff-line-added">+                     @ConstantParameter Counters counters) {</span>
          int scale = ReplacementsUtil.arrayIndexScale(INJECTED_META_ACCESS, elementKind);
          int arrayBaseOffset = ReplacementsUtil.getArrayBaseOffset(INJECTED_META_ACCESS, elementKind);
<span class="udiff-line-removed">- </span>
          long sourceOffset = arrayBaseOffset + (long) srcPos * scale;
          long destOffset = arrayBaseOffset + (long) destPos * scale;
<span class="udiff-line-removed">-         long position = 0;</span>
<span class="udiff-line-removed">-         long delta = scale;</span>
<span class="udiff-line-removed">-         if (probability(NOT_FREQUENT_PROBABILITY, nonNullSrc == nonNullDest &amp;&amp; srcPos &lt; destPos)) {</span>
<span class="udiff-line-removed">-             // bad aliased case so we need to copy the array from back to front</span>
<span class="udiff-line-removed">-             position = (long) (length - 1) * scale;</span>
<span class="udiff-line-removed">-             delta = -delta;</span>
<span class="udiff-line-removed">-         }</span>
  
<span class="udiff-line-modified-removed">-         // the length was already checked before - we can emit unconditional instructions</span>
<span class="udiff-line-modified-removed">-         ExplodeLoopNode.explodeLoop();</span>
<span class="udiff-line-modified-removed">-         for (int iteration = 0; iteration &lt; length; iteration++) {</span>
<span class="udiff-line-modified-removed">-             Object value = RawLoadNode.load(nonNullSrc, sourceOffset + position, elementKind, arrayLocation);</span>
<span class="udiff-line-modified-removed">-             RawStoreNode.storeObject(nonNullDest, destOffset + position, value, elementKind, arrayLocation, false);</span>
<span class="udiff-line-modified-removed">-             position += delta;</span>
<span class="udiff-line-modified-added">+         GuardingNode anchor = SnippetAnchorNode.anchor();</span>
<span class="udiff-line-modified-added">+         if (probability(NOT_FREQUENT_PROBABILITY, src == dest &amp;&amp; srcPos &lt; destPos)) {</span>
<span class="udiff-line-modified-added">+             // bad aliased case so we need to copy the array from back to front</span>
<span class="udiff-line-modified-added">+             for (int position = length - 1; position &gt;= 0; position--) {</span>
<span class="udiff-line-modified-added">+                 Object value = GuardedUnsafeLoadNode.guardedLoad(src, sourceOffset + ((long) position) * scale, elementKind, arrayLocation, anchor);</span>
<span class="udiff-line-modified-added">+                 RawStoreNode.storeObject(dest, destOffset + ((long) position) * scale, value, elementKind, arrayLocation, true);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             for (int position = 0; position &lt; length; position++) {</span>
<span class="udiff-line-added">+                 Object value = GuardedUnsafeLoadNode.guardedLoad(src, sourceOffset + ((long) position) * scale, elementKind, arrayLocation, anchor);</span>
<span class="udiff-line-added">+                 RawStoreNode.storeObject(dest, destOffset + ((long) position) * scale, value, elementKind, arrayLocation, true);</span>
<span class="udiff-line-added">+             }</span>
          }
      }
  
<span class="udiff-line-added">+     @SuppressWarnings(&quot;unused&quot;)</span>
      @Snippet(allowPartialIntrinsicArgumentMismatch = true)
<span class="udiff-line-modified-removed">-     public void checkcastArraycopyWithSlowPathWork(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter Counters counters) {</span>
<span class="udiff-line-modified-added">+     public void checkcastArraycopyWithSlowPathWork(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter JavaKind elementKind,</span>
<span class="udiff-line-added">+                     @ConstantParameter LocationIdentity arrayLocation,</span>
<span class="udiff-line-added">+                     @ConstantParameter Counters counters) {</span>
          if (probability(FREQUENT_PROBABILITY, length &gt; 0)) {
              Object nonNullSrc = PiNode.asNonNullObject(src);
              Object nonNullDest = PiNode.asNonNullObject(dest);
              Pointer srcKlass = loadHub(nonNullSrc);
              Pointer destKlass = loadHub(nonNullDest);
<span class="udiff-line-modified-removed">-             if (probability(LIKELY_PROBABILITY, srcKlass == destKlass)) {</span>
<span class="udiff-line-modified-added">+             if (probability(LIKELY_PROBABILITY, srcKlass == destKlass) || probability(LIKELY_PROBABILITY, nonNullDest.getClass() == Object[].class)) {</span>
                  // no storecheck required.
                  counters.objectCheckcastSameTypeCounter.inc();
                  counters.objectCheckcastSameTypeCopiedCounter.add(length);
                  ArrayCopyCallNode.arraycopyObjectKillsAny(nonNullSrc, srcPos, nonNullDest, destPos, length, heapWordSize());
              } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -219,25 +222,20 @@</span>
                  Word superCheckOffset = getSuperCheckOffset(destElemKlass);
  
                  counters.objectCheckcastDifferentTypeCounter.inc();
                  counters.objectCheckcastDifferentTypeCopiedCounter.add(length);
  
<span class="udiff-line-modified-removed">-                 int copiedElements = CheckcastArrayCopyCallNode.checkcastArraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length, superCheckOffset, destElemKlass, false);</span>
<span class="udiff-line-removed">-                 if (probability(SLOW_PATH_PROBABILITY, copiedElements != 0)) {</span>
<span class="udiff-line-removed">-                     /*</span>
<span class="udiff-line-removed">-                      * the stub doesn&#39;t throw the ArrayStoreException, but returns the number of</span>
<span class="udiff-line-removed">-                      * copied elements (xor&#39;d with -1).</span>
<span class="udiff-line-removed">-                      */</span>
<span class="udiff-line-removed">-                     copiedElements ^= -1;</span>
<span class="udiff-line-removed">-                     System.arraycopy(nonNullSrc, srcPos + copiedElements, nonNullDest, destPos + copiedElements, length - copiedElements);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+                 System.arraycopy(nonNullSrc, srcPos, nonNullDest, destPos, length);</span>
              }
          }
      }
  
<span class="udiff-line-added">+     @SuppressWarnings(&quot;unused&quot;)</span>
      @Snippet(allowPartialIntrinsicArgumentMismatch = true)
<span class="udiff-line-modified-removed">-     public void genericArraycopyWithSlowPathWork(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter Counters counters) {</span>
<span class="udiff-line-modified-added">+     public void genericArraycopyWithSlowPathWork(Object src, int srcPos, Object dest, int destPos, int length, @ConstantParameter JavaKind elementKind,</span>
<span class="udiff-line-added">+                     @ConstantParameter LocationIdentity arrayLocation,</span>
<span class="udiff-line-added">+                     @ConstantParameter Counters counters) {</span>
          // The length &gt; 0 check should not be placed here because generic array copy stub should
          // enforce type check. This is fine performance-wise because this snippet is rarely used.
          counters.genericArraycopyDifferentTypeCounter.inc();
          counters.genericArraycopyDifferentTypeCopiedCounter.add(length);
          int copiedElements = GenericArrayCopyCallNode.genericArraycopy(src, srcPos, dest, destPos, length);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -255,16 +253,31 @@</span>
          if (!IS_BUILDING_NATIVE_IMAGE) {
              counters.lengthHistogram.inc(length);
          }
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Writing this as individual if statements to avoid a merge without a frame state.</span>
<span class="udiff-line-added">+      */</span>
      private static void checkLimits(Object src, int srcPos, Object dest, int destPos, int length, Counters counters) {
<span class="udiff-line-modified-removed">-         if (probability(SLOW_PATH_PROBABILITY, srcPos &lt; 0) ||</span>
<span class="udiff-line-modified-removed">-                         probability(SLOW_PATH_PROBABILITY, destPos &lt; 0) ||</span>
<span class="udiff-line-modified-removed">-                         probability(SLOW_PATH_PROBABILITY, length &lt; 0) ||</span>
<span class="udiff-line-modified-removed">-                         probability(SLOW_PATH_PROBABILITY, srcPos &gt; ArrayLengthNode.arrayLength(src) - length) ||</span>
<span class="udiff-line-modified-removed">-                         probability(SLOW_PATH_PROBABILITY, destPos &gt; ArrayLengthNode.arrayLength(dest) - length)) {</span>
<span class="udiff-line-modified-added">+         if (probability(DEOPT_PROBABILITY, srcPos &lt; 0)) {</span>
<span class="udiff-line-modified-added">+             counters.checkAIOOBECounter.inc();</span>
<span class="udiff-line-modified-added">+             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         if (probability(DEOPT_PROBABILITY, destPos &lt; 0)) {</span>
<span class="udiff-line-added">+             counters.checkAIOOBECounter.inc();</span>
<span class="udiff-line-added">+             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (probability(DEOPT_PROBABILITY, length &lt; 0)) {</span>
<span class="udiff-line-added">+             counters.checkAIOOBECounter.inc();</span>
<span class="udiff-line-added">+             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (probability(DEOPT_PROBABILITY, srcPos &gt; ArrayLengthNode.arrayLength(src) - length)) {</span>
<span class="udiff-line-added">+             counters.checkAIOOBECounter.inc();</span>
<span class="udiff-line-added">+             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (probability(DEOPT_PROBABILITY, destPos &gt; ArrayLengthNode.arrayLength(dest) - length)) {</span>
              counters.checkAIOOBECounter.inc();
              DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);
          }
          counters.checkSuccessCounter.inc();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -273,17 +286,17 @@</span>
          if (arrayTypeCheck == ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK) {
              // nothing to do
          } else if (arrayTypeCheck == ArrayCopyTypeCheck.HUB_BASED_ARRAY_TYPE_CHECK) {
              Pointer srcHub = loadHub(nonNullSrc);
              Pointer destHub = loadHub(nonNullDest);
<span class="udiff-line-modified-removed">-             if (probability(SLOW_PATH_PROBABILITY, srcHub != destHub)) {</span>
<span class="udiff-line-modified-added">+             if (probability(DEOPT_PROBABILITY, srcHub != destHub)) {</span>
                  DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);
              }
          } else if (arrayTypeCheck == ArrayCopyTypeCheck.LAYOUT_HELPER_BASED_ARRAY_TYPE_CHECK) {
              Pointer srcHub = loadHub(nonNullSrc);
              Pointer destHub = loadHub(nonNullDest);
<span class="udiff-line-modified-removed">-             if (probability(SLOW_PATH_PROBABILITY, getReadLayoutHelper(srcHub) != getReadLayoutHelper(destHub))) {</span>
<span class="udiff-line-modified-added">+             if (probability(DEOPT_PROBABILITY, getReadLayoutHelper(srcHub) != getReadLayoutHelper(destHub))) {</span>
                  DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.RuntimeConstraint);
              }
          } else {
              ReplacementsUtil.staticAssert(false, &quot;unknown array type check &quot;, arrayTypeCheck);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -350,34 +363,35 @@</span>
          }
      }
  
      public static class Templates extends SnippetTemplate.AbstractTemplates {
          private final SnippetInfo arraycopyGenericSnippet;
<span class="udiff-line-removed">-         private final SnippetInfo arraycopyUnrolledSnippet;</span>
          private final SnippetInfo arraycopyExactSnippet;
<span class="udiff-line-modified-removed">-         private final SnippetInfo arraycopyZeroLengthSnippet;</span>
<span class="udiff-line-modified-added">+         private final SnippetInfo arraycopyExactStubCallSnippet;</span>
          private final SnippetInfo arraycopyCheckcastSnippet;
          private final SnippetInfo arraycopyNativeSnippet;
          private final SnippetInfo checkcastArraycopyWithSlowPathWork;
          private final SnippetInfo genericArraycopyWithSlowPathWork;
<span class="udiff-line-added">+         private final SnippetInfo exactArraycopyWithSlowPathWork;</span>
  
          private ResolvedJavaMethod originalArraycopy;
          private final Counters counters;
<span class="udiff-line-added">+         private boolean expandArraycopyLoop;</span>
  
          public Templates(ArrayCopySnippets receiver, OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, Factory factory, Providers providers,
                          SnippetReflectionProvider snippetReflection, TargetDescription target) {
              super(options, factories, providers, snippetReflection, target);
              this.counters = new Counters(factory);
  
              arraycopyGenericSnippet = snippet(receiver, &quot;arraycopyGenericSnippet&quot;);
<span class="udiff-line-removed">-             arraycopyUnrolledSnippet = snippet(receiver, &quot;arraycopyUnrolledSnippet&quot;);</span>
              arraycopyExactSnippet = snippet(receiver, &quot;arraycopyExactSnippet&quot;);
<span class="udiff-line-modified-removed">-             arraycopyZeroLengthSnippet = snippet(receiver, &quot;arraycopyZeroLengthSnippet&quot;);</span>
<span class="udiff-line-modified-added">+             arraycopyExactStubCallSnippet = snippet(receiver, &quot;arraycopyExactStubCallSnippet&quot;);</span>
              arraycopyCheckcastSnippet = snippet(receiver, &quot;arraycopyCheckcastSnippet&quot;);
              arraycopyNativeSnippet = snippet(null, &quot;arraycopyNativeSnippet&quot;);
              checkcastArraycopyWithSlowPathWork = snippet(receiver, &quot;checkcastArraycopyWithSlowPathWork&quot;);
              genericArraycopyWithSlowPathWork = snippet(receiver, &quot;genericArraycopyWithSlowPathWork&quot;);
<span class="udiff-line-added">+             exactArraycopyWithSlowPathWork = snippet(receiver, &quot;exactArraycopyWithSlowPathWork&quot;);</span>
          }
  
          protected SnippetInfo snippet(ArrayCopySnippets receiver, String methodName) {
              SnippetInfo info = snippet(ArrayCopySnippets.class, methodName, originalArraycopy(), receiver, LocationIdentity.any());
              return info;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -399,17 +413,21 @@</span>
                  ResolvedJavaType srcComponentType = srcType == null ? null : srcType.getComponentType();
                  ResolvedJavaType destComponentType = destType == null ? null : destType.getComponentType();
  
                  if (arraycopy.isExact()) {
                      // there is a sufficient type match - we don&#39;t need any additional type checks
<span class="udiff-line-modified-removed">-                     snippetInfo = arraycopyExactSnippet;</span>
<span class="udiff-line-modified-added">+                     snippetInfo = arraycopyExactStubCallSnippet;</span>
                      arrayTypeCheck = ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK;
                  } else if (srcComponentType == null &amp;&amp; destComponentType == null) {
                      // we don&#39;t know anything about the types - use the generic copying
                      snippetInfo = arraycopyGenericSnippet;
                      // no need for additional type check to avoid duplicated work
                      arrayTypeCheck = ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK;
<span class="udiff-line-added">+                 } else if (GeneratePIC.getValue(options)) {</span>
<span class="udiff-line-added">+                     // use generic copying for AOT compilation</span>
<span class="udiff-line-added">+                     snippetInfo = arraycopyGenericSnippet;</span>
<span class="udiff-line-added">+                     arrayTypeCheck = ArrayCopyTypeCheck.NO_ARRAY_TYPE_CHECK;</span>
                  } else if (srcComponentType != null &amp;&amp; destComponentType != null) {
                      if (!srcComponentType.isPrimitive() &amp;&amp; !destComponentType.isPrimitive()) {
                          // it depends on the array content if the copy succeeds - we need
                          // a type check for every store
                          snippetInfo = arraycopyCheckcastSnippet;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -424,11 +442,11 @@</span>
                  } else {
                      ResolvedJavaType nonNullComponentType = srcComponentType != null ? srcComponentType : destComponentType;
                      if (nonNullComponentType.isPrimitive()) {
                          // one involved object is a primitive array - it is sufficient to directly
                          // compare the hub.
<span class="udiff-line-modified-removed">-                         snippetInfo = arraycopyExactSnippet;</span>
<span class="udiff-line-modified-added">+                         snippetInfo = arraycopyExactStubCallSnippet;</span>
                          arrayTypeCheck = ArrayCopyTypeCheck.HUB_BASED_ARRAY_TYPE_CHECK;
                          elementKind = nonNullComponentType.getJavaKind();
                      } else {
                          // one involved object is an object array - the other array&#39;s element type
                          // may be primitive or object, hence we compare the layout helper.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -436,21 +454,12 @@</span>
                          arrayTypeCheck = ArrayCopyTypeCheck.LAYOUT_HELPER_BASED_ARRAY_TYPE_CHECK;
                      }
                  }
              }
  
<span class="udiff-line-modified-removed">-             // a few special cases that are easier to handle when all other variables already have a</span>
<span class="udiff-line-modified-removed">-             // value</span>
<span class="udiff-line-removed">-             if (snippetInfo != arraycopyNativeSnippet &amp;&amp; snippetInfo != arraycopyGenericSnippet &amp;&amp; arraycopy.getLength().isConstant() &amp;&amp; arraycopy.getLength().asJavaConstant().asLong() == 0) {</span>
<span class="udiff-line-removed">-                 // Copying 0 element between object arrays with conflicting types will not throw an</span>
<span class="udiff-line-removed">-                 // exception - once we pass the preliminary element type checks that we are not</span>
<span class="udiff-line-removed">-                 // mixing arrays of different basic types, ArrayStoreException is only thrown when</span>
<span class="udiff-line-removed">-                 // an *astore would have thrown it. Therefore, copying null between object arrays</span>
<span class="udiff-line-removed">-                 // with conflicting types will also succeed (we do not optimize for such case here).</span>
<span class="udiff-line-removed">-                 snippetInfo = arraycopyZeroLengthSnippet;</span>
<span class="udiff-line-removed">-             } else if (snippetInfo == arraycopyExactSnippet &amp;&amp; shouldUnroll(arraycopy.getLength())) {</span>
<span class="udiff-line-removed">-                 snippetInfo = arraycopyUnrolledSnippet;</span>
<span class="udiff-line-modified-added">+             if (this.expandArraycopyLoop &amp;&amp; snippetInfo == arraycopyExactStubCallSnippet) {</span>
<span class="udiff-line-modified-added">+                 snippetInfo = arraycopyExactSnippet;</span>
              }
  
              // create the snippet
              Arguments args = new Arguments(snippetInfo, arraycopy.graph().getGuardsStage(), tool.getLoweringStage());
              args.add(&quot;src&quot;, arraycopy.getSource());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -461,17 +470,13 @@</span>
              if (snippetInfo != arraycopyNativeSnippet) {
                  assert arrayTypeCheck != ArrayCopyTypeCheck.UNDEFINED_ARRAY_TYPE_CHECK;
                  args.addConst(&quot;arrayTypeCheck&quot;, arrayTypeCheck);
              }
              Object locationIdentity = arraycopy.killsAnyLocation() ? LocationIdentity.any() : NamedLocationIdentity.getArrayLocation(elementKind);
<span class="udiff-line-modified-removed">-             if (snippetInfo == arraycopyUnrolledSnippet) {</span>
<span class="udiff-line-removed">-                 args.addConst(&quot;elementKind&quot;, elementKind != null ? elementKind : JavaKind.Illegal);</span>
<span class="udiff-line-removed">-                 args.addConst(&quot;locationIdentity&quot;, locationIdentity);</span>
<span class="udiff-line-removed">-                 args.addConst(&quot;unrolledLength&quot;, arraycopy.getLength().asJavaConstant().asInt());</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if (snippetInfo == arraycopyExactSnippet) {</span>
<span class="udiff-line-modified-added">+             if (snippetInfo == arraycopyExactStubCallSnippet || snippetInfo == arraycopyExactSnippet) {</span>
                  assert elementKind != null;
<span class="udiff-line-added">+                 args.addConst(&quot;workSnippet&quot;, exactArraycopyWithSlowPathWork);</span>
                  args.addConst(&quot;elementKind&quot;, elementKind);
                  args.addConst(&quot;locationIdentity&quot;, locationIdentity);
                  args.addConst(&quot;elementKindCounter&quot;, counters.arraycopyCallCounters.get(elementKind));
                  args.addConst(&quot;elementKindCopiedCounter&quot;, counters.arraycopyCallCopiedCounters.get(elementKind));
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -486,24 +491,38 @@</span>
              }
  
              instantiate(args, arraycopy);
          }
  
<span class="udiff-line-modified-removed">-         public void lower(ArrayCopyWithSlowPathNode arraycopy, LoweringTool tool) {</span>
<span class="udiff-line-modified-added">+         public void lower(ArrayCopyWithDelayedLoweringNode arraycopy, LoweringTool tool) {</span>
              StructuredGraph graph = arraycopy.graph();
<span class="udiff-line-modified-removed">-             if (!graph.getGuardsStage().areFrameStatesAtDeopts()) {</span>
<span class="udiff-line-modified-removed">-                 // if an arraycopy contains a slow path, we can&#39;t lower it right away</span>
<span class="udiff-line-modified-removed">-                 return;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             if (arraycopy.getSnippet() == exactArraycopyWithSlowPathWork &amp;&amp; this.expandArraycopyLoop) {</span>
<span class="udiff-line-modified-added">+                 if (!graph.getGuardsStage().areDeoptsFixed()) {</span>
<span class="udiff-line-added">+                     // Don&#39;t lower until floating guards are fixed.</span>
<span class="udiff-line-added">+                     return;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 if (!graph.getGuardsStage().areFrameStatesAtDeopts()) {</span>
<span class="udiff-line-added">+                     // Don&#39;t lower until frame states are assigned to deoptimization points.</span>
<span class="udiff-line-added">+                     return;</span>
<span class="udiff-line-added">+                 }</span>
              }
  
              SnippetInfo snippetInfo = arraycopy.getSnippet();
              Arguments args = new Arguments(snippetInfo, graph.getGuardsStage(), tool.getLoweringStage());
              args.add(&quot;src&quot;, arraycopy.getSource());
              args.add(&quot;srcPos&quot;, arraycopy.getSourcePosition());
              args.add(&quot;dest&quot;, arraycopy.getDestination());
              args.add(&quot;destPos&quot;, arraycopy.getDestinationPosition());
              args.add(&quot;length&quot;, arraycopy.getLength());
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             JavaKind elementKind = arraycopy.getElementKind();</span>
<span class="udiff-line-added">+             args.addConst(&quot;elementKind&quot;, (elementKind == null) ? JavaKind.Illegal : elementKind);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             Object locationIdentity = (elementKind == null) ? LocationIdentity.any() : NamedLocationIdentity.getArrayLocation(arraycopy.getElementKind());</span>
<span class="udiff-line-added">+             args.addConst(&quot;arrayLocation&quot;, locationIdentity);</span>
              args.addConst(&quot;counters&quot;, counters);
              instantiate(args, arraycopy);
          }
  
          private static boolean canBeArray(ResolvedJavaType type) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -524,14 +543,10 @@</span>
                  return null;
              }
              return srcType.getComponentType().getJavaKind();
          }
  
<span class="udiff-line-removed">-         private static boolean shouldUnroll(ValueNode length) {</span>
<span class="udiff-line-removed">-             return length.isConstant() &amp;&amp; length.asJavaConstant().asInt() &lt;= 8 &amp;&amp; length.asJavaConstant().asInt() != 0;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
          /**
           * Instantiate the snippet template and fix up the FrameState of any Invokes of
           * System.arraycopy and propagate the captured bci in the ArrayCopySlowPathNode.
           *
           * @param args
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -549,23 +564,23 @@</span>
  
                      if (!call.targetMethod().equals(originalArraycopy)) {
                          throw new GraalError(&quot;unexpected invoke %s in snippet&quot;, call.targetMethod());
                      }
                      // Here we need to fix the bci of the invoke
<span class="udiff-line-modified-removed">-                     InvokeNode newInvoke = invoke.replaceWithNewBci(arraycopy.getBci());</span>
<span class="udiff-line-modified-removed">-                     newInvoke.setStateDuring(null);</span>
<span class="udiff-line-modified-removed">-                     newInvoke.setStateAfter(null);</span>
<span class="udiff-line-modified-added">+                     invoke.replaceBci(arraycopy.getBci());</span>
<span class="udiff-line-modified-added">+                     invoke.setStateDuring(null);</span>
<span class="udiff-line-modified-added">+                     invoke.setStateAfter(null);</span>
                      if (arraycopy.stateDuring() != null) {
<span class="udiff-line-modified-removed">-                         newInvoke.setStateDuring(arraycopy.stateDuring());</span>
<span class="udiff-line-modified-added">+                         invoke.setStateDuring(arraycopy.stateDuring());</span>
                      } else {
                          assert arraycopy.stateAfter() != null : arraycopy;
<span class="udiff-line-modified-removed">-                         newInvoke.setStateAfter(arraycopy.stateAfter());</span>
<span class="udiff-line-modified-added">+                         invoke.setStateAfter(arraycopy.stateAfter());</span>
                      }
                  } else if (originalNode instanceof InvokeWithExceptionNode) {
                      throw new GraalError(&quot;unexpected invoke with exception %s in snippet&quot;, originalNode);
<span class="udiff-line-modified-removed">-                 } else if (originalNode instanceof ArrayCopyWithSlowPathNode) {</span>
<span class="udiff-line-modified-removed">-                     ArrayCopyWithSlowPathNode slowPath = (ArrayCopyWithSlowPathNode) replacements.get(originalNode);</span>
<span class="udiff-line-modified-added">+                 } else if (originalNode instanceof ArrayCopyWithDelayedLoweringNode) {</span>
<span class="udiff-line-modified-added">+                     ArrayCopyWithDelayedLoweringNode slowPath = (ArrayCopyWithDelayedLoweringNode) replacements.get(originalNode);</span>
                      assert arraycopy.stateAfter() != null : arraycopy;
                      assert slowPath.stateAfter() == arraycopy.stateAfter();
                      slowPath.setBci(arraycopy.getBci());
                  }
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -580,7 +595,11 @@</span>
                      throw new GraalError(e);
                  }
              }
              return originalArraycopy;
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public void setExpandArraycopyLoop(boolean b) {</span>
<span class="udiff-line-added">+             this.expandArraycopyLoop = b;</span>
<span class="udiff-line-added">+         }</span>
      }
  }
</pre>
<center><a href="ArrayCopyNode.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CheckcastArrayCopyCallNode.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
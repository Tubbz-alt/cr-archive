<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/ReplacementsImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements;
 26 
 27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
 28 import static org.graalvm.compiler.core.common.GraalOptions.UseSnippetGraphCache;
 29 import static org.graalvm.compiler.debug.DebugContext.DEFAULT_LOG_STREAM;
<a name="2" id="anc2"></a><span class="line-added"> 30 import static org.graalvm.compiler.debug.DebugOptions.DebugStubsAndSnippets;</span>
 31 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
 32 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineIntrinsicsDuringParsing;
 33 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;
<a name="3" id="anc3"></a><span class="line-added"> 34 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createMethodSubstitutionInlineInfo;</span>
 35 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;
 36 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION;
 37 import static org.graalvm.compiler.phases.common.DeadCodeEliminationPhase.Optionality.Required;
 38 
 39 import java.util.Collections;
 40 import java.util.List;
 41 import java.util.concurrent.ConcurrentHashMap;
 42 import java.util.concurrent.ConcurrentMap;
 43 import java.util.concurrent.atomic.AtomicInteger;
 44 
 45 import jdk.internal.vm.compiler.collections.EconomicMap;
 46 import jdk.internal.vm.compiler.collections.Equivalence;
 47 import org.graalvm.compiler.api.replacements.Fold;
 48 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 49 import org.graalvm.compiler.api.replacements.Snippet;
 50 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 51 import org.graalvm.compiler.api.replacements.SnippetTemplateCache;
 52 import org.graalvm.compiler.bytecode.Bytecode;
 53 import org.graalvm.compiler.bytecode.BytecodeProvider;
 54 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
 55 import org.graalvm.compiler.core.common.CompilationIdentifier;
 56 import org.graalvm.compiler.core.common.GraalOptions;
<a name="4" id="anc4"></a>
 57 import org.graalvm.compiler.debug.DebugCloseable;
 58 import org.graalvm.compiler.debug.DebugContext;
 59 import org.graalvm.compiler.debug.DebugContext.Description;
 60 import org.graalvm.compiler.debug.DebugHandlersFactory;
 61 import org.graalvm.compiler.debug.GraalError;
 62 import org.graalvm.compiler.debug.TimerKey;
 63 import org.graalvm.compiler.graph.Node;
 64 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 65 import org.graalvm.compiler.graph.NodeSourcePosition;
 66 import org.graalvm.compiler.java.GraphBuilderPhase;
 67 import org.graalvm.compiler.java.GraphBuilderPhase.Instance;
<a name="5" id="anc5"></a><span class="line-added"> 68 import org.graalvm.compiler.loop.phases.ConvertDeoptimizeToGuardPhase;</span>
 69 import org.graalvm.compiler.nodes.CallTargetNode;
<a name="6" id="anc6"></a><span class="line-added"> 70 import org.graalvm.compiler.nodes.Cancellable;</span>
 71 import org.graalvm.compiler.nodes.Invoke;
 72 import org.graalvm.compiler.nodes.StateSplit;
 73 import org.graalvm.compiler.nodes.StructuredGraph;
 74 import org.graalvm.compiler.nodes.ValueNode;
 75 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedInvocationPlugin;
 76 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 77 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 78 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 79 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderPlugin;
 80 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 81 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 82 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 83 import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
 84 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 85 import org.graalvm.compiler.nodes.spi.Replacements;
<a name="7" id="anc7"></a>



 86 import org.graalvm.compiler.options.OptionValues;
 87 import org.graalvm.compiler.phases.OptimisticOptimizations;
 88 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
<a name="8" id="anc8"></a>
 89 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
<a name="9" id="anc9"></a>
 90 import org.graalvm.compiler.phases.util.Providers;
 91 import org.graalvm.compiler.word.Word;
 92 import org.graalvm.compiler.word.WordOperationPlugin;
 93 
 94 import jdk.vm.ci.code.TargetDescription;
<a name="10" id="anc10"></a>
 95 import jdk.vm.ci.meta.MetaAccessProvider;
 96 import jdk.vm.ci.meta.ResolvedJavaMethod;
 97 import jdk.vm.ci.meta.ResolvedJavaType;
 98 
 99 public class ReplacementsImpl implements Replacements, InlineInvokePlugin {
100 
<a name="11" id="anc11"></a><span class="line-modified">101     @Override</span>








102     public Providers getProviders() {
103         return providers;
104     }
105 
106     public void setProviders(Providers providers) {
107         this.providers = providers.copyWith(this);
108     }
109 
110     protected Providers providers;
111     public final SnippetReflectionProvider snippetReflection;
112     public final TargetDescription target;
113     private GraphBuilderConfiguration.Plugins graphBuilderPlugins;
114     private final DebugHandlersFactory debugHandlersFactory;
115 
<a name="12" id="anc12"></a>




116     /**
117      * The preprocessed replacement graphs.
118      */
119     protected final ConcurrentMap&lt;ResolvedJavaMethod, StructuredGraph&gt; graphs;
120 
121     /**
122      * The default {@link BytecodeProvider} to use for accessing the bytecode of a replacement if
123      * the replacement doesn&#39;t provide another {@link BytecodeProvider}.
124      */
125     protected final BytecodeProvider defaultBytecodeProvider;
126 
127     public void setGraphBuilderPlugins(GraphBuilderConfiguration.Plugins plugins) {
128         assert this.graphBuilderPlugins == null;
129         this.graphBuilderPlugins = plugins;
130     }
131 
132     @Override
133     public GraphBuilderConfiguration.Plugins getGraphBuilderPlugins() {
134         return graphBuilderPlugins;
135     }
136 
137     @Override
138     public Class&lt;? extends GraphBuilderPlugin&gt; getIntrinsifyingPlugin(ResolvedJavaMethod method) {
139         if (method.getAnnotation(Node.NodeIntrinsic.class) != null || method.getAnnotation(Fold.class) != null) {
140             return GeneratedInvocationPlugin.class;
141         }
142         if (method.getAnnotation(Word.Operation.class) != null) {
143             return WordOperationPlugin.class;
144         }
145         return null;
146     }
147 
148     private static final int MAX_GRAPH_INLINING_DEPTH = 100; // more than enough
149 
150     /**
151      * Determines whether a given method should be inlined based on whether it has a substitution or
152      * whether the inlining context is already within a substitution.
153      *
154      * @return an object specifying how {@code method} is to be inlined or null if it should not be
155      *         inlined based on substitution related criteria
156      */
157     @Override
158     public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
<a name="13" id="anc13"></a><span class="line-modified">159         MethodSubstitutionPlugin msPlugin = getMethodSubstitution(method);</span>
<span class="line-modified">160         if (msPlugin != null) {</span>
161             if (b.parsingIntrinsic() || InlineDuringParsing.getValue(b.getOptions()) || InlineIntrinsicsDuringParsing.getValue(b.getOptions())) {
162                 // Forced inlining of intrinsics
<a name="14" id="anc14"></a><span class="line-modified">163                 return createMethodSubstitutionInlineInfo(method, msPlugin);</span>
164             }
165             return null;
166         }
167         if (b.parsingIntrinsic()) {
168             assert b.getDepth() &lt; MAX_GRAPH_INLINING_DEPTH : &quot;inlining limit exceeded&quot;;
169 
170             // Force inlining when parsing replacements
<a name="15" id="anc15"></a><span class="line-modified">171             return createIntrinsicInlineInfo(method, defaultBytecodeProvider);</span>
172         } else {
173             assert IS_BUILDING_NATIVE_IMAGE || method.getAnnotation(NodeIntrinsic.class) == null : String.format(&quot;@%s method %s must only be called from within a replacement%n%s&quot;,
174                             NodeIntrinsic.class.getSimpleName(),
175                             method.format(&quot;%h.%n&quot;), b);
176         }
177         return null;
178     }
179 
180     @Override
181     public void notifyNotInlined(GraphBuilderContext b, ResolvedJavaMethod method, Invoke invoke) {
182         if (b.parsingIntrinsic()) {
183             IntrinsicContext intrinsic = b.getIntrinsic();
184             if (!intrinsic.isCallToOriginal(method)) {
185                 Class&lt;? extends GraphBuilderPlugin&gt; pluginClass = getIntrinsifyingPlugin(method);
186                 if (pluginClass != null) {
187                     String methodDesc = method.format(&quot;%H.%n(%p)&quot;);
188                     throw new GraalError(&quot;Call to %s should have been intrinsified by a %s. &quot; +
189                                     &quot;This is typically caused by Eclipse failing to run an annotation &quot; +
190                                     &quot;processor. This can usually be fixed by forcing Eclipse to rebuild &quot; +
191                                     &quot;the source file in which %s is declared&quot;,
192                                     methodDesc, pluginClass.getSimpleName(), methodDesc);
193                 }
194                 throw new GraalError(&quot;All non-recursive calls in the intrinsic %s must be inlined or intrinsified: found call to %s&quot;,
195                                 intrinsic.getIntrinsicMethod().format(&quot;%H.%n(%p)&quot;), method.format(&quot;%h.%n(%p)&quot;));
196             }
197         }
198     }
199 
200     // This map is key&#39;ed by a class name instead of a Class object so that
201     // it is stable across VM executions (in support of replay compilation).
202     private final EconomicMap&lt;String, SnippetTemplateCache&gt; snippetTemplateCache;
203 
<a name="16" id="anc16"></a><span class="line-modified">204     public ReplacementsImpl(DebugHandlersFactory debugHandlersFactory, Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider,</span>
205                     TargetDescription target) {
<a name="17" id="anc17"></a>
206         this.providers = providers.copyWith(this);
207         this.snippetReflection = snippetReflection;
208         this.target = target;
209         this.graphs = new ConcurrentHashMap&lt;&gt;();
210         this.snippetTemplateCache = EconomicMap.create(Equivalence.DEFAULT);
211         this.defaultBytecodeProvider = bytecodeProvider;
212         this.debugHandlersFactory = debugHandlersFactory;
213 
214     }
215 
216     private static final TimerKey SnippetPreparationTime = DebugContext.timer(&quot;SnippetPreparationTime&quot;);
217 
218     private static final AtomicInteger nextDebugContextId = new AtomicInteger();
219 
<a name="18" id="anc18"></a><span class="line-modified">220     public DebugContext openDebugContext(String idPrefix, ResolvedJavaMethod method, OptionValues options) {</span>
<span class="line-modified">221         if (DebugStubsAndSnippets.getValue(options)) {</span>
<span class="line-modified">222             DebugContext outer = DebugContext.forCurrentThread();</span>
<span class="line-modified">223             Description description = new Description(method, idPrefix + nextDebugContextId.incrementAndGet());</span>
<span class="line-modified">224             List&lt;DebugHandlersFactory&gt; factories = debugHandlersFactory == null ? Collections.emptyList() : Collections.singletonList(debugHandlersFactory);</span>
<span class="line-added">225             return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, factories);</span>
<span class="line-added">226         }</span>
<span class="line-added">227         return DebugContext.disabled(options);</span>
228     }
229 
230     @Override
231     @SuppressWarnings(&quot;try&quot;)
<a name="19" id="anc19"></a><span class="line-modified">232     public StructuredGraph getSnippet(ResolvedJavaMethod method, ResolvedJavaMethod recursiveEntry, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition,</span>
<span class="line-added">233                     OptionValues options) {</span>
234         assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
235         assert method.hasBytecodes() : &quot;Snippet must not be abstract or native&quot;;
236 
237         StructuredGraph graph = UseSnippetGraphCache.getValue(options) ? graphs.get(method) : null;
238         if (graph == null || (trackNodeSourcePosition &amp;&amp; !graph.trackNodeSourcePosition())) {
<a name="20" id="anc20"></a><span class="line-modified">239             try (DebugContext debug = openDebugContext(&quot;Snippet_&quot;, method, options);</span>
240                             DebugCloseable a = SnippetPreparationTime.start(debug)) {
<a name="21" id="anc21"></a><span class="line-modified">241                 StructuredGraph newGraph = makeGraph(debug, defaultBytecodeProvider, method, args, recursiveEntry, trackNodeSourcePosition, replaceePosition, INLINE_AFTER_PARSING);</span>
242                 DebugContext.counter(&quot;SnippetNodeCount[%#s]&quot;, method).add(newGraph.getDebug(), newGraph.getNodeCount());
243                 if (!UseSnippetGraphCache.getValue(options) || args != null) {
244                     return newGraph;
245                 }
246                 newGraph.freeze();
247                 if (graph != null) {
248                     graphs.replace(method, graph, newGraph);
249                 } else {
250                     graphs.putIfAbsent(method, newGraph);
251                 }
252                 graph = graphs.get(method);
253             }
254         }
255         assert !trackNodeSourcePosition || graph.trackNodeSourcePosition();
256         return graph;
257     }
258 
259     @Override
<a name="22" id="anc22"></a><span class="line-modified">260     public void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition, OptionValues options) {</span>
261         // No initialization needed as snippet graphs are created on demand in getSnippet
262     }
263 
<a name="23" id="anc23"></a><span class="line-added">264     @Override</span>
<span class="line-added">265     public StructuredGraph getMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, IntrinsicContext.CompilationContext context,</span>
<span class="line-added">266                     StructuredGraph.AllowAssumptions allowAssumptions, Cancellable cancellable, OptionValues options) {</span>
<span class="line-added">267         // Method substitutions are parsed by the BytecodeParser.</span>
<span class="line-added">268         return null;</span>
<span class="line-added">269     }</span>
<span class="line-added">270 </span>
<span class="line-added">271     @Override</span>
<span class="line-added">272     public void registerMethodSubstitution(MethodSubstitutionPlugin plugin) {</span>
<span class="line-added">273         // No initialization needed as method substitutions are parsed by the BytecodeParser.</span>
<span class="line-added">274     }</span>
<span class="line-added">275 </span>
<span class="line-added">276     @Override</span>
<span class="line-added">277     public void registerConditionalPlugin(InvocationPlugin plugin) {</span>
<span class="line-added">278     }</span>
<span class="line-added">279 </span>
280     @Override
281     public boolean hasSubstitution(ResolvedJavaMethod method, int invokeBci) {
282         InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
283         return plugin != null &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0);
284     }
285 
286     @Override
287     public BytecodeProvider getDefaultReplacementBytecodeProvider() {
288         return defaultBytecodeProvider;
289     }
290 
<a name="24" id="anc24"></a><span class="line-modified">291     protected MethodSubstitutionPlugin getMethodSubstitution(ResolvedJavaMethod method) {</span>

292         InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
293         if (plugin instanceof MethodSubstitutionPlugin) {
294             MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;
<a name="25" id="anc25"></a><span class="line-modified">295             return msPlugin;</span>

296         }
297         return null;
298     }
299 
300     @Override
<a name="26" id="anc26"></a><span class="line-modified">301     public StructuredGraph getSubstitution(ResolvedJavaMethod method, int invokeBci, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition, OptionValues options) {</span>
302         StructuredGraph result;
303         InvocationPlugin plugin = graphBuilderPlugins.getInvocationPlugins().lookupInvocation(method);
304         if (plugin != null &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0)) {
305             MetaAccessProvider metaAccess = providers.getMetaAccess();
306             if (plugin instanceof MethodSubstitutionPlugin) {
307                 MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;
308                 ResolvedJavaMethod substitute = msPlugin.getSubstitute(metaAccess);
309                 StructuredGraph graph = UseSnippetGraphCache.getValue(options) ? graphs.get(substitute) : null;
310                 if (graph == null || graph.trackNodeSourcePosition() != trackNodeSourcePosition) {
<a name="27" id="anc27"></a><span class="line-modified">311                     try (DebugContext debug = openDebugContext(&quot;Substitution_&quot;, method, options)) {</span>
<span class="line-modified">312                         graph = makeGraph(debug, msPlugin.getBytecodeProvider(), substitute, null, method, trackNodeSourcePosition, replaceePosition, INLINE_AFTER_PARSING);</span>
313                         if (!UseSnippetGraphCache.getValue(options)) {
314                             return graph;
315                         }
316                         graph.freeze();
317                         graphs.putIfAbsent(substitute, graph);
318                         graph = graphs.get(substitute);
319                     }
320                 }
321                 assert graph.isFrozen();
322                 result = graph;
323             } else {
324                 Bytecode code = new ResolvedJavaMethodBytecode(method);
<a name="28" id="anc28"></a><span class="line-modified">325                 try (DebugContext debug = openDebugContext(&quot;Substitution_&quot;, method, options)) {</span>
<span class="line-modified">326                     result = new IntrinsicGraphBuilder(options, debug, providers, code, invokeBci).buildGraph(plugin);</span>



327                 }
328             }
329         } else {
330             result = null;
331         }
332         return result;
333     }
334 
335     @SuppressWarnings(&quot;try&quot;)
336     @Override
<a name="29" id="anc29"></a><span class="line-modified">337     public StructuredGraph getIntrinsicGraph(ResolvedJavaMethod method, CompilationIdentifier compilationId, DebugContext debug, Cancellable cancellable) {</span>
<span class="line-modified">338         MethodSubstitutionPlugin msPlugin = getMethodSubstitution(method);</span>
<span class="line-modified">339         if (msPlugin != null) {</span>
<span class="line-modified">340             ResolvedJavaMethod substMethod = msPlugin.getSubstitute(providers.getMetaAccess());</span>
341             assert !substMethod.equals(method);
<a name="30" id="anc30"></a><span class="line-modified">342             BytecodeProvider bytecodeProvider = msPlugin.getBytecodeProvider();</span>
343             // @formatter:off
<a name="31" id="anc31"></a><span class="line-modified">344             StructuredGraph graph = new StructuredGraph.Builder(debug.getOptions(), debug, StructuredGraph.AllowAssumptions.YES).</span>
345                     method(substMethod).
346                     compilationId(compilationId).
347                     recordInlinedMethods(bytecodeProvider.shouldRecordMethodDependencies()).
348                     setIsSubstitution(true).
349                     build();
350             // @formatter:on
351             try (DebugContext.Scope scope = debug.scope(&quot;GetIntrinsicGraph&quot;, graph)) {
352                 Plugins plugins = new Plugins(getGraphBuilderPlugins());
353                 GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);
354                 IntrinsicContext initialReplacementContext = new IntrinsicContext(method, substMethod, bytecodeProvider, ROOT_COMPILATION);
<a name="32" id="anc32"></a><span class="line-modified">355                 new GraphBuilderPhase.Instance(providers, config, OptimisticOptimizations.NONE, initialReplacementContext).apply(graph);</span>

356                 assert !graph.isFrozen();
357                 return graph;
358             } catch (Throwable e) {
359                 debug.handle(e);
360             }
361         }
362         return null;
363     }
364 
365     /**
366      * Creates a preprocessed graph for a snippet or method substitution.
367      *
368      * @param bytecodeProvider how to access the bytecode of {@code method}
369      * @param method the snippet or method substitution for which a graph will be created
370      * @param args
371      * @param original the original method if {@code method} is a {@linkplain MethodSubstitution
372      *            substitution} otherwise null
<a name="33" id="anc33"></a><span class="line-modified">373      * @param trackNodeSourcePosition record source information</span>
<span class="line-added">374      * @param context</span>
<span class="line-added">375      *            {@link org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext</span>
<span class="line-added">376      *            compilation context} for the graph</span>
377      */
378     public StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, ResolvedJavaMethod method, Object[] args, ResolvedJavaMethod original, boolean trackNodeSourcePosition,
<a name="34" id="anc34"></a><span class="line-modified">379                     NodeSourcePosition replaceePosition, IntrinsicContext.CompilationContext context) {</span>
<span class="line-modified">380         return createGraphMaker(method, original).makeGraph(debug, bytecodeProvider, args, trackNodeSourcePosition, replaceePosition, context);</span>
<span class="line-added">381     }</span>
<span class="line-added">382 </span>
<span class="line-added">383     /**</span>
<span class="line-added">384      * Creates a preprocessed graph for a snippet or method substitution with a context of .</span>
<span class="line-added">385      * {@link org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext#INLINE_AFTER_PARSING}</span>
<span class="line-added">386      * .</span>
<span class="line-added">387      *</span>
<span class="line-added">388      *</span>
<span class="line-added">389      * @param bytecodeProvider how to access the bytecode of {@code method}</span>
<span class="line-added">390      * @param method the snippet or method substitution for which a graph will be created</span>
<span class="line-added">391      * @param args</span>
<span class="line-added">392      * @param original the original method if {@code method} is a {@linkplain MethodSubstitution</span>
<span class="line-added">393      *            substitution} otherwise null</span>
<span class="line-added">394      * @param trackNodeSourcePosition record source information</span>
<span class="line-added">395      */</span>
<span class="line-added">396     public final StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, ResolvedJavaMethod method, Object[] args, ResolvedJavaMethod original,</span>
<span class="line-added">397                     boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>
<span class="line-added">398         return makeGraph(debug, bytecodeProvider, method, args, original, trackNodeSourcePosition, replaceePosition, INLINE_AFTER_PARSING);</span>
399     }
400 
401     /**
402      * Can be overridden to return an object that specializes various parts of graph preprocessing.
403      */
404     protected GraphMaker createGraphMaker(ResolvedJavaMethod substitute, ResolvedJavaMethod original) {
405         return new GraphMaker(this, substitute, original);
406     }
407 
408     /**
409      * Creates and preprocesses a graph for a replacement.
410      */
411     public static class GraphMaker {
412 
413         /** The replacements object that the graphs are created for. */
414         protected final ReplacementsImpl replacements;
415 
416         /**
417          * The method for which a graph is being created.
418          */
419         protected final ResolvedJavaMethod method;
420 
421         /**
422          * The original method which {@link #method} is substituting. Calls to {@link #method} or
423          * {@link #substitutedMethod} will be replaced with a forced inline of
424          * {@link #substitutedMethod}.
425          */
426         protected final ResolvedJavaMethod substitutedMethod;
427 
428         public GraphMaker(ReplacementsImpl replacements, ResolvedJavaMethod substitute, ResolvedJavaMethod substitutedMethod) {
429             this.replacements = replacements;
430             this.method = substitute;
431             this.substitutedMethod = substitutedMethod;
432         }
433 
434         @SuppressWarnings(&quot;try&quot;)
<a name="35" id="anc35"></a><span class="line-modified">435         public StructuredGraph makeGraph(DebugContext debug, BytecodeProvider bytecodeProvider, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition,</span>
<span class="line-added">436                         IntrinsicContext.CompilationContext context) {</span>
437             try (DebugContext.Scope s = debug.scope(&quot;BuildSnippetGraph&quot;, method)) {
438                 assert method.hasBytecodes() : method;
<a name="36" id="anc36"></a><span class="line-modified">439                 StructuredGraph graph = buildInitialGraph(debug, bytecodeProvider, method, args, trackNodeSourcePosition, replaceePosition, context);</span>
440 
441                 finalizeGraph(graph);
442 
443                 debug.dump(DebugContext.INFO_LEVEL, graph, &quot;%s: Final&quot;, method.getName());
444 
445                 return graph;
446             } catch (Throwable e) {
447                 throw debug.handle(e);
448             }
449         }
450 
451         /**
452          * Does final processing of a snippet graph.
453          */
454         protected void finalizeGraph(StructuredGraph graph) {
<a name="37" id="anc37"></a><span class="line-modified">455             if (!GraalOptions.SnippetCounters.getValue(graph.getOptions()) || graph.getNodes().filter(SnippetCounterNode.class).isEmpty()) {</span>
456                 int sideEffectCount = 0;
457                 assert (sideEffectCount = graph.getNodes().filter(e -&gt; hasSideEffect(e)).count()) &gt;= 0;
458                 new ConvertDeoptimizeToGuardPhase().apply(graph, null);
459                 assert sideEffectCount == graph.getNodes().filter(e -&gt; hasSideEffect(e)).count() : &quot;deleted side effecting node&quot;;
460 
461                 new DeadCodeEliminationPhase(Required).apply(graph);
462             } else {
463                 // ConvertDeoptimizeToGuardPhase will eliminate snippet counters on paths
464                 // that terminate in a deopt so we disable it if the graph contains
465                 // snippet counters. The trade off is that we miss out on guard
466                 // coalescing opportunities.
467             }
468         }
469 
470         /**
471          * Filter nodes which have side effects and shouldn&#39;t be deleted from snippets when
472          * converting deoptimizations to guards. Currently this only allows exception constructors
473          * to be eliminated to cover the case when Java assertions are in the inlined code.
474          *
475          * @param node
476          * @return true for nodes that have side effects and are unsafe to delete
477          */
478         private boolean hasSideEffect(Node node) {
479             if (node instanceof StateSplit) {
480                 if (((StateSplit) node).hasSideEffect()) {
481                     if (node instanceof Invoke) {
482                         CallTargetNode callTarget = ((Invoke) node).callTarget();
483                         if (callTarget instanceof MethodCallTargetNode) {
484                             ResolvedJavaMethod targetMethod = ((MethodCallTargetNode) callTarget).targetMethod();
485                             if (targetMethod.isConstructor()) {
486                                 ResolvedJavaType throwableType = replacements.providers.getMetaAccess().lookupJavaType(Throwable.class);
487                                 return !throwableType.isAssignableFrom(targetMethod.getDeclaringClass());
488                             }
489                         }
490                     }
491                     // Not an exception constructor call
492                     return true;
493                 }
494             }
495             // Not a StateSplit
496             return false;
497         }
498 
<a name="38" id="anc38"></a><span class="line-added">499         static class EncodedIntrinsicContext extends IntrinsicContext {</span>
<span class="line-added">500             EncodedIntrinsicContext(ResolvedJavaMethod method, ResolvedJavaMethod intrinsic, BytecodeProvider bytecodeProvider, CompilationContext compilationContext,</span>
<span class="line-added">501                             boolean allowPartialIntrinsicArgumentMismatch) {</span>
<span class="line-added">502                 super(method, intrinsic, bytecodeProvider, compilationContext, allowPartialIntrinsicArgumentMismatch);</span>
<span class="line-added">503             }</span>
<span class="line-added">504 </span>
<span class="line-added">505             @Override</span>
<span class="line-added">506             public boolean isDeferredInvoke(StateSplit stateSplit) {</span>
<span class="line-added">507                 if (stateSplit instanceof Invoke) {</span>
<span class="line-added">508                     Invoke invoke = (Invoke) stateSplit;</span>
<span class="line-added">509                     ResolvedJavaMethod method = invoke.callTarget().targetMethod();</span>
<span class="line-added">510                     if (method.getAnnotation(Fold.class) != null) {</span>
<span class="line-added">511                         return true;</span>
<span class="line-added">512                     }</span>
<span class="line-added">513                     Node.NodeIntrinsic annotation = method.getAnnotation(Node.NodeIntrinsic.class);</span>
<span class="line-added">514                     if (annotation != null &amp;&amp; !annotation.hasSideEffect()) {</span>
<span class="line-added">515                         return true;</span>
<span class="line-added">516                     }</span>
<span class="line-added">517                 }</span>
<span class="line-added">518                 return false;</span>
<span class="line-added">519             }</span>
<span class="line-added">520         }</span>
<span class="line-added">521 </span>
522         /**
523          * Builds the initial graph for a replacement.
524          */
525         @SuppressWarnings(&quot;try&quot;)
526         protected StructuredGraph buildInitialGraph(DebugContext debug, BytecodeProvider bytecodeProvider, final ResolvedJavaMethod methodToParse, Object[] args, boolean trackNodeSourcePosition,
<a name="39" id="anc39"></a><span class="line-modified">527                         NodeSourcePosition replaceePosition, IntrinsicContext.CompilationContext context) {</span>
528             // @formatter:off
529             // Replacements cannot have optimistic assumptions since they have
530             // to be valid for the entire run of the VM.
<a name="40" id="anc40"></a><span class="line-modified">531             final StructuredGraph graph = new StructuredGraph.Builder(debug.getOptions(), debug).</span>
532                             method(methodToParse).
533                             trackNodeSourcePosition(trackNodeSourcePosition).
534                             callerContext(replaceePosition).
535                             setIsSubstitution(true).
536                             build();
537             // @formatter:on
538 
539             // Replacements are not user code so they do not participate in unsafe access
540             // tracking
541             graph.disableUnsafeAccessTracking();
542 
543             try (DebugContext.Scope s = debug.scope(&quot;buildInitialGraph&quot;, graph)) {
544                 MetaAccessProvider metaAccess = replacements.providers.getMetaAccess();
545 
546                 Plugins plugins = new Plugins(replacements.graphBuilderPlugins);
547                 GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);
548                 if (args != null) {
549                     plugins.prependParameterPlugin(new ConstantBindingParameterPlugin(args, metaAccess, replacements.snippetReflection));
550                 }
551 
552                 IntrinsicContext initialIntrinsicContext = null;
553                 Snippet snippetAnnotation = method.getAnnotation(Snippet.class);
554                 MethodSubstitution methodAnnotation = method.getAnnotation(MethodSubstitution.class);
555                 if (methodAnnotation == null &amp;&amp; snippetAnnotation == null) {
556                     // Post-parse inlined intrinsic
<a name="41" id="anc41"></a><span class="line-modified">557                     initialIntrinsicContext = new EncodedIntrinsicContext(substitutedMethod, method, bytecodeProvider, context, false);</span>
558                 } else {
559                     // Snippet
560                     ResolvedJavaMethod original = substitutedMethod != null ? substitutedMethod : method;
<a name="42" id="anc42"></a><span class="line-modified">561                     initialIntrinsicContext = new EncodedIntrinsicContext(original, method, bytecodeProvider, context,</span>
562                                     snippetAnnotation != null ? snippetAnnotation.allowPartialIntrinsicArgumentMismatch() : true);
563                 }
564 
<a name="43" id="anc43"></a><span class="line-modified">565                 createGraphBuilder(replacements.providers, config, OptimisticOptimizations.NONE, initialIntrinsicContext).apply(graph);</span>

566 
<a name="44" id="anc44"></a><span class="line-modified">567                 CanonicalizerPhase.create().apply(graph, replacements.providers);</span>
568             } catch (Throwable e) {
569                 throw debug.handle(e);
570             }
571             return graph;
572         }
573 
<a name="45" id="anc45"></a><span class="line-modified">574         protected Instance createGraphBuilder(Providers providers, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-modified">575             return new GraphBuilderPhase.Instance(providers, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);</span>


576         }
577     }
578 
579     @Override
580     public void registerSnippetTemplateCache(SnippetTemplateCache templates) {
581         assert snippetTemplateCache.get(templates.getClass().getName()) == null;
582         snippetTemplateCache.put(templates.getClass().getName(), templates);
583     }
584 
585     @Override
586     public &lt;T extends SnippetTemplateCache&gt; T getSnippetTemplateCache(Class&lt;T&gt; templatesClass) {
587         SnippetTemplateCache ret = snippetTemplateCache.get(templatesClass.getName());
588         return templatesClass.cast(ret);
589     }
590 }
<a name="46" id="anc46"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="46" type="hidden" />
</body>
</html>
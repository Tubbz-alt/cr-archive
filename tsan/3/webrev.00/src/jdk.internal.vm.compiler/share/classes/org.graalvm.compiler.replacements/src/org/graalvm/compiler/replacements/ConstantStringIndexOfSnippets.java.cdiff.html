<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/ConstantStringIndexOfSnippets.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ConstantBindingParameterPlugin.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DefaultJavaLoweringProvider.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/ConstantStringIndexOfSnippets.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,10 ***</span>
<span class="line-new-header">--- 23,11 ---</span>
  
  
  package org.graalvm.compiler.replacements;
  
  import static org.graalvm.compiler.replacements.SnippetTemplate.DEFAULT_REPLACER;
<span class="line-added">+ import static org.graalvm.compiler.serviceprovider.GraalUnsafeAccess.getUnsafe;</span>
  
  import org.graalvm.compiler.api.replacements.Fold;
  import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
  import org.graalvm.compiler.api.replacements.Snippet;
  import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,12 ***</span>
<span class="line-new-header">--- 43,15 ---</span>
  import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
  
  import jdk.vm.ci.code.TargetDescription;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.MetaAccessProvider;
<span class="line-added">+ import sun.misc.Unsafe;</span>
  
  public class ConstantStringIndexOfSnippets implements Snippets {
<span class="line-added">+     private static final Unsafe UNSAFE = getUnsafe();</span>
<span class="line-added">+ </span>
      public static class Templates extends AbstractTemplates {
  
          private final SnippetInfo indexOfConstant = snippet(ConstantStringIndexOfSnippets.class, &quot;indexOfConstant&quot;);
          private final SnippetInfo latin1IndexOfConstant = snippet(ConstantStringIndexOfSnippets.class, &quot;latin1IndexOfConstant&quot;);
          private final SnippetInfo utf16IndexOfConstant = snippet(ConstantStringIndexOfSnippets.class, &quot;utf16IndexOfConstant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,14 ***</span>
          int c = target.length / 2;
          if (c == 0) {
              return 0;
          }
          long base = metaAccess.getArrayBaseOffset(JavaKind.Byte);
<span class="line-modified">!         char lastChar = UnsafeAccess.UNSAFE.getChar(target, base + (c - 1) * 2);</span>
          int md2 = c;
          for (int i = 0; i &lt; c - 1; i++) {
<span class="line-modified">!             char currChar = UnsafeAccess.UNSAFE.getChar(target, base + i * 2);</span>
              if (currChar == lastChar) {
                  md2 = (c - 1) - i;
              }
          }
          return md2;
<span class="line-new-header">--- 159,14 ---</span>
          int c = target.length / 2;
          if (c == 0) {
              return 0;
          }
          long base = metaAccess.getArrayBaseOffset(JavaKind.Byte);
<span class="line-modified">!         char lastChar = UNSAFE.getChar(target, base + (c - 1) * 2);</span>
          int md2 = c;
          for (int i = 0; i &lt; c - 1; i++) {
<span class="line-modified">!             char currChar = UNSAFE.getChar(target, base + i * 2);</span>
              if (currChar == lastChar) {
                  md2 = (c - 1) - i;
              }
          }
          return md2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,11 ***</span>
          int c = s.length / 2;
          int cache = 0;
          int i;
          long base = metaAccess.getArrayBaseOffset(JavaKind.Byte);
          for (i = 0; i &lt; c - 1; i++) {
<span class="line-modified">!             char currChar = UnsafeAccess.UNSAFE.getChar(s, base + i * 2);</span>
              cache |= (1 &lt;&lt; (currChar &amp; 63));
          }
          return cache;
      }
  
<span class="line-new-header">--- 176,11 ---</span>
          int c = s.length / 2;
          int cache = 0;
          int i;
          long base = metaAccess.getArrayBaseOffset(JavaKind.Byte);
          for (i = 0; i &lt; c - 1; i++) {
<span class="line-modified">!             char currChar = UNSAFE.getChar(s, base + i * 2);</span>
              cache |= (1 &lt;&lt; (currChar &amp; 63));
          }
          return cache;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,14 ***</span>
  
          int targetCountLess1 = targetCount - 1;
          int sourceEnd = sourceCount - targetCountLess1;
  
          long base = charArrayBaseOffset(INJECTED);
<span class="line-modified">!         int lastChar = UnsafeAccess.UNSAFE.getChar(target, base + targetCountLess1 * 2);</span>
  
          outer_loop: for (long i = sourceOffset + fromIndex; i &lt; sourceEnd;) {
<span class="line-modified">!             int src = UnsafeAccess.UNSAFE.getChar(source, base + (i + targetCountLess1) * 2);</span>
              if (src == lastChar) {
                  // With random strings and a 4-character alphabet,
                  // reverse matching at this point sets up 0.8% fewer
                  // frames, but (paradoxically) makes 0.3% more probes.
                  // Since those probes are nearer the lastChar probe,
<span class="line-new-header">--- 214,14 ---</span>
  
          int targetCountLess1 = targetCount - 1;
          int sourceEnd = sourceCount - targetCountLess1;
  
          long base = charArrayBaseOffset(INJECTED);
<span class="line-modified">!         int lastChar = UNSAFE.getChar(target, base + targetCountLess1 * 2);</span>
  
          outer_loop: for (long i = sourceOffset + fromIndex; i &lt; sourceEnd;) {
<span class="line-modified">!             int src = UNSAFE.getChar(source, base + (i + targetCountLess1) * 2);</span>
              if (src == lastChar) {
                  // With random strings and a 4-character alphabet,
                  // reverse matching at this point sets up 0.8% fewer
                  // frames, but (paradoxically) makes 0.3% more probes.
                  // Since those probes are nearer the lastChar probe,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,12 ***</span>
                  // (sourceOffset - targetCountLess1) to (sourceOffset + sourceCount)
                  if (targetCount &lt;= 8) {
                      ExplodeLoopNode.explodeLoop();
                  }
                  for (long j = 0; j &lt; targetCountLess1; j++) {
<span class="line-modified">!                     char sourceChar = UnsafeAccess.UNSAFE.getChar(source, base + (i + j) * 2);</span>
<span class="line-modified">!                     if (UnsafeAccess.UNSAFE.getChar(target, base + (targetOffset + j) * 2) != sourceChar) {</span>
                          if ((cache &amp; (1 &lt;&lt; sourceChar)) == 0) {
                              if (md2 &lt; j + 1) {
                                  i += j + 1;
                                  continue outer_loop;
                              }
<span class="line-new-header">--- 231,12 ---</span>
                  // (sourceOffset - targetCountLess1) to (sourceOffset + sourceCount)
                  if (targetCount &lt;= 8) {
                      ExplodeLoopNode.explodeLoop();
                  }
                  for (long j = 0; j &lt; targetCountLess1; j++) {
<span class="line-modified">!                     char sourceChar = UNSAFE.getChar(source, base + (i + j) * 2);</span>
<span class="line-modified">!                     if (UNSAFE.getChar(target, base + (targetOffset + j) * 2) != sourceChar) {</span>
                          if ((cache &amp; (1 &lt;&lt; sourceChar)) == 0) {
                              if (md2 &lt; j + 1) {
                                  i += j + 1;
                                  continue outer_loop;
                              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,14 ***</span>
  
          int targetCountLess1 = targetCount - 1;
          int sourceEnd = sourceCount - targetCountLess1;
  
          long base = byteArrayBaseOffset(INJECTED);
<span class="line-modified">!         int lastChar = UnsafeAccess.UNSAFE.getChar(target, base + targetCountLess1 * 2);</span>
  
          outer_loop: for (long i = fromIndex; i &lt; sourceEnd;) {
<span class="line-modified">!             int src = UnsafeAccess.UNSAFE.getChar(source, base + (i + targetCountLess1) * 2);</span>
              if (src == lastChar) {
                  // With random strings and a 4-character alphabet,
                  // reverse matching at this point sets up 0.8% fewer
                  // frames, but (paradoxically) makes 0.3% more probes.
                  // Since those probes are nearer the lastChar probe,
<span class="line-new-header">--- 272,14 ---</span>
  
          int targetCountLess1 = targetCount - 1;
          int sourceEnd = sourceCount - targetCountLess1;
  
          long base = byteArrayBaseOffset(INJECTED);
<span class="line-modified">!         int lastChar = UNSAFE.getChar(target, base + targetCountLess1 * 2);</span>
  
          outer_loop: for (long i = fromIndex; i &lt; sourceEnd;) {
<span class="line-modified">!             int src = UNSAFE.getChar(source, base + (i + targetCountLess1) * 2);</span>
              if (src == lastChar) {
                  // With random strings and a 4-character alphabet,
                  // reverse matching at this point sets up 0.8% fewer
                  // frames, but (paradoxically) makes 0.3% more probes.
                  // Since those probes are nearer the lastChar probe,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 285,12 ***</span>
                  // (sourceOffset - targetCountLess1) to (sourceOffset + sourceCount)
                  if (targetCount &lt;= 8) {
                      ExplodeLoopNode.explodeLoop();
                  }
                  for (long j = 0; j &lt; targetCountLess1; j++) {
<span class="line-modified">!                     char sourceChar = UnsafeAccess.UNSAFE.getChar(source, base + (i + j) * 2);</span>
<span class="line-modified">!                     if (UnsafeAccess.UNSAFE.getChar(target, base + j * 2) != sourceChar) {</span>
                          if ((cache &amp; (1 &lt;&lt; sourceChar)) == 0) {
                              if (md2 &lt; j + 1) {
                                  i += j + 1;
                                  continue outer_loop;
                              }
<span class="line-new-header">--- 289,12 ---</span>
                  // (sourceOffset - targetCountLess1) to (sourceOffset + sourceCount)
                  if (targetCount &lt;= 8) {
                      ExplodeLoopNode.explodeLoop();
                  }
                  for (long j = 0; j &lt; targetCountLess1; j++) {
<span class="line-modified">!                     char sourceChar = UNSAFE.getChar(source, base + (i + j) * 2);</span>
<span class="line-modified">!                     if (UNSAFE.getChar(target, base + j * 2) != sourceChar) {</span>
                          if ((cache &amp; (1 &lt;&lt; sourceChar)) == 0) {
                              if (md2 &lt; j + 1) {
                                  i += j + 1;
                                  continue outer_loop;
                              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 326,14 ***</span>
  
          int targetCountLess1 = targetCount - 1;
          int sourceEnd = sourceCount - targetCountLess1;
  
          long base = byteArrayBaseOffset(INJECTED);
<span class="line-modified">!         int lastByte = UnsafeAccess.UNSAFE.getByte(target, base + targetCountLess1);</span>
  
          outer_loop: for (long i = fromIndex; i &lt; sourceEnd;) {
<span class="line-modified">!             int src = UnsafeAccess.UNSAFE.getByte(source, base + i + targetCountLess1);</span>
              if (src == lastByte) {
                  // With random strings and a 4-character alphabet,
                  // reverse matching at this point sets up 0.8% fewer
                  // frames, but (paradoxically) makes 0.3% more probes.
                  // Since those probes are nearer the lastByte probe,
<span class="line-new-header">--- 330,14 ---</span>
  
          int targetCountLess1 = targetCount - 1;
          int sourceEnd = sourceCount - targetCountLess1;
  
          long base = byteArrayBaseOffset(INJECTED);
<span class="line-modified">!         int lastByte = UNSAFE.getByte(target, base + targetCountLess1);</span>
  
          outer_loop: for (long i = fromIndex; i &lt; sourceEnd;) {
<span class="line-modified">!             int src = UNSAFE.getByte(source, base + i + targetCountLess1);</span>
              if (src == lastByte) {
                  // With random strings and a 4-character alphabet,
                  // reverse matching at this point sets up 0.8% fewer
                  // frames, but (paradoxically) makes 0.3% more probes.
                  // Since those probes are nearer the lastByte probe,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 343,12 ***</span>
                  // (sourceOffset - targetCountLess1) to (sourceOffset + sourceCount)
                  if (targetCount &lt;= 8) {
                      ExplodeLoopNode.explodeLoop();
                  }
                  for (long j = 0; j &lt; targetCountLess1; j++) {
<span class="line-modified">!                     byte sourceByte = UnsafeAccess.UNSAFE.getByte(source, base + i + j);</span>
<span class="line-modified">!                     if (UnsafeAccess.UNSAFE.getByte(target, base + j) != sourceByte) {</span>
                          if ((cache &amp; (1 &lt;&lt; sourceByte)) == 0) {
                              if (md2 &lt; j + 1) {
                                  i += j + 1;
                                  continue outer_loop;
                              }
<span class="line-new-header">--- 347,12 ---</span>
                  // (sourceOffset - targetCountLess1) to (sourceOffset + sourceCount)
                  if (targetCount &lt;= 8) {
                      ExplodeLoopNode.explodeLoop();
                  }
                  for (long j = 0; j &lt; targetCountLess1; j++) {
<span class="line-modified">!                     byte sourceByte = UNSAFE.getByte(source, base + i + j);</span>
<span class="line-modified">!                     if (UNSAFE.getByte(target, base + j) != sourceByte) {</span>
                          if ((cache &amp; (1 &lt;&lt; sourceByte)) == 0) {
                              if (md2 &lt; j + 1) {
                                  i += j + 1;
                                  continue outer_loop;
                              }
</pre>
<center><a href="ConstantBindingParameterPlugin.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DefaultJavaLoweringProvider.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
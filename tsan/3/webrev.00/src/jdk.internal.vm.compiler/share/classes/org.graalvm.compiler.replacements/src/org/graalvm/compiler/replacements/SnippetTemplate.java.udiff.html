<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SnippetCounterNode.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="StandardGraphBuilderPlugins.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -117,10 +117,11 @@</span>
  import org.graalvm.compiler.nodes.memory.MemoryMap;
  import org.graalvm.compiler.nodes.memory.MemoryMapNode;
  import org.graalvm.compiler.nodes.memory.MemoryNode;
  import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
  import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
  import org.graalvm.compiler.nodes.spi.LoweringTool;
  import org.graalvm.compiler.nodes.spi.MemoryProxy;
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.options.Option;
  import org.graalvm.compiler.options.OptionKey;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131,11 +132,10 @@</span>
  import org.graalvm.compiler.phases.common.FloatingReadPhase.MemoryMapImpl;
  import org.graalvm.compiler.phases.common.GuardLoweringPhase;
  import org.graalvm.compiler.phases.common.LoweringPhase;
  import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
  import org.graalvm.compiler.phases.common.inlining.InliningUtil;
<span class="udiff-line-removed">- import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
  import org.graalvm.compiler.phases.util.Providers;
  import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
  import org.graalvm.compiler.replacements.nodes.LoadSnippetVarargParameterNode;
  import org.graalvm.util.CollectionsUtil;
  import jdk.internal.vm.compiler.word.LocationIdentity;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -631,10 +631,14 @@</span>
              } else {
                  this.templates = null;
              }
          }
  
<span class="udiff-line-added">+         public Providers getProviders() {</span>
<span class="udiff-line-added">+             return providers;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          public static Method findMethod(Class&lt;? extends Snippets&gt; declaringClass, String methodName, Method except) {
              for (Method m : declaringClass.getDeclaredMethods()) {
                  if (m.getName().equals(methodName) &amp;&amp; !m.equals(except)) {
                      return m;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -673,11 +677,11 @@</span>
          protected SnippetInfo snippet(Class&lt;? extends Snippets&gt; declaringClass, String methodName, ResolvedJavaMethod original, Object receiver, LocationIdentity... initialPrivateLocations) {
              assert methodName != null;
              ResolvedJavaMethod javaMethod = findMethod(providers.getMetaAccess(), declaringClass, methodName);
              assert javaMethod != null : &quot;did not find @&quot; + Snippet.class.getSimpleName() + &quot; method in &quot; + declaringClass + &quot; named &quot; + methodName;
              assert javaMethod.getAnnotation(Snippet.class) != null : javaMethod + &quot; must be annotated with @&quot; + Snippet.class.getSimpleName();
<span class="udiff-line-modified-removed">-             providers.getReplacements().registerSnippet(javaMethod, original, receiver, GraalOptions.TrackNodeSourcePosition.getValue(options));</span>
<span class="udiff-line-modified-added">+             providers.getReplacements().registerSnippet(javaMethod, original, receiver, GraalOptions.TrackNodeSourcePosition.getValue(options), options);</span>
              LocationIdentity[] privateLocations = GraalOptions.SnippetCounters.getValue(options) ? SnippetCounterNode.addSnippetCounters(initialPrivateLocations) : initialPrivateLocations;
              if (GraalOptions.EagerSnippets.getValue(options)) {
                  return new EagerSnippetInfo(javaMethod, original, privateLocations, receiver);
              } else {
                  return new LazySnippetInfo(javaMethod, original, privateLocations, receiver);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -689,18 +693,18 @@</span>
          private DebugContext openDebugContext(DebugContext outer, Arguments args) {
              if (DebugStubsAndSnippets.getValue(options)) {
                  Description description = new Description(args.cacheKey.method, &quot;SnippetTemplate_&quot; + nextSnippetTemplateId.incrementAndGet());
                  return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, factories);
              }
<span class="udiff-line-modified-removed">-             return DebugContext.DISABLED;</span>
<span class="udiff-line-modified-added">+             return DebugContext.disabled(options);</span>
          }
  
          /**
           * Gets a template for a given key, creating it first if necessary.
           */
          @SuppressWarnings(&quot;try&quot;)
<span class="udiff-line-modified-removed">-         protected SnippetTemplate template(ValueNode replacee, final Arguments args) {</span>
<span class="udiff-line-modified-added">+         public SnippetTemplate template(ValueNode replacee, final Arguments args) {</span>
              StructuredGraph graph = replacee.graph();
              DebugContext outer = graph.getDebug();
              SnippetTemplate template = Options.UseSnippetTemplateCache.getValue(options) &amp;&amp; args.cacheable ? templates.get(args.cacheKey) : null;
              if (template == null || (graph.trackNodeSourcePosition() &amp;&amp; !template.snippet.trackNodeSourcePosition())) {
                  try (DebugContext debug = openDebugContext(outer, args)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -762,17 +766,16 @@</span>
          this.snippetReflection = snippetReflection;
          this.info = args.info;
  
          Object[] constantArgs = getConstantArgs(args);
          boolean shouldTrackNodeSourcePosition1 = trackNodeSourcePosition || (providers.getCodeCache() != null &amp;&amp; providers.getCodeCache().shouldDebugNonSafepoints());
<span class="udiff-line-modified-removed">-         StructuredGraph snippetGraph = providers.getReplacements().getSnippet(args.info.method, args.info.original, constantArgs, shouldTrackNodeSourcePosition1, replacee.getNodeSourcePosition());</span>
<span class="udiff-line-modified-added">+         StructuredGraph snippetGraph = providers.getReplacements().getSnippet(args.info.method, args.info.original, constantArgs, shouldTrackNodeSourcePosition1, replacee.getNodeSourcePosition(),</span>
<span class="udiff-line-added">+                         options);</span>
  
          ResolvedJavaMethod method = snippetGraph.method();
          Signature signature = method.getSignature();
  
<span class="udiff-line-removed">-         PhaseContext phaseContext = new PhaseContext(providers);</span>
<span class="udiff-line-removed">- </span>
          // Copy snippet graph, replacing constant parameters with given arguments
          final StructuredGraph snippetCopy = new StructuredGraph.Builder(options, debug).name(snippetGraph.name).method(snippetGraph.method()).trackNodeSourcePosition(
                          snippetGraph.trackNodeSourcePosition()).setIsSubstitution(true).build();
          assert !GraalOptions.TrackNodeSourcePosition.getValue(options) || snippetCopy.trackNodeSourcePosition();
          try (DebugContext.Scope scope = debug.scope(&quot;SpecializeSnippet&quot;, snippetCopy)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -877,20 +880,20 @@</span>
                          parameters[i] = local;
                      }
                  }
              }
  
<span class="udiff-line-modified-removed">-             explodeLoops(snippetCopy, phaseContext);</span>
<span class="udiff-line-modified-added">+             explodeLoops(snippetCopy, providers);</span>
  
              GuardsStage guardsStage = args.cacheKey.guardsStage;
              // Perform lowering on the snippet
              if (!guardsStage.allowsFloatingGuards()) {
                  new GuardLoweringPhase().apply(snippetCopy, null);
              }
              snippetCopy.setGuardsStage(guardsStage);
              try (DebugContext.Scope s = debug.scope(&quot;LoweringSnippetTemplate&quot;, snippetCopy)) {
<span class="udiff-line-modified-removed">-                 new LoweringPhase(new CanonicalizerPhase(), args.cacheKey.loweringStage).apply(snippetCopy, phaseContext);</span>
<span class="udiff-line-modified-added">+                 new LoweringPhase(CanonicalizerPhase.create(), args.cacheKey.loweringStage).apply(snippetCopy, providers);</span>
              } catch (Throwable e) {
                  throw debug.handle(e);
              }
  
              ArrayList&lt;StateSplit&gt; curSideEffectNodes = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -925,11 +928,14 @@</span>
              new DeadCodeEliminationPhase(Required).apply(snippetCopy);
  
              assert checkAllVarargPlaceholdersAreDeleted(parameterCount, placeholders);
  
              new FloatingReadPhase(true, true).apply(snippetCopy);
<span class="udiff-line-modified-removed">-             new RemoveValueProxyPhase().apply(snippetCopy);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+             if (!guardsStage.requiresValueProxies()) {</span>
<span class="udiff-line-added">+                 new RemoveValueProxyPhase().apply(snippetCopy);</span>
<span class="udiff-line-added">+             }</span>
  
              MemoryAnchorNode anchor = snippetCopy.add(new MemoryAnchorNode());
              snippetCopy.start().replaceAtUsages(InputType.Memory, anchor);
  
              this.snippet = snippetCopy;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -963,11 +969,13 @@</span>
                          } else {
                              assert memoryMap == retNode.getMemoryMap();
                          }
                          retNode.setMemoryMap(null);
                      }
<span class="udiff-line-modified-removed">-                     memoryMap.safeDelete();</span>
<span class="udiff-line-modified-added">+                     if (memoryMap != null) {</span>
<span class="udiff-line-added">+                         memoryMap.safeDelete();</span>
<span class="udiff-line-added">+                     }</span>
                  }
                  if (needsAnchor) {
                      snippetCopy.addAfterFixed(snippetCopy.start(), anchor);
                      this.memoryAnchor = anchor;
                  } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1040,11 +1048,11 @@</span>
              }
          }
          return true;
      }
  
<span class="udiff-line-modified-removed">-     public static void explodeLoops(final StructuredGraph snippetCopy, PhaseContext phaseContext) {</span>
<span class="udiff-line-modified-added">+     public static void explodeLoops(final StructuredGraph snippetCopy, CoreProviders providers) {</span>
          // Do any required loop explosion
          boolean exploded = false;
          do {
              exploded = false;
              ExplodeLoopNode explodeLoop = snippetCopy.getNodes().filter(ExplodeLoopNode.class).first();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1052,12 +1060,18 @@</span>
                  // altogether
                  LoopBeginNode loopBegin = explodeLoop.findLoopBegin();
                  if (loopBegin != null) {
                      LoopEx loop = new LoopsData(snippetCopy).loop(loopBegin);
                      Mark mark = snippetCopy.getMark();
<span class="udiff-line-modified-removed">-                     LoopTransformations.fullUnroll(loop, phaseContext, new CanonicalizerPhase());</span>
<span class="udiff-line-modified-removed">-                     new CanonicalizerPhase().applyIncremental(snippetCopy, phaseContext, mark, false);</span>
<span class="udiff-line-modified-added">+                     CanonicalizerPhase canonicalizer = null;</span>
<span class="udiff-line-modified-added">+                     if (GraalOptions.ImmutableCode.getValue(snippetCopy.getOptions())) {</span>
<span class="udiff-line-added">+                         canonicalizer = CanonicalizerPhase.createWithoutReadCanonicalization();</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         canonicalizer = CanonicalizerPhase.create();</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     LoopTransformations.fullUnroll(loop, providers, canonicalizer);</span>
<span class="udiff-line-added">+                     CanonicalizerPhase.create().applyIncremental(snippetCopy, providers, mark, false);</span>
                      loop.deleteUnusedNodes();
                  }
                  GraphUtil.removeFixedWithUnusedInputs(explodeLoop);
                  exploded = true;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1271,11 +1285,11 @@</span>
          EconomicSet&lt;LocationIdentity&gt; kills = EconomicSet.create(Equivalence.DEFAULT);
          kills.addAll(memoryMap.getLocations());
  
          if (replacee instanceof MemoryCheckpoint.Single) {
              // check if some node in snippet graph also kills the same location
<span class="udiff-line-modified-removed">-             LocationIdentity locationIdentity = ((MemoryCheckpoint.Single) replacee).getLocationIdentity();</span>
<span class="udiff-line-modified-added">+             LocationIdentity locationIdentity = ((MemoryCheckpoint.Single) replacee).getKilledLocationIdentity();</span>
              if (locationIdentity.isAny()) {
                  assert !(memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) : replacee + &quot; kills ANY_LOCATION, but snippet does not&quot;;
                  // if the replacee kills ANY_LOCATION, the snippet can kill arbitrary locations
                  return true;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1482,59 +1496,10 @@</span>
              FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
              replacee.replaceAtPredecessor(firstCFGNodeDuplicate);
  
              rewireFrameStates(replacee, duplicates);
  
<span class="udiff-line-removed">-             if (replacee instanceof DeoptimizingNode) {</span>
<span class="udiff-line-removed">-                 DeoptimizingNode replaceeDeopt = (DeoptimizingNode) replacee;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 FrameState stateBefore = null;</span>
<span class="udiff-line-removed">-                 FrameState stateDuring = null;</span>
<span class="udiff-line-removed">-                 FrameState stateAfter = null;</span>
<span class="udiff-line-removed">-                 if (replaceeDeopt.canDeoptimize()) {</span>
<span class="udiff-line-removed">-                     if (replaceeDeopt instanceof DeoptimizingNode.DeoptBefore) {</span>
<span class="udiff-line-removed">-                         stateBefore = ((DeoptimizingNode.DeoptBefore) replaceeDeopt).stateBefore();</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (replaceeDeopt instanceof DeoptimizingNode.DeoptDuring) {</span>
<span class="udiff-line-removed">-                         stateDuring = ((DeoptimizingNode.DeoptDuring) replaceeDeopt).stateDuring();</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (replaceeDeopt instanceof DeoptimizingNode.DeoptAfter) {</span>
<span class="udiff-line-removed">-                         stateAfter = ((DeoptimizingNode.DeoptAfter) replaceeDeopt).stateAfter();</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 for (DeoptimizingNode deoptNode : deoptNodes) {</span>
<span class="udiff-line-removed">-                     DeoptimizingNode deoptDup = (DeoptimizingNode) duplicates.get(deoptNode.asNode());</span>
<span class="udiff-line-removed">-                     if (deoptDup.canDeoptimize()) {</span>
<span class="udiff-line-removed">-                         if (deoptDup instanceof DeoptimizingNode.DeoptBefore) {</span>
<span class="udiff-line-removed">-                             ((DeoptimizingNode.DeoptBefore) deoptDup).setStateBefore(stateBefore);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         if (deoptDup instanceof DeoptimizingNode.DeoptDuring) {</span>
<span class="udiff-line-removed">-                             DeoptimizingNode.DeoptDuring deoptDupDuring = (DeoptimizingNode.DeoptDuring) deoptDup;</span>
<span class="udiff-line-removed">-                             if (stateDuring != null) {</span>
<span class="udiff-line-removed">-                                 deoptDupDuring.setStateDuring(stateDuring);</span>
<span class="udiff-line-removed">-                             } else if (stateAfter != null) {</span>
<span class="udiff-line-removed">-                                 deoptDupDuring.computeStateDuring(stateAfter);</span>
<span class="udiff-line-removed">-                             } else if (stateBefore != null) {</span>
<span class="udiff-line-removed">-                                 assert !deoptDupDuring.hasSideEffect() : &quot;can&#39;t use stateBefore as stateDuring for state split &quot; + deoptDupDuring;</span>
<span class="udiff-line-removed">-                                 deoptDupDuring.setStateDuring(stateBefore);</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         if (deoptDup instanceof DeoptimizingNode.DeoptAfter) {</span>
<span class="udiff-line-removed">-                             DeoptimizingNode.DeoptAfter deoptDupAfter = (DeoptimizingNode.DeoptAfter) deoptDup;</span>
<span class="udiff-line-removed">-                             if (stateAfter != null) {</span>
<span class="udiff-line-removed">-                                 deoptDupAfter.setStateAfter(stateAfter);</span>
<span class="udiff-line-removed">-                             } else {</span>
<span class="udiff-line-removed">-                                 assert !deoptDupAfter.hasSideEffect() : &quot;can&#39;t use stateBefore as stateAfter for state split &quot; + deoptDupAfter;</span>
<span class="udiff-line-removed">-                                 deoptDupAfter.setStateAfter(stateBefore);</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
              updateStamps(replacee, duplicates);
  
              rewireMemoryGraph(replacee, duplicates);
  
              // Replace all usages of the replacee with the value returned by the snippet
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1654,11 +1619,12 @@</span>
              FixedNode next = lastFixedNode.next();
              lastFixedNode.setNext(null);
              FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
              replaceeGraph.addAfterFixed(lastFixedNode, firstCFGNodeDuplicate);
  
<span class="udiff-line-modified-removed">-             rewireFrameStates(replacee, duplicates);</span>
<span class="udiff-line-modified-added">+             // floating nodes are not state-splits not need to re-wire frame states</span>
<span class="udiff-line-added">+             assert !(replacee instanceof StateSplit);</span>
              updateStamps(replacee, duplicates);
  
              rewireMemoryGraph(replacee, duplicates);
  
              // Replace all usages of the replacee with the value returned by the snippet
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1708,11 +1674,12 @@</span>
                      floatingNodes.add(n);
                  }
              }
              UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
  
<span class="udiff-line-modified-removed">-             rewireFrameStates(replacee, duplicates);</span>
<span class="udiff-line-modified-added">+             // floating nodes are not state-splits not need to re-wire frame states</span>
<span class="udiff-line-added">+             assert !(replacee instanceof StateSplit);</span>
              updateStamps(replacee, duplicates);
  
              rewireMemoryGraph(replacee, duplicates);
              assert anchorDuplicate == null || anchorDuplicate.isDeleted();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1723,16 +1690,68 @@</span>
              debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
          }
      }
  
      protected void rewireFrameStates(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
<span class="udiff-line-modified-removed">-         if (replacee instanceof StateSplit) {</span>
<span class="udiff-line-modified-added">+         if (replacee.graph().getGuardsStage().areFrameStatesAtSideEffects() &amp;&amp; replacee instanceof StateSplit) {</span>
              for (StateSplit sideEffectNode : sideEffectNodes) {
                  assert ((StateSplit) replacee).hasSideEffect();
                  Node sideEffectDup = duplicates.get(sideEffectNode.asNode());
                  ((StateSplit) sideEffectDup).setStateAfter(((StateSplit) replacee).stateAfter());
              }
<span class="udiff-line-added">+         } else if (replacee.graph().getGuardsStage().areFrameStatesAtDeopts() &amp;&amp; replacee instanceof DeoptimizingNode) {</span>
<span class="udiff-line-added">+             DeoptimizingNode replaceeDeopt = (DeoptimizingNode) replacee;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             FrameState stateBefore = null;</span>
<span class="udiff-line-added">+             FrameState stateDuring = null;</span>
<span class="udiff-line-added">+             FrameState stateAfter = null;</span>
<span class="udiff-line-added">+             if (replaceeDeopt.canDeoptimize()) {</span>
<span class="udiff-line-added">+                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptBefore) {</span>
<span class="udiff-line-added">+                     stateBefore = ((DeoptimizingNode.DeoptBefore) replaceeDeopt).stateBefore();</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptDuring) {</span>
<span class="udiff-line-added">+                     stateDuring = ((DeoptimizingNode.DeoptDuring) replaceeDeopt).stateDuring();</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptAfter) {</span>
<span class="udiff-line-added">+                     stateAfter = ((DeoptimizingNode.DeoptAfter) replaceeDeopt).stateAfter();</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             for (DeoptimizingNode deoptNode : deoptNodes) {</span>
<span class="udiff-line-added">+                 DeoptimizingNode deoptDup = (DeoptimizingNode) duplicates.get(deoptNode.asNode());</span>
<span class="udiff-line-added">+                 if (deoptDup.canDeoptimize()) {</span>
<span class="udiff-line-added">+                     if (deoptDup instanceof DeoptimizingNode.DeoptBefore) {</span>
<span class="udiff-line-added">+                         ((DeoptimizingNode.DeoptBefore) deoptDup).setStateBefore(stateBefore);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     if (deoptDup instanceof DeoptimizingNode.DeoptDuring) {</span>
<span class="udiff-line-added">+                         // compute a state &quot;during&quot; for a DeoptDuring inside the snippet depending</span>
<span class="udiff-line-added">+                         // on what kind of states we had on the node we are replacing.</span>
<span class="udiff-line-added">+                         // If the original node had a state &quot;during&quot; already, we just use that,</span>
<span class="udiff-line-added">+                         // otherwise we need to find a strategy to compute a state during based on</span>
<span class="udiff-line-added">+                         // some other state (before or after).</span>
<span class="udiff-line-added">+                         DeoptimizingNode.DeoptDuring deoptDupDuring = (DeoptimizingNode.DeoptDuring) deoptDup;</span>
<span class="udiff-line-added">+                         if (stateDuring != null) {</span>
<span class="udiff-line-added">+                             deoptDupDuring.setStateDuring(stateDuring);</span>
<span class="udiff-line-added">+                         } else if (stateAfter != null) {</span>
<span class="udiff-line-added">+                             deoptDupDuring.computeStateDuring(stateAfter);</span>
<span class="udiff-line-added">+                         } else if (stateBefore != null) {</span>
<span class="udiff-line-added">+                             assert !deoptDupDuring.hasSideEffect() : &quot;can&#39;t use stateBefore as stateDuring for state split &quot; + deoptDupDuring;</span>
<span class="udiff-line-added">+                             deoptDupDuring.setStateDuring(stateBefore);</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     if (deoptDup instanceof DeoptimizingNode.DeoptAfter) {</span>
<span class="udiff-line-added">+                         DeoptimizingNode.DeoptAfter deoptDupAfter = (DeoptimizingNode.DeoptAfter) deoptDup;</span>
<span class="udiff-line-added">+                         if (stateAfter != null) {</span>
<span class="udiff-line-added">+                             deoptDupAfter.setStateAfter(stateAfter);</span>
<span class="udiff-line-added">+                         } else {</span>
<span class="udiff-line-added">+                             assert !deoptDupAfter.hasSideEffect() : &quot;can&#39;t use stateBefore as stateAfter for state split &quot; + deoptDupAfter;</span>
<span class="udiff-line-added">+                             deoptDupAfter.setStateAfter(stateBefore);</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
          }
      }
  
      @Override
      public String toString() {
</pre>
<center><a href="SnippetCounterNode.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="StandardGraphBuilderPlugins.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
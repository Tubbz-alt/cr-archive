<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/nodes/MacroNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.nodes;
 26 
 27 import static jdk.vm.ci.code.BytecodeFrame.isPlaceholderBci;
 28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
 29 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_UNKNOWN;
 30 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_UNKNOWN;
 31 
 32 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 33 import org.graalvm.compiler.api.replacements.Snippet;
 34 import org.graalvm.compiler.core.common.type.StampPair;
 35 import org.graalvm.compiler.debug.DebugCloseable;
 36 import org.graalvm.compiler.debug.DebugContext;
 37 import org.graalvm.compiler.debug.GraalError;
 38 import org.graalvm.compiler.graph.Node;
 39 import org.graalvm.compiler.graph.NodeClass;
 40 import org.graalvm.compiler.graph.NodeInputList;
 41 import org.graalvm.compiler.nodeinfo.NodeInfo;
 42 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 43 import org.graalvm.compiler.nodes.FixedNode;
<a name="2" id="anc2"></a><span class="line-removed"> 44 import org.graalvm.compiler.nodes.Invokable;</span>
 45 import org.graalvm.compiler.nodes.FixedWithNextNode;
 46 import org.graalvm.compiler.nodes.FrameState;
<a name="3" id="anc3"></a>
 47 import org.graalvm.compiler.nodes.InvokeNode;
 48 import org.graalvm.compiler.nodes.StructuredGraph;
 49 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
 50 import org.graalvm.compiler.nodes.ValueNode;
 51 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
<a name="4" id="anc4"></a>
 52 import org.graalvm.compiler.nodes.spi.Lowerable;
 53 import org.graalvm.compiler.nodes.spi.LoweringTool;
 54 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 55 import org.graalvm.compiler.phases.common.FrameStateAssignmentPhase;
 56 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 57 import org.graalvm.compiler.phases.common.LoweringPhase;
 58 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 59 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
<a name="5" id="anc5"></a><span class="line-modified"> 60 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 61 
 62 import jdk.vm.ci.meta.JavaKind;
 63 import jdk.vm.ci.meta.ResolvedJavaMethod;
<a name="6" id="anc6"></a><span class="line-removed"> 64 import jdk.internal.vm.compiler.word.LocationIdentity;</span>
 65 
 66 /**
 67  * Macro nodes can be used to temporarily replace an invoke. They can, for example, be used to
 68  * implement constant folding for known JDK functions like {@link Class#isInterface()}.&lt;br/&gt;
 69  * &lt;br/&gt;
 70  * During lowering, multiple sources are queried in order to look for a replacement:
 71  * &lt;ul&gt;
 72  * &lt;li&gt;If {@link #getLoweredSnippetGraph(LoweringTool)} returns a non-null result, this graph is
 73  * used as a replacement.&lt;/li&gt;
 74  * &lt;li&gt;If a {@link MethodSubstitution} for the target method is found, this substitution is used as
 75  * a replacement.&lt;/li&gt;
 76  * &lt;li&gt;Otherwise, the macro node is replaced with an {@link InvokeNode}. Note that this is only
 77  * possible if the macro node is a {@link MacroStateSplitNode}.&lt;/li&gt;
 78  * &lt;/ul&gt;
 79  */
 80 //@formatter:off
 81 @NodeInfo(cycles = CYCLES_UNKNOWN,
 82           cyclesRationale = &quot;If this node is not optimized away it will be lowered to a call, which we cannot estimate&quot;,
 83           size = SIZE_UNKNOWN,
 84           sizeRationale = &quot;If this node is not optimized away it will be lowered to a call, which we cannot estimate&quot;)
 85 //@formatter:on
 86 public abstract class MacroNode extends FixedWithNextNode implements Lowerable, Invokable {
 87 
 88     public static final NodeClass&lt;MacroNode&gt; TYPE = NodeClass.create(MacroNode.class);
 89     @Input protected NodeInputList&lt;ValueNode&gt; arguments;
 90 
 91     protected final int bci;
 92     protected final ResolvedJavaMethod targetMethod;
 93     protected final InvokeKind invokeKind;
 94     protected final StampPair returnStamp;
 95 
 96     protected MacroNode(NodeClass&lt;? extends MacroNode&gt; c, InvokeKind invokeKind, ResolvedJavaMethod targetMethod, int bci, StampPair returnStamp, ValueNode... arguments) {
 97         super(c, returnStamp != null ? returnStamp.getTrustedStamp() : null);
 98         assertArgumentCount(targetMethod, arguments);
 99         this.arguments = new NodeInputList&lt;&gt;(this, arguments);
100         this.bci = bci;
101         this.targetMethod = targetMethod;
102         this.returnStamp = returnStamp;
103         this.invokeKind = invokeKind;
104         assert !isPlaceholderBci(bci);
105     }
106 
107     protected void assertArgumentCount(ResolvedJavaMethod method, ValueNode... args) {
108         assert method.getSignature().getParameterCount(!method.isStatic()) == args.length;
109     }
110 
111     public ValueNode getArgument(int i) {
112         return arguments.get(i);
113     }
114 
115     public int getArgumentCount() {
116         return arguments.size();
117     }
118 
119     public ValueNode[] toArgumentArray() {
120         return arguments.toArray(new ValueNode[0]);
121     }
122 
123     @Override
124     public int bci() {
125         return bci;
126     }
127 
128     @Override
129     public ResolvedJavaMethod getTargetMethod() {
130         return targetMethod;
131     }
132 
133     protected FrameState stateAfter() {
134         return null;
135     }
136 
137     @Override
138     protected void afterClone(Node other) {
139         updateInliningLogAfterClone(other);
140     }
141 
142     @Override
143     public FixedNode asFixedNode() {
144         return this;
145     }
146 
147     /**
148      * Gets a snippet to be used for lowering this macro node. The returned graph (if non-null) must
149      * have been {@linkplain #lowerReplacement(StructuredGraph, LoweringTool) lowered}.
150      */
151     @SuppressWarnings(&quot;unused&quot;)
152     protected StructuredGraph getLoweredSnippetGraph(LoweringTool tool) {
153         return null;
154     }
155 
156     /**
157      * Applies {@linkplain LoweringPhase lowering} to a replacement graph.
158      *
159      * @param replacementGraph a replacement (i.e., snippet or method substitution) graph
160      */
161     @SuppressWarnings(&quot;try&quot;)
162     protected StructuredGraph lowerReplacement(final StructuredGraph replacementGraph, LoweringTool tool) {
<a name="7" id="anc7"></a><span class="line-modified">163         final PhaseContext c = new PhaseContext(tool.getMetaAccess(), tool.getConstantReflection(), tool.getConstantFieldProvider(), tool.getLowerer(), tool.getReplacements(),</span>
<span class="line-removed">164                         tool.getStampProvider(), null);</span>
165         if (!graph().hasValueProxies()) {
166             new RemoveValueProxyPhase().apply(replacementGraph);
167         }
168         GuardsStage guardsStage = graph().getGuardsStage();
169         if (!guardsStage.allowsFloatingGuards()) {
170             new GuardLoweringPhase().apply(replacementGraph, null);
171             if (guardsStage.areFrameStatesAtDeopts()) {
172                 new FrameStateAssignmentPhase().apply(replacementGraph);
173             }
174         }
175         DebugContext debug = replacementGraph.getDebug();
176         try (DebugContext.Scope s = debug.scope(&quot;LoweringSnippetTemplate&quot;, replacementGraph)) {
<a name="8" id="anc8"></a><span class="line-modified">177             new LoweringPhase(new CanonicalizerPhase(), tool.getLoweringStage()).apply(replacementGraph, c);</span>
178         } catch (Throwable e) {
179             throw debug.handle(e);
180         }
181         return replacementGraph;
182     }
183 
184     @Override
185     public void lower(LoweringTool tool) {
186         StructuredGraph replacementGraph = getLoweredSnippetGraph(tool);
187 
188         InvokeNode invoke = replaceWithInvoke();
189         assert invoke.verify();
190 
191         if (replacementGraph != null) {
192             // Pull out the receiver null check so that a replaced
193             // receiver can be lowered if necessary
194             if (!targetMethod.isStatic()) {
195                 ValueNode nonNullReceiver = InliningUtil.nonNullReceiver(invoke);
196                 if (nonNullReceiver instanceof Lowerable) {
197                     ((Lowerable) nonNullReceiver).lower(tool);
198                 }
199             }
200             InliningUtil.inline(invoke, replacementGraph, false, targetMethod, &quot;Replace with graph.&quot;, &quot;LoweringPhase&quot;);
201             replacementGraph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph(), &quot;After inlining replacement %s&quot;, replacementGraph);
202         } else {
203             if (isPlaceholderBci(invoke.bci())) {
204                 throw new GraalError(&quot;%s: cannot lower to invoke with placeholder BCI: %s&quot;, graph(), this);
205             }
206 
207             if (invoke.stateAfter() == null) {
208                 ResolvedJavaMethod method = graph().method();
209                 if (!IS_IN_NATIVE_IMAGE) {
210                     if (method.getAnnotation(MethodSubstitution.class) != null || method.getAnnotation(Snippet.class) != null) {
211                         // One cause for this is that a MacroNode is created for a method that
212                         // no longer needs a MacroNode. For example, Class.getComponentType()
213                         // only needs a MacroNode prior to JDK9 as it was given a non-native
214                         // implementation in JDK9.
215                         throw new GraalError(&quot;%s macro created for call to %s in %s must be lowerable to a snippet or intrinsic graph. &quot; +
216                                         &quot;Maybe a macro node is not needed for this method in the current JDK?&quot;, getClass().getSimpleName(), targetMethod.format(&quot;%h.%n(%p)&quot;), graph());
217                     }
218                 }
219                 throw new GraalError(&quot;%s: cannot lower to invoke without state: %s&quot;, graph(), this);
220             }
221             invoke.lower(tool);
222         }
223     }
224 
225     @SuppressWarnings(&quot;try&quot;)
226     public InvokeNode replaceWithInvoke() {
227         try (DebugCloseable context = withNodeSourcePosition()) {
228             InvokeNode invoke = createInvoke();
229             graph().replaceFixedWithFixed(this, invoke);
230             return invoke;
231         }
232     }
233 
234     public LocationIdentity getLocationIdentity() {
235         return LocationIdentity.any();
236     }
237 
238     protected InvokeNode createInvoke() {
239         MethodCallTargetNode callTarget = graph().add(new MethodCallTargetNode(invokeKind, targetMethod, arguments.toArray(new ValueNode[arguments.size()]), returnStamp, null));
240         InvokeNode invoke = graph().add(new InvokeNode(callTarget, bci, getLocationIdentity()));
241         if (stateAfter() != null) {
242             invoke.setStateAfter(stateAfter().duplicate());
243             if (getStackKind() != JavaKind.Void) {
244                 invoke.stateAfter().replaceFirstInput(this, invoke);
245             }
246         }
247         return invoke;
248     }
249 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/nodes/MethodHandleNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.nodes;
 26 
 27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_UNKNOWN;
 28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_UNKNOWN;
 29 
 30 import java.lang.invoke.MethodHandle;
 31 import java.util.Arrays;
 32 
 33 import org.graalvm.compiler.core.common.type.StampFactory;
 34 import org.graalvm.compiler.core.common.type.StampPair;
 35 import org.graalvm.compiler.core.common.type.TypeReference;
 36 import org.graalvm.compiler.debug.GraalError;
 37 import org.graalvm.compiler.graph.NodeClass;
 38 import org.graalvm.compiler.graph.spi.Simplifiable;
 39 import org.graalvm.compiler.graph.spi.SimplifierTool;
 40 import org.graalvm.compiler.nodeinfo.NodeInfo;
 41 import org.graalvm.compiler.nodes.CallTargetNode;
 42 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 43 import org.graalvm.compiler.nodes.FixedGuardNode;
 44 import org.graalvm.compiler.nodes.FixedNode;
 45 import org.graalvm.compiler.nodes.FixedWithNextNode;
 46 import org.graalvm.compiler.nodes.GuardNode;
 47 import org.graalvm.compiler.nodes.InvokeNode;
 48 import org.graalvm.compiler.nodes.LogicNode;
 49 import org.graalvm.compiler.nodes.NodeView;
 50 import org.graalvm.compiler.nodes.PiNode;
 51 import org.graalvm.compiler.nodes.StructuredGraph;
 52 import org.graalvm.compiler.nodes.ValueNode;
 53 import org.graalvm.compiler.nodes.extended.AnchoringNode;
 54 import org.graalvm.compiler.nodes.extended.GuardingNode;
 55 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;
 56 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 57 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 58 import org.graalvm.compiler.nodes.type.StampTool;
 59 import org.graalvm.compiler.nodes.util.GraphUtil;
 60 
 61 import jdk.vm.ci.meta.Assumptions;
 62 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 63 import jdk.vm.ci.meta.DeoptimizationAction;
 64 import jdk.vm.ci.meta.DeoptimizationReason;
 65 import jdk.vm.ci.meta.JavaKind;
 66 import jdk.vm.ci.meta.JavaType;
 67 import jdk.vm.ci.meta.MethodHandleAccessProvider;
 68 import jdk.vm.ci.meta.MethodHandleAccessProvider.IntrinsicMethod;
 69 import jdk.vm.ci.meta.ResolvedJavaMethod;
 70 import jdk.vm.ci.meta.ResolvedJavaType;
 71 import jdk.vm.ci.meta.Signature;
 72 import jdk.vm.ci.meta.SpeculationLog;
 73 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 74 
 75 /**
 76  * Node for invocation methods defined on the class {@link MethodHandle}.
 77  */
 78 @NodeInfo(cycles = CYCLES_UNKNOWN, size = SIZE_UNKNOWN)
 79 public final class MethodHandleNode extends MacroStateSplitNode implements Simplifiable {
 80     public static final NodeClass&lt;MethodHandleNode&gt; TYPE = NodeClass.create(MethodHandleNode.class);
 81 
 82     protected final IntrinsicMethod intrinsicMethod;
 83 
 84     public MethodHandleNode(IntrinsicMethod intrinsicMethod, InvokeKind invokeKind, ResolvedJavaMethod targetMethod, int bci, StampPair returnStamp, ValueNode... arguments) {
 85         super(TYPE, invokeKind, targetMethod, bci, returnStamp, arguments);
 86         this.intrinsicMethod = intrinsicMethod;
 87     }
 88 
 89     /**
 90      * Attempts to transform application of an intrinsifiable {@link MethodHandle} method into an
 91      * invocation on another method with possibly transformed arguments.
 92      *
 93      * @param methodHandleAccess objects for accessing the implementation internals of a
 94      *            {@link MethodHandle}
 95      * @param intrinsicMethod denotes the intrinsifiable {@link MethodHandle} method being processed
 96      * @param bci the BCI of the original {@link MethodHandle} call
 97      * @param returnStamp return stamp of the original {@link MethodHandle} call
 98      * @param arguments arguments to the original {@link MethodHandle} call
 99      * @return a more direct invocation derived from the {@link MethodHandle} call or null
100      */
101     public static InvokeNode tryResolveTargetInvoke(GraphAdder adder, MethodHandleAccessProvider methodHandleAccess, IntrinsicMethod intrinsicMethod,
102                     ResolvedJavaMethod original, int bci,
103                     StampPair returnStamp, ValueNode... arguments) {
104         switch (intrinsicMethod) {
105             case INVOKE_BASIC:
106                 return getInvokeBasicTarget(adder, intrinsicMethod, methodHandleAccess, original, bci, returnStamp, arguments);
107             case LINK_TO_STATIC:
108             case LINK_TO_SPECIAL:
109             case LINK_TO_VIRTUAL:
110             case LINK_TO_INTERFACE:
111                 return getLinkToTarget(adder, intrinsicMethod, methodHandleAccess, original, bci, returnStamp, arguments);
112             default:
113                 throw GraalError.shouldNotReachHere();
114         }
115     }
116 
117     /**
118      * A simple utility class for adding nodes to the graph when building a MethodHandle invoke.
119      */
120     public abstract static class GraphAdder {
121         private final StructuredGraph graph;
122 
123         public GraphAdder(StructuredGraph graph) {
124             this.graph = graph;
125         }
126 
127         /**
128          * Call {@link StructuredGraph#addOrUnique(org.graalvm.compiler.graph.Node)} on {@code node}
129          * and link any {@link FixedWithNextNode}s into the current control flow.
130          *
131          * @param node
132          * @return the newly added node
133          */
134         public abstract &lt;T extends ValueNode&gt; T add(T node);
135 
136         /**
137          * @return an {@link AnchoringNode} if floating guards should be created, otherwise
138          *         {@link FixedGuardNode}s will be used.
139          */
140         public AnchoringNode getGuardAnchor() {
141             return null;
142         }
143 
144         public Assumptions getAssumptions() {
145             return graph.getAssumptions();
146         }
147     }
148 
149     @Override
150     public void simplify(SimplifierTool tool) {
151         MethodHandleAccessProvider methodHandleAccess = tool.getConstantReflection().getMethodHandleAccess();
152         ValueNode[] argumentsArray = arguments.toArray(new ValueNode[arguments.size()]);
153 
154         final FixedNode before = this;
155         GraphAdder adder = new GraphAdder(graph()) {
156             @Override
157             public &lt;T extends ValueNode&gt; T add(T node) {
158                 T added = graph().addOrUnique(node);
159                 if (added instanceof FixedWithNextNode) {
160                     graph().addBeforeFixed(before, (FixedWithNextNode) added);
161                 }
162                 return added;
163             }
164         };
165         InvokeNode invoke = tryResolveTargetInvoke(adder, methodHandleAccess, intrinsicMethod, targetMethod, bci, returnStamp, argumentsArray);
166         if (invoke != null) {
167             assert invoke.graph() == null;
168             invoke = graph().addOrUniqueWithInputs(invoke);
169             invoke.setStateAfter(stateAfter());
170             FixedNode currentNext = next();
171             replaceAtUsages(invoke);
172             GraphUtil.removeFixedWithUnusedInputs(this);
173             graph().addBeforeFixed(currentNext, invoke);
174         }
175     }
176 
177     /**
178      * Get the receiver of a MethodHandle.invokeBasic call.
179      *
180      * @return the receiver argument node
181      */
182     private static ValueNode getReceiver(ValueNode[] arguments) {
183         return arguments[0];
184     }
185 
186     /**
187      * Get the MemberName argument of a MethodHandle.linkTo* call.
188      *
189      * @return the MemberName argument node (which is the last argument)
190      */
191     private static ValueNode getMemberName(ValueNode[] arguments) {
192         return arguments[arguments.length - 1];
193     }
194 
195     /**
196      * Used for the MethodHandle.invokeBasic method (the {@link IntrinsicMethod#INVOKE_BASIC }
197      * method) to get the target {@link InvokeNode} if the method handle receiver is constant.
198      *
199      * @param adder
200      *
201      * @return invoke node for the {@link java.lang.invoke.MethodHandle} target
202      */
203     private static InvokeNode getInvokeBasicTarget(GraphAdder adder, IntrinsicMethod intrinsicMethod, MethodHandleAccessProvider methodHandleAccess,
204                     ResolvedJavaMethod original,
205                     int bci,
206                     StampPair returnStamp, ValueNode[] arguments) {
207         ValueNode methodHandleNode = getReceiver(arguments);
208         if (methodHandleNode.isConstant()) {
209             return getTargetInvokeNode(adder, intrinsicMethod, bci, returnStamp, arguments, methodHandleAccess.resolveInvokeBasicTarget(methodHandleNode.asJavaConstant(), true), original);
210         }
211         return null;
212     }
213 
214     /**
215      * Used for the MethodHandle.linkTo* methods (the {@link IntrinsicMethod#LINK_TO_STATIC},
216      * {@link IntrinsicMethod#LINK_TO_SPECIAL}, {@link IntrinsicMethod#LINK_TO_VIRTUAL}, and
217      * {@link IntrinsicMethod#LINK_TO_INTERFACE} methods) to get the target {@link InvokeNode} if
218      * the member name argument is constant.
219      *
220      * @param adder
221      *
222      * @return invoke node for the member name target
223      */
224     private static InvokeNode getLinkToTarget(GraphAdder adder, IntrinsicMethod intrinsicMethod, MethodHandleAccessProvider methodHandleAccess,
225                     ResolvedJavaMethod original,
226                     int bci,
227                     StampPair returnStamp, ValueNode[] arguments) {
228         ValueNode memberNameNode = getMemberName(arguments);
229         if (memberNameNode.isConstant()) {
230             return getTargetInvokeNode(adder, intrinsicMethod, bci, returnStamp, arguments, methodHandleAccess.resolveLinkToTarget(memberNameNode.asJavaConstant()), original);
231         }
232         return null;
233     }
234 
235     /**
236      * Helper function to get the {@link InvokeNode} for the targetMethod of a
237      * java.lang.invoke.MemberName.
238      *
239      * @param adder
240      * @param target the target, already loaded from the member name node
241      *
242      * @return invoke node for the member name target
243      */
244     private static InvokeNode getTargetInvokeNode(GraphAdder adder, IntrinsicMethod intrinsicMethod, int bci, StampPair returnStamp, ValueNode[] originalArguments, ResolvedJavaMethod target,
245                     ResolvedJavaMethod original) {
246         if (target == null) {
247             return null;
248         }
249 
250         // In lambda forms we erase signature types to avoid resolving issues
251         // involving class loaders. When we optimize a method handle invoke
252         // to a direct call we must cast the receiver and arguments to its
253         // actual types.
254         Signature signature = target.getSignature();
255         final boolean isStatic = target.isStatic();
256         final int receiverSkip = isStatic ? 0 : 1;
257 
258         Assumptions assumptions = adder.getAssumptions();
259         ResolvedJavaMethod realTarget = null;
260         if (target.canBeStaticallyBound()) {
261             realTarget = target;
262         } else {
263             ResolvedJavaType targetType = target.getDeclaringClass();
264             // Try to bind based on the declaredType
265             AssumptionResult&lt;ResolvedJavaMethod&gt; concreteMethod = targetType.findUniqueConcreteMethod(target);
266             if (concreteMethod == null) {
267                 // Try to get the most accurate receiver type
268                 if (intrinsicMethod == IntrinsicMethod.LINK_TO_VIRTUAL || intrinsicMethod == IntrinsicMethod.LINK_TO_INTERFACE) {
269                     ValueNode receiver = getReceiver(originalArguments);
270                     TypeReference receiverType = StampTool.typeReferenceOrNull(receiver.stamp(NodeView.DEFAULT));
271                     if (receiverType != null) {
272                         concreteMethod = receiverType.getType().findUniqueConcreteMethod(target);
273                     }
274                 }
275 
276             }
277             if (concreteMethod != null &amp;&amp; concreteMethod.canRecordTo(assumptions)) {
278                 concreteMethod.recordTo(assumptions);
279                 realTarget = concreteMethod.getResult();
280             }
281         }
282 
283         if (realTarget != null) {
284             // Don&#39;t mutate the passed in arguments
285             ValueNode[] arguments = originalArguments.clone();
286 
287             // Cast receiver to its type.
288             if (!isStatic) {
289                 JavaType receiverType = target.getDeclaringClass();
290                 maybeCastArgument(adder, arguments, 0, receiverType);
291             }
292 
293             // Cast reference arguments to its type.
294             for (int index = 0; index &lt; signature.getParameterCount(false); index++) {
295                 JavaType parameterType = signature.getParameterType(index, target.getDeclaringClass());
296                 maybeCastArgument(adder, arguments, receiverSkip + index, parameterType);
297             }
298             InvokeNode invoke = createTargetInvokeNode(assumptions, intrinsicMethod, realTarget, original, bci, returnStamp, arguments);
299             assert invoke != null : &quot;graph has been modified so this must result an invoke&quot;;
300             return invoke;
301         }
302         return null;
303     }
304 
305     /**
306      * Inserts a node to cast the argument at index to the given type if the given type is more
307      * concrete than the argument type.
308      *
309      * @param adder
310      * @param index of the argument to be cast
311      * @param type the type the argument should be cast to
312      */
313     private static void maybeCastArgument(GraphAdder adder, ValueNode[] arguments, int index, JavaType type) {
314         ValueNode argument = arguments[index];
315         if (type instanceof ResolvedJavaType &amp;&amp; !((ResolvedJavaType) type).isJavaLangObject()) {
316             Assumptions assumptions = adder.getAssumptions();
317             TypeReference targetType = TypeReference.create(assumptions, (ResolvedJavaType) type);
318             /*
319              * When an argument is a Word type, we can have a mismatch of primitive/object types
320              * here. Not inserting a PiNode is a safe fallback, and Word types need no additional
321              * type information anyway.
322              */
323             if (targetType != null &amp;&amp; !targetType.getType().isPrimitive() &amp;&amp; !argument.getStackKind().isPrimitive()) {
324                 ResolvedJavaType argumentType = StampTool.typeOrNull(argument.stamp(NodeView.DEFAULT));
325                 if (argumentType == null || (argumentType.isAssignableFrom(targetType.getType()) &amp;&amp; !argumentType.equals(targetType.getType()))) {
326                     LogicNode inst = InstanceOfNode.createAllowNull(targetType, argument, null, null);
327                     assert !inst.isAlive();
328                     if (!inst.isTautology()) {
329                         inst = adder.add(inst);
330                         AnchoringNode guardAnchor = adder.getGuardAnchor();
331                         DeoptimizationReason reason = DeoptimizationReason.ClassCastException;
332                         DeoptimizationAction action = DeoptimizationAction.InvalidateRecompile;
333                         Speculation speculation = SpeculationLog.NO_SPECULATION;
334                         GuardingNode guard;
335                         if (guardAnchor == null) {
336                             FixedGuardNode fixedGuard = adder.add(new FixedGuardNode(inst, reason, action, speculation, false));
337                             guard = fixedGuard;
338                         } else {
339                             GuardNode newGuard = adder.add(new GuardNode(inst, guardAnchor, reason, action, false, speculation, null));
340                             adder.add(new ValueAnchorNode(newGuard));
341                             guard = newGuard;
342                         }
343                         ValueNode valueNode = adder.add(PiNode.create(argument, StampFactory.object(targetType), guard.asNode()));
344                         arguments[index] = valueNode;
345                     }
346                 }
347             }
348         }
349     }
350 
351     /**
352      * Creates an {@link InvokeNode} for the given target method. The {@link CallTargetNode} passed
353      * to the InvokeNode is in fact a {@link ResolvedMethodHandleCallTargetNode}.
354      *
355      * @return invoke node for the member name target
356      */
357     private static InvokeNode createTargetInvokeNode(Assumptions assumptions, IntrinsicMethod intrinsicMethod, ResolvedJavaMethod target, ResolvedJavaMethod original, int bci, StampPair returnStamp,
358                     ValueNode[] arguments) {
359         InvokeKind targetInvokeKind = target.isStatic() ? InvokeKind.Static : InvokeKind.Special;
360         JavaType targetReturnType = target.getSignature().getReturnType(null);
361 
362         // MethodHandleLinkTo* nodes have a trailing MemberName argument which
363         // needs to be popped.
364         ValueNode[] targetArguments;
365         switch (intrinsicMethod) {
366             case INVOKE_BASIC:
367                 targetArguments = arguments;
368                 break;
369             case LINK_TO_STATIC:
370             case LINK_TO_SPECIAL:
371             case LINK_TO_VIRTUAL:
372             case LINK_TO_INTERFACE:
373                 targetArguments = Arrays.copyOfRange(arguments, 0, arguments.length - 1);
374                 break;
375             default:
376                 throw GraalError.shouldNotReachHere();
377         }
378         StampPair targetReturnStamp = StampFactory.forDeclaredType(assumptions, targetReturnType, false);
379 
380         MethodCallTargetNode callTarget = ResolvedMethodHandleCallTargetNode.create(targetInvokeKind, target, targetArguments, targetReturnStamp, original, arguments, returnStamp);
381 
382         // The call target can have a different return type than the invoker,
383         // e.g. the target returns an Object but the invoker void. In this case
384         // we need to use the stamp of the invoker. Note: always using the
385         // invoker&#39;s stamp would be wrong because it&#39;s a less concrete type
386         // (usually java.lang.Object).
387         if (returnStamp.getTrustedStamp().getStackKind() == JavaKind.Void) {
388             return new InvokeNode(callTarget, bci, StampFactory.forVoid());
389         } else {
390             return new InvokeNode(callTarget, bci);
391         }
392     }
393 }
    </pre>
  </body>
</html>
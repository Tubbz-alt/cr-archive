<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/PEGraphDecoder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NodeIntrinsificationProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ReplacementsImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/PEGraphDecoder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  78 import org.graalvm.compiler.nodes.ParameterNode;
  79 import org.graalvm.compiler.nodes.ReturnNode;
  80 import org.graalvm.compiler.nodes.SimplifyingGraphDecoder;
  81 import org.graalvm.compiler.nodes.StateSplit;
  82 import org.graalvm.compiler.nodes.StructuredGraph;
  83 import org.graalvm.compiler.nodes.UnwindNode;
  84 import org.graalvm.compiler.nodes.ValueNode;
  85 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  86 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  87 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
  88 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedInvocationPlugin;
  89 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
  90 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
  91 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo;
  92 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
  93 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
  94 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
  95 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.InvocationPluginReceiver;
  96 import org.graalvm.compiler.nodes.graphbuilderconf.LoopExplosionPlugin;
  97 import org.graalvm.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind;

  98 import org.graalvm.compiler.nodes.graphbuilderconf.NodePlugin;
  99 import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
 100 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 101 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 102 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 103 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 104 import org.graalvm.compiler.nodes.java.NewArrayNode;
 105 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 106 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
 107 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 108 import org.graalvm.compiler.nodes.java.StoreIndexedNode;


 109 import org.graalvm.compiler.nodes.spi.StampProvider;
 110 import org.graalvm.compiler.nodes.type.StampTool;
 111 import org.graalvm.compiler.nodes.util.GraphUtil;
 112 import org.graalvm.compiler.options.Option;
 113 import org.graalvm.compiler.options.OptionKey;
 114 import org.graalvm.compiler.options.OptionType;
 115 import org.graalvm.compiler.options.OptionValues;
 116 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 117 
 118 import jdk.vm.ci.code.Architecture;
 119 import jdk.vm.ci.code.BailoutException;
 120 import jdk.vm.ci.code.BytecodeFrame;
 121 import jdk.vm.ci.meta.Assumptions;
 122 import jdk.vm.ci.meta.ConstantReflectionProvider;
 123 import jdk.vm.ci.meta.DeoptimizationAction;
 124 import jdk.vm.ci.meta.DeoptimizationReason;
 125 import jdk.vm.ci.meta.JavaConstant;
 126 import jdk.vm.ci.meta.JavaKind;
 127 import jdk.vm.ci.meta.JavaType;
 128 import jdk.vm.ci.meta.MetaAccessProvider;
</pre>
<hr />
<pre>
 254         }
 255 
 256         @Override
 257         public String getLanguage() {
 258             throw new IllegalStateException(getClass().getSimpleName() + &quot; should not be reachable.&quot;);
 259         }
 260     }
 261 
 262     protected class PENonAppendGraphBuilderContext implements GraphBuilderContext {
 263         protected final PEMethodScope methodScope;
 264         protected final Invoke invoke;
 265 
 266         @Override
 267         public ExternalInliningContext getExternalInliningContext() {
 268             return new ExternalInliningContext() {
 269                 @Override
 270                 public int getInlinedDepth() {
 271                     int count = 0;
 272                     PEGraphDecoder.PEMethodScope scope = methodScope;
 273                     while (scope != null) {
<span class="line-modified"> 274                         if (scope.method.equals(callInlinedMethod)) {</span>
 275                             count++;
 276                         }
 277                         scope = scope.caller;
 278                     }
 279                     return count;
 280                 }
 281             };
 282         }
 283 
 284         public PENonAppendGraphBuilderContext(PEMethodScope methodScope, Invoke invoke) {
 285             this.methodScope = methodScope;
 286             this.invoke = invoke;
 287         }
 288 
 289         /**
 290          * {@link Fold} and {@link NodeIntrinsic} can be deferred during parsing/decoding. Only by
 291          * the end of {@linkplain SnippetTemplate#instantiate Snippet instantiation} do they need to
 292          * have been processed.
 293          *
 294          * This is how SVM handles snippets. They are parsed with plugins disabled and then encoded
 295          * and stored in the image. When the snippet is needed at runtime the graph is decoded and
 296          * the plugins are run during the decoding process. If they aren&#39;t handled at this point
 297          * then they will never be handled.
 298          */
 299         @Override
 300         public boolean canDeferPlugin(GeneratedInvocationPlugin plugin) {
<span class="line-modified"> 301             return plugin.getSource().equals(Fold.class) || plugin.getSource().equals(Node.NodeIntrinsic.class);</span>
 302         }
 303 
 304         @Override
 305         public BailoutException bailout(String string) {
 306             BailoutException bailout = new PermanentBailoutException(string);
 307             throw GraphUtil.createBailoutException(string, bailout, GraphUtil.approxSourceStackTraceElement(methodScope.getCallerBytecodePosition()));
 308         }
 309 
 310         @Override
 311         public StampProvider getStampProvider() {
<span class="line-modified"> 312             return stampProvider;</span>
 313         }
 314 
 315         @Override
 316         public MetaAccessProvider getMetaAccess() {
<span class="line-modified"> 317             return metaAccess;</span>
 318         }
 319 
 320         @Override
 321         public ConstantReflectionProvider getConstantReflection() {
<span class="line-modified"> 322             return constantReflection;</span>
 323         }
 324 
 325         @Override
 326         public ConstantFieldProvider getConstantFieldProvider() {
<span class="line-modified"> 327             return constantFieldProvider;</span>





 328         }
 329 
 330         @Override
 331         public StructuredGraph getGraph() {
 332             return graph;
 333         }
 334 
 335         @Override
 336         public int getDepth() {
 337             return methodScope.inliningDepth;
 338         }
 339 
 340         @Override
 341         public IntrinsicContext getIntrinsic() {
<span class="line-modified"> 342             return null;</span>
 343         }
 344 
 345         @Override
 346         public &lt;T extends ValueNode&gt; T append(T value) {
 347             throw unimplemented();
 348         }
 349 
 350         @Override
 351         public void push(JavaKind kind, ValueNode value) {
 352             throw unimplemented();
 353         }
 354 
 355         @Override
 356         public Invoke handleReplacedInvoke(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, boolean inlineEverything) {
 357             throw unimplemented();
 358         }
 359 
 360         @Override
 361         public void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType) {
 362             throw unimplemented();
 363         }
 364 
 365         @Override
 366         public boolean intrinsify(BytecodeProvider bytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] args) {
 367             return false;
 368         }
 369 





 370         @Override
 371         public void setStateAfter(StateSplit stateSplit) {
 372             throw unimplemented();
 373         }
 374 
 375         @Override
 376         public GraphBuilderContext getParent() {
 377             throw unimplemented();
 378         }
 379 
 380         @Override
 381         public Bytecode getCode() {
 382             throw unimplemented();
 383         }
 384 
 385         @Override
 386         public ResolvedJavaMethod getMethod() {
 387             throw unimplemented();
 388         }
 389 
</pre>
<hr />
<pre>
 398         }
 399 
 400         @Override
 401         public JavaType getInvokeReturnType() {
 402             throw unimplemented();
 403         }
 404 
 405         @Override
 406         public String toString() {
 407             Formatter fmt = new Formatter();
 408             PEMethodScope scope = this.methodScope;
 409             fmt.format(&quot;%s&quot;, new ResolvedJavaMethodBytecode(scope.method).asStackTraceElement(invoke.bci()));
 410             NodeSourcePosition callers = scope.getCallerBytecodePosition();
 411             if (callers != null) {
 412                 fmt.format(&quot;%n%s&quot;, callers);
 413             }
 414             return fmt.toString();
 415         }
 416     }
 417 




 418     protected class PEAppendGraphBuilderContext extends PENonAppendGraphBuilderContext {
 419         protected FixedWithNextNode lastInstr;
 420         protected ValueNode pushedNode;
 421         protected boolean invokeConsumed;
 422         protected final InvokeKind invokeKind;
 423         protected final JavaType invokeReturnType;
 424 
 425         public PEAppendGraphBuilderContext(PEMethodScope inlineScope, FixedWithNextNode lastInstr) {
 426             this(inlineScope, lastInstr, null, null);
 427         }
 428 
 429         public PEAppendGraphBuilderContext(PEMethodScope inlineScope, FixedWithNextNode lastInstr, InvokeKind invokeKind, JavaType invokeReturnType) {
 430             super(inlineScope, inlineScope.invokeData != null ? inlineScope.invokeData.invoke : null);
 431             this.lastInstr = lastInstr;
 432             this.invokeKind = invokeKind;
 433             this.invokeReturnType = invokeReturnType;
 434         }
 435 
 436         @Override
 437         public void push(JavaKind kind, ValueNode value) {
</pre>
<hr />
<pre>
 499         }
 500 
 501         @Override
 502         public JavaType getInvokeReturnType() {
 503             if (invokeReturnType != null) {
 504                 return invokeReturnType;
 505             }
 506             return super.getInvokeReturnType();
 507         }
 508 
 509         @Override
 510         public void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType) {
 511             if (invokeConsumed) {
 512                 throw unimplemented(&quot;handleReplacedInvoke can be called only once&quot;);
 513             }
 514             invokeConsumed = true;
 515 
 516             appendInvoke(methodScope.caller, methodScope.callerLoopScope, methodScope.invokeData, callTarget);
 517             updateLastInstruction(invoke.asNode());
 518         }





 519     }
 520 
 521     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
 522     static class ExceptionPlaceholderNode extends ValueNode {
 523         public static final NodeClass&lt;ExceptionPlaceholderNode&gt; TYPE = NodeClass.create(ExceptionPlaceholderNode.class);
 524 
 525         protected ExceptionPlaceholderNode() {
 526             super(TYPE, StampFactory.object());
 527         }
 528     }
 529 
 530     protected static class SpecialCallTargetCacheKey {
 531         private final InvokeKind invokeKind;
 532         private final ResolvedJavaMethod targetMethod;
 533         private final ResolvedJavaType contextType;
 534         private final Stamp receiverStamp;
 535 
 536         public SpecialCallTargetCacheKey(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ResolvedJavaType contextType, Stamp receiverStamp) {
 537             this.invokeKind = invokeKind;
 538             this.targetMethod = targetMethod;
</pre>
<hr />
<pre>
 546         }
 547 
 548         @Override
 549         public boolean equals(Object obj) {
 550             if (obj instanceof SpecialCallTargetCacheKey) {
 551                 SpecialCallTargetCacheKey key = (SpecialCallTargetCacheKey) obj;
 552                 return key.invokeKind.equals(this.invokeKind) &amp;&amp; key.targetMethod.equals(this.targetMethod) &amp;&amp; key.contextType.equals(this.contextType) &amp;&amp; key.receiverStamp.equals(this.receiverStamp);
 553             }
 554             return false;
 555         }
 556     }
 557 
 558     private final LoopExplosionPlugin loopExplosionPlugin;
 559     private final InvocationPlugins invocationPlugins;
 560     private final InlineInvokePlugin[] inlineInvokePlugins;
 561     private final ParameterPlugin parameterPlugin;
 562     private final NodePlugin[] nodePlugins;
 563     private final EconomicMap&lt;SpecialCallTargetCacheKey, Object&gt; specialCallTargetCache;
 564     private final EconomicMap&lt;ResolvedJavaMethod, Object&gt; invocationPluginCache;
 565     private final ResolvedJavaMethod callInlinedMethod;

 566     protected final SourceLanguagePositionProvider sourceLanguagePositionProvider;
 567 
<span class="line-modified"> 568     public PEGraphDecoder(Architecture architecture, StructuredGraph graph, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,</span>
<span class="line-modified"> 569                     StampProvider stampProvider, LoopExplosionPlugin loopExplosionPlugin, InvocationPlugins invocationPlugins, InlineInvokePlugin[] inlineInvokePlugins,</span>
 570                     ParameterPlugin parameterPlugin,
<span class="line-modified"> 571                     NodePlugin[] nodePlugins, ResolvedJavaMethod callInlinedMethod, SourceLanguagePositionProvider sourceLanguagePositionProvider) {</span>
<span class="line-modified"> 572         super(architecture, graph, metaAccess, constantReflection, constantFieldProvider, stampProvider, true);</span>
 573         this.loopExplosionPlugin = loopExplosionPlugin;
 574         this.invocationPlugins = invocationPlugins;
 575         this.inlineInvokePlugins = inlineInvokePlugins;
 576         this.parameterPlugin = parameterPlugin;
 577         this.nodePlugins = nodePlugins;

 578         this.specialCallTargetCache = EconomicMap.create(Equivalence.DEFAULT);
 579         this.invocationPluginCache = EconomicMap.create(Equivalence.DEFAULT);
 580         this.callInlinedMethod = callInlinedMethod;
 581         this.sourceLanguagePositionProvider = sourceLanguagePositionProvider;
 582     }
 583 
 584     protected static LoopExplosionKind loopExplosionKind(ResolvedJavaMethod method, LoopExplosionPlugin loopExplosionPlugin) {
 585         if (loopExplosionPlugin == null) {
 586             return LoopExplosionKind.NONE;
 587         } else {
 588             return loopExplosionPlugin.loopExplosionKind(method);
 589         }
 590     }
 591 
 592     @SuppressWarnings(&quot;try&quot;)
 593     public void decode(ResolvedJavaMethod method, boolean isSubstitution, boolean trackNodeSourcePosition) {
 594         try (DebugContext.Scope scope = debug.scope(&quot;PEGraphDecode&quot;, graph)) {
 595             EncodedGraph encodedGraph = lookupEncodedGraph(method, null, null, isSubstitution, trackNodeSourcePosition);
 596             PEMethodScope methodScope = new PEMethodScope(graph, null, null, encodedGraph, method, null, 0, loopExplosionPlugin, null);
 597             decode(createInitialLoopScope(methodScope, null));
</pre>
<hr />
<pre>
 805 
 806         return invocationPlugin == CACHED_NULL_VALUE ? null : (InvocationPlugin) invocationPlugin;
 807     }
 808 
 809     protected LoopScope tryInline(PEMethodScope methodScope, LoopScope loopScope, InvokeData invokeData, MethodCallTargetNode callTarget) {
 810         if (!callTarget.invokeKind().isDirect()) {
 811             return null;
 812         }
 813 
 814         ResolvedJavaMethod targetMethod = callTarget.targetMethod();
 815         if (targetMethod.hasNeverInlineDirective()) {
 816             return null;
 817         }
 818 
 819         ValueNode[] arguments = callTarget.arguments().toArray(new ValueNode[0]);
 820         GraphBuilderContext graphBuilderContext = new PENonAppendGraphBuilderContext(methodScope, invokeData.invoke);
 821 
 822         for (InlineInvokePlugin plugin : inlineInvokePlugins) {
 823             InlineInfo inlineInfo = plugin.shouldInlineInvoke(graphBuilderContext, targetMethod, arguments);
 824             if (inlineInfo != null) {
<span class="line-modified"> 825                 if (inlineInfo.getMethodToInline() == null) {</span>
<span class="line-removed"> 826                     return null;</span>
<span class="line-removed"> 827                 } else {</span>
 828                     return doInline(methodScope, loopScope, invokeData, inlineInfo, arguments);


 829                 }
 830             }
 831         }
 832         return null;
 833     }
 834 
 835     protected LoopScope doInline(PEMethodScope methodScope, LoopScope loopScope, InvokeData invokeData, InlineInfo inlineInfo, ValueNode[] arguments) {
 836         if (!invokeData.invoke.useForInlining()) {
 837             return null;
 838         }
 839         ResolvedJavaMethod inlineMethod = inlineInfo.getMethodToInline();
<span class="line-modified"> 840         ResolvedJavaMethod originalMethod = inlineInfo.getOriginalMethod();</span>
<span class="line-removed"> 841         boolean isSubstitution = originalMethod != null &amp;&amp; !originalMethod.equals(inlineMethod);</span>
<span class="line-removed"> 842         EncodedGraph graphToInline = lookupEncodedGraph(inlineMethod, originalMethod, inlineInfo.getIntrinsicBytecodeProvider(), isSubstitution, graph.trackNodeSourcePosition());</span>
 843         if (graphToInline == null) {
 844             return null;
 845         }
 846 
 847         assert !graph.trackNodeSourcePosition() || graphToInline.trackNodeSourcePosition() : graph + &quot; &quot; + graphToInline;
 848         if (methodScope.inliningDepth &gt; Options.InliningDepthError.getValue(options)) {
 849             throw tooDeepInlining(methodScope);
 850         }
 851 
 852         for (InlineInvokePlugin plugin : inlineInvokePlugins) {
 853             plugin.notifyBeforeInline(inlineMethod);
 854         }
 855 
 856         Invoke invoke = invokeData.invoke;
 857         FixedNode invokeNode = invoke.asNode();
 858         FixedWithNextNode predecessor = (FixedWithNextNode) invokeNode.predecessor();
 859         invokeNode.replaceAtPredecessor(null);
 860 
 861         PEMethodScope inlineScope = new PEMethodScope(graph, methodScope, loopScope, graphToInline, inlineMethod, invokeData, methodScope.inliningDepth + 1,
 862                         loopExplosionPlugin, arguments);
</pre>
<hr />
<pre>
1091             n = makeStubNode(methodScope, loopScope, invokeData.nextNextOrderId);
1092         } else {
1093             n = makeStubNode(methodScope, loopScope, invokeData.nextOrderId);
1094         }
1095         return n;
1096     }
1097 
1098     private static void deleteInvoke(Invoke invoke) {
1099         /*
1100          * Clean up unused nodes. We cannot just call killCFG on the invoke node because that can
1101          * kill too much: nodes that are decoded later can use values that appear unused by now.
1102          */
1103         FrameState frameState = invoke.stateAfter();
1104         invoke.asNode().safeDelete();
1105         assert invoke.callTarget() == null : &quot;must not have been added to the graph yet&quot;;
1106         if (frameState != null &amp;&amp; frameState.hasNoUsages()) {
1107             frameState.safeDelete();
1108         }
1109     }
1110 
<span class="line-modified">1111     protected abstract EncodedGraph lookupEncodedGraph(ResolvedJavaMethod method, ResolvedJavaMethod originalMethod, BytecodeProvider intrinsicBytecodeProvider, boolean isSubstitution,</span>
1112                     boolean trackNodeSourcePosition);
1113 
1114     @Override
1115     protected void handleFixedNode(MethodScope s, LoopScope loopScope, int nodeOrderId, FixedNode node) {
1116         PEMethodScope methodScope = (PEMethodScope) s;
1117 
1118         if (node instanceof ForeignCallNode) {
1119             ForeignCallNode foreignCall = (ForeignCallNode) node;
1120             if (foreignCall.getBci() == BytecodeFrame.UNKNOWN_BCI &amp;&amp; methodScope.invokeData != null) {
1121                 foreignCall.setBci(methodScope.invokeData.invoke.bci());
1122             }
1123         }
1124 
1125         super.handleFixedNode(methodScope, loopScope, nodeOrderId, node);
1126     }
1127 
1128     @SuppressWarnings(&quot;try&quot;)
1129     @Override
1130     protected Node canonicalizeFixedNode(MethodScope s, Node node) {
1131         PEMethodScope methodScope = (PEMethodScope) s;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  78 import org.graalvm.compiler.nodes.ParameterNode;
  79 import org.graalvm.compiler.nodes.ReturnNode;
  80 import org.graalvm.compiler.nodes.SimplifyingGraphDecoder;
  81 import org.graalvm.compiler.nodes.StateSplit;
  82 import org.graalvm.compiler.nodes.StructuredGraph;
  83 import org.graalvm.compiler.nodes.UnwindNode;
  84 import org.graalvm.compiler.nodes.ValueNode;
  85 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  86 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  87 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
  88 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedInvocationPlugin;
  89 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
  90 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
  91 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo;
  92 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
  93 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
  94 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
  95 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.InvocationPluginReceiver;
  96 import org.graalvm.compiler.nodes.graphbuilderconf.LoopExplosionPlugin;
  97 import org.graalvm.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind;
<span class="line-added">  98 import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;</span>
  99 import org.graalvm.compiler.nodes.graphbuilderconf.NodePlugin;
 100 import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
 101 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 102 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 103 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 104 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 105 import org.graalvm.compiler.nodes.java.NewArrayNode;
 106 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 107 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
 108 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 109 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
<span class="line-added"> 110 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
<span class="line-added"> 111 import org.graalvm.compiler.nodes.spi.Replacements;</span>
 112 import org.graalvm.compiler.nodes.spi.StampProvider;
 113 import org.graalvm.compiler.nodes.type.StampTool;
 114 import org.graalvm.compiler.nodes.util.GraphUtil;
 115 import org.graalvm.compiler.options.Option;
 116 import org.graalvm.compiler.options.OptionKey;
 117 import org.graalvm.compiler.options.OptionType;
 118 import org.graalvm.compiler.options.OptionValues;
 119 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 120 
 121 import jdk.vm.ci.code.Architecture;
 122 import jdk.vm.ci.code.BailoutException;
 123 import jdk.vm.ci.code.BytecodeFrame;
 124 import jdk.vm.ci.meta.Assumptions;
 125 import jdk.vm.ci.meta.ConstantReflectionProvider;
 126 import jdk.vm.ci.meta.DeoptimizationAction;
 127 import jdk.vm.ci.meta.DeoptimizationReason;
 128 import jdk.vm.ci.meta.JavaConstant;
 129 import jdk.vm.ci.meta.JavaKind;
 130 import jdk.vm.ci.meta.JavaType;
 131 import jdk.vm.ci.meta.MetaAccessProvider;
</pre>
<hr />
<pre>
 257         }
 258 
 259         @Override
 260         public String getLanguage() {
 261             throw new IllegalStateException(getClass().getSimpleName() + &quot; should not be reachable.&quot;);
 262         }
 263     }
 264 
 265     protected class PENonAppendGraphBuilderContext implements GraphBuilderContext {
 266         protected final PEMethodScope methodScope;
 267         protected final Invoke invoke;
 268 
 269         @Override
 270         public ExternalInliningContext getExternalInliningContext() {
 271             return new ExternalInliningContext() {
 272                 @Override
 273                 public int getInlinedDepth() {
 274                     int count = 0;
 275                     PEGraphDecoder.PEMethodScope scope = methodScope;
 276                     while (scope != null) {
<span class="line-modified"> 277                         if (scope.method.equals(callInlinedMethod) || scope.method.equals(callInlinedAgnosticMethod)) {</span>
 278                             count++;
 279                         }
 280                         scope = scope.caller;
 281                     }
 282                     return count;
 283                 }
 284             };
 285         }
 286 
 287         public PENonAppendGraphBuilderContext(PEMethodScope methodScope, Invoke invoke) {
 288             this.methodScope = methodScope;
 289             this.invoke = invoke;
 290         }
 291 
 292         /**
 293          * {@link Fold} and {@link NodeIntrinsic} can be deferred during parsing/decoding. Only by
 294          * the end of {@linkplain SnippetTemplate#instantiate Snippet instantiation} do they need to
 295          * have been processed.
 296          *
 297          * This is how SVM handles snippets. They are parsed with plugins disabled and then encoded
 298          * and stored in the image. When the snippet is needed at runtime the graph is decoded and
 299          * the plugins are run during the decoding process. If they aren&#39;t handled at this point
 300          * then they will never be handled.
 301          */
 302         @Override
 303         public boolean canDeferPlugin(GeneratedInvocationPlugin plugin) {
<span class="line-modified"> 304             return plugin.isGeneratedFromFoldOrNodeIntrinsic();</span>
 305         }
 306 
 307         @Override
 308         public BailoutException bailout(String string) {
 309             BailoutException bailout = new PermanentBailoutException(string);
 310             throw GraphUtil.createBailoutException(string, bailout, GraphUtil.approxSourceStackTraceElement(methodScope.getCallerBytecodePosition()));
 311         }
 312 
 313         @Override
 314         public StampProvider getStampProvider() {
<span class="line-modified"> 315             return providers.getStampProvider();</span>
 316         }
 317 
 318         @Override
 319         public MetaAccessProvider getMetaAccess() {
<span class="line-modified"> 320             return providers.getMetaAccess();</span>
 321         }
 322 
 323         @Override
 324         public ConstantReflectionProvider getConstantReflection() {
<span class="line-modified"> 325             return providers.getConstantReflection();</span>
 326         }
 327 
 328         @Override
 329         public ConstantFieldProvider getConstantFieldProvider() {
<span class="line-modified"> 330             return providers.getConstantFieldProvider();</span>
<span class="line-added"> 331         }</span>
<span class="line-added"> 332 </span>
<span class="line-added"> 333         @Override</span>
<span class="line-added"> 334         public Replacements getReplacements() {</span>
<span class="line-added"> 335             return providers.getReplacements();</span>
 336         }
 337 
 338         @Override
 339         public StructuredGraph getGraph() {
 340             return graph;
 341         }
 342 
 343         @Override
 344         public int getDepth() {
 345             return methodScope.inliningDepth;
 346         }
 347 
 348         @Override
 349         public IntrinsicContext getIntrinsic() {
<span class="line-modified"> 350             return PEGraphDecoder.this.getIntrinsic();</span>
 351         }
 352 
 353         @Override
 354         public &lt;T extends ValueNode&gt; T append(T value) {
 355             throw unimplemented();
 356         }
 357 
 358         @Override
 359         public void push(JavaKind kind, ValueNode value) {
 360             throw unimplemented();
 361         }
 362 
 363         @Override
 364         public Invoke handleReplacedInvoke(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, boolean inlineEverything) {
 365             throw unimplemented();
 366         }
 367 
 368         @Override
 369         public void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType) {
 370             throw unimplemented();
 371         }
 372 
 373         @Override
 374         public boolean intrinsify(BytecodeProvider bytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] args) {
 375             return false;
 376         }
 377 
<span class="line-added"> 378         @Override</span>
<span class="line-added"> 379         public boolean intrinsify(ResolvedJavaMethod targetMethod, StructuredGraph substituteGraph, InvocationPlugin.Receiver receiver, ValueNode[] argsIncludingReceiver) {</span>
<span class="line-added"> 380             return false;</span>
<span class="line-added"> 381         }</span>
<span class="line-added"> 382 </span>
 383         @Override
 384         public void setStateAfter(StateSplit stateSplit) {
 385             throw unimplemented();
 386         }
 387 
 388         @Override
 389         public GraphBuilderContext getParent() {
 390             throw unimplemented();
 391         }
 392 
 393         @Override
 394         public Bytecode getCode() {
 395             throw unimplemented();
 396         }
 397 
 398         @Override
 399         public ResolvedJavaMethod getMethod() {
 400             throw unimplemented();
 401         }
 402 
</pre>
<hr />
<pre>
 411         }
 412 
 413         @Override
 414         public JavaType getInvokeReturnType() {
 415             throw unimplemented();
 416         }
 417 
 418         @Override
 419         public String toString() {
 420             Formatter fmt = new Formatter();
 421             PEMethodScope scope = this.methodScope;
 422             fmt.format(&quot;%s&quot;, new ResolvedJavaMethodBytecode(scope.method).asStackTraceElement(invoke.bci()));
 423             NodeSourcePosition callers = scope.getCallerBytecodePosition();
 424             if (callers != null) {
 425                 fmt.format(&quot;%n%s&quot;, callers);
 426             }
 427             return fmt.toString();
 428         }
 429     }
 430 
<span class="line-added"> 431     protected IntrinsicContext getIntrinsic() {</span>
<span class="line-added"> 432         return null;</span>
<span class="line-added"> 433     }</span>
<span class="line-added"> 434 </span>
 435     protected class PEAppendGraphBuilderContext extends PENonAppendGraphBuilderContext {
 436         protected FixedWithNextNode lastInstr;
 437         protected ValueNode pushedNode;
 438         protected boolean invokeConsumed;
 439         protected final InvokeKind invokeKind;
 440         protected final JavaType invokeReturnType;
 441 
 442         public PEAppendGraphBuilderContext(PEMethodScope inlineScope, FixedWithNextNode lastInstr) {
 443             this(inlineScope, lastInstr, null, null);
 444         }
 445 
 446         public PEAppendGraphBuilderContext(PEMethodScope inlineScope, FixedWithNextNode lastInstr, InvokeKind invokeKind, JavaType invokeReturnType) {
 447             super(inlineScope, inlineScope.invokeData != null ? inlineScope.invokeData.invoke : null);
 448             this.lastInstr = lastInstr;
 449             this.invokeKind = invokeKind;
 450             this.invokeReturnType = invokeReturnType;
 451         }
 452 
 453         @Override
 454         public void push(JavaKind kind, ValueNode value) {
</pre>
<hr />
<pre>
 516         }
 517 
 518         @Override
 519         public JavaType getInvokeReturnType() {
 520             if (invokeReturnType != null) {
 521                 return invokeReturnType;
 522             }
 523             return super.getInvokeReturnType();
 524         }
 525 
 526         @Override
 527         public void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType) {
 528             if (invokeConsumed) {
 529                 throw unimplemented(&quot;handleReplacedInvoke can be called only once&quot;);
 530             }
 531             invokeConsumed = true;
 532 
 533             appendInvoke(methodScope.caller, methodScope.callerLoopScope, methodScope.invokeData, callTarget);
 534             updateLastInstruction(invoke.asNode());
 535         }
<span class="line-added"> 536 </span>
<span class="line-added"> 537         @Override</span>
<span class="line-added"> 538         public GraphBuilderContext getNonIntrinsicAncestor() {</span>
<span class="line-added"> 539             return null;</span>
<span class="line-added"> 540         }</span>
 541     }
 542 
 543     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
 544     static class ExceptionPlaceholderNode extends ValueNode {
 545         public static final NodeClass&lt;ExceptionPlaceholderNode&gt; TYPE = NodeClass.create(ExceptionPlaceholderNode.class);
 546 
 547         protected ExceptionPlaceholderNode() {
 548             super(TYPE, StampFactory.object());
 549         }
 550     }
 551 
 552     protected static class SpecialCallTargetCacheKey {
 553         private final InvokeKind invokeKind;
 554         private final ResolvedJavaMethod targetMethod;
 555         private final ResolvedJavaType contextType;
 556         private final Stamp receiverStamp;
 557 
 558         public SpecialCallTargetCacheKey(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ResolvedJavaType contextType, Stamp receiverStamp) {
 559             this.invokeKind = invokeKind;
 560             this.targetMethod = targetMethod;
</pre>
<hr />
<pre>
 568         }
 569 
 570         @Override
 571         public boolean equals(Object obj) {
 572             if (obj instanceof SpecialCallTargetCacheKey) {
 573                 SpecialCallTargetCacheKey key = (SpecialCallTargetCacheKey) obj;
 574                 return key.invokeKind.equals(this.invokeKind) &amp;&amp; key.targetMethod.equals(this.targetMethod) &amp;&amp; key.contextType.equals(this.contextType) &amp;&amp; key.receiverStamp.equals(this.receiverStamp);
 575             }
 576             return false;
 577         }
 578     }
 579 
 580     private final LoopExplosionPlugin loopExplosionPlugin;
 581     private final InvocationPlugins invocationPlugins;
 582     private final InlineInvokePlugin[] inlineInvokePlugins;
 583     private final ParameterPlugin parameterPlugin;
 584     private final NodePlugin[] nodePlugins;
 585     private final EconomicMap&lt;SpecialCallTargetCacheKey, Object&gt; specialCallTargetCache;
 586     private final EconomicMap&lt;ResolvedJavaMethod, Object&gt; invocationPluginCache;
 587     private final ResolvedJavaMethod callInlinedMethod;
<span class="line-added"> 588     private final ResolvedJavaMethod callInlinedAgnosticMethod;</span>
 589     protected final SourceLanguagePositionProvider sourceLanguagePositionProvider;
 590 
<span class="line-modified"> 591     public PEGraphDecoder(Architecture architecture, StructuredGraph graph, CoreProviders providers, LoopExplosionPlugin loopExplosionPlugin, InvocationPlugins invocationPlugins,</span>
<span class="line-modified"> 592                     InlineInvokePlugin[] inlineInvokePlugins,</span>
 593                     ParameterPlugin parameterPlugin,
<span class="line-modified"> 594                     NodePlugin[] nodePlugins, ResolvedJavaMethod callInlinedMethod, ResolvedJavaMethod callInlinedAgnosticMethod, SourceLanguagePositionProvider sourceLanguagePositionProvider) {</span>
<span class="line-modified"> 595         super(architecture, graph, providers, true);</span>
 596         this.loopExplosionPlugin = loopExplosionPlugin;
 597         this.invocationPlugins = invocationPlugins;
 598         this.inlineInvokePlugins = inlineInvokePlugins;
 599         this.parameterPlugin = parameterPlugin;
 600         this.nodePlugins = nodePlugins;
<span class="line-added"> 601         this.callInlinedAgnosticMethod = callInlinedAgnosticMethod;</span>
 602         this.specialCallTargetCache = EconomicMap.create(Equivalence.DEFAULT);
 603         this.invocationPluginCache = EconomicMap.create(Equivalence.DEFAULT);
 604         this.callInlinedMethod = callInlinedMethod;
 605         this.sourceLanguagePositionProvider = sourceLanguagePositionProvider;
 606     }
 607 
 608     protected static LoopExplosionKind loopExplosionKind(ResolvedJavaMethod method, LoopExplosionPlugin loopExplosionPlugin) {
 609         if (loopExplosionPlugin == null) {
 610             return LoopExplosionKind.NONE;
 611         } else {
 612             return loopExplosionPlugin.loopExplosionKind(method);
 613         }
 614     }
 615 
 616     @SuppressWarnings(&quot;try&quot;)
 617     public void decode(ResolvedJavaMethod method, boolean isSubstitution, boolean trackNodeSourcePosition) {
 618         try (DebugContext.Scope scope = debug.scope(&quot;PEGraphDecode&quot;, graph)) {
 619             EncodedGraph encodedGraph = lookupEncodedGraph(method, null, null, isSubstitution, trackNodeSourcePosition);
 620             PEMethodScope methodScope = new PEMethodScope(graph, null, null, encodedGraph, method, null, 0, loopExplosionPlugin, null);
 621             decode(createInitialLoopScope(methodScope, null));
</pre>
<hr />
<pre>
 829 
 830         return invocationPlugin == CACHED_NULL_VALUE ? null : (InvocationPlugin) invocationPlugin;
 831     }
 832 
 833     protected LoopScope tryInline(PEMethodScope methodScope, LoopScope loopScope, InvokeData invokeData, MethodCallTargetNode callTarget) {
 834         if (!callTarget.invokeKind().isDirect()) {
 835             return null;
 836         }
 837 
 838         ResolvedJavaMethod targetMethod = callTarget.targetMethod();
 839         if (targetMethod.hasNeverInlineDirective()) {
 840             return null;
 841         }
 842 
 843         ValueNode[] arguments = callTarget.arguments().toArray(new ValueNode[0]);
 844         GraphBuilderContext graphBuilderContext = new PENonAppendGraphBuilderContext(methodScope, invokeData.invoke);
 845 
 846         for (InlineInvokePlugin plugin : inlineInvokePlugins) {
 847             InlineInfo inlineInfo = plugin.shouldInlineInvoke(graphBuilderContext, targetMethod, arguments);
 848             if (inlineInfo != null) {
<span class="line-modified"> 849                 if (inlineInfo.allowsInlining()) {</span>


 850                     return doInline(methodScope, loopScope, invokeData, inlineInfo, arguments);
<span class="line-added"> 851                 } else {</span>
<span class="line-added"> 852                     return null;</span>
 853                 }
 854             }
 855         }
 856         return null;
 857     }
 858 
 859     protected LoopScope doInline(PEMethodScope methodScope, LoopScope loopScope, InvokeData invokeData, InlineInfo inlineInfo, ValueNode[] arguments) {
 860         if (!invokeData.invoke.useForInlining()) {
 861             return null;
 862         }
 863         ResolvedJavaMethod inlineMethod = inlineInfo.getMethodToInline();
<span class="line-modified"> 864         EncodedGraph graphToInline = lookupEncodedGraph(inlineMethod, inlineInfo.getPlugin(), inlineInfo.getIntrinsicBytecodeProvider(), inlineInfo.isSubstitution(), graph.trackNodeSourcePosition());</span>


 865         if (graphToInline == null) {
 866             return null;
 867         }
 868 
 869         assert !graph.trackNodeSourcePosition() || graphToInline.trackNodeSourcePosition() : graph + &quot; &quot; + graphToInline;
 870         if (methodScope.inliningDepth &gt; Options.InliningDepthError.getValue(options)) {
 871             throw tooDeepInlining(methodScope);
 872         }
 873 
 874         for (InlineInvokePlugin plugin : inlineInvokePlugins) {
 875             plugin.notifyBeforeInline(inlineMethod);
 876         }
 877 
 878         Invoke invoke = invokeData.invoke;
 879         FixedNode invokeNode = invoke.asNode();
 880         FixedWithNextNode predecessor = (FixedWithNextNode) invokeNode.predecessor();
 881         invokeNode.replaceAtPredecessor(null);
 882 
 883         PEMethodScope inlineScope = new PEMethodScope(graph, methodScope, loopScope, graphToInline, inlineMethod, invokeData, methodScope.inliningDepth + 1,
 884                         loopExplosionPlugin, arguments);
</pre>
<hr />
<pre>
1113             n = makeStubNode(methodScope, loopScope, invokeData.nextNextOrderId);
1114         } else {
1115             n = makeStubNode(methodScope, loopScope, invokeData.nextOrderId);
1116         }
1117         return n;
1118     }
1119 
1120     private static void deleteInvoke(Invoke invoke) {
1121         /*
1122          * Clean up unused nodes. We cannot just call killCFG on the invoke node because that can
1123          * kill too much: nodes that are decoded later can use values that appear unused by now.
1124          */
1125         FrameState frameState = invoke.stateAfter();
1126         invoke.asNode().safeDelete();
1127         assert invoke.callTarget() == null : &quot;must not have been added to the graph yet&quot;;
1128         if (frameState != null &amp;&amp; frameState.hasNoUsages()) {
1129             frameState.safeDelete();
1130         }
1131     }
1132 
<span class="line-modified">1133     protected abstract EncodedGraph lookupEncodedGraph(ResolvedJavaMethod method, MethodSubstitutionPlugin plugin, BytecodeProvider intrinsicBytecodeProvider, boolean isSubstitution,</span>
1134                     boolean trackNodeSourcePosition);
1135 
1136     @Override
1137     protected void handleFixedNode(MethodScope s, LoopScope loopScope, int nodeOrderId, FixedNode node) {
1138         PEMethodScope methodScope = (PEMethodScope) s;
1139 
1140         if (node instanceof ForeignCallNode) {
1141             ForeignCallNode foreignCall = (ForeignCallNode) node;
1142             if (foreignCall.getBci() == BytecodeFrame.UNKNOWN_BCI &amp;&amp; methodScope.invokeData != null) {
1143                 foreignCall.setBci(methodScope.invokeData.invoke.bci());
1144             }
1145         }
1146 
1147         super.handleFixedNode(methodScope, loopScope, nodeOrderId, node);
1148     }
1149 
1150     @SuppressWarnings(&quot;try&quot;)
1151     @Override
1152     protected Node canonicalizeFixedNode(MethodScope s, Node node) {
1153         PEMethodScope methodScope = (PEMethodScope) s;
</pre>
</td>
</tr>
</table>
<center><a href="NodeIntrinsificationProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ReplacementsImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
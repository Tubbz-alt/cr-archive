<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/StandardGraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SnippetTemplate.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="arraycopy/ArrayCopyCallNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/StandardGraphBuilderPlugins.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.replacements;
  26 
  27 import static jdk.vm.ci.code.MemoryBarriers.JMM_POST_VOLATILE_READ;
  28 import static jdk.vm.ci.code.MemoryBarriers.JMM_POST_VOLATILE_WRITE;
  29 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_READ;
  30 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_WRITE;
  31 import static jdk.vm.ci.code.MemoryBarriers.LOAD_LOAD;
  32 import static jdk.vm.ci.code.MemoryBarriers.LOAD_STORE;
  33 import static jdk.vm.ci.code.MemoryBarriers.STORE_LOAD;
  34 import static jdk.vm.ci.code.MemoryBarriers.STORE_STORE;
  35 import static org.graalvm.compiler.nodes.NamedLocationIdentity.OFF_HEAP_LOCATION;
<span class="line-removed">  36 import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java11OrEarlier;</span>
<span class="line-removed">  37 import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java8OrEarlier;</span>
  38 
  39 import java.lang.reflect.Array;
  40 import java.lang.reflect.Field;
  41 import java.util.Arrays;
  42 
  43 import org.graalvm.compiler.api.directives.GraalDirectives;
  44 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
<span class="line-removed">  45 import org.graalvm.compiler.bytecode.BytecodeProvider;</span>
  46 import org.graalvm.compiler.core.common.calc.Condition;
  47 import org.graalvm.compiler.core.common.calc.Condition.CanonicalizedCondition;
  48 import org.graalvm.compiler.core.common.calc.UnsignedMath;
  49 import org.graalvm.compiler.core.common.type.ObjectStamp;
  50 import org.graalvm.compiler.core.common.type.Stamp;
  51 import org.graalvm.compiler.core.common.type.StampFactory;
  52 import org.graalvm.compiler.core.common.type.TypeReference;
  53 import org.graalvm.compiler.debug.GraalError;
  54 import org.graalvm.compiler.graph.Edges;
  55 import org.graalvm.compiler.graph.Node;
  56 import org.graalvm.compiler.graph.NodeList;
  57 import org.graalvm.compiler.nodes.AbstractBeginNode;
  58 import org.graalvm.compiler.nodes.BeginNode;
  59 import org.graalvm.compiler.nodes.ConstantNode;
  60 import org.graalvm.compiler.nodes.DeoptimizeNode;
  61 import org.graalvm.compiler.nodes.EndNode;
  62 import org.graalvm.compiler.nodes.FixedGuardNode;
  63 import org.graalvm.compiler.nodes.FixedWithNextNode;
  64 import org.graalvm.compiler.nodes.IfNode;
  65 import org.graalvm.compiler.nodes.LogicNode;
</pre>
<hr />
<pre>
  70 import org.graalvm.compiler.nodes.StructuredGraph;
  71 import org.graalvm.compiler.nodes.ValueNode;
  72 import org.graalvm.compiler.nodes.ValuePhiNode;
  73 import org.graalvm.compiler.nodes.calc.AbsNode;
  74 import org.graalvm.compiler.nodes.calc.CompareNode;
  75 import org.graalvm.compiler.nodes.calc.ConditionalNode;
  76 import org.graalvm.compiler.nodes.calc.FloatEqualsNode;
  77 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  78 import org.graalvm.compiler.nodes.calc.IsNullNode;
  79 import org.graalvm.compiler.nodes.calc.NarrowNode;
  80 import org.graalvm.compiler.nodes.calc.ReinterpretNode;
  81 import org.graalvm.compiler.nodes.calc.RightShiftNode;
  82 import org.graalvm.compiler.nodes.calc.SignExtendNode;
  83 import org.graalvm.compiler.nodes.calc.SqrtNode;
  84 import org.graalvm.compiler.nodes.calc.UnsignedDivNode;
  85 import org.graalvm.compiler.nodes.calc.UnsignedRemNode;
  86 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  87 import org.graalvm.compiler.nodes.debug.BindToRegisterNode;
  88 import org.graalvm.compiler.nodes.debug.BlackholeNode;
  89 import org.graalvm.compiler.nodes.debug.ControlFlowAnchorNode;

  90 import org.graalvm.compiler.nodes.debug.SpillRegistersNode;
  91 import org.graalvm.compiler.nodes.extended.BoxNode;
  92 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;
  93 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
  94 import org.graalvm.compiler.nodes.extended.GetClassNode;
  95 import org.graalvm.compiler.nodes.extended.GuardingNode;
  96 import org.graalvm.compiler.nodes.extended.JavaReadNode;
  97 import org.graalvm.compiler.nodes.extended.JavaWriteNode;
  98 import org.graalvm.compiler.nodes.extended.MembarNode;
  99 import org.graalvm.compiler.nodes.extended.OpaqueNode;
 100 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 101 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 102 import org.graalvm.compiler.nodes.extended.UnboxNode;
 103 import org.graalvm.compiler.nodes.extended.UnsafeMemoryLoadNode;
 104 import org.graalvm.compiler.nodes.extended.UnsafeMemoryStoreNode;
 105 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 106 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 107 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 108 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 109 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 110 import org.graalvm.compiler.nodes.java.ClassIsAssignableFromNode;
 111 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
 112 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
 113 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 114 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 115 import org.graalvm.compiler.nodes.java.RegisterFinalizerNode;
 116 import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
 117 import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
 118 import org.graalvm.compiler.nodes.memory.HeapAccess;
 119 import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;

 120 import org.graalvm.compiler.nodes.type.StampTool;
 121 import org.graalvm.compiler.nodes.util.GraphUtil;
 122 import org.graalvm.compiler.nodes.virtual.EnsureVirtualizedNode;
 123 import org.graalvm.compiler.replacements.nodes.ProfileBooleanNode;
 124 import org.graalvm.compiler.replacements.nodes.ReverseBytesNode;
 125 import org.graalvm.compiler.replacements.nodes.VirtualizableInvokeMacroNode;
 126 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactNode;
 127 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactOverflowNode;
 128 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactSplitNode;
 129 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerExactArithmeticSplitNode;
 130 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactNode;
 131 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactOverflowNode;
 132 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactSplitNode;
 133 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactNode;
 134 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactOverflowNode;
 135 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactSplitNode;

 136 import org.graalvm.compiler.serviceprovider.SpeculationReasonGroup;
 137 import jdk.internal.vm.compiler.word.LocationIdentity;
 138 
 139 import jdk.vm.ci.code.BytecodePosition;
 140 import jdk.vm.ci.meta.DeoptimizationAction;
 141 import jdk.vm.ci.meta.DeoptimizationReason;
 142 import jdk.vm.ci.meta.JavaConstant;
 143 import jdk.vm.ci.meta.JavaKind;
 144 import jdk.vm.ci.meta.MetaAccessProvider;
 145 import jdk.vm.ci.meta.ResolvedJavaField;
 146 import jdk.vm.ci.meta.ResolvedJavaMethod;
 147 import jdk.vm.ci.meta.ResolvedJavaType;
 148 import jdk.vm.ci.meta.SpeculationLog;
 149 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 150 import jdk.vm.ci.meta.SpeculationLog.SpeculationReason;
 151 import sun.misc.Unsafe;
 152 
 153 /**
 154  * Provides non-runtime specific {@link InvocationPlugin}s.
 155  */
 156 public class StandardGraphBuilderPlugins {
 157 
<span class="line-modified"> 158     public static void registerInvocationPlugins(MetaAccessProvider metaAccess, SnippetReflectionProvider snippetReflection, InvocationPlugins plugins, BytecodeProvider bytecodeProvider,</span>
<span class="line-modified"> 159                     boolean allowDeoptimization, boolean explicitUnsafeNullChecks) {</span>
 160         registerObjectPlugins(plugins);
 161         registerClassPlugins(plugins);
 162         registerMathPlugins(plugins, allowDeoptimization);
 163         registerStrictMathPlugins(plugins);
 164         registerUnsignedMathPlugins(plugins);
<span class="line-modified"> 165         registerStringPlugins(plugins, bytecodeProvider, snippetReflection);</span>
 166         registerCharacterPlugins(plugins);
 167         registerShortPlugins(plugins);
 168         registerIntegerLongPlugins(plugins, JavaKind.Int);
 169         registerIntegerLongPlugins(plugins, JavaKind.Long);
 170         registerFloatPlugins(plugins);
 171         registerDoublePlugins(plugins);
<span class="line-modified"> 172         registerArraysPlugins(plugins, bytecodeProvider);</span>
<span class="line-modified"> 173         registerArrayPlugins(plugins, bytecodeProvider);</span>
<span class="line-modified"> 174         registerUnsafePlugins(plugins, bytecodeProvider, explicitUnsafeNullChecks);</span>


 175         registerEdgesPlugins(metaAccess, plugins);
 176         registerGraalDirectivesPlugins(plugins);
 177         registerBoxingPlugins(plugins);
<span class="line-modified"> 178         registerJMHBlackholePlugins(plugins, bytecodeProvider);</span>
<span class="line-modified"> 179         registerJFRThrowablePlugins(plugins, bytecodeProvider);</span>
<span class="line-modified"> 180         registerMethodHandleImplPlugins(plugins, snippetReflection, bytecodeProvider);</span>
<span class="line-modified"> 181         registerJcovCollectPlugins(plugins, bytecodeProvider);</span>
 182     }
 183 
 184     private static final Field STRING_VALUE_FIELD;
 185     private static final Field STRING_CODER_FIELD;
 186 
 187     static {
 188         Field coder = null;
 189         try {
 190             STRING_VALUE_FIELD = String.class.getDeclaredField(&quot;value&quot;);
<span class="line-modified"> 191             if (!Java8OrEarlier) {</span>
 192                 coder = String.class.getDeclaredField(&quot;coder&quot;);
 193             }
 194         } catch (NoSuchFieldException e) {
 195             throw new GraalError(e);
 196         }
 197         STRING_CODER_FIELD = coder;
 198     }
 199 
<span class="line-modified"> 200     private static void registerStringPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider, SnippetReflectionProvider snippetReflection) {</span>
<span class="line-modified"> 201         final Registration r = new Registration(plugins, String.class, bytecodeProvider);</span>
 202         r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {
 203             @Override
 204             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 205                 if (receiver.isConstant()) {
 206                     String s = snippetReflection.asObject(String.class, (JavaConstant) receiver.get().asConstant());
 207                     if (s != null) {
 208                         b.addPush(JavaKind.Int, b.add(ConstantNode.forInt(s.hashCode())));
 209                         return true;
 210                     }
 211                 }
 212                 return false;
 213             }
 214         });














 215 
<span class="line-modified"> 216         if (Java8OrEarlier) {</span>
<span class="line-modified"> 217             r.registerMethodSubstitution(StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);</span>


 218 
 219             r.register7(&quot;indexOf&quot;, char[].class, int.class, int.class, char[].class, int.class, int.class, int.class, new StringIndexOfConstantPlugin());
 220 
 221             Registration sr = new Registration(plugins, StringSubstitutions.class);
 222             sr.register1(&quot;getValue&quot;, String.class, new InvocationPlugin() {
 223                 @Override
 224                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 225                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_VALUE_FIELD);
 226                     b.addPush(JavaKind.Object, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 227                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 228                     return true;
 229                 }
 230             });
 231         } else {
<span class="line-modified"> 232             r.registerMethodSubstitution(JDK9StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);</span>
<span class="line-modified"> 233             Registration utf16sub = new Registration(plugins, StringUTF16Substitutions.class, bytecodeProvider);</span>


 234             utf16sub.register2(&quot;getCharDirect&quot;, byte[].class, int.class, new InvocationPlugin() {
 235                 @Override
 236                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2) {
 237                     b.addPush(JavaKind.Char, new JavaReadNode(JavaKind.Char, new IndexAddressNode(arg1, arg2, JavaKind.Byte), NamedLocationIdentity.getArrayLocation(JavaKind.Byte),
 238                                     HeapAccess.BarrierType.NONE, false));
 239                     return true;
 240                 }
 241             });
 242             utf16sub.register3(&quot;putCharDirect&quot;, byte[].class, int.class, int.class, new InvocationPlugin() {
 243                 @Override
 244                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3) {
 245                     b.add(new JavaWriteNode(JavaKind.Char, new IndexAddressNode(arg1, arg2, JavaKind.Byte), NamedLocationIdentity.getArrayLocation(JavaKind.Byte), arg3,
 246                                     HeapAccess.BarrierType.NONE, false));
 247                     return true;
 248                 }
 249             });
 250 
<span class="line-modified"> 251             final Registration latin1r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, bytecodeProvider);</span>
 252             latin1r.register5(&quot;indexOf&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringLatin1IndexOfConstantPlugin());
 253 
<span class="line-modified"> 254             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, bytecodeProvider);</span>
 255             utf16r.register5(&quot;indexOfUnsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringUTF16IndexOfConstantPlugin());
 256             utf16r.setAllowOverwrite(true);
 257             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChar&quot;, byte[].class, int.class);
 258             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;putChar&quot;, byte[].class, int.class, int.class);
 259 
 260             Registration sr = new Registration(plugins, JDK9StringSubstitutions.class);
 261             sr.register1(&quot;getValue&quot;, String.class, new InvocationPlugin() {
 262                 @Override
 263                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 264                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_VALUE_FIELD);
 265                     b.addPush(JavaKind.Object, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 266                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 267                     return true;
 268                 }
 269             });
 270             sr.register1(&quot;getCoder&quot;, String.class, new InvocationPlugin() {
 271                 @Override
 272                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 273                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_CODER_FIELD);
 274                     b.addPush(JavaKind.Int, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 275                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 276                     return true;
 277                 }
 278             });
 279         }
 280     }
 281 
<span class="line-modified"> 282     private static void registerArraysPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified"> 283         Registration r = new Registration(plugins, Arrays.class, bytecodeProvider);</span>
 284         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, boolean[].class, boolean[].class);
 285         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, byte[].class, byte[].class);
 286         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, short[].class, short[].class);
 287         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, char[].class, char[].class);
 288         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, int[].class, int[].class);
 289         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, long[].class, long[].class);
 290     }
 291 
<span class="line-modified"> 292     private static void registerArrayPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified"> 293         Registration r = new Registration(plugins, Array.class, bytecodeProvider);</span>
 294         r.register2(&quot;newInstance&quot;, Class.class, int.class, new InvocationPlugin() {
 295             @Override
 296             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unused, ValueNode componentType, ValueNode length) {
 297                 b.addPush(JavaKind.Object, new DynamicNewArrayNode(componentType, length, true));
 298                 return true;
 299             }
 300         });
 301         r.registerMethodSubstitution(ArraySubstitutions.class, &quot;getLength&quot;, Object.class);
 302     }
 303 
 304     /**
 305      * The intrinsic for {@link Math#sqrt(double)} is shared with {@link StrictMath#sqrt(double)}.
 306      *
 307      * @see &quot;http://hg.openjdk.java.net/jdk/jdk/file/621efe32eb0b/src/hotspot/share/oops/method.cpp#l1504&quot;
 308      */
 309     static final class MathSqrtPlugin implements InvocationPlugin {
 310         @Override
 311         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 312             b.push(JavaKind.Double, b.append(SqrtNode.create(value, NodeView.DEFAULT)));
 313             return true;
</pre>
<hr />
<pre>
 351     private static UnsafeCompareAndSwapPluginsRegistrar unsafeCompareAndSwapPluginsRegistrar = new UnsafeCompareAndSwapPluginsRegistrar();
 352 
 353     private static class UnsafeCompareAndExchangePluginsRegistrar extends UnsafeCompareAndUpdatePluginsRegistrar {
 354         @Override
 355         public FixedWithNextNode createNode(ValueNode object, ValueNode offset, ValueNode expected, ValueNode newValue, JavaKind kind, LocationIdentity identity) {
 356             return new UnsafeCompareAndExchangeNode(object, offset, expected, newValue, kind, identity);
 357         }
 358 
 359         @Override
 360         public JavaKind returnKind(JavaKind accessKind) {
 361             if (accessKind.isNumericInteger()) {
 362                 return accessKind.getStackKind();
 363             } else {
 364                 return accessKind;
 365             }
 366         }
 367     }
 368 
 369     private static UnsafeCompareAndExchangePluginsRegistrar unsafeCompareAndExchangePluginsRegistrar = new UnsafeCompareAndExchangePluginsRegistrar();
 370 
<span class="line-modified"> 371     public static void registerPlatformSpecificUnsafePlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider, boolean explicitUnsafeNullChecks, JavaKind[] supportedCasKinds) {</span>
 372         registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
<span class="line-modified"> 373         if (!Java8OrEarlier) {</span>
<span class="line-modified"> 374             registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, bytecodeProvider), false, explicitUnsafeNullChecks);</span>
 375         }
 376 
 377     }
 378 
 379     private static void registerPlatformSpecificUnsafePlugins(JavaKind[] supportedCasKinds, Registration r, boolean java8OrEarlier, boolean explicitUnsafeNullChecks) {
 380         if (java8OrEarlier) {
 381             unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSwap&quot;, explicitUnsafeNullChecks, new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, true);
 382         } else {
<span class="line-modified"> 383             unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSet&quot;, explicitUnsafeNullChecks, supportedCasKinds, Java11OrEarlier);</span>
<span class="line-modified"> 384             unsafeCompareAndExchangePluginsRegistrar.register(r, &quot;compareAndExchange&quot;, explicitUnsafeNullChecks, supportedCasKinds, Java11OrEarlier);</span>
 385         }
 386     }
 387 
<span class="line-modified"> 388     private static void registerUnsafePlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider, boolean explicitUnsafeNullChecks) {</span>
 389         registerUnsafePlugins(new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
<span class="line-modified"> 390         if (!Java8OrEarlier) {</span>
<span class="line-modified"> 391             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, bytecodeProvider), false, explicitUnsafeNullChecks);</span>
 392         }
 393     }
 394 
 395     private static void registerUnsafePlugins(Registration r, boolean sunMiscUnsafe, boolean explicitUnsafeNullChecks) {
 396         for (JavaKind kind : JavaKind.values()) {
 397             if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
 398                 Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
<span class="line-modified"> 399                 String kindName = (kind == JavaKind.Object &amp;&amp; !sunMiscUnsafe &amp;&amp; !Java11OrEarlier) ? &quot;Reference&quot; : kind.name();</span>
 400                 String getName = &quot;get&quot; + kindName;
 401                 String putName = &quot;put&quot; + kindName;
 402                 // Object-based accesses
 403                 r.register3(getName, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
 404                 r.register4(putName, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
 405                 // Volatile object-based accesses
 406                 r.register3(getName + &quot;Volatile&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.VOLATILE, explicitUnsafeNullChecks));
 407                 r.register4(putName + &quot;Volatile&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.VOLATILE, explicitUnsafeNullChecks));
 408                 // Ordered object-based accesses
 409                 if (sunMiscUnsafe) {
 410                     if (kind == JavaKind.Int || kind == JavaKind.Long || kind == JavaKind.Object) {
 411                         r.register4(&quot;putOrdered&quot; + kindName, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 412                     }
 413                 } else {
 414                     r.register4(&quot;put&quot; + kindName + &quot;Release&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 415                     r.register3(&quot;get&quot; + kindName + &quot;Acquire&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 416                     r.register4(&quot;put&quot; + kindName + &quot;Opaque&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.OPAQUE, explicitUnsafeNullChecks));
 417                     r.register3(&quot;get&quot; + kindName + &quot;Opaque&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.OPAQUE, explicitUnsafeNullChecks));
 418                 }
 419                 if (kind != JavaKind.Boolean &amp;&amp; kind != JavaKind.Object) {
</pre>
<hr />
<pre>
 805             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 806                 /*
 807                  * Object.&lt;init&gt; is a common instrumentation point so only perform this rewrite if
 808                  * the current definition is the normal empty method with a single return bytecode.
 809                  * The finalizer registration will instead be performed by the BytecodeParser.
 810                  */
 811                 if (targetMethod.getCodeSize() == 1) {
 812                     ValueNode object = receiver.get();
 813                     if (RegisterFinalizerNode.mayHaveFinalizer(object, b.getAssumptions())) {
 814                         b.add(new RegisterFinalizerNode(object));
 815                     }
 816                     return true;
 817                 }
 818                 return false;
 819             }
 820         });
 821         r.register1(&quot;getClass&quot;, Receiver.class, new InvocationPlugin() {
 822             @Override
 823             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 824                 ValueNode object = receiver.get();
<span class="line-modified"> 825                 ValueNode folded = GetClassNode.tryFold(b.getMetaAccess(), b.getConstantReflection(), NodeView.DEFAULT, GraphUtil.originalValue(object));</span>
 826                 if (folded != null) {
 827                     b.addPush(JavaKind.Object, folded);
 828                 } else {
 829                     Stamp stamp = StampFactory.objectNonNull(TypeReference.createTrusted(b.getAssumptions(), b.getMetaAccess().lookupJavaType(Class.class)));
 830                     b.addPush(JavaKind.Object, new GetClassNode(stamp, object));
 831                 }
 832                 return true;
 833             }
 834         });
 835     }
 836 
 837     private static void registerClassPlugins(InvocationPlugins plugins) {
 838         Registration r = new Registration(plugins, Class.class);
 839         r.register2(&quot;isInstance&quot;, Receiver.class, Object.class, new InvocationPlugin() {
 840             @Override
 841             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver type, ValueNode object) {
 842                 LogicNode condition = b.append(InstanceOfDynamicNode.create(b.getAssumptions(), b.getConstantReflection(), type.get(), object, false));
 843                 b.push(JavaKind.Boolean, b.append(new ConditionalNode(condition).canonical(null)));
 844                 return true;
 845             }
</pre>
<hr />
<pre>
1077         public UnsafeGetPlugin(JavaKind returnKind, boolean explicitUnsafeNullChecks) {
1078             this(returnKind, AccessKind.PLAIN, explicitUnsafeNullChecks);
1079         }
1080 
1081         public UnsafeGetPlugin(JavaKind kind, AccessKind accessKind, boolean explicitUnsafeNullChecks) {
1082             super(kind, explicitUnsafeNullChecks);
1083             this.accessKind = accessKind;
1084         }
1085 
1086         @Override
1087         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode address) {
1088             // Emits a null-check for the otherwise unused receiver
1089             unsafe.get();
1090             b.addPush(unsafeAccessKind, new UnsafeMemoryLoadNode(address, unsafeAccessKind, OFF_HEAP_LOCATION));
1091             b.getGraph().markUnsafeAccess();
1092             return true;
1093         }
1094 
1095         @Override
1096         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset) {






1097             // Emits a null-check for the otherwise unused receiver
1098             unsafe.get();
1099             if (accessKind.emitBarriers) {
1100                 b.add(new MembarNode(accessKind.preReadBarriers));
1101             }



1102             createUnsafeAccess(object, b, (obj, loc) -&gt; new RawLoadNode(obj, offset, unsafeAccessKind, loc));
1103             if (accessKind.emitBarriers) {
1104                 b.add(new MembarNode(accessKind.postReadBarriers));
1105             }
1106             return true;
1107         }
1108     }
1109 
1110     public static class UnsafePutPlugin extends UnsafeAccessPlugin {
1111         private final AccessKind accessKind;
1112 
1113         public UnsafePutPlugin(JavaKind kind, boolean explicitUnsafeNullChecks) {
1114             this(kind, AccessKind.PLAIN, explicitUnsafeNullChecks);
1115         }
1116 
1117         private UnsafePutPlugin(JavaKind kind, AccessKind accessKind, boolean explicitUnsafeNullChecks) {
1118             super(kind, explicitUnsafeNullChecks);
1119             this.accessKind = accessKind;
1120         }
1121 
1122         @Override
1123         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode address, ValueNode value) {
1124             assert !accessKind.emitBarriers : &quot;Barriers for address based Unsafe put is not supported.&quot;;
1125             // Emits a null-check for the otherwise unused receiver
1126             unsafe.get();
1127             b.add(new UnsafeMemoryStoreNode(address, value, unsafeAccessKind, OFF_HEAP_LOCATION));
1128             b.getGraph().markUnsafeAccess();
1129             return true;
1130         }
1131 
1132         @Override
1133         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode value) {






1134             // Emits a null-check for the otherwise unused receiver
1135             unsafe.get();
1136             if (accessKind.emitBarriers) {
1137                 b.add(new MembarNode(accessKind.preWriteBarriers));
1138             }
1139             ValueNode maskedValue = b.maskSubWordValue(value, unsafeAccessKind);



1140             createUnsafeAccess(object, b, (obj, loc) -&gt; new RawStoreNode(obj, offset, maskedValue, unsafeAccessKind, loc));
1141             if (accessKind.emitBarriers) {
1142                 b.add(new MembarNode(accessKind.postWriteBarriers));
1143             }
1144             return true;
1145         }
1146     }
1147 
1148     public static class UnsafeFencePlugin implements InvocationPlugin {
1149 
1150         private final int barriers;
1151 
1152         public UnsafeFencePlugin(int barriers) {
1153             this.barriers = barriers;
1154         }
1155 
1156         @Override
1157         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe) {
1158             // Emits a null-check for the otherwise unused receiver
1159             unsafe.get();
</pre>
<hr />
<pre>
1197                 b.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TransferToInterpreter, speculation));
1198                 return true;
1199             }
1200         });
1201 
1202         r.register0(&quot;inCompiledCode&quot;, new InvocationPlugin() {
1203             @Override
1204             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1205                 b.addPush(JavaKind.Boolean, ConstantNode.forBoolean(true));
1206                 return true;
1207             }
1208         });
1209 
1210         r.register0(&quot;controlFlowAnchor&quot;, new InvocationPlugin() {
1211             @Override
1212             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1213                 b.add(new ControlFlowAnchorNode());
1214                 return true;
1215             }
1216         });
<span class="line-modified">1217 </span>













1218         r.register2(&quot;injectBranchProbability&quot;, double.class, boolean.class, new InvocationPlugin() {
1219             @Override
1220             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode probability, ValueNode condition) {
1221                 b.addPush(JavaKind.Boolean, new BranchProbabilityNode(probability, condition));
1222                 return true;
1223             }
1224         });
1225 
1226         InvocationPlugin blackholePlugin = new InvocationPlugin() {
1227             @Override
1228             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1229                 b.add(new BlackholeNode(value));
1230                 return true;
1231             }
1232         };
1233 
1234         InvocationPlugin bindToRegisterPlugin = new InvocationPlugin() {
1235             @Override
1236             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1237                 b.add(new BindToRegisterNode(value));
</pre>
<hr />
<pre>
1270                 return true;
1271             }
1272         });
1273 
1274         r.register1(&quot;ensureVirtualized&quot;, Object.class, new InvocationPlugin() {
1275             @Override
1276             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1277                 b.add(new EnsureVirtualizedNode(object, false));
1278                 return true;
1279             }
1280         });
1281         r.register1(&quot;ensureVirtualizedHere&quot;, Object.class, new InvocationPlugin() {
1282             @Override
1283             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1284                 b.add(new EnsureVirtualizedNode(object, true));
1285                 return true;
1286             }
1287         });
1288     }
1289 
<span class="line-modified">1290     private static void registerJMHBlackholePlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
1291         InvocationPlugin blackholePlugin = new InvocationPlugin() {
1292             @Override
1293             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver blackhole, ValueNode value) {
1294                 blackhole.get();
1295                 b.add(new BlackholeNode(value));
1296                 return true;
1297             }
1298 
1299             @Override
1300             public boolean isDecorator() {
1301                 return true;
1302             }
1303         };
1304         String[] names = {&quot;org.openjdk.jmh.infra.Blackhole&quot;, &quot;org.openjdk.jmh.logic.BlackHole&quot;};
1305         for (String name : names) {
<span class="line-modified">1306             Registration r = new Registration(plugins, name, bytecodeProvider);</span>
1307             for (JavaKind kind : JavaKind.values()) {
1308                 if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
1309                     Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
1310                     r.registerOptional2(&quot;consume&quot;, Receiver.class, javaClass, blackholePlugin);
1311                 }
1312             }
1313             r.registerOptional2(&quot;consume&quot;, Receiver.class, Object[].class, blackholePlugin);
1314         }
1315     }
1316 
<span class="line-modified">1317     private static void registerJFRThrowablePlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">1318         Registration r = new Registration(plugins, &quot;oracle.jrockit.jfr.jdkevents.ThrowableTracer&quot;, bytecodeProvider);</span>
1319         r.register2(&quot;traceThrowable&quot;, Throwable.class, String.class, new InvocationPlugin() {
1320             @Override
1321             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode throwable, ValueNode message) {
1322                 b.add(new VirtualizableInvokeMacroNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), throwable, message));
1323                 return true;
1324             }
1325 
1326             @Override
1327             public boolean inlineOnly() {
1328                 return true;
1329             }
1330         });
1331     }
1332 
<span class="line-modified">1333     private static void registerMethodHandleImplPlugins(InvocationPlugins plugins, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">1334         Registration r = new Registration(plugins, &quot;java.lang.invoke.MethodHandleImpl&quot;, bytecodeProvider);</span>
1335         // In later JDKs this no longer exists and the usage is replace by Class.cast which is
1336         // already an intrinsic
1337         r.registerOptional2(&quot;castReference&quot;, Class.class, Object.class, new InvocationPlugin() {
1338             @Override
1339             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode javaClass, ValueNode object) {
1340                 b.genCheckcastDynamic(object, javaClass);
1341                 return true;
1342             }
1343 
1344             @Override
1345             public boolean inlineOnly() {
1346                 return true;
1347             }
1348         });
1349         r.register2(&quot;profileBoolean&quot;, boolean.class, int[].class, new InvocationPlugin() {
1350             @Override
1351             public boolean inlineOnly() {
1352                 return true;
1353             }
1354 
</pre>
<hr />
<pre>
1378                         } else {
1379                             // We cannot use BranchProbabilityNode here since there&#39;s no guarantee
1380                             // the result of MethodHandleImpl.profileBoolean() is used as the
1381                             // test in an `if` statement (as required by BranchProbabilityNode).
1382                         }
1383                     }
1384                     b.addPush(JavaKind.Boolean, newResult);
1385                     return true;
1386                 }
1387                 b.addPush(JavaKind.Boolean,
1388                                 new ProfileBooleanNode(snippetReflection, b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), result, counters));
1389                 return true;
1390             }
1391         });
1392     }
1393 
1394     /**
1395      * Registers a plugin to ignore {@code com.sun.tdk.jcov.runtime.Collect.hit} within an
1396      * intrinsic.
1397      */
<span class="line-modified">1398     private static void registerJcovCollectPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">1399         Registration r = new Registration(plugins, &quot;com.sun.tdk.jcov.runtime.Collect&quot;, bytecodeProvider);</span>
1400         r.register1(&quot;hit&quot;, int.class, new InvocationPlugin() {
1401             @Override
1402             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1403                 if (b.parsingIntrinsic()) {
1404                     return true;
1405                 }
1406                 return false;
1407             }
1408         });
1409     }
1410 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.replacements;
  26 
  27 import static jdk.vm.ci.code.MemoryBarriers.JMM_POST_VOLATILE_READ;
  28 import static jdk.vm.ci.code.MemoryBarriers.JMM_POST_VOLATILE_WRITE;
  29 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_READ;
  30 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_WRITE;
  31 import static jdk.vm.ci.code.MemoryBarriers.LOAD_LOAD;
  32 import static jdk.vm.ci.code.MemoryBarriers.LOAD_STORE;
  33 import static jdk.vm.ci.code.MemoryBarriers.STORE_LOAD;
  34 import static jdk.vm.ci.code.MemoryBarriers.STORE_STORE;
  35 import static org.graalvm.compiler.nodes.NamedLocationIdentity.OFF_HEAP_LOCATION;


  36 
  37 import java.lang.reflect.Array;
  38 import java.lang.reflect.Field;
  39 import java.util.Arrays;
  40 
  41 import org.graalvm.compiler.api.directives.GraalDirectives;
  42 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;

  43 import org.graalvm.compiler.core.common.calc.Condition;
  44 import org.graalvm.compiler.core.common.calc.Condition.CanonicalizedCondition;
  45 import org.graalvm.compiler.core.common.calc.UnsignedMath;
  46 import org.graalvm.compiler.core.common.type.ObjectStamp;
  47 import org.graalvm.compiler.core.common.type.Stamp;
  48 import org.graalvm.compiler.core.common.type.StampFactory;
  49 import org.graalvm.compiler.core.common.type.TypeReference;
  50 import org.graalvm.compiler.debug.GraalError;
  51 import org.graalvm.compiler.graph.Edges;
  52 import org.graalvm.compiler.graph.Node;
  53 import org.graalvm.compiler.graph.NodeList;
  54 import org.graalvm.compiler.nodes.AbstractBeginNode;
  55 import org.graalvm.compiler.nodes.BeginNode;
  56 import org.graalvm.compiler.nodes.ConstantNode;
  57 import org.graalvm.compiler.nodes.DeoptimizeNode;
  58 import org.graalvm.compiler.nodes.EndNode;
  59 import org.graalvm.compiler.nodes.FixedGuardNode;
  60 import org.graalvm.compiler.nodes.FixedWithNextNode;
  61 import org.graalvm.compiler.nodes.IfNode;
  62 import org.graalvm.compiler.nodes.LogicNode;
</pre>
<hr />
<pre>
  67 import org.graalvm.compiler.nodes.StructuredGraph;
  68 import org.graalvm.compiler.nodes.ValueNode;
  69 import org.graalvm.compiler.nodes.ValuePhiNode;
  70 import org.graalvm.compiler.nodes.calc.AbsNode;
  71 import org.graalvm.compiler.nodes.calc.CompareNode;
  72 import org.graalvm.compiler.nodes.calc.ConditionalNode;
  73 import org.graalvm.compiler.nodes.calc.FloatEqualsNode;
  74 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  75 import org.graalvm.compiler.nodes.calc.IsNullNode;
  76 import org.graalvm.compiler.nodes.calc.NarrowNode;
  77 import org.graalvm.compiler.nodes.calc.ReinterpretNode;
  78 import org.graalvm.compiler.nodes.calc.RightShiftNode;
  79 import org.graalvm.compiler.nodes.calc.SignExtendNode;
  80 import org.graalvm.compiler.nodes.calc.SqrtNode;
  81 import org.graalvm.compiler.nodes.calc.UnsignedDivNode;
  82 import org.graalvm.compiler.nodes.calc.UnsignedRemNode;
  83 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  84 import org.graalvm.compiler.nodes.debug.BindToRegisterNode;
  85 import org.graalvm.compiler.nodes.debug.BlackholeNode;
  86 import org.graalvm.compiler.nodes.debug.ControlFlowAnchorNode;
<span class="line-added">  87 import org.graalvm.compiler.nodes.debug.SideEffectNode;</span>
  88 import org.graalvm.compiler.nodes.debug.SpillRegistersNode;
  89 import org.graalvm.compiler.nodes.extended.BoxNode;
  90 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;
  91 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
  92 import org.graalvm.compiler.nodes.extended.GetClassNode;
  93 import org.graalvm.compiler.nodes.extended.GuardingNode;
  94 import org.graalvm.compiler.nodes.extended.JavaReadNode;
  95 import org.graalvm.compiler.nodes.extended.JavaWriteNode;
  96 import org.graalvm.compiler.nodes.extended.MembarNode;
  97 import org.graalvm.compiler.nodes.extended.OpaqueNode;
  98 import org.graalvm.compiler.nodes.extended.RawLoadNode;
  99 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 100 import org.graalvm.compiler.nodes.extended.UnboxNode;
 101 import org.graalvm.compiler.nodes.extended.UnsafeMemoryLoadNode;
 102 import org.graalvm.compiler.nodes.extended.UnsafeMemoryStoreNode;
 103 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 104 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 105 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 106 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 107 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 108 import org.graalvm.compiler.nodes.java.ClassIsAssignableFromNode;
 109 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
 110 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
 111 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 112 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 113 import org.graalvm.compiler.nodes.java.RegisterFinalizerNode;
 114 import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
 115 import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
 116 import org.graalvm.compiler.nodes.memory.HeapAccess;
 117 import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;
<span class="line-added"> 118 import org.graalvm.compiler.nodes.spi.Replacements;</span>
 119 import org.graalvm.compiler.nodes.type.StampTool;
 120 import org.graalvm.compiler.nodes.util.GraphUtil;
 121 import org.graalvm.compiler.nodes.virtual.EnsureVirtualizedNode;
 122 import org.graalvm.compiler.replacements.nodes.ProfileBooleanNode;
 123 import org.graalvm.compiler.replacements.nodes.ReverseBytesNode;
 124 import org.graalvm.compiler.replacements.nodes.VirtualizableInvokeMacroNode;
 125 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactNode;
 126 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactOverflowNode;
 127 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactSplitNode;
 128 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerExactArithmeticSplitNode;
 129 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactNode;
 130 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactOverflowNode;
 131 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactSplitNode;
 132 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactNode;
 133 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactOverflowNode;
 134 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactSplitNode;
<span class="line-added"> 135 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
 136 import org.graalvm.compiler.serviceprovider.SpeculationReasonGroup;
 137 import jdk.internal.vm.compiler.word.LocationIdentity;
 138 
 139 import jdk.vm.ci.code.BytecodePosition;
 140 import jdk.vm.ci.meta.DeoptimizationAction;
 141 import jdk.vm.ci.meta.DeoptimizationReason;
 142 import jdk.vm.ci.meta.JavaConstant;
 143 import jdk.vm.ci.meta.JavaKind;
 144 import jdk.vm.ci.meta.MetaAccessProvider;
 145 import jdk.vm.ci.meta.ResolvedJavaField;
 146 import jdk.vm.ci.meta.ResolvedJavaMethod;
 147 import jdk.vm.ci.meta.ResolvedJavaType;
 148 import jdk.vm.ci.meta.SpeculationLog;
 149 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 150 import jdk.vm.ci.meta.SpeculationLog.SpeculationReason;
 151 import sun.misc.Unsafe;
 152 
 153 /**
 154  * Provides non-runtime specific {@link InvocationPlugin}s.
 155  */
 156 public class StandardGraphBuilderPlugins {
 157 
<span class="line-modified"> 158     public static void registerInvocationPlugins(MetaAccessProvider metaAccess, SnippetReflectionProvider snippetReflection, InvocationPlugins plugins, Replacements replacements,</span>
<span class="line-modified"> 159                     boolean allowDeoptimization, boolean explicitUnsafeNullChecks, boolean arrayEqualsSubstitution) {</span>
 160         registerObjectPlugins(plugins);
 161         registerClassPlugins(plugins);
 162         registerMathPlugins(plugins, allowDeoptimization);
 163         registerStrictMathPlugins(plugins);
 164         registerUnsignedMathPlugins(plugins);
<span class="line-modified"> 165         registerStringPlugins(plugins, replacements, snippetReflection, arrayEqualsSubstitution);</span>
 166         registerCharacterPlugins(plugins);
 167         registerShortPlugins(plugins);
 168         registerIntegerLongPlugins(plugins, JavaKind.Int);
 169         registerIntegerLongPlugins(plugins, JavaKind.Long);
 170         registerFloatPlugins(plugins);
 171         registerDoublePlugins(plugins);
<span class="line-modified"> 172         if (arrayEqualsSubstitution) {</span>
<span class="line-modified"> 173             registerArraysPlugins(plugins, replacements);</span>
<span class="line-modified"> 174         }</span>
<span class="line-added"> 175         registerArrayPlugins(plugins, replacements);</span>
<span class="line-added"> 176         registerUnsafePlugins(plugins, replacements, explicitUnsafeNullChecks);</span>
 177         registerEdgesPlugins(metaAccess, plugins);
 178         registerGraalDirectivesPlugins(plugins);
 179         registerBoxingPlugins(plugins);
<span class="line-modified"> 180         registerJMHBlackholePlugins(plugins, replacements);</span>
<span class="line-modified"> 181         registerJFRThrowablePlugins(plugins, replacements);</span>
<span class="line-modified"> 182         registerMethodHandleImplPlugins(plugins, snippetReflection, replacements);</span>
<span class="line-modified"> 183         registerJcovCollectPlugins(plugins, replacements);</span>
 184     }
 185 
 186     private static final Field STRING_VALUE_FIELD;
 187     private static final Field STRING_CODER_FIELD;
 188 
 189     static {
 190         Field coder = null;
 191         try {
 192             STRING_VALUE_FIELD = String.class.getDeclaredField(&quot;value&quot;);
<span class="line-modified"> 193             if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
 194                 coder = String.class.getDeclaredField(&quot;coder&quot;);
 195             }
 196         } catch (NoSuchFieldException e) {
 197             throw new GraalError(e);
 198         }
 199         STRING_CODER_FIELD = coder;
 200     }
 201 
<span class="line-modified"> 202     private static void registerStringPlugins(InvocationPlugins plugins, Replacements replacements, SnippetReflectionProvider snippetReflection, boolean arrayEqualsSubstitution) {</span>
<span class="line-modified"> 203         final Registration r = new Registration(plugins, String.class, replacements);</span>
 204         r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {
 205             @Override
 206             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 207                 if (receiver.isConstant()) {
 208                     String s = snippetReflection.asObject(String.class, (JavaConstant) receiver.get().asConstant());
 209                     if (s != null) {
 210                         b.addPush(JavaKind.Int, b.add(ConstantNode.forInt(s.hashCode())));
 211                         return true;
 212                     }
 213                 }
 214                 return false;
 215             }
 216         });
<span class="line-added"> 217         r.register1(&quot;intern&quot;, Receiver.class, new InvocationPlugin() {</span>
<span class="line-added"> 218             @Override</span>
<span class="line-added"> 219             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {</span>
<span class="line-added"> 220                 if (receiver.isConstant()) {</span>
<span class="line-added"> 221                     String s = snippetReflection.asObject(String.class, (JavaConstant) receiver.get().asConstant());</span>
<span class="line-added"> 222                     if (s != null) {</span>
<span class="line-added"> 223                         JavaConstant interned = snippetReflection.forObject(s.intern());</span>
<span class="line-added"> 224                         b.addPush(JavaKind.Object, b.add(ConstantNode.forConstant(interned, b.getMetaAccess(), b.getGraph())));</span>
<span class="line-added"> 225                         return true;</span>
<span class="line-added"> 226                     }</span>
<span class="line-added"> 227                 }</span>
<span class="line-added"> 228                 return false;</span>
<span class="line-added"> 229             }</span>
<span class="line-added"> 230         });</span>
 231 
<span class="line-modified"> 232         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
<span class="line-modified"> 233             if (arrayEqualsSubstitution) {</span>
<span class="line-added"> 234                 r.registerMethodSubstitution(StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);</span>
<span class="line-added"> 235             }</span>
 236 
 237             r.register7(&quot;indexOf&quot;, char[].class, int.class, int.class, char[].class, int.class, int.class, int.class, new StringIndexOfConstantPlugin());
 238 
 239             Registration sr = new Registration(plugins, StringSubstitutions.class);
 240             sr.register1(&quot;getValue&quot;, String.class, new InvocationPlugin() {
 241                 @Override
 242                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 243                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_VALUE_FIELD);
 244                     b.addPush(JavaKind.Object, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 245                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 246                     return true;
 247                 }
 248             });
 249         } else {
<span class="line-modified"> 250             if (arrayEqualsSubstitution) {</span>
<span class="line-modified"> 251                 r.registerMethodSubstitution(JDK9StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);</span>
<span class="line-added"> 252             }</span>
<span class="line-added"> 253             Registration utf16sub = new Registration(plugins, StringUTF16Substitutions.class, replacements);</span>
 254             utf16sub.register2(&quot;getCharDirect&quot;, byte[].class, int.class, new InvocationPlugin() {
 255                 @Override
 256                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2) {
 257                     b.addPush(JavaKind.Char, new JavaReadNode(JavaKind.Char, new IndexAddressNode(arg1, arg2, JavaKind.Byte), NamedLocationIdentity.getArrayLocation(JavaKind.Byte),
 258                                     HeapAccess.BarrierType.NONE, false));
 259                     return true;
 260                 }
 261             });
 262             utf16sub.register3(&quot;putCharDirect&quot;, byte[].class, int.class, int.class, new InvocationPlugin() {
 263                 @Override
 264                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3) {
 265                     b.add(new JavaWriteNode(JavaKind.Char, new IndexAddressNode(arg1, arg2, JavaKind.Byte), NamedLocationIdentity.getArrayLocation(JavaKind.Byte), arg3,
 266                                     HeapAccess.BarrierType.NONE, false));
 267                     return true;
 268                 }
 269             });
 270 
<span class="line-modified"> 271             final Registration latin1r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, replacements);</span>
 272             latin1r.register5(&quot;indexOf&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringLatin1IndexOfConstantPlugin());
 273 
<span class="line-modified"> 274             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);</span>
 275             utf16r.register5(&quot;indexOfUnsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringUTF16IndexOfConstantPlugin());
 276             utf16r.setAllowOverwrite(true);
 277             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChar&quot;, byte[].class, int.class);
 278             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;putChar&quot;, byte[].class, int.class, int.class);
 279 
 280             Registration sr = new Registration(plugins, JDK9StringSubstitutions.class);
 281             sr.register1(&quot;getValue&quot;, String.class, new InvocationPlugin() {
 282                 @Override
 283                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 284                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_VALUE_FIELD);
 285                     b.addPush(JavaKind.Object, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 286                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 287                     return true;
 288                 }
 289             });
 290             sr.register1(&quot;getCoder&quot;, String.class, new InvocationPlugin() {
 291                 @Override
 292                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 293                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_CODER_FIELD);
 294                     b.addPush(JavaKind.Int, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 295                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 296                     return true;
 297                 }
 298             });
 299         }
 300     }
 301 
<span class="line-modified"> 302     private static void registerArraysPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified"> 303         Registration r = new Registration(plugins, Arrays.class, replacements);</span>
 304         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, boolean[].class, boolean[].class);
 305         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, byte[].class, byte[].class);
 306         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, short[].class, short[].class);
 307         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, char[].class, char[].class);
 308         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, int[].class, int[].class);
 309         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, long[].class, long[].class);
 310     }
 311 
<span class="line-modified"> 312     private static void registerArrayPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified"> 313         Registration r = new Registration(plugins, Array.class, replacements);</span>
 314         r.register2(&quot;newInstance&quot;, Class.class, int.class, new InvocationPlugin() {
 315             @Override
 316             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unused, ValueNode componentType, ValueNode length) {
 317                 b.addPush(JavaKind.Object, new DynamicNewArrayNode(componentType, length, true));
 318                 return true;
 319             }
 320         });
 321         r.registerMethodSubstitution(ArraySubstitutions.class, &quot;getLength&quot;, Object.class);
 322     }
 323 
 324     /**
 325      * The intrinsic for {@link Math#sqrt(double)} is shared with {@link StrictMath#sqrt(double)}.
 326      *
 327      * @see &quot;http://hg.openjdk.java.net/jdk/jdk/file/621efe32eb0b/src/hotspot/share/oops/method.cpp#l1504&quot;
 328      */
 329     static final class MathSqrtPlugin implements InvocationPlugin {
 330         @Override
 331         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 332             b.push(JavaKind.Double, b.append(SqrtNode.create(value, NodeView.DEFAULT)));
 333             return true;
</pre>
<hr />
<pre>
 371     private static UnsafeCompareAndSwapPluginsRegistrar unsafeCompareAndSwapPluginsRegistrar = new UnsafeCompareAndSwapPluginsRegistrar();
 372 
 373     private static class UnsafeCompareAndExchangePluginsRegistrar extends UnsafeCompareAndUpdatePluginsRegistrar {
 374         @Override
 375         public FixedWithNextNode createNode(ValueNode object, ValueNode offset, ValueNode expected, ValueNode newValue, JavaKind kind, LocationIdentity identity) {
 376             return new UnsafeCompareAndExchangeNode(object, offset, expected, newValue, kind, identity);
 377         }
 378 
 379         @Override
 380         public JavaKind returnKind(JavaKind accessKind) {
 381             if (accessKind.isNumericInteger()) {
 382                 return accessKind.getStackKind();
 383             } else {
 384                 return accessKind;
 385             }
 386         }
 387     }
 388 
 389     private static UnsafeCompareAndExchangePluginsRegistrar unsafeCompareAndExchangePluginsRegistrar = new UnsafeCompareAndExchangePluginsRegistrar();
 390 
<span class="line-modified"> 391     public static void registerPlatformSpecificUnsafePlugins(InvocationPlugins plugins, Replacements replacements, boolean explicitUnsafeNullChecks, JavaKind[] supportedCasKinds) {</span>
 392         registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
<span class="line-modified"> 393         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified"> 394             registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements), false, explicitUnsafeNullChecks);</span>
 395         }
 396 
 397     }
 398 
 399     private static void registerPlatformSpecificUnsafePlugins(JavaKind[] supportedCasKinds, Registration r, boolean java8OrEarlier, boolean explicitUnsafeNullChecks) {
 400         if (java8OrEarlier) {
 401             unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSwap&quot;, explicitUnsafeNullChecks, new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, true);
 402         } else {
<span class="line-modified"> 403             unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSet&quot;, explicitUnsafeNullChecks, supportedCasKinds, JavaVersionUtil.JAVA_SPEC &lt;= 11);</span>
<span class="line-modified"> 404             unsafeCompareAndExchangePluginsRegistrar.register(r, &quot;compareAndExchange&quot;, explicitUnsafeNullChecks, supportedCasKinds, JavaVersionUtil.JAVA_SPEC &lt;= 11);</span>
 405         }
 406     }
 407 
<span class="line-modified"> 408     private static void registerUnsafePlugins(InvocationPlugins plugins, Replacements replacements, boolean explicitUnsafeNullChecks) {</span>
 409         registerUnsafePlugins(new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
<span class="line-modified"> 410         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified"> 411             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements), false, explicitUnsafeNullChecks);</span>
 412         }
 413     }
 414 
 415     private static void registerUnsafePlugins(Registration r, boolean sunMiscUnsafe, boolean explicitUnsafeNullChecks) {
 416         for (JavaKind kind : JavaKind.values()) {
 417             if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
 418                 Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
<span class="line-modified"> 419                 String kindName = (kind == JavaKind.Object &amp;&amp; !sunMiscUnsafe &amp;&amp; !(JavaVersionUtil.JAVA_SPEC &lt;= 11)) ? &quot;Reference&quot; : kind.name();</span>
 420                 String getName = &quot;get&quot; + kindName;
 421                 String putName = &quot;put&quot; + kindName;
 422                 // Object-based accesses
 423                 r.register3(getName, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
 424                 r.register4(putName, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
 425                 // Volatile object-based accesses
 426                 r.register3(getName + &quot;Volatile&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.VOLATILE, explicitUnsafeNullChecks));
 427                 r.register4(putName + &quot;Volatile&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.VOLATILE, explicitUnsafeNullChecks));
 428                 // Ordered object-based accesses
 429                 if (sunMiscUnsafe) {
 430                     if (kind == JavaKind.Int || kind == JavaKind.Long || kind == JavaKind.Object) {
 431                         r.register4(&quot;putOrdered&quot; + kindName, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 432                     }
 433                 } else {
 434                     r.register4(&quot;put&quot; + kindName + &quot;Release&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 435                     r.register3(&quot;get&quot; + kindName + &quot;Acquire&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 436                     r.register4(&quot;put&quot; + kindName + &quot;Opaque&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.OPAQUE, explicitUnsafeNullChecks));
 437                     r.register3(&quot;get&quot; + kindName + &quot;Opaque&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.OPAQUE, explicitUnsafeNullChecks));
 438                 }
 439                 if (kind != JavaKind.Boolean &amp;&amp; kind != JavaKind.Object) {
</pre>
<hr />
<pre>
 825             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 826                 /*
 827                  * Object.&lt;init&gt; is a common instrumentation point so only perform this rewrite if
 828                  * the current definition is the normal empty method with a single return bytecode.
 829                  * The finalizer registration will instead be performed by the BytecodeParser.
 830                  */
 831                 if (targetMethod.getCodeSize() == 1) {
 832                     ValueNode object = receiver.get();
 833                     if (RegisterFinalizerNode.mayHaveFinalizer(object, b.getAssumptions())) {
 834                         b.add(new RegisterFinalizerNode(object));
 835                     }
 836                     return true;
 837                 }
 838                 return false;
 839             }
 840         });
 841         r.register1(&quot;getClass&quot;, Receiver.class, new InvocationPlugin() {
 842             @Override
 843             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 844                 ValueNode object = receiver.get();
<span class="line-modified"> 845                 ValueNode folded = GetClassNode.tryFold(b.getMetaAccess(), b.getConstantReflection(), NodeView.DEFAULT, GraphUtil.originalValue(object, true));</span>
 846                 if (folded != null) {
 847                     b.addPush(JavaKind.Object, folded);
 848                 } else {
 849                     Stamp stamp = StampFactory.objectNonNull(TypeReference.createTrusted(b.getAssumptions(), b.getMetaAccess().lookupJavaType(Class.class)));
 850                     b.addPush(JavaKind.Object, new GetClassNode(stamp, object));
 851                 }
 852                 return true;
 853             }
 854         });
 855     }
 856 
 857     private static void registerClassPlugins(InvocationPlugins plugins) {
 858         Registration r = new Registration(plugins, Class.class);
 859         r.register2(&quot;isInstance&quot;, Receiver.class, Object.class, new InvocationPlugin() {
 860             @Override
 861             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver type, ValueNode object) {
 862                 LogicNode condition = b.append(InstanceOfDynamicNode.create(b.getAssumptions(), b.getConstantReflection(), type.get(), object, false));
 863                 b.push(JavaKind.Boolean, b.append(new ConditionalNode(condition).canonical(null)));
 864                 return true;
 865             }
</pre>
<hr />
<pre>
1097         public UnsafeGetPlugin(JavaKind returnKind, boolean explicitUnsafeNullChecks) {
1098             this(returnKind, AccessKind.PLAIN, explicitUnsafeNullChecks);
1099         }
1100 
1101         public UnsafeGetPlugin(JavaKind kind, AccessKind accessKind, boolean explicitUnsafeNullChecks) {
1102             super(kind, explicitUnsafeNullChecks);
1103             this.accessKind = accessKind;
1104         }
1105 
1106         @Override
1107         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode address) {
1108             // Emits a null-check for the otherwise unused receiver
1109             unsafe.get();
1110             b.addPush(unsafeAccessKind, new UnsafeMemoryLoadNode(address, unsafeAccessKind, OFF_HEAP_LOCATION));
1111             b.getGraph().markUnsafeAccess();
1112             return true;
1113         }
1114 
1115         @Override
1116         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset) {
<span class="line-added">1117             // Opaque mode does not directly impose any ordering constraints with respect to other</span>
<span class="line-added">1118             // variables beyond Plain mode.</span>
<span class="line-added">1119             if (accessKind == AccessKind.OPAQUE &amp;&amp; StampTool.isPointerAlwaysNull(object)) {</span>
<span class="line-added">1120                 // OFF_HEAP_LOCATION accesses are not floatable =&gt; no membars needed for opaque.</span>
<span class="line-added">1121                 return apply(b, targetMethod, unsafe, offset);</span>
<span class="line-added">1122             }</span>
1123             // Emits a null-check for the otherwise unused receiver
1124             unsafe.get();
1125             if (accessKind.emitBarriers) {
1126                 b.add(new MembarNode(accessKind.preReadBarriers));
1127             }
<span class="line-added">1128             // Raw accesses can be turned into floatable field accesses, the membars preserve the</span>
<span class="line-added">1129             // access mode. In the case of opaque access, and only for opaque, the location of the</span>
<span class="line-added">1130             // wrapping membars can be refined to the field location.</span>
1131             createUnsafeAccess(object, b, (obj, loc) -&gt; new RawLoadNode(obj, offset, unsafeAccessKind, loc));
1132             if (accessKind.emitBarriers) {
1133                 b.add(new MembarNode(accessKind.postReadBarriers));
1134             }
1135             return true;
1136         }
1137     }
1138 
1139     public static class UnsafePutPlugin extends UnsafeAccessPlugin {
1140         private final AccessKind accessKind;
1141 
1142         public UnsafePutPlugin(JavaKind kind, boolean explicitUnsafeNullChecks) {
1143             this(kind, AccessKind.PLAIN, explicitUnsafeNullChecks);
1144         }
1145 
1146         private UnsafePutPlugin(JavaKind kind, AccessKind accessKind, boolean explicitUnsafeNullChecks) {
1147             super(kind, explicitUnsafeNullChecks);
1148             this.accessKind = accessKind;
1149         }
1150 
1151         @Override
1152         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode address, ValueNode value) {
1153             assert !accessKind.emitBarriers : &quot;Barriers for address based Unsafe put is not supported.&quot;;
1154             // Emits a null-check for the otherwise unused receiver
1155             unsafe.get();
1156             b.add(new UnsafeMemoryStoreNode(address, value, unsafeAccessKind, OFF_HEAP_LOCATION));
1157             b.getGraph().markUnsafeAccess();
1158             return true;
1159         }
1160 
1161         @Override
1162         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode value) {
<span class="line-added">1163             // Opaque mode does not directly impose any ordering constraints with respect to other</span>
<span class="line-added">1164             // variables beyond Plain mode.</span>
<span class="line-added">1165             if (accessKind == AccessKind.OPAQUE &amp;&amp; StampTool.isPointerAlwaysNull(object)) {</span>
<span class="line-added">1166                 // OFF_HEAP_LOCATION accesses are not floatable =&gt; no membars needed for opaque.</span>
<span class="line-added">1167                 return apply(b, targetMethod, unsafe, offset, value);</span>
<span class="line-added">1168             }</span>
1169             // Emits a null-check for the otherwise unused receiver
1170             unsafe.get();
1171             if (accessKind.emitBarriers) {
1172                 b.add(new MembarNode(accessKind.preWriteBarriers));
1173             }
1174             ValueNode maskedValue = b.maskSubWordValue(value, unsafeAccessKind);
<span class="line-added">1175             // Raw accesses can be turned into floatable field accesses, the membars preserve the</span>
<span class="line-added">1176             // access mode. In the case of opaque access, and only for opaque, the location of the</span>
<span class="line-added">1177             // wrapping membars can be refined to the field location.</span>
1178             createUnsafeAccess(object, b, (obj, loc) -&gt; new RawStoreNode(obj, offset, maskedValue, unsafeAccessKind, loc));
1179             if (accessKind.emitBarriers) {
1180                 b.add(new MembarNode(accessKind.postWriteBarriers));
1181             }
1182             return true;
1183         }
1184     }
1185 
1186     public static class UnsafeFencePlugin implements InvocationPlugin {
1187 
1188         private final int barriers;
1189 
1190         public UnsafeFencePlugin(int barriers) {
1191             this.barriers = barriers;
1192         }
1193 
1194         @Override
1195         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe) {
1196             // Emits a null-check for the otherwise unused receiver
1197             unsafe.get();
</pre>
<hr />
<pre>
1235                 b.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TransferToInterpreter, speculation));
1236                 return true;
1237             }
1238         });
1239 
1240         r.register0(&quot;inCompiledCode&quot;, new InvocationPlugin() {
1241             @Override
1242             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1243                 b.addPush(JavaKind.Boolean, ConstantNode.forBoolean(true));
1244                 return true;
1245             }
1246         });
1247 
1248         r.register0(&quot;controlFlowAnchor&quot;, new InvocationPlugin() {
1249             @Override
1250             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1251                 b.add(new ControlFlowAnchorNode());
1252                 return true;
1253             }
1254         });
<span class="line-modified">1255         r.register0(&quot;sideEffect&quot;, new InvocationPlugin() {</span>
<span class="line-added">1256             @Override</span>
<span class="line-added">1257             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {</span>
<span class="line-added">1258                 b.add(new SideEffectNode());</span>
<span class="line-added">1259                 return true;</span>
<span class="line-added">1260             }</span>
<span class="line-added">1261         });</span>
<span class="line-added">1262         r.register1(&quot;sideEffect&quot;, int.class, new InvocationPlugin() {</span>
<span class="line-added">1263             @Override</span>
<span class="line-added">1264             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode a) {</span>
<span class="line-added">1265                 b.addPush(JavaKind.Int, new SideEffectNode(a));</span>
<span class="line-added">1266                 return true;</span>
<span class="line-added">1267             }</span>
<span class="line-added">1268         });</span>
1269         r.register2(&quot;injectBranchProbability&quot;, double.class, boolean.class, new InvocationPlugin() {
1270             @Override
1271             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode probability, ValueNode condition) {
1272                 b.addPush(JavaKind.Boolean, new BranchProbabilityNode(probability, condition));
1273                 return true;
1274             }
1275         });
1276 
1277         InvocationPlugin blackholePlugin = new InvocationPlugin() {
1278             @Override
1279             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1280                 b.add(new BlackholeNode(value));
1281                 return true;
1282             }
1283         };
1284 
1285         InvocationPlugin bindToRegisterPlugin = new InvocationPlugin() {
1286             @Override
1287             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1288                 b.add(new BindToRegisterNode(value));
</pre>
<hr />
<pre>
1321                 return true;
1322             }
1323         });
1324 
1325         r.register1(&quot;ensureVirtualized&quot;, Object.class, new InvocationPlugin() {
1326             @Override
1327             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1328                 b.add(new EnsureVirtualizedNode(object, false));
1329                 return true;
1330             }
1331         });
1332         r.register1(&quot;ensureVirtualizedHere&quot;, Object.class, new InvocationPlugin() {
1333             @Override
1334             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1335                 b.add(new EnsureVirtualizedNode(object, true));
1336                 return true;
1337             }
1338         });
1339     }
1340 
<span class="line-modified">1341     private static void registerJMHBlackholePlugins(InvocationPlugins plugins, Replacements replacements) {</span>
1342         InvocationPlugin blackholePlugin = new InvocationPlugin() {
1343             @Override
1344             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver blackhole, ValueNode value) {
1345                 blackhole.get();
1346                 b.add(new BlackholeNode(value));
1347                 return true;
1348             }
1349 
1350             @Override
1351             public boolean isDecorator() {
1352                 return true;
1353             }
1354         };
1355         String[] names = {&quot;org.openjdk.jmh.infra.Blackhole&quot;, &quot;org.openjdk.jmh.logic.BlackHole&quot;};
1356         for (String name : names) {
<span class="line-modified">1357             Registration r = new Registration(plugins, name, replacements);</span>
1358             for (JavaKind kind : JavaKind.values()) {
1359                 if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
1360                     Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
1361                     r.registerOptional2(&quot;consume&quot;, Receiver.class, javaClass, blackholePlugin);
1362                 }
1363             }
1364             r.registerOptional2(&quot;consume&quot;, Receiver.class, Object[].class, blackholePlugin);
1365         }
1366     }
1367 
<span class="line-modified">1368     private static void registerJFRThrowablePlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">1369         Registration r = new Registration(plugins, &quot;oracle.jrockit.jfr.jdkevents.ThrowableTracer&quot;, replacements);</span>
1370         r.register2(&quot;traceThrowable&quot;, Throwable.class, String.class, new InvocationPlugin() {
1371             @Override
1372             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode throwable, ValueNode message) {
1373                 b.add(new VirtualizableInvokeMacroNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), throwable, message));
1374                 return true;
1375             }
1376 
1377             @Override
1378             public boolean inlineOnly() {
1379                 return true;
1380             }
1381         });
1382     }
1383 
<span class="line-modified">1384     private static void registerMethodHandleImplPlugins(InvocationPlugins plugins, SnippetReflectionProvider snippetReflection, Replacements replacements) {</span>
<span class="line-modified">1385         Registration r = new Registration(plugins, &quot;java.lang.invoke.MethodHandleImpl&quot;, replacements);</span>
1386         // In later JDKs this no longer exists and the usage is replace by Class.cast which is
1387         // already an intrinsic
1388         r.registerOptional2(&quot;castReference&quot;, Class.class, Object.class, new InvocationPlugin() {
1389             @Override
1390             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode javaClass, ValueNode object) {
1391                 b.genCheckcastDynamic(object, javaClass);
1392                 return true;
1393             }
1394 
1395             @Override
1396             public boolean inlineOnly() {
1397                 return true;
1398             }
1399         });
1400         r.register2(&quot;profileBoolean&quot;, boolean.class, int[].class, new InvocationPlugin() {
1401             @Override
1402             public boolean inlineOnly() {
1403                 return true;
1404             }
1405 
</pre>
<hr />
<pre>
1429                         } else {
1430                             // We cannot use BranchProbabilityNode here since there&#39;s no guarantee
1431                             // the result of MethodHandleImpl.profileBoolean() is used as the
1432                             // test in an `if` statement (as required by BranchProbabilityNode).
1433                         }
1434                     }
1435                     b.addPush(JavaKind.Boolean, newResult);
1436                     return true;
1437                 }
1438                 b.addPush(JavaKind.Boolean,
1439                                 new ProfileBooleanNode(snippetReflection, b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), result, counters));
1440                 return true;
1441             }
1442         });
1443     }
1444 
1445     /**
1446      * Registers a plugin to ignore {@code com.sun.tdk.jcov.runtime.Collect.hit} within an
1447      * intrinsic.
1448      */
<span class="line-modified">1449     private static void registerJcovCollectPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">1450         Registration r = new Registration(plugins, &quot;com.sun.tdk.jcov.runtime.Collect&quot;, replacements);</span>
1451         r.register1(&quot;hit&quot;, int.class, new InvocationPlugin() {
1452             @Override
1453             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1454                 if (b.parsingIntrinsic()) {
1455                     return true;
1456                 }
1457                 return false;
1458             }
1459         });
1460     }
1461 }
</pre>
</td>
</tr>
</table>
<center><a href="SnippetTemplate.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="arraycopy/ArrayCopyCallNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/IntrinsicGraphBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineDuringParsingPlugin.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MethodHandlePlugin.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/IntrinsicGraphBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 34 import org.graalvm.compiler.debug.DebugCloseable;
 35 import org.graalvm.compiler.debug.DebugContext;
 36 import org.graalvm.compiler.debug.GraalError;
 37 import org.graalvm.compiler.graph.NodeSourcePosition;
 38 import org.graalvm.compiler.nodes.CallTargetNode;
 39 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 40 import org.graalvm.compiler.nodes.FixedNode;
 41 import org.graalvm.compiler.nodes.FixedWithNextNode;
 42 import org.graalvm.compiler.nodes.FrameState;
 43 import org.graalvm.compiler.nodes.Invoke;
 44 import org.graalvm.compiler.nodes.ParameterNode;
 45 import org.graalvm.compiler.nodes.ReturnNode;
 46 import org.graalvm.compiler.nodes.StateSplit;
 47 import org.graalvm.compiler.nodes.StructuredGraph;
 48 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 49 import org.graalvm.compiler.nodes.ValueNode;
 50 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 51 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 52 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 53 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;


 54 import org.graalvm.compiler.nodes.spi.StampProvider;
 55 import org.graalvm.compiler.options.OptionValues;
 56 
 57 import jdk.vm.ci.code.BailoutException;
 58 import jdk.vm.ci.code.BytecodeFrame;
 59 import jdk.vm.ci.meta.ConstantReflectionProvider;
 60 import jdk.vm.ci.meta.JavaKind;
 61 import jdk.vm.ci.meta.JavaType;
 62 import jdk.vm.ci.meta.MetaAccessProvider;
 63 import jdk.vm.ci.meta.ResolvedJavaMethod;
 64 import jdk.vm.ci.meta.ResolvedJavaType;
 65 import jdk.vm.ci.meta.Signature;
 66 
 67 /**
 68  * Implementation of {@link GraphBuilderContext} used to produce a graph for a method based on an
 69  * {@link InvocationPlugin} for the method.
 70  */
 71 public class IntrinsicGraphBuilder implements GraphBuilderContext, Receiver {
 72 
<span class="line-modified"> 73     protected final MetaAccessProvider metaAccess;</span>
<span class="line-removed"> 74     protected final ConstantReflectionProvider constantReflection;</span>
<span class="line-removed"> 75     protected final ConstantFieldProvider constantFieldProvider;</span>
<span class="line-removed"> 76     protected final StampProvider stampProvider;</span>
 77     protected final StructuredGraph graph;
 78     protected final Bytecode code;
 79     protected final ResolvedJavaMethod method;
 80     protected final int invokeBci;
 81     protected FixedWithNextNode lastInstr;
 82     protected ValueNode[] arguments;
 83     protected ValueNode returnValue;
 84 
<span class="line-modified"> 85     public IntrinsicGraphBuilder(OptionValues options, DebugContext debug, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,</span>
<span class="line-modified"> 86                     StampProvider stampProvider, Bytecode code, int invokeBci) {</span>
<span class="line-removed"> 87         this(options, debug, metaAccess, constantReflection, constantFieldProvider, stampProvider, code, invokeBci, AllowAssumptions.YES);</span>
 88     }
 89 
<span class="line-modified"> 90     protected IntrinsicGraphBuilder(OptionValues options, DebugContext debug, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,</span>
<span class="line-modified"> 91                     StampProvider stampProvider, Bytecode code, int invokeBci, AllowAssumptions allowAssumptions) {</span>
<span class="line-removed"> 92         this.metaAccess = metaAccess;</span>
<span class="line-removed"> 93         this.constantReflection = constantReflection;</span>
<span class="line-removed"> 94         this.constantFieldProvider = constantFieldProvider;</span>
<span class="line-removed"> 95         this.stampProvider = stampProvider;</span>
 96         this.code = code;
 97         this.method = code.getMethod();
 98         this.graph = new StructuredGraph.Builder(options, debug, allowAssumptions).method(method).setIsSubstitution(true).trackNodeSourcePosition(true).build();
 99         this.invokeBci = invokeBci;
100         this.lastInstr = graph.start();
101 
102         Signature sig = method.getSignature();
103         int max = sig.getParameterCount(false);
104         this.arguments = new ValueNode[max + (method.isStatic() ? 0 : 1)];
105 
106         int javaIndex = 0;
107         int index = 0;
108         if (!method.isStatic()) {
109             // add the receiver
110             Stamp receiverStamp = StampFactory.objectNonNull(TypeReference.createWithoutAssumptions(method.getDeclaringClass()));
111             ValueNode receiver = graph.addWithoutUnique(new ParameterNode(javaIndex, StampPair.createSingle(receiverStamp)));
112             arguments[index] = receiver;
113             javaIndex = 1;
114             index = 1;
115         }
116         ResolvedJavaType accessingClass = method.getDeclaringClass();
117         for (int i = 0; i &lt; max; i++) {
118             JavaType type = sig.getParameterType(i, accessingClass).resolve(accessingClass);
119             JavaKind kind = type.getJavaKind();
120             Stamp stamp;
121             if (kind == JavaKind.Object &amp;&amp; type instanceof ResolvedJavaType) {
122                 stamp = StampFactory.object(TypeReference.createWithoutAssumptions((ResolvedJavaType) type));
123             } else {
124                 stamp = StampFactory.forKind(kind);
125             }
126             ValueNode param = graph.addWithoutUnique(new ParameterNode(index, StampPair.createSingle(stamp)));
127             arguments[index] = param;
128             javaIndex += kind.getSlotCount();
129             index++;
130         }
131     }
132 
133     private &lt;T extends ValueNode&gt; void updateLastInstruction(T v) {
134         if (v instanceof FixedNode) {
135             FixedNode fixedNode = (FixedNode) v;
<span class="line-modified">136             lastInstr.setNext(fixedNode);</span>


137             if (fixedNode instanceof FixedWithNextNode) {
138                 FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) fixedNode;
139                 assert fixedWithNextNode.next() == null : &quot;cannot append instruction to instruction which isn&#39;t end&quot;;
140                 lastInstr = fixedWithNextNode;
141             } else {
142                 lastInstr = null;
143             }
144         }
145     }
146 
147     @Override
148     public &lt;T extends ValueNode&gt; T append(T v) {
149         if (v.graph() != null) {
150             return v;
151         }
152         T added = graph.addOrUniqueWithInputs(v);
153         if (added == v) {
154             updateLastInstruction(v);
155         }
156         return added;
157     }
158 
159     @Override
160     public void push(JavaKind kind, ValueNode value) {
161         assert kind != JavaKind.Void;
<span class="line-modified">162         assert returnValue == null;</span>
163         returnValue = value;
164     }
165 








166     @Override
167     public Invoke handleReplacedInvoke(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, boolean forceInlineEverything) {
168         throw GraalError.shouldNotReachHere();
169     }
170 
171     @Override
172     public void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType) {
173         throw GraalError.shouldNotReachHere();
174     }
175 
176     @Override
177     public StampProvider getStampProvider() {
<span class="line-modified">178         return stampProvider;</span>
179     }
180 
181     @Override
182     public MetaAccessProvider getMetaAccess() {
<span class="line-modified">183         return metaAccess;</span>
184     }
185 
186     @Override
187     public ConstantReflectionProvider getConstantReflection() {
<span class="line-modified">188         return constantReflection;</span>
189     }
190 
191     @Override
192     public ConstantFieldProvider getConstantFieldProvider() {
<span class="line-modified">193         return constantFieldProvider;</span>





194     }
195 
196     @Override
197     public StructuredGraph getGraph() {
198         return graph;
199     }
200 
201     @Override
202     public void setStateAfter(StateSplit sideEffect) {
203         assert sideEffect.hasSideEffect();
204         FrameState stateAfter = getGraph().add(new FrameState(BytecodeFrame.BEFORE_BCI));
205         sideEffect.setStateAfter(stateAfter);
206     }
207 
208     @Override
209     public GraphBuilderContext getParent() {
210         return null;
211     }
212 
213     @Override
</pre>
<hr />
<pre>
262 
263     @SuppressWarnings(&quot;try&quot;)
264     public StructuredGraph buildGraph(InvocationPlugin plugin) {
265         NodeSourcePosition position = graph.trackNodeSourcePosition() ? NodeSourcePosition.placeholder(method) : null;
266         try (DebugCloseable context = graph.withNodeSourcePosition(position)) {
267             Receiver receiver = method.isStatic() ? null : this;
268             if (plugin.execute(this, method, receiver, arguments)) {
269                 assert (returnValue != null) == (method.getSignature().getReturnKind() != JavaKind.Void) : method;
270                 append(new ReturnNode(returnValue));
271                 return graph;
272             }
273             return null;
274         }
275     }
276 
277     @Override
278     public boolean intrinsify(BytecodeProvider bytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] args) {
279         throw GraalError.shouldNotReachHere();
280     }
281 





282     @Override
283     public String toString() {
284         return String.format(&quot;%s:intrinsic&quot;, method.format(&quot;%H.%n(%p)&quot;));
285     }
286 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 34 import org.graalvm.compiler.debug.DebugCloseable;
 35 import org.graalvm.compiler.debug.DebugContext;
 36 import org.graalvm.compiler.debug.GraalError;
 37 import org.graalvm.compiler.graph.NodeSourcePosition;
 38 import org.graalvm.compiler.nodes.CallTargetNode;
 39 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 40 import org.graalvm.compiler.nodes.FixedNode;
 41 import org.graalvm.compiler.nodes.FixedWithNextNode;
 42 import org.graalvm.compiler.nodes.FrameState;
 43 import org.graalvm.compiler.nodes.Invoke;
 44 import org.graalvm.compiler.nodes.ParameterNode;
 45 import org.graalvm.compiler.nodes.ReturnNode;
 46 import org.graalvm.compiler.nodes.StateSplit;
 47 import org.graalvm.compiler.nodes.StructuredGraph;
 48 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 49 import org.graalvm.compiler.nodes.ValueNode;
 50 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 51 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 52 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 53 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
<span class="line-added"> 54 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
<span class="line-added"> 55 import org.graalvm.compiler.nodes.spi.Replacements;</span>
 56 import org.graalvm.compiler.nodes.spi.StampProvider;
 57 import org.graalvm.compiler.options.OptionValues;
 58 
 59 import jdk.vm.ci.code.BailoutException;
 60 import jdk.vm.ci.code.BytecodeFrame;
 61 import jdk.vm.ci.meta.ConstantReflectionProvider;
 62 import jdk.vm.ci.meta.JavaKind;
 63 import jdk.vm.ci.meta.JavaType;
 64 import jdk.vm.ci.meta.MetaAccessProvider;
 65 import jdk.vm.ci.meta.ResolvedJavaMethod;
 66 import jdk.vm.ci.meta.ResolvedJavaType;
 67 import jdk.vm.ci.meta.Signature;
 68 
 69 /**
 70  * Implementation of {@link GraphBuilderContext} used to produce a graph for a method based on an
 71  * {@link InvocationPlugin} for the method.
 72  */
 73 public class IntrinsicGraphBuilder implements GraphBuilderContext, Receiver {
 74 
<span class="line-modified"> 75     protected final CoreProviders providers;</span>



 76     protected final StructuredGraph graph;
 77     protected final Bytecode code;
 78     protected final ResolvedJavaMethod method;
 79     protected final int invokeBci;
 80     protected FixedWithNextNode lastInstr;
 81     protected ValueNode[] arguments;
 82     protected ValueNode returnValue;
 83 
<span class="line-modified"> 84     public IntrinsicGraphBuilder(OptionValues options, DebugContext debug, CoreProviders providers, Bytecode code, int invokeBci) {</span>
<span class="line-modified"> 85         this(options, debug, providers, code, invokeBci, AllowAssumptions.YES);</span>

 86     }
 87 
<span class="line-modified"> 88     protected IntrinsicGraphBuilder(OptionValues options, DebugContext debug, CoreProviders providers, Bytecode code, int invokeBci, AllowAssumptions allowAssumptions) {</span>
<span class="line-modified"> 89         this.providers = providers;</span>




 90         this.code = code;
 91         this.method = code.getMethod();
 92         this.graph = new StructuredGraph.Builder(options, debug, allowAssumptions).method(method).setIsSubstitution(true).trackNodeSourcePosition(true).build();
 93         this.invokeBci = invokeBci;
 94         this.lastInstr = graph.start();
 95 
 96         Signature sig = method.getSignature();
 97         int max = sig.getParameterCount(false);
 98         this.arguments = new ValueNode[max + (method.isStatic() ? 0 : 1)];
 99 
100         int javaIndex = 0;
101         int index = 0;
102         if (!method.isStatic()) {
103             // add the receiver
104             Stamp receiverStamp = StampFactory.objectNonNull(TypeReference.createWithoutAssumptions(method.getDeclaringClass()));
105             ValueNode receiver = graph.addWithoutUnique(new ParameterNode(javaIndex, StampPair.createSingle(receiverStamp)));
106             arguments[index] = receiver;
107             javaIndex = 1;
108             index = 1;
109         }
110         ResolvedJavaType accessingClass = method.getDeclaringClass();
111         for (int i = 0; i &lt; max; i++) {
112             JavaType type = sig.getParameterType(i, accessingClass).resolve(accessingClass);
113             JavaKind kind = type.getJavaKind();
114             Stamp stamp;
115             if (kind == JavaKind.Object &amp;&amp; type instanceof ResolvedJavaType) {
116                 stamp = StampFactory.object(TypeReference.createWithoutAssumptions((ResolvedJavaType) type));
117             } else {
118                 stamp = StampFactory.forKind(kind);
119             }
120             ValueNode param = graph.addWithoutUnique(new ParameterNode(index, StampPair.createSingle(stamp)));
121             arguments[index] = param;
122             javaIndex += kind.getSlotCount();
123             index++;
124         }
125     }
126 
127     private &lt;T extends ValueNode&gt; void updateLastInstruction(T v) {
128         if (v instanceof FixedNode) {
129             FixedNode fixedNode = (FixedNode) v;
<span class="line-modified">130             if (lastInstr != null) {</span>
<span class="line-added">131                 lastInstr.setNext(fixedNode);</span>
<span class="line-added">132             }</span>
133             if (fixedNode instanceof FixedWithNextNode) {
134                 FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) fixedNode;
135                 assert fixedWithNextNode.next() == null : &quot;cannot append instruction to instruction which isn&#39;t end&quot;;
136                 lastInstr = fixedWithNextNode;
137             } else {
138                 lastInstr = null;
139             }
140         }
141     }
142 
143     @Override
144     public &lt;T extends ValueNode&gt; T append(T v) {
145         if (v.graph() != null) {
146             return v;
147         }
148         T added = graph.addOrUniqueWithInputs(v);
149         if (added == v) {
150             updateLastInstruction(v);
151         }
152         return added;
153     }
154 
155     @Override
156     public void push(JavaKind kind, ValueNode value) {
157         assert kind != JavaKind.Void;
<span class="line-modified">158         GraalError.guarantee(returnValue == null, &quot;can only push one value&quot;);</span>
159         returnValue = value;
160     }
161 
<span class="line-added">162     @Override</span>
<span class="line-added">163     public ValueNode pop(JavaKind slotKind) {</span>
<span class="line-added">164         GraalError.guarantee(returnValue != null, &quot;no value pushed&quot;);</span>
<span class="line-added">165         ValueNode result = returnValue;</span>
<span class="line-added">166         returnValue = null;</span>
<span class="line-added">167         return result;</span>
<span class="line-added">168     }</span>
<span class="line-added">169 </span>
170     @Override
171     public Invoke handleReplacedInvoke(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, boolean forceInlineEverything) {
172         throw GraalError.shouldNotReachHere();
173     }
174 
175     @Override
176     public void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType) {
177         throw GraalError.shouldNotReachHere();
178     }
179 
180     @Override
181     public StampProvider getStampProvider() {
<span class="line-modified">182         return providers.getStampProvider();</span>
183     }
184 
185     @Override
186     public MetaAccessProvider getMetaAccess() {
<span class="line-modified">187         return providers.getMetaAccess();</span>
188     }
189 
190     @Override
191     public ConstantReflectionProvider getConstantReflection() {
<span class="line-modified">192         return providers.getConstantReflection();</span>
193     }
194 
195     @Override
196     public ConstantFieldProvider getConstantFieldProvider() {
<span class="line-modified">197         return providers.getConstantFieldProvider();</span>
<span class="line-added">198     }</span>
<span class="line-added">199 </span>
<span class="line-added">200     @Override</span>
<span class="line-added">201     public Replacements getReplacements() {</span>
<span class="line-added">202         return providers.getReplacements();</span>
203     }
204 
205     @Override
206     public StructuredGraph getGraph() {
207         return graph;
208     }
209 
210     @Override
211     public void setStateAfter(StateSplit sideEffect) {
212         assert sideEffect.hasSideEffect();
213         FrameState stateAfter = getGraph().add(new FrameState(BytecodeFrame.BEFORE_BCI));
214         sideEffect.setStateAfter(stateAfter);
215     }
216 
217     @Override
218     public GraphBuilderContext getParent() {
219         return null;
220     }
221 
222     @Override
</pre>
<hr />
<pre>
271 
272     @SuppressWarnings(&quot;try&quot;)
273     public StructuredGraph buildGraph(InvocationPlugin plugin) {
274         NodeSourcePosition position = graph.trackNodeSourcePosition() ? NodeSourcePosition.placeholder(method) : null;
275         try (DebugCloseable context = graph.withNodeSourcePosition(position)) {
276             Receiver receiver = method.isStatic() ? null : this;
277             if (plugin.execute(this, method, receiver, arguments)) {
278                 assert (returnValue != null) == (method.getSignature().getReturnKind() != JavaKind.Void) : method;
279                 append(new ReturnNode(returnValue));
280                 return graph;
281             }
282             return null;
283         }
284     }
285 
286     @Override
287     public boolean intrinsify(BytecodeProvider bytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] args) {
288         throw GraalError.shouldNotReachHere();
289     }
290 
<span class="line-added">291     @Override</span>
<span class="line-added">292     public boolean intrinsify(ResolvedJavaMethod targetMethod, StructuredGraph substituteGraph, Receiver receiver, ValueNode[] argsIncludingReceiver) {</span>
<span class="line-added">293         throw GraalError.shouldNotReachHere();</span>
<span class="line-added">294     }</span>
<span class="line-added">295 </span>
296     @Override
297     public String toString() {
298         return String.format(&quot;%s:intrinsic&quot;, method.format(&quot;%H.%n(%p)&quot;));
299     }
300 }
</pre>
</td>
</tr>
</table>
<center><a href="InlineDuringParsingPlugin.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MethodHandlePlugin.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
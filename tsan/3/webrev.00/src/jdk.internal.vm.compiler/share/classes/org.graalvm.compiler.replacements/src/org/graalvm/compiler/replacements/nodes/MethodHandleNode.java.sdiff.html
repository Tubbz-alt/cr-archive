<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/nodes/MethodHandleNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MacroStateSplitNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ReadRegisterNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/nodes/MethodHandleNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
189      * @return the MemberName argument node (which is the last argument)
190      */
191     private static ValueNode getMemberName(ValueNode[] arguments) {
192         return arguments[arguments.length - 1];
193     }
194 
195     /**
196      * Used for the MethodHandle.invokeBasic method (the {@link IntrinsicMethod#INVOKE_BASIC }
197      * method) to get the target {@link InvokeNode} if the method handle receiver is constant.
198      *
199      * @param adder
200      *
201      * @return invoke node for the {@link java.lang.invoke.MethodHandle} target
202      */
203     private static InvokeNode getInvokeBasicTarget(GraphAdder adder, IntrinsicMethod intrinsicMethod, MethodHandleAccessProvider methodHandleAccess,
204                     ResolvedJavaMethod original,
205                     int bci,
206                     StampPair returnStamp, ValueNode[] arguments) {
207         ValueNode methodHandleNode = getReceiver(arguments);
208         if (methodHandleNode.isConstant()) {
<span class="line-modified">209             return getTargetInvokeNode(adder, intrinsicMethod, bci, returnStamp, arguments, methodHandleAccess.resolveInvokeBasicTarget(methodHandleNode.asJavaConstant(), true), original);</span>

210         }
211         return null;
212     }
213 
214     /**
215      * Used for the MethodHandle.linkTo* methods (the {@link IntrinsicMethod#LINK_TO_STATIC},
216      * {@link IntrinsicMethod#LINK_TO_SPECIAL}, {@link IntrinsicMethod#LINK_TO_VIRTUAL}, and
217      * {@link IntrinsicMethod#LINK_TO_INTERFACE} methods) to get the target {@link InvokeNode} if
218      * the member name argument is constant.
219      *
220      * @param adder
221      *
222      * @return invoke node for the member name target
223      */
224     private static InvokeNode getLinkToTarget(GraphAdder adder, IntrinsicMethod intrinsicMethod, MethodHandleAccessProvider methodHandleAccess,
225                     ResolvedJavaMethod original,
226                     int bci,
227                     StampPair returnStamp, ValueNode[] arguments) {
228         ValueNode memberNameNode = getMemberName(arguments);
229         if (memberNameNode.isConstant()) {
<span class="line-modified">230             return getTargetInvokeNode(adder, intrinsicMethod, bci, returnStamp, arguments, methodHandleAccess.resolveLinkToTarget(memberNameNode.asJavaConstant()), original);</span>
231         }
232         return null;
233     }
234 
235     /**
236      * Helper function to get the {@link InvokeNode} for the targetMethod of a
237      * java.lang.invoke.MemberName.
238      *
239      * @param adder
240      * @param target the target, already loaded from the member name node
241      *
242      * @return invoke node for the member name target
243      */
<span class="line-modified">244     private static InvokeNode getTargetInvokeNode(GraphAdder adder, IntrinsicMethod intrinsicMethod, int bci, StampPair returnStamp, ValueNode[] originalArguments, ResolvedJavaMethod target,</span>

245                     ResolvedJavaMethod original) {
<span class="line-modified">246         if (target == null) {</span>
247             return null;
248         }
249 
250         // In lambda forms we erase signature types to avoid resolving issues
251         // involving class loaders. When we optimize a method handle invoke
252         // to a direct call we must cast the receiver and arguments to its
253         // actual types.
254         Signature signature = target.getSignature();
255         final boolean isStatic = target.isStatic();
256         final int receiverSkip = isStatic ? 0 : 1;
257 
258         Assumptions assumptions = adder.getAssumptions();
259         ResolvedJavaMethod realTarget = null;
<span class="line-modified">260         if (target.canBeStaticallyBound()) {</span>
261             realTarget = target;
262         } else {
263             ResolvedJavaType targetType = target.getDeclaringClass();
264             // Try to bind based on the declaredType
265             AssumptionResult&lt;ResolvedJavaMethod&gt; concreteMethod = targetType.findUniqueConcreteMethod(target);
266             if (concreteMethod == null) {
267                 // Try to get the most accurate receiver type
268                 if (intrinsicMethod == IntrinsicMethod.LINK_TO_VIRTUAL || intrinsicMethod == IntrinsicMethod.LINK_TO_INTERFACE) {
269                     ValueNode receiver = getReceiver(originalArguments);
270                     TypeReference receiverType = StampTool.typeReferenceOrNull(receiver.stamp(NodeView.DEFAULT));
271                     if (receiverType != null) {
272                         concreteMethod = receiverType.getType().findUniqueConcreteMethod(target);
273                     }
274                 }
275 
276             }
277             if (concreteMethod != null &amp;&amp; concreteMethod.canRecordTo(assumptions)) {
278                 concreteMethod.recordTo(assumptions);
279                 realTarget = concreteMethod.getResult();
280             }
</pre>
<hr />
<pre>
373                 targetArguments = Arrays.copyOfRange(arguments, 0, arguments.length - 1);
374                 break;
375             default:
376                 throw GraalError.shouldNotReachHere();
377         }
378         StampPair targetReturnStamp = StampFactory.forDeclaredType(assumptions, targetReturnType, false);
379 
380         MethodCallTargetNode callTarget = ResolvedMethodHandleCallTargetNode.create(targetInvokeKind, target, targetArguments, targetReturnStamp, original, arguments, returnStamp);
381 
382         // The call target can have a different return type than the invoker,
383         // e.g. the target returns an Object but the invoker void. In this case
384         // we need to use the stamp of the invoker. Note: always using the
385         // invoker&#39;s stamp would be wrong because it&#39;s a less concrete type
386         // (usually java.lang.Object).
387         if (returnStamp.getTrustedStamp().getStackKind() == JavaKind.Void) {
388             return new InvokeNode(callTarget, bci, StampFactory.forVoid());
389         } else {
390             return new InvokeNode(callTarget, bci);
391         }
392     }
















































































393 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
189      * @return the MemberName argument node (which is the last argument)
190      */
191     private static ValueNode getMemberName(ValueNode[] arguments) {
192         return arguments[arguments.length - 1];
193     }
194 
195     /**
196      * Used for the MethodHandle.invokeBasic method (the {@link IntrinsicMethod#INVOKE_BASIC }
197      * method) to get the target {@link InvokeNode} if the method handle receiver is constant.
198      *
199      * @param adder
200      *
201      * @return invoke node for the {@link java.lang.invoke.MethodHandle} target
202      */
203     private static InvokeNode getInvokeBasicTarget(GraphAdder adder, IntrinsicMethod intrinsicMethod, MethodHandleAccessProvider methodHandleAccess,
204                     ResolvedJavaMethod original,
205                     int bci,
206                     StampPair returnStamp, ValueNode[] arguments) {
207         ValueNode methodHandleNode = getReceiver(arguments);
208         if (methodHandleNode.isConstant()) {
<span class="line-modified">209             return getTargetInvokeNode(adder, intrinsicMethod, methodHandleAccess, bci, returnStamp, arguments, methodHandleAccess.resolveInvokeBasicTarget(methodHandleNode.asJavaConstant(), true),</span>
<span class="line-added">210                             original);</span>
211         }
212         return null;
213     }
214 
215     /**
216      * Used for the MethodHandle.linkTo* methods (the {@link IntrinsicMethod#LINK_TO_STATIC},
217      * {@link IntrinsicMethod#LINK_TO_SPECIAL}, {@link IntrinsicMethod#LINK_TO_VIRTUAL}, and
218      * {@link IntrinsicMethod#LINK_TO_INTERFACE} methods) to get the target {@link InvokeNode} if
219      * the member name argument is constant.
220      *
221      * @param adder
222      *
223      * @return invoke node for the member name target
224      */
225     private static InvokeNode getLinkToTarget(GraphAdder adder, IntrinsicMethod intrinsicMethod, MethodHandleAccessProvider methodHandleAccess,
226                     ResolvedJavaMethod original,
227                     int bci,
228                     StampPair returnStamp, ValueNode[] arguments) {
229         ValueNode memberNameNode = getMemberName(arguments);
230         if (memberNameNode.isConstant()) {
<span class="line-modified">231             return getTargetInvokeNode(adder, intrinsicMethod, methodHandleAccess, bci, returnStamp, arguments, methodHandleAccess.resolveLinkToTarget(memberNameNode.asJavaConstant()), original);</span>
232         }
233         return null;
234     }
235 
236     /**
237      * Helper function to get the {@link InvokeNode} for the targetMethod of a
238      * java.lang.invoke.MemberName.
239      *
240      * @param adder
241      * @param target the target, already loaded from the member name node
242      *
243      * @return invoke node for the member name target
244      */
<span class="line-modified">245     private static InvokeNode getTargetInvokeNode(GraphAdder adder, IntrinsicMethod intrinsicMethod, MethodHandleAccessProvider methodHandleAccess, int bci, StampPair returnStamp,</span>
<span class="line-added">246                     ValueNode[] originalArguments, ResolvedJavaMethod target,</span>
247                     ResolvedJavaMethod original) {
<span class="line-modified">248         if (target == null || !isConsistentInfo(methodHandleAccess, original, target)) {</span>
249             return null;
250         }
251 
252         // In lambda forms we erase signature types to avoid resolving issues
253         // involving class loaders. When we optimize a method handle invoke
254         // to a direct call we must cast the receiver and arguments to its
255         // actual types.
256         Signature signature = target.getSignature();
257         final boolean isStatic = target.isStatic();
258         final int receiverSkip = isStatic ? 0 : 1;
259 
260         Assumptions assumptions = adder.getAssumptions();
261         ResolvedJavaMethod realTarget = null;
<span class="line-modified">262         if (target.canBeStaticallyBound() || intrinsicMethod == IntrinsicMethod.LINK_TO_SPECIAL) {</span>
263             realTarget = target;
264         } else {
265             ResolvedJavaType targetType = target.getDeclaringClass();
266             // Try to bind based on the declaredType
267             AssumptionResult&lt;ResolvedJavaMethod&gt; concreteMethod = targetType.findUniqueConcreteMethod(target);
268             if (concreteMethod == null) {
269                 // Try to get the most accurate receiver type
270                 if (intrinsicMethod == IntrinsicMethod.LINK_TO_VIRTUAL || intrinsicMethod == IntrinsicMethod.LINK_TO_INTERFACE) {
271                     ValueNode receiver = getReceiver(originalArguments);
272                     TypeReference receiverType = StampTool.typeReferenceOrNull(receiver.stamp(NodeView.DEFAULT));
273                     if (receiverType != null) {
274                         concreteMethod = receiverType.getType().findUniqueConcreteMethod(target);
275                     }
276                 }
277 
278             }
279             if (concreteMethod != null &amp;&amp; concreteMethod.canRecordTo(assumptions)) {
280                 concreteMethod.recordTo(assumptions);
281                 realTarget = concreteMethod.getResult();
282             }
</pre>
<hr />
<pre>
375                 targetArguments = Arrays.copyOfRange(arguments, 0, arguments.length - 1);
376                 break;
377             default:
378                 throw GraalError.shouldNotReachHere();
379         }
380         StampPair targetReturnStamp = StampFactory.forDeclaredType(assumptions, targetReturnType, false);
381 
382         MethodCallTargetNode callTarget = ResolvedMethodHandleCallTargetNode.create(targetInvokeKind, target, targetArguments, targetReturnStamp, original, arguments, returnStamp);
383 
384         // The call target can have a different return type than the invoker,
385         // e.g. the target returns an Object but the invoker void. In this case
386         // we need to use the stamp of the invoker. Note: always using the
387         // invoker&#39;s stamp would be wrong because it&#39;s a less concrete type
388         // (usually java.lang.Object).
389         if (returnStamp.getTrustedStamp().getStackKind() == JavaKind.Void) {
390             return new InvokeNode(callTarget, bci, StampFactory.forVoid());
391         } else {
392             return new InvokeNode(callTarget, bci);
393         }
394     }
<span class="line-added">395 </span>
<span class="line-added">396     /**</span>
<span class="line-added">397      * Checks basic type consistency of low level method handle intrinsics.</span>
<span class="line-added">398      *</span>
<span class="line-added">399      * @param original declared method</span>
<span class="line-added">400      * @param target resolved method</span>
<span class="line-added">401      * @return true if original is type consistent with target</span>
<span class="line-added">402      */</span>
<span class="line-added">403     private static boolean isConsistentInfo(MethodHandleAccessProvider methodHandleAccess, ResolvedJavaMethod original, ResolvedJavaMethod target) {</span>
<span class="line-added">404         IntrinsicMethod originalIntrinsicMethod = methodHandleAccess.lookupMethodHandleIntrinsic(original);</span>
<span class="line-added">405         assert originalIntrinsicMethod == IntrinsicMethod.INVOKE_BASIC ||</span>
<span class="line-added">406                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_STATIC ||</span>
<span class="line-added">407                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_SPECIAL ||</span>
<span class="line-added">408                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_VIRTUAL ||</span>
<span class="line-added">409                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_INTERFACE;</span>
<span class="line-added">410         IntrinsicMethod targetIntrinsicMethod = methodHandleAccess.lookupMethodHandleIntrinsic(target);</span>
<span class="line-added">411         Signature originalSignature = original.getSignature();</span>
<span class="line-added">412         Signature targetSignature = target.getSignature();</span>
<span class="line-added">413 </span>
<span class="line-added">414         boolean invokeThroughMHIntrinsic = originalIntrinsicMethod != null &amp;&amp; targetIntrinsicMethod == null;</span>
<span class="line-added">415         if (!invokeThroughMHIntrinsic) {</span>
<span class="line-added">416             return (original.getName().equals(target.getName())) &amp;&amp; (originalSignature.equals(targetSignature));</span>
<span class="line-added">417         }</span>
<span class="line-added">418 </span>
<span class="line-added">419         // Linkers have appendix argument which is not passed to callee.</span>
<span class="line-added">420         int hasAppendix = (originalIntrinsicMethod == IntrinsicMethod.LINK_TO_STATIC ||</span>
<span class="line-added">421                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_SPECIAL ||</span>
<span class="line-added">422                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_VIRTUAL ||</span>
<span class="line-added">423                         originalIntrinsicMethod == IntrinsicMethod.LINK_TO_INTERFACE) ? 1 : 0;</span>
<span class="line-added">424         if (originalSignature.getParameterCount(original.hasReceiver()) != (targetSignature.getParameterCount(target.hasReceiver()) + hasAppendix)) {</span>
<span class="line-added">425             return false; // parameter count mismatch</span>
<span class="line-added">426         }</span>
<span class="line-added">427         int senderBase = 0;</span>
<span class="line-added">428         int receiverBase = 0;</span>
<span class="line-added">429         switch (originalIntrinsicMethod) {</span>
<span class="line-added">430             case LINK_TO_VIRTUAL:</span>
<span class="line-added">431             case LINK_TO_INTERFACE:</span>
<span class="line-added">432             case LINK_TO_SPECIAL: {</span>
<span class="line-added">433                 if (target.isStatic()) {</span>
<span class="line-added">434                     return false;</span>
<span class="line-added">435                 }</span>
<span class="line-added">436                 if (originalSignature.getParameterKind(0).isPrimitive()) {</span>
<span class="line-added">437                     return false; // receiver should be an oop</span>
<span class="line-added">438                 }</span>
<span class="line-added">439                 senderBase = 1; // skip receiver</span>
<span class="line-added">440                 break;</span>
<span class="line-added">441             }</span>
<span class="line-added">442             case LINK_TO_STATIC: {</span>
<span class="line-added">443                 if (target.hasReceiver()) {</span>
<span class="line-added">444                     return false;</span>
<span class="line-added">445                 }</span>
<span class="line-added">446                 break;</span>
<span class="line-added">447             }</span>
<span class="line-added">448             case INVOKE_BASIC: {</span>
<span class="line-added">449                 if (target.isStatic()) {</span>
<span class="line-added">450                     if (targetSignature.getParameterKind(0).isPrimitive()) {</span>
<span class="line-added">451                         return false; // receiver should be an oop</span>
<span class="line-added">452                     }</span>
<span class="line-added">453                     receiverBase = 1; // skip receiver</span>
<span class="line-added">454                 }</span>
<span class="line-added">455                 break;</span>
<span class="line-added">456             }</span>
<span class="line-added">457             default:</span>
<span class="line-added">458                 break;</span>
<span class="line-added">459         }</span>
<span class="line-added">460         assert (targetSignature.getParameterCount(false) - receiverBase) == (originalSignature.getParameterCount(false) - senderBase - hasAppendix) : &quot;argument count mismatch&quot;;</span>
<span class="line-added">461         int argCount = targetSignature.getParameterCount(false) - receiverBase;</span>
<span class="line-added">462         for (int i = 0; i &lt; argCount; i++) {</span>
<span class="line-added">463             if (originalSignature.getParameterKind(senderBase + i).getStackKind() != targetSignature.getParameterKind(receiverBase + i).getStackKind()) {</span>
<span class="line-added">464                 return false;</span>
<span class="line-added">465             }</span>
<span class="line-added">466         }</span>
<span class="line-added">467         // Only check the return type if the symbolic info has non-void return type.</span>
<span class="line-added">468         // I.e. the return value of the resolved method can be dropped.</span>
<span class="line-added">469         if (originalSignature.getReturnKind() != JavaKind.Void &amp;&amp;</span>
<span class="line-added">470                         originalSignature.getReturnKind().getStackKind() != targetSignature.getReturnKind().getStackKind()) {</span>
<span class="line-added">471             return false;</span>
<span class="line-added">472         }</span>
<span class="line-added">473         return true; // no mismatch found</span>
<span class="line-added">474     }</span>
475 }
</pre>
</td>
</tr>
</table>
<center><a href="MacroStateSplitNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ReadRegisterNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
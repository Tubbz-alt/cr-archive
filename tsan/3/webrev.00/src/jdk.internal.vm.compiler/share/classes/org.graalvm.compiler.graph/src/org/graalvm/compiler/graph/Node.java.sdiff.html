<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/Node.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IterableNodeType.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeClass.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/Node.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.graph;
  26 
  27 import static org.graalvm.compiler.graph.Edges.Type.Inputs;
  28 import static org.graalvm.compiler.graph.Edges.Type.Successors;
  29 import static org.graalvm.compiler.graph.Graph.isModificationCountsEnabled;
<span class="line-modified">  30 import static org.graalvm.compiler.graph.UnsafeAccess.UNSAFE;</span>
  31 
  32 import java.lang.annotation.ElementType;
  33 import java.lang.annotation.RetentionPolicy;
  34 import java.util.Arrays;
  35 import java.util.Collections;
  36 import java.util.EnumSet;
  37 import java.util.Formattable;
  38 import java.util.FormattableFlags;
  39 import java.util.Formatter;
  40 import java.util.HashMap;
  41 import java.util.Map;
  42 import java.util.Objects;
  43 import java.util.function.Predicate;
  44 import java.util.function.Supplier;
  45 
  46 import org.graalvm.compiler.core.common.Fields;
  47 import org.graalvm.compiler.core.common.type.AbstractPointerStamp;
  48 import org.graalvm.compiler.core.common.type.Stamp;
  49 import org.graalvm.compiler.debug.DebugCloseable;
  50 import org.graalvm.compiler.debug.DebugContext;
  51 import org.graalvm.compiler.graph.Graph.NodeEventListener;
  52 import org.graalvm.compiler.graph.Graph.Options;
  53 import org.graalvm.compiler.graph.iterators.NodeIterable;
  54 import org.graalvm.compiler.graph.iterators.NodePredicate;
  55 import org.graalvm.compiler.graph.spi.Simplifiable;
  56 import org.graalvm.compiler.graph.spi.SimplifierTool;
  57 import org.graalvm.compiler.nodeinfo.InputType;
  58 import org.graalvm.compiler.nodeinfo.NodeCycles;
  59 import org.graalvm.compiler.nodeinfo.NodeInfo;
  60 import org.graalvm.compiler.nodeinfo.NodeSize;
  61 import org.graalvm.compiler.nodeinfo.Verbosity;
  62 import org.graalvm.compiler.options.OptionValues;
  63 

  64 import sun.misc.Unsafe;
  65 
  66 /**
  67  * This class is the base class for all nodes. It represents a node that can be inserted in a
  68  * {@link Graph}.
  69  * &lt;p&gt;
  70  * Once a node has been added to a graph, it has a graph-unique {@link #id()}. Edges in the
  71  * subclasses are represented with annotated fields. There are two kind of edges : {@link Input} and
  72  * {@link Successor}. If a field, of a type compatible with {@link Node}, annotated with either
  73  * {@link Input} and {@link Successor} is not null, then there is an edge from this node to the node
  74  * this field points to.
  75  * &lt;p&gt;
  76  * Nodes which are be value numberable should implement the {@link ValueNumberable} interface.
  77  *
  78  * &lt;h1&gt;Assertions and Verification&lt;/h1&gt;
  79  *
  80  * The Node class supplies the {@link #assertTrue(boolean, String, Object...)} and
  81  * {@link #assertFalse(boolean, String, Object...)} methods, which will check the supplied boolean
  82  * and throw a VerificationError if it has the wrong value. Both methods will always either throw an
  83  * exception or return true. They can thus be used within an assert statement, so that the check is
  84  * only performed if assertions are enabled.
  85  */
  86 @NodeInfo
  87 public abstract class Node implements Cloneable, Formattable, NodeInterface {
  88 


  89     public static final NodeClass&lt;?&gt; TYPE = null;
  90 
<span class="line-modified">  91     public static final boolean TRACK_CREATION_POSITION = Boolean.getBoolean(&quot;debug.graal.TrackNodeCreationPosition&quot;);</span>
  92 
  93     static final int DELETED_ID_START = -1000000000;
  94     static final int INITIAL_ID = -1;
  95     static final int ALIVE_ID_START = 0;
  96 
  97     // The use of fully qualified class names here and in the rest
  98     // of this file works around a problem javac has resolving symbols
  99 
 100     /**
 101      * Denotes a non-optional (non-null) node input. This should be applied to exactly the fields of
 102      * a node that are of type {@link Node} or {@link NodeInputList}. Nodes that update fields of
 103      * type {@link Node} outside of their constructor should call
 104      * {@link Node#updateUsages(Node, Node)} just prior to doing the update of the input.
 105      */
 106     @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)
 107     @java.lang.annotation.Target(ElementType.FIELD)
 108     public static @interface Input {
 109         InputType value() default InputType.Value;
 110     }
 111 
</pre>
<hr />
<pre>
 172      * {@link NodeIntrinsic} annotated method.
 173      */
 174     @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)
 175     @java.lang.annotation.Target(ElementType.METHOD)
 176     public static @interface NodeIntrinsic {
 177 
 178         /**
 179          * The class declaring the factory method or {@link Node} subclass declaring the constructor
 180          * used to intrinsify a call to the annotated method. The default value is the class in
 181          * which the annotated method is declared.
 182          */
 183         Class&lt;?&gt; value() default NodeIntrinsic.class;
 184 
 185         /**
 186          * If {@code true}, the factory method or constructor selected by the annotation must have
 187          * an {@linkplain InjectedNodeParameter injected} {@link Stamp} parameter. Calling
 188          * {@link AbstractPointerStamp#nonNull()} on the injected stamp is guaranteed to return
 189          * {@code true}.
 190          */
 191         boolean injectedStampIsNonNull() default false;





 192     }
 193 
 194     /**
 195      * Marker for a node that can be replaced by another node via global value numbering. A
 196      * {@linkplain NodeClass#isLeafNode() leaf} node can be replaced by another node of the same
 197      * type that has exactly the same {@linkplain NodeClass#getData() data} values. A non-leaf node
 198      * can be replaced by another node of the same type that has exactly the same data values as
 199      * well as the same {@linkplain Node#inputs() inputs} and {@linkplain Node#successors()
 200      * successors}.
 201      */
 202     public interface ValueNumberable {
 203     }
 204 
 205     /**
 206      * Marker interface for nodes that contains other nodes. When the inputs to this node changes,
 207      * users of this node should also be placed on the work list for canonicalization.
 208      */
 209     public interface IndirectCanonicalization {
 210     }
 211 
</pre>
<hr />
<pre>
 588         updateUsages(oldInput == null ? null : oldInput.asNode(), newInput == null ? null : newInput.asNode());
 589     }
 590 
 591     /**
 592      * Updates the predecessor of the given nodes after a successor slot is changed from
 593      * oldSuccessor to newSuccessor: removes this node from oldSuccessor&#39;s predecessors and adds
 594      * this node to newSuccessor&#39;s predecessors.
 595      */
 596     protected void updatePredecessor(Node oldSuccessor, Node newSuccessor) {
 597         assert isAlive() &amp;&amp; (newSuccessor == null || newSuccessor.isAlive()) || newSuccessor == null &amp;&amp; !isAlive() : &quot;adding &quot; + newSuccessor + &quot; to &quot; + this + &quot; instead of &quot; + oldSuccessor;
 598         assert graph == null || !graph.isFrozen();
 599         if (oldSuccessor != newSuccessor) {
 600             if (oldSuccessor != null) {
 601                 assert assertTrue(newSuccessor == null || oldSuccessor.predecessor == this, &quot;wrong predecessor in old successor (%s): %s, should be %s&quot;, oldSuccessor, oldSuccessor.predecessor, this);
 602                 oldSuccessor.predecessor = null;
 603             }
 604             if (newSuccessor != null) {
 605                 assert assertTrue(newSuccessor.predecessor == null, &quot;unexpected non-null predecessor in new successor (%s): %s, this=%s&quot;, newSuccessor, newSuccessor.predecessor, this);
 606                 newSuccessor.predecessor = this;
 607             }

 608         }
 609     }
 610 
 611     void initialize(Graph newGraph) {
 612         assert assertTrue(id == INITIAL_ID, &quot;unexpected id: %d&quot;, id);
 613         this.graph = newGraph;
 614         newGraph.register(this);
 615         NodeClass&lt;? extends Node&gt; nc = nodeClass;
 616         nc.registerAtInputsAsUsage(this);
 617         nc.registerAtSuccessorsAsPredecessor(this);
 618     }
 619 
 620     /**
 621      * Information associated with this node. A single value is stored directly in the field.
 622      * Multiple values are stored by creating an Object[].
 623      */
 624     private Object annotation;
 625 
 626     private &lt;T&gt; T getNodeInfo(Class&lt;T&gt; clazz) {
 627         assert clazz != Object[].class;
</pre>
<hr />
<pre>
 792         this.extraUsages = NO_NODES;
 793         this.extraUsagesCount = 0;
 794     }
 795 
 796     private void replaceAtUsage(Node other, Node toBeDeleted, Node usage) {
 797         boolean result = usage.getNodeClass().replaceFirstInput(usage, this, other);
 798         assert assertTrue(result, &quot;not found in inputs, usage: %s&quot;, usage);
 799         /*
 800          * Don&#39;t notify for nodes which are about to be deleted.
 801          */
 802         if (toBeDeleted == null || usage != toBeDeleted) {
 803             maybeNotifyInputChanged(usage);
 804         }
 805         if (other != null) {
 806             other.addUsage(usage);
 807         }
 808     }
 809 
 810     private void replaceAtMatchingUsages(Node other, Predicate&lt;Node&gt; filter, Node toBeDeleted) {
 811         if (filter == null) {
<span class="line-modified"> 812             fail(&quot;filter cannot be null&quot;);</span>
 813         }
 814         checkReplaceWith(other);
 815         int i = 0;
<span class="line-modified"> 816         while (i &lt; this.getUsageCount()) {</span>

 817             Node usage = this.getUsageAt(i);
 818             if (filter.test(usage)) {
 819                 replaceAtUsage(other, toBeDeleted, usage);
 820                 this.movUsageFromEndTo(i);

 821             } else {
 822                 ++i;
 823             }
 824         }
 825     }
 826 
<span class="line-modified"> 827     public Node getUsageAt(int index) {</span>
 828         if (index == 0) {
 829             return this.usage0;
 830         } else if (index == 1) {
 831             return this.usage1;
 832         } else {
 833             return this.extraUsages[index - INLINE_USAGE_COUNT];
 834         }
 835     }
 836 
 837     public void replaceAtMatchingUsages(Node other, NodePredicate usagePredicate) {
 838         checkReplaceWith(other);
 839         replaceAtMatchingUsages(other, usagePredicate, null);
 840     }
 841 








 842     public void replaceAtUsages(InputType type, Node other) {
 843         checkReplaceWith(other);
<span class="line-modified"> 844         for (Node usage : usages().snapshot()) {</span>






 845             for (Position pos : usage.inputPositions()) {
 846                 if (pos.getInputType() == type &amp;&amp; pos.get(usage) == this) {
<span class="line-modified"> 847                     pos.set(usage, other);</span>



 848                 }
 849             }




 850         }
 851     }
 852 
 853     private void maybeNotifyInputChanged(Node node) {
 854         if (graph != null) {
 855             assert !graph.isFrozen();
 856             NodeEventListener listener = graph.nodeEventListener;
 857             if (listener != null) {
 858                 listener.event(Graph.NodeEvent.INPUT_CHANGED, node);
 859             }
 860         }
 861     }
 862 
 863     public void maybeNotifyZeroUsages(Node node) {
 864         if (graph != null) {
 865             assert !graph.isFrozen();
 866             NodeEventListener listener = graph.nodeEventListener;
 867             if (listener != null &amp;&amp; node.isAlive()) {
 868                 listener.event(Graph.NodeEvent.ZERO_USAGES, node);
 869             }
</pre>
<hr />
<pre>
 887         }
 888         if (this.hasUsages()) {
 889             replaceAtUsages(other);
 890         }
 891         replaceAtPredecessor(other);
 892         this.safeDelete();
 893     }
 894 
 895     public void replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor) {
 896         if (nodeClass.replaceFirstSuccessor(this, oldSuccessor, newSuccessor)) {
 897             updatePredecessor(oldSuccessor, newSuccessor);
 898         }
 899     }
 900 
 901     public void replaceFirstInput(Node oldInput, Node newInput) {
 902         if (nodeClass.replaceFirstInput(this, oldInput, newInput)) {
 903             updateUsages(oldInput, newInput);
 904         }
 905     }
 906 














 907     public void clearInputs() {
 908         assert assertFalse(isDeleted(), &quot;cannot clear inputs of deleted node&quot;);
 909         getNodeClass().unregisterAtInputsAsUsage(this);
 910     }
 911 
 912     boolean removeThisFromUsages(Node n) {
 913         return n.removeUsage(this);
 914     }
 915 
 916     public void clearSuccessors() {
 917         assert assertFalse(isDeleted(), &quot;cannot clear successors of deleted node&quot;);
 918         getNodeClass().unregisterAtSuccessorsAsPredecessor(this);
 919     }
 920 
 921     private boolean checkDeletion() {
 922         assertTrue(isAlive(), &quot;must be alive&quot;);
 923         assertTrue(hasNoUsages(), &quot;cannot delete node %s because of usages: %s&quot;, this, usages());
 924         assertTrue(predecessor == null, &quot;cannot delete node %s because of predecessor: %s&quot;, this, predecessor);
 925         return true;
 926     }
</pre>
<hr />
<pre>
1033 
1034         if (into != null &amp;&amp; useIntoLeafNodeCache) {
1035             into.putNodeIntoCache(newNode);
1036         }
1037         newNode.afterClone(this);
1038         return newNode;
1039     }
1040 
1041     protected void afterClone(@SuppressWarnings(&quot;unused&quot;) Node other) {
1042     }
1043 
1044     protected boolean verifyInputs() {
1045         for (Position pos : inputPositions()) {
1046             Node input = pos.get(this);
1047             if (input == null) {
1048                 assertTrue(pos.isInputOptional(), &quot;non-optional input %s cannot be null in %s (fix nullness or use @OptionalInput)&quot;, pos, this);
1049             } else {
1050                 assertFalse(input.isDeleted(), &quot;input was deleted %s&quot;, input);
1051                 assertTrue(input.isAlive(), &quot;input is not alive yet, i.e., it was not yet added to the graph&quot;);
1052                 assertTrue(pos.getInputType() == InputType.Unchecked || input.isAllowedUsageType(pos.getInputType()), &quot;invalid usage type %s %s&quot;, input, pos.getInputType());


1053             }
1054         }
1055         return true;
1056     }
1057 
1058     public boolean verify() {
1059         assertTrue(isAlive(), &quot;cannot verify inactive nodes (id=%d)&quot;, id);
1060         assertTrue(graph() != null, &quot;null graph&quot;);
1061         verifyInputs();
1062         if (Options.VerifyGraalGraphEdges.getValue(getOptions())) {
1063             verifyEdges();
1064         }
1065         return true;
1066     }
1067 
1068     public boolean verifySourcePosition() {
1069         return true;
1070     }
1071 
1072     /**
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.graph;
  26 
  27 import static org.graalvm.compiler.graph.Edges.Type.Inputs;
  28 import static org.graalvm.compiler.graph.Edges.Type.Successors;
  29 import static org.graalvm.compiler.graph.Graph.isModificationCountsEnabled;
<span class="line-modified">  30 import static org.graalvm.compiler.serviceprovider.GraalUnsafeAccess.getUnsafe;</span>
  31 
  32 import java.lang.annotation.ElementType;
  33 import java.lang.annotation.RetentionPolicy;
  34 import java.util.Arrays;
  35 import java.util.Collections;
  36 import java.util.EnumSet;
  37 import java.util.Formattable;
  38 import java.util.FormattableFlags;
  39 import java.util.Formatter;
  40 import java.util.HashMap;
  41 import java.util.Map;
  42 import java.util.Objects;
  43 import java.util.function.Predicate;
  44 import java.util.function.Supplier;
  45 
  46 import org.graalvm.compiler.core.common.Fields;
  47 import org.graalvm.compiler.core.common.type.AbstractPointerStamp;
  48 import org.graalvm.compiler.core.common.type.Stamp;
  49 import org.graalvm.compiler.debug.DebugCloseable;
  50 import org.graalvm.compiler.debug.DebugContext;
  51 import org.graalvm.compiler.graph.Graph.NodeEventListener;
  52 import org.graalvm.compiler.graph.Graph.Options;
  53 import org.graalvm.compiler.graph.iterators.NodeIterable;
  54 import org.graalvm.compiler.graph.iterators.NodePredicate;
  55 import org.graalvm.compiler.graph.spi.Simplifiable;
  56 import org.graalvm.compiler.graph.spi.SimplifierTool;
  57 import org.graalvm.compiler.nodeinfo.InputType;
  58 import org.graalvm.compiler.nodeinfo.NodeCycles;
  59 import org.graalvm.compiler.nodeinfo.NodeInfo;
  60 import org.graalvm.compiler.nodeinfo.NodeSize;
  61 import org.graalvm.compiler.nodeinfo.Verbosity;
  62 import org.graalvm.compiler.options.OptionValues;
  63 
<span class="line-added">  64 import jdk.vm.ci.services.Services;</span>
  65 import sun.misc.Unsafe;
  66 
  67 /**
  68  * This class is the base class for all nodes. It represents a node that can be inserted in a
  69  * {@link Graph}.
  70  * &lt;p&gt;
  71  * Once a node has been added to a graph, it has a graph-unique {@link #id()}. Edges in the
  72  * subclasses are represented with annotated fields. There are two kind of edges : {@link Input} and
  73  * {@link Successor}. If a field, of a type compatible with {@link Node}, annotated with either
  74  * {@link Input} and {@link Successor} is not null, then there is an edge from this node to the node
  75  * this field points to.
  76  * &lt;p&gt;
  77  * Nodes which are be value numberable should implement the {@link ValueNumberable} interface.
  78  *
  79  * &lt;h1&gt;Assertions and Verification&lt;/h1&gt;
  80  *
  81  * The Node class supplies the {@link #assertTrue(boolean, String, Object...)} and
  82  * {@link #assertFalse(boolean, String, Object...)} methods, which will check the supplied boolean
  83  * and throw a VerificationError if it has the wrong value. Both methods will always either throw an
  84  * exception or return true. They can thus be used within an assert statement, so that the check is
  85  * only performed if assertions are enabled.
  86  */
  87 @NodeInfo
  88 public abstract class Node implements Cloneable, Formattable, NodeInterface {
  89 
<span class="line-added">  90     private static final Unsafe UNSAFE = getUnsafe();</span>
<span class="line-added">  91 </span>
  92     public static final NodeClass&lt;?&gt; TYPE = null;
  93 
<span class="line-modified">  94     public static final boolean TRACK_CREATION_POSITION = Boolean.parseBoolean(Services.getSavedProperties().get(&quot;debug.graal.TrackNodeCreationPosition&quot;));</span>
  95 
  96     static final int DELETED_ID_START = -1000000000;
  97     static final int INITIAL_ID = -1;
  98     static final int ALIVE_ID_START = 0;
  99 
 100     // The use of fully qualified class names here and in the rest
 101     // of this file works around a problem javac has resolving symbols
 102 
 103     /**
 104      * Denotes a non-optional (non-null) node input. This should be applied to exactly the fields of
 105      * a node that are of type {@link Node} or {@link NodeInputList}. Nodes that update fields of
 106      * type {@link Node} outside of their constructor should call
 107      * {@link Node#updateUsages(Node, Node)} just prior to doing the update of the input.
 108      */
 109     @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)
 110     @java.lang.annotation.Target(ElementType.FIELD)
 111     public static @interface Input {
 112         InputType value() default InputType.Value;
 113     }
 114 
</pre>
<hr />
<pre>
 175      * {@link NodeIntrinsic} annotated method.
 176      */
 177     @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)
 178     @java.lang.annotation.Target(ElementType.METHOD)
 179     public static @interface NodeIntrinsic {
 180 
 181         /**
 182          * The class declaring the factory method or {@link Node} subclass declaring the constructor
 183          * used to intrinsify a call to the annotated method. The default value is the class in
 184          * which the annotated method is declared.
 185          */
 186         Class&lt;?&gt; value() default NodeIntrinsic.class;
 187 
 188         /**
 189          * If {@code true}, the factory method or constructor selected by the annotation must have
 190          * an {@linkplain InjectedNodeParameter injected} {@link Stamp} parameter. Calling
 191          * {@link AbstractPointerStamp#nonNull()} on the injected stamp is guaranteed to return
 192          * {@code true}.
 193          */
 194         boolean injectedStampIsNonNull() default false;
<span class="line-added"> 195 </span>
<span class="line-added"> 196         /**</span>
<span class="line-added"> 197          * If {@code true} then this is lowered into a node that has side effects.</span>
<span class="line-added"> 198          */</span>
<span class="line-added"> 199         boolean hasSideEffect() default false;</span>
 200     }
 201 
 202     /**
 203      * Marker for a node that can be replaced by another node via global value numbering. A
 204      * {@linkplain NodeClass#isLeafNode() leaf} node can be replaced by another node of the same
 205      * type that has exactly the same {@linkplain NodeClass#getData() data} values. A non-leaf node
 206      * can be replaced by another node of the same type that has exactly the same data values as
 207      * well as the same {@linkplain Node#inputs() inputs} and {@linkplain Node#successors()
 208      * successors}.
 209      */
 210     public interface ValueNumberable {
 211     }
 212 
 213     /**
 214      * Marker interface for nodes that contains other nodes. When the inputs to this node changes,
 215      * users of this node should also be placed on the work list for canonicalization.
 216      */
 217     public interface IndirectCanonicalization {
 218     }
 219 
</pre>
<hr />
<pre>
 596         updateUsages(oldInput == null ? null : oldInput.asNode(), newInput == null ? null : newInput.asNode());
 597     }
 598 
 599     /**
 600      * Updates the predecessor of the given nodes after a successor slot is changed from
 601      * oldSuccessor to newSuccessor: removes this node from oldSuccessor&#39;s predecessors and adds
 602      * this node to newSuccessor&#39;s predecessors.
 603      */
 604     protected void updatePredecessor(Node oldSuccessor, Node newSuccessor) {
 605         assert isAlive() &amp;&amp; (newSuccessor == null || newSuccessor.isAlive()) || newSuccessor == null &amp;&amp; !isAlive() : &quot;adding &quot; + newSuccessor + &quot; to &quot; + this + &quot; instead of &quot; + oldSuccessor;
 606         assert graph == null || !graph.isFrozen();
 607         if (oldSuccessor != newSuccessor) {
 608             if (oldSuccessor != null) {
 609                 assert assertTrue(newSuccessor == null || oldSuccessor.predecessor == this, &quot;wrong predecessor in old successor (%s): %s, should be %s&quot;, oldSuccessor, oldSuccessor.predecessor, this);
 610                 oldSuccessor.predecessor = null;
 611             }
 612             if (newSuccessor != null) {
 613                 assert assertTrue(newSuccessor.predecessor == null, &quot;unexpected non-null predecessor in new successor (%s): %s, this=%s&quot;, newSuccessor, newSuccessor.predecessor, this);
 614                 newSuccessor.predecessor = this;
 615             }
<span class="line-added"> 616             maybeNotifyInputChanged(this);</span>
 617         }
 618     }
 619 
 620     void initialize(Graph newGraph) {
 621         assert assertTrue(id == INITIAL_ID, &quot;unexpected id: %d&quot;, id);
 622         this.graph = newGraph;
 623         newGraph.register(this);
 624         NodeClass&lt;? extends Node&gt; nc = nodeClass;
 625         nc.registerAtInputsAsUsage(this);
 626         nc.registerAtSuccessorsAsPredecessor(this);
 627     }
 628 
 629     /**
 630      * Information associated with this node. A single value is stored directly in the field.
 631      * Multiple values are stored by creating an Object[].
 632      */
 633     private Object annotation;
 634 
 635     private &lt;T&gt; T getNodeInfo(Class&lt;T&gt; clazz) {
 636         assert clazz != Object[].class;
</pre>
<hr />
<pre>
 801         this.extraUsages = NO_NODES;
 802         this.extraUsagesCount = 0;
 803     }
 804 
 805     private void replaceAtUsage(Node other, Node toBeDeleted, Node usage) {
 806         boolean result = usage.getNodeClass().replaceFirstInput(usage, this, other);
 807         assert assertTrue(result, &quot;not found in inputs, usage: %s&quot;, usage);
 808         /*
 809          * Don&#39;t notify for nodes which are about to be deleted.
 810          */
 811         if (toBeDeleted == null || usage != toBeDeleted) {
 812             maybeNotifyInputChanged(usage);
 813         }
 814         if (other != null) {
 815             other.addUsage(usage);
 816         }
 817     }
 818 
 819     private void replaceAtMatchingUsages(Node other, Predicate&lt;Node&gt; filter, Node toBeDeleted) {
 820         if (filter == null) {
<span class="line-modified"> 821             throw fail(&quot;filter cannot be null&quot;);</span>
 822         }
 823         checkReplaceWith(other);
 824         int i = 0;
<span class="line-modified"> 825         int usageCount = this.getUsageCount();</span>
<span class="line-added"> 826         while (i &lt; usageCount) {</span>
 827             Node usage = this.getUsageAt(i);
 828             if (filter.test(usage)) {
 829                 replaceAtUsage(other, toBeDeleted, usage);
 830                 this.movUsageFromEndTo(i);
<span class="line-added"> 831                 usageCount--;</span>
 832             } else {
 833                 ++i;
 834             }
 835         }
 836     }
 837 
<span class="line-modified"> 838     private Node getUsageAt(int index) {</span>
 839         if (index == 0) {
 840             return this.usage0;
 841         } else if (index == 1) {
 842             return this.usage1;
 843         } else {
 844             return this.extraUsages[index - INLINE_USAGE_COUNT];
 845         }
 846     }
 847 
 848     public void replaceAtMatchingUsages(Node other, NodePredicate usagePredicate) {
 849         checkReplaceWith(other);
 850         replaceAtMatchingUsages(other, usagePredicate, null);
 851     }
 852 
<span class="line-added"> 853     private void replaceAtUsagePos(Node other, Node usage, Position pos) {</span>
<span class="line-added"> 854         pos.initialize(usage, other);</span>
<span class="line-added"> 855         maybeNotifyInputChanged(usage);</span>
<span class="line-added"> 856         if (other != null) {</span>
<span class="line-added"> 857             other.addUsage(usage);</span>
<span class="line-added"> 858         }</span>
<span class="line-added"> 859     }</span>
<span class="line-added"> 860 </span>
 861     public void replaceAtUsages(InputType type, Node other) {
 862         checkReplaceWith(other);
<span class="line-modified"> 863         int i = 0;</span>
<span class="line-added"> 864         int usageCount = this.getUsageCount();</span>
<span class="line-added"> 865         if (usageCount == 0) {</span>
<span class="line-added"> 866             return;</span>
<span class="line-added"> 867         }</span>
<span class="line-added"> 868         usages: while (i &lt; usageCount) {</span>
<span class="line-added"> 869             Node usage = this.getUsageAt(i);</span>
 870             for (Position pos : usage.inputPositions()) {
 871                 if (pos.getInputType() == type &amp;&amp; pos.get(usage) == this) {
<span class="line-modified"> 872                     replaceAtUsagePos(other, usage, pos);</span>
<span class="line-added"> 873                     this.movUsageFromEndTo(i);</span>
<span class="line-added"> 874                     usageCount--;</span>
<span class="line-added"> 875                     continue usages;</span>
 876                 }
 877             }
<span class="line-added"> 878             i++;</span>
<span class="line-added"> 879         }</span>
<span class="line-added"> 880         if (hasNoUsages()) {</span>
<span class="line-added"> 881             maybeNotifyZeroUsages(this);</span>
 882         }
 883     }
 884 
 885     private void maybeNotifyInputChanged(Node node) {
 886         if (graph != null) {
 887             assert !graph.isFrozen();
 888             NodeEventListener listener = graph.nodeEventListener;
 889             if (listener != null) {
 890                 listener.event(Graph.NodeEvent.INPUT_CHANGED, node);
 891             }
 892         }
 893     }
 894 
 895     public void maybeNotifyZeroUsages(Node node) {
 896         if (graph != null) {
 897             assert !graph.isFrozen();
 898             NodeEventListener listener = graph.nodeEventListener;
 899             if (listener != null &amp;&amp; node.isAlive()) {
 900                 listener.event(Graph.NodeEvent.ZERO_USAGES, node);
 901             }
</pre>
<hr />
<pre>
 919         }
 920         if (this.hasUsages()) {
 921             replaceAtUsages(other);
 922         }
 923         replaceAtPredecessor(other);
 924         this.safeDelete();
 925     }
 926 
 927     public void replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor) {
 928         if (nodeClass.replaceFirstSuccessor(this, oldSuccessor, newSuccessor)) {
 929             updatePredecessor(oldSuccessor, newSuccessor);
 930         }
 931     }
 932 
 933     public void replaceFirstInput(Node oldInput, Node newInput) {
 934         if (nodeClass.replaceFirstInput(this, oldInput, newInput)) {
 935             updateUsages(oldInput, newInput);
 936         }
 937     }
 938 
<span class="line-added"> 939     public void replaceAllInputs(Node oldInput, Node newInput) {</span>
<span class="line-added"> 940         while (nodeClass.replaceFirstInput(this, oldInput, newInput)) {</span>
<span class="line-added"> 941             updateUsages(oldInput, newInput);</span>
<span class="line-added"> 942         }</span>
<span class="line-added"> 943     }</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945     public void replaceFirstInput(Node oldInput, Node newInput, InputType type) {</span>
<span class="line-added"> 946         for (Position pos : inputPositions()) {</span>
<span class="line-added"> 947             if (pos.getInputType() == type &amp;&amp; pos.get(this) == oldInput) {</span>
<span class="line-added"> 948                 pos.set(this, newInput);</span>
<span class="line-added"> 949             }</span>
<span class="line-added"> 950         }</span>
<span class="line-added"> 951     }</span>
<span class="line-added"> 952 </span>
 953     public void clearInputs() {
 954         assert assertFalse(isDeleted(), &quot;cannot clear inputs of deleted node&quot;);
 955         getNodeClass().unregisterAtInputsAsUsage(this);
 956     }
 957 
 958     boolean removeThisFromUsages(Node n) {
 959         return n.removeUsage(this);
 960     }
 961 
 962     public void clearSuccessors() {
 963         assert assertFalse(isDeleted(), &quot;cannot clear successors of deleted node&quot;);
 964         getNodeClass().unregisterAtSuccessorsAsPredecessor(this);
 965     }
 966 
 967     private boolean checkDeletion() {
 968         assertTrue(isAlive(), &quot;must be alive&quot;);
 969         assertTrue(hasNoUsages(), &quot;cannot delete node %s because of usages: %s&quot;, this, usages());
 970         assertTrue(predecessor == null, &quot;cannot delete node %s because of predecessor: %s&quot;, this, predecessor);
 971         return true;
 972     }
</pre>
<hr />
<pre>
1079 
1080         if (into != null &amp;&amp; useIntoLeafNodeCache) {
1081             into.putNodeIntoCache(newNode);
1082         }
1083         newNode.afterClone(this);
1084         return newNode;
1085     }
1086 
1087     protected void afterClone(@SuppressWarnings(&quot;unused&quot;) Node other) {
1088     }
1089 
1090     protected boolean verifyInputs() {
1091         for (Position pos : inputPositions()) {
1092             Node input = pos.get(this);
1093             if (input == null) {
1094                 assertTrue(pos.isInputOptional(), &quot;non-optional input %s cannot be null in %s (fix nullness or use @OptionalInput)&quot;, pos, this);
1095             } else {
1096                 assertFalse(input.isDeleted(), &quot;input was deleted %s&quot;, input);
1097                 assertTrue(input.isAlive(), &quot;input is not alive yet, i.e., it was not yet added to the graph&quot;);
1098                 assertTrue(pos.getInputType() == InputType.Unchecked || input.isAllowedUsageType(pos.getInputType()), &quot;invalid usage type %s %s&quot;, input, pos.getInputType());
<span class="line-added">1099                 Class&lt;?&gt; expectedType = pos.getType();</span>
<span class="line-added">1100                 assertTrue(expectedType.isAssignableFrom(input.getClass()), &quot;Invalid input type for %s: expected a %s but was a %s&quot;, pos, expectedType, input.getClass());</span>
1101             }
1102         }
1103         return true;
1104     }
1105 
1106     public boolean verify() {
1107         assertTrue(isAlive(), &quot;cannot verify inactive nodes (id=%d)&quot;, id);
1108         assertTrue(graph() != null, &quot;null graph&quot;);
1109         verifyInputs();
1110         if (Options.VerifyGraalGraphEdges.getValue(getOptions())) {
1111             verifyEdges();
1112         }
1113         return true;
1114     }
1115 
1116     public boolean verifySourcePosition() {
1117         return true;
1118     }
1119 
1120     /**
</pre>
</td>
</tr>
</table>
<center><a href="IterableNodeType.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeClass.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/NodeClass.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.graph;
  26 
  27 import static org.graalvm.compiler.core.common.Fields.translateInto;
  28 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
  29 import static org.graalvm.compiler.graph.Edges.translateInto;
  30 import static org.graalvm.compiler.graph.Graph.isModificationCountsEnabled;
  31 import static org.graalvm.compiler.graph.InputEdges.translateInto;
  32 import static org.graalvm.compiler.graph.Node.WithAllEdges;
  33 import static org.graalvm.compiler.serviceprovider.GraalUnsafeAccess.getUnsafe;
  34 
  35 import java.lang.annotation.Annotation;
  36 import java.lang.reflect.AnnotatedElement;
  37 import java.lang.reflect.Field;
  38 import java.lang.reflect.Modifier;
  39 import java.util.ArrayList;
  40 import java.util.Arrays;
  41 import java.util.EnumSet;
  42 import java.util.Iterator;
  43 import java.util.NoSuchElementException;
  44 import java.util.Objects;
  45 import java.util.concurrent.atomic.AtomicInteger;
  46 
  47 import jdk.internal.vm.compiler.collections.EconomicMap;
  48 import jdk.internal.vm.compiler.collections.Equivalence;
  49 import org.graalvm.compiler.core.common.FieldIntrospection;
  50 import org.graalvm.compiler.core.common.Fields;
  51 import org.graalvm.compiler.core.common.FieldsScanner;
  52 import org.graalvm.compiler.debug.CounterKey;
  53 import org.graalvm.compiler.debug.DebugCloseable;
  54 import org.graalvm.compiler.debug.DebugContext;
  55 import org.graalvm.compiler.debug.GraalError;
  56 import org.graalvm.compiler.debug.TTY;
  57 import org.graalvm.compiler.debug.TimerKey;
  58 import org.graalvm.compiler.graph.Edges.Type;
  59 import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
  60 import org.graalvm.compiler.graph.Node.EdgeVisitor;
  61 import org.graalvm.compiler.graph.Node.Input;
  62 import org.graalvm.compiler.graph.Node.OptionalInput;
  63 import org.graalvm.compiler.graph.Node.Successor;
  64 import org.graalvm.compiler.graph.iterators.NodeIterable;
  65 import org.graalvm.compiler.graph.spi.Canonicalizable;
  66 import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;
  67 import org.graalvm.compiler.graph.spi.Simplifiable;
  68 import org.graalvm.compiler.nodeinfo.InputType;
  69 import org.graalvm.compiler.nodeinfo.NodeCycles;
  70 import org.graalvm.compiler.nodeinfo.NodeInfo;
  71 import org.graalvm.compiler.nodeinfo.NodeSize;
  72 import org.graalvm.compiler.nodeinfo.Verbosity;
  73 
  74 import sun.misc.Unsafe;
  75 
  76 /**
  77  * Metadata for every {@link Node} type. The metadata includes:
  78  * &lt;ul&gt;
  79  * &lt;li&gt;The offsets of fields annotated with {@link Input} and {@link Successor} as well as methods
  80  * for iterating over such fields.&lt;/li&gt;
  81  * &lt;li&gt;The identifier for an {@link IterableNodeType} class.&lt;/li&gt;
  82  * &lt;/ul&gt;
  83  */
  84 public final class NodeClass&lt;T&gt; extends FieldIntrospection&lt;T&gt; {
  85 
  86     private static final Unsafe UNSAFE = getUnsafe();
  87     // Timers for creation of a NodeClass instance
  88     private static final TimerKey Init_FieldScanning = DebugContext.timer(&quot;NodeClass.Init.FieldScanning&quot;);
  89     private static final TimerKey Init_FieldScanningInner = DebugContext.timer(&quot;NodeClass.Init.FieldScanning.Inner&quot;);
  90     private static final TimerKey Init_AnnotationParsing = DebugContext.timer(&quot;NodeClass.Init.AnnotationParsing&quot;);
  91     private static final TimerKey Init_Edges = DebugContext.timer(&quot;NodeClass.Init.Edges&quot;);
  92     private static final TimerKey Init_Data = DebugContext.timer(&quot;NodeClass.Init.Data&quot;);
  93     private static final TimerKey Init_AllowedUsages = DebugContext.timer(&quot;NodeClass.Init.AllowedUsages&quot;);
  94     private static final TimerKey Init_IterableIds = DebugContext.timer(&quot;NodeClass.Init.IterableIds&quot;);
  95 
  96     public static final long MAX_EDGES = 8;
  97     public static final long MAX_LIST_EDGES = 6;
  98     public static final long OFFSET_MASK = 0xFC;
  99     public static final long LIST_MASK = 0x01;
 100     public static final long NEXT_EDGE = 0x08;
 101 
 102     @SuppressWarnings(&quot;try&quot;)
 103     private static &lt;T extends Annotation&gt; T getAnnotationTimed(AnnotatedElement e, Class&lt;T&gt; annotationClass, DebugContext debug) {
 104         try (DebugCloseable s = Init_AnnotationParsing.start(debug)) {
 105             return e.getAnnotation(annotationClass);
 106         }
 107     }
 108 
 109     /**
 110      * Gets the {@link NodeClass} associated with a given {@link Class}.
 111      */
 112     public static &lt;T&gt; NodeClass&lt;T&gt; create(Class&lt;T&gt; c) {
 113         assert getUnchecked(c) == null;
 114         Class&lt;? super T&gt; superclass = c.getSuperclass();
 115         NodeClass&lt;? super T&gt; nodeSuperclass = null;
 116         if (superclass != NODE_CLASS) {
 117             nodeSuperclass = get(superclass);
 118         }
 119         return new NodeClass&lt;&gt;(c, nodeSuperclass);
 120     }
 121 
 122     @SuppressWarnings(&quot;unchecked&quot;)
 123     private static &lt;T&gt; NodeClass&lt;T&gt; getUnchecked(Class&lt;T&gt; clazz) {
 124         try {
 125             Field field = clazz.getDeclaredField(&quot;TYPE&quot;);
 126             field.setAccessible(true);
 127             return (NodeClass&lt;T&gt;) field.get(null);
 128         } catch (IllegalArgumentException | IllegalAccessException | NoSuchFieldException | SecurityException e) {
 129             throw new RuntimeException(&quot;Could not load Graal NodeClass TYPE field for &quot; + clazz, e);
 130         }
 131     }
 132 
 133     public static &lt;T&gt; NodeClass&lt;T&gt; get(Class&lt;T&gt; clazz) {
 134         int numTries = 0;
 135         while (true) {
 136             boolean shouldBeInitializedBefore = UNSAFE.shouldBeInitialized(clazz);
 137 
 138             NodeClass&lt;T&gt; result = getUnchecked(clazz);
 139             if (result != null || clazz == NODE_CLASS) {
 140                 return result;
 141             }
 142 
 143             /*
 144              * GR-9537: We observed a transient problem with TYPE fields being null. Retry a couple
 145              * of times and print something to the log so that we can gather more diagnostic
 146              * information without failing gates.
 147              */
 148             numTries++;
 149             boolean shouldBeInitializedAfter = UNSAFE.shouldBeInitialized(clazz);
 150             String msg = &quot;GR-9537 Reflective field access of TYPE field returned null. This is probably a bug in HotSpot class initialization. &quot; +
 151                             &quot; clazz: &quot; + clazz.getTypeName() + &quot;, numTries: &quot; + numTries +
 152                             &quot;, shouldBeInitializedBefore: &quot; + shouldBeInitializedBefore + &quot;, shouldBeInitializedAfter: &quot; + shouldBeInitializedAfter;
 153             if (numTries &lt;= 100) {
 154                 TTY.println(msg);
 155                 UNSAFE.ensureClassInitialized(clazz);
 156             } else {
 157                 throw GraalError.shouldNotReachHere(msg);
 158             }
 159             return result;
 160         }
 161     }
 162 
 163     private static final Class&lt;?&gt; NODE_CLASS = Node.class;
 164     private static final Class&lt;?&gt; INPUT_LIST_CLASS = NodeInputList.class;
 165     private static final Class&lt;?&gt; SUCCESSOR_LIST_CLASS = NodeSuccessorList.class;
 166 
 167     private static AtomicInteger nextIterableId = new AtomicInteger();
 168     private static AtomicInteger nextLeafId = new AtomicInteger();
 169 
 170     private final InputEdges inputs;
 171     private final SuccessorEdges successors;
 172     private final NodeClass&lt;? super T&gt; superNodeClass;
 173 
 174     private final boolean canGVN;
 175     private final int startGVNNumber;
 176     private final String nameTemplate;
 177     private final int iterableId;
 178     private final EnumSet&lt;InputType&gt; allowedUsageTypes;
 179     private int[] iterableIds;
 180     private final long inputsIteration;
 181     private final long successorIteration;
 182 
 183     private static final CounterKey ITERABLE_NODE_TYPES = DebugContext.counter(&quot;IterableNodeTypes&quot;);
 184 
 185     /**
 186      * Determines if this node type implements {@link Canonicalizable}.
 187      */
 188     private final boolean isCanonicalizable;
 189 
 190     /**
 191      * Determines if this node type implements {@link BinaryCommutative}.
 192      */
 193     private final boolean isCommutative;
 194 
 195     /**
 196      * Determines if this node type implements {@link Simplifiable}.
 197      */
 198     private final boolean isSimplifiable;
 199     private final boolean isLeafNode;
 200 
 201     private final int leafId;
 202 
 203     public NodeClass(Class&lt;T&gt; clazz, NodeClass&lt;? super T&gt; superNodeClass) {
 204         this(clazz, superNodeClass, new FieldsScanner.DefaultCalcOffset(), null, 0);
 205     }
 206 
 207     @SuppressWarnings(&quot;try&quot;)
 208     public NodeClass(Class&lt;T&gt; clazz, NodeClass&lt;? super T&gt; superNodeClass, FieldsScanner.CalcOffset calcOffset, int[] presetIterableIds, int presetIterableId) {
 209         super(clazz);
 210         DebugContext debug = DebugContext.forCurrentThread();
 211         this.superNodeClass = superNodeClass;
 212         assert NODE_CLASS.isAssignableFrom(clazz);
 213 
 214         this.isCanonicalizable = Canonicalizable.class.isAssignableFrom(clazz);
 215         this.isCommutative = BinaryCommutative.class.isAssignableFrom(clazz);
 216         if (Canonicalizable.Unary.class.isAssignableFrom(clazz) || Canonicalizable.Binary.class.isAssignableFrom(clazz)) {
 217             assert Canonicalizable.Unary.class.isAssignableFrom(clazz) ^ Canonicalizable.Binary.class.isAssignableFrom(clazz) : clazz + &quot; should implement either Unary or Binary, not both&quot;;
 218         }
 219 
 220         this.isSimplifiable = Simplifiable.class.isAssignableFrom(clazz);
 221 
 222         NodeFieldsScanner fs = new NodeFieldsScanner(calcOffset, superNodeClass, debug);
 223         try (DebugCloseable t = Init_FieldScanning.start(debug)) {
 224             fs.scan(clazz, clazz.getSuperclass(), false);
 225         }
 226 
 227         try (DebugCloseable t1 = Init_Edges.start(debug)) {
 228             successors = new SuccessorEdges(fs.directSuccessors, fs.successors);
 229             successorIteration = computeIterationMask(successors.type(), successors.getDirectCount(), successors.getOffsets());
 230             inputs = new InputEdges(fs.directInputs, fs.inputs);
 231             inputsIteration = computeIterationMask(inputs.type(), inputs.getDirectCount(), inputs.getOffsets());
 232         }
 233         try (DebugCloseable t1 = Init_Data.start(debug)) {
 234             data = new Fields(fs.data);
 235         }
 236 
 237         isLeafNode = inputs.getCount() + successors.getCount() == 0;
 238         if (isLeafNode) {
 239             this.leafId = nextLeafId.getAndIncrement();
 240         } else {
 241             this.leafId = -1;
 242         }
 243 
 244         canGVN = Node.ValueNumberable.class.isAssignableFrom(clazz);
 245         startGVNNumber = clazz.getName().hashCode();
 246 
 247         NodeInfo info = getAnnotationTimed(clazz, NodeInfo.class, debug);
 248         assert info != null : &quot;Missing NodeInfo annotation on &quot; + clazz;
 249         if (!info.nameTemplate().isEmpty()) {
 250             this.nameTemplate = info.nameTemplate();
 251         } else if (!info.shortName().isEmpty()) {
 252             this.nameTemplate = info.shortName();
 253         } else {
 254             this.nameTemplate = &quot;&quot;;
 255         }
 256 
 257         try (DebugCloseable t1 = Init_AllowedUsages.start(debug)) {
 258             allowedUsageTypes = superNodeClass == null ? EnumSet.noneOf(InputType.class) : superNodeClass.allowedUsageTypes.clone();
 259             allowedUsageTypes.addAll(Arrays.asList(info.allowedUsageTypes()));
 260         }
 261 
 262         if (presetIterableIds != null) {
 263             this.iterableIds = presetIterableIds;
 264             this.iterableId = presetIterableId;
 265         } else if (IterableNodeType.class.isAssignableFrom(clazz)) {
 266             ITERABLE_NODE_TYPES.increment(debug);
 267             try (DebugCloseable t1 = Init_IterableIds.start(debug)) {
 268                 this.iterableId = nextIterableId.getAndIncrement();
 269 
 270                 NodeClass&lt;?&gt; snc = superNodeClass;
 271                 while (snc != null &amp;&amp; IterableNodeType.class.isAssignableFrom(snc.getClazz())) {
 272                     snc.addIterableId(iterableId);
 273                     snc = snc.superNodeClass;
 274                 }
 275 
 276                 this.iterableIds = new int[]{iterableId};
 277             }
 278         } else {
 279             this.iterableId = Node.NOT_ITERABLE;
 280             this.iterableIds = null;
 281         }
 282         assert verifyIterableIds();
 283 
 284         try (DebugContext.Scope scope = debug.scope(&quot;NodeCosts&quot;)) {
 285             /*
 286              * Note: We do not check for the existence of the node cost annotations during
 287              * construction as not every node needs to have them set. However if costs are queried,
 288              * after the construction of the node class, they must be properly set. This is
 289              * important as we can not trust our cost model if there are unspecified nodes. Nodes
 290              * that do not need cost annotations are e.g. abstractions like FixedNode or
 291              * FloatingNode or ValueNode. Sub classes where costs are not specified will ask the
 292              * superclass for their costs during node class initialization. Therefore getters for
 293              * cycles and size can omit verification during creation.
 294              */
 295             NodeCycles c = info.cycles();
 296             if (c == NodeCycles.CYCLES_UNSET) {
 297                 cycles = superNodeClass != null ? superNodeClass.cycles : NodeCycles.CYCLES_UNSET;
 298             } else {
 299                 cycles = c;
 300             }
 301             assert cycles != null;
 302             NodeSize s = info.size();
 303             if (s == NodeSize.SIZE_UNSET) {
 304                 size = superNodeClass != null ? superNodeClass.size : NodeSize.SIZE_UNSET;
 305             } else {
 306                 size = s;
 307             }
 308             assert size != null;
 309             debug.log(&quot;Node cost for node of type __| %s |_, cycles:%s,size:%s&quot;, clazz, cycles, size);
 310         }
 311     }
 312 
 313     private final NodeCycles cycles;
 314     private final NodeSize size;
 315 
 316     public NodeCycles cycles() {
 317         return cycles;
 318     }
 319 
 320     public NodeSize size() {
 321         return size;
 322     }
 323 
 324     public static long computeIterationMask(Type type, int directCount, long[] offsets) {
 325         long mask = 0;
 326         if (offsets.length &gt; NodeClass.MAX_EDGES) {
 327             throw new GraalError(&quot;Exceeded maximum of %d edges (%s)&quot;, NodeClass.MAX_EDGES, type);
 328         }
 329         if (offsets.length - directCount &gt; NodeClass.MAX_LIST_EDGES) {
 330             throw new GraalError(&quot;Exceeded maximum of %d list edges (%s)&quot;, NodeClass.MAX_LIST_EDGES, type);
 331         }
 332 
 333         for (int i = offsets.length - 1; i &gt;= 0; i--) {
 334             long offset = offsets[i];
 335             assert ((offset &amp; 0xFF) == offset) : &quot;field offset too large!&quot;;
 336             mask &lt;&lt;= NodeClass.NEXT_EDGE;
 337             mask |= offset;
 338             if (i &gt;= directCount) {
 339                 mask |= 0x3;
 340             }
 341         }
 342         return mask;
 343     }
 344 
 345     private synchronized void addIterableId(int newIterableId) {
 346         assert !containsId(newIterableId, iterableIds);
 347         int[] copy = Arrays.copyOf(iterableIds, iterableIds.length + 1);
 348         copy[iterableIds.length] = newIterableId;
 349         iterableIds = copy;
 350     }
 351 
 352     private boolean verifyIterableIds() {
 353         NodeClass&lt;?&gt; snc = superNodeClass;
 354         while (snc != null &amp;&amp; IterableNodeType.class.isAssignableFrom(snc.getClazz())) {
 355             assert containsId(iterableId, snc.iterableIds);
 356             snc = snc.superNodeClass;
 357         }
 358         return true;
 359     }
 360 
 361     private static boolean containsId(int iterableId, int[] iterableIds) {
 362         for (int i : iterableIds) {
 363             if (i == iterableId) {
 364                 return true;
 365             }
 366         }
 367         return false;
 368     }
 369 
 370     private String shortName;
 371 
 372     public String shortName() {
 373         if (shortName == null) {
 374             NodeInfo info = getClazz().getAnnotation(NodeInfo.class);
 375             if (!info.shortName().isEmpty()) {
 376                 shortName = info.shortName();
 377             } else {
 378                 String localShortName = getClazz().getSimpleName();
 379                 if (localShortName.endsWith(&quot;Node&quot;) &amp;&amp; !localShortName.equals(&quot;StartNode&quot;) &amp;&amp; !localShortName.equals(&quot;EndNode&quot;)) {
 380                     shortName = localShortName.substring(0, localShortName.length() - 4);
 381                 } else {
 382                     shortName = localShortName;
 383                 }
 384             }
 385         }
 386         return shortName;
 387     }
 388 
 389     @Override
 390     public Fields[] getAllFields() {
 391         return new Fields[]{data, inputs, successors};
 392     }
 393 
 394     int[] iterableIds() {
 395         return iterableIds;
 396     }
 397 
 398     public int iterableId() {
 399         return iterableId;
 400     }
 401 
 402     public boolean valueNumberable() {
 403         return canGVN;
 404     }
 405 
 406     /**
 407      * Determines if this node type implements {@link Canonicalizable}.
 408      */
 409     public boolean isCanonicalizable() {
 410         return isCanonicalizable;
 411     }
 412 
 413     /**
 414      * Determines if this node type implements {@link BinaryCommutative}.
 415      */
 416     public boolean isCommutative() {
 417         return isCommutative;
 418     }
 419 
 420     /**
 421      * Determines if this node type implements {@link Simplifiable}.
 422      */
 423     public boolean isSimplifiable() {
 424         return isSimplifiable;
 425     }
 426 
 427     static int allocatedNodeIterabledIds() {
 428         return nextIterableId.get();
 429     }
 430 
 431     public EnumSet&lt;InputType&gt; getAllowedUsageTypes() {
 432         return allowedUsageTypes;
 433     }
 434 
 435     /**
 436      * Describes a field representing an input or successor edge in a node.
 437      */
 438     protected static class EdgeInfo extends FieldsScanner.FieldInfo {
 439 
 440         public EdgeInfo(long offset, String name, Class&lt;?&gt; type, Class&lt;?&gt; declaringClass) {
 441             super(offset, name, type, declaringClass);
 442         }
 443 
 444         /**
 445          * Sorts non-list edges before list edges.
 446          */
 447         @Override
 448         public int compareTo(FieldsScanner.FieldInfo o) {
 449             if (NodeList.class.isAssignableFrom(o.type)) {
 450                 if (!NodeList.class.isAssignableFrom(type)) {
 451                     return -1;
 452                 }
 453             } else {
 454                 if (NodeList.class.isAssignableFrom(type)) {
 455                     return 1;
 456                 }
 457             }
 458             return super.compareTo(o);
 459         }
 460     }
 461 
 462     /**
 463      * Describes a field representing an {@linkplain Type#Inputs input} edge in a node.
 464      */
 465     protected static class InputInfo extends EdgeInfo {
 466         final InputType inputType;
 467         final boolean optional;
 468 
 469         public InputInfo(long offset, String name, Class&lt;?&gt; type, Class&lt;?&gt; declaringClass, InputType inputType, boolean optional) {
 470             super(offset, name, type, declaringClass);
 471             this.inputType = inputType;
 472             this.optional = optional;
 473         }
 474 
 475         @Override
 476         public String toString() {
 477             return super.toString() + &quot;{inputType=&quot; + inputType + &quot;, optional=&quot; + optional + &quot;}&quot;;
 478         }
 479     }
 480 
 481     protected static class NodeFieldsScanner extends FieldsScanner {
 482 
 483         public final ArrayList&lt;InputInfo&gt; inputs = new ArrayList&lt;&gt;();
 484         public final ArrayList&lt;EdgeInfo&gt; successors = new ArrayList&lt;&gt;();
 485         int directInputs;
 486         int directSuccessors;
 487         final DebugContext debug;
 488 
 489         protected NodeFieldsScanner(FieldsScanner.CalcOffset calc, NodeClass&lt;?&gt; superNodeClass, DebugContext debug) {
 490             super(calc);
 491             this.debug = debug;
 492             if (superNodeClass != null) {
 493                 translateInto(superNodeClass.inputs, inputs);
 494                 translateInto(superNodeClass.successors, successors);
 495                 translateInto(superNodeClass.data, data);
 496                 directInputs = superNodeClass.inputs.getDirectCount();
 497                 directSuccessors = superNodeClass.successors.getDirectCount();
 498             }
 499         }
 500 
 501         @SuppressWarnings(&quot;try&quot;)
 502         @Override
 503         protected void scanField(Field field, long offset) {
 504             Input inputAnnotation = getAnnotationTimed(field, Node.Input.class, debug);
 505             OptionalInput optionalInputAnnotation = getAnnotationTimed(field, Node.OptionalInput.class, debug);
 506             Successor successorAnnotation = getAnnotationTimed(field, Successor.class, debug);
 507             try (DebugCloseable s = Init_FieldScanningInner.start(debug)) {
 508                 Class&lt;?&gt; type = field.getType();
 509                 int modifiers = field.getModifiers();
 510 
 511                 if (inputAnnotation != null || optionalInputAnnotation != null) {
 512                     assert successorAnnotation == null : &quot;field cannot be both input and successor&quot;;
 513                     if (INPUT_LIST_CLASS.isAssignableFrom(type)) {
 514                         // NodeInputList fields should not be final since they are
 515                         // written (via Unsafe) in clearInputs()
 516                         GraalError.guarantee(!Modifier.isFinal(modifiers), &quot;NodeInputList input field %s should not be final&quot;, field);
 517                         GraalError.guarantee(!Modifier.isPublic(modifiers), &quot;NodeInputList input field %s should not be public&quot;, field);
 518                     } else {
 519                         GraalError.guarantee(NODE_CLASS.isAssignableFrom(type) || type.isInterface(), &quot;invalid input type: %s&quot;, type);
 520                         GraalError.guarantee(!Modifier.isFinal(modifiers), &quot;Node input field %s should not be final&quot;, field);
 521                         directInputs++;
 522                     }
 523                     InputType inputType;
 524                     if (inputAnnotation != null) {
 525                         assert optionalInputAnnotation == null : &quot;inputs can either be optional or non-optional&quot;;
 526                         inputType = inputAnnotation.value();
 527                     } else {
 528                         inputType = optionalInputAnnotation.value();
 529                     }
 530                     inputs.add(new InputInfo(offset, field.getName(), type, field.getDeclaringClass(), inputType, field.isAnnotationPresent(Node.OptionalInput.class)));
 531                 } else if (successorAnnotation != null) {
 532                     if (SUCCESSOR_LIST_CLASS.isAssignableFrom(type)) {
 533                         // NodeSuccessorList fields should not be final since they are
 534                         // written (via Unsafe) in clearSuccessors()
 535                         GraalError.guarantee(!Modifier.isFinal(modifiers), &quot;NodeSuccessorList successor field % should not be final&quot;, field);
 536                         GraalError.guarantee(!Modifier.isPublic(modifiers), &quot;NodeSuccessorList successor field %s should not be public&quot;, field);
 537                     } else {
 538                         GraalError.guarantee(NODE_CLASS.isAssignableFrom(type), &quot;invalid successor type: %s&quot;, type);
 539                         GraalError.guarantee(!Modifier.isFinal(modifiers), &quot;Node successor field %s should not be final&quot;, field);
 540                         directSuccessors++;
 541                     }
 542                     successors.add(new EdgeInfo(offset, field.getName(), type, field.getDeclaringClass()));
 543                 } else {
 544                     GraalError.guarantee(!NODE_CLASS.isAssignableFrom(type) || field.getName().equals(&quot;Null&quot;), &quot;suspicious node field: %s&quot;, field);
 545                     GraalError.guarantee(!INPUT_LIST_CLASS.isAssignableFrom(type), &quot;suspicious node input list field: %s&quot;, field);
 546                     GraalError.guarantee(!SUCCESSOR_LIST_CLASS.isAssignableFrom(type), &quot;suspicious node successor list field: %s&quot;, field);
 547                     super.scanField(field, offset);
 548                 }
 549             }
 550         }
 551     }
 552 
 553     @Override
 554     public String toString() {
 555         StringBuilder str = new StringBuilder();
 556         str.append(&quot;NodeClass &quot;).append(getClazz().getSimpleName()).append(&quot; [&quot;);
 557         inputs.appendFields(str);
 558         str.append(&quot;] [&quot;);
 559         successors.appendFields(str);
 560         str.append(&quot;] [&quot;);
 561         data.appendFields(str);
 562         str.append(&quot;]&quot;);
 563         return str.toString();
 564     }
 565 
 566     private static int deepHashCode0(Object o) {
 567         if (o == null) {
 568             return 0;
 569         } else if (!o.getClass().isArray()) {
 570             return o.hashCode();
 571         } else if (o instanceof Object[]) {
 572             return Arrays.deepHashCode((Object[]) o);
 573         } else if (o instanceof byte[]) {
 574             return Arrays.hashCode((byte[]) o);
 575         } else if (o instanceof short[]) {
 576             return Arrays.hashCode((short[]) o);
 577         } else if (o instanceof int[]) {
 578             return Arrays.hashCode((int[]) o);
 579         } else if (o instanceof long[]) {
 580             return Arrays.hashCode((long[]) o);
 581         } else if (o instanceof char[]) {
 582             return Arrays.hashCode((char[]) o);
 583         } else if (o instanceof float[]) {
 584             return Arrays.hashCode((float[]) o);
 585         } else if (o instanceof double[]) {
 586             return Arrays.hashCode((double[]) o);
 587         } else if (o instanceof boolean[]) {
 588             return Arrays.hashCode((boolean[]) o);
 589         } else {
 590             throw shouldNotReachHere();
 591         }
 592     }
 593 
 594     public int valueNumber(Node n) {
 595         int number = 0;
 596         if (canGVN) {
 597             number = startGVNNumber;
 598             for (int i = 0; i &lt; data.getCount(); ++i) {
 599                 Class&lt;?&gt; type = data.getType(i);
 600                 if (type.isPrimitive()) {
 601                     if (type == Integer.TYPE) {
 602                         int intValue = data.getInt(n, i);
 603                         number += intValue;
 604                     } else if (type == Long.TYPE) {
 605                         long longValue = data.getLong(n, i);
 606                         number += longValue ^ (longValue &gt;&gt;&gt; 32);
 607                     } else if (type == Boolean.TYPE) {
 608                         boolean booleanValue = data.getBoolean(n, i);
 609                         if (booleanValue) {
 610                             number += 7;
 611                         }
 612                     } else if (type == Float.TYPE) {
 613                         float floatValue = data.getFloat(n, i);
 614                         number += Float.floatToRawIntBits(floatValue);
 615                     } else if (type == Double.TYPE) {
 616                         double doubleValue = data.getDouble(n, i);
 617                         long longValue = Double.doubleToRawLongBits(doubleValue);
 618                         number += longValue ^ (longValue &gt;&gt;&gt; 32);
 619                     } else if (type == Short.TYPE) {
 620                         short shortValue = data.getShort(n, i);
 621                         number += shortValue;
 622                     } else if (type == Character.TYPE) {
 623                         char charValue = data.getChar(n, i);
 624                         number += charValue;
 625                     } else if (type == Byte.TYPE) {
 626                         byte byteValue = data.getByte(n, i);
 627                         number += byteValue;
 628                     } else {
 629                         assert false : &quot;unhandled property type: &quot; + type;
 630                     }
 631                 } else {
 632                     Object o = data.getObject(n, i);
 633                     number += deepHashCode0(o);
 634                 }
 635                 number *= 13;
 636             }
 637         }
 638         return number;
 639     }
 640 
 641     private static boolean deepEquals0(Object e1, Object e2) {
 642         if (e1 == e2) {
 643             return true;
 644         } else if (e1 == null || e2 == null) {
 645             return false;
 646         } else if (!e1.getClass().isArray() || e1.getClass() != e2.getClass()) {
 647             return e1.equals(e2);
 648         } else if (e1 instanceof Object[] &amp;&amp; e2 instanceof Object[]) {
 649             return deepEquals((Object[]) e1, (Object[]) e2);
 650         } else if (e1 instanceof int[]) {
 651             return Arrays.equals((int[]) e1, (int[]) e2);
 652         } else if (e1 instanceof long[]) {
 653             return Arrays.equals((long[]) e1, (long[]) e2);
 654         } else if (e1 instanceof byte[]) {
 655             return Arrays.equals((byte[]) e1, (byte[]) e2);
 656         } else if (e1 instanceof char[]) {
 657             return Arrays.equals((char[]) e1, (char[]) e2);
 658         } else if (e1 instanceof short[]) {
 659             return Arrays.equals((short[]) e1, (short[]) e2);
 660         } else if (e1 instanceof float[]) {
 661             return Arrays.equals((float[]) e1, (float[]) e2);
 662         } else if (e1 instanceof double[]) {
 663             return Arrays.equals((double[]) e1, (double[]) e2);
 664         } else if (e1 instanceof boolean[]) {
 665             return Arrays.equals((boolean[]) e1, (boolean[]) e2);
 666         } else {
 667             throw shouldNotReachHere();
 668         }
 669     }
 670 
 671     private static boolean deepEquals(Object[] a1, Object[] a2) {
 672         int length = a1.length;
 673         if (a2.length != length) {
 674             return false;
 675         }
 676 
 677         for (int i = 0; i &lt; length; i++) {
 678             if (!deepEquals0(a1[i], a2[i])) {
 679                 return false;
 680             }
 681         }
 682         return true;
 683     }
 684 
 685     public boolean dataEquals(Node a, Node b) {
 686         assert a.getClass() == b.getClass();
 687         for (int i = 0; i &lt; data.getCount(); ++i) {
 688             Class&lt;?&gt; type = data.getType(i);
 689             if (type.isPrimitive()) {
 690                 if (type == Integer.TYPE) {
 691                     int aInt = data.getInt(a, i);
 692                     int bInt = data.getInt(b, i);
 693                     if (aInt != bInt) {
 694                         return false;
 695                     }
 696                 } else if (type == Boolean.TYPE) {
 697                     boolean aBoolean = data.getBoolean(a, i);
 698                     boolean bBoolean = data.getBoolean(b, i);
 699                     if (aBoolean != bBoolean) {
 700                         return false;
 701                     }
 702                 } else if (type == Long.TYPE) {
 703                     long aLong = data.getLong(a, i);
 704                     long bLong = data.getLong(b, i);
 705                     if (aLong != bLong) {
 706                         return false;
 707                     }
 708                 } else if (type == Float.TYPE) {
 709                     float aFloat = data.getFloat(a, i);
 710                     float bFloat = data.getFloat(b, i);
 711                     if (aFloat != bFloat) {
 712                         return false;
 713                     }
 714                 } else if (type == Double.TYPE) {
 715                     double aDouble = data.getDouble(a, i);
 716                     double bDouble = data.getDouble(b, i);
 717                     if (aDouble != bDouble) {
 718                         return false;
 719                     }
 720                 } else if (type == Short.TYPE) {
 721                     short aShort = data.getShort(a, i);
 722                     short bShort = data.getShort(b, i);
 723                     if (aShort != bShort) {
 724                         return false;
 725                     }
 726                 } else if (type == Character.TYPE) {
 727                     char aChar = data.getChar(a, i);
 728                     char bChar = data.getChar(b, i);
 729                     if (aChar != bChar) {
 730                         return false;
 731                     }
 732                 } else if (type == Byte.TYPE) {
 733                     byte aByte = data.getByte(a, i);
 734                     byte bByte = data.getByte(b, i);
 735                     if (aByte != bByte) {
 736                         return false;
 737                     }
 738                 } else {
 739                     assert false : &quot;unhandled type: &quot; + type;
 740                 }
 741             } else {
 742                 Object objectA = data.getObject(a, i);
 743                 Object objectB = data.getObject(b, i);
 744                 assert !isLambda(objectA) || !isLambda(objectB) : &quot;lambdas are not permitted in fields of &quot; + this.toString();
 745                 if (objectA != objectB) {
 746                     if (objectA != null &amp;&amp; objectB != null) {
 747                         if (!deepEquals0(objectA, objectB)) {
 748                             return false;
 749                         }
 750                     } else {
 751                         return false;
 752                     }
 753                 }
 754             }
 755         }
 756         return true;
 757     }
 758 
 759     private static boolean isLambda(Object obj) {
 760         // This needs to be consistent with InnerClassLambdaMetafactory constructor.
 761         return obj != null &amp;&amp; obj.getClass().getSimpleName().contains(&quot;$$Lambda$&quot;);
 762     }
 763 
 764     public boolean isValid(Position pos, NodeClass&lt;?&gt; from, Edges fromEdges) {
 765         if (this == from) {
 766             return true;
 767         }
 768         Edges toEdges = getEdges(fromEdges.type());
 769         if (pos.getIndex() &gt;= toEdges.getCount()) {
 770             return false;
 771         }
 772         if (pos.getIndex() &gt;= fromEdges.getCount()) {
 773             return false;
 774         }
 775         return toEdges.isSame(fromEdges, pos.getIndex());
 776     }
 777 
 778     static void updateEdgesInPlace(Node node, InplaceUpdateClosure duplicationReplacement, Edges edges) {
 779         int index = 0;
 780         Type curType = edges.type();
 781         int directCount = edges.getDirectCount();
 782         final long[] curOffsets = edges.getOffsets();
 783         while (index &lt; directCount) {
 784             Node edge = Edges.getNode(node, curOffsets, index);
 785             if (edge != null) {
 786                 Node newEdge = duplicationReplacement.replacement(edge, curType);
 787                 if (curType == Edges.Type.Inputs) {
 788                     node.updateUsages(null, newEdge);
 789                 } else {
 790                     node.updatePredecessor(null, newEdge);
 791                 }
 792                 edges.initializeNode(node, index, newEdge);
 793             }
 794             index++;
 795         }
 796 
 797         while (index &lt; edges.getCount()) {
 798             NodeList&lt;Node&gt; list = Edges.getNodeList(node, curOffsets, index);
 799             if (list != null) {
 800                 edges.initializeList(node, index, updateEdgeListCopy(node, list, duplicationReplacement, curType));
 801             }
 802             index++;
 803         }
 804     }
 805 
 806     void updateInputSuccInPlace(Node node, InplaceUpdateClosure duplicationReplacement) {
 807         updateEdgesInPlace(node, duplicationReplacement, inputs);
 808         updateEdgesInPlace(node, duplicationReplacement, successors);
 809     }
 810 
 811     private static NodeList&lt;Node&gt; updateEdgeListCopy(Node node, NodeList&lt;Node&gt; list, InplaceUpdateClosure duplicationReplacement, Edges.Type type) {
 812         NodeList&lt;Node&gt; result = type == Edges.Type.Inputs ? new NodeInputList&lt;&gt;(node, list.size()) : new NodeSuccessorList&lt;&gt;(node, list.size());
 813 
 814         for (int i = 0; i &lt; list.count(); ++i) {
 815             Node oldNode = list.get(i);
 816             if (oldNode != null) {
 817                 Node newNode = duplicationReplacement.replacement(oldNode, type);
 818                 result.set(i, newNode);
 819             }
 820         }
 821         return result;
 822     }
 823 
 824     /**
 825      * Gets the input or successor edges defined by this node class.
 826      */
 827     public Edges getEdges(Edges.Type type) {
 828         return type == Edges.Type.Inputs ? inputs : successors;
 829     }
 830 
 831     public Edges getInputEdges() {
 832         return inputs;
 833     }
 834 
 835     public Edges getSuccessorEdges() {
 836         return successors;
 837     }
 838 
 839     /**
 840      * Returns a newly allocated node for which no subclass-specific constructor has been called.
 841      */
 842     @SuppressWarnings(&quot;unchecked&quot;)
 843     public Node allocateInstance() {
 844         try {
 845             Node node = (Node) UNSAFE.allocateInstance(getJavaClass());
 846             node.init((NodeClass&lt;? extends Node&gt;) this);
 847             return node;
 848         } catch (InstantiationException ex) {
 849             throw shouldNotReachHere(ex);
 850         }
 851     }
 852 
 853     public Class&lt;T&gt; getJavaClass() {
 854         return getClazz();
 855     }
 856 
 857     /**
 858      * The template used to build the {@link Verbosity#Name} version. Variable parts are specified
 859      * using &amp;#123;i#inputName&amp;#125; or &amp;#123;p#propertyName&amp;#125;. If no
 860      * {@link NodeInfo#nameTemplate() template} is specified, it uses {@link NodeInfo#shortName()}.
 861      * If none of the two is specified, it returns an empty string.
 862      */
 863     public String getNameTemplate() {
 864         return nameTemplate;
 865     }
 866 
 867     interface InplaceUpdateClosure {
 868 
 869         Node replacement(Node node, Edges.Type type);
 870     }
 871 
 872     static EconomicMap&lt;Node, Node&gt; addGraphDuplicate(final Graph graph, final Graph oldGraph, int estimatedNodeCount, Iterable&lt;? extends Node&gt; nodes, final DuplicationReplacement replacements) {
 873         final EconomicMap&lt;Node, Node&gt; newNodes;
 874         int denseThreshold = oldGraph.getNodeCount() + oldGraph.getNodesDeletedSinceLastCompression() &gt;&gt; 4;
 875         if (estimatedNodeCount &gt; denseThreshold) {
 876             // Use dense map
 877             newNodes = new NodeMap&lt;&gt;(oldGraph);
 878         } else {
 879             // Use sparse map
 880             newNodes = EconomicMap.create(Equivalence.IDENTITY);
 881         }
 882         createNodeDuplicates(graph, nodes, replacements, newNodes);
 883 
 884         InplaceUpdateClosure replacementClosure = new InplaceUpdateClosure() {
 885 
 886             @Override
 887             public Node replacement(Node node, Edges.Type type) {
 888                 Node target = newNodes.get(node);
 889                 if (target == null) {
 890                     Node replacement = node;
 891                     if (replacements != null) {
 892                         replacement = replacements.replacement(node);
 893                     }
 894                     if (replacement != node) {
 895                         target = replacement;
 896                     } else if (node.graph() == graph &amp;&amp; type == Edges.Type.Inputs) {
 897                         // patch to the outer world
 898                         target = node;
 899                     }
 900 
 901                 }
 902                 return target;
 903             }
 904 
 905         };
 906 
 907         // re-wire inputs
 908         for (Node oldNode : nodes) {
 909             Node node = newNodes.get(oldNode);
 910             NodeClass&lt;?&gt; nodeClass = node.getNodeClass();
 911             if (replacements == null || replacements.replacement(oldNode) == oldNode) {
 912                 nodeClass.updateInputSuccInPlace(node, replacementClosure);
 913             } else {
 914                 transferEdgesDifferentNodeClass(graph, replacements, newNodes, oldNode, node);
 915             }
 916         }
 917 
 918         return newNodes;
 919     }
 920 
 921     private static void createNodeDuplicates(final Graph graph, Iterable&lt;? extends Node&gt; nodes, final DuplicationReplacement replacements, final EconomicMap&lt;Node, Node&gt; newNodes) {
 922         for (Node node : nodes) {
 923             if (node != null) {
 924                 assert !node.isDeleted() : &quot;trying to duplicate deleted node: &quot; + node;
 925                 Node replacement = node;
 926                 if (replacements != null) {
 927                     replacement = replacements.replacement(node);
 928                 }
 929                 if (replacement != node) {
 930                     assert replacement != null;
 931                     newNodes.put(node, replacement);
 932                 } else {
 933                     Node newNode = node.clone(graph, WithAllEdges);
 934                     assert newNode.getNodeClass().isLeafNode() || newNode.hasNoUsages();
 935                     assert newNode.getClass() == node.getClass();
 936                     newNodes.put(node, newNode);
 937                 }
 938             }
 939         }
 940     }
 941 
 942     private static void transferEdgesDifferentNodeClass(final Graph graph, final DuplicationReplacement replacements, final EconomicMap&lt;Node, Node&gt; newNodes, Node oldNode, Node node) {
 943         transferEdges(graph, replacements, newNodes, oldNode, node, Edges.Type.Inputs);
 944         transferEdges(graph, replacements, newNodes, oldNode, node, Edges.Type.Successors);
 945     }
 946 
 947     private static void transferEdges(final Graph graph, final DuplicationReplacement replacements, final EconomicMap&lt;Node, Node&gt; newNodes, Node oldNode, Node node, Edges.Type type) {
 948         NodeClass&lt;?&gt; nodeClass = node.getNodeClass();
 949         NodeClass&lt;?&gt; oldNodeClass = oldNode.getNodeClass();
 950         Edges oldEdges = oldNodeClass.getEdges(type);
 951         for (Position pos : oldEdges.getPositionsIterable(oldNode)) {
 952             if (!nodeClass.isValid(pos, oldNodeClass, oldEdges)) {
 953                 continue;
 954             }
 955             Node oldEdge = pos.get(oldNode);
 956             if (oldEdge != null) {
 957                 Node target = newNodes.get(oldEdge);
 958                 if (target == null) {
 959                     Node replacement = oldEdge;
 960                     if (replacements != null) {
 961                         replacement = replacements.replacement(oldEdge);
 962                     }
 963                     if (replacement != oldEdge) {
 964                         target = replacement;
 965                     } else if (type == Edges.Type.Inputs &amp;&amp; oldEdge.graph() == graph) {
 966                         // patch to the outer world
 967                         target = oldEdge;
 968                     }
 969                 }
 970                 pos.set(node, target);
 971             }
 972         }
 973     }
 974 
 975     /**
 976      * @return true if the node has no inputs and no successors
 977      */
 978     public boolean isLeafNode() {
 979         return isLeafNode;
 980     }
 981 
 982     public int getLeafId() {
 983         return this.leafId;
 984     }
 985 
 986     public NodeClass&lt;? super T&gt; getSuperNodeClass() {
 987         return superNodeClass;
 988     }
 989 
 990     public long inputsIteration() {
 991         return inputsIteration;
 992     }
 993 
 994     /**
 995      * An iterator that will iterate over edges.
 996      *
 997      * An iterator of this type will not return null values, unless edges are modified concurrently.
 998      * Concurrent modifications are detected by an assertion on a best-effort basis.
 999      */
1000     private static class RawEdgesIterator implements Iterator&lt;Node&gt; {
1001         protected final Node node;
1002         protected long mask;
1003         protected Node nextValue;
1004 
1005         RawEdgesIterator(Node node, long mask) {
1006             this.node = node;
1007             this.mask = mask;
1008         }
1009 
1010         @Override
1011         public boolean hasNext() {
1012             Node next = nextValue;
1013             if (next != null) {
1014                 return true;
1015             } else {
1016                 nextValue = forward();
1017                 return nextValue != null;
1018             }
1019         }
1020 
1021         private Node forward() {
1022             while (mask != 0) {
1023                 Node next = getInput();
1024                 mask = advanceInput();
1025                 if (next != null) {
1026                     return next;
1027                 }
1028             }
1029             return null;
1030         }
1031 
1032         @Override
1033         public Node next() {
1034             Node next = nextValue;
1035             if (next == null) {
1036                 next = forward();
1037                 if (next == null) {
1038                     throw new NoSuchElementException();
1039                 } else {
1040                     return next;
1041                 }
1042             } else {
1043                 nextValue = null;
1044                 return next;
1045             }
1046         }
1047 
1048         public final long advanceInput() {
1049             int state = (int) mask &amp; 0x03;
1050             if (state == 0) {
1051                 // Skip normal field.
1052                 return mask &gt;&gt;&gt; NEXT_EDGE;
1053             } else if (state == 1) {
1054                 // We are iterating a node list.
1055                 if ((mask &amp; 0xFFFF00) != 0) {
1056                     // Node list count is non-zero, decrease by 1.
1057                     return mask - 0x100;
1058                 } else {
1059                     // Node list is finished =&gt; go to next input.
1060                     return mask &gt;&gt;&gt; 24;
1061                 }
1062             } else {
1063                 // Need to expand node list.
1064                 NodeList&lt;?&gt; nodeList = Edges.getNodeListUnsafe(node, mask &amp; 0xFC);
1065                 if (nodeList != null) {
1066                     int size = nodeList.size();
1067                     if (size != 0) {
1068                         // Set pointer to upper most index of node list.
1069                         return ((mask &gt;&gt;&gt; NEXT_EDGE) &lt;&lt; 24) | (mask &amp; 0xFD) | ((size - 1) &lt;&lt; NEXT_EDGE);
1070                     }
1071                 }
1072                 // Node list is empty or null =&gt; skip.
1073                 return mask &gt;&gt;&gt; NEXT_EDGE;
1074             }
1075         }
1076 
1077         public Node getInput() {
1078             int state = (int) mask &amp; 0x03;
1079             if (state == 0) {
1080                 return Edges.getNodeUnsafe(node, mask &amp; 0xFC);
1081             } else if (state == 1) {
1082                 // We are iterating a node list.
1083                 NodeList&lt;?&gt; nodeList = Edges.getNodeListUnsafe(node, mask &amp; 0xFC);
1084                 return nodeList.nodes[nodeList.size() - 1 - (int) ((mask &gt;&gt;&gt; NEXT_EDGE) &amp; 0xFFFF)];
1085             } else {
1086                 // Node list needs to expand first.
1087                 return null;
1088             }
1089         }
1090 
1091         @Override
1092         public void remove() {
1093             throw new UnsupportedOperationException();
1094         }
1095 
1096         public Position nextPosition() {
1097             return null;
1098         }
1099     }
1100 
1101     private static final class RawEdgesWithModCountIterator extends RawEdgesIterator {
1102         private final int modCount;
1103 
1104         private RawEdgesWithModCountIterator(Node node, long mask) {
1105             super(node, mask);
1106             assert isModificationCountsEnabled();
1107             this.modCount = node.modCount();
1108         }
1109 
1110         @Override
1111         public boolean hasNext() {
1112             try {
1113                 return super.hasNext();
1114             } finally {
1115                 assert modCount == node.modCount() : &quot;must not be modified&quot;;
1116             }
1117         }
1118 
1119         @Override
1120         public Node next() {
1121             try {
1122                 return super.next();
1123             } finally {
1124                 assert modCount == node.modCount() : &quot;must not be modified&quot;;
1125             }
1126         }
1127 
1128         @Override
1129         public Position nextPosition() {
1130             try {
1131                 return super.nextPosition();
1132             } finally {
1133                 assert modCount == node.modCount();
1134             }
1135         }
1136     }
1137 
1138     public NodeIterable&lt;Node&gt; getSuccessorIterable(final Node node) {
1139         long mask = this.successorIteration;
1140         return new NodeIterable&lt;Node&gt;() {
1141 
1142             @Override
1143             public Iterator&lt;Node&gt; iterator() {
1144                 if (isModificationCountsEnabled()) {
1145                     return new RawEdgesWithModCountIterator(node, mask);
1146                 } else {
1147                     return new RawEdgesIterator(node, mask);
1148                 }
1149             }
1150 
1151             @Override
1152             public String toString() {
1153                 StringBuilder sb = new StringBuilder();
1154                 Iterator&lt;Node&gt; iterator = iterator();
1155                 boolean first = true;
1156                 sb.append(&quot;succs=&quot;);
1157                 sb.append(&#39;[&#39;);
1158                 while (iterator.hasNext()) {
1159                     Node input = iterator.next();
1160                     if (!first) {
1161                         sb.append(&quot;, &quot;);
1162                     }
1163                     sb.append(input);
1164                     first = false;
1165                 }
1166                 sb.append(&#39;]&#39;);
1167                 return sb.toString();
1168             }
1169         };
1170     }
1171 
1172     public NodeIterable&lt;Node&gt; getInputIterable(final Node node) {
1173         long mask = this.inputsIteration;
1174         return new NodeIterable&lt;Node&gt;() {
1175 
1176             @Override
1177             public Iterator&lt;Node&gt; iterator() {
1178                 if (isModificationCountsEnabled()) {
1179                     return new RawEdgesWithModCountIterator(node, mask);
1180                 } else {
1181                     return new RawEdgesIterator(node, mask);
1182                 }
1183             }
1184 
1185             @Override
1186             public String toString() {
1187                 StringBuilder sb = new StringBuilder();
1188                 Iterator&lt;Node&gt; iterator = iterator();
1189                 boolean first = true;
1190                 sb.append(&quot;inputs=&quot;);
1191                 sb.append(&#39;[&#39;);
1192                 while (iterator.hasNext()) {
1193                     Node input = iterator.next();
1194                     if (!first) {
1195                         sb.append(&quot;, &quot;);
1196                     }
1197                     sb.append(input);
1198                     first = false;
1199                 }
1200                 sb.append(&#39;]&#39;);
1201                 return sb.toString();
1202             }
1203         };
1204     }
1205 
1206     public boolean equalSuccessors(Node node, Node other) {
1207         return equalEdges(node, other, successorIteration);
1208     }
1209 
1210     public boolean equalInputs(Node node, Node other) {
1211         return equalEdges(node, other, inputsIteration);
1212     }
1213 
1214     private boolean equalEdges(Node node, Node other, long mask) {
1215         long myMask = mask;
1216         assert other.getNodeClass() == this;
1217         while (myMask != 0) {
1218             long offset = (myMask &amp; OFFSET_MASK);
1219             if ((myMask &amp; LIST_MASK) == 0) {
1220                 Object v1 = Edges.getNodeUnsafe(node, offset);
1221                 Object v2 = Edges.getNodeUnsafe(other, offset);
1222                 if (v1 != v2) {
1223                     return false;
1224                 }
1225             } else {
1226                 NodeList&lt;Node&gt; v1 = Edges.getNodeListUnsafe(node, offset);
1227                 NodeList&lt;Node&gt; v2 = Edges.getNodeListUnsafe(other, offset);
1228                 if (!Objects.equals(v1, v2)) {
1229                     return false;
1230                 }
1231             }
1232             myMask &gt;&gt;&gt;= NEXT_EDGE;
1233         }
1234         return true;
1235     }
1236 
1237     public void pushInputs(Node node, NodeStack stack) {
1238         long myMask = this.inputsIteration;
1239         while (myMask != 0) {
1240             long offset = (myMask &amp; OFFSET_MASK);
1241             if ((myMask &amp; LIST_MASK) == 0) {
1242                 Node curNode = Edges.getNodeUnsafe(node, offset);
1243                 if (curNode != null) {
1244                     stack.push(curNode);
1245                 }
1246             } else {
1247                 pushAllHelper(stack, node, offset);
1248             }
1249             myMask &gt;&gt;&gt;= NEXT_EDGE;
1250         }
1251     }
1252 
1253     private static void pushAllHelper(NodeStack stack, Node node, long offset) {
1254         NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1255         if (list != null) {
1256             for (int i = 0; i &lt; list.size(); ++i) {
1257                 Node curNode = list.get(i);
1258                 if (curNode != null) {
1259                     stack.push(curNode);
1260                 }
1261             }
1262         }
1263     }
1264 
1265     public void applySuccessors(Node node, EdgeVisitor consumer) {
1266         applyEdges(node, consumer, this.successorIteration);
1267     }
1268 
1269     public void applyInputs(Node node, EdgeVisitor consumer) {
1270         applyEdges(node, consumer, this.inputsIteration);
1271     }
1272 
1273     private static void applyEdges(Node node, EdgeVisitor consumer, long mask) {
1274         long myMask = mask;
1275         while (myMask != 0) {
1276             long offset = (myMask &amp; OFFSET_MASK);
1277             if ((myMask &amp; LIST_MASK) == 0) {
1278                 Node curNode = Edges.getNodeUnsafe(node, offset);
1279                 if (curNode != null) {
1280                     Node newNode = consumer.apply(node, curNode);
1281                     if (newNode != curNode) {
1282                         Edges.putNodeUnsafe(node, offset, newNode);
1283                     }
1284                 }
1285             } else {
1286                 applyHelper(node, consumer, offset);
1287             }
1288             myMask &gt;&gt;&gt;= NEXT_EDGE;
1289         }
1290     }
1291 
1292     private static void applyHelper(Node node, EdgeVisitor consumer, long offset) {
1293         NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1294         if (list != null) {
1295             for (int i = 0; i &lt; list.size(); ++i) {
1296                 Node curNode = list.get(i);
1297                 if (curNode != null) {
1298                     Node newNode = consumer.apply(node, curNode);
1299                     if (newNode != curNode) {
1300                         list.initialize(i, newNode);
1301                     }
1302                 }
1303             }
1304         }
1305     }
1306 
1307     public void unregisterAtSuccessorsAsPredecessor(Node node) {
1308         long myMask = this.successorIteration;
1309         while (myMask != 0) {
1310             long offset = (myMask &amp; OFFSET_MASK);
1311             if ((myMask &amp; LIST_MASK) == 0) {
1312                 Node curNode = Edges.getNodeUnsafe(node, offset);
1313                 if (curNode != null) {
1314                     node.updatePredecessor(curNode, null);
1315                     Edges.putNodeUnsafe(node, offset, null);
1316                 }
1317             } else {
1318                 unregisterAtSuccessorsAsPredecessorHelper(node, offset);
1319             }
1320             myMask &gt;&gt;&gt;= NEXT_EDGE;
1321         }
1322     }
1323 
1324     private static void unregisterAtSuccessorsAsPredecessorHelper(Node node, long offset) {
1325         NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1326         if (list != null) {
1327             for (int i = 0; i &lt; list.size(); ++i) {
1328                 Node curNode = list.get(i);
1329                 if (curNode != null) {
1330                     node.updatePredecessor(curNode, null);
1331                 }
1332             }
1333             list.clearWithoutUpdate();
1334         }
1335     }
1336 
1337     public void registerAtSuccessorsAsPredecessor(Node node) {
1338         long myMask = this.successorIteration;
1339         while (myMask != 0) {
1340             long offset = (myMask &amp; OFFSET_MASK);
1341             if ((myMask &amp; LIST_MASK) == 0) {
1342                 Node curNode = Edges.getNodeUnsafe(node, offset);
1343                 if (curNode != null) {
1344                     assert curNode.isAlive() : &quot;Successor not alive&quot;;
1345                     node.updatePredecessor(null, curNode);
1346                 }
1347             } else {
1348                 registerAtSuccessorsAsPredecessorHelper(node, offset);
1349             }
1350             myMask &gt;&gt;&gt;= NEXT_EDGE;
1351         }
1352     }
1353 
1354     private static void registerAtSuccessorsAsPredecessorHelper(Node node, long offset) {
1355         NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1356         if (list != null) {
1357             for (int i = 0; i &lt; list.size(); ++i) {
1358                 Node curNode = list.get(i);
1359                 if (curNode != null) {
1360                     assert curNode.isAlive() : &quot;Successor not alive&quot;;
1361                     node.updatePredecessor(null, curNode);
1362                 }
1363             }
1364         }
1365     }
1366 
1367     public boolean replaceFirstInput(Node node, Node key, Node replacement) {
1368         return replaceFirstEdge(node, key, replacement, this.inputsIteration);
1369     }
1370 
1371     public boolean replaceFirstSuccessor(Node node, Node key, Node replacement) {
1372         return replaceFirstEdge(node, key, replacement, this.successorIteration);
1373     }
1374 
1375     public static boolean replaceFirstEdge(Node node, Node key, Node replacement, long mask) {
1376         long myMask = mask;
1377         while (myMask != 0) {
1378             long offset = (myMask &amp; OFFSET_MASK);
1379             if ((myMask &amp; LIST_MASK) == 0) {
1380                 Object curNode = Edges.getNodeUnsafe(node, offset);
1381                 if (curNode == key) {
1382                     Edges.putNodeUnsafe(node, offset, replacement);
1383                     return true;
1384                 }
1385             } else {
1386                 NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1387                 if (list != null &amp;&amp; list.replaceFirst(key, replacement)) {
1388                     return true;
1389                 }
1390             }
1391             myMask &gt;&gt;&gt;= NEXT_EDGE;
1392         }
1393         return false;
1394     }
1395 
1396     public void registerAtInputsAsUsage(Node node) {
1397         long myMask = this.inputsIteration;
1398         while (myMask != 0) {
1399             long offset = (myMask &amp; OFFSET_MASK);
1400             if ((myMask &amp; LIST_MASK) == 0) {
1401                 Node curNode = Edges.getNodeUnsafe(node, offset);
1402                 if (curNode != null) {
1403                     assert curNode.isAlive() : &quot;Input not alive &quot; + curNode;
1404                     curNode.addUsage(node);
1405                 }
1406             } else {
1407                 registerAtInputsAsUsageHelper(node, offset);
1408             }
1409             myMask &gt;&gt;&gt;= NEXT_EDGE;
1410         }
1411     }
1412 
1413     private static void registerAtInputsAsUsageHelper(Node node, long offset) {
1414         NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1415         if (list != null) {
1416             for (int i = 0; i &lt; list.size(); ++i) {
1417                 Node curNode = list.get(i);
1418                 if (curNode != null) {
1419                     assert curNode.isAlive() : &quot;Input not alive&quot;;
1420                     curNode.addUsage(node);
1421                 }
1422             }
1423         }
1424     }
1425 
1426     public void unregisterAtInputsAsUsage(Node node) {
1427         long myMask = this.inputsIteration;
1428         while (myMask != 0) {
1429             long offset = (myMask &amp; OFFSET_MASK);
1430             if ((myMask &amp; LIST_MASK) == 0) {
1431                 Node curNode = Edges.getNodeUnsafe(node, offset);
1432                 if (curNode != null) {
1433                     node.removeThisFromUsages(curNode);
1434                     if (curNode.hasNoUsages()) {
1435                         node.maybeNotifyZeroUsages(curNode);
1436                     }
1437                     Edges.putNodeUnsafe(node, offset, null);
1438                 }
1439             } else {
1440                 unregisterAtInputsAsUsageHelper(node, offset);
1441             }
1442             myMask &gt;&gt;&gt;= NEXT_EDGE;
1443         }
1444     }
1445 
1446     private static void unregisterAtInputsAsUsageHelper(Node node, long offset) {
1447         NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1448         if (list != null) {
1449             for (int i = 0; i &lt; list.size(); ++i) {
1450                 Node curNode = list.get(i);
1451                 if (curNode != null) {
1452                     node.removeThisFromUsages(curNode);
1453                     if (curNode.hasNoUsages()) {
1454                         node.maybeNotifyZeroUsages(curNode);
1455                     }
1456                 }
1457             }
1458             list.clearWithoutUpdate();
1459         }
1460     }
1461 }
    </pre>
  </body>
</html>
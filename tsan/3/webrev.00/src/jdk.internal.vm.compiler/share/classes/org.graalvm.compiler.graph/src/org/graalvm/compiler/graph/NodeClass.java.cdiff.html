<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/NodeClass.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Node.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeList.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/NodeClass.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,15 ***</span>
   */
  
  
  package org.graalvm.compiler.graph;
  
  import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
  import static org.graalvm.compiler.graph.Graph.isModificationCountsEnabled;
  import static org.graalvm.compiler.graph.InputEdges.translateInto;
  import static org.graalvm.compiler.graph.Node.WithAllEdges;
<span class="line-modified">! import static org.graalvm.compiler.graph.UnsafeAccess.UNSAFE;</span>
  
  import java.lang.annotation.Annotation;
  import java.lang.reflect.AnnotatedElement;
  import java.lang.reflect.Field;
  import java.lang.reflect.Modifier;
<span class="line-new-header">--- 22,17 ---</span>
   */
  
  
  package org.graalvm.compiler.graph;
  
<span class="line-added">+ import static org.graalvm.compiler.core.common.Fields.translateInto;</span>
  import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
<span class="line-added">+ import static org.graalvm.compiler.graph.Edges.translateInto;</span>
  import static org.graalvm.compiler.graph.Graph.isModificationCountsEnabled;
  import static org.graalvm.compiler.graph.InputEdges.translateInto;
  import static org.graalvm.compiler.graph.Node.WithAllEdges;
<span class="line-modified">! import static org.graalvm.compiler.serviceprovider.GraalUnsafeAccess.getUnsafe;</span>
  
  import java.lang.annotation.Annotation;
  import java.lang.reflect.AnnotatedElement;
  import java.lang.reflect.Field;
  import java.lang.reflect.Modifier;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 67,20 ***</span>
<span class="line-new-header">--- 69,23 ---</span>
  import org.graalvm.compiler.nodeinfo.NodeCycles;
  import org.graalvm.compiler.nodeinfo.NodeInfo;
  import org.graalvm.compiler.nodeinfo.NodeSize;
  import org.graalvm.compiler.nodeinfo.Verbosity;
  
<span class="line-added">+ import sun.misc.Unsafe;</span>
<span class="line-added">+ </span>
  /**
   * Metadata for every {@link Node} type. The metadata includes:
   * &lt;ul&gt;
   * &lt;li&gt;The offsets of fields annotated with {@link Input} and {@link Successor} as well as methods
   * for iterating over such fields.&lt;/li&gt;
   * &lt;li&gt;The identifier for an {@link IterableNodeType} class.&lt;/li&gt;
   * &lt;/ul&gt;
   */
  public final class NodeClass&lt;T&gt; extends FieldIntrospection&lt;T&gt; {
  
<span class="line-added">+     private static final Unsafe UNSAFE = getUnsafe();</span>
      // Timers for creation of a NodeClass instance
      private static final TimerKey Init_FieldScanning = DebugContext.timer(&quot;NodeClass.Init.FieldScanning&quot;);
      private static final TimerKey Init_FieldScanningInner = DebugContext.timer(&quot;NodeClass.Init.FieldScanning.Inner&quot;);
      private static final TimerKey Init_AnnotationParsing = DebugContext.timer(&quot;NodeClass.Init.AnnotationParsing&quot;);
      private static final TimerKey Init_Edges = DebugContext.timer(&quot;NodeClass.Init.Edges&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,18 ***</span>
          try {
              Field field = clazz.getDeclaredField(&quot;TYPE&quot;);
              field.setAccessible(true);
              return (NodeClass&lt;T&gt;) field.get(null);
          } catch (IllegalArgumentException | IllegalAccessException | NoSuchFieldException | SecurityException e) {
<span class="line-modified">!             throw new RuntimeException(e);</span>
          }
      }
  
      public static &lt;T&gt; NodeClass&lt;T&gt; get(Class&lt;T&gt; clazz) {
          int numTries = 0;
          while (true) {
<span class="line-modified">!             boolean shouldBeInitializedBefore = UnsafeAccess.UNSAFE.shouldBeInitialized(clazz);</span>
  
              NodeClass&lt;T&gt; result = getUnchecked(clazz);
              if (result != null || clazz == NODE_CLASS) {
                  return result;
              }
<span class="line-new-header">--- 124,18 ---</span>
          try {
              Field field = clazz.getDeclaredField(&quot;TYPE&quot;);
              field.setAccessible(true);
              return (NodeClass&lt;T&gt;) field.get(null);
          } catch (IllegalArgumentException | IllegalAccessException | NoSuchFieldException | SecurityException e) {
<span class="line-modified">!             throw new RuntimeException(&quot;Could not load Graal NodeClass TYPE field for &quot; + clazz, e);</span>
          }
      }
  
      public static &lt;T&gt; NodeClass&lt;T&gt; get(Class&lt;T&gt; clazz) {
          int numTries = 0;
          while (true) {
<span class="line-modified">!             boolean shouldBeInitializedBefore = UNSAFE.shouldBeInitialized(clazz);</span>
  
              NodeClass&lt;T&gt; result = getUnchecked(clazz);
              if (result != null || clazz == NODE_CLASS) {
                  return result;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 139,17 ***</span>
               * GR-9537: We observed a transient problem with TYPE fields being null. Retry a couple
               * of times and print something to the log so that we can gather more diagnostic
               * information without failing gates.
               */
              numTries++;
<span class="line-modified">!             boolean shouldBeInitializedAfter = UnsafeAccess.UNSAFE.shouldBeInitialized(clazz);</span>
              String msg = &quot;GR-9537 Reflective field access of TYPE field returned null. This is probably a bug in HotSpot class initialization. &quot; +
                              &quot; clazz: &quot; + clazz.getTypeName() + &quot;, numTries: &quot; + numTries +
                              &quot;, shouldBeInitializedBefore: &quot; + shouldBeInitializedBefore + &quot;, shouldBeInitializedAfter: &quot; + shouldBeInitializedAfter;
              if (numTries &lt;= 100) {
                  TTY.println(msg);
<span class="line-modified">!                 UnsafeAccess.UNSAFE.ensureClassInitialized(clazz);</span>
              } else {
                  throw GraalError.shouldNotReachHere(msg);
              }
              return result;
          }
<span class="line-new-header">--- 144,17 ---</span>
               * GR-9537: We observed a transient problem with TYPE fields being null. Retry a couple
               * of times and print something to the log so that we can gather more diagnostic
               * information without failing gates.
               */
              numTries++;
<span class="line-modified">!             boolean shouldBeInitializedAfter = UNSAFE.shouldBeInitialized(clazz);</span>
              String msg = &quot;GR-9537 Reflective field access of TYPE field returned null. This is probably a bug in HotSpot class initialization. &quot; +
                              &quot; clazz: &quot; + clazz.getTypeName() + &quot;, numTries: &quot; + numTries +
                              &quot;, shouldBeInitializedBefore: &quot; + shouldBeInitializedBefore + &quot;, shouldBeInitializedAfter: &quot; + shouldBeInitializedAfter;
              if (numTries &lt;= 100) {
                  TTY.println(msg);
<span class="line-modified">!                 UNSAFE.ensureClassInitialized(clazz);</span>
              } else {
                  throw GraalError.shouldNotReachHere(msg);
              }
              return result;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 734,10 ***</span>
<span class="line-new-header">--- 739,11 ---</span>
                      assert false : &quot;unhandled type: &quot; + type;
                  }
              } else {
                  Object objectA = data.getObject(a, i);
                  Object objectB = data.getObject(b, i);
<span class="line-added">+                 assert !isLambda(objectA) || !isLambda(objectB) : &quot;lambdas are not permitted in fields of &quot; + this.toString();</span>
                  if (objectA != objectB) {
                      if (objectA != null &amp;&amp; objectB != null) {
                          if (!deepEquals0(objectA, objectB)) {
                              return false;
                          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 748,10 ***</span>
<span class="line-new-header">--- 754,15 ---</span>
              }
          }
          return true;
      }
  
<span class="line-added">+     private static boolean isLambda(Object obj) {</span>
<span class="line-added">+         // This needs to be consistent with InnerClassLambdaMetafactory constructor.</span>
<span class="line-added">+         return obj != null &amp;&amp; obj.getClass().getSimpleName().contains(&quot;$$Lambda$&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public boolean isValid(Position pos, NodeClass&lt;?&gt; from, Edges fromEdges) {
          if (this == from) {
              return true;
          }
          Edges toEdges = getEdges(fromEdges.type());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1210,12 ***</span>
                  Object v2 = Edges.getNodeUnsafe(other, offset);
                  if (v1 != v2) {
                      return false;
                  }
              } else {
<span class="line-modified">!                 Object v1 = Edges.getNodeListUnsafe(node, offset);</span>
<span class="line-modified">!                 Object v2 = Edges.getNodeListUnsafe(other, offset);</span>
                  if (!Objects.equals(v1, v2)) {
                      return false;
                  }
              }
              myMask &gt;&gt;&gt;= NEXT_EDGE;
<span class="line-new-header">--- 1221,12 ---</span>
                  Object v2 = Edges.getNodeUnsafe(other, offset);
                  if (v1 != v2) {
                      return false;
                  }
              } else {
<span class="line-modified">!                 NodeList&lt;Node&gt; v1 = Edges.getNodeListUnsafe(node, offset);</span>
<span class="line-modified">!                 NodeList&lt;Node&gt; v2 = Edges.getNodeListUnsafe(other, offset);</span>
                  if (!Objects.equals(v1, v2)) {
                      return false;
                  }
              }
              myMask &gt;&gt;&gt;= NEXT_EDGE;
</pre>
<center><a href="Node.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeList.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
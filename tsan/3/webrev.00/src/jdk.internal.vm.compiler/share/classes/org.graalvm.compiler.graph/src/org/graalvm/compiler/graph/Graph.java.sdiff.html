<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/Graph.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Edges.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="IterableNodeType.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/Graph.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 624         public void close() {
 625             assert nodeEventListener != null;
 626             if (nodeEventListener instanceof ChainedNodeEventListener) {
 627                 nodeEventListener = ((ChainedNodeEventListener) nodeEventListener).next;
 628             } else {
 629                 nodeEventListener = null;
 630             }
 631         }
 632     }
 633 
 634     private static class ChainedNodeEventListener extends NodeEventListener {
 635 
 636         NodeEventListener head;
 637         NodeEventListener next;
 638 
 639         ChainedNodeEventListener(NodeEventListener head, NodeEventListener next) {
 640             this.head = head;
 641             this.next = next;
 642         }
 643 
<span class="line-removed"> 644         @Override</span>
<span class="line-removed"> 645         public void nodeAdded(Node node) {</span>
<span class="line-removed"> 646             head.event(NodeEvent.NODE_ADDED, node);</span>
<span class="line-removed"> 647             next.event(NodeEvent.NODE_ADDED, node);</span>
<span class="line-removed"> 648         }</span>
<span class="line-removed"> 649 </span>
<span class="line-removed"> 650         @Override</span>
<span class="line-removed"> 651         public void inputChanged(Node node) {</span>
<span class="line-removed"> 652             head.event(NodeEvent.INPUT_CHANGED, node);</span>
<span class="line-removed"> 653             next.event(NodeEvent.INPUT_CHANGED, node);</span>
<span class="line-removed"> 654         }</span>
<span class="line-removed"> 655 </span>
<span class="line-removed"> 656         @Override</span>
<span class="line-removed"> 657         public void usagesDroppedToZero(Node node) {</span>
<span class="line-removed"> 658             head.event(NodeEvent.ZERO_USAGES, node);</span>
<span class="line-removed"> 659             next.event(NodeEvent.ZERO_USAGES, node);</span>
<span class="line-removed"> 660         }</span>
<span class="line-removed"> 661 </span>
<span class="line-removed"> 662         @Override</span>
<span class="line-removed"> 663         public void nodeRemoved(Node node) {</span>
<span class="line-removed"> 664             head.event(NodeEvent.NODE_REMOVED, node);</span>
<span class="line-removed"> 665             next.event(NodeEvent.NODE_REMOVED, node);</span>
<span class="line-removed"> 666         }</span>
<span class="line-removed"> 667 </span>
 668         @Override
 669         public void changed(NodeEvent e, Node node) {
 670             head.event(e, node);
 671             next.event(e, node);
 672         }
 673     }
 674 
 675     /**
 676      * Registers a given {@link NodeEventListener} with this graph. This should be used in
 677      * conjunction with try-with-resources statement as follows:
 678      *
 679      * &lt;pre&gt;
 680      * try (NodeEventScope nes = graph.trackNodeEvents(listener)) {
 681      *     // make changes to the graph
 682      * }
 683      * &lt;/pre&gt;
 684      */
 685     public NodeEventScope trackNodeEvents(NodeEventListener listener) {
 686         return new NodeEventScope(listener);
 687     }
</pre>
<hr />
<pre>
1134             Node prev = iterableNodesLast.get(nodeClassId);
1135             if (prev != null) {
1136                 prev.typeCacheNext = node;
1137             } else {
1138                 iterableNodesFirst.set(nodeClassId, node);
1139             }
1140             iterableNodesLast.set(nodeClassId, node);
1141         }
1142     }
1143 
1144     void unregister(Node node) {
1145         assert !isFrozen();
1146         assert !node.isDeleted() : node;
1147         if (node.getNodeClass().isLeafNode() &amp;&amp; node.getNodeClass().valueNumberable()) {
1148             removeNodeFromCache(node);
1149         }
1150         nodes[node.id] = null;
1151         nodesDeletedSinceLastCompression++;
1152 
1153         if (nodeEventListener != null) {
<span class="line-modified">1154             nodeEventListener.event(NodeEvent.NODE_ADDED, node);</span>
1155         }
1156 
1157         // nodes aren&#39;t removed from the type cache here - they will be removed during iteration
1158     }
1159 
1160     public boolean verify() {
1161         if (Options.VerifyGraalGraphs.getValue(options)) {
1162             for (Node node : getNodes()) {
1163                 try {
1164                     try {
1165                         assert node.verify();
1166                     } catch (AssertionError t) {
1167                         throw new GraalError(t);
1168                     } catch (RuntimeException t) {
1169                         throw new GraalError(t);
1170                     }
1171                 } catch (GraalError e) {
1172                     throw GraalGraphError.transformAndAddContext(e, node).addContext(this);
1173                 }
1174             }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 624         public void close() {
 625             assert nodeEventListener != null;
 626             if (nodeEventListener instanceof ChainedNodeEventListener) {
 627                 nodeEventListener = ((ChainedNodeEventListener) nodeEventListener).next;
 628             } else {
 629                 nodeEventListener = null;
 630             }
 631         }
 632     }
 633 
 634     private static class ChainedNodeEventListener extends NodeEventListener {
 635 
 636         NodeEventListener head;
 637         NodeEventListener next;
 638 
 639         ChainedNodeEventListener(NodeEventListener head, NodeEventListener next) {
 640             this.head = head;
 641             this.next = next;
 642         }
 643 
























 644         @Override
 645         public void changed(NodeEvent e, Node node) {
 646             head.event(e, node);
 647             next.event(e, node);
 648         }
 649     }
 650 
 651     /**
 652      * Registers a given {@link NodeEventListener} with this graph. This should be used in
 653      * conjunction with try-with-resources statement as follows:
 654      *
 655      * &lt;pre&gt;
 656      * try (NodeEventScope nes = graph.trackNodeEvents(listener)) {
 657      *     // make changes to the graph
 658      * }
 659      * &lt;/pre&gt;
 660      */
 661     public NodeEventScope trackNodeEvents(NodeEventListener listener) {
 662         return new NodeEventScope(listener);
 663     }
</pre>
<hr />
<pre>
1110             Node prev = iterableNodesLast.get(nodeClassId);
1111             if (prev != null) {
1112                 prev.typeCacheNext = node;
1113             } else {
1114                 iterableNodesFirst.set(nodeClassId, node);
1115             }
1116             iterableNodesLast.set(nodeClassId, node);
1117         }
1118     }
1119 
1120     void unregister(Node node) {
1121         assert !isFrozen();
1122         assert !node.isDeleted() : node;
1123         if (node.getNodeClass().isLeafNode() &amp;&amp; node.getNodeClass().valueNumberable()) {
1124             removeNodeFromCache(node);
1125         }
1126         nodes[node.id] = null;
1127         nodesDeletedSinceLastCompression++;
1128 
1129         if (nodeEventListener != null) {
<span class="line-modified">1130             nodeEventListener.event(NodeEvent.NODE_REMOVED, node);</span>
1131         }
1132 
1133         // nodes aren&#39;t removed from the type cache here - they will be removed during iteration
1134     }
1135 
1136     public boolean verify() {
1137         if (Options.VerifyGraalGraphs.getValue(options)) {
1138             for (Node node : getNodes()) {
1139                 try {
1140                     try {
1141                         assert node.verify();
1142                     } catch (AssertionError t) {
1143                         throw new GraalError(t);
1144                     } catch (RuntimeException t) {
1145                         throw new GraalError(t);
1146                     }
1147                 } catch (GraalError e) {
1148                     throw GraalGraphError.transformAndAddContext(e, node).addContext(this);
1149                 }
1150             }
</pre>
</td>
</tr>
</table>
<center><a href="Edges.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="IterableNodeType.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/NodeMap.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.graph;
 26 
 27 import java.util.Arrays;
 28 import java.util.Iterator;
 29 import java.util.function.BiFunction;
 30 
 31 import jdk.internal.vm.compiler.collections.EconomicMap;
 32 import jdk.internal.vm.compiler.collections.MapCursor;
 33 
 34 public class NodeMap&lt;T&gt; extends NodeIdAccessor implements EconomicMap&lt;Node, T&gt; {
 35 
 36     private static final int MIN_REALLOC_SIZE = 16;
 37 
 38     protected Object[] values;
 39 
 40     public NodeMap(Graph graph) {
 41         super(graph);
 42         this.values = new Object[graph.nodeIdCount()];
 43     }
 44 
 45     public NodeMap(NodeMap&lt;T&gt; copyFrom) {
 46         super(copyFrom.graph);
 47         this.values = Arrays.copyOf(copyFrom.values, copyFrom.values.length);
 48     }
 49 
 50     @Override
 51     @SuppressWarnings(&quot;unchecked&quot;)
 52     public T get(Node node) {
 53         assert check(node);
 54         return (T) values[getNodeId(node)];
 55     }
 56 
 57     @SuppressWarnings(&quot;unchecked&quot;)
 58     public T getAndGrow(Node node) {
 59         checkAndGrow(node);
 60         return (T) values[getNodeId(node)];
 61     }
 62 
 63     private void checkAndGrow(Node node) {
 64         if (isNew(node)) {
 65             this.values = Arrays.copyOf(values, Math.max(MIN_REALLOC_SIZE, graph.nodeIdCount() * 3 / 2));
 66         }
 67         assert check(node);
 68     }
 69 
 70     @Override
 71     public boolean isEmpty() {
 72         throw new UnsupportedOperationException(&quot;isEmpty() is not supported for performance reasons&quot;);
 73     }
 74 
 75     @Override
 76     public boolean containsKey(Node node) {
 77         if (node.graph() == graph()) {
 78             return get(node) != null;
 79         }
 80         return false;
 81     }
 82 
 83     public boolean containsValue(Object value) {
 84         for (Object o : values) {
 85             if (o == value) {
 86                 return true;
 87             }
 88         }
 89         return false;
 90     }
 91 
 92     public Graph graph() {
 93         return graph;
 94     }
 95 
 96     public void set(Node node, T value) {
 97         assert check(node);
<a name="2" id="anc2"></a><span class="line-added"> 98         if (!node.isAlive()) {</span>
<span class="line-added"> 99             throw new VerificationError(&quot;this node is not alive: &quot; + node);</span>
<span class="line-added">100         }</span>
101         values[getNodeId(node)] = value;
102     }
103 
104     public void setAndGrow(Node node, T value) {
105         checkAndGrow(node);
106         set(node, value);
107     }
108 
109     /**
110      * @param i
111      * @return Return the key for the entry at index {@code i}
112      */
113     protected Node getKey(int i) {
114         return graph.getNode(i);
115     }
116 
117     @Override
118     public int size() {
119         throw new UnsupportedOperationException(&quot;size() is not supported for performance reasons&quot;);
120     }
121 
122     public int capacity() {
123         return values.length;
124     }
125 
126     public boolean isNew(Node node) {
127         return getNodeId(node) &gt;= capacity();
128     }
129 
130     private boolean check(Node node) {
131         assert node.graph() == graph : String.format(&quot;%s is not part of the graph&quot;, node);
132         assert !isNew(node) : &quot;this node was added to the graph after creating the node map : &quot; + node;
<a name="3" id="anc3"></a><span class="line-added">133         assert node.isAlive() : &quot;this node is not alive: &quot; + node;</span>
134         return true;
135     }
136 
137     @Override
138     public void clear() {
139         Arrays.fill(values, null);
140     }
141 
142     @Override
143     public Iterable&lt;Node&gt; getKeys() {
144         return new Iterable&lt;Node&gt;() {
145 
146             @Override
147             public Iterator&lt;Node&gt; iterator() {
148                 return new Iterator&lt;Node&gt;() {
149 
150                     int i = 0;
151 
152                     @Override
153                     public boolean hasNext() {
154                         forward();
155                         return i &lt; NodeMap.this.values.length;
156                     }
157 
158                     @Override
159                     public Node next() {
160                         final int pos = i;
161                         final Node key = NodeMap.this.getKey(pos);
162                         i++;
163                         forward();
164                         return key;
165                     }
166 
167                     @Override
168                     public void remove() {
169                         throw new UnsupportedOperationException();
170                     }
171 
172                     private void forward() {
173                         while (i &lt; NodeMap.this.values.length &amp;&amp; (NodeMap.this.getKey(i) == null || NodeMap.this.values[i] == null)) {
174                             i++;
175                         }
176                     }
177                 };
178             }
179         };
180     }
181 
182     @Override
183     public MapCursor&lt;Node, T&gt; getEntries() {
184         return new MapCursor&lt;Node, T&gt;() {
185 
186             int current = -1;
187 
188             @Override
189             public boolean advance() {
190                 current++;
191                 while (current &lt; NodeMap.this.values.length &amp;&amp; (NodeMap.this.values[current] == null || NodeMap.this.getKey(current) == null)) {
192                     current++;
193                 }
194                 return current &lt; NodeMap.this.values.length;
195             }
196 
197             @Override
198             public Node getKey() {
199                 return NodeMap.this.getKey(current);
200             }
201 
202             @SuppressWarnings(&quot;unchecked&quot;)
203             @Override
204             public T getValue() {
205                 return (T) NodeMap.this.values[current];
206             }
207 
208             @Override
209             public void remove() {
210                 assert NodeMap.this.values[current] != null;
211                 NodeMap.this.values[current] = null;
212             }
213         };
214     }
215 
216     @Override
217     public Iterable&lt;T&gt; getValues() {
218         return new Iterable&lt;T&gt;() {
219 
220             @Override
221             public Iterator&lt;T&gt; iterator() {
222                 return new Iterator&lt;T&gt;() {
223 
224                     int i = 0;
225 
226                     @Override
227                     public boolean hasNext() {
228                         forward();
229                         return i &lt; NodeMap.this.values.length;
230                     }
231 
232                     @SuppressWarnings(&quot;unchecked&quot;)
233                     @Override
234                     public T next() {
235                         final int pos = i;
236                         final T value = (T) NodeMap.this.values[pos];
237                         i++;
238                         forward();
239                         return value;
240                     }
241 
242                     @Override
243                     public void remove() {
244                         throw new UnsupportedOperationException();
245                     }
246 
247                     private void forward() {
248                         while (i &lt; NodeMap.this.values.length &amp;&amp; (NodeMap.this.getKey(i) == null || NodeMap.this.values[i] == null)) {
249                             i++;
250                         }
251                     }
252                 };
253             }
254         };
255     }
256 
257     @Override
258     public String toString() {
259         MapCursor&lt;Node, T&gt; i = getEntries();
260         if (!i.advance()) {
261             return &quot;{}&quot;;
262         }
263 
264         StringBuilder sb = new StringBuilder();
265         sb.append(&#39;{&#39;);
266         while (true) {
267             Node key = i.getKey();
268             T value = i.getValue();
269             sb.append(key);
270             sb.append(&#39;=&#39;);
271             sb.append(value);
272             if (!i.advance()) {
273                 return sb.append(&#39;}&#39;).toString();
274             }
275             sb.append(&#39;,&#39;).append(&#39; &#39;);
276         }
277     }
278 
279     @Override
280     public T put(Node key, T value) {
281         T result = get(key);
282         set(key, value);
283         return result;
284     }
285 
286     @Override
287     public T removeKey(Node key) {
288         return put(key, null);
289     }
290 
291     @Override
292     public void replaceAll(BiFunction&lt;? super Node, ? super T, ? extends T&gt; function) {
293         for (Node n : getKeys()) {
294             put(n, function.apply(n, get(n)));
295         }
296     }
297 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
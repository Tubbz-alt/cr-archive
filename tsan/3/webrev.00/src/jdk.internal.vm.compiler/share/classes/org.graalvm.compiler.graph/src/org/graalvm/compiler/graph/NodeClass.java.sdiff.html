<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/NodeClass.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Node.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeList.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/NodeClass.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.graph;
  26 

  27 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;

  28 import static org.graalvm.compiler.graph.Graph.isModificationCountsEnabled;
  29 import static org.graalvm.compiler.graph.InputEdges.translateInto;
  30 import static org.graalvm.compiler.graph.Node.WithAllEdges;
<span class="line-modified">  31 import static org.graalvm.compiler.graph.UnsafeAccess.UNSAFE;</span>
  32 
  33 import java.lang.annotation.Annotation;
  34 import java.lang.reflect.AnnotatedElement;
  35 import java.lang.reflect.Field;
  36 import java.lang.reflect.Modifier;
  37 import java.util.ArrayList;
  38 import java.util.Arrays;
  39 import java.util.EnumSet;
  40 import java.util.Iterator;
  41 import java.util.NoSuchElementException;
  42 import java.util.Objects;
  43 import java.util.concurrent.atomic.AtomicInteger;
  44 
  45 import jdk.internal.vm.compiler.collections.EconomicMap;
  46 import jdk.internal.vm.compiler.collections.Equivalence;
  47 import org.graalvm.compiler.core.common.FieldIntrospection;
  48 import org.graalvm.compiler.core.common.Fields;
  49 import org.graalvm.compiler.core.common.FieldsScanner;
  50 import org.graalvm.compiler.debug.CounterKey;
  51 import org.graalvm.compiler.debug.DebugCloseable;
  52 import org.graalvm.compiler.debug.DebugContext;
  53 import org.graalvm.compiler.debug.GraalError;
  54 import org.graalvm.compiler.debug.TTY;
  55 import org.graalvm.compiler.debug.TimerKey;
  56 import org.graalvm.compiler.graph.Edges.Type;
  57 import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
  58 import org.graalvm.compiler.graph.Node.EdgeVisitor;
  59 import org.graalvm.compiler.graph.Node.Input;
  60 import org.graalvm.compiler.graph.Node.OptionalInput;
  61 import org.graalvm.compiler.graph.Node.Successor;
  62 import org.graalvm.compiler.graph.iterators.NodeIterable;
  63 import org.graalvm.compiler.graph.spi.Canonicalizable;
  64 import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;
  65 import org.graalvm.compiler.graph.spi.Simplifiable;
  66 import org.graalvm.compiler.nodeinfo.InputType;
  67 import org.graalvm.compiler.nodeinfo.NodeCycles;
  68 import org.graalvm.compiler.nodeinfo.NodeInfo;
  69 import org.graalvm.compiler.nodeinfo.NodeSize;
  70 import org.graalvm.compiler.nodeinfo.Verbosity;
  71 


  72 /**
  73  * Metadata for every {@link Node} type. The metadata includes:
  74  * &lt;ul&gt;
  75  * &lt;li&gt;The offsets of fields annotated with {@link Input} and {@link Successor} as well as methods
  76  * for iterating over such fields.&lt;/li&gt;
  77  * &lt;li&gt;The identifier for an {@link IterableNodeType} class.&lt;/li&gt;
  78  * &lt;/ul&gt;
  79  */
  80 public final class NodeClass&lt;T&gt; extends FieldIntrospection&lt;T&gt; {
  81 

  82     // Timers for creation of a NodeClass instance
  83     private static final TimerKey Init_FieldScanning = DebugContext.timer(&quot;NodeClass.Init.FieldScanning&quot;);
  84     private static final TimerKey Init_FieldScanningInner = DebugContext.timer(&quot;NodeClass.Init.FieldScanning.Inner&quot;);
  85     private static final TimerKey Init_AnnotationParsing = DebugContext.timer(&quot;NodeClass.Init.AnnotationParsing&quot;);
  86     private static final TimerKey Init_Edges = DebugContext.timer(&quot;NodeClass.Init.Edges&quot;);
  87     private static final TimerKey Init_Data = DebugContext.timer(&quot;NodeClass.Init.Data&quot;);
  88     private static final TimerKey Init_AllowedUsages = DebugContext.timer(&quot;NodeClass.Init.AllowedUsages&quot;);
  89     private static final TimerKey Init_IterableIds = DebugContext.timer(&quot;NodeClass.Init.IterableIds&quot;);
  90 
  91     public static final long MAX_EDGES = 8;
  92     public static final long MAX_LIST_EDGES = 6;
  93     public static final long OFFSET_MASK = 0xFC;
  94     public static final long LIST_MASK = 0x01;
  95     public static final long NEXT_EDGE = 0x08;
  96 
  97     @SuppressWarnings(&quot;try&quot;)
  98     private static &lt;T extends Annotation&gt; T getAnnotationTimed(AnnotatedElement e, Class&lt;T&gt; annotationClass, DebugContext debug) {
  99         try (DebugCloseable s = Init_AnnotationParsing.start(debug)) {
 100             return e.getAnnotation(annotationClass);
 101         }
</pre>
<hr />
<pre>
 104     /**
 105      * Gets the {@link NodeClass} associated with a given {@link Class}.
 106      */
 107     public static &lt;T&gt; NodeClass&lt;T&gt; create(Class&lt;T&gt; c) {
 108         assert getUnchecked(c) == null;
 109         Class&lt;? super T&gt; superclass = c.getSuperclass();
 110         NodeClass&lt;? super T&gt; nodeSuperclass = null;
 111         if (superclass != NODE_CLASS) {
 112             nodeSuperclass = get(superclass);
 113         }
 114         return new NodeClass&lt;&gt;(c, nodeSuperclass);
 115     }
 116 
 117     @SuppressWarnings(&quot;unchecked&quot;)
 118     private static &lt;T&gt; NodeClass&lt;T&gt; getUnchecked(Class&lt;T&gt; clazz) {
 119         try {
 120             Field field = clazz.getDeclaredField(&quot;TYPE&quot;);
 121             field.setAccessible(true);
 122             return (NodeClass&lt;T&gt;) field.get(null);
 123         } catch (IllegalArgumentException | IllegalAccessException | NoSuchFieldException | SecurityException e) {
<span class="line-modified"> 124             throw new RuntimeException(e);</span>
 125         }
 126     }
 127 
 128     public static &lt;T&gt; NodeClass&lt;T&gt; get(Class&lt;T&gt; clazz) {
 129         int numTries = 0;
 130         while (true) {
<span class="line-modified"> 131             boolean shouldBeInitializedBefore = UnsafeAccess.UNSAFE.shouldBeInitialized(clazz);</span>
 132 
 133             NodeClass&lt;T&gt; result = getUnchecked(clazz);
 134             if (result != null || clazz == NODE_CLASS) {
 135                 return result;
 136             }
 137 
 138             /*
 139              * GR-9537: We observed a transient problem with TYPE fields being null. Retry a couple
 140              * of times and print something to the log so that we can gather more diagnostic
 141              * information without failing gates.
 142              */
 143             numTries++;
<span class="line-modified"> 144             boolean shouldBeInitializedAfter = UnsafeAccess.UNSAFE.shouldBeInitialized(clazz);</span>
 145             String msg = &quot;GR-9537 Reflective field access of TYPE field returned null. This is probably a bug in HotSpot class initialization. &quot; +
 146                             &quot; clazz: &quot; + clazz.getTypeName() + &quot;, numTries: &quot; + numTries +
 147                             &quot;, shouldBeInitializedBefore: &quot; + shouldBeInitializedBefore + &quot;, shouldBeInitializedAfter: &quot; + shouldBeInitializedAfter;
 148             if (numTries &lt;= 100) {
 149                 TTY.println(msg);
<span class="line-modified"> 150                 UnsafeAccess.UNSAFE.ensureClassInitialized(clazz);</span>
 151             } else {
 152                 throw GraalError.shouldNotReachHere(msg);
 153             }
 154             return result;
 155         }
 156     }
 157 
 158     private static final Class&lt;?&gt; NODE_CLASS = Node.class;
 159     private static final Class&lt;?&gt; INPUT_LIST_CLASS = NodeInputList.class;
 160     private static final Class&lt;?&gt; SUCCESSOR_LIST_CLASS = NodeSuccessorList.class;
 161 
 162     private static AtomicInteger nextIterableId = new AtomicInteger();
 163     private static AtomicInteger nextLeafId = new AtomicInteger();
 164 
 165     private final InputEdges inputs;
 166     private final SuccessorEdges successors;
 167     private final NodeClass&lt;? super T&gt; superNodeClass;
 168 
 169     private final boolean canGVN;
 170     private final int startGVNNumber;
</pre>
<hr />
<pre>
 719                         return false;
 720                     }
 721                 } else if (type == Character.TYPE) {
 722                     char aChar = data.getChar(a, i);
 723                     char bChar = data.getChar(b, i);
 724                     if (aChar != bChar) {
 725                         return false;
 726                     }
 727                 } else if (type == Byte.TYPE) {
 728                     byte aByte = data.getByte(a, i);
 729                     byte bByte = data.getByte(b, i);
 730                     if (aByte != bByte) {
 731                         return false;
 732                     }
 733                 } else {
 734                     assert false : &quot;unhandled type: &quot; + type;
 735                 }
 736             } else {
 737                 Object objectA = data.getObject(a, i);
 738                 Object objectB = data.getObject(b, i);

 739                 if (objectA != objectB) {
 740                     if (objectA != null &amp;&amp; objectB != null) {
 741                         if (!deepEquals0(objectA, objectB)) {
 742                             return false;
 743                         }
 744                     } else {
 745                         return false;
 746                     }
 747                 }
 748             }
 749         }
 750         return true;
 751     }
 752 





 753     public boolean isValid(Position pos, NodeClass&lt;?&gt; from, Edges fromEdges) {
 754         if (this == from) {
 755             return true;
 756         }
 757         Edges toEdges = getEdges(fromEdges.type());
 758         if (pos.getIndex() &gt;= toEdges.getCount()) {
 759             return false;
 760         }
 761         if (pos.getIndex() &gt;= fromEdges.getCount()) {
 762             return false;
 763         }
 764         return toEdges.isSame(fromEdges, pos.getIndex());
 765     }
 766 
 767     static void updateEdgesInPlace(Node node, InplaceUpdateClosure duplicationReplacement, Edges edges) {
 768         int index = 0;
 769         Type curType = edges.type();
 770         int directCount = edges.getDirectCount();
 771         final long[] curOffsets = edges.getOffsets();
 772         while (index &lt; directCount) {
</pre>
<hr />
<pre>
1195     public boolean equalSuccessors(Node node, Node other) {
1196         return equalEdges(node, other, successorIteration);
1197     }
1198 
1199     public boolean equalInputs(Node node, Node other) {
1200         return equalEdges(node, other, inputsIteration);
1201     }
1202 
1203     private boolean equalEdges(Node node, Node other, long mask) {
1204         long myMask = mask;
1205         assert other.getNodeClass() == this;
1206         while (myMask != 0) {
1207             long offset = (myMask &amp; OFFSET_MASK);
1208             if ((myMask &amp; LIST_MASK) == 0) {
1209                 Object v1 = Edges.getNodeUnsafe(node, offset);
1210                 Object v2 = Edges.getNodeUnsafe(other, offset);
1211                 if (v1 != v2) {
1212                     return false;
1213                 }
1214             } else {
<span class="line-modified">1215                 Object v1 = Edges.getNodeListUnsafe(node, offset);</span>
<span class="line-modified">1216                 Object v2 = Edges.getNodeListUnsafe(other, offset);</span>
1217                 if (!Objects.equals(v1, v2)) {
1218                     return false;
1219                 }
1220             }
1221             myMask &gt;&gt;&gt;= NEXT_EDGE;
1222         }
1223         return true;
1224     }
1225 
1226     public void pushInputs(Node node, NodeStack stack) {
1227         long myMask = this.inputsIteration;
1228         while (myMask != 0) {
1229             long offset = (myMask &amp; OFFSET_MASK);
1230             if ((myMask &amp; LIST_MASK) == 0) {
1231                 Node curNode = Edges.getNodeUnsafe(node, offset);
1232                 if (curNode != null) {
1233                     stack.push(curNode);
1234                 }
1235             } else {
1236                 pushAllHelper(stack, node, offset);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.graph;
  26 
<span class="line-added">  27 import static org.graalvm.compiler.core.common.Fields.translateInto;</span>
  28 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
<span class="line-added">  29 import static org.graalvm.compiler.graph.Edges.translateInto;</span>
  30 import static org.graalvm.compiler.graph.Graph.isModificationCountsEnabled;
  31 import static org.graalvm.compiler.graph.InputEdges.translateInto;
  32 import static org.graalvm.compiler.graph.Node.WithAllEdges;
<span class="line-modified">  33 import static org.graalvm.compiler.serviceprovider.GraalUnsafeAccess.getUnsafe;</span>
  34 
  35 import java.lang.annotation.Annotation;
  36 import java.lang.reflect.AnnotatedElement;
  37 import java.lang.reflect.Field;
  38 import java.lang.reflect.Modifier;
  39 import java.util.ArrayList;
  40 import java.util.Arrays;
  41 import java.util.EnumSet;
  42 import java.util.Iterator;
  43 import java.util.NoSuchElementException;
  44 import java.util.Objects;
  45 import java.util.concurrent.atomic.AtomicInteger;
  46 
  47 import jdk.internal.vm.compiler.collections.EconomicMap;
  48 import jdk.internal.vm.compiler.collections.Equivalence;
  49 import org.graalvm.compiler.core.common.FieldIntrospection;
  50 import org.graalvm.compiler.core.common.Fields;
  51 import org.graalvm.compiler.core.common.FieldsScanner;
  52 import org.graalvm.compiler.debug.CounterKey;
  53 import org.graalvm.compiler.debug.DebugCloseable;
  54 import org.graalvm.compiler.debug.DebugContext;
  55 import org.graalvm.compiler.debug.GraalError;
  56 import org.graalvm.compiler.debug.TTY;
  57 import org.graalvm.compiler.debug.TimerKey;
  58 import org.graalvm.compiler.graph.Edges.Type;
  59 import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
  60 import org.graalvm.compiler.graph.Node.EdgeVisitor;
  61 import org.graalvm.compiler.graph.Node.Input;
  62 import org.graalvm.compiler.graph.Node.OptionalInput;
  63 import org.graalvm.compiler.graph.Node.Successor;
  64 import org.graalvm.compiler.graph.iterators.NodeIterable;
  65 import org.graalvm.compiler.graph.spi.Canonicalizable;
  66 import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;
  67 import org.graalvm.compiler.graph.spi.Simplifiable;
  68 import org.graalvm.compiler.nodeinfo.InputType;
  69 import org.graalvm.compiler.nodeinfo.NodeCycles;
  70 import org.graalvm.compiler.nodeinfo.NodeInfo;
  71 import org.graalvm.compiler.nodeinfo.NodeSize;
  72 import org.graalvm.compiler.nodeinfo.Verbosity;
  73 
<span class="line-added">  74 import sun.misc.Unsafe;</span>
<span class="line-added">  75 </span>
  76 /**
  77  * Metadata for every {@link Node} type. The metadata includes:
  78  * &lt;ul&gt;
  79  * &lt;li&gt;The offsets of fields annotated with {@link Input} and {@link Successor} as well as methods
  80  * for iterating over such fields.&lt;/li&gt;
  81  * &lt;li&gt;The identifier for an {@link IterableNodeType} class.&lt;/li&gt;
  82  * &lt;/ul&gt;
  83  */
  84 public final class NodeClass&lt;T&gt; extends FieldIntrospection&lt;T&gt; {
  85 
<span class="line-added">  86     private static final Unsafe UNSAFE = getUnsafe();</span>
  87     // Timers for creation of a NodeClass instance
  88     private static final TimerKey Init_FieldScanning = DebugContext.timer(&quot;NodeClass.Init.FieldScanning&quot;);
  89     private static final TimerKey Init_FieldScanningInner = DebugContext.timer(&quot;NodeClass.Init.FieldScanning.Inner&quot;);
  90     private static final TimerKey Init_AnnotationParsing = DebugContext.timer(&quot;NodeClass.Init.AnnotationParsing&quot;);
  91     private static final TimerKey Init_Edges = DebugContext.timer(&quot;NodeClass.Init.Edges&quot;);
  92     private static final TimerKey Init_Data = DebugContext.timer(&quot;NodeClass.Init.Data&quot;);
  93     private static final TimerKey Init_AllowedUsages = DebugContext.timer(&quot;NodeClass.Init.AllowedUsages&quot;);
  94     private static final TimerKey Init_IterableIds = DebugContext.timer(&quot;NodeClass.Init.IterableIds&quot;);
  95 
  96     public static final long MAX_EDGES = 8;
  97     public static final long MAX_LIST_EDGES = 6;
  98     public static final long OFFSET_MASK = 0xFC;
  99     public static final long LIST_MASK = 0x01;
 100     public static final long NEXT_EDGE = 0x08;
 101 
 102     @SuppressWarnings(&quot;try&quot;)
 103     private static &lt;T extends Annotation&gt; T getAnnotationTimed(AnnotatedElement e, Class&lt;T&gt; annotationClass, DebugContext debug) {
 104         try (DebugCloseable s = Init_AnnotationParsing.start(debug)) {
 105             return e.getAnnotation(annotationClass);
 106         }
</pre>
<hr />
<pre>
 109     /**
 110      * Gets the {@link NodeClass} associated with a given {@link Class}.
 111      */
 112     public static &lt;T&gt; NodeClass&lt;T&gt; create(Class&lt;T&gt; c) {
 113         assert getUnchecked(c) == null;
 114         Class&lt;? super T&gt; superclass = c.getSuperclass();
 115         NodeClass&lt;? super T&gt; nodeSuperclass = null;
 116         if (superclass != NODE_CLASS) {
 117             nodeSuperclass = get(superclass);
 118         }
 119         return new NodeClass&lt;&gt;(c, nodeSuperclass);
 120     }
 121 
 122     @SuppressWarnings(&quot;unchecked&quot;)
 123     private static &lt;T&gt; NodeClass&lt;T&gt; getUnchecked(Class&lt;T&gt; clazz) {
 124         try {
 125             Field field = clazz.getDeclaredField(&quot;TYPE&quot;);
 126             field.setAccessible(true);
 127             return (NodeClass&lt;T&gt;) field.get(null);
 128         } catch (IllegalArgumentException | IllegalAccessException | NoSuchFieldException | SecurityException e) {
<span class="line-modified"> 129             throw new RuntimeException(&quot;Could not load Graal NodeClass TYPE field for &quot; + clazz, e);</span>
 130         }
 131     }
 132 
 133     public static &lt;T&gt; NodeClass&lt;T&gt; get(Class&lt;T&gt; clazz) {
 134         int numTries = 0;
 135         while (true) {
<span class="line-modified"> 136             boolean shouldBeInitializedBefore = UNSAFE.shouldBeInitialized(clazz);</span>
 137 
 138             NodeClass&lt;T&gt; result = getUnchecked(clazz);
 139             if (result != null || clazz == NODE_CLASS) {
 140                 return result;
 141             }
 142 
 143             /*
 144              * GR-9537: We observed a transient problem with TYPE fields being null. Retry a couple
 145              * of times and print something to the log so that we can gather more diagnostic
 146              * information without failing gates.
 147              */
 148             numTries++;
<span class="line-modified"> 149             boolean shouldBeInitializedAfter = UNSAFE.shouldBeInitialized(clazz);</span>
 150             String msg = &quot;GR-9537 Reflective field access of TYPE field returned null. This is probably a bug in HotSpot class initialization. &quot; +
 151                             &quot; clazz: &quot; + clazz.getTypeName() + &quot;, numTries: &quot; + numTries +
 152                             &quot;, shouldBeInitializedBefore: &quot; + shouldBeInitializedBefore + &quot;, shouldBeInitializedAfter: &quot; + shouldBeInitializedAfter;
 153             if (numTries &lt;= 100) {
 154                 TTY.println(msg);
<span class="line-modified"> 155                 UNSAFE.ensureClassInitialized(clazz);</span>
 156             } else {
 157                 throw GraalError.shouldNotReachHere(msg);
 158             }
 159             return result;
 160         }
 161     }
 162 
 163     private static final Class&lt;?&gt; NODE_CLASS = Node.class;
 164     private static final Class&lt;?&gt; INPUT_LIST_CLASS = NodeInputList.class;
 165     private static final Class&lt;?&gt; SUCCESSOR_LIST_CLASS = NodeSuccessorList.class;
 166 
 167     private static AtomicInteger nextIterableId = new AtomicInteger();
 168     private static AtomicInteger nextLeafId = new AtomicInteger();
 169 
 170     private final InputEdges inputs;
 171     private final SuccessorEdges successors;
 172     private final NodeClass&lt;? super T&gt; superNodeClass;
 173 
 174     private final boolean canGVN;
 175     private final int startGVNNumber;
</pre>
<hr />
<pre>
 724                         return false;
 725                     }
 726                 } else if (type == Character.TYPE) {
 727                     char aChar = data.getChar(a, i);
 728                     char bChar = data.getChar(b, i);
 729                     if (aChar != bChar) {
 730                         return false;
 731                     }
 732                 } else if (type == Byte.TYPE) {
 733                     byte aByte = data.getByte(a, i);
 734                     byte bByte = data.getByte(b, i);
 735                     if (aByte != bByte) {
 736                         return false;
 737                     }
 738                 } else {
 739                     assert false : &quot;unhandled type: &quot; + type;
 740                 }
 741             } else {
 742                 Object objectA = data.getObject(a, i);
 743                 Object objectB = data.getObject(b, i);
<span class="line-added"> 744                 assert !isLambda(objectA) || !isLambda(objectB) : &quot;lambdas are not permitted in fields of &quot; + this.toString();</span>
 745                 if (objectA != objectB) {
 746                     if (objectA != null &amp;&amp; objectB != null) {
 747                         if (!deepEquals0(objectA, objectB)) {
 748                             return false;
 749                         }
 750                     } else {
 751                         return false;
 752                     }
 753                 }
 754             }
 755         }
 756         return true;
 757     }
 758 
<span class="line-added"> 759     private static boolean isLambda(Object obj) {</span>
<span class="line-added"> 760         // This needs to be consistent with InnerClassLambdaMetafactory constructor.</span>
<span class="line-added"> 761         return obj != null &amp;&amp; obj.getClass().getSimpleName().contains(&quot;$$Lambda$&quot;);</span>
<span class="line-added"> 762     }</span>
<span class="line-added"> 763 </span>
 764     public boolean isValid(Position pos, NodeClass&lt;?&gt; from, Edges fromEdges) {
 765         if (this == from) {
 766             return true;
 767         }
 768         Edges toEdges = getEdges(fromEdges.type());
 769         if (pos.getIndex() &gt;= toEdges.getCount()) {
 770             return false;
 771         }
 772         if (pos.getIndex() &gt;= fromEdges.getCount()) {
 773             return false;
 774         }
 775         return toEdges.isSame(fromEdges, pos.getIndex());
 776     }
 777 
 778     static void updateEdgesInPlace(Node node, InplaceUpdateClosure duplicationReplacement, Edges edges) {
 779         int index = 0;
 780         Type curType = edges.type();
 781         int directCount = edges.getDirectCount();
 782         final long[] curOffsets = edges.getOffsets();
 783         while (index &lt; directCount) {
</pre>
<hr />
<pre>
1206     public boolean equalSuccessors(Node node, Node other) {
1207         return equalEdges(node, other, successorIteration);
1208     }
1209 
1210     public boolean equalInputs(Node node, Node other) {
1211         return equalEdges(node, other, inputsIteration);
1212     }
1213 
1214     private boolean equalEdges(Node node, Node other, long mask) {
1215         long myMask = mask;
1216         assert other.getNodeClass() == this;
1217         while (myMask != 0) {
1218             long offset = (myMask &amp; OFFSET_MASK);
1219             if ((myMask &amp; LIST_MASK) == 0) {
1220                 Object v1 = Edges.getNodeUnsafe(node, offset);
1221                 Object v2 = Edges.getNodeUnsafe(other, offset);
1222                 if (v1 != v2) {
1223                     return false;
1224                 }
1225             } else {
<span class="line-modified">1226                 NodeList&lt;Node&gt; v1 = Edges.getNodeListUnsafe(node, offset);</span>
<span class="line-modified">1227                 NodeList&lt;Node&gt; v2 = Edges.getNodeListUnsafe(other, offset);</span>
1228                 if (!Objects.equals(v1, v2)) {
1229                     return false;
1230                 }
1231             }
1232             myMask &gt;&gt;&gt;= NEXT_EDGE;
1233         }
1234         return true;
1235     }
1236 
1237     public void pushInputs(Node node, NodeStack stack) {
1238         long myMask = this.inputsIteration;
1239         while (myMask != 0) {
1240             long offset = (myMask &amp; OFFSET_MASK);
1241             if ((myMask &amp; LIST_MASK) == 0) {
1242                 Node curNode = Edges.getNodeUnsafe(node, offset);
1243                 if (curNode != null) {
1244                     stack.push(curNode);
1245                 }
1246             } else {
1247                 pushAllHelper(stack, node, offset);
</pre>
</td>
</tr>
</table>
<center><a href="Node.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeList.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
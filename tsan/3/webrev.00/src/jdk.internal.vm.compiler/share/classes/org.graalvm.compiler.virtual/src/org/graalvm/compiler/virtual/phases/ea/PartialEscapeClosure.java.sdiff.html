<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/PartialEscapeClosure.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PEReadEliminationClosure.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PartialEscapePhase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/PartialEscapeClosure.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  42 import org.graalvm.compiler.debug.DebugContext;
  43 import org.graalvm.compiler.graph.Node;
  44 import org.graalvm.compiler.graph.NodeBitMap;
  45 import org.graalvm.compiler.graph.Position;
  46 import org.graalvm.compiler.graph.spi.Canonicalizable;
  47 import org.graalvm.compiler.nodes.AbstractEndNode;
  48 import org.graalvm.compiler.nodes.CallTargetNode;
  49 import org.graalvm.compiler.nodes.ConstantNode;
  50 import org.graalvm.compiler.nodes.ControlSinkNode;
  51 import org.graalvm.compiler.nodes.FixedNode;
  52 import org.graalvm.compiler.nodes.FixedWithNextNode;
  53 import org.graalvm.compiler.nodes.FrameState;
  54 import org.graalvm.compiler.nodes.Invoke;
  55 import org.graalvm.compiler.nodes.LoopBeginNode;
  56 import org.graalvm.compiler.nodes.LoopExitNode;
  57 import org.graalvm.compiler.nodes.NodeView;
  58 import org.graalvm.compiler.nodes.PhiNode;
  59 import org.graalvm.compiler.nodes.ProxyNode;
  60 import org.graalvm.compiler.nodes.StructuredGraph;
  61 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;

  62 import org.graalvm.compiler.nodes.ValueNode;
  63 import org.graalvm.compiler.nodes.ValuePhiNode;
  64 import org.graalvm.compiler.nodes.ValueProxyNode;
  65 import org.graalvm.compiler.nodes.VirtualState;
  66 import org.graalvm.compiler.nodes.VirtualState.NodeClosure;
  67 import org.graalvm.compiler.nodes.cfg.Block;
  68 import org.graalvm.compiler.nodes.spi.LoweringProvider;
  69 import org.graalvm.compiler.nodes.spi.NodeWithState;
  70 import org.graalvm.compiler.nodes.spi.Virtualizable;
  71 import org.graalvm.compiler.nodes.spi.VirtualizableAllocation;
  72 import org.graalvm.compiler.nodes.spi.VirtualizerTool;
  73 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
  74 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  75 import org.graalvm.compiler.virtual.nodes.VirtualObjectState;
  76 
  77 import jdk.vm.ci.meta.ConstantReflectionProvider;
  78 import jdk.vm.ci.meta.JavaConstant;
  79 import jdk.vm.ci.meta.JavaKind;
  80 import jdk.vm.ci.meta.MetaAccessProvider;
  81 
</pre>
<hr />
<pre>
  88     public static final CounterKey COUNTER_MATERIALIZATIONS_LOOP_REITERATION = DebugContext.counter(&quot;MaterializationsLoopReiteration&quot;);
  89     public static final CounterKey COUNTER_MATERIALIZATIONS_LOOP_END = DebugContext.counter(&quot;MaterializationsLoopEnd&quot;);
  90     public static final CounterKey COUNTER_ALLOCATION_REMOVED = DebugContext.counter(&quot;AllocationsRemoved&quot;);
  91     public static final CounterKey COUNTER_MEMORYCHECKPOINT = DebugContext.counter(&quot;MemoryCheckpoint&quot;);
  92 
  93     /**
  94      * Nodes with inputs that were modified during analysis are marked in this bitset - this way
  95      * nodes that are not influenced at all by analysis can be rejected quickly.
  96      */
  97     private final NodeBitMap hasVirtualInputs;
  98 
  99     /**
 100      * This is handed out to implementers of {@link Virtualizable}.
 101      */
 102     protected final VirtualizerToolImpl tool;
 103 
 104     /**
 105      * The indexes into this array correspond to {@link VirtualObjectNode#getObjectId()}.
 106      */
 107     public final ArrayList&lt;VirtualObjectNode&gt; virtualObjects = new ArrayList&lt;&gt;();
<span class="line-removed"> 108     public final DebugContext debug;</span>
 109 
 110     @Override
 111     public boolean needsApplyEffects() {
 112         if (hasChanged()) {
 113             return true;
 114         }
 115         /*
 116          * If there is a mismatch between the number of materializations and the number of
 117          * virtualizations, we need to apply effects, even if there were no other significant
 118          * changes to the graph. This applies to each block, since moving from one block to the
 119          * other can also be important (if the probabilities of the block differ).
 120          */
 121         for (Block block : cfg.getBlocks()) {
 122             GraphEffectList effects = blockEffects.get(block);
 123             if (effects != null) {
 124                 if (effects.getVirtualizationDelta() != 0) {
 125                     return true;
 126                 }
 127             }
 128         }
</pre>
<hr />
<pre>
 172         @Override
 173         protected PartialEscapeBlockState.Final getInitialState() {
 174             return new PartialEscapeBlockState.Final(tool.getOptions(), tool.getDebug());
 175         }
 176 
 177         @Override
 178         protected PartialEscapeBlockState.Final cloneState(PartialEscapeBlockState.Final oldState) {
 179             return new PartialEscapeBlockState.Final(oldState);
 180         }
 181     }
 182 
 183     public PartialEscapeClosure(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider) {
 184         this(schedule, metaAccess, constantReflection, constantFieldProvider, null);
 185     }
 186 
 187     public PartialEscapeClosure(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,
 188                     LoweringProvider loweringProvider) {
 189         super(schedule, schedule.getCFG());
 190         StructuredGraph graph = schedule.getCFG().graph;
 191         this.hasVirtualInputs = graph.createNodeBitMap();
<span class="line-removed"> 192         this.debug = graph.getDebug();</span>
 193         this.tool = new VirtualizerToolImpl(metaAccess, constantReflection, constantFieldProvider, this, graph.getAssumptions(), graph.getOptions(), debug, loweringProvider);
 194     }
 195 
 196     /**
 197      * @return true if the node was deleted, false otherwise
 198      */
 199     @Override
 200     protected boolean processNode(Node node, BlockT state, GraphEffectList effects, FixedWithNextNode lastFixedNode) {
 201         /*
 202          * These checks make up for the fact that an earliest schedule moves CallTargetNodes upwards
 203          * and thus materializes virtual objects needlessly. Also, FrameStates and ConstantNodes are
 204          * scheduled, but can safely be ignored.
 205          */
 206         if (node instanceof CallTargetNode || node instanceof FrameState || node instanceof ConstantNode) {
 207             return false;
 208         } else if (node instanceof Invoke) {
 209             processNodeInternal(((Invoke) node).callTarget(), state, effects, lastFixedNode);
 210         }
 211         return processNodeInternal(node, state, effects, lastFixedNode);
 212     }
</pre>
<hr />
<pre>
 670         /**
 671          * Merge all predecessor block states into one block state. This is an iterative process,
 672          * because merging states can lead to materializations which make previous parts of the
 673          * merging operation invalid. The merging process is executed until a stable state has been
 674          * reached. This method needs to be careful to place the effects of the merging operation
 675          * into the correct blocks.
 676          *
 677          * @param statesList the predecessor block states of the merge
 678          */
 679         @Override
 680         protected void merge(List&lt;BlockT&gt; statesList) {
 681 
 682             PartialEscapeBlockState&lt;?&gt;[] states = new PartialEscapeBlockState&lt;?&gt;[statesList.size()];
 683             for (int i = 0; i &lt; statesList.size(); i++) {
 684                 states[i] = statesList.get(i);
 685             }
 686 
 687             // calculate the set of virtual objects that exist in all predecessors
 688             int[] virtualObjTemp = intersectVirtualObjects(states);
 689 




























 690             boolean materialized;
 691             do {
 692                 materialized = false;
 693 
<span class="line-modified"> 694                 if (PartialEscapeBlockState.identicalObjectStates(states)) {</span>
 695                     newState.adoptAddObjectStates(states[0]);
 696                 } else {
 697 
 698                     for (int object : virtualObjTemp) {
<span class="line-modified"> 699                         if (PartialEscapeBlockState.identicalObjectStates(states, object)) {</span>
 700                             newState.addObject(object, states[0].getObjectState(object).share());
 701                             continue;
 702                         }
 703 
 704                         // determine if all inputs are virtual or the same materialized value
 705                         int virtualCount = 0;
 706                         ObjectState startObj = states[0].getObjectState(object);
 707                         boolean locksMatch = true;
 708                         boolean ensureVirtual = true;
 709                         ValueNode uniqueMaterializedValue = startObj.isVirtual() ? null : startObj.getMaterializedValue();
 710                         for (int i = 0; i &lt; states.length; i++) {
 711                             ObjectState obj = states[i].getObjectState(object);
 712                             ensureVirtual &amp;= obj.getEnsureVirtualized();
















 713                             if (obj.isVirtual()) {
 714                                 virtualCount++;
 715                                 uniqueMaterializedValue = null;
 716                                 locksMatch &amp;= obj.locksEqual(startObj);
 717                             } else if (obj.getMaterializedValue() != uniqueMaterializedValue) {
 718                                 uniqueMaterializedValue = null;
 719                             }
 720                         }
 721 
 722                         if (virtualCount == states.length &amp;&amp; locksMatch) {
 723                             materialized |= mergeObjectStates(object, null, states);
 724                         } else {
 725                             if (uniqueMaterializedValue != null) {
 726                                 newState.addObject(object, new ObjectState(uniqueMaterializedValue, null, ensureVirtual));
 727                             } else {
 728                                 PhiNode materializedValuePhi = getPhi(object, StampFactory.forKind(JavaKind.Object));
 729                                 mergeEffects.addFloatingNode(materializedValuePhi, &quot;materializedPhi&quot;);
 730                                 for (int i = 0; i &lt; states.length; i++) {
 731                                     ObjectState obj = states[i].getObjectState(object);
 732                                     if (obj.isVirtual()) {
</pre>
<hr />
<pre>
1012                         VirtualObjectNode virtual = virtualObjs[i];
1013 
1014                         if (!firstVirtual.type().equals(virtual.type()) || firstVirtual.entryCount() != virtual.entryCount()) {
1015                             compatible = false;
1016                             break;
1017                         }
1018                         if (!states[0].getObjectState(firstVirtual).locksEqual(states[i].getObjectState(virtual))) {
1019                             compatible = false;
1020                             break;
1021                         }
1022                     }
1023                     if (compatible) {
1024                         for (int i = 0; i &lt; states.length; i++) {
1025                             VirtualObjectNode virtual = virtualObjs[i];
1026                             /*
1027                              * check whether we trivially see that this is the only reference to
1028                              * this allocation
1029                              */
1030                             if (virtual.hasIdentity() &amp;&amp; !isSingleUsageAllocation(getPhiValueAt(phi, i), virtualObjs, states[i])) {
1031                                 compatible = false;

1032                             }
1033                         }
1034                     }
1035                     if (compatible) {
1036                         VirtualObjectNode virtual = getValueObjectVirtual(phi, virtualObjs[0]);
1037                         mergeEffects.addFloatingNode(virtual, &quot;valueObjectNode&quot;);
1038                         mergeEffects.deleteNode(phi);
1039                         if (virtual.getObjectId() == -1) {
1040                             int id = virtualObjects.size();
1041                             virtualObjects.add(virtual);
1042                             virtual.setObjectId(id);
1043                         }
1044 
1045                         int[] virtualObjectIds = new int[states.length];
1046                         for (int i = 0; i &lt; states.length; i++) {
1047                             virtualObjectIds[i] = virtualObjs[i].getObjectId();
1048                         }
1049                         boolean materialized = mergeObjectStates(virtual.getObjectId(), virtualObjectIds, states);
1050                         addVirtualAlias(virtual, virtual);
1051                         addVirtualAlias(virtual, phi);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  42 import org.graalvm.compiler.debug.DebugContext;
  43 import org.graalvm.compiler.graph.Node;
  44 import org.graalvm.compiler.graph.NodeBitMap;
  45 import org.graalvm.compiler.graph.Position;
  46 import org.graalvm.compiler.graph.spi.Canonicalizable;
  47 import org.graalvm.compiler.nodes.AbstractEndNode;
  48 import org.graalvm.compiler.nodes.CallTargetNode;
  49 import org.graalvm.compiler.nodes.ConstantNode;
  50 import org.graalvm.compiler.nodes.ControlSinkNode;
  51 import org.graalvm.compiler.nodes.FixedNode;
  52 import org.graalvm.compiler.nodes.FixedWithNextNode;
  53 import org.graalvm.compiler.nodes.FrameState;
  54 import org.graalvm.compiler.nodes.Invoke;
  55 import org.graalvm.compiler.nodes.LoopBeginNode;
  56 import org.graalvm.compiler.nodes.LoopExitNode;
  57 import org.graalvm.compiler.nodes.NodeView;
  58 import org.graalvm.compiler.nodes.PhiNode;
  59 import org.graalvm.compiler.nodes.ProxyNode;
  60 import org.graalvm.compiler.nodes.StructuredGraph;
  61 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
<span class="line-added">  62 import org.graalvm.compiler.nodes.UnwindNode;</span>
  63 import org.graalvm.compiler.nodes.ValueNode;
  64 import org.graalvm.compiler.nodes.ValuePhiNode;
  65 import org.graalvm.compiler.nodes.ValueProxyNode;
  66 import org.graalvm.compiler.nodes.VirtualState;
  67 import org.graalvm.compiler.nodes.VirtualState.NodeClosure;
  68 import org.graalvm.compiler.nodes.cfg.Block;
  69 import org.graalvm.compiler.nodes.spi.LoweringProvider;
  70 import org.graalvm.compiler.nodes.spi.NodeWithState;
  71 import org.graalvm.compiler.nodes.spi.Virtualizable;
  72 import org.graalvm.compiler.nodes.spi.VirtualizableAllocation;
  73 import org.graalvm.compiler.nodes.spi.VirtualizerTool;
  74 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
  75 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  76 import org.graalvm.compiler.virtual.nodes.VirtualObjectState;
  77 
  78 import jdk.vm.ci.meta.ConstantReflectionProvider;
  79 import jdk.vm.ci.meta.JavaConstant;
  80 import jdk.vm.ci.meta.JavaKind;
  81 import jdk.vm.ci.meta.MetaAccessProvider;
  82 
</pre>
<hr />
<pre>
  89     public static final CounterKey COUNTER_MATERIALIZATIONS_LOOP_REITERATION = DebugContext.counter(&quot;MaterializationsLoopReiteration&quot;);
  90     public static final CounterKey COUNTER_MATERIALIZATIONS_LOOP_END = DebugContext.counter(&quot;MaterializationsLoopEnd&quot;);
  91     public static final CounterKey COUNTER_ALLOCATION_REMOVED = DebugContext.counter(&quot;AllocationsRemoved&quot;);
  92     public static final CounterKey COUNTER_MEMORYCHECKPOINT = DebugContext.counter(&quot;MemoryCheckpoint&quot;);
  93 
  94     /**
  95      * Nodes with inputs that were modified during analysis are marked in this bitset - this way
  96      * nodes that are not influenced at all by analysis can be rejected quickly.
  97      */
  98     private final NodeBitMap hasVirtualInputs;
  99 
 100     /**
 101      * This is handed out to implementers of {@link Virtualizable}.
 102      */
 103     protected final VirtualizerToolImpl tool;
 104 
 105     /**
 106      * The indexes into this array correspond to {@link VirtualObjectNode#getObjectId()}.
 107      */
 108     public final ArrayList&lt;VirtualObjectNode&gt; virtualObjects = new ArrayList&lt;&gt;();

 109 
 110     @Override
 111     public boolean needsApplyEffects() {
 112         if (hasChanged()) {
 113             return true;
 114         }
 115         /*
 116          * If there is a mismatch between the number of materializations and the number of
 117          * virtualizations, we need to apply effects, even if there were no other significant
 118          * changes to the graph. This applies to each block, since moving from one block to the
 119          * other can also be important (if the probabilities of the block differ).
 120          */
 121         for (Block block : cfg.getBlocks()) {
 122             GraphEffectList effects = blockEffects.get(block);
 123             if (effects != null) {
 124                 if (effects.getVirtualizationDelta() != 0) {
 125                     return true;
 126                 }
 127             }
 128         }
</pre>
<hr />
<pre>
 172         @Override
 173         protected PartialEscapeBlockState.Final getInitialState() {
 174             return new PartialEscapeBlockState.Final(tool.getOptions(), tool.getDebug());
 175         }
 176 
 177         @Override
 178         protected PartialEscapeBlockState.Final cloneState(PartialEscapeBlockState.Final oldState) {
 179             return new PartialEscapeBlockState.Final(oldState);
 180         }
 181     }
 182 
 183     public PartialEscapeClosure(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider) {
 184         this(schedule, metaAccess, constantReflection, constantFieldProvider, null);
 185     }
 186 
 187     public PartialEscapeClosure(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,
 188                     LoweringProvider loweringProvider) {
 189         super(schedule, schedule.getCFG());
 190         StructuredGraph graph = schedule.getCFG().graph;
 191         this.hasVirtualInputs = graph.createNodeBitMap();

 192         this.tool = new VirtualizerToolImpl(metaAccess, constantReflection, constantFieldProvider, this, graph.getAssumptions(), graph.getOptions(), debug, loweringProvider);
 193     }
 194 
 195     /**
 196      * @return true if the node was deleted, false otherwise
 197      */
 198     @Override
 199     protected boolean processNode(Node node, BlockT state, GraphEffectList effects, FixedWithNextNode lastFixedNode) {
 200         /*
 201          * These checks make up for the fact that an earliest schedule moves CallTargetNodes upwards
 202          * and thus materializes virtual objects needlessly. Also, FrameStates and ConstantNodes are
 203          * scheduled, but can safely be ignored.
 204          */
 205         if (node instanceof CallTargetNode || node instanceof FrameState || node instanceof ConstantNode) {
 206             return false;
 207         } else if (node instanceof Invoke) {
 208             processNodeInternal(((Invoke) node).callTarget(), state, effects, lastFixedNode);
 209         }
 210         return processNodeInternal(node, state, effects, lastFixedNode);
 211     }
</pre>
<hr />
<pre>
 669         /**
 670          * Merge all predecessor block states into one block state. This is an iterative process,
 671          * because merging states can lead to materializations which make previous parts of the
 672          * merging operation invalid. The merging process is executed until a stable state has been
 673          * reached. This method needs to be careful to place the effects of the merging operation
 674          * into the correct blocks.
 675          *
 676          * @param statesList the predecessor block states of the merge
 677          */
 678         @Override
 679         protected void merge(List&lt;BlockT&gt; statesList) {
 680 
 681             PartialEscapeBlockState&lt;?&gt;[] states = new PartialEscapeBlockState&lt;?&gt;[statesList.size()];
 682             for (int i = 0; i &lt; statesList.size(); i++) {
 683                 states[i] = statesList.get(i);
 684             }
 685 
 686             // calculate the set of virtual objects that exist in all predecessors
 687             int[] virtualObjTemp = intersectVirtualObjects(states);
 688 
<span class="line-added"> 689             boolean forceMaterialization = false;</span>
<span class="line-added"> 690             ValueNode forcedMaterializationValue = null;</span>
<span class="line-added"> 691             FrameState frameState = merge.stateAfter();</span>
<span class="line-added"> 692             if (frameState != null &amp;&amp; frameState.isExceptionHandlingBCI()) {</span>
<span class="line-added"> 693                 // We can not go below merges with an exception handling bci</span>
<span class="line-added"> 694                 // it could create allocations whose slow-path has an invalid framestate</span>
<span class="line-added"> 695                 forceMaterialization = true;</span>
<span class="line-added"> 696                 // check if we can reduce the scope of forced materialization to one phi node</span>
<span class="line-added"> 697                 if (frameState.stackSize() == 1 &amp;&amp; merge.next() instanceof UnwindNode) {</span>
<span class="line-added"> 698                     assert frameState.outerFrameState() == null;</span>
<span class="line-added"> 699                     UnwindNode unwind = (UnwindNode) merge.next();</span>
<span class="line-added"> 700                     if (unwind.exception() == frameState.stackAt(0)) {</span>
<span class="line-added"> 701                         boolean nullLocals = true;</span>
<span class="line-added"> 702                         for (int i = 0; i &lt; frameState.localsSize(); i++) {</span>
<span class="line-added"> 703                             if (frameState.localAt(i) != null) {</span>
<span class="line-added"> 704                                 nullLocals = false;</span>
<span class="line-added"> 705                                 break;</span>
<span class="line-added"> 706                             }</span>
<span class="line-added"> 707                         }</span>
<span class="line-added"> 708                         if (nullLocals) {</span>
<span class="line-added"> 709                             // We found that the merge is directly followed by an unwind</span>
<span class="line-added"> 710                             // the Framestate only has the thrown value on the stack and no locals</span>
<span class="line-added"> 711                             forcedMaterializationValue = unwind.exception();</span>
<span class="line-added"> 712                         }</span>
<span class="line-added"> 713                     }</span>
<span class="line-added"> 714                 }</span>
<span class="line-added"> 715             }</span>
<span class="line-added"> 716 </span>
 717             boolean materialized;
 718             do {
 719                 materialized = false;
 720 
<span class="line-modified"> 721                 if (!forceMaterialization &amp;&amp; PartialEscapeBlockState.identicalObjectStates(states)) {</span>
 722                     newState.adoptAddObjectStates(states[0]);
 723                 } else {
 724 
 725                     for (int object : virtualObjTemp) {
<span class="line-modified"> 726                         if (!forceMaterialization &amp;&amp; PartialEscapeBlockState.identicalObjectStates(states, object)) {</span>
 727                             newState.addObject(object, states[0].getObjectState(object).share());
 728                             continue;
 729                         }
 730 
 731                         // determine if all inputs are virtual or the same materialized value
 732                         int virtualCount = 0;
 733                         ObjectState startObj = states[0].getObjectState(object);
 734                         boolean locksMatch = true;
 735                         boolean ensureVirtual = true;
 736                         ValueNode uniqueMaterializedValue = startObj.isVirtual() ? null : startObj.getMaterializedValue();
 737                         for (int i = 0; i &lt; states.length; i++) {
 738                             ObjectState obj = states[i].getObjectState(object);
 739                             ensureVirtual &amp;= obj.getEnsureVirtualized();
<span class="line-added"> 740                             if (forceMaterialization) {</span>
<span class="line-added"> 741                                 if (forcedMaterializationValue == null) {</span>
<span class="line-added"> 742                                     uniqueMaterializedValue = null;</span>
<span class="line-added"> 743                                     continue;</span>
<span class="line-added"> 744                                 } else {</span>
<span class="line-added"> 745                                     ValueNode value = forcedMaterializationValue;</span>
<span class="line-added"> 746                                     if (merge.isPhiAtMerge(value)) {</span>
<span class="line-added"> 747                                         value = ((ValuePhiNode) value).valueAt(i);</span>
<span class="line-added"> 748                                     }</span>
<span class="line-added"> 749                                     ValueNode alias = getAlias(value);</span>
<span class="line-added"> 750                                     if (alias instanceof VirtualObjectNode &amp;&amp; ((VirtualObjectNode) alias).getObjectId() == object) {</span>
<span class="line-added"> 751                                         uniqueMaterializedValue = null;</span>
<span class="line-added"> 752                                         continue;</span>
<span class="line-added"> 753                                     }</span>
<span class="line-added"> 754                                 }</span>
<span class="line-added"> 755                             }</span>
 756                             if (obj.isVirtual()) {
 757                                 virtualCount++;
 758                                 uniqueMaterializedValue = null;
 759                                 locksMatch &amp;= obj.locksEqual(startObj);
 760                             } else if (obj.getMaterializedValue() != uniqueMaterializedValue) {
 761                                 uniqueMaterializedValue = null;
 762                             }
 763                         }
 764 
 765                         if (virtualCount == states.length &amp;&amp; locksMatch) {
 766                             materialized |= mergeObjectStates(object, null, states);
 767                         } else {
 768                             if (uniqueMaterializedValue != null) {
 769                                 newState.addObject(object, new ObjectState(uniqueMaterializedValue, null, ensureVirtual));
 770                             } else {
 771                                 PhiNode materializedValuePhi = getPhi(object, StampFactory.forKind(JavaKind.Object));
 772                                 mergeEffects.addFloatingNode(materializedValuePhi, &quot;materializedPhi&quot;);
 773                                 for (int i = 0; i &lt; states.length; i++) {
 774                                     ObjectState obj = states[i].getObjectState(object);
 775                                     if (obj.isVirtual()) {
</pre>
<hr />
<pre>
1055                         VirtualObjectNode virtual = virtualObjs[i];
1056 
1057                         if (!firstVirtual.type().equals(virtual.type()) || firstVirtual.entryCount() != virtual.entryCount()) {
1058                             compatible = false;
1059                             break;
1060                         }
1061                         if (!states[0].getObjectState(firstVirtual).locksEqual(states[i].getObjectState(virtual))) {
1062                             compatible = false;
1063                             break;
1064                         }
1065                     }
1066                     if (compatible) {
1067                         for (int i = 0; i &lt; states.length; i++) {
1068                             VirtualObjectNode virtual = virtualObjs[i];
1069                             /*
1070                              * check whether we trivially see that this is the only reference to
1071                              * this allocation
1072                              */
1073                             if (virtual.hasIdentity() &amp;&amp; !isSingleUsageAllocation(getPhiValueAt(phi, i), virtualObjs, states[i])) {
1074                                 compatible = false;
<span class="line-added">1075                                 break;</span>
1076                             }
1077                         }
1078                     }
1079                     if (compatible) {
1080                         VirtualObjectNode virtual = getValueObjectVirtual(phi, virtualObjs[0]);
1081                         mergeEffects.addFloatingNode(virtual, &quot;valueObjectNode&quot;);
1082                         mergeEffects.deleteNode(phi);
1083                         if (virtual.getObjectId() == -1) {
1084                             int id = virtualObjects.size();
1085                             virtualObjects.add(virtual);
1086                             virtual.setObjectId(id);
1087                         }
1088 
1089                         int[] virtualObjectIds = new int[states.length];
1090                         for (int i = 0; i &lt; states.length; i++) {
1091                             virtualObjectIds[i] = virtualObjs[i].getObjectId();
1092                         }
1093                         boolean materialized = mergeObjectStates(virtual.getObjectId(), virtualObjectIds, states);
1094                         addVirtualAlias(virtual, virtual);
1095                         addVirtualAlias(virtual, phi);
</pre>
</td>
</tr>
</table>
<center><a href="PEReadEliminationClosure.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PartialEscapePhase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
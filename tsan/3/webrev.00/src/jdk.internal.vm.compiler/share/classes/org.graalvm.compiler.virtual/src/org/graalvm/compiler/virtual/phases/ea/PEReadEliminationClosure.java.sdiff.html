<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/PEReadEliminationClosure.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraphEffectList.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PartialEscapeClosure.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/PEReadEliminationClosure.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
104         }
105 
106         if (node instanceof LoadFieldNode) {
107             return processLoadField((LoadFieldNode) node, state, effects);
108         } else if (node instanceof StoreFieldNode) {
109             return processStoreField((StoreFieldNode) node, state, effects);
110         } else if (node instanceof LoadIndexedNode) {
111             return processLoadIndexed((LoadIndexedNode) node, state, effects);
112         } else if (node instanceof StoreIndexedNode) {
113             return processStoreIndexed((StoreIndexedNode) node, state, effects);
114         } else if (node instanceof ArrayLengthNode) {
115             return processArrayLength((ArrayLengthNode) node, state, effects);
116         } else if (node instanceof UnboxNode) {
117             return processUnbox((UnboxNode) node, state, effects);
118         } else if (node instanceof RawLoadNode) {
119             return processUnsafeLoad((RawLoadNode) node, state, effects);
120         } else if (node instanceof RawStoreNode) {
121             return processUnsafeStore((RawStoreNode) node, state, effects);
122         } else if (node instanceof MemoryCheckpoint.Single) {
123             COUNTER_MEMORYCHECKPOINT.increment(node.getDebug());
<span class="line-modified">124             LocationIdentity identity = ((MemoryCheckpoint.Single) node).getLocationIdentity();</span>
125             processIdentity(state, identity);
126         } else if (node instanceof MemoryCheckpoint.Multi) {
127             COUNTER_MEMORYCHECKPOINT.increment(node.getDebug());
<span class="line-modified">128             for (LocationIdentity identity : ((MemoryCheckpoint.Multi) node).getLocationIdentities()) {</span>
129                 processIdentity(state, identity);
130             }
131         }
132 
133         return false;
134     }
135 
136     private boolean processStore(FixedNode store, ValueNode object, LocationIdentity identity, int index, JavaKind accessKind, boolean overflowAccess, ValueNode value,
137                     PEReadEliminationBlockState state, GraphEffectList effects) {
138         ValueNode unproxiedObject = GraphUtil.unproxify(object);
139         ValueNode cachedValue = state.getReadCache(object, identity, index, accessKind, this);
140 
141         ValueNode finalValue = getScalarAlias(value);
142         boolean result = false;
143         if (GraphUtil.unproxify(finalValue) == GraphUtil.unproxify(cachedValue)) {
144             effects.deleteNode(store);
145             result = true;
146         }
147         state.killReadCache(identity, index);
148         state.addReadCache(unproxiedObject, identity, index, accessKind, overflowAccess, finalValue, this);
</pre>
<hr />
<pre>
200                         return true;
201                     } else {
202                         state.addReadCache(object, location, index, accessKind, isOverflowAccess(accessKind, componentKind), load, this);
203                     }
204                 }
205             }
206         }
207         return false;
208     }
209 
210     private boolean processUnsafeStore(RawStoreNode store, PEReadEliminationBlockState state, GraphEffectList effects) {
211         ResolvedJavaType type = StampTool.typeOrNull(store.object());
212         if (type != null &amp;&amp; type.isArray()) {
213             JavaKind accessKind = store.accessKind();
214             JavaKind componentKind = type.getComponentType().getJavaKind();
215             LocationIdentity location = NamedLocationIdentity.getArrayLocation(componentKind);
216             if (store.offset().isConstant()) {
217                 long offset = store.offset().asJavaConstant().asLong();
218                 boolean overflowAccess = isOverflowAccess(accessKind, componentKind);
219                 int index = overflowAccess ? -1 : VirtualArrayNode.entryIndexForOffset(tool.getMetaAccess(), offset, accessKind, type.getComponentType(), Integer.MAX_VALUE);
<span class="line-modified">220                 return processStore(store, store.object(), location, index, accessKind, overflowAccess, store.value(), state, effects);</span>




221             } else {
222                 processIdentity(state, location);
223             }
224         } else {
225             state.killReadCache();
226         }
227         return false;
228     }
229 
230     private boolean processArrayLength(ArrayLengthNode length, PEReadEliminationBlockState state, GraphEffectList effects) {
231         return processLoad(length, length.array(), ARRAY_LENGTH_LOCATION, -1, JavaKind.Int, state, effects);
232     }
233 
234     private boolean processStoreField(StoreFieldNode store, PEReadEliminationBlockState state, GraphEffectList effects) {
235         if (store.isVolatile()) {
236             state.killReadCache();
237             return false;
238         }
239         JavaKind kind = store.field().getJavaKind();
240         return processStore(store, store.object(), new FieldLocationIdentity(store.field()), -1, kind, false, store.value(), state, effects);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
104         }
105 
106         if (node instanceof LoadFieldNode) {
107             return processLoadField((LoadFieldNode) node, state, effects);
108         } else if (node instanceof StoreFieldNode) {
109             return processStoreField((StoreFieldNode) node, state, effects);
110         } else if (node instanceof LoadIndexedNode) {
111             return processLoadIndexed((LoadIndexedNode) node, state, effects);
112         } else if (node instanceof StoreIndexedNode) {
113             return processStoreIndexed((StoreIndexedNode) node, state, effects);
114         } else if (node instanceof ArrayLengthNode) {
115             return processArrayLength((ArrayLengthNode) node, state, effects);
116         } else if (node instanceof UnboxNode) {
117             return processUnbox((UnboxNode) node, state, effects);
118         } else if (node instanceof RawLoadNode) {
119             return processUnsafeLoad((RawLoadNode) node, state, effects);
120         } else if (node instanceof RawStoreNode) {
121             return processUnsafeStore((RawStoreNode) node, state, effects);
122         } else if (node instanceof MemoryCheckpoint.Single) {
123             COUNTER_MEMORYCHECKPOINT.increment(node.getDebug());
<span class="line-modified">124             LocationIdentity identity = ((MemoryCheckpoint.Single) node).getKilledLocationIdentity();</span>
125             processIdentity(state, identity);
126         } else if (node instanceof MemoryCheckpoint.Multi) {
127             COUNTER_MEMORYCHECKPOINT.increment(node.getDebug());
<span class="line-modified">128             for (LocationIdentity identity : ((MemoryCheckpoint.Multi) node).getKilledLocationIdentities()) {</span>
129                 processIdentity(state, identity);
130             }
131         }
132 
133         return false;
134     }
135 
136     private boolean processStore(FixedNode store, ValueNode object, LocationIdentity identity, int index, JavaKind accessKind, boolean overflowAccess, ValueNode value,
137                     PEReadEliminationBlockState state, GraphEffectList effects) {
138         ValueNode unproxiedObject = GraphUtil.unproxify(object);
139         ValueNode cachedValue = state.getReadCache(object, identity, index, accessKind, this);
140 
141         ValueNode finalValue = getScalarAlias(value);
142         boolean result = false;
143         if (GraphUtil.unproxify(finalValue) == GraphUtil.unproxify(cachedValue)) {
144             effects.deleteNode(store);
145             result = true;
146         }
147         state.killReadCache(identity, index);
148         state.addReadCache(unproxiedObject, identity, index, accessKind, overflowAccess, finalValue, this);
</pre>
<hr />
<pre>
200                         return true;
201                     } else {
202                         state.addReadCache(object, location, index, accessKind, isOverflowAccess(accessKind, componentKind), load, this);
203                     }
204                 }
205             }
206         }
207         return false;
208     }
209 
210     private boolean processUnsafeStore(RawStoreNode store, PEReadEliminationBlockState state, GraphEffectList effects) {
211         ResolvedJavaType type = StampTool.typeOrNull(store.object());
212         if (type != null &amp;&amp; type.isArray()) {
213             JavaKind accessKind = store.accessKind();
214             JavaKind componentKind = type.getComponentType().getJavaKind();
215             LocationIdentity location = NamedLocationIdentity.getArrayLocation(componentKind);
216             if (store.offset().isConstant()) {
217                 long offset = store.offset().asJavaConstant().asLong();
218                 boolean overflowAccess = isOverflowAccess(accessKind, componentKind);
219                 int index = overflowAccess ? -1 : VirtualArrayNode.entryIndexForOffset(tool.getMetaAccess(), offset, accessKind, type.getComponentType(), Integer.MAX_VALUE);
<span class="line-modified">220                 if (index != -1) {</span>
<span class="line-added">221                     return processStore(store, store.object(), location, index, accessKind, overflowAccess, store.value(), state, effects);</span>
<span class="line-added">222                 } else {</span>
<span class="line-added">223                     state.killReadCache(location, index);</span>
<span class="line-added">224                 }</span>
225             } else {
226                 processIdentity(state, location);
227             }
228         } else {
229             state.killReadCache();
230         }
231         return false;
232     }
233 
234     private boolean processArrayLength(ArrayLengthNode length, PEReadEliminationBlockState state, GraphEffectList effects) {
235         return processLoad(length, length.array(), ARRAY_LENGTH_LOCATION, -1, JavaKind.Int, state, effects);
236     }
237 
238     private boolean processStoreField(StoreFieldNode store, PEReadEliminationBlockState state, GraphEffectList effects) {
239         if (store.isVolatile()) {
240             state.killReadCache();
241             return false;
242         }
243         JavaKind kind = store.field().getJavaKind();
244         return processStore(store, store.object(), new FieldLocationIdentity(store.field()), -1, kind, false, store.value(), state, effects);
</pre>
</td>
</tr>
</table>
<center><a href="GraphEffectList.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PartialEscapeClosure.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
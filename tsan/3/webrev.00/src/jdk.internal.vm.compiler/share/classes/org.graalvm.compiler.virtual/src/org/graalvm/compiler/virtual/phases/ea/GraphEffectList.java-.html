<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/GraphEffectList.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.virtual.phases.ea;
 26 
 27 import java.util.ArrayList;
 28 
 29 import org.graalvm.compiler.debug.DebugContext;
 30 import org.graalvm.compiler.graph.Node;
 31 import org.graalvm.compiler.nodes.ControlSinkNode;
 32 import org.graalvm.compiler.nodes.FixedNode;
 33 import org.graalvm.compiler.nodes.FixedWithNextNode;
 34 import org.graalvm.compiler.nodes.FrameState;
 35 import org.graalvm.compiler.nodes.IfNode;
 36 import org.graalvm.compiler.nodes.NodeView;
 37 import org.graalvm.compiler.nodes.PhiNode;
 38 import org.graalvm.compiler.nodes.PiNode;
 39 import org.graalvm.compiler.nodes.StructuredGraph;
 40 import org.graalvm.compiler.nodes.ValueNode;
 41 import org.graalvm.compiler.nodes.debug.DynamicCounterNode;
 42 import org.graalvm.compiler.nodes.debug.WeakCounterNode;
 43 import org.graalvm.compiler.nodes.util.GraphUtil;
 44 import org.graalvm.compiler.nodes.virtual.EscapeObjectState;
 45 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 46 
 47 public final class GraphEffectList extends EffectList {
 48 
 49     public GraphEffectList(DebugContext debug) {
 50         super(debug);
 51     }
 52 
 53     /**
 54      * Determines how many objects are virtualized (positive) or materialized (negative) by this
 55      * effect.
 56      */
 57     private int virtualizationDelta;
 58 
 59     @Override
 60     public void clear() {
 61         super.clear();
 62         virtualizationDelta = 0;
 63     }
 64 
 65     public void addCounterBefore(String group, String name, int increment, boolean addContext, FixedNode position) {
 66         add(&quot;add counter&quot;, graph -&gt; DynamicCounterNode.addCounterBefore(group, name, increment, addContext, position));
 67     }
 68 
 69     public void addCounterAfter(String group, String name, int increment, boolean addContext, FixedWithNextNode position) {
 70         FixedNode nextPosition = position.next();
 71         add(&quot;add counter after&quot;, graph -&gt; DynamicCounterNode.addCounterBefore(group, name, increment, addContext, nextPosition));
 72     }
 73 
 74     public void addWeakCounterCounterBefore(String group, String name, int increment, boolean addContext, ValueNode checkedValue, FixedNode position) {
 75         add(&quot;add weak counter&quot;, graph -&gt; WeakCounterNode.addCounterBefore(group, name, increment, addContext, checkedValue, position));
 76     }
 77 
 78     /**
 79      * Adds the given fixed node to the graph&#39;s control flow, before position (so that the original
 80      * predecessor of position will then be node&#39;s predecessor).
 81      *
 82      * @param node The fixed node to be added to the graph.
 83      * @param position The fixed node before which the node should be added.
 84      */
 85     public void addFixedNodeBefore(FixedWithNextNode node, FixedNode position) {
 86         add(&quot;add fixed node&quot;, graph -&gt; {
 87             assert !node.isAlive() &amp;&amp; !node.isDeleted() &amp;&amp; position.isAlive();
 88             graph.addBeforeFixed(position, graph.add(node));
 89         });
 90     }
 91 
 92     public void ensureAdded(ValueNode node, FixedNode position) {
 93         add(&quot;ensure added&quot;, graph -&gt; {
 94             assert position.isAlive();
 95             assert node instanceof FixedNode;
 96             if (!node.isAlive()) {
 97                 graph.addOrUniqueWithInputs(node);
 98                 if (node instanceof FixedWithNextNode) {
 99                     graph.addBeforeFixed(position, (FixedWithNextNode) node);
100                 }
101             }
102         });
103     }
104 
105     public void addVirtualizationDelta(int delta) {
106         virtualizationDelta += delta;
107     }
108 
109     public int getVirtualizationDelta() {
110         return virtualizationDelta;
111     }
112 
113     /**
114      * Add the given floating node to the graph.
115      *
116      * @param node The floating node to be added.
117      */
118     public void addFloatingNode(ValueNode node, @SuppressWarnings(&quot;unused&quot;) String cause) {
119         add(&quot;add floating node&quot;, graph -&gt; {
120             graph.addWithoutUniqueWithInputs(node);
121         });
122     }
123 
124     /**
125      * Sets the phi node&#39;s input at the given index to the given value, adding new phi inputs as
126      * needed.
127      *
128      * @param node The phi node whose input should be changed.
129      * @param index The index of the phi input to be changed.
130      * @param value The new value for the phi input.
131      */
132     public void initializePhiInput(PhiNode node, int index, ValueNode value) {
133         add(&quot;set phi input&quot;, (graph, obsoleteNodes) -&gt; {
134             assert node.isAlive() &amp;&amp; index &gt;= 0;
135             node.initializeValueAt(index, graph.addOrUniqueWithInputs(value));
136         });
137     }
138 
139     /**
140      * Adds a virtual object&#39;s state to the given frame state. If the given reusedVirtualObjects set
141      * contains the virtual object then old states for this object will be removed.
142      *
143      * @param node The frame state to which the state should be added.
144      * @param state The virtual object state to add.
145      */
146     public void addVirtualMapping(FrameState node, EscapeObjectState state) {
147         add(&quot;add virtual mapping&quot;, new Effect() {
148             @Override
149             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
150                 if (node.isAlive()) {
151                     assert !state.isDeleted();
152                     FrameState stateAfter = node;
153                     for (int i = 0; i &lt; stateAfter.virtualObjectMappingCount(); i++) {
154                         if (stateAfter.virtualObjectMappingAt(i).object() == state.object()) {
155                             stateAfter.virtualObjectMappings().remove(i);
156                         }
157                     }
158                     stateAfter.addVirtualObjectMapping(graph.addOrUniqueWithInputs(state));
159                 }
160             }
161 
162             @Override
163             public boolean isVisible() {
164                 return false;
165             }
166         });
167     }
168 
169     /**
170      * Removes the given fixed node from the control flow and deletes it.
171      *
172      * @param node The fixed node that should be deleted.
173      */
174     public void deleteNode(Node node) {
175         add(&quot;delete fixed node&quot;, (graph, obsoleteNodes) -&gt; {
176             if (node instanceof FixedWithNextNode) {
177                 GraphUtil.unlinkFixedNode((FixedWithNextNode) node);
178             }
179             obsoleteNodes.add(node);
180         });
181     }
182 
183     public void killIfBranch(IfNode ifNode, boolean constantCondition) {
184         add(&quot;kill if branch&quot;, new Effect() {
185             @Override
186             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
187                 graph.removeSplitPropagate(ifNode, ifNode.getSuccessor(constantCondition));
188             }
189 
190             @Override
191             public boolean isCfgKill() {
192                 return true;
193             }
194         });
195     }
196 
197     public void replaceWithSink(FixedWithNextNode node, ControlSinkNode sink) {
198         add(&quot;kill if branch&quot;, new Effect() {
199             @Override
200             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
201                 graph.addWithoutUnique(sink);
202                 node.replaceAtPredecessor(sink);
203                 GraphUtil.killCFG(node);
204             }
205 
206             @Override
207             public boolean isCfgKill() {
208                 return true;
209             }
210         });
211     }
212 
213     /**
214      * Replaces the given node at its usages without deleting it. If the current node is a fixed
215      * node it will be disconnected from the control flow, so that it will be deleted by a
216      * subsequent {@link DeadCodeEliminationPhase}
217      *
218      * @param node The node to be replaced.
219      * @param replacement The node that should replace the original value. If the replacement is a
220      *            non-connected {@link FixedWithNextNode} it will be added to the control flow.
221      * @param insertBefore
222      *
223      */
224     public void replaceAtUsages(ValueNode node, ValueNode replacement, FixedNode insertBefore) {
225         assert node != null &amp;&amp; replacement != null : node + &quot; &quot; + replacement;
226         assert node.stamp(NodeView.DEFAULT).isCompatible(replacement.stamp(NodeView.DEFAULT)) : &quot;Replacement node stamp not compatible &quot; + node.stamp(NodeView.DEFAULT) + &quot; vs &quot; +
227                         replacement.stamp(NodeView.DEFAULT);
228         add(&quot;replace at usages&quot;, (graph, obsoleteNodes) -&gt; {
229             assert node.isAlive();
230             ValueNode replacementNode = graph.addOrUniqueWithInputs(replacement);
231             assert replacementNode.isAlive();
232             assert insertBefore != null;
233             if (replacementNode instanceof FixedWithNextNode &amp;&amp; ((FixedWithNextNode) replacementNode).next() == null) {
234                 graph.addBeforeFixed(insertBefore, (FixedWithNextNode) replacementNode);
235             }
236             /*
237              * Keep the (better) stamp information when replacing a node with another one if the
238              * replacement has a less precise stamp than the original node. This can happen for
239              * example in the context of read nodes and unguarded pi nodes where the pi will be used
240              * to improve the stamp information of the read. Such a read might later be replaced
241              * with a read with a less precise stamp.
242              */
243             if (!node.stamp(NodeView.DEFAULT).equals(replacementNode.stamp(NodeView.DEFAULT))) {
244                 replacementNode = graph.unique(new PiNode(replacementNode, node.stamp(NodeView.DEFAULT)));
245             }
246             node.replaceAtUsages(replacementNode);
247             if (node instanceof FixedWithNextNode) {
248                 GraphUtil.unlinkFixedNode((FixedWithNextNode) node);
249             }
250             obsoleteNodes.add(node);
251         });
252     }
253 
254     /**
255      * Replaces the first occurrence of oldInput in node with newInput.
256      *
257      * @param node The node whose input should be changed.
258      * @param oldInput The value to look for.
259      * @param newInput The value to replace with.
260      */
261     public void replaceFirstInput(Node node, Node oldInput, Node newInput) {
262         assert node.isAlive() &amp;&amp; oldInput.isAlive() &amp;&amp; !newInput.isDeleted();
263         add(&quot;replace first input&quot;, new Effect() {
264             @Override
265             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
266                 if (node.isAlive()) {
267                     assert oldInput.isAlive() &amp;&amp; newInput.isAlive();
268                     node.replaceFirstInput(oldInput, newInput);
269                 }
270             }
271 
272             @Override
273             public boolean isVisible() {
274                 return !(node instanceof FrameState);
275             }
276         });
277     }
278 }
    </pre>
  </body>
</html>
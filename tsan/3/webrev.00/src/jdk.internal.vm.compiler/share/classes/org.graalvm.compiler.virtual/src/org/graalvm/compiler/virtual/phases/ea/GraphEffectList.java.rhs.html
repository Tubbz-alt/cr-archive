<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/GraphEffectList.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.virtual.phases.ea;
 26 
 27 import java.util.ArrayList;
 28 
<a name="2" id="anc2"></a><span class="line-added"> 29 import org.graalvm.compiler.debug.DebugCloseable;</span>
 30 import org.graalvm.compiler.debug.DebugContext;
 31 import org.graalvm.compiler.graph.Node;
 32 import org.graalvm.compiler.nodes.ControlSinkNode;
 33 import org.graalvm.compiler.nodes.FixedNode;
 34 import org.graalvm.compiler.nodes.FixedWithNextNode;
 35 import org.graalvm.compiler.nodes.FrameState;
 36 import org.graalvm.compiler.nodes.IfNode;
 37 import org.graalvm.compiler.nodes.NodeView;
 38 import org.graalvm.compiler.nodes.PhiNode;
 39 import org.graalvm.compiler.nodes.PiNode;
 40 import org.graalvm.compiler.nodes.StructuredGraph;
 41 import org.graalvm.compiler.nodes.ValueNode;
 42 import org.graalvm.compiler.nodes.debug.DynamicCounterNode;
 43 import org.graalvm.compiler.nodes.debug.WeakCounterNode;
 44 import org.graalvm.compiler.nodes.util.GraphUtil;
 45 import org.graalvm.compiler.nodes.virtual.EscapeObjectState;
 46 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 47 
 48 public final class GraphEffectList extends EffectList {
 49 
 50     public GraphEffectList(DebugContext debug) {
 51         super(debug);
 52     }
 53 
 54     /**
 55      * Determines how many objects are virtualized (positive) or materialized (negative) by this
 56      * effect.
 57      */
 58     private int virtualizationDelta;
 59 
 60     @Override
 61     public void clear() {
 62         super.clear();
 63         virtualizationDelta = 0;
 64     }
 65 
 66     public void addCounterBefore(String group, String name, int increment, boolean addContext, FixedNode position) {
 67         add(&quot;add counter&quot;, graph -&gt; DynamicCounterNode.addCounterBefore(group, name, increment, addContext, position));
 68     }
 69 
 70     public void addCounterAfter(String group, String name, int increment, boolean addContext, FixedWithNextNode position) {
 71         FixedNode nextPosition = position.next();
 72         add(&quot;add counter after&quot;, graph -&gt; DynamicCounterNode.addCounterBefore(group, name, increment, addContext, nextPosition));
 73     }
 74 
 75     public void addWeakCounterCounterBefore(String group, String name, int increment, boolean addContext, ValueNode checkedValue, FixedNode position) {
 76         add(&quot;add weak counter&quot;, graph -&gt; WeakCounterNode.addCounterBefore(group, name, increment, addContext, checkedValue, position));
 77     }
 78 
 79     /**
 80      * Adds the given fixed node to the graph&#39;s control flow, before position (so that the original
 81      * predecessor of position will then be node&#39;s predecessor).
 82      *
 83      * @param node The fixed node to be added to the graph.
 84      * @param position The fixed node before which the node should be added.
 85      */
 86     public void addFixedNodeBefore(FixedWithNextNode node, FixedNode position) {
 87         add(&quot;add fixed node&quot;, graph -&gt; {
 88             assert !node.isAlive() &amp;&amp; !node.isDeleted() &amp;&amp; position.isAlive();
 89             graph.addBeforeFixed(position, graph.add(node));
 90         });
 91     }
 92 
 93     public void ensureAdded(ValueNode node, FixedNode position) {
 94         add(&quot;ensure added&quot;, graph -&gt; {
 95             assert position.isAlive();
 96             assert node instanceof FixedNode;
 97             if (!node.isAlive()) {
 98                 graph.addOrUniqueWithInputs(node);
 99                 if (node instanceof FixedWithNextNode) {
100                     graph.addBeforeFixed(position, (FixedWithNextNode) node);
101                 }
102             }
103         });
104     }
105 
106     public void addVirtualizationDelta(int delta) {
107         virtualizationDelta += delta;
108     }
109 
110     public int getVirtualizationDelta() {
111         return virtualizationDelta;
112     }
113 
114     /**
115      * Add the given floating node to the graph.
116      *
117      * @param node The floating node to be added.
118      */
119     public void addFloatingNode(ValueNode node, @SuppressWarnings(&quot;unused&quot;) String cause) {
120         add(&quot;add floating node&quot;, graph -&gt; {
121             graph.addWithoutUniqueWithInputs(node);
122         });
123     }
124 
125     /**
126      * Sets the phi node&#39;s input at the given index to the given value, adding new phi inputs as
127      * needed.
128      *
129      * @param node The phi node whose input should be changed.
130      * @param index The index of the phi input to be changed.
131      * @param value The new value for the phi input.
132      */
133     public void initializePhiInput(PhiNode node, int index, ValueNode value) {
134         add(&quot;set phi input&quot;, (graph, obsoleteNodes) -&gt; {
<a name="3" id="anc3"></a><span class="line-modified">135             assert node.isAlive() &amp;&amp; index &gt;= 0 : node;</span>
136             node.initializeValueAt(index, graph.addOrUniqueWithInputs(value));
137         });
138     }
139 
140     /**
141      * Adds a virtual object&#39;s state to the given frame state. If the given reusedVirtualObjects set
142      * contains the virtual object then old states for this object will be removed.
143      *
144      * @param node The frame state to which the state should be added.
145      * @param state The virtual object state to add.
146      */
147     public void addVirtualMapping(FrameState node, EscapeObjectState state) {
148         add(&quot;add virtual mapping&quot;, new Effect() {
149             @Override
150             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
151                 if (node.isAlive()) {
152                     assert !state.isDeleted();
153                     FrameState stateAfter = node;
154                     for (int i = 0; i &lt; stateAfter.virtualObjectMappingCount(); i++) {
155                         if (stateAfter.virtualObjectMappingAt(i).object() == state.object()) {
156                             stateAfter.virtualObjectMappings().remove(i);
157                         }
158                     }
159                     stateAfter.addVirtualObjectMapping(graph.addOrUniqueWithInputs(state));
160                 }
161             }
162 
163             @Override
164             public boolean isVisible() {
165                 return false;
166             }
167         });
168     }
169 
170     /**
171      * Removes the given fixed node from the control flow and deletes it.
172      *
173      * @param node The fixed node that should be deleted.
174      */
175     public void deleteNode(Node node) {
176         add(&quot;delete fixed node&quot;, (graph, obsoleteNodes) -&gt; {
177             if (node instanceof FixedWithNextNode) {
178                 GraphUtil.unlinkFixedNode((FixedWithNextNode) node);
179             }
180             obsoleteNodes.add(node);
181         });
182     }
183 
184     public void killIfBranch(IfNode ifNode, boolean constantCondition) {
185         add(&quot;kill if branch&quot;, new Effect() {
186             @Override
187             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
188                 graph.removeSplitPropagate(ifNode, ifNode.getSuccessor(constantCondition));
189             }
190 
191             @Override
192             public boolean isCfgKill() {
193                 return true;
194             }
195         });
196     }
197 
198     public void replaceWithSink(FixedWithNextNode node, ControlSinkNode sink) {
199         add(&quot;kill if branch&quot;, new Effect() {
<a name="4" id="anc4"></a><span class="line-added">200             @SuppressWarnings(&quot;try&quot;)</span>
201             @Override
202             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
<a name="5" id="anc5"></a><span class="line-modified">203                 try (DebugCloseable position = graph.withNodeSourcePosition(node)) {</span>
<span class="line-modified">204                     graph.addWithoutUnique(sink);</span>
<span class="line-modified">205                     node.replaceAtPredecessor(sink);</span>
<span class="line-added">206                     GraphUtil.killCFG(node);</span>
<span class="line-added">207                 }</span>
208             }
209 
210             @Override
211             public boolean isCfgKill() {
212                 return true;
213             }
214         });
215     }
216 
217     /**
218      * Replaces the given node at its usages without deleting it. If the current node is a fixed
219      * node it will be disconnected from the control flow, so that it will be deleted by a
220      * subsequent {@link DeadCodeEliminationPhase}
221      *
222      * @param node The node to be replaced.
223      * @param replacement The node that should replace the original value. If the replacement is a
224      *            non-connected {@link FixedWithNextNode} it will be added to the control flow.
225      * @param insertBefore
226      *
227      */
<a name="6" id="anc6"></a><span class="line-added">228     @SuppressWarnings(&quot;try&quot;)</span>
229     public void replaceAtUsages(ValueNode node, ValueNode replacement, FixedNode insertBefore) {
230         assert node != null &amp;&amp; replacement != null : node + &quot; &quot; + replacement;
<a name="7" id="anc7"></a><span class="line-modified">231         assert !node.hasUsages() || node.stamp(NodeView.DEFAULT).isCompatible(replacement.stamp(NodeView.DEFAULT)) : &quot;Replacement node stamp not compatible &quot; + node.stamp(NodeView.DEFAULT) + &quot; vs &quot; +</span>
232                         replacement.stamp(NodeView.DEFAULT);
233         add(&quot;replace at usages&quot;, (graph, obsoleteNodes) -&gt; {
<a name="8" id="anc8"></a><span class="line-modified">234             try (DebugCloseable position = graph.withNodeSourcePosition(node)) {</span>
<span class="line-modified">235                 assert node.isAlive();</span>
<span class="line-modified">236                 ValueNode replacementNode = graph.addOrUniqueWithInputs(replacement);</span>
<span class="line-modified">237                 assert replacementNode.isAlive();</span>
<span class="line-modified">238                 assert insertBefore != null;</span>
<span class="line-modified">239                 if (replacementNode instanceof FixedWithNextNode &amp;&amp; ((FixedWithNextNode) replacementNode).next() == null) {</span>
<span class="line-modified">240                     graph.addBeforeFixed(insertBefore, (FixedWithNextNode) replacementNode);</span>
<span class="line-modified">241                 }</span>
<span class="line-modified">242                 /*</span>
<span class="line-modified">243                  * Keep the (better) stamp information when replacing a node with another one if the</span>
<span class="line-modified">244                  * replacement has a less precise stamp than the original node. This can happen for</span>
<span class="line-modified">245                  * example in the context of read nodes and unguarded pi nodes where the pi will be</span>
<span class="line-modified">246                  * used to improve the stamp information of the read. Such a read might later be</span>
<span class="line-modified">247                  * replaced with a read with a less precise stamp.</span>
<span class="line-modified">248                  */</span>
<span class="line-modified">249                 if (node.hasUsages() &amp;&amp; !node.stamp(NodeView.DEFAULT).equals(replacementNode.stamp(NodeView.DEFAULT))) {</span>
<span class="line-modified">250                     replacementNode = graph.unique(new PiNode(replacementNode, node.stamp(NodeView.DEFAULT)));</span>
<span class="line-modified">251                 }</span>
<span class="line-modified">252                 node.replaceAtUsages(replacementNode);</span>
<span class="line-modified">253                 if (node instanceof FixedWithNextNode) {</span>
<span class="line-added">254                     GraphUtil.unlinkFixedNode((FixedWithNextNode) node);</span>
<span class="line-added">255                 }</span>
<span class="line-added">256                 obsoleteNodes.add(node);</span>
257             }
<a name="9" id="anc9"></a>
258         });
259     }
260 
261     /**
262      * Replaces the first occurrence of oldInput in node with newInput.
263      *
264      * @param node The node whose input should be changed.
265      * @param oldInput The value to look for.
266      * @param newInput The value to replace with.
267      */
268     public void replaceFirstInput(Node node, Node oldInput, Node newInput) {
269         assert node.isAlive() &amp;&amp; oldInput.isAlive() &amp;&amp; !newInput.isDeleted();
270         add(&quot;replace first input&quot;, new Effect() {
271             @Override
272             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
273                 if (node.isAlive()) {
274                     assert oldInput.isAlive() &amp;&amp; newInput.isAlive();
275                     node.replaceFirstInput(oldInput, newInput);
276                 }
277             }
278 
279             @Override
280             public boolean isVisible() {
281                 return !(node instanceof FrameState);
282             }
283         });
284     }
285 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
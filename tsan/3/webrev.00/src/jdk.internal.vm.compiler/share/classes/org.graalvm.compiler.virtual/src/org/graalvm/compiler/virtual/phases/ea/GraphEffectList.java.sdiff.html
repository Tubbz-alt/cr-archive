<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/GraphEffectList.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EffectsPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PEReadEliminationClosure.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/GraphEffectList.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.virtual.phases.ea;
 26 
 27 import java.util.ArrayList;
 28 

 29 import org.graalvm.compiler.debug.DebugContext;
 30 import org.graalvm.compiler.graph.Node;
 31 import org.graalvm.compiler.nodes.ControlSinkNode;
 32 import org.graalvm.compiler.nodes.FixedNode;
 33 import org.graalvm.compiler.nodes.FixedWithNextNode;
 34 import org.graalvm.compiler.nodes.FrameState;
 35 import org.graalvm.compiler.nodes.IfNode;
 36 import org.graalvm.compiler.nodes.NodeView;
 37 import org.graalvm.compiler.nodes.PhiNode;
 38 import org.graalvm.compiler.nodes.PiNode;
 39 import org.graalvm.compiler.nodes.StructuredGraph;
 40 import org.graalvm.compiler.nodes.ValueNode;
 41 import org.graalvm.compiler.nodes.debug.DynamicCounterNode;
 42 import org.graalvm.compiler.nodes.debug.WeakCounterNode;
 43 import org.graalvm.compiler.nodes.util.GraphUtil;
 44 import org.graalvm.compiler.nodes.virtual.EscapeObjectState;
 45 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 46 
 47 public final class GraphEffectList extends EffectList {
 48 
</pre>
<hr />
<pre>
114      * Add the given floating node to the graph.
115      *
116      * @param node The floating node to be added.
117      */
118     public void addFloatingNode(ValueNode node, @SuppressWarnings(&quot;unused&quot;) String cause) {
119         add(&quot;add floating node&quot;, graph -&gt; {
120             graph.addWithoutUniqueWithInputs(node);
121         });
122     }
123 
124     /**
125      * Sets the phi node&#39;s input at the given index to the given value, adding new phi inputs as
126      * needed.
127      *
128      * @param node The phi node whose input should be changed.
129      * @param index The index of the phi input to be changed.
130      * @param value The new value for the phi input.
131      */
132     public void initializePhiInput(PhiNode node, int index, ValueNode value) {
133         add(&quot;set phi input&quot;, (graph, obsoleteNodes) -&gt; {
<span class="line-modified">134             assert node.isAlive() &amp;&amp; index &gt;= 0;</span>
135             node.initializeValueAt(index, graph.addOrUniqueWithInputs(value));
136         });
137     }
138 
139     /**
140      * Adds a virtual object&#39;s state to the given frame state. If the given reusedVirtualObjects set
141      * contains the virtual object then old states for this object will be removed.
142      *
143      * @param node The frame state to which the state should be added.
144      * @param state The virtual object state to add.
145      */
146     public void addVirtualMapping(FrameState node, EscapeObjectState state) {
147         add(&quot;add virtual mapping&quot;, new Effect() {
148             @Override
149             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
150                 if (node.isAlive()) {
151                     assert !state.isDeleted();
152                     FrameState stateAfter = node;
153                     for (int i = 0; i &lt; stateAfter.virtualObjectMappingCount(); i++) {
154                         if (stateAfter.virtualObjectMappingAt(i).object() == state.object()) {
</pre>
<hr />
<pre>
179             obsoleteNodes.add(node);
180         });
181     }
182 
183     public void killIfBranch(IfNode ifNode, boolean constantCondition) {
184         add(&quot;kill if branch&quot;, new Effect() {
185             @Override
186             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
187                 graph.removeSplitPropagate(ifNode, ifNode.getSuccessor(constantCondition));
188             }
189 
190             @Override
191             public boolean isCfgKill() {
192                 return true;
193             }
194         });
195     }
196 
197     public void replaceWithSink(FixedWithNextNode node, ControlSinkNode sink) {
198         add(&quot;kill if branch&quot;, new Effect() {

199             @Override
200             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
<span class="line-modified">201                 graph.addWithoutUnique(sink);</span>
<span class="line-modified">202                 node.replaceAtPredecessor(sink);</span>
<span class="line-modified">203                 GraphUtil.killCFG(node);</span>


204             }
205 
206             @Override
207             public boolean isCfgKill() {
208                 return true;
209             }
210         });
211     }
212 
213     /**
214      * Replaces the given node at its usages without deleting it. If the current node is a fixed
215      * node it will be disconnected from the control flow, so that it will be deleted by a
216      * subsequent {@link DeadCodeEliminationPhase}
217      *
218      * @param node The node to be replaced.
219      * @param replacement The node that should replace the original value. If the replacement is a
220      *            non-connected {@link FixedWithNextNode} it will be added to the control flow.
221      * @param insertBefore
222      *
223      */

224     public void replaceAtUsages(ValueNode node, ValueNode replacement, FixedNode insertBefore) {
225         assert node != null &amp;&amp; replacement != null : node + &quot; &quot; + replacement;
<span class="line-modified">226         assert node.stamp(NodeView.DEFAULT).isCompatible(replacement.stamp(NodeView.DEFAULT)) : &quot;Replacement node stamp not compatible &quot; + node.stamp(NodeView.DEFAULT) + &quot; vs &quot; +</span>
227                         replacement.stamp(NodeView.DEFAULT);
228         add(&quot;replace at usages&quot;, (graph, obsoleteNodes) -&gt; {
<span class="line-modified">229             assert node.isAlive();</span>
<span class="line-modified">230             ValueNode replacementNode = graph.addOrUniqueWithInputs(replacement);</span>
<span class="line-modified">231             assert replacementNode.isAlive();</span>
<span class="line-modified">232             assert insertBefore != null;</span>
<span class="line-modified">233             if (replacementNode instanceof FixedWithNextNode &amp;&amp; ((FixedWithNextNode) replacementNode).next() == null) {</span>
<span class="line-modified">234                 graph.addBeforeFixed(insertBefore, (FixedWithNextNode) replacementNode);</span>
<span class="line-modified">235             }</span>
<span class="line-modified">236             /*</span>
<span class="line-modified">237              * Keep the (better) stamp information when replacing a node with another one if the</span>
<span class="line-modified">238              * replacement has a less precise stamp than the original node. This can happen for</span>
<span class="line-modified">239              * example in the context of read nodes and unguarded pi nodes where the pi will be used</span>
<span class="line-modified">240              * to improve the stamp information of the read. Such a read might later be replaced</span>
<span class="line-modified">241              * with a read with a less precise stamp.</span>
<span class="line-modified">242              */</span>
<span class="line-modified">243             if (!node.stamp(NodeView.DEFAULT).equals(replacementNode.stamp(NodeView.DEFAULT))) {</span>
<span class="line-modified">244                 replacementNode = graph.unique(new PiNode(replacementNode, node.stamp(NodeView.DEFAULT)));</span>
<span class="line-modified">245             }</span>
<span class="line-modified">246             node.replaceAtUsages(replacementNode);</span>
<span class="line-modified">247             if (node instanceof FixedWithNextNode) {</span>
<span class="line-modified">248                 GraphUtil.unlinkFixedNode((FixedWithNextNode) node);</span>



249             }
<span class="line-removed">250             obsoleteNodes.add(node);</span>
251         });
252     }
253 
254     /**
255      * Replaces the first occurrence of oldInput in node with newInput.
256      *
257      * @param node The node whose input should be changed.
258      * @param oldInput The value to look for.
259      * @param newInput The value to replace with.
260      */
261     public void replaceFirstInput(Node node, Node oldInput, Node newInput) {
262         assert node.isAlive() &amp;&amp; oldInput.isAlive() &amp;&amp; !newInput.isDeleted();
263         add(&quot;replace first input&quot;, new Effect() {
264             @Override
265             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
266                 if (node.isAlive()) {
267                     assert oldInput.isAlive() &amp;&amp; newInput.isAlive();
268                     node.replaceFirstInput(oldInput, newInput);
269                 }
270             }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.virtual.phases.ea;
 26 
 27 import java.util.ArrayList;
 28 
<span class="line-added"> 29 import org.graalvm.compiler.debug.DebugCloseable;</span>
 30 import org.graalvm.compiler.debug.DebugContext;
 31 import org.graalvm.compiler.graph.Node;
 32 import org.graalvm.compiler.nodes.ControlSinkNode;
 33 import org.graalvm.compiler.nodes.FixedNode;
 34 import org.graalvm.compiler.nodes.FixedWithNextNode;
 35 import org.graalvm.compiler.nodes.FrameState;
 36 import org.graalvm.compiler.nodes.IfNode;
 37 import org.graalvm.compiler.nodes.NodeView;
 38 import org.graalvm.compiler.nodes.PhiNode;
 39 import org.graalvm.compiler.nodes.PiNode;
 40 import org.graalvm.compiler.nodes.StructuredGraph;
 41 import org.graalvm.compiler.nodes.ValueNode;
 42 import org.graalvm.compiler.nodes.debug.DynamicCounterNode;
 43 import org.graalvm.compiler.nodes.debug.WeakCounterNode;
 44 import org.graalvm.compiler.nodes.util.GraphUtil;
 45 import org.graalvm.compiler.nodes.virtual.EscapeObjectState;
 46 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 47 
 48 public final class GraphEffectList extends EffectList {
 49 
</pre>
<hr />
<pre>
115      * Add the given floating node to the graph.
116      *
117      * @param node The floating node to be added.
118      */
119     public void addFloatingNode(ValueNode node, @SuppressWarnings(&quot;unused&quot;) String cause) {
120         add(&quot;add floating node&quot;, graph -&gt; {
121             graph.addWithoutUniqueWithInputs(node);
122         });
123     }
124 
125     /**
126      * Sets the phi node&#39;s input at the given index to the given value, adding new phi inputs as
127      * needed.
128      *
129      * @param node The phi node whose input should be changed.
130      * @param index The index of the phi input to be changed.
131      * @param value The new value for the phi input.
132      */
133     public void initializePhiInput(PhiNode node, int index, ValueNode value) {
134         add(&quot;set phi input&quot;, (graph, obsoleteNodes) -&gt; {
<span class="line-modified">135             assert node.isAlive() &amp;&amp; index &gt;= 0 : node;</span>
136             node.initializeValueAt(index, graph.addOrUniqueWithInputs(value));
137         });
138     }
139 
140     /**
141      * Adds a virtual object&#39;s state to the given frame state. If the given reusedVirtualObjects set
142      * contains the virtual object then old states for this object will be removed.
143      *
144      * @param node The frame state to which the state should be added.
145      * @param state The virtual object state to add.
146      */
147     public void addVirtualMapping(FrameState node, EscapeObjectState state) {
148         add(&quot;add virtual mapping&quot;, new Effect() {
149             @Override
150             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
151                 if (node.isAlive()) {
152                     assert !state.isDeleted();
153                     FrameState stateAfter = node;
154                     for (int i = 0; i &lt; stateAfter.virtualObjectMappingCount(); i++) {
155                         if (stateAfter.virtualObjectMappingAt(i).object() == state.object()) {
</pre>
<hr />
<pre>
180             obsoleteNodes.add(node);
181         });
182     }
183 
184     public void killIfBranch(IfNode ifNode, boolean constantCondition) {
185         add(&quot;kill if branch&quot;, new Effect() {
186             @Override
187             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
188                 graph.removeSplitPropagate(ifNode, ifNode.getSuccessor(constantCondition));
189             }
190 
191             @Override
192             public boolean isCfgKill() {
193                 return true;
194             }
195         });
196     }
197 
198     public void replaceWithSink(FixedWithNextNode node, ControlSinkNode sink) {
199         add(&quot;kill if branch&quot;, new Effect() {
<span class="line-added">200             @SuppressWarnings(&quot;try&quot;)</span>
201             @Override
202             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
<span class="line-modified">203                 try (DebugCloseable position = graph.withNodeSourcePosition(node)) {</span>
<span class="line-modified">204                     graph.addWithoutUnique(sink);</span>
<span class="line-modified">205                     node.replaceAtPredecessor(sink);</span>
<span class="line-added">206                     GraphUtil.killCFG(node);</span>
<span class="line-added">207                 }</span>
208             }
209 
210             @Override
211             public boolean isCfgKill() {
212                 return true;
213             }
214         });
215     }
216 
217     /**
218      * Replaces the given node at its usages without deleting it. If the current node is a fixed
219      * node it will be disconnected from the control flow, so that it will be deleted by a
220      * subsequent {@link DeadCodeEliminationPhase}
221      *
222      * @param node The node to be replaced.
223      * @param replacement The node that should replace the original value. If the replacement is a
224      *            non-connected {@link FixedWithNextNode} it will be added to the control flow.
225      * @param insertBefore
226      *
227      */
<span class="line-added">228     @SuppressWarnings(&quot;try&quot;)</span>
229     public void replaceAtUsages(ValueNode node, ValueNode replacement, FixedNode insertBefore) {
230         assert node != null &amp;&amp; replacement != null : node + &quot; &quot; + replacement;
<span class="line-modified">231         assert !node.hasUsages() || node.stamp(NodeView.DEFAULT).isCompatible(replacement.stamp(NodeView.DEFAULT)) : &quot;Replacement node stamp not compatible &quot; + node.stamp(NodeView.DEFAULT) + &quot; vs &quot; +</span>
232                         replacement.stamp(NodeView.DEFAULT);
233         add(&quot;replace at usages&quot;, (graph, obsoleteNodes) -&gt; {
<span class="line-modified">234             try (DebugCloseable position = graph.withNodeSourcePosition(node)) {</span>
<span class="line-modified">235                 assert node.isAlive();</span>
<span class="line-modified">236                 ValueNode replacementNode = graph.addOrUniqueWithInputs(replacement);</span>
<span class="line-modified">237                 assert replacementNode.isAlive();</span>
<span class="line-modified">238                 assert insertBefore != null;</span>
<span class="line-modified">239                 if (replacementNode instanceof FixedWithNextNode &amp;&amp; ((FixedWithNextNode) replacementNode).next() == null) {</span>
<span class="line-modified">240                     graph.addBeforeFixed(insertBefore, (FixedWithNextNode) replacementNode);</span>
<span class="line-modified">241                 }</span>
<span class="line-modified">242                 /*</span>
<span class="line-modified">243                  * Keep the (better) stamp information when replacing a node with another one if the</span>
<span class="line-modified">244                  * replacement has a less precise stamp than the original node. This can happen for</span>
<span class="line-modified">245                  * example in the context of read nodes and unguarded pi nodes where the pi will be</span>
<span class="line-modified">246                  * used to improve the stamp information of the read. Such a read might later be</span>
<span class="line-modified">247                  * replaced with a read with a less precise stamp.</span>
<span class="line-modified">248                  */</span>
<span class="line-modified">249                 if (node.hasUsages() &amp;&amp; !node.stamp(NodeView.DEFAULT).equals(replacementNode.stamp(NodeView.DEFAULT))) {</span>
<span class="line-modified">250                     replacementNode = graph.unique(new PiNode(replacementNode, node.stamp(NodeView.DEFAULT)));</span>
<span class="line-modified">251                 }</span>
<span class="line-modified">252                 node.replaceAtUsages(replacementNode);</span>
<span class="line-modified">253                 if (node instanceof FixedWithNextNode) {</span>
<span class="line-added">254                     GraphUtil.unlinkFixedNode((FixedWithNextNode) node);</span>
<span class="line-added">255                 }</span>
<span class="line-added">256                 obsoleteNodes.add(node);</span>
257             }

258         });
259     }
260 
261     /**
262      * Replaces the first occurrence of oldInput in node with newInput.
263      *
264      * @param node The node whose input should be changed.
265      * @param oldInput The value to look for.
266      * @param newInput The value to replace with.
267      */
268     public void replaceFirstInput(Node node, Node oldInput, Node newInput) {
269         assert node.isAlive() &amp;&amp; oldInput.isAlive() &amp;&amp; !newInput.isDeleted();
270         add(&quot;replace first input&quot;, new Effect() {
271             @Override
272             public void apply(StructuredGraph graph, ArrayList&lt;Node&gt; obsoleteNodes) {
273                 if (node.isAlive()) {
274                     assert oldInput.isAlive() &amp;&amp; newInput.isAlive();
275                     node.replaceFirstInput(oldInput, newInput);
276                 }
277             }
</pre>
</td>
</tr>
</table>
<center><a href="EffectsPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PEReadEliminationClosure.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.processor/src/org/graalvm/compiler/replacements/processor/GeneratedPlugin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.processor;
 26 
 27 import java.io.PrintWriter;
 28 import java.util.Set;
 29 
 30 import javax.lang.model.element.ExecutableElement;
 31 import javax.lang.model.element.Modifier;
 32 import javax.lang.model.element.TypeElement;
 33 import javax.lang.model.element.VariableElement;
 34 import javax.lang.model.type.ArrayType;
 35 import javax.lang.model.type.DeclaredType;
 36 import javax.lang.model.type.TypeMirror;
 37 import javax.lang.model.type.TypeVariable;
 38 import javax.lang.model.type.WildcardType;
 39 
 40 import org.graalvm.compiler.processor.AbstractProcessor;
 41 import org.graalvm.compiler.replacements.processor.InjectedDependencies.Dependency;
 42 import org.graalvm.compiler.replacements.processor.InjectedDependencies.WellKnownDependency;
 43 
 44 public abstract class GeneratedPlugin {
 45 
 46     protected final ExecutableElement intrinsicMethod;
 47     private boolean needInjectionProvider;
 48 
 49     private String pluginName;
 50 
 51     public GeneratedPlugin(ExecutableElement intrinsicMethod) {
 52         this.intrinsicMethod = intrinsicMethod;
 53         this.needInjectionProvider = false;
 54         // Lets keep generated class names short to mitigate hitting file name length limits.
 55         this.pluginName = &quot;Plugin_&quot; + intrinsicMethod.getEnclosingElement().getSimpleName() + &quot;_&quot; + intrinsicMethod.getSimpleName().toString();
 56     }
 57 
 58     protected abstract TypeElement getAnnotationClass(AbstractProcessor processor);
 59 
 60     public String getPluginName() {
 61         return pluginName;
 62     }
 63 
 64     public void setPluginName(String pluginName) {
 65         this.pluginName = pluginName;
 66     }
 67 
 68     public void generate(AbstractProcessor processor, PrintWriter out) {
 69         out.printf(&quot;//        class: %s\n&quot;, intrinsicMethod.getEnclosingElement());
 70         out.printf(&quot;//       method: %s\n&quot;, intrinsicMethod);
 71         out.printf(&quot;// generated-by: %s\n&quot;, getClass().getName());
 72         out.printf(&quot;final class %s extends GeneratedInvocationPlugin {\n&quot;, pluginName);
 73         out.printf(&quot;\n&quot;);
 74         out.printf(&quot;    @Override\n&quot;);
 75         out.printf(&quot;    public boolean execute(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode[] args) {\n&quot;);
<a name="2" id="anc2"></a><span class="line-added"> 76         out.printf(&quot;        if (!b.isPluginEnabled(this)) {\n&quot;);</span>
<span class="line-added"> 77         out.printf(&quot;            return false;\n&quot;);</span>
<span class="line-added"> 78         out.printf(&quot;        }\n&quot;);</span>
 79         InjectedDependencies deps = createExecute(processor, out);
 80         out.printf(&quot;    }\n&quot;);
 81         out.printf(&quot;    @Override\n&quot;);
 82         out.printf(&quot;    public Class&lt;? extends Annotation&gt; getSource() {\n&quot;);
 83         out.printf(&quot;        return %s.class;\n&quot;, getAnnotationClass(processor).getQualifiedName().toString().replace(&#39;$&#39;, &#39;.&#39;));
 84         out.printf(&quot;    }\n&quot;);
 85 
 86         createPrivateMembers(processor, out, deps);
 87 
 88         out.printf(&quot;}\n&quot;);
 89     }
 90 
 91     public void register(PrintWriter out) {
 92         out.printf(&quot;        plugins.register(new %s(&quot;, pluginName);
 93         if (needInjectionProvider) {
 94             out.printf(&quot;injection&quot;);
 95         }
 96         out.printf(&quot;), %s.class, \&quot;%s\&quot;&quot;, intrinsicMethod.getEnclosingElement(), intrinsicMethod.getSimpleName());
 97         if (!intrinsicMethod.getModifiers().contains(Modifier.STATIC)) {
 98             out.printf(&quot;, InvocationPlugin.Receiver.class&quot;);
 99         }
100         for (VariableElement arg : intrinsicMethod.getParameters()) {
101             out.printf(&quot;, %s.class&quot;, getErasedType(arg.asType()));
102         }
103         out.printf(&quot;);\n&quot;);
104     }
105 
106     public abstract void extraImports(Set&lt;String&gt; imports);
107 
108     protected abstract InjectedDependencies createExecute(AbstractProcessor processor, PrintWriter out);
109 
110     static String getErasedType(TypeMirror type) {
111         switch (type.getKind()) {
112             case DECLARED:
113                 DeclaredType declared = (DeclaredType) type;
114                 TypeElement element = (TypeElement) declared.asElement();
115                 return element.getQualifiedName().toString();
116             case TYPEVAR:
117                 return getErasedType(((TypeVariable) type).getUpperBound());
118             case WILDCARD:
119                 return getErasedType(((WildcardType) type).getExtendsBound());
120             case ARRAY:
121                 return getErasedType(((ArrayType) type).getComponentType()) + &quot;[]&quot;;
122             default:
123                 return type.toString();
124         }
125     }
126 
127     static boolean hasRawtypeWarning(TypeMirror type) {
128         switch (type.getKind()) {
129             case DECLARED:
130                 DeclaredType declared = (DeclaredType) type;
131                 return declared.getTypeArguments().size() &gt; 0;
132             case TYPEVAR:
133                 return false;
134             case WILDCARD:
135                 return false;
136             case ARRAY:
137                 return hasRawtypeWarning(((ArrayType) type).getComponentType());
138             default:
139                 return false;
140         }
141     }
142 
143     static boolean hasUncheckedWarning(TypeMirror type) {
144         switch (type.getKind()) {
145             case DECLARED:
146                 DeclaredType declared = (DeclaredType) type;
147                 for (TypeMirror typeParam : declared.getTypeArguments()) {
148                     if (hasUncheckedWarning(typeParam)) {
149                         return true;
150                     }
151                 }
152                 return false;
153             case TYPEVAR:
154                 return true;
155             case WILDCARD:
156                 return ((WildcardType) type).getExtendsBound() != null;
157             case ARRAY:
158                 return hasUncheckedWarning(((ArrayType) type).getComponentType());
159             default:
160                 return false;
161         }
162     }
163 
164     private void createPrivateMembers(AbstractProcessor processor, PrintWriter out, InjectedDependencies deps) {
165         if (!deps.isEmpty()) {
166             out.printf(&quot;\n&quot;);
167             for (Dependency dep : deps) {
168                 out.printf(&quot;    private final %s %s;\n&quot;, dep.type, dep.name);
169             }
170 
171             out.printf(&quot;\n&quot;);
172             out.printf(&quot;    %s(NodeIntrinsicPluginFactory.InjectionProvider injection) {\n&quot;, pluginName);
173             for (Dependency dep : deps) {
174                 out.printf(&quot;        this.%s = %s;\n&quot;, dep.name, dep.inject(processor, intrinsicMethod));
175             }
176             out.printf(&quot;    }\n&quot;);
177 
178             needInjectionProvider = true;
179         }
180     }
181 
182     protected static String getReturnKind(ExecutableElement method) {
183         switch (method.getReturnType().getKind()) {
184             case BOOLEAN:
185             case BYTE:
186             case SHORT:
187             case CHAR:
188             case INT:
189                 return &quot;Int&quot;;
190             case LONG:
191                 return &quot;Long&quot;;
192             case FLOAT:
193                 return &quot;Float&quot;;
194             case DOUBLE:
195                 return &quot;Double&quot;;
196             case VOID:
197                 return &quot;Void&quot;;
198             case ARRAY:
199             case TYPEVAR:
200             case DECLARED:
201                 return &quot;Object&quot;;
202             default:
203                 throw new IllegalArgumentException(method.getReturnType().toString());
204         }
205     }
206 
207     protected static void constantArgument(AbstractProcessor processor, PrintWriter out, InjectedDependencies deps, int argIdx, TypeMirror type, int nodeIdx) {
208         if (hasRawtypeWarning(type)) {
209             out.printf(&quot;        @SuppressWarnings({\&quot;rawtypes\&quot;})\n&quot;);
210         }
211         out.printf(&quot;        %s arg%d;\n&quot;, getErasedType(type), argIdx);
212         out.printf(&quot;        if (args[%d].isConstant()) {\n&quot;, nodeIdx);
213         if (type.equals(processor.getType(&quot;jdk.vm.ci.meta.ResolvedJavaType&quot;))) {
214             out.printf(&quot;            jdk.vm.ci.meta.JavaConstant cst = args[%d].asJavaConstant();\n&quot;, nodeIdx);
215             out.printf(&quot;            arg%d = %s.asJavaType(cst);\n&quot;, argIdx, deps.use(WellKnownDependency.CONSTANT_REFLECTION));
216             out.printf(&quot;            if (arg%d == null) {\n&quot;, argIdx);
217             out.printf(&quot;                arg%d = %s.asObject(jdk.vm.ci.meta.ResolvedJavaType.class, cst);\n&quot;, argIdx, deps.use(WellKnownDependency.SNIPPET_REFLECTION));
218             out.printf(&quot;            }\n&quot;);
219         } else {
220             switch (type.getKind()) {
221                 case BOOLEAN:
222                     out.printf(&quot;            arg%d = args[%d].asJavaConstant().asInt() != 0;\n&quot;, argIdx, nodeIdx);
223                     break;
224                 case BYTE:
225                     out.printf(&quot;            arg%d = (byte) args[%d].asJavaConstant().asInt();\n&quot;, argIdx, nodeIdx);
226                     break;
227                 case CHAR:
228                     out.printf(&quot;            arg%d = (char) args[%d].asJavaConstant().asInt();\n&quot;, argIdx, nodeIdx);
229                     break;
230                 case SHORT:
231                     out.printf(&quot;            arg%d = (short) args[%d].asJavaConstant().asInt();\n&quot;, argIdx, nodeIdx);
232                     break;
233                 case INT:
234                     out.printf(&quot;            arg%d = args[%d].asJavaConstant().asInt();\n&quot;, argIdx, nodeIdx);
235                     break;
236                 case LONG:
237                     out.printf(&quot;            arg%d = args[%d].asJavaConstant().asLong();\n&quot;, argIdx, nodeIdx);
238                     break;
239                 case FLOAT:
240                     out.printf(&quot;            arg%d = args[%d].asJavaConstant().asFloat();\n&quot;, argIdx, nodeIdx);
241                     break;
242                 case DOUBLE:
243                     out.printf(&quot;            arg%d = args[%d].asJavaConstant().asDouble();\n&quot;, argIdx, nodeIdx);
244                     break;
245                 case ARRAY:
246                 case DECLARED:
247                     out.printf(&quot;            arg%d = %s.asObject(%s.class, args[%d].asJavaConstant());\n&quot;, argIdx, deps.use(WellKnownDependency.SNIPPET_REFLECTION), getErasedType(type), nodeIdx);
248                     break;
249                 default:
250                     throw new IllegalArgumentException(type.toString());
251             }
252         }
253         out.printf(&quot;        } else {\n&quot;);
254         out.printf(&quot;            assert b.canDeferPlugin(this) : b.getClass().toString();\n&quot;);
255         out.printf(&quot;            return false;\n&quot;);
256         out.printf(&quot;        }\n&quot;);
257     }
258 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
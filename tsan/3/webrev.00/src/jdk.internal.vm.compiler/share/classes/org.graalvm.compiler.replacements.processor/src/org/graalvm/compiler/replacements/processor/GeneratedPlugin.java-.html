<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.processor/src/org/graalvm/compiler/replacements/processor/GeneratedPlugin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.processor;
 26 
 27 import java.io.PrintWriter;
 28 import java.util.Set;
 29 
 30 import javax.lang.model.element.ExecutableElement;
 31 import javax.lang.model.element.Modifier;
 32 import javax.lang.model.element.TypeElement;
 33 import javax.lang.model.element.VariableElement;
 34 import javax.lang.model.type.ArrayType;
 35 import javax.lang.model.type.DeclaredType;
 36 import javax.lang.model.type.TypeMirror;
 37 import javax.lang.model.type.TypeVariable;
 38 import javax.lang.model.type.WildcardType;
 39 
 40 import org.graalvm.compiler.processor.AbstractProcessor;
 41 import org.graalvm.compiler.replacements.processor.InjectedDependencies.Dependency;
 42 import org.graalvm.compiler.replacements.processor.InjectedDependencies.WellKnownDependency;
 43 
 44 public abstract class GeneratedPlugin {
 45 
 46     protected final ExecutableElement intrinsicMethod;
 47     private boolean needInjectionProvider;
 48 
 49     private String pluginName;
 50 
 51     public GeneratedPlugin(ExecutableElement intrinsicMethod) {
 52         this.intrinsicMethod = intrinsicMethod;
 53         this.needInjectionProvider = false;
 54         // Lets keep generated class names short to mitigate hitting file name length limits.
 55         this.pluginName = &quot;Plugin_&quot; + intrinsicMethod.getEnclosingElement().getSimpleName() + &quot;_&quot; + intrinsicMethod.getSimpleName().toString();
 56     }
 57 
 58     protected abstract TypeElement getAnnotationClass(AbstractProcessor processor);
 59 
 60     public String getPluginName() {
 61         return pluginName;
 62     }
 63 
 64     public void setPluginName(String pluginName) {
 65         this.pluginName = pluginName;
 66     }
 67 
 68     public void generate(AbstractProcessor processor, PrintWriter out) {
 69         out.printf(&quot;//        class: %s\n&quot;, intrinsicMethod.getEnclosingElement());
 70         out.printf(&quot;//       method: %s\n&quot;, intrinsicMethod);
 71         out.printf(&quot;// generated-by: %s\n&quot;, getClass().getName());
 72         out.printf(&quot;final class %s extends GeneratedInvocationPlugin {\n&quot;, pluginName);
 73         out.printf(&quot;\n&quot;);
 74         out.printf(&quot;    @Override\n&quot;);
 75         out.printf(&quot;    public boolean execute(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode[] args) {\n&quot;);
 76         InjectedDependencies deps = createExecute(processor, out);
 77         out.printf(&quot;    }\n&quot;);
 78         out.printf(&quot;    @Override\n&quot;);
 79         out.printf(&quot;    public Class&lt;? extends Annotation&gt; getSource() {\n&quot;);
 80         out.printf(&quot;        return %s.class;\n&quot;, getAnnotationClass(processor).getQualifiedName().toString().replace(&#39;$&#39;, &#39;.&#39;));
 81         out.printf(&quot;    }\n&quot;);
 82 
 83         createPrivateMembers(processor, out, deps);
 84 
 85         out.printf(&quot;}\n&quot;);
 86     }
 87 
 88     public void register(PrintWriter out) {
 89         out.printf(&quot;        plugins.register(new %s(&quot;, pluginName);
 90         if (needInjectionProvider) {
 91             out.printf(&quot;injection&quot;);
 92         }
 93         out.printf(&quot;), %s.class, \&quot;%s\&quot;&quot;, intrinsicMethod.getEnclosingElement(), intrinsicMethod.getSimpleName());
 94         if (!intrinsicMethod.getModifiers().contains(Modifier.STATIC)) {
 95             out.printf(&quot;, InvocationPlugin.Receiver.class&quot;);
 96         }
 97         for (VariableElement arg : intrinsicMethod.getParameters()) {
 98             out.printf(&quot;, %s.class&quot;, getErasedType(arg.asType()));
 99         }
100         out.printf(&quot;);\n&quot;);
101     }
102 
103     public abstract void extraImports(Set&lt;String&gt; imports);
104 
105     protected abstract InjectedDependencies createExecute(AbstractProcessor processor, PrintWriter out);
106 
107     static String getErasedType(TypeMirror type) {
108         switch (type.getKind()) {
109             case DECLARED:
110                 DeclaredType declared = (DeclaredType) type;
111                 TypeElement element = (TypeElement) declared.asElement();
112                 return element.getQualifiedName().toString();
113             case TYPEVAR:
114                 return getErasedType(((TypeVariable) type).getUpperBound());
115             case WILDCARD:
116                 return getErasedType(((WildcardType) type).getExtendsBound());
117             case ARRAY:
118                 return getErasedType(((ArrayType) type).getComponentType()) + &quot;[]&quot;;
119             default:
120                 return type.toString();
121         }
122     }
123 
124     static boolean hasRawtypeWarning(TypeMirror type) {
125         switch (type.getKind()) {
126             case DECLARED:
127                 DeclaredType declared = (DeclaredType) type;
128                 return declared.getTypeArguments().size() &gt; 0;
129             case TYPEVAR:
130                 return false;
131             case WILDCARD:
132                 return false;
133             case ARRAY:
134                 return hasRawtypeWarning(((ArrayType) type).getComponentType());
135             default:
136                 return false;
137         }
138     }
139 
140     static boolean hasUncheckedWarning(TypeMirror type) {
141         switch (type.getKind()) {
142             case DECLARED:
143                 DeclaredType declared = (DeclaredType) type;
144                 for (TypeMirror typeParam : declared.getTypeArguments()) {
145                     if (hasUncheckedWarning(typeParam)) {
146                         return true;
147                     }
148                 }
149                 return false;
150             case TYPEVAR:
151                 return true;
152             case WILDCARD:
153                 return ((WildcardType) type).getExtendsBound() != null;
154             case ARRAY:
155                 return hasUncheckedWarning(((ArrayType) type).getComponentType());
156             default:
157                 return false;
158         }
159     }
160 
161     private void createPrivateMembers(AbstractProcessor processor, PrintWriter out, InjectedDependencies deps) {
162         if (!deps.isEmpty()) {
163             out.printf(&quot;\n&quot;);
164             for (Dependency dep : deps) {
165                 out.printf(&quot;    private final %s %s;\n&quot;, dep.type, dep.name);
166             }
167 
168             out.printf(&quot;\n&quot;);
169             out.printf(&quot;    %s(NodeIntrinsicPluginFactory.InjectionProvider injection) {\n&quot;, pluginName);
170             for (Dependency dep : deps) {
171                 out.printf(&quot;        this.%s = %s;\n&quot;, dep.name, dep.inject(processor, intrinsicMethod));
172             }
173             out.printf(&quot;    }\n&quot;);
174 
175             needInjectionProvider = true;
176         }
177     }
178 
179     protected static String getReturnKind(ExecutableElement method) {
180         switch (method.getReturnType().getKind()) {
181             case BOOLEAN:
182             case BYTE:
183             case SHORT:
184             case CHAR:
185             case INT:
186                 return &quot;Int&quot;;
187             case LONG:
188                 return &quot;Long&quot;;
189             case FLOAT:
190                 return &quot;Float&quot;;
191             case DOUBLE:
192                 return &quot;Double&quot;;
193             case VOID:
194                 return &quot;Void&quot;;
195             case ARRAY:
196             case TYPEVAR:
197             case DECLARED:
198                 return &quot;Object&quot;;
199             default:
200                 throw new IllegalArgumentException(method.getReturnType().toString());
201         }
202     }
203 
204     protected static void constantArgument(AbstractProcessor processor, PrintWriter out, InjectedDependencies deps, int argIdx, TypeMirror type, int nodeIdx) {
205         if (hasRawtypeWarning(type)) {
206             out.printf(&quot;        @SuppressWarnings({\&quot;rawtypes\&quot;})\n&quot;);
207         }
208         out.printf(&quot;        %s arg%d;\n&quot;, getErasedType(type), argIdx);
209         out.printf(&quot;        if (args[%d].isConstant()) {\n&quot;, nodeIdx);
210         if (type.equals(processor.getType(&quot;jdk.vm.ci.meta.ResolvedJavaType&quot;))) {
211             out.printf(&quot;            jdk.vm.ci.meta.JavaConstant cst = args[%d].asJavaConstant();\n&quot;, nodeIdx);
212             out.printf(&quot;            arg%d = %s.asJavaType(cst);\n&quot;, argIdx, deps.use(WellKnownDependency.CONSTANT_REFLECTION));
213             out.printf(&quot;            if (arg%d == null) {\n&quot;, argIdx);
214             out.printf(&quot;                arg%d = %s.asObject(jdk.vm.ci.meta.ResolvedJavaType.class, cst);\n&quot;, argIdx, deps.use(WellKnownDependency.SNIPPET_REFLECTION));
215             out.printf(&quot;            }\n&quot;);
216         } else {
217             switch (type.getKind()) {
218                 case BOOLEAN:
219                     out.printf(&quot;            arg%d = args[%d].asJavaConstant().asInt() != 0;\n&quot;, argIdx, nodeIdx);
220                     break;
221                 case BYTE:
222                     out.printf(&quot;            arg%d = (byte) args[%d].asJavaConstant().asInt();\n&quot;, argIdx, nodeIdx);
223                     break;
224                 case CHAR:
225                     out.printf(&quot;            arg%d = (char) args[%d].asJavaConstant().asInt();\n&quot;, argIdx, nodeIdx);
226                     break;
227                 case SHORT:
228                     out.printf(&quot;            arg%d = (short) args[%d].asJavaConstant().asInt();\n&quot;, argIdx, nodeIdx);
229                     break;
230                 case INT:
231                     out.printf(&quot;            arg%d = args[%d].asJavaConstant().asInt();\n&quot;, argIdx, nodeIdx);
232                     break;
233                 case LONG:
234                     out.printf(&quot;            arg%d = args[%d].asJavaConstant().asLong();\n&quot;, argIdx, nodeIdx);
235                     break;
236                 case FLOAT:
237                     out.printf(&quot;            arg%d = args[%d].asJavaConstant().asFloat();\n&quot;, argIdx, nodeIdx);
238                     break;
239                 case DOUBLE:
240                     out.printf(&quot;            arg%d = args[%d].asJavaConstant().asDouble();\n&quot;, argIdx, nodeIdx);
241                     break;
242                 case ARRAY:
243                 case DECLARED:
244                     out.printf(&quot;            arg%d = %s.asObject(%s.class, args[%d].asJavaConstant());\n&quot;, argIdx, deps.use(WellKnownDependency.SNIPPET_REFLECTION), getErasedType(type), nodeIdx);
245                     break;
246                 default:
247                     throw new IllegalArgumentException(type.toString());
248             }
249         }
250         out.printf(&quot;        } else {\n&quot;);
251         out.printf(&quot;            assert b.canDeferPlugin(this) : b.getClass().toString();\n&quot;);
252         out.printf(&quot;            return false;\n&quot;);
253         out.printf(&quot;        }\n&quot;);
254     }
255 }
    </pre>
  </body>
</html>
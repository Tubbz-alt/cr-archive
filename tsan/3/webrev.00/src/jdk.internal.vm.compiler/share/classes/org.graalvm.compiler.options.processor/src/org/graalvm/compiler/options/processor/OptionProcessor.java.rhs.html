<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.options.processor/src/org/graalvm/compiler/options/processor/OptionProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.options.processor;
 26 
 27 import java.io.BufferedReader;
 28 import java.io.IOException;
 29 import java.io.InputStreamReader;
 30 import java.io.PrintWriter;
 31 import java.util.ArrayList;
 32 import java.util.Collections;
 33 import java.util.HashMap;
 34 import java.util.HashSet;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.Set;
 38 
 39 import javax.annotation.processing.Filer;
 40 import javax.annotation.processing.ProcessingEnvironment;
 41 import javax.annotation.processing.RoundEnvironment;
 42 import javax.annotation.processing.SupportedAnnotationTypes;
 43 import javax.lang.model.SourceVersion;
 44 import javax.lang.model.element.AnnotationMirror;
 45 import javax.lang.model.element.Element;
 46 import javax.lang.model.element.ElementKind;
 47 import javax.lang.model.element.Modifier;
 48 import javax.lang.model.element.PackageElement;
 49 import javax.lang.model.element.TypeElement;
 50 import javax.lang.model.element.VariableElement;
 51 import javax.lang.model.type.DeclaredType;
 52 import javax.lang.model.type.TypeKind;
 53 import javax.lang.model.type.TypeMirror;
 54 import javax.lang.model.util.Types;
 55 import javax.tools.Diagnostic.Kind;
 56 import javax.tools.FileObject;
 57 import javax.tools.JavaFileObject;
 58 import javax.tools.StandardLocation;
 59 
 60 import org.graalvm.compiler.processor.AbstractProcessor;
 61 
 62 /**
 63  * Processes static fields annotated with {@code Option}. An {@code OptionDescriptors}
 64  * implementation is generated for each top level class containing at least one such field. The name
 65  * of the generated class for top level class {@code com.foo.Bar} is
 66  * {@code com.foo.Bar_OptionDescriptors}.
 67  */
 68 @SupportedAnnotationTypes({&quot;org.graalvm.compiler.options.Option&quot;})
 69 public class OptionProcessor extends AbstractProcessor {
 70 
 71     private static final String OPTION_CLASS_NAME = &quot;org.graalvm.compiler.options.Option&quot;;
 72     private static final String OPTION_KEY_CLASS_NAME = &quot;org.graalvm.compiler.options.OptionKey&quot;;
 73     private static final String OPTION_TYPE_CLASS_NAME = &quot;org.graalvm.compiler.options.OptionType&quot;;
 74     private static final String OPTION_DESCRIPTOR_CLASS_NAME = &quot;org.graalvm.compiler.options.OptionDescriptor&quot;;
 75     private static final String OPTION_DESCRIPTORS_CLASS_NAME = &quot;org.graalvm.compiler.options.OptionDescriptors&quot;;
 76 
 77     @Override
 78     public SourceVersion getSupportedSourceVersion() {
 79         return SourceVersion.latest();
 80     }
 81 
 82     private final Set&lt;Element&gt; processed = new HashSet&lt;&gt;();
 83 
 84     private TypeMirror optionTypeMirror;
 85     private TypeMirror optionKeyTypeMirror;
 86 
 87     private void processElement(Element element, OptionsInfo info) {
 88 
 89         if (!element.getModifiers().contains(Modifier.STATIC)) {
 90             processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Option field must be static&quot;, element);
 91             return;
 92         }
 93         if (element.getModifiers().contains(Modifier.PRIVATE)) {
 94             processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Option field cannot be private&quot;, element);
 95             return;
 96         }
 97 
 98         AnnotationMirror annotation = getAnnotation(element, optionTypeMirror);
 99         assert annotation != null;
100         assert element instanceof VariableElement;
101         assert element.getKind() == ElementKind.FIELD;
102         VariableElement field = (VariableElement) element;
103         String fieldName = field.getSimpleName().toString();
104 
105         Types types = processingEnv.getTypeUtils();
106 
107         TypeMirror fieldType = field.asType();
108         if (fieldType.getKind() != TypeKind.DECLARED) {
109             processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Option field must be of type &quot; + OPTION_KEY_CLASS_NAME, element);
110             return;
111         }
112         DeclaredType declaredFieldType = (DeclaredType) fieldType;
113 
114         if (!types.isSubtype(fieldType, types.erasure(optionKeyTypeMirror))) {
115             String msg = String.format(&quot;Option field type %s is not a subclass of %s&quot;, fieldType, optionKeyTypeMirror);
116             processingEnv.getMessager().printMessage(Kind.ERROR, msg, element);
117             return;
118         }
119 
120         if (!field.getModifiers().contains(Modifier.STATIC)) {
121             processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Option field must be static&quot;, element);
122             return;
123         }
124         if (field.getModifiers().contains(Modifier.PRIVATE)) {
125             processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Option field cannot be private&quot;, element);
126             return;
127         }
128 
129         String optionName = getAnnotationValue(annotation, &quot;name&quot;, String.class);
130         if (optionName.equals(&quot;&quot;)) {
131             optionName = fieldName;
132         }
133 
134         if (!Character.isUpperCase(optionName.charAt(0))) {
135             processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Option name must start with an upper case letter&quot;, element);
136             return;
137         }
138 
139         DeclaredType declaredOptionKeyType = declaredFieldType;
140         while (!types.isSameType(types.erasure(declaredOptionKeyType), types.erasure(optionKeyTypeMirror))) {
141             List&lt;? extends TypeMirror&gt; directSupertypes = types.directSupertypes(declaredFieldType);
142             assert !directSupertypes.isEmpty();
143             declaredOptionKeyType = (DeclaredType) directSupertypes.get(0);
144         }
145 
146         assert !declaredOptionKeyType.getTypeArguments().isEmpty();
147         String optionType = declaredOptionKeyType.getTypeArguments().get(0).toString();
148         if (optionType.startsWith(&quot;java.lang.&quot;)) {
149             optionType = optionType.substring(&quot;java.lang.&quot;.length());
150         }
151 
152         Element enclosing = element.getEnclosingElement();
153         String declaringClass = &quot;&quot;;
154         String separator = &quot;&quot;;
155         Set&lt;Element&gt; originatingElementsList = info.originatingElements;
156         originatingElementsList.add(field);
157         PackageElement enclosingPackage = null;
158         while (enclosing != null) {
159             if (enclosing.getKind() == ElementKind.CLASS || enclosing.getKind() == ElementKind.INTERFACE || enclosing.getKind() == ElementKind.ENUM) {
160                 if (enclosing.getModifiers().contains(Modifier.PRIVATE)) {
161                     String msg = String.format(&quot;Option field cannot be declared in a private %s %s&quot;, enclosing.getKind().name().toLowerCase(), enclosing);
162                     processingEnv.getMessager().printMessage(Kind.ERROR, msg, element);
163                     return;
164                 }
165                 originatingElementsList.add(enclosing);
166                 declaringClass = enclosing.getSimpleName() + separator + declaringClass;
167                 separator = &quot;.&quot;;
168             } else if (enclosing.getKind() == ElementKind.PACKAGE) {
169                 enclosingPackage = (PackageElement) enclosing;
170                 break;
171             } else {
172                 processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Unexpected enclosing element kind: &quot; + enclosing.getKind(), element);
173                 return;
174             }
175             enclosing = enclosing.getEnclosingElement();
176         }
177         if (enclosingPackage == null || enclosingPackage.isUnnamed()) {
178             processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Option field cannot be declared in the unnamed package&quot;, element);
179             return;
180         }
181         List&lt;String&gt; helpValue = getAnnotationValueList(annotation, &quot;help&quot;, String.class);
182         String help = &quot;&quot;;
183         List&lt;String&gt; extraHelp = new ArrayList&lt;&gt;();
184 
185         if (helpValue.size() == 1) {
186             help = helpValue.get(0);
187             if (help.startsWith(&quot;file:&quot;)) {
188                 String path = help.substring(&quot;file:&quot;.length());
189                 Filer filer = processingEnv.getFiler();
190                 try {
191                     FileObject file;
192                     try {
193                         file = filer.getResource(StandardLocation.SOURCE_PATH, enclosingPackage.getQualifiedName(), path);
194                     } catch (IllegalArgumentException | IOException e) {
195                         // Handle the case when a compiler doesn&#39;t support the SOURCE_PATH location
196                         file = filer.getResource(StandardLocation.CLASS_OUTPUT, enclosingPackage.getQualifiedName(), path);
197                     }
198                     try (BufferedReader br = new BufferedReader(new InputStreamReader(file.openInputStream()))) {
199                         help = br.readLine();
200                         if (help == null) {
201                             help = &quot;&quot;;
202                         }
203                         String line = br.readLine();
204                         while (line != null) {
205                             extraHelp.add(line);
206                             line = br.readLine();
207                         }
208                     }
209                 } catch (IOException e) {
210                     String msg = String.format(&quot;Error reading %s containing the help text for option field: %s&quot;, path, e);
211                     processingEnv.getMessager().printMessage(Kind.ERROR, msg, element);
212                     return;
213                 }
214             }
215         } else if (helpValue.size() &gt; 1) {
216             help = helpValue.get(0);
217             extraHelp = helpValue.subList(1, helpValue.size());
218         }
219         if (help.length() != 0) {
220             char firstChar = help.charAt(0);
221             if (!Character.isUpperCase(firstChar)) {
222                 processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Option help text must start with an upper case letter&quot;, element);
223                 return;
224             }
225         }
226 
<a name="2" id="anc2"></a><span class="line-added">227         String optionStabilityName = getAnnotationValue(annotation, &quot;stability&quot;, VariableElement.class).getSimpleName().toString();</span>
<span class="line-added">228         if (optionStabilityName.equals(&quot;STABLE&quot;)) {</span>
<span class="line-added">229             if (help.length() == 0) {</span>
<span class="line-added">230                 processingEnv.getMessager().printMessage(Kind.ERROR, &quot;A stable option must have non-empty help text&quot;, element);</span>
<span class="line-added">231                 return;</span>
<span class="line-added">232             }</span>
<span class="line-added">233         }</span>
<span class="line-added">234 </span>
235         String optionTypeName = getAnnotationValue(annotation, &quot;type&quot;, VariableElement.class).getSimpleName().toString();
236         info.options.add(new OptionInfo(optionName, optionTypeName, help, extraHelp, optionType, declaringClass, field.getSimpleName().toString()));
237     }
238 
239     public static void createOptionsDescriptorsFile(ProcessingEnvironment processingEnv, OptionsInfo info) {
240         Element[] originatingElements = info.originatingElements.toArray(new Element[info.originatingElements.size()]);
241         String optionsDescriptorsClassName = info.className + &quot;_&quot; + getSimpleName(OPTION_DESCRIPTORS_CLASS_NAME);
242 
243         Filer filer = processingEnv.getFiler();
244         try (PrintWriter out = createSourceFile(info.packageName, optionsDescriptorsClassName, filer, originatingElements)) {
245 
246             out.println(&quot;// CheckStyle: stop header check&quot;);
247             out.println(&quot;// CheckStyle: stop line length check&quot;);
248             out.println(&quot;// GENERATED CONTENT - DO NOT EDIT&quot;);
249             out.println(&quot;// Source: &quot; + info.className + &quot;.java&quot;);
250             out.println(&quot;package &quot; + info.packageName + &quot;;&quot;);
251             out.println(&quot;&quot;);
252             out.println(&quot;import java.util.*;&quot;);
253             out.println(&quot;import &quot; + getPackageName(OPTION_DESCRIPTORS_CLASS_NAME) + &quot;.*;&quot;);
254             out.println(&quot;import &quot; + OPTION_TYPE_CLASS_NAME + &quot;;&quot;);
255             out.println(&quot;&quot;);
256             out.println(&quot;public class &quot; + optionsDescriptorsClassName + &quot; implements &quot; + getSimpleName(OPTION_DESCRIPTORS_CLASS_NAME) + &quot; {&quot;);
257 
258             String desc = getSimpleName(OPTION_DESCRIPTOR_CLASS_NAME);
259 
260             Collections.sort(info.options);
261 
262             out.println(&quot;    @Override&quot;);
263             out.println(&quot;    public OptionDescriptor get(String value) {&quot;);
264             out.println(&quot;        switch (value) {&quot;);
265             out.println(&quot;        // CheckStyle: stop line length check&quot;);
266             for (OptionInfo option : info.options) {
267                 String name = option.name;
268                 String optionField = option.declaringClass + &quot;.&quot; + option.field;
269                 out.println(&quot;        case \&quot;&quot; + name + &quot;\&quot;: {&quot;);
270                 String optionType = option.optionType;
271                 String type = option.type;
272                 String help = option.help;
273                 List&lt;String&gt; extraHelp = option.extraHelp;
274                 String declaringClass = option.declaringClass;
275                 String fieldName = option.field;
276                 out.printf(&quot;            return &quot; + desc + &quot;.create(\n&quot;);
277                 out.printf(&quot;                /*name*/ \&quot;%s\&quot;,\n&quot;, name);
278                 out.printf(&quot;                /*optionType*/ %s.%s,\n&quot;, getSimpleName(OPTION_TYPE_CLASS_NAME), optionType);
279                 out.printf(&quot;                /*optionValueType*/ %s.class,\n&quot;, type);
280                 out.printf(&quot;                /*help*/ \&quot;%s\&quot;,\n&quot;, help);
281                 if (extraHelp.size() != 0) {
282                     out.printf(&quot;                /*extraHelp*/ new String[] {\n&quot;);
283                     for (String line : extraHelp) {
284                         out.printf(&quot;                         \&quot;%s\&quot;,\n&quot;, line.replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;));
285                     }
286                     out.printf(&quot;                              },\n&quot;);
287                 }
288                 out.printf(&quot;                /*declaringClass*/ %s.class,\n&quot;, declaringClass);
289                 out.printf(&quot;                /*fieldName*/ \&quot;%s\&quot;,\n&quot;, fieldName);
290                 out.printf(&quot;                /*option*/ %s);\n&quot;, optionField);
291                 out.println(&quot;        }&quot;);
292             }
293             out.println(&quot;        // CheckStyle: resume line length check&quot;);
294             out.println(&quot;        }&quot;);
295             out.println(&quot;        return null;&quot;);
296             out.println(&quot;    }&quot;);
297             out.println();
298             out.println(&quot;    @Override&quot;);
299             out.println(&quot;    public Iterator&lt;&quot; + desc + &quot;&gt; iterator() {&quot;);
300             out.println(&quot;        return new Iterator&lt;OptionDescriptor&gt;() {&quot;);
301             out.println(&quot;            int i = 0;&quot;);
302             out.println(&quot;            @Override&quot;);
303             out.println(&quot;            public boolean hasNext() {&quot;);
304             out.println(&quot;                return i &lt; &quot; + info.options.size() + &quot;;&quot;);
305             out.println(&quot;            }&quot;);
306             out.println(&quot;            @Override&quot;);
307             out.println(&quot;            public OptionDescriptor next() {&quot;);
308             out.println(&quot;                switch (i++) {&quot;);
309             for (int i = 0; i &lt; info.options.size(); i++) {
310                 OptionInfo option = info.options.get(i);
311                 out.println(&quot;                    case &quot; + i + &quot;: return get(\&quot;&quot; + option.name + &quot;\&quot;);&quot;);
312             }
313             out.println(&quot;                }&quot;);
314             out.println(&quot;                throw new NoSuchElementException();&quot;);
315             out.println(&quot;            }&quot;);
316             out.println(&quot;        };&quot;);
317             out.println(&quot;    }&quot;);
318             out.println(&quot;}&quot;);
319         }
320     }
321 
322     public static PrintWriter createSourceFile(String pkg, String relativeName, Filer filer, Element... originatingElements) {
323         try {
324             // Ensure Unix line endings to comply with code style guide checked by Checkstyle
325             String className = pkg + &quot;.&quot; + relativeName;
326             JavaFileObject sourceFile = filer.createSourceFile(className, originatingElements);
327             return new PrintWriter(sourceFile.openWriter()) {
328 
329                 @Override
330                 public void println() {
331                     print(&quot;\n&quot;);
332                 }
333             };
334         } catch (IOException e) {
335             throw new RuntimeException(e);
336         }
337     }
338 
339     public static class OptionInfo implements Comparable&lt;OptionInfo&gt; {
340 
341         public final String name;
342         public final String optionType;
343         public final String help;
344         public final List&lt;String&gt; extraHelp;
345         public final String type;
346         public final String declaringClass;
347         public final String field;
348 
349         public OptionInfo(String name, String optionType, String help, List&lt;String&gt; extraHelp, String type, String declaringClass, String field) {
350             this.name = name;
351             this.optionType = optionType;
352             this.help = help;
353             this.extraHelp = extraHelp;
354             this.type = type;
355             this.declaringClass = declaringClass;
356             this.field = field;
357         }
358 
359         @Override
360         public int compareTo(OptionInfo other) {
361             return name.compareTo(other.name);
362         }
363 
364         @Override
365         public String toString() {
366             return declaringClass + &quot;.&quot; + field;
367         }
368     }
369 
370     public static class OptionsInfo {
371 
372         public final String packageName;
373         public final String className;
374         public final List&lt;OptionInfo&gt; options = new ArrayList&lt;&gt;();
375         public final Set&lt;Element&gt; originatingElements = new HashSet&lt;&gt;();
376 
377         public OptionsInfo(String packageName, String className) {
378             this.packageName = packageName;
379             this.className = className;
380         }
381     }
382 
383     private static Element topDeclaringType(Element element) {
384         Element enclosing = element.getEnclosingElement();
385         if (enclosing == null || enclosing.getKind() == ElementKind.PACKAGE) {
386             return element;
387         }
388         return topDeclaringType(enclosing);
389     }
390 
391     @Override
392     public boolean doProcess(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
393         if (roundEnv.processingOver()) {
394             return true;
395         }
396 
397         TypeElement optionTypeElement = getTypeElement(OPTION_CLASS_NAME);
398 
399         optionTypeMirror = optionTypeElement.asType();
400         optionKeyTypeMirror = getTypeElement(OPTION_KEY_CLASS_NAME).asType();
401 
402         Map&lt;Element, OptionsInfo&gt; map = new HashMap&lt;&gt;();
403         for (Element element : roundEnv.getElementsAnnotatedWith(optionTypeElement)) {
404             if (!processed.contains(element)) {
405                 processed.add(element);
406                 Element topDeclaringType = topDeclaringType(element);
407                 OptionsInfo options = map.get(topDeclaringType);
408                 if (options == null) {
409                     String pkg = ((PackageElement) topDeclaringType.getEnclosingElement()).getQualifiedName().toString();
410                     String topDeclaringClass = topDeclaringType.getSimpleName().toString();
411                     options = new OptionsInfo(pkg, topDeclaringClass);
412                     map.put(topDeclaringType, options);
413                 }
414                 if (!element.getEnclosingElement().getSimpleName().toString().endsWith(&quot;Options&quot;)) {
415                     processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Option declaring classes must have a name that ends with &#39;Options&#39;&quot;, element.getEnclosingElement());
416                 }
417                 processElement(element, options);
418             }
419         }
420 
421         boolean ok = true;
422         Map&lt;String, OptionInfo&gt; uniqueness = new HashMap&lt;&gt;();
423         for (Map.Entry&lt;Element, OptionsInfo&gt; e : map.entrySet()) {
424             OptionsInfo info = e.getValue();
425             for (OptionInfo option : info.options) {
426                 OptionInfo conflict = uniqueness.put(option.name, option);
427                 if (conflict != null) {
428                     processingEnv.getMessager().printMessage(Kind.ERROR, &quot;Duplicate option names for &quot; + option + &quot; and &quot; + conflict, e.getKey());
429                     ok = false;
430                 }
431             }
432         }
433 
434         if (ok) {
435             for (OptionsInfo info : map.values()) {
436                 createOptionsDescriptorsFile(processingEnv, info);
437             }
438         }
439 
440         return true;
441     }
442 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.match.processor/src/org/graalvm/compiler/core/match/processor/MatchProcessor.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.match.processor/src/org/graalvm/compiler/core/match/processor/MatchProcessor.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.match.processor/src/org/graalvm/compiler/core/match/processor/MatchProcessor.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.match.processor/src/org/graalvm/compiler/core/match/processor/MatchProcessor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -346,20 +346,27 @@
          * Can multiple users of this node subsume it. Constants can be swallowed into a match even
          * if there are multiple users.
          */
         final boolean shareable;
 
+        /**
+         * Can this node be subsumed into a match even if there are side effecting nodes between
+         * this node and the match.
+         */
+        final boolean ignoresSideEffects;
+
         final Set<Element> originatingElements = new HashSet<>();
 
-        TypeDescriptor(TypeMirror mirror, String shortName, String nodeClass, String nodePackage, List<String> inputs, boolean commutative, boolean shareable) {
+        TypeDescriptor(TypeMirror mirror, String shortName, String nodeClass, String nodePackage, List<String> inputs, boolean commutative, boolean shareable, boolean ignoresSideEffects) {
             this.mirror = mirror;
             this.shortName = shortName;
             this.nodeClass = nodeClass;
             this.nodePackage = nodePackage;
             this.inputs = inputs;
             this.commutative = commutative;
             this.shareable = shareable;
+            this.ignoresSideEffects = ignoresSideEffects;
             assert !commutative || inputs.size() == 2;
         }
     }
 
     /**
@@ -367,12 +374,13 @@
      */
     Map<String, TypeDescriptor> knownTypes = new HashMap<>();
 
     private TypeDescriptor valueType;
 
-    private void declareType(TypeMirror mirror, String shortName, String nodeClass, String nodePackage, List<String> inputs, boolean commutative, boolean shareable, Element element) {
-        TypeDescriptor descriptor = new TypeDescriptor(mirror, shortName, nodeClass, nodePackage, inputs, commutative, shareable);
+    private void declareType(TypeMirror mirror, String shortName, String nodeClass, String nodePackage, List<String> inputs, boolean commutative, boolean shareable, boolean ignoresSideEffects,
+                    Element element) {
+        TypeDescriptor descriptor = new TypeDescriptor(mirror, shortName, nodeClass, nodePackage, inputs, commutative, shareable, ignoresSideEffects);
         descriptor.originatingElements.add(element);
         knownTypes.put(shortName, descriptor);
     }
 
     private String findPackage(Element type) {
@@ -451,26 +459,26 @@
             return variants;
         }
 
         private String formatPrefix() {
             if (nodeType == valueType) {
-                return String.format("new MatchPattern(%s, false", name != null ? ("\"" + name + "\"") : "null");
+                return String.format("new MatchPattern(%s, false, false", name != null ? ("\"" + name + "\"") : "null");
             } else {
                 return String.format("new MatchPattern(%s.class, %s", nodeType.nodeClass, name != null ? ("\"" + name + "\"") : "null");
             }
         }
 
         private String formatSuffix() {
             if (nodeType != null) {
                 if (inputs.length != nodeType.inputs.size()) {
-                    return ", true)";
+                    return ", true, " + nodeType.ignoresSideEffects + ")";
                 } else {
                     if (nodeType.inputs.size() > 0) {
-                        return ", " + nodeType.nodeClass + "_positions, " + !nodeType.shareable + ")";
+                        return ", " + nodeType.nodeClass + "_positions, " + !nodeType.shareable + ", " + nodeType.ignoresSideEffects + ")";
                     }
                     if (nodeType.shareable) {
-                        return ", false)";
+                        return ", false, " + nodeType.ignoresSideEffects + ")";
                     }
                 }
             }
             return ")";
         }
@@ -719,11 +727,11 @@
                 processMatchableNodes(element);
             }
             // Define a TypeDescriptor for the generic node but don't enter it into the nodeTypes
             // table since it shouldn't be mentioned in match rules.
             TypeMirror valueTypeMirror = getTypeElement(VALUE_NODE_CLASS_NAME).asType();
-            valueType = new TypeDescriptor(valueTypeMirror, "Value", "ValueNode", "org.graalvm.compiler.nodes", Collections.emptyList(), false, false);
+            valueType = new TypeDescriptor(valueTypeMirror, "Value", "ValueNode", "org.graalvm.compiler.nodes", Collections.emptyList(), false, false, false);
 
             Map<TypeElement, MatchRuleDescriptor> map = new HashMap<>();
 
             for (Element element : roundEnv.getElementsAnnotatedWith(matchRuleTypeElement)) {
                 currentElement = element;
@@ -829,11 +837,12 @@
             }
         }
 
         boolean commutative = getAnnotationValue(matchable, "commutative", Boolean.class);
         boolean shareable = getAnnotationValue(matchable, "shareable", Boolean.class);
-        declareType(nodeClassMirror, shortName, nodeClass, nodePackage, inputs, commutative, shareable, element);
+        boolean ignoresSideEffects = getAnnotationValue(matchable, "ignoresSideEffects", Boolean.class);
+        declareType(nodeClassMirror, shortName, nodeClass, nodePackage, inputs, commutative, shareable, ignoresSideEffects, element);
     }
 
     private void processMatchRules(Map<TypeElement, MatchRuleDescriptor> map, Element element, List<AnnotationMirror> matchRules) {
         if (!processedMatchRules.contains(element)) {
             try {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.match.processor/src/org/graalvm/compiler/core/match/processor/MatchProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.core.match.processor;
  26 
  27 import java.io.FileWriter;
  28 import java.io.IOException;
  29 import java.io.PrintWriter;
  30 import java.util.ArrayList;
  31 import java.util.Arrays;
  32 import java.util.Collections;
  33 import java.util.HashMap;
  34 import java.util.HashSet;
  35 import java.util.List;
  36 import java.util.Map;
  37 import java.util.Set;
  38 import java.util.regex.Matcher;
  39 import java.util.regex.Pattern;
  40 
  41 import javax.annotation.processing.Filer;
  42 import javax.annotation.processing.RoundEnvironment;
  43 import javax.annotation.processing.SupportedAnnotationTypes;
  44 import javax.lang.model.SourceVersion;
  45 import javax.lang.model.element.AnnotationMirror;
  46 import javax.lang.model.element.Element;
  47 import javax.lang.model.element.ElementKind;
  48 import javax.lang.model.element.ExecutableElement;
  49 import javax.lang.model.element.Modifier;
  50 import javax.lang.model.element.Name;
  51 import javax.lang.model.element.PackageElement;
  52 import javax.lang.model.element.TypeElement;
  53 import javax.lang.model.element.VariableElement;
  54 import javax.lang.model.type.TypeMirror;
  55 import javax.lang.model.util.ElementFilter;
  56 import javax.lang.model.util.Types;
  57 import javax.tools.Diagnostic.Kind;
  58 import javax.tools.FileObject;
  59 import javax.tools.JavaFileObject;
  60 import javax.tools.StandardLocation;
  61 
  62 import org.graalvm.compiler.processor.AbstractProcessor;
  63 
  64 /**
  65  * Processes classes annotated with {@code MatchRule}. A {@code MatchStatementSet} service is
  66  * generated for each top level class containing at least one such field. These service objects can
  67  * be retrieved as follows:
  68  *
  69  * &lt;pre&gt;
  70  *     Iterable&lt;MatchStatementSet&gt; sl = GraalServices.load(MatchStatementSet.class);
  71  *     for (MatchStatementSet rules : sl) {
  72  *         ...
  73  *     }
  74  * &lt;/pre&gt;
  75  */
  76 @SupportedAnnotationTypes({&quot;org.graalvm.compiler.core.match.MatchRule&quot;, &quot;org.graalvm.compiler.core.match.MatchRules&quot;, &quot;org.graalvm.compiler.core.match.MatchableNode&quot;,
  77                 &quot;org.graalvm.compiler.core.match.MatchableNodes&quot;})
  78 public class MatchProcessor extends AbstractProcessor {
  79 
  80     private static final String VALUE_NODE_CLASS_NAME = &quot;org.graalvm.compiler.nodes.ValueNode&quot;;
  81     private static final String COMPLEX_MATCH_RESULT_CLASS_NAME = &quot;org.graalvm.compiler.core.match.ComplexMatchResult&quot;;
  82     private static final String MATCHABLE_NODES_CLASS_NAME = &quot;org.graalvm.compiler.core.match.MatchableNodes&quot;;
  83     private static final String MATCHABLE_NODE_CLASS_NAME = &quot;org.graalvm.compiler.core.match.MatchableNode&quot;;
  84     private static final String MATCH_RULE_CLASS_NAME = &quot;org.graalvm.compiler.core.match.MatchRule&quot;;
  85     private static final String MATCH_RULES_CLASS_NAME = &quot;org.graalvm.compiler.core.match.MatchRules&quot;;
  86 
  87     public MatchProcessor() {
  88     }
  89 
  90     @Override
  91     public SourceVersion getSupportedSourceVersion() {
  92         return SourceVersion.latest();
  93     }
  94 
  95     private final Set&lt;Element&gt; processedMatchRules = new HashSet&lt;&gt;();
  96     private final Set&lt;Element&gt; processedMatchableNodes = new HashSet&lt;&gt;();
  97 
  98     private static class RuleParseError extends RuntimeException {
  99         private static final long serialVersionUID = 6456128283609257490L;
 100 
 101         RuleParseError(String format, Object... args) {
 102             super(String.format(format, args));
 103         }
 104     }
 105 
 106     private static final Pattern tokenizer = Pattern.compile(&quot;\\s*([()=]|[A-Za-z][A-Za-z0-9]*)\\s*&quot;);
 107 
 108     private class RuleParser {
 109         private ArrayList&lt;TypeDescriptor&gt; capturedTypes = new ArrayList&lt;&gt;();
 110 
 111         private ArrayList&lt;String&gt; capturedNames = new ArrayList&lt;&gt;();
 112 
 113         private final String[] tokens;
 114 
 115         private int current;
 116 
 117         private MatchDescriptor matchDescriptor;
 118 
 119         private final Set&lt;Element&gt; originatingElements = new HashSet&lt;&gt;();
 120 
 121         private Set&lt;String&gt; requiredPackages = new HashSet&lt;&gt;();
 122 
 123         RuleParser(String rule) {
 124             Matcher m = tokenizer.matcher(rule);
 125             List&lt;String&gt; list = new ArrayList&lt;&gt;();
 126             int end = 0;
 127             while (m.lookingAt()) {
 128                 list.add(m.group(1));
 129                 end = m.end();
 130                 m.region(m.end(), m.regionEnd());
 131             }
 132             if (end != m.regionEnd()) {
 133                 throw new RuleParseError(&quot;Unexpected tokens :&quot; + rule.substring(m.end(), m.regionEnd()));
 134             }
 135             tokens = list.toArray(new String[0]);
 136 
 137             matchDescriptor = parseExpression();
 138             if (!done()) {
 139                 throw new RuleParseError(&quot;didn&#39;t consume all tokens&quot;);
 140             }
 141             capturedNames.add(0, &quot;root&quot;);
 142             capturedTypes.add(0, matchDescriptor.nodeType);
 143         }
 144 
 145         String next() {
 146             return tokens[current++];
 147         }
 148 
 149         String peek(String name) {
 150             if (current &gt;= tokens.length) {
 151                 if (name == null) {
 152                     throw new RuleParseError(&quot;Out of tokens&quot;);
 153                 }
 154                 throw new RuleParseError(&quot;Out of tokens looking for %s&quot;, name);
 155             }
 156             return tokens[current];
 157         }
 158 
 159         boolean done() {
 160             return current == tokens.length;
 161         }
 162 
 163         private MatchDescriptor parseExpression() {
 164             if (peek(&quot;(&quot;).equals(&quot;(&quot;)) {
 165                 next();
 166                 MatchDescriptor descriptor = parseType(true);
 167                 for (int n = 0; n &lt; descriptor.nodeType.inputs.size(); n++) {
 168                     if (peek(&quot;(&quot;).equals(&quot;(&quot;)) {
 169                         descriptor.inputs[n] = parseExpression();
 170                     } else {
 171                         descriptor.inputs[n] = parseType(false);
 172                     }
 173                 }
 174                 for (int n = 0; n &lt; descriptor.nodeType.inputs.size(); n++) {
 175                     if (descriptor.inputs[n] == null) {
 176                         throw new RuleParseError(&quot;not enough inputs for &quot; + descriptor.name);
 177                     }
 178                 }
 179                 if (peek(&quot;)&quot;).equals(&quot;)&quot;)) {
 180                     next();
 181                     return descriptor;
 182                 }
 183                 throw new RuleParseError(&quot;Too many arguments to &quot; + descriptor.nodeType.nodeClass);
 184             }
 185             throw new RuleParseError(&quot;Extra tokens following match pattern: &quot; + peek(null));
 186         }
 187 
 188         private MatchDescriptor parseType(boolean forExpression) {
 189             TypeDescriptor type = null;
 190             String name = null;
 191             if (Character.isUpperCase(peek(&quot;node type or name&quot;).charAt(0))) {
 192                 String token = next();
 193                 type = knownTypes.get(token);
 194                 if (type == null) {
 195                     throw new RuleParseError(&quot;Unknown node type: &quot; + token);
 196                 }
 197                 if (peek(&quot;=&quot;).equals(&quot;=&quot;)) {
 198                     next();
 199                     name = next();
 200                 }
 201                 originatingElements.addAll(type.originatingElements);
 202             } else if (Character.isLowerCase(peek(&quot;name&quot;).charAt(0))) {
 203                 name = next();
 204                 type = valueType;
 205             } else {
 206                 throw new RuleParseError(&quot;Unexpected token \&quot;%s\&quot; when looking for name or node type&quot;, peek(null));
 207             }
 208             requiredPackages.add(type.nodePackage);
 209             if (name != null) {
 210                 if (!capturedNames.contains(name)) {
 211                     capturedNames.add(name);
 212                     capturedTypes.add(type);
 213                 } else {
 214                     int index = capturedNames.indexOf(name);
 215                     if (capturedTypes.get(index) != type) {
 216                         throw new RuleParseError(&quot;Captured node \&quot;%s\&quot; has differing types&quot;, name);
 217                     }
 218                 }
 219             }
 220             return new MatchDescriptor(type, name, forExpression);
 221         }
 222 
 223         List&lt;String&gt; generateVariants() {
 224             return matchDescriptor.generateVariants();
 225         }
 226 
 227         /**
 228          * Recursively accumulate any required Position declarations.
 229          */
 230         void generatePositionDeclarations(Set&lt;String&gt; declarations) {
 231             matchDescriptor.generatePositionDeclarations(declarations);
 232         }
 233 
 234         /**
 235          *
 236          * @return the list of node types which are captured by name
 237          */
 238         public ArrayList&lt;TypeDescriptor&gt; capturedTypes() {
 239             return capturedTypes;
 240         }
 241 
 242         public ArrayList&lt;String&gt; capturedNames() {
 243             return capturedNames;
 244         }
 245     }
 246 
 247     /**
 248      * Set to true to enable logging during annotation processing. There&#39;s no normal channel for any
 249      * debug messages and debugging annotation processors requires some special setup.
 250      */
 251     private static final boolean DEBUG = false;
 252 
 253     private PrintWriter log;
 254 
 255     /**
 256      * Logging facility for debugging the annotation processor.
 257      */
 258 
 259     private PrintWriter getLog() {
 260         if (log == null) {
 261             if (processingEnv.getClass().getName().contains(&quot;.javac.&quot;)) {
 262                 // For javac, just log to System.err
 263                 log = new PrintWriter(System.err);
 264             } else {
 265                 try {
 266                     // Create the log file within the generated source directory so it&#39;s easy to
 267                     // find.
 268                     // /tmp isn&#39;t platform independent and java.io.tmpdir can map anywhere,
 269                     // particularly
 270                     // on the mac.
 271                     FileObject file = processingEnv.getFiler().createResource(StandardLocation.SOURCE_OUTPUT, &quot;&quot;, getClass().getSimpleName() + &quot;log&quot;);
 272                     log = new PrintWriter(new FileWriter(file.toUri().getPath(), true));
 273                 } catch (IOException e) {
 274                     // Do nothing
 275                 }
 276             }
 277         }
 278         return log;
 279     }
 280 
 281     private void logMessage(String format, Object... args) {
 282         if (!DEBUG) {
 283             return;
 284         }
 285         PrintWriter bw = getLog();
 286         if (bw != null) {
 287             bw.printf(format, args);
 288             bw.flush();
 289         }
 290     }
 291 
 292     private void logException(Throwable t) {
 293         if (!DEBUG) {
 294             return;
 295         }
 296         PrintWriter bw = getLog();
 297         if (bw != null) {
 298             t.printStackTrace(bw);
 299             bw.flush();
 300         }
 301     }
 302 
 303     /**
 304      * Bugs in an annotation processor can cause silent failure so try to report any exception
 305      * throws as errors.
 306      */
 307     private void reportExceptionThrow(Element element, Throwable t) {
 308         if (element != null) {
 309             logMessage(&quot;throw for %s:\n&quot;, element);
 310         }
 311         logException(t);
 312         printError(element, &quot;Exception throw during processing: %s %s&quot;, t, Arrays.toString(Arrays.copyOf(t.getStackTrace(), 4)));
 313     }
 314 
 315     static class TypeDescriptor {
 316         final TypeMirror mirror;
 317 
 318         /**
 319          * The name uses in match expressions to refer to this type.
 320          */
 321         final String shortName;
 322 
 323         /**
 324          * The simple name of the {@code ValueNode} class represented by this type.
 325          */
 326         final String nodeClass;
 327 
 328         /**
 329          * The package of {@code ValueNode} class represented by this type.
 330          */
 331         final String nodePackage;
 332 
 333         /**
 334          * The matchable inputs of the node.
 335          */
 336         final List&lt;String&gt; inputs;
 337 
 338         /**
 339          * Should swapped variants of this match be generated. The user of the match is expected to
 340          * compensate for any ordering differences in compare which are commutative but require
 341          * reinterpreting the condition in that case.
 342          */
 343         final boolean commutative;
 344 
 345         /**
 346          * Can multiple users of this node subsume it. Constants can be swallowed into a match even
 347          * if there are multiple users.
 348          */
 349         final boolean shareable;
 350 
 351         final Set&lt;Element&gt; originatingElements = new HashSet&lt;&gt;();
 352 
 353         TypeDescriptor(TypeMirror mirror, String shortName, String nodeClass, String nodePackage, List&lt;String&gt; inputs, boolean commutative, boolean shareable) {
 354             this.mirror = mirror;
 355             this.shortName = shortName;
 356             this.nodeClass = nodeClass;
 357             this.nodePackage = nodePackage;
 358             this.inputs = inputs;
 359             this.commutative = commutative;
 360             this.shareable = shareable;
 361             assert !commutative || inputs.size() == 2;
 362         }
 363     }
 364 
 365     /**
 366      * The types which are know for purpose of parsing MatchRule expressions.
 367      */
 368     Map&lt;String, TypeDescriptor&gt; knownTypes = new HashMap&lt;&gt;();
 369 
 370     private TypeDescriptor valueType;
 371 
 372     private void declareType(TypeMirror mirror, String shortName, String nodeClass, String nodePackage, List&lt;String&gt; inputs, boolean commutative, boolean shareable, Element element) {
 373         TypeDescriptor descriptor = new TypeDescriptor(mirror, shortName, nodeClass, nodePackage, inputs, commutative, shareable);
 374         descriptor.originatingElements.add(element);
 375         knownTypes.put(shortName, descriptor);
 376     }
 377 
 378     private String findPackage(Element type) {
 379         PackageElement p = processingEnv.getElementUtils().getPackageOf(type);
 380         if (p != null) {
 381             return p.getQualifiedName().toString();
 382         }
 383         throw new InternalError(&quot;Can&#39;t find package for &quot; + type);
 384     }
 385 
 386     class MatchDescriptor {
 387         TypeDescriptor nodeType;
 388         String name;
 389         MatchDescriptor[] inputs;
 390 
 391         MatchDescriptor(TypeDescriptor nodeType, String name, boolean forExpression) {
 392             this.nodeType = nodeType;
 393             this.name = name;
 394             if (forExpression) {
 395                 this.inputs = new MatchDescriptor[nodeType.inputs.size()];
 396             } else {
 397                 this.inputs = new MatchDescriptor[0];
 398             }
 399         }
 400 
 401         public void generatePositionDeclarations(Set&lt;String&gt; declarations) {
 402             if (inputs.length == 0) {
 403                 return;
 404             }
 405             declarations.add(generatePositionDeclaration());
 406             for (MatchDescriptor desc : inputs) {
 407                 desc.generatePositionDeclarations(declarations);
 408             }
 409         }
 410 
 411         List&lt;String&gt; recurseVariants(int index) {
 412             if (inputs.length == 0) {
 413                 return new ArrayList&lt;&gt;();
 414             }
 415             List&lt;String&gt; currentVariants = inputs[index].generateVariants();
 416             if (index == inputs.length - 1) {
 417                 return currentVariants;
 418             }
 419             List&lt;String&gt; subVariants = recurseVariants(index + 1);
 420             List&lt;String&gt; result = new ArrayList&lt;&gt;();
 421             for (String current : currentVariants) {
 422                 for (String sub : subVariants) {
 423                     result.add(current + &quot;, &quot; + sub);
 424                     if (nodeType.commutative) {
 425                         result.add(sub + &quot;, &quot; + current);
 426                     }
 427                 }
 428             }
 429             return result;
 430         }
 431 
 432         /**
 433          * Recursively generate all the variants of this rule pattern. Currently that just means to
 434          * swap the inputs for commutative rules, producing all possible permutations.
 435          *
 436          * @return a list of Strings which will construct pattern matchers for this rule.
 437          */
 438         List&lt;String&gt; generateVariants() {
 439             String prefix = formatPrefix();
 440             String suffix = formatSuffix();
 441             ArrayList&lt;String&gt; variants = new ArrayList&lt;&gt;();
 442             if (inputs.length &gt; 0) {
 443                 for (String var : recurseVariants(0)) {
 444                     variants.add(prefix + &quot;, &quot; + var + suffix);
 445                 }
 446             } else {
 447                 assert inputs.length == 0;
 448                 variants.add(prefix + suffix);
 449             }
 450 
 451             return variants;
 452         }
 453 
 454         private String formatPrefix() {
 455             if (nodeType == valueType) {
 456                 return String.format(&quot;new MatchPattern(%s, false&quot;, name != null ? (&quot;\&quot;&quot; + name + &quot;\&quot;&quot;) : &quot;null&quot;);
 457             } else {
 458                 return String.format(&quot;new MatchPattern(%s.class, %s&quot;, nodeType.nodeClass, name != null ? (&quot;\&quot;&quot; + name + &quot;\&quot;&quot;) : &quot;null&quot;);
 459             }
 460         }
 461 
 462         private String formatSuffix() {
 463             if (nodeType != null) {
 464                 if (inputs.length != nodeType.inputs.size()) {
 465                     return &quot;, true)&quot;;
 466                 } else {
 467                     if (nodeType.inputs.size() &gt; 0) {
 468                         return &quot;, &quot; + nodeType.nodeClass + &quot;_positions, &quot; + !nodeType.shareable + &quot;)&quot;;
 469                     }
 470                     if (nodeType.shareable) {
 471                         return &quot;, false)&quot;;
 472                     }
 473                 }
 474             }
 475             return &quot;)&quot;;
 476         }
 477 
 478         String generatePositionDeclaration() {
 479             return String.format(&quot;Position[] %s_positions = MatchRuleRegistry.findPositions(%s.TYPE, new String[]{\&quot;%s\&quot;});&quot;, nodeType.nodeClass, nodeType.nodeClass,
 480                             String.join(&quot;\&quot;, \&quot;&quot;, nodeType.inputs));
 481         }
 482     }
 483 
 484     /**
 485      * Strip the package off a class name leaving the full class name including any outer classes.
 486      */
 487     private String fullClassName(Element element) {
 488         String pkg = findPackage(element);
 489         return ((TypeElement) element).getQualifiedName().toString().substring(pkg.length() + 1);
 490     }
 491 
 492     private void createFiles(MatchRuleDescriptor info) {
 493         String pkg = ((PackageElement) info.topDeclaringType.getEnclosingElement()).getQualifiedName().toString();
 494         Name topDeclaringClass = info.topDeclaringType.getSimpleName();
 495 
 496         String matchStatementClassName = topDeclaringClass + &quot;_MatchStatementSet&quot;;
 497         Element[] originatingElements = info.originatingElements.toArray(new Element[info.originatingElements.size()]);
 498 
 499         Types typeUtils = typeUtils();
 500         Filer filer = processingEnv.getFiler();
 501         try (PrintWriter out = createSourceFile(pkg, matchStatementClassName, filer, originatingElements)) {
 502 
 503             out.println(&quot;// CheckStyle: stop header check&quot;);
 504             out.println(&quot;// CheckStyle: stop line length check&quot;);
 505             out.println(&quot;// GENERATED CONTENT - DO NOT EDIT&quot;);
 506             out.println(&quot;// Source: &quot; + topDeclaringClass + &quot;.java&quot;);
 507             out.println(&quot;package &quot; + pkg + &quot;;&quot;);
 508             out.println(&quot;&quot;);
 509             out.println(&quot;import java.util.*;&quot;);
 510             out.println(&quot;import org.graalvm.compiler.core.match.*;&quot;);
 511             out.println(&quot;import org.graalvm.compiler.core.gen.NodeMatchRules;&quot;);
 512             out.println(&quot;import org.graalvm.compiler.graph.Position;&quot;);
 513             for (String p : info.requiredPackages) {
 514                 out.println(&quot;import &quot; + p + &quot;.*;&quot;);
 515             }
 516             out.println(&quot;&quot;);
 517 
 518             out.println(&quot;public class &quot; + matchStatementClassName + &quot; implements MatchStatementSet {&quot;);
 519 
 520             out.println();
 521 
 522             // Generate declarations for the wrapper class to invoke the code generation methods.
 523             for (MethodInvokerItem invoker : info.invokers.values()) {
 524                 StringBuilder args = new StringBuilder();
 525                 StringBuilder types = new StringBuilder();
 526                 int count = invoker.fields.size();
 527                 int index = 0;
 528                 for (VariableElement arg : invoker.fields) {
 529                     args.append(&#39;&quot;&#39;);
 530                     args.append(arg.getSimpleName());
 531                     args.append(&#39;&quot;&#39;);
 532                     types.append(String.format(&quot;(%s) args[%s]&quot;, fullClassName(typeUtils.asElement(arg.asType())), index++));
 533                     if (count-- &gt; 1) {
 534                         args.append(&quot;, &quot;);
 535                         types.append(&quot;, &quot;);
 536                     }
 537                 }
 538                 out.printf(&quot;    private static final String[] %s = new String[] {%s};\n&quot;, invoker.argumentsListName(), args);
 539                 out.printf(&quot;    private static final class %s implements MatchGenerator {\n&quot;, invoker.wrapperClass());
 540                 out.printf(&quot;        static MatchGenerator instance = new %s();\n&quot;, invoker.wrapperClass());
 541                 out.printf(&quot;        @Override\n&quot;);
 542                 out.printf(&quot;        public ComplexMatchResult match(NodeMatchRules nodeMatchRules, Object...args) {\n&quot;);
 543                 out.printf(&quot;            return ((%s) nodeMatchRules).%s(%s);\n&quot;, invoker.nodeLIRBuilderClass, invoker.methodName, types);
 544                 out.printf(&quot;        }\n&quot;);
 545                 out.printf(&quot;        @Override\n&quot;);
 546                 out.printf(&quot;        public String getName() {\n&quot;);
 547                 out.printf(&quot;             return \&quot;%s\&quot;;\n&quot;, invoker.methodName);
 548                 out.printf(&quot;        }\n&quot;);
 549                 out.printf(&quot;    }\n&quot;);
 550                 out.println();
 551 
 552             }
 553 
 554             String desc = &quot;MatchStatement&quot;;
 555 
 556             out.println(&quot;    @Override&quot;);
 557             out.println(&quot;    public Class&lt;? extends NodeMatchRules&gt; forClass() {&quot;);
 558             out.println(&quot;        return &quot; + topDeclaringClass + &quot;.class;&quot;);
 559             out.println(&quot;    }&quot;);
 560             out.println();
 561             out.println(&quot;    @Override&quot;);
 562             out.println(&quot;    public List&lt;&quot; + desc + &quot;&gt; statements() {&quot;);
 563             out.println(&quot;        // Checkstyle: stop &quot;);
 564 
 565             for (String positionDeclaration : info.positionDeclarations) {
 566                 out.println(&quot;        &quot; + positionDeclaration);
 567             }
 568             out.println();
 569 
 570             out.println(&quot;        List&lt;&quot; + desc + &quot;&gt; statements = Collections.unmodifiableList(Arrays.asList(&quot;);
 571 
 572             int i = 0;
 573             for (MatchRuleItem matchRule : info.matchRules) {
 574                 String comma = i == info.matchRules.size() - 1 ? &quot;&quot; : &quot;,&quot;;
 575                 out.printf(&quot;            %s%s\n&quot;, matchRule.ruleBuilder(), comma);
 576                 i++;
 577             }
 578             out.println(&quot;        ));&quot;);
 579             out.println(&quot;        // Checkstyle: resume&quot;);
 580             out.println(&quot;        return statements;&quot;);
 581             out.println(&quot;    }&quot;);
 582 
 583             out.println();
 584 
 585             out.println(&quot;}&quot;);
 586         }
 587         this.createProviderFile(pkg + &quot;.&quot; + matchStatementClassName, &quot;org.graalvm.compiler.core.match.MatchStatementSet&quot;, originatingElements);
 588     }
 589 
 590     protected PrintWriter createSourceFile(String pkg, String relativeName, Filer filer, Element... originatingElements) {
 591         try {
 592             // Ensure Unix line endings to comply with Graal code style guide checked by Checkstyle
 593             JavaFileObject sourceFile = filer.createSourceFile(pkg + &quot;.&quot; + relativeName, originatingElements);
 594             return new PrintWriter(sourceFile.openWriter()) {
 595 
 596                 @Override
 597                 public void println() {
 598                     print(&quot;\n&quot;);
 599                 }
 600             };
 601         } catch (IOException e) {
 602             throw new RuntimeException(e);
 603         }
 604     }
 605 
 606     /**
 607      * Used to generate the MatchStatement constructor invocation.
 608      */
 609     static class MatchRuleItem {
 610         private final String matchPattern;
 611         private final MethodInvokerItem invoker;
 612 
 613         MatchRuleItem(String matchPattern, MethodInvokerItem invoker) {
 614             this.matchPattern = matchPattern;
 615             this.invoker = invoker;
 616         }
 617 
 618         /**
 619          * @return a string which will construct the MatchStatement instance to match this pattern.
 620          */
 621         public String ruleBuilder() {
 622             return String.format(&quot;new MatchStatement(\&quot;%s\&quot;, %s, %s.instance, %s)&quot;, invoker.methodName, matchPattern, invoker.wrapperClass(), invoker.argumentsListName());
 623         }
 624     }
 625 
 626     /**
 627      * Used to generate the wrapper class to invoke the code generation method.
 628      */
 629     static class MethodInvokerItem {
 630         final String methodName;
 631         final String nodeLIRBuilderClass;
 632         final ExecutableElement method;
 633         final List&lt;? extends VariableElement&gt; fields;
 634 
 635         MethodInvokerItem(String methodName, String nodeLIRBuilderClass, ExecutableElement method, List&lt;? extends VariableElement&gt; fields) {
 636             this.methodName = methodName;
 637             this.nodeLIRBuilderClass = nodeLIRBuilderClass;
 638             this.method = method;
 639             this.fields = fields;
 640         }
 641 
 642         String wrapperClass() {
 643             return &quot;MatchGenerator_&quot; + methodName;
 644         }
 645 
 646         String argumentsListName() {
 647             return methodName + &quot;_arguments&quot;;
 648         }
 649     }
 650 
 651     static class MatchRuleDescriptor {
 652 
 653         final TypeElement topDeclaringType;
 654         final List&lt;MatchRuleItem&gt; matchRules = new ArrayList&lt;&gt;();
 655         private final Set&lt;Element&gt; originatingElements = new HashSet&lt;&gt;();
 656         public Set&lt;String&gt; positionDeclarations = new HashSet&lt;&gt;();
 657 
 658         /**
 659          * The mapping between elements with MatchRules and the wrapper class used invoke the code
 660          * generation after the match.
 661          */
 662         Map&lt;String, MethodInvokerItem&gt; invokers = new HashMap&lt;&gt;();
 663 
 664         /**
 665          * The set of packages which must be imported to refer the classes mentioned in matchRules.
 666          */
 667         Set&lt;String&gt; requiredPackages = new HashSet&lt;&gt;();
 668 
 669         MatchRuleDescriptor(TypeElement topDeclaringType) {
 670             this.topDeclaringType = topDeclaringType;
 671         }
 672     }
 673 
 674     private static TypeElement topDeclaringType(Element element) {
 675         Element enclosing = element.getEnclosingElement();
 676         if (enclosing == null || enclosing.getKind() == ElementKind.PACKAGE) {
 677             return (TypeElement) element;
 678         }
 679         return topDeclaringType(enclosing);
 680     }
 681 
 682     /**
 683      * The element currently being processed.
 684      */
 685     private Element currentElement;
 686 
 687     /**
 688      * The current processing round.
 689      */
 690     private RoundEnvironment currentRound;
 691 
 692     @Override
 693     public boolean doProcess(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
 694         if (roundEnv.processingOver()) {
 695             return true;
 696         }
 697 
 698         logMessage(&quot;Starting round %s\n&quot;, roundEnv);
 699 
 700         TypeElement matchRulesTypeElement = getTypeElement(MATCH_RULES_CLASS_NAME);
 701         TypeElement matchRuleTypeElement = getTypeElement(MATCH_RULE_CLASS_NAME);
 702 
 703         TypeMirror matchRulesTypeMirror = matchRulesTypeElement.asType();
 704         TypeMirror matchRuleTypeMirror = matchRuleTypeElement.asType();
 705 
 706         TypeElement matchableNodeTypeElement = getTypeElement(MATCHABLE_NODE_CLASS_NAME);
 707         TypeElement matchableNodesTypeElement = getTypeElement(MATCHABLE_NODES_CLASS_NAME);
 708 
 709         currentRound = roundEnv;
 710         try {
 711             for (Element element : roundEnv.getElementsAnnotatedWith(matchableNodeTypeElement)) {
 712                 currentElement = element;
 713                 logMessage(&quot;%s\n&quot;, element);
 714                 processMatchableNodes(element);
 715             }
 716             for (Element element : roundEnv.getElementsAnnotatedWith(matchableNodesTypeElement)) {
 717                 currentElement = element;
 718                 logMessage(&quot;%s\n&quot;, element);
 719                 processMatchableNodes(element);
 720             }
 721             // Define a TypeDescriptor for the generic node but don&#39;t enter it into the nodeTypes
 722             // table since it shouldn&#39;t be mentioned in match rules.
 723             TypeMirror valueTypeMirror = getTypeElement(VALUE_NODE_CLASS_NAME).asType();
 724             valueType = new TypeDescriptor(valueTypeMirror, &quot;Value&quot;, &quot;ValueNode&quot;, &quot;org.graalvm.compiler.nodes&quot;, Collections.emptyList(), false, false);
 725 
 726             Map&lt;TypeElement, MatchRuleDescriptor&gt; map = new HashMap&lt;&gt;();
 727 
 728             for (Element element : roundEnv.getElementsAnnotatedWith(matchRuleTypeElement)) {
 729                 currentElement = element;
 730                 AnnotationMirror matchRule = getAnnotation(element, matchRuleTypeMirror);
 731                 List&lt;AnnotationMirror&gt; matchRuleAnnotations = Collections.singletonList(matchRule);
 732                 processMatchRules(map, element, matchRuleAnnotations);
 733             }
 734             for (Element element : roundEnv.getElementsAnnotatedWith(matchRulesTypeElement)) {
 735                 currentElement = element;
 736                 AnnotationMirror matchRules = getAnnotation(element, matchRulesTypeMirror);
 737                 List&lt;AnnotationMirror&gt; matchRuleAnnotations = getAnnotationValueList(matchRules, &quot;value&quot;, AnnotationMirror.class);
 738                 processMatchRules(map, element, matchRuleAnnotations);
 739             }
 740 
 741             currentElement = null;
 742             for (MatchRuleDescriptor info : map.values()) {
 743                 createFiles(info);
 744             }
 745 
 746         } catch (Throwable t) {
 747             reportExceptionThrow(currentElement, t);
 748         } finally {
 749             currentElement = null;
 750             currentRound = null;
 751         }
 752 
 753         return true;
 754     }
 755 
 756     /**
 757      * Build up the type table to be used during parsing of the MatchRule.
 758      */
 759     private void processMatchableNodes(Element element) {
 760         if (!processedMatchableNodes.contains(element)) {
 761             try {
 762                 processedMatchableNodes.add(element);
 763 
 764                 List&lt;AnnotationMirror&gt; matchableNodeAnnotations;
 765                 AnnotationMirror mirror = getAnnotation(element, getType(MATCHABLE_NODES_CLASS_NAME));
 766                 if (mirror != null) {
 767                     matchableNodeAnnotations = getAnnotationValueList(mirror, &quot;value&quot;, AnnotationMirror.class);
 768                 } else {
 769                     mirror = getAnnotation(element, getType(MATCHABLE_NODES_CLASS_NAME));
 770                     if (mirror != null) {
 771                         matchableNodeAnnotations = Collections.singletonList(mirror);
 772                     } else {
 773                         return;
 774                     }
 775                 }
 776 
 777                 TypeElement topDeclaringType = topDeclaringType(element);
 778                 for (AnnotationMirror matchableNode : matchableNodeAnnotations) {
 779                     processMatchableNode(element, topDeclaringType, matchableNode);
 780                 }
 781             } catch (Throwable t) {
 782                 reportExceptionThrow(element, t);
 783             }
 784         }
 785     }
 786 
 787     private void processMatchableNode(Element element, TypeElement topDeclaringType, AnnotationMirror matchable) {
 788         logMessage(&quot;processMatchableNode %s %s %s\n&quot;, topDeclaringType, element, matchable);
 789         String nodeClass;
 790         String nodePackage;
 791         TypeMirror nodeClassMirror = getAnnotationValue(matchable, &quot;nodeClass&quot;, TypeMirror.class);
 792         if (nodeClassMirror == null) {
 793             throw new InternalError(&quot;Can&#39;t get mirror for node class &quot; + element);
 794         }
 795         if (nodeClassMirror.toString().equals(MATCHABLE_NODE_CLASS_NAME)) {
 796             nodeClass = topDeclaringType.getQualifiedName().toString();
 797         } else {
 798             nodeClass = nodeClassMirror.toString();
 799         }
 800         TypeElement typeElement = processingEnv.getElementUtils().getTypeElement(nodeClass);
 801         if (typeElement == null) {
 802             printError(element, matchable, &quot;Class \&quot;%s\&quot; cannot be resolved to a type&quot;, nodeClass);
 803             return;
 804         }
 805         nodePackage = findPackage(typeElement);
 806         assert nodeClass.startsWith(nodePackage);
 807         nodeClass = nodeClass.substring(nodePackage.length() + 1);
 808         assert nodeClass.endsWith(&quot;Node&quot;);
 809         String shortName = nodeClass.substring(0, nodeClass.length() - 4);
 810 
 811         Types typeUtils = processingEnv.getTypeUtils();
 812         TypeElement nodeClassElement = (TypeElement) typeUtils.asElement(nodeClassMirror);
 813         List&lt;String&gt; inputs = getAnnotationValueList(matchable, &quot;inputs&quot;, String.class);
 814         for (String input : inputs) {
 815             boolean ok = false;
 816             TypeElement current = nodeClassElement;
 817             while (!ok &amp;&amp; current != null) {
 818                 for (Element fieldElement : ElementFilter.fieldsIn(current.getEnclosedElements())) {
 819                     if (fieldElement.getSimpleName().toString().equals(input)) {
 820                         ok = true;
 821                         break;
 822                     }
 823                 }
 824                 TypeMirror theSuper = current.getSuperclass();
 825                 current = (TypeElement) typeUtils.asElement(theSuper);
 826             }
 827             if (!ok) {
 828                 printError(element, matchable, &quot;Input named \&quot;%s\&quot; doesn&#39;t exist in %s&quot;, input, nodeClassElement.getSimpleName());
 829             }
 830         }
 831 
 832         boolean commutative = getAnnotationValue(matchable, &quot;commutative&quot;, Boolean.class);
 833         boolean shareable = getAnnotationValue(matchable, &quot;shareable&quot;, Boolean.class);
 834         declareType(nodeClassMirror, shortName, nodeClass, nodePackage, inputs, commutative, shareable, element);
 835     }
 836 
 837     private void processMatchRules(Map&lt;TypeElement, MatchRuleDescriptor&gt; map, Element element, List&lt;AnnotationMirror&gt; matchRules) {
 838         if (!processedMatchRules.contains(element)) {
 839             try {
 840                 processedMatchRules.add(element);
 841 
 842                 // The annotation element type should ensure this is true.
 843                 assert element instanceof ExecutableElement;
 844 
 845                 findMatchableNodes(element);
 846 
 847                 TypeElement topDeclaringType = topDeclaringType(element);
 848                 MatchRuleDescriptor info = map.get(topDeclaringType);
 849                 if (info == null) {
 850                     info = new MatchRuleDescriptor(topDeclaringType);
 851                     map.put(topDeclaringType, info);
 852                 }
 853                 for (AnnotationMirror matchRule : matchRules) {
 854                     processMatchRule((ExecutableElement) element, info, matchRule);
 855                 }
 856             } catch (Throwable t) {
 857                 reportExceptionThrow(element, t);
 858             }
 859         }
 860     }
 861 
 862     /**
 863      * Search the super types of element for MatchableNode definitions. Any superclass or super
 864      * interface can contain definitions of matchable nodes.
 865      *
 866      * @param element
 867      */
 868     private void findMatchableNodes(Element element) {
 869         processMatchableNodes(element);
 870         Element enclosing = element.getEnclosingElement();
 871         while (enclosing != null) {
 872             if (enclosing.getKind() == ElementKind.CLASS || enclosing.getKind() == ElementKind.INTERFACE) {
 873                 TypeElement current = (TypeElement) enclosing;
 874                 while (current != null) {
 875                     processMatchableNodes(current);
 876                     for (TypeMirror intf : current.getInterfaces()) {
 877                         Element interfaceElement = typeUtils().asElement(intf);
 878                         processMatchableNodes(interfaceElement);
 879                         // Recurse
 880                         findMatchableNodes(interfaceElement);
 881                     }
 882                     TypeMirror theSuper = current.getSuperclass();
 883                     current = (TypeElement) typeUtils().asElement(theSuper);
 884                 }
 885             }
 886             enclosing = enclosing.getEnclosingElement();
 887         }
 888     }
 889 
 890     private Types typeUtils() {
 891         return processingEnv.getTypeUtils();
 892     }
 893 
 894     private void processMatchRule(ExecutableElement method, MatchRuleDescriptor info, AnnotationMirror matchRule) {
 895         logMessage(&quot;processMatchRule %s\n&quot;, method);
 896 
 897         Types typeUtils = typeUtils();
 898 
 899         if (!method.getModifiers().contains(Modifier.PUBLIC)) {
 900             printError(method, &quot;MatchRule method %s must be public&quot;, method.getSimpleName());
 901             return;
 902         }
 903         if (method.getModifiers().contains(Modifier.STATIC)) {
 904             printError(method, &quot;MatchRule method %s must be non-static&quot;, method.getSimpleName());
 905             return;
 906         }
 907 
 908         try {
 909             TypeMirror returnType = method.getReturnType();
 910             if (!typeUtils.isSameType(returnType, processingEnv.getElementUtils().getTypeElement(COMPLEX_MATCH_RESULT_CLASS_NAME).asType())) {
 911                 printError(method, &quot;MatchRule method return type must be %s&quot;, COMPLEX_MATCH_RESULT_CLASS_NAME);
 912                 return;
 913             }
 914 
 915             String rule = getAnnotationValue(matchRule, &quot;value&quot;, String.class);
 916             RuleParser parser = new RuleParser(rule);
 917             ArrayList&lt;TypeDescriptor&gt; expectedTypes = parser.capturedTypes();
 918             ArrayList&lt;String&gt; expectedNames = parser.capturedNames();
 919             List&lt;? extends VariableElement&gt; actualParameters = method.getParameters();
 920             if (expectedTypes.size() + 1 &lt; actualParameters.size()) {
 921                 printError(method, &quot;Too many arguments for match method %s != %s&quot;, expectedTypes.size() + 1, actualParameters.size());
 922                 return;
 923             }
 924 
 925             // Walk through the parameters to the method and see if they exist in the match rule.
 926             // The order doesn&#39;t matter but only names mentioned in the rule can be used and they
 927             // must be assignment compatible.
 928             for (VariableElement parameter : actualParameters) {
 929                 String name = parameter.getSimpleName().toString();
 930                 int nameIndex = expectedNames.indexOf(name);
 931                 if (nameIndex == -1) {
 932                     printError(method, &quot;Argument \&quot;%s\&quot; isn&#39;t captured in the match rule&quot;, name);
 933                     return;
 934                 }
 935                 TypeMirror type = parameter.asType();
 936                 if (!typeUtils.isAssignable(expectedTypes.get(nameIndex).mirror, type)) {
 937                     printError(method, &quot;Captured value \&quot;%s\&quot; of type %s is not assignable to argument of type %s&quot;, name, expectedTypes.get(nameIndex).mirror, type);
 938                     return;
 939                 }
 940             }
 941 
 942             String methodName = method.getSimpleName().toString();
 943             MethodInvokerItem invoker = info.invokers.get(methodName);
 944             if (invoker == null) {
 945                 invoker = new MethodInvokerItem(methodName, topDeclaringType(method).getSimpleName().toString(), method, actualParameters);
 946                 info.invokers.put(methodName, invoker);
 947             } else if (invoker.method != method) {
 948                 // This could be supported but it&#39;s easier if they are unique since the names
 949                 // are used in log output and snippet counters.
 950                 printError(method, &quot;Use unique method names for match methods: %s.%s != %s.%s&quot;, method.getReceiverType(), method.getSimpleName(), invoker.method.getReceiverType(),
 951                                 invoker.method.getSimpleName());
 952                 return;
 953             }
 954 
 955             Element enclosing = method.getEnclosingElement();
 956             String declaringClass = &quot;&quot;;
 957             String separator = &quot;&quot;;
 958             Set&lt;Element&gt; originatingElementsList = info.originatingElements;
 959             originatingElementsList.add(method);
 960             while (enclosing != null) {
 961                 if (enclosing.getKind() == ElementKind.CLASS || enclosing.getKind() == ElementKind.INTERFACE || enclosing.getKind() == ElementKind.ENUM) {
 962                     if (enclosing.getModifiers().contains(Modifier.PRIVATE)) {
 963                         printError(method, &quot;MatchRule cannot be declared in a private %s %s&quot;, enclosing.getKind().name().toLowerCase(), enclosing);
 964                         return;
 965                     }
 966                     originatingElementsList.add(enclosing);
 967                     declaringClass = enclosing.getSimpleName() + separator + declaringClass;
 968                     separator = &quot;.&quot;;
 969                 } else if (enclosing.getKind() == ElementKind.PACKAGE) {
 970                     break;
 971                 } else {
 972                     printError(method, &quot;MatchRule cannot be declared in a %s&quot;, enclosing.getKind().name().toLowerCase());
 973                     return;
 974                 }
 975                 enclosing = enclosing.getEnclosingElement();
 976             }
 977 
 978             originatingElementsList.addAll(parser.originatingElements);
 979             info.requiredPackages.addAll(parser.requiredPackages);
 980 
 981             // Accumulate any position declarations.
 982             parser.generatePositionDeclarations(info.positionDeclarations);
 983 
 984             List&lt;String&gt; matches = parser.generateVariants();
 985             for (String match : matches) {
 986                 info.matchRules.add(new MatchRuleItem(match, invoker));
 987             }
 988         } catch (RuleParseError e) {
 989             printError(method, matchRule, e.getMessage());
 990         }
 991     }
 992 
 993     private Element elementForMessage(Element e) {
 994         if (currentRound != null &amp;&amp; !currentRound.getRootElements().contains(e) &amp;&amp; currentElement != null) {
 995             return currentElement;
 996         }
 997         return e;
 998     }
 999 
1000     private void printError(Element annotatedElement, String format, Object... args) {
1001         Element e = elementForMessage(annotatedElement);
1002         String prefix = e == annotatedElement ? &quot;&quot; : annotatedElement + &quot;: &quot;;
1003         processingEnv.getMessager().printMessage(Kind.ERROR, prefix + String.format(format, args), e);
1004     }
1005 
1006     private void printError(Element annotatedElement, AnnotationMirror annotation, String format, Object... args) {
1007         Element e = elementForMessage(annotatedElement);
1008         String prefix = e == annotatedElement ? &quot;&quot; : annotation + &quot; on &quot; + annotatedElement + &quot;: &quot;;
1009         processingEnv.getMessager().printMessage(Kind.ERROR, prefix + String.format(format, args), e, annotation);
1010     }
1011 }
    </pre>
  </body>
</html>
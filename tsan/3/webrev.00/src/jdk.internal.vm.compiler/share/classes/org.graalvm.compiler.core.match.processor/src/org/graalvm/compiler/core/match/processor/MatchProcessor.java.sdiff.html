<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.match.processor/src/org/graalvm/compiler/core/match/processor/MatchProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/util/UnsignedLong.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../org.graalvm.compiler.core.sparc/src/org/graalvm/compiler/core/sparc/SPARCArithmeticLIRGenerator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.match.processor/src/org/graalvm/compiler/core/match/processor/MatchProcessor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 331         final String nodePackage;
 332 
 333         /**
 334          * The matchable inputs of the node.
 335          */
 336         final List&lt;String&gt; inputs;
 337 
 338         /**
 339          * Should swapped variants of this match be generated. The user of the match is expected to
 340          * compensate for any ordering differences in compare which are commutative but require
 341          * reinterpreting the condition in that case.
 342          */
 343         final boolean commutative;
 344 
 345         /**
 346          * Can multiple users of this node subsume it. Constants can be swallowed into a match even
 347          * if there are multiple users.
 348          */
 349         final boolean shareable;
 350 






 351         final Set&lt;Element&gt; originatingElements = new HashSet&lt;&gt;();
 352 
<span class="line-modified"> 353         TypeDescriptor(TypeMirror mirror, String shortName, String nodeClass, String nodePackage, List&lt;String&gt; inputs, boolean commutative, boolean shareable) {</span>
 354             this.mirror = mirror;
 355             this.shortName = shortName;
 356             this.nodeClass = nodeClass;
 357             this.nodePackage = nodePackage;
 358             this.inputs = inputs;
 359             this.commutative = commutative;
 360             this.shareable = shareable;

 361             assert !commutative || inputs.size() == 2;
 362         }
 363     }
 364 
 365     /**
 366      * The types which are know for purpose of parsing MatchRule expressions.
 367      */
 368     Map&lt;String, TypeDescriptor&gt; knownTypes = new HashMap&lt;&gt;();
 369 
 370     private TypeDescriptor valueType;
 371 
<span class="line-modified"> 372     private void declareType(TypeMirror mirror, String shortName, String nodeClass, String nodePackage, List&lt;String&gt; inputs, boolean commutative, boolean shareable, Element element) {</span>
<span class="line-modified"> 373         TypeDescriptor descriptor = new TypeDescriptor(mirror, shortName, nodeClass, nodePackage, inputs, commutative, shareable);</span>

 374         descriptor.originatingElements.add(element);
 375         knownTypes.put(shortName, descriptor);
 376     }
 377 
 378     private String findPackage(Element type) {
 379         PackageElement p = processingEnv.getElementUtils().getPackageOf(type);
 380         if (p != null) {
 381             return p.getQualifiedName().toString();
 382         }
 383         throw new InternalError(&quot;Can&#39;t find package for &quot; + type);
 384     }
 385 
 386     class MatchDescriptor {
 387         TypeDescriptor nodeType;
 388         String name;
 389         MatchDescriptor[] inputs;
 390 
 391         MatchDescriptor(TypeDescriptor nodeType, String name, boolean forExpression) {
 392             this.nodeType = nodeType;
 393             this.name = name;
</pre>
<hr />
<pre>
 436          * @return a list of Strings which will construct pattern matchers for this rule.
 437          */
 438         List&lt;String&gt; generateVariants() {
 439             String prefix = formatPrefix();
 440             String suffix = formatSuffix();
 441             ArrayList&lt;String&gt; variants = new ArrayList&lt;&gt;();
 442             if (inputs.length &gt; 0) {
 443                 for (String var : recurseVariants(0)) {
 444                     variants.add(prefix + &quot;, &quot; + var + suffix);
 445                 }
 446             } else {
 447                 assert inputs.length == 0;
 448                 variants.add(prefix + suffix);
 449             }
 450 
 451             return variants;
 452         }
 453 
 454         private String formatPrefix() {
 455             if (nodeType == valueType) {
<span class="line-modified"> 456                 return String.format(&quot;new MatchPattern(%s, false&quot;, name != null ? (&quot;\&quot;&quot; + name + &quot;\&quot;&quot;) : &quot;null&quot;);</span>
 457             } else {
 458                 return String.format(&quot;new MatchPattern(%s.class, %s&quot;, nodeType.nodeClass, name != null ? (&quot;\&quot;&quot; + name + &quot;\&quot;&quot;) : &quot;null&quot;);
 459             }
 460         }
 461 
 462         private String formatSuffix() {
 463             if (nodeType != null) {
 464                 if (inputs.length != nodeType.inputs.size()) {
<span class="line-modified"> 465                     return &quot;, true)&quot;;</span>
 466                 } else {
 467                     if (nodeType.inputs.size() &gt; 0) {
<span class="line-modified"> 468                         return &quot;, &quot; + nodeType.nodeClass + &quot;_positions, &quot; + !nodeType.shareable + &quot;)&quot;;</span>
 469                     }
 470                     if (nodeType.shareable) {
<span class="line-modified"> 471                         return &quot;, false)&quot;;</span>
 472                     }
 473                 }
 474             }
 475             return &quot;)&quot;;
 476         }
 477 
 478         String generatePositionDeclaration() {
 479             return String.format(&quot;Position[] %s_positions = MatchRuleRegistry.findPositions(%s.TYPE, new String[]{\&quot;%s\&quot;});&quot;, nodeType.nodeClass, nodeType.nodeClass,
 480                             String.join(&quot;\&quot;, \&quot;&quot;, nodeType.inputs));
 481         }
 482     }
 483 
 484     /**
 485      * Strip the package off a class name leaving the full class name including any outer classes.
 486      */
 487     private String fullClassName(Element element) {
 488         String pkg = findPackage(element);
 489         return ((TypeElement) element).getQualifiedName().toString().substring(pkg.length() + 1);
 490     }
 491 
</pre>
<hr />
<pre>
 704         TypeMirror matchRuleTypeMirror = matchRuleTypeElement.asType();
 705 
 706         TypeElement matchableNodeTypeElement = getTypeElement(MATCHABLE_NODE_CLASS_NAME);
 707         TypeElement matchableNodesTypeElement = getTypeElement(MATCHABLE_NODES_CLASS_NAME);
 708 
 709         currentRound = roundEnv;
 710         try {
 711             for (Element element : roundEnv.getElementsAnnotatedWith(matchableNodeTypeElement)) {
 712                 currentElement = element;
 713                 logMessage(&quot;%s\n&quot;, element);
 714                 processMatchableNodes(element);
 715             }
 716             for (Element element : roundEnv.getElementsAnnotatedWith(matchableNodesTypeElement)) {
 717                 currentElement = element;
 718                 logMessage(&quot;%s\n&quot;, element);
 719                 processMatchableNodes(element);
 720             }
 721             // Define a TypeDescriptor for the generic node but don&#39;t enter it into the nodeTypes
 722             // table since it shouldn&#39;t be mentioned in match rules.
 723             TypeMirror valueTypeMirror = getTypeElement(VALUE_NODE_CLASS_NAME).asType();
<span class="line-modified"> 724             valueType = new TypeDescriptor(valueTypeMirror, &quot;Value&quot;, &quot;ValueNode&quot;, &quot;org.graalvm.compiler.nodes&quot;, Collections.emptyList(), false, false);</span>
 725 
 726             Map&lt;TypeElement, MatchRuleDescriptor&gt; map = new HashMap&lt;&gt;();
 727 
 728             for (Element element : roundEnv.getElementsAnnotatedWith(matchRuleTypeElement)) {
 729                 currentElement = element;
 730                 AnnotationMirror matchRule = getAnnotation(element, matchRuleTypeMirror);
 731                 List&lt;AnnotationMirror&gt; matchRuleAnnotations = Collections.singletonList(matchRule);
 732                 processMatchRules(map, element, matchRuleAnnotations);
 733             }
 734             for (Element element : roundEnv.getElementsAnnotatedWith(matchRulesTypeElement)) {
 735                 currentElement = element;
 736                 AnnotationMirror matchRules = getAnnotation(element, matchRulesTypeMirror);
 737                 List&lt;AnnotationMirror&gt; matchRuleAnnotations = getAnnotationValueList(matchRules, &quot;value&quot;, AnnotationMirror.class);
 738                 processMatchRules(map, element, matchRuleAnnotations);
 739             }
 740 
 741             currentElement = null;
 742             for (MatchRuleDescriptor info : map.values()) {
 743                 createFiles(info);
 744             }
</pre>
<hr />
<pre>
 814         for (String input : inputs) {
 815             boolean ok = false;
 816             TypeElement current = nodeClassElement;
 817             while (!ok &amp;&amp; current != null) {
 818                 for (Element fieldElement : ElementFilter.fieldsIn(current.getEnclosedElements())) {
 819                     if (fieldElement.getSimpleName().toString().equals(input)) {
 820                         ok = true;
 821                         break;
 822                     }
 823                 }
 824                 TypeMirror theSuper = current.getSuperclass();
 825                 current = (TypeElement) typeUtils.asElement(theSuper);
 826             }
 827             if (!ok) {
 828                 printError(element, matchable, &quot;Input named \&quot;%s\&quot; doesn&#39;t exist in %s&quot;, input, nodeClassElement.getSimpleName());
 829             }
 830         }
 831 
 832         boolean commutative = getAnnotationValue(matchable, &quot;commutative&quot;, Boolean.class);
 833         boolean shareable = getAnnotationValue(matchable, &quot;shareable&quot;, Boolean.class);
<span class="line-modified"> 834         declareType(nodeClassMirror, shortName, nodeClass, nodePackage, inputs, commutative, shareable, element);</span>

 835     }
 836 
 837     private void processMatchRules(Map&lt;TypeElement, MatchRuleDescriptor&gt; map, Element element, List&lt;AnnotationMirror&gt; matchRules) {
 838         if (!processedMatchRules.contains(element)) {
 839             try {
 840                 processedMatchRules.add(element);
 841 
 842                 // The annotation element type should ensure this is true.
 843                 assert element instanceof ExecutableElement;
 844 
 845                 findMatchableNodes(element);
 846 
 847                 TypeElement topDeclaringType = topDeclaringType(element);
 848                 MatchRuleDescriptor info = map.get(topDeclaringType);
 849                 if (info == null) {
 850                     info = new MatchRuleDescriptor(topDeclaringType);
 851                     map.put(topDeclaringType, info);
 852                 }
 853                 for (AnnotationMirror matchRule : matchRules) {
 854                     processMatchRule((ExecutableElement) element, info, matchRule);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 331         final String nodePackage;
 332 
 333         /**
 334          * The matchable inputs of the node.
 335          */
 336         final List&lt;String&gt; inputs;
 337 
 338         /**
 339          * Should swapped variants of this match be generated. The user of the match is expected to
 340          * compensate for any ordering differences in compare which are commutative but require
 341          * reinterpreting the condition in that case.
 342          */
 343         final boolean commutative;
 344 
 345         /**
 346          * Can multiple users of this node subsume it. Constants can be swallowed into a match even
 347          * if there are multiple users.
 348          */
 349         final boolean shareable;
 350 
<span class="line-added"> 351         /**</span>
<span class="line-added"> 352          * Can this node be subsumed into a match even if there are side effecting nodes between</span>
<span class="line-added"> 353          * this node and the match.</span>
<span class="line-added"> 354          */</span>
<span class="line-added"> 355         final boolean ignoresSideEffects;</span>
<span class="line-added"> 356 </span>
 357         final Set&lt;Element&gt; originatingElements = new HashSet&lt;&gt;();
 358 
<span class="line-modified"> 359         TypeDescriptor(TypeMirror mirror, String shortName, String nodeClass, String nodePackage, List&lt;String&gt; inputs, boolean commutative, boolean shareable, boolean ignoresSideEffects) {</span>
 360             this.mirror = mirror;
 361             this.shortName = shortName;
 362             this.nodeClass = nodeClass;
 363             this.nodePackage = nodePackage;
 364             this.inputs = inputs;
 365             this.commutative = commutative;
 366             this.shareable = shareable;
<span class="line-added"> 367             this.ignoresSideEffects = ignoresSideEffects;</span>
 368             assert !commutative || inputs.size() == 2;
 369         }
 370     }
 371 
 372     /**
 373      * The types which are know for purpose of parsing MatchRule expressions.
 374      */
 375     Map&lt;String, TypeDescriptor&gt; knownTypes = new HashMap&lt;&gt;();
 376 
 377     private TypeDescriptor valueType;
 378 
<span class="line-modified"> 379     private void declareType(TypeMirror mirror, String shortName, String nodeClass, String nodePackage, List&lt;String&gt; inputs, boolean commutative, boolean shareable, boolean ignoresSideEffects,</span>
<span class="line-modified"> 380                     Element element) {</span>
<span class="line-added"> 381         TypeDescriptor descriptor = new TypeDescriptor(mirror, shortName, nodeClass, nodePackage, inputs, commutative, shareable, ignoresSideEffects);</span>
 382         descriptor.originatingElements.add(element);
 383         knownTypes.put(shortName, descriptor);
 384     }
 385 
 386     private String findPackage(Element type) {
 387         PackageElement p = processingEnv.getElementUtils().getPackageOf(type);
 388         if (p != null) {
 389             return p.getQualifiedName().toString();
 390         }
 391         throw new InternalError(&quot;Can&#39;t find package for &quot; + type);
 392     }
 393 
 394     class MatchDescriptor {
 395         TypeDescriptor nodeType;
 396         String name;
 397         MatchDescriptor[] inputs;
 398 
 399         MatchDescriptor(TypeDescriptor nodeType, String name, boolean forExpression) {
 400             this.nodeType = nodeType;
 401             this.name = name;
</pre>
<hr />
<pre>
 444          * @return a list of Strings which will construct pattern matchers for this rule.
 445          */
 446         List&lt;String&gt; generateVariants() {
 447             String prefix = formatPrefix();
 448             String suffix = formatSuffix();
 449             ArrayList&lt;String&gt; variants = new ArrayList&lt;&gt;();
 450             if (inputs.length &gt; 0) {
 451                 for (String var : recurseVariants(0)) {
 452                     variants.add(prefix + &quot;, &quot; + var + suffix);
 453                 }
 454             } else {
 455                 assert inputs.length == 0;
 456                 variants.add(prefix + suffix);
 457             }
 458 
 459             return variants;
 460         }
 461 
 462         private String formatPrefix() {
 463             if (nodeType == valueType) {
<span class="line-modified"> 464                 return String.format(&quot;new MatchPattern(%s, false, false&quot;, name != null ? (&quot;\&quot;&quot; + name + &quot;\&quot;&quot;) : &quot;null&quot;);</span>
 465             } else {
 466                 return String.format(&quot;new MatchPattern(%s.class, %s&quot;, nodeType.nodeClass, name != null ? (&quot;\&quot;&quot; + name + &quot;\&quot;&quot;) : &quot;null&quot;);
 467             }
 468         }
 469 
 470         private String formatSuffix() {
 471             if (nodeType != null) {
 472                 if (inputs.length != nodeType.inputs.size()) {
<span class="line-modified"> 473                     return &quot;, true, &quot; + nodeType.ignoresSideEffects + &quot;)&quot;;</span>
 474                 } else {
 475                     if (nodeType.inputs.size() &gt; 0) {
<span class="line-modified"> 476                         return &quot;, &quot; + nodeType.nodeClass + &quot;_positions, &quot; + !nodeType.shareable + &quot;, &quot; + nodeType.ignoresSideEffects + &quot;)&quot;;</span>
 477                     }
 478                     if (nodeType.shareable) {
<span class="line-modified"> 479                         return &quot;, false, &quot; + nodeType.ignoresSideEffects + &quot;)&quot;;</span>
 480                     }
 481                 }
 482             }
 483             return &quot;)&quot;;
 484         }
 485 
 486         String generatePositionDeclaration() {
 487             return String.format(&quot;Position[] %s_positions = MatchRuleRegistry.findPositions(%s.TYPE, new String[]{\&quot;%s\&quot;});&quot;, nodeType.nodeClass, nodeType.nodeClass,
 488                             String.join(&quot;\&quot;, \&quot;&quot;, nodeType.inputs));
 489         }
 490     }
 491 
 492     /**
 493      * Strip the package off a class name leaving the full class name including any outer classes.
 494      */
 495     private String fullClassName(Element element) {
 496         String pkg = findPackage(element);
 497         return ((TypeElement) element).getQualifiedName().toString().substring(pkg.length() + 1);
 498     }
 499 
</pre>
<hr />
<pre>
 712         TypeMirror matchRuleTypeMirror = matchRuleTypeElement.asType();
 713 
 714         TypeElement matchableNodeTypeElement = getTypeElement(MATCHABLE_NODE_CLASS_NAME);
 715         TypeElement matchableNodesTypeElement = getTypeElement(MATCHABLE_NODES_CLASS_NAME);
 716 
 717         currentRound = roundEnv;
 718         try {
 719             for (Element element : roundEnv.getElementsAnnotatedWith(matchableNodeTypeElement)) {
 720                 currentElement = element;
 721                 logMessage(&quot;%s\n&quot;, element);
 722                 processMatchableNodes(element);
 723             }
 724             for (Element element : roundEnv.getElementsAnnotatedWith(matchableNodesTypeElement)) {
 725                 currentElement = element;
 726                 logMessage(&quot;%s\n&quot;, element);
 727                 processMatchableNodes(element);
 728             }
 729             // Define a TypeDescriptor for the generic node but don&#39;t enter it into the nodeTypes
 730             // table since it shouldn&#39;t be mentioned in match rules.
 731             TypeMirror valueTypeMirror = getTypeElement(VALUE_NODE_CLASS_NAME).asType();
<span class="line-modified"> 732             valueType = new TypeDescriptor(valueTypeMirror, &quot;Value&quot;, &quot;ValueNode&quot;, &quot;org.graalvm.compiler.nodes&quot;, Collections.emptyList(), false, false, false);</span>
 733 
 734             Map&lt;TypeElement, MatchRuleDescriptor&gt; map = new HashMap&lt;&gt;();
 735 
 736             for (Element element : roundEnv.getElementsAnnotatedWith(matchRuleTypeElement)) {
 737                 currentElement = element;
 738                 AnnotationMirror matchRule = getAnnotation(element, matchRuleTypeMirror);
 739                 List&lt;AnnotationMirror&gt; matchRuleAnnotations = Collections.singletonList(matchRule);
 740                 processMatchRules(map, element, matchRuleAnnotations);
 741             }
 742             for (Element element : roundEnv.getElementsAnnotatedWith(matchRulesTypeElement)) {
 743                 currentElement = element;
 744                 AnnotationMirror matchRules = getAnnotation(element, matchRulesTypeMirror);
 745                 List&lt;AnnotationMirror&gt; matchRuleAnnotations = getAnnotationValueList(matchRules, &quot;value&quot;, AnnotationMirror.class);
 746                 processMatchRules(map, element, matchRuleAnnotations);
 747             }
 748 
 749             currentElement = null;
 750             for (MatchRuleDescriptor info : map.values()) {
 751                 createFiles(info);
 752             }
</pre>
<hr />
<pre>
 822         for (String input : inputs) {
 823             boolean ok = false;
 824             TypeElement current = nodeClassElement;
 825             while (!ok &amp;&amp; current != null) {
 826                 for (Element fieldElement : ElementFilter.fieldsIn(current.getEnclosedElements())) {
 827                     if (fieldElement.getSimpleName().toString().equals(input)) {
 828                         ok = true;
 829                         break;
 830                     }
 831                 }
 832                 TypeMirror theSuper = current.getSuperclass();
 833                 current = (TypeElement) typeUtils.asElement(theSuper);
 834             }
 835             if (!ok) {
 836                 printError(element, matchable, &quot;Input named \&quot;%s\&quot; doesn&#39;t exist in %s&quot;, input, nodeClassElement.getSimpleName());
 837             }
 838         }
 839 
 840         boolean commutative = getAnnotationValue(matchable, &quot;commutative&quot;, Boolean.class);
 841         boolean shareable = getAnnotationValue(matchable, &quot;shareable&quot;, Boolean.class);
<span class="line-modified"> 842         boolean ignoresSideEffects = getAnnotationValue(matchable, &quot;ignoresSideEffects&quot;, Boolean.class);</span>
<span class="line-added"> 843         declareType(nodeClassMirror, shortName, nodeClass, nodePackage, inputs, commutative, shareable, ignoresSideEffects, element);</span>
 844     }
 845 
 846     private void processMatchRules(Map&lt;TypeElement, MatchRuleDescriptor&gt; map, Element element, List&lt;AnnotationMirror&gt; matchRules) {
 847         if (!processedMatchRules.contains(element)) {
 848             try {
 849                 processedMatchRules.add(element);
 850 
 851                 // The annotation element type should ensure this is true.
 852                 assert element instanceof ExecutableElement;
 853 
 854                 findMatchableNodes(element);
 855 
 856                 TypeElement topDeclaringType = topDeclaringType(element);
 857                 MatchRuleDescriptor info = map.get(topDeclaringType);
 858                 if (info == null) {
 859                     info = new MatchRuleDescriptor(topDeclaringType);
 860                     map.put(topDeclaringType, info);
 861                 }
 862                 for (AnnotationMirror matchRule : matchRules) {
 863                     processMatchRule((ExecutableElement) element, info, matchRule);
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/util/UnsignedLong.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../org.graalvm.compiler.core.sparc/src/org/graalvm/compiler/core/sparc/SPARCArithmeticLIRGenerator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/classfile/ClassfileBytecodeProviderTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.test.classfile;
 26 
 27 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD;
 28 import static org.graalvm.compiler.bytecode.Bytecodes.ANEWARRAY;
 29 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE;
 30 import static org.graalvm.compiler.bytecode.Bytecodes.BIPUSH;
 31 import static org.graalvm.compiler.bytecode.Bytecodes.CHECKCAST;
 32 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD;
 33 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE;
 34 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD;
 35 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE;
 36 import static org.graalvm.compiler.bytecode.Bytecodes.GETFIELD;
 37 import static org.graalvm.compiler.bytecode.Bytecodes.GETSTATIC;
 38 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO;
 39 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO_W;
 40 import static org.graalvm.compiler.bytecode.Bytecodes.IFEQ;
 41 import static org.graalvm.compiler.bytecode.Bytecodes.IFGE;
 42 import static org.graalvm.compiler.bytecode.Bytecodes.IFGT;
 43 import static org.graalvm.compiler.bytecode.Bytecodes.IFLE;
 44 import static org.graalvm.compiler.bytecode.Bytecodes.IFLT;
 45 import static org.graalvm.compiler.bytecode.Bytecodes.IFNE;
 46 import static org.graalvm.compiler.bytecode.Bytecodes.IFNONNULL;
 47 import static org.graalvm.compiler.bytecode.Bytecodes.IFNULL;
 48 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPEQ;
 49 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPNE;
 50 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPEQ;
 51 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGE;
 52 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGT;
 53 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLE;
 54 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLT;
 55 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPNE;
 56 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD;
 57 import static org.graalvm.compiler.bytecode.Bytecodes.INSTANCEOF;
 58 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEDYNAMIC;
 59 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEINTERFACE;
 60 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESPECIAL;
 61 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESTATIC;
 62 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEVIRTUAL;
 63 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE;
 64 import static org.graalvm.compiler.bytecode.Bytecodes.JSR;
 65 import static org.graalvm.compiler.bytecode.Bytecodes.JSR_W;
 66 import static org.graalvm.compiler.bytecode.Bytecodes.LDC;
 67 import static org.graalvm.compiler.bytecode.Bytecodes.LDC2_W;
 68 import static org.graalvm.compiler.bytecode.Bytecodes.LDC_W;
 69 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD;
 70 import static org.graalvm.compiler.bytecode.Bytecodes.LOOKUPSWITCH;
 71 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE;
 72 import static org.graalvm.compiler.bytecode.Bytecodes.MULTIANEWARRAY;
 73 import static org.graalvm.compiler.bytecode.Bytecodes.NEW;
 74 import static org.graalvm.compiler.bytecode.Bytecodes.NEWARRAY;
 75 import static org.graalvm.compiler.bytecode.Bytecodes.PUTFIELD;
 76 import static org.graalvm.compiler.bytecode.Bytecodes.PUTSTATIC;
 77 import static org.graalvm.compiler.bytecode.Bytecodes.RET;
 78 import static org.graalvm.compiler.bytecode.Bytecodes.SIPUSH;
 79 import static org.graalvm.compiler.bytecode.Bytecodes.TABLESWITCH;
 80 
 81 import java.io.File;
 82 import java.io.IOException;
 83 import java.lang.reflect.Executable;
 84 import java.lang.reflect.Method;
 85 import java.util.Enumeration;
 86 import java.util.Formatter;
 87 import java.util.zip.ZipEntry;
 88 import java.util.zip.ZipFile;
 89 
<a name="2" id="anc2"></a>





 90 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 91 import org.graalvm.compiler.api.test.Graal;
 92 import org.graalvm.compiler.bytecode.Bytecode;
 93 import org.graalvm.compiler.bytecode.BytecodeDisassembler;
 94 import org.graalvm.compiler.bytecode.BytecodeLookupSwitch;
 95 import org.graalvm.compiler.bytecode.BytecodeStream;
 96 import org.graalvm.compiler.bytecode.BytecodeSwitch;
 97 import org.graalvm.compiler.bytecode.BytecodeTableSwitch;
 98 import org.graalvm.compiler.bytecode.Bytecodes;
 99 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
100 import org.graalvm.compiler.core.test.GraalCompilerTest;
101 import org.graalvm.compiler.phases.VerifyPhase;
102 import org.graalvm.compiler.phases.util.Providers;
103 import org.graalvm.compiler.replacements.classfile.ClassfileBytecode;
104 import org.graalvm.compiler.replacements.classfile.ClassfileBytecodeProvider;
105 import org.graalvm.compiler.runtime.RuntimeProvider;
<a name="3" id="anc3"></a><span class="line-added">106 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
<span class="line-added">107 import org.graalvm.compiler.api.test.ModuleSupport;</span>
<span class="line-added">108 import org.graalvm.compiler.test.SubprocessUtil;</span>
<span class="line-added">109 import org.junit.Assert;</span>
<span class="line-added">110 import org.junit.Assume;</span>
<span class="line-added">111 import org.junit.Before;</span>
<span class="line-added">112 import org.junit.Test;</span>
113 
114 import jdk.vm.ci.meta.ConstantPool;
115 import jdk.vm.ci.meta.JavaField;
116 import jdk.vm.ci.meta.JavaMethodProfile.ProfiledMethod;
117 import jdk.vm.ci.meta.JavaType;
118 import jdk.vm.ci.meta.MetaAccessProvider;
119 import jdk.vm.ci.meta.ResolvedJavaField;
120 import jdk.vm.ci.meta.ResolvedJavaMethod;
121 import jdk.vm.ci.meta.ResolvedJavaType;
122 
123 /**
124  * Tests that bytecode exposed via {@link ClassfileBytecode} objects is the same as the bytecode
125  * (modulo minor differences in constant pool resolution) obtained directly from
126  * {@link ResolvedJavaMethod} objects.
127  */
128 public class ClassfileBytecodeProviderTest extends GraalCompilerTest {
129 
130     @Before
131     public void checkJavaAgent() {
132         assumeManagementLibraryIsLoadable();
133         Assume.assumeFalse(&quot;Java Agent found -&gt; skipping&quot;, SubprocessUtil.isJavaAgentAttached());
134     }
135 
136     private static boolean shouldProcess(String classpathEntry) {
137         if (classpathEntry.endsWith(&quot;.jar&quot;)) {
138             String name = new File(classpathEntry).getName();
139             return name.contains(&quot;jvmci&quot;) || name.contains(&quot;graal&quot;);
140         }
141         return false;
142     }
143 
<a name="4" id="anc4"></a><span class="line-added">144     /**</span>
<span class="line-added">145      * Keep test time down by only sampling a limited number of class files per jar.</span>
<span class="line-added">146      */</span>
<span class="line-added">147     private static final int CLASSES_PER_JAR = 250;</span>
<span class="line-added">148 </span>
<span class="line-added">149     /**</span>
<span class="line-added">150      * Magic token to denote the classes in the Java runtime image (i.e. in the {@code jrt:/} file</span>
<span class="line-added">151      * system).</span>
<span class="line-added">152      */</span>
<span class="line-added">153     public static final String JRT_CLASS_PATH_ENTRY = &quot;&lt;jrt&gt;&quot;;</span>
<span class="line-added">154 </span>
155     @Test
156     public void test() {
157         RuntimeProvider rt = Graal.getRequiredCapability(RuntimeProvider.class);
158         Providers providers = rt.getHostBackend().getProviders();
159         MetaAccessProvider metaAccess = providers.getMetaAccess();
160 
161         Assume.assumeTrue(VerifyPhase.class.desiredAssertionStatus());
<a name="5" id="anc5"></a><span class="line-modified">162         String bootclasspath;</span>
<span class="line-modified">163         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
<span class="line-modified">164             String propertyName = &quot;sun.boot.class.path&quot;;</span>
<span class="line-modified">165             bootclasspath = System.getProperty(propertyName);</span>
<span class="line-added">166             Assert.assertNotNull(&quot;Cannot find value of &quot; + propertyName, bootclasspath);</span>
<span class="line-added">167         } else {</span>
<span class="line-added">168             bootclasspath = JRT_CLASS_PATH_ENTRY;</span>
<span class="line-added">169         }</span>
170 
171         for (String path : bootclasspath.split(File.pathSeparator)) {
172             if (shouldProcess(path)) {
173                 try {
<a name="6" id="anc6"></a><span class="line-modified">174                     if (path.equals(JRT_CLASS_PATH_ENTRY)) {</span>
<span class="line-modified">175                         for (String className : ModuleSupport.getJRTGraalClassNames()) {</span>
<span class="line-modified">176                             if (isGSON(className)) {</span>




177                                 /*
<a name="7" id="anc7"></a><span class="line-modified">178                                  * GSON classes are compiled with old JDK</span>

179                                  */
180                                 continue;
181                             }
<a name="8" id="anc8"></a>



182                             try {
183                                 checkClass(metaAccess, getSnippetReflection(), className);
184                             } catch (ClassNotFoundException e) {
185                                 throw new AssertionError(e);
186                             }
187                         }
<a name="9" id="anc9"></a><span class="line-added">188                     } else {</span>
<span class="line-added">189                         final ZipFile zipFile = new ZipFile(new File(path));</span>
<span class="line-added">190                         int index = 0;</span>
<span class="line-added">191                         int step = zipFile.size() &gt; CLASSES_PER_JAR ? zipFile.size() / CLASSES_PER_JAR : 1;</span>
<span class="line-added">192                         for (final Enumeration&lt;? extends ZipEntry&gt; entry = zipFile.entries(); entry.hasMoreElements();) {</span>
<span class="line-added">193                             final ZipEntry zipEntry = entry.nextElement();</span>
<span class="line-added">194                             if ((index % step) == 0) {</span>
<span class="line-added">195                                 String name = zipEntry.getName();</span>
<span class="line-added">196                                 if (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.equals(&quot;module-info.class&quot;) &amp;&amp; !name.startsWith(&quot;META-INF/versions/&quot;)) {</span>
<span class="line-added">197                                     String className = name.substring(0, name.length() - &quot;.class&quot;.length()).replace(&#39;/&#39;, &#39;.&#39;);</span>
<span class="line-added">198                                     if (isInNativeImage(className)) {</span>
<span class="line-added">199                                         /*</span>
<span class="line-added">200                                          * Native image requires non-graalsdk classes to be present</span>
<span class="line-added">201                                          * in the classpath.</span>
<span class="line-added">202                                          */</span>
<span class="line-added">203                                         continue;</span>
<span class="line-added">204                                     }</span>
<span class="line-added">205                                     if (isGSON(className)) {</span>
<span class="line-added">206                                         /* uses old class format */</span>
<span class="line-added">207                                         continue;</span>
<span class="line-added">208                                     }</span>
<span class="line-added">209                                     try {</span>
<span class="line-added">210                                         checkClass(metaAccess, getSnippetReflection(), className);</span>
<span class="line-added">211                                     } catch (UnsupportedClassVersionError e) {</span>
<span class="line-added">212                                         // graal-test.jar can contain classes compiled for different</span>
<span class="line-added">213                                         // Java versions</span>
<span class="line-added">214                                     } catch (NoClassDefFoundError e) {</span>
<span class="line-added">215                                         if (!e.getMessage().contains(&quot;Could not initialize class&quot;)) {</span>
<span class="line-added">216                                             throw e;</span>
<span class="line-added">217                                         } else {</span>
<span class="line-added">218                                             // A second or later attempt to initialize a class</span>
<span class="line-added">219                                             // results in this confusing error where the</span>
<span class="line-added">220                                             // original cause of initialization failure is lost</span>
<span class="line-added">221                                         }</span>
<span class="line-added">222                                     } catch (ClassNotFoundException e) {</span>
<span class="line-added">223                                         throw new AssertionError(e);</span>
<span class="line-added">224                                     }</span>
<span class="line-added">225                                 }</span>
<span class="line-added">226                             }</span>
<span class="line-added">227                             index++;</span>
<span class="line-added">228                         }</span>
229                     }
230                 } catch (IOException ex) {
231                     Assert.fail(ex.toString());
232                 }
233             }
234         }
235     }
236 
237     private static boolean isInNativeImage(String className) {
238         return className.startsWith(&quot;org.graalvm.nativeimage&quot;);
239     }
240 
241     private static boolean isGSON(String className) {
242         return className.contains(&quot;com.google.gson&quot;);
243     }
244 
245     protected void checkClass(MetaAccessProvider metaAccess, SnippetReflectionProvider snippetReflection, String className) throws ClassNotFoundException {
246         if (className.equals(&quot;jdk.vm.ci.services.JVMCIClassLoaderFactory&quot;)) {
247             // JVMCIClassLoaderFactory must only be initialized by the VM
248             return;
249         }
250         Class&lt;?&gt; c = Class.forName(className, true, getClass().getClassLoader());
251         ClassfileBytecodeProvider cbp = new ClassfileBytecodeProvider(metaAccess, snippetReflection);
252         for (Method method : c.getDeclaredMethods()) {
253             checkMethod(cbp, metaAccess, method);
254         }
255     }
256 
257     private static void checkMethod(ClassfileBytecodeProvider cbp, MetaAccessProvider metaAccess, Executable executable) {
258         ResolvedJavaMethod method = metaAccess.lookupJavaMethod(executable);
259         if (method.hasBytecodes()) {
260             Bytecode actual = getBytecode(cbp, method);
261             if (actual != null) {
262                 ResolvedJavaMethodBytecode expected = new ResolvedJavaMethodBytecode(method);
263                 new BytecodeComparer(expected, actual).compare();
264             }
265         }
266     }
267 
268     protected static Bytecode getBytecode(ClassfileBytecodeProvider cbp, ResolvedJavaMethod method) {
269         try {
270             return cbp.getBytecode(method);
271         } catch (UnsupportedClassVersionError e) {
272             // This can happen when a library containing old class files
273             // is bundled into a Graal jar (GR-12672).
274             return null;
275         } catch (Throwable e) {
276             throw new AssertionError(String.format(&quot;Error getting bytecode for %s&quot;, method.format(&quot;%H.%n(%p)&quot;)), e);
277         }
278     }
279 
280     static class BytecodeComparer {
281 
282         private Bytecode expected;
283         private Bytecode actual;
284         private ConstantPool eCp;
285         private ConstantPool aCp;
286         BytecodeStream eStream;
287         BytecodeStream aStream;
288         int bci = -1;
289 
290         BytecodeComparer(Bytecode expected, Bytecode actual) {
291             this.expected = expected;
292             this.actual = actual;
293             this.eCp = expected.getConstantPool();
294             this.aCp = actual.getConstantPool();
295             Assert.assertEquals(expected.getMethod().toString(), expected.getCodeSize(), actual.getCodeSize());
296             this.eStream = new BytecodeStream(expected.getCode());
297             this.aStream = new BytecodeStream(actual.getCode());
298         }
299 
300         public void compare() {
301             try {
302                 compare0();
303             } catch (Throwable e) {
304                 BytecodeDisassembler dis = new BytecodeDisassembler(true, false);
305                 Formatter msg = new Formatter();
306                 msg.format(&quot;Error comparing bytecode for %s&quot;, expected.getMethod().format(&quot;%H.%n(%p)&quot;));
307                 if (bci &gt;= 0) {
308                     msg.format(&quot;%nexpected: %s&quot;, dis.disassemble(expected, bci, eStream.nextBCI() - 1));
309                     msg.format(&quot;%nactual:   %s&quot;, dis.disassemble(actual, bci, aStream.nextBCI() - 1));
310                 }
311                 throw new AssertionError(msg.toString(), e);
312             }
313         }
314 
315         public void compare0() {
316             int opcode = eStream.currentBC();
317             ResolvedJavaMethod method = expected.getMethod();
318             while (opcode != Bytecodes.END) {
319                 bci = eStream.currentBCI();
320                 int actualOpcode = aStream.currentBC();
321                 if (opcode != actualOpcode) {
322                     Assert.assertEquals(opcode, actualOpcode);
323                 }
324                 if (eStream.nextBCI() &gt; bci + 1) {
325                     switch (opcode) {
326                         case BIPUSH:
327                             Assert.assertEquals(eStream.readByte(), aStream.readByte());
328                             break;
329                         case SIPUSH:
330                             Assert.assertEquals(eStream.readShort(), aStream.readShort());
331                             break;
332                         case NEW:
333                         case CHECKCAST:
334                         case INSTANCEOF:
335                         case ANEWARRAY: {
336                             ResolvedJavaType e = lookupType(eCp, eStream.readCPI(), opcode);
337                             ResolvedJavaType a = lookupType(aCp, aStream.readCPI(), opcode);
338                             assertEqualTypes(e, a);
339                             break;
340                         }
341                         case GETSTATIC:
342                         case PUTSTATIC:
343                         case GETFIELD:
344                         case PUTFIELD: {
345                             ResolvedJavaField e = lookupField(eCp, eStream.readCPI(), method, opcode);
346                             ResolvedJavaField a = lookupField(aCp, aStream.readCPI(), method, opcode);
347                             assertEqualFields(e, a);
348                             break;
349                         }
350                         case INVOKEVIRTUAL:
351                         case INVOKESPECIAL:
352                         case INVOKESTATIC: {
353                             ResolvedJavaMethod e = lookupMethod(eCp, eStream.readCPI(), opcode);
354                             ResolvedJavaMethod a = lookupMethodOrNull(aCp, aStream.readCPI(), opcode);
355                             assertEqualMethods(e, a);
356                             break;
357                         }
358                         case INVOKEINTERFACE: {
359                             ResolvedJavaMethod e = lookupMethod(eCp, eStream.readCPI(), opcode);
360                             ResolvedJavaMethod a = lookupMethod(aCp, aStream.readCPI(), opcode);
361                             assertEqualMethods(e, a);
362                             break;
363                         }
364                         case INVOKEDYNAMIC: {
365                             // INVOKEDYNAMIC is not supported by ClassfileBytecodeProvider
366                             return;
367                         }
368                         case LDC:
369                         case LDC_W:
370                         case LDC2_W: {
371                             Object e = lookupConstant(eCp, eStream.readCPI(), opcode);
372                             Object a = lookupConstant(aCp, aStream.readCPI(), opcode);
373                             assertEqualsConstants(e, a);
374                             break;
375                         }
376                         case RET:
377                         case ILOAD:
378                         case LLOAD:
379                         case FLOAD:
380                         case DLOAD:
381                         case ALOAD:
382                         case ISTORE:
383                         case LSTORE:
384                         case FSTORE:
385                         case DSTORE:
386                         case ASTORE: {
387                             Assert.assertEquals(eStream.readLocalIndex(), aStream.readLocalIndex());
388                             break;
389                         }
390                         case IFEQ:
391                         case IFNE:
392                         case IFLT:
393                         case IFGE:
394                         case IFGT:
395                         case IFLE:
396                         case IF_ICMPEQ:
397                         case IF_ICMPNE:
398                         case IF_ICMPLT:
399                         case IF_ICMPGE:
400                         case IF_ICMPGT:
401                         case IF_ICMPLE:
402                         case IF_ACMPEQ:
403                         case IF_ACMPNE:
404                         case GOTO:
405                         case JSR:
406                         case IFNULL:
407                         case IFNONNULL:
408                         case GOTO_W:
409                         case JSR_W: {
410                             Assert.assertEquals(eStream.readBranchDest(), aStream.readBranchDest());
411                             break;
412                         }
413                         case LOOKUPSWITCH:
414                         case TABLESWITCH: {
415                             BytecodeSwitch e = opcode == LOOKUPSWITCH ? new BytecodeLookupSwitch(eStream, bci) : new BytecodeTableSwitch(eStream, bci);
416                             BytecodeSwitch a = opcode == LOOKUPSWITCH ? new BytecodeLookupSwitch(aStream, bci) : new BytecodeTableSwitch(aStream, bci);
417                             Assert.assertEquals(e.numberOfCases(), a.numberOfCases());
418                             for (int i = 0; i &lt; e.numberOfCases(); i++) {
419                                 Assert.assertEquals(e.keyAt(i), a.keyAt(i));
420                                 Assert.assertEquals(e.targetAt(i), a.targetAt(i));
421                             }
422                             Assert.assertEquals(e.defaultTarget(), a.defaultTarget());
423                             Assert.assertEquals(e.defaultOffset(), a.defaultOffset());
424                             break;
425                         }
426                         case NEWARRAY: {
427                             Assert.assertEquals(eStream.readLocalIndex(), aStream.readLocalIndex());
428                             break;
429                         }
430                         case MULTIANEWARRAY: {
431                             ResolvedJavaType e = lookupType(eCp, eStream.readCPI(), opcode);
432                             ResolvedJavaType a = lookupType(aCp, aStream.readCPI(), opcode);
433                             Assert.assertEquals(e, a);
434                             break;
435                         }
436                     }
437                 }
438                 eStream.next();
439                 aStream.next();
440                 opcode = eStream.currentBC();
441             }
442         }
443 
444         static Object lookupConstant(ConstantPool cp, int cpi, int opcode) {
445             cp.loadReferencedType(cpi, opcode);
446             return cp.lookupConstant(cpi);
447         }
448 
449         static ResolvedJavaField lookupField(ConstantPool cp, int cpi, ResolvedJavaMethod method, int opcode) {
450             cp.loadReferencedType(cpi, opcode);
451             return (ResolvedJavaField) cp.lookupField(cpi, method, opcode);
452         }
453 
454         static ResolvedJavaMethod lookupMethod(ConstantPool cp, int cpi, int opcode) {
455             cp.loadReferencedType(cpi, opcode);
456             return (ResolvedJavaMethod) cp.lookupMethod(cpi, opcode);
457         }
458 
459         static ResolvedJavaMethod lookupMethodOrNull(ConstantPool cp, int cpi, int opcode) {
460             try {
461                 return lookupMethod(cp, cpi, opcode);
462             } catch (NoSuchMethodError e) {
463                 // A method hidden to reflection
464                 return null;
465             }
466         }
467 
468         static ResolvedJavaType lookupType(ConstantPool cp, int cpi, int opcode) {
469             cp.loadReferencedType(cpi, opcode);
470             return (ResolvedJavaType) cp.lookupType(cpi, opcode);
471         }
472 
473         static void assertEqualsConstants(Object e, Object a) {
474             if (!e.equals(a)) {
475                 Assert.assertEquals(String.valueOf(e), String.valueOf(a));
476             }
477         }
478 
479         static void assertEqualFields(JavaField e, JavaField a) {
480             if (!e.equals(a)) {
481                 Assert.assertEquals(e.format(&quot;%H.%n %T&quot;), a.format(&quot;%H.%n %T&quot;));
482             }
483         }
484 
485         static void assertEqualTypes(JavaType e, JavaType a) {
486             if (!e.equals(a)) {
487                 Assert.assertEquals(e.toJavaName(), a.toJavaName());
488             }
489         }
490 
491         static void assertEqualMethods(ResolvedJavaMethod e, ResolvedJavaMethod a) {
492             if (a != null) {
493                 if (!e.equals(a)) {
494                     if (!e.equals(a)) {
495                         if (!e.getDeclaringClass().equals(a.getDeclaringClass())) {
496 
497                             if (!typesAreRelated(e, a)) {
498                                 throw new AssertionError(String.format(&quot;%s and %s are unrelated&quot;, a.getDeclaringClass().toJavaName(), e.getDeclaringClass().toJavaName()));
499                             }
500                         }
501                         Assert.assertEquals(e.getName(), a.getName());
502                         Assert.assertEquals(e.getSignature(), a.getSignature());
503                     } else {
504                         Assert.assertEquals(e, a);
505                     }
506                 }
507             }
508         }
509 
510         /**
511          * The VM can resolve references to methods not available via reflection. For example, the
512          * javap output for {@link ProfiledMethod#toString()} includes:
513          *
514          * &lt;pre&gt;
515          *     16: invokeinterface #40, 1 // InterfaceMethod jdk/vm/ci/meta/ResolvedJavaMethod.getName:()Ljava/lang/String;
516          * &lt;/pre&gt;
517          *
518          * When resolving via {@code HotSpotConstantPool}, we get:
519          *
520          * &lt;pre&gt;
521          *     16: invokeinterface#4, 1   // jdk.vm.ci.meta.ResolvedJavaMethod.getName:()java.lang.String
522          * &lt;/pre&gt;
523          *
524          * However resolving via {@code ClassfileConstantPool}, we get:
525          *
526          * &lt;pre&gt;
527          *     16: invokeinterface#40, 1  // jdk.vm.ci.meta.JavaMethod.getName:()java.lang.String
528          * &lt;/pre&gt;
529          *
530          * since the latter relies on {@link ResolvedJavaType#getDeclaredMethods()} which only
531          * returns methods originating from class files.
532          *
533          * We accept such differences for the purpose of this test if the declaring class of two
534          * otherwise similar methods are related (i.e. one is a subclass of the other).
535          */
536         protected static boolean typesAreRelated(ResolvedJavaMethod e, ResolvedJavaMethod a) {
537             return a.getDeclaringClass().isAssignableFrom(e.getDeclaringClass()) || e.getDeclaringClass().isAssignableFrom(a.getDeclaringClass());
538         }
539     }
540 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
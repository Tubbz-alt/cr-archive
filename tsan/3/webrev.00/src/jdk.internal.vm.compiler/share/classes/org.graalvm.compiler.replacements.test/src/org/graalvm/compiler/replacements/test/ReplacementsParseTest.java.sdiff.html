<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/ReplacementsParseTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PointerTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="SnippetsTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/ReplacementsParseTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 52 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 53 import org.graalvm.compiler.nodes.StructuredGraph.Builder;
 54 import org.graalvm.compiler.nodes.ValueNode;
 55 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 56 import org.graalvm.compiler.nodes.extended.OpaqueNode;
 57 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 58 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 59 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 60 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 61 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 62 import org.graalvm.compiler.nodes.graphbuilderconf.NodeIntrinsicPluginFactory;
 63 import org.graalvm.compiler.nodes.spi.LoweringTool;
 64 import org.graalvm.compiler.options.OptionValues;
 65 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 66 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 67 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 68 import org.graalvm.compiler.phases.common.FrameStateAssignmentPhase;
 69 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 70 import org.graalvm.compiler.phases.common.LoweringPhase;
 71 import org.graalvm.compiler.phases.tiers.HighTierContext;
<span class="line-modified"> 72 import org.graalvm.compiler.test.GraalTest;</span>
 73 import jdk.internal.vm.compiler.word.LocationIdentity;
 74 import org.junit.Assert;
 75 import org.junit.Assume;
 76 import org.junit.BeforeClass;
 77 import org.junit.Test;
 78 
 79 import jdk.vm.ci.code.InstalledCode;
 80 import jdk.vm.ci.meta.JavaKind;
 81 import jdk.vm.ci.meta.ResolvedJavaMethod;
 82 
 83 /**
 84  * Tests for expected behavior when parsing snippets and intrinsics.
 85  */
 86 public class ReplacementsParseTest extends ReplacementsTest {
 87 
 88     private static final String IN_COMPILED_HANDLER_MARKER = &quot;*** in compiled handler ***&quot;;
 89 
 90     /**
 91      * Marker value to indicate an exception handler was interpreted. We cannot use a complex string
 92      * expression in this context without risking non-deterministic behavior dependent on whether
</pre>
<hr />
<pre>
301         @MethodSubstitution
302         static int div(int x, int y) {
303             assert y != 0;
304             return x / y;
305         }
306 
307         public static void nonVoidIntrinsicWithCallStub(int zLen) {
308             nonVoidIntrinsicWithCallStub(STUB_CALL, zLen);
309         }
310 
311         static final ForeignCallDescriptor STUB_CALL = new ForeignCallDescriptor(&quot;stubCall&quot;, void.class, int.class);
312 
313         @NodeIntrinsic(ForeignCallNode.class)
314         private static native void nonVoidIntrinsicWithCallStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, int zLen);
315 
316     }
317 
318     @Override
319     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
320         BytecodeProvider replacementBytecodeProvider = getSystemClassLoaderBytecodeProvider();
<span class="line-modified">321         Registration r = new Registration(invocationPlugins, TestObject.class, replacementBytecodeProvider);</span>
322         NodeIntrinsicPluginFactory.InjectionProvider injections = new DummyInjectionProvider();
323         new PluginFactory_ReplacementsParseTest().registerPlugins(invocationPlugins, injections);
324         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;nextAfter&quot;, double.class, double.class);
325         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;stringize&quot;, Object.class);
326         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;stringizeId&quot;, Receiver.class);
327         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;copyFirst&quot;, byte[].class, byte[].class, boolean.class);
328         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;copyFirstL2R&quot;, byte[].class, byte[].class);
329         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;nonVoidIntrinsicWithCall&quot;, int.class, int.class);
330         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;nonVoidIntrinsicWithOptimizedSplit&quot;, int.class);
331         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;div&quot;, int.class, int.class);
332 
333         if (replacementBytecodeProvider.supportsInvokedynamic()) {
334             r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;identity&quot;, String.class);
335         }
336         super.registerInvocationPlugins(invocationPlugins);
337     }
338 
339     @BeforeClass
340     public static void warmupProfiles() {
341         for (int i = 0; i &lt; 40000; i++) {
</pre>
<hr />
<pre>
358 
359     /**
360      * Ensure that calling the substitution method binds to the original method properly.
361      */
362     @Test
363     public void test2() {
364         test(&quot;test2Snippet&quot;, 1.0);
365     }
366 
367     public double test2Snippet(double d) {
368         return TestObject.next2(d);
369     }
370 
371     /**
372      * Ensure that substitution methods with assertions in them don&#39;t complain when the exception
373      * constructor is deleted.
374      */
375 
376     @Test
377     public void testNextAfter() {
<span class="line-modified">378         Assume.assumeFalse(GraalTest.Java8OrEarlier);</span>
379         double[] inArray = new double[1024];
380         double[] outArray = new double[1024];
381         for (int i = 0; i &lt; inArray.length; i++) {
382             inArray[i] = -0.0;
383         }
384         test(&quot;doNextAfter&quot;, inArray, outArray);
385     }
386 
387     public void doNextAfter(double[] outArray, double[] inArray) {
388         for (int i = 0; i &lt; inArray.length; i++) {
389             double direction = (i &amp; 1) == 0 ? Double.POSITIVE_INFINITY : -Double.NEGATIVE_INFINITY;
390             outArray[i] = TestObject.nextAfter(inArray[i], direction);
391         }
392     }
393 
394     private void testWithDifferentReturnValues(OptionValues options, String standardReturnValue, String compiledReturnValue, String name, Object... args) {
395         ResolvedJavaMethod method = getResolvedJavaMethod(name);
396         Object receiver = null;
397 
398         Result expect = executeExpected(method, receiver, args);
</pre>
<hr />
<pre>
413         test(&quot;callStringize&quot;, &quot;a string&quot;);
414         test(&quot;callStringize&quot;, Boolean.TRUE);
415         // Unset &#39;exception seen&#39; bit if testCallStringizeWithoutInlinePartialIntrinsicExit
416         // is executed before this test
417         getResolvedJavaMethod(&quot;callStringize&quot;).reprofile();
418         forceCompileOverride = true;
419         String standardReturnValue = IN_INTERPRETED_HANDLER_MARKER;
420         String compiledReturnValue = IN_COMPILED_HANDLER_MARKER;
421         testWithDifferentReturnValues(getInitialOptions(), standardReturnValue, compiledReturnValue, &quot;callStringize&quot;, THROW_EXCEPTION_MARKER);
422     }
423 
424     @Test
425     public void testCallStringizeWithoutInlinePartialIntrinsicExit() {
426         OptionValues options = new OptionValues(getInitialOptions(), InlinePartialIntrinsicExitDuringParsing, false);
427         test(options, &quot;callStringize&quot;, &quot;a string&quot;);
428         test(options, &quot;callStringize&quot;, Boolean.TRUE);
429         String standardReturnValue = IN_INTERPRETED_HANDLER_MARKER;
430         String compiledReturnValue = IN_COMPILED_HANDLER_MARKER;
431         forceCompileOverride = true;
432         inlineInvokeDecision = InlineInvokePlugin.InlineInfo.DO_NOT_INLINE_WITH_EXCEPTION;
<span class="line-modified">433         inlineInvokeMethodName = &quot;stringizeId&quot;;</span>
434         try {
435             testWithDifferentReturnValues(options, standardReturnValue, compiledReturnValue, &quot;callStringize&quot;, THROW_EXCEPTION_MARKER);
436         } finally {
437             inlineInvokeDecision = null;
438             inlineInvokeMethodName = null;
439         }
440     }
441 
442     @Test
443     public void testCallStringizeId() {
444         test(&quot;callStringizeId&quot;, new TestObject(&quot;a string&quot;));
445         test(&quot;callStringizeId&quot;, new TestObject(Boolean.TRUE));
446         // Unset &#39;exception seen&#39; bit if testCallStringizeIdWithoutInlinePartialIntrinsicExit
447         // is executed before this test
448         getResolvedJavaMethod(&quot;callStringize&quot;).reprofile();
449         forceCompileOverride = true;
450         String standardReturnValue = IN_INTERPRETED_HANDLER_MARKER;
451         String compiledReturnValue = IN_COMPILED_HANDLER_MARKER;
452         testWithDifferentReturnValues(getInitialOptions(), standardReturnValue, compiledReturnValue, &quot;callStringizeId&quot;, new TestObject(THROW_EXCEPTION_MARKER));
453     }
</pre>
<hr />
<pre>
617     public void testAssertionInMethodSubstitution() {
618         try {
619             ResolvedJavaMethod method = getResolvedJavaMethod(&quot;div&quot;);
620             // avoid dumping graphs and printing exception since and exception is expected
621             OptionValues options = new OptionValues(getInitialOptions(), DumpOnError, false);
622             parse(new Builder(options, getDebugContext(options, null, method), AllowAssumptions.YES).method(method).compilationId(getCompilationId(method)), getEagerGraphBuilderSuite());
623             throw GraalError.shouldNotReachHere(&quot;BytecodeParser should have complained about using assertion in an intrinsic.&quot;);
624         } catch (BytecodeParserError e) {
625             // Expected behavior
626         }
627     }
628 
629     @SuppressWarnings(&quot;try&quot;)
630     private void testGraph(String name) {
631         StructuredGraph graph = parseEager(name, StructuredGraph.AllowAssumptions.YES);
632         try (DebugContext.Scope s0 = graph.getDebug().scope(name, graph)) {
633             for (OpaqueNode node : graph.getNodes().filter(OpaqueNode.class)) {
634                 node.remove();
635             }
636             HighTierContext context = getDefaultHighTierContext();
<span class="line-modified">637             CanonicalizerPhase canonicalizer = new CanonicalizerPhase();</span>
638             new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, context);
639             new FloatingReadPhase().apply(graph);
640             canonicalizer.apply(graph, context);
641             new DeadCodeEliminationPhase().apply(graph);
642             new GuardLoweringPhase().apply(graph, getDefaultMidTierContext());
643             new FrameStateAssignmentPhase().apply(graph);
644         } catch (Throwable e) {
645             throw graph.getDebug().handle(e);
646         }
647     }
648 
649     private class DummyInjectionProvider implements NodeIntrinsicPluginFactory.InjectionProvider {
650         @SuppressWarnings(&quot;unchecked&quot;)
651         @Override
652         public &lt;T&gt; T getInjectedArgument(Class&lt;T&gt; type) {
653             if (type == ForeignCallsProvider.class) {
654                 return (T) new ForeignCallsProvider() {
655                     @Override
656                     public LIRKind getValueKind(JavaKind javaKind) {
657                         return null;
</pre>
<hr />
<pre>
664 
665                     @Override
666                     public LocationIdentity[] getKilledLocations(ForeignCallDescriptor descriptor) {
667                         return new LocationIdentity[0];
668                     }
669 
670                     @Override
671                     public boolean canDeoptimize(ForeignCallDescriptor descriptor) {
672                         return false;
673                     }
674 
675                     @Override
676                     public boolean isGuaranteedSafepoint(ForeignCallDescriptor descriptor) {
677                         return false;
678                     }
679 
680                     @Override
681                     public ForeignCallLinkage lookupForeignCall(ForeignCallDescriptor descriptor) {
682                         return null;
683                     }





684                 };
685             }
686             if (type == SnippetReflectionProvider.class) {
687                 return (T) getSnippetReflection();
688             }
689             return null;
690         }
691 
692         @Override
693         public Stamp getInjectedStamp(Class&lt;?&gt; type, boolean nonNull) {
694             JavaKind kind = JavaKind.fromJavaClass(type);
695             return StampFactory.forKind(kind);
696         }
697     }
698 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 52 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 53 import org.graalvm.compiler.nodes.StructuredGraph.Builder;
 54 import org.graalvm.compiler.nodes.ValueNode;
 55 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 56 import org.graalvm.compiler.nodes.extended.OpaqueNode;
 57 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 58 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 59 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 60 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 61 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 62 import org.graalvm.compiler.nodes.graphbuilderconf.NodeIntrinsicPluginFactory;
 63 import org.graalvm.compiler.nodes.spi.LoweringTool;
 64 import org.graalvm.compiler.options.OptionValues;
 65 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 66 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 67 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 68 import org.graalvm.compiler.phases.common.FrameStateAssignmentPhase;
 69 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 70 import org.graalvm.compiler.phases.common.LoweringPhase;
 71 import org.graalvm.compiler.phases.tiers.HighTierContext;
<span class="line-modified"> 72 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
 73 import jdk.internal.vm.compiler.word.LocationIdentity;
 74 import org.junit.Assert;
 75 import org.junit.Assume;
 76 import org.junit.BeforeClass;
 77 import org.junit.Test;
 78 
 79 import jdk.vm.ci.code.InstalledCode;
 80 import jdk.vm.ci.meta.JavaKind;
 81 import jdk.vm.ci.meta.ResolvedJavaMethod;
 82 
 83 /**
 84  * Tests for expected behavior when parsing snippets and intrinsics.
 85  */
 86 public class ReplacementsParseTest extends ReplacementsTest {
 87 
 88     private static final String IN_COMPILED_HANDLER_MARKER = &quot;*** in compiled handler ***&quot;;
 89 
 90     /**
 91      * Marker value to indicate an exception handler was interpreted. We cannot use a complex string
 92      * expression in this context without risking non-deterministic behavior dependent on whether
</pre>
<hr />
<pre>
301         @MethodSubstitution
302         static int div(int x, int y) {
303             assert y != 0;
304             return x / y;
305         }
306 
307         public static void nonVoidIntrinsicWithCallStub(int zLen) {
308             nonVoidIntrinsicWithCallStub(STUB_CALL, zLen);
309         }
310 
311         static final ForeignCallDescriptor STUB_CALL = new ForeignCallDescriptor(&quot;stubCall&quot;, void.class, int.class);
312 
313         @NodeIntrinsic(ForeignCallNode.class)
314         private static native void nonVoidIntrinsicWithCallStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, int zLen);
315 
316     }
317 
318     @Override
319     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
320         BytecodeProvider replacementBytecodeProvider = getSystemClassLoaderBytecodeProvider();
<span class="line-modified">321         Registration r = new Registration(invocationPlugins, TestObject.class, getReplacements(), replacementBytecodeProvider);</span>
322         NodeIntrinsicPluginFactory.InjectionProvider injections = new DummyInjectionProvider();
323         new PluginFactory_ReplacementsParseTest().registerPlugins(invocationPlugins, injections);
324         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;nextAfter&quot;, double.class, double.class);
325         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;stringize&quot;, Object.class);
326         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;stringizeId&quot;, Receiver.class);
327         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;copyFirst&quot;, byte[].class, byte[].class, boolean.class);
328         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;copyFirstL2R&quot;, byte[].class, byte[].class);
329         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;nonVoidIntrinsicWithCall&quot;, int.class, int.class);
330         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;nonVoidIntrinsicWithOptimizedSplit&quot;, int.class);
331         r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;div&quot;, int.class, int.class);
332 
333         if (replacementBytecodeProvider.supportsInvokedynamic()) {
334             r.registerMethodSubstitution(TestObjectSubstitutions.class, &quot;identity&quot;, String.class);
335         }
336         super.registerInvocationPlugins(invocationPlugins);
337     }
338 
339     @BeforeClass
340     public static void warmupProfiles() {
341         for (int i = 0; i &lt; 40000; i++) {
</pre>
<hr />
<pre>
358 
359     /**
360      * Ensure that calling the substitution method binds to the original method properly.
361      */
362     @Test
363     public void test2() {
364         test(&quot;test2Snippet&quot;, 1.0);
365     }
366 
367     public double test2Snippet(double d) {
368         return TestObject.next2(d);
369     }
370 
371     /**
372      * Ensure that substitution methods with assertions in them don&#39;t complain when the exception
373      * constructor is deleted.
374      */
375 
376     @Test
377     public void testNextAfter() {
<span class="line-modified">378         Assume.assumeFalse(JavaVersionUtil.JAVA_SPEC &lt;= 8);</span>
379         double[] inArray = new double[1024];
380         double[] outArray = new double[1024];
381         for (int i = 0; i &lt; inArray.length; i++) {
382             inArray[i] = -0.0;
383         }
384         test(&quot;doNextAfter&quot;, inArray, outArray);
385     }
386 
387     public void doNextAfter(double[] outArray, double[] inArray) {
388         for (int i = 0; i &lt; inArray.length; i++) {
389             double direction = (i &amp; 1) == 0 ? Double.POSITIVE_INFINITY : -Double.NEGATIVE_INFINITY;
390             outArray[i] = TestObject.nextAfter(inArray[i], direction);
391         }
392     }
393 
394     private void testWithDifferentReturnValues(OptionValues options, String standardReturnValue, String compiledReturnValue, String name, Object... args) {
395         ResolvedJavaMethod method = getResolvedJavaMethod(name);
396         Object receiver = null;
397 
398         Result expect = executeExpected(method, receiver, args);
</pre>
<hr />
<pre>
413         test(&quot;callStringize&quot;, &quot;a string&quot;);
414         test(&quot;callStringize&quot;, Boolean.TRUE);
415         // Unset &#39;exception seen&#39; bit if testCallStringizeWithoutInlinePartialIntrinsicExit
416         // is executed before this test
417         getResolvedJavaMethod(&quot;callStringize&quot;).reprofile();
418         forceCompileOverride = true;
419         String standardReturnValue = IN_INTERPRETED_HANDLER_MARKER;
420         String compiledReturnValue = IN_COMPILED_HANDLER_MARKER;
421         testWithDifferentReturnValues(getInitialOptions(), standardReturnValue, compiledReturnValue, &quot;callStringize&quot;, THROW_EXCEPTION_MARKER);
422     }
423 
424     @Test
425     public void testCallStringizeWithoutInlinePartialIntrinsicExit() {
426         OptionValues options = new OptionValues(getInitialOptions(), InlinePartialIntrinsicExitDuringParsing, false);
427         test(options, &quot;callStringize&quot;, &quot;a string&quot;);
428         test(options, &quot;callStringize&quot;, Boolean.TRUE);
429         String standardReturnValue = IN_INTERPRETED_HANDLER_MARKER;
430         String compiledReturnValue = IN_COMPILED_HANDLER_MARKER;
431         forceCompileOverride = true;
432         inlineInvokeDecision = InlineInvokePlugin.InlineInfo.DO_NOT_INLINE_WITH_EXCEPTION;
<span class="line-modified">433         inlineInvokeMethodName = &quot;stringize&quot;;</span>
434         try {
435             testWithDifferentReturnValues(options, standardReturnValue, compiledReturnValue, &quot;callStringize&quot;, THROW_EXCEPTION_MARKER);
436         } finally {
437             inlineInvokeDecision = null;
438             inlineInvokeMethodName = null;
439         }
440     }
441 
442     @Test
443     public void testCallStringizeId() {
444         test(&quot;callStringizeId&quot;, new TestObject(&quot;a string&quot;));
445         test(&quot;callStringizeId&quot;, new TestObject(Boolean.TRUE));
446         // Unset &#39;exception seen&#39; bit if testCallStringizeIdWithoutInlinePartialIntrinsicExit
447         // is executed before this test
448         getResolvedJavaMethod(&quot;callStringize&quot;).reprofile();
449         forceCompileOverride = true;
450         String standardReturnValue = IN_INTERPRETED_HANDLER_MARKER;
451         String compiledReturnValue = IN_COMPILED_HANDLER_MARKER;
452         testWithDifferentReturnValues(getInitialOptions(), standardReturnValue, compiledReturnValue, &quot;callStringizeId&quot;, new TestObject(THROW_EXCEPTION_MARKER));
453     }
</pre>
<hr />
<pre>
617     public void testAssertionInMethodSubstitution() {
618         try {
619             ResolvedJavaMethod method = getResolvedJavaMethod(&quot;div&quot;);
620             // avoid dumping graphs and printing exception since and exception is expected
621             OptionValues options = new OptionValues(getInitialOptions(), DumpOnError, false);
622             parse(new Builder(options, getDebugContext(options, null, method), AllowAssumptions.YES).method(method).compilationId(getCompilationId(method)), getEagerGraphBuilderSuite());
623             throw GraalError.shouldNotReachHere(&quot;BytecodeParser should have complained about using assertion in an intrinsic.&quot;);
624         } catch (BytecodeParserError e) {
625             // Expected behavior
626         }
627     }
628 
629     @SuppressWarnings(&quot;try&quot;)
630     private void testGraph(String name) {
631         StructuredGraph graph = parseEager(name, StructuredGraph.AllowAssumptions.YES);
632         try (DebugContext.Scope s0 = graph.getDebug().scope(name, graph)) {
633             for (OpaqueNode node : graph.getNodes().filter(OpaqueNode.class)) {
634                 node.remove();
635             }
636             HighTierContext context = getDefaultHighTierContext();
<span class="line-modified">637             CanonicalizerPhase canonicalizer = createCanonicalizerPhase();</span>
638             new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, context);
639             new FloatingReadPhase().apply(graph);
640             canonicalizer.apply(graph, context);
641             new DeadCodeEliminationPhase().apply(graph);
642             new GuardLoweringPhase().apply(graph, getDefaultMidTierContext());
643             new FrameStateAssignmentPhase().apply(graph);
644         } catch (Throwable e) {
645             throw graph.getDebug().handle(e);
646         }
647     }
648 
649     private class DummyInjectionProvider implements NodeIntrinsicPluginFactory.InjectionProvider {
650         @SuppressWarnings(&quot;unchecked&quot;)
651         @Override
652         public &lt;T&gt; T getInjectedArgument(Class&lt;T&gt; type) {
653             if (type == ForeignCallsProvider.class) {
654                 return (T) new ForeignCallsProvider() {
655                     @Override
656                     public LIRKind getValueKind(JavaKind javaKind) {
657                         return null;
</pre>
<hr />
<pre>
664 
665                     @Override
666                     public LocationIdentity[] getKilledLocations(ForeignCallDescriptor descriptor) {
667                         return new LocationIdentity[0];
668                     }
669 
670                     @Override
671                     public boolean canDeoptimize(ForeignCallDescriptor descriptor) {
672                         return false;
673                     }
674 
675                     @Override
676                     public boolean isGuaranteedSafepoint(ForeignCallDescriptor descriptor) {
677                         return false;
678                     }
679 
680                     @Override
681                     public ForeignCallLinkage lookupForeignCall(ForeignCallDescriptor descriptor) {
682                         return null;
683                     }
<span class="line-added">684 </span>
<span class="line-added">685                     @Override</span>
<span class="line-added">686                     public boolean isAvailable(ForeignCallDescriptor descriptor) {</span>
<span class="line-added">687                         return true;</span>
<span class="line-added">688                     }</span>
689                 };
690             }
691             if (type == SnippetReflectionProvider.class) {
692                 return (T) getSnippetReflection();
693             }
694             return null;
695         }
696 
697         @Override
698         public Stamp getInjectedStamp(Class&lt;?&gt; type, boolean nonNull) {
699             JavaKind kind = JavaKind.fromJavaClass(type);
700             return StampFactory.forKind(kind);
701         }
702     }
703 }
</pre>
</td>
</tr>
</table>
<center><a href="PointerTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="SnippetsTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
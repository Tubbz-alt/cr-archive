<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/classfile/RedefineIntrinsicTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.test.classfile;
 26 
 27 import static org.graalvm.compiler.test.SubprocessUtil.getVMCommandLine;
 28 import static org.graalvm.compiler.test.SubprocessUtil.java;
 29 import static org.graalvm.compiler.test.SubprocessUtil.withoutDebuggerArguments;
 30 import static org.junit.Assume.assumeTrue;
 31 
 32 import java.io.FileOutputStream;
 33 import java.io.IOException;
 34 import java.io.InputStream;
 35 import java.lang.instrument.ClassFileTransformer;
 36 import java.lang.instrument.IllegalClassFormatException;
 37 import java.lang.instrument.Instrumentation;
 38 import java.lang.management.ManagementFactory;
 39 import java.lang.reflect.Method;
 40 import java.nio.file.Files;
 41 import java.nio.file.Path;
 42 import java.security.ProtectionDomain;
 43 import java.util.List;
 44 import java.util.jar.Attributes;
 45 import java.util.jar.JarEntry;
 46 import java.util.jar.JarOutputStream;
 47 import java.util.jar.Manifest;
 48 
 49 import javax.tools.ToolProvider;
 50 
 51 import org.graalvm.compiler.api.replacements.ClassSubstitution;
 52 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 53 import org.graalvm.compiler.bytecode.BytecodeProvider;
 54 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 55 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 56 import org.graalvm.compiler.replacements.test.ReplacementsTest;
<a name="2" id="anc2"></a>

 57 import org.graalvm.compiler.test.SubprocessUtil.Subprocess;
 58 import org.junit.Assert;
 59 import org.junit.Test;
 60 
 61 import jdk.vm.ci.meta.ResolvedJavaMethod;
 62 
 63 /**
 64  * Tests that intrinsics (and snippets) are isolated from bytecode instrumentation.
 65  */
 66 public class RedefineIntrinsicTest extends ReplacementsTest {
 67 
 68     public static class Original {
 69 
 70         // Intrinsified by Intrinsic.getValue
 71         public static String getValue() {
 72             return &quot;original&quot;;
 73         }
 74     }
 75 
 76     @ClassSubstitution(Original.class)
 77     private static class Intrinsic {
 78 
 79         @MethodSubstitution
 80         public static String getValue() {
 81             return &quot;intrinsic&quot;;
 82         }
 83     }
 84 
 85     @Override
 86     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
 87         BytecodeProvider replacementBytecodeProvider = getSystemClassLoaderBytecodeProvider();
<a name="3" id="anc3"></a><span class="line-modified"> 88         Registration r = new Registration(invocationPlugins, Original.class, replacementBytecodeProvider);</span>
 89         r.registerMethodSubstitution(Intrinsic.class, &quot;getValue&quot;);
 90         super.registerInvocationPlugins(invocationPlugins);
 91     }
 92 
 93     public static String callOriginalGetValue() {
 94         // This call will be intrinsified when compiled by Graal
 95         return Original.getValue();
 96     }
 97 
 98     public static String callIntrinsicGetValue() {
 99         // This call will *not* be intrinsified when compiled by Graal
100         return Intrinsic.getValue();
101     }
102 
103     @Test
104     public void test() throws Throwable {
105         assumeManagementLibraryIsLoadable();
106         try {
107             Class.forName(&quot;java.lang.instrument.Instrumentation&quot;);
108         } catch (ClassNotFoundException ex) {
109             // skip this test if java.instrument JDK9 module is missing
110             return;
111         }
112         String recursionPropName = getClass().getName() + &quot;.recursion&quot;;
<a name="4" id="anc4"></a><span class="line-modified">113         if (Java8OrEarlier || Boolean.getBoolean(recursionPropName)) {</span>
114             testHelper();
115         } else {
116             List&lt;String&gt; vmArgs = withoutDebuggerArguments(getVMCommandLine());
117             vmArgs.add(&quot;-D&quot; + recursionPropName + &quot;=true&quot;);
<a name="5" id="anc5"></a>
118             vmArgs.add(&quot;-Djdk.attach.allowAttachSelf=true&quot;);
119             Subprocess proc = java(vmArgs, &quot;com.oracle.mxtool.junit.MxJUnitWrapper&quot;, getClass().getName());
120             if (proc.exitCode != 0) {
121                 Assert.fail(String.format(&quot;non-zero exit code %d for command:%n%s&quot;, proc.exitCode, proc));
122             }
123         }
124     }
125 
126     public void testHelper() throws Throwable {
127 
128         Object receiver = null;
129         Object[] args = {};
130 
131         // Prior to redefinition, both Original and Intrinsic
132         // should behave as per their Java source code
133         Assert.assertEquals(&quot;original&quot;, Original.getValue());
134         Assert.assertEquals(&quot;intrinsic&quot;, Intrinsic.getValue());
135 
136         ResolvedJavaMethod callOriginalGetValue = getResolvedJavaMethod(&quot;callOriginalGetValue&quot;);
137         ResolvedJavaMethod callIntrinsicGetValue = getResolvedJavaMethod(&quot;callIntrinsicGetValue&quot;);
138 
139         // Expect intrinsification to change &quot;original&quot; to &quot;intrinsic&quot;
140         testAgainstExpected(callOriginalGetValue, new Result(&quot;intrinsic&quot;, null), receiver, args);
141 
142         // Expect no intrinsification
143         testAgainstExpected(callIntrinsicGetValue, new Result(&quot;intrinsic&quot;, null), receiver, args);
144 
145         // Apply redefinition of intrinsic bytecode
146         if (!redefineIntrinsic()) {
147             // running on JDK9 without agent
148             return;
149         }
150 
151         // Expect redefinition to have no effect
152         Assert.assertEquals(&quot;original&quot;, Original.getValue());
153 
154         // Expect redefinition to change &quot;intrinsic&quot; to &quot;redefined&quot;
155         Assert.assertEquals(&quot;redefined&quot;, Intrinsic.getValue());
156 
157         // Expect redefinition to have no effect on intrinsification (i.e.,
158         // &quot;original&quot; is still changed to &quot;intrinsic&quot;, not &quot;redefined&quot;
159         testAgainstExpected(callOriginalGetValue, new Result(&quot;intrinsic&quot;, null), receiver, args);
160     }
161 
162     /**
163      * Adds the class file bytes for a given class to a JAR stream.
164      */
165     static void add(JarOutputStream jar, Class&lt;?&gt; c) throws IOException {
166         String name = c.getName();
167         String classAsPath = name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;;
168         jar.putNextEntry(new JarEntry(classAsPath));
169 
170         InputStream stream = c.getClassLoader().getResourceAsStream(classAsPath);
171 
172         int nRead;
173         byte[] buf = new byte[1024];
174         while ((nRead = stream.read(buf, 0, buf.length)) != -1) {
175             jar.write(buf, 0, nRead);
176         }
177 
178         jar.closeEntry();
179     }
180 
181     static boolean redefineIntrinsic() throws Exception {
182         Manifest manifest = new Manifest();
183         manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, &quot;1.0&quot;);
184         Attributes mainAttrs = manifest.getMainAttributes();
185         mainAttrs.putValue(&quot;Agent-Class&quot;, RedefinerAgent.class.getName());
186         mainAttrs.putValue(&quot;Can-Redefine-Classes&quot;, &quot;true&quot;);
187         mainAttrs.putValue(&quot;Can-Retransform-Classes&quot;, &quot;true&quot;);
188 
189         Path jar = Files.createTempFile(&quot;myagent&quot;, &quot;.jar&quot;);
190         try {
191             JarOutputStream jarStream = new JarOutputStream(new FileOutputStream(jar.toFile()), manifest);
192             add(jarStream, RedefinerAgent.class);
193             add(jarStream, Redefiner.class);
194             jarStream.close();
195 
196             return loadAgent(jar);
197         } finally {
198             Files.deleteIfExists(jar);
199         }
200     }
201 
202     @SuppressWarnings({&quot;deprecation&quot;, &quot;unused&quot;})
203     public static boolean loadAgent(Path agent) throws Exception {
204         String vmName = ManagementFactory.getRuntimeMXBean().getName();
205         int p = vmName.indexOf(&#39;@&#39;);
206         assumeTrue(&quot;VM name not in &lt;pid&gt;@&lt;host&gt; format: &quot; + vmName, p != -1);
207         String pid = vmName.substring(0, p);
208         Class&lt;?&gt; c;
<a name="6" id="anc6"></a><span class="line-modified">209         if (Java8OrEarlier) {</span>
210             ClassLoader cl = ToolProvider.getSystemToolClassLoader();
211             c = Class.forName(&quot;com.sun.tools.attach.VirtualMachine&quot;, true, cl);
212         } else {
213             try {
214                 // I don&#39;t know what changed to make this necessary...
215                 c = Class.forName(&quot;com.sun.tools.attach.VirtualMachine&quot;, true, RedefineIntrinsicTest.class.getClassLoader());
216             } catch (ClassNotFoundException ex) {
217                 try {
218                     Class.forName(&quot;javax.naming.Reference&quot;);
219                 } catch (ClassNotFoundException coreNamingMissing) {
220                     // if core JDK classes aren&#39;t found, we are probably running in a
221                     // JDK9 java.base environment and then missing class is OK
222                     return false;
223                 }
224                 throw ex;
225             }
226         }
227         Method attach = c.getDeclaredMethod(&quot;attach&quot;, String.class);
228         Method loadAgent = c.getDeclaredMethod(&quot;loadAgent&quot;, String.class, String.class);
229         Method detach = c.getDeclaredMethod(&quot;detach&quot;);
230         Object vm = attach.invoke(null, pid);
231         loadAgent.invoke(vm, agent.toString(), &quot;&quot;);
232         detach.invoke(vm);
233         return true;
234     }
235 
236     public static class RedefinerAgent {
237 
238         public static void agentmain(@SuppressWarnings(&quot;unused&quot;) String args, Instrumentation inst) throws Exception {
239             if (inst.isRedefineClassesSupported() &amp;&amp; inst.isRetransformClassesSupported()) {
240                 inst.addTransformer(new Redefiner(), true);
241                 Class&lt;?&gt;[] allClasses = inst.getAllLoadedClasses();
242                 for (int i = 0; i &lt; allClasses.length; i++) {
243                     Class&lt;?&gt; c = allClasses[i];
244                     if (c == Intrinsic.class) {
245                         inst.retransformClasses(new Class&lt;?&gt;[]{c});
246                     }
247                 }
248             }
249         }
250     }
251 
252     /**
253      * This transformer replaces the first instance of the constant &quot;intrinsic&quot; in the class file
254      * for {@link Intrinsic} with &quot;redefined&quot;.
255      */
256     static class Redefiner implements ClassFileTransformer {
257 
258         @Override
259         public byte[] transform(ClassLoader cl, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
260             if (Intrinsic.class.equals(classBeingRedefined)) {
261                 String cf = new String(classfileBuffer);
262                 int i = cf.indexOf(&quot;intrinsic&quot;);
263                 Assert.assertTrue(&quot;cannot find \&quot;intrinsic\&quot; constant in &quot; + Intrinsic.class.getSimpleName() + &quot;&#39;s class file&quot;, i &gt; 0);
264                 System.arraycopy(&quot;redefined&quot;.getBytes(), 0, classfileBuffer, i, &quot;redefined&quot;.length());
265             }
266             return classfileBuffer;
267         }
268     }
269 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
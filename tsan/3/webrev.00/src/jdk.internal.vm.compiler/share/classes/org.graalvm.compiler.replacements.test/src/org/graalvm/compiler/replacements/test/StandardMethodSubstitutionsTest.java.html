<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/StandardMethodSubstitutionsTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.test;
 26 
 27 import java.util.HashMap;
 28 
 29 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 30 import org.graalvm.compiler.nodes.IfNode;
 31 import org.graalvm.compiler.nodes.StructuredGraph;
 32 import org.graalvm.compiler.nodes.calc.AbsNode;
 33 import org.graalvm.compiler.nodes.calc.ReinterpretNode;
 34 import org.graalvm.compiler.replacements.amd64.AMD64CountLeadingZerosNode;
 35 import org.graalvm.compiler.replacements.amd64.AMD64CountTrailingZerosNode;
 36 import org.graalvm.compiler.replacements.nodes.BitCountNode;
 37 import org.graalvm.compiler.replacements.nodes.BitScanForwardNode;
 38 import org.graalvm.compiler.replacements.nodes.BitScanReverseNode;
 39 import org.graalvm.compiler.replacements.nodes.ReverseBytesNode;
 40 import org.junit.Test;
 41 
 42 import jdk.vm.ci.code.InstalledCode;
 43 import jdk.vm.ci.meta.ResolvedJavaMethod;
 44 
 45 /**
 46  * Tests the VM independent {@link MethodSubstitution}s.
 47  */
 48 public class StandardMethodSubstitutionsTest extends MethodSubstitutionTest {
 49 
 50     @Test
 51     public void testMathSubstitutions() {
 52         assertInGraph(assertNotInGraph(testGraph(&quot;mathAbs&quot;), IfNode.class), AbsNode.class);     // Java
 53         double value = 34567.891D;
 54         testGraph(&quot;mathCos&quot;);
 55         testGraph(&quot;mathLog&quot;);
 56         testGraph(&quot;mathLog10&quot;);
 57         testGraph(&quot;mathSin&quot;);
 58         testGraph(&quot;mathSqrt&quot;);
 59         testGraph(&quot;mathTan&quot;);
 60         testGraph(&quot;mathAll&quot;);
 61 
 62         test(&quot;mathCos&quot;, value);
 63         test(&quot;mathLog&quot;, value);
 64         test(&quot;mathLog10&quot;, value);
 65         test(&quot;mathSin&quot;, value);
 66         test(&quot;mathSqrt&quot;, value);
 67         test(&quot;mathTan&quot;, value);
 68         test(&quot;mathAll&quot;, value);
 69     }
 70 
 71     @Test
 72     public void testMathPow() {
 73         double a = 34567.891D;
 74         double b = 4.6D;
 75         test(&quot;mathPow&quot;, a, b);
 76 
 77         // Test the values directly handled by the substitution
 78 
 79         // If the second argument is positive or negative zero, then the result is 1.0.
 80         test(&quot;mathPow&quot;, a, 0.0D);
 81         test(&quot;mathPow&quot;, a, -0.0D);
 82         // If the second argument is 1.0, then the result is the same as the first argument.
 83         test(&quot;mathPow&quot;, a, 1.0D);
 84         // If the second argument is NaN, then the result is NaN.
 85         test(&quot;mathPow&quot;, a, Double.NaN);
 86         // If the first argument is NaN and the second argument is nonzero, then the result is NaN.
 87         test(&quot;mathPow&quot;, Double.NaN, b);
 88         test(&quot;mathPow&quot;, Double.NaN, 0.0D);
 89         // x**-1 = 1/x
 90         test(&quot;mathPow&quot;, a, -1.0D);
 91         // x**2 = x*x
 92         test(&quot;mathPow&quot;, a, 2.0D);
 93         // x**0.5 = sqrt(x)
 94         test(&quot;mathPow&quot;, a, 0.5D);
 95     }
 96 
 97     public static double mathPow(double a, double b) {
 98         return mathPow0(a, b);
 99     }
100 
101     public static double mathPow0(double a, double b) {
102         return Math.pow(a, b);
103     }
104 
105     public static double mathAbs(double value) {
106         return Math.abs(value);
107     }
108 
109     public static double mathSqrt(double value) {
110         return Math.sqrt(value);
111     }
112 
113     public static double mathLog(double value) {
114         return Math.log(value);
115     }
116 
117     public static double mathLog10(double value) {
118         return Math.log10(value);
119     }
120 
121     public static double mathSin(double value) {
122         return Math.sin(value);
123     }
124 
125     public static double mathCos(double value) {
126         return Math.cos(value);
127     }
128 
129     public static double mathTan(double value) {
130         return Math.tan(value);
131     }
132 
133     public static double mathAll(double value) {
134         return Math.sqrt(value) + Math.log(value) + Math.log10(value) + Math.sin(value) + Math.cos(value) + Math.tan(value);
135     }
136 
137     public void testSubstitution(String testMethodName, Class&lt;?&gt; holder, String methodName, boolean optional, Object[] args, Class&lt;?&gt;... intrinsicClasses) {
138         ResolvedJavaMethod realJavaMethod = getResolvedJavaMethod(holder, methodName);
139         ResolvedJavaMethod testJavaMethod = getResolvedJavaMethod(testMethodName);
140         StructuredGraph graph = testGraph(testMethodName);
141 
142         // Check to see if the resulting graph contains the expected node
143         StructuredGraph replacement = getReplacements().getSubstitution(realJavaMethod, -1, false, null, graph.getOptions());
144         if (replacement == null &amp;&amp; !optional) {
145             assertInGraph(graph, intrinsicClasses);
146         }
147 
148         for (Object l : args) {
149             // Force compilation
150             InstalledCode code = getCode(testJavaMethod);
151             assert optional || code != null;
152             // Verify that the original method and the substitution produce the same value
153             Object expected = invokeSafe(realJavaMethod, null, l);
154             assertDeepEquals(expected, invokeSafe(testJavaMethod, null, l));
155             // Verify that the generated code and the original produce the same value
156             assertDeepEquals(expected, executeVarargsSafe(code, l));
157         }
158     }
159 
160     @Test
161     public void testCharSubstitutions() {
162         Object[] args = new Character[]{Character.MIN_VALUE, (char) -1, (char) 0, (char) 1, Character.MAX_VALUE};
163 
164         testSubstitution(&quot;charReverseBytes&quot;, Character.class, &quot;reverseBytes&quot;, false, args, ReverseBytesNode.class);
165     }
166 
167     public static char charReverseBytes(char value) {
168         return Character.reverseBytes(value);
169     }
170 
171     @Test
172     public void testCharSubstitutionsNarrowing() {
173         Object[] args = new Integer[]{(int) Character.MIN_VALUE, -1, 0, 1, (int) Character.MAX_VALUE};
174 
175         for (Object arg : args) {
176             test(&quot;charReverseBytesNarrowing&quot;, arg);
177         }
178     }
179 
180     public static char charReverseBytesNarrowing(int value) {
181         return Character.reverseBytes((char) value);
182     }
183 
184     @Test
185     public void testShortSubstitutions() {
186         Object[] args = new Short[]{Short.MIN_VALUE, -1, 0, 1, Short.MAX_VALUE};
187 
188         testSubstitution(&quot;shortReverseBytes&quot;, Short.class, &quot;reverseBytes&quot;, false, args, ReverseBytesNode.class);
189     }
190 
191     public static short shortReverseBytes(short value) {
192         return Short.reverseBytes(value);
193     }
194 
195     @Test
196     public void testShortSubstitutionsNarrowing() {
197         Object[] args = new Integer[]{(int) Short.MIN_VALUE, -1, 0, 1, (int) Short.MAX_VALUE};
198 
199         for (Object arg : args) {
200             test(&quot;shortReverseBytesNarrowing&quot;, arg);
201         }
202     }
203 
204     public static short shortReverseBytesNarrowing(int value) {
205         return Short.reverseBytes((short) value);
206     }
207 
208     @Test
209     public void testIntegerSubstitutions() {
210         Object[] args = new Object[]{Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE};
211 
212         testSubstitution(&quot;integerReverseBytes&quot;, Integer.class, &quot;reverseBytes&quot;, false, args, ReverseBytesNode.class);
213         testSubstitution(&quot;integerNumberOfLeadingZeros&quot;, Integer.class, &quot;numberOfLeadingZeros&quot;, true, args, BitScanReverseNode.class, AMD64CountLeadingZerosNode.class);
214         testSubstitution(&quot;integerNumberOfTrailingZeros&quot;, Integer.class, &quot;numberOfTrailingZeros&quot;, false, args, BitScanForwardNode.class, AMD64CountTrailingZerosNode.class);
215         testSubstitution(&quot;integerBitCount&quot;, Integer.class, &quot;bitCount&quot;, true, args, BitCountNode.class);
216     }
217 
218     public static int integerReverseBytes(int value) {
219         return Integer.reverseBytes(value);
220     }
221 
222     public static int integerNumberOfLeadingZeros(int value) {
223         return Integer.numberOfLeadingZeros(value);
224     }
225 
226     public static int integerNumberOfTrailingZeros(int value) {
227         return Integer.numberOfTrailingZeros(value);
228     }
229 
230     public static int integerBitCount(int value) {
231         return Integer.bitCount(value);
232     }
233 
234     @Test
235     public void testLongSubstitutions() {
236         Object[] args = new Object[]{Long.MIN_VALUE, -1L, 0L, 1L, Long.MAX_VALUE};
237 
238         testSubstitution(&quot;longReverseBytes&quot;, Long.class, &quot;reverseBytes&quot;, false, args, ReverseBytesNode.class);
239         testSubstitution(&quot;longNumberOfLeadingZeros&quot;, Long.class, &quot;numberOfLeadingZeros&quot;, true, args, BitScanReverseNode.class, AMD64CountLeadingZerosNode.class);
240         testSubstitution(&quot;longNumberOfTrailingZeros&quot;, Long.class, &quot;numberOfTrailingZeros&quot;, false, args, BitScanForwardNode.class, AMD64CountTrailingZerosNode.class);
241         testSubstitution(&quot;longBitCount&quot;, Long.class, &quot;bitCount&quot;, true, args, BitCountNode.class);
242     }
243 
244     public static long longReverseBytes(long value) {
245         return Long.reverseBytes(value);
246     }
247 
248     public static int longNumberOfLeadingZeros(long value) {
249         return Long.numberOfLeadingZeros(value);
250     }
251 
252     public static int longNumberOfTrailingZeros(long value) {
253         return Long.numberOfTrailingZeros(value);
254     }
255 
256     public static int longBitCount(long value) {
257         return Long.bitCount(value);
258     }
259 
260     @Test
261     public void testFloatSubstitutions() {
262         assertInGraph(testGraph(&quot;floatToIntBits&quot;), ReinterpretNode.class); // Java
263         testGraph(&quot;intBitsToFloat&quot;);
264     }
265 
266     public static int floatToIntBits(float value) {
267         return Float.floatToIntBits(value);
268     }
269 
270     public static float intBitsToFloat(int value) {
271         return Float.intBitsToFloat(value);
272     }
273 
274     @Test
275     public void testDoubleSubstitutions() {
276         assertInGraph(testGraph(&quot;doubleToLongBits&quot;), ReinterpretNode.class); // Java
277         testGraph(&quot;longBitsToDouble&quot;);
278     }
279 
280     public static long doubleToLongBits(double value) {
281         return Double.doubleToLongBits(value);
282     }
283 
284     public static double longBitsToDouble(long value) {
285         return Double.longBitsToDouble(value);
286     }
287 
288     public static boolean isInstance(Class&lt;?&gt; clazz, Object object) {
289         return clazz.isInstance(object);
290     }
291 
292     public static boolean isInstance2(boolean cond, Object object) {
293         Class&lt;?&gt; clazz;
294         if (cond) {
295             clazz = String.class;
296         } else {
297             clazz = java.util.HashMap.class;
298         }
299         return clazz.isInstance(object);
300     }
301 
302     public static boolean isAssignableFrom(Class&lt;?&gt; clazz, Class&lt;?&gt; other) {
303         return clazz.isAssignableFrom(other);
304     }
305 
306     @Test
307     public void testClassSubstitutions() {
308         testGraph(&quot;isInstance&quot;);
309         testGraph(&quot;isInstance2&quot;);
310         testGraph(&quot;isAssignableFrom&quot;);
311         for (Class&lt;?&gt; c : new Class&lt;?&gt;[]{getClass(), Cloneable.class, int[].class, String[][].class}) {
312             for (Object o : new Object[]{this, new int[5], new String[2][], new Object()}) {
313                 test(&quot;isInstance&quot;, c, o);
314                 test(&quot;isAssignableFrom&quot;, c, o.getClass());
315             }
316         }
317 
318         test(&quot;isInstance2&quot;, true, null);
319         test(&quot;isInstance2&quot;, false, null);
320         test(&quot;isInstance2&quot;, true, &quot;string&quot;);
321         test(&quot;isInstance2&quot;, false, &quot;string&quot;);
322         test(&quot;isInstance2&quot;, true, new HashMap&lt;&gt;());
323         test(&quot;isInstance2&quot;, false, new HashMap&lt;&gt;());
324     }
325 }
    </pre>
  </body>
</html>
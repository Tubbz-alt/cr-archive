<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/classfile/RedefineIntrinsicTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassfileBytecodeProviderTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/ArraySubstitutions.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/classfile/RedefineIntrinsicTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 37 import java.lang.instrument.Instrumentation;
 38 import java.lang.management.ManagementFactory;
 39 import java.lang.reflect.Method;
 40 import java.nio.file.Files;
 41 import java.nio.file.Path;
 42 import java.security.ProtectionDomain;
 43 import java.util.List;
 44 import java.util.jar.Attributes;
 45 import java.util.jar.JarEntry;
 46 import java.util.jar.JarOutputStream;
 47 import java.util.jar.Manifest;
 48 
 49 import javax.tools.ToolProvider;
 50 
 51 import org.graalvm.compiler.api.replacements.ClassSubstitution;
 52 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 53 import org.graalvm.compiler.bytecode.BytecodeProvider;
 54 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 55 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 56 import org.graalvm.compiler.replacements.test.ReplacementsTest;


 57 import org.graalvm.compiler.test.SubprocessUtil.Subprocess;
 58 import org.junit.Assert;
 59 import org.junit.Test;
 60 
 61 import jdk.vm.ci.meta.ResolvedJavaMethod;
 62 
 63 /**
 64  * Tests that intrinsics (and snippets) are isolated from bytecode instrumentation.
 65  */
 66 public class RedefineIntrinsicTest extends ReplacementsTest {
 67 
 68     public static class Original {
 69 
 70         // Intrinsified by Intrinsic.getValue
 71         public static String getValue() {
 72             return &quot;original&quot;;
 73         }
 74     }
 75 
 76     @ClassSubstitution(Original.class)
 77     private static class Intrinsic {
 78 
 79         @MethodSubstitution
 80         public static String getValue() {
 81             return &quot;intrinsic&quot;;
 82         }
 83     }
 84 
 85     @Override
 86     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
 87         BytecodeProvider replacementBytecodeProvider = getSystemClassLoaderBytecodeProvider();
<span class="line-modified"> 88         Registration r = new Registration(invocationPlugins, Original.class, replacementBytecodeProvider);</span>
 89         r.registerMethodSubstitution(Intrinsic.class, &quot;getValue&quot;);
 90         super.registerInvocationPlugins(invocationPlugins);
 91     }
 92 
 93     public static String callOriginalGetValue() {
 94         // This call will be intrinsified when compiled by Graal
 95         return Original.getValue();
 96     }
 97 
 98     public static String callIntrinsicGetValue() {
 99         // This call will *not* be intrinsified when compiled by Graal
100         return Intrinsic.getValue();
101     }
102 
103     @Test
104     public void test() throws Throwable {
105         assumeManagementLibraryIsLoadable();
106         try {
107             Class.forName(&quot;java.lang.instrument.Instrumentation&quot;);
108         } catch (ClassNotFoundException ex) {
109             // skip this test if java.instrument JDK9 module is missing
110             return;
111         }
112         String recursionPropName = getClass().getName() + &quot;.recursion&quot;;
<span class="line-modified">113         if (Java8OrEarlier || Boolean.getBoolean(recursionPropName)) {</span>
114             testHelper();
115         } else {
116             List&lt;String&gt; vmArgs = withoutDebuggerArguments(getVMCommandLine());
117             vmArgs.add(&quot;-D&quot; + recursionPropName + &quot;=true&quot;);

118             vmArgs.add(&quot;-Djdk.attach.allowAttachSelf=true&quot;);
119             Subprocess proc = java(vmArgs, &quot;com.oracle.mxtool.junit.MxJUnitWrapper&quot;, getClass().getName());
120             if (proc.exitCode != 0) {
121                 Assert.fail(String.format(&quot;non-zero exit code %d for command:%n%s&quot;, proc.exitCode, proc));
122             }
123         }
124     }
125 
126     public void testHelper() throws Throwable {
127 
128         Object receiver = null;
129         Object[] args = {};
130 
131         // Prior to redefinition, both Original and Intrinsic
132         // should behave as per their Java source code
133         Assert.assertEquals(&quot;original&quot;, Original.getValue());
134         Assert.assertEquals(&quot;intrinsic&quot;, Intrinsic.getValue());
135 
136         ResolvedJavaMethod callOriginalGetValue = getResolvedJavaMethod(&quot;callOriginalGetValue&quot;);
137         ResolvedJavaMethod callIntrinsicGetValue = getResolvedJavaMethod(&quot;callIntrinsicGetValue&quot;);
</pre>
<hr />
<pre>
189         Path jar = Files.createTempFile(&quot;myagent&quot;, &quot;.jar&quot;);
190         try {
191             JarOutputStream jarStream = new JarOutputStream(new FileOutputStream(jar.toFile()), manifest);
192             add(jarStream, RedefinerAgent.class);
193             add(jarStream, Redefiner.class);
194             jarStream.close();
195 
196             return loadAgent(jar);
197         } finally {
198             Files.deleteIfExists(jar);
199         }
200     }
201 
202     @SuppressWarnings({&quot;deprecation&quot;, &quot;unused&quot;})
203     public static boolean loadAgent(Path agent) throws Exception {
204         String vmName = ManagementFactory.getRuntimeMXBean().getName();
205         int p = vmName.indexOf(&#39;@&#39;);
206         assumeTrue(&quot;VM name not in &lt;pid&gt;@&lt;host&gt; format: &quot; + vmName, p != -1);
207         String pid = vmName.substring(0, p);
208         Class&lt;?&gt; c;
<span class="line-modified">209         if (Java8OrEarlier) {</span>
210             ClassLoader cl = ToolProvider.getSystemToolClassLoader();
211             c = Class.forName(&quot;com.sun.tools.attach.VirtualMachine&quot;, true, cl);
212         } else {
213             try {
214                 // I don&#39;t know what changed to make this necessary...
215                 c = Class.forName(&quot;com.sun.tools.attach.VirtualMachine&quot;, true, RedefineIntrinsicTest.class.getClassLoader());
216             } catch (ClassNotFoundException ex) {
217                 try {
218                     Class.forName(&quot;javax.naming.Reference&quot;);
219                 } catch (ClassNotFoundException coreNamingMissing) {
220                     // if core JDK classes aren&#39;t found, we are probably running in a
221                     // JDK9 java.base environment and then missing class is OK
222                     return false;
223                 }
224                 throw ex;
225             }
226         }
227         Method attach = c.getDeclaredMethod(&quot;attach&quot;, String.class);
228         Method loadAgent = c.getDeclaredMethod(&quot;loadAgent&quot;, String.class, String.class);
229         Method detach = c.getDeclaredMethod(&quot;detach&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 37 import java.lang.instrument.Instrumentation;
 38 import java.lang.management.ManagementFactory;
 39 import java.lang.reflect.Method;
 40 import java.nio.file.Files;
 41 import java.nio.file.Path;
 42 import java.security.ProtectionDomain;
 43 import java.util.List;
 44 import java.util.jar.Attributes;
 45 import java.util.jar.JarEntry;
 46 import java.util.jar.JarOutputStream;
 47 import java.util.jar.Manifest;
 48 
 49 import javax.tools.ToolProvider;
 50 
 51 import org.graalvm.compiler.api.replacements.ClassSubstitution;
 52 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 53 import org.graalvm.compiler.bytecode.BytecodeProvider;
 54 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 55 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 56 import org.graalvm.compiler.replacements.test.ReplacementsTest;
<span class="line-added"> 57 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
<span class="line-added"> 58 import org.graalvm.compiler.test.SubprocessUtil;</span>
 59 import org.graalvm.compiler.test.SubprocessUtil.Subprocess;
 60 import org.junit.Assert;
 61 import org.junit.Test;
 62 
 63 import jdk.vm.ci.meta.ResolvedJavaMethod;
 64 
 65 /**
 66  * Tests that intrinsics (and snippets) are isolated from bytecode instrumentation.
 67  */
 68 public class RedefineIntrinsicTest extends ReplacementsTest {
 69 
 70     public static class Original {
 71 
 72         // Intrinsified by Intrinsic.getValue
 73         public static String getValue() {
 74             return &quot;original&quot;;
 75         }
 76     }
 77 
 78     @ClassSubstitution(Original.class)
 79     private static class Intrinsic {
 80 
 81         @MethodSubstitution
 82         public static String getValue() {
 83             return &quot;intrinsic&quot;;
 84         }
 85     }
 86 
 87     @Override
 88     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
 89         BytecodeProvider replacementBytecodeProvider = getSystemClassLoaderBytecodeProvider();
<span class="line-modified"> 90         Registration r = new Registration(invocationPlugins, Original.class, getReplacements(), replacementBytecodeProvider);</span>
 91         r.registerMethodSubstitution(Intrinsic.class, &quot;getValue&quot;);
 92         super.registerInvocationPlugins(invocationPlugins);
 93     }
 94 
 95     public static String callOriginalGetValue() {
 96         // This call will be intrinsified when compiled by Graal
 97         return Original.getValue();
 98     }
 99 
100     public static String callIntrinsicGetValue() {
101         // This call will *not* be intrinsified when compiled by Graal
102         return Intrinsic.getValue();
103     }
104 
105     @Test
106     public void test() throws Throwable {
107         assumeManagementLibraryIsLoadable();
108         try {
109             Class.forName(&quot;java.lang.instrument.Instrumentation&quot;);
110         } catch (ClassNotFoundException ex) {
111             // skip this test if java.instrument JDK9 module is missing
112             return;
113         }
114         String recursionPropName = getClass().getName() + &quot;.recursion&quot;;
<span class="line-modified">115         if (JavaVersionUtil.JAVA_SPEC &lt;= 8 || Boolean.getBoolean(recursionPropName)) {</span>
116             testHelper();
117         } else {
118             List&lt;String&gt; vmArgs = withoutDebuggerArguments(getVMCommandLine());
119             vmArgs.add(&quot;-D&quot; + recursionPropName + &quot;=true&quot;);
<span class="line-added">120             vmArgs.add(SubprocessUtil.PACKAGE_OPENING_OPTIONS);</span>
121             vmArgs.add(&quot;-Djdk.attach.allowAttachSelf=true&quot;);
122             Subprocess proc = java(vmArgs, &quot;com.oracle.mxtool.junit.MxJUnitWrapper&quot;, getClass().getName());
123             if (proc.exitCode != 0) {
124                 Assert.fail(String.format(&quot;non-zero exit code %d for command:%n%s&quot;, proc.exitCode, proc));
125             }
126         }
127     }
128 
129     public void testHelper() throws Throwable {
130 
131         Object receiver = null;
132         Object[] args = {};
133 
134         // Prior to redefinition, both Original and Intrinsic
135         // should behave as per their Java source code
136         Assert.assertEquals(&quot;original&quot;, Original.getValue());
137         Assert.assertEquals(&quot;intrinsic&quot;, Intrinsic.getValue());
138 
139         ResolvedJavaMethod callOriginalGetValue = getResolvedJavaMethod(&quot;callOriginalGetValue&quot;);
140         ResolvedJavaMethod callIntrinsicGetValue = getResolvedJavaMethod(&quot;callIntrinsicGetValue&quot;);
</pre>
<hr />
<pre>
192         Path jar = Files.createTempFile(&quot;myagent&quot;, &quot;.jar&quot;);
193         try {
194             JarOutputStream jarStream = new JarOutputStream(new FileOutputStream(jar.toFile()), manifest);
195             add(jarStream, RedefinerAgent.class);
196             add(jarStream, Redefiner.class);
197             jarStream.close();
198 
199             return loadAgent(jar);
200         } finally {
201             Files.deleteIfExists(jar);
202         }
203     }
204 
205     @SuppressWarnings({&quot;deprecation&quot;, &quot;unused&quot;})
206     public static boolean loadAgent(Path agent) throws Exception {
207         String vmName = ManagementFactory.getRuntimeMXBean().getName();
208         int p = vmName.indexOf(&#39;@&#39;);
209         assumeTrue(&quot;VM name not in &lt;pid&gt;@&lt;host&gt; format: &quot; + vmName, p != -1);
210         String pid = vmName.substring(0, p);
211         Class&lt;?&gt; c;
<span class="line-modified">212         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
213             ClassLoader cl = ToolProvider.getSystemToolClassLoader();
214             c = Class.forName(&quot;com.sun.tools.attach.VirtualMachine&quot;, true, cl);
215         } else {
216             try {
217                 // I don&#39;t know what changed to make this necessary...
218                 c = Class.forName(&quot;com.sun.tools.attach.VirtualMachine&quot;, true, RedefineIntrinsicTest.class.getClassLoader());
219             } catch (ClassNotFoundException ex) {
220                 try {
221                     Class.forName(&quot;javax.naming.Reference&quot;);
222                 } catch (ClassNotFoundException coreNamingMissing) {
223                     // if core JDK classes aren&#39;t found, we are probably running in a
224                     // JDK9 java.base environment and then missing class is OK
225                     return false;
226                 }
227                 throw ex;
228             }
229         }
230         Method attach = c.getDeclaredMethod(&quot;attach&quot;, String.class);
231         Method loadAgent = c.getDeclaredMethod(&quot;loadAgent&quot;, String.class, String.class);
232         Method detach = c.getDeclaredMethod(&quot;detach&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="ClassfileBytecodeProviderTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/ArraySubstitutions.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/StandardMethodSubstitutionsTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SnippetsTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StringCompareToTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/StandardMethodSubstitutionsTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.test;
 26 
 27 import java.util.HashMap;
 28 
 29 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 30 import org.graalvm.compiler.nodes.IfNode;
 31 import org.graalvm.compiler.nodes.StructuredGraph;
 32 import org.graalvm.compiler.nodes.calc.AbsNode;
 33 import org.graalvm.compiler.nodes.calc.ReinterpretNode;


 34 import org.graalvm.compiler.replacements.nodes.BitCountNode;
 35 import org.graalvm.compiler.replacements.nodes.BitScanForwardNode;
 36 import org.graalvm.compiler.replacements.nodes.BitScanReverseNode;
 37 import org.graalvm.compiler.replacements.nodes.ReverseBytesNode;
 38 import org.junit.Test;
 39 
 40 import jdk.vm.ci.code.InstalledCode;
 41 import jdk.vm.ci.meta.ResolvedJavaMethod;
 42 
 43 /**
 44  * Tests the VM independent {@link MethodSubstitution}s.
 45  */
 46 public class StandardMethodSubstitutionsTest extends MethodSubstitutionTest {
 47 
 48     @Test
 49     public void testMathSubstitutions() {
 50         assertInGraph(assertNotInGraph(testGraph(&quot;mathAbs&quot;), IfNode.class), AbsNode.class);     // Java
 51         double value = 34567.891D;
 52         testGraph(&quot;mathCos&quot;);
 53         testGraph(&quot;mathLog&quot;);
</pre>
<hr />
<pre>
115     public static double mathLog10(double value) {
116         return Math.log10(value);
117     }
118 
119     public static double mathSin(double value) {
120         return Math.sin(value);
121     }
122 
123     public static double mathCos(double value) {
124         return Math.cos(value);
125     }
126 
127     public static double mathTan(double value) {
128         return Math.tan(value);
129     }
130 
131     public static double mathAll(double value) {
132         return Math.sqrt(value) + Math.log(value) + Math.log10(value) + Math.sin(value) + Math.cos(value) + Math.tan(value);
133     }
134 
<span class="line-modified">135     public void testSubstitution(String testMethodName, Class&lt;?&gt; intrinsicClass, Class&lt;?&gt; holder, String methodName, boolean optional, Object... args) {</span>
136         ResolvedJavaMethod realJavaMethod = getResolvedJavaMethod(holder, methodName);
137         ResolvedJavaMethod testJavaMethod = getResolvedJavaMethod(testMethodName);
138         StructuredGraph graph = testGraph(testMethodName);
139 
140         // Check to see if the resulting graph contains the expected node
<span class="line-modified">141         StructuredGraph replacement = getReplacements().getSubstitution(realJavaMethod, -1, false, null);</span>
142         if (replacement == null &amp;&amp; !optional) {
<span class="line-modified">143             assertInGraph(graph, intrinsicClass);</span>
144         }
145 
146         for (Object l : args) {
147             // Force compilation
148             InstalledCode code = getCode(testJavaMethod);
149             assert optional || code != null;
150             // Verify that the original method and the substitution produce the same value
151             Object expected = invokeSafe(realJavaMethod, null, l);
152             assertDeepEquals(expected, invokeSafe(testJavaMethod, null, l));
153             // Verify that the generated code and the original produce the same value
154             assertDeepEquals(expected, executeVarargsSafe(code, l));
155         }
156     }
157 
158     @Test
159     public void testCharSubstitutions() {
160         Object[] args = new Character[]{Character.MIN_VALUE, (char) -1, (char) 0, (char) 1, Character.MAX_VALUE};
161 
<span class="line-modified">162         testSubstitution(&quot;charReverseBytes&quot;, ReverseBytesNode.class, Character.class, &quot;reverseBytes&quot;, false, args);</span>
163     }
164 
165     public static char charReverseBytes(char value) {
166         return Character.reverseBytes(value);
167     }
168 
169     @Test
170     public void testCharSubstitutionsNarrowing() {
171         Object[] args = new Integer[]{(int) Character.MIN_VALUE, -1, 0, 1, (int) Character.MAX_VALUE};
172 
173         for (Object arg : args) {
174             test(&quot;charReverseBytesNarrowing&quot;, arg);
175         }
176     }
177 
178     public static char charReverseBytesNarrowing(int value) {
179         return Character.reverseBytes((char) value);
180     }
181 
182     @Test
183     public void testShortSubstitutions() {
184         Object[] args = new Short[]{Short.MIN_VALUE, -1, 0, 1, Short.MAX_VALUE};
185 
<span class="line-modified">186         testSubstitution(&quot;shortReverseBytes&quot;, ReverseBytesNode.class, Short.class, &quot;reverseBytes&quot;, false, args);</span>
187     }
188 
189     public static short shortReverseBytes(short value) {
190         return Short.reverseBytes(value);
191     }
192 
193     @Test
194     public void testShortSubstitutionsNarrowing() {
195         Object[] args = new Integer[]{(int) Short.MIN_VALUE, -1, 0, 1, (int) Short.MAX_VALUE};
196 
197         for (Object arg : args) {
198             test(&quot;shortReverseBytesNarrowing&quot;, arg);
199         }
200     }
201 
202     public static short shortReverseBytesNarrowing(int value) {
203         return Short.reverseBytes((short) value);
204     }
205 
206     @Test
207     public void testIntegerSubstitutions() {
208         Object[] args = new Object[]{Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE};
209 
<span class="line-modified">210         testSubstitution(&quot;integerReverseBytes&quot;, ReverseBytesNode.class, Integer.class, &quot;reverseBytes&quot;, false, args);</span>
<span class="line-modified">211         testSubstitution(&quot;integerNumberOfLeadingZeros&quot;, BitScanReverseNode.class, Integer.class, &quot;numberOfLeadingZeros&quot;, true, args);</span>
<span class="line-modified">212         testSubstitution(&quot;integerNumberOfTrailingZeros&quot;, BitScanForwardNode.class, Integer.class, &quot;numberOfTrailingZeros&quot;, false, args);</span>
<span class="line-modified">213         testSubstitution(&quot;integerBitCount&quot;, BitCountNode.class, Integer.class, &quot;bitCount&quot;, true, args);</span>
214     }
215 
216     public static int integerReverseBytes(int value) {
217         return Integer.reverseBytes(value);
218     }
219 
220     public static int integerNumberOfLeadingZeros(int value) {
221         return Integer.numberOfLeadingZeros(value);
222     }
223 
224     public static int integerNumberOfTrailingZeros(int value) {
225         return Integer.numberOfTrailingZeros(value);
226     }
227 
228     public static int integerBitCount(int value) {
229         return Integer.bitCount(value);
230     }
231 
232     @Test
233     public void testLongSubstitutions() {
234         Object[] args = new Object[]{Long.MIN_VALUE, -1L, 0L, 1L, Long.MAX_VALUE};
235 
<span class="line-modified">236         testSubstitution(&quot;longReverseBytes&quot;, ReverseBytesNode.class, Long.class, &quot;reverseBytes&quot;, false, args);</span>
<span class="line-modified">237         testSubstitution(&quot;longNumberOfLeadingZeros&quot;, BitScanReverseNode.class, Long.class, &quot;numberOfLeadingZeros&quot;, true, args);</span>
<span class="line-modified">238         testSubstitution(&quot;longNumberOfTrailingZeros&quot;, BitScanForwardNode.class, Long.class, &quot;numberOfTrailingZeros&quot;, false, args);</span>
<span class="line-modified">239         testSubstitution(&quot;longBitCount&quot;, BitCountNode.class, Long.class, &quot;bitCount&quot;, true, args);</span>
240     }
241 
242     public static long longReverseBytes(long value) {
243         return Long.reverseBytes(value);
244     }
245 
246     public static int longNumberOfLeadingZeros(long value) {
247         return Long.numberOfLeadingZeros(value);
248     }
249 
250     public static int longNumberOfTrailingZeros(long value) {
251         return Long.numberOfTrailingZeros(value);
252     }
253 
254     public static int longBitCount(long value) {
255         return Long.bitCount(value);
256     }
257 
258     @Test
259     public void testFloatSubstitutions() {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.test;
 26 
 27 import java.util.HashMap;
 28 
 29 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 30 import org.graalvm.compiler.nodes.IfNode;
 31 import org.graalvm.compiler.nodes.StructuredGraph;
 32 import org.graalvm.compiler.nodes.calc.AbsNode;
 33 import org.graalvm.compiler.nodes.calc.ReinterpretNode;
<span class="line-added"> 34 import org.graalvm.compiler.replacements.amd64.AMD64CountLeadingZerosNode;</span>
<span class="line-added"> 35 import org.graalvm.compiler.replacements.amd64.AMD64CountTrailingZerosNode;</span>
 36 import org.graalvm.compiler.replacements.nodes.BitCountNode;
 37 import org.graalvm.compiler.replacements.nodes.BitScanForwardNode;
 38 import org.graalvm.compiler.replacements.nodes.BitScanReverseNode;
 39 import org.graalvm.compiler.replacements.nodes.ReverseBytesNode;
 40 import org.junit.Test;
 41 
 42 import jdk.vm.ci.code.InstalledCode;
 43 import jdk.vm.ci.meta.ResolvedJavaMethod;
 44 
 45 /**
 46  * Tests the VM independent {@link MethodSubstitution}s.
 47  */
 48 public class StandardMethodSubstitutionsTest extends MethodSubstitutionTest {
 49 
 50     @Test
 51     public void testMathSubstitutions() {
 52         assertInGraph(assertNotInGraph(testGraph(&quot;mathAbs&quot;), IfNode.class), AbsNode.class);     // Java
 53         double value = 34567.891D;
 54         testGraph(&quot;mathCos&quot;);
 55         testGraph(&quot;mathLog&quot;);
</pre>
<hr />
<pre>
117     public static double mathLog10(double value) {
118         return Math.log10(value);
119     }
120 
121     public static double mathSin(double value) {
122         return Math.sin(value);
123     }
124 
125     public static double mathCos(double value) {
126         return Math.cos(value);
127     }
128 
129     public static double mathTan(double value) {
130         return Math.tan(value);
131     }
132 
133     public static double mathAll(double value) {
134         return Math.sqrt(value) + Math.log(value) + Math.log10(value) + Math.sin(value) + Math.cos(value) + Math.tan(value);
135     }
136 
<span class="line-modified">137     public void testSubstitution(String testMethodName, Class&lt;?&gt; holder, String methodName, boolean optional, Object[] args, Class&lt;?&gt;... intrinsicClasses) {</span>
138         ResolvedJavaMethod realJavaMethod = getResolvedJavaMethod(holder, methodName);
139         ResolvedJavaMethod testJavaMethod = getResolvedJavaMethod(testMethodName);
140         StructuredGraph graph = testGraph(testMethodName);
141 
142         // Check to see if the resulting graph contains the expected node
<span class="line-modified">143         StructuredGraph replacement = getReplacements().getSubstitution(realJavaMethod, -1, false, null, graph.getOptions());</span>
144         if (replacement == null &amp;&amp; !optional) {
<span class="line-modified">145             assertInGraph(graph, intrinsicClasses);</span>
146         }
147 
148         for (Object l : args) {
149             // Force compilation
150             InstalledCode code = getCode(testJavaMethod);
151             assert optional || code != null;
152             // Verify that the original method and the substitution produce the same value
153             Object expected = invokeSafe(realJavaMethod, null, l);
154             assertDeepEquals(expected, invokeSafe(testJavaMethod, null, l));
155             // Verify that the generated code and the original produce the same value
156             assertDeepEquals(expected, executeVarargsSafe(code, l));
157         }
158     }
159 
160     @Test
161     public void testCharSubstitutions() {
162         Object[] args = new Character[]{Character.MIN_VALUE, (char) -1, (char) 0, (char) 1, Character.MAX_VALUE};
163 
<span class="line-modified">164         testSubstitution(&quot;charReverseBytes&quot;, Character.class, &quot;reverseBytes&quot;, false, args, ReverseBytesNode.class);</span>
165     }
166 
167     public static char charReverseBytes(char value) {
168         return Character.reverseBytes(value);
169     }
170 
171     @Test
172     public void testCharSubstitutionsNarrowing() {
173         Object[] args = new Integer[]{(int) Character.MIN_VALUE, -1, 0, 1, (int) Character.MAX_VALUE};
174 
175         for (Object arg : args) {
176             test(&quot;charReverseBytesNarrowing&quot;, arg);
177         }
178     }
179 
180     public static char charReverseBytesNarrowing(int value) {
181         return Character.reverseBytes((char) value);
182     }
183 
184     @Test
185     public void testShortSubstitutions() {
186         Object[] args = new Short[]{Short.MIN_VALUE, -1, 0, 1, Short.MAX_VALUE};
187 
<span class="line-modified">188         testSubstitution(&quot;shortReverseBytes&quot;, Short.class, &quot;reverseBytes&quot;, false, args, ReverseBytesNode.class);</span>
189     }
190 
191     public static short shortReverseBytes(short value) {
192         return Short.reverseBytes(value);
193     }
194 
195     @Test
196     public void testShortSubstitutionsNarrowing() {
197         Object[] args = new Integer[]{(int) Short.MIN_VALUE, -1, 0, 1, (int) Short.MAX_VALUE};
198 
199         for (Object arg : args) {
200             test(&quot;shortReverseBytesNarrowing&quot;, arg);
201         }
202     }
203 
204     public static short shortReverseBytesNarrowing(int value) {
205         return Short.reverseBytes((short) value);
206     }
207 
208     @Test
209     public void testIntegerSubstitutions() {
210         Object[] args = new Object[]{Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE};
211 
<span class="line-modified">212         testSubstitution(&quot;integerReverseBytes&quot;, Integer.class, &quot;reverseBytes&quot;, false, args, ReverseBytesNode.class);</span>
<span class="line-modified">213         testSubstitution(&quot;integerNumberOfLeadingZeros&quot;, Integer.class, &quot;numberOfLeadingZeros&quot;, true, args, BitScanReverseNode.class, AMD64CountLeadingZerosNode.class);</span>
<span class="line-modified">214         testSubstitution(&quot;integerNumberOfTrailingZeros&quot;, Integer.class, &quot;numberOfTrailingZeros&quot;, false, args, BitScanForwardNode.class, AMD64CountTrailingZerosNode.class);</span>
<span class="line-modified">215         testSubstitution(&quot;integerBitCount&quot;, Integer.class, &quot;bitCount&quot;, true, args, BitCountNode.class);</span>
216     }
217 
218     public static int integerReverseBytes(int value) {
219         return Integer.reverseBytes(value);
220     }
221 
222     public static int integerNumberOfLeadingZeros(int value) {
223         return Integer.numberOfLeadingZeros(value);
224     }
225 
226     public static int integerNumberOfTrailingZeros(int value) {
227         return Integer.numberOfTrailingZeros(value);
228     }
229 
230     public static int integerBitCount(int value) {
231         return Integer.bitCount(value);
232     }
233 
234     @Test
235     public void testLongSubstitutions() {
236         Object[] args = new Object[]{Long.MIN_VALUE, -1L, 0L, 1L, Long.MAX_VALUE};
237 
<span class="line-modified">238         testSubstitution(&quot;longReverseBytes&quot;, Long.class, &quot;reverseBytes&quot;, false, args, ReverseBytesNode.class);</span>
<span class="line-modified">239         testSubstitution(&quot;longNumberOfLeadingZeros&quot;, Long.class, &quot;numberOfLeadingZeros&quot;, true, args, BitScanReverseNode.class, AMD64CountLeadingZerosNode.class);</span>
<span class="line-modified">240         testSubstitution(&quot;longNumberOfTrailingZeros&quot;, Long.class, &quot;numberOfTrailingZeros&quot;, false, args, BitScanForwardNode.class, AMD64CountTrailingZerosNode.class);</span>
<span class="line-modified">241         testSubstitution(&quot;longBitCount&quot;, Long.class, &quot;bitCount&quot;, true, args, BitCountNode.class);</span>
242     }
243 
244     public static long longReverseBytes(long value) {
245         return Long.reverseBytes(value);
246     }
247 
248     public static int longNumberOfLeadingZeros(long value) {
249         return Long.numberOfLeadingZeros(value);
250     }
251 
252     public static int longNumberOfTrailingZeros(long value) {
253         return Long.numberOfTrailingZeros(value);
254     }
255 
256     public static int longBitCount(long value) {
257         return Long.bitCount(value);
258     }
259 
260     @Test
261     public void testFloatSubstitutions() {
</pre>
</td>
</tr>
</table>
<center><a href="SnippetsTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StringCompareToTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
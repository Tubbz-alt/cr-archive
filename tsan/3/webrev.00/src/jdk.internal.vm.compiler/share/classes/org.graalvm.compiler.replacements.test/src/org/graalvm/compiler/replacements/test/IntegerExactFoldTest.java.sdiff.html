<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/IntegerExactFoldTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IntegerExactExceptionTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MethodSubstitutionTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/IntegerExactFoldTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 77         assert lowerBoundB &lt;= upperBoundB;
 78         assert bits == 64 || isInteger(lowerBoundA);
 79         assert bits == 64 || isInteger(upperBoundA);
 80         assert bits == 64 || isInteger(lowerBoundB);
 81         assert bits == 64 || isInteger(upperBoundB);
 82     }
 83 
 84     @Test
 85     public void testFolding() {
 86         StructuredGraph graph = prepareGraph();
 87         IntegerStamp a = StampFactory.forInteger(bits, lowerBoundA, upperBoundA);
 88         IntegerStamp b = StampFactory.forInteger(bits, lowerBoundB, upperBoundB);
 89 
 90         List&lt;ParameterNode&gt; params = graph.getNodes(ParameterNode.TYPE).snapshot();
 91         params.get(0).replaceAtMatchingUsages(graph.addOrUnique(new PiNode(params.get(0), a)), x -&gt; x instanceof IntegerExactArithmeticNode);
 92         params.get(1).replaceAtMatchingUsages(graph.addOrUnique(new PiNode(params.get(1), b)), x -&gt; x instanceof IntegerExactArithmeticNode);
 93 
 94         Node originalNode = graph.getNodes().filter(x -&gt; x instanceof IntegerExactArithmeticNode).first();
 95         assertNotNull(&quot;original node must be in the graph&quot;, originalNode);
 96 
<span class="line-modified"> 97         new CanonicalizerPhase().apply(graph, getDefaultHighTierContext());</span>
 98 
 99         ValueNode node = findNode(graph);
100         boolean overflowExpected = node instanceof IntegerExactArithmeticNode;
101 
102         IntegerStamp resultStamp = (IntegerStamp) node.stamp(NodeView.DEFAULT);
103         operation.verifyOverflow(lowerBoundA, upperBoundA, lowerBoundB, upperBoundB, bits, overflowExpected, resultStamp);
104     }
105 
106     @Test
107     public void testFoldingAfterLowering() {
108         StructuredGraph graph = prepareGraph();
109 
110         Node originalNode = graph.getNodes().filter(x -&gt; x instanceof IntegerExactArithmeticNode).first();
111         assertNotNull(&quot;original node must be in the graph&quot;, originalNode);
<span class="line-modified">112         CanonicalizerPhase canonicalizer = new CanonicalizerPhase();</span>
113         HighTierContext highTierContext = getDefaultHighTierContext();
114         new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, highTierContext);
115         MidTierContext midTierContext = getDefaultMidTierContext();
116         new GuardLoweringPhase().apply(graph, midTierContext);
<span class="line-modified">117         new CanonicalizerPhase().apply(graph, midTierContext);</span>
118 
119         IntegerExactArithmeticSplitNode loweredNode = graph.getNodes().filter(IntegerExactArithmeticSplitNode.class).first();
120         assertNotNull(&quot;the lowered node must be in the graph&quot;, loweredNode);
121 
122         loweredNode.getX().setStamp(StampFactory.forInteger(bits, lowerBoundA, upperBoundA));
123         loweredNode.getY().setStamp(StampFactory.forInteger(bits, lowerBoundB, upperBoundB));
<span class="line-modified">124         new CanonicalizerPhase().apply(graph, midTierContext);</span>
125 
126         ValueNode node = findNode(graph);
127         boolean overflowExpected = node instanceof IntegerExactArithmeticSplitNode;
128 
129         IntegerStamp resultStamp = (IntegerStamp) node.stamp(NodeView.DEFAULT);
130         operation.verifyOverflow(lowerBoundA, upperBoundA, lowerBoundB, upperBoundB, bits, overflowExpected, resultStamp);
131     }
132 
133     private static boolean isInteger(long value) {
134         return value &gt;= Integer.MIN_VALUE &amp;&amp; value &lt;= Integer.MAX_VALUE;
135     }
136 
137     private static ValueNode findNode(StructuredGraph graph) {
138         ValueNode resultNode = graph.getNodes().filter(ReturnNode.class).first().result();
139         assertNotNull(&quot;some node must be the returned value&quot;, resultNode);
140         return resultNode;
141     }
142 
143     protected StructuredGraph prepareGraph() {
144         String snippet = &quot;snippetInt&quot; + bits;
145         StructuredGraph graph = parseEager(getResolvedJavaMethod(operation.getClass(), snippet), AllowAssumptions.NO);
146         HighTierContext context = getDefaultHighTierContext();
<span class="line-modified">147         new CanonicalizerPhase().apply(graph, context);</span>
148         return graph;
149     }
150 
151     private static void addTest(ArrayList&lt;Object[]&gt; tests, long lowerBound1, long upperBound1, long lowerBound2, long upperBound2, int bits, Operation operation) {
152         tests.add(new Object[]{lowerBound1, upperBound1, lowerBound2, upperBound2, bits, operation});
153     }
154 
155     @Parameters(name = &quot;a[{0} / {1}], b[{2} / {3}], bits={4}, operation={5}&quot;)
156     public static Collection&lt;Object[]&gt; data() {
157         ArrayList&lt;Object[]&gt; tests = new ArrayList&lt;&gt;();
158 
159         Operation[] operations = new Operation[]{new AddOperation(), new SubOperation(), new MulOperation()};
160         for (Operation operation : operations) {
161             for (int bits : new int[]{32, 64}) {
162                 // zero related
163                 addTest(tests, 0, 0, 1, 1, bits, operation);
164                 addTest(tests, 1, 1, 0, 0, bits, operation);
165                 addTest(tests, -1, 1, 0, 1, bits, operation);
166 
167                 // bounds
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 77         assert lowerBoundB &lt;= upperBoundB;
 78         assert bits == 64 || isInteger(lowerBoundA);
 79         assert bits == 64 || isInteger(upperBoundA);
 80         assert bits == 64 || isInteger(lowerBoundB);
 81         assert bits == 64 || isInteger(upperBoundB);
 82     }
 83 
 84     @Test
 85     public void testFolding() {
 86         StructuredGraph graph = prepareGraph();
 87         IntegerStamp a = StampFactory.forInteger(bits, lowerBoundA, upperBoundA);
 88         IntegerStamp b = StampFactory.forInteger(bits, lowerBoundB, upperBoundB);
 89 
 90         List&lt;ParameterNode&gt; params = graph.getNodes(ParameterNode.TYPE).snapshot();
 91         params.get(0).replaceAtMatchingUsages(graph.addOrUnique(new PiNode(params.get(0), a)), x -&gt; x instanceof IntegerExactArithmeticNode);
 92         params.get(1).replaceAtMatchingUsages(graph.addOrUnique(new PiNode(params.get(1), b)), x -&gt; x instanceof IntegerExactArithmeticNode);
 93 
 94         Node originalNode = graph.getNodes().filter(x -&gt; x instanceof IntegerExactArithmeticNode).first();
 95         assertNotNull(&quot;original node must be in the graph&quot;, originalNode);
 96 
<span class="line-modified"> 97         createCanonicalizerPhase().apply(graph, getDefaultHighTierContext());</span>
 98 
 99         ValueNode node = findNode(graph);
100         boolean overflowExpected = node instanceof IntegerExactArithmeticNode;
101 
102         IntegerStamp resultStamp = (IntegerStamp) node.stamp(NodeView.DEFAULT);
103         operation.verifyOverflow(lowerBoundA, upperBoundA, lowerBoundB, upperBoundB, bits, overflowExpected, resultStamp);
104     }
105 
106     @Test
107     public void testFoldingAfterLowering() {
108         StructuredGraph graph = prepareGraph();
109 
110         Node originalNode = graph.getNodes().filter(x -&gt; x instanceof IntegerExactArithmeticNode).first();
111         assertNotNull(&quot;original node must be in the graph&quot;, originalNode);
<span class="line-modified">112         CanonicalizerPhase canonicalizer = createCanonicalizerPhase();</span>
113         HighTierContext highTierContext = getDefaultHighTierContext();
114         new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, highTierContext);
115         MidTierContext midTierContext = getDefaultMidTierContext();
116         new GuardLoweringPhase().apply(graph, midTierContext);
<span class="line-modified">117         createCanonicalizerPhase().apply(graph, midTierContext);</span>
118 
119         IntegerExactArithmeticSplitNode loweredNode = graph.getNodes().filter(IntegerExactArithmeticSplitNode.class).first();
120         assertNotNull(&quot;the lowered node must be in the graph&quot;, loweredNode);
121 
122         loweredNode.getX().setStamp(StampFactory.forInteger(bits, lowerBoundA, upperBoundA));
123         loweredNode.getY().setStamp(StampFactory.forInteger(bits, lowerBoundB, upperBoundB));
<span class="line-modified">124         createCanonicalizerPhase().apply(graph, midTierContext);</span>
125 
126         ValueNode node = findNode(graph);
127         boolean overflowExpected = node instanceof IntegerExactArithmeticSplitNode;
128 
129         IntegerStamp resultStamp = (IntegerStamp) node.stamp(NodeView.DEFAULT);
130         operation.verifyOverflow(lowerBoundA, upperBoundA, lowerBoundB, upperBoundB, bits, overflowExpected, resultStamp);
131     }
132 
133     private static boolean isInteger(long value) {
134         return value &gt;= Integer.MIN_VALUE &amp;&amp; value &lt;= Integer.MAX_VALUE;
135     }
136 
137     private static ValueNode findNode(StructuredGraph graph) {
138         ValueNode resultNode = graph.getNodes().filter(ReturnNode.class).first().result();
139         assertNotNull(&quot;some node must be the returned value&quot;, resultNode);
140         return resultNode;
141     }
142 
143     protected StructuredGraph prepareGraph() {
144         String snippet = &quot;snippetInt&quot; + bits;
145         StructuredGraph graph = parseEager(getResolvedJavaMethod(operation.getClass(), snippet), AllowAssumptions.NO);
146         HighTierContext context = getDefaultHighTierContext();
<span class="line-modified">147         createCanonicalizerPhase().apply(graph, context);</span>
148         return graph;
149     }
150 
151     private static void addTest(ArrayList&lt;Object[]&gt; tests, long lowerBound1, long upperBound1, long lowerBound2, long upperBound2, int bits, Operation operation) {
152         tests.add(new Object[]{lowerBound1, upperBound1, lowerBound2, upperBound2, bits, operation});
153     }
154 
155     @Parameters(name = &quot;a[{0} / {1}], b[{2} / {3}], bits={4}, operation={5}&quot;)
156     public static Collection&lt;Object[]&gt; data() {
157         ArrayList&lt;Object[]&gt; tests = new ArrayList&lt;&gt;();
158 
159         Operation[] operations = new Operation[]{new AddOperation(), new SubOperation(), new MulOperation()};
160         for (Operation operation : operations) {
161             for (int bits : new int[]{32, 64}) {
162                 // zero related
163                 addTest(tests, 0, 0, 1, 1, bits, operation);
164                 addTest(tests, 1, 1, 0, 0, bits, operation);
165                 addTest(tests, -1, 1, 0, 1, bits, operation);
166 
167                 // bounds
</pre>
</td>
</tr>
</table>
<center><a href="IntegerExactExceptionTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MethodSubstitutionTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
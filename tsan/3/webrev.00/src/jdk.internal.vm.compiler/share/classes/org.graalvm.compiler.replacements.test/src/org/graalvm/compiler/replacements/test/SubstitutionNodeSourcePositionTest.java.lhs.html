<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/SubstitutionNodeSourcePositionTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.test;
 26 
 27 import static org.graalvm.compiler.core.GraalCompiler.compileGraph;
 28 import static org.graalvm.compiler.core.common.GraalOptions.TrackNodeSourcePosition;
<a name="2" id="anc2"></a>
 29 
 30 import java.util.List;
 31 
 32 import org.graalvm.compiler.api.directives.GraalDirectives;
 33 import org.graalvm.compiler.api.replacements.ClassSubstitution;
 34 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 35 import org.graalvm.compiler.code.CompilationResult;
 36 import org.graalvm.compiler.code.SourceMapping;
 37 import org.graalvm.compiler.graph.Node;
 38 import org.graalvm.compiler.graph.NodeSourcePosition;
 39 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
 40 import org.graalvm.compiler.nodes.StructuredGraph;
 41 import org.graalvm.compiler.nodes.debug.BlackholeNode;
 42 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 43 import org.graalvm.compiler.options.OptionValues;
 44 import org.graalvm.compiler.phases.OptimisticOptimizations;
 45 import org.graalvm.compiler.replacements.classfile.ClassfileBytecodeProvider;
 46 import org.junit.Assert;
<a name="3" id="anc3"></a>
 47 import org.junit.Test;
 48 
 49 import jdk.vm.ci.meta.ResolvedJavaMethod;
 50 import jdk.vm.ci.meta.ResolvedJavaType;
 51 
 52 /**
 53  * Test that various substitution implementations produce the expected
 54  * {@link org.graalvm.compiler.graph.NodeSourcePosition} structure. Method substitutions and method
 55  * plugins should leave behind a frame for the substitution. Method substitutions should have
 56  * bytecodes below the substitution. Snippet lowerings should just have the bytecodes without a
 57  * marker frame.
 58  */
 59 public class SubstitutionNodeSourcePositionTest extends ReplacementsTest {
 60 
 61     private static class TestMethod {
 62 
 63         public static int test(int i) {
 64             return i;
 65         }
 66     }
 67 
 68     @ClassSubstitution(TestMethod.class)
 69     public static class TestMethodSubstitution {
 70 
 71         @MethodSubstitution
 72         public static int test(int i) {
 73             blackhole(i);
 74             return i;
 75         }
 76 
 77         @Node.NodeIntrinsic(BlackholeNode.class)
 78         private static native void blackhole(int i);
 79     }
 80 
 81     @Override
 82     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
 83         new PluginFactory_SubstitutionNodeSourcePositionTest().registerPlugins(invocationPlugins, null);
 84         ClassfileBytecodeProvider bytecodeProvider = getSystemClassLoaderBytecodeProvider();
<a name="4" id="anc4"></a><span class="line-modified"> 85         InvocationPlugins.Registration r = new InvocationPlugins.Registration(invocationPlugins, TestMethod.class, bytecodeProvider);</span>
 86         r.registerMethodSubstitution(TestMethodSubstitution.class, &quot;test&quot;, int.class);
 87         super.registerInvocationPlugins(invocationPlugins);
 88     }
 89 
 90     public int methodSubstitution() {
 91         return TestMethod.test(42);
 92     }
 93 
 94     @Test
 95     public void testMethodSubstitution() {
 96         // @formatter:off
 97         // Expect mappings of the form:
 98         //   at org.graalvm.compiler.replacements.test.SubstitutionNodeSourcePositionTest$TestMethodSubstitution.blackhole(int) [bci: -1]
 99         //   at org.graalvm.compiler.replacements.test.SubstitutionNodeSourcePositionTest$TestMethodSubstitution.test(SubstitutionNodeSourcePositionTest.java:71) [bci: 1] Substitution
100         //   at org.graalvm.compiler.replacements.test.SubstitutionNodeSourcePositionTest$TestMethod.test(int) [bci: -1]
101         //   at org.graalvm.compiler.replacements.test.SubstitutionNodeSourcePositionTest.methodSubstitution(SubstitutionNodeSourcePositionTest.java:89) [bci: 2]
102         // @formatter:on
<a name="5" id="anc5"></a>
103         checkMappings(&quot;methodSubstitution&quot;, true, TestMethod.class, &quot;test&quot;);
104     }
105 
106     public void snippetLowering(String[] array, String value) {
107         array[0] = value;
108     }
109 
110     @Test
111     public void testSnippetLowering() {
112         // @formatter:off
113         // Expect mappings of the form:
114         //   at org.graalvm.compiler.hotspot.replacements.WriteBarrierSnippets.serialWriteBarrier(WriteBarrierSnippets.java:140) [bci: 18]
115         //   at org.graalvm.compiler.hotspot.replacements.WriteBarrierSnippets.serialPreciseWriteBarrier(WriteBarrierSnippets.java:158) [bci: 5] Substitution
116         //   at org.graalvm.compiler.hotspot.replacements.WriteBarrierSnippets.serialPreciseWriteBarrier(AddressNode$Address, WriteBarrierSnippets$Counters) [bci: -1] Substitution
117         //   at org.graalvm.compiler.replacements.test.SubstitutionNodeSourcePositionTest.snippetLowering(SubstitutionNodeSourcePositionTest.java:99) [bci: 3]
118         // @formatter:on
119         //
120         // The precise snippet bytecodes don&#39;t matter, just ensure that some actually appear after
121         // lowering.
<a name="6" id="anc6"></a>
122         checkMappings(&quot;snippetLowering&quot;, true, SubstitutionNodeSourcePositionTest.class, &quot;snippetLowering&quot;);
123     }
124 
125     public int methodPlugin(int i) {
126         GraalDirectives.blackhole(i);
127         return i;
128     }
129 
130     @Test
131     public void testMethodPlugin() {
132         // @formatter:off
133         // Expect mappings of the form:
134         //   at org.graalvm.compiler.api.directives.GraalDirectives.blackhole(int) [bci: -1]
135         //   at org.graalvm.compiler.replacements.test.SubstitutionNodeSourcePositionTest.methodPlugin(SubstitutionNodeSourcePositionTest.java:109) [bci: 1]
136         // @formatter:on
137         checkMappings(&quot;methodPlugin&quot;, false, GraalDirectives.class, &quot;blackhole&quot;);
138     }
139 
140     private void checkMappings(String snippetMethod, boolean hasBytecodes, Class&lt;?&gt; boundaryClass, String boundaryMethod) {
141         List&lt;SourceMapping&gt; mappings = getSourceMappings(snippetMethod);
142         ResolvedJavaType resolvedJavaType = getMetaAccess().lookupJavaType(boundaryClass);
143         boolean found = false;
144         Assert.assertTrue(&quot;must have mappings&quot;, !mappings.isEmpty());
145         for (SourceMapping mapping : mappings) {
146             NodeSourcePosition callee = null;
147             for (NodeSourcePosition pos = mapping.getSourcePosition(); pos != null; pos = pos.getCaller()) {
148                 ResolvedJavaMethod method = pos.getMethod();
149                 if (method.getName().equals(boundaryMethod) &amp;&amp; method.getDeclaringClass().equals(resolvedJavaType)) {
150                     if ((callee != null) == hasBytecodes) {
151                         if (hasBytecodes) {
152                             assertTrue(callee.isSubstitution());
153                         }
154                         assertTrue(pos.trim() == pos);
155                         assertTrue(mapping.getSourcePosition().trim() == pos);
156                         found = true;
157                     }
158                 }
159                 callee = pos;
160             }
161         }
162         Assert.assertTrue(&quot;must have substitution for &quot; + resolvedJavaType + &quot;.&quot; + boundaryMethod, found);
163     }
164 
165     private List&lt;SourceMapping&gt; getSourceMappings(String name) {
166         final ResolvedJavaMethod method = getResolvedJavaMethod(name);
167         final OptionValues options = new OptionValues(getInitialOptions(), TrackNodeSourcePosition, true);
168         final StructuredGraph graph = parseEager(method, StructuredGraph.AllowAssumptions.YES, options);
169         final CompilationResult cr = compileGraph(graph, graph.method(), getProviders(), getBackend(), getDefaultGraphBuilderSuite(), OptimisticOptimizations.ALL, graph.getProfilingInfo(),
170                         createSuites(graph.getOptions()), createLIRSuites(graph.getOptions()), new CompilationResult(graph.compilationId()), CompilationResultBuilderFactory.Default, true);
171         return cr.getSourceMappings();
172     }
173 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
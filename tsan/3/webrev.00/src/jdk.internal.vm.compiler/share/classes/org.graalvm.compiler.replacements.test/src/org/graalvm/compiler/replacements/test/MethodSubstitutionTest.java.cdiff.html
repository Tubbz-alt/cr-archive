<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/MethodSubstitutionTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IntegerExactFoldTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NullBytecodeExceptionTest.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/MethodSubstitutionTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,21 ***</span>
  
  
  package org.graalvm.compiler.replacements.test;
  
  import java.lang.reflect.InvocationTargetException;
  
  import org.graalvm.compiler.api.replacements.MethodSubstitution;
  import org.graalvm.compiler.core.test.GraalCompilerTest;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.nodes.Invoke;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
  import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  import org.graalvm.compiler.nodes.spi.LoweringTool;
<span class="line-removed">- import org.graalvm.compiler.phases.common.CanonicalizerPhase;</span>
  import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
  import org.graalvm.compiler.phases.common.LoweringPhase;
  import org.graalvm.compiler.phases.tiers.HighTierContext;
  import org.graalvm.compiler.replacements.nodes.MacroNode;
  
<span class="line-new-header">--- 23,21 ---</span>
  
  
  package org.graalvm.compiler.replacements.test;
  
  import java.lang.reflect.InvocationTargetException;
<span class="line-added">+ import java.util.Arrays;</span>
  
  import org.graalvm.compiler.api.replacements.MethodSubstitution;
  import org.graalvm.compiler.core.test.GraalCompilerTest;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.nodes.Invoke;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
  import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  import org.graalvm.compiler.nodes.spi.LoweringTool;
  import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
  import org.graalvm.compiler.phases.common.LoweringPhase;
  import org.graalvm.compiler.phases.tiers.HighTierContext;
  import org.graalvm.compiler.replacements.nodes.MacroNode;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,47 ***</span>
  
      protected StructuredGraph testGraph(final String snippet) {
          return testGraph(snippet, null);
      }
  
<span class="line-modified">!     @SuppressWarnings(&quot;try&quot;)</span>
      protected StructuredGraph testGraph(final String snippet, String name) {
<span class="line-modified">!         return testGraph(getResolvedJavaMethod(snippet), name);</span>
      }
  
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     protected StructuredGraph testGraph(final ResolvedJavaMethod method, String name) {</span>
          DebugContext debug = getDebugContext();
          try (DebugContext.Scope s = debug.scope(&quot;MethodSubstitutionTest&quot;, method)) {
              StructuredGraph graph = parseEager(method, AllowAssumptions.YES, debug);
              HighTierContext context = getDefaultHighTierContext();
              debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;Graph&quot;);
              createInliningPhase().apply(graph, context);
              debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;Graph&quot;);
<span class="line-modified">!             new CanonicalizerPhase().apply(graph, context);</span>
              new DeadCodeEliminationPhase().apply(graph);
              // Try to ensure any macro nodes are lowered to expose any resulting invokes
              if (graph.getNodes().filter(MacroNode.class).isNotEmpty()) {
<span class="line-modified">!                 new LoweringPhase(new CanonicalizerPhase(), LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, context);</span>
              }
              if (graph.getNodes().filter(MacroNode.class).isNotEmpty()) {
<span class="line-modified">!                 new LoweringPhase(new CanonicalizerPhase(), LoweringTool.StandardLoweringStage.MID_TIER).apply(graph, context);</span>
              }
              assertNotInGraph(graph, MacroNode.class);
              if (name != null) {
                  for (Node node : graph.getNodes()) {
                      if (node instanceof Invoke) {
                          Invoke invoke = (Invoke) node;
                          if (invoke.callTarget() instanceof MethodCallTargetNode) {
                              MethodCallTargetNode call = (MethodCallTargetNode) invoke.callTarget();
<span class="line-modified">!                             assertTrue(!call.targetMethod().getName().equals(name), &quot;Unexpected invoke of intrinsic %s&quot;, call.targetMethod());</span>
                          }
                      }
  
                  }
              } else {
<span class="line-modified">!                 assertNotInGraph(graph, Invoke.class);</span>
              }
              return graph;
          } catch (Throwable e) {
              throw debug.handle(e);
          }
<span class="line-new-header">--- 54,64 ---</span>
  
      protected StructuredGraph testGraph(final String snippet) {
          return testGraph(snippet, null);
      }
  
<span class="line-modified">!     protected StructuredGraph testGraph(final String snippet, boolean assertInvoke) {</span>
<span class="line-added">+         return testGraph(snippet, null, assertInvoke);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      protected StructuredGraph testGraph(final String snippet, String name) {
<span class="line-modified">!         return testGraph(snippet, name, false);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-added">+     protected StructuredGraph testGraph(final String snippet, String name, boolean assertInvoke) {</span>
<span class="line-added">+         return testGraph(getResolvedJavaMethod(snippet), name, assertInvoke);</span>
      }
  
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     protected StructuredGraph testGraph(final ResolvedJavaMethod method, String name, boolean assertInvoke) {</span>
          DebugContext debug = getDebugContext();
          try (DebugContext.Scope s = debug.scope(&quot;MethodSubstitutionTest&quot;, method)) {
              StructuredGraph graph = parseEager(method, AllowAssumptions.YES, debug);
              HighTierContext context = getDefaultHighTierContext();
              debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;Graph&quot;);
              createInliningPhase().apply(graph, context);
              debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;Graph&quot;);
<span class="line-modified">!             createCanonicalizerPhase().apply(graph, context);</span>
              new DeadCodeEliminationPhase().apply(graph);
              // Try to ensure any macro nodes are lowered to expose any resulting invokes
              if (graph.getNodes().filter(MacroNode.class).isNotEmpty()) {
<span class="line-modified">!                 new LoweringPhase(this.createCanonicalizerPhase(), LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, context);</span>
              }
              if (graph.getNodes().filter(MacroNode.class).isNotEmpty()) {
<span class="line-modified">!                 new LoweringPhase(this.createCanonicalizerPhase(), LoweringTool.StandardLoweringStage.MID_TIER).apply(graph, context);</span>
              }
              assertNotInGraph(graph, MacroNode.class);
              if (name != null) {
                  for (Node node : graph.getNodes()) {
                      if (node instanceof Invoke) {
                          Invoke invoke = (Invoke) node;
                          if (invoke.callTarget() instanceof MethodCallTargetNode) {
                              MethodCallTargetNode call = (MethodCallTargetNode) invoke.callTarget();
<span class="line-modified">!                             boolean found = call.targetMethod().getName().equals(name);</span>
<span class="line-added">+                             if (assertInvoke) {</span>
<span class="line-added">+                                 assertTrue(found, &quot;Expected to find a call to %s&quot;, name);</span>
<span class="line-added">+                             } else {</span>
<span class="line-added">+                                 assertFalse(found, &quot;Unexpected call to %s&quot;, name);</span>
<span class="line-added">+                             }</span>
                          }
                      }
  
                  }
              } else {
<span class="line-modified">!                 if (assertInvoke) {</span>
<span class="line-added">+                     assertInGraph(graph, Invoke.class);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     assertNotInGraph(graph, Invoke.class);</span>
<span class="line-added">+                 }</span>
              }
              return graph;
          } catch (Throwable e) {
              throw debug.handle(e);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 114,11 ***</span>
          ResolvedJavaMethod realMethod = getResolvedJavaMethod(holder, methodName, parameterTypes);
          ResolvedJavaMethod testMethod = getResolvedJavaMethod(testMethodName);
          StructuredGraph graph = testGraph(testMethodName);
  
          // Check to see if the resulting graph contains the expected node
<span class="line-modified">!         StructuredGraph replacement = getReplacements().getSubstitution(realMethod, -1, false, null);</span>
          if (replacement == null &amp;&amp; !optional) {
              assertInGraph(graph, intrinsicClass);
          }
  
          // Force compilation
<span class="line-new-header">--- 131,11 ---</span>
          ResolvedJavaMethod realMethod = getResolvedJavaMethod(holder, methodName, parameterTypes);
          ResolvedJavaMethod testMethod = getResolvedJavaMethod(testMethodName);
          StructuredGraph graph = testGraph(testMethodName);
  
          // Check to see if the resulting graph contains the expected node
<span class="line-modified">!         StructuredGraph replacement = getReplacements().getSubstitution(realMethod, -1, false, null, graph.getOptions());</span>
          if (replacement == null &amp;&amp; !optional) {
              assertInGraph(graph, intrinsicClass);
          }
  
          // Force compilation
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,17 ***</span>
              // Verify that the generated code and the original produce the same value
              assertDeepEquals(expected, executeVarargsSafe(code, arg1, arg2));
          }
      }
  
<span class="line-modified">!     protected static StructuredGraph assertInGraph(StructuredGraph graph, Class&lt;?&gt; clazz) {</span>
          for (Node node : graph.getNodes()) {
<span class="line-modified">!             if (clazz.isInstance(node)) {</span>
<span class="line-modified">!                 return graph;</span>
              }
          }
<span class="line-modified">!         fail(&quot;Graph does not contain a node of class &quot; + clazz.getName());</span>
          return graph;
      }
  
      protected static Object executeVarargsSafe(InstalledCode code, Object... args) {
          try {
<span class="line-new-header">--- 151,24 ---</span>
              // Verify that the generated code and the original produce the same value
              assertDeepEquals(expected, executeVarargsSafe(code, arg1, arg2));
          }
      }
  
<span class="line-modified">!     protected static StructuredGraph assertInGraph(StructuredGraph graph, Class&lt;?&gt;... clazzes) {</span>
          for (Node node : graph.getNodes()) {
<span class="line-modified">!             for (Class&lt;?&gt; clazz : clazzes) {</span>
<span class="line-modified">!                 if (clazz.isInstance(node)) {</span>
<span class="line-added">+                     return graph;</span>
<span class="line-added">+                 }</span>
              }
          }
<span class="line-modified">!         if (clazzes.length == 1) {</span>
<span class="line-added">+             fail(&quot;Graph does not contain a node of class &quot; + clazzes[0].getName());</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             fail(&quot;Graph does not contain a node of one these classes class &quot; + Arrays.toString(clazzes));</span>
<span class="line-added">+ </span>
<span class="line-added">+         }</span>
          return graph;
      }
  
      protected static Object executeVarargsSafe(InstalledCode code, Object... args) {
          try {
</pre>
<center><a href="IntegerExactFoldTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NullBytecodeExceptionTest.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
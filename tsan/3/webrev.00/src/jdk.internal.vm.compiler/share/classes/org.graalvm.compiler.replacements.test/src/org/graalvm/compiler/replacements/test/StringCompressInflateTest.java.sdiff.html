<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/StringCompressInflateTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringCompareToTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StringIndexOfCharTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/StringCompressInflateTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.test;
 26 
 27 import static org.junit.Assume.assumeFalse;
 28 import static org.junit.Assume.assumeTrue;
 29 
 30 import java.io.UnsupportedEncodingException;
 31 
 32 import org.graalvm.compiler.core.common.CompilationIdentifier;
 33 import org.graalvm.compiler.nodes.StructuredGraph;
 34 import org.graalvm.compiler.replacements.amd64.AMD64StringLatin1InflateNode;
 35 import org.graalvm.compiler.replacements.amd64.AMD64StringLatin1Substitutions;
 36 import org.graalvm.compiler.replacements.amd64.AMD64StringUTF16CompressNode;
 37 import org.graalvm.compiler.replacements.amd64.AMD64StringUTF16Substitutions;

 38 import org.graalvm.compiler.test.AddExports;
 39 import org.junit.Before;
 40 import org.junit.Test;
 41 
 42 import jdk.vm.ci.amd64.AMD64;
 43 import jdk.vm.ci.code.InstalledCode;
 44 import jdk.vm.ci.meta.ResolvedJavaMethod;
 45 
 46 /**
 47  * Test intrinsic/node substitutions for (innate) methods StringLatin1.inflate and
 48  * StringUTF16.compress provided by {@link AMD64StringLatin1Substitutions} and
 49  * {@link AMD64StringUTF16Substitutions}.
 50  */
 51 @AddExports({&quot;java.base/java.lang&quot;})
 52 public final class StringCompressInflateTest extends MethodSubstitutionTest {
 53 
 54     static final int N = 1000;
 55 
 56     @Before
 57     public void checkAMD64() {
<span class="line-modified"> 58         assumeFalse(Java8OrEarlier);</span>
 59         // Test case is (currently) AMD64 only.
 60         assumeTrue(getTarget().arch instanceof AMD64);
 61     }
 62 
 63     @Test
 64     public void testStringLatin1Inflate() throws ClassNotFoundException, UnsupportedEncodingException {
 65         Class&lt;?&gt; javaclass = Class.forName(&quot;java.lang.StringLatin1&quot;);
 66         Class&lt;?&gt; testclass = AMD64StringLatin1InflateNode.class;
 67 
 68         TestMethods tms = new TestMethods(&quot;testInflate&quot;, javaclass, AMD64StringLatin1InflateNode.class, &quot;inflate&quot;,
 69                         byte[].class, int.class, char[].class, int.class, int.class);
 70 
 71         tms.testSubstitution(testclass);
 72 
 73         for (int i = 0; i &lt; N; i++) {
 74             byte[] src = fillLatinBytes(new byte[i2sz(i)]);
 75             char[] dst = new char[i2sz(i)];
 76 
 77             // Invoke void StringLatin1.inflate(byte[], 0, char[], 0, length)
 78             Object nil = tms.invokeJava(src, 0, dst, 0, i2sz(i));
</pre>
<hr />
<pre>
 97 
 98             // Another sanity check:
 99             for (int j = 0; j &lt; i2sz(i); j++) {
100                 assert (inflate1[j] &amp; 0xff00) == 0;
101                 assert (32 &lt;= inflate1[j] &amp;&amp; inflate1[j] &lt;= 126) || (160 &lt;= inflate1[j] &amp;&amp; inflate1[j] &lt;= 255);
102             }
103 
104             assertDeepEquals(dst, inflate1);
105 
106             // Invoke char[] testInflate(String) through code handle.
107             char[] inflate2 = (char[]) tms.invokeCode(str);
108             assertDeepEquals(dst, inflate2);
109         }
110     }
111 
112     @Test
113     public void testStringLatin1InflateByteByte() throws ClassNotFoundException {
114         Class&lt;?&gt; javaclass = Class.forName(&quot;java.lang.StringLatin1&quot;);
115 
116         ResolvedJavaMethod caller = getResolvedJavaMethod(javaclass, &quot;inflate&quot;, byte[].class, int.class, byte[].class, int.class, int.class);
<span class="line-modified">117         StructuredGraph graph = getReplacements().getIntrinsicGraph(caller, CompilationIdentifier.INVALID_COMPILATION_ID, getDebugContext());</span>
118         assertInGraph(graph, AMD64StringLatin1InflateNode.class);
119 
120         InstalledCode code = getCode(caller, graph);
121 
122         for (int dstOffset = 0; dstOffset &lt; 2; dstOffset++) {
123             for (int srcOffset = 0; srcOffset &lt; 2; srcOffset++) {
124                 for (int i = 0; i &lt; N; i++) {
125                     int length = i2sz(i);
126                     byte[] src = fillLatinBytes(new byte[length]);
127                     int resultLength = length * 2;
128                     byte[] dst = new byte[resultLength];
129                     int copiedLength = Math.max(0, length - Math.max(dstOffset, srcOffset));
130                     int dstDelta = Math.min(dstOffset, copiedLength);
131                     int srcDelta = Math.min(srcOffset, copiedLength);
132                     invokeSafe(caller, null, src, srcDelta, dst, dstDelta, copiedLength);
133 
134                     // Perform a sanity check:
135                     for (int j = 0; j &lt; copiedLength; j++) {
136                         assert (dst[j * 2 + 1 + dstDelta * 2]) == 0;
137                         int c = dst[j * 2 + dstDelta * 2] &amp; 0xFF;
138                         assert (32 &lt;= c &amp;&amp; c &lt;= 126) || (160 &lt;= c &amp;&amp; c &lt;= 255);
139                         assert (c == (src[j + srcDelta] &amp; 0xFF));
140                     }
141 
142                     byte[] dst2 = new byte[resultLength];
143                     executeVarargsSafe(code, src, srcDelta, dst2, dstDelta, copiedLength);
144                     assertDeepEquals(dst, dst2);
145                 }
146             }
147         }
148     }
149 
150     @Test
151     public void testStringLatin1InflateByteChar() throws ClassNotFoundException {
152         Class&lt;?&gt; javaclass = Class.forName(&quot;java.lang.StringLatin1&quot;);
153 
154         ResolvedJavaMethod caller = getResolvedJavaMethod(javaclass, &quot;inflate&quot;, byte[].class, int.class, char[].class, int.class, int.class);
<span class="line-modified">155         StructuredGraph graph = getReplacements().getIntrinsicGraph(caller, CompilationIdentifier.INVALID_COMPILATION_ID, getDebugContext());</span>
156         assertInGraph(graph, AMD64StringLatin1InflateNode.class);
157 
158         InstalledCode code = getCode(caller, graph);
159 
160         for (int dstOffset = 0; dstOffset &lt; 2; dstOffset++) {
161             for (int srcOffset = 0; srcOffset &lt; 2; srcOffset++) {
162                 for (int i = 0; i &lt; N; i++) {
163                     int length = i2sz(i);
164                     byte[] src = fillLatinBytes(new byte[length]);
165                     char[] dst = new char[length];
166                     int copiedLength = Math.max(0, length - Math.max(dstOffset, srcOffset));
167                     int dstDelta = Math.min(dstOffset, copiedLength);
168                     int srcDelta = Math.min(srcOffset, copiedLength);
169                     invokeSafe(caller, null, src, srcDelta, dst, dstDelta, copiedLength);
170 
171                     // Perform a sanity check:
172                     for (int j = 0; j &lt; copiedLength; j++) {
173                         int c = dst[j + dstDelta] &amp; 0xFF;
174                         assert (32 &lt;= c &amp;&amp; c &lt;= 126) || (160 &lt;= c &amp;&amp; c &lt;= 255);
175                         assert (c == (src[j + srcDelta] &amp; 0xFF));
</pre>
<hr />
<pre>
200 
201             assert (int) len == i2sz(i);
202 
203             // Invoke String testCompress(char[])
204             String str1 = (String) tms.invokeTest(src);
205 
206             assertDeepEquals(dst, str1.getBytes(&quot;ISO8859_1&quot;));
207 
208             // Invoke String testCompress(char[]) through code handle.
209             String str2 = (String) tms.invokeCode(src);
210 
211             assertDeepEquals(dst, str2.getBytes(&quot;ISO8859_1&quot;));
212         }
213     }
214 
215     @Test
216     public void testStringUTF16CompressByteByte() throws ClassNotFoundException {
217         Class&lt;?&gt; javaclass = Class.forName(&quot;java.lang.StringUTF16&quot;);
218 
219         ResolvedJavaMethod caller = getResolvedJavaMethod(javaclass, &quot;compress&quot;, byte[].class, int.class, byte[].class, int.class, int.class);
<span class="line-modified">220         StructuredGraph graph = getReplacements().getIntrinsicGraph(caller, CompilationIdentifier.INVALID_COMPILATION_ID, getDebugContext());</span>
221         assertInGraph(graph, AMD64StringUTF16CompressNode.class);
222 
223         InstalledCode code = getCode(caller, graph);
224 
225         for (int dstOffset = 0; dstOffset &lt; 2; dstOffset++) {
226             for (int srcOffset = 0; srcOffset &lt; 2; srcOffset++) {
227                 for (int i = 0; i &lt; N; i++) {
228                     int length = i2sz(i);
229                     byte[] src = fillLatinChars(new byte[length * 2]);
230                     byte[] dst = new byte[length];
231                     int copiedLength = Math.max(0, length - Math.max(dstOffset, srcOffset));
232                     int dstDelta = Math.min(dstOffset, copiedLength);
233                     int srcDelta = Math.min(srcOffset, copiedLength);
234                     invokeSafe(caller, null, src, srcDelta, dst, dstDelta, copiedLength);
235 
236                     // Perform a sanity check:
237                     for (int j = 0; j &lt; copiedLength; j++) {
238                         int c = dst[j + dstDelta] &amp; 0xFF;
239                         assert (32 &lt;= c &amp;&amp; c &lt;= 126) || (160 &lt;= c &amp;&amp; c &lt;= 255);
240                         assert (c == (src[(j + srcDelta) * 2] &amp; 0xFF));
241                     }
242 
243                     byte[] dst2 = new byte[length];
244                     executeVarargsSafe(code, src, srcDelta, dst2, dstDelta, copiedLength);
245                     assertDeepEquals(dst, dst2);
246                 }
247             }
248         }
249     }
250 
251     @Test
252     public void testStringUTF16CompressCharByte() throws ClassNotFoundException {
253         Class&lt;?&gt; javaclass = Class.forName(&quot;java.lang.StringUTF16&quot;);
254 
255         ResolvedJavaMethod caller = getResolvedJavaMethod(javaclass, &quot;compress&quot;, char[].class, int.class, byte[].class, int.class, int.class);
<span class="line-modified">256         StructuredGraph graph = getReplacements().getIntrinsicGraph(caller, CompilationIdentifier.INVALID_COMPILATION_ID, getDebugContext());</span>
257         assertInGraph(graph, AMD64StringUTF16CompressNode.class);
258 
259         InstalledCode code = getCode(caller, graph);
260 
261         for (int dstOffset = 0; dstOffset &lt; 2; dstOffset++) {
262             for (int srcOffset = 0; srcOffset &lt; 2; srcOffset++) {
263                 for (int i = 0; i &lt; N; i++) {
264                     int length = i2sz(i);
265                     char[] src = fillLatinChars(new char[length]);
266                     byte[] dst = new byte[length];
267                     int copiedLength = Math.max(0, length - Math.max(dstOffset, srcOffset));
268                     int dstDelta = Math.min(dstOffset, copiedLength);
269                     int srcDelta = Math.min(srcOffset, copiedLength);
270                     invokeSafe(caller, null, src, srcDelta, dst, dstDelta, copiedLength);
271 
272                     // Perform a sanity check:
273                     for (int j = 0; j &lt; copiedLength; j++) {
274                         int c = dst[j + dstDelta] &amp; 0xFF;
275                         assert (32 &lt;= c &amp;&amp; c &lt;= 126) || (160 &lt;= c &amp;&amp; c &lt;= 255);
276                         assert (c == (src[j + srcDelta] &amp; 0xFF));
</pre>
<hr />
<pre>
282                 }
283             }
284         }
285     }
286 
287     @SuppressWarnings(&quot;all&quot;)
288     public static String testCompress(char[] a) {
289         return new String(a);
290     }
291 
292     @SuppressWarnings(&quot;all&quot;)
293     public static char[] testInflate(String a) {
294         return a.toCharArray();
295     }
296 
297     private class TestMethods {
298 
299         TestMethods(String testmname, Class&lt;?&gt; javaclass, Class&lt;?&gt; intrinsicClass, String javamname, Class&lt;?&gt;... params) {
300             javamethod = getResolvedJavaMethod(javaclass, javamname, params);
301             testmethod = getResolvedJavaMethod(testmname);
<span class="line-modified">302             testgraph = getReplacements().getIntrinsicGraph(javamethod, CompilationIdentifier.INVALID_COMPILATION_ID, getDebugContext());</span>
303             assertInGraph(testgraph, intrinsicClass);
304 
305             assert javamethod != null;
306             assert testmethod != null;
307 
308             // Force the test method to be compiled.
309             testcode = getCode(testmethod);
310 
311             assert testcode != null;
312         }
313 
314         StructuredGraph replacementGraph() {
<span class="line-modified">315             return getReplacements().getSubstitution(javamethod, -1, false, null);</span>
316         }
317 
318         StructuredGraph testMethodGraph() {
319             return testgraph;
320         }
321 
322         void testSubstitution(Class&lt;?&gt; intrinsicclass) {
323             // Check if the resulting graph contains the expected node.
324             if (replacementGraph() == null) {
325                 assertInGraph(testMethodGraph(), intrinsicclass);
326             }
327         }
328 
329         Object invokeJava(Object... args) {
330             return invokeSafe(javamethod, null, args);
331         }
332 
333         Object invokeTest(Object... args) {
334             return invokeSafe(testmethod, null, args);
335         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.test;
 26 
 27 import static org.junit.Assume.assumeFalse;
 28 import static org.junit.Assume.assumeTrue;
 29 
 30 import java.io.UnsupportedEncodingException;
 31 
 32 import org.graalvm.compiler.core.common.CompilationIdentifier;
 33 import org.graalvm.compiler.nodes.StructuredGraph;
 34 import org.graalvm.compiler.replacements.amd64.AMD64StringLatin1InflateNode;
 35 import org.graalvm.compiler.replacements.amd64.AMD64StringLatin1Substitutions;
 36 import org.graalvm.compiler.replacements.amd64.AMD64StringUTF16CompressNode;
 37 import org.graalvm.compiler.replacements.amd64.AMD64StringUTF16Substitutions;
<span class="line-added"> 38 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
 39 import org.graalvm.compiler.test.AddExports;
 40 import org.junit.Before;
 41 import org.junit.Test;
 42 
 43 import jdk.vm.ci.amd64.AMD64;
 44 import jdk.vm.ci.code.InstalledCode;
 45 import jdk.vm.ci.meta.ResolvedJavaMethod;
 46 
 47 /**
 48  * Test intrinsic/node substitutions for (innate) methods StringLatin1.inflate and
 49  * StringUTF16.compress provided by {@link AMD64StringLatin1Substitutions} and
 50  * {@link AMD64StringUTF16Substitutions}.
 51  */
 52 @AddExports({&quot;java.base/java.lang&quot;})
 53 public final class StringCompressInflateTest extends MethodSubstitutionTest {
 54 
 55     static final int N = 1000;
 56 
 57     @Before
 58     public void checkAMD64() {
<span class="line-modified"> 59         assumeFalse(JavaVersionUtil.JAVA_SPEC &lt;= 8);</span>
 60         // Test case is (currently) AMD64 only.
 61         assumeTrue(getTarget().arch instanceof AMD64);
 62     }
 63 
 64     @Test
 65     public void testStringLatin1Inflate() throws ClassNotFoundException, UnsupportedEncodingException {
 66         Class&lt;?&gt; javaclass = Class.forName(&quot;java.lang.StringLatin1&quot;);
 67         Class&lt;?&gt; testclass = AMD64StringLatin1InflateNode.class;
 68 
 69         TestMethods tms = new TestMethods(&quot;testInflate&quot;, javaclass, AMD64StringLatin1InflateNode.class, &quot;inflate&quot;,
 70                         byte[].class, int.class, char[].class, int.class, int.class);
 71 
 72         tms.testSubstitution(testclass);
 73 
 74         for (int i = 0; i &lt; N; i++) {
 75             byte[] src = fillLatinBytes(new byte[i2sz(i)]);
 76             char[] dst = new char[i2sz(i)];
 77 
 78             // Invoke void StringLatin1.inflate(byte[], 0, char[], 0, length)
 79             Object nil = tms.invokeJava(src, 0, dst, 0, i2sz(i));
</pre>
<hr />
<pre>
 98 
 99             // Another sanity check:
100             for (int j = 0; j &lt; i2sz(i); j++) {
101                 assert (inflate1[j] &amp; 0xff00) == 0;
102                 assert (32 &lt;= inflate1[j] &amp;&amp; inflate1[j] &lt;= 126) || (160 &lt;= inflate1[j] &amp;&amp; inflate1[j] &lt;= 255);
103             }
104 
105             assertDeepEquals(dst, inflate1);
106 
107             // Invoke char[] testInflate(String) through code handle.
108             char[] inflate2 = (char[]) tms.invokeCode(str);
109             assertDeepEquals(dst, inflate2);
110         }
111     }
112 
113     @Test
114     public void testStringLatin1InflateByteByte() throws ClassNotFoundException {
115         Class&lt;?&gt; javaclass = Class.forName(&quot;java.lang.StringLatin1&quot;);
116 
117         ResolvedJavaMethod caller = getResolvedJavaMethod(javaclass, &quot;inflate&quot;, byte[].class, int.class, byte[].class, int.class, int.class);
<span class="line-modified">118         StructuredGraph graph = getReplacements().getIntrinsicGraph(caller, CompilationIdentifier.INVALID_COMPILATION_ID, getDebugContext(), null);</span>
119         assertInGraph(graph, AMD64StringLatin1InflateNode.class);
120 
121         InstalledCode code = getCode(caller, graph);
122 
123         for (int dstOffset = 0; dstOffset &lt; 2; dstOffset++) {
124             for (int srcOffset = 0; srcOffset &lt; 2; srcOffset++) {
125                 for (int i = 0; i &lt; N; i++) {
126                     int length = i2sz(i);
127                     byte[] src = fillLatinBytes(new byte[length]);
128                     int resultLength = length * 2;
129                     byte[] dst = new byte[resultLength];
130                     int copiedLength = Math.max(0, length - Math.max(dstOffset, srcOffset));
131                     int dstDelta = Math.min(dstOffset, copiedLength);
132                     int srcDelta = Math.min(srcOffset, copiedLength);
133                     invokeSafe(caller, null, src, srcDelta, dst, dstDelta, copiedLength);
134 
135                     // Perform a sanity check:
136                     for (int j = 0; j &lt; copiedLength; j++) {
137                         assert (dst[j * 2 + 1 + dstDelta * 2]) == 0;
138                         int c = dst[j * 2 + dstDelta * 2] &amp; 0xFF;
139                         assert (32 &lt;= c &amp;&amp; c &lt;= 126) || (160 &lt;= c &amp;&amp; c &lt;= 255);
140                         assert (c == (src[j + srcDelta] &amp; 0xFF));
141                     }
142 
143                     byte[] dst2 = new byte[resultLength];
144                     executeVarargsSafe(code, src, srcDelta, dst2, dstDelta, copiedLength);
145                     assertDeepEquals(dst, dst2);
146                 }
147             }
148         }
149     }
150 
151     @Test
152     public void testStringLatin1InflateByteChar() throws ClassNotFoundException {
153         Class&lt;?&gt; javaclass = Class.forName(&quot;java.lang.StringLatin1&quot;);
154 
155         ResolvedJavaMethod caller = getResolvedJavaMethod(javaclass, &quot;inflate&quot;, byte[].class, int.class, char[].class, int.class, int.class);
<span class="line-modified">156         StructuredGraph graph = getReplacements().getIntrinsicGraph(caller, CompilationIdentifier.INVALID_COMPILATION_ID, getDebugContext(), null);</span>
157         assertInGraph(graph, AMD64StringLatin1InflateNode.class);
158 
159         InstalledCode code = getCode(caller, graph);
160 
161         for (int dstOffset = 0; dstOffset &lt; 2; dstOffset++) {
162             for (int srcOffset = 0; srcOffset &lt; 2; srcOffset++) {
163                 for (int i = 0; i &lt; N; i++) {
164                     int length = i2sz(i);
165                     byte[] src = fillLatinBytes(new byte[length]);
166                     char[] dst = new char[length];
167                     int copiedLength = Math.max(0, length - Math.max(dstOffset, srcOffset));
168                     int dstDelta = Math.min(dstOffset, copiedLength);
169                     int srcDelta = Math.min(srcOffset, copiedLength);
170                     invokeSafe(caller, null, src, srcDelta, dst, dstDelta, copiedLength);
171 
172                     // Perform a sanity check:
173                     for (int j = 0; j &lt; copiedLength; j++) {
174                         int c = dst[j + dstDelta] &amp; 0xFF;
175                         assert (32 &lt;= c &amp;&amp; c &lt;= 126) || (160 &lt;= c &amp;&amp; c &lt;= 255);
176                         assert (c == (src[j + srcDelta] &amp; 0xFF));
</pre>
<hr />
<pre>
201 
202             assert (int) len == i2sz(i);
203 
204             // Invoke String testCompress(char[])
205             String str1 = (String) tms.invokeTest(src);
206 
207             assertDeepEquals(dst, str1.getBytes(&quot;ISO8859_1&quot;));
208 
209             // Invoke String testCompress(char[]) through code handle.
210             String str2 = (String) tms.invokeCode(src);
211 
212             assertDeepEquals(dst, str2.getBytes(&quot;ISO8859_1&quot;));
213         }
214     }
215 
216     @Test
217     public void testStringUTF16CompressByteByte() throws ClassNotFoundException {
218         Class&lt;?&gt; javaclass = Class.forName(&quot;java.lang.StringUTF16&quot;);
219 
220         ResolvedJavaMethod caller = getResolvedJavaMethod(javaclass, &quot;compress&quot;, byte[].class, int.class, byte[].class, int.class, int.class);
<span class="line-modified">221         StructuredGraph graph = getReplacements().getIntrinsicGraph(caller, CompilationIdentifier.INVALID_COMPILATION_ID, getDebugContext(), null);</span>
222         assertInGraph(graph, AMD64StringUTF16CompressNode.class);
223 
224         InstalledCode code = getCode(caller, graph);
225 
226         for (int dstOffset = 0; dstOffset &lt; 2; dstOffset++) {
227             for (int srcOffset = 0; srcOffset &lt; 2; srcOffset++) {
228                 for (int i = 0; i &lt; N; i++) {
229                     int length = i2sz(i);
230                     byte[] src = fillLatinChars(new byte[length * 2]);
231                     byte[] dst = new byte[length];
232                     int copiedLength = Math.max(0, length - Math.max(dstOffset, srcOffset));
233                     int dstDelta = Math.min(dstOffset, copiedLength);
234                     int srcDelta = Math.min(srcOffset, copiedLength);
235                     invokeSafe(caller, null, src, srcDelta, dst, dstDelta, copiedLength);
236 
237                     // Perform a sanity check:
238                     for (int j = 0; j &lt; copiedLength; j++) {
239                         int c = dst[j + dstDelta] &amp; 0xFF;
240                         assert (32 &lt;= c &amp;&amp; c &lt;= 126) || (160 &lt;= c &amp;&amp; c &lt;= 255);
241                         assert (c == (src[(j + srcDelta) * 2] &amp; 0xFF));
242                     }
243 
244                     byte[] dst2 = new byte[length];
245                     executeVarargsSafe(code, src, srcDelta, dst2, dstDelta, copiedLength);
246                     assertDeepEquals(dst, dst2);
247                 }
248             }
249         }
250     }
251 
252     @Test
253     public void testStringUTF16CompressCharByte() throws ClassNotFoundException {
254         Class&lt;?&gt; javaclass = Class.forName(&quot;java.lang.StringUTF16&quot;);
255 
256         ResolvedJavaMethod caller = getResolvedJavaMethod(javaclass, &quot;compress&quot;, char[].class, int.class, byte[].class, int.class, int.class);
<span class="line-modified">257         StructuredGraph graph = getReplacements().getIntrinsicGraph(caller, CompilationIdentifier.INVALID_COMPILATION_ID, getDebugContext(), null);</span>
258         assertInGraph(graph, AMD64StringUTF16CompressNode.class);
259 
260         InstalledCode code = getCode(caller, graph);
261 
262         for (int dstOffset = 0; dstOffset &lt; 2; dstOffset++) {
263             for (int srcOffset = 0; srcOffset &lt; 2; srcOffset++) {
264                 for (int i = 0; i &lt; N; i++) {
265                     int length = i2sz(i);
266                     char[] src = fillLatinChars(new char[length]);
267                     byte[] dst = new byte[length];
268                     int copiedLength = Math.max(0, length - Math.max(dstOffset, srcOffset));
269                     int dstDelta = Math.min(dstOffset, copiedLength);
270                     int srcDelta = Math.min(srcOffset, copiedLength);
271                     invokeSafe(caller, null, src, srcDelta, dst, dstDelta, copiedLength);
272 
273                     // Perform a sanity check:
274                     for (int j = 0; j &lt; copiedLength; j++) {
275                         int c = dst[j + dstDelta] &amp; 0xFF;
276                         assert (32 &lt;= c &amp;&amp; c &lt;= 126) || (160 &lt;= c &amp;&amp; c &lt;= 255);
277                         assert (c == (src[j + srcDelta] &amp; 0xFF));
</pre>
<hr />
<pre>
283                 }
284             }
285         }
286     }
287 
288     @SuppressWarnings(&quot;all&quot;)
289     public static String testCompress(char[] a) {
290         return new String(a);
291     }
292 
293     @SuppressWarnings(&quot;all&quot;)
294     public static char[] testInflate(String a) {
295         return a.toCharArray();
296     }
297 
298     private class TestMethods {
299 
300         TestMethods(String testmname, Class&lt;?&gt; javaclass, Class&lt;?&gt; intrinsicClass, String javamname, Class&lt;?&gt;... params) {
301             javamethod = getResolvedJavaMethod(javaclass, javamname, params);
302             testmethod = getResolvedJavaMethod(testmname);
<span class="line-modified">303             testgraph = getReplacements().getIntrinsicGraph(javamethod, CompilationIdentifier.INVALID_COMPILATION_ID, getDebugContext(), null);</span>
304             assertInGraph(testgraph, intrinsicClass);
305 
306             assert javamethod != null;
307             assert testmethod != null;
308 
309             // Force the test method to be compiled.
310             testcode = getCode(testmethod);
311 
312             assert testcode != null;
313         }
314 
315         StructuredGraph replacementGraph() {
<span class="line-modified">316             return getReplacements().getSubstitution(javamethod, -1, false, null, getInitialOptions());</span>
317         }
318 
319         StructuredGraph testMethodGraph() {
320             return testgraph;
321         }
322 
323         void testSubstitution(Class&lt;?&gt; intrinsicclass) {
324             // Check if the resulting graph contains the expected node.
325             if (replacementGraph() == null) {
326                 assertInGraph(testMethodGraph(), intrinsicclass);
327             }
328         }
329 
330         Object invokeJava(Object... args) {
331             return invokeSafe(javamethod, null, args);
332         }
333 
334         Object invokeTest(Object... args) {
335             return invokeSafe(testmethod, null, args);
336         }
</pre>
</td>
</tr>
</table>
<center><a href="StringCompareToTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StringIndexOfCharTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.serviceprovider/src/org/graalvm/compiler/serviceprovider/GraalServices.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.serviceprovider;
 26 
 27 import static java.lang.Thread.currentThread;
 28 
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.util.Arrays;
<a name="2" id="anc2"></a><span class="line-added"> 32 import java.util.ArrayList;</span>
<span class="line-added"> 33 import java.util.HashMap;</span>
 34 import java.util.Iterator;
 35 import java.util.List;
<a name="3" id="anc3"></a><span class="line-added"> 36 import java.util.Map;</span>
 37 import java.util.ServiceConfigurationError;
 38 import java.util.ServiceLoader;
 39 import java.util.concurrent.atomic.AtomicLong;
<a name="4" id="anc4"></a><span class="line-added"> 40 import java.util.function.Supplier;</span>
 41 
<a name="5" id="anc5"></a><span class="line-added"> 42 import org.graalvm.compiler.serviceprovider.SpeculationReasonGroup.SpeculationContextObject;</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44 import jdk.vm.ci.code.BytecodePosition;</span>
<span class="line-added"> 45 import jdk.vm.ci.code.VirtualObject;</span>
<span class="line-added"> 46 import jdk.vm.ci.meta.ResolvedJavaField;</span>
<span class="line-added"> 47 import jdk.vm.ci.meta.ResolvedJavaMethod;</span>
<span class="line-added"> 48 import jdk.vm.ci.meta.ResolvedJavaType;</span>
 49 import jdk.vm.ci.meta.SpeculationLog.SpeculationReason;
<a name="6" id="anc6"></a><span class="line-added"> 50 import jdk.vm.ci.meta.SpeculationLog.SpeculationReasonEncoding;</span>
 51 import jdk.vm.ci.runtime.JVMCI;
 52 import jdk.vm.ci.services.JVMCIPermission;
 53 import jdk.vm.ci.services.Services;
 54 
<a name="7" id="anc7"></a><span class="line-added"> 55 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;</span>
<span class="line-added"> 56 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;</span>
<span class="line-added"> 57 </span>
 58 /**
<a name="8" id="anc8"></a><span class="line-modified"> 59  * JDK 13+ version of {@link GraalServices}.</span>
 60  */
 61 public final class GraalServices {
 62 
<a name="9" id="anc9"></a><span class="line-added"> 63     private static final Map&lt;Class&lt;?&gt;, List&lt;?&gt;&gt; servicesCache = IS_BUILDING_NATIVE_IMAGE ? new HashMap&lt;&gt;() : null;</span>
<span class="line-added"> 64 </span>
 65     private GraalServices() {
 66     }
 67 
 68     /**
 69      * Gets an {@link Iterable} of the providers available for a given service.
 70      *
 71      * @throws SecurityException if on JDK8 and a security manager is present and it denies
 72      *             {@link JVMCIPermission}
 73      */
<a name="10" id="anc10"></a><span class="line-added"> 74     @SuppressWarnings(&quot;unchecked&quot;)</span>
 75     public static &lt;S&gt; Iterable&lt;S&gt; load(Class&lt;S&gt; service) {
<a name="11" id="anc11"></a><span class="line-modified"> 76         if (IS_IN_NATIVE_IMAGE || IS_BUILDING_NATIVE_IMAGE) {</span>
<span class="line-added"> 77             List&lt;?&gt; list = servicesCache.get(service);</span>
<span class="line-added"> 78             if (list != null) {</span>
<span class="line-added"> 79                 return (Iterable&lt;S&gt;) list;</span>
<span class="line-added"> 80             }</span>
<span class="line-added"> 81             if (IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added"> 82                 throw new InternalError(String.format(&quot;No %s providers found when building native image&quot;, service.getName()));</span>
<span class="line-added"> 83             }</span>
<span class="line-added"> 84         }</span>
<span class="line-added"> 85 </span>
<span class="line-added"> 86         Iterable&lt;S&gt; providers = load0(service);</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88         if (IS_BUILDING_NATIVE_IMAGE) {</span>
<span class="line-added"> 89             synchronized (servicesCache) {</span>
<span class="line-added"> 90                 ArrayList&lt;S&gt; providersList = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 91                 for (S provider : providers) {</span>
<span class="line-added"> 92                     Module module = provider.getClass().getModule();</span>
<span class="line-added"> 93                     if (isHotSpotGraalModule(module.getName())) {</span>
<span class="line-added"> 94                         providersList.add(provider);</span>
<span class="line-added"> 95                     }</span>
<span class="line-added"> 96                 }</span>
<span class="line-added"> 97                 providers = providersList;</span>
<span class="line-added"> 98                 servicesCache.put(service, providersList);</span>
<span class="line-added"> 99                 return providers;</span>
<span class="line-added">100             }</span>
<span class="line-added">101         }</span>
<span class="line-added">102 </span>
<span class="line-added">103         return providers;</span>
<span class="line-added">104     }</span>
<span class="line-added">105 </span>
<span class="line-added">106     /**</span>
<span class="line-added">107      * Determines if the module named by {@code name} is part of Graal when it is configured as a</span>
<span class="line-added">108      * HotSpot JIT compiler.</span>
<span class="line-added">109      */</span>
<span class="line-added">110     private static boolean isHotSpotGraalModule(String name) {</span>
<span class="line-added">111         if (name != null) {</span>
<span class="line-added">112             return name.equals(&quot;jdk.internal.vm.compiler&quot;) ||</span>
<span class="line-added">113                             name.equals(&quot;jdk.internal.vm.compiler.management&quot;) ||</span>
<span class="line-added">114                             name.equals(&quot;com.oracle.graal.graal_enterprise&quot;);</span>
<span class="line-added">115         }</span>
<span class="line-added">116         return false;</span>
<span class="line-added">117     }</span>
<span class="line-added">118 </span>
<span class="line-added">119     protected static &lt;S&gt; Iterable&lt;S&gt; load0(Class&lt;S&gt; service) {</span>
<span class="line-added">120         Module module = GraalServices.class.getModule();</span>
<span class="line-added">121         // Graal cannot know all the services used by another module</span>
<span class="line-added">122         // (e.g. enterprise) so dynamically register the service use now.</span>
<span class="line-added">123         if (!module.canUse(service)) {</span>
<span class="line-added">124             module.addUses(service);</span>
<span class="line-added">125         }</span>
<span class="line-added">126 </span>
<span class="line-added">127         ModuleLayer layer = module.getLayer();</span>
<span class="line-added">128         Iterable&lt;S&gt; iterable = ServiceLoader.load(layer, service);</span>
129         return new Iterable&lt;&gt;() {
130             @Override
131             public Iterator&lt;S&gt; iterator() {
132                 Iterator&lt;S&gt; iterator = iterable.iterator();
133                 return new Iterator&lt;&gt;() {
134                     @Override
135                     public boolean hasNext() {
136                         return iterator.hasNext();
137                     }
138 
139                     @Override
140                     public S next() {
141                         S provider = iterator.next();
142                         // Allow Graal extensions to access JVMCI
143                         openJVMCITo(provider.getClass());
144                         return provider;
145                     }
146 
147                     @Override
148                     public void remove() {
149                         iterator.remove();
150                     }
151                 };
152             }
153         };
154     }
155 
156     /**
157      * Opens all JVMCI packages to the module of a given class. This relies on JVMCI already having
158      * opened all its packages to the module defining {@link GraalServices}.
159      *
160      * @param other all JVMCI packages will be opened to the module defining this class
161      */
162     static void openJVMCITo(Class&lt;?&gt; other) {
<a name="12" id="anc12"></a><span class="line-added">163         if (IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added">164             return;</span>
<span class="line-added">165         }</span>
<span class="line-added">166 </span>
167         Module jvmciModule = JVMCI_MODULE;
168         Module otherModule = other.getModule();
169         if (jvmciModule != otherModule) {
170             for (String pkg : jvmciModule.getPackages()) {
171                 if (!jvmciModule.isOpen(pkg, otherModule)) {
172                     // JVMCI initialization opens all JVMCI packages
173                     // to Graal which is a prerequisite for Graal to
174                     // open JVMCI packages to other modules.
<a name="13" id="anc13"></a><span class="line-modified">175                     JVMCI.getRuntime();</span>
176 
177                     jvmciModule.addOpens(pkg, otherModule);
178                 }
179             }
180         }
181     }
182 
183     /**
184      * Gets the provider for a given service for which at most one provider must be available.
185      *
186      * @param service the service whose provider is being requested
187      * @param required specifies if an {@link InternalError} should be thrown if no provider of
188      *            {@code service} is available
189      * @return the requested provider if available else {@code null}
190      * @throws SecurityException if on JDK8 and a security manager is present and it denies
191      *             {@link JVMCIPermission}
192      */
193     public static &lt;S&gt; S loadSingle(Class&lt;S&gt; service, boolean required) {
194         assert !service.getName().startsWith(&quot;jdk.vm.ci&quot;) : &quot;JVMCI services must be loaded via &quot; + Services.class.getName();
195         Iterable&lt;S&gt; providers = load(service);
196         S singleProvider = null;
197         try {
198             for (Iterator&lt;S&gt; it = providers.iterator(); it.hasNext();) {
199                 singleProvider = it.next();
200                 if (it.hasNext()) {
201                     S other = it.next();
202                     throw new InternalError(String.format(&quot;Multiple %s providers found: %s, %s&quot;, service.getName(), singleProvider.getClass().getName(), other.getClass().getName()));
203                 }
204             }
205         } catch (ServiceConfigurationError e) {
206             // If the service is required we will bail out below.
207         }
208         if (singleProvider == null) {
209             if (required) {
210                 throw new InternalError(String.format(&quot;No provider for %s found&quot;, service.getName()));
211             }
212         }
213         return singleProvider;
214     }
215 
216     /**
217      * Gets the class file bytes for {@code c}.
218      */
219     public static InputStream getClassfileAsStream(Class&lt;?&gt; c) throws IOException {
220         String classfilePath = c.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;;
221         return c.getModule().getResourceAsStream(classfilePath);
222     }
223 
224     private static final Module JVMCI_MODULE = Services.class.getModule();
225 
226     /**
227      * A JVMCI package dynamically exported to trusted modules.
228      */
229     private static final String JVMCI_RUNTIME_PACKAGE = &quot;jdk.vm.ci.runtime&quot;;
230     static {
231         assert JVMCI_MODULE.getPackages().contains(JVMCI_RUNTIME_PACKAGE);
232     }
233 
234     /**
235      * Determines if invoking {@link Object#toString()} on an instance of {@code c} will only run
236      * trusted code.
237      */
238     public static boolean isToStringTrusted(Class&lt;?&gt; c) {
<a name="14" id="anc14"></a><span class="line-added">239         if (IS_IN_NATIVE_IMAGE) {</span>
<span class="line-added">240             return true;</span>
<span class="line-added">241         }</span>
<span class="line-added">242 </span>
243         Module module = c.getModule();
244         Module jvmciModule = JVMCI_MODULE;
245         assert jvmciModule.getPackages().contains(&quot;jdk.vm.ci.runtime&quot;);
246         if (module == jvmciModule || jvmciModule.isOpen(JVMCI_RUNTIME_PACKAGE, module)) {
247             // Can access non-statically-exported package in JVMCI
248             return true;
249         }
250         return false;
251     }
252 
253     /**
254      * An implementation of {@link SpeculationReason} based on direct, unencoded values.
255      */
256     static final class DirectSpeculationReason implements SpeculationReason {
257         final int groupId;
258         final String groupName;
259         final Object[] context;
<a name="15" id="anc15"></a><span class="line-added">260         private SpeculationReasonEncoding encoding;</span>
261 
262         DirectSpeculationReason(int groupId, String groupName, Object[] context) {
263             this.groupId = groupId;
264             this.groupName = groupName;
265             this.context = context;
266         }
267 
268         @Override
269         public boolean equals(Object obj) {
270             if (obj instanceof DirectSpeculationReason) {
271                 DirectSpeculationReason that = (DirectSpeculationReason) obj;
272                 return this.groupId == that.groupId &amp;&amp; Arrays.equals(this.context, that.context);
273             }
274             return false;
275         }
276 
277         @Override
278         public int hashCode() {
279             return groupId + Arrays.hashCode(this.context);
280         }
281 
282         @Override
283         public String toString() {
284             return String.format(&quot;%s@%d%s&quot;, groupName, groupId, Arrays.toString(context));
285         }
<a name="16" id="anc16"></a><span class="line-added">286 </span>
<span class="line-added">287         @Override</span>
<span class="line-added">288         public SpeculationReasonEncoding encode(Supplier&lt;SpeculationReasonEncoding&gt; encodingSupplier) {</span>
<span class="line-added">289             if (encoding == null) {</span>
<span class="line-added">290                 encoding = encodingSupplier.get();</span>
<span class="line-added">291                 encoding.addInt(groupId);</span>
<span class="line-added">292                 for (Object o : context) {</span>
<span class="line-added">293                     if (o == null) {</span>
<span class="line-added">294                         encoding.addInt(0);</span>
<span class="line-added">295                     } else {</span>
<span class="line-added">296                         addNonNullObject(encoding, o);</span>
<span class="line-added">297                     }</span>
<span class="line-added">298                 }</span>
<span class="line-added">299             }</span>
<span class="line-added">300             return encoding;</span>
<span class="line-added">301         }</span>
<span class="line-added">302 </span>
<span class="line-added">303         static void addNonNullObject(SpeculationReasonEncoding encoding, Object o) {</span>
<span class="line-added">304             Class&lt;? extends Object&gt; c = o.getClass();</span>
<span class="line-added">305             if (c == String.class) {</span>
<span class="line-added">306                 encoding.addString((String) o);</span>
<span class="line-added">307             } else if (c == Byte.class) {</span>
<span class="line-added">308                 encoding.addByte((Byte) o);</span>
<span class="line-added">309             } else if (c == Short.class) {</span>
<span class="line-added">310                 encoding.addShort((Short) o);</span>
<span class="line-added">311             } else if (c == Character.class) {</span>
<span class="line-added">312                 encoding.addShort((Character) o);</span>
<span class="line-added">313             } else if (c == Integer.class) {</span>
<span class="line-added">314                 encoding.addInt((Integer) o);</span>
<span class="line-added">315             } else if (c == Long.class) {</span>
<span class="line-added">316                 encoding.addLong((Long) o);</span>
<span class="line-added">317             } else if (c == Float.class) {</span>
<span class="line-added">318                 encoding.addInt(Float.floatToRawIntBits((Float) o));</span>
<span class="line-added">319             } else if (c == Double.class) {</span>
<span class="line-added">320                 encoding.addLong(Double.doubleToRawLongBits((Double) o));</span>
<span class="line-added">321             } else if (o instanceof Enum) {</span>
<span class="line-added">322                 encoding.addInt(((Enum&lt;?&gt;) o).ordinal());</span>
<span class="line-added">323             } else if (o instanceof ResolvedJavaMethod) {</span>
<span class="line-added">324                 encoding.addMethod((ResolvedJavaMethod) o);</span>
<span class="line-added">325             } else if (o instanceof ResolvedJavaType) {</span>
<span class="line-added">326                 encoding.addType((ResolvedJavaType) o);</span>
<span class="line-added">327             } else if (o instanceof ResolvedJavaField) {</span>
<span class="line-added">328                 encoding.addField((ResolvedJavaField) o);</span>
<span class="line-added">329             } else if (o instanceof SpeculationContextObject) {</span>
<span class="line-added">330                 SpeculationContextObject sco = (SpeculationContextObject) o;</span>
<span class="line-added">331                 // These are compiler objects which all have the same class</span>
<span class="line-added">332                 // loader so the class name uniquely identifies the class.</span>
<span class="line-added">333                 encoding.addString(o.getClass().getName());</span>
<span class="line-added">334                 sco.accept(new EncodingAdapter(encoding));</span>
<span class="line-added">335             } else if (o.getClass() == BytecodePosition.class) {</span>
<span class="line-added">336                 BytecodePosition p = (BytecodePosition) o;</span>
<span class="line-added">337                 while (p != null) {</span>
<span class="line-added">338                     encoding.addInt(p.getBCI());</span>
<span class="line-added">339                     encoding.addMethod(p.getMethod());</span>
<span class="line-added">340                     p = p.getCaller();</span>
<span class="line-added">341                 }</span>
<span class="line-added">342             } else {</span>
<span class="line-added">343                 throw new IllegalArgumentException(&quot;Unsupported type for encoding: &quot; + c.getName());</span>
<span class="line-added">344             }</span>
<span class="line-added">345         }</span>
<span class="line-added">346     }</span>
<span class="line-added">347 </span>
<span class="line-added">348     static class EncodingAdapter implements SpeculationContextObject.Visitor {</span>
<span class="line-added">349         private final SpeculationReasonEncoding encoding;</span>
<span class="line-added">350 </span>
<span class="line-added">351         EncodingAdapter(SpeculationReasonEncoding encoding) {</span>
<span class="line-added">352             this.encoding = encoding;</span>
<span class="line-added">353         }</span>
<span class="line-added">354 </span>
<span class="line-added">355         @Override</span>
<span class="line-added">356         public void visitBoolean(boolean v) {</span>
<span class="line-added">357             encoding.addByte(v ? 1 : 0);</span>
<span class="line-added">358         }</span>
<span class="line-added">359 </span>
<span class="line-added">360         @Override</span>
<span class="line-added">361         public void visitByte(byte v) {</span>
<span class="line-added">362             encoding.addByte(v);</span>
<span class="line-added">363         }</span>
<span class="line-added">364 </span>
<span class="line-added">365         @Override</span>
<span class="line-added">366         public void visitChar(char v) {</span>
<span class="line-added">367             encoding.addShort(v);</span>
<span class="line-added">368         }</span>
<span class="line-added">369 </span>
<span class="line-added">370         @Override</span>
<span class="line-added">371         public void visitShort(short v) {</span>
<span class="line-added">372             encoding.addInt(v);</span>
<span class="line-added">373         }</span>
<span class="line-added">374 </span>
<span class="line-added">375         @Override</span>
<span class="line-added">376         public void visitInt(int v) {</span>
<span class="line-added">377             encoding.addInt(v);</span>
<span class="line-added">378         }</span>
<span class="line-added">379 </span>
<span class="line-added">380         @Override</span>
<span class="line-added">381         public void visitLong(long v) {</span>
<span class="line-added">382             encoding.addLong(v);</span>
<span class="line-added">383         }</span>
<span class="line-added">384 </span>
<span class="line-added">385         @Override</span>
<span class="line-added">386         public void visitFloat(float v) {</span>
<span class="line-added">387             encoding.addInt(Float.floatToRawIntBits(v));</span>
<span class="line-added">388         }</span>
<span class="line-added">389 </span>
<span class="line-added">390         @Override</span>
<span class="line-added">391         public void visitDouble(double v) {</span>
<span class="line-added">392             encoding.addLong(Double.doubleToRawLongBits(v));</span>
<span class="line-added">393         }</span>
<span class="line-added">394 </span>
<span class="line-added">395         @Override</span>
<span class="line-added">396         public void visitObject(Object v) {</span>
<span class="line-added">397             if (v == null) {</span>
<span class="line-added">398                 encoding.addInt(0);</span>
<span class="line-added">399             } else {</span>
<span class="line-added">400                 DirectSpeculationReason.addNonNullObject(encoding, v);</span>
<span class="line-added">401             }</span>
<span class="line-added">402         }</span>
403     }
404 
405     static SpeculationReason createSpeculationReason(int groupId, String groupName, Object... context) {
406         return new DirectSpeculationReason(groupId, groupName, context);
407     }
408 
409     /**
410      * Gets a unique identifier for this execution such as a process ID or a
411      * {@linkplain #getGlobalTimeStamp() fixed timestamp}.
412      */
413     public static String getExecutionID() {
414         return Long.toString(ProcessHandle.current().pid());
415     }
416 
417     private static final AtomicLong globalTimeStamp = new AtomicLong();
418 
419     /**
420      * Gets a time stamp for the current process. This method will always return the same value for
421      * the current VM execution.
422      */
423     public static long getGlobalTimeStamp() {
424         if (globalTimeStamp.get() == 0) {
425             globalTimeStamp.compareAndSet(0, System.currentTimeMillis());
426         }
427         return globalTimeStamp.get();
428     }
429 
430     /**
431      * Returns an approximation of the total amount of memory, in bytes, allocated in heap memory
432      * for the thread of the specified ID. The returned value is an approximation because some Java
433      * virtual machine implementations may use object allocation mechanisms that result in a delay
434      * between the time an object is allocated and the time its size is recorded.
435      * &lt;p&gt;
436      * If the thread of the specified ID is not alive or does not exist, this method returns
437      * {@code -1}. If thread memory allocation measurement is disabled, this method returns
438      * {@code -1}. A thread is alive if it has been started and has not yet died.
439      * &lt;p&gt;
440      * If thread memory allocation measurement is enabled after the thread has started, the Java
441      * virtual machine implementation may choose any time up to and including the time that the
442      * capability is enabled as the point where thread memory allocation measurement starts.
443      *
444      * @param id the thread ID of a thread
445      * @return an approximation of the total memory allocated, in bytes, in heap memory for a thread
446      *         of the specified ID if the thread of the specified ID exists, the thread is alive,
447      *         and thread memory allocation measurement is enabled; {@code -1} otherwise.
448      *
449      * @throws IllegalArgumentException if {@code id} {@code &lt;=} {@code 0}.
450      * @throws UnsupportedOperationException if the Java virtual machine implementation does not
451      *             {@linkplain #isThreadAllocatedMemorySupported() support} thread memory allocation
452      *             measurement.
453      */
454     public static long getThreadAllocatedBytes(long id) {
455         JMXService jmx = JMXService.instance;
456         if (jmx == null) {
457             throw new UnsupportedOperationException();
458         }
459         return jmx.getThreadAllocatedBytes(id);
460     }
461 
462     /**
463      * Convenience method for calling {@link #getThreadAllocatedBytes(long)} with the id of the
464      * current thread.
465      */
466     public static long getCurrentThreadAllocatedBytes() {
467         return getThreadAllocatedBytes(currentThread().getId());
468     }
469 
470     /**
471      * Returns the total CPU time for the current thread in nanoseconds. The returned value is of
472      * nanoseconds precision but not necessarily nanoseconds accuracy. If the implementation
473      * distinguishes between user mode time and system mode time, the returned CPU time is the
474      * amount of time that the current thread has executed in user mode or system mode.
475      *
476      * @return the total CPU time for the current thread if CPU time measurement is enabled;
477      *         {@code -1} otherwise.
478      *
479      * @throws UnsupportedOperationException if the Java virtual machine does not
480      *             {@linkplain #isCurrentThreadCpuTimeSupported() support} CPU time measurement for
481      *             the current thread
482      */
483     public static long getCurrentThreadCpuTime() {
484         JMXService jmx = JMXService.instance;
485         if (jmx == null) {
486             throw new UnsupportedOperationException();
487         }
488         return jmx.getCurrentThreadCpuTime();
489     }
490 
491     /**
492      * Determines if the Java virtual machine implementation supports thread memory allocation
493      * measurement.
494      */
495     public static boolean isThreadAllocatedMemorySupported() {
496         JMXService jmx = JMXService.instance;
497         if (jmx == null) {
498             return false;
499         }
500         return jmx.isThreadAllocatedMemorySupported();
501     }
502 
503     /**
504      * Determines if the Java virtual machine supports CPU time measurement for the current thread.
505      */
506     public static boolean isCurrentThreadCpuTimeSupported() {
507         JMXService jmx = JMXService.instance;
508         if (jmx == null) {
509             return false;
510         }
511         return jmx.isCurrentThreadCpuTimeSupported();
512     }
513 
514     /**
515      * Gets the input arguments passed to the Java virtual machine which does not include the
516      * arguments to the {@code main} method. This method returns an empty list if there is no input
517      * argument to the Java virtual machine.
518      * &lt;p&gt;
519      * Some Java virtual machine implementations may take input arguments from multiple different
520      * sources: for examples, arguments passed from the application that launches the Java virtual
521      * machine such as the &#39;java&#39; command, environment variables, configuration files, etc.
522      * &lt;p&gt;
523      * Typically, not all command-line options to the &#39;java&#39; command are passed to the Java virtual
524      * machine. Thus, the returned input arguments may not include all command-line options.
525      *
526      * @return the input arguments to the JVM or {@code null} if they are unavailable
527      */
528     public static List&lt;String&gt; getInputArguments() {
529         JMXService jmx = JMXService.instance;
530         if (jmx == null) {
531             return null;
532         }
533         return jmx.getInputArguments();
534     }
<a name="17" id="anc17"></a><span class="line-added">535 </span>
<span class="line-added">536     /**</span>
<span class="line-added">537      * Returns the fused multiply add of the three arguments; that is, returns the exact product of</span>
<span class="line-added">538      * the first two arguments summed with the third argument and then rounded once to the nearest</span>
<span class="line-added">539      * {@code float}.</span>
<span class="line-added">540      */</span>
<span class="line-added">541     public static float fma(float a, float b, float c) {</span>
<span class="line-added">542         return Math.fma(a, b, c);</span>
<span class="line-added">543     }</span>
<span class="line-added">544 </span>
<span class="line-added">545     /**</span>
<span class="line-added">546      * Returns the fused multiply add of the three arguments; that is, returns the exact product of</span>
<span class="line-added">547      * the first two arguments summed with the third argument and then rounded once to the nearest</span>
<span class="line-added">548      * {@code double}.</span>
<span class="line-added">549      */</span>
<span class="line-added">550     public static double fma(double a, double b, double c) {</span>
<span class="line-added">551         return Math.fma(a, b, c);</span>
<span class="line-added">552     }</span>
<span class="line-added">553 </span>
<span class="line-added">554     public static VirtualObject createVirtualObject(ResolvedJavaType type, int id, boolean isAutoBox) {</span>
<span class="line-added">555         return VirtualObject.get(type, id, isAutoBox);</span>
<span class="line-added">556     }</span>
557 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
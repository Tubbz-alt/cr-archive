<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.aarch64/src/org/graalvm/compiler/replacements/aarch64/AArch64GraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.printer/src/org/graalvm/compiler/printer/GraphPrinterDumpHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64IntegerArithmeticSnippets.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.aarch64/src/org/graalvm/compiler/replacements/aarch64/AArch64GraphBuilderPlugins.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.aarch64;
 26 
 27 import static org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.registerPlatformSpecificUnsafePlugins;
 28 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.COS;
 29 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.EXP;
 30 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG;
 31 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG10;
 32 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.SIN;
 33 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.TAN;
<span class="line-removed"> 34 import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.JAVA_SPECIFICATION_VERSION;</span>
<span class="line-removed"> 35 import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java11OrEarlier;</span>
<span class="line-removed"> 36 import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java8OrEarlier;</span>
 37 
<span class="line-removed"> 38 import org.graalvm.compiler.bytecode.BytecodeProvider;</span>
 39 import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticLIRGeneratorTool.RoundingMode;
 40 import org.graalvm.compiler.nodes.ValueNode;
 41 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 42 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 43 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 44 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 45 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 46 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 47 import org.graalvm.compiler.nodes.java.AtomicReadAndAddNode;
 48 import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
 49 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 50 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;


 51 import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode;

 52 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode;
 53 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation;

 54 import jdk.internal.vm.compiler.word.LocationIdentity;
 55 

 56 import jdk.vm.ci.meta.JavaKind;
 57 import jdk.vm.ci.meta.ResolvedJavaMethod;
 58 import sun.misc.Unsafe;
 59 
<span class="line-modified"> 60 public class AArch64GraphBuilderPlugins {</span>





 61 
<span class="line-modified"> 62     public static void register(Plugins plugins, BytecodeProvider bytecodeProvider, boolean explicitUnsafeNullChecks) {</span>

 63         InvocationPlugins invocationPlugins = plugins.getInvocationPlugins();
 64         invocationPlugins.defer(new Runnable() {
 65             @Override
 66             public void run() {
<span class="line-modified"> 67                 registerIntegerLongPlugins(invocationPlugins, AArch64IntegerSubstitutions.class, JavaKind.Int, bytecodeProvider);</span>
<span class="line-modified"> 68                 registerIntegerLongPlugins(invocationPlugins, AArch64LongSubstitutions.class, JavaKind.Long, bytecodeProvider);</span>
<span class="line-modified"> 69                 registerMathPlugins(invocationPlugins);</span>
<span class="line-modified"> 70                 registerStringLatin1Plugins(invocationPlugins, bytecodeProvider);</span>
<span class="line-modified"> 71                 registerStringUTF16Plugins(invocationPlugins, bytecodeProvider);</span>
<span class="line-modified"> 72                 registerUnsafePlugins(invocationPlugins, bytecodeProvider);</span>




 73                 // This is temporarily disabled until we implement correct emitting of the CAS
 74                 // instructions of the proper width.
<span class="line-modified"> 75                 registerPlatformSpecificUnsafePlugins(invocationPlugins, bytecodeProvider, explicitUnsafeNullChecks,</span>
 76                                 new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object});
 77             }
 78         });
 79     }
 80 
<span class="line-modified"> 81     private static void registerIntegerLongPlugins(InvocationPlugins plugins, Class&lt;?&gt; substituteDeclaringClass, JavaKind kind, BytecodeProvider bytecodeProvider) {</span>
 82         Class&lt;?&gt; declaringClass = kind.toBoxedJavaClass();
 83         Class&lt;?&gt; type = kind.toJavaClass();
<span class="line-modified"> 84         Registration r = new Registration(plugins, declaringClass, bytecodeProvider);</span>
 85         r.register1(&quot;numberOfLeadingZeros&quot;, type, new InvocationPlugin() {
 86             @Override
 87             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 88                 ValueNode folded = AArch64CountLeadingZerosNode.tryFold(value);
 89                 if (folded != null) {
 90                     b.addPush(JavaKind.Int, folded);
 91                 } else {
 92                     b.addPush(JavaKind.Int, new AArch64CountLeadingZerosNode(value));
 93                 }
 94                 return true;
 95             }
 96         });
 97         r.register1(&quot;numberOfTrailingZeros&quot;, type, new InvocationPlugin() {
 98             @Override
 99             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
100                 ValueNode folded = AArch64CountTrailingZerosNode.tryFold(value);
101                 if (folded != null) {
102                     b.addPush(JavaKind.Int, folded);
103                 } else {
104                     b.addPush(JavaKind.Int, new AArch64CountTrailingZerosNode(value));
105                 }
106                 return true;
107             }
108         });
<span class="line-modified">109         r.registerMethodSubstitution(substituteDeclaringClass, &quot;bitCount&quot;, type);</span>






110     }
111 
<span class="line-modified">112     private static void registerMathPlugins(InvocationPlugins plugins) {</span>
113         Registration r = new Registration(plugins, Math.class);
114         registerUnaryMath(r, &quot;sin&quot;, SIN);
115         registerUnaryMath(r, &quot;cos&quot;, COS);
116         registerUnaryMath(r, &quot;tan&quot;, TAN);
117         registerUnaryMath(r, &quot;exp&quot;, EXP);
118         registerUnaryMath(r, &quot;log&quot;, LOG);
119         registerUnaryMath(r, &quot;log10&quot;, LOG10);
120         r.register2(&quot;pow&quot;, Double.TYPE, Double.TYPE, new InvocationPlugin() {
121             @Override
122             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
123                 b.push(JavaKind.Double, b.append(BinaryMathIntrinsicNode.create(x, y, BinaryMathIntrinsicNode.BinaryOperation.POW)));
124                 return true;
125             }
126         });
127         registerRound(r, &quot;rint&quot;, RoundingMode.NEAREST);
128         registerRound(r, &quot;ceil&quot;, RoundingMode.UP);
129         registerRound(r, &quot;floor&quot;, RoundingMode.DOWN);






























130     }
131 
132     private static void registerUnaryMath(Registration r, String name, UnaryOperation operation) {
133         r.register1(name, Double.TYPE, new InvocationPlugin() {
134             @Override
135             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
136                 b.push(JavaKind.Double, b.append(UnaryMathIntrinsicNode.create(value, operation)));
137                 return true;
138             }
139         });
140     }
141 
142     private static void registerRound(Registration r, String name, RoundingMode mode) {
143         r.register1(name, Double.TYPE, new InvocationPlugin() {
144             @Override
145             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg) {
146                 b.push(JavaKind.Double, b.append(new AArch64RoundNode(arg, mode)));
147                 return true;
148             }
149         });
150     }
151 
<span class="line-modified">152     private static void registerStringLatin1Plugins(InvocationPlugins plugins, BytecodeProvider replacementsBytecodeProvider) {</span>
<span class="line-modified">153         if (JAVA_SPECIFICATION_VERSION &gt;= 9) {</span>
<span class="line-modified">154             Registration r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, replacementsBytecodeProvider);</span>
155             r.setAllowOverwrite(true);
156             r.registerMethodSubstitution(AArch64StringLatin1Substitutions.class, &quot;compareTo&quot;, byte[].class, byte[].class);
157             r.registerMethodSubstitution(AArch64StringLatin1Substitutions.class, &quot;compareToUTF16&quot;, byte[].class, byte[].class);
158         }
159     }
160 
<span class="line-modified">161     private static void registerStringUTF16Plugins(InvocationPlugins plugins, BytecodeProvider replacementsBytecodeProvider) {</span>
<span class="line-modified">162         if (JAVA_SPECIFICATION_VERSION &gt;= 9) {</span>
<span class="line-modified">163             Registration r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacementsBytecodeProvider);</span>
164             r.setAllowOverwrite(true);
165             r.registerMethodSubstitution(AArch64StringUTF16Substitutions.class, &quot;compareTo&quot;, byte[].class, byte[].class);
166             r.registerMethodSubstitution(AArch64StringUTF16Substitutions.class, &quot;compareToLatin1&quot;, byte[].class, byte[].class);
167         }
168     }
169 
<span class="line-modified">170     private static void registerUnsafePlugins(InvocationPlugins plugins, BytecodeProvider replacementsBytecodeProvider) {</span>
171         registerUnsafePlugins(new Registration(plugins, Unsafe.class),
172                         new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, &quot;Object&quot;);
<span class="line-modified">173         if (!Java8OrEarlier) {</span>
<span class="line-modified">174             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacementsBytecodeProvider),</span>
175                             new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object},
<span class="line-modified">176                             Java11OrEarlier ? &quot;Object&quot; : &quot;Reference&quot;);</span>
177         }
178     }
179 
180     private static void registerUnsafePlugins(Registration r, JavaKind[] unsafeJavaKinds, String objectKindName) {
181 
182         for (JavaKind kind : unsafeJavaKinds) {
183             Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
184             String kindName = kind == JavaKind.Object ? objectKindName : kind.name();
185             r.register4(&quot;getAndSet&quot; + kindName, Receiver.class, Object.class, long.class, javaClass, new InvocationPlugin() {
186                 @Override
187                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode value) {
188                     // Emits a null-check for the otherwise unused receiver
189                     unsafe.get();
190                     b.addPush(kind, new AtomicReadAndWriteNode(object, offset, value, kind, LocationIdentity.any()));
191                     b.getGraph().markUnsafeAccess();
192                     return true;
193                 }
194             });
195 
196             if (kind != JavaKind.Boolean &amp;&amp; kind.isNumericInteger()) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.aarch64;
 26 
 27 import static org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.registerPlatformSpecificUnsafePlugins;
 28 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.COS;
 29 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.EXP;
 30 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG;
 31 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG10;
 32 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.SIN;
 33 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.TAN;



 34 

 35 import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticLIRGeneratorTool.RoundingMode;
 36 import org.graalvm.compiler.nodes.ValueNode;
 37 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 38 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 39 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 40 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 41 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 42 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 43 import org.graalvm.compiler.nodes.java.AtomicReadAndAddNode;
 44 import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
 45 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 46 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<span class="line-added"> 47 import org.graalvm.compiler.nodes.spi.Replacements;</span>
<span class="line-added"> 48 import org.graalvm.compiler.replacements.TargetGraphBuilderPlugins;</span>
 49 import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode;
<span class="line-added"> 50 import org.graalvm.compiler.replacements.nodes.FusedMultiplyAddNode;</span>
 51 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode;
 52 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation;
<span class="line-added"> 53 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
 54 import jdk.internal.vm.compiler.word.LocationIdentity;
 55 
<span class="line-added"> 56 import jdk.vm.ci.code.Architecture;</span>
 57 import jdk.vm.ci.meta.JavaKind;
 58 import jdk.vm.ci.meta.ResolvedJavaMethod;
 59 import sun.misc.Unsafe;
 60 
<span class="line-modified"> 61 public class AArch64GraphBuilderPlugins implements TargetGraphBuilderPlugins {</span>
<span class="line-added"> 62     @Override</span>
<span class="line-added"> 63     public void register(Plugins plugins, Replacements replacements, Architecture arch, boolean explicitUnsafeNullChecks, boolean registerMathPlugins,</span>
<span class="line-added"> 64                     boolean emitJDK9StringSubstitutions, boolean useFMAIntrinsics) {</span>
<span class="line-added"> 65         register(plugins, replacements, explicitUnsafeNullChecks, registerMathPlugins, emitJDK9StringSubstitutions, useFMAIntrinsics);</span>
<span class="line-added"> 66     }</span>
 67 
<span class="line-modified"> 68     public static void register(Plugins plugins, Replacements replacements, boolean explicitUnsafeNullChecks,</span>
<span class="line-added"> 69                     boolean registerMathPlugins, boolean emitJDK9StringSubstitutions, boolean useFMAIntrinsics) {</span>
 70         InvocationPlugins invocationPlugins = plugins.getInvocationPlugins();
 71         invocationPlugins.defer(new Runnable() {
 72             @Override
 73             public void run() {
<span class="line-modified"> 74                 registerIntegerLongPlugins(invocationPlugins, JavaKind.Int, replacements);</span>
<span class="line-modified"> 75                 registerIntegerLongPlugins(invocationPlugins, JavaKind.Long, replacements);</span>
<span class="line-modified"> 76                 if (registerMathPlugins) {</span>
<span class="line-modified"> 77                     registerMathPlugins(invocationPlugins, useFMAIntrinsics);</span>
<span class="line-modified"> 78                 }</span>
<span class="line-modified"> 79                 if (emitJDK9StringSubstitutions) {</span>
<span class="line-added"> 80                     registerStringLatin1Plugins(invocationPlugins, replacements);</span>
<span class="line-added"> 81                     registerStringUTF16Plugins(invocationPlugins, replacements);</span>
<span class="line-added"> 82                 }</span>
<span class="line-added"> 83                 registerUnsafePlugins(invocationPlugins, replacements);</span>
 84                 // This is temporarily disabled until we implement correct emitting of the CAS
 85                 // instructions of the proper width.
<span class="line-modified"> 86                 registerPlatformSpecificUnsafePlugins(invocationPlugins, replacements, explicitUnsafeNullChecks,</span>
 87                                 new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object});
 88             }
 89         });
 90     }
 91 
<span class="line-modified"> 92     private static void registerIntegerLongPlugins(InvocationPlugins plugins, JavaKind kind, Replacements replacements) {</span>
 93         Class&lt;?&gt; declaringClass = kind.toBoxedJavaClass();
 94         Class&lt;?&gt; type = kind.toJavaClass();
<span class="line-modified"> 95         Registration r = new Registration(plugins, declaringClass, replacements);</span>
 96         r.register1(&quot;numberOfLeadingZeros&quot;, type, new InvocationPlugin() {
 97             @Override
 98             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 99                 ValueNode folded = AArch64CountLeadingZerosNode.tryFold(value);
100                 if (folded != null) {
101                     b.addPush(JavaKind.Int, folded);
102                 } else {
103                     b.addPush(JavaKind.Int, new AArch64CountLeadingZerosNode(value));
104                 }
105                 return true;
106             }
107         });
108         r.register1(&quot;numberOfTrailingZeros&quot;, type, new InvocationPlugin() {
109             @Override
110             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
111                 ValueNode folded = AArch64CountTrailingZerosNode.tryFold(value);
112                 if (folded != null) {
113                     b.addPush(JavaKind.Int, folded);
114                 } else {
115                     b.addPush(JavaKind.Int, new AArch64CountTrailingZerosNode(value));
116                 }
117                 return true;
118             }
119         });
<span class="line-modified">120         r.register1(&quot;bitCount&quot;, type, new InvocationPlugin() {</span>
<span class="line-added">121             @Override</span>
<span class="line-added">122             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {</span>
<span class="line-added">123                 b.push(JavaKind.Int, b.append(new AArch64BitCountNode(value).canonical(null)));</span>
<span class="line-added">124                 return true;</span>
<span class="line-added">125             }</span>
<span class="line-added">126         });</span>
127     }
128 
<span class="line-modified">129     private static void registerMathPlugins(InvocationPlugins plugins, boolean useFMAIntrinsics) {</span>
130         Registration r = new Registration(plugins, Math.class);
131         registerUnaryMath(r, &quot;sin&quot;, SIN);
132         registerUnaryMath(r, &quot;cos&quot;, COS);
133         registerUnaryMath(r, &quot;tan&quot;, TAN);
134         registerUnaryMath(r, &quot;exp&quot;, EXP);
135         registerUnaryMath(r, &quot;log&quot;, LOG);
136         registerUnaryMath(r, &quot;log10&quot;, LOG10);
137         r.register2(&quot;pow&quot;, Double.TYPE, Double.TYPE, new InvocationPlugin() {
138             @Override
139             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
140                 b.push(JavaKind.Double, b.append(BinaryMathIntrinsicNode.create(x, y, BinaryMathIntrinsicNode.BinaryOperation.POW)));
141                 return true;
142             }
143         });
144         registerRound(r, &quot;rint&quot;, RoundingMode.NEAREST);
145         registerRound(r, &quot;ceil&quot;, RoundingMode.UP);
146         registerRound(r, &quot;floor&quot;, RoundingMode.DOWN);
<span class="line-added">147         if (useFMAIntrinsics &amp;&amp; JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-added">148             registerFMA(r);</span>
<span class="line-added">149         }</span>
<span class="line-added">150     }</span>
<span class="line-added">151 </span>
<span class="line-added">152     private static void registerFMA(Registration r) {</span>
<span class="line-added">153         r.register3(&quot;fma&quot;, Double.TYPE, Double.TYPE, Double.TYPE, new InvocationPlugin() {</span>
<span class="line-added">154             @Override</span>
<span class="line-added">155             public boolean apply(GraphBuilderContext b,</span>
<span class="line-added">156                             ResolvedJavaMethod targetMethod,</span>
<span class="line-added">157                             Receiver receiver,</span>
<span class="line-added">158                             ValueNode na,</span>
<span class="line-added">159                             ValueNode nb,</span>
<span class="line-added">160                             ValueNode nc) {</span>
<span class="line-added">161                 b.push(JavaKind.Double, b.append(new FusedMultiplyAddNode(na, nb, nc)));</span>
<span class="line-added">162                 return true;</span>
<span class="line-added">163             }</span>
<span class="line-added">164         });</span>
<span class="line-added">165         r.register3(&quot;fma&quot;, Float.TYPE, Float.TYPE, Float.TYPE, new InvocationPlugin() {</span>
<span class="line-added">166             @Override</span>
<span class="line-added">167             public boolean apply(GraphBuilderContext b,</span>
<span class="line-added">168                             ResolvedJavaMethod targetMethod,</span>
<span class="line-added">169                             Receiver receiver,</span>
<span class="line-added">170                             ValueNode na,</span>
<span class="line-added">171                             ValueNode nb,</span>
<span class="line-added">172                             ValueNode nc) {</span>
<span class="line-added">173                 b.push(JavaKind.Float, b.append(new FusedMultiplyAddNode(na, nb, nc)));</span>
<span class="line-added">174                 return true;</span>
<span class="line-added">175             }</span>
<span class="line-added">176         });</span>
177     }
178 
179     private static void registerUnaryMath(Registration r, String name, UnaryOperation operation) {
180         r.register1(name, Double.TYPE, new InvocationPlugin() {
181             @Override
182             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
183                 b.push(JavaKind.Double, b.append(UnaryMathIntrinsicNode.create(value, operation)));
184                 return true;
185             }
186         });
187     }
188 
189     private static void registerRound(Registration r, String name, RoundingMode mode) {
190         r.register1(name, Double.TYPE, new InvocationPlugin() {
191             @Override
192             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg) {
193                 b.push(JavaKind.Double, b.append(new AArch64RoundNode(arg, mode)));
194                 return true;
195             }
196         });
197     }
198 
<span class="line-modified">199     private static void registerStringLatin1Plugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">200         if (JavaVersionUtil.JAVA_SPEC &gt;= 9) {</span>
<span class="line-modified">201             Registration r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, replacements);</span>
202             r.setAllowOverwrite(true);
203             r.registerMethodSubstitution(AArch64StringLatin1Substitutions.class, &quot;compareTo&quot;, byte[].class, byte[].class);
204             r.registerMethodSubstitution(AArch64StringLatin1Substitutions.class, &quot;compareToUTF16&quot;, byte[].class, byte[].class);
205         }
206     }
207 
<span class="line-modified">208     private static void registerStringUTF16Plugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">209         if (JavaVersionUtil.JAVA_SPEC &gt;= 9) {</span>
<span class="line-modified">210             Registration r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);</span>
211             r.setAllowOverwrite(true);
212             r.registerMethodSubstitution(AArch64StringUTF16Substitutions.class, &quot;compareTo&quot;, byte[].class, byte[].class);
213             r.registerMethodSubstitution(AArch64StringUTF16Substitutions.class, &quot;compareToLatin1&quot;, byte[].class, byte[].class);
214         }
215     }
216 
<span class="line-modified">217     private static void registerUnsafePlugins(InvocationPlugins plugins, Replacements replacements) {</span>
218         registerUnsafePlugins(new Registration(plugins, Unsafe.class),
219                         new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, &quot;Object&quot;);
<span class="line-modified">220         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified">221             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements),</span>
222                             new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object},
<span class="line-modified">223                             JavaVersionUtil.JAVA_SPEC &lt;= 11 ? &quot;Object&quot; : &quot;Reference&quot;);</span>
224         }
225     }
226 
227     private static void registerUnsafePlugins(Registration r, JavaKind[] unsafeJavaKinds, String objectKindName) {
228 
229         for (JavaKind kind : unsafeJavaKinds) {
230             Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
231             String kindName = kind == JavaKind.Object ? objectKindName : kind.name();
232             r.register4(&quot;getAndSet&quot; + kindName, Receiver.class, Object.class, long.class, javaClass, new InvocationPlugin() {
233                 @Override
234                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode value) {
235                     // Emits a null-check for the otherwise unused receiver
236                     unsafe.get();
237                     b.addPush(kind, new AtomicReadAndWriteNode(object, offset, value, kind, LocationIdentity.any()));
238                     b.getGraph().markUnsafeAccess();
239                     return true;
240                 }
241             });
242 
243             if (kind != JavaKind.Boolean &amp;&amp; kind.isNumericInteger()) {
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../org.graalvm.compiler.printer/src/org/graalvm/compiler/printer/GraphPrinterDumpHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64IntegerArithmeticSnippets.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
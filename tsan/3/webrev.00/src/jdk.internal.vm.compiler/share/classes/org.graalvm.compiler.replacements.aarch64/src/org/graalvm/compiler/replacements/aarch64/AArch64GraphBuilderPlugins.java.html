<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.aarch64/src/org/graalvm/compiler/replacements/aarch64/AArch64GraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.aarch64;
 26 
 27 import static org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.registerPlatformSpecificUnsafePlugins;
 28 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.COS;
 29 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.EXP;
 30 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG;
 31 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG10;
 32 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.SIN;
 33 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.TAN;
 34 
 35 import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticLIRGeneratorTool.RoundingMode;
 36 import org.graalvm.compiler.nodes.ValueNode;
 37 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 38 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 39 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 40 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 41 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 42 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 43 import org.graalvm.compiler.nodes.java.AtomicReadAndAddNode;
 44 import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
 45 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 46 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 47 import org.graalvm.compiler.nodes.spi.Replacements;
 48 import org.graalvm.compiler.replacements.TargetGraphBuilderPlugins;
 49 import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode;
 50 import org.graalvm.compiler.replacements.nodes.FusedMultiplyAddNode;
 51 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode;
 52 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation;
 53 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 54 import jdk.internal.vm.compiler.word.LocationIdentity;
 55 
 56 import jdk.vm.ci.code.Architecture;
 57 import jdk.vm.ci.meta.JavaKind;
 58 import jdk.vm.ci.meta.ResolvedJavaMethod;
 59 import sun.misc.Unsafe;
 60 
 61 public class AArch64GraphBuilderPlugins implements TargetGraphBuilderPlugins {
 62     @Override
 63     public void register(Plugins plugins, Replacements replacements, Architecture arch, boolean explicitUnsafeNullChecks, boolean registerMathPlugins,
 64                     boolean emitJDK9StringSubstitutions, boolean useFMAIntrinsics) {
 65         register(plugins, replacements, explicitUnsafeNullChecks, registerMathPlugins, emitJDK9StringSubstitutions, useFMAIntrinsics);
 66     }
 67 
 68     public static void register(Plugins plugins, Replacements replacements, boolean explicitUnsafeNullChecks,
 69                     boolean registerMathPlugins, boolean emitJDK9StringSubstitutions, boolean useFMAIntrinsics) {
 70         InvocationPlugins invocationPlugins = plugins.getInvocationPlugins();
 71         invocationPlugins.defer(new Runnable() {
 72             @Override
 73             public void run() {
 74                 registerIntegerLongPlugins(invocationPlugins, JavaKind.Int, replacements);
 75                 registerIntegerLongPlugins(invocationPlugins, JavaKind.Long, replacements);
 76                 if (registerMathPlugins) {
 77                     registerMathPlugins(invocationPlugins, useFMAIntrinsics);
 78                 }
 79                 if (emitJDK9StringSubstitutions) {
 80                     registerStringLatin1Plugins(invocationPlugins, replacements);
 81                     registerStringUTF16Plugins(invocationPlugins, replacements);
 82                 }
 83                 registerUnsafePlugins(invocationPlugins, replacements);
 84                 // This is temporarily disabled until we implement correct emitting of the CAS
 85                 // instructions of the proper width.
 86                 registerPlatformSpecificUnsafePlugins(invocationPlugins, replacements, explicitUnsafeNullChecks,
 87                                 new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object});
 88             }
 89         });
 90     }
 91 
 92     private static void registerIntegerLongPlugins(InvocationPlugins plugins, JavaKind kind, Replacements replacements) {
 93         Class&lt;?&gt; declaringClass = kind.toBoxedJavaClass();
 94         Class&lt;?&gt; type = kind.toJavaClass();
 95         Registration r = new Registration(plugins, declaringClass, replacements);
 96         r.register1(&quot;numberOfLeadingZeros&quot;, type, new InvocationPlugin() {
 97             @Override
 98             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 99                 ValueNode folded = AArch64CountLeadingZerosNode.tryFold(value);
100                 if (folded != null) {
101                     b.addPush(JavaKind.Int, folded);
102                 } else {
103                     b.addPush(JavaKind.Int, new AArch64CountLeadingZerosNode(value));
104                 }
105                 return true;
106             }
107         });
108         r.register1(&quot;numberOfTrailingZeros&quot;, type, new InvocationPlugin() {
109             @Override
110             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
111                 ValueNode folded = AArch64CountTrailingZerosNode.tryFold(value);
112                 if (folded != null) {
113                     b.addPush(JavaKind.Int, folded);
114                 } else {
115                     b.addPush(JavaKind.Int, new AArch64CountTrailingZerosNode(value));
116                 }
117                 return true;
118             }
119         });
120         r.register1(&quot;bitCount&quot;, type, new InvocationPlugin() {
121             @Override
122             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
123                 b.push(JavaKind.Int, b.append(new AArch64BitCountNode(value).canonical(null)));
124                 return true;
125             }
126         });
127     }
128 
129     private static void registerMathPlugins(InvocationPlugins plugins, boolean useFMAIntrinsics) {
130         Registration r = new Registration(plugins, Math.class);
131         registerUnaryMath(r, &quot;sin&quot;, SIN);
132         registerUnaryMath(r, &quot;cos&quot;, COS);
133         registerUnaryMath(r, &quot;tan&quot;, TAN);
134         registerUnaryMath(r, &quot;exp&quot;, EXP);
135         registerUnaryMath(r, &quot;log&quot;, LOG);
136         registerUnaryMath(r, &quot;log10&quot;, LOG10);
137         r.register2(&quot;pow&quot;, Double.TYPE, Double.TYPE, new InvocationPlugin() {
138             @Override
139             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
140                 b.push(JavaKind.Double, b.append(BinaryMathIntrinsicNode.create(x, y, BinaryMathIntrinsicNode.BinaryOperation.POW)));
141                 return true;
142             }
143         });
144         registerRound(r, &quot;rint&quot;, RoundingMode.NEAREST);
145         registerRound(r, &quot;ceil&quot;, RoundingMode.UP);
146         registerRound(r, &quot;floor&quot;, RoundingMode.DOWN);
147         if (useFMAIntrinsics &amp;&amp; JavaVersionUtil.JAVA_SPEC &gt; 8) {
148             registerFMA(r);
149         }
150     }
151 
152     private static void registerFMA(Registration r) {
153         r.register3(&quot;fma&quot;, Double.TYPE, Double.TYPE, Double.TYPE, new InvocationPlugin() {
154             @Override
155             public boolean apply(GraphBuilderContext b,
156                             ResolvedJavaMethod targetMethod,
157                             Receiver receiver,
158                             ValueNode na,
159                             ValueNode nb,
160                             ValueNode nc) {
161                 b.push(JavaKind.Double, b.append(new FusedMultiplyAddNode(na, nb, nc)));
162                 return true;
163             }
164         });
165         r.register3(&quot;fma&quot;, Float.TYPE, Float.TYPE, Float.TYPE, new InvocationPlugin() {
166             @Override
167             public boolean apply(GraphBuilderContext b,
168                             ResolvedJavaMethod targetMethod,
169                             Receiver receiver,
170                             ValueNode na,
171                             ValueNode nb,
172                             ValueNode nc) {
173                 b.push(JavaKind.Float, b.append(new FusedMultiplyAddNode(na, nb, nc)));
174                 return true;
175             }
176         });
177     }
178 
179     private static void registerUnaryMath(Registration r, String name, UnaryOperation operation) {
180         r.register1(name, Double.TYPE, new InvocationPlugin() {
181             @Override
182             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
183                 b.push(JavaKind.Double, b.append(UnaryMathIntrinsicNode.create(value, operation)));
184                 return true;
185             }
186         });
187     }
188 
189     private static void registerRound(Registration r, String name, RoundingMode mode) {
190         r.register1(name, Double.TYPE, new InvocationPlugin() {
191             @Override
192             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg) {
193                 b.push(JavaKind.Double, b.append(new AArch64RoundNode(arg, mode)));
194                 return true;
195             }
196         });
197     }
198 
199     private static void registerStringLatin1Plugins(InvocationPlugins plugins, Replacements replacements) {
200         if (JavaVersionUtil.JAVA_SPEC &gt;= 9) {
201             Registration r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, replacements);
202             r.setAllowOverwrite(true);
203             r.registerMethodSubstitution(AArch64StringLatin1Substitutions.class, &quot;compareTo&quot;, byte[].class, byte[].class);
204             r.registerMethodSubstitution(AArch64StringLatin1Substitutions.class, &quot;compareToUTF16&quot;, byte[].class, byte[].class);
205         }
206     }
207 
208     private static void registerStringUTF16Plugins(InvocationPlugins plugins, Replacements replacements) {
209         if (JavaVersionUtil.JAVA_SPEC &gt;= 9) {
210             Registration r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);
211             r.setAllowOverwrite(true);
212             r.registerMethodSubstitution(AArch64StringUTF16Substitutions.class, &quot;compareTo&quot;, byte[].class, byte[].class);
213             r.registerMethodSubstitution(AArch64StringUTF16Substitutions.class, &quot;compareToLatin1&quot;, byte[].class, byte[].class);
214         }
215     }
216 
217     private static void registerUnsafePlugins(InvocationPlugins plugins, Replacements replacements) {
218         registerUnsafePlugins(new Registration(plugins, Unsafe.class),
219                         new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, &quot;Object&quot;);
220         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
221             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements),
222                             new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object},
223                             JavaVersionUtil.JAVA_SPEC &lt;= 11 ? &quot;Object&quot; : &quot;Reference&quot;);
224         }
225     }
226 
227     private static void registerUnsafePlugins(Registration r, JavaKind[] unsafeJavaKinds, String objectKindName) {
228 
229         for (JavaKind kind : unsafeJavaKinds) {
230             Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
231             String kindName = kind == JavaKind.Object ? objectKindName : kind.name();
232             r.register4(&quot;getAndSet&quot; + kindName, Receiver.class, Object.class, long.class, javaClass, new InvocationPlugin() {
233                 @Override
234                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode value) {
235                     // Emits a null-check for the otherwise unused receiver
236                     unsafe.get();
237                     b.addPush(kind, new AtomicReadAndWriteNode(object, offset, value, kind, LocationIdentity.any()));
238                     b.getGraph().markUnsafeAccess();
239                     return true;
240                 }
241             });
242 
243             if (kind != JavaKind.Boolean &amp;&amp; kind.isNumericInteger()) {
244                 r.register4(&quot;getAndAdd&quot; + kindName, Receiver.class, Object.class, long.class, javaClass, new InvocationPlugin() {
245                     @Override
246                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode delta) {
247                         // Emits a null-check for the otherwise unused receiver
248                         unsafe.get();
249                         AddressNode address = b.add(new OffsetAddressNode(object, offset));
250                         b.addPush(kind, new AtomicReadAndAddNode(address, delta, kind, LocationIdentity.any()));
251                         b.getGraph().markUnsafeAccess();
252                         return true;
253                     }
254                 });
255             }
256         }
257     }
258 }
    </pre>
  </body>
</html>
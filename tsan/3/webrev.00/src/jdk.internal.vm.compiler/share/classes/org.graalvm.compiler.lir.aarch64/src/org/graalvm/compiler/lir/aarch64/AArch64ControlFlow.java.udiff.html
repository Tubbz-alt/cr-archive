<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64ControlFlow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64Compare.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64Move.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64ControlFlow.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22,33 +22,37 @@</span>
   */
  
  
  package org.graalvm.compiler.lir.aarch64;
  
<span class="udiff-line-added">+ import static jdk.vm.ci.aarch64.AArch64.lr;</span>
  import static jdk.vm.ci.code.ValueUtil.asAllocatableValue;
  import static jdk.vm.ci.code.ValueUtil.asRegister;
  import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;
<span class="udiff-line-added">+ import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
  import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
  
  import java.util.function.Function;
  
  import jdk.vm.ci.meta.AllocatableValue;
  import org.graalvm.compiler.asm.Label;
<span class="udiff-line-removed">- import org.graalvm.compiler.core.common.NumUtil;</span>
  import org.graalvm.compiler.asm.aarch64.AArch64Assembler;
  import org.graalvm.compiler.asm.aarch64.AArch64Assembler.ConditionFlag;
  import org.graalvm.compiler.asm.aarch64.AArch64Assembler.ExtendType;
  import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
  import org.graalvm.compiler.code.CompilationResult.JumpTable;
  import org.graalvm.compiler.core.common.LIRKind;
<span class="udiff-line-added">+ import org.graalvm.compiler.core.common.NumUtil;</span>
  import org.graalvm.compiler.core.common.calc.Condition;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.lir.ConstantValue;
<span class="udiff-line-added">+ import org.graalvm.compiler.lir.LIRInstruction;</span>
  import org.graalvm.compiler.lir.LIRInstructionClass;
  import org.graalvm.compiler.lir.LabelRef;
  import org.graalvm.compiler.lir.Opcode;
  import org.graalvm.compiler.lir.StandardOp;
<span class="udiff-line-added">+ import org.graalvm.compiler.lir.StandardOp.BlockEndOp;</span>
  import org.graalvm.compiler.lir.SwitchStrategy;
  import org.graalvm.compiler.lir.SwitchStrategy.BaseSwitchClosure;
  import org.graalvm.compiler.lir.Variable;
  import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -57,10 +61,25 @@</span>
  import jdk.vm.ci.meta.Constant;
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.Value;
  
  public class AArch64ControlFlow {
<span class="udiff-line-added">+     public static final class ReturnOp extends AArch64BlockEndOp implements BlockEndOp {</span>
<span class="udiff-line-added">+         public static final LIRInstructionClass&lt;ReturnOp&gt; TYPE = LIRInstructionClass.create(ReturnOp.class);</span>
<span class="udiff-line-added">+         @Use({REG, ILLEGAL}) protected Value x;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public ReturnOp(Value x) {</span>
<span class="udiff-line-added">+             super(TYPE);</span>
<span class="udiff-line-added">+             this.x = x;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         protected void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {</span>
<span class="udiff-line-added">+             crb.frameContext.leave(crb);</span>
<span class="udiff-line-added">+             masm.ret(lr);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
      public abstract static class AbstractBranchOp extends AArch64BlockEndOp implements StandardOp.BranchOp {
          private final LabelRef trueDestination;
          private final LabelRef falseDestination;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -128,14 +147,29 @@</span>
          protected void emitBranch(CompilationResultBuilder crb, AArch64MacroAssembler masm, LabelRef target, boolean negate) {
              AArch64Kind kind = (AArch64Kind) this.value.getPlatformKind();
              assert kind.isInteger();
              int size = kind.getSizeInBytes() * Byte.SIZE;
  
<span class="udiff-line-modified-removed">-             if (negate) {</span>
<span class="udiff-line-modified-removed">-                 masm.cbnz(size, asRegister(this.value), target.label());</span>
<span class="udiff-line-modified-added">+             Label label = target.label();</span>
<span class="udiff-line-modified-added">+             boolean isFarBranch = isFarBranch(this, 21, crb, masm, label);</span>
<span class="udiff-line-added">+             boolean useCbnz;</span>
<span class="udiff-line-added">+             if (isFarBranch) {</span>
<span class="udiff-line-added">+                 useCbnz = !negate;</span>
<span class="udiff-line-added">+                 label = new Label();</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 useCbnz = negate;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (useCbnz) {</span>
<span class="udiff-line-added">+                 masm.cbnz(size, asRegister(this.value), label);</span>
              } else {
<span class="udiff-line-modified-removed">-                 masm.cbz(size, asRegister(this.value), target.label());</span>
<span class="udiff-line-modified-added">+                 masm.cbz(size, asRegister(this.value), label);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (isFarBranch) {</span>
<span class="udiff-line-added">+                 masm.jmp(target.label());</span>
<span class="udiff-line-added">+                 masm.bind(label);</span>
              }
          }
      }
  
      public static class BitTestAndBranchOp extends AbstractBranchOp implements StandardOp.BranchOp {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -152,21 +186,11 @@</span>
  
          @Override
          protected void emitBranch(CompilationResultBuilder crb, AArch64MacroAssembler masm, LabelRef target, boolean negate) {
              ConditionFlag cond = negate ? ConditionFlag.NE : ConditionFlag.EQ;
              Label label = target.label();
<span class="udiff-line-modified-removed">-             boolean isFarBranch;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if (label.isBound()) {</span>
<span class="udiff-line-removed">-                 isFarBranch = NumUtil.isSignedNbit(18, masm.position() - label.position());</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 // Max range of tbz is +-2^13 instructions. We estimate that each LIR instruction</span>
<span class="udiff-line-removed">-                 // emits 2 AArch64 instructions on average. Thus we test for maximum 2^12 LIR</span>
<span class="udiff-line-removed">-                 // instruction offset.</span>
<span class="udiff-line-removed">-                 int maxLIRDistance = (1 &lt;&lt; 12);</span>
<span class="udiff-line-removed">-                 isFarBranch = !crb.labelWithinRange(this, label, maxLIRDistance);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+             boolean isFarBranch = isFarBranch(this, 14, crb, masm, label);</span>
  
              if (isFarBranch) {
                  cond = cond.negate();
                  label = new Label();
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -369,6 +393,22 @@</span>
              AArch64Move.move(crb, masm, asAllocatableValue(scratchValue), c);
              masm.cmp(size, asRegister(key), asRegister(scratchValue));
          }
      }
  
<span class="udiff-line-added">+     private static boolean isFarBranch(LIRInstruction instruction, int offsetBits, CompilationResultBuilder crb, AArch64MacroAssembler masm, Label label) {</span>
<span class="udiff-line-added">+         boolean isFarBranch;</span>
<span class="udiff-line-added">+         if (label.isBound()) {</span>
<span class="udiff-line-added">+             // The label.position() is a byte based index. The instruction instruction has</span>
<span class="udiff-line-added">+             // offsetBits bits for the offset and AArch64 instruction is 4 bytes aligned. So</span>
<span class="udiff-line-added">+             // instruction can encode offsetBits+2 bits signed offset.</span>
<span class="udiff-line-added">+             isFarBranch = !NumUtil.isSignedNbit(offsetBits + 2, masm.position() - label.position());</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             // Max range of instruction is 2^offsetBits instructions. We estimate that each LIR</span>
<span class="udiff-line-added">+             // instruction emits 2 AArch64 instructions on average. Thus we test for maximum</span>
<span class="udiff-line-added">+             // 2^(offsetBits-2) LIR instruction offset.</span>
<span class="udiff-line-added">+             int maxLIRDistance = (1 &lt;&lt; (offsetBits - 2));</span>
<span class="udiff-line-added">+             isFarBranch = !crb.labelWithinRange(instruction, label, maxLIRDistance);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return isFarBranch;</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="AArch64Compare.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64Move.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
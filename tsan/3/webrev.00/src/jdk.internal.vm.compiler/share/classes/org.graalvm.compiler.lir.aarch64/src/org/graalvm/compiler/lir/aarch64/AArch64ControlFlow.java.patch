diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64ControlFlow.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64ControlFlow.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64ControlFlow.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64ControlFlow.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,33 +22,37 @@
  */
 
 
 package org.graalvm.compiler.lir.aarch64;
 
+import static jdk.vm.ci.aarch64.AArch64.lr;
 import static jdk.vm.ci.code.ValueUtil.asAllocatableValue;
 import static jdk.vm.ci.code.ValueUtil.asRegister;
 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;
+import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;
 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
 
 import java.util.function.Function;
 
 import jdk.vm.ci.meta.AllocatableValue;
 import org.graalvm.compiler.asm.Label;
-import org.graalvm.compiler.core.common.NumUtil;
 import org.graalvm.compiler.asm.aarch64.AArch64Assembler;
 import org.graalvm.compiler.asm.aarch64.AArch64Assembler.ConditionFlag;
 import org.graalvm.compiler.asm.aarch64.AArch64Assembler.ExtendType;
 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 import org.graalvm.compiler.code.CompilationResult.JumpTable;
 import org.graalvm.compiler.core.common.LIRKind;
+import org.graalvm.compiler.core.common.NumUtil;
 import org.graalvm.compiler.core.common.calc.Condition;
 import org.graalvm.compiler.debug.GraalError;
 import org.graalvm.compiler.lir.ConstantValue;
+import org.graalvm.compiler.lir.LIRInstruction;
 import org.graalvm.compiler.lir.LIRInstructionClass;
 import org.graalvm.compiler.lir.LabelRef;
 import org.graalvm.compiler.lir.Opcode;
 import org.graalvm.compiler.lir.StandardOp;
+import org.graalvm.compiler.lir.StandardOp.BlockEndOp;
 import org.graalvm.compiler.lir.SwitchStrategy;
 import org.graalvm.compiler.lir.SwitchStrategy.BaseSwitchClosure;
 import org.graalvm.compiler.lir.Variable;
 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 
@@ -57,10 +61,25 @@
 import jdk.vm.ci.meta.Constant;
 import jdk.vm.ci.meta.JavaConstant;
 import jdk.vm.ci.meta.Value;
 
 public class AArch64ControlFlow {
+    public static final class ReturnOp extends AArch64BlockEndOp implements BlockEndOp {
+        public static final LIRInstructionClass<ReturnOp> TYPE = LIRInstructionClass.create(ReturnOp.class);
+        @Use({REG, ILLEGAL}) protected Value x;
+
+        public ReturnOp(Value x) {
+            super(TYPE);
+            this.x = x;
+        }
+
+        @Override
+        protected void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
+            crb.frameContext.leave(crb);
+            masm.ret(lr);
+        }
+    }
 
     public abstract static class AbstractBranchOp extends AArch64BlockEndOp implements StandardOp.BranchOp {
         private final LabelRef trueDestination;
         private final LabelRef falseDestination;
 
@@ -128,14 +147,29 @@
         protected void emitBranch(CompilationResultBuilder crb, AArch64MacroAssembler masm, LabelRef target, boolean negate) {
             AArch64Kind kind = (AArch64Kind) this.value.getPlatformKind();
             assert kind.isInteger();
             int size = kind.getSizeInBytes() * Byte.SIZE;
 
-            if (negate) {
-                masm.cbnz(size, asRegister(this.value), target.label());
+            Label label = target.label();
+            boolean isFarBranch = isFarBranch(this, 21, crb, masm, label);
+            boolean useCbnz;
+            if (isFarBranch) {
+                useCbnz = !negate;
+                label = new Label();
+            } else {
+                useCbnz = negate;
+            }
+
+            if (useCbnz) {
+                masm.cbnz(size, asRegister(this.value), label);
             } else {
-                masm.cbz(size, asRegister(this.value), target.label());
+                masm.cbz(size, asRegister(this.value), label);
+            }
+
+            if (isFarBranch) {
+                masm.jmp(target.label());
+                masm.bind(label);
             }
         }
     }
 
     public static class BitTestAndBranchOp extends AbstractBranchOp implements StandardOp.BranchOp {
@@ -152,21 +186,11 @@
 
         @Override
         protected void emitBranch(CompilationResultBuilder crb, AArch64MacroAssembler masm, LabelRef target, boolean negate) {
             ConditionFlag cond = negate ? ConditionFlag.NE : ConditionFlag.EQ;
             Label label = target.label();
-            boolean isFarBranch;
-
-            if (label.isBound()) {
-                isFarBranch = NumUtil.isSignedNbit(18, masm.position() - label.position());
-            } else {
-                // Max range of tbz is +-2^13 instructions. We estimate that each LIR instruction
-                // emits 2 AArch64 instructions on average. Thus we test for maximum 2^12 LIR
-                // instruction offset.
-                int maxLIRDistance = (1 << 12);
-                isFarBranch = !crb.labelWithinRange(this, label, maxLIRDistance);
-            }
+            boolean isFarBranch = isFarBranch(this, 14, crb, masm, label);
 
             if (isFarBranch) {
                 cond = cond.negate();
                 label = new Label();
             }
@@ -369,6 +393,22 @@
             AArch64Move.move(crb, masm, asAllocatableValue(scratchValue), c);
             masm.cmp(size, asRegister(key), asRegister(scratchValue));
         }
     }
 
+    private static boolean isFarBranch(LIRInstruction instruction, int offsetBits, CompilationResultBuilder crb, AArch64MacroAssembler masm, Label label) {
+        boolean isFarBranch;
+        if (label.isBound()) {
+            // The label.position() is a byte based index. The instruction instruction has
+            // offsetBits bits for the offset and AArch64 instruction is 4 bytes aligned. So
+            // instruction can encode offsetBits+2 bits signed offset.
+            isFarBranch = !NumUtil.isSignedNbit(offsetBits + 2, masm.position() - label.position());
+        } else {
+            // Max range of instruction is 2^offsetBits instructions. We estimate that each LIR
+            // instruction emits 2 AArch64 instructions on average. Thus we test for maximum
+            // 2^(offsetBits-2) LIR instruction offset.
+            int maxLIRDistance = (1 << (offsetBits - 2));
+            isFarBranch = !crb.labelWithinRange(instruction, label, maxLIRDistance);
+        }
+        return isFarBranch;
+    }
 }

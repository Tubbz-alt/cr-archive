<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64ArithmeticOp.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.aarch64;
 26 
 27 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
 28 import static org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp.ARMv8ConstantCategory.ARITHMETIC;
 29 import static org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp.ARMv8ConstantCategory.LOGICAL;
 30 import static org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp.ARMv8ConstantCategory.NONE;
 31 import static org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp.ARMv8ConstantCategory.SHIFT;
 32 import static jdk.vm.ci.aarch64.AArch64.zr;
 33 import static jdk.vm.ci.code.ValueUtil.asRegister;
 34 
 35 import org.graalvm.compiler.asm.aarch64.AArch64Assembler;
 36 import org.graalvm.compiler.asm.aarch64.AArch64Assembler.ConditionFlag;
 37 import org.graalvm.compiler.debug.GraalError;
 38 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 39 import org.graalvm.compiler.lir.LIRInstructionClass;
 40 import org.graalvm.compiler.lir.Opcode;
 41 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 42 
 43 import jdk.vm.ci.code.Register;
 44 import jdk.vm.ci.meta.AllocatableValue;
 45 import jdk.vm.ci.meta.JavaConstant;
 46 
 47 public enum AArch64ArithmeticOp {
 48     // TODO At least add and sub *can* be used with SP, so this should be supported
 49     NEG,
 50     NOT,
 51     ADD(ARITHMETIC),
 52     ADDS(ARITHMETIC),
 53     SUB(ARITHMETIC),
 54     SUBS(ARITHMETIC),
 55     MUL,
 56     MULVS,
 57     MNEG,
 58     DIV,
 59     SMULH,
 60     UMULH,
<a name="2" id="anc2"></a>






 61     REM,
 62     UDIV,
 63     UREM,
 64     AND(LOGICAL),
 65     ANDS(LOGICAL),
 66     OR(LOGICAL),
 67     XOR(LOGICAL),
 68     SHL(SHIFT),
 69     LSHR(SHIFT),
 70     ASHR(SHIFT),
 71     ABS,
 72 
 73     FADD,
 74     FSUB,
 75     FMUL,
 76     FDIV,
 77     FREM,
 78     FNEG,
 79     FABS,
 80     FRINTM,
 81     FRINTN,
 82     FRINTP,
 83     SQRT;
 84 
 85     /**
 86      * Specifies what constants can be used directly without having to be loaded into a register
 87      * with the given instruction.
 88      */
 89     public enum ARMv8ConstantCategory {
 90         NONE,
 91         LOGICAL,
 92         ARITHMETIC,
 93         SHIFT
 94     }
 95 
 96     public final ARMv8ConstantCategory category;
 97 
 98     AArch64ArithmeticOp(ARMv8ConstantCategory category) {
 99         this.category = category;
100     }
101 
102     AArch64ArithmeticOp() {
103         this(NONE);
104     }
105 
106     public static class UnaryOp extends AArch64LIRInstruction {
107         private static final LIRInstructionClass&lt;UnaryOp&gt; TYPE = LIRInstructionClass.create(UnaryOp.class);
108 
109         @Opcode private final AArch64ArithmeticOp opcode;
110         @Def({REG}) protected AllocatableValue result;
111         @Use({REG}) protected AllocatableValue x;
112 
113         public UnaryOp(AArch64ArithmeticOp opcode, AllocatableValue result, AllocatableValue x) {
114             super(TYPE);
115             this.opcode = opcode;
116             this.result = result;
117             this.x = x;
118         }
119 
120         @Override
121         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
122             Register dst = asRegister(result);
123             Register src = asRegister(x);
124             int size = result.getPlatformKind().getSizeInBytes() * Byte.SIZE;
125             switch (opcode) {
126                 case NEG:
127                     masm.sub(size, dst, zr, src);
128                     break;
129                 case FNEG:
130                     masm.fneg(size, dst, src);
131                     break;
132                 case NOT:
133                     masm.not(size, dst, src);
134                     break;
135                 case ABS:
136                     masm.cmp(size, src, 0);
137                     masm.csneg(size, dst, src, ConditionFlag.LT);
138                     break;
139                 case FABS:
140                     masm.fabs(size, dst, src);
141                     break;
142                 case FRINTM:
143                     masm.frintm(size, dst, src);
144                     break;
145                 case FRINTN:
146                     masm.frintn(size, dst, src);
147                     break;
148                 case FRINTP:
149                     masm.frintp(size, dst, src);
150                     break;
151                 case SQRT:
152                     masm.fsqrt(size, dst, src);
153                     break;
154                 default:
155                     throw GraalError.shouldNotReachHere(&quot;op=&quot; + opcode.name());
156             }
157         }
158     }
159 
160     public static class BinaryConstOp extends AArch64LIRInstruction {
161         private static final LIRInstructionClass&lt;BinaryConstOp&gt; TYPE = LIRInstructionClass.create(BinaryConstOp.class);
162 
163         @Opcode private final AArch64ArithmeticOp op;
164         @Def({REG}) protected AllocatableValue result;
165         @Use({REG}) protected AllocatableValue a;
166         private final JavaConstant b;
167 
168         public BinaryConstOp(AArch64ArithmeticOp op, AllocatableValue result, AllocatableValue a, JavaConstant b) {
169             super(TYPE);
170             this.op = op;
171             this.result = result;
172             this.a = a;
173             this.b = b;
174         }
175 
176         @Override
177         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
178             assert op.category != NONE;
179             Register dst = asRegister(result);
180             Register src = asRegister(a);
181             int size = result.getPlatformKind().getSizeInBytes() * Byte.SIZE;
182             switch (op) {
183                 case ADD:
184                     // Don&#39;t use asInt() here, since we can&#39;t use asInt on a long variable, even
185                     // if the constant easily fits as an int.
186                     assert AArch64MacroAssembler.isArithmeticImmediate(b.asLong());
187                     masm.add(size, dst, src, (int) b.asLong());
188                     break;
189                 case SUB:
190                     // Don&#39;t use asInt() here, since we can&#39;t use asInt on a long variable, even
191                     // if the constant easily fits as an int.
192                     assert AArch64MacroAssembler.isArithmeticImmediate(b.asLong());
193                     masm.sub(size, dst, src, (int) b.asLong());
194                     break;
195                 case ADDS:
196                     assert AArch64MacroAssembler.isArithmeticImmediate(b.asLong());
197                     masm.adds(size, dst, src, (int) b.asLong());
198                     break;
199                 case SUBS:
200                     assert AArch64MacroAssembler.isArithmeticImmediate(b.asLong());
201                     masm.subs(size, dst, src, (int) b.asLong());
202                     break;
203                 case AND:
204                     // XXX Should this be handled somewhere else?
205                     if (size == 32 &amp;&amp; b.asLong() == 0xFFFF_FFFFL) {
206                         masm.mov(size, dst, src);
207                     } else {
208                         masm.and(size, dst, src, b.asLong());
209                     }
210                     break;
211                 case ANDS:
212                     masm.ands(size, dst, src, b.asLong());
213                     break;
214                 case OR:
215                     masm.or(size, dst, src, b.asLong());
216                     break;
217                 case XOR:
218                     masm.eor(size, dst, src, b.asLong());
219                     break;
220                 case SHL:
221                     masm.shl(size, dst, src, b.asLong());
222                     break;
223                 case LSHR:
224                     masm.lshr(size, dst, src, b.asLong());
225                     break;
226                 case ASHR:
227                     masm.ashr(size, dst, src, b.asLong());
228                     break;
229                 default:
230                     throw GraalError.shouldNotReachHere(&quot;op=&quot; + op.name());
231             }
232         }
233     }
234 
235     public static class BinaryOp extends AArch64LIRInstruction {
236         private static final LIRInstructionClass&lt;BinaryOp&gt; TYPE = LIRInstructionClass.create(BinaryOp.class);
237 
238         @Opcode private final AArch64ArithmeticOp op;
239         @Def({REG}) protected AllocatableValue result;
240         @Use({REG}) protected AllocatableValue a;
241         @Use({REG}) protected AllocatableValue b;
242 
243         public BinaryOp(AArch64ArithmeticOp op, AllocatableValue result, AllocatableValue a, AllocatableValue b) {
244             super(TYPE);
245             this.op = op;
246             this.result = result;
247             this.a = a;
248             this.b = b;
249         }
250 
251         @Override
252         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
253             Register dst = asRegister(result);
254             Register src1 = asRegister(a);
255             Register src2 = asRegister(b);
256             int size = result.getPlatformKind().getSizeInBytes() * Byte.SIZE;
257             switch (op) {
258                 case ADD:
259                     masm.add(size, dst, src1, src2);
260                     break;
261                 case ADDS:
262                     masm.adds(size, dst, src1, src2);
263                     break;
264                 case SUB:
265                     masm.sub(size, dst, src1, src2);
266                     break;
267                 case SUBS:
268                     masm.subs(size, dst, src1, src2);
269                     break;
270                 case MUL:
271                     masm.mul(size, dst, src1, src2);
272                     break;
273                 case UMULH:
274                     masm.umulh(size, dst, src1, src2);
275                     break;
276                 case SMULH:
277                     masm.smulh(size, dst, src1, src2);
278                     break;
279                 case MNEG:
280                     masm.mneg(size, dst, src1, src2);
281                     break;
<a name="3" id="anc3"></a>





282                 case DIV:
283                     masm.sdiv(size, dst, src1, src2);
284                     break;
285                 case UDIV:
286                     masm.udiv(size, dst, src1, src2);
287                     break;
288                 case AND:
289                     masm.and(size, dst, src1, src2);
290                     break;
291                 case ANDS:
292                     masm.ands(size, dst, src1, src2);
293                     break;
294                 case OR:
295                     masm.or(size, dst, src1, src2);
296                     break;
297                 case XOR:
298                     masm.eor(size, dst, src1, src2);
299                     break;
300                 case SHL:
301                     masm.shl(size, dst, src1, src2);
302                     break;
303                 case LSHR:
304                     masm.lshr(size, dst, src1, src2);
305                     break;
306                 case ASHR:
307                     masm.ashr(size, dst, src1, src2);
308                     break;
309                 case FADD:
310                     masm.fadd(size, dst, src1, src2);
311                     break;
312                 case FSUB:
313                     masm.fsub(size, dst, src1, src2);
314                     break;
315                 case FMUL:
316                     masm.fmul(size, dst, src1, src2);
317                     break;
318                 case FDIV:
319                     masm.fdiv(size, dst, src1, src2);
320                     break;
321                 case MULVS:
322                     masm.mulvs(size, dst, src1, src2);
323                     break;
324                 default:
325                     throw GraalError.shouldNotReachHere(&quot;op=&quot; + op.name());
326             }
327         }
328     }
329 
330     /**
331      * Class used for instructions that have to reuse one of their arguments. This only applies to
332      * the remainder instructions at the moment, since we have to compute n % d using rem = n -
333      * TruncatingDivision(n, d) * d
334      *
335      * TODO (das) Replace the remainder nodes in the LIR.
336      */
337     public static class BinaryCompositeOp extends AArch64LIRInstruction {
338         private static final LIRInstructionClass&lt;BinaryCompositeOp&gt; TYPE = LIRInstructionClass.create(BinaryCompositeOp.class);
339         @Opcode private final AArch64ArithmeticOp op;
340         @Def({REG}) protected AllocatableValue result;
341         @Alive({REG}) protected AllocatableValue a;
342         @Alive({REG}) protected AllocatableValue b;
343 
344         public BinaryCompositeOp(AArch64ArithmeticOp op, AllocatableValue result, AllocatableValue a, AllocatableValue b) {
345             super(TYPE);
346             this.op = op;
347             this.result = result;
348             this.a = a;
349             this.b = b;
350         }
351 
352         @Override
353         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
354             Register dst = asRegister(result);
355             Register src1 = asRegister(a);
356             Register src2 = asRegister(b);
357             int size = result.getPlatformKind().getSizeInBytes() * Byte.SIZE;
358             switch (op) {
359                 case REM:
360                     masm.rem(size, dst, src1, src2);
361                     break;
362                 case UREM:
363                     masm.urem(size, dst, src1, src2);
364                     break;
365                 case FREM:
366                     masm.frem(size, dst, src1, src2);
367                     break;
368                 default:
369                     throw GraalError.shouldNotReachHere();
370             }
371         }
372     }
373 
374     public static class BinaryShiftOp extends AArch64LIRInstruction {
375         private static final LIRInstructionClass&lt;BinaryShiftOp&gt; TYPE = LIRInstructionClass.create(BinaryShiftOp.class);
376 
377         @Opcode private final AArch64ArithmeticOp op;
378         @Def(REG) protected AllocatableValue result;
379         @Use(REG) protected AllocatableValue src1;
380         @Use(REG) protected AllocatableValue src2;
381         private final AArch64MacroAssembler.ShiftType shiftType;
382         private final int shiftAmt;
383         private final boolean isShiftNot;
384 
385         /**
386          * If shiftNot: Computes &lt;code&gt;result = src1 &lt;op&gt; ~(src2 &lt;shiftType&gt; &lt;shiftAmt&gt;)&lt;/code&gt;
387          * (Only for logic ops). else: Computes
388          * &lt;code&gt;result = src1 &lt;op&gt; src2 &lt;shiftType&gt; &lt;shiftAmt&gt;&lt;/code&gt;.
389          */
390         public BinaryShiftOp(AArch64ArithmeticOp op, AllocatableValue result, AllocatableValue src1, AllocatableValue src2,
391                         AArch64MacroAssembler.ShiftType shiftType, int shiftAmt, boolean isShiftNot) {
392             super(TYPE);
393             assert op == ADD || op == SUB || op == AND || op == OR || op == XOR;
394             this.op = op;
395             this.result = result;
396             this.src1 = src1;
397             this.src2 = src2;
398             this.shiftType = shiftType;
399             this.shiftAmt = shiftAmt;
400             this.isShiftNot = isShiftNot;
401         }
402 
403         @Override
404         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
405             int size = result.getPlatformKind().getSizeInBytes() * Byte.SIZE;
406             switch (op) {
407                 case ADD:
408                     masm.add(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);
409                     break;
410                 case SUB:
411                     masm.sub(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);
412                     break;
413                 case AND:
414                     if (!isShiftNot) {
415                         masm.and(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);
416                     } else {
417                         masm.bic(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);
418                     }
419                     break;
420                 case OR:
421                     if (!isShiftNot) {
422                         masm.or(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);
423                     } else {
424                         masm.orn(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);
425                     }
426                     break;
427                 case XOR:
428                     if (!isShiftNot) {
429                         masm.eor(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);
430                     } else {
431                         masm.eon(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);
432                     }
433                     break;
434                 default:
435                     throw GraalError.shouldNotReachHere();
436             }
437         }
438     }
439 
440     public static class ExtendedAddShiftOp extends AArch64LIRInstruction {
441         private static final LIRInstructionClass&lt;ExtendedAddShiftOp&gt; TYPE = LIRInstructionClass.create(ExtendedAddShiftOp.class);
442         @Def(REG) protected AllocatableValue result;
443         @Use(REG) protected AllocatableValue src1;
444         @Use(REG) protected AllocatableValue src2;
445         private final AArch64Assembler.ExtendType extendType;
446         private final int shiftAmt;
447 
448         /**
449          * Computes &lt;code&gt;result = src1 + extendType(src2) &lt;&lt; shiftAmt&lt;/code&gt;.
450          *
451          * @param extendType defines how src2 is extended to the same size as src1.
452          * @param shiftAmt must be in range 0 to 4.
453          */
454         public ExtendedAddShiftOp(AllocatableValue result, AllocatableValue src1, AllocatableValue src2, AArch64Assembler.ExtendType extendType, int shiftAmt) {
455             super(TYPE);
456             this.result = result;
457             this.src1 = src1;
458             this.src2 = src2;
459             this.extendType = extendType;
460             this.shiftAmt = shiftAmt;
461         }
462 
463         @Override
464         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
465             int size = result.getPlatformKind().getSizeInBytes() * Byte.SIZE;
466             masm.add(size, asRegister(result), asRegister(src1), asRegister(src2), extendType, shiftAmt);
467         }
468     }
469 
470     public static class MultiplyAddSubOp extends AArch64LIRInstruction {
471         private static final LIRInstructionClass&lt;MultiplyAddSubOp&gt; TYPE = LIRInstructionClass.create(MultiplyAddSubOp.class);
472 
473         @Opcode private final AArch64ArithmeticOp op;
474         @Def(REG) protected AllocatableValue result;
475         @Use(REG) protected AllocatableValue src1;
476         @Use(REG) protected AllocatableValue src2;
477         @Use(REG) protected AllocatableValue src3;
478 
479         /**
<a name="4" id="anc4"></a><span class="line-modified">480          * Computes &lt;code&gt;result = src3 &lt;op&gt; src1 * src2&lt;/code&gt;.</span>
481          */
482         public MultiplyAddSubOp(AArch64ArithmeticOp op, AllocatableValue result, AllocatableValue src1, AllocatableValue src2, AllocatableValue src3) {
483             super(TYPE);
<a name="5" id="anc5"></a><span class="line-removed">484             assert op == ADD || op == SUB;</span>
485             this.op = op;
486             this.result = result;
487             this.src1 = src1;
488             this.src2 = src2;
489             this.src3 = src3;
490         }
491 
492         @Override
493         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
494             int size = result.getPlatformKind().getSizeInBytes() * Byte.SIZE;
495             switch (op) {
<a name="6" id="anc6"></a><span class="line-modified">496                 case ADD:</span>
497                     masm.madd(size, asRegister(result), asRegister(src1), asRegister(src2), asRegister(src3));
498                     break;
<a name="7" id="anc7"></a><span class="line-modified">499                 case SUB:</span>
500                     masm.msub(size, asRegister(result), asRegister(src1), asRegister(src2), asRegister(src3));
501                     break;
<a name="8" id="anc8"></a>










502                 default:
503                     throw GraalError.shouldNotReachHere();
504             }
505         }
506     }
507 
508 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
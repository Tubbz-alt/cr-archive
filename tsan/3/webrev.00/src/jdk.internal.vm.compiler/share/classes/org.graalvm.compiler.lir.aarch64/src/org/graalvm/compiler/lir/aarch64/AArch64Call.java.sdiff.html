<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64Call.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64BitManipulationOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64Compare.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64Call.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2018, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
198      */
199     public static boolean isNearCall(ForeignCallLinkage linkage) {
200         long maxOffset = linkage.getMaxCallTargetOffset();
201         return maxOffset != -1 &amp;&amp; AArch64MacroAssembler.isBranchImmediateOffset(maxOffset);
202     }
203 
204     public static void directCall(CompilationResultBuilder crb, AArch64MacroAssembler masm, InvokeTarget callTarget, Register scratch, LIRFrameState info) {
205         directCall(crb, masm, callTarget, scratch, info, null);
206     }
207 
208     public static void directCall(CompilationResultBuilder crb, AArch64MacroAssembler masm, InvokeTarget callTarget, Register scratch, LIRFrameState info, Label label) {
209         int before = masm.position();
210         if (scratch != null) {
211             if (GeneratePIC.getValue(crb.getOptions())) {
212                 masm.bl(0);
213             } else {
214                 /*
215                  * Offset might not fit into a 28-bit immediate, generate an indirect call with a
216                  * 64-bit immediate address which is fixed up by HotSpot.
217                  */
<span class="line-modified">218                 masm.movNativeAddress(scratch, 0L);</span>
219                 masm.blr(scratch);
220             }
221         } else {
222             // Address is fixed up by HotSpot.
223             masm.bl(0);
224         }
225         if (label != null) {
226             // We need this label to be the return address.
227             masm.bind(label);
228         }
229         int after = masm.position();
230         crb.recordDirectCall(before, after, callTarget, info);
231         crb.recordExceptionHandlers(after, info);
232         masm.ensureUniquePC();
233     }
234 
235     public static void indirectCall(CompilationResultBuilder crb, AArch64MacroAssembler masm, Register dst, InvokeTarget callTarget, LIRFrameState info) {
236         int before = masm.position();
237         masm.blr(dst);
238         int after = masm.position();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2018, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
198      */
199     public static boolean isNearCall(ForeignCallLinkage linkage) {
200         long maxOffset = linkage.getMaxCallTargetOffset();
201         return maxOffset != -1 &amp;&amp; AArch64MacroAssembler.isBranchImmediateOffset(maxOffset);
202     }
203 
204     public static void directCall(CompilationResultBuilder crb, AArch64MacroAssembler masm, InvokeTarget callTarget, Register scratch, LIRFrameState info) {
205         directCall(crb, masm, callTarget, scratch, info, null);
206     }
207 
208     public static void directCall(CompilationResultBuilder crb, AArch64MacroAssembler masm, InvokeTarget callTarget, Register scratch, LIRFrameState info, Label label) {
209         int before = masm.position();
210         if (scratch != null) {
211             if (GeneratePIC.getValue(crb.getOptions())) {
212                 masm.bl(0);
213             } else {
214                 /*
215                  * Offset might not fit into a 28-bit immediate, generate an indirect call with a
216                  * 64-bit immediate address which is fixed up by HotSpot.
217                  */
<span class="line-modified">218                 masm.movNativeAddress(scratch, 0L, true);</span>
219                 masm.blr(scratch);
220             }
221         } else {
222             // Address is fixed up by HotSpot.
223             masm.bl(0);
224         }
225         if (label != null) {
226             // We need this label to be the return address.
227             masm.bind(label);
228         }
229         int after = masm.position();
230         crb.recordDirectCall(before, after, callTarget, info);
231         crb.recordExceptionHandlers(after, info);
232         masm.ensureUniquePC();
233     }
234 
235     public static void indirectCall(CompilationResultBuilder crb, AArch64MacroAssembler masm, Register dst, InvokeTarget callTarget, LIRFrameState info) {
236         int before = masm.position();
237         masm.blr(dst);
238         int after = masm.position();
</pre>
</td>
</tr>
</table>
<center><a href="AArch64BitManipulationOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64Compare.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
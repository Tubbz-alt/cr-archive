<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64Call.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2018, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 package org.graalvm.compiler.lir.aarch64;
 27 
 28 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 29 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;
 30 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
 31 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;
 32 import static jdk.vm.ci.aarch64.AArch64.r8;
 33 import static jdk.vm.ci.code.ValueUtil.asRegister;
 34 import static jdk.vm.ci.code.ValueUtil.isRegister;
 35 
 36 import org.graalvm.compiler.asm.Label;
 37 import org.graalvm.compiler.asm.aarch64.AArch64Assembler;
 38 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 39 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 40 import org.graalvm.compiler.lir.LIRFrameState;
 41 import org.graalvm.compiler.lir.LIRInstructionClass;
 42 import org.graalvm.compiler.lir.Opcode;
 43 import org.graalvm.compiler.lir.StandardOp.LabelHoldingOp;
 44 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 45 
 46 import jdk.vm.ci.code.Register;
 47 import jdk.vm.ci.meta.InvokeTarget;
 48 import jdk.vm.ci.meta.ResolvedJavaMethod;
 49 import jdk.vm.ci.meta.Value;
 50 
 51 public class AArch64Call {
 52 
 53     public abstract static class CallOp extends AArch64LIRInstruction {
 54         @Def({REG, ILLEGAL}) protected Value result;
 55         @Use({REG, STACK}) protected Value[] parameters;
 56         @Temp({REG, STACK}) protected Value[] temps;
 57         @State protected LIRFrameState state;
 58 
 59         protected CallOp(LIRInstructionClass&lt;? extends CallOp&gt; c, Value result, Value[] parameters, Value[] temps, LIRFrameState state) {
 60             super(c);
 61             this.result = result;
 62             this.parameters = parameters;
 63             this.state = state;
 64             this.temps = addStackSlotsToTemporaries(parameters, temps);
 65             assert temps != null;
 66         }
 67 
 68         @Override
 69         public boolean destroysCallerSavedRegisters() {
 70             return true;
 71         }
 72     }
 73 
 74     public abstract static class MethodCallOp extends CallOp {
 75         protected final ResolvedJavaMethod callTarget;
 76 
 77         protected MethodCallOp(LIRInstructionClass&lt;? extends MethodCallOp&gt; c, ResolvedJavaMethod callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState state) {
 78             super(c, result, parameters, temps, state);
 79             this.callTarget = callTarget;
 80         }
 81     }
 82 
 83     @Opcode(&quot;CALL_INDIRECT&quot;)
 84     public static class IndirectCallOp extends MethodCallOp {
 85         public static final LIRInstructionClass&lt;IndirectCallOp&gt; TYPE = LIRInstructionClass.create(IndirectCallOp.class);
 86 
 87         @Use({REG}) protected Value targetAddress;
 88 
 89         public IndirectCallOp(ResolvedJavaMethod callTarget, Value result, Value[] parameters, Value[] temps, Value targetAddress, LIRFrameState state) {
 90             this(TYPE, callTarget, result, parameters, temps, targetAddress, state);
 91         }
 92 
 93         protected IndirectCallOp(LIRInstructionClass&lt;? extends IndirectCallOp&gt; c, ResolvedJavaMethod callTarget, Value result, Value[] parameters, Value[] temps, Value targetAddress,
 94                         LIRFrameState state) {
 95             super(c, callTarget, result, parameters, temps, state);
 96             this.targetAddress = targetAddress;
 97         }
 98 
 99         @Override
100         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
101             Register target = asRegister(targetAddress);
102             indirectCall(crb, masm, target, callTarget, state);
103         }
104 
105         @Override
106         public void verify() {
107             super.verify();
108             assert isRegister(targetAddress) : &quot;The current register allocator cannot handle variables to be used at call sites, &quot; + &quot;it must be in a fixed register for now&quot;;
109         }
110     }
111 
112     @Opcode(&quot;CALL_DIRECT&quot;)
113     public abstract static class DirectCallOp extends MethodCallOp {
114         public static final LIRInstructionClass&lt;DirectCallOp&gt; TYPE = LIRInstructionClass.create(DirectCallOp.class);
115 
116         public DirectCallOp(ResolvedJavaMethod target, Value result, Value[] parameters, Value[] temps, LIRFrameState state) {
117             super(TYPE, target, result, parameters, temps, state);
118         }
119 
120         protected DirectCallOp(LIRInstructionClass&lt;? extends DirectCallOp&gt; c, ResolvedJavaMethod callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState state) {
121             super(c, callTarget, result, parameters, temps, state);
122         }
123 
124         @Override
125         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
126             directCall(crb, masm, callTarget, null, state);
127         }
128     }
129 
130     public abstract static class ForeignCallOp extends CallOp implements LabelHoldingOp {
131         protected final ForeignCallLinkage callTarget;
132         protected final Label label;
133 
134         protected ForeignCallOp(LIRInstructionClass&lt;? extends ForeignCallOp&gt; c, ForeignCallLinkage callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState state, Label label) {
135             super(c, result, parameters, temps, state);
136             this.callTarget = callTarget;
137             this.label = label;
138         }
139 
140         @Override
141         public boolean destroysCallerSavedRegisters() {
142             return callTarget.destroysRegisters();
143         }
144 
145         @Override
146         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
147             emitCall(crb, masm);
148         }
149 
150         protected abstract void emitCall(CompilationResultBuilder crb, AArch64MacroAssembler masm);
151 
152         @Override
153         public Label getLabel() {
154             return label;
155         }
156     }
157 
158     @Opcode(&quot;NEAR_FOREIGN_CALL&quot;)
159     public static class DirectNearForeignCallOp extends ForeignCallOp {
160         public static final LIRInstructionClass&lt;DirectNearForeignCallOp&gt; TYPE = LIRInstructionClass.create(DirectNearForeignCallOp.class);
161 
162         public DirectNearForeignCallOp(ForeignCallLinkage callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState state, Label label) {
163             super(TYPE, callTarget, result, parameters, temps, state, label);
164         }
165 
166         @Override
167         protected void emitCall(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
168             directCall(crb, masm, callTarget, null, state, label);
169         }
170     }
171 
172     @Opcode(&quot;FAR_FOREIGN_CALL&quot;)
173     public static class DirectFarForeignCallOp extends ForeignCallOp {
174         public static final LIRInstructionClass&lt;DirectFarForeignCallOp&gt; TYPE = LIRInstructionClass.create(DirectFarForeignCallOp.class);
175 
176         public DirectFarForeignCallOp(ForeignCallLinkage callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState state, Label label) {
177             super(TYPE, callTarget, result, parameters, temps, state, label);
178         }
179 
180         @Override
181         protected void emitCall(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
182             // We can use any scratch register we want, since we know that they have been saved
183             // before calling.
184             directCall(crb, masm, callTarget, r8, state, label);
185         }
186     }
187 
188     /**
189      * Tests whether linkage can be called directly under all circumstances without the need for a
190      * scratch register.
191      *
192      * Note this is a pessimistic assumption: This may return false despite a near call/jump being
193      * adequate.
194      *
195      * @param linkage Foreign call description
196      * @return true if foreign call can be called directly and does not need a scratch register to
197      *         load the address into.
198      */
199     public static boolean isNearCall(ForeignCallLinkage linkage) {
200         long maxOffset = linkage.getMaxCallTargetOffset();
201         return maxOffset != -1 &amp;&amp; AArch64MacroAssembler.isBranchImmediateOffset(maxOffset);
202     }
203 
204     public static void directCall(CompilationResultBuilder crb, AArch64MacroAssembler masm, InvokeTarget callTarget, Register scratch, LIRFrameState info) {
205         directCall(crb, masm, callTarget, scratch, info, null);
206     }
207 
208     public static void directCall(CompilationResultBuilder crb, AArch64MacroAssembler masm, InvokeTarget callTarget, Register scratch, LIRFrameState info, Label label) {
209         int before = masm.position();
210         if (scratch != null) {
211             if (GeneratePIC.getValue(crb.getOptions())) {
212                 masm.bl(0);
213             } else {
214                 /*
215                  * Offset might not fit into a 28-bit immediate, generate an indirect call with a
216                  * 64-bit immediate address which is fixed up by HotSpot.
217                  */
<a name="2" id="anc2"></a><span class="line-modified">218                 masm.movNativeAddress(scratch, 0L);</span>
219                 masm.blr(scratch);
220             }
221         } else {
222             // Address is fixed up by HotSpot.
223             masm.bl(0);
224         }
225         if (label != null) {
226             // We need this label to be the return address.
227             masm.bind(label);
228         }
229         int after = masm.position();
230         crb.recordDirectCall(before, after, callTarget, info);
231         crb.recordExceptionHandlers(after, info);
232         masm.ensureUniquePC();
233     }
234 
235     public static void indirectCall(CompilationResultBuilder crb, AArch64MacroAssembler masm, Register dst, InvokeTarget callTarget, LIRFrameState info) {
236         int before = masm.position();
237         masm.blr(dst);
238         int after = masm.position();
239         crb.recordIndirectCall(before, after, callTarget, info);
240         crb.recordExceptionHandlers(after, info);
241         masm.ensureUniquePC();
242     }
243 
244     public static void directJmp(CompilationResultBuilder crb, AArch64MacroAssembler masm, InvokeTarget callTarget) {
245         try (AArch64MacroAssembler.ScratchRegister scratch = masm.getScratchRegister()) {
246             int before = masm.position();
247             if (GeneratePIC.getValue(crb.getOptions())) {
248                 masm.jmp();
249             } else {
250                 masm.movNativeAddress(scratch.getRegister(), 0L);
251                 masm.jmp(scratch.getRegister());
252             }
253             int after = masm.position();
254             crb.recordDirectCall(before, after, callTarget, null);
255             masm.ensureUniquePC();
256         }
257     }
258 
259     public static void indirectJmp(CompilationResultBuilder crb, AArch64MacroAssembler masm, Register dst, InvokeTarget target) {
260         int before = masm.position();
261         masm.jmp(dst);
262         int after = masm.position();
263         crb.recordIndirectCall(before, after, target, null);
264         masm.ensureUniquePC();
265     }
266 
267     public static void directConditionalJmp(CompilationResultBuilder crb, AArch64MacroAssembler masm, InvokeTarget target, AArch64Assembler.ConditionFlag cond) {
268         int before = masm.position();
269         masm.branchConditionally(cond);
270         int after = masm.position();
271         crb.recordDirectCall(before, after, target, null);
272         masm.ensureUniquePC();
273     }
274 
275 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
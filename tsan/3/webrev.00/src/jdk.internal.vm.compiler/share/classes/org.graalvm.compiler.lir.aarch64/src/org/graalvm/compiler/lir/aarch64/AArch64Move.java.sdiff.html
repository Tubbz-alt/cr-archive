<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64Move.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64ControlFlow.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64RestoreRegistersOp.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64Move.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.aarch64;
 26 
 27 import static jdk.vm.ci.aarch64.AArch64.sp;
 28 import static jdk.vm.ci.aarch64.AArch64.zr;
 29 import static jdk.vm.ci.code.ValueUtil.asAllocatableValue;
 30 import static jdk.vm.ci.code.ValueUtil.asRegister;
 31 import static jdk.vm.ci.code.ValueUtil.asStackSlot;
 32 import static jdk.vm.ci.code.ValueUtil.isRegister;
 33 import static jdk.vm.ci.code.ValueUtil.isStackSlot;

 34 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.COMPOSITE;

 35 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;

 36 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
 37 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;
 38 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.UNINITIALIZED;
 39 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 40 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 41 

 42 import org.graalvm.compiler.asm.aarch64.AArch64Address;

 43 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 44 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.ScratchRegister;

 45 import org.graalvm.compiler.core.common.LIRKind;

 46 import org.graalvm.compiler.core.common.type.DataPointerConstant;
 47 import org.graalvm.compiler.debug.GraalError;
 48 import org.graalvm.compiler.lir.LIRFrameState;
 49 import org.graalvm.compiler.lir.LIRInstructionClass;
 50 import org.graalvm.compiler.lir.Opcode;
 51 import org.graalvm.compiler.lir.StandardOp;
 52 import org.graalvm.compiler.lir.StandardOp.LoadConstantOp;
 53 import org.graalvm.compiler.lir.StandardOp.NullCheck;
 54 import org.graalvm.compiler.lir.StandardOp.ValueMoveOp;
 55 import org.graalvm.compiler.lir.VirtualStackSlot;
 56 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;

 57 
 58 import jdk.vm.ci.aarch64.AArch64Kind;
 59 import jdk.vm.ci.code.MemoryBarriers;
 60 import jdk.vm.ci.code.Register;
 61 import jdk.vm.ci.code.StackSlot;
 62 import jdk.vm.ci.meta.AllocatableValue;
 63 import jdk.vm.ci.meta.Constant;
 64 import jdk.vm.ci.meta.JavaConstant;
 65 import jdk.vm.ci.meta.PlatformKind;
 66 import jdk.vm.ci.meta.Value;
 67 
 68 public class AArch64Move {
 69 
 70     public static class LoadInlineConstant extends AArch64LIRInstruction implements LoadConstantOp {
 71         public static final LIRInstructionClass&lt;LoadInlineConstant&gt; TYPE = LIRInstructionClass.create(LoadInlineConstant.class);
 72 
 73         private JavaConstant constant;
 74         @Def({REG, STACK}) AllocatableValue result;
 75 
 76         public LoadInlineConstant(JavaConstant constant, AllocatableValue result) {
</pre>
<hr />
<pre>
230         }
231     }
232 
233     abstract static class MemOp extends AArch64LIRInstruction implements StandardOp.ImplicitNullCheck {
234 
235         protected final AArch64Kind kind;
236         @Use({COMPOSITE}) protected AArch64AddressValue addressValue;
237         @State protected LIRFrameState state;
238 
239         MemOp(LIRInstructionClass&lt;? extends MemOp&gt; c, AArch64Kind kind, AArch64AddressValue address, LIRFrameState state) {
240             super(c);
241             this.kind = kind;
242             this.addressValue = address;
243             this.state = state;
244         }
245 
246         protected abstract void emitMemAccess(CompilationResultBuilder crb, AArch64MacroAssembler masm);
247 
248         @Override
249         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {


250             if (state != null) {
<span class="line-modified">251                 crb.recordImplicitException(masm.position(), state);</span>








252             }
<span class="line-removed">253             emitMemAccess(crb, masm);</span>
254         }
255 
256         @Override
257         public boolean makeNullCheckFor(Value value, LIRFrameState nullCheckState, int implicitNullCheckLimit) {
258             int displacement = addressValue.getDisplacement();
259             if (state == null &amp;&amp; value.equals(addressValue.getBase()) &amp;&amp; addressValue.getOffset().equals(Value.ILLEGAL) &amp;&amp; displacement &gt;= 0 &amp;&amp; displacement &lt; implicitNullCheckLimit) {
260                 state = nullCheckState;
261                 return true;
262             }
263             return false;
264         }
265     }
266 
267     public static final class LoadOp extends MemOp {
268         public static final LIRInstructionClass&lt;LoadOp&gt; TYPE = LIRInstructionClass.create(LoadOp.class);
269 
270         @Def protected AllocatableValue result;
271 
272         public LoadOp(AArch64Kind kind, AllocatableValue result, AArch64AddressValue address, LIRFrameState state) {
273             super(TYPE, kind, address, state);
</pre>
<hr />
<pre>
321         @Override
322         public void emitMemAccess(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
323             emitStore(crb, masm, kind, addressValue.toAddress(), zr.asValue(LIRKind.combine(addressValue)));
324         }
325     }
326 
327     public static final class NullCheckOp extends AArch64LIRInstruction implements NullCheck {
328         public static final LIRInstructionClass&lt;NullCheckOp&gt; TYPE = LIRInstructionClass.create(NullCheckOp.class);
329 
330         @Use(COMPOSITE) protected AArch64AddressValue address;
331         @State protected LIRFrameState state;
332 
333         public NullCheckOp(AArch64AddressValue address, LIRFrameState state) {
334             super(TYPE);
335             this.address = address;
336             this.state = state;
337         }
338 
339         @Override
340         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
<span class="line-modified">341             crb.recordImplicitException(masm.position(), state);</span>
342             masm.ldr(64, zr, address.toAddress());









343         }
344 
345         @Override
346         public Value getCheckedValue() {
347             return address.base;
348         }
349 
350         @Override
351         public LIRFrameState getState() {
352             return state;
353         }
354     }
355 
356     private static void emitStore(@SuppressWarnings(&quot;unused&quot;) CompilationResultBuilder crb, AArch64MacroAssembler masm, AArch64Kind kind, AArch64Address dst, Value src) {
357         int destSize = kind.getSizeInBytes() * Byte.SIZE;
358         if (kind.isInteger()) {
359             masm.str(destSize, asRegister(src), dst);
360         } else {
361             masm.fstr(destSize, asRegister(src), dst);
362         }
</pre>
<hr />
<pre>
408             }
409         }
410     }
411 
412     private static void reg2reg(@SuppressWarnings(&quot;unused&quot;) CompilationResultBuilder crb, AArch64MacroAssembler masm, AllocatableValue result, AllocatableValue input) {
413         Register dst = asRegister(result);
414         Register src = asRegister(input);
415         if (src.equals(dst)) {
416             return;
417         }
418         AArch64Kind kind = (AArch64Kind) input.getPlatformKind();
419         int size = kind.getSizeInBytes() * Byte.SIZE;
420         if (kind.isInteger()) {
421             masm.mov(size, dst, src);
422         } else {
423             masm.fmov(size, dst, src);
424         }
425     }
426 
427     static void reg2stack(CompilationResultBuilder crb, AArch64MacroAssembler masm, AllocatableValue result, AllocatableValue input) {
<span class="line-modified">428         AArch64Address dest = loadStackSlotAddress(crb, masm, asStackSlot(result), Value.ILLEGAL);</span>



429         Register src = asRegister(input);
430         // use the slot kind to define the operand size
431         AArch64Kind kind = (AArch64Kind) result.getPlatformKind();
432         final int size = kind.getSizeInBytes() * Byte.SIZE;
433         if (kind.isInteger()) {
434             masm.str(size, src, dest);
435         } else {
436             masm.fstr(size, src, dest);
437         }
438     }
439 
440     static void stack2reg(CompilationResultBuilder crb, AArch64MacroAssembler masm, AllocatableValue result, AllocatableValue input) {
441         AArch64Kind kind = (AArch64Kind) input.getPlatformKind();
442         // use the slot kind to define the operand size
443         final int size = kind.getSizeInBytes() * Byte.SIZE;
444         if (kind.isInteger()) {
445             AArch64Address src = loadStackSlotAddress(crb, masm, asStackSlot(input), result);
446             masm.ldr(size, asRegister(result), src);
447         } else {
448             try (ScratchRegister sc = masm.getScratchRegister()) {
</pre>
<hr />
<pre>
472                         maskedValue = value;
473                         break;
474                     default:
475                         throw GraalError.shouldNotReachHere();
476                 }
477                 masm.mov(dst, maskedValue);
478                 break;
479             case Long:
480                 masm.mov(dst, input.asLong());
481                 break;
482             case Float:
483                 if (AArch64MacroAssembler.isFloatImmediate(input.asFloat())) {
484                     masm.fmov(32, dst, input.asFloat());
485                 } else if (crb.compilationResult.isImmutablePIC()) {
486                     try (ScratchRegister scr = masm.getScratchRegister()) {
487                         Register scratch = scr.getRegister();
488                         masm.mov(scratch, Float.floatToRawIntBits(input.asFloat()));
489                         masm.fmov(32, dst, scratch);
490                     }
491                 } else {
<span class="line-modified">492                     masm.fldr(32, dst, (AArch64Address) crb.asFloatConstRef(input));</span>





493                 }
494                 break;
495             case Double:
496                 if (AArch64MacroAssembler.isDoubleImmediate(input.asDouble())) {
497                     masm.fmov(64, dst, input.asDouble());
498                 } else if (crb.compilationResult.isImmutablePIC()) {
499                     try (ScratchRegister scr = masm.getScratchRegister()) {
500                         Register scratch = scr.getRegister();
501                         masm.mov(scratch, Double.doubleToRawLongBits(input.asDouble()));
502                         masm.fmov(64, dst, scratch);
503                     }
504                 } else {
<span class="line-modified">505                     masm.fldr(64, dst, (AArch64Address) crb.asDoubleConstRef(input));</span>





506                 }
507                 break;
508             case Object:
509                 if (input.isNull()) {
<span class="line-modified">510                     masm.mov(dst, 0);</span>




511                 } else if (crb.target.inlineObjects) {
512                     crb.recordInlineDataInCode(input);
<span class="line-modified">513                     masm.movNativeAddress(dst, 0xDEADDEADDEADDEADL);</span>
514                 } else {
515                     masm.ldr(64, dst, (AArch64Address) crb.recordDataReferenceInCode(input, 8));
516                 }
517                 break;
518             default:
519                 throw GraalError.shouldNotReachHere(&quot;kind=&quot; + input.getJavaKind().getStackKind());
520         }
521     }
522 
523     private static void const2stack(CompilationResultBuilder crb, AArch64MacroAssembler masm, Value result, JavaConstant constant) {
524         try (ScratchRegister addrReg = masm.getScratchRegister()) {
525             StackSlot slot = (StackSlot) result;
526             AArch64Address resultAddress = loadStackSlotAddress(crb, masm, slot, addrReg.getRegister());
<span class="line-modified">527             if (constant.isDefaultForKind() || constant.isNull()) {</span>
528                 emitStore(crb, masm, (AArch64Kind) result.getPlatformKind(), resultAddress, zr.asValue(LIRKind.combine(result)));
529             } else {
530                 try (ScratchRegister sc = masm.getScratchRegister()) {
531                     Value scratchRegisterValue = sc.getRegister().asValue(LIRKind.combine(result));
532                     const2reg(crb, masm, scratchRegisterValue, constant);
533                     emitStore(crb, masm, (AArch64Kind) result.getPlatformKind(), resultAddress, scratchRegisterValue);
534                 }
535             }
536         }
537     }
538 
539     /**
540      * Returns AArch64Address of given StackSlot. We cannot use CompilationResultBuilder.asAddress
541      * since this calls AArch64MacroAssembler.makeAddress with displacements that may be larger than
542      * 9-bit signed, which cannot be handled by that method.
543      *
544      * Instead we create an address ourselves. We use scaled unsigned addressing since we know the
545      * transfersize, which gives us a 15-bit address range (for longs/doubles) respectively a 14-bit
546      * range (for everything else).
547      *
548      * @param scratch Scratch register that can be used to load address. If Value.ILLEGAL this
549      *            instruction fails if we try to access a StackSlot that is too large to be loaded
550      *            directly.
551      * @return AArch64Address of given StackSlot. Uses scratch register if necessary to do so.
552      */
553     private static AArch64Address loadStackSlotAddress(CompilationResultBuilder crb, AArch64MacroAssembler masm, StackSlot slot, AllocatableValue scratch) {
554         Register scratchReg = Value.ILLEGAL.equals(scratch) ? zr : asRegister(scratch);
555         return loadStackSlotAddress(crb, masm, slot, scratchReg);
556     }
557 
558     private static AArch64Address loadStackSlotAddress(CompilationResultBuilder crb, AArch64MacroAssembler masm, StackSlot slot, Register scratchReg) {
559         int displacement = crb.frameMap.offsetForStackSlot(slot);
560         int transferSize = slot.getPlatformKind().getSizeInBytes();
561         return masm.makeAddress(sp, displacement, scratchReg, transferSize, /* allowOverwrite */false);
562     }
563 


































































































































































































564 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.aarch64;
 26 
 27 import static jdk.vm.ci.aarch64.AArch64.sp;
 28 import static jdk.vm.ci.aarch64.AArch64.zr;
 29 import static jdk.vm.ci.code.ValueUtil.asAllocatableValue;
 30 import static jdk.vm.ci.code.ValueUtil.asRegister;
 31 import static jdk.vm.ci.code.ValueUtil.asStackSlot;
 32 import static jdk.vm.ci.code.ValueUtil.isRegister;
 33 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
<span class="line-added"> 34 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;</span>
 35 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.COMPOSITE;
<span class="line-added"> 36 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.CONST;</span>
 37 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;
<span class="line-added"> 38 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
 39 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
 40 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;
 41 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.UNINITIALIZED;
 42 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 43 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 44 
<span class="line-added"> 45 import org.graalvm.compiler.asm.Label;</span>
 46 import org.graalvm.compiler.asm.aarch64.AArch64Address;
<span class="line-added"> 47 import org.graalvm.compiler.asm.aarch64.AArch64Assembler;</span>
 48 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 49 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.ScratchRegister;
<span class="line-added"> 50 import org.graalvm.compiler.core.common.CompressEncoding;</span>
 51 import org.graalvm.compiler.core.common.LIRKind;
<span class="line-added"> 52 import org.graalvm.compiler.core.common.spi.LIRKindTool;</span>
 53 import org.graalvm.compiler.core.common.type.DataPointerConstant;
 54 import org.graalvm.compiler.debug.GraalError;
 55 import org.graalvm.compiler.lir.LIRFrameState;
 56 import org.graalvm.compiler.lir.LIRInstructionClass;
 57 import org.graalvm.compiler.lir.Opcode;
 58 import org.graalvm.compiler.lir.StandardOp;
 59 import org.graalvm.compiler.lir.StandardOp.LoadConstantOp;
 60 import org.graalvm.compiler.lir.StandardOp.NullCheck;
 61 import org.graalvm.compiler.lir.StandardOp.ValueMoveOp;
 62 import org.graalvm.compiler.lir.VirtualStackSlot;
 63 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
<span class="line-added"> 64 import org.graalvm.compiler.options.OptionValues;</span>
 65 
 66 import jdk.vm.ci.aarch64.AArch64Kind;
 67 import jdk.vm.ci.code.MemoryBarriers;
 68 import jdk.vm.ci.code.Register;
 69 import jdk.vm.ci.code.StackSlot;
 70 import jdk.vm.ci.meta.AllocatableValue;
 71 import jdk.vm.ci.meta.Constant;
 72 import jdk.vm.ci.meta.JavaConstant;
 73 import jdk.vm.ci.meta.PlatformKind;
 74 import jdk.vm.ci.meta.Value;
 75 
 76 public class AArch64Move {
 77 
 78     public static class LoadInlineConstant extends AArch64LIRInstruction implements LoadConstantOp {
 79         public static final LIRInstructionClass&lt;LoadInlineConstant&gt; TYPE = LIRInstructionClass.create(LoadInlineConstant.class);
 80 
 81         private JavaConstant constant;
 82         @Def({REG, STACK}) AllocatableValue result;
 83 
 84         public LoadInlineConstant(JavaConstant constant, AllocatableValue result) {
</pre>
<hr />
<pre>
238         }
239     }
240 
241     abstract static class MemOp extends AArch64LIRInstruction implements StandardOp.ImplicitNullCheck {
242 
243         protected final AArch64Kind kind;
244         @Use({COMPOSITE}) protected AArch64AddressValue addressValue;
245         @State protected LIRFrameState state;
246 
247         MemOp(LIRInstructionClass&lt;? extends MemOp&gt; c, AArch64Kind kind, AArch64AddressValue address, LIRFrameState state) {
248             super(c);
249             this.kind = kind;
250             this.addressValue = address;
251             this.state = state;
252         }
253 
254         protected abstract void emitMemAccess(CompilationResultBuilder crb, AArch64MacroAssembler masm);
255 
256         @Override
257         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
<span class="line-added">258             int prePosition = masm.position();</span>
<span class="line-added">259             emitMemAccess(crb, masm);</span>
260             if (state != null) {
<span class="line-modified">261                 int implicitExceptionPosition = prePosition;</span>
<span class="line-added">262                 // Adjust implicit exception position if this ldr/str has been merged to ldp/stp.</span>
<span class="line-added">263                 if (kind.isInteger() &amp;&amp; prePosition == masm.position() &amp;&amp; masm.isImmLoadStoreMerged()) {</span>
<span class="line-added">264                     implicitExceptionPosition = prePosition - 4;</span>
<span class="line-added">265                     if (crb.isImplicitExceptionExist(implicitExceptionPosition)) {</span>
<span class="line-added">266                         return;</span>
<span class="line-added">267                     }</span>
<span class="line-added">268                 }</span>
<span class="line-added">269                 crb.recordImplicitException(implicitExceptionPosition, state);</span>
270             }

271         }
272 
273         @Override
274         public boolean makeNullCheckFor(Value value, LIRFrameState nullCheckState, int implicitNullCheckLimit) {
275             int displacement = addressValue.getDisplacement();
276             if (state == null &amp;&amp; value.equals(addressValue.getBase()) &amp;&amp; addressValue.getOffset().equals(Value.ILLEGAL) &amp;&amp; displacement &gt;= 0 &amp;&amp; displacement &lt; implicitNullCheckLimit) {
277                 state = nullCheckState;
278                 return true;
279             }
280             return false;
281         }
282     }
283 
284     public static final class LoadOp extends MemOp {
285         public static final LIRInstructionClass&lt;LoadOp&gt; TYPE = LIRInstructionClass.create(LoadOp.class);
286 
287         @Def protected AllocatableValue result;
288 
289         public LoadOp(AArch64Kind kind, AllocatableValue result, AArch64AddressValue address, LIRFrameState state) {
290             super(TYPE, kind, address, state);
</pre>
<hr />
<pre>
338         @Override
339         public void emitMemAccess(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
340             emitStore(crb, masm, kind, addressValue.toAddress(), zr.asValue(LIRKind.combine(addressValue)));
341         }
342     }
343 
344     public static final class NullCheckOp extends AArch64LIRInstruction implements NullCheck {
345         public static final LIRInstructionClass&lt;NullCheckOp&gt; TYPE = LIRInstructionClass.create(NullCheckOp.class);
346 
347         @Use(COMPOSITE) protected AArch64AddressValue address;
348         @State protected LIRFrameState state;
349 
350         public NullCheckOp(AArch64AddressValue address, LIRFrameState state) {
351             super(TYPE);
352             this.address = address;
353             this.state = state;
354         }
355 
356         @Override
357         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
<span class="line-modified">358             int prePosition = masm.position();</span>
359             masm.ldr(64, zr, address.toAddress());
<span class="line-added">360             int implicitExceptionPosition = prePosition;</span>
<span class="line-added">361             // Adjust implicit exception position if this ldr has been merged to ldp.</span>
<span class="line-added">362             if (prePosition == masm.position() &amp;&amp; masm.isImmLoadStoreMerged()) {</span>
<span class="line-added">363                 implicitExceptionPosition = prePosition - 4;</span>
<span class="line-added">364                 if (crb.isImplicitExceptionExist(implicitExceptionPosition)) {</span>
<span class="line-added">365                     return;</span>
<span class="line-added">366                 }</span>
<span class="line-added">367             }</span>
<span class="line-added">368             crb.recordImplicitException(implicitExceptionPosition, state);</span>
369         }
370 
371         @Override
372         public Value getCheckedValue() {
373             return address.base;
374         }
375 
376         @Override
377         public LIRFrameState getState() {
378             return state;
379         }
380     }
381 
382     private static void emitStore(@SuppressWarnings(&quot;unused&quot;) CompilationResultBuilder crb, AArch64MacroAssembler masm, AArch64Kind kind, AArch64Address dst, Value src) {
383         int destSize = kind.getSizeInBytes() * Byte.SIZE;
384         if (kind.isInteger()) {
385             masm.str(destSize, asRegister(src), dst);
386         } else {
387             masm.fstr(destSize, asRegister(src), dst);
388         }
</pre>
<hr />
<pre>
434             }
435         }
436     }
437 
438     private static void reg2reg(@SuppressWarnings(&quot;unused&quot;) CompilationResultBuilder crb, AArch64MacroAssembler masm, AllocatableValue result, AllocatableValue input) {
439         Register dst = asRegister(result);
440         Register src = asRegister(input);
441         if (src.equals(dst)) {
442             return;
443         }
444         AArch64Kind kind = (AArch64Kind) input.getPlatformKind();
445         int size = kind.getSizeInBytes() * Byte.SIZE;
446         if (kind.isInteger()) {
447             masm.mov(size, dst, src);
448         } else {
449             masm.fmov(size, dst, src);
450         }
451     }
452 
453     static void reg2stack(CompilationResultBuilder crb, AArch64MacroAssembler masm, AllocatableValue result, AllocatableValue input) {
<span class="line-modified">454         AArch64Address dest;</span>
<span class="line-added">455         try (ScratchRegister scratch = masm.getScratchRegister()) {</span>
<span class="line-added">456             dest = loadStackSlotAddress(crb, masm, asStackSlot(result), scratch.getRegister());</span>
<span class="line-added">457         }</span>
458         Register src = asRegister(input);
459         // use the slot kind to define the operand size
460         AArch64Kind kind = (AArch64Kind) result.getPlatformKind();
461         final int size = kind.getSizeInBytes() * Byte.SIZE;
462         if (kind.isInteger()) {
463             masm.str(size, src, dest);
464         } else {
465             masm.fstr(size, src, dest);
466         }
467     }
468 
469     static void stack2reg(CompilationResultBuilder crb, AArch64MacroAssembler masm, AllocatableValue result, AllocatableValue input) {
470         AArch64Kind kind = (AArch64Kind) input.getPlatformKind();
471         // use the slot kind to define the operand size
472         final int size = kind.getSizeInBytes() * Byte.SIZE;
473         if (kind.isInteger()) {
474             AArch64Address src = loadStackSlotAddress(crb, masm, asStackSlot(input), result);
475             masm.ldr(size, asRegister(result), src);
476         } else {
477             try (ScratchRegister sc = masm.getScratchRegister()) {
</pre>
<hr />
<pre>
501                         maskedValue = value;
502                         break;
503                     default:
504                         throw GraalError.shouldNotReachHere();
505                 }
506                 masm.mov(dst, maskedValue);
507                 break;
508             case Long:
509                 masm.mov(dst, input.asLong());
510                 break;
511             case Float:
512                 if (AArch64MacroAssembler.isFloatImmediate(input.asFloat())) {
513                     masm.fmov(32, dst, input.asFloat());
514                 } else if (crb.compilationResult.isImmutablePIC()) {
515                     try (ScratchRegister scr = masm.getScratchRegister()) {
516                         Register scratch = scr.getRegister();
517                         masm.mov(scratch, Float.floatToRawIntBits(input.asFloat()));
518                         masm.fmov(32, dst, scratch);
519                     }
520                 } else {
<span class="line-modified">521                     try (ScratchRegister scr = masm.getScratchRegister()) {</span>
<span class="line-added">522                         Register scratch = scr.getRegister();</span>
<span class="line-added">523                         crb.asFloatConstRef(input);</span>
<span class="line-added">524                         masm.addressOf(scratch);</span>
<span class="line-added">525                         masm.fldr(32, dst, AArch64Address.createBaseRegisterOnlyAddress(scratch));</span>
<span class="line-added">526                     }</span>
527                 }
528                 break;
529             case Double:
530                 if (AArch64MacroAssembler.isDoubleImmediate(input.asDouble())) {
531                     masm.fmov(64, dst, input.asDouble());
532                 } else if (crb.compilationResult.isImmutablePIC()) {
533                     try (ScratchRegister scr = masm.getScratchRegister()) {
534                         Register scratch = scr.getRegister();
535                         masm.mov(scratch, Double.doubleToRawLongBits(input.asDouble()));
536                         masm.fmov(64, dst, scratch);
537                     }
538                 } else {
<span class="line-modified">539                     try (ScratchRegister scr = masm.getScratchRegister()) {</span>
<span class="line-added">540                         Register scratch = scr.getRegister();</span>
<span class="line-added">541                         crb.asDoubleConstRef(input);</span>
<span class="line-added">542                         masm.addressOf(scratch);</span>
<span class="line-added">543                         masm.fldr(64, dst, AArch64Address.createBaseRegisterOnlyAddress(scratch));</span>
<span class="line-added">544                     }</span>
545                 }
546                 break;
547             case Object:
548                 if (input.isNull()) {
<span class="line-modified">549                     if (crb.mustReplaceWithUncompressedNullRegister(input)) {</span>
<span class="line-added">550                         masm.mov(64, dst, crb.uncompressedNullRegister);</span>
<span class="line-added">551                     } else {</span>
<span class="line-added">552                         masm.mov(dst, 0);</span>
<span class="line-added">553                     }</span>
554                 } else if (crb.target.inlineObjects) {
555                     crb.recordInlineDataInCode(input);
<span class="line-modified">556                     masm.mov(dst, 0xDEADDEADDEADDEADL, true);</span>
557                 } else {
558                     masm.ldr(64, dst, (AArch64Address) crb.recordDataReferenceInCode(input, 8));
559                 }
560                 break;
561             default:
562                 throw GraalError.shouldNotReachHere(&quot;kind=&quot; + input.getJavaKind().getStackKind());
563         }
564     }
565 
566     private static void const2stack(CompilationResultBuilder crb, AArch64MacroAssembler masm, Value result, JavaConstant constant) {
567         try (ScratchRegister addrReg = masm.getScratchRegister()) {
568             StackSlot slot = (StackSlot) result;
569             AArch64Address resultAddress = loadStackSlotAddress(crb, masm, slot, addrReg.getRegister());
<span class="line-modified">570             if (constant.isNull() &amp;&amp; !crb.mustReplaceWithUncompressedNullRegister(constant)) {</span>
571                 emitStore(crb, masm, (AArch64Kind) result.getPlatformKind(), resultAddress, zr.asValue(LIRKind.combine(result)));
572             } else {
573                 try (ScratchRegister sc = masm.getScratchRegister()) {
574                     Value scratchRegisterValue = sc.getRegister().asValue(LIRKind.combine(result));
575                     const2reg(crb, masm, scratchRegisterValue, constant);
576                     emitStore(crb, masm, (AArch64Kind) result.getPlatformKind(), resultAddress, scratchRegisterValue);
577                 }
578             }
579         }
580     }
581 
582     /**
583      * Returns AArch64Address of given StackSlot. We cannot use CompilationResultBuilder.asAddress
584      * since this calls AArch64MacroAssembler.makeAddress with displacements that may be larger than
585      * 9-bit signed, which cannot be handled by that method.
586      *
587      * Instead we create an address ourselves. We use scaled unsigned addressing since we know the
588      * transfersize, which gives us a 15-bit address range (for longs/doubles) respectively a 14-bit
589      * range (for everything else).
590      *
591      * @param scratch Scratch register that can be used to load address. If Value.ILLEGAL this
592      *            instruction fails if we try to access a StackSlot that is too large to be loaded
593      *            directly.
594      * @return AArch64Address of given StackSlot. Uses scratch register if necessary to do so.
595      */
596     private static AArch64Address loadStackSlotAddress(CompilationResultBuilder crb, AArch64MacroAssembler masm, StackSlot slot, AllocatableValue scratch) {
597         Register scratchReg = Value.ILLEGAL.equals(scratch) ? zr : asRegister(scratch);
598         return loadStackSlotAddress(crb, masm, slot, scratchReg);
599     }
600 
601     private static AArch64Address loadStackSlotAddress(CompilationResultBuilder crb, AArch64MacroAssembler masm, StackSlot slot, Register scratchReg) {
602         int displacement = crb.frameMap.offsetForStackSlot(slot);
603         int transferSize = slot.getPlatformKind().getSizeInBytes();
604         return masm.makeAddress(sp, displacement, scratchReg, transferSize, /* allowOverwrite */false);
605     }
606 
<span class="line-added">607     public abstract static class PointerCompressionOp extends AArch64LIRInstruction {</span>
<span class="line-added">608 </span>
<span class="line-added">609         @Def({REG, HINT}) private AllocatableValue result;</span>
<span class="line-added">610         @Use({REG, CONST}) private Value input;</span>
<span class="line-added">611         @Alive({REG, ILLEGAL, UNINITIALIZED}) private AllocatableValue baseRegister;</span>
<span class="line-added">612 </span>
<span class="line-added">613         protected final CompressEncoding encoding;</span>
<span class="line-added">614         protected final boolean nonNull;</span>
<span class="line-added">615         protected final LIRKindTool lirKindTool;</span>
<span class="line-added">616 </span>
<span class="line-added">617         protected PointerCompressionOp(LIRInstructionClass&lt;? extends PointerCompressionOp&gt; type, AllocatableValue result, Value input,</span>
<span class="line-added">618                         AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {</span>
<span class="line-added">619 </span>
<span class="line-added">620             super(type);</span>
<span class="line-added">621             this.result = result;</span>
<span class="line-added">622             this.input = input;</span>
<span class="line-added">623             this.baseRegister = baseRegister;</span>
<span class="line-added">624             this.encoding = encoding;</span>
<span class="line-added">625             this.nonNull = nonNull;</span>
<span class="line-added">626             this.lirKindTool = lirKindTool;</span>
<span class="line-added">627         }</span>
<span class="line-added">628 </span>
<span class="line-added">629         public static boolean hasBase(OptionValues options, CompressEncoding encoding) {</span>
<span class="line-added">630             return GeneratePIC.getValue(options) || encoding.hasBase();</span>
<span class="line-added">631         }</span>
<span class="line-added">632 </span>
<span class="line-added">633         public final Value getInput() {</span>
<span class="line-added">634             return input;</span>
<span class="line-added">635         }</span>
<span class="line-added">636 </span>
<span class="line-added">637         public final AllocatableValue getResult() {</span>
<span class="line-added">638             return result;</span>
<span class="line-added">639         }</span>
<span class="line-added">640 </span>
<span class="line-added">641         protected final Register getResultRegister() {</span>
<span class="line-added">642             return asRegister(result);</span>
<span class="line-added">643         }</span>
<span class="line-added">644 </span>
<span class="line-added">645         protected final Register getBaseRegister(CompilationResultBuilder crb) {</span>
<span class="line-added">646             return hasBase(crb.getOptions(), encoding) ? asRegister(baseRegister) : Register.None;</span>
<span class="line-added">647         }</span>
<span class="line-added">648 </span>
<span class="line-added">649         protected final int getShift() {</span>
<span class="line-added">650             return encoding.getShift();</span>
<span class="line-added">651         }</span>
<span class="line-added">652 </span>
<span class="line-added">653         protected final void move(CompilationResultBuilder crb, AArch64MacroAssembler masm) {</span>
<span class="line-added">654             AArch64Move.move(crb, masm, result, input);</span>
<span class="line-added">655         }</span>
<span class="line-added">656     }</span>
<span class="line-added">657 </span>
<span class="line-added">658     public static class CompressPointerOp extends PointerCompressionOp {</span>
<span class="line-added">659         public static final LIRInstructionClass&lt;CompressPointerOp&gt; TYPE = LIRInstructionClass.create(CompressPointerOp.class);</span>
<span class="line-added">660 </span>
<span class="line-added">661         public CompressPointerOp(AllocatableValue result, Value input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {</span>
<span class="line-added">662             this(TYPE, result, input, baseRegister, encoding, nonNull, lirKindTool);</span>
<span class="line-added">663         }</span>
<span class="line-added">664 </span>
<span class="line-added">665         private CompressPointerOp(LIRInstructionClass&lt;? extends PointerCompressionOp&gt; type, AllocatableValue result, Value input,</span>
<span class="line-added">666                         AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {</span>
<span class="line-added">667 </span>
<span class="line-added">668             super(type, result, input, baseRegister, encoding, nonNull, lirKindTool);</span>
<span class="line-added">669         }</span>
<span class="line-added">670 </span>
<span class="line-added">671         @Override</span>
<span class="line-added">672         protected void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {</span>
<span class="line-added">673             Register resultRegister = getResultRegister();</span>
<span class="line-added">674             Register ptr = asRegister(getInput());</span>
<span class="line-added">675             Register base = getBaseRegister(crb);</span>
<span class="line-added">676             // result = (ptr - base) &gt;&gt; shift</span>
<span class="line-added">677             if (!encoding.hasBase()) {</span>
<span class="line-added">678                 if (encoding.hasShift()) {</span>
<span class="line-added">679                     masm.lshr(64, resultRegister, ptr, encoding.getShift());</span>
<span class="line-added">680                 } else {</span>
<span class="line-added">681                     masm.movx(resultRegister, ptr);</span>
<span class="line-added">682                 }</span>
<span class="line-added">683             } else if (nonNull) {</span>
<span class="line-added">684                 masm.sub(64, resultRegister, ptr, base);</span>
<span class="line-added">685                 if (encoding.hasShift()) {</span>
<span class="line-added">686                     masm.lshr(64, resultRegister, resultRegister, encoding.getShift());</span>
<span class="line-added">687                 }</span>
<span class="line-added">688             } else {</span>
<span class="line-added">689                 // if ptr is null it still has to be null after compression</span>
<span class="line-added">690                 masm.cmp(64, ptr, 0);</span>
<span class="line-added">691                 masm.cmov(64, resultRegister, ptr, base, AArch64Assembler.ConditionFlag.NE);</span>
<span class="line-added">692                 masm.sub(64, resultRegister, resultRegister, base);</span>
<span class="line-added">693                 if (encoding.hasShift()) {</span>
<span class="line-added">694                     masm.lshr(64, resultRegister, resultRegister, encoding.getShift());</span>
<span class="line-added">695                 }</span>
<span class="line-added">696             }</span>
<span class="line-added">697         }</span>
<span class="line-added">698     }</span>
<span class="line-added">699 </span>
<span class="line-added">700     public static class UncompressPointerOp extends PointerCompressionOp {</span>
<span class="line-added">701         public static final LIRInstructionClass&lt;UncompressPointerOp&gt; TYPE = LIRInstructionClass.create(UncompressPointerOp.class);</span>
<span class="line-added">702 </span>
<span class="line-added">703         public UncompressPointerOp(AllocatableValue result, Value input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {</span>
<span class="line-added">704             this(TYPE, result, input, baseRegister, encoding, nonNull, lirKindTool);</span>
<span class="line-added">705         }</span>
<span class="line-added">706 </span>
<span class="line-added">707         private UncompressPointerOp(LIRInstructionClass&lt;? extends PointerCompressionOp&gt; type, AllocatableValue result, Value input,</span>
<span class="line-added">708                         AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {</span>
<span class="line-added">709             super(type, result, input, baseRegister, encoding, nonNull, lirKindTool);</span>
<span class="line-added">710         }</span>
<span class="line-added">711 </span>
<span class="line-added">712         @Override</span>
<span class="line-added">713         protected void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {</span>
<span class="line-added">714             Register inputRegister = asRegister(getInput());</span>
<span class="line-added">715             Register resultRegister = getResultRegister();</span>
<span class="line-added">716             Register base = encoding.hasBase() ? getBaseRegister(crb) : null;</span>
<span class="line-added">717 </span>
<span class="line-added">718             // result = base + (ptr &lt;&lt; shift)</span>
<span class="line-added">719             if (nonNull || base == null) {</span>
<span class="line-added">720                 masm.add(64, resultRegister, base == null ? zr : base, inputRegister, AArch64Assembler.ShiftType.LSL, encoding.getShift());</span>
<span class="line-added">721             } else {</span>
<span class="line-added">722                 // if ptr is null it has to be null after decompression</span>
<span class="line-added">723                 Label done = new Label();</span>
<span class="line-added">724                 if (!resultRegister.equals(inputRegister)) {</span>
<span class="line-added">725                     masm.mov(32, resultRegister, inputRegister);</span>
<span class="line-added">726                 }</span>
<span class="line-added">727                 masm.cbz(32, resultRegister, done);</span>
<span class="line-added">728                 masm.add(64, resultRegister, base, resultRegister, AArch64Assembler.ShiftType.LSL, encoding.getShift());</span>
<span class="line-added">729                 masm.bind(done);</span>
<span class="line-added">730             }</span>
<span class="line-added">731         }</span>
<span class="line-added">732     }</span>
<span class="line-added">733 </span>
<span class="line-added">734     private abstract static class ZeroNullConversionOp extends AArch64LIRInstruction {</span>
<span class="line-added">735         @Def({REG, HINT}) protected AllocatableValue result;</span>
<span class="line-added">736         @Use({REG}) protected AllocatableValue input;</span>
<span class="line-added">737 </span>
<span class="line-added">738         protected ZeroNullConversionOp(LIRInstructionClass&lt;? extends ZeroNullConversionOp&gt; type, AllocatableValue result, AllocatableValue input) {</span>
<span class="line-added">739             super(type);</span>
<span class="line-added">740             this.result = result;</span>
<span class="line-added">741             this.input = input;</span>
<span class="line-added">742         }</span>
<span class="line-added">743 </span>
<span class="line-added">744         @Override</span>
<span class="line-added">745         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {</span>
<span class="line-added">746             Register nullRegister = crb.uncompressedNullRegister;</span>
<span class="line-added">747             if (!nullRegister.equals(Register.None)) {</span>
<span class="line-added">748                 emitConversion(asRegister(result), asRegister(input), nullRegister, masm);</span>
<span class="line-added">749             }</span>
<span class="line-added">750         }</span>
<span class="line-added">751 </span>
<span class="line-added">752         protected abstract void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AArch64MacroAssembler masm);</span>
<span class="line-added">753     }</span>
<span class="line-added">754 </span>
<span class="line-added">755     public static class ConvertNullToZeroOp extends ZeroNullConversionOp {</span>
<span class="line-added">756         public static final LIRInstructionClass&lt;ConvertNullToZeroOp&gt; TYPE = LIRInstructionClass.create(ConvertNullToZeroOp.class);</span>
<span class="line-added">757 </span>
<span class="line-added">758         public ConvertNullToZeroOp(AllocatableValue result, AllocatableValue input) {</span>
<span class="line-added">759             super(TYPE, result, input);</span>
<span class="line-added">760         }</span>
<span class="line-added">761 </span>
<span class="line-added">762         @Override</span>
<span class="line-added">763         protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AArch64MacroAssembler masm) {</span>
<span class="line-added">764             if (inputRegister.equals(resultRegister)) {</span>
<span class="line-added">765                 masm.subs(64, inputRegister, inputRegister, nullRegister);</span>
<span class="line-added">766                 Label done = new Label();</span>
<span class="line-added">767                 masm.branchConditionally(AArch64Assembler.ConditionFlag.EQ, done);</span>
<span class="line-added">768                 masm.add(64, inputRegister, inputRegister, nullRegister);</span>
<span class="line-added">769                 masm.bind(done);</span>
<span class="line-added">770             } else {</span>
<span class="line-added">771                 masm.subs(64, resultRegister, resultRegister, resultRegister);</span>
<span class="line-added">772                 masm.cmp(64, inputRegister, nullRegister);</span>
<span class="line-added">773                 Label done = new Label();</span>
<span class="line-added">774                 masm.branchConditionally(AArch64Assembler.ConditionFlag.EQ, done);</span>
<span class="line-added">775                 masm.movx(resultRegister, inputRegister);</span>
<span class="line-added">776                 masm.bind(done);</span>
<span class="line-added">777             }</span>
<span class="line-added">778         }</span>
<span class="line-added">779     }</span>
<span class="line-added">780 </span>
<span class="line-added">781     public static class ConvertZeroToNullOp extends ZeroNullConversionOp {</span>
<span class="line-added">782         public static final LIRInstructionClass&lt;ConvertZeroToNullOp&gt; TYPE = LIRInstructionClass.create(ConvertZeroToNullOp.class);</span>
<span class="line-added">783 </span>
<span class="line-added">784         public ConvertZeroToNullOp(AllocatableValue result, AllocatableValue input) {</span>
<span class="line-added">785             super(TYPE, result, input);</span>
<span class="line-added">786         }</span>
<span class="line-added">787 </span>
<span class="line-added">788         @Override</span>
<span class="line-added">789         protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AArch64MacroAssembler masm) {</span>
<span class="line-added">790             if (!inputRegister.equals(resultRegister)) {</span>
<span class="line-added">791                 masm.movx(resultRegister, inputRegister);</span>
<span class="line-added">792             }</span>
<span class="line-added">793             Label done = new Label();</span>
<span class="line-added">794             masm.ands(64, zr, inputRegister, inputRegister);</span>
<span class="line-added">795             masm.branchConditionally(AArch64Assembler.ConditionFlag.NE, done);</span>
<span class="line-added">796             masm.movx(resultRegister, nullRegister);</span>
<span class="line-added">797             masm.bind(done);</span>
<span class="line-added">798         }</span>
<span class="line-added">799     }</span>
<span class="line-added">800 </span>
801 }
</pre>
</td>
</tr>
</table>
<center><a href="AArch64ControlFlow.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64RestoreRegistersOp.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64Move.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64ControlFlow.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64RestoreRegistersOp.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64Move.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -29,22 +29,29 @@</span>
  import static jdk.vm.ci.code.ValueUtil.asAllocatableValue;
  import static jdk.vm.ci.code.ValueUtil.asRegister;
  import static jdk.vm.ci.code.ValueUtil.asStackSlot;
  import static jdk.vm.ci.code.ValueUtil.isRegister;
  import static jdk.vm.ci.code.ValueUtil.isStackSlot;
<span class="udiff-line-added">+ import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;</span>
  import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.COMPOSITE;
<span class="udiff-line-added">+ import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.CONST;</span>
  import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;
<span class="udiff-line-added">+ import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;</span>
  import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
  import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;
  import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.UNINITIALIZED;
  import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
  import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
  
<span class="udiff-line-added">+ import org.graalvm.compiler.asm.Label;</span>
  import org.graalvm.compiler.asm.aarch64.AArch64Address;
<span class="udiff-line-added">+ import org.graalvm.compiler.asm.aarch64.AArch64Assembler;</span>
  import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
  import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.ScratchRegister;
<span class="udiff-line-added">+ import org.graalvm.compiler.core.common.CompressEncoding;</span>
  import org.graalvm.compiler.core.common.LIRKind;
<span class="udiff-line-added">+ import org.graalvm.compiler.core.common.spi.LIRKindTool;</span>
  import org.graalvm.compiler.core.common.type.DataPointerConstant;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.lir.LIRFrameState;
  import org.graalvm.compiler.lir.LIRInstructionClass;
  import org.graalvm.compiler.lir.Opcode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -52,10 +59,11 @@</span>
  import org.graalvm.compiler.lir.StandardOp.LoadConstantOp;
  import org.graalvm.compiler.lir.StandardOp.NullCheck;
  import org.graalvm.compiler.lir.StandardOp.ValueMoveOp;
  import org.graalvm.compiler.lir.VirtualStackSlot;
  import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
<span class="udiff-line-added">+ import org.graalvm.compiler.options.OptionValues;</span>
  
  import jdk.vm.ci.aarch64.AArch64Kind;
  import jdk.vm.ci.code.MemoryBarriers;
  import jdk.vm.ci.code.Register;
  import jdk.vm.ci.code.StackSlot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -245,14 +253,23 @@</span>
  
          protected abstract void emitMemAccess(CompilationResultBuilder crb, AArch64MacroAssembler masm);
  
          @Override
          public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
<span class="udiff-line-added">+             int prePosition = masm.position();</span>
<span class="udiff-line-added">+             emitMemAccess(crb, masm);</span>
              if (state != null) {
<span class="udiff-line-modified-removed">-                 crb.recordImplicitException(masm.position(), state);</span>
<span class="udiff-line-modified-added">+                 int implicitExceptionPosition = prePosition;</span>
<span class="udiff-line-added">+                 // Adjust implicit exception position if this ldr/str has been merged to ldp/stp.</span>
<span class="udiff-line-added">+                 if (kind.isInteger() &amp;&amp; prePosition == masm.position() &amp;&amp; masm.isImmLoadStoreMerged()) {</span>
<span class="udiff-line-added">+                     implicitExceptionPosition = prePosition - 4;</span>
<span class="udiff-line-added">+                     if (crb.isImplicitExceptionExist(implicitExceptionPosition)) {</span>
<span class="udiff-line-added">+                         return;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 crb.recordImplicitException(implicitExceptionPosition, state);</span>
              }
<span class="udiff-line-removed">-             emitMemAccess(crb, masm);</span>
          }
  
          @Override
          public boolean makeNullCheckFor(Value value, LIRFrameState nullCheckState, int implicitNullCheckLimit) {
              int displacement = addressValue.getDisplacement();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -336,12 +353,21 @@</span>
              this.state = state;
          }
  
          @Override
          public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
<span class="udiff-line-modified-removed">-             crb.recordImplicitException(masm.position(), state);</span>
<span class="udiff-line-modified-added">+             int prePosition = masm.position();</span>
              masm.ldr(64, zr, address.toAddress());
<span class="udiff-line-added">+             int implicitExceptionPosition = prePosition;</span>
<span class="udiff-line-added">+             // Adjust implicit exception position if this ldr has been merged to ldp.</span>
<span class="udiff-line-added">+             if (prePosition == masm.position() &amp;&amp; masm.isImmLoadStoreMerged()) {</span>
<span class="udiff-line-added">+                 implicitExceptionPosition = prePosition - 4;</span>
<span class="udiff-line-added">+                 if (crb.isImplicitExceptionExist(implicitExceptionPosition)) {</span>
<span class="udiff-line-added">+                     return;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             crb.recordImplicitException(implicitExceptionPosition, state);</span>
          }
  
          @Override
          public Value getCheckedValue() {
              return address.base;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -423,11 +449,14 @@</span>
              masm.fmov(size, dst, src);
          }
      }
  
      static void reg2stack(CompilationResultBuilder crb, AArch64MacroAssembler masm, AllocatableValue result, AllocatableValue input) {
<span class="udiff-line-modified-removed">-         AArch64Address dest = loadStackSlotAddress(crb, masm, asStackSlot(result), Value.ILLEGAL);</span>
<span class="udiff-line-modified-added">+         AArch64Address dest;</span>
<span class="udiff-line-added">+         try (ScratchRegister scratch = masm.getScratchRegister()) {</span>
<span class="udiff-line-added">+             dest = loadStackSlotAddress(crb, masm, asStackSlot(result), scratch.getRegister());</span>
<span class="udiff-line-added">+         }</span>
          Register src = asRegister(input);
          // use the slot kind to define the operand size
          AArch64Kind kind = (AArch64Kind) result.getPlatformKind();
          final int size = kind.getSizeInBytes() * Byte.SIZE;
          if (kind.isInteger()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -487,11 +516,16 @@</span>
                          Register scratch = scr.getRegister();
                          masm.mov(scratch, Float.floatToRawIntBits(input.asFloat()));
                          masm.fmov(32, dst, scratch);
                      }
                  } else {
<span class="udiff-line-modified-removed">-                     masm.fldr(32, dst, (AArch64Address) crb.asFloatConstRef(input));</span>
<span class="udiff-line-modified-added">+                     try (ScratchRegister scr = masm.getScratchRegister()) {</span>
<span class="udiff-line-added">+                         Register scratch = scr.getRegister();</span>
<span class="udiff-line-added">+                         crb.asFloatConstRef(input);</span>
<span class="udiff-line-added">+                         masm.addressOf(scratch);</span>
<span class="udiff-line-added">+                         masm.fldr(32, dst, AArch64Address.createBaseRegisterOnlyAddress(scratch));</span>
<span class="udiff-line-added">+                     }</span>
                  }
                  break;
              case Double:
                  if (AArch64MacroAssembler.isDoubleImmediate(input.asDouble())) {
                      masm.fmov(64, dst, input.asDouble());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -500,19 +534,28 @@</span>
                          Register scratch = scr.getRegister();
                          masm.mov(scratch, Double.doubleToRawLongBits(input.asDouble()));
                          masm.fmov(64, dst, scratch);
                      }
                  } else {
<span class="udiff-line-modified-removed">-                     masm.fldr(64, dst, (AArch64Address) crb.asDoubleConstRef(input));</span>
<span class="udiff-line-modified-added">+                     try (ScratchRegister scr = masm.getScratchRegister()) {</span>
<span class="udiff-line-added">+                         Register scratch = scr.getRegister();</span>
<span class="udiff-line-added">+                         crb.asDoubleConstRef(input);</span>
<span class="udiff-line-added">+                         masm.addressOf(scratch);</span>
<span class="udiff-line-added">+                         masm.fldr(64, dst, AArch64Address.createBaseRegisterOnlyAddress(scratch));</span>
<span class="udiff-line-added">+                     }</span>
                  }
                  break;
              case Object:
                  if (input.isNull()) {
<span class="udiff-line-modified-removed">-                     masm.mov(dst, 0);</span>
<span class="udiff-line-modified-added">+                     if (crb.mustReplaceWithUncompressedNullRegister(input)) {</span>
<span class="udiff-line-added">+                         masm.mov(64, dst, crb.uncompressedNullRegister);</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         masm.mov(dst, 0);</span>
<span class="udiff-line-added">+                     }</span>
                  } else if (crb.target.inlineObjects) {
                      crb.recordInlineDataInCode(input);
<span class="udiff-line-modified-removed">-                     masm.movNativeAddress(dst, 0xDEADDEADDEADDEADL);</span>
<span class="udiff-line-modified-added">+                     masm.mov(dst, 0xDEADDEADDEADDEADL, true);</span>
                  } else {
                      masm.ldr(64, dst, (AArch64Address) crb.recordDataReferenceInCode(input, 8));
                  }
                  break;
              default:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -522,11 +565,11 @@</span>
  
      private static void const2stack(CompilationResultBuilder crb, AArch64MacroAssembler masm, Value result, JavaConstant constant) {
          try (ScratchRegister addrReg = masm.getScratchRegister()) {
              StackSlot slot = (StackSlot) result;
              AArch64Address resultAddress = loadStackSlotAddress(crb, masm, slot, addrReg.getRegister());
<span class="udiff-line-modified-removed">-             if (constant.isDefaultForKind() || constant.isNull()) {</span>
<span class="udiff-line-modified-added">+             if (constant.isNull() &amp;&amp; !crb.mustReplaceWithUncompressedNullRegister(constant)) {</span>
                  emitStore(crb, masm, (AArch64Kind) result.getPlatformKind(), resultAddress, zr.asValue(LIRKind.combine(result)));
              } else {
                  try (ScratchRegister sc = masm.getScratchRegister()) {
                      Value scratchRegisterValue = sc.getRegister().asValue(LIRKind.combine(result));
                      const2reg(crb, masm, scratchRegisterValue, constant);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -559,6 +602,200 @@</span>
          int displacement = crb.frameMap.offsetForStackSlot(slot);
          int transferSize = slot.getPlatformKind().getSizeInBytes();
          return masm.makeAddress(sp, displacement, scratchReg, transferSize, /* allowOverwrite */false);
      }
  
<span class="udiff-line-added">+     public abstract static class PointerCompressionOp extends AArch64LIRInstruction {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Def({REG, HINT}) private AllocatableValue result;</span>
<span class="udiff-line-added">+         @Use({REG, CONST}) private Value input;</span>
<span class="udiff-line-added">+         @Alive({REG, ILLEGAL, UNINITIALIZED}) private AllocatableValue baseRegister;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         protected final CompressEncoding encoding;</span>
<span class="udiff-line-added">+         protected final boolean nonNull;</span>
<span class="udiff-line-added">+         protected final LIRKindTool lirKindTool;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         protected PointerCompressionOp(LIRInstructionClass&lt;? extends PointerCompressionOp&gt; type, AllocatableValue result, Value input,</span>
<span class="udiff-line-added">+                         AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             super(type);</span>
<span class="udiff-line-added">+             this.result = result;</span>
<span class="udiff-line-added">+             this.input = input;</span>
<span class="udiff-line-added">+             this.baseRegister = baseRegister;</span>
<span class="udiff-line-added">+             this.encoding = encoding;</span>
<span class="udiff-line-added">+             this.nonNull = nonNull;</span>
<span class="udiff-line-added">+             this.lirKindTool = lirKindTool;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public static boolean hasBase(OptionValues options, CompressEncoding encoding) {</span>
<span class="udiff-line-added">+             return GeneratePIC.getValue(options) || encoding.hasBase();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public final Value getInput() {</span>
<span class="udiff-line-added">+             return input;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public final AllocatableValue getResult() {</span>
<span class="udiff-line-added">+             return result;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         protected final Register getResultRegister() {</span>
<span class="udiff-line-added">+             return asRegister(result);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         protected final Register getBaseRegister(CompilationResultBuilder crb) {</span>
<span class="udiff-line-added">+             return hasBase(crb.getOptions(), encoding) ? asRegister(baseRegister) : Register.None;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         protected final int getShift() {</span>
<span class="udiff-line-added">+             return encoding.getShift();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         protected final void move(CompilationResultBuilder crb, AArch64MacroAssembler masm) {</span>
<span class="udiff-line-added">+             AArch64Move.move(crb, masm, result, input);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static class CompressPointerOp extends PointerCompressionOp {</span>
<span class="udiff-line-added">+         public static final LIRInstructionClass&lt;CompressPointerOp&gt; TYPE = LIRInstructionClass.create(CompressPointerOp.class);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public CompressPointerOp(AllocatableValue result, Value input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {</span>
<span class="udiff-line-added">+             this(TYPE, result, input, baseRegister, encoding, nonNull, lirKindTool);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private CompressPointerOp(LIRInstructionClass&lt;? extends PointerCompressionOp&gt; type, AllocatableValue result, Value input,</span>
<span class="udiff-line-added">+                         AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             super(type, result, input, baseRegister, encoding, nonNull, lirKindTool);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         protected void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {</span>
<span class="udiff-line-added">+             Register resultRegister = getResultRegister();</span>
<span class="udiff-line-added">+             Register ptr = asRegister(getInput());</span>
<span class="udiff-line-added">+             Register base = getBaseRegister(crb);</span>
<span class="udiff-line-added">+             // result = (ptr - base) &gt;&gt; shift</span>
<span class="udiff-line-added">+             if (!encoding.hasBase()) {</span>
<span class="udiff-line-added">+                 if (encoding.hasShift()) {</span>
<span class="udiff-line-added">+                     masm.lshr(64, resultRegister, ptr, encoding.getShift());</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     masm.movx(resultRegister, ptr);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else if (nonNull) {</span>
<span class="udiff-line-added">+                 masm.sub(64, resultRegister, ptr, base);</span>
<span class="udiff-line-added">+                 if (encoding.hasShift()) {</span>
<span class="udiff-line-added">+                     masm.lshr(64, resultRegister, resultRegister, encoding.getShift());</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 // if ptr is null it still has to be null after compression</span>
<span class="udiff-line-added">+                 masm.cmp(64, ptr, 0);</span>
<span class="udiff-line-added">+                 masm.cmov(64, resultRegister, ptr, base, AArch64Assembler.ConditionFlag.NE);</span>
<span class="udiff-line-added">+                 masm.sub(64, resultRegister, resultRegister, base);</span>
<span class="udiff-line-added">+                 if (encoding.hasShift()) {</span>
<span class="udiff-line-added">+                     masm.lshr(64, resultRegister, resultRegister, encoding.getShift());</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static class UncompressPointerOp extends PointerCompressionOp {</span>
<span class="udiff-line-added">+         public static final LIRInstructionClass&lt;UncompressPointerOp&gt; TYPE = LIRInstructionClass.create(UncompressPointerOp.class);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public UncompressPointerOp(AllocatableValue result, Value input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {</span>
<span class="udiff-line-added">+             this(TYPE, result, input, baseRegister, encoding, nonNull, lirKindTool);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private UncompressPointerOp(LIRInstructionClass&lt;? extends PointerCompressionOp&gt; type, AllocatableValue result, Value input,</span>
<span class="udiff-line-added">+                         AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {</span>
<span class="udiff-line-added">+             super(type, result, input, baseRegister, encoding, nonNull, lirKindTool);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         protected void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {</span>
<span class="udiff-line-added">+             Register inputRegister = asRegister(getInput());</span>
<span class="udiff-line-added">+             Register resultRegister = getResultRegister();</span>
<span class="udiff-line-added">+             Register base = encoding.hasBase() ? getBaseRegister(crb) : null;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // result = base + (ptr &lt;&lt; shift)</span>
<span class="udiff-line-added">+             if (nonNull || base == null) {</span>
<span class="udiff-line-added">+                 masm.add(64, resultRegister, base == null ? zr : base, inputRegister, AArch64Assembler.ShiftType.LSL, encoding.getShift());</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 // if ptr is null it has to be null after decompression</span>
<span class="udiff-line-added">+                 Label done = new Label();</span>
<span class="udiff-line-added">+                 if (!resultRegister.equals(inputRegister)) {</span>
<span class="udiff-line-added">+                     masm.mov(32, resultRegister, inputRegister);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 masm.cbz(32, resultRegister, done);</span>
<span class="udiff-line-added">+                 masm.add(64, resultRegister, base, resultRegister, AArch64Assembler.ShiftType.LSL, encoding.getShift());</span>
<span class="udiff-line-added">+                 masm.bind(done);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private abstract static class ZeroNullConversionOp extends AArch64LIRInstruction {</span>
<span class="udiff-line-added">+         @Def({REG, HINT}) protected AllocatableValue result;</span>
<span class="udiff-line-added">+         @Use({REG}) protected AllocatableValue input;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         protected ZeroNullConversionOp(LIRInstructionClass&lt;? extends ZeroNullConversionOp&gt; type, AllocatableValue result, AllocatableValue input) {</span>
<span class="udiff-line-added">+             super(type);</span>
<span class="udiff-line-added">+             this.result = result;</span>
<span class="udiff-line-added">+             this.input = input;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {</span>
<span class="udiff-line-added">+             Register nullRegister = crb.uncompressedNullRegister;</span>
<span class="udiff-line-added">+             if (!nullRegister.equals(Register.None)) {</span>
<span class="udiff-line-added">+                 emitConversion(asRegister(result), asRegister(input), nullRegister, masm);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         protected abstract void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AArch64MacroAssembler masm);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static class ConvertNullToZeroOp extends ZeroNullConversionOp {</span>
<span class="udiff-line-added">+         public static final LIRInstructionClass&lt;ConvertNullToZeroOp&gt; TYPE = LIRInstructionClass.create(ConvertNullToZeroOp.class);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public ConvertNullToZeroOp(AllocatableValue result, AllocatableValue input) {</span>
<span class="udiff-line-added">+             super(TYPE, result, input);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AArch64MacroAssembler masm) {</span>
<span class="udiff-line-added">+             if (inputRegister.equals(resultRegister)) {</span>
<span class="udiff-line-added">+                 masm.subs(64, inputRegister, inputRegister, nullRegister);</span>
<span class="udiff-line-added">+                 Label done = new Label();</span>
<span class="udiff-line-added">+                 masm.branchConditionally(AArch64Assembler.ConditionFlag.EQ, done);</span>
<span class="udiff-line-added">+                 masm.add(64, inputRegister, inputRegister, nullRegister);</span>
<span class="udiff-line-added">+                 masm.bind(done);</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 masm.subs(64, resultRegister, resultRegister, resultRegister);</span>
<span class="udiff-line-added">+                 masm.cmp(64, inputRegister, nullRegister);</span>
<span class="udiff-line-added">+                 Label done = new Label();</span>
<span class="udiff-line-added">+                 masm.branchConditionally(AArch64Assembler.ConditionFlag.EQ, done);</span>
<span class="udiff-line-added">+                 masm.movx(resultRegister, inputRegister);</span>
<span class="udiff-line-added">+                 masm.bind(done);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static class ConvertZeroToNullOp extends ZeroNullConversionOp {</span>
<span class="udiff-line-added">+         public static final LIRInstructionClass&lt;ConvertZeroToNullOp&gt; TYPE = LIRInstructionClass.create(ConvertZeroToNullOp.class);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public ConvertZeroToNullOp(AllocatableValue result, AllocatableValue input) {</span>
<span class="udiff-line-added">+             super(TYPE, result, input);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AArch64MacroAssembler masm) {</span>
<span class="udiff-line-added">+             if (!inputRegister.equals(resultRegister)) {</span>
<span class="udiff-line-added">+                 masm.movx(resultRegister, inputRegister);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             Label done = new Label();</span>
<span class="udiff-line-added">+             masm.ands(64, zr, inputRegister, inputRegister);</span>
<span class="udiff-line-added">+             masm.branchConditionally(AArch64Assembler.ConditionFlag.NE, done);</span>
<span class="udiff-line-added">+             masm.movx(resultRegister, nullRegister);</span>
<span class="udiff-line-added">+             masm.bind(done);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
  }
</pre>
<center><a href="AArch64ControlFlow.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64RestoreRegistersOp.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
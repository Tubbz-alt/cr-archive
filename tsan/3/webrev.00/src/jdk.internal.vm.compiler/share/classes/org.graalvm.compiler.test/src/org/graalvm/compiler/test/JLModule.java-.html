<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.test/src/org/graalvm/compiler/test/JLModule.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.test;
 26 
 27 import java.lang.reflect.AccessibleObject;
 28 import java.lang.reflect.Method;
 29 import java.util.Set;
 30 
 31 /**
 32  * Facade for the {@code java.lang.Module} class introduced in JDK9 that allows tests to be
 33  * developed against JDK8 but use module logic if deployed on JDK9.
 34  */
 35 public class JLModule {
 36 
 37     static {
 38         if (GraalTest.Java8OrEarlier) {
 39             throw new AssertionError(&quot;Use of &quot; + JLModule.class + &quot; only allowed if &quot; + GraalTest.class.getName() + &quot;.JDK8OrEarlier is false&quot;);
 40         }
 41     }
 42 
 43     private final Object realModule;
 44 
 45     public JLModule(Object module) {
 46         this.realModule = module;
 47     }
 48 
 49     private static final Class&lt;?&gt; moduleClass;
 50     private static final Method getModuleMethod;
 51     private static final Method getUnnamedModuleMethod;
 52     private static final Method getPackagesMethod;
 53     private static final Method isExportedMethod;
 54     private static final Method isExported2Method;
 55     private static final Method addExportsMethod;
 56     /**
 57      * {@code jdk.internal.module.Modules.addExports(Module, String, Module)}.
 58      */
 59     private static final Method modulesAddExportsMethod;
 60 
 61     /**
 62      * {@code jdk.internal.module.Modules.addOpens(Module, String, Module)}.
 63      */
 64     private static final Method modulesAddOpensMethod;
 65 
 66     static {
 67         try {
 68             moduleClass = Class.forName(&quot;java.lang.Module&quot;);
 69             Class&lt;?&gt; modulesClass = Class.forName(&quot;jdk.internal.module.Modules&quot;);
 70             getModuleMethod = Class.class.getMethod(&quot;getModule&quot;);
 71             getUnnamedModuleMethod = ClassLoader.class.getMethod(&quot;getUnnamedModule&quot;);
 72             getPackagesMethod = moduleClass.getMethod(&quot;getPackages&quot;);
 73             isExportedMethod = moduleClass.getMethod(&quot;isExported&quot;, String.class);
 74             isExported2Method = moduleClass.getMethod(&quot;isExported&quot;, String.class, moduleClass);
 75             addExportsMethod = moduleClass.getMethod(&quot;addExports&quot;, String.class, moduleClass);
 76             modulesAddExportsMethod = modulesClass.getDeclaredMethod(&quot;addExports&quot;, moduleClass, String.class, moduleClass);
 77             modulesAddOpensMethod = modulesClass.getDeclaredMethod(&quot;addOpens&quot;, moduleClass, String.class, moduleClass);
 78         } catch (Exception e) {
 79             throw new AssertionError(e);
 80         }
 81     }
 82 
 83     public static JLModule fromClass(Class&lt;?&gt; cls) {
 84         try {
 85             return new JLModule(getModuleMethod.invoke(cls));
 86         } catch (Exception e) {
 87             throw new AssertionError(e);
 88         }
 89     }
 90 
 91     public static JLModule getUnnamedModuleFor(ClassLoader cl) {
 92         try {
 93             return new JLModule(getUnnamedModuleMethod.invoke(cl));
 94         } catch (Exception e) {
 95             throw new AssertionError(e);
 96         }
 97     }
 98 
 99     /**
100      * Exports all packages in this module to a given module.
101      */
102     public void exportAllPackagesTo(JLModule module) {
103         if (this != module) {
104             for (String pkg : getPackages()) {
105                 // Export all JVMCI packages dynamically instead
106                 // of requiring a long list of -XaddExports
107                 // options on the JVM command line.
108                 if (!isExported(pkg, module)) {
109                     addExports(pkg, module);
110                 }
111             }
112         }
113     }
114 
115     @SuppressWarnings(&quot;unchecked&quot;)
116     public Set&lt;String&gt; getPackages() {
117         try {
118             return (Set&lt;String&gt;) getPackagesMethod.invoke(realModule);
119         } catch (Exception e) {
120             throw new AssertionError(e);
121         }
122     }
123 
124     public boolean isExported(String pn) {
125         try {
126             return (Boolean) isExportedMethod.invoke(realModule, pn);
127         } catch (Exception e) {
128             throw new AssertionError(e);
129         }
130     }
131 
132     public boolean isExported(String pn, JLModule other) {
133         try {
134             return (Boolean) isExported2Method.invoke(realModule, pn, other.realModule);
135         } catch (Exception e) {
136             throw new AssertionError(e);
137         }
138     }
139 
140     public void addExports(String pn, JLModule other) {
141         try {
142             addExportsMethod.invoke(realModule, pn, other.realModule);
143         } catch (Exception e) {
144             throw new AssertionError(e);
145         }
146     }
147 
148     private static Object unbox(Object obj) {
149         if (obj instanceof JLModule) {
150             return ((JLModule) obj).realModule;
151         }
152         return obj;
153     }
154 
155     /**
156      * Updates module m1 to export a package to module m2. Same as m1.addExports(pn, m2) but without
157      * a caller check
158      */
159     public static void uncheckedAddExports(Object m1, String pn, Object m2) {
160         try {
161             modulesAddExportsMethod.invoke(null, unbox(m1), pn, unbox(m2));
162         } catch (Exception e) {
163             throw new AssertionError(e);
164         }
165     }
166 
167     /**
168      * Opens all packages in {@code moduleMember}&#39;s module for deep reflection (i.e., allow
169      * {@link AccessibleObject#setAccessible(boolean)} to be called for any class/method/field) by
170      * {@code requestor}&#39;s module.
171      */
172     public static void openAllPackagesForReflectionTo(Class&lt;?&gt; moduleMember, Class&lt;?&gt; requestor) {
173         try {
174             Object moduleToOpen = getModuleMethod.invoke(moduleMember);
175             Object requestorModule = getModuleMethod.invoke(requestor);
176             if (moduleToOpen != requestorModule) {
177                 String[] packages = (String[]) getPackagesMethod.invoke(moduleToOpen);
178                 for (String pkg : packages) {
179                     modulesAddOpensMethod.invoke(moduleToOpen, pkg, requestorModule);
180                 }
181             }
182         } catch (Exception e) {
183             throw new AssertionError(e);
184         }
185     }
186 
187     /**
188      * Opens {@code declaringClass}&#39;s package to allow a method declared in {@code accessor} to call
189      * {@link AccessibleObject#setAccessible(boolean)} on an {@link AccessibleObject} representing a
190      * field or method declared by {@code declaringClass}.
191      */
192     public static void openForReflectionTo(Class&lt;?&gt; declaringClass, Class&lt;?&gt; accessor) {
193         try {
194             Object moduleToOpen = getModuleMethod.invoke(declaringClass);
195             Object accessorModule = getModuleMethod.invoke(accessor);
196             if (moduleToOpen != accessorModule) {
197                 modulesAddOpensMethod.invoke(null, moduleToOpen, declaringClass.getPackage().getName(), accessorModule);
198             }
199         } catch (Exception e) {
200             throw new AssertionError(e);
201         }
202     }
203 
204     /**
205      * Exports the package named {@code packageName} declared in {@code moduleMember}&#39;s module to
206      * {@code requestor}&#39;s module.
207      */
208     public static void exportPackageTo(Class&lt;?&gt; moduleMember, String packageName, Class&lt;?&gt; requestor) {
209         try {
210             Object moduleToExport = getModuleMethod.invoke(moduleMember);
211             Object requestorModule = getModuleMethod.invoke(requestor);
212             if (moduleToExport != requestorModule) {
213                 modulesAddExportsMethod.invoke(null, moduleToExport, packageName, requestorModule);
214             }
215         } catch (Exception e) {
216             throw new AssertionError(e);
217         }
218     }
219 }
    </pre>
  </body>
</html>
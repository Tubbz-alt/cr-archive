<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/VerifyUsageWithEquals.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="VerifyUpdateUsages.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="VerifyVirtualizableUsage.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/VerifyUsageWithEquals.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import org.graalvm.compiler.core.common.type.ObjectStamp;
 28 import org.graalvm.compiler.nodes.Invoke;
 29 import org.graalvm.compiler.nodes.NodeView;
 30 import org.graalvm.compiler.nodes.ParameterNode;
 31 import org.graalvm.compiler.nodes.StructuredGraph;
 32 import org.graalvm.compiler.nodes.ValueNode;
 33 import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
 34 import org.graalvm.compiler.nodes.java.LoadFieldNode;

 35 import org.graalvm.compiler.nodes.spi.UncheckedInterfaceProvider;
 36 import org.graalvm.compiler.nodes.type.StampTool;
 37 import org.graalvm.compiler.phases.VerifyPhase;
<span class="line-removed"> 38 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 39 
 40 import jdk.vm.ci.meta.JavaField;
 41 import jdk.vm.ci.meta.JavaKind;
 42 import jdk.vm.ci.meta.JavaMethod;
 43 import jdk.vm.ci.meta.JavaType;
 44 import jdk.vm.ci.meta.MetaAccessProvider;
 45 import jdk.vm.ci.meta.ResolvedJavaMethod;
 46 import jdk.vm.ci.meta.ResolvedJavaType;
 47 import jdk.vm.ci.meta.Signature;
 48 
 49 /**
 50  * For certain types, object identity should not be used for object equality check. This phase
 51  * checks the correct usage of the given type. Equality checks with == or != (except null checks)
 52  * results in an {@link AssertionError}.
 53  */
<span class="line-modified"> 54 public class VerifyUsageWithEquals extends VerifyPhase&lt;PhaseContext&gt; {</span>
 55 
 56     @Override
 57     public boolean checkContract() {
 58         return false;
 59     }
 60 
 61     /**
 62      * The type of values that must not use identity for testing object equality.
 63      */
 64     private final Class&lt;?&gt; restrictedClass;
 65 
 66     public VerifyUsageWithEquals(Class&lt;?&gt; restrictedClass) {
 67         this.restrictedClass = restrictedClass;
 68         assert !restrictedClass.isInterface() || isTrustedInterface(restrictedClass);
 69     }
 70 
 71     private static final Class&lt;?&gt;[] trustedInterfaceTypes = {JavaType.class, JavaField.class, JavaMethod.class};
 72 
 73     private static boolean isTrustedInterface(Class&lt;?&gt; cls) {
 74         for (Class&lt;?&gt; trusted : trustedInterfaceTypes) {
</pre>
<hr />
<pre>
126 
127     private static boolean isThisParameter(ValueNode node) {
128         return node instanceof ParameterNode &amp;&amp; ((ParameterNode) node).index() == 0;
129     }
130 
131     /**
132      * Checks whether the type of {@code x} is assignable to the restricted type and that {@code y}
133      * is not a null constant.
134      */
135     private boolean isIllegalUsage(ResolvedJavaMethod method, ValueNode x, ValueNode y, MetaAccessProvider metaAccess) {
136         if (isAssignableToRestrictedType(x, metaAccess) &amp;&amp; !isNullConstant(y)) {
137             if (isEqualsMethod(method) &amp;&amp; isThisParameter(x) || isThisParameter(y)) {
138                 return false;
139             }
140             return true;
141         }
142         return false;
143     }
144 
145     @Override
<span class="line-modified">146     protected boolean verify(StructuredGraph graph, PhaseContext context) {</span>
147         for (ObjectEqualsNode cn : graph.getNodes().filter(ObjectEqualsNode.class)) {
148             // bail out if we compare an object of type klass with == or != (except null checks)
149             ResolvedJavaMethod method = graph.method();
150             ResolvedJavaType restrictedType = context.getMetaAccess().lookupJavaType(restrictedClass);
151 
152             if (method.getDeclaringClass().equals(restrictedType)) {
153                 // Allow violation in methods of the restricted type itself.
154             } else if (isIllegalUsage(method, cn.getX(), cn.getY(), context.getMetaAccess()) || isIllegalUsage(method, cn.getY(), cn.getX(), context.getMetaAccess())) {
155                 throw new VerificationError(&quot;Verification of &quot; + restrictedClass.getName() + &quot; usage failed: Comparing &quot; + cn.getX() + &quot; and &quot; + cn.getY() + &quot; in &quot; + method +
156                                 &quot; must use .equals() for object equality, not &#39;==&#39; or &#39;!=&#39;&quot;);
157             }
158         }
<span class="line-removed">159         return true;</span>
160     }
161 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import org.graalvm.compiler.core.common.type.ObjectStamp;
 28 import org.graalvm.compiler.nodes.Invoke;
 29 import org.graalvm.compiler.nodes.NodeView;
 30 import org.graalvm.compiler.nodes.ParameterNode;
 31 import org.graalvm.compiler.nodes.StructuredGraph;
 32 import org.graalvm.compiler.nodes.ValueNode;
 33 import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
 34 import org.graalvm.compiler.nodes.java.LoadFieldNode;
<span class="line-added"> 35 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 36 import org.graalvm.compiler.nodes.spi.UncheckedInterfaceProvider;
 37 import org.graalvm.compiler.nodes.type.StampTool;
 38 import org.graalvm.compiler.phases.VerifyPhase;

 39 
 40 import jdk.vm.ci.meta.JavaField;
 41 import jdk.vm.ci.meta.JavaKind;
 42 import jdk.vm.ci.meta.JavaMethod;
 43 import jdk.vm.ci.meta.JavaType;
 44 import jdk.vm.ci.meta.MetaAccessProvider;
 45 import jdk.vm.ci.meta.ResolvedJavaMethod;
 46 import jdk.vm.ci.meta.ResolvedJavaType;
 47 import jdk.vm.ci.meta.Signature;
 48 
 49 /**
 50  * For certain types, object identity should not be used for object equality check. This phase
 51  * checks the correct usage of the given type. Equality checks with == or != (except null checks)
 52  * results in an {@link AssertionError}.
 53  */
<span class="line-modified"> 54 public class VerifyUsageWithEquals extends VerifyPhase&lt;CoreProviders&gt; {</span>
 55 
 56     @Override
 57     public boolean checkContract() {
 58         return false;
 59     }
 60 
 61     /**
 62      * The type of values that must not use identity for testing object equality.
 63      */
 64     private final Class&lt;?&gt; restrictedClass;
 65 
 66     public VerifyUsageWithEquals(Class&lt;?&gt; restrictedClass) {
 67         this.restrictedClass = restrictedClass;
 68         assert !restrictedClass.isInterface() || isTrustedInterface(restrictedClass);
 69     }
 70 
 71     private static final Class&lt;?&gt;[] trustedInterfaceTypes = {JavaType.class, JavaField.class, JavaMethod.class};
 72 
 73     private static boolean isTrustedInterface(Class&lt;?&gt; cls) {
 74         for (Class&lt;?&gt; trusted : trustedInterfaceTypes) {
</pre>
<hr />
<pre>
126 
127     private static boolean isThisParameter(ValueNode node) {
128         return node instanceof ParameterNode &amp;&amp; ((ParameterNode) node).index() == 0;
129     }
130 
131     /**
132      * Checks whether the type of {@code x} is assignable to the restricted type and that {@code y}
133      * is not a null constant.
134      */
135     private boolean isIllegalUsage(ResolvedJavaMethod method, ValueNode x, ValueNode y, MetaAccessProvider metaAccess) {
136         if (isAssignableToRestrictedType(x, metaAccess) &amp;&amp; !isNullConstant(y)) {
137             if (isEqualsMethod(method) &amp;&amp; isThisParameter(x) || isThisParameter(y)) {
138                 return false;
139             }
140             return true;
141         }
142         return false;
143     }
144 
145     @Override
<span class="line-modified">146     protected void verify(StructuredGraph graph, CoreProviders context) {</span>
147         for (ObjectEqualsNode cn : graph.getNodes().filter(ObjectEqualsNode.class)) {
148             // bail out if we compare an object of type klass with == or != (except null checks)
149             ResolvedJavaMethod method = graph.method();
150             ResolvedJavaType restrictedType = context.getMetaAccess().lookupJavaType(restrictedClass);
151 
152             if (method.getDeclaringClass().equals(restrictedType)) {
153                 // Allow violation in methods of the restricted type itself.
154             } else if (isIllegalUsage(method, cn.getX(), cn.getY(), context.getMetaAccess()) || isIllegalUsage(method, cn.getY(), cn.getX(), context.getMetaAccess())) {
155                 throw new VerificationError(&quot;Verification of &quot; + restrictedClass.getName() + &quot; usage failed: Comparing &quot; + cn.getX() + &quot; and &quot; + cn.getY() + &quot; in &quot; + method +
156                                 &quot; must use .equals() for object equality, not &#39;==&#39; or &#39;!=&#39;&quot;);
157             }
158         }

159     }
160 }
</pre>
</td>
</tr>
</table>
<center><a href="VerifyUpdateUsages.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="VerifyVirtualizableUsage.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
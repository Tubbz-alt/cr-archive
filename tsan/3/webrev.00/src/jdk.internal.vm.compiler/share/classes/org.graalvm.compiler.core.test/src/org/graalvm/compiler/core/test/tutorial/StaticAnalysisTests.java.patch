diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/tutorial/StaticAnalysisTests.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/tutorial/StaticAnalysisTests.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/tutorial/StaticAnalysisTests.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/tutorial/StaticAnalysisTests.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -27,25 +27,22 @@
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.Collection;
 
-import jdk.vm.ci.meta.MetaAccessProvider;
-import jdk.vm.ci.meta.ResolvedJavaField;
-import jdk.vm.ci.meta.ResolvedJavaMethod;
-import jdk.vm.ci.meta.ResolvedJavaType;
-
-import org.junit.Assert;
-import org.junit.Test;
-
 import org.graalvm.compiler.api.test.Graal;
 import org.graalvm.compiler.core.target.Backend;
 import org.graalvm.compiler.core.test.tutorial.StaticAnalysis.MethodState;
 import org.graalvm.compiler.core.test.tutorial.StaticAnalysis.TypeFlow;
-import org.graalvm.compiler.nodes.spi.StampProvider;
-import org.graalvm.compiler.phases.util.Providers;
+import org.graalvm.compiler.nodes.spi.CoreProviders;
 import org.graalvm.compiler.runtime.RuntimeProvider;
+import org.junit.Assert;
+import org.junit.Test;
+
+import jdk.vm.ci.meta.ResolvedJavaField;
+import jdk.vm.ci.meta.ResolvedJavaMethod;
+import jdk.vm.ci.meta.ResolvedJavaType;
 
 public class StaticAnalysisTests {
 
     static class A {
         Object foo(Object arg) {
@@ -66,28 +63,25 @@
 
     static class Data {
         Object f;
     }
 
-    private final MetaAccessProvider metaAccess;
-    private final StampProvider stampProvider;
+    private final CoreProviders providers;
 
     public StaticAnalysisTests() {
         Backend backend = Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend();
-        Providers providers = backend.getProviders();
-        this.metaAccess = providers.getMetaAccess();
-        this.stampProvider = providers.getStampProvider();
+        providers = backend.getProviders();
     }
 
     static void test01Entry() {
         A a = new A();
         a.foo(null);
     }
 
     @Test
     public void test01() {
-        StaticAnalysis sa = new StaticAnalysis(metaAccess, stampProvider);
+        StaticAnalysis sa = new StaticAnalysis(providers);
         sa.addMethod(findMethod(StaticAnalysisTests.class, "test01Entry"));
         sa.finish();
 
         assertEquals(sa.getResults().getAllInstantiatedTypes(), t(A.class));
         assertEquals(f(sa, Data.class, "f"));
@@ -104,11 +98,11 @@
         b.foo(null);
     }
 
     @Test
     public void test02() {
-        StaticAnalysis sa = new StaticAnalysis(metaAccess, stampProvider);
+        StaticAnalysis sa = new StaticAnalysis(providers);
         sa.addMethod(findMethod(StaticAnalysisTests.class, "test02Entry"));
         sa.finish();
 
         assertEquals(sa.getResults().getAllInstantiatedTypes(), t(A.class), t(B.class), t(Data.class));
         assertEquals(f(sa, Data.class, "f"));
@@ -132,11 +126,11 @@
         b.foo(null);
     }
 
     @Test
     public void test03() {
-        StaticAnalysis sa = new StaticAnalysis(metaAccess, stampProvider);
+        StaticAnalysis sa = new StaticAnalysis(providers);
         sa.addMethod(findMethod(StaticAnalysisTests.class, "test03Entry"));
         sa.finish();
 
         assertEquals(sa.getResults().getAllInstantiatedTypes(), t(A.class), t(B.class), t(Data.class), t(Integer.class));
         assertEquals(f(sa, Data.class, "f"), t(Integer.class));
@@ -163,11 +157,11 @@
         a.foo(data);
     }
 
     @Test
     public void test04() {
-        StaticAnalysis sa = new StaticAnalysis(metaAccess, stampProvider);
+        StaticAnalysis sa = new StaticAnalysis(providers);
         sa.addMethod(findMethod(StaticAnalysisTests.class, "test04Entry"));
         sa.finish();
 
         assertEquals(sa.getResults().getAllInstantiatedTypes(), t(A.class), t(Data.class), t(Integer.class));
         assertEquals(f(sa, Data.class, "f"), t(Integer.class));
@@ -190,11 +184,11 @@
             Assert.fail(actualTypes + " != " + Arrays.asList(expected));
         }
     }
 
     private ResolvedJavaType t(Class<?> clazz) {
-        return metaAccess.lookupJavaType(clazz);
+        return providers.getMetaAccess().lookupJavaType(clazz);
     }
 
     private ResolvedJavaMethod findMethod(Class<?> declaringClass, String name) {
         Method reflectionMethod = null;
         for (Method m : declaringClass.getDeclaredMethods()) {
@@ -202,18 +196,18 @@
                 assert reflectionMethod == null : "More than one method with name " + name + " in class " + declaringClass.getName();
                 reflectionMethod = m;
             }
         }
         assert reflectionMethod != null : "No method with name " + name + " in class " + declaringClass.getName();
-        return metaAccess.lookupJavaMethod(reflectionMethod);
+        return providers.getMetaAccess().lookupJavaMethod(reflectionMethod);
     }
 
     private ResolvedJavaField findField(Class<?> declaringClass, String name) {
         Field reflectionField;
         try {
             reflectionField = declaringClass.getDeclaredField(name);
         } catch (NoSuchFieldException | SecurityException ex) {
             throw new AssertionError(ex);
         }
-        return metaAccess.lookupJavaField(reflectionField);
+        return providers.getMetaAccess().lookupJavaField(reflectionField);
     }
 }

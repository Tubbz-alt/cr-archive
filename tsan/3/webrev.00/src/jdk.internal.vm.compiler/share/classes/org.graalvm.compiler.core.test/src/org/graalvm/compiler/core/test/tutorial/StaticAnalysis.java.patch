diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/tutorial/StaticAnalysis.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/tutorial/StaticAnalysis.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/tutorial/StaticAnalysis.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/tutorial/StaticAnalysis.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -32,12 +32,12 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
-import org.graalvm.compiler.debug.DebugHandlersFactory;
 import org.graalvm.compiler.debug.DebugContext;
+import org.graalvm.compiler.debug.DebugHandlersFactory;
 import org.graalvm.compiler.debug.GraalError;
 import org.graalvm.compiler.graph.Node;
 import org.graalvm.compiler.graph.NodeMap;
 import org.graalvm.compiler.java.GraphBuilderPhase;
 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
@@ -56,19 +56,18 @@
 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 import org.graalvm.compiler.nodes.java.NewArrayNode;
 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 import org.graalvm.compiler.nodes.java.StoreFieldNode;
-import org.graalvm.compiler.nodes.spi.StampProvider;
+import org.graalvm.compiler.nodes.spi.CoreProviders;
 import org.graalvm.compiler.nodes.util.GraphUtil;
 import org.graalvm.compiler.options.OptionValues;
 import org.graalvm.compiler.phases.OptimisticOptimizations;
 import org.graalvm.compiler.phases.graph.StatelessPostOrderNodeIterator;
 
 import jdk.vm.ci.meta.JavaConstant;
 import jdk.vm.ci.meta.JavaKind;
-import jdk.vm.ci.meta.MetaAccessProvider;
 import jdk.vm.ci.meta.ResolvedJavaField;
 import jdk.vm.ci.meta.ResolvedJavaMethod;
 import jdk.vm.ci.meta.ResolvedJavaType;
 
 /**
@@ -87,22 +86,25 @@
  * list} of types assigned to the field; every Java method has {@link Results#lookupMethod one
  * state} for each {@link MethodState#formalParameters parameter} as well as the
  * {@link MethodState#formalReturn return value}.
  */
 public class StaticAnalysis {
-    /** Access to type, method, and fields using the Graal API. */
-    private final MetaAccessProvider metaAccess;
-    /** Access to platform dependent stamps. */
-    private final StampProvider stampProvider;
-    /** The results of the static analysis. */
+    /**
+     * Access to various builtin providers.
+     */
+    private final CoreProviders providers;
+    /**
+     * The results of the static analysis.
+     */
     private final Results results;
-    /** Worklist for fixpoint iteration. */
+    /**
+     * Worklist for fixpoint iteration.
+     */
     private final Deque<WorklistEntry> worklist;
 
-    public StaticAnalysis(MetaAccessProvider metaAccess, StampProvider stampProvider) {
-        this.metaAccess = metaAccess;
-        this.stampProvider = stampProvider;
+    public StaticAnalysis(CoreProviders providers) {
+        this.providers = providers;
         this.results = new Results();
         this.worklist = new ArrayDeque<>();
     }
 
     /**
@@ -271,11 +273,11 @@
                      * code before static analysis, the profiling information is empty and therefore
                      * wrong.
                      */
                     OptimisticOptimizations optimisticOpts = OptimisticOptimizations.NONE;
 
-                    GraphBuilderPhase.Instance graphBuilder = new GraphBuilderPhase.Instance(metaAccess, stampProvider, null, null, graphBuilderConfig, optimisticOpts, null);
+                    GraphBuilderPhase.Instance graphBuilder = new GraphBuilderPhase.Instance(providers, graphBuilderConfig, optimisticOpts, null);
                     graphBuilder.apply(graph);
                 } catch (Throwable ex) {
                     debug.handle(ex);
                 }
 
@@ -302,11 +304,13 @@
         protected TypeFlow() {
             types = new HashSet<>();
             uses = new HashSet<>();
         }
 
-        /** Returns the types of this element. */
+        /**
+         * Returns the types of this element.
+         */
         public Set<ResolvedJavaType> getTypes() {
             return types;
         }
 
         /**
@@ -347,11 +351,11 @@
      * {@link InvokeKind#Interface interface} calls, the {@link TypeFlow#getTypes() types} of this
      * node are the receiver types. When a new receiver type is added, a new callee might be added.
      * Adding a new callee means linking the type flow of the actual parameters with the formal
      * parameters of the callee, and linking the return value of the callee with the return value
      * state of the invocation.
-     *
+     * <p>
      * Statically bindable methods calls ({@link InvokeKind#Static static} and
      * {@link InvokeKind#Special special} calls) have only one callee, but use the same code for
      * simplicity.
      */
     class InvokeTypeFlow extends TypeFlow {

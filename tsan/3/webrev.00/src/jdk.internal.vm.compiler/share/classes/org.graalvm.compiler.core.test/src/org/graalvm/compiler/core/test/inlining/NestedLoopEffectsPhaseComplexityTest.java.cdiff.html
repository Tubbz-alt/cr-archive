<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/inlining/NestedLoopEffectsPhaseComplexityTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InliningTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../tutorial/StaticAnalysis.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/inlining/NestedLoopEffectsPhaseComplexityTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 33,22 ***</span>
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.nodes.Invoke;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
  import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.BasePhase;
  import org.graalvm.compiler.phases.OptimisticOptimizations;
  import org.graalvm.compiler.phases.PhaseSuite;
  import org.graalvm.compiler.phases.common.CanonicalizerPhase;
  import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
  import org.graalvm.compiler.phases.common.inlining.InliningUtil;
  import org.graalvm.compiler.phases.tiers.HighTierContext;
<span class="line-removed">- import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
  import org.graalvm.compiler.virtual.phases.ea.EarlyReadEliminationPhase;
  import org.graalvm.compiler.virtual.phases.ea.PartialEscapePhase;
<span class="line-removed">- </span>
  import org.junit.Rule;
  import org.junit.Test;
  import org.junit.rules.TestRule;
  
  import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="line-new-header">--- 33,21 ---</span>
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.nodes.Invoke;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
  import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.BasePhase;
  import org.graalvm.compiler.phases.OptimisticOptimizations;
  import org.graalvm.compiler.phases.PhaseSuite;
  import org.graalvm.compiler.phases.common.CanonicalizerPhase;
  import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
  import org.graalvm.compiler.phases.common.inlining.InliningUtil;
  import org.graalvm.compiler.phases.tiers.HighTierContext;
  import org.graalvm.compiler.virtual.phases.ea.EarlyReadEliminationPhase;
  import org.graalvm.compiler.virtual.phases.ea.PartialEscapePhase;
  import org.junit.Rule;
  import org.junit.Test;
  import org.junit.rules.TestRule;
  
  import jdk.vm.ci.meta.ResolvedJavaMethod;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,22 ***</span>
      private void testAndTime(String snippet) {
          for (int i = InliningCountLowerBound; i &lt; InliningCountUpperBound; i++) {
              StructuredGraph g1 = prepareGraph(snippet, i);
              StructuredGraph g2 = (StructuredGraph) g1.copy(g1.getDebug());
              ResolvedJavaMethod method = g1.method();
<span class="line-modified">!             long elapsedRE = runAndTimePhase(g1, new EarlyReadEliminationPhase(new CanonicalizerPhase()));</span>
<span class="line-modified">!             long elapsedPEA = runAndTimePhase(g2, new PartialEscapePhase(true, new CanonicalizerPhase(), g1.getOptions()));</span>
              if (LOG_PHASE_TIMINGS) {
                  TTY.printf(&quot;Needed %dms to run early partial escape analysis on a graph with %d nested loops compiling method %s\n&quot;, elapsedPEA, i, method);
              }
              if (LOG_PHASE_TIMINGS) {
                  TTY.printf(&quot;Needed %dms to run early read elimination on a graph with %d nested loops compiling method %s\n&quot;, elapsedRE, i, method);
              }
          }
      }
  
<span class="line-modified">!     private long runAndTimePhase(StructuredGraph g, BasePhase&lt;? super PhaseContext&gt; phase) {</span>
          HighTierContext context = getDefaultHighTierContext();
          long start = System.currentTimeMillis();
          phase.apply(g, context);
          long end = System.currentTimeMillis();
          DebugContext debug = g.getDebug();
<span class="line-new-header">--- 110,22 ---</span>
      private void testAndTime(String snippet) {
          for (int i = InliningCountLowerBound; i &lt; InliningCountUpperBound; i++) {
              StructuredGraph g1 = prepareGraph(snippet, i);
              StructuredGraph g2 = (StructuredGraph) g1.copy(g1.getDebug());
              ResolvedJavaMethod method = g1.method();
<span class="line-modified">!             long elapsedRE = runAndTimePhase(g1, new EarlyReadEliminationPhase(createCanonicalizerPhase()));</span>
<span class="line-modified">!             long elapsedPEA = runAndTimePhase(g2, new PartialEscapePhase(true, createCanonicalizerPhase(), g1.getOptions()));</span>
              if (LOG_PHASE_TIMINGS) {
                  TTY.printf(&quot;Needed %dms to run early partial escape analysis on a graph with %d nested loops compiling method %s\n&quot;, elapsedPEA, i, method);
              }
              if (LOG_PHASE_TIMINGS) {
                  TTY.printf(&quot;Needed %dms to run early read elimination on a graph with %d nested loops compiling method %s\n&quot;, elapsedRE, i, method);
              }
          }
      }
  
<span class="line-modified">!     private long runAndTimePhase(StructuredGraph g, BasePhase&lt;? super CoreProviders&gt; phase) {</span>
          HighTierContext context = getDefaultHighTierContext();
          long start = System.currentTimeMillis();
          phase.apply(g, context);
          long end = System.currentTimeMillis();
          DebugContext debug = g.getDebug();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,11 ***</span>
      private StructuredGraph prepareGraph(String snippet, int inliningCount) {
          ResolvedJavaMethod callerMethod = getResolvedJavaMethod(snippet);
          StructuredGraph callerGraph = parseEager(callerMethod, AllowAssumptions.YES);
          PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite = getDefaultGraphBuilderSuite();
          HighTierContext context = new HighTierContext(getProviders(), graphBuilderSuite, OptimisticOptimizations.ALL);
<span class="line-modified">!         CanonicalizerPhase canonicalizer = new CanonicalizerPhase();</span>
          Invoke next = callerGraph.getNodes(MethodCallTargetNode.TYPE).first().invoke();
          StructuredGraph calleeGraph = parseBytecodes(next.callTarget().targetMethod(), context, canonicalizer);
          ResolvedJavaMethod calleeMethod = next.callTarget().targetMethod();
          for (int i = 0; i &lt; inliningCount; i++) {
              next = callerGraph.getNodes(MethodCallTargetNode.TYPE).first().invoke();
<span class="line-new-header">--- 136,11 ---</span>
      private StructuredGraph prepareGraph(String snippet, int inliningCount) {
          ResolvedJavaMethod callerMethod = getResolvedJavaMethod(snippet);
          StructuredGraph callerGraph = parseEager(callerMethod, AllowAssumptions.YES);
          PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite = getDefaultGraphBuilderSuite();
          HighTierContext context = new HighTierContext(getProviders(), graphBuilderSuite, OptimisticOptimizations.ALL);
<span class="line-modified">!         CanonicalizerPhase canonicalizer = createCanonicalizerPhase();</span>
          Invoke next = callerGraph.getNodes(MethodCallTargetNode.TYPE).first().invoke();
          StructuredGraph calleeGraph = parseBytecodes(next.callTarget().targetMethod(), context, canonicalizer);
          ResolvedJavaMethod calleeMethod = next.callTarget().targetMethod();
          for (int i = 0; i &lt; inliningCount; i++) {
              next = callerGraph.getNodes(MethodCallTargetNode.TYPE).first().invoke();
</pre>
<center><a href="InliningTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../tutorial/StaticAnalysis.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
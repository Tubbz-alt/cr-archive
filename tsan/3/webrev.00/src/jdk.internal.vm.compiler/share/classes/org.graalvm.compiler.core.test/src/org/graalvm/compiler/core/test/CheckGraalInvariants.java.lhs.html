<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/CheckGraalInvariants.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import java.io.File;
 28 import java.io.IOException;
 29 import java.io.PrintWriter;
 30 import java.io.StringWriter;
 31 import java.lang.annotation.Annotation;
 32 import java.lang.reflect.Method;
 33 import java.lang.reflect.Modifier;
 34 import java.util.ArrayList;
<a name="2" id="anc2"></a>
 35 import java.util.Collections;
 36 import java.util.Enumeration;
 37 import java.util.List;
 38 import java.util.concurrent.LinkedBlockingQueue;
 39 import java.util.concurrent.ThreadPoolExecutor;
 40 import java.util.concurrent.TimeUnit;
 41 import java.util.zip.ZipEntry;
 42 import java.util.zip.ZipFile;
 43 
 44 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 45 import org.graalvm.compiler.api.replacements.Snippet;
 46 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
 47 import org.graalvm.compiler.api.replacements.Snippet.NonNullParameter;
 48 import org.graalvm.compiler.api.replacements.Snippet.VarargsParameter;
 49 import org.graalvm.compiler.api.test.Graal;
 50 import org.graalvm.compiler.bytecode.BridgeMethodUtils;
 51 import org.graalvm.compiler.core.CompilerThreadFactory;
 52 import org.graalvm.compiler.core.common.LIRKind;
 53 import org.graalvm.compiler.core.common.type.ArithmeticOpTable;
 54 import org.graalvm.compiler.debug.DebugCloseable;
 55 import org.graalvm.compiler.debug.DebugContext;
 56 import org.graalvm.compiler.debug.DebugHandlersFactory;
 57 import org.graalvm.compiler.debug.GraalError;
 58 import org.graalvm.compiler.graph.Node;
 59 import org.graalvm.compiler.graph.NodeClass;
 60 import org.graalvm.compiler.java.GraphBuilderPhase;
 61 import org.graalvm.compiler.nodeinfo.NodeInfo;
 62 import org.graalvm.compiler.nodes.PhiNode;
 63 import org.graalvm.compiler.nodes.StructuredGraph;
 64 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 65 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 66 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 67 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
<a name="3" id="anc3"></a>
 68 import org.graalvm.compiler.options.OptionValues;
 69 import org.graalvm.compiler.phases.OptimisticOptimizations;
 70 import org.graalvm.compiler.phases.PhaseSuite;
 71 import org.graalvm.compiler.phases.VerifyPhase;
 72 import org.graalvm.compiler.phases.VerifyPhase.VerificationError;
 73 import org.graalvm.compiler.phases.contract.VerifyNodeCosts;
 74 import org.graalvm.compiler.phases.tiers.HighTierContext;
<a name="4" id="anc4"></a><span class="line-removed"> 75 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 76 import org.graalvm.compiler.phases.util.Providers;
 77 import org.graalvm.compiler.runtime.RuntimeProvider;
<a name="5" id="anc5"></a>


 78 import jdk.internal.vm.compiler.word.LocationIdentity;
 79 import org.junit.Assert;
 80 import org.junit.Assume;
 81 import org.junit.Test;
 82 
 83 import jdk.vm.ci.code.BailoutException;
 84 import jdk.vm.ci.code.Register;
 85 import jdk.vm.ci.code.Register.RegisterCategory;
 86 import jdk.vm.ci.meta.JavaField;
 87 import jdk.vm.ci.meta.JavaMethod;
 88 import jdk.vm.ci.meta.JavaType;
 89 import jdk.vm.ci.meta.MetaAccessProvider;
 90 import jdk.vm.ci.meta.ResolvedJavaMethod;
 91 import jdk.vm.ci.meta.ResolvedJavaType;
 92 import jdk.vm.ci.meta.Value;
 93 
 94 /**
 95  * Checks that all classes in *graal*.jar and *jvmci*.jar entries on the boot class path comply with
 96  * global invariants such as using {@link Object#equals(Object)} to compare certain types instead of
 97  * identity comparisons.
 98  */
<a name="6" id="anc6"></a>
 99 public class CheckGraalInvariants extends GraalCompilerTest {
100 
<a name="7" id="anc7"></a>





101     private static boolean shouldVerifyEquals(ResolvedJavaMethod m) {
102         if (m.getName().equals(&quot;identityEquals&quot;)) {
103             ResolvedJavaType c = m.getDeclaringClass();
104             if (c.getName().equals(&quot;Ljdk/vm/ci/meta/AbstractValue;&quot;) || c.getName().equals(&quot;jdk/vm/ci/meta/Value&quot;)) {
105                 return false;
106             }
107         }
108 
109         return true;
110     }
111 
112     public static String relativeFileName(String absolutePath) {
113         int lastFileSeparatorIndex = absolutePath.lastIndexOf(File.separator);
114         return absolutePath.substring(lastFileSeparatorIndex &gt;= 0 ? lastFileSeparatorIndex : 0);
115     }
116 
117     public static class InvariantsTool {
118 
119         protected boolean shouldProcess(String classpathEntry) {
<a name="8" id="anc8"></a>


120             if (classpathEntry.endsWith(&quot;.jar&quot;)) {
121                 String name = new File(classpathEntry).getName();
122                 return name.contains(&quot;jvmci&quot;) || name.contains(&quot;graal&quot;) || name.contains(&quot;jdk.internal.vm.compiler&quot;);
123             }
124             return false;
125         }
126 
127         protected String getClassPath() {
128             String bootclasspath;
<a name="9" id="anc9"></a><span class="line-modified">129             if (Java8OrEarlier) {</span>
130                 bootclasspath = System.getProperty(&quot;sun.boot.class.path&quot;);
131             } else {
<a name="10" id="anc10"></a><span class="line-modified">132                 bootclasspath = System.getProperty(&quot;jdk.module.path&quot;) + File.pathSeparatorChar + System.getProperty(&quot;jdk.module.upgrade.path&quot;);</span>
133             }
134             return bootclasspath;
135         }
136 
137         protected boolean shouldLoadClass(String className) {
138             if (className.equals(&quot;module-info&quot;) || className.startsWith(&quot;META-INF.versions.&quot;)) {
139                 return false;
140             }
<a name="11" id="anc11"></a><span class="line-modified">141             if (!Java8OrEarlier) {</span>
142                 // @formatter:off
143                 /*
144                  * Work around to prevent:
145                  *
146                  * org.graalvm.compiler.debug.GraalError: java.lang.IllegalAccessError: class org.graalvm.compiler.serviceprovider.GraalServices$Lazy (in module
147                  * jdk.internal.vm.compiler) cannot access class java.lang.management.ManagementFactory (in module java.management) because module
148                  * jdk.internal.vm.compiler does not read module java.management
149                  *     at jdk.internal.vm.compiler/org.graalvm.compiler.debug.GraalError.shouldNotReachHere(GraalError.java:55)
150                  *     at org.graalvm.compiler.core.test.CheckGraalInvariants$InvariantsTool.handleClassLoadingException(CheckGraalInvariants.java:149)
151                  *     at org.graalvm.compiler.core.test.CheckGraalInvariants.initializeClasses(CheckGraalInvariants.java:321)
152                  *     at org.graalvm.compiler.core.test.CheckGraalInvariants.runTest(CheckGraalInvariants.java:239)
153                  *
154                  * which occurs because JDK8 overlays are in modular jars. They are never used normally.
155                  */
156                 // @formatter:on
157                 if (className.equals(&quot;org.graalvm.compiler.serviceprovider.GraalServices$Lazy&quot;)) {
158                     return false;
159                 }
160             } else {
161                 if (className.equals(&quot;jdk.vm.ci.services.JVMCIClassLoaderFactory&quot;)) {
162                     return false;
163                 }
164             }
165             return true;
166         }
167 
168         protected void handleClassLoadingException(Throwable t) {
169             GraalError.shouldNotReachHere(t);
170         }
171 
172         protected void handleParsingException(Throwable t) {
173             GraalError.shouldNotReachHere(t);
174         }
175 
176         public boolean shouldVerifyFoldableMethods() {
177             return true;
178         }
<a name="12" id="anc12"></a>






179     }
180 
181     @Test
182     @SuppressWarnings(&quot;try&quot;)
183     public void test() {
184         assumeManagementLibraryIsLoadable();
185         runTest(new InvariantsTool());
186     }
187 
188     @SuppressWarnings(&quot;try&quot;)
189     public static void runTest(InvariantsTool tool) {
190         RuntimeProvider rt = Graal.getRequiredCapability(RuntimeProvider.class);
191         Providers providers = rt.getHostBackend().getProviders();
192         MetaAccessProvider metaAccess = providers.getMetaAccess();
193 
194         PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite = new PhaseSuite&lt;&gt;();
195         Plugins plugins = new Plugins(new InvocationPlugins());
196         GraphBuilderConfiguration config = GraphBuilderConfiguration.getDefault(plugins).withEagerResolving(true).withUnresolvedIsError(true);
197         graphBuilderSuite.appendPhase(new GraphBuilderPhase(config));
198         HighTierContext context = new HighTierContext(providers, graphBuilderSuite, OptimisticOptimizations.NONE);
199 
200         Assume.assumeTrue(VerifyPhase.class.desiredAssertionStatus());
201 
202         String bootclasspath = tool.getClassPath();
203         Assert.assertNotNull(&quot;Cannot find boot class path&quot;, bootclasspath);
204 
205         final List&lt;String&gt; classNames = new ArrayList&lt;&gt;();
206         for (String path : bootclasspath.split(File.pathSeparator)) {
207             if (tool.shouldProcess(path)) {
208                 try {
<a name="13" id="anc13"></a><span class="line-modified">209                     final ZipFile zipFile = new ZipFile(new File(path));</span>
<span class="line-modified">210                     for (final Enumeration&lt;? extends ZipEntry&gt; entry = zipFile.entries(); entry.hasMoreElements();) {</span>
<span class="line-removed">211                         final ZipEntry zipEntry = entry.nextElement();</span>
<span class="line-removed">212                         String name = zipEntry.getName();</span>
<span class="line-removed">213                         if (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.startsWith(&quot;META-INF/versions/&quot;)) {</span>
<span class="line-removed">214                             String className = name.substring(0, name.length() - &quot;.class&quot;.length()).replace(&#39;/&#39;, &#39;.&#39;);</span>
<span class="line-removed">215                             if (isInNativeImage(className)) {</span>
<span class="line-removed">216                                 /*</span>
<span class="line-removed">217                                  * Native Image is an external tool and does not need to follow the</span>
<span class="line-removed">218                                  * Graal invariants.</span>
<span class="line-removed">219                                  */</span>
<span class="line-removed">220                                 continue;</span>
<span class="line-removed">221                             }</span>
222                             if (isGSON(className)) {
223                                 /*
224                                  * GSON classes are compiled with old JDK
225                                  */
226                                 continue;
227                             }
228                             classNames.add(className);
229                         }
<a name="14" id="anc14"></a>






















230                     }
231                 } catch (IOException ex) {
232                     Assert.fail(ex.toString());
233                 }
234             }
235         }
236         Assert.assertFalse(&quot;Could not find graal jars on boot class path: &quot; + bootclasspath, classNames.isEmpty());
237 
238         // Allows a subset of methods to be checked through use of a system property
239         String property = System.getProperty(CheckGraalInvariants.class.getName() + &quot;.filters&quot;);
240         String[] filters = property == null ? null : property.split(&quot;,&quot;);
241 
242         OptionValues options = getInitialOptions();
243         CompilerThreadFactory factory = new CompilerThreadFactory(&quot;CheckInvariantsThread&quot;);
244         int availableProcessors = Runtime.getRuntime().availableProcessors();
245         ThreadPoolExecutor executor = new ThreadPoolExecutor(availableProcessors, availableProcessors, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), factory);
246 
247         List&lt;String&gt; errors = Collections.synchronizedList(new ArrayList&lt;&gt;());
248 
<a name="15" id="anc15"></a><span class="line-modified">249         List&lt;VerifyPhase&lt;PhaseContext&gt;&gt; verifiers = new ArrayList&lt;&gt;();</span>
250 
251         // If you add a new type to test here, be sure to add appropriate
252         // methods to the BadUsageWithEquals class below
253         verifiers.add(new VerifyUsageWithEquals(Value.class));
254         verifiers.add(new VerifyUsageWithEquals(Register.class));
255         verifiers.add(new VerifyUsageWithEquals(RegisterCategory.class));
256         verifiers.add(new VerifyUsageWithEquals(JavaType.class));
257         verifiers.add(new VerifyUsageWithEquals(JavaMethod.class));
258         verifiers.add(new VerifyUsageWithEquals(JavaField.class));
259         verifiers.add(new VerifyUsageWithEquals(LocationIdentity.class));
260         verifiers.add(new VerifyUsageWithEquals(LIRKind.class));
261         verifiers.add(new VerifyUsageWithEquals(ArithmeticOpTable.class));
262         verifiers.add(new VerifyUsageWithEquals(ArithmeticOpTable.Op.class));
263 
264         verifiers.add(new VerifyDebugUsage());
265         verifiers.add(new VerifyCallerSensitiveMethods());
266         verifiers.add(new VerifyVirtualizableUsage());
267         verifiers.add(new VerifyUpdateUsages());
268         verifiers.add(new VerifyBailoutUsage());
<a name="16" id="anc16"></a>
269         verifiers.add(new VerifyInstanceOfUsage());
270         verifiers.add(new VerifyGraphAddUsage());
<a name="17" id="anc17"></a>
271         verifiers.add(new VerifyGetOptionsUsage());
<a name="18" id="anc18"></a>
272 
273         VerifyFoldableMethods foldableMethodsVerifier = new VerifyFoldableMethods();
274         if (tool.shouldVerifyFoldableMethods()) {
275             verifiers.add(foldableMethodsVerifier);
276         }
277 
<a name="19" id="anc19"></a>

278         for (Method m : BadUsageWithEquals.class.getDeclaredMethods()) {
279             ResolvedJavaMethod method = metaAccess.lookupJavaMethod(m);
280             try (DebugContext debug = DebugContext.create(options, DebugHandlersFactory.LOADER)) {
281                 StructuredGraph graph = new StructuredGraph.Builder(options, debug, AllowAssumptions.YES).method(method).build();
282                 try (DebugCloseable s = debug.disableIntercept(); DebugContext.Scope ds = debug.scope(&quot;CheckingGraph&quot;, graph, method)) {
283                     graphBuilderSuite.apply(graph, context);
284                     // update phi stamps
285                     graph.getNodes().filter(PhiNode.class).forEach(PhiNode::inferStamp);
286                     checkGraph(verifiers, context, graph);
287                     errors.add(String.format(&quot;Expected error while checking %s&quot;, m));
288                 } catch (VerificationError e) {
289                     // expected!
290                 } catch (Throwable e) {
291                     errors.add(String.format(&quot;Error while checking %s:%n%s&quot;, m, printStackTraceToString(e)));
292                 }
293             }
294         }
295         if (errors.isEmpty()) {
296             // Order outer classes before the inner classes
297             classNames.sort((String a, String b) -&gt; a.compareTo(b));
298             // Initialize classes in single thread to avoid deadlocking issues during initialization
299             List&lt;Class&lt;?&gt;&gt; classes = initializeClasses(tool, classNames);
300             for (Class&lt;?&gt; c : classes) {
301                 String className = c.getName();
302                 executor.execute(() -&gt; {
303                     try {
<a name="20" id="anc20"></a><span class="line-modified">304                         checkClass(c, metaAccess);</span>
305                     } catch (Throwable e) {
306                         errors.add(String.format(&quot;Error while checking %s:%n%s&quot;, className, printStackTraceToString(e)));
307                     }
308                 });
309 
<a name="21" id="anc21"></a><span class="line-modified">310                 for (Method m : c.getDeclaredMethods()) {</span>
<span class="line-modified">311                     if (Modifier.isNative(m.getModifiers()) || Modifier.isAbstract(m.getModifiers())) {</span>













312                         // ignore
313                     } else {
<a name="22" id="anc22"></a><span class="line-modified">314                         String methodName = className + &quot;.&quot; + m.getName();</span>
315                         if (matches(filters, methodName)) {
316                             executor.execute(() -&gt; {
317                                 try (DebugContext debug = DebugContext.create(options, DebugHandlersFactory.LOADER)) {
<a name="23" id="anc23"></a><span class="line-removed">318                                     ResolvedJavaMethod method = metaAccess.lookupJavaMethod(m);</span>
319                                     boolean isSubstitution = method.getAnnotation(Snippet.class) != null || method.getAnnotation(MethodSubstitution.class) != null;
320                                     StructuredGraph graph = new StructuredGraph.Builder(options, debug).method(method).setIsSubstitution(isSubstitution).build();
321                                     try (DebugCloseable s = debug.disableIntercept(); DebugContext.Scope ds = debug.scope(&quot;CheckingGraph&quot;, graph, method)) {
322                                         checkMethod(method);
323                                         graphBuilderSuite.apply(graph, context);
324                                         // update phi stamps
325                                         graph.getNodes().filter(PhiNode.class).forEach(PhiNode::inferStamp);
326                                         checkGraph(verifiers, context, graph);
327                                     } catch (VerificationError e) {
328                                         errors.add(e.getMessage());
329                                     } catch (LinkageError e) {
330                                         // suppress linkages errors resulting from eager resolution
331                                     } catch (BailoutException e) {
332                                         // Graal bail outs on certain patterns in Java bytecode
333                                         // (e.g.,
334                                         // unbalanced monitors introduced by jacoco).
335                                     } catch (Throwable e) {
336                                         try {
337                                             tool.handleParsingException(e);
338                                         } catch (Throwable t) {
339                                             errors.add(String.format(&quot;Error while checking %s:%n%s&quot;, methodName, printStackTraceToString(e)));
340                                         }
341                                     }
342                                 }
343                             });
344                         }
345                     }
346                 }
347             }
348 
349             executor.shutdown();
350             try {
351                 executor.awaitTermination(1, TimeUnit.HOURS);
352             } catch (InterruptedException e1) {
353                 throw new RuntimeException(e1);
354             }
355 
356             if (tool.shouldVerifyFoldableMethods()) {
357                 try {
358                     foldableMethodsVerifier.finish();
359                 } catch (Throwable e) {
360                     errors.add(e.getMessage());
361                 }
362             }
363         }
364         if (!errors.isEmpty()) {
365             StringBuilder msg = new StringBuilder();
366             String nl = String.format(&quot;%n&quot;);
367             for (String e : errors) {
368                 if (msg.length() != 0) {
369                     msg.append(nl);
370                 }
371                 msg.append(e);
372             }
373             Assert.fail(msg.toString());
374         }
375     }
376 
377     private static boolean isInNativeImage(String className) {
378         return className.startsWith(&quot;org.graalvm.nativeimage&quot;);
379     }
380 
381     private static boolean isGSON(String className) {
382         return className.contains(&quot;com.google.gson&quot;);
383     }
384 
385     private static List&lt;Class&lt;?&gt;&gt; initializeClasses(InvariantsTool tool, List&lt;String&gt; classNames) {
386         List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;(classNames.size());
387         for (String className : classNames) {
388             if (!tool.shouldLoadClass(className)) {
389                 continue;
390             }
391             try {
392                 Class&lt;?&gt; c = Class.forName(className, true, CheckGraalInvariants.class.getClassLoader());
393                 classes.add(c);
<a name="24" id="anc24"></a>









394             } catch (Throwable t) {
395                 tool.handleClassLoadingException(t);
396             }
397         }
398         return classes;
399     }
400 
401     /**
402      * @param metaAccess
<a name="25" id="anc25"></a>
403      */
<a name="26" id="anc26"></a><span class="line-modified">404     private static void checkClass(Class&lt;?&gt; c, MetaAccessProvider metaAccess) {</span>
405         if (Node.class.isAssignableFrom(c)) {
406             if (c.getAnnotation(NodeInfo.class) == null) {
407                 throw new AssertionError(String.format(&quot;Node subclass %s requires %s annotation&quot;, c.getName(), NodeClass.class.getSimpleName()));
408             }
409             VerifyNodeCosts.verifyNodeClass(c);
410         }
<a name="27" id="anc27"></a>


411     }
412 
413     private static void checkMethod(ResolvedJavaMethod method) {
414         if (method.getAnnotation(Snippet.class) == null) {
415             Annotation[][] parameterAnnotations = method.getParameterAnnotations();
416             for (int i = 0; i &lt; parameterAnnotations.length; i++) {
417                 for (Annotation a : parameterAnnotations[i]) {
418                     Class&lt;? extends Annotation&gt; annotationType = a.annotationType();
419                     if (annotationType == ConstantParameter.class || annotationType == VarargsParameter.class || annotationType == NonNullParameter.class) {
420                         VerificationError verificationError = new VerificationError(&quot;Parameter %d of %s is annotated with %s but the method is not annotated with %s&quot;, i, method,
421                                         annotationType.getSimpleName(),
422                                         Snippet.class.getSimpleName());
423                         throw verificationError;
424                     }
425                 }
426             }
427         }
428     }
429 
430     /**
431      * Checks the invariants for a single graph.
432      */
<a name="28" id="anc28"></a><span class="line-modified">433     private static void checkGraph(List&lt;VerifyPhase&lt;PhaseContext&gt;&gt; verifiers, HighTierContext context, StructuredGraph graph) {</span>
<span class="line-modified">434         for (VerifyPhase&lt;PhaseContext&gt; verifier : verifiers) {</span>
435             if (!(verifier instanceof VerifyUsageWithEquals) || shouldVerifyEquals(graph.method())) {
436                 verifier.apply(graph, context);
437             } else {
438                 verifier.apply(graph, context);
439             }
440         }
441         if (graph.method().isBridge()) {
442             BridgeMethodUtils.getBridgedMethod(graph.method());
443         }
444     }
445 
446     private static boolean matches(String[] filters, String s) {
447         if (filters == null || filters.length == 0) {
448             return true;
449         }
450         for (String filter : filters) {
451             if (s.contains(filter)) {
452                 return true;
453             }
454         }
455         return false;
456     }
457 
458     private static String printStackTraceToString(Throwable t) {
459         StringWriter sw = new StringWriter();
460         t.printStackTrace(new PrintWriter(sw));
461         return sw.toString();
462     }
463 
464     static class BadUsageWithEquals {
465         Value aValue;
466         Register aRegister;
467         RegisterCategory aRegisterCategory;
468         JavaType aJavaType;
469         JavaField aJavaField;
470         JavaMethod aJavaMethod;
471         LocationIdentity aLocationIdentity;
472         LIRKind aLIRKind;
473         ArithmeticOpTable anArithmeticOpTable;
474         ArithmeticOpTable.Op anArithmeticOpTableOp;
475 
476         static Value aStaticValue;
477         static Register aStaticRegister;
478         static RegisterCategory aStaticRegisterCategory;
479         static JavaType aStaticJavaType;
480         static JavaField aStaticJavaField;
481         static JavaMethod aStaticJavaMethod;
482         static LocationIdentity aStaticLocationIdentity;
483         static LIRKind aStaticLIRKind;
484         static ArithmeticOpTable aStaticArithmeticOpTable;
485         static ArithmeticOpTable.Op aStaticArithmeticOpTableOp;
486 
487         boolean test01(Value f) {
488             return aValue == f;
489         }
490 
491         boolean test02(Register f) {
492             return aRegister == f;
493         }
494 
495         boolean test03(RegisterCategory f) {
496             return aRegisterCategory == f;
497         }
498 
499         boolean test04(JavaType f) {
500             return aJavaType == f;
501         }
502 
503         boolean test05(JavaField f) {
504             return aJavaField == f;
505         }
506 
507         boolean test06(JavaMethod f) {
508             return aJavaMethod == f;
509         }
510 
511         boolean test07(LocationIdentity f) {
512             return aLocationIdentity == f;
513         }
514 
515         boolean test08(LIRKind f) {
516             return aLIRKind == f;
517         }
518 
519         boolean test09(ArithmeticOpTable f) {
520             return anArithmeticOpTable == f;
521         }
522 
523         boolean test10(ArithmeticOpTable.Op f) {
524             return anArithmeticOpTableOp == f;
525         }
526 
527         boolean test12(Value f) {
528             return aStaticValue == f;
529         }
530 
531         boolean test13(Register f) {
532             return aStaticRegister == f;
533         }
534 
535         boolean test14(RegisterCategory f) {
536             return aStaticRegisterCategory == f;
537         }
538 
539         boolean test15(JavaType f) {
540             return aStaticJavaType == f;
541         }
542 
543         boolean test16(JavaField f) {
544             return aStaticJavaField == f;
545         }
546 
547         boolean test17(JavaMethod f) {
548             return aStaticJavaMethod == f;
549         }
550 
551         boolean test18(LocationIdentity f) {
552             return aStaticLocationIdentity == f;
553         }
554 
555         boolean test19(LIRKind f) {
556             return aStaticLIRKind == f;
557         }
558 
559         boolean test20(ArithmeticOpTable f) {
560             return aStaticArithmeticOpTable == f;
561         }
562 
563         boolean test21(ArithmeticOpTable.Op f) {
564             return aStaticArithmeticOpTableOp == f;
565         }
566     }
567 }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
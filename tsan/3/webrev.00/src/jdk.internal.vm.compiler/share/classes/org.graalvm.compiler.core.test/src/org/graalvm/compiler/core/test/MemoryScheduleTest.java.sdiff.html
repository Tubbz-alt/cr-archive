<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/MemoryScheduleTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryGraphCanonicalizeTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MergeCanonicalizerTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/MemoryScheduleTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.OptImplicitNullChecks;
 28 import static org.graalvm.compiler.core.common.GraalOptions.OptScheduleOutOfLoops;
 29 import static org.graalvm.compiler.graph.test.matchers.NodeIterableCount.hasCount;
 30 import static org.hamcrest.core.IsInstanceOf.instanceOf;
 31 import static org.junit.Assert.assertThat;
 32 
 33 import java.util.ArrayList;
 34 import java.util.List;
 35 
 36 import org.graalvm.compiler.api.directives.GraalDirectives;
 37 import org.graalvm.compiler.debug.DebugContext;
 38 import org.graalvm.compiler.graph.Node;
 39 import org.graalvm.compiler.graph.iterators.NodeIterable;
 40 import org.graalvm.compiler.nodes.ReturnNode;
<span class="line-removed"> 41 import org.graalvm.compiler.nodes.StartNode;</span>
 42 import org.graalvm.compiler.nodes.StructuredGraph;
 43 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 44 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 45 import org.graalvm.compiler.nodes.cfg.Block;
 46 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
 47 import org.graalvm.compiler.nodes.memory.WriteNode;
 48 import org.graalvm.compiler.nodes.spi.LoweringTool;
 49 import org.graalvm.compiler.options.OptionValues;
 50 import org.graalvm.compiler.phases.OptimisticOptimizations;
 51 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 52 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 53 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 54 import org.graalvm.compiler.phases.common.LoweringPhase;
 55 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 56 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 57 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
 58 import org.graalvm.compiler.phases.tiers.HighTierContext;
 59 import org.graalvm.compiler.phases.tiers.MidTierContext;
 60 import org.junit.Assert;
 61 import org.junit.Test;
</pre>
<hr />
<pre>
160     /**
161      * Here the read should not float to the end.
162      */
163     public static int testLoop1Snippet(int a, int b) {
164         try {
165             return container.a;
166         } finally {
167             for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
168                 if (b &lt; 0) {
169                     container.b = 10;
170                 } else {
171                     container.a = 15;
172                 }
173             }
174         }
175     }
176 
177     @Test
178     public void testLoop1() {
179         ScheduleResult schedule = getFinalSchedule(&quot;testLoop1Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">180         assertDeepEquals(6, schedule.getCFG().getBlocks().length);</span>
181         assertReadWithinStartBlock(schedule, true);
182         assertReadWithinAllReturnBlocks(schedule, false);
183     }
184 
185     /**
186      * Here the read should float to the end.
187      */
188     public static int testLoop2Snippet(int a, int b) {
189         try {
190             return container.a;
191         } finally {
192             for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
193                 if (b &lt; 0) {
194                     container.b = 10;
195                 } else {
196                     container.c = 15;
197                 }
198             }
199         }
200     }
201 
202     @Test
203     public void testLoop2() {
204         ScheduleResult schedule = getFinalSchedule(&quot;testLoop2Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">205         assertDeepEquals(6, schedule.getCFG().getBlocks().length);</span>
206         assertReadWithinStartBlock(schedule, false);
207         assertReadWithinAllReturnBlocks(schedule, true);
208     }
209 
210     /**
211      * Here the read should float out of the loop.
212      */
213     public static int testLoop3Snippet(int a) {
214         int j = 0;
215         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
216             if (i - container.a == 0) {
217                 break;
218             }
219             j++;
220         }
221         return j;
222     }
223 
224     @Test
225     public void testLoop3() {
226         ScheduleResult schedule = getFinalSchedule(&quot;testLoop3Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">227         assertDeepEquals(6, schedule.getCFG().getBlocks().length);</span>
228         assertReadWithinStartBlock(schedule, true);
229         assertReadWithinAllReturnBlocks(schedule, false);
230     }
231 
232     public String testStringReplaceSnippet(String input) {
233         return input.replace(&#39;a&#39;, &#39;b&#39;);
234     }
235 
236     @Test
237     public void testStringReplace() {
238         getFinalSchedule(&quot;testStringReplaceSnippet&quot;, TestMode.INLINED_WITHOUT_FRAMESTATES);
239         test(&quot;testStringReplaceSnippet&quot;, &quot;acbaaa&quot;);
240     }
241 
242     /**
243      * Here the read should float out of the loop.
244      */
245     public static int testLoop5Snippet(int a, int b, MemoryScheduleTest obj) {
246         int ret = 0;
247         int bb = b;
248         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
249             ret = obj.hash;
250             if (a &gt; 10) {
251                 bb++;
252             } else {
253                 bb--;
254             }
255             ret = ret / 10;
256         }
257         return ret + bb;
258     }
259 
260     @Test
261     public void testLoop5() {
262         ScheduleResult schedule = getFinalSchedule(&quot;testLoop5Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">263         assertDeepEquals(10, schedule.getCFG().getBlocks().length);</span>
264         assertReadWithinStartBlock(schedule, false);
265         assertReadWithinAllReturnBlocks(schedule, false);
266     }
267 
268     /**
269      * Here the read should not float out of the loop.
270      */
271     public static int testLoop6Snippet(int a, int b, MemoryScheduleTest obj) {
272         int ret = 0;
273         int bb = b;
274         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
275             ret = obj.hash;
276             if (a &gt; 10) {
277                 bb++;
278             } else {
279                 bb--;
280                 for (int j = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, j &lt; b); ++j) {
281                     obj.hash = 3;
282                 }
283             }
284             ret = ret / 10;
285         }
286         return ret + bb;
287     }
288 
289     @Test
290     public void testLoop6() {
291         ScheduleResult schedule = getFinalSchedule(&quot;testLoop6Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">292         assertDeepEquals(13, schedule.getCFG().getBlocks().length);</span>
293         assertReadWithinStartBlock(schedule, false);
294         assertReadWithinAllReturnBlocks(schedule, false);
295     }
296 
297     /**
298      * Here the read should not float out of the loop.
299      */
300     public static int testLoop7Snippet(int a, int b, MemoryScheduleTest obj) {
301         int ret = 0;
302         int bb = b;
303         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
304             ret = obj.hash;
305             if (a &gt; 10) {
306                 bb++;
307             } else {
308                 bb--;
309                 for (int k = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, k &lt; a); ++k) {
310                     if (k % 2 == 1) {
311                         for (int j = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, j &lt; b); ++j) {
312                             obj.hash = 3;
313                         }
314                     }
315                 }
316             }
317             ret = ret / 10;
318         }
319         return ret + bb;
320     }
321 
322     @Test
323     public void testLoop7() {
324         ScheduleResult schedule = getFinalSchedule(&quot;testLoop7Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">325         assertDeepEquals(18, schedule.getCFG().getBlocks().length);</span>
326         assertReadWithinStartBlock(schedule, false);
327         assertReadWithinAllReturnBlocks(schedule, false);
328     }
329 
330     /**
331      * Here the read should not float to the end.
332      */
333     public static int testLoop8Snippet(int a, int b) {
334         int result = container.a;
335         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
336             if (b &lt; 0) {
337                 container.b = 10;
338                 break;
339             } else {
340                 for (int j = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, j &lt; b); j++) {
341                     container.a = 0;
342                 }
343             }
344         }
345         GraalDirectives.controlFlowAnchor();
346         return result;
347     }
348 
349     @Test
350     public void testLoop8() {
351         ScheduleResult schedule = getFinalSchedule(&quot;testLoop8Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">352         assertDeepEquals(10, schedule.getCFG().getBlocks().length);</span>
353         assertReadWithinStartBlock(schedule, true);
354         assertReadWithinAllReturnBlocks(schedule, false);
355     }
356 
357     /**
358      * Here the read should float after the loop.
359      */
360     public static int testLoop9Snippet(int a, int b) {
361         container.a = b;
362         for (int i = 0; i &lt; a; i++) {
363             container.a = i;
364         }
365         GraalDirectives.controlFlowAnchor();
366         return container.a;
367     }
368 
369     @Test
370     public void testLoop9() {
371         ScheduleResult schedule = getFinalSchedule(&quot;testLoop9Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
372         StructuredGraph graph = schedule.getCFG().getStartBlock().getBeginNode().graph();
</pre>
<hr />
<pre>
374         ReturnNode ret = graph.getNodes(ReturnNode.TYPE).first();
375         assertThat(ret.result(), instanceOf(FloatingReadNode.class));
376         Block readBlock = schedule.getNodeToBlockMap().get(ret.result());
377         Assert.assertEquals(0, readBlock.getLoopDepth());
378     }
379 
380     /**
381      * Here the read should not float to the end.
382      */
383     public static int testIfRead1Snippet(int a) {
384         int res = container.a;
385         if (a &lt; 0) {
386             container.a = 10;
387         }
388         return res;
389     }
390 
391     @Test
392     public void testIfRead1() {
393         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead1Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">394         assertDeepEquals(3, schedule.getCFG().getBlocks().length);</span>
395         assertReadWithinStartBlock(schedule, true);
396         assertReadAndWriteInSameBlock(schedule, false);
397     }
398 
399     /**
400      * Here the read should float in the else block.
401      */
402     public static int testIfRead2Snippet(int a) {
403         int res = 0;
404         if (a &lt; 0) {
405             container.a = 10;
406         } else {
407             res = container.a;
408         }
409         return res;
410     }
411 
412     @Test
413     public void testIfRead2() {
414         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead2Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">415         assertDeepEquals(3, schedule.getCFG().getBlocks().length);</span>
416         assertDeepEquals(1, schedule.getCFG().graph.getNodes().filter(FloatingReadNode.class).count());
417         assertReadWithinStartBlock(schedule, false);
418         assertReadWithinAllReturnBlocks(schedule, false);
419         assertReadAndWriteInSameBlock(schedule, false);
420     }
421 
422     /**
423      * Here the read should float to the end, right before the write.
424      */
425     public static int testIfRead3Snippet(int a) {
426         if (a &lt; 0) {
427             container.a = 10;
428         }
429         int res = container.a;
430         container.a = 20;
431         return res;
432     }
433 
434     @Test
435     public void testIfRead3() {
436         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead3Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">437         assertDeepEquals(4, schedule.getCFG().getBlocks().length);</span>
438         assertReadWithinStartBlock(schedule, false);
439         assertReadWithinAllReturnBlocks(schedule, true);
440     }
441 
442     /**
443      * Here the read should be just in the if branch (with the write).
444      */
445     public static int testIfRead4Snippet(int a) {
446         if (a &gt; 0) {
447             int res = container.a;
448             container.a = 0x20;
449             return res;
450         } else {
451             return 0x10;
452         }
453     }
454 
455     @Test
456     public void testIfRead4() {
457         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead4Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">458         assertDeepEquals(3, schedule.getCFG().getBlocks().length);</span>
459         assertReadWithinStartBlock(schedule, false);
460         assertReadWithinAllReturnBlocks(schedule, false);
461         assertReadAndWriteInSameBlock(schedule, true);
462     }
463 
464     /**
465      * Here the read should float to the end.
466      */
467     public static int testIfRead5Snippet(int a) {
468         if (a &lt; 0) {
469             container.a = 10;
470         }
471         return container.a;
472     }
473 
474     @Test
475     public void testIfRead5() {
476         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead5Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">477         assertDeepEquals(4, schedule.getCFG().getBlocks().length);</span>
478         assertReadWithinStartBlock(schedule, false);
479         assertReadWithinAllReturnBlocks(schedule, true);
480         assertReadAndWriteInSameBlock(schedule, false);
481     }
482 
483     public static int testAntiDependencySnippet(int a) {
484         /*
485          * This read must not be scheduled after the following write.
486          */
487         int res = container.a;
488         container.a = 10;
489 
490         /*
491          * Add some more basic blocks.
492          */
493         if (a &lt; 0) {
494             container.b = 20;
495         }
496         container.c = 30;
497         return res;
498     }
499 
500     @Test
501     public void testAntiDependency() {
502         ScheduleResult schedule = getFinalSchedule(&quot;testAntiDependencySnippet&quot;, TestMode.WITHOUT_FRAMESTATES);
<span class="line-removed">503         assertDeepEquals(4, schedule.getCFG().getBlocks().length);</span>
504         assertReadBeforeAllWritesInStartBlock(schedule);
505     }
506 
507     /**
508      * testing scheduling within a block.
509      */
510     public static int testBlockScheduleSnippet() {
511         int res = 0;
512         container.a = 0x00;
513         container.a = 0x10;
514         container.a = 0x20;
515         container.a = 0x30;
516         container.a = 0x40;
517         res = container.a;
518         container.a = 0x50;
519         container.a = 0x60;
520         container.a = 0x70;
521         return res;
522     }
523 
524     @Test
525     public void testBlockSchedule() {
526         ScheduleResult schedule = getFinalSchedule(&quot;testBlockScheduleSnippet&quot;, TestMode.WITHOUT_FRAMESTATES);
527         StructuredGraph graph = schedule.getCFG().graph;
528         NodeIterable&lt;WriteNode&gt; writeNodes = graph.getNodes().filter(WriteNode.class);
529 
<span class="line-removed">530         assertDeepEquals(1, schedule.getCFG().getBlocks().length);</span>
531         assertDeepEquals(8, writeNodes.count());
532         assertDeepEquals(1, graph.getNodes().filter(FloatingReadNode.class).count());
533 
534         FloatingReadNode read = graph.getNodes().filter(FloatingReadNode.class).first();
535 
536         WriteNode[] writes = new WriteNode[8];
537         int i = 0;
538         for (WriteNode n : writeNodes) {
539             writes[i] = n;
540             i++;
541         }
542         assertOrderedAfterSchedule(schedule, writes[4], read);
543         assertOrderedAfterSchedule(schedule, read, writes[5]);
544         for (int j = 0; j &lt; 7; j++) {
545             assertOrderedAfterSchedule(schedule, writes[j], writes[j + 1]);
546         }
547     }
548 
549     /**
550      * read should move inside the loop (out of loop is disabled).
</pre>
<hr />
<pre>
691                 assertTrue(!writeNodeFound);
692                 readNodeFound = true;
693             } else if (node instanceof WriteNode) {
694                 writeNodeFound = true;
695             }
696         }
697         assertTrue(readNodeFound);
698     }
699 
700     private ScheduleResult getFinalSchedule(final String snippet, final TestMode mode) {
701         return getFinalSchedule(snippet, mode, SchedulingStrategy.LATEST_OUT_OF_LOOPS);
702     }
703 
704     @SuppressWarnings(&quot;try&quot;)
705     private ScheduleResult getFinalSchedule(final String snippet, final TestMode mode, final SchedulingStrategy schedulingStrategy) {
706         OptionValues options = new OptionValues(getInitialOptions(), OptScheduleOutOfLoops, schedulingStrategy == SchedulingStrategy.LATEST_OUT_OF_LOOPS, OptImplicitNullChecks, false);
707         final StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO, options);
708         DebugContext debug = graph.getDebug();
709         try (DebugContext.Scope d = debug.scope(&quot;FloatingReadTest&quot;, graph)) {
710             HighTierContext context = getDefaultHighTierContext();
<span class="line-modified">711             CanonicalizerPhase canonicalizer = new CanonicalizerPhase();</span>
712             canonicalizer.apply(graph, context);
713             if (mode == TestMode.INLINED_WITHOUT_FRAMESTATES) {
714                 createInliningPhase(canonicalizer).apply(graph, context);
715             }
716             new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, context);
717             if (mode == TestMode.WITHOUT_FRAMESTATES || mode == TestMode.INLINED_WITHOUT_FRAMESTATES) {
718                 graph.clearAllStateAfter();
719             }
720             debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;after removal of framestates&quot;);
721 
722             new FloatingReadPhase().apply(graph);
723             new RemoveValueProxyPhase().apply(graph);
724 
725             MidTierContext midContext = new MidTierContext(getProviders(), getTargetProvider(), OptimisticOptimizations.ALL, graph.getProfilingInfo());
726             new GuardLoweringPhase().apply(graph, midContext);
727             new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.MID_TIER).apply(graph, midContext);
728             new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.LOW_TIER).apply(graph, midContext);
729 
730             SchedulePhase schedule = new SchedulePhase(schedulingStrategy);
731             schedule.apply(graph);
<span class="line-removed">732             assertDeepEquals(1, graph.getNodes().filter(StartNode.class).count());</span>
733             return graph.getLastSchedule();
734         } catch (Throwable e) {
735             throw debug.handle(e);
736         }
737     }
738 }
</pre>
</td>
<td>
<hr />
<pre>
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.OptImplicitNullChecks;
 28 import static org.graalvm.compiler.core.common.GraalOptions.OptScheduleOutOfLoops;
 29 import static org.graalvm.compiler.graph.test.matchers.NodeIterableCount.hasCount;
 30 import static org.hamcrest.core.IsInstanceOf.instanceOf;
 31 import static org.junit.Assert.assertThat;
 32 
 33 import java.util.ArrayList;
 34 import java.util.List;
 35 
 36 import org.graalvm.compiler.api.directives.GraalDirectives;
 37 import org.graalvm.compiler.debug.DebugContext;
 38 import org.graalvm.compiler.graph.Node;
 39 import org.graalvm.compiler.graph.iterators.NodeIterable;
 40 import org.graalvm.compiler.nodes.ReturnNode;

 41 import org.graalvm.compiler.nodes.StructuredGraph;
 42 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 43 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 44 import org.graalvm.compiler.nodes.cfg.Block;
 45 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
 46 import org.graalvm.compiler.nodes.memory.WriteNode;
 47 import org.graalvm.compiler.nodes.spi.LoweringTool;
 48 import org.graalvm.compiler.options.OptionValues;
 49 import org.graalvm.compiler.phases.OptimisticOptimizations;
 50 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 51 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 52 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 53 import org.graalvm.compiler.phases.common.LoweringPhase;
 54 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 55 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 56 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
 57 import org.graalvm.compiler.phases.tiers.HighTierContext;
 58 import org.graalvm.compiler.phases.tiers.MidTierContext;
 59 import org.junit.Assert;
 60 import org.junit.Test;
</pre>
<hr />
<pre>
159     /**
160      * Here the read should not float to the end.
161      */
162     public static int testLoop1Snippet(int a, int b) {
163         try {
164             return container.a;
165         } finally {
166             for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
167                 if (b &lt; 0) {
168                     container.b = 10;
169                 } else {
170                     container.a = 15;
171                 }
172             }
173         }
174     }
175 
176     @Test
177     public void testLoop1() {
178         ScheduleResult schedule = getFinalSchedule(&quot;testLoop1Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);

179         assertReadWithinStartBlock(schedule, true);
180         assertReadWithinAllReturnBlocks(schedule, false);
181     }
182 
183     /**
184      * Here the read should float to the end.
185      */
186     public static int testLoop2Snippet(int a, int b) {
187         try {
188             return container.a;
189         } finally {
190             for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
191                 if (b &lt; 0) {
192                     container.b = 10;
193                 } else {
194                     container.c = 15;
195                 }
196             }
197         }
198     }
199 
200     @Test
201     public void testLoop2() {
202         ScheduleResult schedule = getFinalSchedule(&quot;testLoop2Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);

203         assertReadWithinStartBlock(schedule, false);
204         assertReadWithinAllReturnBlocks(schedule, true);
205     }
206 
207     /**
208      * Here the read should float out of the loop.
209      */
210     public static int testLoop3Snippet(int a) {
211         int j = 0;
212         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
213             if (i - container.a == 0) {
214                 break;
215             }
216             j++;
217         }
218         return j;
219     }
220 
221     @Test
222     public void testLoop3() {
223         ScheduleResult schedule = getFinalSchedule(&quot;testLoop3Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);

224         assertReadWithinStartBlock(schedule, true);
225         assertReadWithinAllReturnBlocks(schedule, false);
226     }
227 
228     public String testStringReplaceSnippet(String input) {
229         return input.replace(&#39;a&#39;, &#39;b&#39;);
230     }
231 
232     @Test
233     public void testStringReplace() {
234         getFinalSchedule(&quot;testStringReplaceSnippet&quot;, TestMode.INLINED_WITHOUT_FRAMESTATES);
235         test(&quot;testStringReplaceSnippet&quot;, &quot;acbaaa&quot;);
236     }
237 
238     /**
239      * Here the read should float out of the loop.
240      */
241     public static int testLoop5Snippet(int a, int b, MemoryScheduleTest obj) {
242         int ret = 0;
243         int bb = b;
244         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
245             ret = obj.hash;
246             if (a &gt; 10) {
247                 bb++;
248             } else {
249                 bb--;
250             }
251             ret = ret / 10;
252         }
253         return ret + bb;
254     }
255 
256     @Test
257     public void testLoop5() {
258         ScheduleResult schedule = getFinalSchedule(&quot;testLoop5Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);

259         assertReadWithinStartBlock(schedule, false);
260         assertReadWithinAllReturnBlocks(schedule, false);
261     }
262 
263     /**
264      * Here the read should not float out of the loop.
265      */
266     public static int testLoop6Snippet(int a, int b, MemoryScheduleTest obj) {
267         int ret = 0;
268         int bb = b;
269         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
270             ret = obj.hash;
271             if (a &gt; 10) {
272                 bb++;
273             } else {
274                 bb--;
275                 for (int j = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, j &lt; b); ++j) {
276                     obj.hash = 3;
277                 }
278             }
279             ret = ret / 10;
280         }
281         return ret + bb;
282     }
283 
284     @Test
285     public void testLoop6() {
286         ScheduleResult schedule = getFinalSchedule(&quot;testLoop6Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);

287         assertReadWithinStartBlock(schedule, false);
288         assertReadWithinAllReturnBlocks(schedule, false);
289     }
290 
291     /**
292      * Here the read should not float out of the loop.
293      */
294     public static int testLoop7Snippet(int a, int b, MemoryScheduleTest obj) {
295         int ret = 0;
296         int bb = b;
297         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
298             ret = obj.hash;
299             if (a &gt; 10) {
300                 bb++;
301             } else {
302                 bb--;
303                 for (int k = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, k &lt; a); ++k) {
304                     if (k % 2 == 1) {
305                         for (int j = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, j &lt; b); ++j) {
306                             obj.hash = 3;
307                         }
308                     }
309                 }
310             }
311             ret = ret / 10;
312         }
313         return ret + bb;
314     }
315 
316     @Test
317     public void testLoop7() {
318         ScheduleResult schedule = getFinalSchedule(&quot;testLoop7Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);

319         assertReadWithinStartBlock(schedule, false);
320         assertReadWithinAllReturnBlocks(schedule, false);
321     }
322 
323     /**
324      * Here the read should not float to the end.
325      */
326     public static int testLoop8Snippet(int a, int b) {
327         int result = container.a;
328         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
329             if (b &lt; 0) {
330                 container.b = 10;
331                 break;
332             } else {
333                 for (int j = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, j &lt; b); j++) {
334                     container.a = 0;
335                 }
336             }
337         }
338         GraalDirectives.controlFlowAnchor();
339         return result;
340     }
341 
342     @Test
343     public void testLoop8() {
344         ScheduleResult schedule = getFinalSchedule(&quot;testLoop8Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);

345         assertReadWithinStartBlock(schedule, true);
346         assertReadWithinAllReturnBlocks(schedule, false);
347     }
348 
349     /**
350      * Here the read should float after the loop.
351      */
352     public static int testLoop9Snippet(int a, int b) {
353         container.a = b;
354         for (int i = 0; i &lt; a; i++) {
355             container.a = i;
356         }
357         GraalDirectives.controlFlowAnchor();
358         return container.a;
359     }
360 
361     @Test
362     public void testLoop9() {
363         ScheduleResult schedule = getFinalSchedule(&quot;testLoop9Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
364         StructuredGraph graph = schedule.getCFG().getStartBlock().getBeginNode().graph();
</pre>
<hr />
<pre>
366         ReturnNode ret = graph.getNodes(ReturnNode.TYPE).first();
367         assertThat(ret.result(), instanceOf(FloatingReadNode.class));
368         Block readBlock = schedule.getNodeToBlockMap().get(ret.result());
369         Assert.assertEquals(0, readBlock.getLoopDepth());
370     }
371 
372     /**
373      * Here the read should not float to the end.
374      */
375     public static int testIfRead1Snippet(int a) {
376         int res = container.a;
377         if (a &lt; 0) {
378             container.a = 10;
379         }
380         return res;
381     }
382 
383     @Test
384     public void testIfRead1() {
385         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead1Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);

386         assertReadWithinStartBlock(schedule, true);
387         assertReadAndWriteInSameBlock(schedule, false);
388     }
389 
390     /**
391      * Here the read should float in the else block.
392      */
393     public static int testIfRead2Snippet(int a) {
394         int res = 0;
395         if (a &lt; 0) {
396             container.a = 10;
397         } else {
398             res = container.a;
399         }
400         return res;
401     }
402 
403     @Test
404     public void testIfRead2() {
405         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead2Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);

406         assertDeepEquals(1, schedule.getCFG().graph.getNodes().filter(FloatingReadNode.class).count());
407         assertReadWithinStartBlock(schedule, false);
408         assertReadWithinAllReturnBlocks(schedule, false);
409         assertReadAndWriteInSameBlock(schedule, false);
410     }
411 
412     /**
413      * Here the read should float to the end, right before the write.
414      */
415     public static int testIfRead3Snippet(int a) {
416         if (a &lt; 0) {
417             container.a = 10;
418         }
419         int res = container.a;
420         container.a = 20;
421         return res;
422     }
423 
424     @Test
425     public void testIfRead3() {
426         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead3Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);

427         assertReadWithinStartBlock(schedule, false);
428         assertReadWithinAllReturnBlocks(schedule, true);
429     }
430 
431     /**
432      * Here the read should be just in the if branch (with the write).
433      */
434     public static int testIfRead4Snippet(int a) {
435         if (a &gt; 0) {
436             int res = container.a;
437             container.a = 0x20;
438             return res;
439         } else {
440             return 0x10;
441         }
442     }
443 
444     @Test
445     public void testIfRead4() {
446         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead4Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);

447         assertReadWithinStartBlock(schedule, false);
448         assertReadWithinAllReturnBlocks(schedule, false);
449         assertReadAndWriteInSameBlock(schedule, true);
450     }
451 
452     /**
453      * Here the read should float to the end.
454      */
455     public static int testIfRead5Snippet(int a) {
456         if (a &lt; 0) {
457             container.a = 10;
458         }
459         return container.a;
460     }
461 
462     @Test
463     public void testIfRead5() {
464         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead5Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);

465         assertReadWithinStartBlock(schedule, false);
466         assertReadWithinAllReturnBlocks(schedule, true);
467         assertReadAndWriteInSameBlock(schedule, false);
468     }
469 
470     public static int testAntiDependencySnippet(int a) {
471         /*
472          * This read must not be scheduled after the following write.
473          */
474         int res = container.a;
475         container.a = 10;
476 
477         /*
478          * Add some more basic blocks.
479          */
480         if (a &lt; 0) {
481             container.b = 20;
482         }
483         container.c = 30;
484         return res;
485     }
486 
487     @Test
488     public void testAntiDependency() {
489         ScheduleResult schedule = getFinalSchedule(&quot;testAntiDependencySnippet&quot;, TestMode.WITHOUT_FRAMESTATES);

490         assertReadBeforeAllWritesInStartBlock(schedule);
491     }
492 
493     /**
494      * testing scheduling within a block.
495      */
496     public static int testBlockScheduleSnippet() {
497         int res = 0;
498         container.a = 0x00;
499         container.a = 0x10;
500         container.a = 0x20;
501         container.a = 0x30;
502         container.a = 0x40;
503         res = container.a;
504         container.a = 0x50;
505         container.a = 0x60;
506         container.a = 0x70;
507         return res;
508     }
509 
510     @Test
511     public void testBlockSchedule() {
512         ScheduleResult schedule = getFinalSchedule(&quot;testBlockScheduleSnippet&quot;, TestMode.WITHOUT_FRAMESTATES);
513         StructuredGraph graph = schedule.getCFG().graph;
514         NodeIterable&lt;WriteNode&gt; writeNodes = graph.getNodes().filter(WriteNode.class);
515 

516         assertDeepEquals(8, writeNodes.count());
517         assertDeepEquals(1, graph.getNodes().filter(FloatingReadNode.class).count());
518 
519         FloatingReadNode read = graph.getNodes().filter(FloatingReadNode.class).first();
520 
521         WriteNode[] writes = new WriteNode[8];
522         int i = 0;
523         for (WriteNode n : writeNodes) {
524             writes[i] = n;
525             i++;
526         }
527         assertOrderedAfterSchedule(schedule, writes[4], read);
528         assertOrderedAfterSchedule(schedule, read, writes[5]);
529         for (int j = 0; j &lt; 7; j++) {
530             assertOrderedAfterSchedule(schedule, writes[j], writes[j + 1]);
531         }
532     }
533 
534     /**
535      * read should move inside the loop (out of loop is disabled).
</pre>
<hr />
<pre>
676                 assertTrue(!writeNodeFound);
677                 readNodeFound = true;
678             } else if (node instanceof WriteNode) {
679                 writeNodeFound = true;
680             }
681         }
682         assertTrue(readNodeFound);
683     }
684 
685     private ScheduleResult getFinalSchedule(final String snippet, final TestMode mode) {
686         return getFinalSchedule(snippet, mode, SchedulingStrategy.LATEST_OUT_OF_LOOPS);
687     }
688 
689     @SuppressWarnings(&quot;try&quot;)
690     private ScheduleResult getFinalSchedule(final String snippet, final TestMode mode, final SchedulingStrategy schedulingStrategy) {
691         OptionValues options = new OptionValues(getInitialOptions(), OptScheduleOutOfLoops, schedulingStrategy == SchedulingStrategy.LATEST_OUT_OF_LOOPS, OptImplicitNullChecks, false);
692         final StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO, options);
693         DebugContext debug = graph.getDebug();
694         try (DebugContext.Scope d = debug.scope(&quot;FloatingReadTest&quot;, graph)) {
695             HighTierContext context = getDefaultHighTierContext();
<span class="line-modified">696             CanonicalizerPhase canonicalizer = createCanonicalizerPhase();</span>
697             canonicalizer.apply(graph, context);
698             if (mode == TestMode.INLINED_WITHOUT_FRAMESTATES) {
699                 createInliningPhase(canonicalizer).apply(graph, context);
700             }
701             new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, context);
702             if (mode == TestMode.WITHOUT_FRAMESTATES || mode == TestMode.INLINED_WITHOUT_FRAMESTATES) {
703                 graph.clearAllStateAfter();
704             }
705             debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;after removal of framestates&quot;);
706 
707             new FloatingReadPhase().apply(graph);
708             new RemoveValueProxyPhase().apply(graph);
709 
710             MidTierContext midContext = new MidTierContext(getProviders(), getTargetProvider(), OptimisticOptimizations.ALL, graph.getProfilingInfo());
711             new GuardLoweringPhase().apply(graph, midContext);
712             new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.MID_TIER).apply(graph, midContext);
713             new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.LOW_TIER).apply(graph, midContext);
714 
715             SchedulePhase schedule = new SchedulePhase(schedulingStrategy);
716             schedule.apply(graph);

717             return graph.getLastSchedule();
718         } catch (Throwable e) {
719             throw debug.handle(e);
720         }
721     }
722 }
</pre>
</td>
</tr>
</table>
<center><a href="MemoryGraphCanonicalizeTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MergeCanonicalizerTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
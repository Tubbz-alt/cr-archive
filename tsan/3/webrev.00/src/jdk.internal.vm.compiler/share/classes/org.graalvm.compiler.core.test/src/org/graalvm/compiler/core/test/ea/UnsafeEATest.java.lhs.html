<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ea/UnsafeEATest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test.ea;
 26 
 27 import java.nio.ByteBuffer;
 28 
 29 import org.graalvm.compiler.api.directives.GraalDirectives;
 30 import org.graalvm.compiler.graph.Graph;
 31 import org.graalvm.compiler.graph.Node;
 32 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 33 import org.graalvm.compiler.nodes.PhiNode;
 34 import org.graalvm.compiler.nodes.ValuePhiNode;
 35 import org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode;
 36 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 37 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 38 import org.graalvm.compiler.nodes.extended.UnsafeAccessNode;
 39 import org.graalvm.compiler.nodes.java.LoadFieldNode;
<a name="2" id="anc2"></a><span class="line-removed"> 40 import org.graalvm.compiler.phases.common.CanonicalizerPhase;</span>
 41 import org.junit.Assert;
 42 import org.junit.Test;
 43 
 44 import jdk.vm.ci.meta.JavaConstant;
 45 import jdk.vm.ci.meta.JavaKind;
 46 import jdk.vm.ci.meta.ResolvedJavaMethod;
 47 
 48 public class UnsafeEATest extends EATestBase {
 49 
 50     public static int zero = 0;
 51 
<a name="3" id="anc3"></a><span class="line-removed"> 52     private static final long fieldOffset1;</span>
<span class="line-removed"> 53     private static final long fieldOffset2;</span>
<span class="line-removed"> 54 </span>
<span class="line-removed"> 55     static {</span>
<span class="line-removed"> 56         try {</span>
<span class="line-removed"> 57             long localFieldOffset1 = UNSAFE.objectFieldOffset(TestClassInt.class.getField(&quot;x&quot;));</span>
<span class="line-removed"> 58             // Make the fields 8 byte aligned (Required for testing setLong on Architectures which</span>
<span class="line-removed"> 59             // does not support unaligned memory access</span>
<span class="line-removed"> 60             if (localFieldOffset1 % 8 == 0) {</span>
<span class="line-removed"> 61                 fieldOffset1 = localFieldOffset1;</span>
<span class="line-removed"> 62                 fieldOffset2 = UNSAFE.objectFieldOffset(TestClassInt.class.getField(&quot;y&quot;));</span>
<span class="line-removed"> 63             } else {</span>
<span class="line-removed"> 64                 fieldOffset1 = UNSAFE.objectFieldOffset(TestClassInt.class.getField(&quot;y&quot;));</span>
<span class="line-removed"> 65                 fieldOffset2 = UNSAFE.objectFieldOffset(TestClassInt.class.getField(&quot;z&quot;));</span>
<span class="line-removed"> 66             }</span>
<span class="line-removed"> 67             assert fieldOffset2 == fieldOffset1 + 4;</span>
<span class="line-removed"> 68         } catch (Exception e) {</span>
<span class="line-removed"> 69             throw new RuntimeException(e);</span>
<span class="line-removed"> 70         }</span>
<span class="line-removed"> 71     }</span>
<span class="line-removed"> 72 </span>
 73     @Override
 74     protected void testEscapeAnalysis(String snippet, JavaConstant expectedConstantResult, boolean iterativeEscapeAnalysis) {
 75         // Exercise both a graph containing UnsafeAccessNodes and one which has been possibly been
 76         // canonicalized into AccessFieldNodes.
 77         testingUnsafe = true;
 78         super.testEscapeAnalysis(snippet, expectedConstantResult, iterativeEscapeAnalysis);
 79         testingUnsafe = false;
 80         super.testEscapeAnalysis(snippet, expectedConstantResult, iterativeEscapeAnalysis);
 81         if (expectedConstantResult != null) {
 82             // Check that a compiled version of this method returns the same value if we expect a
 83             // constant result.
 84             ResolvedJavaMethod method = getResolvedJavaMethod(snippet);
 85             JavaKind[] javaKinds = method.getSignature().toParameterKinds(false);
 86             Object[] args = new Object[javaKinds.length];
 87             int i = 0;
 88             for (JavaKind k : javaKinds) {
 89                 args[i++] = JavaConstant.defaultForKind(k).asBoxedPrimitive();
 90             }
 91             Result result = executeExpected(method, null, args);
 92             assertTrue(result.returnValue.equals(expectedConstantResult.asBoxedPrimitive()));
 93         }
 94     }
 95 
 96     @Override
 97     protected void canonicalizeGraph() {
 98         if (testingUnsafe) {
 99             // For testing purposes we&#39;d like to ensure that our raw unsafe operations stay as
100             // unsafe nodes, so force them to appear to have LocationIdentity.any to disable
101             // transformation into field access nodes.
102             for (Node node : graph.getNodes().filter(x -&gt; x instanceof UnsafeAccessNode).snapshot()) {
103                 if (node instanceof RawStoreNode) {
104                     RawStoreNode store = (RawStoreNode) node;
105                     RawStoreNode newStore = graph.add(new RawStoreNode(store.object(), store.offset(), store.value(), store.accessKind(), NamedLocationIdentity.any(),
106                                     store.needsBarrier(), store.stateAfter(), true));
107                     graph.replaceFixedWithFixed(store, newStore);
108                 } else if (node instanceof RawLoadNode) {
109                     RawLoadNode load = (RawLoadNode) node;
110                     RawLoadNode newLoad = graph.add(new RawLoadNode(load.object(), load.offset(), load.accessKind(), NamedLocationIdentity.any(),
111                                     true));
112                     graph.replaceFixedWithFixed(load, newLoad);
113                 }
114             }
115         }
116         super.canonicalizeGraph();
117     }
118 
119     @Override
120     protected void postEACanonicalizeGraph() {
121         // Simplify any UnpackEndianHalfNode so we end up with constants.
122         Graph.Mark mark = graph.getMark();
123         for (UnpackEndianHalfNode node : graph.getNodes().filter(UnpackEndianHalfNode.class)) {
124             node.lower(getTarget().arch.getByteOrder());
125         }
<a name="4" id="anc4"></a><span class="line-modified">126         new CanonicalizerPhase().applyIncremental(graph, context, mark);</span>
127     }
128 
129     private boolean testingUnsafe;
130 
131     @Test
132     public void testSimpleInt() {
133         testEscapeAnalysis(&quot;testSimpleIntSnippet&quot;, JavaConstant.forInt(101), false);
134     }
135 
136     public static int testSimpleIntSnippet() {
137         TestClassInt x = new TestClassInt();
<a name="5" id="anc5"></a><span class="line-modified">138         UNSAFE.putInt(x, fieldOffset1, 101);</span>
<span class="line-modified">139         return UNSAFE.getInt(x, fieldOffset1);</span>
140     }
141 
142     @Test
143     public void testMaterializedInt() {
144         test(&quot;testMaterializedIntSnippet&quot;);
145     }
146 
147     public static TestClassInt testMaterializedIntSnippet() {
148         TestClassInt x = new TestClassInt();
<a name="6" id="anc6"></a><span class="line-modified">149         UNSAFE.putInt(x, fieldOffset1, 101);</span>
150         return x;
151     }
152 
153     @Test
154     public void testSimpleDouble() {
155         testEscapeAnalysis(&quot;testSimpleDoubleSnippet&quot;, JavaConstant.forDouble(10.1), false);
156     }
157 
158     public static double testSimpleDoubleSnippet() {
159         TestClassInt x = new TestClassInt();
<a name="7" id="anc7"></a><span class="line-modified">160         UNSAFE.putDouble(x, fieldOffset1, 10.1);</span>
<span class="line-modified">161         return UNSAFE.getDouble(x, fieldOffset1);</span>
162     }
163 
164     @Test
165     public void testSimpleDoubleOverwriteWithInt() {
166         testEscapeAnalysis(&quot;testSimpleDoubleOverwriteWithIntSnippet&quot;, JavaConstant.forInt(10), false);
167     }
168 
169     public static int testSimpleDoubleOverwriteWithIntSnippet() {
170         TestClassInt x = new TestClassInt();
<a name="8" id="anc8"></a><span class="line-modified">171         UNSAFE.putDouble(x, fieldOffset1, 10.1);</span>
<span class="line-modified">172         UNSAFE.putInt(x, fieldOffset1, 10);</span>
<span class="line-modified">173         return UNSAFE.getInt(x, fieldOffset1);</span>
174     }
175 
176     @Test
177     public void testSimpleDoubleOverwriteWithSecondInt() {
178         ByteBuffer bb = ByteBuffer.allocate(8).order(getTarget().arch.getByteOrder());
179         bb.putDouble(10.1);
180         int value = bb.getInt(4);
181 
182         testEscapeAnalysis(&quot;testSimpleDoubleOverwriteWithSecondIntSnippet&quot;, JavaConstant.forInt(value), false);
183     }
184 
185     public static int testSimpleDoubleOverwriteWithSecondIntSnippet() {
186         TestClassInt x = new TestClassInt();
<a name="9" id="anc9"></a><span class="line-modified">187         UNSAFE.putDouble(x, fieldOffset1, 10.1);</span>
<span class="line-modified">188         UNSAFE.putInt(x, fieldOffset1, 10);</span>
<span class="line-modified">189         return UNSAFE.getInt(x, fieldOffset2);</span>
190     }
191 
192     @Test
193     public void testSimpleDoubleOverwriteWithFirstInt() {
194         ByteBuffer bb = ByteBuffer.allocate(8).order(getTarget().arch.getByteOrder());
195         bb.putDouble(10.1);
196         int value = bb.getInt(0);
197 
198         testEscapeAnalysis(&quot;testSimpleDoubleOverwriteWithFirstIntSnippet&quot;, JavaConstant.forInt(value), false);
199     }
200 
201     public static int testSimpleDoubleOverwriteWithFirstIntSnippet() {
202         TestClassInt x = new TestClassInt();
<a name="10" id="anc10"></a><span class="line-modified">203         UNSAFE.putDouble(x, fieldOffset1, 10.1);</span>
<span class="line-modified">204         UNSAFE.putInt(x, fieldOffset2, 10);</span>
<span class="line-modified">205         return UNSAFE.getInt(x, fieldOffset1);</span>
206     }
207 
208     @Test
209     public void testSimpleLongOverwriteWithSecondInt() {
210         ByteBuffer bb = ByteBuffer.allocate(8).order(getTarget().arch.getByteOrder());
211         bb.putLong(0, 0x1122334455667788L);
212         int value = bb.getInt(4);
213 
214         testEscapeAnalysis(&quot;testSimpleLongOverwriteWithSecondIntSnippet&quot;, JavaConstant.forInt(value), false);
215     }
216 
217     public static int testSimpleLongOverwriteWithSecondIntSnippet() {
218         TestClassInt x = new TestClassInt();
<a name="11" id="anc11"></a><span class="line-modified">219         UNSAFE.putLong(x, fieldOffset1, 0x1122334455667788L);</span>
<span class="line-modified">220         UNSAFE.putInt(x, fieldOffset1, 10);</span>
<span class="line-modified">221         return UNSAFE.getInt(x, fieldOffset2);</span>
222     }
223 
224     @Test
225     public void testSimpleLongOverwriteWithFirstInt() {
226         ByteBuffer bb = ByteBuffer.allocate(8).order(getTarget().arch.getByteOrder());
227         bb.putLong(0, 0x1122334455667788L);
228         int value = bb.getInt(0);
229 
230         testEscapeAnalysis(&quot;testSimpleLongOverwriteWithFirstIntSnippet&quot;, JavaConstant.forInt(value), false);
231     }
232 
233     public static int testSimpleLongOverwriteWithFirstIntSnippet() {
234         TestClassInt x = new TestClassInt();
<a name="12" id="anc12"></a><span class="line-modified">235         UNSAFE.putLong(x, fieldOffset1, 0x1122334455667788L);</span>
<span class="line-modified">236         UNSAFE.putInt(x, fieldOffset2, 10);</span>
<span class="line-modified">237         return UNSAFE.getInt(x, fieldOffset1);</span>
238     }
239 
240     @Test
241     public void testMergedDouble() {
242         testEscapeAnalysis(&quot;testMergedDoubleSnippet&quot;, null, false);
243         Assert.assertEquals(1, returnNodes.size());
244         Assert.assertTrue(returnNodes.get(0).result() instanceof ValuePhiNode);
245         PhiNode phi = (PhiNode) returnNodes.get(0).result();
246         Assert.assertTrue(phi.valueAt(0) instanceof LoadFieldNode);
247         Assert.assertTrue(phi.valueAt(1) instanceof LoadFieldNode);
248     }
249 
250     public static double testMergedDoubleSnippet(boolean a) {
251         TestClassInt x;
252         if (a) {
253             x = new TestClassInt(0, 0);
<a name="13" id="anc13"></a><span class="line-modified">254             UNSAFE.putDouble(x, fieldOffset1, doubleField);</span>
255         } else {
256             x = new TestClassInt();
<a name="14" id="anc14"></a><span class="line-modified">257             UNSAFE.putDouble(x, fieldOffset1, doubleField2);</span>
258         }
<a name="15" id="anc15"></a><span class="line-modified">259         return UNSAFE.getDouble(x, fieldOffset1);</span>
260     }
261 
262     static class ExtendedTestClassInt extends TestClassInt {
263         public long l;
264     }
265 
266     @Test
267     public void testMergedVirtualObjects() {
268         testEscapeAnalysis(&quot;testMergedVirtualObjectsSnippet&quot;, null, false);
269     }
270 
271     public static TestClassInt testMergedVirtualObjectsSnippet(int value) {
272         TestClassInt x;
273         if (value == 1) {
274             x = new TestClassInt();
<a name="16" id="anc16"></a><span class="line-modified">275             UNSAFE.putDouble(x, fieldOffset1, 10);</span>
276         } else {
277             x = new TestClassInt();
<a name="17" id="anc17"></a><span class="line-modified">278             UNSAFE.putInt(x, fieldOffset1, 0);</span>
279         }
<a name="18" id="anc18"></a><span class="line-modified">280         UNSAFE.putInt(x, fieldOffset1, 0);</span>
281         if (value == 2) {
<a name="19" id="anc19"></a><span class="line-modified">282             UNSAFE.putInt(x, fieldOffset2, 0);</span>
283         }
284         GraalDirectives.deoptimizeAndInvalidate();
285         return x;
286     }
287 
288     @Test
289     public void testMaterializedDouble() {
290         test(&quot;testMaterializedDoubleSnippet&quot;);
291     }
292 
293     public static TestClassInt testMaterializedDoubleSnippet() {
294         TestClassInt x = new TestClassInt();
<a name="20" id="anc20"></a><span class="line-modified">295         UNSAFE.putDouble(x, fieldOffset1, 10.1);</span>
296         return x;
297     }
298 
299     @Test
300     public void testDeoptDoubleVar() {
301         test(&quot;testDeoptDoubleVarSnippet&quot;);
302     }
303 
304     public static double doubleField = 10.1e99;
305     public static double doubleField2;
306 
307     public static TestClassInt testDeoptDoubleVarSnippet() {
308         TestClassInt x = new TestClassInt();
<a name="21" id="anc21"></a><span class="line-modified">309         UNSAFE.putDouble(x, fieldOffset1, doubleField);</span>
310         doubleField2 = 123;
311         try {
<a name="22" id="anc22"></a><span class="line-modified">312             doubleField = ((int) UNSAFE.getDouble(x, fieldOffset1)) / zero;</span>
313         } catch (RuntimeException e) {
314             return x;
315         }
316         return x;
317     }
318 
319     @Test
320     public void testDeoptDoubleConstant() {
321         test(&quot;testDeoptDoubleConstantSnippet&quot;);
322     }
323 
324     public static TestClassInt testDeoptDoubleConstantSnippet() {
325         TestClassInt x = new TestClassInt();
<a name="23" id="anc23"></a><span class="line-modified">326         UNSAFE.putDouble(x, fieldOffset1, 10.123);</span>
327         doubleField2 = 123;
328         try {
<a name="24" id="anc24"></a><span class="line-modified">329             doubleField = ((int) UNSAFE.getDouble(x, fieldOffset1)) / zero;</span>
330         } catch (RuntimeException e) {
331             return x;
332         }
333         return x;
334     }
335 
336     @Test
337     public void testDeoptLongVar() {
338         test(&quot;testDeoptLongVarSnippet&quot;);
339     }
340 
341     public static long longField = 0x133443218aaaffffL;
342     public static long longField2;
343 
344     public static TestClassInt testDeoptLongVarSnippet() {
345         TestClassInt x = new TestClassInt();
<a name="25" id="anc25"></a><span class="line-modified">346         UNSAFE.putLong(x, fieldOffset1, longField);</span>
347         longField2 = 123;
348         try {
<a name="26" id="anc26"></a><span class="line-modified">349             longField = UNSAFE.getLong(x, fieldOffset1) / zero;</span>
350         } catch (RuntimeException e) {
351             return x;
352         }
353         return x;
354     }
355 
356     @Test
357     public void testDeoptLongConstant() {
358         test(&quot;testDeoptLongConstantSnippet&quot;);
359     }
360 
361     public static TestClassInt testDeoptLongConstantSnippet() {
362         TestClassInt x = new TestClassInt();
<a name="27" id="anc27"></a><span class="line-modified">363         UNSAFE.putLong(x, fieldOffset1, 0x2222222210123L);</span>
364         longField2 = 123;
365         try {
<a name="28" id="anc28"></a><span class="line-modified">366             longField = UNSAFE.getLong(x, fieldOffset1) / zero;</span>
367         } catch (RuntimeException e) {
368             return x;
369         }
370         return x;
371     }
372 
373 }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
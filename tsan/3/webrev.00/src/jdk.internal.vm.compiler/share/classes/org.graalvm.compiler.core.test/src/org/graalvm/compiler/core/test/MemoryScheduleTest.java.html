<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/MemoryScheduleTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.OptImplicitNullChecks;
 28 import static org.graalvm.compiler.core.common.GraalOptions.OptScheduleOutOfLoops;
 29 import static org.graalvm.compiler.graph.test.matchers.NodeIterableCount.hasCount;
 30 import static org.hamcrest.core.IsInstanceOf.instanceOf;
 31 import static org.junit.Assert.assertThat;
 32 
 33 import java.util.ArrayList;
 34 import java.util.List;
 35 
 36 import org.graalvm.compiler.api.directives.GraalDirectives;
 37 import org.graalvm.compiler.debug.DebugContext;
 38 import org.graalvm.compiler.graph.Node;
 39 import org.graalvm.compiler.graph.iterators.NodeIterable;
 40 import org.graalvm.compiler.nodes.ReturnNode;
 41 import org.graalvm.compiler.nodes.StructuredGraph;
 42 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 43 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 44 import org.graalvm.compiler.nodes.cfg.Block;
 45 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
 46 import org.graalvm.compiler.nodes.memory.WriteNode;
 47 import org.graalvm.compiler.nodes.spi.LoweringTool;
 48 import org.graalvm.compiler.options.OptionValues;
 49 import org.graalvm.compiler.phases.OptimisticOptimizations;
 50 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 51 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 52 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 53 import org.graalvm.compiler.phases.common.LoweringPhase;
 54 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 55 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 56 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
 57 import org.graalvm.compiler.phases.tiers.HighTierContext;
 58 import org.graalvm.compiler.phases.tiers.MidTierContext;
 59 import org.junit.Assert;
 60 import org.junit.Test;
 61 
 62 /**
 63  * In these test the FrameStates are explicitly cleared out, so that the scheduling of
 64  * FloatingReadNodes depends solely on the scheduling algorithm. The FrameStates normally keep the
 65  * FloatingReadNodes above a certain point, so that they (most of the time...) magically do the
 66  * right thing.
 67  *
 68  * The scheduling shouldn&#39;t depend on FrameStates, which is tested by this class.
 69  */
 70 public class MemoryScheduleTest extends GraphScheduleTest {
 71 
 72     private enum TestMode {
 73         WITH_FRAMESTATES,
 74         WITHOUT_FRAMESTATES,
 75         INLINED_WITHOUT_FRAMESTATES
 76     }
 77 
 78     public static class Container {
 79 
 80         public int a;
 81         public int b;
 82         public int c;
 83 
 84         public Object obj;
 85     }
 86 
 87     private static final Container container = new Container();
 88     private static final List&lt;Container&gt; containerList = new ArrayList&lt;&gt;();
 89     private static final double LOOP_ENTRY_PROBABILITY = 0.9;
 90 
 91     /**
 92      * In this test the read should be scheduled before the write.
 93      */
 94     public static int testSimpleSnippet() {
 95         try {
 96             return container.a;
 97         } finally {
 98             container.a = 15;
 99         }
100     }
101 
102     @Test
103     public void testSimple() {
104         for (TestMode mode : TestMode.values()) {
105             ScheduleResult schedule = getFinalSchedule(&quot;testSimpleSnippet&quot;, mode);
106             StructuredGraph graph = schedule.getCFG().graph;
107             assertReadAndWriteInSameBlock(schedule, true);
108             assertOrderedAfterSchedule(schedule, graph.getNodes().filter(FloatingReadNode.class).first(), graph.getNodes().filter(WriteNode.class).first());
109         }
110     }
111 
112     /**
113      * In this case the read should be scheduled in the first block.
114      */
115     public static int testSplit1Snippet(int a) {
116         try {
117             return container.a;
118         } finally {
119             if (a &lt; 0) {
120                 container.a = 15;
121             } else {
122                 container.b = 15;
123             }
124         }
125     }
126 
127     @Test
128     public void testSplit1() {
129         for (TestMode mode : TestMode.values()) {
130             ScheduleResult schedule = getFinalSchedule(&quot;testSplit1Snippet&quot;, mode);
131             assertReadWithinStartBlock(schedule, true);
132             assertReadWithinAllReturnBlocks(schedule, false);
133         }
134     }
135 
136     /**
137      * Here the read should float to the end.
138      */
139     public static int testSplit2Snippet(int a) {
140         try {
141             return container.a;
142         } finally {
143             if (a &lt; 0) {
144                 container.c = 15;
145             } else {
146                 container.b = 15;
147             }
148             container.obj = null;
149         }
150     }
151 
152     @Test
153     public void testSplit2() {
154         ScheduleResult schedule = getFinalSchedule(&quot;testSplit2Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
155         assertReadWithinStartBlock(schedule, false);
156         assertReadWithinAllReturnBlocks(schedule, true);
157     }
158 
159     /**
160      * Here the read should not float to the end.
161      */
162     public static int testLoop1Snippet(int a, int b) {
163         try {
164             return container.a;
165         } finally {
166             for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
167                 if (b &lt; 0) {
168                     container.b = 10;
169                 } else {
170                     container.a = 15;
171                 }
172             }
173         }
174     }
175 
176     @Test
177     public void testLoop1() {
178         ScheduleResult schedule = getFinalSchedule(&quot;testLoop1Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
179         assertReadWithinStartBlock(schedule, true);
180         assertReadWithinAllReturnBlocks(schedule, false);
181     }
182 
183     /**
184      * Here the read should float to the end.
185      */
186     public static int testLoop2Snippet(int a, int b) {
187         try {
188             return container.a;
189         } finally {
190             for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
191                 if (b &lt; 0) {
192                     container.b = 10;
193                 } else {
194                     container.c = 15;
195                 }
196             }
197         }
198     }
199 
200     @Test
201     public void testLoop2() {
202         ScheduleResult schedule = getFinalSchedule(&quot;testLoop2Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
203         assertReadWithinStartBlock(schedule, false);
204         assertReadWithinAllReturnBlocks(schedule, true);
205     }
206 
207     /**
208      * Here the read should float out of the loop.
209      */
210     public static int testLoop3Snippet(int a) {
211         int j = 0;
212         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
213             if (i - container.a == 0) {
214                 break;
215             }
216             j++;
217         }
218         return j;
219     }
220 
221     @Test
222     public void testLoop3() {
223         ScheduleResult schedule = getFinalSchedule(&quot;testLoop3Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
224         assertReadWithinStartBlock(schedule, true);
225         assertReadWithinAllReturnBlocks(schedule, false);
226     }
227 
228     public String testStringReplaceSnippet(String input) {
229         return input.replace(&#39;a&#39;, &#39;b&#39;);
230     }
231 
232     @Test
233     public void testStringReplace() {
234         getFinalSchedule(&quot;testStringReplaceSnippet&quot;, TestMode.INLINED_WITHOUT_FRAMESTATES);
235         test(&quot;testStringReplaceSnippet&quot;, &quot;acbaaa&quot;);
236     }
237 
238     /**
239      * Here the read should float out of the loop.
240      */
241     public static int testLoop5Snippet(int a, int b, MemoryScheduleTest obj) {
242         int ret = 0;
243         int bb = b;
244         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
245             ret = obj.hash;
246             if (a &gt; 10) {
247                 bb++;
248             } else {
249                 bb--;
250             }
251             ret = ret / 10;
252         }
253         return ret + bb;
254     }
255 
256     @Test
257     public void testLoop5() {
258         ScheduleResult schedule = getFinalSchedule(&quot;testLoop5Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
259         assertReadWithinStartBlock(schedule, false);
260         assertReadWithinAllReturnBlocks(schedule, false);
261     }
262 
263     /**
264      * Here the read should not float out of the loop.
265      */
266     public static int testLoop6Snippet(int a, int b, MemoryScheduleTest obj) {
267         int ret = 0;
268         int bb = b;
269         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
270             ret = obj.hash;
271             if (a &gt; 10) {
272                 bb++;
273             } else {
274                 bb--;
275                 for (int j = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, j &lt; b); ++j) {
276                     obj.hash = 3;
277                 }
278             }
279             ret = ret / 10;
280         }
281         return ret + bb;
282     }
283 
284     @Test
285     public void testLoop6() {
286         ScheduleResult schedule = getFinalSchedule(&quot;testLoop6Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
287         assertReadWithinStartBlock(schedule, false);
288         assertReadWithinAllReturnBlocks(schedule, false);
289     }
290 
291     /**
292      * Here the read should not float out of the loop.
293      */
294     public static int testLoop7Snippet(int a, int b, MemoryScheduleTest obj) {
295         int ret = 0;
296         int bb = b;
297         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
298             ret = obj.hash;
299             if (a &gt; 10) {
300                 bb++;
301             } else {
302                 bb--;
303                 for (int k = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, k &lt; a); ++k) {
304                     if (k % 2 == 1) {
305                         for (int j = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, j &lt; b); ++j) {
306                             obj.hash = 3;
307                         }
308                     }
309                 }
310             }
311             ret = ret / 10;
312         }
313         return ret + bb;
314     }
315 
316     @Test
317     public void testLoop7() {
318         ScheduleResult schedule = getFinalSchedule(&quot;testLoop7Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
319         assertReadWithinStartBlock(schedule, false);
320         assertReadWithinAllReturnBlocks(schedule, false);
321     }
322 
323     /**
324      * Here the read should not float to the end.
325      */
326     public static int testLoop8Snippet(int a, int b) {
327         int result = container.a;
328         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a); i++) {
329             if (b &lt; 0) {
330                 container.b = 10;
331                 break;
332             } else {
333                 for (int j = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, j &lt; b); j++) {
334                     container.a = 0;
335                 }
336             }
337         }
338         GraalDirectives.controlFlowAnchor();
339         return result;
340     }
341 
342     @Test
343     public void testLoop8() {
344         ScheduleResult schedule = getFinalSchedule(&quot;testLoop8Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
345         assertReadWithinStartBlock(schedule, true);
346         assertReadWithinAllReturnBlocks(schedule, false);
347     }
348 
349     /**
350      * Here the read should float after the loop.
351      */
352     public static int testLoop9Snippet(int a, int b) {
353         container.a = b;
354         for (int i = 0; i &lt; a; i++) {
355             container.a = i;
356         }
357         GraalDirectives.controlFlowAnchor();
358         return container.a;
359     }
360 
361     @Test
362     public void testLoop9() {
363         ScheduleResult schedule = getFinalSchedule(&quot;testLoop9Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
364         StructuredGraph graph = schedule.getCFG().getStartBlock().getBeginNode().graph();
365         assertThat(graph.getNodes(ReturnNode.TYPE), hasCount(1));
366         ReturnNode ret = graph.getNodes(ReturnNode.TYPE).first();
367         assertThat(ret.result(), instanceOf(FloatingReadNode.class));
368         Block readBlock = schedule.getNodeToBlockMap().get(ret.result());
369         Assert.assertEquals(0, readBlock.getLoopDepth());
370     }
371 
372     /**
373      * Here the read should not float to the end.
374      */
375     public static int testIfRead1Snippet(int a) {
376         int res = container.a;
377         if (a &lt; 0) {
378             container.a = 10;
379         }
380         return res;
381     }
382 
383     @Test
384     public void testIfRead1() {
385         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead1Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
386         assertReadWithinStartBlock(schedule, true);
387         assertReadAndWriteInSameBlock(schedule, false);
388     }
389 
390     /**
391      * Here the read should float in the else block.
392      */
393     public static int testIfRead2Snippet(int a) {
394         int res = 0;
395         if (a &lt; 0) {
396             container.a = 10;
397         } else {
398             res = container.a;
399         }
400         return res;
401     }
402 
403     @Test
404     public void testIfRead2() {
405         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead2Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
406         assertDeepEquals(1, schedule.getCFG().graph.getNodes().filter(FloatingReadNode.class).count());
407         assertReadWithinStartBlock(schedule, false);
408         assertReadWithinAllReturnBlocks(schedule, false);
409         assertReadAndWriteInSameBlock(schedule, false);
410     }
411 
412     /**
413      * Here the read should float to the end, right before the write.
414      */
415     public static int testIfRead3Snippet(int a) {
416         if (a &lt; 0) {
417             container.a = 10;
418         }
419         int res = container.a;
420         container.a = 20;
421         return res;
422     }
423 
424     @Test
425     public void testIfRead3() {
426         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead3Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
427         assertReadWithinStartBlock(schedule, false);
428         assertReadWithinAllReturnBlocks(schedule, true);
429     }
430 
431     /**
432      * Here the read should be just in the if branch (with the write).
433      */
434     public static int testIfRead4Snippet(int a) {
435         if (a &gt; 0) {
436             int res = container.a;
437             container.a = 0x20;
438             return res;
439         } else {
440             return 0x10;
441         }
442     }
443 
444     @Test
445     public void testIfRead4() {
446         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead4Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
447         assertReadWithinStartBlock(schedule, false);
448         assertReadWithinAllReturnBlocks(schedule, false);
449         assertReadAndWriteInSameBlock(schedule, true);
450     }
451 
452     /**
453      * Here the read should float to the end.
454      */
455     public static int testIfRead5Snippet(int a) {
456         if (a &lt; 0) {
457             container.a = 10;
458         }
459         return container.a;
460     }
461 
462     @Test
463     public void testIfRead5() {
464         ScheduleResult schedule = getFinalSchedule(&quot;testIfRead5Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
465         assertReadWithinStartBlock(schedule, false);
466         assertReadWithinAllReturnBlocks(schedule, true);
467         assertReadAndWriteInSameBlock(schedule, false);
468     }
469 
470     public static int testAntiDependencySnippet(int a) {
471         /*
472          * This read must not be scheduled after the following write.
473          */
474         int res = container.a;
475         container.a = 10;
476 
477         /*
478          * Add some more basic blocks.
479          */
480         if (a &lt; 0) {
481             container.b = 20;
482         }
483         container.c = 30;
484         return res;
485     }
486 
487     @Test
488     public void testAntiDependency() {
489         ScheduleResult schedule = getFinalSchedule(&quot;testAntiDependencySnippet&quot;, TestMode.WITHOUT_FRAMESTATES);
490         assertReadBeforeAllWritesInStartBlock(schedule);
491     }
492 
493     /**
494      * testing scheduling within a block.
495      */
496     public static int testBlockScheduleSnippet() {
497         int res = 0;
498         container.a = 0x00;
499         container.a = 0x10;
500         container.a = 0x20;
501         container.a = 0x30;
502         container.a = 0x40;
503         res = container.a;
504         container.a = 0x50;
505         container.a = 0x60;
506         container.a = 0x70;
507         return res;
508     }
509 
510     @Test
511     public void testBlockSchedule() {
512         ScheduleResult schedule = getFinalSchedule(&quot;testBlockScheduleSnippet&quot;, TestMode.WITHOUT_FRAMESTATES);
513         StructuredGraph graph = schedule.getCFG().graph;
514         NodeIterable&lt;WriteNode&gt; writeNodes = graph.getNodes().filter(WriteNode.class);
515 
516         assertDeepEquals(8, writeNodes.count());
517         assertDeepEquals(1, graph.getNodes().filter(FloatingReadNode.class).count());
518 
519         FloatingReadNode read = graph.getNodes().filter(FloatingReadNode.class).first();
520 
521         WriteNode[] writes = new WriteNode[8];
522         int i = 0;
523         for (WriteNode n : writeNodes) {
524             writes[i] = n;
525             i++;
526         }
527         assertOrderedAfterSchedule(schedule, writes[4], read);
528         assertOrderedAfterSchedule(schedule, read, writes[5]);
529         for (int j = 0; j &lt; 7; j++) {
530             assertOrderedAfterSchedule(schedule, writes[j], writes[j + 1]);
531         }
532     }
533 
534     /**
535      * read should move inside the loop (out of loop is disabled).
536      */
537     public static int testBlockSchedule2Snippet(int value) {
538         int res = 0;
539 
540         container.a = value;
541         for (int i = 0; i &lt; 100; i++) {
542             if (i == 10) {
543                 return container.a;
544             }
545             res += i;
546         }
547         return res;
548     }
549 
550     @Test
551     public void testBlockSchedule2() {
552         ScheduleResult schedule = getFinalSchedule(&quot;testBlockSchedule2Snippet&quot;, TestMode.WITHOUT_FRAMESTATES, SchedulingStrategy.LATEST);
553         assertReadWithinStartBlock(schedule, false);
554         assertReadWithinAllReturnBlocks(schedule, false);
555         assertReadAndWriteInSameBlock(schedule, false);
556     }
557 
558     public static void testProxySnippet() {
559         while (container.a &lt; container.b) {
560             List&lt;Container&gt; list = new ArrayList&lt;&gt;(containerList);
561             while (container.c &lt; list.size()) {
562                 if (container.obj != null) {
563                     return;
564                 }
565                 container.c++;
566             }
567             container.a = 0;
568             container.b--;
569         }
570         container.b++;
571     }
572 
573     @Test
574     public void testProxy() {
575         ScheduleResult schedule = getFinalSchedule(&quot;testProxySnippet&quot;, TestMode.WITHOUT_FRAMESTATES);
576         assertReadWithinStartBlock(schedule, false);
577         assertReadWithinAllReturnBlocks(schedule, false);
578     }
579 
580     private int hash = 0;
581     private final char[] value = new char[3];
582 
583     public int testStringHashCodeSnippet() {
584         int h = hash;
585         if (h == 0 &amp;&amp; value.length &gt; 0) {
586             char[] val = value;
587 
588             for (int i = 0; i &lt; value.length; i++) {
589                 h = 31 * h + val[i];
590             }
591             hash = h;
592         }
593         return h;
594     }
595 
596     @Test
597     public void testStringHashCode() {
598         ScheduleResult schedule = getFinalSchedule(&quot;testStringHashCodeSnippet&quot;, TestMode.WITHOUT_FRAMESTATES);
599         assertReadWithinStartBlock(schedule, true);
600         assertReadWithinAllReturnBlocks(schedule, false);
601 
602         hash = 0x1337;
603         value[0] = &#39;a&#39;;
604         value[1] = &#39;b&#39;;
605         value[2] = &#39;c&#39;;
606         test(&quot;testStringHashCodeSnippet&quot;);
607     }
608 
609     public static int testLoop4Snippet(int count) {
610         int[] a = new int[count];
611 
612         for (int i = 0; GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; a.length); i++) {
613             a[i] = i;
614         }
615 
616         int i = 0;
617         int iwrap = count - 1;
618         int sum = 0;
619 
620         while (GraalDirectives.injectBranchProbability(LOOP_ENTRY_PROBABILITY, i &lt; count)) {
621             sum += (a[i] + a[iwrap]) / 2;
622             iwrap = i;
623             i++;
624         }
625         return sum;
626     }
627 
628     @Test
629     public void testLoop4() {
630         ScheduleResult schedule = getFinalSchedule(&quot;testLoop4Snippet&quot;, TestMode.WITHOUT_FRAMESTATES);
631         assertReadWithinStartBlock(schedule, false);
632         assertReadWithinAllReturnBlocks(schedule, false);
633     }
634 
635     private void assertReadWithinAllReturnBlocks(ScheduleResult schedule, boolean withinReturnBlock) {
636         StructuredGraph graph = schedule.getCFG().graph;
637         assertTrue(graph.getNodes(ReturnNode.TYPE).isNotEmpty());
638 
639         int withRead = 0;
640         int returnBlocks = 0;
641         for (ReturnNode returnNode : graph.getNodes(ReturnNode.TYPE)) {
642             Block block = schedule.getCFG().getNodeToBlock().get(returnNode);
643             for (Node node : schedule.getBlockToNodesMap().get(block)) {
644                 if (node instanceof FloatingReadNode) {
645                     withRead++;
646                     break;
647                 }
648             }
649             returnBlocks++;
650         }
651         assertDeepEquals(withRead == returnBlocks, withinReturnBlock);
652     }
653 
654     private void assertReadWithinStartBlock(ScheduleResult schedule, boolean withinStartBlock) {
655         boolean readEncountered = false;
656         for (Node node : schedule.getBlockToNodesMap().get(schedule.getCFG().getStartBlock())) {
657             if (node instanceof FloatingReadNode) {
658                 readEncountered = true;
659             }
660         }
661         assertDeepEquals(withinStartBlock, readEncountered);
662     }
663 
664     private static void assertReadAndWriteInSameBlock(ScheduleResult schedule, boolean inSame) {
665         StructuredGraph graph = schedule.getCFG().graph;
666         FloatingReadNode read = graph.getNodes().filter(FloatingReadNode.class).first();
667         WriteNode write = graph.getNodes().filter(WriteNode.class).first();
668         assertTrue(!(inSame ^ schedule.getCFG().blockFor(read) == schedule.getCFG().blockFor(write)));
669     }
670 
671     private static void assertReadBeforeAllWritesInStartBlock(ScheduleResult schedule) {
672         boolean writeNodeFound = false;
673         boolean readNodeFound = false;
674         for (Node node : schedule.nodesFor(schedule.getCFG().getStartBlock())) {
675             if (node instanceof FloatingReadNode) {
676                 assertTrue(!writeNodeFound);
677                 readNodeFound = true;
678             } else if (node instanceof WriteNode) {
679                 writeNodeFound = true;
680             }
681         }
682         assertTrue(readNodeFound);
683     }
684 
685     private ScheduleResult getFinalSchedule(final String snippet, final TestMode mode) {
686         return getFinalSchedule(snippet, mode, SchedulingStrategy.LATEST_OUT_OF_LOOPS);
687     }
688 
689     @SuppressWarnings(&quot;try&quot;)
690     private ScheduleResult getFinalSchedule(final String snippet, final TestMode mode, final SchedulingStrategy schedulingStrategy) {
691         OptionValues options = new OptionValues(getInitialOptions(), OptScheduleOutOfLoops, schedulingStrategy == SchedulingStrategy.LATEST_OUT_OF_LOOPS, OptImplicitNullChecks, false);
692         final StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO, options);
693         DebugContext debug = graph.getDebug();
694         try (DebugContext.Scope d = debug.scope(&quot;FloatingReadTest&quot;, graph)) {
695             HighTierContext context = getDefaultHighTierContext();
696             CanonicalizerPhase canonicalizer = createCanonicalizerPhase();
697             canonicalizer.apply(graph, context);
698             if (mode == TestMode.INLINED_WITHOUT_FRAMESTATES) {
699                 createInliningPhase(canonicalizer).apply(graph, context);
700             }
701             new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, context);
702             if (mode == TestMode.WITHOUT_FRAMESTATES || mode == TestMode.INLINED_WITHOUT_FRAMESTATES) {
703                 graph.clearAllStateAfter();
704             }
705             debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;after removal of framestates&quot;);
706 
707             new FloatingReadPhase().apply(graph);
708             new RemoveValueProxyPhase().apply(graph);
709 
710             MidTierContext midContext = new MidTierContext(getProviders(), getTargetProvider(), OptimisticOptimizations.ALL, graph.getProfilingInfo());
711             new GuardLoweringPhase().apply(graph, midContext);
712             new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.MID_TIER).apply(graph, midContext);
713             new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.LOW_TIER).apply(graph, midContext);
714 
715             SchedulePhase schedule = new SchedulePhase(schedulingStrategy);
716             schedule.apply(graph);
717             return graph.getLastSchedule();
718         } catch (Throwable e) {
719             throw debug.handle(e);
720         }
721     }
722 }
    </pre>
  </body>
</html>
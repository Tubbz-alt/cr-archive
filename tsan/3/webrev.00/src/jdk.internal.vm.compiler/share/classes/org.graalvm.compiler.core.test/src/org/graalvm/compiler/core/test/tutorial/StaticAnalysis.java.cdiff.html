<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/tutorial/StaticAnalysis.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../inlining/NestedLoopEffectsPhaseComplexityTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="StaticAnalysisTests.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/tutorial/StaticAnalysis.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 32,12 ***</span>
  import java.util.HashMap;
  import java.util.HashSet;
  import java.util.Map;
  import java.util.Set;
  
<span class="line-removed">- import org.graalvm.compiler.debug.DebugHandlersFactory;</span>
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.NodeMap;
  import org.graalvm.compiler.java.GraphBuilderPhase;
  import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
<span class="line-new-header">--- 32,12 ---</span>
  import java.util.HashMap;
  import java.util.HashSet;
  import java.util.Map;
  import java.util.Set;
  
  import org.graalvm.compiler.debug.DebugContext;
<span class="line-added">+ import org.graalvm.compiler.debug.DebugHandlersFactory;</span>
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.NodeMap;
  import org.graalvm.compiler.java.GraphBuilderPhase;
  import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 56,19 ***</span>
  import org.graalvm.compiler.nodes.java.LoadFieldNode;
  import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  import org.graalvm.compiler.nodes.java.NewArrayNode;
  import org.graalvm.compiler.nodes.java.NewInstanceNode;
  import org.graalvm.compiler.nodes.java.StoreFieldNode;
<span class="line-modified">! import org.graalvm.compiler.nodes.spi.StampProvider;</span>
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.OptimisticOptimizations;
  import org.graalvm.compiler.phases.graph.StatelessPostOrderNodeIterator;
  
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.JavaKind;
<span class="line-removed">- import jdk.vm.ci.meta.MetaAccessProvider;</span>
  import jdk.vm.ci.meta.ResolvedJavaField;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.ResolvedJavaType;
  
  /**
<span class="line-new-header">--- 56,18 ---</span>
  import org.graalvm.compiler.nodes.java.LoadFieldNode;
  import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  import org.graalvm.compiler.nodes.java.NewArrayNode;
  import org.graalvm.compiler.nodes.java.NewInstanceNode;
  import org.graalvm.compiler.nodes.java.StoreFieldNode;
<span class="line-modified">! import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.OptimisticOptimizations;
  import org.graalvm.compiler.phases.graph.StatelessPostOrderNodeIterator;
  
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.ResolvedJavaField;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.ResolvedJavaType;
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,22 ***</span>
   * list} of types assigned to the field; every Java method has {@link Results#lookupMethod one
   * state} for each {@link MethodState#formalParameters parameter} as well as the
   * {@link MethodState#formalReturn return value}.
   */
  public class StaticAnalysis {
<span class="line-modified">!     /** Access to type, method, and fields using the Graal API. */</span>
<span class="line-modified">!     private final MetaAccessProvider metaAccess;</span>
<span class="line-modified">!     /** Access to platform dependent stamps. */</span>
<span class="line-modified">!     private final StampProvider stampProvider;</span>
<span class="line-modified">!     /** The results of the static analysis. */</span>
      private final Results results;
<span class="line-modified">!     /** Worklist for fixpoint iteration. */</span>
      private final Deque&lt;WorklistEntry&gt; worklist;
  
<span class="line-modified">!     public StaticAnalysis(MetaAccessProvider metaAccess, StampProvider stampProvider) {</span>
<span class="line-modified">!         this.metaAccess = metaAccess;</span>
<span class="line-removed">-         this.stampProvider = stampProvider;</span>
          this.results = new Results();
          this.worklist = new ArrayDeque&lt;&gt;();
      }
  
      /**
<span class="line-new-header">--- 86,25 ---</span>
   * list} of types assigned to the field; every Java method has {@link Results#lookupMethod one
   * state} for each {@link MethodState#formalParameters parameter} as well as the
   * {@link MethodState#formalReturn return value}.
   */
  public class StaticAnalysis {
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Access to various builtin providers.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private final CoreProviders providers;</span>
<span class="line-modified">!     /**</span>
<span class="line-added">+      * The results of the static analysis.</span>
<span class="line-added">+      */</span>
      private final Results results;
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Worklist for fixpoint iteration.</span>
<span class="line-added">+      */</span>
      private final Deque&lt;WorklistEntry&gt; worklist;
  
<span class="line-modified">!     public StaticAnalysis(CoreProviders providers) {</span>
<span class="line-modified">!         this.providers = providers;</span>
          this.results = new Results();
          this.worklist = new ArrayDeque&lt;&gt;();
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 271,11 ***</span>
                       * code before static analysis, the profiling information is empty and therefore
                       * wrong.
                       */
                      OptimisticOptimizations optimisticOpts = OptimisticOptimizations.NONE;
  
<span class="line-modified">!                     GraphBuilderPhase.Instance graphBuilder = new GraphBuilderPhase.Instance(metaAccess, stampProvider, null, null, graphBuilderConfig, optimisticOpts, null);</span>
                      graphBuilder.apply(graph);
                  } catch (Throwable ex) {
                      debug.handle(ex);
                  }
  
<span class="line-new-header">--- 273,11 ---</span>
                       * code before static analysis, the profiling information is empty and therefore
                       * wrong.
                       */
                      OptimisticOptimizations optimisticOpts = OptimisticOptimizations.NONE;
  
<span class="line-modified">!                     GraphBuilderPhase.Instance graphBuilder = new GraphBuilderPhase.Instance(providers, graphBuilderConfig, optimisticOpts, null);</span>
                      graphBuilder.apply(graph);
                  } catch (Throwable ex) {
                      debug.handle(ex);
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,11 ***</span>
          protected TypeFlow() {
              types = new HashSet&lt;&gt;();
              uses = new HashSet&lt;&gt;();
          }
  
<span class="line-modified">!         /** Returns the types of this element. */</span>
          public Set&lt;ResolvedJavaType&gt; getTypes() {
              return types;
          }
  
          /**
<span class="line-new-header">--- 304,13 ---</span>
          protected TypeFlow() {
              types = new HashSet&lt;&gt;();
              uses = new HashSet&lt;&gt;();
          }
  
<span class="line-modified">!         /**</span>
<span class="line-added">+          * Returns the types of this element.</span>
<span class="line-added">+          */</span>
          public Set&lt;ResolvedJavaType&gt; getTypes() {
              return types;
          }
  
          /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 347,11 ***</span>
       * {@link InvokeKind#Interface interface} calls, the {@link TypeFlow#getTypes() types} of this
       * node are the receiver types. When a new receiver type is added, a new callee might be added.
       * Adding a new callee means linking the type flow of the actual parameters with the formal
       * parameters of the callee, and linking the return value of the callee with the return value
       * state of the invocation.
<span class="line-modified">!      *</span>
       * Statically bindable methods calls ({@link InvokeKind#Static static} and
       * {@link InvokeKind#Special special} calls) have only one callee, but use the same code for
       * simplicity.
       */
      class InvokeTypeFlow extends TypeFlow {
<span class="line-new-header">--- 351,11 ---</span>
       * {@link InvokeKind#Interface interface} calls, the {@link TypeFlow#getTypes() types} of this
       * node are the receiver types. When a new receiver type is added, a new callee might be added.
       * Adding a new callee means linking the type flow of the actual parameters with the formal
       * parameters of the callee, and linking the return value of the callee with the return value
       * state of the invocation.
<span class="line-modified">!      * &lt;p&gt;</span>
       * Statically bindable methods calls ({@link InvokeKind#Static static} and
       * {@link InvokeKind#Special special} calls) have only one callee, but use the same code for
       * simplicity.
       */
      class InvokeTypeFlow extends TypeFlow {
</pre>
<center><a href="../inlining/NestedLoopEffectsPhaseComplexityTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="StaticAnalysisTests.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ea/UnsafeEATest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnsafeCompareAndSwapVirtualizationTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../inlining/InliningTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ea/UnsafeEATest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test.ea;
 26 
 27 import java.nio.ByteBuffer;
 28 
 29 import org.graalvm.compiler.api.directives.GraalDirectives;
 30 import org.graalvm.compiler.graph.Graph;
 31 import org.graalvm.compiler.graph.Node;
 32 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 33 import org.graalvm.compiler.nodes.PhiNode;
 34 import org.graalvm.compiler.nodes.ValuePhiNode;
 35 import org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode;
 36 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 37 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 38 import org.graalvm.compiler.nodes.extended.UnsafeAccessNode;
 39 import org.graalvm.compiler.nodes.java.LoadFieldNode;
<span class="line-removed"> 40 import org.graalvm.compiler.phases.common.CanonicalizerPhase;</span>
 41 import org.junit.Assert;
 42 import org.junit.Test;
 43 
 44 import jdk.vm.ci.meta.JavaConstant;
 45 import jdk.vm.ci.meta.JavaKind;
 46 import jdk.vm.ci.meta.ResolvedJavaMethod;
 47 
 48 public class UnsafeEATest extends EATestBase {
 49 
 50     public static int zero = 0;
 51 
<span class="line-removed"> 52     private static final long fieldOffset1;</span>
<span class="line-removed"> 53     private static final long fieldOffset2;</span>
<span class="line-removed"> 54 </span>
<span class="line-removed"> 55     static {</span>
<span class="line-removed"> 56         try {</span>
<span class="line-removed"> 57             long localFieldOffset1 = UNSAFE.objectFieldOffset(TestClassInt.class.getField(&quot;x&quot;));</span>
<span class="line-removed"> 58             // Make the fields 8 byte aligned (Required for testing setLong on Architectures which</span>
<span class="line-removed"> 59             // does not support unaligned memory access</span>
<span class="line-removed"> 60             if (localFieldOffset1 % 8 == 0) {</span>
<span class="line-removed"> 61                 fieldOffset1 = localFieldOffset1;</span>
<span class="line-removed"> 62                 fieldOffset2 = UNSAFE.objectFieldOffset(TestClassInt.class.getField(&quot;y&quot;));</span>
<span class="line-removed"> 63             } else {</span>
<span class="line-removed"> 64                 fieldOffset1 = UNSAFE.objectFieldOffset(TestClassInt.class.getField(&quot;y&quot;));</span>
<span class="line-removed"> 65                 fieldOffset2 = UNSAFE.objectFieldOffset(TestClassInt.class.getField(&quot;z&quot;));</span>
<span class="line-removed"> 66             }</span>
<span class="line-removed"> 67             assert fieldOffset2 == fieldOffset1 + 4;</span>
<span class="line-removed"> 68         } catch (Exception e) {</span>
<span class="line-removed"> 69             throw new RuntimeException(e);</span>
<span class="line-removed"> 70         }</span>
<span class="line-removed"> 71     }</span>
<span class="line-removed"> 72 </span>
 73     @Override
 74     protected void testEscapeAnalysis(String snippet, JavaConstant expectedConstantResult, boolean iterativeEscapeAnalysis) {
 75         // Exercise both a graph containing UnsafeAccessNodes and one which has been possibly been
 76         // canonicalized into AccessFieldNodes.
 77         testingUnsafe = true;
 78         super.testEscapeAnalysis(snippet, expectedConstantResult, iterativeEscapeAnalysis);
 79         testingUnsafe = false;
 80         super.testEscapeAnalysis(snippet, expectedConstantResult, iterativeEscapeAnalysis);
 81         if (expectedConstantResult != null) {
 82             // Check that a compiled version of this method returns the same value if we expect a
 83             // constant result.
 84             ResolvedJavaMethod method = getResolvedJavaMethod(snippet);
 85             JavaKind[] javaKinds = method.getSignature().toParameterKinds(false);
 86             Object[] args = new Object[javaKinds.length];
 87             int i = 0;
 88             for (JavaKind k : javaKinds) {
 89                 args[i++] = JavaConstant.defaultForKind(k).asBoxedPrimitive();
 90             }
 91             Result result = executeExpected(method, null, args);
 92             assertTrue(result.returnValue.equals(expectedConstantResult.asBoxedPrimitive()));
</pre>
<hr />
<pre>
106                                     store.needsBarrier(), store.stateAfter(), true));
107                     graph.replaceFixedWithFixed(store, newStore);
108                 } else if (node instanceof RawLoadNode) {
109                     RawLoadNode load = (RawLoadNode) node;
110                     RawLoadNode newLoad = graph.add(new RawLoadNode(load.object(), load.offset(), load.accessKind(), NamedLocationIdentity.any(),
111                                     true));
112                     graph.replaceFixedWithFixed(load, newLoad);
113                 }
114             }
115         }
116         super.canonicalizeGraph();
117     }
118 
119     @Override
120     protected void postEACanonicalizeGraph() {
121         // Simplify any UnpackEndianHalfNode so we end up with constants.
122         Graph.Mark mark = graph.getMark();
123         for (UnpackEndianHalfNode node : graph.getNodes().filter(UnpackEndianHalfNode.class)) {
124             node.lower(getTarget().arch.getByteOrder());
125         }
<span class="line-modified">126         new CanonicalizerPhase().applyIncremental(graph, context, mark);</span>
127     }
128 
129     private boolean testingUnsafe;
130 
131     @Test
132     public void testSimpleInt() {
133         testEscapeAnalysis(&quot;testSimpleIntSnippet&quot;, JavaConstant.forInt(101), false);
134     }
135 
136     public static int testSimpleIntSnippet() {
137         TestClassInt x = new TestClassInt();
<span class="line-modified">138         UNSAFE.putInt(x, fieldOffset1, 101);</span>
<span class="line-modified">139         return UNSAFE.getInt(x, fieldOffset1);</span>
140     }
141 
142     @Test
143     public void testMaterializedInt() {
144         test(&quot;testMaterializedIntSnippet&quot;);
145     }
146 
147     public static TestClassInt testMaterializedIntSnippet() {
148         TestClassInt x = new TestClassInt();
<span class="line-modified">149         UNSAFE.putInt(x, fieldOffset1, 101);</span>
150         return x;
151     }
152 
153     @Test
154     public void testSimpleDouble() {
155         testEscapeAnalysis(&quot;testSimpleDoubleSnippet&quot;, JavaConstant.forDouble(10.1), false);
156     }
157 
158     public static double testSimpleDoubleSnippet() {
159         TestClassInt x = new TestClassInt();
<span class="line-modified">160         UNSAFE.putDouble(x, fieldOffset1, 10.1);</span>
<span class="line-modified">161         return UNSAFE.getDouble(x, fieldOffset1);</span>
162     }
163 
164     @Test
165     public void testSimpleDoubleOverwriteWithInt() {
166         testEscapeAnalysis(&quot;testSimpleDoubleOverwriteWithIntSnippet&quot;, JavaConstant.forInt(10), false);
167     }
168 
169     public static int testSimpleDoubleOverwriteWithIntSnippet() {
170         TestClassInt x = new TestClassInt();
<span class="line-modified">171         UNSAFE.putDouble(x, fieldOffset1, 10.1);</span>
<span class="line-modified">172         UNSAFE.putInt(x, fieldOffset1, 10);</span>
<span class="line-modified">173         return UNSAFE.getInt(x, fieldOffset1);</span>
174     }
175 
176     @Test
177     public void testSimpleDoubleOverwriteWithSecondInt() {
178         ByteBuffer bb = ByteBuffer.allocate(8).order(getTarget().arch.getByteOrder());
179         bb.putDouble(10.1);
180         int value = bb.getInt(4);
181 
182         testEscapeAnalysis(&quot;testSimpleDoubleOverwriteWithSecondIntSnippet&quot;, JavaConstant.forInt(value), false);
183     }
184 
185     public static int testSimpleDoubleOverwriteWithSecondIntSnippet() {
186         TestClassInt x = new TestClassInt();
<span class="line-modified">187         UNSAFE.putDouble(x, fieldOffset1, 10.1);</span>
<span class="line-modified">188         UNSAFE.putInt(x, fieldOffset1, 10);</span>
<span class="line-modified">189         return UNSAFE.getInt(x, fieldOffset2);</span>
190     }
191 
192     @Test
193     public void testSimpleDoubleOverwriteWithFirstInt() {
194         ByteBuffer bb = ByteBuffer.allocate(8).order(getTarget().arch.getByteOrder());
195         bb.putDouble(10.1);
196         int value = bb.getInt(0);
197 
198         testEscapeAnalysis(&quot;testSimpleDoubleOverwriteWithFirstIntSnippet&quot;, JavaConstant.forInt(value), false);
199     }
200 
201     public static int testSimpleDoubleOverwriteWithFirstIntSnippet() {
202         TestClassInt x = new TestClassInt();
<span class="line-modified">203         UNSAFE.putDouble(x, fieldOffset1, 10.1);</span>
<span class="line-modified">204         UNSAFE.putInt(x, fieldOffset2, 10);</span>
<span class="line-modified">205         return UNSAFE.getInt(x, fieldOffset1);</span>
206     }
207 
208     @Test
209     public void testSimpleLongOverwriteWithSecondInt() {
210         ByteBuffer bb = ByteBuffer.allocate(8).order(getTarget().arch.getByteOrder());
211         bb.putLong(0, 0x1122334455667788L);
212         int value = bb.getInt(4);
213 
214         testEscapeAnalysis(&quot;testSimpleLongOverwriteWithSecondIntSnippet&quot;, JavaConstant.forInt(value), false);
215     }
216 
217     public static int testSimpleLongOverwriteWithSecondIntSnippet() {
218         TestClassInt x = new TestClassInt();
<span class="line-modified">219         UNSAFE.putLong(x, fieldOffset1, 0x1122334455667788L);</span>
<span class="line-modified">220         UNSAFE.putInt(x, fieldOffset1, 10);</span>
<span class="line-modified">221         return UNSAFE.getInt(x, fieldOffset2);</span>
222     }
223 
224     @Test
225     public void testSimpleLongOverwriteWithFirstInt() {
226         ByteBuffer bb = ByteBuffer.allocate(8).order(getTarget().arch.getByteOrder());
227         bb.putLong(0, 0x1122334455667788L);
228         int value = bb.getInt(0);
229 
230         testEscapeAnalysis(&quot;testSimpleLongOverwriteWithFirstIntSnippet&quot;, JavaConstant.forInt(value), false);
231     }
232 
233     public static int testSimpleLongOverwriteWithFirstIntSnippet() {
234         TestClassInt x = new TestClassInt();
<span class="line-modified">235         UNSAFE.putLong(x, fieldOffset1, 0x1122334455667788L);</span>
<span class="line-modified">236         UNSAFE.putInt(x, fieldOffset2, 10);</span>
<span class="line-modified">237         return UNSAFE.getInt(x, fieldOffset1);</span>
238     }
239 
240     @Test
241     public void testMergedDouble() {
242         testEscapeAnalysis(&quot;testMergedDoubleSnippet&quot;, null, false);
243         Assert.assertEquals(1, returnNodes.size());
244         Assert.assertTrue(returnNodes.get(0).result() instanceof ValuePhiNode);
245         PhiNode phi = (PhiNode) returnNodes.get(0).result();
246         Assert.assertTrue(phi.valueAt(0) instanceof LoadFieldNode);
247         Assert.assertTrue(phi.valueAt(1) instanceof LoadFieldNode);
248     }
249 
250     public static double testMergedDoubleSnippet(boolean a) {
251         TestClassInt x;
252         if (a) {
253             x = new TestClassInt(0, 0);
<span class="line-modified">254             UNSAFE.putDouble(x, fieldOffset1, doubleField);</span>
255         } else {
256             x = new TestClassInt();
<span class="line-modified">257             UNSAFE.putDouble(x, fieldOffset1, doubleField2);</span>
258         }
<span class="line-modified">259         return UNSAFE.getDouble(x, fieldOffset1);</span>
260     }
261 
262     static class ExtendedTestClassInt extends TestClassInt {
263         public long l;
264     }
265 
266     @Test
267     public void testMergedVirtualObjects() {
268         testEscapeAnalysis(&quot;testMergedVirtualObjectsSnippet&quot;, null, false);
269     }
270 
271     public static TestClassInt testMergedVirtualObjectsSnippet(int value) {
272         TestClassInt x;
273         if (value == 1) {
274             x = new TestClassInt();
<span class="line-modified">275             UNSAFE.putDouble(x, fieldOffset1, 10);</span>
276         } else {
277             x = new TestClassInt();
<span class="line-modified">278             UNSAFE.putInt(x, fieldOffset1, 0);</span>
279         }
<span class="line-modified">280         UNSAFE.putInt(x, fieldOffset1, 0);</span>
281         if (value == 2) {
<span class="line-modified">282             UNSAFE.putInt(x, fieldOffset2, 0);</span>
283         }
284         GraalDirectives.deoptimizeAndInvalidate();
285         return x;
286     }
287 
288     @Test
289     public void testMaterializedDouble() {
290         test(&quot;testMaterializedDoubleSnippet&quot;);
291     }
292 
293     public static TestClassInt testMaterializedDoubleSnippet() {
294         TestClassInt x = new TestClassInt();
<span class="line-modified">295         UNSAFE.putDouble(x, fieldOffset1, 10.1);</span>
296         return x;
297     }
298 
299     @Test
300     public void testDeoptDoubleVar() {
301         test(&quot;testDeoptDoubleVarSnippet&quot;);
302     }
303 
304     public static double doubleField = 10.1e99;
305     public static double doubleField2;
306 
307     public static TestClassInt testDeoptDoubleVarSnippet() {
308         TestClassInt x = new TestClassInt();
<span class="line-modified">309         UNSAFE.putDouble(x, fieldOffset1, doubleField);</span>
310         doubleField2 = 123;
311         try {
<span class="line-modified">312             doubleField = ((int) UNSAFE.getDouble(x, fieldOffset1)) / zero;</span>
313         } catch (RuntimeException e) {
314             return x;
315         }
316         return x;
317     }
318 
319     @Test
320     public void testDeoptDoubleConstant() {
321         test(&quot;testDeoptDoubleConstantSnippet&quot;);
322     }
323 
324     public static TestClassInt testDeoptDoubleConstantSnippet() {
325         TestClassInt x = new TestClassInt();
<span class="line-modified">326         UNSAFE.putDouble(x, fieldOffset1, 10.123);</span>
327         doubleField2 = 123;
328         try {
<span class="line-modified">329             doubleField = ((int) UNSAFE.getDouble(x, fieldOffset1)) / zero;</span>
330         } catch (RuntimeException e) {
331             return x;
332         }
333         return x;
334     }
335 
336     @Test
337     public void testDeoptLongVar() {
338         test(&quot;testDeoptLongVarSnippet&quot;);
339     }
340 
341     public static long longField = 0x133443218aaaffffL;
342     public static long longField2;
343 
344     public static TestClassInt testDeoptLongVarSnippet() {
345         TestClassInt x = new TestClassInt();
<span class="line-modified">346         UNSAFE.putLong(x, fieldOffset1, longField);</span>
347         longField2 = 123;
348         try {
<span class="line-modified">349             longField = UNSAFE.getLong(x, fieldOffset1) / zero;</span>
350         } catch (RuntimeException e) {
351             return x;
352         }
353         return x;
354     }
355 
356     @Test
357     public void testDeoptLongConstant() {
358         test(&quot;testDeoptLongConstantSnippet&quot;);
359     }
360 
361     public static TestClassInt testDeoptLongConstantSnippet() {
362         TestClassInt x = new TestClassInt();
<span class="line-modified">363         UNSAFE.putLong(x, fieldOffset1, 0x2222222210123L);</span>
364         longField2 = 123;
365         try {
<span class="line-modified">366             longField = UNSAFE.getLong(x, fieldOffset1) / zero;</span>
367         } catch (RuntimeException e) {
368             return x;
369         }
370         return x;
371     }
372 
373 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test.ea;
 26 
 27 import java.nio.ByteBuffer;
 28 
 29 import org.graalvm.compiler.api.directives.GraalDirectives;
 30 import org.graalvm.compiler.graph.Graph;
 31 import org.graalvm.compiler.graph.Node;
 32 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 33 import org.graalvm.compiler.nodes.PhiNode;
 34 import org.graalvm.compiler.nodes.ValuePhiNode;
 35 import org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode;
 36 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 37 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 38 import org.graalvm.compiler.nodes.extended.UnsafeAccessNode;
 39 import org.graalvm.compiler.nodes.java.LoadFieldNode;

 40 import org.junit.Assert;
 41 import org.junit.Test;
 42 
 43 import jdk.vm.ci.meta.JavaConstant;
 44 import jdk.vm.ci.meta.JavaKind;
 45 import jdk.vm.ci.meta.ResolvedJavaMethod;
 46 
 47 public class UnsafeEATest extends EATestBase {
 48 
 49     public static int zero = 0;
 50 





















 51     @Override
 52     protected void testEscapeAnalysis(String snippet, JavaConstant expectedConstantResult, boolean iterativeEscapeAnalysis) {
 53         // Exercise both a graph containing UnsafeAccessNodes and one which has been possibly been
 54         // canonicalized into AccessFieldNodes.
 55         testingUnsafe = true;
 56         super.testEscapeAnalysis(snippet, expectedConstantResult, iterativeEscapeAnalysis);
 57         testingUnsafe = false;
 58         super.testEscapeAnalysis(snippet, expectedConstantResult, iterativeEscapeAnalysis);
 59         if (expectedConstantResult != null) {
 60             // Check that a compiled version of this method returns the same value if we expect a
 61             // constant result.
 62             ResolvedJavaMethod method = getResolvedJavaMethod(snippet);
 63             JavaKind[] javaKinds = method.getSignature().toParameterKinds(false);
 64             Object[] args = new Object[javaKinds.length];
 65             int i = 0;
 66             for (JavaKind k : javaKinds) {
 67                 args[i++] = JavaConstant.defaultForKind(k).asBoxedPrimitive();
 68             }
 69             Result result = executeExpected(method, null, args);
 70             assertTrue(result.returnValue.equals(expectedConstantResult.asBoxedPrimitive()));
</pre>
<hr />
<pre>
 84                                     store.needsBarrier(), store.stateAfter(), true));
 85                     graph.replaceFixedWithFixed(store, newStore);
 86                 } else if (node instanceof RawLoadNode) {
 87                     RawLoadNode load = (RawLoadNode) node;
 88                     RawLoadNode newLoad = graph.add(new RawLoadNode(load.object(), load.offset(), load.accessKind(), NamedLocationIdentity.any(),
 89                                     true));
 90                     graph.replaceFixedWithFixed(load, newLoad);
 91                 }
 92             }
 93         }
 94         super.canonicalizeGraph();
 95     }
 96 
 97     @Override
 98     protected void postEACanonicalizeGraph() {
 99         // Simplify any UnpackEndianHalfNode so we end up with constants.
100         Graph.Mark mark = graph.getMark();
101         for (UnpackEndianHalfNode node : graph.getNodes().filter(UnpackEndianHalfNode.class)) {
102             node.lower(getTarget().arch.getByteOrder());
103         }
<span class="line-modified">104         createCanonicalizerPhase().applyIncremental(graph, context, mark);</span>
105     }
106 
107     private boolean testingUnsafe;
108 
109     @Test
110     public void testSimpleInt() {
111         testEscapeAnalysis(&quot;testSimpleIntSnippet&quot;, JavaConstant.forInt(101), false);
112     }
113 
114     public static int testSimpleIntSnippet() {
115         TestClassInt x = new TestClassInt();
<span class="line-modified">116         UNSAFE.putInt(x, TestClassInt.fieldOffset1, 101);</span>
<span class="line-modified">117         return UNSAFE.getInt(x, TestClassInt.fieldOffset1);</span>
118     }
119 
120     @Test
121     public void testMaterializedInt() {
122         test(&quot;testMaterializedIntSnippet&quot;);
123     }
124 
125     public static TestClassInt testMaterializedIntSnippet() {
126         TestClassInt x = new TestClassInt();
<span class="line-modified">127         UNSAFE.putInt(x, TestClassInt.fieldOffset1, 101);</span>
128         return x;
129     }
130 
131     @Test
132     public void testSimpleDouble() {
133         testEscapeAnalysis(&quot;testSimpleDoubleSnippet&quot;, JavaConstant.forDouble(10.1), false);
134     }
135 
136     public static double testSimpleDoubleSnippet() {
137         TestClassInt x = new TestClassInt();
<span class="line-modified">138         UNSAFE.putDouble(x, TestClassInt.fieldOffset1, 10.1);</span>
<span class="line-modified">139         return UNSAFE.getDouble(x, TestClassInt.fieldOffset1);</span>
140     }
141 
142     @Test
143     public void testSimpleDoubleOverwriteWithInt() {
144         testEscapeAnalysis(&quot;testSimpleDoubleOverwriteWithIntSnippet&quot;, JavaConstant.forInt(10), false);
145     }
146 
147     public static int testSimpleDoubleOverwriteWithIntSnippet() {
148         TestClassInt x = new TestClassInt();
<span class="line-modified">149         UNSAFE.putDouble(x, TestClassInt.fieldOffset1, 10.1);</span>
<span class="line-modified">150         UNSAFE.putInt(x, TestClassInt.fieldOffset1, 10);</span>
<span class="line-modified">151         return UNSAFE.getInt(x, TestClassInt.fieldOffset1);</span>
152     }
153 
154     @Test
155     public void testSimpleDoubleOverwriteWithSecondInt() {
156         ByteBuffer bb = ByteBuffer.allocate(8).order(getTarget().arch.getByteOrder());
157         bb.putDouble(10.1);
158         int value = bb.getInt(4);
159 
160         testEscapeAnalysis(&quot;testSimpleDoubleOverwriteWithSecondIntSnippet&quot;, JavaConstant.forInt(value), false);
161     }
162 
163     public static int testSimpleDoubleOverwriteWithSecondIntSnippet() {
164         TestClassInt x = new TestClassInt();
<span class="line-modified">165         UNSAFE.putDouble(x, TestClassInt.fieldOffset1, 10.1);</span>
<span class="line-modified">166         UNSAFE.putInt(x, TestClassInt.fieldOffset1, 10);</span>
<span class="line-modified">167         return UNSAFE.getInt(x, TestClassInt.fieldOffset2);</span>
168     }
169 
170     @Test
171     public void testSimpleDoubleOverwriteWithFirstInt() {
172         ByteBuffer bb = ByteBuffer.allocate(8).order(getTarget().arch.getByteOrder());
173         bb.putDouble(10.1);
174         int value = bb.getInt(0);
175 
176         testEscapeAnalysis(&quot;testSimpleDoubleOverwriteWithFirstIntSnippet&quot;, JavaConstant.forInt(value), false);
177     }
178 
179     public static int testSimpleDoubleOverwriteWithFirstIntSnippet() {
180         TestClassInt x = new TestClassInt();
<span class="line-modified">181         UNSAFE.putDouble(x, TestClassInt.fieldOffset1, 10.1);</span>
<span class="line-modified">182         UNSAFE.putInt(x, TestClassInt.fieldOffset2, 10);</span>
<span class="line-modified">183         return UNSAFE.getInt(x, TestClassInt.fieldOffset1);</span>
184     }
185 
186     @Test
187     public void testSimpleLongOverwriteWithSecondInt() {
188         ByteBuffer bb = ByteBuffer.allocate(8).order(getTarget().arch.getByteOrder());
189         bb.putLong(0, 0x1122334455667788L);
190         int value = bb.getInt(4);
191 
192         testEscapeAnalysis(&quot;testSimpleLongOverwriteWithSecondIntSnippet&quot;, JavaConstant.forInt(value), false);
193     }
194 
195     public static int testSimpleLongOverwriteWithSecondIntSnippet() {
196         TestClassInt x = new TestClassInt();
<span class="line-modified">197         UNSAFE.putLong(x, TestClassInt.fieldOffset1, 0x1122334455667788L);</span>
<span class="line-modified">198         UNSAFE.putInt(x, TestClassInt.fieldOffset1, 10);</span>
<span class="line-modified">199         return UNSAFE.getInt(x, TestClassInt.fieldOffset2);</span>
200     }
201 
202     @Test
203     public void testSimpleLongOverwriteWithFirstInt() {
204         ByteBuffer bb = ByteBuffer.allocate(8).order(getTarget().arch.getByteOrder());
205         bb.putLong(0, 0x1122334455667788L);
206         int value = bb.getInt(0);
207 
208         testEscapeAnalysis(&quot;testSimpleLongOverwriteWithFirstIntSnippet&quot;, JavaConstant.forInt(value), false);
209     }
210 
211     public static int testSimpleLongOverwriteWithFirstIntSnippet() {
212         TestClassInt x = new TestClassInt();
<span class="line-modified">213         UNSAFE.putLong(x, TestClassInt.fieldOffset1, 0x1122334455667788L);</span>
<span class="line-modified">214         UNSAFE.putInt(x, TestClassInt.fieldOffset2, 10);</span>
<span class="line-modified">215         return UNSAFE.getInt(x, TestClassInt.fieldOffset1);</span>
216     }
217 
218     @Test
219     public void testMergedDouble() {
220         testEscapeAnalysis(&quot;testMergedDoubleSnippet&quot;, null, false);
221         Assert.assertEquals(1, returnNodes.size());
222         Assert.assertTrue(returnNodes.get(0).result() instanceof ValuePhiNode);
223         PhiNode phi = (PhiNode) returnNodes.get(0).result();
224         Assert.assertTrue(phi.valueAt(0) instanceof LoadFieldNode);
225         Assert.assertTrue(phi.valueAt(1) instanceof LoadFieldNode);
226     }
227 
228     public static double testMergedDoubleSnippet(boolean a) {
229         TestClassInt x;
230         if (a) {
231             x = new TestClassInt(0, 0);
<span class="line-modified">232             UNSAFE.putDouble(x, TestClassInt.fieldOffset1, doubleField);</span>
233         } else {
234             x = new TestClassInt();
<span class="line-modified">235             UNSAFE.putDouble(x, TestClassInt.fieldOffset1, doubleField2);</span>
236         }
<span class="line-modified">237         return UNSAFE.getDouble(x, TestClassInt.fieldOffset1);</span>
238     }
239 
240     static class ExtendedTestClassInt extends TestClassInt {
241         public long l;
242     }
243 
244     @Test
245     public void testMergedVirtualObjects() {
246         testEscapeAnalysis(&quot;testMergedVirtualObjectsSnippet&quot;, null, false);
247     }
248 
249     public static TestClassInt testMergedVirtualObjectsSnippet(int value) {
250         TestClassInt x;
251         if (value == 1) {
252             x = new TestClassInt();
<span class="line-modified">253             UNSAFE.putDouble(x, TestClassInt.fieldOffset1, 10);</span>
254         } else {
255             x = new TestClassInt();
<span class="line-modified">256             UNSAFE.putInt(x, TestClassInt.fieldOffset1, 0);</span>
257         }
<span class="line-modified">258         UNSAFE.putInt(x, TestClassInt.fieldOffset1, 0);</span>
259         if (value == 2) {
<span class="line-modified">260             UNSAFE.putInt(x, TestClassInt.fieldOffset2, 0);</span>
261         }
262         GraalDirectives.deoptimizeAndInvalidate();
263         return x;
264     }
265 
266     @Test
267     public void testMaterializedDouble() {
268         test(&quot;testMaterializedDoubleSnippet&quot;);
269     }
270 
271     public static TestClassInt testMaterializedDoubleSnippet() {
272         TestClassInt x = new TestClassInt();
<span class="line-modified">273         UNSAFE.putDouble(x, TestClassInt.fieldOffset1, 10.1);</span>
274         return x;
275     }
276 
277     @Test
278     public void testDeoptDoubleVar() {
279         test(&quot;testDeoptDoubleVarSnippet&quot;);
280     }
281 
282     public static double doubleField = 10.1e99;
283     public static double doubleField2;
284 
285     public static TestClassInt testDeoptDoubleVarSnippet() {
286         TestClassInt x = new TestClassInt();
<span class="line-modified">287         UNSAFE.putDouble(x, TestClassInt.fieldOffset1, doubleField);</span>
288         doubleField2 = 123;
289         try {
<span class="line-modified">290             doubleField = ((int) UNSAFE.getDouble(x, TestClassInt.fieldOffset1)) / zero;</span>
291         } catch (RuntimeException e) {
292             return x;
293         }
294         return x;
295     }
296 
297     @Test
298     public void testDeoptDoubleConstant() {
299         test(&quot;testDeoptDoubleConstantSnippet&quot;);
300     }
301 
302     public static TestClassInt testDeoptDoubleConstantSnippet() {
303         TestClassInt x = new TestClassInt();
<span class="line-modified">304         UNSAFE.putDouble(x, TestClassInt.fieldOffset1, 10.123);</span>
305         doubleField2 = 123;
306         try {
<span class="line-modified">307             doubleField = ((int) UNSAFE.getDouble(x, TestClassInt.fieldOffset1)) / zero;</span>
308         } catch (RuntimeException e) {
309             return x;
310         }
311         return x;
312     }
313 
314     @Test
315     public void testDeoptLongVar() {
316         test(&quot;testDeoptLongVarSnippet&quot;);
317     }
318 
319     public static long longField = 0x133443218aaaffffL;
320     public static long longField2;
321 
322     public static TestClassInt testDeoptLongVarSnippet() {
323         TestClassInt x = new TestClassInt();
<span class="line-modified">324         UNSAFE.putLong(x, TestClassInt.fieldOffset1, longField);</span>
325         longField2 = 123;
326         try {
<span class="line-modified">327             longField = UNSAFE.getLong(x, TestClassInt.fieldOffset1) / zero;</span>
328         } catch (RuntimeException e) {
329             return x;
330         }
331         return x;
332     }
333 
334     @Test
335     public void testDeoptLongConstant() {
336         test(&quot;testDeoptLongConstantSnippet&quot;);
337     }
338 
339     public static TestClassInt testDeoptLongConstantSnippet() {
340         TestClassInt x = new TestClassInt();
<span class="line-modified">341         UNSAFE.putLong(x, TestClassInt.fieldOffset1, 0x2222222210123L);</span>
342         longField2 = 123;
343         try {
<span class="line-modified">344             longField = UNSAFE.getLong(x, TestClassInt.fieldOffset1) / zero;</span>
345         } catch (RuntimeException e) {
346             return x;
347         }
348         return x;
349     }
350 
351 }
</pre>
</td>
</tr>
</table>
<center><a href="UnsafeCompareAndSwapVirtualizationTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../inlining/InliningTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
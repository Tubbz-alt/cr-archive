<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/CheckGraalInvariants.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CanonicalizedConversionTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompareCanonicalizerTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/CheckGraalInvariants.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import java.io.File;
 28 import java.io.IOException;
 29 import java.io.PrintWriter;
 30 import java.io.StringWriter;
 31 import java.lang.annotation.Annotation;
 32 import java.lang.reflect.Method;
 33 import java.lang.reflect.Modifier;
 34 import java.util.ArrayList;

 35 import java.util.Collections;
 36 import java.util.Enumeration;
 37 import java.util.List;
 38 import java.util.concurrent.LinkedBlockingQueue;
 39 import java.util.concurrent.ThreadPoolExecutor;
 40 import java.util.concurrent.TimeUnit;
 41 import java.util.zip.ZipEntry;
 42 import java.util.zip.ZipFile;
 43 
 44 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 45 import org.graalvm.compiler.api.replacements.Snippet;
 46 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
 47 import org.graalvm.compiler.api.replacements.Snippet.NonNullParameter;
 48 import org.graalvm.compiler.api.replacements.Snippet.VarargsParameter;
 49 import org.graalvm.compiler.api.test.Graal;
 50 import org.graalvm.compiler.bytecode.BridgeMethodUtils;
 51 import org.graalvm.compiler.core.CompilerThreadFactory;
 52 import org.graalvm.compiler.core.common.LIRKind;
 53 import org.graalvm.compiler.core.common.type.ArithmeticOpTable;
 54 import org.graalvm.compiler.debug.DebugCloseable;
 55 import org.graalvm.compiler.debug.DebugContext;
 56 import org.graalvm.compiler.debug.DebugHandlersFactory;
 57 import org.graalvm.compiler.debug.GraalError;
 58 import org.graalvm.compiler.graph.Node;
 59 import org.graalvm.compiler.graph.NodeClass;
 60 import org.graalvm.compiler.java.GraphBuilderPhase;
 61 import org.graalvm.compiler.nodeinfo.NodeInfo;
 62 import org.graalvm.compiler.nodes.PhiNode;
 63 import org.graalvm.compiler.nodes.StructuredGraph;
 64 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 65 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 66 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 67 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;

 68 import org.graalvm.compiler.options.OptionValues;
 69 import org.graalvm.compiler.phases.OptimisticOptimizations;
 70 import org.graalvm.compiler.phases.PhaseSuite;
 71 import org.graalvm.compiler.phases.VerifyPhase;
 72 import org.graalvm.compiler.phases.VerifyPhase.VerificationError;
 73 import org.graalvm.compiler.phases.contract.VerifyNodeCosts;
 74 import org.graalvm.compiler.phases.tiers.HighTierContext;
<span class="line-removed"> 75 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 76 import org.graalvm.compiler.phases.util.Providers;
 77 import org.graalvm.compiler.runtime.RuntimeProvider;



 78 import jdk.internal.vm.compiler.word.LocationIdentity;
 79 import org.junit.Assert;
 80 import org.junit.Assume;
 81 import org.junit.Test;
 82 
 83 import jdk.vm.ci.code.BailoutException;
 84 import jdk.vm.ci.code.Register;
 85 import jdk.vm.ci.code.Register.RegisterCategory;
 86 import jdk.vm.ci.meta.JavaField;
 87 import jdk.vm.ci.meta.JavaMethod;
 88 import jdk.vm.ci.meta.JavaType;
 89 import jdk.vm.ci.meta.MetaAccessProvider;
 90 import jdk.vm.ci.meta.ResolvedJavaMethod;
 91 import jdk.vm.ci.meta.ResolvedJavaType;
 92 import jdk.vm.ci.meta.Value;
 93 
 94 /**
 95  * Checks that all classes in *graal*.jar and *jvmci*.jar entries on the boot class path comply with
 96  * global invariants such as using {@link Object#equals(Object)} to compare certain types instead of
 97  * identity comparisons.
 98  */

 99 public class CheckGraalInvariants extends GraalCompilerTest {
100 






101     private static boolean shouldVerifyEquals(ResolvedJavaMethod m) {
102         if (m.getName().equals(&quot;identityEquals&quot;)) {
103             ResolvedJavaType c = m.getDeclaringClass();
104             if (c.getName().equals(&quot;Ljdk/vm/ci/meta/AbstractValue;&quot;) || c.getName().equals(&quot;jdk/vm/ci/meta/Value&quot;)) {
105                 return false;
106             }
107         }
108 
109         return true;
110     }
111 
112     public static String relativeFileName(String absolutePath) {
113         int lastFileSeparatorIndex = absolutePath.lastIndexOf(File.separator);
114         return absolutePath.substring(lastFileSeparatorIndex &gt;= 0 ? lastFileSeparatorIndex : 0);
115     }
116 
117     public static class InvariantsTool {
118 
119         protected boolean shouldProcess(String classpathEntry) {



120             if (classpathEntry.endsWith(&quot;.jar&quot;)) {
121                 String name = new File(classpathEntry).getName();
122                 return name.contains(&quot;jvmci&quot;) || name.contains(&quot;graal&quot;) || name.contains(&quot;jdk.internal.vm.compiler&quot;);
123             }
124             return false;
125         }
126 
127         protected String getClassPath() {
128             String bootclasspath;
<span class="line-modified">129             if (Java8OrEarlier) {</span>
130                 bootclasspath = System.getProperty(&quot;sun.boot.class.path&quot;);
131             } else {
<span class="line-modified">132                 bootclasspath = System.getProperty(&quot;jdk.module.path&quot;) + File.pathSeparatorChar + System.getProperty(&quot;jdk.module.upgrade.path&quot;);</span>
133             }
134             return bootclasspath;
135         }
136 
137         protected boolean shouldLoadClass(String className) {
138             if (className.equals(&quot;module-info&quot;) || className.startsWith(&quot;META-INF.versions.&quot;)) {
139                 return false;
140             }
<span class="line-modified">141             if (!Java8OrEarlier) {</span>
142                 // @formatter:off
143                 /*
144                  * Work around to prevent:
145                  *
146                  * org.graalvm.compiler.debug.GraalError: java.lang.IllegalAccessError: class org.graalvm.compiler.serviceprovider.GraalServices$Lazy (in module
147                  * jdk.internal.vm.compiler) cannot access class java.lang.management.ManagementFactory (in module java.management) because module
148                  * jdk.internal.vm.compiler does not read module java.management
149                  *     at jdk.internal.vm.compiler/org.graalvm.compiler.debug.GraalError.shouldNotReachHere(GraalError.java:55)
150                  *     at org.graalvm.compiler.core.test.CheckGraalInvariants$InvariantsTool.handleClassLoadingException(CheckGraalInvariants.java:149)
151                  *     at org.graalvm.compiler.core.test.CheckGraalInvariants.initializeClasses(CheckGraalInvariants.java:321)
152                  *     at org.graalvm.compiler.core.test.CheckGraalInvariants.runTest(CheckGraalInvariants.java:239)
153                  *
154                  * which occurs because JDK8 overlays are in modular jars. They are never used normally.
155                  */
156                 // @formatter:on
157                 if (className.equals(&quot;org.graalvm.compiler.serviceprovider.GraalServices$Lazy&quot;)) {
158                     return false;
159                 }
160             } else {
161                 if (className.equals(&quot;jdk.vm.ci.services.JVMCIClassLoaderFactory&quot;)) {
162                     return false;
163                 }
164             }
165             return true;
166         }
167 
168         protected void handleClassLoadingException(Throwable t) {
169             GraalError.shouldNotReachHere(t);
170         }
171 
172         protected void handleParsingException(Throwable t) {
173             GraalError.shouldNotReachHere(t);
174         }
175 
176         public boolean shouldVerifyFoldableMethods() {
177             return true;
178         }







179     }
180 
181     @Test
182     @SuppressWarnings(&quot;try&quot;)
183     public void test() {
184         assumeManagementLibraryIsLoadable();
185         runTest(new InvariantsTool());
186     }
187 
188     @SuppressWarnings(&quot;try&quot;)
189     public static void runTest(InvariantsTool tool) {
190         RuntimeProvider rt = Graal.getRequiredCapability(RuntimeProvider.class);
191         Providers providers = rt.getHostBackend().getProviders();
192         MetaAccessProvider metaAccess = providers.getMetaAccess();
193 
194         PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite = new PhaseSuite&lt;&gt;();
195         Plugins plugins = new Plugins(new InvocationPlugins());
196         GraphBuilderConfiguration config = GraphBuilderConfiguration.getDefault(plugins).withEagerResolving(true).withUnresolvedIsError(true);
197         graphBuilderSuite.appendPhase(new GraphBuilderPhase(config));
198         HighTierContext context = new HighTierContext(providers, graphBuilderSuite, OptimisticOptimizations.NONE);
199 
200         Assume.assumeTrue(VerifyPhase.class.desiredAssertionStatus());
201 
202         String bootclasspath = tool.getClassPath();
203         Assert.assertNotNull(&quot;Cannot find boot class path&quot;, bootclasspath);
204 
205         final List&lt;String&gt; classNames = new ArrayList&lt;&gt;();
206         for (String path : bootclasspath.split(File.pathSeparator)) {
207             if (tool.shouldProcess(path)) {
208                 try {
<span class="line-modified">209                     final ZipFile zipFile = new ZipFile(new File(path));</span>
<span class="line-modified">210                     for (final Enumeration&lt;? extends ZipEntry&gt; entry = zipFile.entries(); entry.hasMoreElements();) {</span>
<span class="line-removed">211                         final ZipEntry zipEntry = entry.nextElement();</span>
<span class="line-removed">212                         String name = zipEntry.getName();</span>
<span class="line-removed">213                         if (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.startsWith(&quot;META-INF/versions/&quot;)) {</span>
<span class="line-removed">214                             String className = name.substring(0, name.length() - &quot;.class&quot;.length()).replace(&#39;/&#39;, &#39;.&#39;);</span>
<span class="line-removed">215                             if (isInNativeImage(className)) {</span>
<span class="line-removed">216                                 /*</span>
<span class="line-removed">217                                  * Native Image is an external tool and does not need to follow the</span>
<span class="line-removed">218                                  * Graal invariants.</span>
<span class="line-removed">219                                  */</span>
<span class="line-removed">220                                 continue;</span>
<span class="line-removed">221                             }</span>
222                             if (isGSON(className)) {
223                                 /*
224                                  * GSON classes are compiled with old JDK
225                                  */
226                                 continue;
227                             }
228                             classNames.add(className);
229                         }























230                     }
231                 } catch (IOException ex) {
232                     Assert.fail(ex.toString());
233                 }
234             }
235         }
236         Assert.assertFalse(&quot;Could not find graal jars on boot class path: &quot; + bootclasspath, classNames.isEmpty());
237 
238         // Allows a subset of methods to be checked through use of a system property
239         String property = System.getProperty(CheckGraalInvariants.class.getName() + &quot;.filters&quot;);
240         String[] filters = property == null ? null : property.split(&quot;,&quot;);
241 
242         OptionValues options = getInitialOptions();
243         CompilerThreadFactory factory = new CompilerThreadFactory(&quot;CheckInvariantsThread&quot;);
244         int availableProcessors = Runtime.getRuntime().availableProcessors();
245         ThreadPoolExecutor executor = new ThreadPoolExecutor(availableProcessors, availableProcessors, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), factory);
246 
247         List&lt;String&gt; errors = Collections.synchronizedList(new ArrayList&lt;&gt;());
248 
<span class="line-modified">249         List&lt;VerifyPhase&lt;PhaseContext&gt;&gt; verifiers = new ArrayList&lt;&gt;();</span>
250 
251         // If you add a new type to test here, be sure to add appropriate
252         // methods to the BadUsageWithEquals class below
253         verifiers.add(new VerifyUsageWithEquals(Value.class));
254         verifiers.add(new VerifyUsageWithEquals(Register.class));
255         verifiers.add(new VerifyUsageWithEquals(RegisterCategory.class));
256         verifiers.add(new VerifyUsageWithEquals(JavaType.class));
257         verifiers.add(new VerifyUsageWithEquals(JavaMethod.class));
258         verifiers.add(new VerifyUsageWithEquals(JavaField.class));
259         verifiers.add(new VerifyUsageWithEquals(LocationIdentity.class));
260         verifiers.add(new VerifyUsageWithEquals(LIRKind.class));
261         verifiers.add(new VerifyUsageWithEquals(ArithmeticOpTable.class));
262         verifiers.add(new VerifyUsageWithEquals(ArithmeticOpTable.Op.class));
263 
264         verifiers.add(new VerifyDebugUsage());
265         verifiers.add(new VerifyCallerSensitiveMethods());
266         verifiers.add(new VerifyVirtualizableUsage());
267         verifiers.add(new VerifyUpdateUsages());
268         verifiers.add(new VerifyBailoutUsage());

269         verifiers.add(new VerifyInstanceOfUsage());
270         verifiers.add(new VerifyGraphAddUsage());

271         verifiers.add(new VerifyGetOptionsUsage());

272 
273         VerifyFoldableMethods foldableMethodsVerifier = new VerifyFoldableMethods();
274         if (tool.shouldVerifyFoldableMethods()) {
275             verifiers.add(foldableMethodsVerifier);
276         }
277 


278         for (Method m : BadUsageWithEquals.class.getDeclaredMethods()) {
279             ResolvedJavaMethod method = metaAccess.lookupJavaMethod(m);
280             try (DebugContext debug = DebugContext.create(options, DebugHandlersFactory.LOADER)) {
281                 StructuredGraph graph = new StructuredGraph.Builder(options, debug, AllowAssumptions.YES).method(method).build();
282                 try (DebugCloseable s = debug.disableIntercept(); DebugContext.Scope ds = debug.scope(&quot;CheckingGraph&quot;, graph, method)) {
283                     graphBuilderSuite.apply(graph, context);
284                     // update phi stamps
285                     graph.getNodes().filter(PhiNode.class).forEach(PhiNode::inferStamp);
286                     checkGraph(verifiers, context, graph);
287                     errors.add(String.format(&quot;Expected error while checking %s&quot;, m));
288                 } catch (VerificationError e) {
289                     // expected!
290                 } catch (Throwable e) {
291                     errors.add(String.format(&quot;Error while checking %s:%n%s&quot;, m, printStackTraceToString(e)));
292                 }
293             }
294         }
295         if (errors.isEmpty()) {
296             // Order outer classes before the inner classes
297             classNames.sort((String a, String b) -&gt; a.compareTo(b));
298             // Initialize classes in single thread to avoid deadlocking issues during initialization
299             List&lt;Class&lt;?&gt;&gt; classes = initializeClasses(tool, classNames);
300             for (Class&lt;?&gt; c : classes) {
301                 String className = c.getName();
302                 executor.execute(() -&gt; {
303                     try {
<span class="line-modified">304                         checkClass(c, metaAccess);</span>
305                     } catch (Throwable e) {
306                         errors.add(String.format(&quot;Error while checking %s:%n%s&quot;, className, printStackTraceToString(e)));
307                     }
308                 });
309 
<span class="line-modified">310                 for (Method m : c.getDeclaredMethods()) {</span>
<span class="line-modified">311                     if (Modifier.isNative(m.getModifiers()) || Modifier.isAbstract(m.getModifiers())) {</span>













312                         // ignore
313                     } else {
<span class="line-modified">314                         String methodName = className + &quot;.&quot; + m.getName();</span>
315                         if (matches(filters, methodName)) {
316                             executor.execute(() -&gt; {
317                                 try (DebugContext debug = DebugContext.create(options, DebugHandlersFactory.LOADER)) {
<span class="line-removed">318                                     ResolvedJavaMethod method = metaAccess.lookupJavaMethod(m);</span>
319                                     boolean isSubstitution = method.getAnnotation(Snippet.class) != null || method.getAnnotation(MethodSubstitution.class) != null;
320                                     StructuredGraph graph = new StructuredGraph.Builder(options, debug).method(method).setIsSubstitution(isSubstitution).build();
321                                     try (DebugCloseable s = debug.disableIntercept(); DebugContext.Scope ds = debug.scope(&quot;CheckingGraph&quot;, graph, method)) {
322                                         checkMethod(method);
323                                         graphBuilderSuite.apply(graph, context);
324                                         // update phi stamps
325                                         graph.getNodes().filter(PhiNode.class).forEach(PhiNode::inferStamp);
326                                         checkGraph(verifiers, context, graph);
327                                     } catch (VerificationError e) {
328                                         errors.add(e.getMessage());
329                                     } catch (LinkageError e) {
330                                         // suppress linkages errors resulting from eager resolution
331                                     } catch (BailoutException e) {
332                                         // Graal bail outs on certain patterns in Java bytecode
333                                         // (e.g.,
334                                         // unbalanced monitors introduced by jacoco).
335                                     } catch (Throwable e) {
336                                         try {
337                                             tool.handleParsingException(e);
338                                         } catch (Throwable t) {
</pre>
<hr />
<pre>
374         }
375     }
376 
377     private static boolean isInNativeImage(String className) {
378         return className.startsWith(&quot;org.graalvm.nativeimage&quot;);
379     }
380 
381     private static boolean isGSON(String className) {
382         return className.contains(&quot;com.google.gson&quot;);
383     }
384 
385     private static List&lt;Class&lt;?&gt;&gt; initializeClasses(InvariantsTool tool, List&lt;String&gt; classNames) {
386         List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;(classNames.size());
387         for (String className : classNames) {
388             if (!tool.shouldLoadClass(className)) {
389                 continue;
390             }
391             try {
392                 Class&lt;?&gt; c = Class.forName(className, true, CheckGraalInvariants.class.getClassLoader());
393                 classes.add(c);










394             } catch (Throwable t) {
395                 tool.handleClassLoadingException(t);
396             }
397         }
398         return classes;
399     }
400 
401     /**
402      * @param metaAccess

403      */
<span class="line-modified">404     private static void checkClass(Class&lt;?&gt; c, MetaAccessProvider metaAccess) {</span>
405         if (Node.class.isAssignableFrom(c)) {
406             if (c.getAnnotation(NodeInfo.class) == null) {
407                 throw new AssertionError(String.format(&quot;Node subclass %s requires %s annotation&quot;, c.getName(), NodeClass.class.getSimpleName()));
408             }
409             VerifyNodeCosts.verifyNodeClass(c);
410         }



411     }
412 
413     private static void checkMethod(ResolvedJavaMethod method) {
414         if (method.getAnnotation(Snippet.class) == null) {
415             Annotation[][] parameterAnnotations = method.getParameterAnnotations();
416             for (int i = 0; i &lt; parameterAnnotations.length; i++) {
417                 for (Annotation a : parameterAnnotations[i]) {
418                     Class&lt;? extends Annotation&gt; annotationType = a.annotationType();
419                     if (annotationType == ConstantParameter.class || annotationType == VarargsParameter.class || annotationType == NonNullParameter.class) {
420                         VerificationError verificationError = new VerificationError(&quot;Parameter %d of %s is annotated with %s but the method is not annotated with %s&quot;, i, method,
421                                         annotationType.getSimpleName(),
422                                         Snippet.class.getSimpleName());
423                         throw verificationError;
424                     }
425                 }
426             }
427         }
428     }
429 
430     /**
431      * Checks the invariants for a single graph.
432      */
<span class="line-modified">433     private static void checkGraph(List&lt;VerifyPhase&lt;PhaseContext&gt;&gt; verifiers, HighTierContext context, StructuredGraph graph) {</span>
<span class="line-modified">434         for (VerifyPhase&lt;PhaseContext&gt; verifier : verifiers) {</span>
435             if (!(verifier instanceof VerifyUsageWithEquals) || shouldVerifyEquals(graph.method())) {
436                 verifier.apply(graph, context);
437             } else {
438                 verifier.apply(graph, context);
439             }
440         }
441         if (graph.method().isBridge()) {
442             BridgeMethodUtils.getBridgedMethod(graph.method());
443         }
444     }
445 
446     private static boolean matches(String[] filters, String s) {
447         if (filters == null || filters.length == 0) {
448             return true;
449         }
450         for (String filter : filters) {
451             if (s.contains(filter)) {
452                 return true;
453             }
454         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import java.io.File;
 28 import java.io.IOException;
 29 import java.io.PrintWriter;
 30 import java.io.StringWriter;
 31 import java.lang.annotation.Annotation;
 32 import java.lang.reflect.Method;
 33 import java.lang.reflect.Modifier;
 34 import java.util.ArrayList;
<span class="line-added"> 35 import java.util.Arrays;</span>
 36 import java.util.Collections;
 37 import java.util.Enumeration;
 38 import java.util.List;
 39 import java.util.concurrent.LinkedBlockingQueue;
 40 import java.util.concurrent.ThreadPoolExecutor;
 41 import java.util.concurrent.TimeUnit;
 42 import java.util.zip.ZipEntry;
 43 import java.util.zip.ZipFile;
 44 
 45 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 46 import org.graalvm.compiler.api.replacements.Snippet;
 47 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
 48 import org.graalvm.compiler.api.replacements.Snippet.NonNullParameter;
 49 import org.graalvm.compiler.api.replacements.Snippet.VarargsParameter;
 50 import org.graalvm.compiler.api.test.Graal;
 51 import org.graalvm.compiler.bytecode.BridgeMethodUtils;
 52 import org.graalvm.compiler.core.CompilerThreadFactory;
 53 import org.graalvm.compiler.core.common.LIRKind;
 54 import org.graalvm.compiler.core.common.type.ArithmeticOpTable;
 55 import org.graalvm.compiler.debug.DebugCloseable;
 56 import org.graalvm.compiler.debug.DebugContext;
 57 import org.graalvm.compiler.debug.DebugHandlersFactory;
 58 import org.graalvm.compiler.debug.GraalError;
 59 import org.graalvm.compiler.graph.Node;
 60 import org.graalvm.compiler.graph.NodeClass;
 61 import org.graalvm.compiler.java.GraphBuilderPhase;
 62 import org.graalvm.compiler.nodeinfo.NodeInfo;
 63 import org.graalvm.compiler.nodes.PhiNode;
 64 import org.graalvm.compiler.nodes.StructuredGraph;
 65 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 66 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 67 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 68 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
<span class="line-added"> 69 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 70 import org.graalvm.compiler.options.OptionValues;
 71 import org.graalvm.compiler.phases.OptimisticOptimizations;
 72 import org.graalvm.compiler.phases.PhaseSuite;
 73 import org.graalvm.compiler.phases.VerifyPhase;
 74 import org.graalvm.compiler.phases.VerifyPhase.VerificationError;
 75 import org.graalvm.compiler.phases.contract.VerifyNodeCosts;
 76 import org.graalvm.compiler.phases.tiers.HighTierContext;

 77 import org.graalvm.compiler.phases.util.Providers;
 78 import org.graalvm.compiler.runtime.RuntimeProvider;
<span class="line-added"> 79 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
<span class="line-added"> 80 import org.graalvm.compiler.test.AddExports;</span>
<span class="line-added"> 81 import org.graalvm.compiler.api.test.ModuleSupport;</span>
 82 import jdk.internal.vm.compiler.word.LocationIdentity;
 83 import org.junit.Assert;
 84 import org.junit.Assume;
 85 import org.junit.Test;
 86 
 87 import jdk.vm.ci.code.BailoutException;
 88 import jdk.vm.ci.code.Register;
 89 import jdk.vm.ci.code.Register.RegisterCategory;
 90 import jdk.vm.ci.meta.JavaField;
 91 import jdk.vm.ci.meta.JavaMethod;
 92 import jdk.vm.ci.meta.JavaType;
 93 import jdk.vm.ci.meta.MetaAccessProvider;
 94 import jdk.vm.ci.meta.ResolvedJavaMethod;
 95 import jdk.vm.ci.meta.ResolvedJavaType;
 96 import jdk.vm.ci.meta.Value;
 97 
 98 /**
 99  * Checks that all classes in *graal*.jar and *jvmci*.jar entries on the boot class path comply with
100  * global invariants such as using {@link Object#equals(Object)} to compare certain types instead of
101  * identity comparisons.
102  */
<span class="line-added">103 @AddExports(&quot;jdk.internal.vm.ci/*=jdk.aot&quot;)</span>
104 public class CheckGraalInvariants extends GraalCompilerTest {
105 
<span class="line-added">106     /**</span>
<span class="line-added">107      * Magic token to denote the classes in the Java runtime image (i.e. in the {@code jrt:/} file</span>
<span class="line-added">108      * system).</span>
<span class="line-added">109      */</span>
<span class="line-added">110     public static final String JRT_CLASS_PATH_ENTRY = &quot;&lt;jrt&gt;&quot;;</span>
<span class="line-added">111 </span>
112     private static boolean shouldVerifyEquals(ResolvedJavaMethod m) {
113         if (m.getName().equals(&quot;identityEquals&quot;)) {
114             ResolvedJavaType c = m.getDeclaringClass();
115             if (c.getName().equals(&quot;Ljdk/vm/ci/meta/AbstractValue;&quot;) || c.getName().equals(&quot;jdk/vm/ci/meta/Value&quot;)) {
116                 return false;
117             }
118         }
119 
120         return true;
121     }
122 
123     public static String relativeFileName(String absolutePath) {
124         int lastFileSeparatorIndex = absolutePath.lastIndexOf(File.separator);
125         return absolutePath.substring(lastFileSeparatorIndex &gt;= 0 ? lastFileSeparatorIndex : 0);
126     }
127 
128     public static class InvariantsTool {
129 
130         protected boolean shouldProcess(String classpathEntry) {
<span class="line-added">131             if (classpathEntry.equals(JRT_CLASS_PATH_ENTRY)) {</span>
<span class="line-added">132                 return true;</span>
<span class="line-added">133             }</span>
134             if (classpathEntry.endsWith(&quot;.jar&quot;)) {
135                 String name = new File(classpathEntry).getName();
136                 return name.contains(&quot;jvmci&quot;) || name.contains(&quot;graal&quot;) || name.contains(&quot;jdk.internal.vm.compiler&quot;);
137             }
138             return false;
139         }
140 
141         protected String getClassPath() {
142             String bootclasspath;
<span class="line-modified">143             if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
144                 bootclasspath = System.getProperty(&quot;sun.boot.class.path&quot;);
145             } else {
<span class="line-modified">146                 bootclasspath = JRT_CLASS_PATH_ENTRY;</span>
147             }
148             return bootclasspath;
149         }
150 
151         protected boolean shouldLoadClass(String className) {
152             if (className.equals(&quot;module-info&quot;) || className.startsWith(&quot;META-INF.versions.&quot;)) {
153                 return false;
154             }
<span class="line-modified">155             if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
156                 // @formatter:off
157                 /*
158                  * Work around to prevent:
159                  *
160                  * org.graalvm.compiler.debug.GraalError: java.lang.IllegalAccessError: class org.graalvm.compiler.serviceprovider.GraalServices$Lazy (in module
161                  * jdk.internal.vm.compiler) cannot access class java.lang.management.ManagementFactory (in module java.management) because module
162                  * jdk.internal.vm.compiler does not read module java.management
163                  *     at jdk.internal.vm.compiler/org.graalvm.compiler.debug.GraalError.shouldNotReachHere(GraalError.java:55)
164                  *     at org.graalvm.compiler.core.test.CheckGraalInvariants$InvariantsTool.handleClassLoadingException(CheckGraalInvariants.java:149)
165                  *     at org.graalvm.compiler.core.test.CheckGraalInvariants.initializeClasses(CheckGraalInvariants.java:321)
166                  *     at org.graalvm.compiler.core.test.CheckGraalInvariants.runTest(CheckGraalInvariants.java:239)
167                  *
168                  * which occurs because JDK8 overlays are in modular jars. They are never used normally.
169                  */
170                 // @formatter:on
171                 if (className.equals(&quot;org.graalvm.compiler.serviceprovider.GraalServices$Lazy&quot;)) {
172                     return false;
173                 }
174             } else {
175                 if (className.equals(&quot;jdk.vm.ci.services.JVMCIClassLoaderFactory&quot;)) {
176                     return false;
177                 }
178             }
179             return true;
180         }
181 
182         protected void handleClassLoadingException(Throwable t) {
183             GraalError.shouldNotReachHere(t);
184         }
185 
186         protected void handleParsingException(Throwable t) {
187             GraalError.shouldNotReachHere(t);
188         }
189 
190         public boolean shouldVerifyFoldableMethods() {
191             return true;
192         }
<span class="line-added">193 </span>
<span class="line-added">194         /**</span>
<span class="line-added">195          * Makes edits to the list of verifiers to be run.</span>
<span class="line-added">196          */</span>
<span class="line-added">197         @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added">198         protected void updateVerifiers(List&lt;VerifyPhase&lt;CoreProviders&gt;&gt; verifiers) {</span>
<span class="line-added">199         }</span>
200     }
201 
202     @Test
203     @SuppressWarnings(&quot;try&quot;)
204     public void test() {
205         assumeManagementLibraryIsLoadable();
206         runTest(new InvariantsTool());
207     }
208 
209     @SuppressWarnings(&quot;try&quot;)
210     public static void runTest(InvariantsTool tool) {
211         RuntimeProvider rt = Graal.getRequiredCapability(RuntimeProvider.class);
212         Providers providers = rt.getHostBackend().getProviders();
213         MetaAccessProvider metaAccess = providers.getMetaAccess();
214 
215         PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite = new PhaseSuite&lt;&gt;();
216         Plugins plugins = new Plugins(new InvocationPlugins());
217         GraphBuilderConfiguration config = GraphBuilderConfiguration.getDefault(plugins).withEagerResolving(true).withUnresolvedIsError(true);
218         graphBuilderSuite.appendPhase(new GraphBuilderPhase(config));
219         HighTierContext context = new HighTierContext(providers, graphBuilderSuite, OptimisticOptimizations.NONE);
220 
221         Assume.assumeTrue(VerifyPhase.class.desiredAssertionStatus());
222 
223         String bootclasspath = tool.getClassPath();
224         Assert.assertNotNull(&quot;Cannot find boot class path&quot;, bootclasspath);
225 
226         final List&lt;String&gt; classNames = new ArrayList&lt;&gt;();
227         for (String path : bootclasspath.split(File.pathSeparator)) {
228             if (tool.shouldProcess(path)) {
229                 try {
<span class="line-modified">230                     if (path.equals(JRT_CLASS_PATH_ENTRY)) {</span>
<span class="line-modified">231                         for (String className : ModuleSupport.getJRTGraalClassNames()) {</span>











232                             if (isGSON(className)) {
233                                 /*
234                                  * GSON classes are compiled with old JDK
235                                  */
236                                 continue;
237                             }
238                             classNames.add(className);
239                         }
<span class="line-added">240                     } else {</span>
<span class="line-added">241                         final ZipFile zipFile = new ZipFile(new File(path));</span>
<span class="line-added">242                         for (final Enumeration&lt;? extends ZipEntry&gt; entry = zipFile.entries(); entry.hasMoreElements();) {</span>
<span class="line-added">243                             final ZipEntry zipEntry = entry.nextElement();</span>
<span class="line-added">244                             String name = zipEntry.getName();</span>
<span class="line-added">245                             if (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.startsWith(&quot;META-INF/versions/&quot;)) {</span>
<span class="line-added">246                                 String className = name.substring(0, name.length() - &quot;.class&quot;.length()).replace(&#39;/&#39;, &#39;.&#39;);</span>
<span class="line-added">247                                 if (isInNativeImage(className)) {</span>
<span class="line-added">248                                     /*</span>
<span class="line-added">249                                      * Native Image is an external tool and does not need to follow</span>
<span class="line-added">250                                      * the Graal invariants.</span>
<span class="line-added">251                                      */</span>
<span class="line-added">252                                     continue;</span>
<span class="line-added">253                                 }</span>
<span class="line-added">254                                 if (isGSON(className)) {</span>
<span class="line-added">255                                     /*</span>
<span class="line-added">256                                      * GSON classes are compiled with old JDK</span>
<span class="line-added">257                                      */</span>
<span class="line-added">258                                     continue;</span>
<span class="line-added">259                                 }</span>
<span class="line-added">260                                 classNames.add(className);</span>
<span class="line-added">261                             }</span>
<span class="line-added">262                         }</span>
263                     }
264                 } catch (IOException ex) {
265                     Assert.fail(ex.toString());
266                 }
267             }
268         }
269         Assert.assertFalse(&quot;Could not find graal jars on boot class path: &quot; + bootclasspath, classNames.isEmpty());
270 
271         // Allows a subset of methods to be checked through use of a system property
272         String property = System.getProperty(CheckGraalInvariants.class.getName() + &quot;.filters&quot;);
273         String[] filters = property == null ? null : property.split(&quot;,&quot;);
274 
275         OptionValues options = getInitialOptions();
276         CompilerThreadFactory factory = new CompilerThreadFactory(&quot;CheckInvariantsThread&quot;);
277         int availableProcessors = Runtime.getRuntime().availableProcessors();
278         ThreadPoolExecutor executor = new ThreadPoolExecutor(availableProcessors, availableProcessors, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), factory);
279 
280         List&lt;String&gt; errors = Collections.synchronizedList(new ArrayList&lt;&gt;());
281 
<span class="line-modified">282         List&lt;VerifyPhase&lt;CoreProviders&gt;&gt; verifiers = new ArrayList&lt;&gt;();</span>
283 
284         // If you add a new type to test here, be sure to add appropriate
285         // methods to the BadUsageWithEquals class below
286         verifiers.add(new VerifyUsageWithEquals(Value.class));
287         verifiers.add(new VerifyUsageWithEquals(Register.class));
288         verifiers.add(new VerifyUsageWithEquals(RegisterCategory.class));
289         verifiers.add(new VerifyUsageWithEquals(JavaType.class));
290         verifiers.add(new VerifyUsageWithEquals(JavaMethod.class));
291         verifiers.add(new VerifyUsageWithEquals(JavaField.class));
292         verifiers.add(new VerifyUsageWithEquals(LocationIdentity.class));
293         verifiers.add(new VerifyUsageWithEquals(LIRKind.class));
294         verifiers.add(new VerifyUsageWithEquals(ArithmeticOpTable.class));
295         verifiers.add(new VerifyUsageWithEquals(ArithmeticOpTable.Op.class));
296 
297         verifiers.add(new VerifyDebugUsage());
298         verifiers.add(new VerifyCallerSensitiveMethods());
299         verifiers.add(new VerifyVirtualizableUsage());
300         verifiers.add(new VerifyUpdateUsages());
301         verifiers.add(new VerifyBailoutUsage());
<span class="line-added">302         verifiers.add(new VerifySystemPropertyUsage());</span>
303         verifiers.add(new VerifyInstanceOfUsage());
304         verifiers.add(new VerifyGraphAddUsage());
<span class="line-added">305         verifiers.add(new VerifyBufferUsage());</span>
306         verifiers.add(new VerifyGetOptionsUsage());
<span class="line-added">307         verifiers.add(new VerifyUnsafeAccess());</span>
308 
309         VerifyFoldableMethods foldableMethodsVerifier = new VerifyFoldableMethods();
310         if (tool.shouldVerifyFoldableMethods()) {
311             verifiers.add(foldableMethodsVerifier);
312         }
313 
<span class="line-added">314         tool.updateVerifiers(verifiers);</span>
<span class="line-added">315 </span>
316         for (Method m : BadUsageWithEquals.class.getDeclaredMethods()) {
317             ResolvedJavaMethod method = metaAccess.lookupJavaMethod(m);
318             try (DebugContext debug = DebugContext.create(options, DebugHandlersFactory.LOADER)) {
319                 StructuredGraph graph = new StructuredGraph.Builder(options, debug, AllowAssumptions.YES).method(method).build();
320                 try (DebugCloseable s = debug.disableIntercept(); DebugContext.Scope ds = debug.scope(&quot;CheckingGraph&quot;, graph, method)) {
321                     graphBuilderSuite.apply(graph, context);
322                     // update phi stamps
323                     graph.getNodes().filter(PhiNode.class).forEach(PhiNode::inferStamp);
324                     checkGraph(verifiers, context, graph);
325                     errors.add(String.format(&quot;Expected error while checking %s&quot;, m));
326                 } catch (VerificationError e) {
327                     // expected!
328                 } catch (Throwable e) {
329                     errors.add(String.format(&quot;Error while checking %s:%n%s&quot;, m, printStackTraceToString(e)));
330                 }
331             }
332         }
333         if (errors.isEmpty()) {
334             // Order outer classes before the inner classes
335             classNames.sort((String a, String b) -&gt; a.compareTo(b));
336             // Initialize classes in single thread to avoid deadlocking issues during initialization
337             List&lt;Class&lt;?&gt;&gt; classes = initializeClasses(tool, classNames);
338             for (Class&lt;?&gt; c : classes) {
339                 String className = c.getName();
340                 executor.execute(() -&gt; {
341                     try {
<span class="line-modified">342                         checkClass(c, metaAccess, verifiers);</span>
343                     } catch (Throwable e) {
344                         errors.add(String.format(&quot;Error while checking %s:%n%s&quot;, className, printStackTraceToString(e)));
345                     }
346                 });
347 
<span class="line-modified">348                 ResolvedJavaType type = metaAccess.lookupJavaType(c);</span>
<span class="line-modified">349                 List&lt;ResolvedJavaMethod&gt; methods = new ArrayList&lt;&gt;();</span>
<span class="line-added">350                 try {</span>
<span class="line-added">351                     methods.addAll(Arrays.asList(type.getDeclaredMethods()));</span>
<span class="line-added">352                     methods.addAll(Arrays.asList(type.getDeclaredConstructors()));</span>
<span class="line-added">353                 } catch (Throwable e) {</span>
<span class="line-added">354                     errors.add(String.format(&quot;Error while checking %s:%n%s&quot;, className, printStackTraceToString(e)));</span>
<span class="line-added">355                 }</span>
<span class="line-added">356                 ResolvedJavaMethod clinit = type.getClassInitializer();</span>
<span class="line-added">357                 if (clinit != null) {</span>
<span class="line-added">358                     methods.add(clinit);</span>
<span class="line-added">359                 }</span>
<span class="line-added">360 </span>
<span class="line-added">361                 for (ResolvedJavaMethod method : methods) {</span>
<span class="line-added">362                     if (Modifier.isNative(method.getModifiers()) || Modifier.isAbstract(method.getModifiers())) {</span>
363                         // ignore
364                     } else {
<span class="line-modified">365                         String methodName = className + &quot;.&quot; + method.getName();</span>
366                         if (matches(filters, methodName)) {
367                             executor.execute(() -&gt; {
368                                 try (DebugContext debug = DebugContext.create(options, DebugHandlersFactory.LOADER)) {

369                                     boolean isSubstitution = method.getAnnotation(Snippet.class) != null || method.getAnnotation(MethodSubstitution.class) != null;
370                                     StructuredGraph graph = new StructuredGraph.Builder(options, debug).method(method).setIsSubstitution(isSubstitution).build();
371                                     try (DebugCloseable s = debug.disableIntercept(); DebugContext.Scope ds = debug.scope(&quot;CheckingGraph&quot;, graph, method)) {
372                                         checkMethod(method);
373                                         graphBuilderSuite.apply(graph, context);
374                                         // update phi stamps
375                                         graph.getNodes().filter(PhiNode.class).forEach(PhiNode::inferStamp);
376                                         checkGraph(verifiers, context, graph);
377                                     } catch (VerificationError e) {
378                                         errors.add(e.getMessage());
379                                     } catch (LinkageError e) {
380                                         // suppress linkages errors resulting from eager resolution
381                                     } catch (BailoutException e) {
382                                         // Graal bail outs on certain patterns in Java bytecode
383                                         // (e.g.,
384                                         // unbalanced monitors introduced by jacoco).
385                                     } catch (Throwable e) {
386                                         try {
387                                             tool.handleParsingException(e);
388                                         } catch (Throwable t) {
</pre>
<hr />
<pre>
424         }
425     }
426 
427     private static boolean isInNativeImage(String className) {
428         return className.startsWith(&quot;org.graalvm.nativeimage&quot;);
429     }
430 
431     private static boolean isGSON(String className) {
432         return className.contains(&quot;com.google.gson&quot;);
433     }
434 
435     private static List&lt;Class&lt;?&gt;&gt; initializeClasses(InvariantsTool tool, List&lt;String&gt; classNames) {
436         List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;(classNames.size());
437         for (String className : classNames) {
438             if (!tool.shouldLoadClass(className)) {
439                 continue;
440             }
441             try {
442                 Class&lt;?&gt; c = Class.forName(className, true, CheckGraalInvariants.class.getClassLoader());
443                 classes.add(c);
<span class="line-added">444             } catch (UnsupportedClassVersionError e) {</span>
<span class="line-added">445                 // graal-test.jar can contain classes compiled for different Java versions</span>
<span class="line-added">446             } catch (NoClassDefFoundError e) {</span>
<span class="line-added">447                 if (!e.getMessage().contains(&quot;Could not initialize class&quot;)) {</span>
<span class="line-added">448                     throw e;</span>
<span class="line-added">449                 } else {</span>
<span class="line-added">450                     // A second or later attempt to initialize a class</span>
<span class="line-added">451                     // results in this confusing error where the</span>
<span class="line-added">452                     // original cause of initialization failure is lost</span>
<span class="line-added">453                 }</span>
454             } catch (Throwable t) {
455                 tool.handleClassLoadingException(t);
456             }
457         }
458         return classes;
459     }
460 
461     /**
462      * @param metaAccess
<span class="line-added">463      * @param verifiers</span>
464      */
<span class="line-modified">465     private static void checkClass(Class&lt;?&gt; c, MetaAccessProvider metaAccess, List&lt;VerifyPhase&lt;CoreProviders&gt;&gt; verifiers) {</span>
466         if (Node.class.isAssignableFrom(c)) {
467             if (c.getAnnotation(NodeInfo.class) == null) {
468                 throw new AssertionError(String.format(&quot;Node subclass %s requires %s annotation&quot;, c.getName(), NodeClass.class.getSimpleName()));
469             }
470             VerifyNodeCosts.verifyNodeClass(c);
471         }
<span class="line-added">472         for (VerifyPhase&lt;CoreProviders&gt; verifier : verifiers) {</span>
<span class="line-added">473             verifier.verifyClass(c, metaAccess);</span>
<span class="line-added">474         }</span>
475     }
476 
477     private static void checkMethod(ResolvedJavaMethod method) {
478         if (method.getAnnotation(Snippet.class) == null) {
479             Annotation[][] parameterAnnotations = method.getParameterAnnotations();
480             for (int i = 0; i &lt; parameterAnnotations.length; i++) {
481                 for (Annotation a : parameterAnnotations[i]) {
482                     Class&lt;? extends Annotation&gt; annotationType = a.annotationType();
483                     if (annotationType == ConstantParameter.class || annotationType == VarargsParameter.class || annotationType == NonNullParameter.class) {
484                         VerificationError verificationError = new VerificationError(&quot;Parameter %d of %s is annotated with %s but the method is not annotated with %s&quot;, i, method,
485                                         annotationType.getSimpleName(),
486                                         Snippet.class.getSimpleName());
487                         throw verificationError;
488                     }
489                 }
490             }
491         }
492     }
493 
494     /**
495      * Checks the invariants for a single graph.
496      */
<span class="line-modified">497     private static void checkGraph(List&lt;VerifyPhase&lt;CoreProviders&gt;&gt; verifiers, HighTierContext context, StructuredGraph graph) {</span>
<span class="line-modified">498         for (VerifyPhase&lt;CoreProviders&gt; verifier : verifiers) {</span>
499             if (!(verifier instanceof VerifyUsageWithEquals) || shouldVerifyEquals(graph.method())) {
500                 verifier.apply(graph, context);
501             } else {
502                 verifier.apply(graph, context);
503             }
504         }
505         if (graph.method().isBridge()) {
506             BridgeMethodUtils.getBridgedMethod(graph.method());
507         }
508     }
509 
510     private static boolean matches(String[] filters, String s) {
511         if (filters == null || filters.length == 0) {
512             return true;
513         }
514         for (String filter : filters) {
515             if (s.contains(filter)) {
516                 return true;
517             }
518         }
</pre>
</td>
</tr>
</table>
<center><a href="CanonicalizedConversionTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompareCanonicalizerTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
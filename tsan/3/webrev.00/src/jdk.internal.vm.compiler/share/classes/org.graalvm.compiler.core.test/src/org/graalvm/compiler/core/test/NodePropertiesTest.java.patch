diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/NodePropertiesTest.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/NodePropertiesTest.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/NodePropertiesTest.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/NodePropertiesTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -31,16 +31,16 @@
 import org.graalvm.compiler.graph.spi.SimplifierTool;
 import org.graalvm.compiler.java.ComputeLoopFrequenciesClosure;
 import org.graalvm.compiler.nodes.LoopBeginNode;
 import org.graalvm.compiler.nodes.StructuredGraph;
 import org.graalvm.compiler.nodes.ValueNode;
+import org.graalvm.compiler.nodes.spi.CoreProviders;
 import org.graalvm.compiler.phases.BasePhase;
 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
-import org.graalvm.compiler.phases.common.CanonicalizerPhase.CustomCanonicalizer;
+import org.graalvm.compiler.phases.common.CanonicalizerPhase.CustomSimplification;
 import org.graalvm.compiler.phases.contract.NodeCostUtil;
 import org.graalvm.compiler.phases.tiers.HighTierContext;
-import org.graalvm.compiler.phases.tiers.PhaseContext;
 import org.junit.Assert;
 import org.junit.Test;
 
 public class NodePropertiesTest extends GraalCompilerTest {
 
@@ -160,23 +160,25 @@
     }
 
     @Test
     public void testCanonicalizationExample() {
         HighTierContext htc = getDefaultHighTierContext();
-        ImprovementSavingCanonicalizer c1 = new ImprovementSavingCanonicalizer();
+        ImprovementSavingCalculator c1 = new ImprovementSavingCalculator();
         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod("test1Snippet"));
-        new CanonicalizerPhase(c1).apply(g1, htc);
-        ImprovementSavingCanonicalizer c2 = new ImprovementSavingCanonicalizer();
+        CanonicalizerPhase canonicalizer1 = this.createCanonicalizerPhase().copyWithCustomSimplification(c1);
+        canonicalizer1.apply(g1, htc);
+        ImprovementSavingCalculator c2 = new ImprovementSavingCalculator();
         StructuredGraph g2 = parseForCompile(getResolvedJavaMethod("test2Snippet"));
-        new CanonicalizerPhase(c2).apply(g2, htc);
+        CanonicalizerPhase canonicalizer2 = this.createCanonicalizerPhase().copyWithCustomSimplification(c2);
+        canonicalizer2.apply(g2, htc);
         Assert.assertEquals(0, c1.savedCycles);
         Assert.assertEquals(0, c2.savedCycles);
     }
 
-    private static void prepareGraphForLoopFrequencies(StructuredGraph g, HighTierContext htc) {
+    private void prepareGraphForLoopFrequencies(StructuredGraph g, HighTierContext htc) {
         // let canonicalizer work away branch probability nodes
-        new CanonicalizerPhase().apply(g, htc);
+        createCanonicalizerPhase().apply(g, htc);
         // recompute the loop frequencies
         ComputeLoopFrequenciesClosure.compute(g);
     }
 
     private static void assertFrequency(StructuredGraph g, int iterations) {
@@ -240,12 +242,12 @@
     @Test
     public void testGraphCost() {
         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod("test1Snippet"));
         StructuredGraph g2 = parseForCompile(getResolvedJavaMethod("test2Snippet"));
         HighTierContext htc = getDefaultHighTierContext();
-        new CanonicalizerPhase().apply(g1, htc);
-        new CanonicalizerPhase().apply(g2, htc);
+        createCanonicalizerPhase().apply(g1, htc);
+        createCanonicalizerPhase().apply(g2, htc);
         GraphCostPhase gc1 = new GraphCostPhase();
         GraphCostPhase gc2 = new GraphCostPhase();
         gc1.apply(g1, htc);
         gc2.apply(g2, htc);
         g1.getDebug().log("Test Graph Cost --> 1.Graph cost:%f vs. 2.Graph cost:%f\n", gc1.finalCycles, gc2.finalCycles);
@@ -255,56 +257,56 @@
 
     @Test
     public void testExpectUntrusted() {
         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod("untrused01"));
         HighTierContext htc = getDefaultHighTierContext();
-        new CanonicalizerPhase().apply(g1, htc);
+        createCanonicalizerPhase().apply(g1, htc);
         GraphCostPhase gc1 = new GraphCostPhase();
         gc1.apply(g1, htc);
     }
 
     @Test
     public void testArrayLoad() {
         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod("arrayLoadTest"));
         HighTierContext htc = getDefaultHighTierContext();
-        new CanonicalizerPhase().apply(g1, htc);
+        createCanonicalizerPhase().apply(g1, htc);
         GraphCostPhase gc1 = new GraphCostPhase();
         gc1.apply(g1, htc);
         Assert.assertEquals(15, gc1.finalCycles, 25);
     }
 
     @Test
     public void testArrayStore() {
         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod("arrayStoreTest"));
         HighTierContext htc = getDefaultHighTierContext();
-        new CanonicalizerPhase().apply(g1, htc);
+        createCanonicalizerPhase().apply(g1, htc);
         GraphCostPhase gc1 = new GraphCostPhase();
         gc1.apply(g1, htc);
         Assert.assertEquals(15, gc1.finalCycles, 25);
     }
 
     @Test
     public void testFieldLoad() {
         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod("fieldLoad"));
         HighTierContext htc = getDefaultHighTierContext();
-        new CanonicalizerPhase().apply(g1, htc);
+        createCanonicalizerPhase().apply(g1, htc);
         GraphCostPhase gc1 = new GraphCostPhase();
         gc1.apply(g1, htc);
         Assert.assertEquals(15, gc1.finalCycles, 25);
     }
 
     @Test
     public void testFieldStore() {
         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod("fieldStore"));
         HighTierContext htc = getDefaultHighTierContext();
-        new CanonicalizerPhase().apply(g1, htc);
+        createCanonicalizerPhase().apply(g1, htc);
         GraphCostPhase gc1 = new GraphCostPhase();
         gc1.apply(g1, htc);
         Assert.assertEquals(15, gc1.finalCycles, 25);
     }
 
-    static class ImprovementSavingCanonicalizer extends CustomCanonicalizer {
+    static class ImprovementSavingCalculator implements CustomSimplification {
         private int savedCycles;
 
         @Override
         public void simplify(Node node, SimplifierTool tool) {
             if (node instanceof Canonicalizable.Binary<?>) {
@@ -316,16 +318,16 @@
                 }
             }
         }
     }
 
-    private static class GraphCostPhase extends BasePhase<PhaseContext> {
+    private static class GraphCostPhase extends BasePhase<CoreProviders> {
         private double finalCycles;
         private double finalSize;
 
         @Override
-        protected void run(StructuredGraph graph, PhaseContext context) {
+        protected void run(StructuredGraph graph, CoreProviders context) {
             finalCycles = NodeCostUtil.computeGraphCycles(graph, true);
             finalSize = NodeCostUtil.computeGraphSize(graph);
         }
 
     }

diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ea/UnsafeCompareAndSwapVirtualizationTest.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ea/UnsafeCompareAndSwapVirtualizationTest.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ea/UnsafeCompareAndSwapVirtualizationTest.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ea/UnsafeCompareAndSwapVirtualizationTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -44,11 +44,11 @@
     }
 
     @Test
     public void bothVirtualNoMatchTest() {
         testEscapeAnalysis("bothVirtualNoMatch", JavaConstant.INT_0, true);
-        assertTrue(graph.getNodes(LogicCompareAndSwapNode.TYPE).isEmpty());
+        assertTrue(graph.getNodes().filter(LogicCompareAndSwapNode.class).isEmpty());
     }
 
     public static boolean bothVirtualMatch() {
         Object expect = new Object();
         AtomicReference<Object> a = new AtomicReference<>(expect);
@@ -56,11 +56,11 @@
     }
 
     @Test
     public void bothVirtualMatchTest() {
         testEscapeAnalysis("bothVirtualMatch", JavaConstant.INT_1, true);
-        assertTrue(graph.getNodes(LogicCompareAndSwapNode.TYPE).isEmpty());
+        assertTrue(graph.getNodes().filter(LogicCompareAndSwapNode.class).isEmpty());
     }
 
     public static boolean expectedVirtualMatch() {
         Object o = new Object();
         AtomicReference<Object> a = new AtomicReference<>(o);
@@ -68,11 +68,11 @@
     }
 
     @Test
     public void expectedVirtualMatchTest() {
         testEscapeAnalysis("expectedVirtualMatch", JavaConstant.INT_1, true);
-        assertTrue(graph.getNodes(LogicCompareAndSwapNode.TYPE).isEmpty());
+        assertTrue(graph.getNodes().filter(LogicCompareAndSwapNode.class).isEmpty());
     }
 
     public static boolean expectedVirtualNoMatch() {
         Object o = new Object();
         AtomicReference<Object> a = new AtomicReference<>();
@@ -80,44 +80,44 @@
     }
 
     @Test
     public void expectedVirtualNoMatchTest() {
         testEscapeAnalysis("expectedVirtualNoMatch", JavaConstant.INT_0, true);
-        assertTrue(graph.getNodes(LogicCompareAndSwapNode.TYPE).isEmpty());
+        assertTrue(graph.getNodes().filter(LogicCompareAndSwapNode.class).isEmpty());
     }
 
     public static boolean bothNonVirtualNoMatch() {
         AtomicReference<Object> a = new AtomicReference<>();
         return a.compareAndSet(OBJ1, obj2);
     }
 
     @Test
     public void bothNonVirtualNoMatchTest() {
         testEscapeAnalysis("bothNonVirtualNoMatch", JavaConstant.INT_0, true);
-        assertTrue(graph.getNodes(LogicCompareAndSwapNode.TYPE).isEmpty());
+        assertTrue(graph.getNodes().filter(LogicCompareAndSwapNode.class).isEmpty());
     }
 
     public static boolean bothNonVirtualMatch() {
         AtomicReference<Object> a = new AtomicReference<>(OBJ1);
         return a.compareAndSet(OBJ1, obj2);
     }
 
     @Test
     public void bothNonVirtualMatchTest() {
         testEscapeAnalysis("bothNonVirtualMatch", JavaConstant.INT_1, true);
-        assertTrue(graph.getNodes(LogicCompareAndSwapNode.TYPE).isEmpty());
+        assertTrue(graph.getNodes().filter(LogicCompareAndSwapNode.class).isEmpty());
     }
 
     public static boolean onlyInitialValueVirtualNoMatch() {
         AtomicReference<Object> a = new AtomicReference<>(new Object());
         return a.compareAndSet(obj1, obj2);
     }
 
     @Test
     public void onlyInitialValueVirtualNoMatchTest() {
         testEscapeAnalysis("onlyInitialValueVirtualNoMatch", JavaConstant.INT_0, true);
-        assertTrue(graph.getNodes(LogicCompareAndSwapNode.TYPE).isEmpty());
+        assertTrue(graph.getNodes().filter(LogicCompareAndSwapNode.class).isEmpty());
     }
 
     public static boolean onlyInitialValueVirtualMatch() {
         Object o = new Object();
         AtomicReference<Object> a = new AtomicReference<>(o);
@@ -125,19 +125,19 @@
     }
 
     @Test
     public void onlyInitialValueVirtualMatchTest() {
         testEscapeAnalysis("onlyInitialValueVirtualMatch", JavaConstant.INT_1, true);
-        assertTrue(graph.getNodes(LogicCompareAndSwapNode.TYPE).isEmpty());
+        assertTrue(graph.getNodes().filter(LogicCompareAndSwapNode.class).isEmpty());
     }
 
     public static boolean bothVirtualNoMatchArray() {
         AtomicReferenceArray<Object> array = new AtomicReferenceArray<>(1);
         return array.compareAndSet(0, new Object(), new Object());
     }
 
     @Test
     public void bothVirtualNoMatchArrayTest() {
         testEscapeAnalysis("bothVirtualNoMatchArray", JavaConstant.INT_0, true);
-        assertTrue(graph.getNodes(LogicCompareAndSwapNode.TYPE).isEmpty());
+        assertTrue(graph.getNodes().filter(LogicCompareAndSwapNode.class).isEmpty());
     }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/inlining/InliningTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test.inlining;
 26 
 27 import java.util.regex.Pattern;
 28 
 29 import org.graalvm.compiler.core.common.GraalOptions;
 30 import org.graalvm.compiler.core.test.GraalCompilerTest;
 31 import org.graalvm.compiler.debug.DebugContext;
 32 import org.graalvm.compiler.debug.DebugDumpScope;
 33 import org.graalvm.compiler.debug.TTY;
 34 import org.graalvm.compiler.graph.Node;
 35 import org.graalvm.compiler.nodes.FullInfopointNode;
 36 import org.graalvm.compiler.nodes.Invoke;
 37 import org.graalvm.compiler.nodes.StructuredGraph;
 38 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 39 import org.graalvm.compiler.nodes.StructuredGraph.Builder;
 40 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 41 import org.graalvm.compiler.options.OptionValues;
 42 import org.graalvm.compiler.phases.OptimisticOptimizations;
 43 import org.graalvm.compiler.phases.PhaseSuite;
 44 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 45 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 46 import org.graalvm.compiler.phases.tiers.HighTierContext;
 47 import org.junit.Assert;
 48 import org.junit.Ignore;
 49 import org.junit.Test;
 50 
 51 import jdk.vm.ci.code.site.InfopointReason;
 52 import jdk.vm.ci.meta.ResolvedJavaMethod;
 53 
 54 public class InliningTest extends GraalCompilerTest {
 55 
 56     @Test
 57     public void testInvokeStaticInlining() {
 58         assertInlined(getGraph(&quot;invokeStaticSnippet&quot;, false));
 59         assertInlined(getGraph(&quot;invokeStaticOnInstanceSnippet&quot;, false));
 60     }
 61 
 62     @SuppressWarnings(&quot;all&quot;)
 63     public static Boolean invokeStaticSnippet(boolean value) {
 64         return Boolean.valueOf(value);
 65     }
 66 
 67     @SuppressWarnings({&quot;all&quot;, &quot;static&quot;})
 68     public static Boolean invokeStaticOnInstanceSnippet(Boolean obj, boolean value) {
 69         return obj.valueOf(value);
 70     }
 71 
 72     @Test
 73     public void testStaticBindableInlining() {
 74         assertInlined(getGraph(&quot;invokeConstructorSnippet&quot;, false));
 75         assertInlined(getGraph(&quot;invokeFinalMethodSnippet&quot;, false));
 76         assertInlined(getGraph(&quot;invokeMethodOnFinalClassSnippet&quot;, false));
 77         assertInlined(getGraph(&quot;invokeMethodOnStaticFinalFieldSnippet&quot;, false));
 78     }
 79 
 80     @Ignore(&quot;would need read elimination/EA before inlining&quot;)
 81     @Test
 82     public void testDependentStaticBindableInlining() {
 83         assertInlined(getGraph(&quot;invokeMethodOnFinalFieldSnippet&quot;, false));
 84         assertInlined(getGraph(&quot;invokeMethodOnFieldSnippet&quot;, false));
 85     }
 86 
 87     @Test
 88     public void testStaticBindableInliningIP() {
 89         assertManyMethodInfopoints(assertInlined(getGraph(&quot;invokeConstructorSnippet&quot;, true)));
 90         assertManyMethodInfopoints(assertInlined(getGraph(&quot;invokeFinalMethodSnippet&quot;, true)));
 91         assertManyMethodInfopoints(assertInlined(getGraph(&quot;invokeMethodOnFinalClassSnippet&quot;, true)));
 92         assertManyMethodInfopoints(assertInlined(getGraph(&quot;invokeMethodOnStaticFinalFieldSnippet&quot;, true)));
 93     }
 94 
 95     @Ignore(&quot;would need read elimination/EA before inlining&quot;)
 96     @Test
 97     public void testDependentStaticBindableInliningIP() {
 98         assertManyMethodInfopoints(assertInlined(getGraph(&quot;invokeMethodOnFinalFieldSnippet&quot;, true)));
 99         assertManyMethodInfopoints(assertInlined(getGraph(&quot;invokeMethodOnFieldSnippet&quot;, true)));
100     }
101 
102     @SuppressWarnings(&quot;all&quot;)
103     public static Object invokeConstructorSnippet(int value) {
104         return new SuperClass(value);
105     }
106 
107     @SuppressWarnings(&quot;all&quot;)
108     public static int invokeFinalMethodSnippet(SuperClass superClass, SubClassA subClassA, FinalSubClass finalSubClass) {
109         return superClass.publicFinalMethod() + subClassA.publicFinalMethod() + finalSubClass.publicFinalMethod() + superClass.protectedFinalMethod() + subClassA.protectedFinalMethod() +
110                         finalSubClass.protectedFinalMethod();
111     }
112 
113     @SuppressWarnings(&quot;all&quot;)
114     public static int invokeMethodOnFinalClassSnippet(FinalSubClass finalSubClass) {
115         return finalSubClass.publicFinalMethod() + finalSubClass.publicNotOverriddenMethod() + finalSubClass.publicOverriddenMethod() + finalSubClass.protectedFinalMethod() +
116                         finalSubClass.protectedNotOverriddenMethod() + finalSubClass.protectedOverriddenMethod();
117     }
118 
119     @SuppressWarnings(&quot;all&quot;)
120     public static int invokeMethodOnStaticFinalFieldSnippet() {
121         return StaticFinalFields.NumberStaticFinalField.intValue() + StaticFinalFields.SuperClassStaticFinalField.publicOverriddenMethod() +
122                         StaticFinalFields.FinalSubClassStaticFinalField.publicOverriddenMethod() + StaticFinalFields.SingleImplementorStaticFinalField.publicOverriddenMethod() +
123                         StaticFinalFields.MultipleImplementorsStaticFinalField.publicOverriddenMethod() + StaticFinalFields.SubClassAStaticFinalField.publicOverriddenMethod() +
124                         StaticFinalFields.SubClassBStaticFinalField.publicOverriddenMethod() + StaticFinalFields.SubClassCStaticFinalField.publicOverriddenMethod();
125     }
126 
127     @SuppressWarnings(&quot;all&quot;)
128     public static int invokeMethodOnFinalFieldSnippet() {
129         FinalFields fields = new FinalFields();
130         return fields.numberFinalField.intValue() + fields.superClassFinalField.publicOverriddenMethod() + fields.finalSubClassFinalField.publicOverriddenMethod() +
131                         fields.singleImplementorFinalField.publicOverriddenMethod() + fields.multipleImplementorsFinalField.publicOverriddenMethod() +
132                         fields.subClassAFinalField.publicOverriddenMethod() + fields.subClassBFinalField.publicOverriddenMethod() + fields.subClassCFinalField.publicOverriddenMethod();
133     }
134 
135     @SuppressWarnings(&quot;all&quot;)
136     public static int invokeMethodOnFieldSnippet() {
137         Fields fields = new Fields();
138         return fields.numberField.intValue() + fields.superClassField.publicOverriddenMethod() + fields.finalSubClassField.publicOverriddenMethod() +
139                         fields.singleImplementorField.publicOverriddenMethod() + fields.multipleImplementorsField.publicOverriddenMethod() + fields.subClassAField.publicOverriddenMethod() +
140                         fields.subClassBField.publicOverriddenMethod() + fields.subClassCField.publicOverriddenMethod();
141     }
142 
143     public interface Attributes {
144 
145         int getLength();
146     }
147 
148     public class NullAttributes implements Attributes {
149 
150         @Override
151         public int getLength() {
152             return 0;
153         }
154 
155     }
156 
157     public class TenAttributes implements Attributes {
158 
159         @Override
160         public int getLength() {
161             return 10;
162         }
163 
164     }
165 
166     public int getAttributesLength(Attributes a) {
167         return a.getLength();
168     }
169 
170     @Test
171     public void testGuardedInline() {
172         NullAttributes nullAttributes = new NullAttributes();
173         for (int i = 0; i &lt; 10000; i++) {
174             getAttributesLength(nullAttributes);
175         }
176         getAttributesLength(new TenAttributes());
177 
178         test(&quot;getAttributesLength&quot;, nullAttributes);
179         test(&quot;getAttributesLength&quot;, (Object) null);
180     }
181 
182     @Test
183     public void testClassHierarchyAnalysis() {
184         assertInlined(getGraph(&quot;invokeLeafClassMethodSnippet&quot;, false));
185         assertInlined(getGraph(&quot;invokeConcreteMethodSnippet&quot;, false));
186         assertInlined(getGraph(&quot;invokeSingleImplementorInterfaceSnippet&quot;, false));
187         // assertInlined(getGraph(&quot;invokeConcreteInterfaceMethodSnippet&quot;, false));
188 
189         assertNotInlined(getGraph(&quot;invokeOverriddenPublicMethodSnippet&quot;, false));
190         assertNotInlined(getGraph(&quot;invokeOverriddenProtectedMethodSnippet&quot;, false));
191         assertNotInlined(getGraph(&quot;invokeOverriddenInterfaceMethodSnippet&quot;, false));
192     }
193 
194     @Test
195     public void testClassHierarchyAnalysisIP() {
196         assertManyMethodInfopoints(assertInlined(getGraph(&quot;invokeLeafClassMethodSnippet&quot;, true)));
197         assertManyMethodInfopoints(assertInlined(getGraph(&quot;invokeConcreteMethodSnippet&quot;, true)));
198         assertManyMethodInfopoints(assertInlined(getGraph(&quot;invokeSingleImplementorInterfaceSnippet&quot;, true)));
199         //@formatter:off
200         // assertInlineInfopoints(assertInlined(getGraph(&quot;invokeConcreteInterfaceMethodSnippet&quot;, true)));
201         //@formatter:on
202 
203         assertFewMethodInfopoints(assertNotInlined(getGraph(&quot;invokeOverriddenPublicMethodSnippet&quot;, true)));
204         assertFewMethodInfopoints(assertNotInlined(getGraph(&quot;invokeOverriddenProtectedMethodSnippet&quot;, true)));
205         assertFewMethodInfopoints(assertNotInlined(getGraph(&quot;invokeOverriddenInterfaceMethodSnippet&quot;, true)));
206     }
207 
208     public static void traceInliningTest() {
209         callTrivial();
210     }
211 
212     private static void callTrivial() {
213         callNonTrivial();
214     }
215 
216     private static double callNonTrivial() {
217         double x = 0.0;
218         for (int i = 0; i &lt; 10; i++) {
219             x += i * 1.21;
220         }
221         return x;
222     }
223 
224     @Test
225     @SuppressWarnings(&quot;try&quot;)
226     public void testTracing() {
227         OptionValues options = new OptionValues(getInitialOptions(), GraalOptions.TraceInlining, true);
228         StructuredGraph graph;
229         try (TTY.Filter f = new TTY.Filter()) {
230             graph = getGraph(&quot;traceInliningTest&quot;, options, false);
231         }
232         String inliningTree = graph.getInliningLog().formatAsTree(false);
233         String expectedRegex = &quot;compilation of org.graalvm.compiler.core.test.inlining.InliningTest.traceInliningTest.*: \\R&quot; +
234                         &quot;  at .*org.graalvm.compiler.core.test.inlining.InliningTest.traceInliningTest.*: &lt;GraphBuilderPhase&gt; org.graalvm.compiler.core.test.inlining.InliningTest.callTrivial.*: yes, inline method\\R&quot; +
235                         &quot;    at .*org.graalvm.compiler.core.test.inlining.InliningTest.callTrivial.*: .*\\R&quot; +
236                         &quot;       .*&lt;GraphBuilderPhase&gt; org.graalvm.compiler.core.test.inlining.InliningTest.callNonTrivial.*: .*(.*\\R)*&quot; +
237                         &quot;       .*&lt;InliningPhase&gt; org.graalvm.compiler.core.test.inlining.InliningTest.callNonTrivial.*: .*(.*\\R)*&quot;;
238         Pattern expectedPattern = Pattern.compile(expectedRegex, Pattern.MULTILINE);
239         Assert.assertTrue(&quot;Got: &quot; + inliningTree, expectedPattern.matcher(inliningTree).matches());
240     }
241 
242     @SuppressWarnings(&quot;all&quot;)
243     public static int invokeLeafClassMethodSnippet(SubClassA subClassA) {
244         return subClassA.publicFinalMethod() + subClassA.publicNotOverriddenMethod() + subClassA.publicOverriddenMethod();
245     }
246 
247     @SuppressWarnings(&quot;all&quot;)
248     public static int invokeConcreteMethodSnippet(SuperClass superClass) {
249         return superClass.publicNotOverriddenMethod() + superClass.protectedNotOverriddenMethod();
250     }
251 
252     @SuppressWarnings(&quot;all&quot;)
253     public static int invokeSingleImplementorInterfaceSnippet(SingleImplementorInterface testInterface) {
254         return testInterface.publicNotOverriddenMethod() + testInterface.publicOverriddenMethod();
255     }
256 
257     @SuppressWarnings(&quot;all&quot;)
258     public static int invokeConcreteInterfaceMethodSnippet(MultipleImplementorsInterface testInterface) {
259         return testInterface.publicNotOverriddenMethod();
260     }
261 
262     @SuppressWarnings(&quot;all&quot;)
263     public static int invokeOverriddenInterfaceMethodSnippet(MultipleImplementorsInterface testInterface) {
264         return testInterface.publicOverriddenMethod();
265     }
266 
267     @SuppressWarnings(&quot;all&quot;)
268     public static int invokeOverriddenPublicMethodSnippet(SuperClass superClass) {
269         return superClass.publicOverriddenMethod();
270     }
271 
272     @SuppressWarnings(&quot;all&quot;)
273     public static int invokeOverriddenProtectedMethodSnippet(SuperClass superClass) {
274         return superClass.protectedOverriddenMethod();
275     }
276 
277     private StructuredGraph getGraph(final String snippet, final boolean eagerInfopointMode) {
278         return getGraph(snippet, null, eagerInfopointMode);
279     }
280 
281     @SuppressWarnings(&quot;try&quot;)
282     private StructuredGraph getGraph(final String snippet, OptionValues options, final boolean eagerInfopointMode) {
283         DebugContext debug = options == null ? getDebugContext() : getDebugContext(options, null, null);
284         try (DebugContext.Scope s = debug.scope(&quot;InliningTest&quot;, new DebugDumpScope(snippet, true))) {
285             ResolvedJavaMethod method = getResolvedJavaMethod(snippet);
286             Builder builder = builder(method, AllowAssumptions.YES, debug);
287             StructuredGraph graph = eagerInfopointMode ? parse(builder, getDebugGraphBuilderSuite()) : parse(builder, getEagerGraphBuilderSuite());
288             try (DebugContext.Scope s2 = debug.scope(&quot;Inlining&quot;, graph)) {
289                 PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite = eagerInfopointMode
290                                 ? getCustomGraphBuilderSuite(GraphBuilderConfiguration.getDefault(getDefaultGraphBuilderPlugins()).withFullInfopoints(true))
291                                 : getDefaultGraphBuilderSuite();
292                 HighTierContext context = new HighTierContext(getProviders(), graphBuilderSuite, OptimisticOptimizations.ALL);
293                 debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;Graph&quot;);
294                 new CanonicalizerPhase().apply(graph, context);
295                 createInliningPhase().apply(graph, context);
296                 debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;Graph&quot;);
297                 new CanonicalizerPhase().apply(graph, context);
298                 new DeadCodeEliminationPhase().apply(graph);
299                 return graph;
300             }
301         } catch (Throwable e) {
302             throw debug.handle(e);
303         }
304     }
305 
306     private static StructuredGraph assertInlined(StructuredGraph graph) {
307         return assertNotInGraph(graph, Invoke.class);
308     }
309 
310     private static StructuredGraph assertNotInlined(StructuredGraph graph) {
311         return assertInGraph(graph, Invoke.class);
312     }
313 
314     private static StructuredGraph assertNotInGraph(StructuredGraph graph, Class&lt;?&gt; clazz) {
315         for (Node node : graph.getNodes()) {
316             if (clazz.isInstance(node)) {
317                 fail(node.toString());
318             }
319         }
320         return graph;
321     }
322 
323     private static StructuredGraph assertInGraph(StructuredGraph graph, Class&lt;?&gt; clazz) {
324         for (Node node : graph.getNodes()) {
325             if (clazz.isInstance(node)) {
326                 return graph;
327             }
328         }
329         fail(&quot;Graph does not contain a node of class &quot; + clazz.getName());
330         return graph;
331     }
332 
333     private static int[] countMethodInfopoints(StructuredGraph graph) {
334         int start = 0;
335         int end = 0;
336         for (FullInfopointNode ipn : graph.getNodes().filter(FullInfopointNode.class)) {
337             if (ipn.getReason() == InfopointReason.METHOD_START) {
338                 ++start;
339             } else if (ipn.getReason() == InfopointReason.METHOD_END) {
340                 ++end;
341             }
342         }
343         return new int[]{start, end};
344     }
345 
346     private static StructuredGraph assertManyMethodInfopoints(StructuredGraph graph) {
347         int[] counts = countMethodInfopoints(graph);
348         if (counts[0] &lt;= 1 || counts[1] &lt;= 1) {
349             fail(String.format(&quot;Graph contains too few required method boundary infopoints: %d starts, %d ends.&quot;, counts[0], counts[1]));
350         }
351         return graph;
352     }
353 
354     private static StructuredGraph assertFewMethodInfopoints(StructuredGraph graph) {
355         int[] counts = countMethodInfopoints(graph);
356         if (counts[0] &gt; 1 || counts[1] &gt; 1) {
357             fail(String.format(&quot;Graph contains too many method boundary infopoints: %d starts, %d ends.&quot;, counts[0], counts[1]));
358         }
359         return graph;
360     }
361 
362     // some interfaces and classes for testing
363     private interface MultipleImplementorsInterface {
364 
365         int publicNotOverriddenMethod();
366 
367         int publicOverriddenMethod();
368     }
369 
370     private interface SingleImplementorInterface {
371 
372         int publicNotOverriddenMethod();
373 
374         int publicOverriddenMethod();
375     }
376 
377     private static class SuperClass implements MultipleImplementorsInterface {
378 
379         protected int value;
380 
381         SuperClass(int value) {
382             this.value = value;
383         }
384 
385         @Override
386         public int publicNotOverriddenMethod() {
387             return value;
388         }
389 
390         @Override
391         public int publicOverriddenMethod() {
392             return value;
393         }
394 
395         protected int protectedNotOverriddenMethod() {
396             return value;
397         }
398 
399         protected int protectedOverriddenMethod() {
400             return value;
401         }
402 
403         public final int publicFinalMethod() {
404             return value + 255;
405         }
406 
407         protected final int protectedFinalMethod() {
408             return value + 255;
409         }
410     }
411 
412     private static class SubClassA extends SuperClass implements SingleImplementorInterface {
413 
414         SubClassA(int value) {
415             super(value);
416         }
417 
418         @Override
419         public int publicOverriddenMethod() {
420             return value + 2;
421         }
422 
423         @Override
424         protected int protectedOverriddenMethod() {
425             return value * 2;
426         }
427     }
428 
429     private static class SubClassB extends SuperClass {
430 
431         SubClassB(int value) {
432             super(value);
433         }
434 
435         @Override
436         public int publicOverriddenMethod() {
437             return value + 3;
438         }
439 
440         @Override
441         protected int protectedOverriddenMethod() {
442             return value * 3;
443         }
444     }
445 
446     private static class SubClassC extends SuperClass {
447 
448         SubClassC(int value) {
449             super(value);
450         }
451 
452         @Override
453         public int publicOverriddenMethod() {
454             return value + 4;
455         }
456 
457         @Override
458         protected int protectedOverriddenMethod() {
459             return value * 4;
460         }
461     }
462 
463     private static final class FinalSubClass extends SuperClass {
464 
465         FinalSubClass(int value) {
466             super(value);
467         }
468 
469         @Override
470         public int publicOverriddenMethod() {
471             return value + 5;
472         }
473 
474         @Override
475         protected int protectedOverriddenMethod() {
476             return value * 5;
477         }
478     }
479 
480     private static final class StaticFinalFields {
481 
482         private static final Number NumberStaticFinalField = Integer.valueOf(1);
483         private static final SuperClass SuperClassStaticFinalField = new SubClassA(2);
484         private static final FinalSubClass FinalSubClassStaticFinalField = new FinalSubClass(3);
485         private static final SingleImplementorInterface SingleImplementorStaticFinalField = new SubClassA(4);
486         private static final MultipleImplementorsInterface MultipleImplementorsStaticFinalField = new SubClassC(5);
487         private static final SubClassA SubClassAStaticFinalField = new SubClassA(6);
488         private static final SubClassB SubClassBStaticFinalField = new SubClassB(7);
489         private static final SubClassC SubClassCStaticFinalField = new SubClassC(8);
490     }
491 
492     private static final class FinalFields {
493 
494         private final Number numberFinalField = Integer.valueOf(1);
495         private final SuperClass superClassFinalField = new SubClassA(2);
496         private final FinalSubClass finalSubClassFinalField = new FinalSubClass(3);
497         private final SingleImplementorInterface singleImplementorFinalField = new SubClassA(4);
498         private final MultipleImplementorsInterface multipleImplementorsFinalField = new SubClassC(5);
499         private final SubClassA subClassAFinalField = new SubClassA(6);
500         private final SubClassB subClassBFinalField = new SubClassB(7);
501         private final SubClassC subClassCFinalField = new SubClassC(8);
502     }
503 
504     private static final class Fields {
505 
506         private Number numberField = Integer.valueOf(1);
507         private SuperClass superClassField = new SubClassA(2);
508         private FinalSubClass finalSubClassField = new FinalSubClass(3);
509         private SingleImplementorInterface singleImplementorField = new SubClassA(4);
510         private MultipleImplementorsInterface multipleImplementorsField = new SubClassC(5);
511         private SubClassA subClassAField = new SubClassA(6);
512         private SubClassB subClassBField = new SubClassB(7);
513         private SubClassC subClassCField = new SubClassC(8);
514     }
515 }
    </pre>
  </body>
</html>
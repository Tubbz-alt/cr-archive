<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/CheckGraalInvariants.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CanonicalizedConversionTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompareCanonicalizerTest.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/CheckGraalInvariants.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 30,11 ---</span>
  import java.io.StringWriter;
  import java.lang.annotation.Annotation;
  import java.lang.reflect.Method;
  import java.lang.reflect.Modifier;
  import java.util.ArrayList;
<span class="line-added">+ import java.util.Arrays;</span>
  import java.util.Collections;
  import java.util.Enumeration;
  import java.util.List;
  import java.util.concurrent.LinkedBlockingQueue;
  import java.util.concurrent.ThreadPoolExecutor;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,20 ***</span>
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.OptimisticOptimizations;
  import org.graalvm.compiler.phases.PhaseSuite;
  import org.graalvm.compiler.phases.VerifyPhase;
  import org.graalvm.compiler.phases.VerifyPhase.VerificationError;
  import org.graalvm.compiler.phases.contract.VerifyNodeCosts;
  import org.graalvm.compiler.phases.tiers.HighTierContext;
<span class="line-removed">- import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
  import org.graalvm.compiler.phases.util.Providers;
  import org.graalvm.compiler.runtime.RuntimeProvider;
  import jdk.internal.vm.compiler.word.LocationIdentity;
  import org.junit.Assert;
  import org.junit.Assume;
  import org.junit.Test;
  
<span class="line-new-header">--- 64,23 ---</span>
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
<span class="line-added">+ import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.OptimisticOptimizations;
  import org.graalvm.compiler.phases.PhaseSuite;
  import org.graalvm.compiler.phases.VerifyPhase;
  import org.graalvm.compiler.phases.VerifyPhase.VerificationError;
  import org.graalvm.compiler.phases.contract.VerifyNodeCosts;
  import org.graalvm.compiler.phases.tiers.HighTierContext;
  import org.graalvm.compiler.phases.util.Providers;
  import org.graalvm.compiler.runtime.RuntimeProvider;
<span class="line-added">+ import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
<span class="line-added">+ import org.graalvm.compiler.test.AddExports;</span>
<span class="line-added">+ import org.graalvm.compiler.api.test.ModuleSupport;</span>
  import jdk.internal.vm.compiler.word.LocationIdentity;
  import org.junit.Assert;
  import org.junit.Assume;
  import org.junit.Test;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,12 ***</span>
<span class="line-new-header">--- 98,19 ---</span>
  /**
   * Checks that all classes in *graal*.jar and *jvmci*.jar entries on the boot class path comply with
   * global invariants such as using {@link Object#equals(Object)} to compare certain types instead of
   * identity comparisons.
   */
<span class="line-added">+ @AddExports(&quot;jdk.internal.vm.ci/*=jdk.aot&quot;)</span>
  public class CheckGraalInvariants extends GraalCompilerTest {
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Magic token to denote the classes in the Java runtime image (i.e. in the {@code jrt:/} file</span>
<span class="line-added">+      * system).</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static final String JRT_CLASS_PATH_ENTRY = &quot;&lt;jrt&gt;&quot;;</span>
<span class="line-added">+ </span>
      private static boolean shouldVerifyEquals(ResolvedJavaMethod m) {
          if (m.getName().equals(&quot;identityEquals&quot;)) {
              ResolvedJavaType c = m.getDeclaringClass();
              if (c.getName().equals(&quot;Ljdk/vm/ci/meta/AbstractValue;&quot;) || c.getName().equals(&quot;jdk/vm/ci/meta/Value&quot;)) {
                  return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,32 ***</span>
      }
  
      public static class InvariantsTool {
  
          protected boolean shouldProcess(String classpathEntry) {
              if (classpathEntry.endsWith(&quot;.jar&quot;)) {
                  String name = new File(classpathEntry).getName();
                  return name.contains(&quot;jvmci&quot;) || name.contains(&quot;graal&quot;) || name.contains(&quot;jdk.internal.vm.compiler&quot;);
              }
              return false;
          }
  
          protected String getClassPath() {
              String bootclasspath;
<span class="line-modified">!             if (Java8OrEarlier) {</span>
                  bootclasspath = System.getProperty(&quot;sun.boot.class.path&quot;);
              } else {
<span class="line-modified">!                 bootclasspath = System.getProperty(&quot;jdk.module.path&quot;) + File.pathSeparatorChar + System.getProperty(&quot;jdk.module.upgrade.path&quot;);</span>
              }
              return bootclasspath;
          }
  
          protected boolean shouldLoadClass(String className) {
              if (className.equals(&quot;module-info&quot;) || className.startsWith(&quot;META-INF.versions.&quot;)) {
                  return false;
              }
<span class="line-modified">!             if (!Java8OrEarlier) {</span>
                  // @formatter:off
                  /*
                   * Work around to prevent:
                   *
                   * org.graalvm.compiler.debug.GraalError: java.lang.IllegalAccessError: class org.graalvm.compiler.serviceprovider.GraalServices$Lazy (in module
<span class="line-new-header">--- 126,35 ---</span>
      }
  
      public static class InvariantsTool {
  
          protected boolean shouldProcess(String classpathEntry) {
<span class="line-added">+             if (classpathEntry.equals(JRT_CLASS_PATH_ENTRY)) {</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
              if (classpathEntry.endsWith(&quot;.jar&quot;)) {
                  String name = new File(classpathEntry).getName();
                  return name.contains(&quot;jvmci&quot;) || name.contains(&quot;graal&quot;) || name.contains(&quot;jdk.internal.vm.compiler&quot;);
              }
              return false;
          }
  
          protected String getClassPath() {
              String bootclasspath;
<span class="line-modified">!             if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
                  bootclasspath = System.getProperty(&quot;sun.boot.class.path&quot;);
              } else {
<span class="line-modified">!                 bootclasspath = JRT_CLASS_PATH_ENTRY;</span>
              }
              return bootclasspath;
          }
  
          protected boolean shouldLoadClass(String className) {
              if (className.equals(&quot;module-info&quot;) || className.startsWith(&quot;META-INF.versions.&quot;)) {
                  return false;
              }
<span class="line-modified">!             if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
                  // @formatter:off
                  /*
                   * Work around to prevent:
                   *
                   * org.graalvm.compiler.debug.GraalError: java.lang.IllegalAccessError: class org.graalvm.compiler.serviceprovider.GraalServices$Lazy (in module
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,10 ***</span>
<span class="line-new-header">--- 188,17 ---</span>
          }
  
          public boolean shouldVerifyFoldableMethods() {
              return true;
          }
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Makes edits to the list of verifiers to be run.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added">+         protected void updateVerifiers(List&lt;VerifyPhase&lt;CoreProviders&gt;&gt; verifiers) {</span>
<span class="line-added">+         }</span>
      }
  
      @Test
      @SuppressWarnings(&quot;try&quot;)
      public void test() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,31 ***</span>
  
          final List&lt;String&gt; classNames = new ArrayList&lt;&gt;();
          for (String path : bootclasspath.split(File.pathSeparator)) {
              if (tool.shouldProcess(path)) {
                  try {
<span class="line-modified">!                     final ZipFile zipFile = new ZipFile(new File(path));</span>
<span class="line-modified">!                     for (final Enumeration&lt;? extends ZipEntry&gt; entry = zipFile.entries(); entry.hasMoreElements();) {</span>
<span class="line-removed">-                         final ZipEntry zipEntry = entry.nextElement();</span>
<span class="line-removed">-                         String name = zipEntry.getName();</span>
<span class="line-removed">-                         if (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.startsWith(&quot;META-INF/versions/&quot;)) {</span>
<span class="line-removed">-                             String className = name.substring(0, name.length() - &quot;.class&quot;.length()).replace(&#39;/&#39;, &#39;.&#39;);</span>
<span class="line-removed">-                             if (isInNativeImage(className)) {</span>
<span class="line-removed">-                                 /*</span>
<span class="line-removed">-                                  * Native Image is an external tool and does not need to follow the</span>
<span class="line-removed">-                                  * Graal invariants.</span>
<span class="line-removed">-                                  */</span>
<span class="line-removed">-                                 continue;</span>
<span class="line-removed">-                             }</span>
                              if (isGSON(className)) {
                                  /*
                                   * GSON classes are compiled with old JDK
                                   */
                                  continue;
                              }
                              classNames.add(className);
                          }
                      }
                  } catch (IOException ex) {
                      Assert.fail(ex.toString());
                  }
              }
<span class="line-new-header">--- 225,43 ---</span>
  
          final List&lt;String&gt; classNames = new ArrayList&lt;&gt;();
          for (String path : bootclasspath.split(File.pathSeparator)) {
              if (tool.shouldProcess(path)) {
                  try {
<span class="line-modified">!                     if (path.equals(JRT_CLASS_PATH_ENTRY)) {</span>
<span class="line-modified">!                         for (String className : ModuleSupport.getJRTGraalClassNames()) {</span>
                              if (isGSON(className)) {
                                  /*
                                   * GSON classes are compiled with old JDK
                                   */
                                  continue;
                              }
                              classNames.add(className);
                          }
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         final ZipFile zipFile = new ZipFile(new File(path));</span>
<span class="line-added">+                         for (final Enumeration&lt;? extends ZipEntry&gt; entry = zipFile.entries(); entry.hasMoreElements();) {</span>
<span class="line-added">+                             final ZipEntry zipEntry = entry.nextElement();</span>
<span class="line-added">+                             String name = zipEntry.getName();</span>
<span class="line-added">+                             if (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.startsWith(&quot;META-INF/versions/&quot;)) {</span>
<span class="line-added">+                                 String className = name.substring(0, name.length() - &quot;.class&quot;.length()).replace(&#39;/&#39;, &#39;.&#39;);</span>
<span class="line-added">+                                 if (isInNativeImage(className)) {</span>
<span class="line-added">+                                     /*</span>
<span class="line-added">+                                      * Native Image is an external tool and does not need to follow</span>
<span class="line-added">+                                      * the Graal invariants.</span>
<span class="line-added">+                                      */</span>
<span class="line-added">+                                     continue;</span>
<span class="line-added">+                                 }</span>
<span class="line-added">+                                 if (isGSON(className)) {</span>
<span class="line-added">+                                     /*</span>
<span class="line-added">+                                      * GSON classes are compiled with old JDK</span>
<span class="line-added">+                                      */</span>
<span class="line-added">+                                     continue;</span>
<span class="line-added">+                                 }</span>
<span class="line-added">+                                 classNames.add(className);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
                      }
                  } catch (IOException ex) {
                      Assert.fail(ex.toString());
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,11 ***</span>
          int availableProcessors = Runtime.getRuntime().availableProcessors();
          ThreadPoolExecutor executor = new ThreadPoolExecutor(availableProcessors, availableProcessors, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), factory);
  
          List&lt;String&gt; errors = Collections.synchronizedList(new ArrayList&lt;&gt;());
  
<span class="line-modified">!         List&lt;VerifyPhase&lt;PhaseContext&gt;&gt; verifiers = new ArrayList&lt;&gt;();</span>
  
          // If you add a new type to test here, be sure to add appropriate
          // methods to the BadUsageWithEquals class below
          verifiers.add(new VerifyUsageWithEquals(Value.class));
          verifiers.add(new VerifyUsageWithEquals(Register.class));
<span class="line-new-header">--- 277,11 ---</span>
          int availableProcessors = Runtime.getRuntime().availableProcessors();
          ThreadPoolExecutor executor = new ThreadPoolExecutor(availableProcessors, availableProcessors, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), factory);
  
          List&lt;String&gt; errors = Collections.synchronizedList(new ArrayList&lt;&gt;());
  
<span class="line-modified">!         List&lt;VerifyPhase&lt;CoreProviders&gt;&gt; verifiers = new ArrayList&lt;&gt;();</span>
  
          // If you add a new type to test here, be sure to add appropriate
          // methods to the BadUsageWithEquals class below
          verifiers.add(new VerifyUsageWithEquals(Value.class));
          verifiers.add(new VerifyUsageWithEquals(Register.class));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,19 ***</span>
<span class="line-new-header">--- 297,24 ---</span>
          verifiers.add(new VerifyDebugUsage());
          verifiers.add(new VerifyCallerSensitiveMethods());
          verifiers.add(new VerifyVirtualizableUsage());
          verifiers.add(new VerifyUpdateUsages());
          verifiers.add(new VerifyBailoutUsage());
<span class="line-added">+         verifiers.add(new VerifySystemPropertyUsage());</span>
          verifiers.add(new VerifyInstanceOfUsage());
          verifiers.add(new VerifyGraphAddUsage());
<span class="line-added">+         verifiers.add(new VerifyBufferUsage());</span>
          verifiers.add(new VerifyGetOptionsUsage());
<span class="line-added">+         verifiers.add(new VerifyUnsafeAccess());</span>
  
          VerifyFoldableMethods foldableMethodsVerifier = new VerifyFoldableMethods();
          if (tool.shouldVerifyFoldableMethods()) {
              verifiers.add(foldableMethodsVerifier);
          }
  
<span class="line-added">+         tool.updateVerifiers(verifiers);</span>
<span class="line-added">+ </span>
          for (Method m : BadUsageWithEquals.class.getDeclaredMethods()) {
              ResolvedJavaMethod method = metaAccess.lookupJavaMethod(m);
              try (DebugContext debug = DebugContext.create(options, DebugHandlersFactory.LOADER)) {
                  StructuredGraph graph = new StructuredGraph.Builder(options, debug, AllowAssumptions.YES).method(method).build();
                  try (DebugCloseable s = debug.disableIntercept(); DebugContext.Scope ds = debug.scope(&quot;CheckingGraph&quot;, graph, method)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,25 ***</span>
              List&lt;Class&lt;?&gt;&gt; classes = initializeClasses(tool, classNames);
              for (Class&lt;?&gt; c : classes) {
                  String className = c.getName();
                  executor.execute(() -&gt; {
                      try {
<span class="line-modified">!                         checkClass(c, metaAccess);</span>
                      } catch (Throwable e) {
                          errors.add(String.format(&quot;Error while checking %s:%n%s&quot;, className, printStackTraceToString(e)));
                      }
                  });
  
<span class="line-modified">!                 for (Method m : c.getDeclaredMethods()) {</span>
<span class="line-modified">!                     if (Modifier.isNative(m.getModifiers()) || Modifier.isAbstract(m.getModifiers())) {</span>
                          // ignore
                      } else {
<span class="line-modified">!                         String methodName = className + &quot;.&quot; + m.getName();</span>
                          if (matches(filters, methodName)) {
                              executor.execute(() -&gt; {
                                  try (DebugContext debug = DebugContext.create(options, DebugHandlersFactory.LOADER)) {
<span class="line-removed">-                                     ResolvedJavaMethod method = metaAccess.lookupJavaMethod(m);</span>
                                      boolean isSubstitution = method.getAnnotation(Snippet.class) != null || method.getAnnotation(MethodSubstitution.class) != null;
                                      StructuredGraph graph = new StructuredGraph.Builder(options, debug).method(method).setIsSubstitution(isSubstitution).build();
                                      try (DebugCloseable s = debug.disableIntercept(); DebugContext.Scope ds = debug.scope(&quot;CheckingGraph&quot;, graph, method)) {
                                          checkMethod(method);
                                          graphBuilderSuite.apply(graph, context);
<span class="line-new-header">--- 337,37 ---</span>
              List&lt;Class&lt;?&gt;&gt; classes = initializeClasses(tool, classNames);
              for (Class&lt;?&gt; c : classes) {
                  String className = c.getName();
                  executor.execute(() -&gt; {
                      try {
<span class="line-modified">!                         checkClass(c, metaAccess, verifiers);</span>
                      } catch (Throwable e) {
                          errors.add(String.format(&quot;Error while checking %s:%n%s&quot;, className, printStackTraceToString(e)));
                      }
                  });
  
<span class="line-modified">!                 ResolvedJavaType type = metaAccess.lookupJavaType(c);</span>
<span class="line-modified">!                 List&lt;ResolvedJavaMethod&gt; methods = new ArrayList&lt;&gt;();</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     methods.addAll(Arrays.asList(type.getDeclaredMethods()));</span>
<span class="line-added">+                     methods.addAll(Arrays.asList(type.getDeclaredConstructors()));</span>
<span class="line-added">+                 } catch (Throwable e) {</span>
<span class="line-added">+                     errors.add(String.format(&quot;Error while checking %s:%n%s&quot;, className, printStackTraceToString(e)));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 ResolvedJavaMethod clinit = type.getClassInitializer();</span>
<span class="line-added">+                 if (clinit != null) {</span>
<span class="line-added">+                     methods.add(clinit);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 for (ResolvedJavaMethod method : methods) {</span>
<span class="line-added">+                     if (Modifier.isNative(method.getModifiers()) || Modifier.isAbstract(method.getModifiers())) {</span>
                          // ignore
                      } else {
<span class="line-modified">!                         String methodName = className + &quot;.&quot; + method.getName();</span>
                          if (matches(filters, methodName)) {
                              executor.execute(() -&gt; {
                                  try (DebugContext debug = DebugContext.create(options, DebugHandlersFactory.LOADER)) {
                                      boolean isSubstitution = method.getAnnotation(Snippet.class) != null || method.getAnnotation(MethodSubstitution.class) != null;
                                      StructuredGraph graph = new StructuredGraph.Builder(options, debug).method(method).setIsSubstitution(isSubstitution).build();
                                      try (DebugCloseable s = debug.disableIntercept(); DebugContext.Scope ds = debug.scope(&quot;CheckingGraph&quot;, graph, method)) {
                                          checkMethod(method);
                                          graphBuilderSuite.apply(graph, context);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 389,27 ***</span>
                  continue;
              }
              try {
                  Class&lt;?&gt; c = Class.forName(className, true, CheckGraalInvariants.class.getClassLoader());
                  classes.add(c);
              } catch (Throwable t) {
                  tool.handleClassLoadingException(t);
              }
          }
          return classes;
      }
  
      /**
       * @param metaAccess
       */
<span class="line-modified">!     private static void checkClass(Class&lt;?&gt; c, MetaAccessProvider metaAccess) {</span>
          if (Node.class.isAssignableFrom(c)) {
              if (c.getAnnotation(NodeInfo.class) == null) {
                  throw new AssertionError(String.format(&quot;Node subclass %s requires %s annotation&quot;, c.getName(), NodeClass.class.getSimpleName()));
              }
              VerifyNodeCosts.verifyNodeClass(c);
          }
      }
  
      private static void checkMethod(ResolvedJavaMethod method) {
          if (method.getAnnotation(Snippet.class) == null) {
              Annotation[][] parameterAnnotations = method.getParameterAnnotations();
<span class="line-new-header">--- 439,41 ---</span>
                  continue;
              }
              try {
                  Class&lt;?&gt; c = Class.forName(className, true, CheckGraalInvariants.class.getClassLoader());
                  classes.add(c);
<span class="line-added">+             } catch (UnsupportedClassVersionError e) {</span>
<span class="line-added">+                 // graal-test.jar can contain classes compiled for different Java versions</span>
<span class="line-added">+             } catch (NoClassDefFoundError e) {</span>
<span class="line-added">+                 if (!e.getMessage().contains(&quot;Could not initialize class&quot;)) {</span>
<span class="line-added">+                     throw e;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // A second or later attempt to initialize a class</span>
<span class="line-added">+                     // results in this confusing error where the</span>
<span class="line-added">+                     // original cause of initialization failure is lost</span>
<span class="line-added">+                 }</span>
              } catch (Throwable t) {
                  tool.handleClassLoadingException(t);
              }
          }
          return classes;
      }
  
      /**
       * @param metaAccess
<span class="line-added">+      * @param verifiers</span>
       */
<span class="line-modified">!     private static void checkClass(Class&lt;?&gt; c, MetaAccessProvider metaAccess, List&lt;VerifyPhase&lt;CoreProviders&gt;&gt; verifiers) {</span>
          if (Node.class.isAssignableFrom(c)) {
              if (c.getAnnotation(NodeInfo.class) == null) {
                  throw new AssertionError(String.format(&quot;Node subclass %s requires %s annotation&quot;, c.getName(), NodeClass.class.getSimpleName()));
              }
              VerifyNodeCosts.verifyNodeClass(c);
          }
<span class="line-added">+         for (VerifyPhase&lt;CoreProviders&gt; verifier : verifiers) {</span>
<span class="line-added">+             verifier.verifyClass(c, metaAccess);</span>
<span class="line-added">+         }</span>
      }
  
      private static void checkMethod(ResolvedJavaMethod method) {
          if (method.getAnnotation(Snippet.class) == null) {
              Annotation[][] parameterAnnotations = method.getParameterAnnotations();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 428,12 ***</span>
      }
  
      /**
       * Checks the invariants for a single graph.
       */
<span class="line-modified">!     private static void checkGraph(List&lt;VerifyPhase&lt;PhaseContext&gt;&gt; verifiers, HighTierContext context, StructuredGraph graph) {</span>
<span class="line-modified">!         for (VerifyPhase&lt;PhaseContext&gt; verifier : verifiers) {</span>
              if (!(verifier instanceof VerifyUsageWithEquals) || shouldVerifyEquals(graph.method())) {
                  verifier.apply(graph, context);
              } else {
                  verifier.apply(graph, context);
              }
<span class="line-new-header">--- 492,12 ---</span>
      }
  
      /**
       * Checks the invariants for a single graph.
       */
<span class="line-modified">!     private static void checkGraph(List&lt;VerifyPhase&lt;CoreProviders&gt;&gt; verifiers, HighTierContext context, StructuredGraph graph) {</span>
<span class="line-modified">!         for (VerifyPhase&lt;CoreProviders&gt; verifier : verifiers) {</span>
              if (!(verifier instanceof VerifyUsageWithEquals) || shouldVerifyEquals(graph.method())) {
                  verifier.apply(graph, context);
              } else {
                  verifier.apply(graph, context);
              }
</pre>
<center><a href="CanonicalizedConversionTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompareCanonicalizerTest.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
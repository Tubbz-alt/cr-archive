<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ea/EscapeAnalysisTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EarlyReadEliminationTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PEAAssertionsTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ea/EscapeAnalysisTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test.ea;
 26 
 27 import java.util.List;
 28 
 29 import org.graalvm.compiler.graph.Node;
 30 import org.graalvm.compiler.graph.iterators.NodeIterable;
 31 import org.graalvm.compiler.loop.DefaultLoopPolicies;
 32 import org.graalvm.compiler.loop.phases.LoopFullUnrollPhase;
 33 import org.graalvm.compiler.loop.phases.LoopPeelingPhase;
 34 import org.graalvm.compiler.nodes.ConstantNode;
 35 import org.graalvm.compiler.nodes.ReturnNode;
 36 import org.graalvm.compiler.nodes.extended.BoxNode;
 37 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;
 38 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 39 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
 40 import org.graalvm.compiler.nodes.virtual.CommitAllocationNode;
<span class="line-removed"> 41 import org.graalvm.compiler.phases.common.CanonicalizerPhase;</span>
 42 import org.graalvm.compiler.phases.schedule.SchedulePhase;

 43 import org.graalvm.compiler.virtual.phases.ea.PartialEscapePhase;
 44 import org.junit.Assert;
 45 import org.junit.Assume;
 46 import org.junit.Test;
 47 
 48 import jdk.vm.ci.meta.JavaConstant;
 49 
 50 /**
 51  * The PartialEscapeAnalysisPhase is expected to remove all allocations and return the correct
 52  * values.
 53  */
 54 public class EscapeAnalysisTest extends EATestBase {
 55 
 56     @Test
 57     public void test1() {
 58         testEscapeAnalysis(&quot;test1Snippet&quot;, JavaConstant.forInt(101), false);
 59     }
 60 
 61     @SuppressWarnings(&quot;deprecation&quot;)
 62     public static int test1Snippet() {
</pre>
<hr />
<pre>
309             obj = new MyException(one);
310             notInlineable();
311         } else {
312             obj = new MyException(one);
313             notInlineable();
314         }
315         return obj.value &lt;= 3 ? 1 : 0;
316     }
317 
318     /**
319      * Tests that a graph with allocations that does not make progress during PEA will not be
320      * changed.
321      */
322     @Test
323     public void testChangeHandling() {
324         prepareGraph(&quot;testChangeHandlingSnippet&quot;, false);
325         Assert.assertEquals(2, graph.getNodes().filter(CommitAllocationNode.class).count());
326         Assert.assertEquals(1, graph.getNodes().filter(BoxNode.class).count());
327         List&lt;Node&gt; nodes = graph.getNodes().snapshot();
328         // verify that an additional run doesn&#39;t add or remove nodes
<span class="line-modified">329         new PartialEscapePhase(false, false, new CanonicalizerPhase(), null, graph.getOptions()).apply(graph, context);</span>
330         Assert.assertEquals(nodes.size(), graph.getNodeCount());
331         for (Node node : nodes) {
332             Assert.assertTrue(node.isAlive());
333         }
334     }
335 
336     public volatile Object field;
337 
338     @SuppressWarnings(&quot;deprecation&quot;)
339     public int testChangeHandlingSnippet(int a) {
340         Object obj;
341         Integer one = 1;
342         obj = new MyException(one);
343         if (a &lt; 0) {
344             notInlineable();
345         } else {
346             obj = new Integer(1);
347             notInlineable();
348         }
349         field = obj;
350         return 1;
351     }
352 
353     /**
354      * Test the case where allocations before and during a loop that have no usages other than their
355      * phi need to be recognized as an important change. This needs a loop so that the allocation is
356      * not trivially removed by dead code elimination.
357      */
358     @Test
359     public void testRemovalSpecialCase() {
360         prepareGraph(&quot;testRemovalSpecialCaseSnippet&quot;, false);
361         Assert.assertEquals(2, graph.getNodes().filter(CommitAllocationNode.class).count());
362         // create the situation by removing the if
363         graph.replaceFixedWithFloating(graph.getNodes().filter(LoadFieldNode.class).first(), graph.unique(ConstantNode.forInt(0)));
<span class="line-modified">364         new CanonicalizerPhase().apply(graph, context);</span>
365         // verify that an additional run removes all allocations
<span class="line-modified">366         new PartialEscapePhase(false, false, new CanonicalizerPhase(), null, graph.getOptions()).apply(graph, context);</span>
367         Assert.assertEquals(0, graph.getNodes().filter(CommitAllocationNode.class).count());
368     }
369 
370     public volatile int field2;
371 
372     public int testRemovalSpecialCaseSnippet(int a) {
373         Object phi = new Object();
374         for (int i = 0; i &lt; a; i++) {
375             field = null;
376             if (field2 == 1) {
377                 phi = new Object();
378             }
379         }
380         return phi == null ? 1 : 0;
381     }
382 
383     @Test
384     public void testCheckCast() {
385         testEscapeAnalysis(&quot;testCheckCastSnippet&quot;, getSnippetReflection().forObject(TestClassObject.class), true);
386     }
</pre>
<hr />
<pre>
396         testEscapeAnalysis(&quot;testInstanceOfSnippet&quot;, JavaConstant.forInt(1), false);
397     }
398 
399     public boolean testInstanceOfSnippet() {
400         TestClassObject obj = new TestClassObject(TestClassObject.class);
401         TestClassObject obj2 = new TestClassObject(obj);
402         return obj2.x instanceof TestClassObject;
403     }
404 
405     @SuppressWarnings(&quot;unused&quot;)
406     public static void testNewNodeSnippet() {
407         new ValueAnchorNode(null);
408     }
409 
410     /**
411      * This test makes sure that the allocation of a {@link Node} can be removed. It therefore also
412      * tests the intrinsification of {@link Object#getClass()}.
413      */
414     @Test
415     public void testNewNode() {
<span class="line-modified">416         // Trackking of creation interferes with escape analysis</span>
417         Assume.assumeFalse(Node.TRACK_CREATION_POSITION);



418         testEscapeAnalysis(&quot;testNewNodeSnippet&quot;, null, false);
419     }
420 
421     private static final TestClassObject staticObj = new TestClassObject();
422 
423     public static Object testFullyUnrolledLoopSnippet() {
424         /*
425          * This tests a case that can appear if PEA is performed both before and after loop
426          * unrolling/peeling: If the VirtualInstanceNode is not duplicated correctly with the loop,
427          * the resulting object will reference itself, and not a second (different) object.
428          */
429         TestClassObject obj = staticObj;
430         for (int i = 0; i &lt; 2; i++) {
431             obj = new TestClassObject(obj);
432         }
433         return obj.x;
434     }
435 
436     @Test
437     public void testFullyUnrolledLoop() {
438         prepareGraph(&quot;testFullyUnrolledLoopSnippet&quot;, false);
<span class="line-modified">439         new LoopFullUnrollPhase(new CanonicalizerPhase(), new DefaultLoopPolicies()).apply(graph, context);</span>
<span class="line-modified">440         new PartialEscapePhase(false, new CanonicalizerPhase(), graph.getOptions()).apply(graph, context);</span>
441         Assert.assertEquals(1, returnNodes.size());
442         Assert.assertTrue(returnNodes.get(0).result() instanceof AllocatedObjectNode);
443         CommitAllocationNode commit = ((AllocatedObjectNode) returnNodes.get(0).result()).getCommit();
444         Assert.assertEquals(2, commit.getValues().size());
445         Assert.assertEquals(1, commit.getVirtualObjects().size());
446         Assert.assertTrue(&quot;non-cyclic data structure expected&quot;, commit.getVirtualObjects().get(0) != commit.getValues().get(0));
447     }
448 
449     @SuppressWarnings(&quot;unused&quot;) private static Object staticField;
450 
451     private static TestClassObject inlinedPart(TestClassObject obj) {
452         TestClassObject ret = new TestClassObject(obj);
453         staticField = null;
454         return ret;
455     }
456 
457     public static Object testPeeledLoopSnippet() {
458         TestClassObject obj = staticObj;
459         int i = 0;
460         do {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test.ea;
 26 
 27 import java.util.List;
 28 
 29 import org.graalvm.compiler.graph.Node;
 30 import org.graalvm.compiler.graph.iterators.NodeIterable;
 31 import org.graalvm.compiler.loop.DefaultLoopPolicies;
 32 import org.graalvm.compiler.loop.phases.LoopFullUnrollPhase;
 33 import org.graalvm.compiler.loop.phases.LoopPeelingPhase;
 34 import org.graalvm.compiler.nodes.ConstantNode;
 35 import org.graalvm.compiler.nodes.ReturnNode;
 36 import org.graalvm.compiler.nodes.extended.BoxNode;
 37 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;
 38 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 39 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
 40 import org.graalvm.compiler.nodes.virtual.CommitAllocationNode;

 41 import org.graalvm.compiler.phases.schedule.SchedulePhase;
<span class="line-added"> 42 import org.graalvm.compiler.test.SubprocessUtil;</span>
 43 import org.graalvm.compiler.virtual.phases.ea.PartialEscapePhase;
 44 import org.junit.Assert;
 45 import org.junit.Assume;
 46 import org.junit.Test;
 47 
 48 import jdk.vm.ci.meta.JavaConstant;
 49 
 50 /**
 51  * The PartialEscapeAnalysisPhase is expected to remove all allocations and return the correct
 52  * values.
 53  */
 54 public class EscapeAnalysisTest extends EATestBase {
 55 
 56     @Test
 57     public void test1() {
 58         testEscapeAnalysis(&quot;test1Snippet&quot;, JavaConstant.forInt(101), false);
 59     }
 60 
 61     @SuppressWarnings(&quot;deprecation&quot;)
 62     public static int test1Snippet() {
</pre>
<hr />
<pre>
309             obj = new MyException(one);
310             notInlineable();
311         } else {
312             obj = new MyException(one);
313             notInlineable();
314         }
315         return obj.value &lt;= 3 ? 1 : 0;
316     }
317 
318     /**
319      * Tests that a graph with allocations that does not make progress during PEA will not be
320      * changed.
321      */
322     @Test
323     public void testChangeHandling() {
324         prepareGraph(&quot;testChangeHandlingSnippet&quot;, false);
325         Assert.assertEquals(2, graph.getNodes().filter(CommitAllocationNode.class).count());
326         Assert.assertEquals(1, graph.getNodes().filter(BoxNode.class).count());
327         List&lt;Node&gt; nodes = graph.getNodes().snapshot();
328         // verify that an additional run doesn&#39;t add or remove nodes
<span class="line-modified">329         new PartialEscapePhase(false, false, createCanonicalizerPhase(), null, graph.getOptions()).apply(graph, context);</span>
330         Assert.assertEquals(nodes.size(), graph.getNodeCount());
331         for (Node node : nodes) {
332             Assert.assertTrue(node.isAlive());
333         }
334     }
335 
336     public volatile Object field;
337 
338     @SuppressWarnings(&quot;deprecation&quot;)
339     public int testChangeHandlingSnippet(int a) {
340         Object obj;
341         Integer one = 1;
342         obj = new MyException(one);
343         if (a &lt; 0) {
344             notInlineable();
345         } else {
346             obj = new Integer(1);
347             notInlineable();
348         }
349         field = obj;
350         return 1;
351     }
352 
353     /**
354      * Test the case where allocations before and during a loop that have no usages other than their
355      * phi need to be recognized as an important change. This needs a loop so that the allocation is
356      * not trivially removed by dead code elimination.
357      */
358     @Test
359     public void testRemovalSpecialCase() {
360         prepareGraph(&quot;testRemovalSpecialCaseSnippet&quot;, false);
361         Assert.assertEquals(2, graph.getNodes().filter(CommitAllocationNode.class).count());
362         // create the situation by removing the if
363         graph.replaceFixedWithFloating(graph.getNodes().filter(LoadFieldNode.class).first(), graph.unique(ConstantNode.forInt(0)));
<span class="line-modified">364         createCanonicalizerPhase().apply(graph, context);</span>
365         // verify that an additional run removes all allocations
<span class="line-modified">366         new PartialEscapePhase(false, false, createCanonicalizerPhase(), null, graph.getOptions()).apply(graph, context);</span>
367         Assert.assertEquals(0, graph.getNodes().filter(CommitAllocationNode.class).count());
368     }
369 
370     public volatile int field2;
371 
372     public int testRemovalSpecialCaseSnippet(int a) {
373         Object phi = new Object();
374         for (int i = 0; i &lt; a; i++) {
375             field = null;
376             if (field2 == 1) {
377                 phi = new Object();
378             }
379         }
380         return phi == null ? 1 : 0;
381     }
382 
383     @Test
384     public void testCheckCast() {
385         testEscapeAnalysis(&quot;testCheckCastSnippet&quot;, getSnippetReflection().forObject(TestClassObject.class), true);
386     }
</pre>
<hr />
<pre>
396         testEscapeAnalysis(&quot;testInstanceOfSnippet&quot;, JavaConstant.forInt(1), false);
397     }
398 
399     public boolean testInstanceOfSnippet() {
400         TestClassObject obj = new TestClassObject(TestClassObject.class);
401         TestClassObject obj2 = new TestClassObject(obj);
402         return obj2.x instanceof TestClassObject;
403     }
404 
405     @SuppressWarnings(&quot;unused&quot;)
406     public static void testNewNodeSnippet() {
407         new ValueAnchorNode(null);
408     }
409 
410     /**
411      * This test makes sure that the allocation of a {@link Node} can be removed. It therefore also
412      * tests the intrinsification of {@link Object#getClass()}.
413      */
414     @Test
415     public void testNewNode() {
<span class="line-modified">416         // Tracking of creation interferes with escape analysis</span>
417         Assume.assumeFalse(Node.TRACK_CREATION_POSITION);
<span class="line-added">418         // JaCoco can add escaping allocations (e.g. allocation of coverage recording data</span>
<span class="line-added">419         // structures)</span>
<span class="line-added">420         Assume.assumeFalse(&quot;JaCoCo found -&gt; skipping&quot;, SubprocessUtil.isJaCoCoAttached());</span>
421         testEscapeAnalysis(&quot;testNewNodeSnippet&quot;, null, false);
422     }
423 
424     private static final TestClassObject staticObj = new TestClassObject();
425 
426     public static Object testFullyUnrolledLoopSnippet() {
427         /*
428          * This tests a case that can appear if PEA is performed both before and after loop
429          * unrolling/peeling: If the VirtualInstanceNode is not duplicated correctly with the loop,
430          * the resulting object will reference itself, and not a second (different) object.
431          */
432         TestClassObject obj = staticObj;
433         for (int i = 0; i &lt; 2; i++) {
434             obj = new TestClassObject(obj);
435         }
436         return obj.x;
437     }
438 
439     @Test
440     public void testFullyUnrolledLoop() {
441         prepareGraph(&quot;testFullyUnrolledLoopSnippet&quot;, false);
<span class="line-modified">442         new LoopFullUnrollPhase(createCanonicalizerPhase(), new DefaultLoopPolicies()).apply(graph, context);</span>
<span class="line-modified">443         new PartialEscapePhase(false, createCanonicalizerPhase(), graph.getOptions()).apply(graph, context);</span>
444         Assert.assertEquals(1, returnNodes.size());
445         Assert.assertTrue(returnNodes.get(0).result() instanceof AllocatedObjectNode);
446         CommitAllocationNode commit = ((AllocatedObjectNode) returnNodes.get(0).result()).getCommit();
447         Assert.assertEquals(2, commit.getValues().size());
448         Assert.assertEquals(1, commit.getVirtualObjects().size());
449         Assert.assertTrue(&quot;non-cyclic data structure expected&quot;, commit.getVirtualObjects().get(0) != commit.getValues().get(0));
450     }
451 
452     @SuppressWarnings(&quot;unused&quot;) private static Object staticField;
453 
454     private static TestClassObject inlinedPart(TestClassObject obj) {
455         TestClassObject ret = new TestClassObject(obj);
456         staticField = null;
457         return ret;
458     }
459 
460     public static Object testPeeledLoopSnippet() {
461         TestClassObject obj = staticObj;
462         int i = 0;
463         do {
</pre>
</td>
</tr>
</table>
<center><a href="EarlyReadEliminationTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PEAAssertionsTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
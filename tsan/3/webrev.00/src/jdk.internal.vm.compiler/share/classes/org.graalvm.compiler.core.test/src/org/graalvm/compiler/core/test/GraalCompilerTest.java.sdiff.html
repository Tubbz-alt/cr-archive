<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/GraalCompilerTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FloatingReadTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphEncoderTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/GraalCompilerTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  26 
  27 import static java.lang.reflect.Modifier.isStatic;
  28 import static jdk.vm.ci.runtime.JVMCICompiler.INVOCATION_ENTRY_BCI;
  29 import static org.graalvm.compiler.nodes.ConstantNode.getConstantNodes;
  30 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
  31 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.DO_NOT_INLINE_WITH_EXCEPTION;
  32 
  33 import java.lang.annotation.ElementType;
  34 import java.lang.annotation.Retention;
  35 import java.lang.annotation.RetentionPolicy;
  36 import java.lang.annotation.Target;
  37 import java.lang.reflect.Constructor;
  38 import java.lang.reflect.Executable;
  39 import java.lang.reflect.InvocationTargetException;
  40 import java.lang.reflect.Method;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collection;
  44 import java.util.Collections;
  45 import java.util.EnumMap;

  46 import java.util.List;
  47 import java.util.ListIterator;
  48 import java.util.Map;
  49 import java.util.Set;
  50 import java.util.concurrent.ConcurrentHashMap;
  51 import java.util.function.Supplier;
  52 
  53 import org.graalvm.compiler.api.directives.GraalDirectives;
  54 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  55 import org.graalvm.compiler.api.test.Graal;

  56 import org.graalvm.compiler.code.CompilationResult;
  57 import org.graalvm.compiler.core.CompilationPrinter;
  58 import org.graalvm.compiler.core.GraalCompiler;
  59 import org.graalvm.compiler.core.GraalCompiler.Request;
  60 import org.graalvm.compiler.core.common.CompilationIdentifier;
  61 import org.graalvm.compiler.core.common.type.StampFactory;
  62 import org.graalvm.compiler.core.target.Backend;
  63 import org.graalvm.compiler.debug.DebugContext;
  64 import org.graalvm.compiler.debug.DebugDumpHandler;
<span class="line-removed">  65 import org.graalvm.compiler.debug.DebugDumpScope;</span>
  66 import org.graalvm.compiler.debug.DebugHandlersFactory;
  67 import org.graalvm.compiler.debug.GraalError;
  68 import org.graalvm.compiler.debug.TTY;
  69 import org.graalvm.compiler.graph.Node;
  70 import org.graalvm.compiler.graph.NodeClass;
  71 import org.graalvm.compiler.graph.NodeMap;
  72 import org.graalvm.compiler.java.BytecodeParser;
  73 import org.graalvm.compiler.java.ComputeLoopFrequenciesClosure;
  74 import org.graalvm.compiler.java.GraphBuilderPhase;
  75 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
  76 import org.graalvm.compiler.lir.phases.LIRSuites;

  77 import org.graalvm.compiler.nodeinfo.NodeInfo;
  78 import org.graalvm.compiler.nodeinfo.NodeSize;
  79 import org.graalvm.compiler.nodeinfo.Verbosity;
  80 import org.graalvm.compiler.nodes.BreakpointNode;
  81 import org.graalvm.compiler.nodes.Cancellable;
  82 import org.graalvm.compiler.nodes.ConstantNode;
  83 import org.graalvm.compiler.nodes.FixedWithNextNode;
  84 import org.graalvm.compiler.nodes.FrameState;
  85 import org.graalvm.compiler.nodes.FullInfopointNode;
  86 import org.graalvm.compiler.nodes.Invoke;
  87 import org.graalvm.compiler.nodes.InvokeNode;
  88 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
  89 import org.graalvm.compiler.nodes.ParameterNode;
  90 import org.graalvm.compiler.nodes.ProxyNode;
  91 import org.graalvm.compiler.nodes.ReturnNode;
  92 import org.graalvm.compiler.nodes.StructuredGraph;
  93 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
  94 import org.graalvm.compiler.nodes.StructuredGraph.Builder;
  95 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
  96 import org.graalvm.compiler.nodes.ValueNode;
  97 import org.graalvm.compiler.nodes.cfg.Block;
  98 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
  99 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 100 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 101 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 102 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 103 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 104 import org.graalvm.compiler.nodes.java.AccessFieldNode;
 105 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 106 import org.graalvm.compiler.nodes.spi.Replacements;
 107 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 108 import org.graalvm.compiler.options.OptionValues;
 109 import org.graalvm.compiler.phases.BasePhase;
 110 import org.graalvm.compiler.phases.OptimisticOptimizations;
 111 import org.graalvm.compiler.phases.Phase;
 112 import org.graalvm.compiler.phases.PhaseSuite;
 113 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
<span class="line-removed"> 114 import org.graalvm.compiler.loop.phases.ConvertDeoptimizeToGuardPhase;</span>
 115 import org.graalvm.compiler.phases.common.inlining.InliningPhase;
 116 import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
 117 import org.graalvm.compiler.phases.common.inlining.policy.GreedyInliningPolicy;
 118 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 119 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
 120 import org.graalvm.compiler.phases.tiers.HighTierContext;
 121 import org.graalvm.compiler.phases.tiers.MidTierContext;
 122 import org.graalvm.compiler.phases.tiers.Suites;
 123 import org.graalvm.compiler.phases.tiers.TargetProvider;
 124 import org.graalvm.compiler.phases.util.Providers;
 125 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
 126 import org.graalvm.compiler.runtime.RuntimeProvider;
 127 import org.graalvm.compiler.test.AddExports;
 128 import org.graalvm.compiler.test.GraalTest;
<span class="line-removed"> 129 import org.graalvm.compiler.test.JLModule;</span>
 130 import org.junit.After;
 131 import org.junit.Assert;

 132 import org.junit.Test;
 133 import org.junit.internal.AssumptionViolatedException;
 134 
 135 import jdk.vm.ci.code.Architecture;
 136 import jdk.vm.ci.code.BailoutException;
 137 import jdk.vm.ci.code.CodeCacheProvider;
 138 import jdk.vm.ci.code.InstalledCode;
 139 import jdk.vm.ci.code.TargetDescription;
 140 import jdk.vm.ci.meta.Assumptions.Assumption;
 141 import jdk.vm.ci.meta.ConstantReflectionProvider;
 142 import jdk.vm.ci.meta.DeoptimizationReason;
 143 import jdk.vm.ci.meta.JavaConstant;
 144 import jdk.vm.ci.meta.JavaKind;
 145 import jdk.vm.ci.meta.JavaType;
 146 import jdk.vm.ci.meta.MetaAccessProvider;
 147 import jdk.vm.ci.meta.ProfilingInfo;
 148 import jdk.vm.ci.meta.ResolvedJavaMethod;
 149 import jdk.vm.ci.meta.ResolvedJavaType;
 150 import jdk.vm.ci.meta.SpeculationLog;
 151 
 152 /**
<span class="line-modified"> 153  * Base class for Graal compiler unit tests.</span>
 154  * &lt;p&gt;
<span class="line-modified"> 155  * White box tests for Graal compiler transformations use this pattern:</span>
 156  * &lt;ol&gt;
 157  * &lt;li&gt;Create a graph by {@linkplain #parseEager parsing} a method.&lt;/li&gt;
 158  * &lt;li&gt;Manually modify the graph (e.g. replace a parameter node with a constant).&lt;/li&gt;
 159  * &lt;li&gt;Apply a transformation to the graph.&lt;/li&gt;
 160  * &lt;li&gt;Assert that the transformed graph is equal to an expected graph.&lt;/li&gt;
 161  * &lt;/ol&gt;
 162  * &lt;p&gt;
 163  * See {@link InvokeHintsTest} as an example of a white box test.
 164  * &lt;p&gt;
 165  * Black box tests use the {@link #test(String, Object...)} or
 166  * {@link #testN(int, String, Object...)} to execute some method in the interpreter and compare its
 167  * result against that produced by a Graal compiled version of the method.
 168  * &lt;p&gt;
 169  * These tests will be run by the {@code mx unittest} command.
 170  */
 171 @AddExports({&quot;java.base/jdk.internal.org.objectweb.asm&quot;, &quot;java.base/jdk.internal.org.objectweb.asm.tree&quot;})
 172 public abstract class GraalCompilerTest extends GraalTest {
 173 
 174     /**
 175      * Gets the initial option values provided by the Graal runtime. These are option values
</pre>
<hr />
<pre>
 177      */
 178     public static OptionValues getInitialOptions() {
 179         return Graal.getRequiredCapability(OptionValues.class);
 180     }
 181 
 182     private static final int BAILOUT_RETRY_LIMIT = 1;
 183     private final Providers providers;
 184     private final Backend backend;
 185 
 186     /**
 187      * Representative class for the {@code java.base} module.
 188      */
 189     public static final Class&lt;?&gt; JAVA_BASE = Class.class;
 190 
 191     /**
 192      * Exports the package named {@code packageName} declared in {@code moduleMember}&#39;s module to
 193      * this object&#39;s module. This must be called before accessing packages that are no longer public
 194      * as of JDK 9.
 195      */
 196     protected final void exportPackage(Class&lt;?&gt; moduleMember, String packageName) {
<span class="line-modified"> 197         if (!Java8OrEarlier) {</span>
<span class="line-removed"> 198             JLModule.exportPackageTo(moduleMember, packageName, getClass());</span>
<span class="line-removed"> 199         }</span>
 200     }
 201 
 202     /**
 203      * Denotes a test method that must be inlined by the {@link BytecodeParser}.
 204      */
 205     @Target({ElementType.METHOD, ElementType.CONSTRUCTOR})
 206     @Retention(RetentionPolicy.RUNTIME)
 207     public @interface BytecodeParserForceInline {
 208     }
 209 
 210     /**
 211      * Denotes a test method that must never be inlined by the {@link BytecodeParser}.
 212      */
 213     @Retention(RetentionPolicy.RUNTIME)
 214     @Target({ElementType.METHOD, ElementType.CONSTRUCTOR})
 215     public @interface BytecodeParserNeverInline {
 216         /**
 217          * Specifies if the call should be implemented with {@link InvokeWithExceptionNode} instead
 218          * of {@link InvokeNode}.
 219          */
 220         boolean invokeWithException() default false;
 221     }
 222 
 223     /**
 224      * Can be overridden by unit tests to verify properties of the graph.
 225      *
 226      * @param graph the graph at the end of HighTier

 227      */
<span class="line-modified"> 228     protected boolean checkHighTierGraph(StructuredGraph graph) {</span>
<span class="line-removed"> 229         return true;</span>
 230     }
 231 
 232     /**
 233      * Can be overridden by unit tests to verify properties of the graph.
 234      *
 235      * @param graph the graph at the end of MidTier

 236      */
<span class="line-modified"> 237     protected boolean checkMidTierGraph(StructuredGraph graph) {</span>
<span class="line-removed"> 238         return true;</span>
 239     }
 240 
 241     /**
 242      * Can be overridden by unit tests to verify properties of the graph.
 243      *
 244      * @param graph the graph at the end of LowTier

 245      */
<span class="line-modified"> 246     protected boolean checkLowTierGraph(StructuredGraph graph) {</span>
<span class="line-removed"> 247         return true;</span>
 248     }
 249 
 250     protected static void breakpoint() {
 251     }
 252 
 253     @SuppressWarnings(&quot;unused&quot;)
 254     protected static void breakpoint(int arg0) {
 255     }
 256 
 257     protected static void shouldBeOptimizedAway() {
 258     }
 259 
 260     protected Suites createSuites(OptionValues opts) {
 261         Suites ret = backend.getSuites().getDefaultSuites(opts).copy();
 262         ListIterator&lt;BasePhase&lt;? super HighTierContext&gt;&gt; iter = ret.getHighTier().findPhase(ConvertDeoptimizeToGuardPhase.class, true);
 263         if (iter == null) {
 264             /*
 265              * in the economy configuration, we don&#39;t have the ConvertDeoptimizeToGuard phase, so we
 266              * just select the first CanonicalizerPhase in HighTier
 267              */
</pre>
<hr />
<pre>
 271 
 272             @Override
 273             protected void run(StructuredGraph graph) {
 274                 ComputeLoopFrequenciesClosure.compute(graph);
 275             }
 276 
 277             @Override
 278             public float codeSizeIncrease() {
 279                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
 280             }
 281 
 282             @Override
 283             protected CharSequence getName() {
 284                 return &quot;ComputeLoopFrequenciesPhase&quot;;
 285             }
 286         });
 287         ret.getHighTier().appendPhase(new Phase() {
 288 
 289             @Override
 290             protected void run(StructuredGraph graph) {
<span class="line-modified"> 291                 assert checkHighTierGraph(graph) : &quot;failed HighTier graph check&quot;;</span>
 292             }
 293 
 294             @Override
 295             public float codeSizeIncrease() {
 296                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
 297             }
 298 
 299             @Override
 300             protected CharSequence getName() {
 301                 return &quot;CheckGraphPhase&quot;;
 302             }
 303         });
 304         ret.getMidTier().appendPhase(new Phase() {
 305 
 306             @Override
 307             protected void run(StructuredGraph graph) {
<span class="line-modified"> 308                 assert checkMidTierGraph(graph) : &quot;failed MidTier graph check&quot;;</span>
 309             }
 310 
 311             @Override
 312             public float codeSizeIncrease() {
 313                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
 314             }
 315 
 316             @Override
 317             protected CharSequence getName() {
 318                 return &quot;CheckGraphPhase&quot;;
 319             }
 320         });
 321         ret.getLowTier().appendPhase(new Phase() {
 322 
 323             @Override
 324             protected void run(StructuredGraph graph) {
<span class="line-modified"> 325                 assert checkLowTierGraph(graph) : &quot;failed LowTier graph check&quot;;</span>
 326             }
 327 
 328             @Override
 329             public float codeSizeIncrease() {
 330                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
 331             }
 332 
 333             @Override
 334             protected CharSequence getName() {
 335                 return &quot;CheckGraphPhase&quot;;
 336             }
 337         });
 338         return ret;
 339     }
 340 
 341     protected LIRSuites createLIRSuites(OptionValues opts) {
 342         LIRSuites ret = backend.getSuites().getDefaultLIRSuites(opts).copy();
 343         return ret;
 344     }
 345 







 346     public GraalCompilerTest() {
 347         this.backend = Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend();
 348         this.providers = getBackend().getProviders();
 349     }
 350 
 351     /**
 352      * Set up a test for a non-default backend. The test should check (via {@link #getBackend()} )
 353      * whether the desired backend is available.
 354      *
 355      * @param arch the name of the desired backend architecture
 356      */
 357     public GraalCompilerTest(Class&lt;? extends Architecture&gt; arch) {
 358         RuntimeProvider runtime = Graal.getRequiredCapability(RuntimeProvider.class);
 359         Backend b = runtime.getBackend(arch);
 360         if (b != null) {
 361             this.backend = b;
 362         } else {
 363             // Fall back to the default/host backend
 364             this.backend = runtime.getHostBackend();
 365         }
</pre>
<hr />
<pre>
 583             result.append(&quot;-&gt; &quot;);
 584             for (Block succ : block.getSuccessors()) {
 585                 result.append(succ).append(&#39; &#39;);
 586             }
 587             result.append(&#39;\n&#39;);
 588             for (Node node : scheduleResult.getBlockToNodesMap().get(block)) {
 589                 result.append(String.format(&quot;%1S\n&quot;, node));
 590             }
 591         }
 592         return result.toString();
 593     }
 594 
 595     protected Backend getBackend() {
 596         return backend;
 597     }
 598 
 599     protected final Providers getProviders() {
 600         return providers;
 601     }
 602 
<span class="line-modified"> 603     protected HighTierContext getDefaultHighTierContext() {</span>










 604         return new HighTierContext(getProviders(), getDefaultGraphBuilderSuite(), getOptimisticOptimizations());
 605     }
 606 
<span class="line-modified"> 607     protected MidTierContext getDefaultMidTierContext() {</span>
 608         return new MidTierContext(getProviders(), getTargetProvider(), getOptimisticOptimizations(), null);
 609     }
 610 
 611     protected SnippetReflectionProvider getSnippetReflection() {
 612         return Graal.getRequiredCapability(SnippetReflectionProvider.class);
 613     }
 614 
 615     protected TargetDescription getTarget() {
 616         return getTargetProvider().getTarget();
 617     }
 618 
 619     protected TargetProvider getTargetProvider() {
 620         return getBackend();
 621     }
 622 
 623     protected CodeCacheProvider getCodeCache() {
 624         return getProviders().getCodeCache();
 625     }
 626 
 627     protected ConstantReflectionProvider getConstantReflection() {
 628         return getProviders().getConstantReflection();
 629     }
 630 
 631     protected MetaAccessProvider getMetaAccess() {
 632         return getProviders().getMetaAccess();
 633     }
 634 
 635     protected LoweringProvider getLowerer() {
 636         return getProviders().getLowerer();
 637     }
 638 
 639     protected final BasePhase&lt;HighTierContext&gt; createInliningPhase() {
<span class="line-modified"> 640         return createInliningPhase(new CanonicalizerPhase());</span>
 641     }
 642 
 643     protected BasePhase&lt;HighTierContext&gt; createInliningPhase(CanonicalizerPhase canonicalizer) {
 644         return createInliningPhase(null, canonicalizer);
 645     }
 646 
 647     static class GreedyTestInliningPolicy extends GreedyInliningPolicy {
 648         GreedyTestInliningPolicy(Map&lt;Invoke, Double&gt; hints) {
 649             super(hints);
 650         }
 651 
 652         @Override
 653         protected int previousLowLevelGraphSize(InlineInfo info) {
 654             // Ignore previous compiles for tests
 655             return 0;
 656         }
 657     }
 658 
 659     protected BasePhase&lt;HighTierContext&gt; createInliningPhase(Map&lt;Invoke, Double&gt; hints, CanonicalizerPhase canonicalizer) {
 660         return new InliningPhase(new GreedyTestInliningPolicy(hints), canonicalizer);
</pre>
<hr />
<pre>
 905                     ArrayStoreException.class,
 906                     ClassCastException.class,
 907                     NullPointerException.class);
 908 
 909     protected void assertEquals(Result expect, Result actual) {
 910         if (expect.exception != null) {
 911             Assert.assertTrue(&quot;expected &quot; + expect.exception, actual.exception != null);
 912             Assert.assertEquals(&quot;Exception class&quot;, expect.exception.getClass(), actual.exception.getClass());
 913             // C2 can optimize out the stack trace and message in some cases
 914             if (expect.exception.getMessage() != null || !C2_OMIT_STACK_TRACE_IN_FAST_THROW_EXCEPTIONS.contains(expect.exception.getClass())) {
 915                 Assert.assertEquals(&quot;Exception message&quot;, expect.exception.getMessage(), actual.exception.getMessage());
 916             }
 917         } else {
 918             if (actual.exception != null) {
 919                 throw new AssertionError(&quot;expected &quot; + expect.returnValue + &quot; but got an exception&quot;, actual.exception);
 920             }
 921             assertDeepEquals(expect.returnValue, actual.returnValue);
 922         }
 923     }
 924 
<span class="line-removed"> 925     private Map&lt;ResolvedJavaMethod, InstalledCode&gt; cache = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-removed"> 926 </span>
 927     /**
 928      * Gets installed code for a given method, compiling it first if necessary. The graph is parsed
 929      * {@link #parseEager eagerly}.
 930      */
 931     protected final InstalledCode getCode(ResolvedJavaMethod method) {
 932         return getCode(method, null, false, false, getInitialOptions());
 933     }
 934 
 935     protected final InstalledCode getCode(ResolvedJavaMethod method, OptionValues options) {
 936         return getCode(method, null, false, false, options);
 937     }
 938 
 939     /**
 940      * Gets installed code for a given method, compiling it first if necessary.
 941      *
 942      * @param installedCodeOwner the method the compiled code will be associated with when installed
 943      * @param graph the graph to be compiled. If null, a graph will be obtained from
 944      *            {@code installedCodeOwner} via {@link #parseForCompile(ResolvedJavaMethod)}.
 945      */
 946     protected final InstalledCode getCode(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph) {
</pre>
<hr />
<pre>
 958      */
 959     protected final InstalledCode getCode(final ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, boolean forceCompile) {
 960         return getCode(installedCodeOwner, graph, forceCompile, false, graph == null ? getInitialOptions() : graph.getOptions());
 961     }
 962 
 963     /**
 964      * Gets installed code for a given method and graph, compiling it first if necessary.
 965      *
 966      * @param installedCodeOwner the method the compiled code will be associated with when installed
 967      * @param graph the graph to be compiled. If null, a graph will be obtained from
 968      *            {@code installedCodeOwner} via {@link #parseForCompile(ResolvedJavaMethod)}.
 969      * @param forceCompile specifies whether to ignore any previous code cached for the (method,
 970      *            key) pair
 971      * @param installAsDefault specifies whether to install as the default implementation
 972      * @param options the options that will be used in {@link #parseForCompile(ResolvedJavaMethod)}
 973      */
 974     @SuppressWarnings(&quot;try&quot;)
 975     protected InstalledCode getCode(final ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, boolean forceCompile, boolean installAsDefault, OptionValues options) {
 976         boolean useCache = !forceCompile &amp;&amp; getArgumentToBind() == null;
 977         if (useCache &amp;&amp; graph == null) {
<span class="line-modified"> 978             InstalledCode cached = cache.get(installedCodeOwner);</span>
 979             if (cached != null) {
 980                 if (cached.isValid()) {
 981                     return cached;
 982                 }
 983             }
 984         }
 985         // loop for retrying compilation
 986         for (int retry = 0; retry &lt;= BAILOUT_RETRY_LIMIT; retry++) {
 987             final CompilationIdentifier id = getOrCreateCompilationId(installedCodeOwner, graph);
 988 
 989             InstalledCode installedCode = null;
 990             StructuredGraph graphToCompile = graph == null ? parseForCompile(installedCodeOwner, id, options) : graph;
 991             DebugContext debug = graphToCompile.getDebug();
 992 
<span class="line-modified"> 993             try (AllocSpy spy = AllocSpy.open(installedCodeOwner); DebugContext.Scope ds = debug.scope(&quot;Compiling&quot;, new DebugDumpScope(id.toString(CompilationIdentifier.Verbosity.ID), true))) {</span>
 994                 CompilationPrinter printer = CompilationPrinter.begin(options, id, installedCodeOwner, INVOCATION_ENTRY_BCI);
 995                 CompilationResult compResult = compile(installedCodeOwner, graphToCompile, new CompilationResult(graphToCompile.compilationId()), id, options);
 996                 printer.finish(compResult);
 997 
 998                 try (DebugContext.Scope s = debug.scope(&quot;CodeInstall&quot;, getCodeCache(), installedCodeOwner, compResult);
 999                                 DebugContext.Activation a = debug.activate()) {
1000                     try {
1001                         if (installAsDefault) {
1002                             installedCode = addDefaultMethod(debug, installedCodeOwner, compResult);
1003                         } else {
1004                             installedCode = addMethod(debug, installedCodeOwner, compResult);
1005                         }
1006                         if (installedCode == null) {
1007                             throw new GraalError(&quot;Could not install code for &quot; + installedCodeOwner.format(&quot;%H.%n(%p)&quot;));
1008                         }
1009                     } catch (BailoutException e) {
1010                         if (retry &lt; BAILOUT_RETRY_LIMIT &amp;&amp; graph == null &amp;&amp; !e.isPermanent()) {
1011                             // retry (if there is no predefined graph)
1012                             TTY.println(String.format(&quot;Restart compilation %s (%s) due to a non-permanent bailout!&quot;, installedCodeOwner, id));
1013                             continue;
1014                         }
1015                         throw e;
1016                     }
1017                 } catch (Throwable e) {
1018                     throw debug.handle(e);
1019                 }
1020             } catch (Throwable e) {
1021                 throw debug.handle(e);
1022             }
1023 
1024             if (useCache) {
<span class="line-modified">1025                 cache.put(installedCodeOwner, installedCode);</span>
1026             }
1027             return installedCode;
1028         }
1029         throw GraalError.shouldNotReachHere();
1030     }
1031 
1032     /**
1033      * Used to produce a graph for a method about to be compiled by
1034      * {@link #compile(ResolvedJavaMethod, StructuredGraph)} if the second parameter to that method
1035      * is null.
1036      *
1037      * The default implementation in {@link GraalCompilerTest} is to call {@link #parseEager}.
1038      */
1039     protected StructuredGraph parseForCompile(ResolvedJavaMethod method, OptionValues options) {
1040         return parseEager(method, AllowAssumptions.YES, getCompilationId(method), options);
1041     }
1042 
1043     protected final StructuredGraph parseForCompile(ResolvedJavaMethod method, DebugContext debug) {
1044         return parseEager(method, AllowAssumptions.YES, debug);
1045     }
</pre>
<hr />
<pre>
1060      *            be obtained from {@code installedCodeOwner} via
1061      *            {@link #parseForCompile(ResolvedJavaMethod)}.
1062      */
1063     protected final CompilationResult compile(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph) {
1064         OptionValues options = graph == null ? getInitialOptions() : graph.getOptions();
1065         CompilationIdentifier compilationId = getOrCreateCompilationId(installedCodeOwner, graph);
1066         return compile(installedCodeOwner, graph, new CompilationResult(compilationId), compilationId, options);
1067     }
1068 
1069     protected final CompilationResult compile(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, CompilationIdentifier compilationId) {
1070         OptionValues options = graph == null ? getInitialOptions() : graph.getOptions();
1071         return compile(installedCodeOwner, graph, new CompilationResult(compilationId), compilationId, options);
1072     }
1073 
1074     protected final CompilationResult compile(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, OptionValues options) {
1075         assert graph == null || graph.getOptions() == options;
1076         CompilationIdentifier compilationId = getOrCreateCompilationId(installedCodeOwner, graph);
1077         return compile(installedCodeOwner, graph, new CompilationResult(compilationId), compilationId, options);
1078     }
1079 
<span class="line-removed">1080     protected OptimisticOptimizations getOptimisticOptimizations() {</span>
<span class="line-removed">1081         return OptimisticOptimizations.ALL;</span>
<span class="line-removed">1082     }</span>
<span class="line-removed">1083 </span>
1084     /**
1085      * Compiles a given method.
1086      *
1087      * @param installedCodeOwner the method the compiled code will be associated with when installed
1088      * @param graph the graph to be compiled for {@code installedCodeOwner}. If null, a graph will
1089      *            be obtained from {@code installedCodeOwner} via
1090      *            {@link #parseForCompile(ResolvedJavaMethod)}.
1091      * @param compilationId
1092      */
1093     @SuppressWarnings(&quot;try&quot;)
1094     protected CompilationResult compile(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, CompilationResult compilationResult, CompilationIdentifier compilationId, OptionValues options) {
1095         StructuredGraph graphToCompile = graph == null ? parseForCompile(installedCodeOwner, compilationId, options) : graph;
1096         lastCompiledGraph = graphToCompile;
1097         DebugContext debug = graphToCompile.getDebug();
1098         try (DebugContext.Scope s = debug.scope(&quot;Compile&quot;, graphToCompile)) {
1099             assert options != null;
1100             Request&lt;CompilationResult&gt; request = new Request&lt;&gt;(graphToCompile, installedCodeOwner, getProviders(), getBackend(), getDefaultGraphBuilderSuite(), getOptimisticOptimizations(),
1101                             graphToCompile.getProfilingInfo(), createSuites(options), createLIRSuites(options), compilationResult, CompilationResultBuilderFactory.Default, true);
1102             return GraalCompiler.compile(request);
1103         } catch (Throwable e) {
1104             throw debug.handle(e);
1105         }
1106     }
1107 
1108     protected StructuredGraph getFinalGraph(String method) {
1109         return getFinalGraph(getResolvedJavaMethod(method));
1110     }
1111 
1112     protected StructuredGraph getFinalGraph(ResolvedJavaMethod method) {
1113         StructuredGraph graph = parseForCompile(method);
1114         applyFrontEnd(graph);
1115         return graph;
1116     }
1117 







1118     protected void applyFrontEnd(StructuredGraph graph) {
<span class="line-modified">1119         GraalCompiler.emitFrontEnd(getProviders(), getBackend(), graph, getDefaultGraphBuilderSuite(), getOptimisticOptimizations(), graph.getProfilingInfo(), createSuites(graph.getOptions()));</span>





1120     }
1121 
1122     protected StructuredGraph lastCompiledGraph;
1123 
1124     protected SpeculationLog getSpeculationLog() {
1125         return null;
1126     }
1127 
1128     protected InstalledCode addMethod(DebugContext debug, final ResolvedJavaMethod method, final CompilationResult compilationResult) {
1129         return backend.addInstalledCode(debug, method, null, compilationResult);
1130     }
1131 
1132     protected InstalledCode addDefaultMethod(DebugContext debug, final ResolvedJavaMethod method, final CompilationResult compilationResult) {
1133         return backend.createDefaultInstalledCode(debug, method, compilationResult);
1134     }
1135 
1136     private final Map&lt;ResolvedJavaMethod, Executable&gt; methodMap = new ConcurrentHashMap&lt;&gt;();
1137 
1138     /**
1139      * Converts a reflection {@link Method} to a {@link ResolvedJavaMethod}.
</pre>
<hr />
<pre>
1298         ResolvedJavaMethod javaMethod = builder.getMethod();
1299         builder.speculationLog(getSpeculationLog());
1300         if (builder.getCancellable() == null) {
1301             builder.cancellable(getCancellable(javaMethod));
1302         }
1303         assert javaMethod.getAnnotation(Test.class) == null : &quot;shouldn&#39;t parse method with @Test annotation: &quot; + javaMethod;
1304         StructuredGraph graph = builder.build();
1305         DebugContext debug = graph.getDebug();
1306         try (DebugContext.Scope ds = debug.scope(&quot;Parsing&quot;, javaMethod, graph)) {
1307             graphBuilderSuite.apply(graph, getDefaultHighTierContext());
1308             Object[] args = getArgumentToBind();
1309             if (args != null) {
1310                 bindArguments(graph, args);
1311             }
1312             return graph;
1313         } catch (Throwable e) {
1314             throw debug.handle(e);
1315         }
1316     }
1317 


1318     protected void bindArguments(StructuredGraph graph, Object[] argsToBind) {
1319         ResolvedJavaMethod m = graph.method();
1320         Object receiver = isStatic(m.getModifiers()) ? null : this;
1321         Object[] args = argsWithReceiver(receiver, argsToBind);
1322         JavaType[] parameterTypes = m.toParameterTypes();
1323         assert parameterTypes.length == args.length;
1324         for (ParameterNode param : graph.getNodes(ParameterNode.TYPE)) {
<span class="line-modified">1325             JavaConstant c = getSnippetReflection().forBoxed(parameterTypes[param.index()].getJavaKind(), args[param.index()]);</span>
<span class="line-modified">1326             ConstantNode replacement = ConstantNode.forConstant(c, getMetaAccess(), graph);</span>
<span class="line-modified">1327             param.replaceAtUsages(replacement);</span>



1328         }
1329     }
1330 
1331     protected Object[] getArgumentToBind() {
1332         return null;
1333     }
1334 
1335     protected PhaseSuite&lt;HighTierContext&gt; getEagerGraphBuilderSuite() {
1336         return getCustomGraphBuilderSuite(GraphBuilderConfiguration.getDefault(getDefaultGraphBuilderPlugins()).withEagerResolving(true).withUnresolvedIsError(true));
1337     }
1338 
1339     /**
1340      * Gets the cancellable that should be associated with a graph being created by any of the
1341      * {@code parse...()} methods.
1342      *
1343      * @param method the method being parsed into a graph
1344      */
1345     protected Cancellable getCancellable(ResolvedJavaMethod method) {
1346         return null;
1347     }
</pre>
<hr />
<pre>
1483      * case.
1484      *
1485      * @param i the iteration count of the loop
1486      * @param cond the condition of the loop
1487      * @return cond
1488      */
1489     protected static boolean iterationCount(double i, boolean cond) {
1490         return GraalDirectives.injectIterationCount(i, cond);
1491     }
1492 
1493     /**
1494      * Test if the current test runs on the given platform. The name must match the name given in
1495      * the {@link Architecture#getName()}.
1496      *
1497      * @param name The name to test
1498      * @return true if we run on the architecture given by name
1499      */
1500     protected boolean isArchitecture(String name) {
1501         return name.equals(backend.getTarget().arch.getName());
1502     }




1503 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  26 
  27 import static java.lang.reflect.Modifier.isStatic;
  28 import static jdk.vm.ci.runtime.JVMCICompiler.INVOCATION_ENTRY_BCI;
  29 import static org.graalvm.compiler.nodes.ConstantNode.getConstantNodes;
  30 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
  31 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.DO_NOT_INLINE_WITH_EXCEPTION;
  32 
  33 import java.lang.annotation.ElementType;
  34 import java.lang.annotation.Retention;
  35 import java.lang.annotation.RetentionPolicy;
  36 import java.lang.annotation.Target;
  37 import java.lang.reflect.Constructor;
  38 import java.lang.reflect.Executable;
  39 import java.lang.reflect.InvocationTargetException;
  40 import java.lang.reflect.Method;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collection;
  44 import java.util.Collections;
  45 import java.util.EnumMap;
<span class="line-added">  46 import java.util.HashMap;</span>
  47 import java.util.List;
  48 import java.util.ListIterator;
  49 import java.util.Map;
  50 import java.util.Set;
  51 import java.util.concurrent.ConcurrentHashMap;
  52 import java.util.function.Supplier;
  53 
  54 import org.graalvm.compiler.api.directives.GraalDirectives;
  55 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  56 import org.graalvm.compiler.api.test.Graal;
<span class="line-added">  57 import org.graalvm.compiler.api.test.ModuleSupport;</span>
  58 import org.graalvm.compiler.code.CompilationResult;
  59 import org.graalvm.compiler.core.CompilationPrinter;
  60 import org.graalvm.compiler.core.GraalCompiler;
  61 import org.graalvm.compiler.core.GraalCompiler.Request;
  62 import org.graalvm.compiler.core.common.CompilationIdentifier;
  63 import org.graalvm.compiler.core.common.type.StampFactory;
  64 import org.graalvm.compiler.core.target.Backend;
  65 import org.graalvm.compiler.debug.DebugContext;
  66 import org.graalvm.compiler.debug.DebugDumpHandler;

  67 import org.graalvm.compiler.debug.DebugHandlersFactory;
  68 import org.graalvm.compiler.debug.GraalError;
  69 import org.graalvm.compiler.debug.TTY;
  70 import org.graalvm.compiler.graph.Node;
  71 import org.graalvm.compiler.graph.NodeClass;
  72 import org.graalvm.compiler.graph.NodeMap;
  73 import org.graalvm.compiler.java.BytecodeParser;
  74 import org.graalvm.compiler.java.ComputeLoopFrequenciesClosure;
  75 import org.graalvm.compiler.java.GraphBuilderPhase;
  76 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
  77 import org.graalvm.compiler.lir.phases.LIRSuites;
<span class="line-added">  78 import org.graalvm.compiler.loop.phases.ConvertDeoptimizeToGuardPhase;</span>
  79 import org.graalvm.compiler.nodeinfo.NodeInfo;
  80 import org.graalvm.compiler.nodeinfo.NodeSize;
  81 import org.graalvm.compiler.nodeinfo.Verbosity;
  82 import org.graalvm.compiler.nodes.BreakpointNode;
  83 import org.graalvm.compiler.nodes.Cancellable;
  84 import org.graalvm.compiler.nodes.ConstantNode;
  85 import org.graalvm.compiler.nodes.FixedWithNextNode;
  86 import org.graalvm.compiler.nodes.FrameState;
  87 import org.graalvm.compiler.nodes.FullInfopointNode;
  88 import org.graalvm.compiler.nodes.Invoke;
  89 import org.graalvm.compiler.nodes.InvokeNode;
  90 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
  91 import org.graalvm.compiler.nodes.ParameterNode;
  92 import org.graalvm.compiler.nodes.ProxyNode;
  93 import org.graalvm.compiler.nodes.ReturnNode;
  94 import org.graalvm.compiler.nodes.StructuredGraph;
  95 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
  96 import org.graalvm.compiler.nodes.StructuredGraph.Builder;
  97 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
  98 import org.graalvm.compiler.nodes.ValueNode;
  99 import org.graalvm.compiler.nodes.cfg.Block;
 100 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 101 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 102 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 103 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 104 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 105 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 106 import org.graalvm.compiler.nodes.java.AccessFieldNode;
 107 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 108 import org.graalvm.compiler.nodes.spi.Replacements;
 109 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 110 import org.graalvm.compiler.options.OptionValues;
 111 import org.graalvm.compiler.phases.BasePhase;
 112 import org.graalvm.compiler.phases.OptimisticOptimizations;
 113 import org.graalvm.compiler.phases.Phase;
 114 import org.graalvm.compiler.phases.PhaseSuite;
 115 import org.graalvm.compiler.phases.common.CanonicalizerPhase;

 116 import org.graalvm.compiler.phases.common.inlining.InliningPhase;
 117 import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
 118 import org.graalvm.compiler.phases.common.inlining.policy.GreedyInliningPolicy;
 119 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 120 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
 121 import org.graalvm.compiler.phases.tiers.HighTierContext;
 122 import org.graalvm.compiler.phases.tiers.MidTierContext;
 123 import org.graalvm.compiler.phases.tiers.Suites;
 124 import org.graalvm.compiler.phases.tiers.TargetProvider;
 125 import org.graalvm.compiler.phases.util.Providers;
 126 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
 127 import org.graalvm.compiler.runtime.RuntimeProvider;
 128 import org.graalvm.compiler.test.AddExports;
 129 import org.graalvm.compiler.test.GraalTest;

 130 import org.junit.After;
 131 import org.junit.Assert;
<span class="line-added"> 132 import org.junit.BeforeClass;</span>
 133 import org.junit.Test;
 134 import org.junit.internal.AssumptionViolatedException;
 135 
 136 import jdk.vm.ci.code.Architecture;
 137 import jdk.vm.ci.code.BailoutException;
 138 import jdk.vm.ci.code.CodeCacheProvider;
 139 import jdk.vm.ci.code.InstalledCode;
 140 import jdk.vm.ci.code.TargetDescription;
 141 import jdk.vm.ci.meta.Assumptions.Assumption;
 142 import jdk.vm.ci.meta.ConstantReflectionProvider;
 143 import jdk.vm.ci.meta.DeoptimizationReason;
 144 import jdk.vm.ci.meta.JavaConstant;
 145 import jdk.vm.ci.meta.JavaKind;
 146 import jdk.vm.ci.meta.JavaType;
 147 import jdk.vm.ci.meta.MetaAccessProvider;
 148 import jdk.vm.ci.meta.ProfilingInfo;
 149 import jdk.vm.ci.meta.ResolvedJavaMethod;
 150 import jdk.vm.ci.meta.ResolvedJavaType;
 151 import jdk.vm.ci.meta.SpeculationLog;
 152 
 153 /**
<span class="line-modified"> 154  * Base class for compiler unit tests.</span>
 155  * &lt;p&gt;
<span class="line-modified"> 156  * White box tests for compiler transformations use this pattern:</span>
 157  * &lt;ol&gt;
 158  * &lt;li&gt;Create a graph by {@linkplain #parseEager parsing} a method.&lt;/li&gt;
 159  * &lt;li&gt;Manually modify the graph (e.g. replace a parameter node with a constant).&lt;/li&gt;
 160  * &lt;li&gt;Apply a transformation to the graph.&lt;/li&gt;
 161  * &lt;li&gt;Assert that the transformed graph is equal to an expected graph.&lt;/li&gt;
 162  * &lt;/ol&gt;
 163  * &lt;p&gt;
 164  * See {@link InvokeHintsTest} as an example of a white box test.
 165  * &lt;p&gt;
 166  * Black box tests use the {@link #test(String, Object...)} or
 167  * {@link #testN(int, String, Object...)} to execute some method in the interpreter and compare its
 168  * result against that produced by a Graal compiled version of the method.
 169  * &lt;p&gt;
 170  * These tests will be run by the {@code mx unittest} command.
 171  */
 172 @AddExports({&quot;java.base/jdk.internal.org.objectweb.asm&quot;, &quot;java.base/jdk.internal.org.objectweb.asm.tree&quot;})
 173 public abstract class GraalCompilerTest extends GraalTest {
 174 
 175     /**
 176      * Gets the initial option values provided by the Graal runtime. These are option values
</pre>
<hr />
<pre>
 178      */
 179     public static OptionValues getInitialOptions() {
 180         return Graal.getRequiredCapability(OptionValues.class);
 181     }
 182 
 183     private static final int BAILOUT_RETRY_LIMIT = 1;
 184     private final Providers providers;
 185     private final Backend backend;
 186 
 187     /**
 188      * Representative class for the {@code java.base} module.
 189      */
 190     public static final Class&lt;?&gt; JAVA_BASE = Class.class;
 191 
 192     /**
 193      * Exports the package named {@code packageName} declared in {@code moduleMember}&#39;s module to
 194      * this object&#39;s module. This must be called before accessing packages that are no longer public
 195      * as of JDK 9.
 196      */
 197     protected final void exportPackage(Class&lt;?&gt; moduleMember, String packageName) {
<span class="line-modified"> 198         ModuleSupport.exportPackageTo(moduleMember, packageName, getClass());</span>


 199     }
 200 
 201     /**
 202      * Denotes a test method that must be inlined by the {@link BytecodeParser}.
 203      */
 204     @Target({ElementType.METHOD, ElementType.CONSTRUCTOR})
 205     @Retention(RetentionPolicy.RUNTIME)
 206     public @interface BytecodeParserForceInline {
 207     }
 208 
 209     /**
 210      * Denotes a test method that must never be inlined by the {@link BytecodeParser}.
 211      */
 212     @Retention(RetentionPolicy.RUNTIME)
 213     @Target({ElementType.METHOD, ElementType.CONSTRUCTOR})
 214     public @interface BytecodeParserNeverInline {
 215         /**
 216          * Specifies if the call should be implemented with {@link InvokeWithExceptionNode} instead
 217          * of {@link InvokeNode}.
 218          */
 219         boolean invokeWithException() default false;
 220     }
 221 
 222     /**
 223      * Can be overridden by unit tests to verify properties of the graph.
 224      *
 225      * @param graph the graph at the end of HighTier
<span class="line-added"> 226      * @throws AssertionError if the verification fails</span>
 227      */
<span class="line-modified"> 228     protected void checkHighTierGraph(StructuredGraph graph) {</span>

 229     }
 230 
 231     /**
 232      * Can be overridden by unit tests to verify properties of the graph.
 233      *
 234      * @param graph the graph at the end of MidTier
<span class="line-added"> 235      * @throws AssertionError if the verification fails</span>
 236      */
<span class="line-modified"> 237     protected void checkMidTierGraph(StructuredGraph graph) {</span>

 238     }
 239 
 240     /**
 241      * Can be overridden by unit tests to verify properties of the graph.
 242      *
 243      * @param graph the graph at the end of LowTier
<span class="line-added"> 244      * @throws AssertionError if the verification fails</span>
 245      */
<span class="line-modified"> 246     protected void checkLowTierGraph(StructuredGraph graph) {</span>

 247     }
 248 
 249     protected static void breakpoint() {
 250     }
 251 
 252     @SuppressWarnings(&quot;unused&quot;)
 253     protected static void breakpoint(int arg0) {
 254     }
 255 
 256     protected static void shouldBeOptimizedAway() {
 257     }
 258 
 259     protected Suites createSuites(OptionValues opts) {
 260         Suites ret = backend.getSuites().getDefaultSuites(opts).copy();
 261         ListIterator&lt;BasePhase&lt;? super HighTierContext&gt;&gt; iter = ret.getHighTier().findPhase(ConvertDeoptimizeToGuardPhase.class, true);
 262         if (iter == null) {
 263             /*
 264              * in the economy configuration, we don&#39;t have the ConvertDeoptimizeToGuard phase, so we
 265              * just select the first CanonicalizerPhase in HighTier
 266              */
</pre>
<hr />
<pre>
 270 
 271             @Override
 272             protected void run(StructuredGraph graph) {
 273                 ComputeLoopFrequenciesClosure.compute(graph);
 274             }
 275 
 276             @Override
 277             public float codeSizeIncrease() {
 278                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
 279             }
 280 
 281             @Override
 282             protected CharSequence getName() {
 283                 return &quot;ComputeLoopFrequenciesPhase&quot;;
 284             }
 285         });
 286         ret.getHighTier().appendPhase(new Phase() {
 287 
 288             @Override
 289             protected void run(StructuredGraph graph) {
<span class="line-modified"> 290                 checkHighTierGraph(graph);</span>
 291             }
 292 
 293             @Override
 294             public float codeSizeIncrease() {
 295                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
 296             }
 297 
 298             @Override
 299             protected CharSequence getName() {
 300                 return &quot;CheckGraphPhase&quot;;
 301             }
 302         });
 303         ret.getMidTier().appendPhase(new Phase() {
 304 
 305             @Override
 306             protected void run(StructuredGraph graph) {
<span class="line-modified"> 307                 checkMidTierGraph(graph);</span>
 308             }
 309 
 310             @Override
 311             public float codeSizeIncrease() {
 312                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
 313             }
 314 
 315             @Override
 316             protected CharSequence getName() {
 317                 return &quot;CheckGraphPhase&quot;;
 318             }
 319         });
 320         ret.getLowTier().appendPhase(new Phase() {
 321 
 322             @Override
 323             protected void run(StructuredGraph graph) {
<span class="line-modified"> 324                 checkLowTierGraph(graph);</span>
 325             }
 326 
 327             @Override
 328             public float codeSizeIncrease() {
 329                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
 330             }
 331 
 332             @Override
 333             protected CharSequence getName() {
 334                 return &quot;CheckGraphPhase&quot;;
 335             }
 336         });
 337         return ret;
 338     }
 339 
 340     protected LIRSuites createLIRSuites(OptionValues opts) {
 341         LIRSuites ret = backend.getSuites().getDefaultLIRSuites(opts).copy();
 342         return ret;
 343     }
 344 
<span class="line-added"> 345     private static final ThreadLocal&lt;HashMap&lt;ResolvedJavaMethod, InstalledCode&gt;&gt; cache = ThreadLocal.withInitial(HashMap::new);</span>
<span class="line-added"> 346 </span>
<span class="line-added"> 347     @BeforeClass</span>
<span class="line-added"> 348     public static void resetCache() {</span>
<span class="line-added"> 349         cache.get().clear();</span>
<span class="line-added"> 350     }</span>
<span class="line-added"> 351 </span>
 352     public GraalCompilerTest() {
 353         this.backend = Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend();
 354         this.providers = getBackend().getProviders();
 355     }
 356 
 357     /**
 358      * Set up a test for a non-default backend. The test should check (via {@link #getBackend()} )
 359      * whether the desired backend is available.
 360      *
 361      * @param arch the name of the desired backend architecture
 362      */
 363     public GraalCompilerTest(Class&lt;? extends Architecture&gt; arch) {
 364         RuntimeProvider runtime = Graal.getRequiredCapability(RuntimeProvider.class);
 365         Backend b = runtime.getBackend(arch);
 366         if (b != null) {
 367             this.backend = b;
 368         } else {
 369             // Fall back to the default/host backend
 370             this.backend = runtime.getHostBackend();
 371         }
</pre>
<hr />
<pre>
 589             result.append(&quot;-&gt; &quot;);
 590             for (Block succ : block.getSuccessors()) {
 591                 result.append(succ).append(&#39; &#39;);
 592             }
 593             result.append(&#39;\n&#39;);
 594             for (Node node : scheduleResult.getBlockToNodesMap().get(block)) {
 595                 result.append(String.format(&quot;%1S\n&quot;, node));
 596             }
 597         }
 598         return result.toString();
 599     }
 600 
 601     protected Backend getBackend() {
 602         return backend;
 603     }
 604 
 605     protected final Providers getProviders() {
 606         return providers;
 607     }
 608 
<span class="line-modified"> 609     /**</span>
<span class="line-added"> 610      * Override the {@link OptimisticOptimizations} settings used for the test. This is called for</span>
<span class="line-added"> 611      * all the paths where the value is set so it is the proper place for a test override. Setting</span>
<span class="line-added"> 612      * it in other places can result in inconsistent values being used in other parts of the</span>
<span class="line-added"> 613      * compiler.</span>
<span class="line-added"> 614      */</span>
<span class="line-added"> 615     protected OptimisticOptimizations getOptimisticOptimizations() {</span>
<span class="line-added"> 616         return OptimisticOptimizations.ALL;</span>
<span class="line-added"> 617     }</span>
<span class="line-added"> 618 </span>
<span class="line-added"> 619     protected final HighTierContext getDefaultHighTierContext() {</span>
 620         return new HighTierContext(getProviders(), getDefaultGraphBuilderSuite(), getOptimisticOptimizations());
 621     }
 622 
<span class="line-modified"> 623     protected final MidTierContext getDefaultMidTierContext() {</span>
 624         return new MidTierContext(getProviders(), getTargetProvider(), getOptimisticOptimizations(), null);
 625     }
 626 
 627     protected SnippetReflectionProvider getSnippetReflection() {
 628         return Graal.getRequiredCapability(SnippetReflectionProvider.class);
 629     }
 630 
 631     protected TargetDescription getTarget() {
 632         return getTargetProvider().getTarget();
 633     }
 634 
 635     protected TargetProvider getTargetProvider() {
 636         return getBackend();
 637     }
 638 
 639     protected CodeCacheProvider getCodeCache() {
 640         return getProviders().getCodeCache();
 641     }
 642 
 643     protected ConstantReflectionProvider getConstantReflection() {
 644         return getProviders().getConstantReflection();
 645     }
 646 
 647     protected MetaAccessProvider getMetaAccess() {
 648         return getProviders().getMetaAccess();
 649     }
 650 
 651     protected LoweringProvider getLowerer() {
 652         return getProviders().getLowerer();
 653     }
 654 
 655     protected final BasePhase&lt;HighTierContext&gt; createInliningPhase() {
<span class="line-modified"> 656         return createInliningPhase(this.createCanonicalizerPhase());</span>
 657     }
 658 
 659     protected BasePhase&lt;HighTierContext&gt; createInliningPhase(CanonicalizerPhase canonicalizer) {
 660         return createInliningPhase(null, canonicalizer);
 661     }
 662 
 663     static class GreedyTestInliningPolicy extends GreedyInliningPolicy {
 664         GreedyTestInliningPolicy(Map&lt;Invoke, Double&gt; hints) {
 665             super(hints);
 666         }
 667 
 668         @Override
 669         protected int previousLowLevelGraphSize(InlineInfo info) {
 670             // Ignore previous compiles for tests
 671             return 0;
 672         }
 673     }
 674 
 675     protected BasePhase&lt;HighTierContext&gt; createInliningPhase(Map&lt;Invoke, Double&gt; hints, CanonicalizerPhase canonicalizer) {
 676         return new InliningPhase(new GreedyTestInliningPolicy(hints), canonicalizer);
</pre>
<hr />
<pre>
 921                     ArrayStoreException.class,
 922                     ClassCastException.class,
 923                     NullPointerException.class);
 924 
 925     protected void assertEquals(Result expect, Result actual) {
 926         if (expect.exception != null) {
 927             Assert.assertTrue(&quot;expected &quot; + expect.exception, actual.exception != null);
 928             Assert.assertEquals(&quot;Exception class&quot;, expect.exception.getClass(), actual.exception.getClass());
 929             // C2 can optimize out the stack trace and message in some cases
 930             if (expect.exception.getMessage() != null || !C2_OMIT_STACK_TRACE_IN_FAST_THROW_EXCEPTIONS.contains(expect.exception.getClass())) {
 931                 Assert.assertEquals(&quot;Exception message&quot;, expect.exception.getMessage(), actual.exception.getMessage());
 932             }
 933         } else {
 934             if (actual.exception != null) {
 935                 throw new AssertionError(&quot;expected &quot; + expect.returnValue + &quot; but got an exception&quot;, actual.exception);
 936             }
 937             assertDeepEquals(expect.returnValue, actual.returnValue);
 938         }
 939     }
 940 


 941     /**
 942      * Gets installed code for a given method, compiling it first if necessary. The graph is parsed
 943      * {@link #parseEager eagerly}.
 944      */
 945     protected final InstalledCode getCode(ResolvedJavaMethod method) {
 946         return getCode(method, null, false, false, getInitialOptions());
 947     }
 948 
 949     protected final InstalledCode getCode(ResolvedJavaMethod method, OptionValues options) {
 950         return getCode(method, null, false, false, options);
 951     }
 952 
 953     /**
 954      * Gets installed code for a given method, compiling it first if necessary.
 955      *
 956      * @param installedCodeOwner the method the compiled code will be associated with when installed
 957      * @param graph the graph to be compiled. If null, a graph will be obtained from
 958      *            {@code installedCodeOwner} via {@link #parseForCompile(ResolvedJavaMethod)}.
 959      */
 960     protected final InstalledCode getCode(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph) {
</pre>
<hr />
<pre>
 972      */
 973     protected final InstalledCode getCode(final ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, boolean forceCompile) {
 974         return getCode(installedCodeOwner, graph, forceCompile, false, graph == null ? getInitialOptions() : graph.getOptions());
 975     }
 976 
 977     /**
 978      * Gets installed code for a given method and graph, compiling it first if necessary.
 979      *
 980      * @param installedCodeOwner the method the compiled code will be associated with when installed
 981      * @param graph the graph to be compiled. If null, a graph will be obtained from
 982      *            {@code installedCodeOwner} via {@link #parseForCompile(ResolvedJavaMethod)}.
 983      * @param forceCompile specifies whether to ignore any previous code cached for the (method,
 984      *            key) pair
 985      * @param installAsDefault specifies whether to install as the default implementation
 986      * @param options the options that will be used in {@link #parseForCompile(ResolvedJavaMethod)}
 987      */
 988     @SuppressWarnings(&quot;try&quot;)
 989     protected InstalledCode getCode(final ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, boolean forceCompile, boolean installAsDefault, OptionValues options) {
 990         boolean useCache = !forceCompile &amp;&amp; getArgumentToBind() == null;
 991         if (useCache &amp;&amp; graph == null) {
<span class="line-modified"> 992             InstalledCode cached = cache.get().get(installedCodeOwner);</span>
 993             if (cached != null) {
 994                 if (cached.isValid()) {
 995                     return cached;
 996                 }
 997             }
 998         }
 999         // loop for retrying compilation
1000         for (int retry = 0; retry &lt;= BAILOUT_RETRY_LIMIT; retry++) {
1001             final CompilationIdentifier id = getOrCreateCompilationId(installedCodeOwner, graph);
1002 
1003             InstalledCode installedCode = null;
1004             StructuredGraph graphToCompile = graph == null ? parseForCompile(installedCodeOwner, id, options) : graph;
1005             DebugContext debug = graphToCompile.getDebug();
1006 
<span class="line-modified">1007             try (AllocSpy spy = AllocSpy.open(installedCodeOwner); DebugContext.Scope ds = debug.scope(&quot;Compiling&quot;, graph)) {</span>
1008                 CompilationPrinter printer = CompilationPrinter.begin(options, id, installedCodeOwner, INVOCATION_ENTRY_BCI);
1009                 CompilationResult compResult = compile(installedCodeOwner, graphToCompile, new CompilationResult(graphToCompile.compilationId()), id, options);
1010                 printer.finish(compResult);
1011 
1012                 try (DebugContext.Scope s = debug.scope(&quot;CodeInstall&quot;, getCodeCache(), installedCodeOwner, compResult);
1013                                 DebugContext.Activation a = debug.activate()) {
1014                     try {
1015                         if (installAsDefault) {
1016                             installedCode = addDefaultMethod(debug, installedCodeOwner, compResult);
1017                         } else {
1018                             installedCode = addMethod(debug, installedCodeOwner, compResult);
1019                         }
1020                         if (installedCode == null) {
1021                             throw new GraalError(&quot;Could not install code for &quot; + installedCodeOwner.format(&quot;%H.%n(%p)&quot;));
1022                         }
1023                     } catch (BailoutException e) {
1024                         if (retry &lt; BAILOUT_RETRY_LIMIT &amp;&amp; graph == null &amp;&amp; !e.isPermanent()) {
1025                             // retry (if there is no predefined graph)
1026                             TTY.println(String.format(&quot;Restart compilation %s (%s) due to a non-permanent bailout!&quot;, installedCodeOwner, id));
1027                             continue;
1028                         }
1029                         throw e;
1030                     }
1031                 } catch (Throwable e) {
1032                     throw debug.handle(e);
1033                 }
1034             } catch (Throwable e) {
1035                 throw debug.handle(e);
1036             }
1037 
1038             if (useCache) {
<span class="line-modified">1039                 cache.get().put(installedCodeOwner, installedCode);</span>
1040             }
1041             return installedCode;
1042         }
1043         throw GraalError.shouldNotReachHere();
1044     }
1045 
1046     /**
1047      * Used to produce a graph for a method about to be compiled by
1048      * {@link #compile(ResolvedJavaMethod, StructuredGraph)} if the second parameter to that method
1049      * is null.
1050      *
1051      * The default implementation in {@link GraalCompilerTest} is to call {@link #parseEager}.
1052      */
1053     protected StructuredGraph parseForCompile(ResolvedJavaMethod method, OptionValues options) {
1054         return parseEager(method, AllowAssumptions.YES, getCompilationId(method), options);
1055     }
1056 
1057     protected final StructuredGraph parseForCompile(ResolvedJavaMethod method, DebugContext debug) {
1058         return parseEager(method, AllowAssumptions.YES, debug);
1059     }
</pre>
<hr />
<pre>
1074      *            be obtained from {@code installedCodeOwner} via
1075      *            {@link #parseForCompile(ResolvedJavaMethod)}.
1076      */
1077     protected final CompilationResult compile(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph) {
1078         OptionValues options = graph == null ? getInitialOptions() : graph.getOptions();
1079         CompilationIdentifier compilationId = getOrCreateCompilationId(installedCodeOwner, graph);
1080         return compile(installedCodeOwner, graph, new CompilationResult(compilationId), compilationId, options);
1081     }
1082 
1083     protected final CompilationResult compile(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, CompilationIdentifier compilationId) {
1084         OptionValues options = graph == null ? getInitialOptions() : graph.getOptions();
1085         return compile(installedCodeOwner, graph, new CompilationResult(compilationId), compilationId, options);
1086     }
1087 
1088     protected final CompilationResult compile(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, OptionValues options) {
1089         assert graph == null || graph.getOptions() == options;
1090         CompilationIdentifier compilationId = getOrCreateCompilationId(installedCodeOwner, graph);
1091         return compile(installedCodeOwner, graph, new CompilationResult(compilationId), compilationId, options);
1092     }
1093 




1094     /**
1095      * Compiles a given method.
1096      *
1097      * @param installedCodeOwner the method the compiled code will be associated with when installed
1098      * @param graph the graph to be compiled for {@code installedCodeOwner}. If null, a graph will
1099      *            be obtained from {@code installedCodeOwner} via
1100      *            {@link #parseForCompile(ResolvedJavaMethod)}.
1101      * @param compilationId
1102      */
1103     @SuppressWarnings(&quot;try&quot;)
1104     protected CompilationResult compile(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, CompilationResult compilationResult, CompilationIdentifier compilationId, OptionValues options) {
1105         StructuredGraph graphToCompile = graph == null ? parseForCompile(installedCodeOwner, compilationId, options) : graph;
1106         lastCompiledGraph = graphToCompile;
1107         DebugContext debug = graphToCompile.getDebug();
1108         try (DebugContext.Scope s = debug.scope(&quot;Compile&quot;, graphToCompile)) {
1109             assert options != null;
1110             Request&lt;CompilationResult&gt; request = new Request&lt;&gt;(graphToCompile, installedCodeOwner, getProviders(), getBackend(), getDefaultGraphBuilderSuite(), getOptimisticOptimizations(),
1111                             graphToCompile.getProfilingInfo(), createSuites(options), createLIRSuites(options), compilationResult, CompilationResultBuilderFactory.Default, true);
1112             return GraalCompiler.compile(request);
1113         } catch (Throwable e) {
1114             throw debug.handle(e);
1115         }
1116     }
1117 
1118     protected StructuredGraph getFinalGraph(String method) {
1119         return getFinalGraph(getResolvedJavaMethod(method));
1120     }
1121 
1122     protected StructuredGraph getFinalGraph(ResolvedJavaMethod method) {
1123         StructuredGraph graph = parseForCompile(method);
1124         applyFrontEnd(graph);
1125         return graph;
1126     }
1127 
<span class="line-added">1128     protected StructuredGraph getFinalGraph(ResolvedJavaMethod method, OptionValues options) {</span>
<span class="line-added">1129         StructuredGraph graph = parseForCompile(method, options);</span>
<span class="line-added">1130         applyFrontEnd(graph);</span>
<span class="line-added">1131         return graph;</span>
<span class="line-added">1132     }</span>
<span class="line-added">1133 </span>
<span class="line-added">1134     @SuppressWarnings(&quot;try&quot;)</span>
1135     protected void applyFrontEnd(StructuredGraph graph) {
<span class="line-modified">1136         DebugContext debug = graph.getDebug();</span>
<span class="line-added">1137         try (DebugContext.Scope s = debug.scope(&quot;FrontEnd&quot;, graph)) {</span>
<span class="line-added">1138             GraalCompiler.emitFrontEnd(getProviders(), getBackend(), graph, getDefaultGraphBuilderSuite(), getOptimisticOptimizations(), graph.getProfilingInfo(), createSuites(graph.getOptions()));</span>
<span class="line-added">1139         } catch (Throwable e) {</span>
<span class="line-added">1140             throw debug.handle(e);</span>
<span class="line-added">1141         }</span>
1142     }
1143 
1144     protected StructuredGraph lastCompiledGraph;
1145 
1146     protected SpeculationLog getSpeculationLog() {
1147         return null;
1148     }
1149 
1150     protected InstalledCode addMethod(DebugContext debug, final ResolvedJavaMethod method, final CompilationResult compilationResult) {
1151         return backend.addInstalledCode(debug, method, null, compilationResult);
1152     }
1153 
1154     protected InstalledCode addDefaultMethod(DebugContext debug, final ResolvedJavaMethod method, final CompilationResult compilationResult) {
1155         return backend.createDefaultInstalledCode(debug, method, compilationResult);
1156     }
1157 
1158     private final Map&lt;ResolvedJavaMethod, Executable&gt; methodMap = new ConcurrentHashMap&lt;&gt;();
1159 
1160     /**
1161      * Converts a reflection {@link Method} to a {@link ResolvedJavaMethod}.
</pre>
<hr />
<pre>
1320         ResolvedJavaMethod javaMethod = builder.getMethod();
1321         builder.speculationLog(getSpeculationLog());
1322         if (builder.getCancellable() == null) {
1323             builder.cancellable(getCancellable(javaMethod));
1324         }
1325         assert javaMethod.getAnnotation(Test.class) == null : &quot;shouldn&#39;t parse method with @Test annotation: &quot; + javaMethod;
1326         StructuredGraph graph = builder.build();
1327         DebugContext debug = graph.getDebug();
1328         try (DebugContext.Scope ds = debug.scope(&quot;Parsing&quot;, javaMethod, graph)) {
1329             graphBuilderSuite.apply(graph, getDefaultHighTierContext());
1330             Object[] args = getArgumentToBind();
1331             if (args != null) {
1332                 bindArguments(graph, args);
1333             }
1334             return graph;
1335         } catch (Throwable e) {
1336             throw debug.handle(e);
1337         }
1338     }
1339 
<span class="line-added">1340     protected static final Object NO_BIND = new Object();</span>
<span class="line-added">1341 </span>
1342     protected void bindArguments(StructuredGraph graph, Object[] argsToBind) {
1343         ResolvedJavaMethod m = graph.method();
1344         Object receiver = isStatic(m.getModifiers()) ? null : this;
1345         Object[] args = argsWithReceiver(receiver, argsToBind);
1346         JavaType[] parameterTypes = m.toParameterTypes();
1347         assert parameterTypes.length == args.length;
1348         for (ParameterNode param : graph.getNodes(ParameterNode.TYPE)) {
<span class="line-modified">1349             Object arg = args[param.index()];</span>
<span class="line-modified">1350             if (arg != NO_BIND) {</span>
<span class="line-modified">1351                 JavaConstant c = getSnippetReflection().forBoxed(parameterTypes[param.index()].getJavaKind(), arg);</span>
<span class="line-added">1352                 ConstantNode replacement = ConstantNode.forConstant(c, getMetaAccess(), graph);</span>
<span class="line-added">1353                 param.replaceAtUsages(replacement);</span>
<span class="line-added">1354             }</span>
1355         }
1356     }
1357 
1358     protected Object[] getArgumentToBind() {
1359         return null;
1360     }
1361 
1362     protected PhaseSuite&lt;HighTierContext&gt; getEagerGraphBuilderSuite() {
1363         return getCustomGraphBuilderSuite(GraphBuilderConfiguration.getDefault(getDefaultGraphBuilderPlugins()).withEagerResolving(true).withUnresolvedIsError(true));
1364     }
1365 
1366     /**
1367      * Gets the cancellable that should be associated with a graph being created by any of the
1368      * {@code parse...()} methods.
1369      *
1370      * @param method the method being parsed into a graph
1371      */
1372     protected Cancellable getCancellable(ResolvedJavaMethod method) {
1373         return null;
1374     }
</pre>
<hr />
<pre>
1510      * case.
1511      *
1512      * @param i the iteration count of the loop
1513      * @param cond the condition of the loop
1514      * @return cond
1515      */
1516     protected static boolean iterationCount(double i, boolean cond) {
1517         return GraalDirectives.injectIterationCount(i, cond);
1518     }
1519 
1520     /**
1521      * Test if the current test runs on the given platform. The name must match the name given in
1522      * the {@link Architecture#getName()}.
1523      *
1524      * @param name The name to test
1525      * @return true if we run on the architecture given by name
1526      */
1527     protected boolean isArchitecture(String name) {
1528         return name.equals(backend.getTarget().arch.getName());
1529     }
<span class="line-added">1530 </span>
<span class="line-added">1531     protected CanonicalizerPhase createCanonicalizerPhase() {</span>
<span class="line-added">1532         return CanonicalizerPhase.create();</span>
<span class="line-added">1533     }</span>
1534 }
</pre>
</td>
</tr>
</table>
<center><a href="FloatingReadTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphEncoderTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
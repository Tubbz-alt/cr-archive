<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/CompareCanonicalizerTest3.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import org.graalvm.compiler.nodes.StructuredGraph;
 28 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 29 import org.graalvm.compiler.nodes.ValueNode;
 30 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 31 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
<a name="2" id="anc2"></a>
 32 import org.graalvm.compiler.phases.OptimisticOptimizations;
 33 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 34 import org.graalvm.compiler.phases.common.FrameStateAssignmentPhase;
 35 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 36 import org.graalvm.compiler.phases.tiers.MidTierContext;
<a name="3" id="anc3"></a><span class="line-removed"> 37 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 38 import org.junit.Ignore;
 39 import org.junit.Test;
 40 
 41 import jdk.vm.ci.meta.ResolvedJavaMethod;
 42 
 43 public class CompareCanonicalizerTest3 extends GraalCompilerTest {
 44 
 45     @SuppressWarnings(&quot;unused&quot;) private static int sink0;
 46     @SuppressWarnings(&quot;unused&quot;) private static int sink1;
 47 
 48     @Ignore(&quot;Subword input cannot be trusted.&quot;)
 49     @Test
 50     public void test00() {
 51         assertCanonicallyEqual(&quot;integerTestCanonicalization00&quot;, &quot;referenceSnippet00&quot;);
 52     }
 53 
 54     public static void integerTestCanonicalization00(char a) {
 55         if (a - 1 &lt; a) {
 56             sink1 = 0;
 57         } else {
 58             sink0 = -1;
 59         }
 60     }
 61 
 62     @SuppressWarnings(&quot;unused&quot;)
 63     public static void referenceSnippet00(char a) {
 64         sink1 = 0;
 65     }
 66 
 67     @Ignore(&quot;Needs better stamp support for unsigned ranges&quot;)
 68     @Test
 69     public void test01() {
 70         assertCanonicallyEqual(&quot;integerTestCanonicalization01&quot;, &quot;referenceSnippet01&quot;);
 71     }
 72 
 73     public static void integerTestCanonicalization01(char a) {
 74         if (Integer.compareUnsigned(a - 1, a) &lt; 0) {
 75             sink1 = 0;
 76         } else {
 77             sink0 = -1;
 78         }
 79     }
 80 
 81     public static void referenceSnippet01(char a) {
 82         if (a != 0) {
 83             sink1 = 0;
 84         } else {
 85             sink0 = -1;
 86         }
 87     }
 88 
 89     @Ignore(&quot;Needs better stamp support for unsigned ranges&quot;)
 90     @Test
 91     public void test1() {
 92         assertCanonicallyEqual(&quot;integerTestCanonicalization1&quot;, &quot;referenceSnippet1&quot;);
 93     }
 94 
 95     public static void integerTestCanonicalization1(char[] a) {
 96         int len = a.length;
 97         if (Integer.compareUnsigned(len - 2, len) &lt; 0) {
 98             sink1 = 0;
 99         } else {
100             sink0 = -1;
101         }
102     }
103 
104     public static void referenceSnippet1(char[] a) {
105         int len = a.length;
106         if (Integer.compareUnsigned(len, 2) &gt;= 0) {
107             sink1 = 0;
108         } else {
109             sink0 = -1;
110         }
111     }
112 
113     @Test
114     public void test2() {
115         assertCanonicallyEqual(&quot;integerTestCanonicalization2&quot;, &quot;referenceSnippet2&quot;);
116     }
117 
118     public static void integerTestCanonicalization2(int a) {
119         if (a - 1 &lt; a) {
120             sink1 = 0;
121         } else {
122             sink0 = -1;
123         }
124     }
125 
126     public static void referenceSnippet2(int a) {
127         if (a != Integer.MIN_VALUE) {
128             sink1 = 0;
129         } else {
130             sink0 = -1;
131         }
132     }
133 
134     @Test
135     public void test3() {
136         assertCanonicallyEqual(&quot;integerTestCanonicalization3&quot;, &quot;referenceSnippet3&quot;);
137     }
138 
139     public static void integerTestCanonicalization3(int a) {
140         if (a - 2 &lt; a) {
141             sink1 = 0;
142         } else {
143             sink0 = -1;
144         }
145     }
146 
147     public static void referenceSnippet3(int a) {
148         if (a &gt;= Integer.MIN_VALUE + 2) {
149             sink1 = 0;
150         } else {
151             sink0 = -1;
152         }
153     }
154 
155     @Test
156     public void test4() {
157         assertCanonicallyEqual(&quot;integerTestCanonicalization4&quot;, &quot;referenceSnippet4&quot;);
158     }
159 
160     public static void integerTestCanonicalization4(int a) {
161         if (a + 1 &lt; a) {
162             sink1 = 0;
163         } else {
164             sink0 = -1;
165         }
166     }
167 
168     public static void referenceSnippet4(int a) {
169         if (a == Integer.MAX_VALUE) {
170             sink1 = 0;
171         } else {
172             sink0 = -1;
173         }
174     }
175 
176     @Test
177     public void test5() {
178         assertCanonicallyEqual(&quot;integerTestCanonicalization5&quot;, &quot;referenceSnippet5&quot;);
179     }
180 
181     public static void integerTestCanonicalization5(int a) {
182         if (a + 2 &lt; a) {
183             sink1 = 0;
184         } else {
185             sink0 = -1;
186         }
187     }
188 
189     public static void referenceSnippet5(int a) {
190         if (a &gt; Integer.MAX_VALUE - 2) {
191             sink1 = 0;
192         } else {
193             sink0 = -1;
194         }
195     }
196 
197     @Test
198     public void test6() {
199         assertCanonicallyEqual(&quot;integerTestCanonicalization6&quot;, &quot;referenceSnippet6&quot;);
200     }
201 
202     public static void integerTestCanonicalization6(int a) {
203         if (a &lt; a + 1) {
204             sink1 = 0;
205         } else {
206             sink0 = -1;
207         }
208     }
209 
210     public static void referenceSnippet6(int a) {
211         if (a != Integer.MAX_VALUE) {
212             sink1 = 0;
213         } else {
214             sink0 = -1;
215         }
216     }
217 
218     @Test
219     public void test7() {
220         assertCanonicallyEqual(&quot;integerTestCanonicalization7&quot;, &quot;referenceSnippet7&quot;);
221     }
222 
223     public static void integerTestCanonicalization7(int a) {
224         if (a &lt; a + 2) {
225             sink1 = 0;
226         } else {
227             sink0 = -1;
228         }
229     }
230 
231     public static void referenceSnippet7(int a) {
232         if (a &lt;= Integer.MAX_VALUE - 2) {
233             sink1 = 0;
234         } else {
235             sink0 = -1;
236         }
237     }
238 
239     protected void assertCanonicallyEqual(String snippet, String reference) {
240         StructuredGraph graph = parseEager(snippet, AllowAssumptions.YES);
<a name="4" id="anc4"></a><span class="line-modified">241         PhaseContext context = new PhaseContext(getProviders());</span>
<span class="line-modified">242         CanonicalizerPhase canonicalizer = new CanonicalizerPhase();</span>
243 
244         canonicalizer.apply(graph, context);
245         new GuardLoweringPhase().apply(graph, new MidTierContext(getProviders(), getTargetProvider(), OptimisticOptimizations.ALL, graph.getProfilingInfo()));
246         new FrameStateAssignmentPhase().apply(graph);
247         canonicalizer.apply(graph, context);
248 
249         StructuredGraph referenceGraph = parseEager(reference, AllowAssumptions.YES);
250         canonicalizer.apply(referenceGraph, context);
251         new GuardLoweringPhase().apply(referenceGraph, new MidTierContext(getProviders(), getTargetProvider(), OptimisticOptimizations.ALL, graph.getProfilingInfo()));
252         new FrameStateAssignmentPhase().apply(referenceGraph);
253         canonicalizer.apply(referenceGraph, context);
254 
255         canonicalizer.apply(referenceGraph, context);
256         assertEquals(referenceGraph, graph, true, true);
257     }
258 
259     @Override
260     protected InlineInvokePlugin.InlineInfo bytecodeParserShouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
261         return InlineInvokePlugin.InlineInfo.createStandardInlineInfo(method);
262     }
263 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
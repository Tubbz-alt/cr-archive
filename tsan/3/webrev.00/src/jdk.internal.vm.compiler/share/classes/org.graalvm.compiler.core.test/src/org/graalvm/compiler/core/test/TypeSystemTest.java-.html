<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/TypeSystemTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import java.io.BufferedInputStream;
 28 import java.io.ByteArrayInputStream;
 29 import java.io.FileInputStream;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 
 33 import org.graalvm.compiler.debug.DebugContext;
 34 import org.graalvm.compiler.debug.TTY;
 35 import org.graalvm.compiler.graph.Node;
 36 import org.graalvm.compiler.nodeinfo.Verbosity;
 37 import org.graalvm.compiler.nodes.AbstractMergeNode;
 38 import org.graalvm.compiler.nodes.PhiNode;
 39 import org.graalvm.compiler.nodes.StructuredGraph;
 40 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 41 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 42 import org.graalvm.compiler.nodes.cfg.Block;
 43 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 44 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 45 import org.graalvm.compiler.phases.common.ConditionalEliminationPhase;
 46 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 47 import org.graalvm.compiler.phases.tiers.PhaseContext;
 48 import org.junit.Assert;
 49 import org.junit.Ignore;
 50 import org.junit.Test;
 51 
 52 /**
 53  * In the following tests, the scalar type system of the compiler should be complete enough to see
 54  * the relation between the different conditions.
 55  */
 56 public class TypeSystemTest extends GraalCompilerTest {
 57 
 58     @Test
 59     public void test3() {
 60         test(&quot;test3Snippet&quot;, &quot;referenceSnippet3&quot;);
 61     }
 62 
 63     public static int referenceSnippet3(Object o) {
 64         if (o == null) {
 65             return 1;
 66         } else {
 67             return 2;
 68         }
 69     }
 70 
 71     @SuppressWarnings(&quot;unused&quot;)
 72     public static int test3Snippet(Object o) {
 73         if (o == null) {
 74             if (o != null) {
 75                 return 3;
 76             } else {
 77                 return 1;
 78             }
 79         } else {
 80             return 2;
 81         }
 82     }
 83 
 84     @Test
 85     public void test4() {
 86         test(&quot;test4Snippet&quot;, &quot;referenceSnippet3&quot;);
 87     }
 88 
 89     @SuppressWarnings(&quot;unused&quot;)
 90     public static int test4Snippet(Object o) {
 91         if (o == null) {
 92             Object o2 = Integer.class;
 93             if (o == o2) {
 94                 return 3;
 95             } else {
 96                 return 1;
 97             }
 98         } else {
 99             return 2;
100         }
101     }
102 
103     @Test
104     @Ignore
105     public void test5() {
106         test(&quot;test5Snippet&quot;, &quot;referenceSnippet5&quot;);
107     }
108 
109     public static int referenceSnippet5(Object o, Object a) {
110         if (o == null) {
111             if (a == Integer.class) {
112                 return 1;
113             }
114         } else {
115             if (a == Double.class) {
116                 return 11;
117             }
118         }
119         if (a == Integer.class) {
120             return 3;
121         }
122         return 5;
123     }
124 
125     @SuppressWarnings(&quot;unused&quot;)
126     public static int test5Snippet(Object o, Object a) {
127         if (o == null) {
128             if (a == Integer.class) {
129                 if (a == null) {
130                     return 10;
131                 }
132                 return 1;
133             }
134         } else {
135             if (a == Double.class) {
136                 if (a != null) {
137                     return 11;
138                 }
139                 return 2;
140             }
141         }
142         if (a == Integer.class) {
143             return 3;
144         }
145         return 5;
146     }
147 
148     @Test
149     public void test6() {
150         testHelper(&quot;test6Snippet&quot;, InstanceOfNode.class);
151     }
152 
153     public static int test6Snippet(int i) throws IOException {
154         Object o = null;
155 
156         if (i == 5) {
157             o = new FileInputStream(&quot;asdf&quot;);
158         }
159         if (i &lt; 10) {
160             o = new ByteArrayInputStream(new byte[]{1, 2, 3});
161         }
162         if (i &gt; 0) {
163             o = new BufferedInputStream(null);
164         }
165 
166         return ((InputStream) o).available();
167     }
168 
169     @Test
170     public void test7() {
171         test(&quot;test7Snippet&quot;, &quot;referenceSnippet7&quot;);
172     }
173 
174     public static int test7Snippet(int x) {
175         return ((x &amp; 0xff) &lt;&lt; 10) == ((x &amp; 0x1f) + 1) ? 0 : x;
176     }
177 
178     public static int referenceSnippet7(int x) {
179         return x;
180     }
181 
182     private void test(String snippet, String referenceSnippet) {
183         StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO);
184         DebugContext debug = graph.getDebug();
185         debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;Graph&quot;);
186         /*
187          * When using FlowSensitiveReductionPhase instead of ConditionalEliminationPhase,
188          * tail-duplication gets activated thus resulting in a graph with more nodes than the
189          * reference graph.
190          */
191         new ConditionalEliminationPhase(false).apply(graph, new PhaseContext(getProviders()));
192         new CanonicalizerPhase().apply(graph, new PhaseContext(getProviders()));
193         // a second canonicalizer is needed to process nested MaterializeNodes
194         new CanonicalizerPhase().apply(graph, new PhaseContext(getProviders()));
195         StructuredGraph referenceGraph = parseEager(referenceSnippet, AllowAssumptions.NO);
196         new ConditionalEliminationPhase(false).apply(referenceGraph, new PhaseContext(getProviders()));
197         new CanonicalizerPhase().apply(referenceGraph, new PhaseContext(getProviders()));
198         new CanonicalizerPhase().apply(referenceGraph, new PhaseContext(getProviders()));
199         assertEquals(referenceGraph, graph);
200     }
201 
202     @Override
203     protected void assertEquals(StructuredGraph expected, StructuredGraph graph) {
204         DebugContext debug = graph.getDebug();
205         if (getNodeCountExcludingUnusedConstants(expected) != getNodeCountExcludingUnusedConstants(graph)) {
206             debug.dump(DebugContext.BASIC_LEVEL, expected, &quot;expected (node count)&quot;);
207             debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;graph (node count)&quot;);
208             Assert.fail(&quot;Graphs do not have the same number of nodes: &quot; + expected.getNodeCount() + &quot; vs. &quot; + graph.getNodeCount());
209         }
210     }
211 
212     public static void outputGraph(StructuredGraph graph, String message) {
213         TTY.println(&quot;========================= &quot; + message);
214         SchedulePhase schedulePhase = new SchedulePhase(graph.getOptions());
215         schedulePhase.apply(graph);
216         ScheduleResult schedule = graph.getLastSchedule();
217         for (Block block : schedule.getCFG().getBlocks()) {
218             TTY.print(&quot;Block &quot; + block + &quot; &quot;);
219             if (block == schedule.getCFG().getStartBlock()) {
220                 TTY.print(&quot;* &quot;);
221             }
222             TTY.print(&quot;-&gt; &quot;);
223             for (Block succ : block.getSuccessors()) {
224                 TTY.print(succ + &quot; &quot;);
225             }
226             TTY.println();
227             for (Node node : schedule.getBlockToNodesMap().get(block)) {
228                 outputNode(node);
229             }
230         }
231     }
232 
233     private static void outputNode(Node node) {
234         TTY.print(&quot;  &quot; + node + &quot;    (usage count: &quot; + node.getUsageCount() + &quot;) (inputs:&quot;);
235         for (Node input : node.inputs()) {
236             TTY.print(&quot; &quot; + input.toString(Verbosity.Id));
237         }
238         TTY.println(&quot;)&quot;);
239         if (node instanceof AbstractMergeNode) {
240             for (PhiNode phi : ((AbstractMergeNode) node).phis()) {
241                 outputNode(phi);
242             }
243         }
244     }
245 
246     private &lt;T extends Node&gt; void testHelper(String snippet, Class&lt;T&gt; clazz) {
247         StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO);
248         new CanonicalizerPhase().apply(graph, new PhaseContext(getProviders()));
249         new CanonicalizerPhase().apply(graph, new PhaseContext(getProviders()));
250         DebugContext debug = graph.getDebug();
251         debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;Graph &quot; + snippet);
252         Assert.assertFalse(&quot;shouldn&#39;t have nodes of type &quot; + clazz, graph.getNodes().filter(clazz).iterator().hasNext());
253     }
254 }
    </pre>
  </body>
</html>
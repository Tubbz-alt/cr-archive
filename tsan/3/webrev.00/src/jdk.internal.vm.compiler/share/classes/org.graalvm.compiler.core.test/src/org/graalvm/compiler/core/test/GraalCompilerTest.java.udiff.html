<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/GraalCompilerTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FloatingReadTest.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphEncoderTest.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/GraalCompilerTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -41,30 +41,31 @@</span>
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Collection;
  import java.util.Collections;
  import java.util.EnumMap;
<span class="udiff-line-added">+ import java.util.HashMap;</span>
  import java.util.List;
  import java.util.ListIterator;
  import java.util.Map;
  import java.util.Set;
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.function.Supplier;
  
  import org.graalvm.compiler.api.directives.GraalDirectives;
  import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  import org.graalvm.compiler.api.test.Graal;
<span class="udiff-line-added">+ import org.graalvm.compiler.api.test.ModuleSupport;</span>
  import org.graalvm.compiler.code.CompilationResult;
  import org.graalvm.compiler.core.CompilationPrinter;
  import org.graalvm.compiler.core.GraalCompiler;
  import org.graalvm.compiler.core.GraalCompiler.Request;
  import org.graalvm.compiler.core.common.CompilationIdentifier;
  import org.graalvm.compiler.core.common.type.StampFactory;
  import org.graalvm.compiler.core.target.Backend;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.debug.DebugDumpHandler;
<span class="udiff-line-removed">- import org.graalvm.compiler.debug.DebugDumpScope;</span>
  import org.graalvm.compiler.debug.DebugHandlersFactory;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.debug.TTY;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.NodeClass;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -72,10 +73,11 @@</span>
  import org.graalvm.compiler.java.BytecodeParser;
  import org.graalvm.compiler.java.ComputeLoopFrequenciesClosure;
  import org.graalvm.compiler.java.GraphBuilderPhase;
  import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
  import org.graalvm.compiler.lir.phases.LIRSuites;
<span class="udiff-line-added">+ import org.graalvm.compiler.loop.phases.ConvertDeoptimizeToGuardPhase;</span>
  import org.graalvm.compiler.nodeinfo.NodeInfo;
  import org.graalvm.compiler.nodeinfo.NodeSize;
  import org.graalvm.compiler.nodeinfo.Verbosity;
  import org.graalvm.compiler.nodes.BreakpointNode;
  import org.graalvm.compiler.nodes.Cancellable;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109,11 +111,10 @@</span>
  import org.graalvm.compiler.phases.BasePhase;
  import org.graalvm.compiler.phases.OptimisticOptimizations;
  import org.graalvm.compiler.phases.Phase;
  import org.graalvm.compiler.phases.PhaseSuite;
  import org.graalvm.compiler.phases.common.CanonicalizerPhase;
<span class="udiff-line-removed">- import org.graalvm.compiler.loop.phases.ConvertDeoptimizeToGuardPhase;</span>
  import org.graalvm.compiler.phases.common.inlining.InliningPhase;
  import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
  import org.graalvm.compiler.phases.common.inlining.policy.GreedyInliningPolicy;
  import org.graalvm.compiler.phases.schedule.SchedulePhase;
  import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -124,13 +125,13 @@</span>
  import org.graalvm.compiler.phases.util.Providers;
  import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
  import org.graalvm.compiler.runtime.RuntimeProvider;
  import org.graalvm.compiler.test.AddExports;
  import org.graalvm.compiler.test.GraalTest;
<span class="udiff-line-removed">- import org.graalvm.compiler.test.JLModule;</span>
  import org.junit.After;
  import org.junit.Assert;
<span class="udiff-line-added">+ import org.junit.BeforeClass;</span>
  import org.junit.Test;
  import org.junit.internal.AssumptionViolatedException;
  
  import jdk.vm.ci.code.Architecture;
  import jdk.vm.ci.code.BailoutException;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148,13 +149,13 @@</span>
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.ResolvedJavaType;
  import jdk.vm.ci.meta.SpeculationLog;
  
  /**
<span class="udiff-line-modified-removed">-  * Base class for Graal compiler unit tests.</span>
<span class="udiff-line-modified-added">+  * Base class for compiler unit tests.</span>
   * &lt;p&gt;
<span class="udiff-line-modified-removed">-  * White box tests for Graal compiler transformations use this pattern:</span>
<span class="udiff-line-modified-added">+  * White box tests for compiler transformations use this pattern:</span>
   * &lt;ol&gt;
   * &lt;li&gt;Create a graph by {@linkplain #parseEager parsing} a method.&lt;/li&gt;
   * &lt;li&gt;Manually modify the graph (e.g. replace a parameter node with a constant).&lt;/li&gt;
   * &lt;li&gt;Apply a transformation to the graph.&lt;/li&gt;
   * &lt;li&gt;Assert that the transformed graph is equal to an expected graph.&lt;/li&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -192,13 +193,11 @@</span>
       * Exports the package named {@code packageName} declared in {@code moduleMember}&#39;s module to
       * this object&#39;s module. This must be called before accessing packages that are no longer public
       * as of JDK 9.
       */
      protected final void exportPackage(Class&lt;?&gt; moduleMember, String packageName) {
<span class="udiff-line-modified-removed">-         if (!Java8OrEarlier) {</span>
<span class="udiff-line-removed">-             JLModule.exportPackageTo(moduleMember, packageName, getClass());</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         ModuleSupport.exportPackageTo(moduleMember, packageName, getClass());</span>
      }
  
      /**
       * Denotes a test method that must be inlined by the {@link BytecodeParser}.
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -222,31 +221,31 @@</span>
  
      /**
       * Can be overridden by unit tests to verify properties of the graph.
       *
       * @param graph the graph at the end of HighTier
<span class="udiff-line-added">+      * @throws AssertionError if the verification fails</span>
       */
<span class="udiff-line-modified-removed">-     protected boolean checkHighTierGraph(StructuredGraph graph) {</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-modified-added">+     protected void checkHighTierGraph(StructuredGraph graph) {</span>
      }
  
      /**
       * Can be overridden by unit tests to verify properties of the graph.
       *
       * @param graph the graph at the end of MidTier
<span class="udiff-line-added">+      * @throws AssertionError if the verification fails</span>
       */
<span class="udiff-line-modified-removed">-     protected boolean checkMidTierGraph(StructuredGraph graph) {</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-modified-added">+     protected void checkMidTierGraph(StructuredGraph graph) {</span>
      }
  
      /**
       * Can be overridden by unit tests to verify properties of the graph.
       *
       * @param graph the graph at the end of LowTier
<span class="udiff-line-added">+      * @throws AssertionError if the verification fails</span>
       */
<span class="udiff-line-modified-removed">-     protected boolean checkLowTierGraph(StructuredGraph graph) {</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-modified-added">+     protected void checkLowTierGraph(StructuredGraph graph) {</span>
      }
  
      protected static void breakpoint() {
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -286,11 +285,11 @@</span>
          });
          ret.getHighTier().appendPhase(new Phase() {
  
              @Override
              protected void run(StructuredGraph graph) {
<span class="udiff-line-modified-removed">-                 assert checkHighTierGraph(graph) : &quot;failed HighTier graph check&quot;;</span>
<span class="udiff-line-modified-added">+                 checkHighTierGraph(graph);</span>
              }
  
              @Override
              public float codeSizeIncrease() {
                  return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -303,11 +302,11 @@</span>
          });
          ret.getMidTier().appendPhase(new Phase() {
  
              @Override
              protected void run(StructuredGraph graph) {
<span class="udiff-line-modified-removed">-                 assert checkMidTierGraph(graph) : &quot;failed MidTier graph check&quot;;</span>
<span class="udiff-line-modified-added">+                 checkMidTierGraph(graph);</span>
              }
  
              @Override
              public float codeSizeIncrease() {
                  return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -320,11 +319,11 @@</span>
          });
          ret.getLowTier().appendPhase(new Phase() {
  
              @Override
              protected void run(StructuredGraph graph) {
<span class="udiff-line-modified-removed">-                 assert checkLowTierGraph(graph) : &quot;failed LowTier graph check&quot;;</span>
<span class="udiff-line-modified-added">+                 checkLowTierGraph(graph);</span>
              }
  
              @Override
              public float codeSizeIncrease() {
                  return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -341,10 +340,17 @@</span>
      protected LIRSuites createLIRSuites(OptionValues opts) {
          LIRSuites ret = backend.getSuites().getDefaultLIRSuites(opts).copy();
          return ret;
      }
  
<span class="udiff-line-added">+     private static final ThreadLocal&lt;HashMap&lt;ResolvedJavaMethod, InstalledCode&gt;&gt; cache = ThreadLocal.withInitial(HashMap::new);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @BeforeClass</span>
<span class="udiff-line-added">+     public static void resetCache() {</span>
<span class="udiff-line-added">+         cache.get().clear();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      public GraalCompilerTest() {
          this.backend = Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend();
          this.providers = getBackend().getProviders();
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -598,15 +604,25 @@</span>
  
      protected final Providers getProviders() {
          return providers;
      }
  
<span class="udiff-line-modified-removed">-     protected HighTierContext getDefaultHighTierContext() {</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-added">+      * Override the {@link OptimisticOptimizations} settings used for the test. This is called for</span>
<span class="udiff-line-added">+      * all the paths where the value is set so it is the proper place for a test override. Setting</span>
<span class="udiff-line-added">+      * it in other places can result in inconsistent values being used in other parts of the</span>
<span class="udiff-line-added">+      * compiler.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     protected OptimisticOptimizations getOptimisticOptimizations() {</span>
<span class="udiff-line-added">+         return OptimisticOptimizations.ALL;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     protected final HighTierContext getDefaultHighTierContext() {</span>
          return new HighTierContext(getProviders(), getDefaultGraphBuilderSuite(), getOptimisticOptimizations());
      }
  
<span class="udiff-line-modified-removed">-     protected MidTierContext getDefaultMidTierContext() {</span>
<span class="udiff-line-modified-added">+     protected final MidTierContext getDefaultMidTierContext() {</span>
          return new MidTierContext(getProviders(), getTargetProvider(), getOptimisticOptimizations(), null);
      }
  
      protected SnippetReflectionProvider getSnippetReflection() {
          return Graal.getRequiredCapability(SnippetReflectionProvider.class);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -635,11 +651,11 @@</span>
      protected LoweringProvider getLowerer() {
          return getProviders().getLowerer();
      }
  
      protected final BasePhase&lt;HighTierContext&gt; createInliningPhase() {
<span class="udiff-line-modified-removed">-         return createInliningPhase(new CanonicalizerPhase());</span>
<span class="udiff-line-modified-added">+         return createInliningPhase(this.createCanonicalizerPhase());</span>
      }
  
      protected BasePhase&lt;HighTierContext&gt; createInliningPhase(CanonicalizerPhase canonicalizer) {
          return createInliningPhase(null, canonicalizer);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -920,12 +936,10 @@</span>
              }
              assertDeepEquals(expect.returnValue, actual.returnValue);
          }
      }
  
<span class="udiff-line-removed">-     private Map&lt;ResolvedJavaMethod, InstalledCode&gt; cache = new ConcurrentHashMap&lt;&gt;();</span>
<span class="udiff-line-removed">- </span>
      /**
       * Gets installed code for a given method, compiling it first if necessary. The graph is parsed
       * {@link #parseEager eagerly}.
       */
      protected final InstalledCode getCode(ResolvedJavaMethod method) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -973,11 +987,11 @@</span>
       */
      @SuppressWarnings(&quot;try&quot;)
      protected InstalledCode getCode(final ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, boolean forceCompile, boolean installAsDefault, OptionValues options) {
          boolean useCache = !forceCompile &amp;&amp; getArgumentToBind() == null;
          if (useCache &amp;&amp; graph == null) {
<span class="udiff-line-modified-removed">-             InstalledCode cached = cache.get(installedCodeOwner);</span>
<span class="udiff-line-modified-added">+             InstalledCode cached = cache.get().get(installedCodeOwner);</span>
              if (cached != null) {
                  if (cached.isValid()) {
                      return cached;
                  }
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -988,11 +1002,11 @@</span>
  
              InstalledCode installedCode = null;
              StructuredGraph graphToCompile = graph == null ? parseForCompile(installedCodeOwner, id, options) : graph;
              DebugContext debug = graphToCompile.getDebug();
  
<span class="udiff-line-modified-removed">-             try (AllocSpy spy = AllocSpy.open(installedCodeOwner); DebugContext.Scope ds = debug.scope(&quot;Compiling&quot;, new DebugDumpScope(id.toString(CompilationIdentifier.Verbosity.ID), true))) {</span>
<span class="udiff-line-modified-added">+             try (AllocSpy spy = AllocSpy.open(installedCodeOwner); DebugContext.Scope ds = debug.scope(&quot;Compiling&quot;, graph)) {</span>
                  CompilationPrinter printer = CompilationPrinter.begin(options, id, installedCodeOwner, INVOCATION_ENTRY_BCI);
                  CompilationResult compResult = compile(installedCodeOwner, graphToCompile, new CompilationResult(graphToCompile.compilationId()), id, options);
                  printer.finish(compResult);
  
                  try (DebugContext.Scope s = debug.scope(&quot;CodeInstall&quot;, getCodeCache(), installedCodeOwner, compResult);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1020,11 +1034,11 @@</span>
              } catch (Throwable e) {
                  throw debug.handle(e);
              }
  
              if (useCache) {
<span class="udiff-line-modified-removed">-                 cache.put(installedCodeOwner, installedCode);</span>
<span class="udiff-line-modified-added">+                 cache.get().put(installedCodeOwner, installedCode);</span>
              }
              return installedCode;
          }
          throw GraalError.shouldNotReachHere();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1075,14 +1089,10 @@</span>
          assert graph == null || graph.getOptions() == options;
          CompilationIdentifier compilationId = getOrCreateCompilationId(installedCodeOwner, graph);
          return compile(installedCodeOwner, graph, new CompilationResult(compilationId), compilationId, options);
      }
  
<span class="udiff-line-removed">-     protected OptimisticOptimizations getOptimisticOptimizations() {</span>
<span class="udiff-line-removed">-         return OptimisticOptimizations.ALL;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /**
       * Compiles a given method.
       *
       * @param installedCodeOwner the method the compiled code will be associated with when installed
       * @param graph the graph to be compiled for {@code installedCodeOwner}. If null, a graph will
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1113,12 +1123,24 @@</span>
          StructuredGraph graph = parseForCompile(method);
          applyFrontEnd(graph);
          return graph;
      }
  
<span class="udiff-line-added">+     protected StructuredGraph getFinalGraph(ResolvedJavaMethod method, OptionValues options) {</span>
<span class="udiff-line-added">+         StructuredGraph graph = parseForCompile(method, options);</span>
<span class="udiff-line-added">+         applyFrontEnd(graph);</span>
<span class="udiff-line-added">+         return graph;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @SuppressWarnings(&quot;try&quot;)</span>
      protected void applyFrontEnd(StructuredGraph graph) {
<span class="udiff-line-modified-removed">-         GraalCompiler.emitFrontEnd(getProviders(), getBackend(), graph, getDefaultGraphBuilderSuite(), getOptimisticOptimizations(), graph.getProfilingInfo(), createSuites(graph.getOptions()));</span>
<span class="udiff-line-modified-added">+         DebugContext debug = graph.getDebug();</span>
<span class="udiff-line-added">+         try (DebugContext.Scope s = debug.scope(&quot;FrontEnd&quot;, graph)) {</span>
<span class="udiff-line-added">+             GraalCompiler.emitFrontEnd(getProviders(), getBackend(), graph, getDefaultGraphBuilderSuite(), getOptimisticOptimizations(), graph.getProfilingInfo(), createSuites(graph.getOptions()));</span>
<span class="udiff-line-added">+         } catch (Throwable e) {</span>
<span class="udiff-line-added">+             throw debug.handle(e);</span>
<span class="udiff-line-added">+         }</span>
      }
  
      protected StructuredGraph lastCompiledGraph;
  
      protected SpeculationLog getSpeculationLog() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1313,20 +1335,25 @@</span>
          } catch (Throwable e) {
              throw debug.handle(e);
          }
      }
  
<span class="udiff-line-added">+     protected static final Object NO_BIND = new Object();</span>
<span class="udiff-line-added">+ </span>
      protected void bindArguments(StructuredGraph graph, Object[] argsToBind) {
          ResolvedJavaMethod m = graph.method();
          Object receiver = isStatic(m.getModifiers()) ? null : this;
          Object[] args = argsWithReceiver(receiver, argsToBind);
          JavaType[] parameterTypes = m.toParameterTypes();
          assert parameterTypes.length == args.length;
          for (ParameterNode param : graph.getNodes(ParameterNode.TYPE)) {
<span class="udiff-line-modified-removed">-             JavaConstant c = getSnippetReflection().forBoxed(parameterTypes[param.index()].getJavaKind(), args[param.index()]);</span>
<span class="udiff-line-modified-removed">-             ConstantNode replacement = ConstantNode.forConstant(c, getMetaAccess(), graph);</span>
<span class="udiff-line-modified-removed">-             param.replaceAtUsages(replacement);</span>
<span class="udiff-line-modified-added">+             Object arg = args[param.index()];</span>
<span class="udiff-line-modified-added">+             if (arg != NO_BIND) {</span>
<span class="udiff-line-modified-added">+                 JavaConstant c = getSnippetReflection().forBoxed(parameterTypes[param.index()].getJavaKind(), arg);</span>
<span class="udiff-line-added">+                 ConstantNode replacement = ConstantNode.forConstant(c, getMetaAccess(), graph);</span>
<span class="udiff-line-added">+                 param.replaceAtUsages(replacement);</span>
<span class="udiff-line-added">+             }</span>
          }
      }
  
      protected Object[] getArgumentToBind() {
          return null;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1498,6 +1525,10 @@</span>
       * @return true if we run on the architecture given by name
       */
      protected boolean isArchitecture(String name) {
          return name.equals(backend.getTarget().arch.getName());
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     protected CanonicalizerPhase createCanonicalizerPhase() {</span>
<span class="udiff-line-added">+         return CanonicalizerPhase.create();</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="FloatingReadTest.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="GraphEncoderTest.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
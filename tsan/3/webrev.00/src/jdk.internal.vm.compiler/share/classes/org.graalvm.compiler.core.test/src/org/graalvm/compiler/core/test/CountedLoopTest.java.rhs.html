<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/CountedLoopTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
 28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
 29 
 30 import org.graalvm.compiler.api.directives.GraalDirectives;
 31 import org.graalvm.compiler.graph.NodeClass;
 32 import org.graalvm.compiler.loop.InductionVariable;
 33 import org.graalvm.compiler.loop.LoopsData;
 34 import org.graalvm.compiler.nodeinfo.NodeInfo;
 35 import org.graalvm.compiler.nodes.ConstantNode;
 36 import org.graalvm.compiler.nodes.NodeView;
 37 import org.graalvm.compiler.nodes.StructuredGraph;
 38 import org.graalvm.compiler.nodes.ValueNode;
 39 import org.graalvm.compiler.nodes.calc.FloatingNode;
 40 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 41 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 42 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 43 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 44 import org.graalvm.compiler.nodes.spi.LIRLowerable;
 45 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
<a name="2" id="anc2"></a><span class="line-added"> 46 import org.graalvm.compiler.nodes.util.GraphUtil;</span>
 47 import org.graalvm.compiler.phases.OptimisticOptimizations;
<a name="3" id="anc3"></a>
 48 import org.junit.Test;
 49 
 50 import jdk.vm.ci.meta.JavaKind;
 51 import jdk.vm.ci.meta.ResolvedJavaMethod;
 52 
 53 public class CountedLoopTest extends GraalCompilerTest {
 54 
 55     @FunctionalInterface
 56     private interface IVProperty {
 57         ValueNode get(InductionVariable iv);
 58     }
 59 
 60     @FunctionalInterface
 61     private interface StaticIVProperty {
 62         long get(InductionVariable iv);
 63     }
 64 
 65     @FunctionalInterface
 66     private interface IVPredicate {
 67         boolean test(InductionVariable iv);
 68     }
 69 
 70     /**
 71      * Get a property of an induction variable.
 72      */
<a name="4" id="anc4"></a><span class="line-modified"> 73     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-modified"> 74     private static int get(IVProperty property, StaticIVProperty staticProperty, IVPredicate constantCheck, int iv) {</span>
 75         return iv;
 76     }
 77 
<a name="5" id="anc5"></a><span class="line-modified"> 78     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added"> 79     private static int get(IVProperty property, int iv) {</span>
 80         return iv;
 81     }
 82 
<a name="6" id="anc6"></a><span class="line-modified"> 83     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added"> 84     private static long get(IVProperty property, StaticIVProperty staticProperty, IVPredicate constantCheck,</span>
 85                     long iv) {
 86         return iv;
 87     }
 88 
<a name="7" id="anc7"></a><span class="line-modified"> 89     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added"> 90     private static long get(IVProperty property, long iv) {</span>
 91         return iv;
 92     }
 93 
 94     private static class Result {
 95         public long extremum;
 96         public long exitValue;
 97 
 98         @Override
 99         public int hashCode() {
100             final int prime = 31;
101             int result = 1;
102             result = prime * result + Long.hashCode(exitValue);
103             result = prime * result + Long.hashCode(extremum);
104             return result;
105         }
106 
107         @Override
108         public boolean equals(Object obj) {
109             if (!(obj instanceof Result)) {
110                 return false;
111             }
112             Result other = (Result) obj;
113             return extremum == other.extremum &amp;&amp; exitValue == other.exitValue;
114         }
115 
116         @Override
117         public String toString() {
118             return String.format(&quot;extremum = %d, exitValue = %d&quot;, extremum, exitValue);
119         }
120     }
121 
122     public static Result incrementSnippet(int start, int limit, int step) {
123         int i;
124         int inc = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive
125         Result ret = new Result();
126         for (i = start; i &lt; limit; i += inc) {
127             GraalDirectives.controlFlowAnchor();
128             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);
129         }
130         ret.exitValue = get(InductionVariable::exitValueNode, i);
131         return ret;
132     }
133 
134     @Test
135     public void increment1() {
136         testCounted(&quot;incrementSnippet&quot;, 0, 256, 1);
137     }
138 
139     @Test
140     public void increment2() {
141         testCounted(&quot;incrementSnippet&quot;, 0, 256, 2);
142     }
143 
144     @Test
145     public void increment3() {
146         testCounted(&quot;incrementSnippet&quot;, 0, 256, 3);
147     }
148 
149     @Test
150     public void increment4() {
151         testCounted(&quot;incrementSnippet&quot;, -10, 1, Integer.MAX_VALUE);
152     }
153 
154     @Test
155     public void increment5() {
<a name="8" id="anc8"></a><span class="line-modified">156         testRemovableCounted(&quot;incrementSnippet&quot;, 256, 256, 1);</span>
157     }
158 
159     @Test
160     public void increment6() {
<a name="9" id="anc9"></a><span class="line-modified">161         testRemovableCounted(&quot;incrementSnippet&quot;, 257, 256, 1);</span>
162     }
163 
164     @Test
165     public void increment7() {
166         testCounted(&quot;incrementSnippet&quot;, -10, Integer.MAX_VALUE, 1);
167     }
168 
169     @Test
170     public void increment8() {
171         testCounted(&quot;incrementSnippet&quot;, -10, Integer.MAX_VALUE - 1, 2);
172     }
173 
174     public static Result incrementEqSnippet(int start, int limit, int step) {
175         int i;
176         int inc = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive
177         Result ret = new Result();
178         for (i = start; i &lt;= limit; i += inc) {
179             GraalDirectives.controlFlowAnchor();
180             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);
181         }
182         ret.exitValue = get(InductionVariable::exitValueNode, i);
183         return ret;
184     }
185 
186     @Test
187     public void incrementEq1() {
188         testCounted(&quot;incrementEqSnippet&quot;, 0, 256, 1);
189     }
190 
191     @Test
192     public void incrementEq2() {
193         testCounted(&quot;incrementEqSnippet&quot;, 0, 256, 2);
194     }
195 
196     @Test
197     public void incrementEq3() {
198         testCounted(&quot;incrementEqSnippet&quot;, 0, 256, 3);
199     }
200 
201     @Test
202     public void incrementEq4() {
203         testCounted(&quot;incrementEqSnippet&quot;, -10, 0, Integer.MAX_VALUE);
204     }
205 
206     @Test
207     public void incrementEq5() {
208         testCounted(&quot;incrementEqSnippet&quot;, 256, 256, 1);
209     }
210 
211     @Test
212     public void incrementEq6() {
<a name="10" id="anc10"></a><span class="line-modified">213         testRemovableCounted(&quot;incrementEqSnippet&quot;, 257, 256, 1);</span>
214     }
215 
216     @Test
217     public void incrementEq7() {
218         testCounted(&quot;incrementEqSnippet&quot;, -10, Integer.MAX_VALUE - 1, 1);
219     }
220 
221     @Test
222     public void incrementEq8() {
223         testCounted(&quot;incrementEqSnippet&quot;, -10, Integer.MAX_VALUE - 2, 2);
224     }
225 
<a name="11" id="anc11"></a><span class="line-added">226     @Test</span>
<span class="line-added">227     public void incrementEq9() {</span>
<span class="line-added">228         testCounted(&quot;incrementEqSnippet&quot;, 0, 0, 1);</span>
<span class="line-added">229     }</span>
<span class="line-added">230 </span>
<span class="line-added">231     @Test</span>
<span class="line-added">232     public void incrementEq10() {</span>
<span class="line-added">233         testCounted(&quot;incrementEqSnippet&quot;, 0, 0, 3);</span>
<span class="line-added">234     }</span>
<span class="line-added">235 </span>
236     public static Result decrementSnippet(int start, int limit, int step) {
237         int i;
238         int dec = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive
239         Result ret = new Result();
240         for (i = start; i &gt; limit; i -= dec) {
241             GraalDirectives.controlFlowAnchor();
242             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);
243         }
244         ret.exitValue = get(InductionVariable::exitValueNode, i);
245         return ret;
246     }
247 
248     @Test
249     public void decrement1() {
250         testCounted(&quot;decrementSnippet&quot;, 256, 0, 1);
251     }
252 
253     @Test
254     public void decrement2() {
255         testCounted(&quot;decrementSnippet&quot;, 256, 0, 2);
256     }
257 
258     @Test
259     public void decrement3() {
260         testCounted(&quot;decrementSnippet&quot;, 256, 0, 3);
261     }
262 
263     @Test
264     public void decrement4() {
265         testCounted(&quot;decrementSnippet&quot;, Integer.MAX_VALUE, -10, 1);
266     }
267 
268     @Test
269     public void decrement5() {
270         testCounted(&quot;decrementSnippet&quot;, Integer.MAX_VALUE, -10, 2);
271     }
272 
273     public static Result decrementEqSnippet(int start, int limit, int step) {
274         int i;
275         int dec = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive
276         Result ret = new Result();
277         for (i = start; i &gt;= limit; i -= dec) {
278             GraalDirectives.controlFlowAnchor();
279             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);
280         }
281         ret.exitValue = get(InductionVariable::exitValueNode, i);
282         return ret;
283     }
284 
285     @Test
286     public void decrementEq1() {
287         testCounted(&quot;decrementEqSnippet&quot;, 256, 0, 1);
288     }
289 
290     @Test
291     public void decrementEq2() {
292         testCounted(&quot;decrementEqSnippet&quot;, 256, 0, 2);
293     }
294 
295     @Test
296     public void decrementEq3() {
297         testCounted(&quot;decrementEqSnippet&quot;, 256, 0, 3);
298     }
299 
300     @Test
301     public void decrementEq4() {
<a name="12" id="anc12"></a><span class="line-modified">302         testRemovableCounted(&quot;decrementEqSnippet&quot;, -10, 0, Integer.MAX_VALUE);</span>
303     }
304 
305     @Test
306     public void decrementEq5() {
307         testCounted(&quot;decrementEqSnippet&quot;, Integer.MAX_VALUE, -10, 1);
308     }
309 
310     @Test
311     public void decrementEq6() {
312         testCounted(&quot;decrementEqSnippet&quot;, Integer.MAX_VALUE, -10, 2);
313     }
314 
<a name="13" id="anc13"></a><span class="line-added">315     @Test</span>
<span class="line-added">316     public void decrementEq7() {</span>
<span class="line-added">317         testCounted(&quot;decrementEqSnippet&quot;, 10, 10, 1);</span>
<span class="line-added">318     }</span>
<span class="line-added">319 </span>
<span class="line-added">320     @Test</span>
<span class="line-added">321     public void decrementEq8() {</span>
<span class="line-added">322         testCounted(&quot;decrementEqSnippet&quot;, 10, 10, 3);</span>
<span class="line-added">323     }</span>
<span class="line-added">324 </span>
325     public static Result twoVariablesSnippet() {
326         Result ret = new Result();
327         int j = 0;
328         for (int i = 0; i &lt; 1024; i++) {
329             j += 5;
330             GraalDirectives.controlFlowAnchor();
331             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, j);
332         }
333         ret.exitValue = get(InductionVariable::exitValueNode, j);
334         return ret;
335     }
336 
337     @Test
338     public void testTwoVariables() {
339         testCounted(&quot;twoVariablesSnippet&quot;);
340     }
341 
342     public static Result incrementNeqSnippet(int limit) {
343         int i;
344         int posLimit = ((limit - 1) &amp; 0xFFFF) + 1; // make sure limit is always strictly positive
345         Result ret = new Result();
346         for (i = 0; i != posLimit; i++) {
347             GraalDirectives.controlFlowAnchor();
348             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);
349         }
350         ret.exitValue = get(InductionVariable::exitValueNode, i);
351         return ret;
352     }
353 
354     @Test
355     public void decrementNeq() {
356         testCounted(&quot;decrementNeqSnippet&quot;, 256);
357     }
358 
359     public static Result decrementNeqSnippet(int limit) {
360         int i;
361         int posLimit = ((limit - 1) &amp; 0xFFFF) + 1; // make sure limit is always strictly positive
362         Result ret = new Result();
363         for (i = posLimit; i != 0; i--) {
364             GraalDirectives.controlFlowAnchor();
365             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);
366         }
367         ret.exitValue = get(InductionVariable::exitValueNode, i);
368         return ret;
369     }
370 
371     @Test
372     public void incrementNeq() {
373         testCounted(&quot;incrementNeqSnippet&quot;, 256);
374     }
375 
376     public static Result incrementLongSnippet(long start, long limit, long step) {
377         long i;
378         long inc = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive
379         Result ret = new Result();
380         for (i = start; i &lt; limit; i += inc) {
381             GraalDirectives.controlFlowAnchor();
382             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);
383         }
384         ret.exitValue = get(InductionVariable::exitValueNode, i);
385         return ret;
386     }
387 
388     @Test
389     public void incrementLong1() {
390         testCounted(&quot;incrementLongSnippet&quot;, 0L, 256L, 1L);
391     }
392 
393     @Test
394     public void incrementLong2() {
395         testCounted(&quot;incrementLongSnippet&quot;, 0L, 256L, 2L);
396     }
397 
398     @Test
399     public void incrementLong3() {
400         testCounted(&quot;incrementLongSnippet&quot;, 0L, 256L, 3L);
401     }
402 
403     @Test
404     public void incrementLong4() {
405         testCounted(&quot;incrementLongSnippet&quot;, -10L, 1L, Long.MAX_VALUE);
406     }
407 
408     @Test
409     public void incrementLong5() {
<a name="14" id="anc14"></a><span class="line-modified">410         testRemovableCounted(&quot;incrementLongSnippet&quot;, 256L, 256L, 1L);</span>
411     }
412 
413     @Test
414     public void incrementLong6() {
<a name="15" id="anc15"></a><span class="line-modified">415         testRemovableCounted(&quot;incrementLongSnippet&quot;, 257L, 256L, 1L);</span>
<span class="line-added">416     }</span>
<span class="line-added">417 </span>
<span class="line-added">418     public static Result incrementUnsignedSnippet(int start, int limit, int step) {</span>
<span class="line-added">419         int i;</span>
<span class="line-added">420         int inc = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive</span>
<span class="line-added">421         Result ret = new Result();</span>
<span class="line-added">422         for (i = start; Integer.compareUnsigned(i, limit) &lt; 0; i += inc) {</span>
<span class="line-added">423             GraalDirectives.controlFlowAnchor();</span>
<span class="line-added">424             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);</span>
<span class="line-added">425         }</span>
<span class="line-added">426         ret.exitValue = get(InductionVariable::exitValueNode, i);</span>
<span class="line-added">427         return ret;</span>
<span class="line-added">428     }</span>
<span class="line-added">429 </span>
<span class="line-added">430     @Test</span>
<span class="line-added">431     public void incrementUnsigned1() {</span>
<span class="line-added">432         testCounted(&quot;incrementUnsignedSnippet&quot;, 0, 256, 1);</span>
<span class="line-added">433     }</span>
<span class="line-added">434 </span>
<span class="line-added">435     @Test</span>
<span class="line-added">436     public void incrementUnsigned2() {</span>
<span class="line-added">437         testCounted(&quot;incrementUnsignedSnippet&quot;, 0, 256, 2);</span>
<span class="line-added">438     }</span>
<span class="line-added">439 </span>
<span class="line-added">440     @Test</span>
<span class="line-added">441     public void incrementUnsigned3() {</span>
<span class="line-added">442         testCounted(&quot;incrementUnsignedSnippet&quot;, 0, 256, 3);</span>
<span class="line-added">443     }</span>
<span class="line-added">444 </span>
<span class="line-added">445     @Test</span>
<span class="line-added">446     public void incrementUnsigned4() {</span>
<span class="line-added">447         testCounted(&quot;incrementUnsignedSnippet&quot;, 1, Integer.MAX_VALUE + 10, Integer.MAX_VALUE);</span>
<span class="line-added">448     }</span>
<span class="line-added">449 </span>
<span class="line-added">450     @Test</span>
<span class="line-added">451     public void incrementUnsigned5() {</span>
<span class="line-added">452         testRemovableCounted(&quot;incrementUnsignedSnippet&quot;, 256, 256, 1);</span>
<span class="line-added">453     }</span>
<span class="line-added">454 </span>
<span class="line-added">455     @Test</span>
<span class="line-added">456     public void incrementUnsigned6() {</span>
<span class="line-added">457         testRemovableCounted(&quot;incrementUnsignedSnippet&quot;, 257, 256, 1);</span>
<span class="line-added">458     }</span>
<span class="line-added">459 </span>
<span class="line-added">460     @Test</span>
<span class="line-added">461     public void incrementUnsigned7() {</span>
<span class="line-added">462         testCounted(&quot;incrementUnsignedSnippet&quot;, 0, Integer.MAX_VALUE + 10, 1);</span>
<span class="line-added">463     }</span>
<span class="line-added">464 </span>
<span class="line-added">465     @Test</span>
<span class="line-added">466     public void incrementUnsigned8a() {</span>
<span class="line-added">467         testCounted(&quot;incrementUnsignedSnippet&quot;, 0, Integer.MAX_VALUE + 11, 2);</span>
<span class="line-added">468     }</span>
<span class="line-added">469 </span>
<span class="line-added">470     @Test</span>
<span class="line-added">471     public void incrementUnsigned8b() {</span>
<span class="line-added">472         testCounted(&quot;incrementUnsignedSnippet&quot;, 0, Integer.MAX_VALUE + 10, 2);</span>
<span class="line-added">473     }</span>
<span class="line-added">474 </span>
<span class="line-added">475     @Test</span>
<span class="line-added">476     public void incrementUnsigned9() {</span>
<span class="line-added">477         testCounted(&quot;incrementUnsignedSnippet&quot;, Integer.MAX_VALUE - 1, Integer.MAX_VALUE + 10, 1);</span>
<span class="line-added">478     }</span>
<span class="line-added">479 </span>
<span class="line-added">480     @Test</span>
<span class="line-added">481     public void incrementUnsigned10() {</span>
<span class="line-added">482         testCounted(&quot;incrementUnsignedSnippet&quot;, Integer.MAX_VALUE - 1, Integer.MAX_VALUE + 10, 2);</span>
<span class="line-added">483     }</span>
<span class="line-added">484 </span>
<span class="line-added">485     public static Result decrementUnsignedSnippet(int start, int limit, int step) {</span>
<span class="line-added">486         int dec = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive</span>
<span class="line-added">487         Result ret = new Result();</span>
<span class="line-added">488         int i;</span>
<span class="line-added">489         for (i = start; Integer.compareUnsigned(i, limit) &gt; 0; i -= dec) {</span>
<span class="line-added">490             GraalDirectives.controlFlowAnchor();</span>
<span class="line-added">491             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);</span>
<span class="line-added">492         }</span>
<span class="line-added">493         ret.exitValue = get(InductionVariable::exitValueNode, i);</span>
<span class="line-added">494         return ret;</span>
<span class="line-added">495     }</span>
<span class="line-added">496 </span>
<span class="line-added">497     @Test</span>
<span class="line-added">498     public void decrementUnsigned1() {</span>
<span class="line-added">499         testCounted(&quot;decrementUnsignedSnippet&quot;, 256, 0, 1);</span>
<span class="line-added">500     }</span>
<span class="line-added">501 </span>
<span class="line-added">502     @Test</span>
<span class="line-added">503     public void decrementUnsigned2() {</span>
<span class="line-added">504         testCounted(&quot;decrementUnsignedSnippet&quot;, 256, 0, 2);</span>
<span class="line-added">505     }</span>
<span class="line-added">506 </span>
<span class="line-added">507     @Test</span>
<span class="line-added">508     public void decrementUnsigned3() {</span>
<span class="line-added">509         testCounted(&quot;decrementUnsignedSnippet&quot;, 256, 2, 3);</span>
<span class="line-added">510     }</span>
<span class="line-added">511 </span>
<span class="line-added">512     @Test</span>
<span class="line-added">513     public void decrementUnsigned5() {</span>
<span class="line-added">514         testRemovableCounted(&quot;decrementUnsignedSnippet&quot;, 256, 256, 1);</span>
<span class="line-added">515     }</span>
<span class="line-added">516 </span>
<span class="line-added">517     @Test</span>
<span class="line-added">518     public void decrementUnsigned6() {</span>
<span class="line-added">519         testRemovableCounted(&quot;decrementUnsignedSnippet&quot;, 256, 257, 1);</span>
<span class="line-added">520     }</span>
<span class="line-added">521 </span>
<span class="line-added">522     @Test</span>
<span class="line-added">523     public void decrementUnsigned7() {</span>
<span class="line-added">524         testCounted(&quot;decrementUnsignedSnippet&quot;, Integer.MAX_VALUE + 10, 0, 1);</span>
<span class="line-added">525     }</span>
<span class="line-added">526 </span>
<span class="line-added">527     @Test</span>
<span class="line-added">528     public void decrementUnsigned8() {</span>
<span class="line-added">529         testCounted(&quot;decrementUnsignedSnippet&quot;, Integer.MAX_VALUE + 11, 0, 2);</span>
<span class="line-added">530     }</span>
<span class="line-added">531 </span>
<span class="line-added">532     @Test</span>
<span class="line-added">533     public void decrementUnsigned9() {</span>
<span class="line-added">534         testCounted(&quot;decrementUnsignedSnippet&quot;, Integer.MAX_VALUE + 10, Integer.MAX_VALUE - 1, 1);</span>
<span class="line-added">535     }</span>
<span class="line-added">536 </span>
<span class="line-added">537     @Test</span>
<span class="line-added">538     public void decrementUnsigned10() {</span>
<span class="line-added">539         testCounted(&quot;decrementUnsignedSnippet&quot;, Integer.MAX_VALUE + 10, Integer.MAX_VALUE - 1, 2);</span>
540     }
541 
542     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
543     private static class IVPropertyNode extends FloatingNode implements LIRLowerable {
<a name="16" id="anc16"></a>
544         public static final NodeClass&lt;IVPropertyNode&gt; TYPE = NodeClass.create(IVPropertyNode.class);
545 
546         private final IVProperty property;
547         private final StaticIVProperty staticProperty;
548         private final IVPredicate staticCheck;
<a name="17" id="anc17"></a><span class="line-added">549         private final boolean loopCanBeRemoved;</span>
550         @Input private ValueNode iv;
551 
<a name="18" id="anc18"></a><span class="line-modified">552         protected IVPropertyNode(IVProperty property, StaticIVProperty staticProperty, IVPredicate staticCheck, ValueNode iv, boolean loopCanBeRemoved) {</span>
553             super(TYPE, iv.stamp(NodeView.DEFAULT).unrestricted());
554             this.property = property;
555             this.staticProperty = staticProperty;
556             this.staticCheck = staticCheck;
557             this.iv = iv;
<a name="19" id="anc19"></a><span class="line-added">558             this.loopCanBeRemoved = loopCanBeRemoved;</span>
559         }
560 
561         public void rewrite(LoopsData loops) {
<a name="20" id="anc20"></a><span class="line-modified">562             InductionVariable inductionVariable = loops.getInductionVariable(GraphUtil.unproxify(iv));</span>


563             ValueNode node = null;
<a name="21" id="anc21"></a><span class="line-modified">564             if (inductionVariable == null) {</span>
<span class="line-modified">565                 assert loopCanBeRemoved;</span>
<span class="line-modified">566                 assert loops.loops().isEmpty();</span>
<span class="line-modified">567                 node = iv;</span>
<span class="line-added">568             } else {</span>
<span class="line-added">569                 assertTrue(inductionVariable.getLoop().isCounted(), &quot;must be counted&quot;);</span>
<span class="line-added">570                 if (staticCheck != null) {</span>
<span class="line-added">571                     assert staticProperty != null;</span>
<span class="line-added">572                     if (staticCheck.test(inductionVariable)) {</span>
<span class="line-added">573                         node = ConstantNode.forLong(staticProperty.get(inductionVariable), graph());</span>
<span class="line-added">574                     }</span>
<span class="line-added">575                 }</span>
<span class="line-added">576                 if (node == null) {</span>
<span class="line-added">577                     node = property.get(inductionVariable);</span>
578                 }
<a name="22" id="anc22"></a>


579             }
580             replaceAtUsagesAndDelete(node);
581         }
582 
583         @Override
584         public void generate(NodeLIRBuilderTool gen) {
585             gen.setResult(this, gen.operand(iv));
586         }
587     }
588 
589     @Override
590     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
591         Registration r = new Registration(invocationPlugins, CountedLoopTest.class);
592         registerPlugins(r, JavaKind.Int);
593         registerPlugins(r, JavaKind.Long);
594         super.registerInvocationPlugins(invocationPlugins);
595     }
596 
597     private void registerPlugins(Registration r, JavaKind ivKind) {
598         r.register2(&quot;get&quot;, IVProperty.class, ivKind.toJavaClass(), new InvocationPlugin() {
599             @Override
600             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2) {
601                 IVProperty property = null;
602                 if (arg1.isConstant()) {
603                     property = getSnippetReflection().asObject(IVProperty.class, arg1.asJavaConstant());
604                 }
605                 if (property != null) {
<a name="23" id="anc23"></a><span class="line-modified">606                     b.addPush(ivKind, new IVPropertyNode(property, null, null, arg2, loopCanBeRemoved));</span>
607                     return true;
608                 } else {
609                     return false;
610                 }
611             }
612         });
613         r.register4(&quot;get&quot;, IVProperty.class, StaticIVProperty.class, IVPredicate.class, ivKind.toJavaClass(), new InvocationPlugin() {
614             @Override
615             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3, ValueNode arg4) {
616                 IVProperty property = null;
617                 StaticIVProperty staticProperty = null;
618                 IVPredicate staticCheck = null;
619                 if (arg1.isConstant()) {
620                     property = getSnippetReflection().asObject(IVProperty.class, arg1.asJavaConstant());
621                 }
622                 if (arg2.isConstant()) {
623                     staticProperty = getSnippetReflection().asObject(StaticIVProperty.class, arg2.asJavaConstant());
624                 }
625                 if (arg3.isConstant()) {
626                     staticCheck = getSnippetReflection().asObject(IVPredicate.class, arg3.asJavaConstant());
627                 }
628                 if (property != null &amp;&amp; staticProperty != null &amp;&amp; staticCheck != null) {
<a name="24" id="anc24"></a><span class="line-modified">629                     b.addPush(ivKind, new IVPropertyNode(property, staticProperty, staticCheck, arg4, loopCanBeRemoved));</span>
630                     return true;
631                 } else {
632                     return false;
633                 }
634             }
635         });
636     }
637 
638     @Override
<a name="25" id="anc25"></a><span class="line-modified">639     protected void checkHighTierGraph(StructuredGraph graph) {</span>
640         LoopsData loops = new LoopsData(graph);
641         loops.detectedCountedLoops();
642         for (IVPropertyNode node : graph.getNodes().filter(IVPropertyNode.class)) {
643             node.rewrite(loops);
644         }
645         assert graph.getNodes().filter(IVPropertyNode.class).isEmpty();
<a name="26" id="anc26"></a>
646     }
647 
648     @Override
<a name="27" id="anc27"></a><span class="line-modified">649     protected OptimisticOptimizations getOptimisticOptimizations() {</span>
650         // Don&#39;t convert unreached paths into Guard
<a name="28" id="anc28"></a><span class="line-modified">651         return OptimisticOptimizations.ALL.remove(OptimisticOptimizations.Optimization.RemoveNeverExecutedCode);</span>
652     }
653 
654     private Object[] argsToBind;
<a name="29" id="anc29"></a><span class="line-added">655     private boolean loopCanBeRemoved;</span>
656 
657     @Override
658     protected Object[] getArgumentToBind() {
659         return argsToBind;
660     }
661 
662     public void testCounted(String snippetName, Object... args) {
<a name="30" id="anc30"></a><span class="line-added">663         this.loopCanBeRemoved = false;</span>
<span class="line-added">664         test(snippetName, args);</span>
<span class="line-added">665         this.argsToBind = args;</span>
<span class="line-added">666         test(snippetName, args);</span>
<span class="line-added">667         this.argsToBind = null;</span>
<span class="line-added">668     }</span>
<span class="line-added">669 </span>
<span class="line-added">670     public void testCounted(String snippetName, Object start, Object limit, Object step) {</span>
<span class="line-added">671         testCounted(false, snippetName, start, limit, step);</span>
<span class="line-added">672     }</span>
<span class="line-added">673 </span>
<span class="line-added">674     public void testRemovableCounted(String snippetName, Object start, Object limit, Object step) {</span>
<span class="line-added">675         testCounted(true, snippetName, start, limit, step);</span>
<span class="line-added">676     }</span>
<span class="line-added">677 </span>
<span class="line-added">678     public void testCounted(boolean removable, String snippetName, Object start, Object limit, Object step) {</span>
<span class="line-added">679         this.loopCanBeRemoved = removable;</span>
<span class="line-added">680         Object[] args = {start, limit, step};</span>
<span class="line-added">681         test(snippetName, args);</span>
<span class="line-added">682         this.argsToBind = args;</span>
<span class="line-added">683         test(snippetName, args);</span>
<span class="line-added">684         this.argsToBind = new Object[]{NO_BIND, NO_BIND, step};</span>
685         test(snippetName, args);
<a name="31" id="anc31"></a><span class="line-modified">686         this.argsToBind = new Object[]{start, NO_BIND, step};</span>
687         test(snippetName, args);
<a name="32" id="anc32"></a><span class="line-modified">688         this.argsToBind = null;</span>
<span class="line-added">689         this.loopCanBeRemoved = false;</span>
690     }
691 }
<a name="33" id="anc33"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="33" type="hidden" />
</body>
</html>
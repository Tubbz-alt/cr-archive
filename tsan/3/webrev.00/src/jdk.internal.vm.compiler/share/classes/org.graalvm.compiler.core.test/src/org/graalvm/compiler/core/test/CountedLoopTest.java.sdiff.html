<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/CountedLoopTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CopyOfVirtualizationTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CustomizedBytecodePatternTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/CountedLoopTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 26 
 27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
 28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
 29 
 30 import org.graalvm.compiler.api.directives.GraalDirectives;
 31 import org.graalvm.compiler.graph.NodeClass;
 32 import org.graalvm.compiler.loop.InductionVariable;
 33 import org.graalvm.compiler.loop.LoopsData;
 34 import org.graalvm.compiler.nodeinfo.NodeInfo;
 35 import org.graalvm.compiler.nodes.ConstantNode;
 36 import org.graalvm.compiler.nodes.NodeView;
 37 import org.graalvm.compiler.nodes.StructuredGraph;
 38 import org.graalvm.compiler.nodes.ValueNode;
 39 import org.graalvm.compiler.nodes.calc.FloatingNode;
 40 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 41 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 42 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 43 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 44 import org.graalvm.compiler.nodes.spi.LIRLowerable;
 45 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;

 46 import org.graalvm.compiler.phases.OptimisticOptimizations;
<span class="line-removed"> 47 import org.graalvm.compiler.phases.tiers.HighTierContext;</span>
 48 import org.junit.Test;
 49 
 50 import jdk.vm.ci.meta.JavaKind;
 51 import jdk.vm.ci.meta.ResolvedJavaMethod;
 52 
 53 public class CountedLoopTest extends GraalCompilerTest {
 54 
 55     @FunctionalInterface
 56     private interface IVProperty {
 57         ValueNode get(InductionVariable iv);
 58     }
 59 
 60     @FunctionalInterface
 61     private interface StaticIVProperty {
 62         long get(InductionVariable iv);
 63     }
 64 
 65     @FunctionalInterface
 66     private interface IVPredicate {
 67         boolean test(InductionVariable iv);
 68     }
 69 
 70     /**
 71      * Get a property of an induction variable.
 72      */
<span class="line-modified"> 73     private static int get(@SuppressWarnings(&quot;unused&quot;) IVProperty property, @SuppressWarnings(&quot;unused&quot;) StaticIVProperty staticProperty, @SuppressWarnings(&quot;unused&quot;) IVPredicate constantCheck,</span>
<span class="line-modified"> 74                     int iv) {</span>
 75         return iv;
 76     }
 77 
<span class="line-modified"> 78     private static int get(@SuppressWarnings(&quot;unused&quot;) IVProperty property, int iv) {</span>

 79         return iv;
 80     }
 81 
<span class="line-modified"> 82     private static long get(@SuppressWarnings(&quot;unused&quot;) IVProperty property, @SuppressWarnings(&quot;unused&quot;) StaticIVProperty staticProperty, @SuppressWarnings(&quot;unused&quot;) IVPredicate constantCheck,</span>

 83                     long iv) {
 84         return iv;
 85     }
 86 
<span class="line-modified"> 87     private static long get(@SuppressWarnings(&quot;unused&quot;) IVProperty property, long iv) {</span>

 88         return iv;
 89     }
 90 
 91     private static class Result {
 92         public long extremum;
 93         public long exitValue;
 94 
 95         @Override
 96         public int hashCode() {
 97             final int prime = 31;
 98             int result = 1;
 99             result = prime * result + Long.hashCode(exitValue);
100             result = prime * result + Long.hashCode(extremum);
101             return result;
102         }
103 
104         @Override
105         public boolean equals(Object obj) {
106             if (!(obj instanceof Result)) {
107                 return false;
</pre>
<hr />
<pre>
133         testCounted(&quot;incrementSnippet&quot;, 0, 256, 1);
134     }
135 
136     @Test
137     public void increment2() {
138         testCounted(&quot;incrementSnippet&quot;, 0, 256, 2);
139     }
140 
141     @Test
142     public void increment3() {
143         testCounted(&quot;incrementSnippet&quot;, 0, 256, 3);
144     }
145 
146     @Test
147     public void increment4() {
148         testCounted(&quot;incrementSnippet&quot;, -10, 1, Integer.MAX_VALUE);
149     }
150 
151     @Test
152     public void increment5() {
<span class="line-modified">153         testCounted(&quot;incrementSnippet&quot;, 256, 256, 1);</span>
154     }
155 
156     @Test
157     public void increment6() {
<span class="line-modified">158         testCounted(&quot;incrementSnippet&quot;, 257, 256, 1);</span>
159     }
160 
161     @Test
162     public void increment7() {
163         testCounted(&quot;incrementSnippet&quot;, -10, Integer.MAX_VALUE, 1);
164     }
165 
166     @Test
167     public void increment8() {
168         testCounted(&quot;incrementSnippet&quot;, -10, Integer.MAX_VALUE - 1, 2);
169     }
170 
171     public static Result incrementEqSnippet(int start, int limit, int step) {
172         int i;
173         int inc = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive
174         Result ret = new Result();
175         for (i = start; i &lt;= limit; i += inc) {
176             GraalDirectives.controlFlowAnchor();
177             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);
178         }
</pre>
<hr />
<pre>
190         testCounted(&quot;incrementEqSnippet&quot;, 0, 256, 2);
191     }
192 
193     @Test
194     public void incrementEq3() {
195         testCounted(&quot;incrementEqSnippet&quot;, 0, 256, 3);
196     }
197 
198     @Test
199     public void incrementEq4() {
200         testCounted(&quot;incrementEqSnippet&quot;, -10, 0, Integer.MAX_VALUE);
201     }
202 
203     @Test
204     public void incrementEq5() {
205         testCounted(&quot;incrementEqSnippet&quot;, 256, 256, 1);
206     }
207 
208     @Test
209     public void incrementEq6() {
<span class="line-modified">210         testCounted(&quot;incrementEqSnippet&quot;, 257, 256, 1);</span>
211     }
212 
213     @Test
214     public void incrementEq7() {
215         testCounted(&quot;incrementEqSnippet&quot;, -10, Integer.MAX_VALUE - 1, 1);
216     }
217 
218     @Test
219     public void incrementEq8() {
220         testCounted(&quot;incrementEqSnippet&quot;, -10, Integer.MAX_VALUE - 2, 2);
221     }
222 










223     public static Result decrementSnippet(int start, int limit, int step) {
224         int i;
225         int dec = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive
226         Result ret = new Result();
227         for (i = start; i &gt; limit; i -= dec) {
228             GraalDirectives.controlFlowAnchor();
229             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);
230         }
231         ret.exitValue = get(InductionVariable::exitValueNode, i);
232         return ret;
233     }
234 
235     @Test
236     public void decrement1() {
237         testCounted(&quot;decrementSnippet&quot;, 256, 0, 1);
238     }
239 
240     @Test
241     public void decrement2() {
242         testCounted(&quot;decrementSnippet&quot;, 256, 0, 2);
</pre>
<hr />
<pre>
269         return ret;
270     }
271 
272     @Test
273     public void decrementEq1() {
274         testCounted(&quot;decrementEqSnippet&quot;, 256, 0, 1);
275     }
276 
277     @Test
278     public void decrementEq2() {
279         testCounted(&quot;decrementEqSnippet&quot;, 256, 0, 2);
280     }
281 
282     @Test
283     public void decrementEq3() {
284         testCounted(&quot;decrementEqSnippet&quot;, 256, 0, 3);
285     }
286 
287     @Test
288     public void decrementEq4() {
<span class="line-modified">289         testCounted(&quot;decrementEqSnippet&quot;, -10, 0, Integer.MAX_VALUE);</span>
290     }
291 
292     @Test
293     public void decrementEq5() {
294         testCounted(&quot;decrementEqSnippet&quot;, Integer.MAX_VALUE, -10, 1);
295     }
296 
297     @Test
298     public void decrementEq6() {
299         testCounted(&quot;decrementEqSnippet&quot;, Integer.MAX_VALUE, -10, 2);
300     }
301 










302     public static Result twoVariablesSnippet() {
303         Result ret = new Result();
304         int j = 0;
305         for (int i = 0; i &lt; 1024; i++) {
306             j += 5;
307             GraalDirectives.controlFlowAnchor();
308             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, j);
309         }
310         ret.exitValue = get(InductionVariable::exitValueNode, j);
311         return ret;
312     }
313 
314     @Test
315     public void testTwoVariables() {
316         testCounted(&quot;twoVariablesSnippet&quot;);
317     }
318 
319     public static Result incrementNeqSnippet(int limit) {
320         int i;
321         int posLimit = ((limit - 1) &amp; 0xFFFF) + 1; // make sure limit is always strictly positive
</pre>
<hr />
<pre>
367         testCounted(&quot;incrementLongSnippet&quot;, 0L, 256L, 1L);
368     }
369 
370     @Test
371     public void incrementLong2() {
372         testCounted(&quot;incrementLongSnippet&quot;, 0L, 256L, 2L);
373     }
374 
375     @Test
376     public void incrementLong3() {
377         testCounted(&quot;incrementLongSnippet&quot;, 0L, 256L, 3L);
378     }
379 
380     @Test
381     public void incrementLong4() {
382         testCounted(&quot;incrementLongSnippet&quot;, -10L, 1L, Long.MAX_VALUE);
383     }
384 
385     @Test
386     public void incrementLong5() {
<span class="line-modified">387         testCounted(&quot;incrementLongSnippet&quot;, 256L, 256L, 1L);</span>
388     }
389 
390     @Test
391     public void incrementLong6() {
<span class="line-modified">392         testCounted(&quot;incrementLongSnippet&quot;, 257L, 256L, 1L);</span>




























































































































393     }
394 
395     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
396     private static class IVPropertyNode extends FloatingNode implements LIRLowerable {
<span class="line-removed">397 </span>
398         public static final NodeClass&lt;IVPropertyNode&gt; TYPE = NodeClass.create(IVPropertyNode.class);
399 
400         private final IVProperty property;
401         private final StaticIVProperty staticProperty;
402         private final IVPredicate staticCheck;

403         @Input private ValueNode iv;
404 
<span class="line-modified">405         protected IVPropertyNode(IVProperty property, StaticIVProperty staticProperty, IVPredicate staticCheck, ValueNode iv) {</span>
406             super(TYPE, iv.stamp(NodeView.DEFAULT).unrestricted());
407             this.property = property;
408             this.staticProperty = staticProperty;
409             this.staticCheck = staticCheck;
410             this.iv = iv;

411         }
412 
413         public void rewrite(LoopsData loops) {
<span class="line-modified">414             InductionVariable inductionVariable = loops.getInductionVariable(iv);</span>
<span class="line-removed">415             assert inductionVariable != null;</span>
<span class="line-removed">416             assertTrue(inductionVariable.getLoop().isCounted(), &quot;must be counted&quot;);</span>
417             ValueNode node = null;
<span class="line-modified">418             if (staticCheck != null) {</span>
<span class="line-modified">419                 assert staticProperty != null;</span>
<span class="line-modified">420                 if (staticCheck.test(inductionVariable)) {</span>
<span class="line-modified">421                     node = ConstantNode.forLong(staticProperty.get(inductionVariable), graph());</span>










422                 }
<span class="line-removed">423             }</span>
<span class="line-removed">424             if (node == null) {</span>
<span class="line-removed">425                 node = property.get(inductionVariable);</span>
426             }
427             replaceAtUsagesAndDelete(node);
428         }
429 
430         @Override
431         public void generate(NodeLIRBuilderTool gen) {
432             gen.setResult(this, gen.operand(iv));
433         }
434     }
435 
436     @Override
437     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
438         Registration r = new Registration(invocationPlugins, CountedLoopTest.class);
439         registerPlugins(r, JavaKind.Int);
440         registerPlugins(r, JavaKind.Long);
441         super.registerInvocationPlugins(invocationPlugins);
442     }
443 
444     private void registerPlugins(Registration r, JavaKind ivKind) {
445         r.register2(&quot;get&quot;, IVProperty.class, ivKind.toJavaClass(), new InvocationPlugin() {
446             @Override
447             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2) {
448                 IVProperty property = null;
449                 if (arg1.isConstant()) {
450                     property = getSnippetReflection().asObject(IVProperty.class, arg1.asJavaConstant());
451                 }
452                 if (property != null) {
<span class="line-modified">453                     b.addPush(ivKind, new IVPropertyNode(property, null, null, arg2));</span>
454                     return true;
455                 } else {
456                     return false;
457                 }
458             }
459         });
460         r.register4(&quot;get&quot;, IVProperty.class, StaticIVProperty.class, IVPredicate.class, ivKind.toJavaClass(), new InvocationPlugin() {
461             @Override
462             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3, ValueNode arg4) {
463                 IVProperty property = null;
464                 StaticIVProperty staticProperty = null;
465                 IVPredicate staticCheck = null;
466                 if (arg1.isConstant()) {
467                     property = getSnippetReflection().asObject(IVProperty.class, arg1.asJavaConstant());
468                 }
469                 if (arg2.isConstant()) {
470                     staticProperty = getSnippetReflection().asObject(StaticIVProperty.class, arg2.asJavaConstant());
471                 }
472                 if (arg3.isConstant()) {
473                     staticCheck = getSnippetReflection().asObject(IVPredicate.class, arg3.asJavaConstant());
474                 }
475                 if (property != null &amp;&amp; staticProperty != null &amp;&amp; staticCheck != null) {
<span class="line-modified">476                     b.addPush(ivKind, new IVPropertyNode(property, staticProperty, staticCheck, arg4));</span>
477                     return true;
478                 } else {
479                     return false;
480                 }
481             }
482         });
483     }
484 
485     @Override
<span class="line-modified">486     protected boolean checkHighTierGraph(StructuredGraph graph) {</span>
487         LoopsData loops = new LoopsData(graph);
488         loops.detectedCountedLoops();
489         for (IVPropertyNode node : graph.getNodes().filter(IVPropertyNode.class)) {
490             node.rewrite(loops);
491         }
492         assert graph.getNodes().filter(IVPropertyNode.class).isEmpty();
<span class="line-removed">493         return true;</span>
494     }
495 
496     @Override
<span class="line-modified">497     protected HighTierContext getDefaultHighTierContext() {</span>
498         // Don&#39;t convert unreached paths into Guard
<span class="line-modified">499         return new HighTierContext(getProviders(), getDefaultGraphBuilderSuite(), OptimisticOptimizations.NONE);</span>
500     }
501 
502     private Object[] argsToBind;

503 
504     @Override
505     protected Object[] getArgumentToBind() {
506         return argsToBind;
507     }
508 
509     public void testCounted(String snippetName, Object... args) {






















510         test(snippetName, args);
<span class="line-modified">511         argsToBind = args;</span>
512         test(snippetName, args);
<span class="line-modified">513         argsToBind = null;</span>

514     }
515 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 26 
 27 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
 28 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
 29 
 30 import org.graalvm.compiler.api.directives.GraalDirectives;
 31 import org.graalvm.compiler.graph.NodeClass;
 32 import org.graalvm.compiler.loop.InductionVariable;
 33 import org.graalvm.compiler.loop.LoopsData;
 34 import org.graalvm.compiler.nodeinfo.NodeInfo;
 35 import org.graalvm.compiler.nodes.ConstantNode;
 36 import org.graalvm.compiler.nodes.NodeView;
 37 import org.graalvm.compiler.nodes.StructuredGraph;
 38 import org.graalvm.compiler.nodes.ValueNode;
 39 import org.graalvm.compiler.nodes.calc.FloatingNode;
 40 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 41 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 42 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 43 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 44 import org.graalvm.compiler.nodes.spi.LIRLowerable;
 45 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
<span class="line-added"> 46 import org.graalvm.compiler.nodes.util.GraphUtil;</span>
 47 import org.graalvm.compiler.phases.OptimisticOptimizations;

 48 import org.junit.Test;
 49 
 50 import jdk.vm.ci.meta.JavaKind;
 51 import jdk.vm.ci.meta.ResolvedJavaMethod;
 52 
 53 public class CountedLoopTest extends GraalCompilerTest {
 54 
 55     @FunctionalInterface
 56     private interface IVProperty {
 57         ValueNode get(InductionVariable iv);
 58     }
 59 
 60     @FunctionalInterface
 61     private interface StaticIVProperty {
 62         long get(InductionVariable iv);
 63     }
 64 
 65     @FunctionalInterface
 66     private interface IVPredicate {
 67         boolean test(InductionVariable iv);
 68     }
 69 
 70     /**
 71      * Get a property of an induction variable.
 72      */
<span class="line-modified"> 73     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-modified"> 74     private static int get(IVProperty property, StaticIVProperty staticProperty, IVPredicate constantCheck, int iv) {</span>
 75         return iv;
 76     }
 77 
<span class="line-modified"> 78     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added"> 79     private static int get(IVProperty property, int iv) {</span>
 80         return iv;
 81     }
 82 
<span class="line-modified"> 83     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added"> 84     private static long get(IVProperty property, StaticIVProperty staticProperty, IVPredicate constantCheck,</span>
 85                     long iv) {
 86         return iv;
 87     }
 88 
<span class="line-modified"> 89     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added"> 90     private static long get(IVProperty property, long iv) {</span>
 91         return iv;
 92     }
 93 
 94     private static class Result {
 95         public long extremum;
 96         public long exitValue;
 97 
 98         @Override
 99         public int hashCode() {
100             final int prime = 31;
101             int result = 1;
102             result = prime * result + Long.hashCode(exitValue);
103             result = prime * result + Long.hashCode(extremum);
104             return result;
105         }
106 
107         @Override
108         public boolean equals(Object obj) {
109             if (!(obj instanceof Result)) {
110                 return false;
</pre>
<hr />
<pre>
136         testCounted(&quot;incrementSnippet&quot;, 0, 256, 1);
137     }
138 
139     @Test
140     public void increment2() {
141         testCounted(&quot;incrementSnippet&quot;, 0, 256, 2);
142     }
143 
144     @Test
145     public void increment3() {
146         testCounted(&quot;incrementSnippet&quot;, 0, 256, 3);
147     }
148 
149     @Test
150     public void increment4() {
151         testCounted(&quot;incrementSnippet&quot;, -10, 1, Integer.MAX_VALUE);
152     }
153 
154     @Test
155     public void increment5() {
<span class="line-modified">156         testRemovableCounted(&quot;incrementSnippet&quot;, 256, 256, 1);</span>
157     }
158 
159     @Test
160     public void increment6() {
<span class="line-modified">161         testRemovableCounted(&quot;incrementSnippet&quot;, 257, 256, 1);</span>
162     }
163 
164     @Test
165     public void increment7() {
166         testCounted(&quot;incrementSnippet&quot;, -10, Integer.MAX_VALUE, 1);
167     }
168 
169     @Test
170     public void increment8() {
171         testCounted(&quot;incrementSnippet&quot;, -10, Integer.MAX_VALUE - 1, 2);
172     }
173 
174     public static Result incrementEqSnippet(int start, int limit, int step) {
175         int i;
176         int inc = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive
177         Result ret = new Result();
178         for (i = start; i &lt;= limit; i += inc) {
179             GraalDirectives.controlFlowAnchor();
180             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);
181         }
</pre>
<hr />
<pre>
193         testCounted(&quot;incrementEqSnippet&quot;, 0, 256, 2);
194     }
195 
196     @Test
197     public void incrementEq3() {
198         testCounted(&quot;incrementEqSnippet&quot;, 0, 256, 3);
199     }
200 
201     @Test
202     public void incrementEq4() {
203         testCounted(&quot;incrementEqSnippet&quot;, -10, 0, Integer.MAX_VALUE);
204     }
205 
206     @Test
207     public void incrementEq5() {
208         testCounted(&quot;incrementEqSnippet&quot;, 256, 256, 1);
209     }
210 
211     @Test
212     public void incrementEq6() {
<span class="line-modified">213         testRemovableCounted(&quot;incrementEqSnippet&quot;, 257, 256, 1);</span>
214     }
215 
216     @Test
217     public void incrementEq7() {
218         testCounted(&quot;incrementEqSnippet&quot;, -10, Integer.MAX_VALUE - 1, 1);
219     }
220 
221     @Test
222     public void incrementEq8() {
223         testCounted(&quot;incrementEqSnippet&quot;, -10, Integer.MAX_VALUE - 2, 2);
224     }
225 
<span class="line-added">226     @Test</span>
<span class="line-added">227     public void incrementEq9() {</span>
<span class="line-added">228         testCounted(&quot;incrementEqSnippet&quot;, 0, 0, 1);</span>
<span class="line-added">229     }</span>
<span class="line-added">230 </span>
<span class="line-added">231     @Test</span>
<span class="line-added">232     public void incrementEq10() {</span>
<span class="line-added">233         testCounted(&quot;incrementEqSnippet&quot;, 0, 0, 3);</span>
<span class="line-added">234     }</span>
<span class="line-added">235 </span>
236     public static Result decrementSnippet(int start, int limit, int step) {
237         int i;
238         int dec = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive
239         Result ret = new Result();
240         for (i = start; i &gt; limit; i -= dec) {
241             GraalDirectives.controlFlowAnchor();
242             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);
243         }
244         ret.exitValue = get(InductionVariable::exitValueNode, i);
245         return ret;
246     }
247 
248     @Test
249     public void decrement1() {
250         testCounted(&quot;decrementSnippet&quot;, 256, 0, 1);
251     }
252 
253     @Test
254     public void decrement2() {
255         testCounted(&quot;decrementSnippet&quot;, 256, 0, 2);
</pre>
<hr />
<pre>
282         return ret;
283     }
284 
285     @Test
286     public void decrementEq1() {
287         testCounted(&quot;decrementEqSnippet&quot;, 256, 0, 1);
288     }
289 
290     @Test
291     public void decrementEq2() {
292         testCounted(&quot;decrementEqSnippet&quot;, 256, 0, 2);
293     }
294 
295     @Test
296     public void decrementEq3() {
297         testCounted(&quot;decrementEqSnippet&quot;, 256, 0, 3);
298     }
299 
300     @Test
301     public void decrementEq4() {
<span class="line-modified">302         testRemovableCounted(&quot;decrementEqSnippet&quot;, -10, 0, Integer.MAX_VALUE);</span>
303     }
304 
305     @Test
306     public void decrementEq5() {
307         testCounted(&quot;decrementEqSnippet&quot;, Integer.MAX_VALUE, -10, 1);
308     }
309 
310     @Test
311     public void decrementEq6() {
312         testCounted(&quot;decrementEqSnippet&quot;, Integer.MAX_VALUE, -10, 2);
313     }
314 
<span class="line-added">315     @Test</span>
<span class="line-added">316     public void decrementEq7() {</span>
<span class="line-added">317         testCounted(&quot;decrementEqSnippet&quot;, 10, 10, 1);</span>
<span class="line-added">318     }</span>
<span class="line-added">319 </span>
<span class="line-added">320     @Test</span>
<span class="line-added">321     public void decrementEq8() {</span>
<span class="line-added">322         testCounted(&quot;decrementEqSnippet&quot;, 10, 10, 3);</span>
<span class="line-added">323     }</span>
<span class="line-added">324 </span>
325     public static Result twoVariablesSnippet() {
326         Result ret = new Result();
327         int j = 0;
328         for (int i = 0; i &lt; 1024; i++) {
329             j += 5;
330             GraalDirectives.controlFlowAnchor();
331             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, j);
332         }
333         ret.exitValue = get(InductionVariable::exitValueNode, j);
334         return ret;
335     }
336 
337     @Test
338     public void testTwoVariables() {
339         testCounted(&quot;twoVariablesSnippet&quot;);
340     }
341 
342     public static Result incrementNeqSnippet(int limit) {
343         int i;
344         int posLimit = ((limit - 1) &amp; 0xFFFF) + 1; // make sure limit is always strictly positive
</pre>
<hr />
<pre>
390         testCounted(&quot;incrementLongSnippet&quot;, 0L, 256L, 1L);
391     }
392 
393     @Test
394     public void incrementLong2() {
395         testCounted(&quot;incrementLongSnippet&quot;, 0L, 256L, 2L);
396     }
397 
398     @Test
399     public void incrementLong3() {
400         testCounted(&quot;incrementLongSnippet&quot;, 0L, 256L, 3L);
401     }
402 
403     @Test
404     public void incrementLong4() {
405         testCounted(&quot;incrementLongSnippet&quot;, -10L, 1L, Long.MAX_VALUE);
406     }
407 
408     @Test
409     public void incrementLong5() {
<span class="line-modified">410         testRemovableCounted(&quot;incrementLongSnippet&quot;, 256L, 256L, 1L);</span>
411     }
412 
413     @Test
414     public void incrementLong6() {
<span class="line-modified">415         testRemovableCounted(&quot;incrementLongSnippet&quot;, 257L, 256L, 1L);</span>
<span class="line-added">416     }</span>
<span class="line-added">417 </span>
<span class="line-added">418     public static Result incrementUnsignedSnippet(int start, int limit, int step) {</span>
<span class="line-added">419         int i;</span>
<span class="line-added">420         int inc = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive</span>
<span class="line-added">421         Result ret = new Result();</span>
<span class="line-added">422         for (i = start; Integer.compareUnsigned(i, limit) &lt; 0; i += inc) {</span>
<span class="line-added">423             GraalDirectives.controlFlowAnchor();</span>
<span class="line-added">424             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);</span>
<span class="line-added">425         }</span>
<span class="line-added">426         ret.exitValue = get(InductionVariable::exitValueNode, i);</span>
<span class="line-added">427         return ret;</span>
<span class="line-added">428     }</span>
<span class="line-added">429 </span>
<span class="line-added">430     @Test</span>
<span class="line-added">431     public void incrementUnsigned1() {</span>
<span class="line-added">432         testCounted(&quot;incrementUnsignedSnippet&quot;, 0, 256, 1);</span>
<span class="line-added">433     }</span>
<span class="line-added">434 </span>
<span class="line-added">435     @Test</span>
<span class="line-added">436     public void incrementUnsigned2() {</span>
<span class="line-added">437         testCounted(&quot;incrementUnsignedSnippet&quot;, 0, 256, 2);</span>
<span class="line-added">438     }</span>
<span class="line-added">439 </span>
<span class="line-added">440     @Test</span>
<span class="line-added">441     public void incrementUnsigned3() {</span>
<span class="line-added">442         testCounted(&quot;incrementUnsignedSnippet&quot;, 0, 256, 3);</span>
<span class="line-added">443     }</span>
<span class="line-added">444 </span>
<span class="line-added">445     @Test</span>
<span class="line-added">446     public void incrementUnsigned4() {</span>
<span class="line-added">447         testCounted(&quot;incrementUnsignedSnippet&quot;, 1, Integer.MAX_VALUE + 10, Integer.MAX_VALUE);</span>
<span class="line-added">448     }</span>
<span class="line-added">449 </span>
<span class="line-added">450     @Test</span>
<span class="line-added">451     public void incrementUnsigned5() {</span>
<span class="line-added">452         testRemovableCounted(&quot;incrementUnsignedSnippet&quot;, 256, 256, 1);</span>
<span class="line-added">453     }</span>
<span class="line-added">454 </span>
<span class="line-added">455     @Test</span>
<span class="line-added">456     public void incrementUnsigned6() {</span>
<span class="line-added">457         testRemovableCounted(&quot;incrementUnsignedSnippet&quot;, 257, 256, 1);</span>
<span class="line-added">458     }</span>
<span class="line-added">459 </span>
<span class="line-added">460     @Test</span>
<span class="line-added">461     public void incrementUnsigned7() {</span>
<span class="line-added">462         testCounted(&quot;incrementUnsignedSnippet&quot;, 0, Integer.MAX_VALUE + 10, 1);</span>
<span class="line-added">463     }</span>
<span class="line-added">464 </span>
<span class="line-added">465     @Test</span>
<span class="line-added">466     public void incrementUnsigned8a() {</span>
<span class="line-added">467         testCounted(&quot;incrementUnsignedSnippet&quot;, 0, Integer.MAX_VALUE + 11, 2);</span>
<span class="line-added">468     }</span>
<span class="line-added">469 </span>
<span class="line-added">470     @Test</span>
<span class="line-added">471     public void incrementUnsigned8b() {</span>
<span class="line-added">472         testCounted(&quot;incrementUnsignedSnippet&quot;, 0, Integer.MAX_VALUE + 10, 2);</span>
<span class="line-added">473     }</span>
<span class="line-added">474 </span>
<span class="line-added">475     @Test</span>
<span class="line-added">476     public void incrementUnsigned9() {</span>
<span class="line-added">477         testCounted(&quot;incrementUnsignedSnippet&quot;, Integer.MAX_VALUE - 1, Integer.MAX_VALUE + 10, 1);</span>
<span class="line-added">478     }</span>
<span class="line-added">479 </span>
<span class="line-added">480     @Test</span>
<span class="line-added">481     public void incrementUnsigned10() {</span>
<span class="line-added">482         testCounted(&quot;incrementUnsignedSnippet&quot;, Integer.MAX_VALUE - 1, Integer.MAX_VALUE + 10, 2);</span>
<span class="line-added">483     }</span>
<span class="line-added">484 </span>
<span class="line-added">485     public static Result decrementUnsignedSnippet(int start, int limit, int step) {</span>
<span class="line-added">486         int dec = ((step - 1) &amp; 0xFFFF) + 1; // make sure this value is always strictly positive</span>
<span class="line-added">487         Result ret = new Result();</span>
<span class="line-added">488         int i;</span>
<span class="line-added">489         for (i = start; Integer.compareUnsigned(i, limit) &gt; 0; i -= dec) {</span>
<span class="line-added">490             GraalDirectives.controlFlowAnchor();</span>
<span class="line-added">491             ret.extremum = get(InductionVariable::extremumNode, InductionVariable::constantExtremum, InductionVariable::isConstantExtremum, i);</span>
<span class="line-added">492         }</span>
<span class="line-added">493         ret.exitValue = get(InductionVariable::exitValueNode, i);</span>
<span class="line-added">494         return ret;</span>
<span class="line-added">495     }</span>
<span class="line-added">496 </span>
<span class="line-added">497     @Test</span>
<span class="line-added">498     public void decrementUnsigned1() {</span>
<span class="line-added">499         testCounted(&quot;decrementUnsignedSnippet&quot;, 256, 0, 1);</span>
<span class="line-added">500     }</span>
<span class="line-added">501 </span>
<span class="line-added">502     @Test</span>
<span class="line-added">503     public void decrementUnsigned2() {</span>
<span class="line-added">504         testCounted(&quot;decrementUnsignedSnippet&quot;, 256, 0, 2);</span>
<span class="line-added">505     }</span>
<span class="line-added">506 </span>
<span class="line-added">507     @Test</span>
<span class="line-added">508     public void decrementUnsigned3() {</span>
<span class="line-added">509         testCounted(&quot;decrementUnsignedSnippet&quot;, 256, 2, 3);</span>
<span class="line-added">510     }</span>
<span class="line-added">511 </span>
<span class="line-added">512     @Test</span>
<span class="line-added">513     public void decrementUnsigned5() {</span>
<span class="line-added">514         testRemovableCounted(&quot;decrementUnsignedSnippet&quot;, 256, 256, 1);</span>
<span class="line-added">515     }</span>
<span class="line-added">516 </span>
<span class="line-added">517     @Test</span>
<span class="line-added">518     public void decrementUnsigned6() {</span>
<span class="line-added">519         testRemovableCounted(&quot;decrementUnsignedSnippet&quot;, 256, 257, 1);</span>
<span class="line-added">520     }</span>
<span class="line-added">521 </span>
<span class="line-added">522     @Test</span>
<span class="line-added">523     public void decrementUnsigned7() {</span>
<span class="line-added">524         testCounted(&quot;decrementUnsignedSnippet&quot;, Integer.MAX_VALUE + 10, 0, 1);</span>
<span class="line-added">525     }</span>
<span class="line-added">526 </span>
<span class="line-added">527     @Test</span>
<span class="line-added">528     public void decrementUnsigned8() {</span>
<span class="line-added">529         testCounted(&quot;decrementUnsignedSnippet&quot;, Integer.MAX_VALUE + 11, 0, 2);</span>
<span class="line-added">530     }</span>
<span class="line-added">531 </span>
<span class="line-added">532     @Test</span>
<span class="line-added">533     public void decrementUnsigned9() {</span>
<span class="line-added">534         testCounted(&quot;decrementUnsignedSnippet&quot;, Integer.MAX_VALUE + 10, Integer.MAX_VALUE - 1, 1);</span>
<span class="line-added">535     }</span>
<span class="line-added">536 </span>
<span class="line-added">537     @Test</span>
<span class="line-added">538     public void decrementUnsigned10() {</span>
<span class="line-added">539         testCounted(&quot;decrementUnsignedSnippet&quot;, Integer.MAX_VALUE + 10, Integer.MAX_VALUE - 1, 2);</span>
540     }
541 
542     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
543     private static class IVPropertyNode extends FloatingNode implements LIRLowerable {

544         public static final NodeClass&lt;IVPropertyNode&gt; TYPE = NodeClass.create(IVPropertyNode.class);
545 
546         private final IVProperty property;
547         private final StaticIVProperty staticProperty;
548         private final IVPredicate staticCheck;
<span class="line-added">549         private final boolean loopCanBeRemoved;</span>
550         @Input private ValueNode iv;
551 
<span class="line-modified">552         protected IVPropertyNode(IVProperty property, StaticIVProperty staticProperty, IVPredicate staticCheck, ValueNode iv, boolean loopCanBeRemoved) {</span>
553             super(TYPE, iv.stamp(NodeView.DEFAULT).unrestricted());
554             this.property = property;
555             this.staticProperty = staticProperty;
556             this.staticCheck = staticCheck;
557             this.iv = iv;
<span class="line-added">558             this.loopCanBeRemoved = loopCanBeRemoved;</span>
559         }
560 
561         public void rewrite(LoopsData loops) {
<span class="line-modified">562             InductionVariable inductionVariable = loops.getInductionVariable(GraphUtil.unproxify(iv));</span>


563             ValueNode node = null;
<span class="line-modified">564             if (inductionVariable == null) {</span>
<span class="line-modified">565                 assert loopCanBeRemoved;</span>
<span class="line-modified">566                 assert loops.loops().isEmpty();</span>
<span class="line-modified">567                 node = iv;</span>
<span class="line-added">568             } else {</span>
<span class="line-added">569                 assertTrue(inductionVariable.getLoop().isCounted(), &quot;must be counted&quot;);</span>
<span class="line-added">570                 if (staticCheck != null) {</span>
<span class="line-added">571                     assert staticProperty != null;</span>
<span class="line-added">572                     if (staticCheck.test(inductionVariable)) {</span>
<span class="line-added">573                         node = ConstantNode.forLong(staticProperty.get(inductionVariable), graph());</span>
<span class="line-added">574                     }</span>
<span class="line-added">575                 }</span>
<span class="line-added">576                 if (node == null) {</span>
<span class="line-added">577                     node = property.get(inductionVariable);</span>
578                 }



579             }
580             replaceAtUsagesAndDelete(node);
581         }
582 
583         @Override
584         public void generate(NodeLIRBuilderTool gen) {
585             gen.setResult(this, gen.operand(iv));
586         }
587     }
588 
589     @Override
590     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
591         Registration r = new Registration(invocationPlugins, CountedLoopTest.class);
592         registerPlugins(r, JavaKind.Int);
593         registerPlugins(r, JavaKind.Long);
594         super.registerInvocationPlugins(invocationPlugins);
595     }
596 
597     private void registerPlugins(Registration r, JavaKind ivKind) {
598         r.register2(&quot;get&quot;, IVProperty.class, ivKind.toJavaClass(), new InvocationPlugin() {
599             @Override
600             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2) {
601                 IVProperty property = null;
602                 if (arg1.isConstant()) {
603                     property = getSnippetReflection().asObject(IVProperty.class, arg1.asJavaConstant());
604                 }
605                 if (property != null) {
<span class="line-modified">606                     b.addPush(ivKind, new IVPropertyNode(property, null, null, arg2, loopCanBeRemoved));</span>
607                     return true;
608                 } else {
609                     return false;
610                 }
611             }
612         });
613         r.register4(&quot;get&quot;, IVProperty.class, StaticIVProperty.class, IVPredicate.class, ivKind.toJavaClass(), new InvocationPlugin() {
614             @Override
615             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3, ValueNode arg4) {
616                 IVProperty property = null;
617                 StaticIVProperty staticProperty = null;
618                 IVPredicate staticCheck = null;
619                 if (arg1.isConstant()) {
620                     property = getSnippetReflection().asObject(IVProperty.class, arg1.asJavaConstant());
621                 }
622                 if (arg2.isConstant()) {
623                     staticProperty = getSnippetReflection().asObject(StaticIVProperty.class, arg2.asJavaConstant());
624                 }
625                 if (arg3.isConstant()) {
626                     staticCheck = getSnippetReflection().asObject(IVPredicate.class, arg3.asJavaConstant());
627                 }
628                 if (property != null &amp;&amp; staticProperty != null &amp;&amp; staticCheck != null) {
<span class="line-modified">629                     b.addPush(ivKind, new IVPropertyNode(property, staticProperty, staticCheck, arg4, loopCanBeRemoved));</span>
630                     return true;
631                 } else {
632                     return false;
633                 }
634             }
635         });
636     }
637 
638     @Override
<span class="line-modified">639     protected void checkHighTierGraph(StructuredGraph graph) {</span>
640         LoopsData loops = new LoopsData(graph);
641         loops.detectedCountedLoops();
642         for (IVPropertyNode node : graph.getNodes().filter(IVPropertyNode.class)) {
643             node.rewrite(loops);
644         }
645         assert graph.getNodes().filter(IVPropertyNode.class).isEmpty();

646     }
647 
648     @Override
<span class="line-modified">649     protected OptimisticOptimizations getOptimisticOptimizations() {</span>
650         // Don&#39;t convert unreached paths into Guard
<span class="line-modified">651         return OptimisticOptimizations.ALL.remove(OptimisticOptimizations.Optimization.RemoveNeverExecutedCode);</span>
652     }
653 
654     private Object[] argsToBind;
<span class="line-added">655     private boolean loopCanBeRemoved;</span>
656 
657     @Override
658     protected Object[] getArgumentToBind() {
659         return argsToBind;
660     }
661 
662     public void testCounted(String snippetName, Object... args) {
<span class="line-added">663         this.loopCanBeRemoved = false;</span>
<span class="line-added">664         test(snippetName, args);</span>
<span class="line-added">665         this.argsToBind = args;</span>
<span class="line-added">666         test(snippetName, args);</span>
<span class="line-added">667         this.argsToBind = null;</span>
<span class="line-added">668     }</span>
<span class="line-added">669 </span>
<span class="line-added">670     public void testCounted(String snippetName, Object start, Object limit, Object step) {</span>
<span class="line-added">671         testCounted(false, snippetName, start, limit, step);</span>
<span class="line-added">672     }</span>
<span class="line-added">673 </span>
<span class="line-added">674     public void testRemovableCounted(String snippetName, Object start, Object limit, Object step) {</span>
<span class="line-added">675         testCounted(true, snippetName, start, limit, step);</span>
<span class="line-added">676     }</span>
<span class="line-added">677 </span>
<span class="line-added">678     public void testCounted(boolean removable, String snippetName, Object start, Object limit, Object step) {</span>
<span class="line-added">679         this.loopCanBeRemoved = removable;</span>
<span class="line-added">680         Object[] args = {start, limit, step};</span>
<span class="line-added">681         test(snippetName, args);</span>
<span class="line-added">682         this.argsToBind = args;</span>
<span class="line-added">683         test(snippetName, args);</span>
<span class="line-added">684         this.argsToBind = new Object[]{NO_BIND, NO_BIND, step};</span>
685         test(snippetName, args);
<span class="line-modified">686         this.argsToBind = new Object[]{start, NO_BIND, step};</span>
687         test(snippetName, args);
<span class="line-modified">688         this.argsToBind = null;</span>
<span class="line-added">689         this.loopCanBeRemoved = false;</span>
690     }
691 }
</pre>
</td>
</tr>
</table>
<center><a href="CopyOfVirtualizationTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CustomizedBytecodePatternTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
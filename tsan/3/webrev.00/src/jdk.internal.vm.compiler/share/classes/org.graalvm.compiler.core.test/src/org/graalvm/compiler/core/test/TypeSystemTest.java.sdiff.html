<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/TypeSystemTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SwitchDyingLoopTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="TypeWriterTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/TypeSystemTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import java.io.BufferedInputStream;
 28 import java.io.ByteArrayInputStream;
 29 import java.io.FileInputStream;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 
 33 import org.graalvm.compiler.debug.DebugContext;
 34 import org.graalvm.compiler.debug.TTY;
 35 import org.graalvm.compiler.graph.Node;
 36 import org.graalvm.compiler.nodeinfo.Verbosity;
 37 import org.graalvm.compiler.nodes.AbstractMergeNode;
 38 import org.graalvm.compiler.nodes.PhiNode;
 39 import org.graalvm.compiler.nodes.StructuredGraph;
 40 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 41 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 42 import org.graalvm.compiler.nodes.cfg.Block;
 43 import org.graalvm.compiler.nodes.java.InstanceOfNode;
<span class="line-removed"> 44 import org.graalvm.compiler.phases.common.CanonicalizerPhase;</span>
 45 import org.graalvm.compiler.phases.common.ConditionalEliminationPhase;
 46 import org.graalvm.compiler.phases.schedule.SchedulePhase;
<span class="line-removed"> 47 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 48 import org.junit.Assert;
 49 import org.junit.Ignore;
 50 import org.junit.Test;
 51 
 52 /**
 53  * In the following tests, the scalar type system of the compiler should be complete enough to see
 54  * the relation between the different conditions.
 55  */
 56 public class TypeSystemTest extends GraalCompilerTest {
 57 
 58     @Test
 59     public void test3() {
 60         test(&quot;test3Snippet&quot;, &quot;referenceSnippet3&quot;);
 61     }
 62 
 63     public static int referenceSnippet3(Object o) {
 64         if (o == null) {
 65             return 1;
 66         } else {
 67             return 2;
</pre>
<hr />
<pre>
171         test(&quot;test7Snippet&quot;, &quot;referenceSnippet7&quot;);
172     }
173 
174     public static int test7Snippet(int x) {
175         return ((x &amp; 0xff) &lt;&lt; 10) == ((x &amp; 0x1f) + 1) ? 0 : x;
176     }
177 
178     public static int referenceSnippet7(int x) {
179         return x;
180     }
181 
182     private void test(String snippet, String referenceSnippet) {
183         StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO);
184         DebugContext debug = graph.getDebug();
185         debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;Graph&quot;);
186         /*
187          * When using FlowSensitiveReductionPhase instead of ConditionalEliminationPhase,
188          * tail-duplication gets activated thus resulting in a graph with more nodes than the
189          * reference graph.
190          */
<span class="line-modified">191         new ConditionalEliminationPhase(false).apply(graph, new PhaseContext(getProviders()));</span>
<span class="line-modified">192         new CanonicalizerPhase().apply(graph, new PhaseContext(getProviders()));</span>
193         // a second canonicalizer is needed to process nested MaterializeNodes
<span class="line-modified">194         new CanonicalizerPhase().apply(graph, new PhaseContext(getProviders()));</span>
195         StructuredGraph referenceGraph = parseEager(referenceSnippet, AllowAssumptions.NO);
<span class="line-modified">196         new ConditionalEliminationPhase(false).apply(referenceGraph, new PhaseContext(getProviders()));</span>
<span class="line-modified">197         new CanonicalizerPhase().apply(referenceGraph, new PhaseContext(getProviders()));</span>
<span class="line-modified">198         new CanonicalizerPhase().apply(referenceGraph, new PhaseContext(getProviders()));</span>
199         assertEquals(referenceGraph, graph);
200     }
201 
202     @Override
203     protected void assertEquals(StructuredGraph expected, StructuredGraph graph) {
204         DebugContext debug = graph.getDebug();
205         if (getNodeCountExcludingUnusedConstants(expected) != getNodeCountExcludingUnusedConstants(graph)) {
206             debug.dump(DebugContext.BASIC_LEVEL, expected, &quot;expected (node count)&quot;);
207             debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;graph (node count)&quot;);
208             Assert.fail(&quot;Graphs do not have the same number of nodes: &quot; + expected.getNodeCount() + &quot; vs. &quot; + graph.getNodeCount());
209         }
210     }
211 
212     public static void outputGraph(StructuredGraph graph, String message) {
213         TTY.println(&quot;========================= &quot; + message);
214         SchedulePhase schedulePhase = new SchedulePhase(graph.getOptions());
215         schedulePhase.apply(graph);
216         ScheduleResult schedule = graph.getLastSchedule();
217         for (Block block : schedule.getCFG().getBlocks()) {
218             TTY.print(&quot;Block &quot; + block + &quot; &quot;);
</pre>
<hr />
<pre>
228                 outputNode(node);
229             }
230         }
231     }
232 
233     private static void outputNode(Node node) {
234         TTY.print(&quot;  &quot; + node + &quot;    (usage count: &quot; + node.getUsageCount() + &quot;) (inputs:&quot;);
235         for (Node input : node.inputs()) {
236             TTY.print(&quot; &quot; + input.toString(Verbosity.Id));
237         }
238         TTY.println(&quot;)&quot;);
239         if (node instanceof AbstractMergeNode) {
240             for (PhiNode phi : ((AbstractMergeNode) node).phis()) {
241                 outputNode(phi);
242             }
243         }
244     }
245 
246     private &lt;T extends Node&gt; void testHelper(String snippet, Class&lt;T&gt; clazz) {
247         StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO);
<span class="line-modified">248         new CanonicalizerPhase().apply(graph, new PhaseContext(getProviders()));</span>
<span class="line-modified">249         new CanonicalizerPhase().apply(graph, new PhaseContext(getProviders()));</span>
250         DebugContext debug = graph.getDebug();
251         debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;Graph &quot; + snippet);
252         Assert.assertFalse(&quot;shouldn&#39;t have nodes of type &quot; + clazz, graph.getNodes().filter(clazz).iterator().hasNext());
253     }
254 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import java.io.BufferedInputStream;
 28 import java.io.ByteArrayInputStream;
 29 import java.io.FileInputStream;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 
 33 import org.graalvm.compiler.debug.DebugContext;
 34 import org.graalvm.compiler.debug.TTY;
 35 import org.graalvm.compiler.graph.Node;
 36 import org.graalvm.compiler.nodeinfo.Verbosity;
 37 import org.graalvm.compiler.nodes.AbstractMergeNode;
 38 import org.graalvm.compiler.nodes.PhiNode;
 39 import org.graalvm.compiler.nodes.StructuredGraph;
 40 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 41 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 42 import org.graalvm.compiler.nodes.cfg.Block;
 43 import org.graalvm.compiler.nodes.java.InstanceOfNode;

 44 import org.graalvm.compiler.phases.common.ConditionalEliminationPhase;
 45 import org.graalvm.compiler.phases.schedule.SchedulePhase;

 46 import org.junit.Assert;
 47 import org.junit.Ignore;
 48 import org.junit.Test;
 49 
 50 /**
 51  * In the following tests, the scalar type system of the compiler should be complete enough to see
 52  * the relation between the different conditions.
 53  */
 54 public class TypeSystemTest extends GraalCompilerTest {
 55 
 56     @Test
 57     public void test3() {
 58         test(&quot;test3Snippet&quot;, &quot;referenceSnippet3&quot;);
 59     }
 60 
 61     public static int referenceSnippet3(Object o) {
 62         if (o == null) {
 63             return 1;
 64         } else {
 65             return 2;
</pre>
<hr />
<pre>
169         test(&quot;test7Snippet&quot;, &quot;referenceSnippet7&quot;);
170     }
171 
172     public static int test7Snippet(int x) {
173         return ((x &amp; 0xff) &lt;&lt; 10) == ((x &amp; 0x1f) + 1) ? 0 : x;
174     }
175 
176     public static int referenceSnippet7(int x) {
177         return x;
178     }
179 
180     private void test(String snippet, String referenceSnippet) {
181         StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO);
182         DebugContext debug = graph.getDebug();
183         debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;Graph&quot;);
184         /*
185          * When using FlowSensitiveReductionPhase instead of ConditionalEliminationPhase,
186          * tail-duplication gets activated thus resulting in a graph with more nodes than the
187          * reference graph.
188          */
<span class="line-modified">189         new ConditionalEliminationPhase(false).apply(graph, getProviders());</span>
<span class="line-modified">190         createCanonicalizerPhase().apply(graph, getProviders());</span>
191         // a second canonicalizer is needed to process nested MaterializeNodes
<span class="line-modified">192         createCanonicalizerPhase().apply(graph, getProviders());</span>
193         StructuredGraph referenceGraph = parseEager(referenceSnippet, AllowAssumptions.NO);
<span class="line-modified">194         new ConditionalEliminationPhase(false).apply(referenceGraph, getProviders());</span>
<span class="line-modified">195         this.createCanonicalizerPhase().apply(referenceGraph, getProviders());</span>
<span class="line-modified">196         this.createCanonicalizerPhase().apply(referenceGraph, getProviders());</span>
197         assertEquals(referenceGraph, graph);
198     }
199 
200     @Override
201     protected void assertEquals(StructuredGraph expected, StructuredGraph graph) {
202         DebugContext debug = graph.getDebug();
203         if (getNodeCountExcludingUnusedConstants(expected) != getNodeCountExcludingUnusedConstants(graph)) {
204             debug.dump(DebugContext.BASIC_LEVEL, expected, &quot;expected (node count)&quot;);
205             debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;graph (node count)&quot;);
206             Assert.fail(&quot;Graphs do not have the same number of nodes: &quot; + expected.getNodeCount() + &quot; vs. &quot; + graph.getNodeCount());
207         }
208     }
209 
210     public static void outputGraph(StructuredGraph graph, String message) {
211         TTY.println(&quot;========================= &quot; + message);
212         SchedulePhase schedulePhase = new SchedulePhase(graph.getOptions());
213         schedulePhase.apply(graph);
214         ScheduleResult schedule = graph.getLastSchedule();
215         for (Block block : schedule.getCFG().getBlocks()) {
216             TTY.print(&quot;Block &quot; + block + &quot; &quot;);
</pre>
<hr />
<pre>
226                 outputNode(node);
227             }
228         }
229     }
230 
231     private static void outputNode(Node node) {
232         TTY.print(&quot;  &quot; + node + &quot;    (usage count: &quot; + node.getUsageCount() + &quot;) (inputs:&quot;);
233         for (Node input : node.inputs()) {
234             TTY.print(&quot; &quot; + input.toString(Verbosity.Id));
235         }
236         TTY.println(&quot;)&quot;);
237         if (node instanceof AbstractMergeNode) {
238             for (PhiNode phi : ((AbstractMergeNode) node).phis()) {
239                 outputNode(phi);
240             }
241         }
242     }
243 
244     private &lt;T extends Node&gt; void testHelper(String snippet, Class&lt;T&gt; clazz) {
245         StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO);
<span class="line-modified">246         createCanonicalizerPhase().apply(graph, getProviders());</span>
<span class="line-modified">247         createCanonicalizerPhase().apply(graph, getProviders());</span>
248         DebugContext debug = graph.getDebug();
249         debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;Graph &quot; + snippet);
250         Assert.assertFalse(&quot;shouldn&#39;t have nodes of type &quot; + clazz, graph.getNodes().filter(clazz).iterator().hasNext());
251     }
252 }
</pre>
</td>
</tr>
</table>
<center><a href="SwitchDyingLoopTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="TypeWriterTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
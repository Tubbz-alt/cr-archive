<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/NodePropertiesTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NewInstanceTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="OptionsVerifierTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/NodePropertiesTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import org.graalvm.compiler.api.directives.GraalDirectives;
 28 import org.graalvm.compiler.graph.Node;
 29 import org.graalvm.compiler.graph.iterators.NodeIterable;
 30 import org.graalvm.compiler.graph.spi.Canonicalizable;
 31 import org.graalvm.compiler.graph.spi.SimplifierTool;
 32 import org.graalvm.compiler.java.ComputeLoopFrequenciesClosure;
 33 import org.graalvm.compiler.nodes.LoopBeginNode;
 34 import org.graalvm.compiler.nodes.StructuredGraph;
 35 import org.graalvm.compiler.nodes.ValueNode;

 36 import org.graalvm.compiler.phases.BasePhase;
 37 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
<span class="line-modified"> 38 import org.graalvm.compiler.phases.common.CanonicalizerPhase.CustomCanonicalizer;</span>
 39 import org.graalvm.compiler.phases.contract.NodeCostUtil;
 40 import org.graalvm.compiler.phases.tiers.HighTierContext;
<span class="line-removed"> 41 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 42 import org.junit.Assert;
 43 import org.junit.Test;
 44 
 45 public class NodePropertiesTest extends GraalCompilerTest {
 46 
 47     public static Object sideEffect;
 48 
 49     public static Object[] array = new Object[]{new Object(), new Object(), new Object()};
 50 
 51     public static int test1Snippet(int a) {
 52         int x = 0;
 53         if (a &gt; 0) {
 54             x = 1;
 55             sideEffect = null;
 56         } else {
 57             x = 2;
 58             sideEffect = null;
 59         }
 60         int b = 4;
 61         sideEffect = null;
</pre>
<hr />
<pre>
145         return array[a].hashCode();
146     }
147 
148     public static int arrayStoreTest(int a) {
149         array[2] = a;
150         return a;
151     }
152 
153     public static int fieldLoad(int a) {
154         return sideEffect.hashCode() * a;
155     }
156 
157     public static int fieldStore(int a) {
158         sideEffect = a;
159         return a;
160     }
161 
162     @Test
163     public void testCanonicalizationExample() {
164         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">165         ImprovementSavingCanonicalizer c1 = new ImprovementSavingCanonicalizer();</span>
166         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;test1Snippet&quot;));
<span class="line-modified">167         new CanonicalizerPhase(c1).apply(g1, htc);</span>
<span class="line-modified">168         ImprovementSavingCanonicalizer c2 = new ImprovementSavingCanonicalizer();</span>

169         StructuredGraph g2 = parseForCompile(getResolvedJavaMethod(&quot;test2Snippet&quot;));
<span class="line-modified">170         new CanonicalizerPhase(c2).apply(g2, htc);</span>

171         Assert.assertEquals(0, c1.savedCycles);
172         Assert.assertEquals(0, c2.savedCycles);
173     }
174 
<span class="line-modified">175     private static void prepareGraphForLoopFrequencies(StructuredGraph g, HighTierContext htc) {</span>
176         // let canonicalizer work away branch probability nodes
<span class="line-modified">177         new CanonicalizerPhase().apply(g, htc);</span>
178         // recompute the loop frequencies
179         ComputeLoopFrequenciesClosure.compute(g);
180     }
181 
182     private static void assertFrequency(StructuredGraph g, int iterations) {
183         NodeIterable&lt;LoopBeginNode&gt; loopBeginNodes = g.getNodes(LoopBeginNode.TYPE);
184         LoopBeginNode loopBeginNode = loopBeginNodes.first();
185         Assert.assertEquals(&quot;loop frequency of &quot; + loopBeginNode, iterations, loopBeginNode.loopFrequency(), 0);
186     }
187 
188     @Test
189     public void testDifferentLoopFaster() {
190         HighTierContext htc = getDefaultHighTierContext();
191         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;testLoop01&quot;));
192         StructuredGraph g2 = parseForCompile(getResolvedJavaMethod(&quot;testLoop03&quot;));
193         prepareGraphForLoopFrequencies(g1, htc);
194         prepareGraphForLoopFrequencies(g2, htc);
195         assertFrequency(g1, ITERATIONS_LOOP_1);
196         assertFrequency(g2, ITERATIONS_LOOP_1);
197         GraphCostPhase gc1 = new GraphCostPhase();
</pre>
<hr />
<pre>
225     public void testDifferentLoopsInnerOuter() {
226         HighTierContext htc = getDefaultHighTierContext();
227         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;testLoop04&quot;));
228         StructuredGraph g2 = parseForCompile(getResolvedJavaMethod(&quot;testLoop05&quot;));
229         prepareGraphForLoopFrequencies(g1, htc);
230         prepareGraphForLoopFrequencies(g2, htc);
231         assertFrequency(g1, ITERATIONS_LOOP_1 * ITERATIONS_LOOP_2);
232         GraphCostPhase gc1 = new GraphCostPhase();
233         GraphCostPhase gc2 = new GraphCostPhase();
234         gc1.apply(g1, htc);
235         gc2.apply(g2, htc);
236         g1.getDebug().log(&quot;Test testDifferentLoopsInnerOuter --&gt; 1.Graph cycles:%f size:%f vs. 2.Graph cycles:%f size:%f\n&quot;, gc1.finalCycles, gc1.finalSize, gc2.finalCycles, gc2.finalSize);
237         Assert.assertTrue(gc2.finalSize &gt; gc1.finalSize);
238     }
239 
240     @Test
241     public void testGraphCost() {
242         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;test1Snippet&quot;));
243         StructuredGraph g2 = parseForCompile(getResolvedJavaMethod(&quot;test2Snippet&quot;));
244         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">245         new CanonicalizerPhase().apply(g1, htc);</span>
<span class="line-modified">246         new CanonicalizerPhase().apply(g2, htc);</span>
247         GraphCostPhase gc1 = new GraphCostPhase();
248         GraphCostPhase gc2 = new GraphCostPhase();
249         gc1.apply(g1, htc);
250         gc2.apply(g2, htc);
251         g1.getDebug().log(&quot;Test Graph Cost --&gt; 1.Graph cost:%f vs. 2.Graph cost:%f\n&quot;, gc1.finalCycles, gc2.finalCycles);
252         Assert.assertTrue(gc2.finalCycles &gt; gc1.finalCycles);
253         Assert.assertTrue(gc2.finalSize == gc1.finalSize);
254     }
255 
256     @Test
257     public void testExpectUntrusted() {
258         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;untrused01&quot;));
259         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">260         new CanonicalizerPhase().apply(g1, htc);</span>
261         GraphCostPhase gc1 = new GraphCostPhase();
262         gc1.apply(g1, htc);
263     }
264 
265     @Test
266     public void testArrayLoad() {
267         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;arrayLoadTest&quot;));
268         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">269         new CanonicalizerPhase().apply(g1, htc);</span>
270         GraphCostPhase gc1 = new GraphCostPhase();
271         gc1.apply(g1, htc);
272         Assert.assertEquals(15, gc1.finalCycles, 25);
273     }
274 
275     @Test
276     public void testArrayStore() {
277         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;arrayStoreTest&quot;));
278         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">279         new CanonicalizerPhase().apply(g1, htc);</span>
280         GraphCostPhase gc1 = new GraphCostPhase();
281         gc1.apply(g1, htc);
282         Assert.assertEquals(15, gc1.finalCycles, 25);
283     }
284 
285     @Test
286     public void testFieldLoad() {
287         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;fieldLoad&quot;));
288         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">289         new CanonicalizerPhase().apply(g1, htc);</span>
290         GraphCostPhase gc1 = new GraphCostPhase();
291         gc1.apply(g1, htc);
292         Assert.assertEquals(15, gc1.finalCycles, 25);
293     }
294 
295     @Test
296     public void testFieldStore() {
297         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;fieldStore&quot;));
298         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">299         new CanonicalizerPhase().apply(g1, htc);</span>
300         GraphCostPhase gc1 = new GraphCostPhase();
301         gc1.apply(g1, htc);
302         Assert.assertEquals(15, gc1.finalCycles, 25);
303     }
304 
<span class="line-modified">305     static class ImprovementSavingCanonicalizer extends CustomCanonicalizer {</span>
306         private int savedCycles;
307 
308         @Override
309         public void simplify(Node node, SimplifierTool tool) {
310             if (node instanceof Canonicalizable.Binary&lt;?&gt;) {
311                 @SuppressWarnings(&quot;unchecked&quot;)
312                 Canonicalizable.Binary&lt;ValueNode&gt; bc = (Canonicalizable.Binary&lt;ValueNode&gt;) node;
313                 Node canonicalized = bc.canonical(tool, bc.getX(), bc.getY());
314                 if (canonicalized != node) {
315                     savedCycles += node.estimatedNodeCycles().value - canonicalized.estimatedNodeCycles().value;
316                 }
317             }
318         }
319     }
320 
<span class="line-modified">321     private static class GraphCostPhase extends BasePhase&lt;PhaseContext&gt; {</span>
322         private double finalCycles;
323         private double finalSize;
324 
325         @Override
<span class="line-modified">326         protected void run(StructuredGraph graph, PhaseContext context) {</span>
327             finalCycles = NodeCostUtil.computeGraphCycles(graph, true);
328             finalSize = NodeCostUtil.computeGraphSize(graph);
329         }
330 
331     }
332 
333 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import org.graalvm.compiler.api.directives.GraalDirectives;
 28 import org.graalvm.compiler.graph.Node;
 29 import org.graalvm.compiler.graph.iterators.NodeIterable;
 30 import org.graalvm.compiler.graph.spi.Canonicalizable;
 31 import org.graalvm.compiler.graph.spi.SimplifierTool;
 32 import org.graalvm.compiler.java.ComputeLoopFrequenciesClosure;
 33 import org.graalvm.compiler.nodes.LoopBeginNode;
 34 import org.graalvm.compiler.nodes.StructuredGraph;
 35 import org.graalvm.compiler.nodes.ValueNode;
<span class="line-added"> 36 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 37 import org.graalvm.compiler.phases.BasePhase;
 38 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
<span class="line-modified"> 39 import org.graalvm.compiler.phases.common.CanonicalizerPhase.CustomSimplification;</span>
 40 import org.graalvm.compiler.phases.contract.NodeCostUtil;
 41 import org.graalvm.compiler.phases.tiers.HighTierContext;

 42 import org.junit.Assert;
 43 import org.junit.Test;
 44 
 45 public class NodePropertiesTest extends GraalCompilerTest {
 46 
 47     public static Object sideEffect;
 48 
 49     public static Object[] array = new Object[]{new Object(), new Object(), new Object()};
 50 
 51     public static int test1Snippet(int a) {
 52         int x = 0;
 53         if (a &gt; 0) {
 54             x = 1;
 55             sideEffect = null;
 56         } else {
 57             x = 2;
 58             sideEffect = null;
 59         }
 60         int b = 4;
 61         sideEffect = null;
</pre>
<hr />
<pre>
145         return array[a].hashCode();
146     }
147 
148     public static int arrayStoreTest(int a) {
149         array[2] = a;
150         return a;
151     }
152 
153     public static int fieldLoad(int a) {
154         return sideEffect.hashCode() * a;
155     }
156 
157     public static int fieldStore(int a) {
158         sideEffect = a;
159         return a;
160     }
161 
162     @Test
163     public void testCanonicalizationExample() {
164         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">165         ImprovementSavingCalculator c1 = new ImprovementSavingCalculator();</span>
166         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;test1Snippet&quot;));
<span class="line-modified">167         CanonicalizerPhase canonicalizer1 = this.createCanonicalizerPhase().copyWithCustomSimplification(c1);</span>
<span class="line-modified">168         canonicalizer1.apply(g1, htc);</span>
<span class="line-added">169         ImprovementSavingCalculator c2 = new ImprovementSavingCalculator();</span>
170         StructuredGraph g2 = parseForCompile(getResolvedJavaMethod(&quot;test2Snippet&quot;));
<span class="line-modified">171         CanonicalizerPhase canonicalizer2 = this.createCanonicalizerPhase().copyWithCustomSimplification(c2);</span>
<span class="line-added">172         canonicalizer2.apply(g2, htc);</span>
173         Assert.assertEquals(0, c1.savedCycles);
174         Assert.assertEquals(0, c2.savedCycles);
175     }
176 
<span class="line-modified">177     private void prepareGraphForLoopFrequencies(StructuredGraph g, HighTierContext htc) {</span>
178         // let canonicalizer work away branch probability nodes
<span class="line-modified">179         createCanonicalizerPhase().apply(g, htc);</span>
180         // recompute the loop frequencies
181         ComputeLoopFrequenciesClosure.compute(g);
182     }
183 
184     private static void assertFrequency(StructuredGraph g, int iterations) {
185         NodeIterable&lt;LoopBeginNode&gt; loopBeginNodes = g.getNodes(LoopBeginNode.TYPE);
186         LoopBeginNode loopBeginNode = loopBeginNodes.first();
187         Assert.assertEquals(&quot;loop frequency of &quot; + loopBeginNode, iterations, loopBeginNode.loopFrequency(), 0);
188     }
189 
190     @Test
191     public void testDifferentLoopFaster() {
192         HighTierContext htc = getDefaultHighTierContext();
193         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;testLoop01&quot;));
194         StructuredGraph g2 = parseForCompile(getResolvedJavaMethod(&quot;testLoop03&quot;));
195         prepareGraphForLoopFrequencies(g1, htc);
196         prepareGraphForLoopFrequencies(g2, htc);
197         assertFrequency(g1, ITERATIONS_LOOP_1);
198         assertFrequency(g2, ITERATIONS_LOOP_1);
199         GraphCostPhase gc1 = new GraphCostPhase();
</pre>
<hr />
<pre>
227     public void testDifferentLoopsInnerOuter() {
228         HighTierContext htc = getDefaultHighTierContext();
229         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;testLoop04&quot;));
230         StructuredGraph g2 = parseForCompile(getResolvedJavaMethod(&quot;testLoop05&quot;));
231         prepareGraphForLoopFrequencies(g1, htc);
232         prepareGraphForLoopFrequencies(g2, htc);
233         assertFrequency(g1, ITERATIONS_LOOP_1 * ITERATIONS_LOOP_2);
234         GraphCostPhase gc1 = new GraphCostPhase();
235         GraphCostPhase gc2 = new GraphCostPhase();
236         gc1.apply(g1, htc);
237         gc2.apply(g2, htc);
238         g1.getDebug().log(&quot;Test testDifferentLoopsInnerOuter --&gt; 1.Graph cycles:%f size:%f vs. 2.Graph cycles:%f size:%f\n&quot;, gc1.finalCycles, gc1.finalSize, gc2.finalCycles, gc2.finalSize);
239         Assert.assertTrue(gc2.finalSize &gt; gc1.finalSize);
240     }
241 
242     @Test
243     public void testGraphCost() {
244         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;test1Snippet&quot;));
245         StructuredGraph g2 = parseForCompile(getResolvedJavaMethod(&quot;test2Snippet&quot;));
246         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">247         createCanonicalizerPhase().apply(g1, htc);</span>
<span class="line-modified">248         createCanonicalizerPhase().apply(g2, htc);</span>
249         GraphCostPhase gc1 = new GraphCostPhase();
250         GraphCostPhase gc2 = new GraphCostPhase();
251         gc1.apply(g1, htc);
252         gc2.apply(g2, htc);
253         g1.getDebug().log(&quot;Test Graph Cost --&gt; 1.Graph cost:%f vs. 2.Graph cost:%f\n&quot;, gc1.finalCycles, gc2.finalCycles);
254         Assert.assertTrue(gc2.finalCycles &gt; gc1.finalCycles);
255         Assert.assertTrue(gc2.finalSize == gc1.finalSize);
256     }
257 
258     @Test
259     public void testExpectUntrusted() {
260         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;untrused01&quot;));
261         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">262         createCanonicalizerPhase().apply(g1, htc);</span>
263         GraphCostPhase gc1 = new GraphCostPhase();
264         gc1.apply(g1, htc);
265     }
266 
267     @Test
268     public void testArrayLoad() {
269         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;arrayLoadTest&quot;));
270         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">271         createCanonicalizerPhase().apply(g1, htc);</span>
272         GraphCostPhase gc1 = new GraphCostPhase();
273         gc1.apply(g1, htc);
274         Assert.assertEquals(15, gc1.finalCycles, 25);
275     }
276 
277     @Test
278     public void testArrayStore() {
279         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;arrayStoreTest&quot;));
280         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">281         createCanonicalizerPhase().apply(g1, htc);</span>
282         GraphCostPhase gc1 = new GraphCostPhase();
283         gc1.apply(g1, htc);
284         Assert.assertEquals(15, gc1.finalCycles, 25);
285     }
286 
287     @Test
288     public void testFieldLoad() {
289         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;fieldLoad&quot;));
290         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">291         createCanonicalizerPhase().apply(g1, htc);</span>
292         GraphCostPhase gc1 = new GraphCostPhase();
293         gc1.apply(g1, htc);
294         Assert.assertEquals(15, gc1.finalCycles, 25);
295     }
296 
297     @Test
298     public void testFieldStore() {
299         StructuredGraph g1 = parseForCompile(getResolvedJavaMethod(&quot;fieldStore&quot;));
300         HighTierContext htc = getDefaultHighTierContext();
<span class="line-modified">301         createCanonicalizerPhase().apply(g1, htc);</span>
302         GraphCostPhase gc1 = new GraphCostPhase();
303         gc1.apply(g1, htc);
304         Assert.assertEquals(15, gc1.finalCycles, 25);
305     }
306 
<span class="line-modified">307     static class ImprovementSavingCalculator implements CustomSimplification {</span>
308         private int savedCycles;
309 
310         @Override
311         public void simplify(Node node, SimplifierTool tool) {
312             if (node instanceof Canonicalizable.Binary&lt;?&gt;) {
313                 @SuppressWarnings(&quot;unchecked&quot;)
314                 Canonicalizable.Binary&lt;ValueNode&gt; bc = (Canonicalizable.Binary&lt;ValueNode&gt;) node;
315                 Node canonicalized = bc.canonical(tool, bc.getX(), bc.getY());
316                 if (canonicalized != node) {
317                     savedCycles += node.estimatedNodeCycles().value - canonicalized.estimatedNodeCycles().value;
318                 }
319             }
320         }
321     }
322 
<span class="line-modified">323     private static class GraphCostPhase extends BasePhase&lt;CoreProviders&gt; {</span>
324         private double finalCycles;
325         private double finalSize;
326 
327         @Override
<span class="line-modified">328         protected void run(StructuredGraph graph, CoreProviders context) {</span>
329             finalCycles = NodeCostUtil.computeGraphCycles(graph, true);
330             finalSize = NodeCostUtil.computeGraphSize(graph);
331         }
332 
333     }
334 
335 }
</pre>
</td>
</tr>
</table>
<center><a href="NewInstanceTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="OptionsVerifierTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
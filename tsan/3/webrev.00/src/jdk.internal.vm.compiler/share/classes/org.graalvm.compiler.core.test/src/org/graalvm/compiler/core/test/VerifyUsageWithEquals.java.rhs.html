<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/VerifyUsageWithEquals.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.test;
 26 
 27 import org.graalvm.compiler.core.common.type.ObjectStamp;
 28 import org.graalvm.compiler.nodes.Invoke;
 29 import org.graalvm.compiler.nodes.NodeView;
 30 import org.graalvm.compiler.nodes.ParameterNode;
 31 import org.graalvm.compiler.nodes.StructuredGraph;
 32 import org.graalvm.compiler.nodes.ValueNode;
 33 import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
 34 import org.graalvm.compiler.nodes.java.LoadFieldNode;
<a name="2" id="anc2"></a><span class="line-added"> 35 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 36 import org.graalvm.compiler.nodes.spi.UncheckedInterfaceProvider;
 37 import org.graalvm.compiler.nodes.type.StampTool;
 38 import org.graalvm.compiler.phases.VerifyPhase;
<a name="3" id="anc3"></a>
 39 
 40 import jdk.vm.ci.meta.JavaField;
 41 import jdk.vm.ci.meta.JavaKind;
 42 import jdk.vm.ci.meta.JavaMethod;
 43 import jdk.vm.ci.meta.JavaType;
 44 import jdk.vm.ci.meta.MetaAccessProvider;
 45 import jdk.vm.ci.meta.ResolvedJavaMethod;
 46 import jdk.vm.ci.meta.ResolvedJavaType;
 47 import jdk.vm.ci.meta.Signature;
 48 
 49 /**
 50  * For certain types, object identity should not be used for object equality check. This phase
 51  * checks the correct usage of the given type. Equality checks with == or != (except null checks)
 52  * results in an {@link AssertionError}.
 53  */
<a name="4" id="anc4"></a><span class="line-modified"> 54 public class VerifyUsageWithEquals extends VerifyPhase&lt;CoreProviders&gt; {</span>
 55 
 56     @Override
 57     public boolean checkContract() {
 58         return false;
 59     }
 60 
 61     /**
 62      * The type of values that must not use identity for testing object equality.
 63      */
 64     private final Class&lt;?&gt; restrictedClass;
 65 
 66     public VerifyUsageWithEquals(Class&lt;?&gt; restrictedClass) {
 67         this.restrictedClass = restrictedClass;
 68         assert !restrictedClass.isInterface() || isTrustedInterface(restrictedClass);
 69     }
 70 
 71     private static final Class&lt;?&gt;[] trustedInterfaceTypes = {JavaType.class, JavaField.class, JavaMethod.class};
 72 
 73     private static boolean isTrustedInterface(Class&lt;?&gt; cls) {
 74         for (Class&lt;?&gt; trusted : trustedInterfaceTypes) {
 75             if (trusted.isAssignableFrom(cls)) {
 76                 return true;
 77             }
 78         }
 79         return false;
 80     }
 81 
 82     /**
 83      * Determines whether the type of {@code node} is assignable to the {@link #restrictedClass}.
 84      */
 85     private boolean isAssignableToRestrictedType(ValueNode node, MetaAccessProvider metaAccess) {
 86         if (node.stamp(NodeView.DEFAULT) instanceof ObjectStamp) {
 87             ResolvedJavaType restrictedType = metaAccess.lookupJavaType(restrictedClass);
 88             ResolvedJavaType nodeType = StampTool.typeOrNull(node);
 89             if (nodeType == null &amp;&amp; node instanceof LoadFieldNode) {
 90                 nodeType = (ResolvedJavaType) ((LoadFieldNode) node).field().getType();
 91             }
 92             if (nodeType == null &amp;&amp; node instanceof Invoke) {
 93                 ResolvedJavaMethod target = ((Invoke) node).callTarget().targetMethod();
 94                 nodeType = (ResolvedJavaType) target.getSignature().getReturnType(target.getDeclaringClass());
 95             }
 96             if (nodeType == null &amp;&amp; node instanceof UncheckedInterfaceProvider) {
 97                 nodeType = StampTool.typeOrNull(((UncheckedInterfaceProvider) node).uncheckedStamp());
 98             }
 99 
100             if (nodeType != null &amp;&amp; restrictedType.isAssignableFrom(nodeType)) {
101                 return true;
102             }
103         }
104         return false;
105     }
106 
107     private static boolean isNullConstant(ValueNode node) {
108         return node.isConstant() &amp;&amp; node.isNullConstant();
109     }
110 
111     private static boolean isEqualsMethod(ResolvedJavaMethod method) {
112         if (method.getName().equals(&quot;equals&quot;)) {
113             Signature sig = method.getSignature();
114             if (sig.getReturnKind() == JavaKind.Boolean) {
115                 if (sig.getParameterCount(false) == 1) {
116                     ResolvedJavaType ptype = (ResolvedJavaType) sig.getParameterType(0, method.getDeclaringClass());
117                     if (ptype.isJavaLangObject()) {
118                         return true;
119                     }
120 
121                 }
122             }
123         }
124         return false;
125     }
126 
127     private static boolean isThisParameter(ValueNode node) {
128         return node instanceof ParameterNode &amp;&amp; ((ParameterNode) node).index() == 0;
129     }
130 
131     /**
132      * Checks whether the type of {@code x} is assignable to the restricted type and that {@code y}
133      * is not a null constant.
134      */
135     private boolean isIllegalUsage(ResolvedJavaMethod method, ValueNode x, ValueNode y, MetaAccessProvider metaAccess) {
136         if (isAssignableToRestrictedType(x, metaAccess) &amp;&amp; !isNullConstant(y)) {
137             if (isEqualsMethod(method) &amp;&amp; isThisParameter(x) || isThisParameter(y)) {
138                 return false;
139             }
140             return true;
141         }
142         return false;
143     }
144 
145     @Override
<a name="5" id="anc5"></a><span class="line-modified">146     protected void verify(StructuredGraph graph, CoreProviders context) {</span>
147         for (ObjectEqualsNode cn : graph.getNodes().filter(ObjectEqualsNode.class)) {
148             // bail out if we compare an object of type klass with == or != (except null checks)
149             ResolvedJavaMethod method = graph.method();
150             ResolvedJavaType restrictedType = context.getMetaAccess().lookupJavaType(restrictedClass);
151 
152             if (method.getDeclaringClass().equals(restrictedType)) {
153                 // Allow violation in methods of the restricted type itself.
154             } else if (isIllegalUsage(method, cn.getX(), cn.getY(), context.getMetaAccess()) || isIllegalUsage(method, cn.getY(), cn.getX(), context.getMetaAccess())) {
155                 throw new VerificationError(&quot;Verification of &quot; + restrictedClass.getName() + &quot; usage failed: Comparing &quot; + cn.getX() + &quot; and &quot; + cn.getY() + &quot; in &quot; + method +
156                                 &quot; must use .equals() for object equality, not &#39;==&#39; or &#39;!=&#39;&quot;);
157             }
158         }
<a name="6" id="anc6"></a>
159     }
160 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
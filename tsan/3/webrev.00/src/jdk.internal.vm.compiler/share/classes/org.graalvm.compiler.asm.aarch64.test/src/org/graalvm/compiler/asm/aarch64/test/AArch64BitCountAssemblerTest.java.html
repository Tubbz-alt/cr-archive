<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64.test/src/org/graalvm/compiler/asm/aarch64/test/AArch64BitCountAssemblerTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2019, Arm Limited. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 package org.graalvm.compiler.asm.aarch64.test;
 27 
 28 import static jdk.vm.ci.code.ValueUtil.asRegister;
 29 import static org.junit.Assume.assumeTrue;
 30 
 31 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 32 import org.graalvm.compiler.asm.test.AssemblerTest;
 33 import org.graalvm.compiler.code.CompilationResult;
 34 import org.junit.Before;
 35 import org.junit.Test;
 36 
 37 import jdk.vm.ci.aarch64.AArch64;
 38 import jdk.vm.ci.aarch64.AArch64Kind;
 39 import jdk.vm.ci.code.CallingConvention;
 40 import jdk.vm.ci.code.Register;
 41 import jdk.vm.ci.code.RegisterArray;
 42 import jdk.vm.ci.code.RegisterConfig;
 43 import jdk.vm.ci.code.TargetDescription;
 44 import jdk.vm.ci.meta.JavaKind;
 45 
 46 public class AArch64BitCountAssemblerTest extends AssemblerTest {
 47     @Before
 48     public void checkAArch64() {
 49         assumeTrue(&quot;skipping non AArch64 specific test&quot;, codeCache.getTarget().arch instanceof AArch64);
 50     }
 51 
 52     public interface AArch64CodeGenTestCase {
 53         CodeGenTest create();
 54 
 55         int getExpected();
 56     }
 57 
 58     private class AArch64BitCountCodeGenTestCase&lt;T extends Number&gt; implements AArch64CodeGenTestCase {
 59         final T value;
 60         final int size;
 61 
 62         AArch64BitCountCodeGenTestCase(T x, int size) {
 63             assert x instanceof Integer || x instanceof Long;
 64             this.value = x;
 65             this.size = size;
 66         }
 67 
 68         T getValue() {
 69             return value;
 70         }
 71 
 72         @Override
 73         public CodeGenTest create() {
 74             return (CompilationResult compResult, TargetDescription target, RegisterConfig registerConfig, CallingConvention cc) -&gt; {
 75                 AArch64MacroAssembler masm = new AArch64MacroAssembler(target);
 76                 Register dst = registerConfig.getReturnRegister(JavaKind.Int);
 77                 Register src = asRegister(cc.getArgument(0));
 78                 // Generate a nop first as AArch64 Hotspot requires instruction at nmethod verified
 79                 // entry to be a jump or nop. (See https://github.com/oracle/graal/issues/1439)
 80                 masm.nop();
 81                 RegisterArray registers = registerConfig.filterAllocatableRegisters(AArch64Kind.V64_BYTE, registerConfig.getAllocatableRegisters());
 82                 masm.popcnt(size, dst, src, registers.get(registers.size() - 1));
 83                 masm.ret(AArch64.lr);
 84                 return masm.close(true);
 85             };
 86         }
 87 
 88         @Override
 89         public int getExpected() {
 90             if (value instanceof Integer) {
 91                 return Integer.bitCount((Integer) value);
 92             } else if (value instanceof Long) {
 93                 return Long.bitCount((Long) value);
 94             }
 95             return -1;
 96         }
 97     }
 98 
 99     @Test
100     @SuppressWarnings(&quot;unchecked&quot;)
101     public void testBitCount() {
102         AArch64CodeGenTestCase[] tests = {
103                         new AArch64BitCountCodeGenTestCase&lt;&gt;(0, JavaKind.Int.getByteCount() * Byte.SIZE),
104                         new AArch64BitCountCodeGenTestCase&lt;&gt;(1522767384, JavaKind.Int.getByteCount() * Byte.SIZE),
105                         new AArch64BitCountCodeGenTestCase&lt;&gt;(0L, JavaKind.Long.getByteCount() * Byte.SIZE),
106                         new AArch64BitCountCodeGenTestCase&lt;&gt;(81985529216486895L, JavaKind.Long.getByteCount() * Byte.SIZE),
107         };
108 
109         assertReturn(&quot;intStub&quot;, tests[0].create(), tests[0].getExpected(), ((AArch64BitCountCodeGenTestCase&lt;Integer&gt;) tests[0]).getValue());
110         assertReturn(&quot;intStub&quot;, tests[1].create(), tests[1].getExpected(), ((AArch64BitCountCodeGenTestCase&lt;Integer&gt;) tests[1]).getValue());
111         assertReturn(&quot;longStub&quot;, tests[2].create(), tests[2].getExpected(), ((AArch64BitCountCodeGenTestCase&lt;Long&gt;) tests[2]).getValue());
112         assertReturn(&quot;longStub&quot;, tests[3].create(), tests[3].getExpected(), ((AArch64BitCountCodeGenTestCase&lt;Long&gt;) tests[3]).getValue());
113     }
114 
115     @SuppressWarnings(&quot;unused&quot;)
116     public static int intStub(int x) {
117         return 0;
118     }
119 
120     @SuppressWarnings(&quot;unused&quot;)
121     public static int longStub(long x) {
122         return 0;
123     }
124 }
    </pre>
  </body>
</html>
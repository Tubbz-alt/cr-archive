<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64.test/src/org/graalvm/compiler/asm/aarch64/test/AArch64LoadStoreMergingAssemblerTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2019, Arm Limited. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 package org.graalvm.compiler.asm.aarch64.test;
 27 
 28 import jdk.vm.ci.aarch64.AArch64;
 29 import jdk.vm.ci.code.Register;
 30 import jdk.vm.ci.code.TargetDescription;
 31 import jdk.vm.ci.runtime.JVMCI;
 32 import org.graalvm.compiler.asm.aarch64.AArch64Address;
 33 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 34 import org.graalvm.compiler.test.GraalTest;
 35 import org.junit.Assert;
 36 import org.junit.Before;
 37 import org.junit.Test;
 38 
 39 import static org.junit.Assert.assertArrayEquals;
 40 import static org.junit.Assume.assumeTrue;
 41 
 42 public class AArch64LoadStoreMergingAssemblerTest extends GraalTest {
 43     private Register base;
 44     private Register rt1;
 45     private Register rt2;
 46 
 47     @Before
 48     public void checkAArch64() {
 49         TargetDescription target = JVMCI.getRuntime().getHostJVMCIBackend().getTarget();
 50         assumeTrue(&quot;skipping non AArch64 specific test&quot;, target.arch instanceof AArch64);
 51     }
 52 
 53     @Before
 54     public void setupEnvironment() {
 55         base = AArch64.sp;
 56         rt1 = AArch64.r1;
 57         rt2 = AArch64.r2;
 58     }
 59 
 60     private abstract static class AArch64LoadStoreCodeGen {
 61         protected AArch64MacroAssembler masm1;
 62         protected AArch64MacroAssembler masm2;
 63 
 64         AArch64LoadStoreCodeGen() {
 65             TargetDescription target = JVMCI.getRuntime().getHostJVMCIBackend().getTarget();
 66             masm1 = new AArch64MacroAssembler(target);
 67             masm2 = new AArch64MacroAssembler(target);
 68         }
 69 
 70         void emitScaledImmLdr(int size, Register rt, Register base, int imm12) {
 71             AArch64Address address = AArch64Address.createScaledImmediateAddress(base, imm12);
 72             masm2.ldr(size, rt, address);
 73         }
 74 
 75         void emitUnscaledImmLdr(int size, Register rt, Register base, int imm9) {
 76             AArch64Address address1 = AArch64Address.createUnscaledImmediateAddress(base, imm9);
 77             masm2.ldr(size, rt, address1);
 78         }
 79 
 80         void emitScaledImmStr(int size, Register rt, Register base, int imm12) {
 81             AArch64Address address = AArch64Address.createScaledImmediateAddress(base, imm12);
 82             masm2.str(size, rt, address);
 83         }
 84 
 85         void emitUnscaledImmStr(int size, Register rt, Register base, int imm9) {
 86             AArch64Address address1 = AArch64Address.createUnscaledImmediateAddress(base, imm9);
 87             masm2.str(size, rt, address1);
 88         }
 89 
 90         void emitScaledLdp(int size, Register rt1, Register rt2, Register base, int imm7) {
 91             AArch64Address mergeAddress = AArch64Address.createScaledImmediateAddress(base, imm7);
 92             masm1.ldp(size, rt1, rt2, mergeAddress);
 93         }
 94 
 95         void emitScaledStp(int size, Register rt1, Register rt2, Register base, int imm7) {
 96             AArch64Address mergeAddress = AArch64Address.createScaledImmediateAddress(base, imm7);
 97             masm1.stp(size, rt1, rt2, mergeAddress);
 98         }
 99 
100         void emitUnscaledLdp(int size, Register rt1, Register rt2, Register base, int imm) {
101             AArch64Address mergeAddress = AArch64Address.createUnscaledImmediateAddress(base, imm);
102             masm1.ldp(size, rt1, rt2, mergeAddress);
103         }
104 
105         void emitUnscaledStp(int size, Register rt1, Register rt2, Register base, int imm) {
106             AArch64Address mergeAddress = AArch64Address.createUnscaledImmediateAddress(base, imm);
107             masm1.stp(size, rt1, rt2, mergeAddress);
108         }
109 
110         abstract void checkAssembly();
111     }
112 
113     private static class AArch64LoadStoreMergingCodeGen extends AArch64LoadStoreCodeGen {
114         AArch64LoadStoreMergingCodeGen() {
115             super();
116         }
117 
118         @Override
119         void checkAssembly() {
120             byte[] expected = masm1.close(false);
121             byte[] actual = masm2.close(false);
122             assertArrayEquals(expected, actual);
123         }
124     }
125 
126     @Test
127     public void testLoad64BitsScaledImmAddress() {
128         AArch64LoadStoreMergingCodeGen codeGen = new AArch64LoadStoreMergingCodeGen();
129         codeGen.emitScaledImmLdr(64, rt1, base, 4);
130         codeGen.emitScaledImmLdr(64, rt2, base, 5);
131         codeGen.emitScaledLdp(64, rt1, rt2, base, 4);
132         codeGen.checkAssembly();
133     }
134 
135     @Test
136     public void testLoad32BitsScaledImmAddress() {
137         AArch64LoadStoreMergingCodeGen codeGen = new AArch64LoadStoreMergingCodeGen();
138         codeGen.emitScaledImmLdr(32, rt1, base, 5);
139         codeGen.emitScaledImmLdr(32, rt2, base, 4);
140         codeGen.emitScaledLdp(32, rt2, rt1, base, 4);
141         codeGen.checkAssembly();
142     }
143 
144     @Test
145     public void testStore64BitsScaledImmAddress() {
146         AArch64LoadStoreMergingCodeGen codeGen = new AArch64LoadStoreMergingCodeGen();
147         codeGen.emitScaledImmStr(64, rt1, base, 4);
148         codeGen.emitScaledImmStr(64, rt2, base, 5);
149         codeGen.emitScaledStp(64, rt1, rt2, base, 4);
150         codeGen.checkAssembly();
151     }
152 
153     @Test
154     public void testStore32BitsScaledImmAddress() {
155         AArch64LoadStoreMergingCodeGen codeGen = new AArch64LoadStoreMergingCodeGen();
156         codeGen.emitScaledImmStr(32, rt1, base, 4);
157         codeGen.emitScaledImmStr(32, rt2, base, 5);
158         codeGen.emitScaledStp(32, rt1, rt2, base, 4);
159         codeGen.checkAssembly();
160     }
161 
162     @Test
163     public void testLoad64BitsUnscaledImmAddress() {
164         AArch64LoadStoreMergingCodeGen codeGen = new AArch64LoadStoreMergingCodeGen();
165         codeGen.emitUnscaledImmLdr(64, rt1, base, -32);
166         codeGen.emitUnscaledImmLdr(64, rt2, base, -24);
167         codeGen.emitUnscaledLdp(64, rt1, rt2, base, -32);
168         codeGen.checkAssembly();
169     }
170 
171     @Test
172     public void testLoad32BitsUnscaledImmAddress() {
173         AArch64LoadStoreMergingCodeGen codeGen = new AArch64LoadStoreMergingCodeGen();
174         codeGen.emitUnscaledImmLdr(32, rt1, base, 248);
175         codeGen.emitUnscaledImmLdr(32, rt2, base, 252);
176         codeGen.emitUnscaledLdp(32, rt1, rt2, base, 248);
177         codeGen.checkAssembly();
178     }
179 
180     @Test
181     public void testStore64BitsUnscaledImmAddress() {
182         AArch64LoadStoreMergingCodeGen codeGen = new AArch64LoadStoreMergingCodeGen();
183         codeGen.emitUnscaledImmStr(64, rt1, base, 32);
184         codeGen.emitUnscaledImmStr(64, rt2, base, 40);
185         codeGen.emitUnscaledStp(64, rt1, rt2, base, 32);
186         codeGen.checkAssembly();
187     }
188 
189     @Test
190     public void testStore32BitsUnscaledImmAddress() {
191         AArch64LoadStoreMergingCodeGen codeGen = new AArch64LoadStoreMergingCodeGen();
192         codeGen.emitUnscaledImmStr(32, rt1, base, 32);
193         codeGen.emitUnscaledImmStr(32, rt2, base, 36);
194         codeGen.emitUnscaledStp(32, rt1, rt2, base, 32);
195         codeGen.checkAssembly();
196     }
197 
198     @Test
199     public void testLoadUnscaledScaledImmAddress() {
200         AArch64LoadStoreMergingCodeGen codeGen = new AArch64LoadStoreMergingCodeGen();
201         codeGen.emitUnscaledImmLdr(32, rt1, base, 48);
202         codeGen.emitScaledImmLdr(32, rt2, base, 13);
203         codeGen.emitScaledLdp(32, rt1, rt2, base, 12);
204         codeGen.checkAssembly();
205     }
206 
207     @Test
208     public void testLoadScaledUnscaledImmAddress() {
209         AArch64LoadStoreMergingCodeGen codeGen = new AArch64LoadStoreMergingCodeGen();
210         codeGen.emitScaledImmLdr(32, rt1, base, 13);
211         codeGen.emitUnscaledImmLdr(32, rt2, base, 48);
212         codeGen.emitUnscaledLdp(32, rt2, rt1, base, 48);
213         codeGen.checkAssembly();
214     }
215 
216     @Test
217     public void testLoadMaxAlignedOffset() {
218         AArch64LoadStoreMergingCodeGen codeGen = new AArch64LoadStoreMergingCodeGen();
219         codeGen.emitScaledImmLdr(64, rt1, base, 62);
220         codeGen.emitScaledImmLdr(64, rt2, base, 63);
221         codeGen.emitScaledLdp(64, rt1, rt2, base, 62);
222         codeGen.checkAssembly();
223     }
224 
225     @Test
226     public void testStoreMinAlignedOffest() {
227         AArch64LoadStoreMergingCodeGen codeGen = new AArch64LoadStoreMergingCodeGen();
228         codeGen.emitUnscaledImmStr(32, rt1, base, -256);
229         codeGen.emitUnscaledImmStr(32, rt2, base, -252);
230         codeGen.emitUnscaledStp(32, rt1, rt2, base, -256);
231         codeGen.checkAssembly();
232     }
233 
234     // All the following tests are the negative ones that ldr/str will not be merged to ldp/stp.
235     private static class AArch64LoadStoreNotMergingCodeGen extends AArch64LoadStoreCodeGen {
236         AArch64LoadStoreNotMergingCodeGen() {
237             super();
238         }
239 
240         @Override
241         void checkAssembly() {
242             boolean isMerged = masm2.isImmLoadStoreMerged();
243             masm2.close(false);
244             Assert.assertFalse(isMerged);
245         }
246     }
247 
248     @Test
249     public void testDifferentBase() {
250         AArch64LoadStoreNotMergingCodeGen codeGen = new AArch64LoadStoreNotMergingCodeGen();
251         codeGen.emitScaledImmLdr(32, rt1, base, 4);
252         codeGen.emitScaledImmLdr(32, rt2, AArch64.r3, 5);
253         codeGen.checkAssembly();
254     }
255 
256     @Test
257     public void testDifferentSize() {
258         AArch64LoadStoreNotMergingCodeGen codeGen = new AArch64LoadStoreNotMergingCodeGen();
259         codeGen.emitScaledImmLdr(32, rt1, base, 4);
260         codeGen.emitScaledImmLdr(64, rt2, base, 5);
261         codeGen.checkAssembly();
262     }
263 
264     @Test
265     public void testSameRt() {
266         AArch64LoadStoreNotMergingCodeGen codeGen = new AArch64LoadStoreNotMergingCodeGen();
267         codeGen.emitScaledImmLdr(32, rt1, base, 4);
268         codeGen.emitScaledImmLdr(32, rt1, base, 5);
269         codeGen.checkAssembly();
270     }
271 
272     @Test
273     public void testDependencyLdrs() {
274         AArch64LoadStoreNotMergingCodeGen codeGen = new AArch64LoadStoreNotMergingCodeGen();
275         codeGen.emitScaledImmLdr(32, rt1, rt1, 4);
276         codeGen.emitScaledImmLdr(32, rt2, rt1, 5);
277         codeGen.checkAssembly();
278     }
279 
280     @Test
281     public void testUnalignedOffset() {
282         AArch64LoadStoreNotMergingCodeGen codeGen = new AArch64LoadStoreNotMergingCodeGen();
283         codeGen.emitUnscaledImmLdr(32, rt1, base, 34);
284         codeGen.emitUnscaledImmLdr(32, rt2, base, 38);
285         codeGen.checkAssembly();
286     }
287 
288     @Test
289     public void testUncontinuousOffset() {
290         AArch64LoadStoreNotMergingCodeGen codeGen = new AArch64LoadStoreNotMergingCodeGen();
291         codeGen.emitScaledImmLdr(32, rt1, base, 4);
292         codeGen.emitScaledImmLdr(32, rt2, base, 6);
293         codeGen.checkAssembly();
294     }
295 
296     @Test
297     public void testGreaterThanMaxOffset() {
298         AArch64LoadStoreNotMergingCodeGen codeGen = new AArch64LoadStoreNotMergingCodeGen();
299         codeGen.emitScaledImmLdr(32, rt1, base, 66);
300         codeGen.emitScaledImmLdr(32, rt2, base, 67);
301         codeGen.checkAssembly();
302     }
303 
304     @Test
305     public void testLdrStr() {
306         AArch64LoadStoreNotMergingCodeGen codeGen = new AArch64LoadStoreNotMergingCodeGen();
307         codeGen.emitScaledImmLdr(32, rt1, base, 4);
308         codeGen.emitScaledImmStr(32, rt2, base, 5);
309         codeGen.checkAssembly();
310     }
311 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/util/GraphOrder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../tiers/MidTierContext.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="Providers.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/util/GraphOrder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -156,11 +156,11 @@</span>
       */
      @SuppressWarnings(&quot;try&quot;)
      public static boolean assertSchedulableGraph(final StructuredGraph graph) {
          assert graph.getGuardsStage() != GuardsStage.AFTER_FSA : &quot;Cannot use the BlockIteratorClosure after FrameState Assignment, HIR Loop Data Structures are no longer valid.&quot;;
          try (DebugContext.Scope s = graph.getDebug().scope(&quot;AssertSchedulableGraph&quot;)) {
<span class="udiff-line-modified-removed">-             final SchedulePhase schedulePhase = new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true);</span>
<span class="udiff-line-modified-added">+             final SchedulePhase schedulePhase = new SchedulePhase(getSchedulingPolicy(graph), true);</span>
              final EconomicMap&lt;LoopBeginNode, NodeBitMap&gt; loopEntryStates = EconomicMap.create(Equivalence.IDENTITY);
              schedulePhase.apply(graph, false);
              final ScheduleResult schedule = graph.getLastSchedule();
  
              BlockIteratorClosure&lt;NodeBitMap&gt; closure = new BlockIteratorClosure&lt;NodeBitMap&gt;() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -214,15 +214,15 @@</span>
                                              if (input != proxy.proxyPoint()) {
                                                  assert currentState.isMarked(input) : input + &quot; not available at &quot; + proxy + &quot; in block &quot; + block + &quot;\n&quot; + list;
                                              }
                                          }
                                      }
<span class="udiff-line-removed">- </span>
                                      // loop contents are only accessible via proxies at the exit
                                      currentState.clearAll();
                                      currentState.markAll(loopEntryStates.get(((LoopExitNode) node).loopBegin()));
                                  }
<span class="udiff-line-added">+ </span>
                                  // Loop proxies aren&#39;t scheduled, so they need to be added
                                  // explicitly
                                  currentState.markAll(((LoopExitNode) node).proxies());
                              } else {
                                  for (Node input : node.inputs()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -295,6 +295,16 @@</span>
          } catch (Throwable t) {
              graph.getDebug().handle(t);
          }
          return true;
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /*</span>
<span class="udiff-line-added">+      * Complexity of verification for LATEST_OUT_OF_LOOPS with value proxies exceeds the benefits.</span>
<span class="udiff-line-added">+      * The problem are floating values that can be scheduled before the loop and have proxies only</span>
<span class="udiff-line-added">+      * on some use edges after the loop. These values, which are hard to detect, get scheduled</span>
<span class="udiff-line-added">+      * before the loop exit and are not visible in the state after the loop exit.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static SchedulingStrategy getSchedulingPolicy(StructuredGraph graph) {</span>
<span class="udiff-line-added">+         return graph.hasValueProxies() ? SchedulingStrategy.EARLIEST : SchedulingStrategy.LATEST_OUT_OF_LOOPS;</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="../tiers/MidTierContext.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="Providers.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/schedule/SchedulePhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../graph/ReentrantBlockIterator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../tiers/HighTierContext.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/schedule/SchedulePhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,19 ***</span>
      public enum SchedulingStrategy {
          EARLIEST_WITH_GUARD_ORDER,
          EARLIEST,
          LATEST,
          LATEST_OUT_OF_LOOPS,
<span class="line-modified">!         FINAL_SCHEDULE;</span>
  
          public boolean isEarliest() {
              return this == EARLIEST || this == EARLIEST_WITH_GUARD_ORDER;
          }
  
          public boolean isLatest() {
              return !isEarliest();
          }
      }
  
      private final SchedulingStrategy selectedStrategy;
  
      private final boolean immutableGraph;
<span class="line-new-header">--- 92,27 ---</span>
      public enum SchedulingStrategy {
          EARLIEST_WITH_GUARD_ORDER,
          EARLIEST,
          LATEST,
          LATEST_OUT_OF_LOOPS,
<span class="line-modified">!         LATEST_OUT_OF_LOOPS_IMPLICIT_NULL_CHECKS;</span>
  
          public boolean isEarliest() {
              return this == EARLIEST || this == EARLIEST_WITH_GUARD_ORDER;
          }
  
          public boolean isLatest() {
              return !isEarliest();
          }
<span class="line-added">+ </span>
<span class="line-added">+         public boolean scheduleOutOfLoops() {</span>
<span class="line-added">+             return this == LATEST_OUT_OF_LOOPS || this == LATEST_OUT_OF_LOOPS_IMPLICIT_NULL_CHECKS;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         public boolean considerImplicitNullChecks() {</span>
<span class="line-added">+             return this == LATEST_OUT_OF_LOOPS_IMPLICIT_NULL_CHECKS;</span>
<span class="line-added">+         }</span>
      }
  
      private final SchedulingStrategy selectedStrategy;
  
      private final boolean immutableGraph;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 196,11 ***</span>
  
                  BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap = calcLatestBlocks(selectedStrategy, currentNodeMap, earliestBlockToNodesMap, visited, latestBlockToNodesMap, immutableGraph);
                  sortNodesLatestWithinBlock(cfg, earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited);
  
                  assert verifySchedule(cfg, latestBlockToNodesMap, currentNodeMap);
<span class="line-modified">!                 assert (!Assertions.detailedAssertionsEnabled(graph.getOptions())) || MemoryScheduleVerification.check(cfg.getStartBlock(), latestBlockToNodesMap);</span>
  
                  this.blockToNodesMap = latestBlockToNodesMap;
  
              }
              cfg.setNodeToBlock(currentNodeMap);
<span class="line-new-header">--- 204,12 ---</span>
  
                  BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap = calcLatestBlocks(selectedStrategy, currentNodeMap, earliestBlockToNodesMap, visited, latestBlockToNodesMap, immutableGraph);
                  sortNodesLatestWithinBlock(cfg, earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited);
  
                  assert verifySchedule(cfg, latestBlockToNodesMap, currentNodeMap);
<span class="line-modified">!                 assert (!Assertions.detailedAssertionsEnabled(graph.getOptions())) ||</span>
<span class="line-added">+                                 ScheduleVerification.check(cfg.getStartBlock(), latestBlockToNodesMap, currentNodeMap);</span>
  
                  this.blockToNodesMap = latestBlockToNodesMap;
  
              }
              cfg.setNodeToBlock(currentNodeMap);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 226,12 ***</span>
                      if (currentNode instanceof FixedNode) {
                          // For these nodes, the earliest is at the same time the latest block.
                      } else {
                          Block latestBlock = null;
  
                          LocationIdentity constrainingLocation = null;
<span class="line-modified">!                         if (currentNode instanceof FloatingReadNode) {</span>
                              // We are scheduling a floating read node =&gt; check memory
                              // anti-dependencies.
                              FloatingReadNode floatingReadNode = (FloatingReadNode) currentNode;
                              LocationIdentity location = floatingReadNode.getLocationIdentity();
                              if (location.isMutable()) {
<span class="line-new-header">--- 235,18 ---</span>
                      if (currentNode instanceof FixedNode) {
                          // For these nodes, the earliest is at the same time the latest block.
                      } else {
                          Block latestBlock = null;
  
<span class="line-added">+                         if (currentBlock.getFirstDominated() == null &amp;&amp; !(currentNode instanceof VirtualState)) {</span>
<span class="line-added">+                             // This block doesn&#39;t dominate any other blocks =&gt;</span>
<span class="line-added">+                             // node must be scheduled in earliest block.</span>
<span class="line-added">+                             latestBlock = currentBlock;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+ </span>
                          LocationIdentity constrainingLocation = null;
<span class="line-modified">!                         if (latestBlock == null &amp;&amp; currentNode instanceof FloatingReadNode) {</span>
                              // We are scheduling a floating read node =&gt; check memory
                              // anti-dependencies.
                              FloatingReadNode floatingReadNode = (FloatingReadNode) currentNode;
                              LocationIdentity location = floatingReadNode.getLocationIdentity();
                              if (location.isMutable()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 342,11 ***</span>
                  }
                  lastBlock = currentBlock;
              }
  
              if (lastBlock.getBeginNode() instanceof KillingBeginNode) {
<span class="line-modified">!                 LocationIdentity locationIdentity = ((KillingBeginNode) lastBlock.getBeginNode()).getLocationIdentity();</span>
                  if ((locationIdentity.isAny() || locationIdentity.equals(location)) &amp;&amp; lastBlock != earliestBlock) {
                      // The begin of this block kills the location, so we *have* to schedule the node
                      // in the dominating block.
                      lastBlock = lastBlock.getDominator();
                  }
<span class="line-new-header">--- 357,11 ---</span>
                  }
                  lastBlock = currentBlock;
              }
  
              if (lastBlock.getBeginNode() instanceof KillingBeginNode) {
<span class="line-modified">!                 LocationIdentity locationIdentity = ((KillingBeginNode) lastBlock.getBeginNode()).getKilledLocationIdentity();</span>
                  if ((locationIdentity.isAny() || locationIdentity.equals(location)) &amp;&amp; lastBlock != earliestBlock) {
                      // The begin of this block kills the location, so we *have* to schedule the node
                      // in the dominating block.
                      lastBlock = lastBlock.getDominator();
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 358,17 ***</span>
          private static void fillKillSet(LocationSet killed, List&lt;Node&gt; subList) {
              if (!killed.isAny()) {
                  for (Node n : subList) {
                      // Check if this node kills a node in the watch list.
                      if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified">!                         LocationIdentity identity = ((MemoryCheckpoint.Single) n).getLocationIdentity();</span>
                          killed.add(identity);
                          if (killed.isAny()) {
                              return;
                          }
                      } else if (n instanceof MemoryCheckpoint.Multi) {
<span class="line-modified">!                         for (LocationIdentity identity : ((MemoryCheckpoint.Multi) n).getLocationIdentities()) {</span>
                              killed.add(identity);
                              if (killed.isAny()) {
                                  return;
                              }
                          }
<span class="line-new-header">--- 373,17 ---</span>
          private static void fillKillSet(LocationSet killed, List&lt;Node&gt; subList) {
              if (!killed.isAny()) {
                  for (Node n : subList) {
                      // Check if this node kills a node in the watch list.
                      if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified">!                         LocationIdentity identity = ((MemoryCheckpoint.Single) n).getKilledLocationIdentity();</span>
                          killed.add(identity);
                          if (killed.isAny()) {
                              return;
                          }
                      } else if (n instanceof MemoryCheckpoint.Multi) {
<span class="line-modified">!                         for (LocationIdentity identity : ((MemoryCheckpoint.Multi) n).getKilledLocationIdentities()) {</span>
                              killed.add(identity);
                              if (killed.isAny()) {
                                  return;
                              }
                          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 455,14 ***</span>
  
          private static void checkWatchList(Block b, NodeMap&lt;Block&gt; nodeMap, NodeBitMap unprocessed, ArrayList&lt;Node&gt; result, ArrayList&lt;FloatingReadNode&gt; watchList, Node n) {
              if (watchList != null &amp;&amp; !watchList.isEmpty()) {
                  // Check if this node kills a node in the watch list.
                  if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified">!                     LocationIdentity identity = ((MemoryCheckpoint.Single) n).getLocationIdentity();</span>
                      checkWatchList(watchList, identity, b, result, nodeMap, unprocessed);
                  } else if (n instanceof MemoryCheckpoint.Multi) {
<span class="line-modified">!                     for (LocationIdentity identity : ((MemoryCheckpoint.Multi) n).getLocationIdentities()) {</span>
                          checkWatchList(watchList, identity, b, result, nodeMap, unprocessed);
                      }
                  }
              }
          }
<span class="line-new-header">--- 470,14 ---</span>
  
          private static void checkWatchList(Block b, NodeMap&lt;Block&gt; nodeMap, NodeBitMap unprocessed, ArrayList&lt;Node&gt; result, ArrayList&lt;FloatingReadNode&gt; watchList, Node n) {
              if (watchList != null &amp;&amp; !watchList.isEmpty()) {
                  // Check if this node kills a node in the watch list.
                  if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified">!                     LocationIdentity identity = ((MemoryCheckpoint.Single) n).getKilledLocationIdentity();</span>
                      checkWatchList(watchList, identity, b, result, nodeMap, unprocessed);
                  } else if (n instanceof MemoryCheckpoint.Multi) {
<span class="line-modified">!                     for (LocationIdentity identity : ((MemoryCheckpoint.Multi) n).getKilledLocationIdentities()) {</span>
                          checkWatchList(watchList, identity, b, result, nodeMap, unprocessed);
                      }
                  }
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 542,11 ***</span>
                      latestBlock = calcBlockForUsage(currentNode, usage, latestBlock, currentNodeMap);
                  }
  
                  assert latestBlock != null : currentNode;
  
<span class="line-modified">!                 if (strategy == SchedulingStrategy.FINAL_SCHEDULE || strategy == SchedulingStrategy.LATEST_OUT_OF_LOOPS) {</span>
                      Block currentBlock = latestBlock;
                      while (currentBlock.getLoopDepth() &gt; earliestBlock.getLoopDepth() &amp;&amp; currentBlock != earliestBlock.getDominator()) {
                          Block previousCurrentBlock = currentBlock;
                          currentBlock = currentBlock.getDominator();
                          if (previousCurrentBlock.isLoopHeader()) {
<span class="line-new-header">--- 557,11 ---</span>
                      latestBlock = calcBlockForUsage(currentNode, usage, latestBlock, currentNodeMap);
                  }
  
                  assert latestBlock != null : currentNode;
  
<span class="line-modified">!                 if (strategy.scheduleOutOfLoops()) {</span>
                      Block currentBlock = latestBlock;
                      while (currentBlock.getLoopDepth() &gt; earliestBlock.getLoopDepth() &amp;&amp; currentBlock != earliestBlock.getDominator()) {
                          Block previousCurrentBlock = currentBlock;
                          currentBlock = currentBlock.getDominator();
                          if (previousCurrentBlock.isLoopHeader()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 562,31 ***</span>
                  if (latestBlock != earliestBlock &amp;&amp; latestBlock != earliestBlock.getDominator() &amp;&amp; constrainingLocation != null) {
                      latestBlock = checkKillsBetween(earliestBlock, latestBlock, constrainingLocation);
                  }
              }
  
<span class="line-modified">!             if (latestBlock != earliestBlock &amp;&amp; currentNode instanceof FloatingReadNode) {</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 FloatingReadNode floatingReadNode = (FloatingReadNode) currentNode;</span>
<span class="line-removed">-                 if (isImplicitNullOpportunity(floatingReadNode, earliestBlock) &amp;&amp;</span>
<span class="line-removed">-                                 earliestBlock.getRelativeFrequency() &lt; latestBlock.getRelativeFrequency() * IMPLICIT_NULL_CHECK_OPPORTUNITY_PROBABILITY_FACTOR) {</span>
<span class="line-removed">-                     latestBlock = earliestBlock;</span>
<span class="line-removed">-                 }</span>
              }
  
              selectLatestBlock(currentNode, earliestBlock, latestBlock, currentNodeMap, watchListMap, constrainingLocation, latestBlockToNodesMap);
          }
  
<span class="line-modified">!         private static boolean isImplicitNullOpportunity(FloatingReadNode floatingReadNode, Block block) {</span>
<span class="line-modified">! </span>
<span class="line-modified">!             Node pred = block.getBeginNode().predecessor();</span>
<span class="line-modified">!             if (pred instanceof IfNode) {</span>
<span class="line-modified">!                 IfNode ifNode = (IfNode) pred;</span>
<span class="line-modified">!                 if (ifNode.condition() instanceof IsNullNode) {</span>
<span class="line-modified">!                     IsNullNode isNullNode = (IsNullNode) ifNode.condition();</span>
<span class="line-modified">!                     if (getUnproxifiedUncompressed(floatingReadNode.getAddress().getBase()) == getUnproxifiedUncompressed(isNullNode.getValue())) {</span>
<span class="line-modified">!                         return true;</span>
                      }
                  }
              }
              return false;
          }
<span class="line-new-header">--- 577,29 ---</span>
                  if (latestBlock != earliestBlock &amp;&amp; latestBlock != earliestBlock.getDominator() &amp;&amp; constrainingLocation != null) {
                      latestBlock = checkKillsBetween(earliestBlock, latestBlock, constrainingLocation);
                  }
              }
  
<span class="line-modified">!             if (latestBlock != earliestBlock &amp;&amp; strategy.considerImplicitNullChecks() &amp;&amp; isImplicitNullOpportunity(currentNode, earliestBlock) &amp;&amp;</span>
<span class="line-modified">!                             earliestBlock.getRelativeFrequency() &lt; latestBlock.getRelativeFrequency() * IMPLICIT_NULL_CHECK_OPPORTUNITY_PROBABILITY_FACTOR) {</span>
<span class="line-modified">!                 latestBlock = earliestBlock;</span>
              }
  
              selectLatestBlock(currentNode, earliestBlock, latestBlock, currentNodeMap, watchListMap, constrainingLocation, latestBlockToNodesMap);
          }
  
<span class="line-modified">!         protected static boolean isImplicitNullOpportunity(Node currentNode, Block block) {</span>
<span class="line-modified">!             if (currentNode instanceof FloatingReadNode) {</span>
<span class="line-modified">!                 FloatingReadNode floatingReadNode = (FloatingReadNode) currentNode;</span>
<span class="line-modified">!                 Node pred = block.getBeginNode().predecessor();</span>
<span class="line-modified">!                 if (pred instanceof IfNode) {</span>
<span class="line-modified">!                     IfNode ifNode = (IfNode) pred;</span>
<span class="line-modified">!                     if (ifNode.condition() instanceof IsNullNode &amp;&amp; ifNode.getTrueSuccessorProbability() == 0.0) {</span>
<span class="line-modified">!                         IsNullNode isNullNode = (IsNullNode) ifNode.condition();</span>
<span class="line-modified">!                         if (getUnproxifiedUncompressed(floatingReadNode.getAddress().getBase()) == getUnproxifiedUncompressed(isNullNode.getValue())) {</span>
<span class="line-added">+                             return true;</span>
<span class="line-added">+                         }</span>
                      }
                  }
              }
              return false;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 882,11 ***</span>
                          next = next.getNext();
                      }
                  }
              }
  
<span class="line-modified">!             assert (!Assertions.detailedAssertionsEnabled(cfg.graph.getOptions())) || MemoryScheduleVerification.check(cfg.getStartBlock(), blockToNodes);</span>
          }
  
          private static void processNodes(NodeBitMap visited, NodeMap&lt;MicroBlock&gt; entries, NodeStack stack, MicroBlock startBlock, Iterable&lt;? extends Node&gt; nodes) {
              for (Node node : nodes) {
                  if (entries.get(node) == null) {
<span class="line-new-header">--- 895,11 ---</span>
                          next = next.getNext();
                      }
                  }
              }
  
<span class="line-modified">!             assert (!Assertions.detailedAssertionsEnabled(cfg.graph.getOptions())) || ScheduleVerification.check(cfg.getStartBlock(), blockToNodes, nodeToBlock);</span>
          }
  
          private static void processNodes(NodeBitMap visited, NodeMap&lt;MicroBlock&gt; entries, NodeStack stack, MicroBlock startBlock, Iterable&lt;? extends Node&gt; nodes) {
              for (Node node : nodes) {
                  if (entries.get(node) == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1169,14 ***</span>
  
          private static void printNode(Node n) {
              Formatter buf = new Formatter();
              buf.format(&quot;%s&quot;, n);
              if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified">!                 buf.format(&quot; // kills %s&quot;, ((MemoryCheckpoint.Single) n).getLocationIdentity());</span>
              } else if (n instanceof MemoryCheckpoint.Multi) {
                  buf.format(&quot; // kills &quot;);
<span class="line-modified">!                 for (LocationIdentity locid : ((MemoryCheckpoint.Multi) n).getLocationIdentities()) {</span>
                      buf.format(&quot;%s, &quot;, locid);
                  }
              } else if (n instanceof FloatingReadNode) {
                  FloatingReadNode frn = (FloatingReadNode) n;
                  buf.format(&quot; // from %s&quot;, frn.getLocationIdentity());
<span class="line-new-header">--- 1182,14 ---</span>
  
          private static void printNode(Node n) {
              Formatter buf = new Formatter();
              buf.format(&quot;%s&quot;, n);
              if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified">!                 buf.format(&quot; // kills %s&quot;, ((MemoryCheckpoint.Single) n).getKilledLocationIdentity());</span>
              } else if (n instanceof MemoryCheckpoint.Multi) {
                  buf.format(&quot; // kills &quot;);
<span class="line-modified">!                 for (LocationIdentity locid : ((MemoryCheckpoint.Multi) n).getKilledLocationIdentities()) {</span>
                      buf.format(&quot;%s, &quot;, locid);
                  }
              } else if (n instanceof FloatingReadNode) {
                  FloatingReadNode frn = (FloatingReadNode) n;
                  buf.format(&quot; // from %s&quot;, frn.getLocationIdentity());
</pre>
<center><a href="../graph/ReentrantBlockIterator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../tiers/HighTierContext.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
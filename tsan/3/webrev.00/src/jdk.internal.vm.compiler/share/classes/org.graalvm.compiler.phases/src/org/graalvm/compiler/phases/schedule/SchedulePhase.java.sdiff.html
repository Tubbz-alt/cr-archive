<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/schedule/SchedulePhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../graph/ReentrantBlockIterator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../tiers/HighTierContext.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/schedule/SchedulePhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  77 import org.graalvm.compiler.nodes.calc.ConvertNode;
  78 import org.graalvm.compiler.nodes.calc.IsNullNode;
  79 import org.graalvm.compiler.nodes.cfg.Block;
  80 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  81 import org.graalvm.compiler.nodes.cfg.HIRLoop;
  82 import org.graalvm.compiler.nodes.cfg.LocationSet;
  83 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
  84 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;
  85 import org.graalvm.compiler.nodes.spi.ValueProxy;
  86 import org.graalvm.compiler.options.OptionValues;
  87 import org.graalvm.compiler.phases.Phase;
  88 import jdk.internal.vm.compiler.word.LocationIdentity;
  89 
  90 public final class SchedulePhase extends Phase {
  91 
  92     public enum SchedulingStrategy {
  93         EARLIEST_WITH_GUARD_ORDER,
  94         EARLIEST,
  95         LATEST,
  96         LATEST_OUT_OF_LOOPS,
<span class="line-modified">  97         FINAL_SCHEDULE;</span>
  98 
  99         public boolean isEarliest() {
 100             return this == EARLIEST || this == EARLIEST_WITH_GUARD_ORDER;
 101         }
 102 
 103         public boolean isLatest() {
 104             return !isEarliest();
 105         }








 106     }
 107 
 108     private final SchedulingStrategy selectedStrategy;
 109 
 110     private final boolean immutableGraph;
 111 
 112     public SchedulePhase(OptionValues options) {
 113         this(false, options);
 114     }
 115 
 116     public SchedulePhase(boolean immutableGraph, OptionValues options) {
 117         this(OptScheduleOutOfLoops.getValue(options) ? SchedulingStrategy.LATEST_OUT_OF_LOOPS : SchedulingStrategy.LATEST, immutableGraph);
 118     }
 119 
 120     public SchedulePhase(SchedulingStrategy strategy) {
 121         this(strategy, false);
 122     }
 123 
 124     public SchedulePhase(SchedulingStrategy strategy, boolean immutableGraph) {
 125         this.selectedStrategy = strategy;
</pre>
<hr />
<pre>
 181 
 182             NodeMap&lt;Block&gt; currentNodeMap = graph.createNodeMap();
 183             NodeBitMap visited = graph.createNodeBitMap();
 184             BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap = new BlockMap&lt;&gt;(cfg);
 185             this.nodeToBlockMap = currentNodeMap;
 186             this.blockToNodesMap = earliestBlockToNodesMap;
 187 
 188             scheduleEarliestIterative(earliestBlockToNodesMap, currentNodeMap, visited, graph, immutableGraph, selectedStrategy == SchedulingStrategy.EARLIEST_WITH_GUARD_ORDER);
 189 
 190             if (!selectedStrategy.isEarliest()) {
 191                 // For non-earliest schedules, we need to do a second pass.
 192                 BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap = new BlockMap&lt;&gt;(cfg);
 193                 for (Block b : cfg.getBlocks()) {
 194                     latestBlockToNodesMap.put(b, new ArrayList&lt;&gt;());
 195                 }
 196 
 197                 BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap = calcLatestBlocks(selectedStrategy, currentNodeMap, earliestBlockToNodesMap, visited, latestBlockToNodesMap, immutableGraph);
 198                 sortNodesLatestWithinBlock(cfg, earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited);
 199 
 200                 assert verifySchedule(cfg, latestBlockToNodesMap, currentNodeMap);
<span class="line-modified"> 201                 assert (!Assertions.detailedAssertionsEnabled(graph.getOptions())) || MemoryScheduleVerification.check(cfg.getStartBlock(), latestBlockToNodesMap);</span>

 202 
 203                 this.blockToNodesMap = latestBlockToNodesMap;
 204 
 205             }
 206             cfg.setNodeToBlock(currentNodeMap);
 207 
 208             graph.setLastSchedule(new ScheduleResult(this.cfg, this.nodeToBlockMap, this.blockToNodesMap));
 209         }
 210 
 211         @SuppressFBWarnings(value = &quot;RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE&quot;, justification = &quot;false positive found by findbugs&quot;)
 212         private BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; calcLatestBlocks(SchedulingStrategy strategy, NodeMap&lt;Block&gt; currentNodeMap, BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap, NodeBitMap visited,
 213                         BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, boolean immutableGraph) {
 214             BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap = new BlockMap&lt;&gt;(cfg);
 215             Block[] reversePostOrder = cfg.reversePostOrder();
 216             for (int j = reversePostOrder.length - 1; j &gt;= 0; --j) {
 217                 Block currentBlock = reversePostOrder[j];
 218                 List&lt;Node&gt; blockToNodes = earliestBlockToNodesMap.get(currentBlock);
 219                 LocationSet killed = null;
 220                 int previousIndex = blockToNodes.size();
 221                 for (int i = blockToNodes.size() - 1; i &gt;= 0; --i) {
 222                     Node currentNode = blockToNodes.get(i);
 223                     assert currentNodeMap.get(currentNode) == currentBlock;
 224                     assert !(currentNode instanceof PhiNode) &amp;&amp; !(currentNode instanceof ProxyNode);
 225                     assert visited.isMarked(currentNode);
 226                     if (currentNode instanceof FixedNode) {
 227                         // For these nodes, the earliest is at the same time the latest block.
 228                     } else {
 229                         Block latestBlock = null;
 230 






 231                         LocationIdentity constrainingLocation = null;
<span class="line-modified"> 232                         if (currentNode instanceof FloatingReadNode) {</span>
 233                             // We are scheduling a floating read node =&gt; check memory
 234                             // anti-dependencies.
 235                             FloatingReadNode floatingReadNode = (FloatingReadNode) currentNode;
 236                             LocationIdentity location = floatingReadNode.getLocationIdentity();
 237                             if (location.isMutable()) {
 238                                 // Location can be killed.
 239                                 constrainingLocation = location;
 240                                 if (currentBlock.canKill(location)) {
 241                                     if (killed == null) {
 242                                         killed = new LocationSet();
 243                                     }
 244                                     fillKillSet(killed, blockToNodes.subList(i + 1, previousIndex));
 245                                     previousIndex = i;
 246                                     if (killed.contains(location)) {
 247                                         // Earliest block kills location =&gt; we need to stay within
 248                                         // earliest block.
 249                                         latestBlock = currentBlock;
 250                                     }
 251                                 }
 252                             }
</pre>
<hr />
<pre>
 327             assert dominatorChain.get(dominatorChain.size() - 1).getDominator() == earliestBlock;
 328 
 329             Block lastBlock = earliestBlock;
 330             for (int i = dominatorChain.size() - 1; i &gt;= 0; --i) {
 331                 Block currentBlock = dominatorChain.get(i);
 332                 if (currentBlock.getLoopDepth() &gt; lastBlock.getLoopDepth()) {
 333                     // We are entering a loop boundary. The new loops must not kill the location for
 334                     // the crossing to be safe.
 335                     if (currentBlock.getLoop() != null &amp;&amp; ((HIRLoop) currentBlock.getLoop()).canKill(location)) {
 336                         break;
 337                     }
 338                 }
 339 
 340                 if (currentBlock.canKillBetweenThisAndDominator(location)) {
 341                     break;
 342                 }
 343                 lastBlock = currentBlock;
 344             }
 345 
 346             if (lastBlock.getBeginNode() instanceof KillingBeginNode) {
<span class="line-modified"> 347                 LocationIdentity locationIdentity = ((KillingBeginNode) lastBlock.getBeginNode()).getLocationIdentity();</span>
 348                 if ((locationIdentity.isAny() || locationIdentity.equals(location)) &amp;&amp; lastBlock != earliestBlock) {
 349                     // The begin of this block kills the location, so we *have* to schedule the node
 350                     // in the dominating block.
 351                     lastBlock = lastBlock.getDominator();
 352                 }
 353             }
 354 
 355             return lastBlock;
 356         }
 357 
 358         private static void fillKillSet(LocationSet killed, List&lt;Node&gt; subList) {
 359             if (!killed.isAny()) {
 360                 for (Node n : subList) {
 361                     // Check if this node kills a node in the watch list.
 362                     if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified"> 363                         LocationIdentity identity = ((MemoryCheckpoint.Single) n).getLocationIdentity();</span>
 364                         killed.add(identity);
 365                         if (killed.isAny()) {
 366                             return;
 367                         }
 368                     } else if (n instanceof MemoryCheckpoint.Multi) {
<span class="line-modified"> 369                         for (LocationIdentity identity : ((MemoryCheckpoint.Multi) n).getLocationIdentities()) {</span>
 370                             killed.add(identity);
 371                             if (killed.isAny()) {
 372                                 return;
 373                             }
 374                         }
 375                     }
 376                 }
 377             }
 378         }
 379 
 380         private static void sortNodesLatestWithinBlock(ControlFlowGraph cfg, BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap, BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, NodeMap&lt;Block&gt; currentNodeMap,
 381                         BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap, NodeBitMap visited) {
 382             for (Block b : cfg.getBlocks()) {
 383                 sortNodesLatestWithinBlock(b, earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited);
 384             }
 385         }
 386 
 387         private static void sortNodesLatestWithinBlock(Block b, BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap, BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, NodeMap&lt;Block&gt; nodeMap,
 388                         BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap, NodeBitMap unprocessed) {
 389             List&lt;Node&gt; earliestSorting = earliestBlockToNodesMap.get(b);
</pre>
<hr />
<pre>
 440 
 441             for (Node n : latestBlockToNodesMap.get(b)) {
 442                 assert nodeMap.get(n) == b : n;
 443                 assert !(n instanceof FixedNode);
 444                 if (unprocessed.isMarked(n)) {
 445                     sortIntoList(n, b, result, nodeMap, unprocessed, fixedEndNode);
 446                 }
 447             }
 448 
 449             if (endNode != null &amp;&amp; unprocessed.isMarked(endNode)) {
 450                 sortIntoList(endNode, b, result, nodeMap, unprocessed, null);
 451             }
 452 
 453             latestBlockToNodesMap.put(b, result);
 454         }
 455 
 456         private static void checkWatchList(Block b, NodeMap&lt;Block&gt; nodeMap, NodeBitMap unprocessed, ArrayList&lt;Node&gt; result, ArrayList&lt;FloatingReadNode&gt; watchList, Node n) {
 457             if (watchList != null &amp;&amp; !watchList.isEmpty()) {
 458                 // Check if this node kills a node in the watch list.
 459                 if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified"> 460                     LocationIdentity identity = ((MemoryCheckpoint.Single) n).getLocationIdentity();</span>
 461                     checkWatchList(watchList, identity, b, result, nodeMap, unprocessed);
 462                 } else if (n instanceof MemoryCheckpoint.Multi) {
<span class="line-modified"> 463                     for (LocationIdentity identity : ((MemoryCheckpoint.Multi) n).getLocationIdentities()) {</span>
 464                         checkWatchList(watchList, identity, b, result, nodeMap, unprocessed);
 465                     }
 466                 }
 467             }
 468         }
 469 
 470         private static void checkWatchList(ArrayList&lt;FloatingReadNode&gt; watchList, LocationIdentity identity, Block b, ArrayList&lt;Node&gt; result, NodeMap&lt;Block&gt; nodeMap, NodeBitMap unprocessed) {
 471             if (identity.isImmutable()) {
 472                 // Nothing to do. This can happen for an initialization write.
 473             } else if (identity.isAny()) {
 474                 for (FloatingReadNode r : watchList) {
 475                     if (unprocessed.isMarked(r)) {
 476                         sortIntoList(r, b, result, nodeMap, unprocessed, null);
 477                     }
 478                 }
 479                 watchList.clear();
 480             } else {
 481                 int index = 0;
 482                 while (index &lt; watchList.size()) {
 483                     FloatingReadNode r = watchList.get(index);
</pre>
<hr />
<pre>
 527             Block latestBlock = null;
 528             if (!currentNode.hasUsages()) {
 529                 assert currentNode instanceof GuardNode;
 530                 latestBlock = earliestBlock;
 531             } else {
 532                 assert currentNode.hasUsages();
 533                 for (Node usage : currentNode.usages()) {
 534                     if (immutableGraph &amp;&amp; !visited.contains(usage)) {
 535                         /*
 536                          * Normally, dead nodes are deleted by the scheduler before we reach this
 537                          * point. Only when the scheduler is asked to not modify a graph, we can see
 538                          * dead nodes here.
 539                          */
 540                         continue;
 541                     }
 542                     latestBlock = calcBlockForUsage(currentNode, usage, latestBlock, currentNodeMap);
 543                 }
 544 
 545                 assert latestBlock != null : currentNode;
 546 
<span class="line-modified"> 547                 if (strategy == SchedulingStrategy.FINAL_SCHEDULE || strategy == SchedulingStrategy.LATEST_OUT_OF_LOOPS) {</span>
 548                     Block currentBlock = latestBlock;
 549                     while (currentBlock.getLoopDepth() &gt; earliestBlock.getLoopDepth() &amp;&amp; currentBlock != earliestBlock.getDominator()) {
 550                         Block previousCurrentBlock = currentBlock;
 551                         currentBlock = currentBlock.getDominator();
 552                         if (previousCurrentBlock.isLoopHeader()) {
 553                             if (currentBlock.getRelativeFrequency() &lt; latestBlock.getRelativeFrequency() || ((StructuredGraph) currentNode.graph()).hasValueProxies()) {
 554                                 // Only assign new latest block if frequency is actually lower or if
 555                                 // loop proxies would be required otherwise.
 556                                 latestBlock = currentBlock;
 557                             }
 558                         }
 559                     }
 560                 }
 561 
 562                 if (latestBlock != earliestBlock &amp;&amp; latestBlock != earliestBlock.getDominator() &amp;&amp; constrainingLocation != null) {
 563                     latestBlock = checkKillsBetween(earliestBlock, latestBlock, constrainingLocation);
 564                 }
 565             }
 566 
<span class="line-modified"> 567             if (latestBlock != earliestBlock &amp;&amp; currentNode instanceof FloatingReadNode) {</span>
<span class="line-modified"> 568 </span>
<span class="line-modified"> 569                 FloatingReadNode floatingReadNode = (FloatingReadNode) currentNode;</span>
<span class="line-removed"> 570                 if (isImplicitNullOpportunity(floatingReadNode, earliestBlock) &amp;&amp;</span>
<span class="line-removed"> 571                                 earliestBlock.getRelativeFrequency() &lt; latestBlock.getRelativeFrequency() * IMPLICIT_NULL_CHECK_OPPORTUNITY_PROBABILITY_FACTOR) {</span>
<span class="line-removed"> 572                     latestBlock = earliestBlock;</span>
<span class="line-removed"> 573                 }</span>
 574             }
 575 
 576             selectLatestBlock(currentNode, earliestBlock, latestBlock, currentNodeMap, watchListMap, constrainingLocation, latestBlockToNodesMap);
 577         }
 578 
<span class="line-modified"> 579         private static boolean isImplicitNullOpportunity(FloatingReadNode floatingReadNode, Block block) {</span>
<span class="line-modified"> 580 </span>
<span class="line-modified"> 581             Node pred = block.getBeginNode().predecessor();</span>
<span class="line-modified"> 582             if (pred instanceof IfNode) {</span>
<span class="line-modified"> 583                 IfNode ifNode = (IfNode) pred;</span>
<span class="line-modified"> 584                 if (ifNode.condition() instanceof IsNullNode) {</span>
<span class="line-modified"> 585                     IsNullNode isNullNode = (IsNullNode) ifNode.condition();</span>
<span class="line-modified"> 586                     if (getUnproxifiedUncompressed(floatingReadNode.getAddress().getBase()) == getUnproxifiedUncompressed(isNullNode.getValue())) {</span>
<span class="line-modified"> 587                         return true;</span>


 588                     }
 589                 }
 590             }
 591             return false;
 592         }
 593 
 594         private static Node getUnproxifiedUncompressed(Node node) {
 595             Node result = node;
 596             while (true) {
 597                 if (result instanceof ValueProxy) {
 598                     ValueProxy valueProxy = (ValueProxy) result;
 599                     result = valueProxy.getOriginalNode();
 600                 } else if (result instanceof ConvertNode) {
 601                     ConvertNode convertNode = (ConvertNode) result;
 602                     if (convertNode.mayNullCheckSkipConversion()) {
 603                         result = convertNode.getValue();
 604                     } else {
 605                         break;
 606                     }
 607                 } else {
</pre>
<hr />
<pre>
 867                 }
 868 
 869                 // Initialize with begin node, it is always the first node.
 870                 ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(totalCount);
 871                 blockToNodes.put(b, nodes);
 872 
 873                 for (FixedNode current : b.getBeginNode().getBlockNodes()) {
 874                     MicroBlock microBlock = entries.get(current);
 875                     nodeToBlock.set(current, b);
 876                     nodes.add(current);
 877                     NodeEntry next = microBlock.getFirstNode();
 878                     while (next != null) {
 879                         Node nextNode = next.getNode();
 880                         nodeToBlock.set(nextNode, b);
 881                         nodes.add(nextNode);
 882                         next = next.getNext();
 883                     }
 884                 }
 885             }
 886 
<span class="line-modified"> 887             assert (!Assertions.detailedAssertionsEnabled(cfg.graph.getOptions())) || MemoryScheduleVerification.check(cfg.getStartBlock(), blockToNodes);</span>
 888         }
 889 
 890         private static void processNodes(NodeBitMap visited, NodeMap&lt;MicroBlock&gt; entries, NodeStack stack, MicroBlock startBlock, Iterable&lt;? extends Node&gt; nodes) {
 891             for (Node node : nodes) {
 892                 if (entries.get(node) == null) {
 893                     processStack(node, startBlock, entries, visited, stack);
 894                 }
 895             }
 896         }
 897 
 898         private static void processStackPhi(NodeStack stack, PhiNode phiNode, NodeMap&lt;MicroBlock&gt; nodeToBlock, NodeBitMap visited) {
 899             stack.pop();
 900             if (visited.checkAndMarkInc(phiNode)) {
 901                 MicroBlock mergeBlock = nodeToBlock.get(phiNode.merge());
 902                 assert mergeBlock != null : phiNode;
 903                 nodeToBlock.set(phiNode, mergeBlock);
 904                 AbstractMergeNode merge = phiNode.merge();
 905                 for (int i = 0; i &lt; merge.forwardEndCount(); ++i) {
 906                     Node input = phiNode.valueAt(i);
 907                     if (input != null &amp;&amp; nodeToBlock.get(input) == null) {
</pre>
<hr />
<pre>
1154                 buf.format(&quot;succs: %s ====%n&quot;, Arrays.toString(b.getSuccessors()));
1155 
1156                 if (blockToNodesMap.get(b) != null) {
1157                     for (Node n : nodesFor(b)) {
1158                         printNode(n);
1159                     }
1160                 } else {
1161                     for (Node n : b.getNodes()) {
1162                         printNode(n);
1163                     }
1164                 }
1165             }
1166             buf.format(&quot;%n&quot;);
1167             return buf.toString();
1168         }
1169 
1170         private static void printNode(Node n) {
1171             Formatter buf = new Formatter();
1172             buf.format(&quot;%s&quot;, n);
1173             if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified">1174                 buf.format(&quot; // kills %s&quot;, ((MemoryCheckpoint.Single) n).getLocationIdentity());</span>
1175             } else if (n instanceof MemoryCheckpoint.Multi) {
1176                 buf.format(&quot; // kills &quot;);
<span class="line-modified">1177                 for (LocationIdentity locid : ((MemoryCheckpoint.Multi) n).getLocationIdentities()) {</span>
1178                     buf.format(&quot;%s, &quot;, locid);
1179                 }
1180             } else if (n instanceof FloatingReadNode) {
1181                 FloatingReadNode frn = (FloatingReadNode) n;
1182                 buf.format(&quot; // from %s&quot;, frn.getLocationIdentity());
1183                 buf.format(&quot;, lastAccess: %s&quot;, frn.getLastLocationAccess());
1184                 buf.format(&quot;, address: %s&quot;, frn.getAddress());
1185             } else if (n instanceof GuardNode) {
1186                 buf.format(&quot;, anchor: %s&quot;, ((GuardNode) n).getAnchor());
1187             }
1188             n.getDebug().log(&quot;%s&quot;, buf);
1189         }
1190 
1191         public ControlFlowGraph getCFG() {
1192             return cfg;
1193         }
1194 
1195         /**
1196          * Gets the nodes in a given block.
1197          */
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  77 import org.graalvm.compiler.nodes.calc.ConvertNode;
  78 import org.graalvm.compiler.nodes.calc.IsNullNode;
  79 import org.graalvm.compiler.nodes.cfg.Block;
  80 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  81 import org.graalvm.compiler.nodes.cfg.HIRLoop;
  82 import org.graalvm.compiler.nodes.cfg.LocationSet;
  83 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
  84 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;
  85 import org.graalvm.compiler.nodes.spi.ValueProxy;
  86 import org.graalvm.compiler.options.OptionValues;
  87 import org.graalvm.compiler.phases.Phase;
  88 import jdk.internal.vm.compiler.word.LocationIdentity;
  89 
  90 public final class SchedulePhase extends Phase {
  91 
  92     public enum SchedulingStrategy {
  93         EARLIEST_WITH_GUARD_ORDER,
  94         EARLIEST,
  95         LATEST,
  96         LATEST_OUT_OF_LOOPS,
<span class="line-modified">  97         LATEST_OUT_OF_LOOPS_IMPLICIT_NULL_CHECKS;</span>
  98 
  99         public boolean isEarliest() {
 100             return this == EARLIEST || this == EARLIEST_WITH_GUARD_ORDER;
 101         }
 102 
 103         public boolean isLatest() {
 104             return !isEarliest();
 105         }
<span class="line-added"> 106 </span>
<span class="line-added"> 107         public boolean scheduleOutOfLoops() {</span>
<span class="line-added"> 108             return this == LATEST_OUT_OF_LOOPS || this == LATEST_OUT_OF_LOOPS_IMPLICIT_NULL_CHECKS;</span>
<span class="line-added"> 109         }</span>
<span class="line-added"> 110 </span>
<span class="line-added"> 111         public boolean considerImplicitNullChecks() {</span>
<span class="line-added"> 112             return this == LATEST_OUT_OF_LOOPS_IMPLICIT_NULL_CHECKS;</span>
<span class="line-added"> 113         }</span>
 114     }
 115 
 116     private final SchedulingStrategy selectedStrategy;
 117 
 118     private final boolean immutableGraph;
 119 
 120     public SchedulePhase(OptionValues options) {
 121         this(false, options);
 122     }
 123 
 124     public SchedulePhase(boolean immutableGraph, OptionValues options) {
 125         this(OptScheduleOutOfLoops.getValue(options) ? SchedulingStrategy.LATEST_OUT_OF_LOOPS : SchedulingStrategy.LATEST, immutableGraph);
 126     }
 127 
 128     public SchedulePhase(SchedulingStrategy strategy) {
 129         this(strategy, false);
 130     }
 131 
 132     public SchedulePhase(SchedulingStrategy strategy, boolean immutableGraph) {
 133         this.selectedStrategy = strategy;
</pre>
<hr />
<pre>
 189 
 190             NodeMap&lt;Block&gt; currentNodeMap = graph.createNodeMap();
 191             NodeBitMap visited = graph.createNodeBitMap();
 192             BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap = new BlockMap&lt;&gt;(cfg);
 193             this.nodeToBlockMap = currentNodeMap;
 194             this.blockToNodesMap = earliestBlockToNodesMap;
 195 
 196             scheduleEarliestIterative(earliestBlockToNodesMap, currentNodeMap, visited, graph, immutableGraph, selectedStrategy == SchedulingStrategy.EARLIEST_WITH_GUARD_ORDER);
 197 
 198             if (!selectedStrategy.isEarliest()) {
 199                 // For non-earliest schedules, we need to do a second pass.
 200                 BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap = new BlockMap&lt;&gt;(cfg);
 201                 for (Block b : cfg.getBlocks()) {
 202                     latestBlockToNodesMap.put(b, new ArrayList&lt;&gt;());
 203                 }
 204 
 205                 BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap = calcLatestBlocks(selectedStrategy, currentNodeMap, earliestBlockToNodesMap, visited, latestBlockToNodesMap, immutableGraph);
 206                 sortNodesLatestWithinBlock(cfg, earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited);
 207 
 208                 assert verifySchedule(cfg, latestBlockToNodesMap, currentNodeMap);
<span class="line-modified"> 209                 assert (!Assertions.detailedAssertionsEnabled(graph.getOptions())) ||</span>
<span class="line-added"> 210                                 ScheduleVerification.check(cfg.getStartBlock(), latestBlockToNodesMap, currentNodeMap);</span>
 211 
 212                 this.blockToNodesMap = latestBlockToNodesMap;
 213 
 214             }
 215             cfg.setNodeToBlock(currentNodeMap);
 216 
 217             graph.setLastSchedule(new ScheduleResult(this.cfg, this.nodeToBlockMap, this.blockToNodesMap));
 218         }
 219 
 220         @SuppressFBWarnings(value = &quot;RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE&quot;, justification = &quot;false positive found by findbugs&quot;)
 221         private BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; calcLatestBlocks(SchedulingStrategy strategy, NodeMap&lt;Block&gt; currentNodeMap, BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap, NodeBitMap visited,
 222                         BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, boolean immutableGraph) {
 223             BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap = new BlockMap&lt;&gt;(cfg);
 224             Block[] reversePostOrder = cfg.reversePostOrder();
 225             for (int j = reversePostOrder.length - 1; j &gt;= 0; --j) {
 226                 Block currentBlock = reversePostOrder[j];
 227                 List&lt;Node&gt; blockToNodes = earliestBlockToNodesMap.get(currentBlock);
 228                 LocationSet killed = null;
 229                 int previousIndex = blockToNodes.size();
 230                 for (int i = blockToNodes.size() - 1; i &gt;= 0; --i) {
 231                     Node currentNode = blockToNodes.get(i);
 232                     assert currentNodeMap.get(currentNode) == currentBlock;
 233                     assert !(currentNode instanceof PhiNode) &amp;&amp; !(currentNode instanceof ProxyNode);
 234                     assert visited.isMarked(currentNode);
 235                     if (currentNode instanceof FixedNode) {
 236                         // For these nodes, the earliest is at the same time the latest block.
 237                     } else {
 238                         Block latestBlock = null;
 239 
<span class="line-added"> 240                         if (currentBlock.getFirstDominated() == null &amp;&amp; !(currentNode instanceof VirtualState)) {</span>
<span class="line-added"> 241                             // This block doesn&#39;t dominate any other blocks =&gt;</span>
<span class="line-added"> 242                             // node must be scheduled in earliest block.</span>
<span class="line-added"> 243                             latestBlock = currentBlock;</span>
<span class="line-added"> 244                         }</span>
<span class="line-added"> 245 </span>
 246                         LocationIdentity constrainingLocation = null;
<span class="line-modified"> 247                         if (latestBlock == null &amp;&amp; currentNode instanceof FloatingReadNode) {</span>
 248                             // We are scheduling a floating read node =&gt; check memory
 249                             // anti-dependencies.
 250                             FloatingReadNode floatingReadNode = (FloatingReadNode) currentNode;
 251                             LocationIdentity location = floatingReadNode.getLocationIdentity();
 252                             if (location.isMutable()) {
 253                                 // Location can be killed.
 254                                 constrainingLocation = location;
 255                                 if (currentBlock.canKill(location)) {
 256                                     if (killed == null) {
 257                                         killed = new LocationSet();
 258                                     }
 259                                     fillKillSet(killed, blockToNodes.subList(i + 1, previousIndex));
 260                                     previousIndex = i;
 261                                     if (killed.contains(location)) {
 262                                         // Earliest block kills location =&gt; we need to stay within
 263                                         // earliest block.
 264                                         latestBlock = currentBlock;
 265                                     }
 266                                 }
 267                             }
</pre>
<hr />
<pre>
 342             assert dominatorChain.get(dominatorChain.size() - 1).getDominator() == earliestBlock;
 343 
 344             Block lastBlock = earliestBlock;
 345             for (int i = dominatorChain.size() - 1; i &gt;= 0; --i) {
 346                 Block currentBlock = dominatorChain.get(i);
 347                 if (currentBlock.getLoopDepth() &gt; lastBlock.getLoopDepth()) {
 348                     // We are entering a loop boundary. The new loops must not kill the location for
 349                     // the crossing to be safe.
 350                     if (currentBlock.getLoop() != null &amp;&amp; ((HIRLoop) currentBlock.getLoop()).canKill(location)) {
 351                         break;
 352                     }
 353                 }
 354 
 355                 if (currentBlock.canKillBetweenThisAndDominator(location)) {
 356                     break;
 357                 }
 358                 lastBlock = currentBlock;
 359             }
 360 
 361             if (lastBlock.getBeginNode() instanceof KillingBeginNode) {
<span class="line-modified"> 362                 LocationIdentity locationIdentity = ((KillingBeginNode) lastBlock.getBeginNode()).getKilledLocationIdentity();</span>
 363                 if ((locationIdentity.isAny() || locationIdentity.equals(location)) &amp;&amp; lastBlock != earliestBlock) {
 364                     // The begin of this block kills the location, so we *have* to schedule the node
 365                     // in the dominating block.
 366                     lastBlock = lastBlock.getDominator();
 367                 }
 368             }
 369 
 370             return lastBlock;
 371         }
 372 
 373         private static void fillKillSet(LocationSet killed, List&lt;Node&gt; subList) {
 374             if (!killed.isAny()) {
 375                 for (Node n : subList) {
 376                     // Check if this node kills a node in the watch list.
 377                     if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified"> 378                         LocationIdentity identity = ((MemoryCheckpoint.Single) n).getKilledLocationIdentity();</span>
 379                         killed.add(identity);
 380                         if (killed.isAny()) {
 381                             return;
 382                         }
 383                     } else if (n instanceof MemoryCheckpoint.Multi) {
<span class="line-modified"> 384                         for (LocationIdentity identity : ((MemoryCheckpoint.Multi) n).getKilledLocationIdentities()) {</span>
 385                             killed.add(identity);
 386                             if (killed.isAny()) {
 387                                 return;
 388                             }
 389                         }
 390                     }
 391                 }
 392             }
 393         }
 394 
 395         private static void sortNodesLatestWithinBlock(ControlFlowGraph cfg, BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap, BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, NodeMap&lt;Block&gt; currentNodeMap,
 396                         BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap, NodeBitMap visited) {
 397             for (Block b : cfg.getBlocks()) {
 398                 sortNodesLatestWithinBlock(b, earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited);
 399             }
 400         }
 401 
 402         private static void sortNodesLatestWithinBlock(Block b, BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap, BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, NodeMap&lt;Block&gt; nodeMap,
 403                         BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap, NodeBitMap unprocessed) {
 404             List&lt;Node&gt; earliestSorting = earliestBlockToNodesMap.get(b);
</pre>
<hr />
<pre>
 455 
 456             for (Node n : latestBlockToNodesMap.get(b)) {
 457                 assert nodeMap.get(n) == b : n;
 458                 assert !(n instanceof FixedNode);
 459                 if (unprocessed.isMarked(n)) {
 460                     sortIntoList(n, b, result, nodeMap, unprocessed, fixedEndNode);
 461                 }
 462             }
 463 
 464             if (endNode != null &amp;&amp; unprocessed.isMarked(endNode)) {
 465                 sortIntoList(endNode, b, result, nodeMap, unprocessed, null);
 466             }
 467 
 468             latestBlockToNodesMap.put(b, result);
 469         }
 470 
 471         private static void checkWatchList(Block b, NodeMap&lt;Block&gt; nodeMap, NodeBitMap unprocessed, ArrayList&lt;Node&gt; result, ArrayList&lt;FloatingReadNode&gt; watchList, Node n) {
 472             if (watchList != null &amp;&amp; !watchList.isEmpty()) {
 473                 // Check if this node kills a node in the watch list.
 474                 if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified"> 475                     LocationIdentity identity = ((MemoryCheckpoint.Single) n).getKilledLocationIdentity();</span>
 476                     checkWatchList(watchList, identity, b, result, nodeMap, unprocessed);
 477                 } else if (n instanceof MemoryCheckpoint.Multi) {
<span class="line-modified"> 478                     for (LocationIdentity identity : ((MemoryCheckpoint.Multi) n).getKilledLocationIdentities()) {</span>
 479                         checkWatchList(watchList, identity, b, result, nodeMap, unprocessed);
 480                     }
 481                 }
 482             }
 483         }
 484 
 485         private static void checkWatchList(ArrayList&lt;FloatingReadNode&gt; watchList, LocationIdentity identity, Block b, ArrayList&lt;Node&gt; result, NodeMap&lt;Block&gt; nodeMap, NodeBitMap unprocessed) {
 486             if (identity.isImmutable()) {
 487                 // Nothing to do. This can happen for an initialization write.
 488             } else if (identity.isAny()) {
 489                 for (FloatingReadNode r : watchList) {
 490                     if (unprocessed.isMarked(r)) {
 491                         sortIntoList(r, b, result, nodeMap, unprocessed, null);
 492                     }
 493                 }
 494                 watchList.clear();
 495             } else {
 496                 int index = 0;
 497                 while (index &lt; watchList.size()) {
 498                     FloatingReadNode r = watchList.get(index);
</pre>
<hr />
<pre>
 542             Block latestBlock = null;
 543             if (!currentNode.hasUsages()) {
 544                 assert currentNode instanceof GuardNode;
 545                 latestBlock = earliestBlock;
 546             } else {
 547                 assert currentNode.hasUsages();
 548                 for (Node usage : currentNode.usages()) {
 549                     if (immutableGraph &amp;&amp; !visited.contains(usage)) {
 550                         /*
 551                          * Normally, dead nodes are deleted by the scheduler before we reach this
 552                          * point. Only when the scheduler is asked to not modify a graph, we can see
 553                          * dead nodes here.
 554                          */
 555                         continue;
 556                     }
 557                     latestBlock = calcBlockForUsage(currentNode, usage, latestBlock, currentNodeMap);
 558                 }
 559 
 560                 assert latestBlock != null : currentNode;
 561 
<span class="line-modified"> 562                 if (strategy.scheduleOutOfLoops()) {</span>
 563                     Block currentBlock = latestBlock;
 564                     while (currentBlock.getLoopDepth() &gt; earliestBlock.getLoopDepth() &amp;&amp; currentBlock != earliestBlock.getDominator()) {
 565                         Block previousCurrentBlock = currentBlock;
 566                         currentBlock = currentBlock.getDominator();
 567                         if (previousCurrentBlock.isLoopHeader()) {
 568                             if (currentBlock.getRelativeFrequency() &lt; latestBlock.getRelativeFrequency() || ((StructuredGraph) currentNode.graph()).hasValueProxies()) {
 569                                 // Only assign new latest block if frequency is actually lower or if
 570                                 // loop proxies would be required otherwise.
 571                                 latestBlock = currentBlock;
 572                             }
 573                         }
 574                     }
 575                 }
 576 
 577                 if (latestBlock != earliestBlock &amp;&amp; latestBlock != earliestBlock.getDominator() &amp;&amp; constrainingLocation != null) {
 578                     latestBlock = checkKillsBetween(earliestBlock, latestBlock, constrainingLocation);
 579                 }
 580             }
 581 
<span class="line-modified"> 582             if (latestBlock != earliestBlock &amp;&amp; strategy.considerImplicitNullChecks() &amp;&amp; isImplicitNullOpportunity(currentNode, earliestBlock) &amp;&amp;</span>
<span class="line-modified"> 583                             earliestBlock.getRelativeFrequency() &lt; latestBlock.getRelativeFrequency() * IMPLICIT_NULL_CHECK_OPPORTUNITY_PROBABILITY_FACTOR) {</span>
<span class="line-modified"> 584                 latestBlock = earliestBlock;</span>




 585             }
 586 
 587             selectLatestBlock(currentNode, earliestBlock, latestBlock, currentNodeMap, watchListMap, constrainingLocation, latestBlockToNodesMap);
 588         }
 589 
<span class="line-modified"> 590         protected static boolean isImplicitNullOpportunity(Node currentNode, Block block) {</span>
<span class="line-modified"> 591             if (currentNode instanceof FloatingReadNode) {</span>
<span class="line-modified"> 592                 FloatingReadNode floatingReadNode = (FloatingReadNode) currentNode;</span>
<span class="line-modified"> 593                 Node pred = block.getBeginNode().predecessor();</span>
<span class="line-modified"> 594                 if (pred instanceof IfNode) {</span>
<span class="line-modified"> 595                     IfNode ifNode = (IfNode) pred;</span>
<span class="line-modified"> 596                     if (ifNode.condition() instanceof IsNullNode &amp;&amp; ifNode.getTrueSuccessorProbability() == 0.0) {</span>
<span class="line-modified"> 597                         IsNullNode isNullNode = (IsNullNode) ifNode.condition();</span>
<span class="line-modified"> 598                         if (getUnproxifiedUncompressed(floatingReadNode.getAddress().getBase()) == getUnproxifiedUncompressed(isNullNode.getValue())) {</span>
<span class="line-added"> 599                             return true;</span>
<span class="line-added"> 600                         }</span>
 601                     }
 602                 }
 603             }
 604             return false;
 605         }
 606 
 607         private static Node getUnproxifiedUncompressed(Node node) {
 608             Node result = node;
 609             while (true) {
 610                 if (result instanceof ValueProxy) {
 611                     ValueProxy valueProxy = (ValueProxy) result;
 612                     result = valueProxy.getOriginalNode();
 613                 } else if (result instanceof ConvertNode) {
 614                     ConvertNode convertNode = (ConvertNode) result;
 615                     if (convertNode.mayNullCheckSkipConversion()) {
 616                         result = convertNode.getValue();
 617                     } else {
 618                         break;
 619                     }
 620                 } else {
</pre>
<hr />
<pre>
 880                 }
 881 
 882                 // Initialize with begin node, it is always the first node.
 883                 ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(totalCount);
 884                 blockToNodes.put(b, nodes);
 885 
 886                 for (FixedNode current : b.getBeginNode().getBlockNodes()) {
 887                     MicroBlock microBlock = entries.get(current);
 888                     nodeToBlock.set(current, b);
 889                     nodes.add(current);
 890                     NodeEntry next = microBlock.getFirstNode();
 891                     while (next != null) {
 892                         Node nextNode = next.getNode();
 893                         nodeToBlock.set(nextNode, b);
 894                         nodes.add(nextNode);
 895                         next = next.getNext();
 896                     }
 897                 }
 898             }
 899 
<span class="line-modified"> 900             assert (!Assertions.detailedAssertionsEnabled(cfg.graph.getOptions())) || ScheduleVerification.check(cfg.getStartBlock(), blockToNodes, nodeToBlock);</span>
 901         }
 902 
 903         private static void processNodes(NodeBitMap visited, NodeMap&lt;MicroBlock&gt; entries, NodeStack stack, MicroBlock startBlock, Iterable&lt;? extends Node&gt; nodes) {
 904             for (Node node : nodes) {
 905                 if (entries.get(node) == null) {
 906                     processStack(node, startBlock, entries, visited, stack);
 907                 }
 908             }
 909         }
 910 
 911         private static void processStackPhi(NodeStack stack, PhiNode phiNode, NodeMap&lt;MicroBlock&gt; nodeToBlock, NodeBitMap visited) {
 912             stack.pop();
 913             if (visited.checkAndMarkInc(phiNode)) {
 914                 MicroBlock mergeBlock = nodeToBlock.get(phiNode.merge());
 915                 assert mergeBlock != null : phiNode;
 916                 nodeToBlock.set(phiNode, mergeBlock);
 917                 AbstractMergeNode merge = phiNode.merge();
 918                 for (int i = 0; i &lt; merge.forwardEndCount(); ++i) {
 919                     Node input = phiNode.valueAt(i);
 920                     if (input != null &amp;&amp; nodeToBlock.get(input) == null) {
</pre>
<hr />
<pre>
1167                 buf.format(&quot;succs: %s ====%n&quot;, Arrays.toString(b.getSuccessors()));
1168 
1169                 if (blockToNodesMap.get(b) != null) {
1170                     for (Node n : nodesFor(b)) {
1171                         printNode(n);
1172                     }
1173                 } else {
1174                     for (Node n : b.getNodes()) {
1175                         printNode(n);
1176                     }
1177                 }
1178             }
1179             buf.format(&quot;%n&quot;);
1180             return buf.toString();
1181         }
1182 
1183         private static void printNode(Node n) {
1184             Formatter buf = new Formatter();
1185             buf.format(&quot;%s&quot;, n);
1186             if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified">1187                 buf.format(&quot; // kills %s&quot;, ((MemoryCheckpoint.Single) n).getKilledLocationIdentity());</span>
1188             } else if (n instanceof MemoryCheckpoint.Multi) {
1189                 buf.format(&quot; // kills &quot;);
<span class="line-modified">1190                 for (LocationIdentity locid : ((MemoryCheckpoint.Multi) n).getKilledLocationIdentities()) {</span>
1191                     buf.format(&quot;%s, &quot;, locid);
1192                 }
1193             } else if (n instanceof FloatingReadNode) {
1194                 FloatingReadNode frn = (FloatingReadNode) n;
1195                 buf.format(&quot; // from %s&quot;, frn.getLocationIdentity());
1196                 buf.format(&quot;, lastAccess: %s&quot;, frn.getLastLocationAccess());
1197                 buf.format(&quot;, address: %s&quot;, frn.getAddress());
1198             } else if (n instanceof GuardNode) {
1199                 buf.format(&quot;, anchor: %s&quot;, ((GuardNode) n).getAnchor());
1200             }
1201             n.getDebug().log(&quot;%s&quot;, buf);
1202         }
1203 
1204         public ControlFlowGraph getCFG() {
1205             return cfg;
1206         }
1207 
1208         /**
1209          * Gets the nodes in a given block.
1210          */
</pre>
</td>
</tr>
</table>
<center><a href="../graph/ReentrantBlockIterator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../tiers/HighTierContext.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
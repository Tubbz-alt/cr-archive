<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/util/GraphOrder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../tiers/MidTierContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="Providers.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/util/GraphOrder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
141                         nodes.add(phi);
142                     }
143                 }
144                 if (stateAfter != null) {
145                     visitForward(nodes, visited, stateAfter, true);
146                 }
147             }
148         } catch (GraalError e) {
149             throw GraalGraphError.transformAndAddContext(e, node);
150         }
151     }
152 
153     /**
154      * This method schedules the graph and makes sure that, for every node, all inputs are available
155      * at the position where it is scheduled. This is a very expensive assertion.
156      */
157     @SuppressWarnings(&quot;try&quot;)
158     public static boolean assertSchedulableGraph(final StructuredGraph graph) {
159         assert graph.getGuardsStage() != GuardsStage.AFTER_FSA : &quot;Cannot use the BlockIteratorClosure after FrameState Assignment, HIR Loop Data Structures are no longer valid.&quot;;
160         try (DebugContext.Scope s = graph.getDebug().scope(&quot;AssertSchedulableGraph&quot;)) {
<span class="line-modified">161             final SchedulePhase schedulePhase = new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true);</span>
162             final EconomicMap&lt;LoopBeginNode, NodeBitMap&gt; loopEntryStates = EconomicMap.create(Equivalence.IDENTITY);
163             schedulePhase.apply(graph, false);
164             final ScheduleResult schedule = graph.getLastSchedule();
165 
166             BlockIteratorClosure&lt;NodeBitMap&gt; closure = new BlockIteratorClosure&lt;NodeBitMap&gt;() {
167 
168                 @Override
169                 protected List&lt;NodeBitMap&gt; processLoop(Loop&lt;Block&gt; loop, NodeBitMap initialState) {
170                     return ReentrantBlockIterator.processLoop(this, loop, initialState).exitStates;
171                 }
172 
173                 @Override
174                 protected NodeBitMap processBlock(final Block block, final NodeBitMap currentState) {
175                     final List&lt;Node&gt; list = graph.getLastSchedule().getBlockToNodesMap().get(block);
176 
177                     /*
178                      * A stateAfter is not valid directly after its associated state split, but
179                      * right before the next fixed node. Therefore a pending stateAfter is kept that
180                      * will be checked at the correct position.
181                      */
</pre>
<hr />
<pre>
199                             }
200 
201                             if (node instanceof AbstractMergeNode) {
202                                 // phis aren&#39;t scheduled, so they need to be added explicitly
203                                 currentState.markAll(((AbstractMergeNode) node).phis());
204                                 if (node instanceof LoopBeginNode) {
205                                     // remember the state at the loop entry, it&#39;s restored at exits
206                                     loopEntryStates.put((LoopBeginNode) node, currentState.copy());
207                                 }
208                             } else if (node instanceof ProxyNode) {
209                                 assert false : &quot;proxy nodes should not be in the schedule&quot;;
210                             } else if (node instanceof LoopExitNode) {
211                                 if (graph.hasValueProxies()) {
212                                     for (ProxyNode proxy : ((LoopExitNode) node).proxies()) {
213                                         for (Node input : proxy.inputs()) {
214                                             if (input != proxy.proxyPoint()) {
215                                                 assert currentState.isMarked(input) : input + &quot; not available at &quot; + proxy + &quot; in block &quot; + block + &quot;\n&quot; + list;
216                                             }
217                                         }
218                                     }
<span class="line-removed">219 </span>
220                                     // loop contents are only accessible via proxies at the exit
221                                     currentState.clearAll();
222                                     currentState.markAll(loopEntryStates.get(((LoopExitNode) node).loopBegin()));
223                                 }

224                                 // Loop proxies aren&#39;t scheduled, so they need to be added
225                                 // explicitly
226                                 currentState.markAll(((LoopExitNode) node).proxies());
227                             } else {
228                                 for (Node input : node.inputs()) {
229                                     if (input != stateAfter) {
230                                         if (input instanceof FrameState) {
231                                             ((FrameState) input).applyToNonVirtual(new VirtualState.NodeClosure&lt;Node&gt;() {
232                                                 @Override
233                                                 public void apply(Node usage, Node nonVirtual) {
234                                                     assert currentState.isMarked(nonVirtual) : nonVirtual + &quot; not available at &quot; + node + &quot; in block &quot; + block + &quot;\n&quot; + list;
235                                                 }
236                                             });
237                                         } else {
238                                             assert currentState.isMarked(input) || input instanceof VirtualObjectNode || input instanceof ConstantNode : input + &quot; not available at &quot; + node +
239                                                             &quot; in block &quot; + block + &quot;\n&quot; + list;
240                                         }
241                                     }
242                                 }
243                             }
</pre>
<hr />
<pre>
280                 @Override
281                 protected NodeBitMap getInitialState() {
282                     NodeBitMap ret = graph.createNodeBitMap();
283                     ret.markAll(graph.getNodes().filter(ConstantNode.class));
284                     return ret;
285                 }
286 
287                 @Override
288                 protected NodeBitMap cloneState(NodeBitMap oldState) {
289                     return oldState.copy();
290                 }
291             };
292 
293             ReentrantBlockIterator.apply(closure, schedule.getCFG().getStartBlock());
294 
295         } catch (Throwable t) {
296             graph.getDebug().handle(t);
297         }
298         return true;
299     }










300 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
141                         nodes.add(phi);
142                     }
143                 }
144                 if (stateAfter != null) {
145                     visitForward(nodes, visited, stateAfter, true);
146                 }
147             }
148         } catch (GraalError e) {
149             throw GraalGraphError.transformAndAddContext(e, node);
150         }
151     }
152 
153     /**
154      * This method schedules the graph and makes sure that, for every node, all inputs are available
155      * at the position where it is scheduled. This is a very expensive assertion.
156      */
157     @SuppressWarnings(&quot;try&quot;)
158     public static boolean assertSchedulableGraph(final StructuredGraph graph) {
159         assert graph.getGuardsStage() != GuardsStage.AFTER_FSA : &quot;Cannot use the BlockIteratorClosure after FrameState Assignment, HIR Loop Data Structures are no longer valid.&quot;;
160         try (DebugContext.Scope s = graph.getDebug().scope(&quot;AssertSchedulableGraph&quot;)) {
<span class="line-modified">161             final SchedulePhase schedulePhase = new SchedulePhase(getSchedulingPolicy(graph), true);</span>
162             final EconomicMap&lt;LoopBeginNode, NodeBitMap&gt; loopEntryStates = EconomicMap.create(Equivalence.IDENTITY);
163             schedulePhase.apply(graph, false);
164             final ScheduleResult schedule = graph.getLastSchedule();
165 
166             BlockIteratorClosure&lt;NodeBitMap&gt; closure = new BlockIteratorClosure&lt;NodeBitMap&gt;() {
167 
168                 @Override
169                 protected List&lt;NodeBitMap&gt; processLoop(Loop&lt;Block&gt; loop, NodeBitMap initialState) {
170                     return ReentrantBlockIterator.processLoop(this, loop, initialState).exitStates;
171                 }
172 
173                 @Override
174                 protected NodeBitMap processBlock(final Block block, final NodeBitMap currentState) {
175                     final List&lt;Node&gt; list = graph.getLastSchedule().getBlockToNodesMap().get(block);
176 
177                     /*
178                      * A stateAfter is not valid directly after its associated state split, but
179                      * right before the next fixed node. Therefore a pending stateAfter is kept that
180                      * will be checked at the correct position.
181                      */
</pre>
<hr />
<pre>
199                             }
200 
201                             if (node instanceof AbstractMergeNode) {
202                                 // phis aren&#39;t scheduled, so they need to be added explicitly
203                                 currentState.markAll(((AbstractMergeNode) node).phis());
204                                 if (node instanceof LoopBeginNode) {
205                                     // remember the state at the loop entry, it&#39;s restored at exits
206                                     loopEntryStates.put((LoopBeginNode) node, currentState.copy());
207                                 }
208                             } else if (node instanceof ProxyNode) {
209                                 assert false : &quot;proxy nodes should not be in the schedule&quot;;
210                             } else if (node instanceof LoopExitNode) {
211                                 if (graph.hasValueProxies()) {
212                                     for (ProxyNode proxy : ((LoopExitNode) node).proxies()) {
213                                         for (Node input : proxy.inputs()) {
214                                             if (input != proxy.proxyPoint()) {
215                                                 assert currentState.isMarked(input) : input + &quot; not available at &quot; + proxy + &quot; in block &quot; + block + &quot;\n&quot; + list;
216                                             }
217                                         }
218                                     }

219                                     // loop contents are only accessible via proxies at the exit
220                                     currentState.clearAll();
221                                     currentState.markAll(loopEntryStates.get(((LoopExitNode) node).loopBegin()));
222                                 }
<span class="line-added">223 </span>
224                                 // Loop proxies aren&#39;t scheduled, so they need to be added
225                                 // explicitly
226                                 currentState.markAll(((LoopExitNode) node).proxies());
227                             } else {
228                                 for (Node input : node.inputs()) {
229                                     if (input != stateAfter) {
230                                         if (input instanceof FrameState) {
231                                             ((FrameState) input).applyToNonVirtual(new VirtualState.NodeClosure&lt;Node&gt;() {
232                                                 @Override
233                                                 public void apply(Node usage, Node nonVirtual) {
234                                                     assert currentState.isMarked(nonVirtual) : nonVirtual + &quot; not available at &quot; + node + &quot; in block &quot; + block + &quot;\n&quot; + list;
235                                                 }
236                                             });
237                                         } else {
238                                             assert currentState.isMarked(input) || input instanceof VirtualObjectNode || input instanceof ConstantNode : input + &quot; not available at &quot; + node +
239                                                             &quot; in block &quot; + block + &quot;\n&quot; + list;
240                                         }
241                                     }
242                                 }
243                             }
</pre>
<hr />
<pre>
280                 @Override
281                 protected NodeBitMap getInitialState() {
282                     NodeBitMap ret = graph.createNodeBitMap();
283                     ret.markAll(graph.getNodes().filter(ConstantNode.class));
284                     return ret;
285                 }
286 
287                 @Override
288                 protected NodeBitMap cloneState(NodeBitMap oldState) {
289                     return oldState.copy();
290                 }
291             };
292 
293             ReentrantBlockIterator.apply(closure, schedule.getCFG().getStartBlock());
294 
295         } catch (Throwable t) {
296             graph.getDebug().handle(t);
297         }
298         return true;
299     }
<span class="line-added">300 </span>
<span class="line-added">301     /*</span>
<span class="line-added">302      * Complexity of verification for LATEST_OUT_OF_LOOPS with value proxies exceeds the benefits.</span>
<span class="line-added">303      * The problem are floating values that can be scheduled before the loop and have proxies only</span>
<span class="line-added">304      * on some use edges after the loop. These values, which are hard to detect, get scheduled</span>
<span class="line-added">305      * before the loop exit and are not visible in the state after the loop exit.</span>
<span class="line-added">306      */</span>
<span class="line-added">307     private static SchedulingStrategy getSchedulingPolicy(StructuredGraph graph) {</span>
<span class="line-added">308         return graph.hasValueProxies() ? SchedulingStrategy.EARLIEST : SchedulingStrategy.LATEST_OUT_OF_LOOPS;</span>
<span class="line-added">309     }</span>
310 }
</pre>
</td>
</tr>
</table>
<center><a href="../tiers/MidTierContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="Providers.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/util/GraphOrder.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/util/GraphOrder.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/util/GraphOrder.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/util/GraphOrder.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -156,11 +156,11 @@
      */
     @SuppressWarnings("try")
     public static boolean assertSchedulableGraph(final StructuredGraph graph) {
         assert graph.getGuardsStage() != GuardsStage.AFTER_FSA : "Cannot use the BlockIteratorClosure after FrameState Assignment, HIR Loop Data Structures are no longer valid.";
         try (DebugContext.Scope s = graph.getDebug().scope("AssertSchedulableGraph")) {
-            final SchedulePhase schedulePhase = new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true);
+            final SchedulePhase schedulePhase = new SchedulePhase(getSchedulingPolicy(graph), true);
             final EconomicMap<LoopBeginNode, NodeBitMap> loopEntryStates = EconomicMap.create(Equivalence.IDENTITY);
             schedulePhase.apply(graph, false);
             final ScheduleResult schedule = graph.getLastSchedule();
 
             BlockIteratorClosure<NodeBitMap> closure = new BlockIteratorClosure<NodeBitMap>() {
@@ -214,15 +214,15 @@
                                             if (input != proxy.proxyPoint()) {
                                                 assert currentState.isMarked(input) : input + " not available at " + proxy + " in block " + block + "\n" + list;
                                             }
                                         }
                                     }
-
                                     // loop contents are only accessible via proxies at the exit
                                     currentState.clearAll();
                                     currentState.markAll(loopEntryStates.get(((LoopExitNode) node).loopBegin()));
                                 }
+
                                 // Loop proxies aren't scheduled, so they need to be added
                                 // explicitly
                                 currentState.markAll(((LoopExitNode) node).proxies());
                             } else {
                                 for (Node input : node.inputs()) {
@@ -295,6 +295,16 @@
         } catch (Throwable t) {
             graph.getDebug().handle(t);
         }
         return true;
     }
+
+    /*
+     * Complexity of verification for LATEST_OUT_OF_LOOPS with value proxies exceeds the benefits.
+     * The problem are floating values that can be scheduled before the loop and have proxies only
+     * on some use edges after the loop. These values, which are hard to detect, get scheduled
+     * before the loop exit and are not visible in the state after the loop exit.
+     */
+    private static SchedulingStrategy getSchedulingPolicy(StructuredGraph graph) {
+        return graph.hasValueProxies() ? SchedulingStrategy.EARLIEST : SchedulingStrategy.LATEST_OUT_OF_LOOPS;
+    }
 }

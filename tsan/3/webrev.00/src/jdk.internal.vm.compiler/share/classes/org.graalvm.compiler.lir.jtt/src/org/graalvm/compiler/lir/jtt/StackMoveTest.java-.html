<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.jtt/src/org/graalvm/compiler/lir/jtt/StackMoveTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.jtt;
 26 
 27 import org.junit.Before;
 28 import org.junit.Test;
 29 
 30 import org.graalvm.compiler.core.common.LIRKind;
 31 import org.graalvm.compiler.lir.Variable;
 32 import org.graalvm.compiler.lir.VirtualStackSlot;
 33 import org.graalvm.compiler.lir.framemap.FrameMapBuilder;
 34 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 35 
 36 import jdk.vm.ci.meta.JavaKind;
 37 import jdk.vm.ci.meta.PlatformKind;
 38 import jdk.vm.ci.meta.Value;
 39 import jdk.vm.ci.meta.ValueKind;
 40 
 41 public class StackMoveTest extends LIRTest {
 42     private static PlatformKind byteKind;
 43     private static PlatformKind shortKind;
 44 
 45     @Before
 46     public void setUp() {
 47         byteKind = getBackend().getTarget().arch.getPlatformKind(JavaKind.Byte);
 48         shortKind = getBackend().getTarget().arch.getPlatformKind(JavaKind.Short);
 49     }
 50 
 51     private static class StackCopySpec extends LIRTestSpecification {
 52         @Override
 53         public void generate(LIRGeneratorTool gen, Value a) {
 54             FrameMapBuilder frameMapBuilder = gen.getResult().getFrameMapBuilder();
 55             ValueKind&lt;?&gt; valueKind = getValueKind(a);
 56 
 57             // create slots
 58             VirtualStackSlot s1 = frameMapBuilder.allocateSpillSlot(valueKind);
 59             VirtualStackSlot s2 = frameMapBuilder.allocateSpillSlot(valueKind);
 60 
 61             // start emit
 62             gen.emitMove(s1, a);
 63             Value copy1 = gen.emitMove(s1);
 64             gen.append(gen.getSpillMoveFactory().createStackMove(s2, s1));
 65             Variable result = gen.emitMove(s2);
 66             // end emit
 67 
 68             // set output and result
 69             setResult(result);
 70             setOutput(&quot;slotcopy&quot;, copy1);
 71             setOutput(&quot;slot1&quot;, s1);
 72             setOutput(&quot;slot2&quot;, s2);
 73         }
 74 
 75         protected ValueKind&lt;?&gt; getValueKind(Value value) {
 76             return value.getValueKind();
 77         }
 78     }
 79 
 80     private static final LIRTestSpecification stackCopy = new StackCopySpec();
 81 
 82     /*
 83      * int
 84      */
 85 
 86     @SuppressWarnings(&quot;unused&quot;)
 87     @LIRIntrinsic
 88     public static int copyInt(LIRTestSpecification spec, int a) {
 89         return a;
 90     }
 91 
 92     public int[] testInt(int a, int[] out) {
 93         out[0] = copyInt(stackCopy, a);
 94         out[1] = getOutput(stackCopy, &quot;slotcopy&quot;, a);
 95         out[2] = getOutput(stackCopy, &quot;slot1&quot;, a);
 96         out[3] = getOutput(stackCopy, &quot;slot2&quot;, a);
 97         return out;
 98     }
 99 
100     @Test
101     public void runInt() throws Throwable {
102         runTest(&quot;testInt&quot;, Integer.MIN_VALUE, supply(() -&gt; new int[4]));
103         runTest(&quot;testInt&quot;, -1, supply(() -&gt; new int[4]));
104         runTest(&quot;testInt&quot;, 0, supply(() -&gt; new int[4]));
105         runTest(&quot;testInt&quot;, 1, supply(() -&gt; new int[4]));
106         runTest(&quot;testInt&quot;, Integer.MAX_VALUE, supply(() -&gt; new int[4]));
107     }
108 
109     /*
110      * long
111      */
112 
113     @SuppressWarnings(&quot;unused&quot;)
114     @LIRIntrinsic
115     public static long copyLong(LIRTestSpecification spec, long a) {
116         return a;
117     }
118 
119     public long[] testLong(long a, long[] out) {
120         out[0] = copyLong(stackCopy, a);
121         out[1] = getOutput(stackCopy, &quot;slotcopy&quot;, a);
122         out[2] = getOutput(stackCopy, &quot;slot1&quot;, a);
123         out[3] = getOutput(stackCopy, &quot;slot2&quot;, a);
124         return out;
125     }
126 
127     @Test
128     public void runLong() throws Throwable {
129         runTest(&quot;testLong&quot;, Long.MIN_VALUE, supply(() -&gt; new long[3]));
130         runTest(&quot;testLong&quot;, -1L, supply(() -&gt; new long[3]));
131         runTest(&quot;testLong&quot;, 0L, supply(() -&gt; new long[3]));
132         runTest(&quot;testLong&quot;, 1L, supply(() -&gt; new long[3]));
133         runTest(&quot;testLong&quot;, Long.MAX_VALUE, supply(() -&gt; new long[3]));
134     }
135 
136     /*
137      * float
138      */
139 
140     @SuppressWarnings(&quot;unused&quot;)
141     @LIRIntrinsic
142     public static float copyFloat(LIRTestSpecification spec, float a) {
143         return a;
144     }
145 
146     public float[] testFloat(float a, float[] out) {
147         out[0] = copyFloat(stackCopy, a);
148         out[1] = getOutput(stackCopy, &quot;slotcopy&quot;, a);
149         out[2] = getOutput(stackCopy, &quot;slot1&quot;, a);
150         out[3] = getOutput(stackCopy, &quot;slot2&quot;, a);
151         return out;
152     }
153 
154     @Test
155     public void runFloat() throws Throwable {
156         runTest(&quot;testFloat&quot;, Float.MIN_VALUE, supply(() -&gt; new float[3]));
157         runTest(&quot;testFloat&quot;, -1f, supply(() -&gt; new float[3]));
158         runTest(&quot;testFloat&quot;, -0.1f, supply(() -&gt; new float[3]));
159         runTest(&quot;testFloat&quot;, 0f, supply(() -&gt; new float[3]));
160         runTest(&quot;testFloat&quot;, 0.1f, supply(() -&gt; new float[3]));
161         runTest(&quot;testFloat&quot;, 1f, supply(() -&gt; new float[3]));
162         runTest(&quot;testFloat&quot;, Float.MAX_VALUE, supply(() -&gt; new float[3]));
163     }
164 
165     /*
166      * double
167      */
168 
169     @SuppressWarnings(&quot;unused&quot;)
170     @LIRIntrinsic
171     public static double copyDouble(LIRTestSpecification spec, double a) {
172         return a;
173     }
174 
175     public double[] testDouble(double a, double[] out) {
176         out[0] = copyDouble(stackCopy, a);
177         out[1] = getOutput(stackCopy, &quot;slotcopy&quot;, a);
178         out[2] = getOutput(stackCopy, &quot;slot1&quot;, a);
179         out[3] = getOutput(stackCopy, &quot;slot2&quot;, a);
180         return out;
181     }
182 
183     @Test
184     public void runDouble() throws Throwable {
185         runTest(&quot;testDouble&quot;, Double.MIN_VALUE, supply(() -&gt; new double[3]));
186         runTest(&quot;testDouble&quot;, -1., supply(() -&gt; new double[3]));
187         runTest(&quot;testDouble&quot;, -0.1, supply(() -&gt; new double[3]));
188         runTest(&quot;testDouble&quot;, 0., supply(() -&gt; new double[3]));
189         runTest(&quot;testDouble&quot;, 0.1, supply(() -&gt; new double[3]));
190         runTest(&quot;testDouble&quot;, 1., supply(() -&gt; new double[3]));
191         runTest(&quot;testDouble&quot;, Double.MAX_VALUE, supply(() -&gt; new double[3]));
192     }
193 
194     /*
195      * short
196      */
197 
198     private static final LIRTestSpecification shortStackCopy = new StackCopySpec() {
199         @Override
200         protected ValueKind&lt;?&gt; getValueKind(Value value) {
201             return LIRKind.value(shortKind);
202         }
203     };
204 
205     @SuppressWarnings(&quot;unused&quot;)
206     @LIRIntrinsic
207     public static short copyShort(LIRTestSpecification spec, short a) {
208         return a;
209     }
210 
211     public short[] testShort(short a, short[] out) {
212         out[0] = copyShort(shortStackCopy, a);
213         out[1] = getOutput(shortStackCopy, &quot;slotcopy&quot;, a);
214         out[2] = getOutput(shortStackCopy, &quot;slot1&quot;, a);
215         out[3] = getOutput(shortStackCopy, &quot;slot2&quot;, a);
216         return out;
217     }
218 
219     @Test
220     public void runShort() throws Throwable {
221         runTest(&quot;testShort&quot;, Short.MIN_VALUE, supply(() -&gt; new short[3]));
222         runTest(&quot;testShort&quot;, (short) -1, supply(() -&gt; new short[3]));
223         runTest(&quot;testShort&quot;, (short) 0, supply(() -&gt; new short[3]));
224         runTest(&quot;testShort&quot;, (short) 1, supply(() -&gt; new short[3]));
225         runTest(&quot;testShort&quot;, Short.MAX_VALUE, supply(() -&gt; new short[3]));
226     }
227 
228     /*
229      * byte
230      */
231 
232     private static final LIRTestSpecification byteStackCopy = new StackCopySpec() {
233         @Override
234         protected ValueKind&lt;?&gt; getValueKind(Value value) {
235             return LIRKind.value(byteKind);
236         }
237     };
238 
239     @SuppressWarnings(&quot;unused&quot;)
240     @LIRIntrinsic
241     public static byte copyByte(LIRTestSpecification spec, byte a) {
242         return a;
243     }
244 
245     public byte[] testByte(byte a, byte[] out) {
246         out[0] = copyByte(byteStackCopy, a);
247         out[1] = getOutput(byteStackCopy, &quot;slotcopy&quot;, a);
248         out[2] = getOutput(byteStackCopy, &quot;slot1&quot;, a);
249         out[3] = getOutput(byteStackCopy, &quot;slot2&quot;, a);
250         return out;
251     }
252 
253     @Test
254     public void runByte() throws Throwable {
255         runTest(&quot;testByte&quot;, Byte.MIN_VALUE, supply(() -&gt; new byte[3]));
256         runTest(&quot;testByte&quot;, (byte) -1, supply(() -&gt; new byte[3]));
257         runTest(&quot;testByte&quot;, (byte) 0, supply(() -&gt; new byte[3]));
258         runTest(&quot;testByte&quot;, (byte) 1, supply(() -&gt; new byte[3]));
259         runTest(&quot;testByte&quot;, Byte.MAX_VALUE, supply(() -&gt; new byte[3]));
260     }
261 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.jtt/src/org/graalvm/compiler/lir/jtt/StackStoreLoadTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2017, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 package org.graalvm.compiler.lir.jtt;
 27 
 28 import org.junit.Before;
 29 import org.junit.Test;
 30 
 31 import org.graalvm.compiler.core.common.LIRKind;
 32 import org.graalvm.compiler.lir.Variable;
 33 import org.graalvm.compiler.lir.VirtualStackSlot;
 34 import org.graalvm.compiler.lir.framemap.FrameMapBuilder;
 35 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 36 
 37 import jdk.vm.ci.meta.JavaKind;
 38 import jdk.vm.ci.meta.PlatformKind;
 39 import jdk.vm.ci.meta.Value;
 40 import jdk.vm.ci.meta.ValueKind;
 41 
 42 public class StackStoreLoadTest extends LIRTest {
 43     private static PlatformKind byteKind;
 44     private static PlatformKind shortKind;
 45 
 46     @Before
 47     public void setUp() {
 48         byteKind = getBackend().getTarget().arch.getPlatformKind(JavaKind.Byte);
 49         shortKind = getBackend().getTarget().arch.getPlatformKind(JavaKind.Short);
 50     }
 51 
 52     private static class StackStoreLoadSpec extends LIRTestSpecification {
 53         @Override
 54         public void generate(LIRGeneratorTool gen, Value a) {
 55             FrameMapBuilder frameMapBuilder = gen.getResult().getFrameMapBuilder();
 56             ValueKind&lt;?&gt; valueKind = getValueKind(a);
 57 
 58             // create slots
 59             VirtualStackSlot s1 = frameMapBuilder.allocateSpillSlot(valueKind);
 60             VirtualStackSlot s2 = frameMapBuilder.allocateSpillSlot(valueKind);
 61             VirtualStackSlot s3 = frameMapBuilder.allocateSpillSlot(valueKind);
 62 
 63             // start emit
 64             gen.emitMove(s1, a);
 65             gen.emitMove(s2, a);
 66             gen.emitMove(s3, a);
 67             gen.append(gen.getSpillMoveFactory().createStackMove(s1, s3));
 68             Variable result = gen.emitMove(s2);
 69             Value slot1 = gen.emitMove(s1);
 70             Value slot3 = gen.emitMove(s3);
 71             // end emit
 72 
 73             // set output and result
 74             setResult(result);
 75             setOutput(&quot;slot1&quot;, slot1);
 76             setOutput(&quot;slot3&quot;, slot3);
 77         }
 78 
 79         protected ValueKind&lt;?&gt; getValueKind(Value value) {
 80             return value.getValueKind();
 81         }
 82     }
 83 
 84     /*
 85      * short
 86      */
 87 
 88     private static final LIRTestSpecification shortStackCopy = new StackStoreLoadSpec() {
 89         @Override
 90         protected ValueKind&lt;?&gt; getValueKind(Value value) {
 91             return LIRKind.value(shortKind);
 92         }
 93     };
 94 
 95     @SuppressWarnings(&quot;unused&quot;)
 96     @LIRIntrinsic
 97     public static short copyShort(LIRTestSpecification spec, short a) {
 98         return a;
 99     }
100 
101     public short[] testShort(short a, short[] out) {
102         out[0] = copyShort(shortStackCopy, a);
103         out[1] = getOutput(shortStackCopy, &quot;slot1&quot;, a);
104         out[2] = getOutput(shortStackCopy, &quot;slot3&quot;, a);
105         return out;
106     }
107 
108     @Test
109     public void runShort() throws Throwable {
110         runTest(&quot;testShort&quot;, Short.MIN_VALUE, supply(() -&gt; new short[3]));
111         runTest(&quot;testShort&quot;, (short) -1, supply(() -&gt; new short[3]));
112         runTest(&quot;testShort&quot;, (short) 0, supply(() -&gt; new short[3]));
113         runTest(&quot;testShort&quot;, (short) 1, supply(() -&gt; new short[3]));
114         runTest(&quot;testShort&quot;, Short.MAX_VALUE, supply(() -&gt; new short[3]));
115     }
116 
117     /*
118      * byte
119      */
120 
121     private static final LIRTestSpecification byteStackCopy = new StackStoreLoadSpec() {
122         @Override
123         protected ValueKind&lt;?&gt; getValueKind(Value value) {
124             return LIRKind.value(byteKind);
125         }
126     };
127 
128     @SuppressWarnings(&quot;unused&quot;)
129     @LIRIntrinsic
130     public static byte copyByte(LIRTestSpecification spec, byte a) {
131         return a;
132     }
133 
134     public byte[] testByte(byte a, byte[] out) {
135         out[0] = copyByte(byteStackCopy, a);
136         out[1] = getOutput(byteStackCopy, &quot;slot1&quot;, a);
137         out[2] = getOutput(byteStackCopy, &quot;slot3&quot;, a);
138         return out;
139     }
140 
141     @Test
142     public void runByte() throws Throwable {
143         runTest(&quot;testByte&quot;, Byte.MIN_VALUE, supply(() -&gt; new byte[3]));
144         runTest(&quot;testByte&quot;, (byte) -1, supply(() -&gt; new byte[3]));
145         runTest(&quot;testByte&quot;, (byte) 0, supply(() -&gt; new byte[3]));
146         runTest(&quot;testByte&quot;, (byte) 1, supply(() -&gt; new byte[3]));
147         runTest(&quot;testByte&quot;, Byte.MAX_VALUE, supply(() -&gt; new byte[3]));
148     }
149 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.jtt/src/org/graalvm/compiler/lir/jtt/StackMoveTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LIRTestTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StackStoreLoadTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.jtt/src/org/graalvm/compiler/lir/jtt/StackMoveTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 81 
 82     /*
 83      * int
 84      */
 85 
 86     @SuppressWarnings(&quot;unused&quot;)
 87     @LIRIntrinsic
 88     public static int copyInt(LIRTestSpecification spec, int a) {
 89         return a;
 90     }
 91 
 92     public int[] testInt(int a, int[] out) {
 93         out[0] = copyInt(stackCopy, a);
 94         out[1] = getOutput(stackCopy, &quot;slotcopy&quot;, a);
 95         out[2] = getOutput(stackCopy, &quot;slot1&quot;, a);
 96         out[3] = getOutput(stackCopy, &quot;slot2&quot;, a);
 97         return out;
 98     }
 99 
100     @Test
<span class="line-modified">101     public void runInt() throws Throwable {</span>
102         runTest(&quot;testInt&quot;, Integer.MIN_VALUE, supply(() -&gt; new int[4]));
103         runTest(&quot;testInt&quot;, -1, supply(() -&gt; new int[4]));
104         runTest(&quot;testInt&quot;, 0, supply(() -&gt; new int[4]));
105         runTest(&quot;testInt&quot;, 1, supply(() -&gt; new int[4]));
106         runTest(&quot;testInt&quot;, Integer.MAX_VALUE, supply(() -&gt; new int[4]));
107     }
108 
109     /*
110      * long
111      */
112 
113     @SuppressWarnings(&quot;unused&quot;)
114     @LIRIntrinsic
115     public static long copyLong(LIRTestSpecification spec, long a) {
116         return a;
117     }
118 
119     public long[] testLong(long a, long[] out) {
120         out[0] = copyLong(stackCopy, a);
121         out[1] = getOutput(stackCopy, &quot;slotcopy&quot;, a);
122         out[2] = getOutput(stackCopy, &quot;slot1&quot;, a);
123         out[3] = getOutput(stackCopy, &quot;slot2&quot;, a);
124         return out;
125     }
126 
127     @Test
<span class="line-modified">128     public void runLong() throws Throwable {</span>
129         runTest(&quot;testLong&quot;, Long.MIN_VALUE, supply(() -&gt; new long[3]));
130         runTest(&quot;testLong&quot;, -1L, supply(() -&gt; new long[3]));
131         runTest(&quot;testLong&quot;, 0L, supply(() -&gt; new long[3]));
132         runTest(&quot;testLong&quot;, 1L, supply(() -&gt; new long[3]));
133         runTest(&quot;testLong&quot;, Long.MAX_VALUE, supply(() -&gt; new long[3]));
134     }
135 
136     /*
137      * float
138      */
139 
140     @SuppressWarnings(&quot;unused&quot;)
141     @LIRIntrinsic
142     public static float copyFloat(LIRTestSpecification spec, float a) {
143         return a;
144     }
145 
146     public float[] testFloat(float a, float[] out) {
147         out[0] = copyFloat(stackCopy, a);
148         out[1] = getOutput(stackCopy, &quot;slotcopy&quot;, a);
149         out[2] = getOutput(stackCopy, &quot;slot1&quot;, a);
150         out[3] = getOutput(stackCopy, &quot;slot2&quot;, a);
151         return out;
152     }
153 
154     @Test
<span class="line-modified">155     public void runFloat() throws Throwable {</span>
156         runTest(&quot;testFloat&quot;, Float.MIN_VALUE, supply(() -&gt; new float[3]));
157         runTest(&quot;testFloat&quot;, -1f, supply(() -&gt; new float[3]));
158         runTest(&quot;testFloat&quot;, -0.1f, supply(() -&gt; new float[3]));
159         runTest(&quot;testFloat&quot;, 0f, supply(() -&gt; new float[3]));
160         runTest(&quot;testFloat&quot;, 0.1f, supply(() -&gt; new float[3]));
161         runTest(&quot;testFloat&quot;, 1f, supply(() -&gt; new float[3]));
162         runTest(&quot;testFloat&quot;, Float.MAX_VALUE, supply(() -&gt; new float[3]));
163     }
164 
165     /*
166      * double
167      */
168 
169     @SuppressWarnings(&quot;unused&quot;)
170     @LIRIntrinsic
171     public static double copyDouble(LIRTestSpecification spec, double a) {
172         return a;
173     }
174 
175     public double[] testDouble(double a, double[] out) {
</pre>
<hr />
<pre>
200         protected ValueKind&lt;?&gt; getValueKind(Value value) {
201             return LIRKind.value(shortKind);
202         }
203     };
204 
205     @SuppressWarnings(&quot;unused&quot;)
206     @LIRIntrinsic
207     public static short copyShort(LIRTestSpecification spec, short a) {
208         return a;
209     }
210 
211     public short[] testShort(short a, short[] out) {
212         out[0] = copyShort(shortStackCopy, a);
213         out[1] = getOutput(shortStackCopy, &quot;slotcopy&quot;, a);
214         out[2] = getOutput(shortStackCopy, &quot;slot1&quot;, a);
215         out[3] = getOutput(shortStackCopy, &quot;slot2&quot;, a);
216         return out;
217     }
218 
219     @Test
<span class="line-modified">220     public void runShort() throws Throwable {</span>
221         runTest(&quot;testShort&quot;, Short.MIN_VALUE, supply(() -&gt; new short[3]));
222         runTest(&quot;testShort&quot;, (short) -1, supply(() -&gt; new short[3]));
223         runTest(&quot;testShort&quot;, (short) 0, supply(() -&gt; new short[3]));
224         runTest(&quot;testShort&quot;, (short) 1, supply(() -&gt; new short[3]));
225         runTest(&quot;testShort&quot;, Short.MAX_VALUE, supply(() -&gt; new short[3]));
226     }
227 
228     /*
229      * byte
230      */
231 
232     private static final LIRTestSpecification byteStackCopy = new StackCopySpec() {
233         @Override
234         protected ValueKind&lt;?&gt; getValueKind(Value value) {
235             return LIRKind.value(byteKind);
236         }
237     };
238 
239     @SuppressWarnings(&quot;unused&quot;)
240     @LIRIntrinsic
241     public static byte copyByte(LIRTestSpecification spec, byte a) {
242         return a;
243     }
244 
245     public byte[] testByte(byte a, byte[] out) {
246         out[0] = copyByte(byteStackCopy, a);
247         out[1] = getOutput(byteStackCopy, &quot;slotcopy&quot;, a);
248         out[2] = getOutput(byteStackCopy, &quot;slot1&quot;, a);
249         out[3] = getOutput(byteStackCopy, &quot;slot2&quot;, a);
250         return out;
251     }
252 
253     @Test
<span class="line-modified">254     public void runByte() throws Throwable {</span>
255         runTest(&quot;testByte&quot;, Byte.MIN_VALUE, supply(() -&gt; new byte[3]));
256         runTest(&quot;testByte&quot;, (byte) -1, supply(() -&gt; new byte[3]));
257         runTest(&quot;testByte&quot;, (byte) 0, supply(() -&gt; new byte[3]));
258         runTest(&quot;testByte&quot;, (byte) 1, supply(() -&gt; new byte[3]));
259         runTest(&quot;testByte&quot;, Byte.MAX_VALUE, supply(() -&gt; new byte[3]));
260     }
261 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 81 
 82     /*
 83      * int
 84      */
 85 
 86     @SuppressWarnings(&quot;unused&quot;)
 87     @LIRIntrinsic
 88     public static int copyInt(LIRTestSpecification spec, int a) {
 89         return a;
 90     }
 91 
 92     public int[] testInt(int a, int[] out) {
 93         out[0] = copyInt(stackCopy, a);
 94         out[1] = getOutput(stackCopy, &quot;slotcopy&quot;, a);
 95         out[2] = getOutput(stackCopy, &quot;slot1&quot;, a);
 96         out[3] = getOutput(stackCopy, &quot;slot2&quot;, a);
 97         return out;
 98     }
 99 
100     @Test
<span class="line-modified">101     public void runInt() {</span>
102         runTest(&quot;testInt&quot;, Integer.MIN_VALUE, supply(() -&gt; new int[4]));
103         runTest(&quot;testInt&quot;, -1, supply(() -&gt; new int[4]));
104         runTest(&quot;testInt&quot;, 0, supply(() -&gt; new int[4]));
105         runTest(&quot;testInt&quot;, 1, supply(() -&gt; new int[4]));
106         runTest(&quot;testInt&quot;, Integer.MAX_VALUE, supply(() -&gt; new int[4]));
107     }
108 
109     /*
110      * long
111      */
112 
113     @SuppressWarnings(&quot;unused&quot;)
114     @LIRIntrinsic
115     public static long copyLong(LIRTestSpecification spec, long a) {
116         return a;
117     }
118 
119     public long[] testLong(long a, long[] out) {
120         out[0] = copyLong(stackCopy, a);
121         out[1] = getOutput(stackCopy, &quot;slotcopy&quot;, a);
122         out[2] = getOutput(stackCopy, &quot;slot1&quot;, a);
123         out[3] = getOutput(stackCopy, &quot;slot2&quot;, a);
124         return out;
125     }
126 
127     @Test
<span class="line-modified">128     public void runLong() {</span>
129         runTest(&quot;testLong&quot;, Long.MIN_VALUE, supply(() -&gt; new long[3]));
130         runTest(&quot;testLong&quot;, -1L, supply(() -&gt; new long[3]));
131         runTest(&quot;testLong&quot;, 0L, supply(() -&gt; new long[3]));
132         runTest(&quot;testLong&quot;, 1L, supply(() -&gt; new long[3]));
133         runTest(&quot;testLong&quot;, Long.MAX_VALUE, supply(() -&gt; new long[3]));
134     }
135 
136     /*
137      * float
138      */
139 
140     @SuppressWarnings(&quot;unused&quot;)
141     @LIRIntrinsic
142     public static float copyFloat(LIRTestSpecification spec, float a) {
143         return a;
144     }
145 
146     public float[] testFloat(float a, float[] out) {
147         out[0] = copyFloat(stackCopy, a);
148         out[1] = getOutput(stackCopy, &quot;slotcopy&quot;, a);
149         out[2] = getOutput(stackCopy, &quot;slot1&quot;, a);
150         out[3] = getOutput(stackCopy, &quot;slot2&quot;, a);
151         return out;
152     }
153 
154     @Test
<span class="line-modified">155     public void runFloat() {</span>
156         runTest(&quot;testFloat&quot;, Float.MIN_VALUE, supply(() -&gt; new float[3]));
157         runTest(&quot;testFloat&quot;, -1f, supply(() -&gt; new float[3]));
158         runTest(&quot;testFloat&quot;, -0.1f, supply(() -&gt; new float[3]));
159         runTest(&quot;testFloat&quot;, 0f, supply(() -&gt; new float[3]));
160         runTest(&quot;testFloat&quot;, 0.1f, supply(() -&gt; new float[3]));
161         runTest(&quot;testFloat&quot;, 1f, supply(() -&gt; new float[3]));
162         runTest(&quot;testFloat&quot;, Float.MAX_VALUE, supply(() -&gt; new float[3]));
163     }
164 
165     /*
166      * double
167      */
168 
169     @SuppressWarnings(&quot;unused&quot;)
170     @LIRIntrinsic
171     public static double copyDouble(LIRTestSpecification spec, double a) {
172         return a;
173     }
174 
175     public double[] testDouble(double a, double[] out) {
</pre>
<hr />
<pre>
200         protected ValueKind&lt;?&gt; getValueKind(Value value) {
201             return LIRKind.value(shortKind);
202         }
203     };
204 
205     @SuppressWarnings(&quot;unused&quot;)
206     @LIRIntrinsic
207     public static short copyShort(LIRTestSpecification spec, short a) {
208         return a;
209     }
210 
211     public short[] testShort(short a, short[] out) {
212         out[0] = copyShort(shortStackCopy, a);
213         out[1] = getOutput(shortStackCopy, &quot;slotcopy&quot;, a);
214         out[2] = getOutput(shortStackCopy, &quot;slot1&quot;, a);
215         out[3] = getOutput(shortStackCopy, &quot;slot2&quot;, a);
216         return out;
217     }
218 
219     @Test
<span class="line-modified">220     public void runShort() {</span>
221         runTest(&quot;testShort&quot;, Short.MIN_VALUE, supply(() -&gt; new short[3]));
222         runTest(&quot;testShort&quot;, (short) -1, supply(() -&gt; new short[3]));
223         runTest(&quot;testShort&quot;, (short) 0, supply(() -&gt; new short[3]));
224         runTest(&quot;testShort&quot;, (short) 1, supply(() -&gt; new short[3]));
225         runTest(&quot;testShort&quot;, Short.MAX_VALUE, supply(() -&gt; new short[3]));
226     }
227 
228     /*
229      * byte
230      */
231 
232     private static final LIRTestSpecification byteStackCopy = new StackCopySpec() {
233         @Override
234         protected ValueKind&lt;?&gt; getValueKind(Value value) {
235             return LIRKind.value(byteKind);
236         }
237     };
238 
239     @SuppressWarnings(&quot;unused&quot;)
240     @LIRIntrinsic
241     public static byte copyByte(LIRTestSpecification spec, byte a) {
242         return a;
243     }
244 
245     public byte[] testByte(byte a, byte[] out) {
246         out[0] = copyByte(byteStackCopy, a);
247         out[1] = getOutput(byteStackCopy, &quot;slotcopy&quot;, a);
248         out[2] = getOutput(byteStackCopy, &quot;slot1&quot;, a);
249         out[3] = getOutput(byteStackCopy, &quot;slot2&quot;, a);
250         return out;
251     }
252 
253     @Test
<span class="line-modified">254     public void runByte() {</span>
255         runTest(&quot;testByte&quot;, Byte.MIN_VALUE, supply(() -&gt; new byte[3]));
256         runTest(&quot;testByte&quot;, (byte) -1, supply(() -&gt; new byte[3]));
257         runTest(&quot;testByte&quot;, (byte) 0, supply(() -&gt; new byte[3]));
258         runTest(&quot;testByte&quot;, (byte) 1, supply(() -&gt; new byte[3]));
259         runTest(&quot;testByte&quot;, Byte.MAX_VALUE, supply(() -&gt; new byte[3]));
260     }
261 }
</pre>
</td>
</tr>
</table>
<center><a href="LIRTestTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StackStoreLoadTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
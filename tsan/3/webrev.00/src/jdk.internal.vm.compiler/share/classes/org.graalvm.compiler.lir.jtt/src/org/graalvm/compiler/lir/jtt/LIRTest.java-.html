<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.jtt/src/org/graalvm/compiler/lir/jtt/LIRTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.jtt;
 26 
 27 import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;
 28 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
 29 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
 30 
 31 import java.lang.annotation.ElementType;
 32 import java.lang.annotation.RetentionPolicy;
 33 import java.lang.reflect.Method;
 34 import java.lang.reflect.Modifier;
 35 import java.util.stream.Stream;
 36 
 37 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 38 import org.graalvm.compiler.core.common.type.StampFactory;
 39 import org.graalvm.compiler.graph.NodeClass;
 40 import org.graalvm.compiler.graph.NodeInputList;
 41 import org.graalvm.compiler.jtt.JTTTest;
 42 import org.graalvm.compiler.nodeinfo.NodeInfo;
 43 import org.graalvm.compiler.nodes.FixedWithNextNode;
 44 import org.graalvm.compiler.nodes.ValueNode;
 45 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 46 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 47 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 48 import org.graalvm.compiler.nodes.spi.LIRLowerable;
 49 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
 50 
 51 import jdk.vm.ci.meta.JavaKind;
 52 import jdk.vm.ci.meta.ResolvedJavaMethod;
 53 import jdk.vm.ci.meta.Value;
 54 
 55 /**
 56  * Base class for LIR tests.
 57  * &lt;p&gt;
 58  * It provides facilities to replace methods with {@link LIRTestSpecification arbitrary LIR
 59  * instructions}.
 60  */
 61 public abstract class LIRTest extends JTTTest {
 62 
 63     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
 64     private static final class LIRTestNode extends FixedWithNextNode implements LIRLowerable {
 65 
 66         public static final NodeClass&lt;LIRTestNode&gt; TYPE = NodeClass.create(LIRTestNode.class);
 67         @Input protected ValueNode opsNode;
 68         @Input protected NodeInputList&lt;ValueNode&gt; values;
 69         public final SnippetReflectionProvider snippetReflection;
 70 
 71         protected LIRTestNode(SnippetReflectionProvider snippetReflection, JavaKind kind, ValueNode opsNode, ValueNode[] values) {
 72             super(TYPE, StampFactory.forKind(kind));
 73             this.opsNode = opsNode;
 74             this.values = new NodeInputList&lt;&gt;(this, values);
 75             this.snippetReflection = snippetReflection;
 76         }
 77 
 78         public NodeInputList&lt;ValueNode&gt; values() {
 79             return values;
 80         }
 81 
 82         public ValueNode getLIROpsNode() {
 83             return opsNode;
 84         }
 85 
 86         @Override
 87         public void generate(NodeLIRBuilderTool gen) {
 88             LIRTestSpecification ops = getLIROperations();
 89             Stream&lt;Value&gt; v = values().stream().map(node -&gt; gen.operand(node));
 90 
 91             ops.generate(gen.getLIRGeneratorTool(), v.toArray(size -&gt; new Value[size]));
 92             Value result = ops.getResult();
 93             if (result != null) {
 94                 gen.setResult(this, result);
 95             }
 96         }
 97 
 98         public LIRTestSpecification getLIROperations() {
 99             assert getLIROpsNode().isConstant();
100             LIRTestSpecification spec = snippetReflection.asObject(LIRTestSpecification.class, getLIROpsNode().asJavaConstant());
101             return spec;
102         }
103     }
104 
105     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
106     private static final class LIRValueNode extends FixedWithNextNode implements LIRLowerable {
107 
108         public static final NodeClass&lt;LIRValueNode&gt; TYPE = NodeClass.create(LIRValueNode.class);
109         @Input protected ValueNode opsNode;
110         @Input protected ValueNode name;
111         public final SnippetReflectionProvider snippetReflection;
112 
113         protected LIRValueNode(SnippetReflectionProvider snippetReflection, JavaKind kind, ValueNode opsNode, ValueNode name) {
114             super(TYPE, StampFactory.forKind(kind));
115             this.opsNode = opsNode;
116             this.name = name;
117             this.snippetReflection = snippetReflection;
118         }
119 
120         public ValueNode getLIROpsNode() {
121             return opsNode;
122         }
123 
124         @Override
125         public void generate(NodeLIRBuilderTool gen) {
126             LIRTestSpecification spec = getLIROperations();
127             Value output = spec.getOutput(getName());
128             gen.setResult(this, isVariable(output) ? output : gen.getLIRGeneratorTool().emitMove(output));
129         }
130 
131         private String getName() {
132             assert name.isConstant();
133             return snippetReflection.asObject(String.class, name.asJavaConstant());
134         }
135 
136         private LIRTestSpecification getLIROperations() {
137             assert getLIROpsNode().isConstant();
138             return snippetReflection.asObject(LIRTestSpecification.class, getLIROpsNode().asJavaConstant());
139         }
140 
141     }
142 
143     private InvocationPlugin lirTestPlugin = new InvocationPlugin() {
144         @Override
145         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode spec) {
146             JavaKind returnKind = targetMethod.getSignature().getReturnKind();
147             LIRTestNode node = new LIRTestNode(getSnippetReflection(), returnKind, spec, new ValueNode[]{});
148             addNode(b, returnKind, node);
149             return true;
150         }
151 
152         @Override
153         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode spec, ValueNode arg0) {
154             JavaKind returnKind = targetMethod.getSignature().getReturnKind();
155             LIRTestNode node = new LIRTestNode(getSnippetReflection(), returnKind, spec, new ValueNode[]{arg0});
156             addNode(b, returnKind, node);
157             return true;
158         }
159 
160         @Override
161         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode spec, ValueNode arg0, ValueNode arg1) {
162             JavaKind returnKind = targetMethod.getSignature().getReturnKind();
163             LIRTestNode node = new LIRTestNode(getSnippetReflection(), returnKind, spec, new ValueNode[]{arg0, arg1});
164             addNode(b, returnKind, node);
165             return true;
166         }
167 
168         @Override
169         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode spec, ValueNode arg0, ValueNode arg1, ValueNode arg2) {
170             JavaKind returnKind = targetMethod.getSignature().getReturnKind();
171             LIRTestNode node = new LIRTestNode(getSnippetReflection(), returnKind, spec, new ValueNode[]{arg0, arg1, arg2});
172             addNode(b, returnKind, node);
173             return true;
174         }
175 
176         @Override
177         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode spec, ValueNode arg0, ValueNode arg1, ValueNode arg2, ValueNode arg3) {
178             JavaKind returnKind = targetMethod.getSignature().getReturnKind();
179             LIRTestNode node = new LIRTestNode(getSnippetReflection(), returnKind, spec, new ValueNode[]{arg0, arg1, arg2, arg3});
180             addNode(b, returnKind, node);
181             return true;
182         }
183 
184         private void addNode(GraphBuilderContext b, JavaKind returnKind, LIRTestNode node) {
185             if (returnKind.equals(JavaKind.Void)) {
186                 b.add(node);
187             } else {
188                 b.addPush(returnKind, node);
189             }
190         }
191 
192     };
193 
194     @Override
195     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
196         Class&lt;? extends LIRTest&gt; c = getClass();
197         for (Method m : c.getMethods()) {
198             if (m.getAnnotation(LIRIntrinsic.class) != null) {
199                 assert Modifier.isStatic(m.getModifiers());
200                 Class&lt;?&gt;[] p = m.getParameterTypes();
201                 assert p.length &gt; 0;
202                 assert LIRTestSpecification.class.isAssignableFrom(p[0]);
203 
204                 invocationPlugins.register(lirTestPlugin, c, m.getName(), p);
205             }
206         }
207         InvocationPlugin outputPlugin = new InvocationPlugin() {
208             @Override
209             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode spec, ValueNode name, ValueNode expected) {
210                 JavaKind returnKind = targetMethod.getSignature().getReturnKind();
211                 b.addPush(returnKind, new LIRValueNode(getSnippetReflection(), returnKind, spec, name));
212                 return true;
213             }
214         };
215         invocationPlugins.register(outputPlugin, LIRTest.class, &quot;getOutput&quot;, new Class&lt;?&gt;[]{LIRTestSpecification.class, String.class, Object.class});
216         invocationPlugins.register(outputPlugin, LIRTest.class, &quot;getOutput&quot;, new Class&lt;?&gt;[]{LIRTestSpecification.class, String.class, int.class});
217         super.registerInvocationPlugins(invocationPlugins);
218     }
219 
220     @SuppressWarnings(&quot;unused&quot;)
221     public static byte getOutput(LIRTestSpecification spec, String name, byte expected) {
222         return expected;
223     }
224 
225     @SuppressWarnings(&quot;unused&quot;)
226     public static short getOutput(LIRTestSpecification spec, String name, short expected) {
227         return expected;
228     }
229 
230     @SuppressWarnings(&quot;unused&quot;)
231     public static int getOutput(LIRTestSpecification spec, String name, int expected) {
232         return expected;
233     }
234 
235     @SuppressWarnings(&quot;unused&quot;)
236     public static long getOutput(LIRTestSpecification spec, String name, long expected) {
237         return expected;
238     }
239 
240     @SuppressWarnings(&quot;unused&quot;)
241     public static float getOutput(LIRTestSpecification spec, String name, float expected) {
242         return expected;
243     }
244 
245     @SuppressWarnings(&quot;unused&quot;)
246     public static double getOutput(LIRTestSpecification spec, String name, double expected) {
247         return expected;
248     }
249 
250     @SuppressWarnings(&quot;unused&quot;)
251     public static Object getOutput(LIRTestSpecification spec, String name, Object expected) {
252         return expected;
253     }
254 
255     @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)
256     @java.lang.annotation.Target(ElementType.METHOD)
257     public static @interface LIRIntrinsic {
258     }
259 
260 }
    </pre>
  </body>
</html>
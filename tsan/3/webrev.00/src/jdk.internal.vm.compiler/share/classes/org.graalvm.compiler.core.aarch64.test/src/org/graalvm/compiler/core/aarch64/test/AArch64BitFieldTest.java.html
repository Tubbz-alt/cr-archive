<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2019, Arm Limited and affiliates. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 
 27 package org.graalvm.compiler.core.aarch64.test;
 28 
 29 import org.graalvm.compiler.lir.LIRInstruction;
 30 import org.graalvm.compiler.lir.aarch64.AArch64BitFieldOp;
 31 import org.junit.Test;
 32 
 33 import java.util.function.Predicate;
 34 
 35 public class AArch64BitFieldTest extends AArch64MatchRuleTest {
 36     private static final Predicate&lt;LIRInstruction&gt; predicate = op -&gt; (op instanceof AArch64BitFieldOp);
 37 
 38     private void testAndCheckLIR(String method, String negativeMethod, Object input) {
 39         test(method, input);
 40         checkLIR(method, predicate, 1);
 41         test(negativeMethod, input);
 42         checkLIR(negativeMethod, predicate, 0);
 43     }
 44 
 45     /**
 46      * unsigned bit field extract int.
 47      */
 48     public static int extractInt(int input) {
 49         return (input &gt;&gt;&gt; 6) &amp; 0xffff;
 50     }
 51 
 52     /**
 53      * unsigned bit field extract int (negative cases).
 54      */
 55     public static int invalidExtractInt(int input) {
 56         int result = 0;
 57         result += ((input &gt;&gt;&gt; 10) &amp; 0xfff0);    // Invalid mask
 58         result += ((input &gt;&gt;&gt; 2) &amp; 0x7fffffff); // Bit field width too large
 59         result += ((input &gt;&gt;&gt; 16) &amp; 0x1ffff);   // Width + lsb exceeds limit
 60         return result;
 61     }
 62 
 63     @Test
 64     public void testExtractInt() {
 65         testAndCheckLIR(&quot;extractInt&quot;, &quot;invalidExtractInt&quot;, 0x12345678);
 66     }
 67 
 68     /**
 69      * unsigned bit field extract long.
 70      */
 71     public static long extractLong(long input) {
 72         return (input &gt;&gt;&gt; 25) &amp; 0xffffffffL;
 73     }
 74 
 75     /**
 76      * unsigned bit field extract long (negative cases).
 77      */
 78     public static long invalidExtractLong(long input) {
 79         long result = 0L;
 80         result += ((input &gt;&gt;&gt; 10) &amp; 0x230L);                // Invalid mask
 81         result += ((input &gt;&gt;&gt; 2) &amp; 0x7fffffffffffffffL);    // Bit field width too large
 82         result += ((input &gt;&gt;&gt; 62) &amp; 0x7L);                  // Width + lsb exceeds limit
 83         return result;
 84     }
 85 
 86     @Test
 87     public void testExtractLong() {
 88         testAndCheckLIR(&quot;extractLong&quot;, &quot;invalidExtractLong&quot;, 0xfedcba9876543210L);
 89     }
 90 
 91     /**
 92      * unsigned bit field insert int.
 93      */
 94     public static int insertInt(int input) {
 95         return (input &amp; 0xfff) &lt;&lt; 10;
 96     }
 97 
 98     /**
 99      * unsigned bit field insert int (negative cases).
100      */
101     public static int invalidInsertInt(int input) {
102         int result = 0;
103         result += ((input &amp; 0xe) &lt;&lt; 25);        // Invalid mask
104         result += ((input &amp; 0x7fffffff) &lt;&lt; 1);  // Bit field width too large
105         result += ((input &amp; 0x1ffff) &lt;&lt; 16);    // Width + lsb exceeds limit
106         return result;
107     }
108 
109     @Test
110     public void testInsertInt() {
111         testAndCheckLIR(&quot;insertInt&quot;, &quot;invalidInsertInt&quot;, 0xcafebabe);
112     }
113 
114     /**
115      * unsigned bit field insert long.
116      */
117     public static long insertLong(long input) {
118         return (input &amp; 0x3fffffffffffL) &lt;&lt; 7;
119     }
120 
121     /**
122      * unsigned bit field insert long (negative cases).
123      */
124     public static long invalidInsertLong(long input) {
125         long result = 0L;
126         result += ((input &amp; 0x1a) &lt;&lt; 39);                   // Invalid mask
127         result += ((input &amp; 0x7fffffffffffffffL) &lt;&lt; 1);     // Bit field width too large
128         result += ((input &amp; 0x3fffffff) &lt;&lt; 52);             // Width + lsb exceeds limit
129         return result;
130     }
131 
132     @Test
133     public void testInsertLong() {
134         testAndCheckLIR(&quot;insertLong&quot;, &quot;invalidInsertLong&quot;, 0xdeadbeefdeadbeefL);
135     }
136 }
    </pre>
  </body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64TestBitAndBranchTest.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64TestBitAndBranchTest.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64TestBitAndBranchTest.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64TestBitAndBranchTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,14 +22,13 @@
  */
 
 
 package org.graalvm.compiler.core.aarch64.test;
 
-import static org.junit.Assume.assumeTrue;
-
-import java.util.function.Predicate;
-
+import jdk.vm.ci.aarch64.AArch64;
+import jdk.vm.ci.code.TargetDescription;
+import jdk.vm.ci.meta.Value;
 import org.graalvm.compiler.api.directives.GraalDirectives;
 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 import org.graalvm.compiler.lir.LIR;
 import org.graalvm.compiler.lir.LIRInstruction;
 import org.graalvm.compiler.lir.LIRInstructionClass;
@@ -46,13 +45,13 @@
 import org.graalvm.compiler.options.OptionValues;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
-import jdk.vm.ci.aarch64.AArch64;
-import jdk.vm.ci.code.TargetDescription;
-import jdk.vm.ci.meta.Value;
+import java.util.function.Predicate;
+
+import static org.junit.Assume.assumeTrue;
 
 public class AArch64TestBitAndBranchTest extends LIRTest {
     private static final Predicate<LIRInstruction> checkForBitTestAndBranchOp = op -> (op instanceof AArch64ControlFlow.BitTestAndBranchOp);
     private LIR lir;
 
@@ -60,25 +59,25 @@
     public void checkAArch64() {
         assumeTrue("skipping AArch64 specific test", getTarget().arch instanceof AArch64);
     }
 
     public static long testBit42Snippet(long a, long b, long c) {
-        if ((a & (1 << 42)) == 0) {
+        if ((a & (1L << 42)) == 0) {
             return b;
         } else {
             return c;
         }
     }
 
     @Test
     public void testBit42() {
-        test("testBit42Snippet", 1L << 42L, Long.MAX_VALUE, Long.MIN_VALUE);
-        test("testBit42Snippet", ~(1L << 42L), Long.MAX_VALUE, Long.MIN_VALUE);
+        test("testBit42Snippet", 1L << 42, Long.MAX_VALUE, Long.MIN_VALUE);
+        test("testBit42Snippet", ~(1L << 42), Long.MAX_VALUE, Long.MIN_VALUE);
         checkLIR("testBit42Snippet", checkForBitTestAndBranchOp, 1);
     }
 
-    private static final LargeOpSpec largeOpSingleNop = new LargeOpSpec((1 << 14 - 2), 2);
+    private static final LargeOpSpec largeOpSingleNop = new LargeOpSpec((1 << 14 - 2) - 10, 2);
 
     /**
      * Tests the graceful case, where the estimation for
      * {@link CompilationResultBuilder#labelWithinRange(LIRInstruction, org.graalvm.compiler.asm.Label, int)}
      * holds.
@@ -97,11 +96,11 @@
     public void testBitTestAndBranchSingle() {
         runTest("testBitTestAndBranchSingleSnippet", 1);
         checkLIR("testBitTestAndBranchSingleSnippet", checkForBitTestAndBranchOp, 1);
     }
 
-    private static final LargeOpSpec largeOpFourNop = new LargeOpSpec((1 << 14 - 2), 8);
+    private static final LargeOpSpec largeOpFourNop = new LargeOpSpec((1 << 14 - 2) - 10, 8);
 
     /**
      * Tests the case, where the estimation for
      * {@link CompilationResultBuilder#labelWithinRange(LIRInstruction, org.graalvm.compiler.asm.Label, int)}
      * does not hold and the code generation must be redone with large branches.
@@ -120,10 +119,77 @@
     public void testBitTestAndBranchFour() {
         runTest("testBitTestAndBranchFourSnippet", 1);
         checkLIR("testBitTestAndBranchFourSnippet", checkForBitTestAndBranchOp, 1);
     }
 
+    private static final float trueTarget = Float.MAX_VALUE;
+    private static final float falseTarget = Float.MIN_VALUE;
+
+    public static float testLessThanZeroSnippet(long a, long b) {
+        if (b + a - b < 0) {
+            return trueTarget - a;
+        } else {
+            return falseTarget + a;
+        }
+    }
+
+    @Test
+    public void testLessThanZero() {
+        test("testLessThanZeroSnippet", 1L, 777L);
+        test("testLessThanZeroSnippet", 0L, 777L);
+        test("testLessThanZeroSnippet", -1L, 777L);
+        checkLIR("testLessThanZeroSnippet", checkForBitTestAndBranchOp, 1);
+    }
+
+    public static float testLessThanEqualZeroSnippet(long a) {
+        if (a <= 0) {
+            return trueTarget - a;
+        } else {
+            return falseTarget + a;
+        }
+    }
+
+    @Test
+    public void testLessThanEqualZero() {
+        test("testLessThanEqualZeroSnippet", 1L);
+        test("testLessThanEqualZeroSnippet", 0L);
+        test("testLessThanEqualZeroSnippet", -1L);
+        checkLIR("testLessThanEqualZeroSnippet", checkForBitTestAndBranchOp, 0);
+    }
+
+    public static float testGreaterThanZeroSnippet(int a) {
+        if (a > 0) {
+            return trueTarget - a;
+        } else {
+            return falseTarget + a;
+        }
+    }
+
+    @Test
+    public void testGreaterThanZero() {
+        test("testGreaterThanZeroSnippet", 1);
+        test("testGreaterThanZeroSnippet", 0);
+        test("testGreaterThanZeroSnippet", -1);
+        checkLIR("testGreaterThanZeroSnippet", checkForBitTestAndBranchOp, 0);
+    }
+
+    public static float testGreaterThanEqualZeroSnippet(int a) {
+        if (a >= 0) {
+            return trueTarget - a;
+        } else {
+            return falseTarget + a;
+        }
+    }
+
+    @Test
+    public void testGreaterThanEqualZero() {
+        test("testGreaterThanEqualZeroSnippet", 1);
+        test("testGreaterThanEqualZeroSnippet", 0);
+        test("testGreaterThanEqualZeroSnippet", -1);
+        checkLIR("testGreaterThanEqualZeroSnippet", checkForBitTestAndBranchOp, 1);
+    }
+
     private static class LargeOpSpec extends LIRTestSpecification {
         private final int n;
         private final int nopCount;
 
         LargeOpSpec(int n, int nopCount) {
@@ -170,11 +236,13 @@
         return suites;
     }
 
     public class CheckPhase extends LIRPhase<PreAllocationOptimizationContext> {
         @Override
-        protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {
+        protected void run(
+                        TargetDescription target, LIRGenerationResult lirGenRes,
+                        PreAllocationOptimizationContext context) {
             lir = lirGenRes.getLIR();
         }
     }
 
     protected void checkLIR(String methodName, Predicate<LIRInstruction> predicate, int expected) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/inlining/info/MultiTypeGuardInlineInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.phases.common.inlining.info;
 26 
 27 import java.util.ArrayList;
 28 import java.util.List;
 29 
 30 import jdk.internal.vm.compiler.collections.EconomicSet;
 31 import jdk.internal.vm.compiler.collections.Equivalence;
 32 import org.graalvm.compiler.core.common.type.StampFactory;
 33 import org.graalvm.compiler.graph.Node;
 34 import org.graalvm.compiler.nodes.AbstractBeginNode;
 35 import org.graalvm.compiler.nodes.AbstractMergeNode;
 36 import org.graalvm.compiler.nodes.BeginNode;
 37 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 38 import org.graalvm.compiler.nodes.DeoptimizeNode;
 39 import org.graalvm.compiler.nodes.EndNode;
 40 import org.graalvm.compiler.nodes.FixedNode;
 41 import org.graalvm.compiler.nodes.FixedWithNextNode;
 42 import org.graalvm.compiler.nodes.FrameState;
 43 import org.graalvm.compiler.nodes.Invoke;
 44 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 45 import org.graalvm.compiler.nodes.MergeNode;
 46 import org.graalvm.compiler.nodes.NodeView;
 47 import org.graalvm.compiler.nodes.PhiNode;
 48 import org.graalvm.compiler.nodes.PiNode;
 49 import org.graalvm.compiler.nodes.StructuredGraph;
 50 import org.graalvm.compiler.nodes.ValueNode;
 51 import org.graalvm.compiler.nodes.ValuePhiNode;
 52 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 53 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
 54 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 55 import org.graalvm.compiler.nodes.java.TypeSwitchNode;
 56 import org.graalvm.compiler.nodes.spi.StampProvider;
 57 import org.graalvm.compiler.nodes.util.GraphUtil;
 58 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 59 import org.graalvm.compiler.phases.common.inlining.info.elem.Inlineable;
 60 import org.graalvm.compiler.phases.util.Providers;
 61 
 62 import jdk.vm.ci.meta.ConstantReflectionProvider;
 63 import jdk.vm.ci.meta.DeoptimizationAction;
 64 import jdk.vm.ci.meta.DeoptimizationReason;
 65 import jdk.vm.ci.meta.JavaKind;
 66 import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;
 67 import jdk.vm.ci.meta.ResolvedJavaMethod;
 68 import jdk.vm.ci.meta.ResolvedJavaType;
 69 
 70 /**
 71  * Polymorphic inlining of m methods with n type checks (n &amp;ge; m) in case that the profiling
 72  * information suggests a reasonable amount of different receiver types and different methods. If an
 73  * unknown type is encountered a deoptimization is triggered.
 74  */
 75 public class MultiTypeGuardInlineInfo extends AbstractInlineInfo {
 76 
 77     private final List&lt;ResolvedJavaMethod&gt; concretes;
 78     private final double[] methodProbabilities;
 79     private final double maximumMethodProbability;
 80     private final ArrayList&lt;Integer&gt; typesToConcretes;
 81     private final ArrayList&lt;ProfiledType&gt; ptypes;
 82     private final double notRecordedTypeProbability;
 83     private final Inlineable[] inlineableElements;
 84 
 85     public MultiTypeGuardInlineInfo(Invoke invoke, ArrayList&lt;ResolvedJavaMethod&gt; concretes, ArrayList&lt;ProfiledType&gt; ptypes, ArrayList&lt;Integer&gt; typesToConcretes, double notRecordedTypeProbability) {
 86         super(invoke);
 87         assert concretes.size() &gt; 0 : &quot;must have at least one method&quot;;
 88         assert ptypes.size() == typesToConcretes.size() : &quot;array lengths must match&quot;;
 89 
 90         this.concretes = concretes;
 91         this.ptypes = ptypes;
 92         this.typesToConcretes = typesToConcretes;
 93         this.notRecordedTypeProbability = notRecordedTypeProbability;
 94         this.inlineableElements = new Inlineable[concretes.size()];
 95         this.methodProbabilities = computeMethodProbabilities();
 96         this.maximumMethodProbability = maximumMethodProbability();
 97         assert maximumMethodProbability &gt; 0;
 98         assert assertUniqueTypes(ptypes);
 99     }
100 
101     private static boolean assertUniqueTypes(ArrayList&lt;ProfiledType&gt; ptypes) {
102         EconomicSet&lt;ResolvedJavaType&gt; set = EconomicSet.create(Equivalence.DEFAULT);
103         for (ProfiledType ptype : ptypes) {
104             set.add(ptype.getType());
105         }
106         return set.size() == ptypes.size();
107     }
108 
109     private double[] computeMethodProbabilities() {
110         double[] result = new double[concretes.size()];
111         for (int i = 0; i &lt; typesToConcretes.size(); i++) {
112             int concrete = typesToConcretes.get(i);
113             double probability = ptypes.get(i).getProbability();
114             result[concrete] += probability;
115         }
116         return result;
117     }
118 
119     private double maximumMethodProbability() {
120         double max = 0;
121         for (int i = 0; i &lt; methodProbabilities.length; i++) {
122             max = Math.max(max, methodProbabilities[i]);
123         }
124         return max;
125     }
126 
127     @Override
128     public int numberOfMethods() {
129         return concretes.size();
130     }
131 
132     @Override
133     public ResolvedJavaMethod methodAt(int index) {
134         assert index &gt;= 0 &amp;&amp; index &lt; concretes.size();
135         return concretes.get(index);
136     }
137 
138     @Override
139     public Inlineable inlineableElementAt(int index) {
140         assert index &gt;= 0 &amp;&amp; index &lt; concretes.size();
141         return inlineableElements[index];
142     }
143 
144     @Override
145     public double probabilityAt(int index) {
146         return methodProbabilities[index];
147     }
148 
149     @Override
150     public double relevanceAt(int index) {
151         return probabilityAt(index) / maximumMethodProbability;
152     }
153 
154     @Override
155     public void setInlinableElement(int index, Inlineable inlineableElement) {
156         assert index &gt;= 0 &amp;&amp; index &lt; concretes.size();
157         inlineableElements[index] = inlineableElement;
158     }
159 
160     @Override
161     public EconomicSet&lt;Node&gt; inline(Providers providers, String reason) {
162         if (hasSingleMethod()) {
163             return inlineSingleMethod(graph(), providers.getStampProvider(), providers.getConstantReflection(), reason);
164         } else {
165             return inlineMultipleMethods(graph(), providers, reason);
166         }
167     }
168 
169     @Override
170     public boolean shouldInline() {
171         for (ResolvedJavaMethod method : concretes) {
172             if (method.shouldBeInlined()) {
173                 return true;
174             }
175         }
176         return false;
177     }
178 
179     private boolean hasSingleMethod() {
180         return concretes.size() == 1 &amp;&amp; !shouldFallbackToInvoke();
181     }
182 
183     private boolean shouldFallbackToInvoke() {
184         return notRecordedTypeProbability &gt; 0;
185     }
186 
187     private EconomicSet&lt;Node&gt; inlineMultipleMethods(StructuredGraph graph, Providers providers, String reason) {
188         int numberOfMethods = concretes.size();
189         FixedNode continuation = invoke.next();
190 
191         // setup merge and phi nodes for results and exceptions
192         AbstractMergeNode returnMerge = graph.add(new MergeNode());
193         returnMerge.setStateAfter(invoke.stateAfter());
194 
195         PhiNode returnValuePhi = null;
196         if (invoke.asNode().getStackKind() != JavaKind.Void) {
197             returnValuePhi = graph.addWithoutUnique(new ValuePhiNode(invoke.asNode().stamp(NodeView.DEFAULT).unrestricted(), returnMerge));
198         }
199 
200         AbstractMergeNode exceptionMerge = null;
201         PhiNode exceptionObjectPhi = null;
202         if (invoke instanceof InvokeWithExceptionNode) {
203             InvokeWithExceptionNode invokeWithException = (InvokeWithExceptionNode) invoke;
204             ExceptionObjectNode exceptionEdge = (ExceptionObjectNode) invokeWithException.exceptionEdge();
205 
206             exceptionMerge = graph.add(new MergeNode());
207 
208             FixedNode exceptionSux = exceptionEdge.next();
209             graph.addBeforeFixed(exceptionSux, exceptionMerge);
210             exceptionObjectPhi = graph.addWithoutUnique(new ValuePhiNode(StampFactory.forKind(JavaKind.Object), exceptionMerge));
<a name="2" id="anc2"></a><span class="line-modified">211             exceptionMerge.setStateAfter(exceptionEdge.stateAfter().duplicateModified(invoke.stateAfter().bci, true, JavaKind.Object, new JavaKind[]{JavaKind.Object},</span>
<span class="line-modified">212                             new ValueNode[]{exceptionObjectPhi}));</span>


213         }
214 
215         // create one separate block for each invoked method
216         AbstractBeginNode[] successors = new AbstractBeginNode[numberOfMethods + 1];
217         for (int i = 0; i &lt; numberOfMethods; i++) {
218             successors[i] = createInvocationBlock(graph, invoke, returnMerge, returnValuePhi, exceptionMerge, exceptionObjectPhi, true);
219         }
220 
221         // create the successor for an unknown type
222         FixedNode unknownTypeSux;
223         if (shouldFallbackToInvoke()) {
224             unknownTypeSux = createInvocationBlock(graph, invoke, returnMerge, returnValuePhi, exceptionMerge, exceptionObjectPhi, false);
225         } else {
226             unknownTypeSux = graph.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TypeCheckedInliningViolated));
227         }
228         successors[successors.length - 1] = BeginNode.begin(unknownTypeSux);
229 
230         // replace the invoke exception edge
231         if (invoke instanceof InvokeWithExceptionNode) {
232             InvokeWithExceptionNode invokeWithExceptionNode = (InvokeWithExceptionNode) invoke;
233             ExceptionObjectNode exceptionEdge = (ExceptionObjectNode) invokeWithExceptionNode.exceptionEdge();
234             exceptionEdge.replaceAtUsages(exceptionObjectPhi);
235             exceptionEdge.setNext(null);
236             GraphUtil.killCFG(invokeWithExceptionNode.exceptionEdge());
237         }
238 
239         assert invoke.asNode().isAlive();
240 
241         // replace the invoke with a switch on the type of the actual receiver
242         boolean methodDispatch = createDispatchOnTypeBeforeInvoke(graph, successors, false, providers.getStampProvider(), providers.getConstantReflection());
243 
244         assert invoke.next() == continuation;
245         invoke.setNext(null);
246         returnMerge.setNext(continuation);
247         if (returnValuePhi != null) {
248             invoke.asNode().replaceAtUsages(returnValuePhi);
249         }
250         invoke.asNode().safeDelete();
251 
252         ArrayList&lt;PiNode&gt; replacementNodes = new ArrayList&lt;&gt;();
253 
254         // prepare the anchors for the invokes
255         for (int i = 0; i &lt; numberOfMethods; i++) {
256             AbstractBeginNode node = successors[i];
257             Invoke invokeForInlining = (Invoke) node.next();
258 
259             ResolvedJavaType commonType;
260             if (methodDispatch) {
261                 commonType = concretes.get(i).getDeclaringClass();
262             } else {
263                 commonType = getLeastCommonType(i);
264             }
265 
266             ValueNode receiver = ((MethodCallTargetNode) invokeForInlining.callTarget()).receiver();
267             boolean exact = (getTypeCount(i) == 1 &amp;&amp; !methodDispatch);
268             PiNode anchoredReceiver = InliningUtil.createAnchoredReceiver(graph, node, commonType, receiver, exact);
269             invokeForInlining.callTarget().replaceFirstInput(receiver, anchoredReceiver);
270 
271             assert !anchoredReceiver.isDeleted() : anchoredReceiver;
272             replacementNodes.add(anchoredReceiver);
273         }
274         if (shouldFallbackToInvoke()) {
275             replacementNodes.add(null);
276         }
277 
278         EconomicSet&lt;Node&gt; canonicalizeNodes = EconomicSet.create(Equivalence.DEFAULT);
279         // do the actual inlining for every invoke
280         for (int i = 0; i &lt; numberOfMethods; i++) {
281             Invoke invokeForInlining = (Invoke) successors[i].next();
282             canonicalizeNodes.addAll(doInline(i, invokeForInlining, reason));
283         }
284         if (returnValuePhi != null) {
285             canonicalizeNodes.add(returnValuePhi);
286         }
287         return canonicalizeNodes;
288     }
289 
290     protected EconomicSet&lt;Node&gt; doInline(int index, Invoke invokeForInlining, String reason) {
291         return inline(invokeForInlining, methodAt(index), inlineableElementAt(index), false, reason);
292     }
293 
294     private int getTypeCount(int concreteMethodIndex) {
295         int count = 0;
296         for (int i = 0; i &lt; typesToConcretes.size(); i++) {
297             if (typesToConcretes.get(i) == concreteMethodIndex) {
298                 count++;
299             }
300         }
301         return count;
302     }
303 
304     private ResolvedJavaType getLeastCommonType(int concreteMethodIndex) {
305         ResolvedJavaType commonType = null;
306         for (int i = 0; i &lt; typesToConcretes.size(); i++) {
307             if (typesToConcretes.get(i) == concreteMethodIndex) {
308                 if (commonType == null) {
309                     commonType = ptypes.get(i).getType();
310                 } else {
311                     commonType = commonType.findLeastCommonAncestor(ptypes.get(i).getType());
312                 }
313             }
314         }
315         assert commonType != null;
316         return commonType;
317     }
318 
319     private ResolvedJavaType getLeastCommonType() {
320         ResolvedJavaType result = getLeastCommonType(0);
321         for (int i = 1; i &lt; concretes.size(); i++) {
322             result = result.findLeastCommonAncestor(getLeastCommonType(i));
323         }
324         return result;
325     }
326 
327     private EconomicSet&lt;Node&gt; inlineSingleMethod(StructuredGraph graph, StampProvider stampProvider, ConstantReflectionProvider constantReflection, String reason) {
328         assert concretes.size() == 1 &amp;&amp; inlineableElements.length == 1 &amp;&amp; ptypes.size() &gt; 1 &amp;&amp; !shouldFallbackToInvoke() &amp;&amp; notRecordedTypeProbability == 0;
329 
330         AbstractBeginNode calleeEntryNode = graph.add(new BeginNode());
331 
332         AbstractBeginNode unknownTypeSux = createUnknownTypeSuccessor(graph);
333         AbstractBeginNode[] successors = new AbstractBeginNode[]{calleeEntryNode, unknownTypeSux};
334         createDispatchOnTypeBeforeInvoke(graph, successors, false, stampProvider, constantReflection);
335 
336         calleeEntryNode.setNext(invoke.asNode());
337 
338         return inline(invoke, methodAt(0), inlineableElementAt(0), false, reason);
339     }
340 
341     private boolean createDispatchOnTypeBeforeInvoke(StructuredGraph graph, AbstractBeginNode[] successors, boolean invokeIsOnlySuccessor, StampProvider stampProvider,
342                     ConstantReflectionProvider constantReflection) {
343         assert ptypes.size() &gt;= 1;
344         ValueNode nonNullReceiver = InliningUtil.nonNullReceiver(invoke);
345         LoadHubNode hub = graph.unique(new LoadHubNode(stampProvider, nonNullReceiver));
346 
347         graph.getDebug().log(&quot;Type switch with %d types&quot;, concretes.size());
348 
349         ResolvedJavaType[] keys = new ResolvedJavaType[ptypes.size()];
350         double[] keyProbabilities = new double[ptypes.size() + 1];
351         int[] keySuccessors = new int[ptypes.size() + 1];
352         double totalProbability = notRecordedTypeProbability;
353         for (int i = 0; i &lt; ptypes.size(); i++) {
354             keys[i] = ptypes.get(i).getType();
355             keyProbabilities[i] = ptypes.get(i).getProbability();
356             totalProbability += keyProbabilities[i];
357             keySuccessors[i] = invokeIsOnlySuccessor ? 0 : typesToConcretes.get(i);
358             assert keySuccessors[i] &lt; successors.length - 1 : &quot;last successor is the unknownTypeSux&quot;;
359         }
360         keyProbabilities[keyProbabilities.length - 1] = notRecordedTypeProbability;
361         keySuccessors[keySuccessors.length - 1] = successors.length - 1;
362 
363         // Normalize the probabilities.
364         for (int i = 0; i &lt; keyProbabilities.length; i++) {
365             keyProbabilities[i] /= totalProbability;
366         }
367 
368         TypeSwitchNode typeSwitch = graph.add(new TypeSwitchNode(hub, successors, keys, keyProbabilities, keySuccessors, constantReflection));
369         FixedWithNextNode pred = (FixedWithNextNode) invoke.asNode().predecessor();
370         pred.setNext(typeSwitch);
371         return false;
372     }
373 
374     private static AbstractBeginNode createInvocationBlock(StructuredGraph graph, Invoke invoke, AbstractMergeNode returnMerge, PhiNode returnValuePhi, AbstractMergeNode exceptionMerge,
375                     PhiNode exceptionObjectPhi, boolean useForInlining) {
376         Invoke duplicatedInvoke = duplicateInvokeForInlining(graph, invoke, exceptionMerge, exceptionObjectPhi, useForInlining);
377         AbstractBeginNode calleeEntryNode = graph.add(new BeginNode());
378         calleeEntryNode.setNext(duplicatedInvoke.asNode());
379 
380         EndNode endNode = graph.add(new EndNode());
381         duplicatedInvoke.setNext(endNode);
382         returnMerge.addForwardEnd(endNode);
383 
384         if (returnValuePhi != null) {
385             returnValuePhi.addInput(duplicatedInvoke.asNode());
386         }
387         return calleeEntryNode;
388     }
389 
390     private static Invoke duplicateInvokeForInlining(StructuredGraph graph, Invoke invoke, AbstractMergeNode exceptionMerge, PhiNode exceptionObjectPhi, boolean useForInlining) {
391         Invoke result = (Invoke) invoke.asNode().copyWithInputs();
392         Node callTarget = result.callTarget().copyWithInputs();
393         result.asNode().replaceFirstInput(result.callTarget(), callTarget);
394         result.setUseForInlining(useForInlining);
395 
396         JavaKind kind = invoke.asNode().getStackKind();
397         if (kind != JavaKind.Void) {
398             FrameState stateAfter = invoke.stateAfter();
<a name="3" id="anc3"></a><span class="line-modified">399             stateAfter = stateAfter.duplicate(stateAfter.bci);</span>
400             stateAfter.replaceFirstInput(invoke.asNode(), result.asNode());
401             result.setStateAfter(stateAfter);
402         }
403 
404         if (invoke instanceof InvokeWithExceptionNode) {
405             assert exceptionMerge != null &amp;&amp; exceptionObjectPhi != null;
406 
407             InvokeWithExceptionNode invokeWithException = (InvokeWithExceptionNode) invoke;
408             ExceptionObjectNode exceptionEdge = (ExceptionObjectNode) invokeWithException.exceptionEdge();
409             FrameState stateAfterException = exceptionEdge.stateAfter();
410 
411             ExceptionObjectNode newExceptionEdge = (ExceptionObjectNode) exceptionEdge.copyWithInputs();
412             // set new state (pop old exception object, push new one)
413             newExceptionEdge.setStateAfter(stateAfterException.duplicateModified(JavaKind.Object, JavaKind.Object, newExceptionEdge));
414 
415             EndNode endNode = graph.add(new EndNode());
416             newExceptionEdge.setNext(endNode);
417             exceptionMerge.addForwardEnd(endNode);
418             exceptionObjectPhi.addInput(newExceptionEdge);
419 
420             ((InvokeWithExceptionNode) result).setExceptionEdge(newExceptionEdge);
421         }
422         return result;
423     }
424 
425     @Override
426     public void tryToDevirtualizeInvoke(Providers providers) {
427         if (hasSingleMethod()) {
428             devirtualizeWithTypeSwitch(graph(), InvokeKind.Special, concretes.get(0), providers.getStampProvider(), providers.getConstantReflection());
429         } else {
430             tryToDevirtualizeMultipleMethods(graph(), providers.getStampProvider(), providers.getConstantReflection());
431         }
432     }
433 
434     private void tryToDevirtualizeMultipleMethods(StructuredGraph graph, StampProvider stampProvider, ConstantReflectionProvider constantReflection) {
435         MethodCallTargetNode methodCallTarget = (MethodCallTargetNode) invoke.callTarget();
436         if (methodCallTarget.invokeKind() == InvokeKind.Interface) {
437             ResolvedJavaMethod targetMethod = methodCallTarget.targetMethod();
438             ResolvedJavaType leastCommonType = getLeastCommonType();
439             ResolvedJavaType contextType = invoke.getContextType();
440             // check if we have a common base type that implements the interface -&gt; in that case
441             // we have a vtable entry for the interface method and can use a less expensive
442             // virtual call
443             if (!leastCommonType.isInterface() &amp;&amp; targetMethod.getDeclaringClass().isAssignableFrom(leastCommonType)) {
444                 ResolvedJavaMethod baseClassTargetMethod = leastCommonType.resolveConcreteMethod(targetMethod, contextType);
445                 if (baseClassTargetMethod != null) {
446                     devirtualizeWithTypeSwitch(graph, InvokeKind.Virtual, leastCommonType.resolveConcreteMethod(targetMethod, contextType), stampProvider, constantReflection);
447                 }
448             }
449         }
450     }
451 
452     private void devirtualizeWithTypeSwitch(StructuredGraph graph, InvokeKind kind, ResolvedJavaMethod target, StampProvider stampProvider, ConstantReflectionProvider constantReflection) {
453         AbstractBeginNode invocationEntry = graph.add(new BeginNode());
454         AbstractBeginNode unknownTypeSux = createUnknownTypeSuccessor(graph);
455         AbstractBeginNode[] successors = new AbstractBeginNode[]{invocationEntry, unknownTypeSux};
456         createDispatchOnTypeBeforeInvoke(graph, successors, true, stampProvider, constantReflection);
457 
458         invocationEntry.setNext(invoke.asNode());
459         ValueNode receiver = ((MethodCallTargetNode) invoke.callTarget()).receiver();
460         PiNode anchoredReceiver = InliningUtil.createAnchoredReceiver(graph, invocationEntry, target.getDeclaringClass(), receiver, false);
461         invoke.callTarget().replaceFirstInput(receiver, anchoredReceiver);
462         InliningUtil.replaceInvokeCallTarget(invoke, graph, kind, target);
463     }
464 
465     private static AbstractBeginNode createUnknownTypeSuccessor(StructuredGraph graph) {
466         return BeginNode.begin(graph.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TypeCheckedInliningViolated)));
467     }
468 
469     @Override
470     public String toString() {
471         StringBuilder builder = new StringBuilder(shouldFallbackToInvoke() ? &quot;megamorphic&quot; : &quot;polymorphic&quot;);
472         builder.append(&quot;, &quot;);
473         builder.append(concretes.size());
474         builder.append(&quot; methods [ &quot;);
475         for (int i = 0; i &lt; concretes.size(); i++) {
476             builder.append(concretes.get(i).format(&quot;  %H.%n(%p):%r&quot;));
477         }
478         builder.append(&quot; ], &quot;);
479         builder.append(ptypes.size());
480         builder.append(&quot; type checks [ &quot;);
481         for (int i = 0; i &lt; ptypes.size(); i++) {
482             builder.append(&quot;  &quot;);
483             builder.append(ptypes.get(i).getType().getName());
484             builder.append(ptypes.get(i).getProbability());
485         }
486         builder.append(&quot; ]&quot;);
487         return builder.toString();
488     }
489 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/inlining/InliningUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.phases.common.inlining;
  26 
  27 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateReprofile;
  28 import static jdk.vm.ci.meta.DeoptimizationReason.NullCheckException;
  29 import static org.graalvm.compiler.core.common.GraalOptions.HotSpotPrintInlining;
  30 
  31 import java.util.ArrayDeque;
  32 import java.util.ArrayList;
  33 import java.util.List;
  34 import java.util.Objects;
  35 import java.util.function.Consumer;
  36 
  37 import jdk.internal.vm.compiler.collections.EconomicMap;
  38 import jdk.internal.vm.compiler.collections.EconomicSet;
  39 import jdk.internal.vm.compiler.collections.Equivalence;
  40 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  41 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
  42 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  43 import org.graalvm.compiler.core.common.GraalOptions;
  44 import org.graalvm.compiler.core.common.type.Stamp;
  45 import org.graalvm.compiler.core.common.type.StampFactory;
  46 import org.graalvm.compiler.core.common.type.TypeReference;
  47 import org.graalvm.compiler.core.common.util.Util;
  48 import org.graalvm.compiler.debug.DebugCloseable;
  49 import org.graalvm.compiler.debug.DebugContext;
  50 import org.graalvm.compiler.debug.GraalError;
  51 import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
  52 import org.graalvm.compiler.graph.Graph.Mark;
  53 import org.graalvm.compiler.graph.Graph.NodeEventScope;
  54 import org.graalvm.compiler.graph.Node;
  55 import org.graalvm.compiler.graph.NodeInputList;
  56 import org.graalvm.compiler.graph.NodeMap;
  57 import org.graalvm.compiler.graph.NodeSourcePosition;
  58 import org.graalvm.compiler.graph.NodeWorkList;
  59 import org.graalvm.compiler.nodeinfo.InputType;
  60 import org.graalvm.compiler.nodeinfo.Verbosity;
  61 import org.graalvm.compiler.nodes.AbstractBeginNode;
  62 import org.graalvm.compiler.nodes.AbstractEndNode;
  63 import org.graalvm.compiler.nodes.AbstractMergeNode;
  64 import org.graalvm.compiler.nodes.BeginNode;
  65 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
  66 import org.graalvm.compiler.nodes.DeoptimizeNode;
  67 import org.graalvm.compiler.nodes.DeoptimizingGuard;
  68 import org.graalvm.compiler.nodes.EndNode;
  69 import org.graalvm.compiler.nodes.FixedGuardNode;
  70 import org.graalvm.compiler.nodes.FixedNode;
  71 import org.graalvm.compiler.nodes.FrameState;
  72 import org.graalvm.compiler.nodes.InliningLog;
  73 import org.graalvm.compiler.nodes.Invoke;
  74 import org.graalvm.compiler.nodes.InvokeNode;
  75 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
  76 import org.graalvm.compiler.nodes.LogicNode;
  77 import org.graalvm.compiler.nodes.MergeNode;
  78 import org.graalvm.compiler.nodes.NodeView;
  79 import org.graalvm.compiler.nodes.ParameterNode;
  80 import org.graalvm.compiler.nodes.PhiNode;
  81 import org.graalvm.compiler.nodes.PiNode;
  82 import org.graalvm.compiler.nodes.ReturnNode;
  83 import org.graalvm.compiler.nodes.StartNode;
  84 import org.graalvm.compiler.nodes.StateSplit;
  85 import org.graalvm.compiler.nodes.StructuredGraph;
  86 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
  87 import org.graalvm.compiler.nodes.UnwindNode;
  88 import org.graalvm.compiler.nodes.ValueNode;
  89 import org.graalvm.compiler.nodes.calc.IsNullNode;
  90 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  91 import org.graalvm.compiler.nodes.extended.GuardedNode;
  92 import org.graalvm.compiler.nodes.extended.GuardingNode;
  93 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
  94 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  95 import org.graalvm.compiler.nodes.java.MonitorExitNode;
  96 import org.graalvm.compiler.nodes.java.MonitorIdNode;
  97 import org.graalvm.compiler.nodes.type.StampTool;
  98 import org.graalvm.compiler.nodes.util.GraphUtil;
  99 import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
 100 import org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener;
 101 import org.graalvm.compiler.phases.util.ValueMergeUtil;
 102 
 103 import jdk.vm.ci.code.BytecodeFrame;
 104 import jdk.vm.ci.meta.Assumptions;
 105 import jdk.vm.ci.meta.DeoptimizationAction;
 106 import jdk.vm.ci.meta.DeoptimizationReason;
 107 import jdk.vm.ci.meta.JavaKind;
 108 import jdk.vm.ci.meta.ResolvedJavaMethod;
 109 import jdk.vm.ci.meta.ResolvedJavaType;
 110 
 111 public class InliningUtil extends ValueMergeUtil {
 112 
 113     private static final String inliningDecisionsScopeString = &quot;InliningDecisions&quot;;
 114 
 115     /**
 116      * Print a HotSpot-style inlining message to the console.
 117      */
 118     private static void printInlining(final InlineInfo info, final int inliningDepth, final boolean success, final String msg, final Object... args) {
 119         printInlining(info.methodAt(0), info.invoke(), inliningDepth, success, msg, args);
 120     }
 121 
 122     /**
 123      * @see #printInlining
 124      */
 125     private static void printInlining(final ResolvedJavaMethod method, final Invoke invoke, final int inliningDepth, final boolean success, final String msg, final Object... args) {
 126         if (HotSpotPrintInlining.getValue(invoke.asNode().getOptions())) {
 127             Util.printInlining(method, invoke.bci(), inliningDepth, success, msg, args);
 128         }
 129     }
 130 
 131     /**
 132      * Trace a decision to inline a method.
 133      *
 134      * This prints a HotSpot-style inlining message to the console, and it also logs the decision to
 135      * the logging stream.
 136      *
 137      * Phases that perform inlining should use this method to trace the inlining decisions, and use
 138      * the {@link #traceNotInlinedMethod} methods only for debugging purposes.
 139      */
 140     public static void traceInlinedMethod(InlineInfo info, int inliningDepth, boolean allowLogging, String msg, Object... args) {
 141         traceMethod(info, inliningDepth, allowLogging, true, msg, args);
 142     }
 143 
 144     /**
 145      * Trace a decision to inline a method.
 146      *
 147      * This prints a HotSpot-style inlining message to the console, and it also logs the decision to
 148      * the logging stream.
 149      *
 150      * Phases that perform inlining should use this method to trace the inlining decisions, and use
 151      * the {@link #traceNotInlinedMethod} methods only for debugging purposes.
 152      */
 153     public static void traceInlinedMethod(Invoke invoke, int inliningDepth, boolean allowLogging, ResolvedJavaMethod method, String msg, Object... args) {
 154         traceMethod(invoke, inliningDepth, allowLogging, true, method, msg, args);
 155     }
 156 
 157     /**
 158      * Trace a decision to not inline a method.
 159      *
 160      * This prints a HotSpot-style inlining message to the console, and it also logs the decision to
 161      * the logging stream.
 162      *
 163      * Phases that perform inlining should use this method to trace the inlining decisions, and use
 164      * the {@link #traceNotInlinedMethod} methods only for debugging purposes.
 165      */
 166     public static void traceNotInlinedMethod(InlineInfo info, int inliningDepth, String msg, Object... args) {
 167         traceMethod(info, inliningDepth, true, false, msg, args);
 168     }
 169 
 170     /**
 171      * Trace a decision about not inlining a method.
 172      *
 173      * This prints a HotSpot-style inlining message to the console, and it also logs the decision to
 174      * the logging stream.
 175      *
 176      * Phases that perform inlining should use this method to trace the inlining decisions, and use
 177      * the {@link #traceNotInlinedMethod} methods only for debugging purposes.
 178      */
 179     public static void traceNotInlinedMethod(Invoke invoke, int inliningDepth, ResolvedJavaMethod method, String msg, Object... args) {
 180         traceMethod(invoke, inliningDepth, true, false, method, msg, args);
 181     }
 182 
 183     private static void traceMethod(Invoke invoke, int inliningDepth, boolean allowLogging, boolean success, ResolvedJavaMethod method, String msg, Object... args) {
 184         if (allowLogging) {
 185             DebugContext debug = invoke.asNode().getDebug();
 186             printInlining(method, invoke, inliningDepth, success, msg, args);
 187             if (shouldLogMethod(debug)) {
 188                 String methodString = methodName(method, invoke);
 189                 logMethod(debug, methodString, success, msg, args);
 190             }
 191         }
 192     }
 193 
 194     private static void traceMethod(InlineInfo info, int inliningDepth, boolean allowLogging, boolean success, String msg, final Object... args) {
 195         if (allowLogging) {
 196             printInlining(info, inliningDepth, success, msg, args);
 197             DebugContext debug = info.graph().getDebug();
 198             if (shouldLogMethod(debug)) {
 199                 logMethod(debug, methodName(info), success, msg, args);
 200             }
 201         }
 202     }
 203 
 204     /**
 205      * Output a generic inlining decision to the logging stream (e.g. inlining termination
 206      * condition).
 207      *
 208      * Used for debugging purposes.
 209      */
 210     public static void logInliningDecision(DebugContext debug, final String msg, final Object... args) {
 211         logInlining(debug, msg, args);
 212     }
 213 
 214     /**
 215      * Output a decision about not inlining a method to the logging stream, for debugging purposes.
 216      */
 217     public static void logNotInlinedMethod(Invoke invoke, String msg) {
 218         DebugContext debug = invoke.asNode().getDebug();
 219         if (shouldLogMethod(debug)) {
 220             String methodString = invoke.toString();
 221             if (invoke.callTarget() == null) {
 222                 methodString += &quot; callTarget=null&quot;;
 223             } else {
 224                 String targetName = invoke.callTarget().targetName();
 225                 if (!methodString.endsWith(targetName)) {
 226                     methodString += &quot; &quot; + targetName;
 227                 }
 228             }
 229             logMethod(debug, methodString, false, msg, new Object[0]);
 230         }
 231     }
 232 
 233     private static void logMethod(DebugContext debug, final String methodString, final boolean success, final String msg, final Object... args) {
 234         String inliningMsg = &quot;inlining &quot; + methodString + &quot;: &quot; + msg;
 235         if (!success) {
 236             inliningMsg = &quot;not &quot; + inliningMsg;
 237         }
 238         logInlining(debug, inliningMsg, args);
 239     }
 240 
 241     @SuppressWarnings(&quot;try&quot;)
 242     private static void logInlining(DebugContext debug, final String msg, final Object... args) {
 243         try (DebugContext.Scope s = debug.scope(inliningDecisionsScopeString)) {
 244             // Can&#39;t use log here since we are varargs
 245             if (debug.isLogEnabled()) {
 246                 debug.logv(msg, args);
 247             }
 248         }
 249     }
 250 
 251     @SuppressWarnings(&quot;try&quot;)
 252     private static boolean shouldLogMethod(DebugContext debug) {
 253         try (DebugContext.Scope s = debug.scope(inliningDecisionsScopeString)) {
 254             return debug.isLogEnabled();
 255         }
 256     }
 257 
 258     private static String methodName(ResolvedJavaMethod method, Invoke invoke) {
 259         if (invoke != null &amp;&amp; invoke.stateAfter() != null) {
 260             return methodName(invoke.stateAfter(), invoke.bci()) + &quot;: &quot; + method.format(&quot;%H.%n(%p):%r&quot;) + &quot; (&quot; + method.getCodeSize() + &quot; bytes)&quot;;
 261         } else {
 262             return method.format(&quot;%H.%n(%p):%r&quot;) + &quot; (&quot; + method.getCodeSize() + &quot; bytes)&quot;;
 263         }
 264     }
 265 
 266     private static String methodName(InlineInfo info) {
 267         if (info == null) {
 268             return &quot;null&quot;;
 269         } else if (info.invoke() != null &amp;&amp; info.invoke().stateAfter() != null) {
 270             return methodName(info.invoke().stateAfter(), info.invoke().bci()) + &quot;: &quot; + info.toString();
 271         } else {
 272             return info.toString();
 273         }
 274     }
 275 
 276     private static String methodName(FrameState frameState, int bci) {
 277         StringBuilder sb = new StringBuilder();
 278         if (frameState.outerFrameState() != null) {
 279             sb.append(methodName(frameState.outerFrameState(), frameState.outerFrameState().bci));
 280             sb.append(&quot;-&gt;&quot;);
 281         }
 282         ResolvedJavaMethod method = frameState.getMethod();
 283         sb.append(method != null ? method.format(&quot;%h.%n&quot;) : &quot;?&quot;);
 284         sb.append(&quot;@&quot;).append(bci);
 285         return sb.toString();
 286     }
 287 
 288     public static void replaceInvokeCallTarget(Invoke invoke, StructuredGraph graph, InvokeKind invokeKind, ResolvedJavaMethod targetMethod) {
 289         MethodCallTargetNode oldCallTarget = (MethodCallTargetNode) invoke.callTarget();
 290         MethodCallTargetNode newCallTarget = graph.add(new MethodCallTargetNode(invokeKind, targetMethod, oldCallTarget.arguments().toArray(new ValueNode[0]), oldCallTarget.returnStamp(),
 291                         oldCallTarget.getProfile()));
 292         invoke.asNode().replaceFirstInput(oldCallTarget, newCallTarget);
 293     }
 294 
 295     public static PiNode createAnchoredReceiver(StructuredGraph graph, GuardingNode anchor, ResolvedJavaType commonType, ValueNode receiver, boolean exact) {
 296         return createAnchoredReceiver(graph, anchor, receiver,
 297                         exact ? StampFactory.objectNonNull(TypeReference.createExactTrusted(commonType)) : StampFactory.objectNonNull(TypeReference.createTrusted(graph.getAssumptions(), commonType)));
 298     }
 299 
 300     private static PiNode createAnchoredReceiver(StructuredGraph graph, GuardingNode anchor, ValueNode receiver, Stamp stamp) {
 301         // to avoid that floating reads on receiver fields float above the type check
 302         return graph.unique(new PiNode(receiver, stamp, (ValueNode) anchor));
 303     }
 304 
 305     /**
 306      * @return null iff the check succeeds, otherwise a (non-null) descriptive message.
 307      */
 308     public static String checkInvokeConditions(Invoke invoke) {
 309         if (invoke.predecessor() == null || !invoke.asNode().isAlive()) {
 310             return &quot;the invoke is dead code&quot;;
 311         }
 312         if (!(invoke.callTarget() instanceof MethodCallTargetNode)) {
 313             return &quot;the invoke has already been lowered, or has been created as a low-level node&quot;;
 314         }
 315         MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
 316         if (callTarget.targetMethod() == null) {
 317             return &quot;target method is null&quot;;
 318         }
 319         assert invoke.stateAfter() != null : invoke;
 320         if (!invoke.useForInlining()) {
 321             return &quot;the invoke is marked to be not used for inlining&quot;;
 322         }
 323         ValueNode receiver = callTarget.receiver();
 324         if (receiver != null &amp;&amp; receiver.isConstant() &amp;&amp; receiver.isNullConstant()) {
 325             return &quot;receiver is null&quot;;
 326         }
 327         return null;
 328     }
 329 
 330     /**
 331      * Performs an actual inlining, thereby replacing the given invoke with the given
 332      * {@code inlineGraph}.
 333      *
 334      * @param invoke the invoke that will be replaced
 335      * @param inlineGraph the graph that the invoke will be replaced with
 336      * @param receiverNullCheck true if a null check needs to be generated for non-static inlinings,
 337      *            false if no such check is required
 338      * @param inlineeMethod the actual method being inlined. Maybe be null for snippets.
 339      */
 340     @SuppressWarnings(&quot;try&quot;)
 341     public static UnmodifiableEconomicMap&lt;Node, Node&gt; inline(Invoke invoke, StructuredGraph inlineGraph, boolean receiverNullCheck, ResolvedJavaMethod inlineeMethod) {
 342         try {
 343             return inline(invoke, inlineGraph, receiverNullCheck, inlineeMethod, &quot;reason not specified&quot;, &quot;phase not specified&quot;);
 344         } catch (GraalError ex) {
 345             ex.addContext(&quot;inlining into&quot;, invoke.asNode().graph().method());
 346             ex.addContext(&quot;inlinee&quot;, inlineGraph.method());
 347             throw ex;
 348         }
 349     }
 350 
 351     /**
 352      * Performs an actual inlining, thereby replacing the given invoke with the given
 353      * {@code inlineGraph}.
 354      *
 355      * @param invoke the invoke that will be replaced
 356      * @param inlineGraph the graph that the invoke will be replaced with
 357      * @param receiverNullCheck true if a null check needs to be generated for non-static inlinings,
 358      *            false if no such check is required
 359      * @param inlineeMethod the actual method being inlined. Maybe be null for snippets.
 360      * @param reason the reason for inlining, used in tracing
 361      * @param phase the phase that invoked inlining
 362      */
 363     @SuppressWarnings(&quot;try&quot;)
 364     public static UnmodifiableEconomicMap&lt;Node, Node&gt; inline(Invoke invoke, StructuredGraph inlineGraph, boolean receiverNullCheck, ResolvedJavaMethod inlineeMethod, String reason, String phase) {
 365         FixedNode invokeNode = invoke.asNode();
 366         StructuredGraph graph = invokeNode.graph();
 367         final NodeInputList&lt;ValueNode&gt; parameters = invoke.callTarget().arguments();
 368 
 369         assert inlineGraph.getGuardsStage().ordinal() &gt;= graph.getGuardsStage().ordinal();
 370         assert !invokeNode.graph().isAfterFloatingReadPhase() : &quot;inline isn&#39;t handled correctly after floating reads phase&quot;;
 371 
 372         if (receiverNullCheck &amp;&amp; !((MethodCallTargetNode) invoke.callTarget()).isStatic()) {
 373             nonNullReceiver(invoke);
 374         }
 375 
 376         ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(inlineGraph.getNodes().count());
 377         ArrayList&lt;ReturnNode&gt; returnNodes = new ArrayList&lt;&gt;(4);
 378         ArrayList&lt;Invoke&gt; partialIntrinsicExits = new ArrayList&lt;&gt;();
 379         UnwindNode unwindNode = null;
 380         final StartNode entryPointNode = inlineGraph.start();
 381         FixedNode firstCFGNode = entryPointNode.next();
 382         if (firstCFGNode == null) {
 383             throw new IllegalStateException(&quot;Inlined graph is in invalid state: &quot; + inlineGraph);
 384         }
 385         for (Node node : inlineGraph.getNodes()) {
 386             if (node == entryPointNode || (node == entryPointNode.stateAfter() &amp;&amp; node.hasExactlyOneUsage()) || node instanceof ParameterNode) {
 387                 // Do nothing.
 388             } else {
 389                 nodes.add(node);
 390                 if (node instanceof ReturnNode) {
 391                     returnNodes.add((ReturnNode) node);
 392                 } else if (node instanceof Invoke) {
 393                     Invoke invokeInInlineGraph = (Invoke) node;
 394                     if (invokeInInlineGraph.bci() == BytecodeFrame.UNKNOWN_BCI) {
 395                         ResolvedJavaMethod target1 = inlineeMethod;
 396                         ResolvedJavaMethod target2 = invokeInInlineGraph.callTarget().targetMethod();
 397                         assert target1.equals(target2) : String.format(&quot;invoke in inlined method expected to be partial intrinsic exit (i.e., call to %s), not a call to %s&quot;,
 398                                         target1.format(&quot;%H.%n(%p)&quot;), target2.format(&quot;%H.%n(%p)&quot;));
 399                         partialIntrinsicExits.add(invokeInInlineGraph);
 400                     }
 401                 } else if (node instanceof UnwindNode) {
 402                     assert unwindNode == null;
 403                     unwindNode = (UnwindNode) node;
 404                 }
 405             }
 406         }
 407 
 408         final AbstractBeginNode prevBegin = AbstractBeginNode.prevBegin(invokeNode);
 409         DuplicationReplacement localReplacement = new DuplicationReplacement() {
 410 
 411             @Override
 412             public Node replacement(Node node) {
 413                 if (node instanceof ParameterNode) {
 414                     return parameters.get(((ParameterNode) node).index());
 415                 } else if (node == entryPointNode) {
 416                     return prevBegin;
 417                 }
 418                 return node;
 419             }
 420         };
 421 
 422         assert invokeNode.successors().first() != null : invoke;
 423         assert invokeNode.predecessor() != null;
 424 
 425         Mark mark = graph.getMark();
 426         // Instead, attach the inlining log of the child graph to the current inlining log.
 427         EconomicMap&lt;Node, Node&gt; duplicates;
 428         try (InliningLog.UpdateScope scope = graph.getInliningLog().openDefaultUpdateScope()) {
 429             duplicates = graph.addDuplicates(nodes, inlineGraph, inlineGraph.getNodeCount(), localReplacement);
 430             if (scope != null) {
 431                 graph.getInliningLog().addDecision(invoke, true, phase, duplicates, inlineGraph.getInliningLog(), reason);
 432             }
 433         }
 434 
 435         FrameState stateAfter = invoke.stateAfter();
 436         assert stateAfter == null || stateAfter.isAlive();
 437 
 438         FrameState stateAtExceptionEdge = null;
 439         if (invoke instanceof InvokeWithExceptionNode) {
 440             InvokeWithExceptionNode invokeWithException = ((InvokeWithExceptionNode) invoke);
 441             if (unwindNode != null) {
 442                 ExceptionObjectNode obj = (ExceptionObjectNode) invokeWithException.exceptionEdge();
 443                 stateAtExceptionEdge = obj.stateAfter();
 444             }
 445         }
 446 
 447         updateSourcePositions(invoke, inlineGraph, duplicates, !Objects.equals(inlineGraph.method(), inlineeMethod), mark);
 448         if (stateAfter != null) {
 449             processFrameStates(invoke, inlineGraph, duplicates, stateAtExceptionEdge, returnNodes.size() &gt; 1);
 450             int callerLockDepth = stateAfter.nestedLockDepth();
 451             if (callerLockDepth != 0) {
 452                 for (MonitorIdNode original : inlineGraph.getNodes(MonitorIdNode.TYPE)) {
 453                     MonitorIdNode monitor = (MonitorIdNode) duplicates.get(original);
 454                     processMonitorId(invoke.stateAfter(), monitor);
 455                 }
 456             }
 457         } else {
 458             assert checkContainsOnlyInvalidOrAfterFrameState(duplicates);
 459         }
 460 
 461         firstCFGNode = (FixedNode) duplicates.get(firstCFGNode);
 462         for (int i = 0; i &lt; returnNodes.size(); i++) {
 463             returnNodes.set(i, (ReturnNode) duplicates.get(returnNodes.get(i)));
 464         }
 465         for (Invoke exit : partialIntrinsicExits) {
 466             // A partial intrinsic exit must be replaced with a call to
 467             // the intrinsified method.
 468             Invoke dup = (Invoke) duplicates.get(exit.asNode());
 469             dup.replaceBci(invoke.bci());
 470         }
 471         if (unwindNode != null) {
 472             unwindNode = (UnwindNode) duplicates.get(unwindNode);
 473         }
 474 
 475         finishInlining(invoke, graph, firstCFGNode, returnNodes, unwindNode, inlineGraph.getAssumptions(), inlineGraph);
 476         GraphUtil.killCFG(invokeNode);
 477 
 478         return duplicates;
 479     }
 480 
 481     /**
 482      * Inline {@code inlineGraph} into the current replacing the node {@code Invoke} and return the
 483      * set of nodes which should be canonicalized. The set should only contain nodes which modified
 484      * by the inlining since the current graph and {@code inlineGraph} are expected to already be
 485      * canonical.
 486      *
 487      * @param invoke
 488      * @param inlineGraph
 489      * @param receiverNullCheck
 490      * @param inlineeMethod
 491      * @return the set of nodes to canonicalize
 492      */
 493     @SuppressWarnings(&quot;try&quot;)
 494     public static EconomicSet&lt;Node&gt; inlineForCanonicalization(Invoke invoke, StructuredGraph inlineGraph, boolean receiverNullCheck, ResolvedJavaMethod inlineeMethod, String reason, String phase) {
 495         return inlineForCanonicalization(invoke, inlineGraph, receiverNullCheck, inlineeMethod, null, reason, phase);
 496     }
 497 
 498     @SuppressWarnings(&quot;try&quot;)
 499     public static EconomicSet&lt;Node&gt; inlineForCanonicalization(Invoke invoke, StructuredGraph inlineGraph, boolean receiverNullCheck, ResolvedJavaMethod inlineeMethod,
 500                     Consumer&lt;UnmodifiableEconomicMap&lt;Node, Node&gt;&gt; duplicatesConsumer, String reason, String phase) {
 501         EconomicSetNodeEventListener listener = new EconomicSetNodeEventListener();
 502         /*
 503          * This code relies on the fact that Graph.addDuplicates doesn&#39;t trigger the
 504          * NodeEventListener to track only nodes which were modified into the process of inlining
 505          * the graph into the current graph.
 506          */
 507         try (NodeEventScope nes = invoke.asNode().graph().trackNodeEvents(listener)) {
 508             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = InliningUtil.inline(invoke, inlineGraph, receiverNullCheck, inlineeMethod, reason, phase);
 509             if (duplicatesConsumer != null) {
 510                 duplicatesConsumer.accept(duplicates);
 511             }
 512         }
 513         return listener.getNodes();
 514     }
 515 
 516     @SuppressWarnings(&quot;try&quot;)
 517     private static ValueNode finishInlining(Invoke invoke, StructuredGraph graph, FixedNode firstNode, List&lt;ReturnNode&gt; returnNodes, UnwindNode unwindNode, Assumptions inlinedAssumptions,
 518                     StructuredGraph inlineGraph) {
 519         FixedNode invokeNode = invoke.asNode();
 520         FrameState stateAfter = invoke.stateAfter();
 521         assert stateAfter == null || stateAfter.isAlive();
 522 
 523         invokeNode.replaceAtPredecessor(firstNode);
 524 
 525         if (invoke instanceof InvokeWithExceptionNode) {
 526             InvokeWithExceptionNode invokeWithException = ((InvokeWithExceptionNode) invoke);
 527             if (unwindNode != null &amp;&amp; unwindNode.isAlive()) {
 528                 assert unwindNode.predecessor() != null;
 529                 assert invokeWithException.exceptionEdge().successors().count() == 1;
 530                 ExceptionObjectNode obj = (ExceptionObjectNode) invokeWithException.exceptionEdge();
 531                 /*
 532                  * The exception object node is a begin node, i.e., it can be used as an anchor for
 533                  * other nodes, thus we need to re-route them to a valid anchor, i.e. the begin node
 534                  * of the unwind block.
 535                  */
 536                 assert obj.usages().filter(x -&gt; x instanceof GuardedNode &amp;&amp; ((GuardedNode) x).getGuard() == obj).count() == 0 : &quot;Must not have guards attached to an exception object node&quot;;
 537                 AbstractBeginNode replacementAnchor = AbstractBeginNode.prevBegin(unwindNode);
 538                 assert replacementAnchor != null;
 539                 obj.replaceAtUsages(InputType.Anchor, replacementAnchor);
 540                 obj.replaceAtUsages(InputType.Value, unwindNode.exception());
 541 
 542                 Node n = obj.next();
 543                 obj.setNext(null);
 544                 unwindNode.replaceAndDelete(n);
 545 
 546                 obj.replaceAtPredecessor(null);
 547                 obj.safeDelete();
 548             } else {
 549                 invokeWithException.killExceptionEdge();
 550             }
 551 
 552             // get rid of memory kill
 553             invokeWithException.killKillingBegin();
 554         } else {
 555             if (unwindNode != null &amp;&amp; unwindNode.isAlive()) {
 556                 try (DebugCloseable position = unwindNode.withNodeSourcePosition()) {
 557                     DeoptimizeNode deoptimizeNode = addDeoptimizeNode(graph, DeoptimizationAction.InvalidateRecompile, DeoptimizationReason.NotCompiledExceptionHandler);
 558                     unwindNode.replaceAndDelete(deoptimizeNode);
 559                 }
 560             }
 561         }
 562 
 563         ValueNode returnValue;
 564         if (!returnNodes.isEmpty()) {
 565             FixedNode n = invoke.next();
 566             invoke.setNext(null);
 567             if (returnNodes.size() == 1) {
 568                 ReturnNode returnNode = returnNodes.get(0);
 569                 returnValue = returnNode.result();
 570                 invokeNode.replaceAtUsages(returnValue);
 571                 returnNode.replaceAndDelete(n);
 572             } else {
 573                 MergeNode merge = graph.add(new MergeNode());
 574                 merge.setStateAfter(stateAfter);
 575                 returnValue = mergeReturns(merge, returnNodes);
 576                 invokeNode.replaceAtUsages(returnValue);
 577                 if (merge.isPhiAtMerge(returnValue)) {
 578                     fixFrameStates(graph, merge, (PhiNode) returnValue);
 579                 }
 580                 merge.setNext(n);
 581             }
 582         } else {
 583             returnValue = null;
 584             invokeNode.replaceAtUsages(null);
 585             GraphUtil.killCFG(invoke.next());
 586         }
 587 
 588         // Copy assumptions from inlinee to caller
 589         Assumptions assumptions = graph.getAssumptions();
 590         if (assumptions != null) {
 591             if (inlinedAssumptions != null) {
 592                 assumptions.record(inlinedAssumptions);
 593             }
 594         } else {
 595             assert inlinedAssumptions == null : String.format(&quot;cannot inline graph (%s) which makes assumptions into a graph (%s) that doesn&#39;t&quot;, inlineGraph, graph);
 596         }
 597 
 598         // Copy inlined methods from inlinee to caller
 599         graph.updateMethods(inlineGraph);
 600 
 601         // Update the set of accessed fields
 602         if (GraalOptions.GeneratePIC.getValue(graph.getOptions())) {
 603             graph.updateFields(inlineGraph);
 604         }
 605 
 606         if (inlineGraph.hasUnsafeAccess()) {
 607             graph.markUnsafeAccess();
 608         }
 609         assert inlineGraph.getSpeculationLog() == null || inlineGraph.getSpeculationLog() == graph.getSpeculationLog() : &quot;Only the root graph should have a speculation log&quot;;
 610 
 611         return returnValue;
 612     }
 613 
 614     private static void fixFrameStates(StructuredGraph graph, MergeNode originalMerge, PhiNode returnPhi) {
 615         // It is possible that some of the frame states that came from AFTER_BCI reference a Phi
 616         // node that was created to merge multiple returns. This can create cycles
 617         // (see GR-3949 and GR-3957).
 618         // To detect this, we follow the control paths starting from the merge node,
 619         // split the Phi node inputs at merges and assign the proper input to each frame state.
 620         NodeMap&lt;Node&gt; seen = new NodeMap&lt;&gt;(graph);
 621         ArrayDeque&lt;Node&gt; workList = new ArrayDeque&lt;&gt;();
 622         ArrayDeque&lt;ValueNode&gt; valueList = new ArrayDeque&lt;&gt;();
 623         workList.push(originalMerge);
 624         valueList.push(returnPhi);
 625         while (!workList.isEmpty()) {
 626             Node current = workList.pop();
 627             ValueNode currentValue = valueList.pop();
 628             if (seen.containsKey(current)) {
 629                 continue;
 630             }
 631             seen.put(current, current);
 632             if (current instanceof StateSplit &amp;&amp; current != originalMerge) {
 633                 StateSplit stateSplit = (StateSplit) current;
 634                 FrameState state = stateSplit.stateAfter();
 635                 if (state != null &amp;&amp; state.values().contains(returnPhi)) {
 636                     int index = 0;
 637                     FrameState duplicate = state.duplicate();
 638                     for (ValueNode value : state.values()) {
 639                         if (value == returnPhi) {
 640                             duplicate.values().set(index, currentValue);
 641                         }
 642                         index++;
 643                     }
 644                     stateSplit.setStateAfter(duplicate);
 645                     GraphUtil.tryKillUnused(state);
 646                 }
 647             }
 648             if (current instanceof AbstractMergeNode) {
 649                 AbstractMergeNode currentMerge = (AbstractMergeNode) current;
 650                 for (EndNode pred : currentMerge.cfgPredecessors()) {
 651                     ValueNode newValue = currentValue;
 652                     if (currentMerge.isPhiAtMerge(currentValue)) {
 653                         PhiNode currentPhi = (PhiNode) currentValue;
 654                         newValue = currentPhi.valueAt(pred);
 655                     }
 656                     workList.push(pred);
 657                     valueList.push(newValue);
 658                 }
 659             } else if (current.predecessor() != null) {
 660                 workList.push(current.predecessor());
 661                 valueList.push(currentValue);
 662             }
 663         }
 664     }
 665 
 666     @SuppressWarnings(&quot;try&quot;)
 667     private static void updateSourcePositions(Invoke invoke, StructuredGraph inlineGraph, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates, boolean isSub, Mark mark) {
 668         FixedNode invokeNode = invoke.asNode();
 669         StructuredGraph invokeGraph = invokeNode.graph();
 670         if (invokeGraph.trackNodeSourcePosition() &amp;&amp; invoke.stateAfter() != null) {
 671             boolean isSubstitution = isSub || inlineGraph.isSubstitution();
 672             assert !invokeGraph.trackNodeSourcePosition() || inlineGraph.trackNodeSourcePosition() ||
 673                             isSubstitution : String.format(&quot;trackNodeSourcePosition mismatch %s %s != %s %s&quot;, invokeGraph, invokeGraph.trackNodeSourcePosition(), inlineGraph,
 674                                             inlineGraph.trackNodeSourcePosition());
 675             final NodeSourcePosition invokePos = invoke.asNode().getNodeSourcePosition();
 676             updateSourcePosition(invokeGraph, duplicates, mark, invokePos, isSubstitution);
 677         }
 678     }
 679 
 680     public static void updateSourcePosition(StructuredGraph invokeGraph, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates, Mark mark, NodeSourcePosition invokePos, boolean isSubstitution) {
 681         /*
 682          * Not every duplicate node is newly created, so only update the position of the newly
 683          * created nodes.
 684          */
 685         EconomicSet&lt;Node&gt; newNodes = EconomicSet.create(Equivalence.DEFAULT);
 686         newNodes.addAll(invokeGraph.getNewNodes(mark));
 687         EconomicMap&lt;NodeSourcePosition, NodeSourcePosition&gt; posMap = EconomicMap.create(Equivalence.DEFAULT);
 688         UnmodifiableMapCursor&lt;Node, Node&gt; cursor = duplicates.getEntries();
 689         ResolvedJavaMethod inlineeRoot = null;
 690         while (cursor.advance()) {
 691             Node value = cursor.getValue();
 692             if (!newNodes.contains(value)) {
 693                 continue;
 694             }
 695             if (isSubstitution &amp;&amp; invokePos == null) {
 696                 // There&#39;s no caller information so the source position for this node will be
 697                 // invalid, so it should be cleared.
 698                 value.clearNodeSourcePosition();
 699             } else {
 700                 NodeSourcePosition pos = cursor.getKey().getNodeSourcePosition();
 701                 if (pos != null) {
 702                     if (inlineeRoot == null) {
 703                         assert (inlineeRoot = pos.getRootMethod()) != null;
 704                     } else {
 705                         assert pos.verifyRootMethod(inlineeRoot);
 706                     }
 707                     NodeSourcePosition callerPos = posMap.get(pos);
 708                     if (callerPos == null) {
 709                         callerPos = pos.addCaller(invokePos, isSubstitution);
 710                         posMap.put(pos, callerPos);
 711                     }
 712                     value.setNodeSourcePosition(callerPos);
 713 
 714                     if (value instanceof DeoptimizingGuard) {
 715                         ((DeoptimizingGuard) value).addCallerToNoDeoptSuccessorPosition(callerPos.getCaller());
 716                     }
 717                 } else {
 718                     if (isSubstitution) {
 719                         /*
 720                          * If no other position is provided at least attribute the substituted node
 721                          * to the original invoke.
 722                          */
 723                         value.setNodeSourcePosition(invokePos);
 724                     }
 725                 }
 726             }
 727         }
 728         assert invokeGraph.verifySourcePositions(false);
 729     }
 730 
 731     public static void processMonitorId(FrameState stateAfter, MonitorIdNode monitorIdNode) {
 732         if (stateAfter != null) {
 733             int callerLockDepth = stateAfter.nestedLockDepth();
 734             monitorIdNode.setLockDepth(monitorIdNode.getLockDepth() + callerLockDepth);
 735         }
 736     }
 737 
 738     protected static void processFrameStates(Invoke invoke, StructuredGraph inlineGraph, EconomicMap&lt;Node, Node&gt; duplicates, FrameState stateAtExceptionEdge,
 739                     boolean alwaysDuplicateStateAfter) {
 740         FrameState stateAtReturn = invoke.stateAfter();
 741         FrameState outerFrameState = null;
 742         JavaKind invokeReturnKind = invoke.asNode().getStackKind();
 743         EconomicMap&lt;Node, Node&gt; replacements = EconomicMap.create(Equivalence.IDENTITY);
 744         for (FrameState original : inlineGraph.getNodes(FrameState.TYPE)) {
 745             FrameState frameState = (FrameState) duplicates.get(original);
 746             if (frameState != null &amp;&amp; frameState.isAlive()) {
 747                 if (outerFrameState == null) {
 748                     outerFrameState = stateAtReturn.duplicateModifiedDuringCall(invoke.bci(), invokeReturnKind);
 749                 }
 750                 processFrameState(frameState, invoke, replacements, inlineGraph.method(), stateAtExceptionEdge, outerFrameState, alwaysDuplicateStateAfter, invoke.callTarget().targetMethod(),
 751                                 invoke.callTarget().arguments());
 752             }
 753         }
 754         // If processing the frame states replaced any nodes, update the duplicates map.
 755         duplicates.replaceAll((key, value) -&gt; replacements.containsKey(value) ? replacements.get(value) : value);
 756     }
 757 
 758     public static FrameState processFrameState(FrameState frameState, Invoke invoke, EconomicMap&lt;Node, Node&gt; replacements, ResolvedJavaMethod inlinedMethod, FrameState stateAtExceptionEdge,
 759                     FrameState outerFrameState,
 760                     boolean alwaysDuplicateStateAfter, ResolvedJavaMethod invokeTargetMethod, List&lt;ValueNode&gt; invokeArgsList) {
 761         assert outerFrameState == null || !outerFrameState.isDeleted() : outerFrameState;
 762         final FrameState stateAtReturn = invoke.stateAfter();
 763         JavaKind invokeReturnKind = invoke.asNode().getStackKind();
 764 
 765         if (frameState.bci == BytecodeFrame.AFTER_BCI) {
 766             return handleAfterBciFrameState(frameState, invoke, alwaysDuplicateStateAfter);
 767         } else if (stateAtExceptionEdge != null &amp;&amp; isStateAfterException(frameState)) {
 768             // pop exception object from invoke&#39;s stateAfter and replace with this frameState&#39;s
 769             // exception object (top of stack)
 770             FrameState stateAfterException = stateAtExceptionEdge;
 771             if (frameState.stackSize() &gt; 0 &amp;&amp; stateAtExceptionEdge.stackAt(0) != frameState.stackAt(0)) {
 772                 stateAfterException = stateAtExceptionEdge.duplicateModified(JavaKind.Object, JavaKind.Object, frameState.stackAt(0));
 773             }
 774             frameState.replaceAndDelete(stateAfterException);
 775             return stateAfterException;
 776         } else if ((frameState.bci == BytecodeFrame.UNWIND_BCI &amp;&amp; frameState.graph().getGuardsStage() == GuardsStage.FLOATING_GUARDS) || frameState.bci == BytecodeFrame.AFTER_EXCEPTION_BCI) {
 777             /*
 778              * This path converts the frame states relevant for exception unwinding to
 779              * deoptimization. This is only allowed in configurations when Graal compiles code for
 780              * speculative execution (e.g., JIT compilation in HotSpot) but not when compiled code
 781              * must be deoptimization free (e.g., AOT compilation for native image generation).
 782              * There is currently no global flag in StructuredGraph to distinguish such modes, but
 783              * the GuardsStage during inlining indicates the mode in which Graal operates.
 784              */
 785             handleMissingAfterExceptionFrameState(frameState, invoke, replacements, alwaysDuplicateStateAfter);
 786             return frameState;
 787         } else if (frameState.bci == BytecodeFrame.BEFORE_BCI) {
 788             // This is an intrinsic. Deoptimizing within an intrinsic
 789             // must re-execute the intrinsified invocation
 790             assert frameState.outerFrameState() == null;
 791             ValueNode[] invokeArgs = invokeArgsList.isEmpty() ? NO_ARGS : invokeArgsList.toArray(new ValueNode[invokeArgsList.size()]);
 792             FrameState stateBeforeCall = stateAtReturn.duplicateModifiedBeforeCall(invoke.bci(), invokeReturnKind, invokeTargetMethod.getSignature().toParameterKinds(!invokeTargetMethod.isStatic()),
 793                             invokeArgs);
 794             frameState.replaceAndDelete(stateBeforeCall);
 795             return stateBeforeCall;
 796         } else {
 797             // only handle the outermost frame states
 798             if (frameState.outerFrameState() == null) {
 799                 assert checkInlineeFrameState(invoke, inlinedMethod, frameState);
 800                 frameState.setOuterFrameState(outerFrameState);
 801             }
 802             return frameState;
 803         }
 804     }
 805 
 806     private static FrameState handleAfterBciFrameState(FrameState frameState, Invoke invoke, boolean alwaysDuplicateStateAfter) {
 807         FrameState stateAtReturn = invoke.stateAfter();
 808         JavaKind invokeReturnKind = invoke.asNode().getStackKind();
 809         FrameState stateAfterReturn = stateAtReturn;
 810         if (frameState.getCode() == null) {
 811             // This is a frame state for a side effect within an intrinsic
 812             // that was parsed for post-parse intrinsification
 813             for (Node usage : frameState.usages()) {
 814                 if (usage instanceof ForeignCallNode) {
 815                     // A foreign call inside an intrinsic needs to have
 816                     // the BCI of the invoke being intrinsified
 817                     ForeignCallNode foreign = (ForeignCallNode) usage;
 818                     foreign.setBci(invoke.bci());
 819                 }
 820             }
 821         }
 822 
 823         // pop return kind from invoke&#39;s stateAfter and replace with this frameState&#39;s return
 824         // value (top of stack)
 825         assert !frameState.rethrowException() : frameState;
 826         if (frameState.stackSize() &gt; 0 &amp;&amp; (alwaysDuplicateStateAfter || stateAfterReturn.stackAt(0) != frameState.stackAt(0))) {
 827             // A non-void return value.
 828             stateAfterReturn = stateAtReturn.duplicateModified(invokeReturnKind, invokeReturnKind, frameState.stackAt(0));
 829         } else {
 830             // A void return value.
 831             stateAfterReturn = stateAtReturn.duplicate();
 832         }
 833         assert stateAfterReturn.bci != BytecodeFrame.UNKNOWN_BCI;
 834 
 835         // Return value does no longer need to be limited by the monitor exit.
 836         for (MonitorExitNode n : frameState.usages().filter(MonitorExitNode.class)) {
 837             n.clearEscapedValue();
 838         }
 839 
 840         frameState.replaceAndDelete(stateAfterReturn);
 841         return stateAfterReturn;
 842     }
 843 
 844     static boolean checkInlineeFrameState(Invoke invoke, ResolvedJavaMethod inlinedMethod, FrameState frameState) {
 845         assert frameState.bci != BytecodeFrame.AFTER_EXCEPTION_BCI : frameState;
 846         assert frameState.bci != BytecodeFrame.BEFORE_BCI : frameState;
 847         assert frameState.bci != BytecodeFrame.UNKNOWN_BCI : frameState;
 848         if (frameState.bci != BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 849             ResolvedJavaMethod method = frameState.getMethod();
 850             if (method.equals(inlinedMethod)) {
 851                 // Normal inlining expects all outermost inlinee frame states to
 852                 // denote the inlinee method
 853             } else if (method.equals(invoke.callTarget().targetMethod())) {
 854                 // This occurs when an intrinsic calls back to the original
 855                 // method to handle a slow path. During parsing of such a
 856                 // partial intrinsic, these calls are given frame states
 857                 // that exclude the outer frame state denoting a position
 858                 // in the intrinsic code.
 859                 assert inlinedMethod.getAnnotation(
 860                                 MethodSubstitution.class) != null : &quot;expected an intrinsic when inlinee frame state matches method of call target but does not match the method of the inlinee graph: &quot; +
 861                                                 frameState;
 862             } else if (method.getName().equals(inlinedMethod.getName())) {
 863                 // This can happen for method substitutions.
 864             } else {
 865                 throw new AssertionError(String.format(&quot;inlinedMethod=%s frameState.method=%s frameState=%s invoke.method=%s&quot;, inlinedMethod, method, frameState,
 866                                 invoke.callTarget().targetMethod()));
 867             }
 868         }
 869         return true;
 870     }
 871 
 872     private static final ValueNode[] NO_ARGS = {};
 873 
 874     private static boolean isStateAfterException(FrameState frameState) {
 875         return frameState.bci == BytecodeFrame.AFTER_EXCEPTION_BCI || (frameState.bci == BytecodeFrame.UNWIND_BCI &amp;&amp; !frameState.getMethod().isSynchronized());
 876     }
 877 
 878     @SuppressWarnings(&quot;try&quot;)
 879     public static FrameState handleMissingAfterExceptionFrameState(FrameState nonReplaceableFrameState, Invoke invoke, EconomicMap&lt;Node, Node&gt; replacements, boolean alwaysDuplicateStateAfter) {
 880         StructuredGraph graph = nonReplaceableFrameState.graph();
 881         NodeWorkList workList = graph.createNodeWorkList();
 882         workList.add(nonReplaceableFrameState);
 883         for (Node node : workList) {
 884             FrameState fs = (FrameState) node;
 885             for (Node usage : fs.usages().snapshot()) {
 886                 if (!usage.isAlive()) {
 887                     continue;
 888                 }
 889                 if (usage instanceof FrameState) {
 890                     workList.add(usage);
 891                 } else {
 892                     StateSplit stateSplit = (StateSplit) usage;
 893                     FixedNode fixedStateSplit = stateSplit.asNode();
 894                     if (fixedStateSplit instanceof AbstractMergeNode) {
 895                         AbstractMergeNode merge = (AbstractMergeNode) fixedStateSplit;
 896                         while (merge.isAlive()) {
 897                             AbstractEndNode end = merge.forwardEnds().first();
 898                             try (DebugCloseable position = end.withNodeSourcePosition()) {
 899                                 DeoptimizeNode deoptimizeNode = addDeoptimizeNode(graph, DeoptimizationAction.InvalidateRecompile, DeoptimizationReason.NotCompiledExceptionHandler);
 900                                 end.replaceAtPredecessor(deoptimizeNode);
 901                                 GraphUtil.killCFG(end);
 902                             }
 903                         }
 904                     } else if (fixedStateSplit instanceof ExceptionObjectNode) {
 905                         // The target invoke does not have an exception edge. This means that the
 906                         // bytecode parser made the wrong assumption of making an
 907                         // InvokeWithExceptionNode for the partial intrinsic exit. We therefore
 908                         // replace the InvokeWithExceptionNode with a normal
 909                         // InvokeNode -- the deoptimization occurs when the invoke throws.
 910                         InvokeWithExceptionNode oldInvoke = (InvokeWithExceptionNode) fixedStateSplit.predecessor();
 911                         InvokeNode newInvoke = oldInvoke.replaceWithInvoke();
 912                         if (replacements != null) {
 913                             replacements.put(oldInvoke, newInvoke);
 914                         }
 915                         handleAfterBciFrameState(newInvoke.stateAfter(), invoke, alwaysDuplicateStateAfter);
 916                     } else {
 917                         try (DebugCloseable position = fixedStateSplit.withNodeSourcePosition()) {
 918                             FixedNode deoptimizeNode = addDeoptimizeNode(graph, DeoptimizationAction.InvalidateRecompile, DeoptimizationReason.NotCompiledExceptionHandler);
 919                             if (fixedStateSplit instanceof AbstractBeginNode) {
 920                                 deoptimizeNode = BeginNode.begin(deoptimizeNode);
 921                             }
 922                             fixedStateSplit.replaceAtPredecessor(deoptimizeNode);
 923                             GraphUtil.killCFG(fixedStateSplit);
 924                         }
 925                     }
 926                 }
 927             }
 928         }
 929         return nonReplaceableFrameState;
 930     }
 931 
 932     private static DeoptimizeNode addDeoptimizeNode(StructuredGraph graph, DeoptimizationAction action, DeoptimizationReason reason) {
 933         GraalError.guarantee(graph.getGuardsStage() == GuardsStage.FLOATING_GUARDS, &quot;Cannot introduce speculative deoptimization when Graal is used with fixed guards&quot;);
 934         return graph.add(new DeoptimizeNode(action, reason));
 935     }
 936 
 937     /**
 938      * Ensure that all states are either {@link BytecodeFrame#INVALID_FRAMESTATE_BCI} or one of
 939      * {@link BytecodeFrame#AFTER_BCI} or {@link BytecodeFrame#BEFORE_BCI}. Mixing of before and
 940      * after isn&#39;t allowed.
 941      */
 942     private static boolean checkContainsOnlyInvalidOrAfterFrameState(UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
 943         int okBci = BytecodeFrame.INVALID_FRAMESTATE_BCI;
 944         for (Node node : duplicates.getValues()) {
 945             if (node instanceof FrameState) {
 946                 FrameState frameState = (FrameState) node;
 947                 if (frameState.bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 948                     continue;
 949                 }
 950                 if (frameState.bci == BytecodeFrame.AFTER_BCI || frameState.bci == BytecodeFrame.BEFORE_BCI) {
 951                     if (okBci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 952                         okBci = frameState.bci;
 953                     } else {
 954                         assert okBci == frameState.bci : node.toString(Verbosity.Debugger);
 955                     }
 956                 } else {
 957                     assert false : node.toString(Verbosity.Debugger);
 958                 }
 959             }
 960         }
 961         return true;
 962     }
 963 
 964     /**
 965      * Gets the receiver for an invoke, adding a guard if necessary to ensure it is non-null, and
 966      * ensuring that the resulting type is compatible with the method being invoked.
 967      */
 968     @SuppressWarnings(&quot;try&quot;)
 969     public static ValueNode nonNullReceiver(Invoke invoke) {
 970         try (DebugCloseable position = invoke.asNode().withNodeSourcePosition()) {
 971             MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
 972             assert !callTarget.isStatic() : callTarget.targetMethod();
 973             StructuredGraph graph = callTarget.graph();
 974             ValueNode oldReceiver = callTarget.arguments().get(0);
 975             ValueNode newReceiver = oldReceiver;
 976             if (newReceiver.getStackKind() == JavaKind.Object) {
 977 
 978                 if (invoke.getInvokeKind() == InvokeKind.Special) {
 979                     Stamp paramStamp = newReceiver.stamp(NodeView.DEFAULT);
 980                     Stamp stamp = paramStamp.join(StampFactory.object(TypeReference.create(graph.getAssumptions(), callTarget.targetMethod().getDeclaringClass())));
 981                     if (!stamp.equals(paramStamp)) {
 982                         // The verifier and previous optimizations guarantee unconditionally that
 983                         // the
 984                         // receiver is at least of the type of the method holder for a special
 985                         // invoke.
 986                         newReceiver = graph.unique(new PiNode(newReceiver, stamp));
 987                     }
 988                 }
 989 
 990                 if (!StampTool.isPointerNonNull(newReceiver)) {
 991                     LogicNode condition = graph.unique(IsNullNode.create(newReceiver));
 992                     FixedGuardNode fixedGuard = graph.add(new FixedGuardNode(condition, NullCheckException, InvalidateReprofile, true));
 993                     PiNode nonNullReceiver = graph.unique(new PiNode(newReceiver, StampFactory.objectNonNull(), fixedGuard));
 994                     graph.addBeforeFixed(invoke.asNode(), fixedGuard);
 995                     newReceiver = nonNullReceiver;
 996                 }
 997             }
 998 
 999             if (newReceiver != oldReceiver) {
1000                 callTarget.replaceFirstInput(oldReceiver, newReceiver);
1001             }
1002             return newReceiver;
1003         }
1004     }
1005 
1006     /**
1007      * This method exclude InstrumentationNode from inlining heuristics.
1008      */
1009     public static int getNodeCount(StructuredGraph graph) {
1010         return graph.getNodeCount();
1011     }
1012 
1013 }
    </pre>
  </body>
</html>
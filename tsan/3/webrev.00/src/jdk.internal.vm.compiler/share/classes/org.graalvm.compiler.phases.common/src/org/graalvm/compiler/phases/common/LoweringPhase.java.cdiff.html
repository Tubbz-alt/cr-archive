<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/LoweringPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IterativeConditionalEliminationPhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeCounterPhase.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/LoweringPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,17 ***</span>
<span class="line-new-header">--- 36,19 ---</span>
  import java.util.ArrayList;
  import java.util.Collection;
  import java.util.List;
  
  import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
<span class="line-added">+ import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;</span>
  import org.graalvm.compiler.core.common.type.StampFactory;
  import org.graalvm.compiler.debug.DebugCloseable;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.graph.Graph.Mark;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.NodeBitMap;
  import org.graalvm.compiler.graph.NodeClass;
<span class="line-added">+ import org.graalvm.compiler.graph.NodeMap;</span>
  import org.graalvm.compiler.graph.NodeSourcePosition;
  import org.graalvm.compiler.graph.iterators.NodeIterable;
  import org.graalvm.compiler.nodeinfo.InputType;
  import org.graalvm.compiler.nodeinfo.NodeInfo;
  import org.graalvm.compiler.nodes.AbstractBeginNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,20 ***</span>
  import org.graalvm.compiler.nodes.cfg.Block;
  import org.graalvm.compiler.nodes.extended.AnchoringNode;
  import org.graalvm.compiler.nodes.extended.GuardedNode;
  import org.graalvm.compiler.nodes.extended.GuardingNode;
  import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;
  import org.graalvm.compiler.nodes.spi.Lowerable;
  import org.graalvm.compiler.nodes.spi.LoweringProvider;
  import org.graalvm.compiler.nodes.spi.LoweringTool;
  import org.graalvm.compiler.nodes.spi.Replacements;
  import org.graalvm.compiler.nodes.spi.StampProvider;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.BasePhase;
  import org.graalvm.compiler.phases.Phase;
  import org.graalvm.compiler.phases.schedule.SchedulePhase;
<span class="line-removed">- import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
  import jdk.internal.vm.compiler.word.LocationIdentity;
  
  import jdk.vm.ci.meta.ConstantReflectionProvider;
  import jdk.vm.ci.meta.DeoptimizationAction;
  import jdk.vm.ci.meta.DeoptimizationReason;
<span class="line-new-header">--- 68,20 ---</span>
  import org.graalvm.compiler.nodes.cfg.Block;
  import org.graalvm.compiler.nodes.extended.AnchoringNode;
  import org.graalvm.compiler.nodes.extended.GuardedNode;
  import org.graalvm.compiler.nodes.extended.GuardingNode;
  import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;
<span class="line-added">+ import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
  import org.graalvm.compiler.nodes.spi.Lowerable;
  import org.graalvm.compiler.nodes.spi.LoweringProvider;
  import org.graalvm.compiler.nodes.spi.LoweringTool;
  import org.graalvm.compiler.nodes.spi.Replacements;
  import org.graalvm.compiler.nodes.spi.StampProvider;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.BasePhase;
  import org.graalvm.compiler.phases.Phase;
  import org.graalvm.compiler.phases.schedule.SchedulePhase;
  import jdk.internal.vm.compiler.word.LocationIdentity;
  
  import jdk.vm.ci.meta.ConstantReflectionProvider;
  import jdk.vm.ci.meta.DeoptimizationAction;
  import jdk.vm.ci.meta.DeoptimizationReason;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,11 ***</span>
  import jdk.vm.ci.meta.SpeculationLog.Speculation;
  
  /**
   * Processes all {@link Lowerable} nodes to do their lowering.
   */
<span class="line-modified">! public class LoweringPhase extends BasePhase&lt;PhaseContext&gt; {</span>
  
      @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
      static final class DummyGuardHandle extends ValueNode implements GuardedNode {
          public static final NodeClass&lt;DummyGuardHandle&gt; TYPE = NodeClass.create(DummyGuardHandle.class);
          @Input(InputType.Guard) GuardingNode guard;
<span class="line-new-header">--- 90,11 ---</span>
  import jdk.vm.ci.meta.SpeculationLog.Speculation;
  
  /**
   * Processes all {@link Lowerable} nodes to do their lowering.
   */
<span class="line-modified">! public class LoweringPhase extends BasePhase&lt;CoreProviders&gt; {</span>
  
      @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
      static final class DummyGuardHandle extends ValueNode implements GuardedNode {
          public static final NodeClass&lt;DummyGuardHandle&gt; TYPE = NodeClass.create(DummyGuardHandle.class);
          @Input(InputType.Guard) GuardingNode guard;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,27 ***</span>
          return false;
      }
  
      final class LoweringToolImpl implements LoweringTool {
  
<span class="line-modified">!         private final PhaseContext context;</span>
          private final NodeBitMap activeGuards;
          private AnchoringNode guardAnchor;
          private FixedWithNextNode lastFixedNode;
  
<span class="line-modified">!         LoweringToolImpl(PhaseContext context, AnchoringNode guardAnchor, NodeBitMap activeGuards, FixedWithNextNode lastFixedNode) {</span>
              this.context = context;
              this.guardAnchor = guardAnchor;
              this.activeGuards = activeGuards;
              this.lastFixedNode = lastFixedNode;
          }
  
          @Override
          public LoweringStage getLoweringStage() {
              return loweringStage;
          }
  
          @Override
          public ConstantReflectionProvider getConstantReflection() {
              return context.getConstantReflection();
          }
  
<span class="line-new-header">--- 126,34 ---</span>
          return false;
      }
  
      final class LoweringToolImpl implements LoweringTool {
  
<span class="line-modified">!         private final CoreProviders context;</span>
          private final NodeBitMap activeGuards;
          private AnchoringNode guardAnchor;
          private FixedWithNextNode lastFixedNode;
<span class="line-added">+         private NodeMap&lt;Block&gt; nodeMap;</span>
  
<span class="line-modified">!         LoweringToolImpl(CoreProviders context, AnchoringNode guardAnchor, NodeBitMap activeGuards, FixedWithNextNode lastFixedNode, NodeMap&lt;Block&gt; nodeMap) {</span>
              this.context = context;
              this.guardAnchor = guardAnchor;
              this.activeGuards = activeGuards;
              this.lastFixedNode = lastFixedNode;
<span class="line-added">+             this.nodeMap = nodeMap;</span>
          }
  
          @Override
          public LoweringStage getLoweringStage() {
              return loweringStage;
          }
  
<span class="line-added">+         @Override</span>
<span class="line-added">+         public CoreProviders getProviders() {</span>
<span class="line-added">+             return context;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          @Override
          public ConstantReflectionProvider getConstantReflection() {
              return context.getConstantReflection();
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,10 ***</span>
<span class="line-new-header">--- 175,14 ---</span>
          @Override
          public Replacements getReplacements() {
              return context.getReplacements();
          }
  
<span class="line-added">+         public ForeignCallsProvider getForeignCalls() {</span>
<span class="line-added">+             return context.getForeignCalls();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          @Override
          public AnchoringNode getCurrentGuardAnchor() {
              return guardAnchor;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,11 ***</span>
          public GuardingNode createGuard(FixedNode before, LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, Speculation speculation, boolean negated,
                          NodeSourcePosition noDeoptSucccessorPosition) {
              StructuredGraph graph = before.graph();
              if (OptEliminateGuards.getValue(graph.getOptions())) {
                  for (Node usage : condition.usages()) {
<span class="line-modified">!                     if (!activeGuards.isNew(usage) &amp;&amp; activeGuards.isMarked(usage) &amp;&amp; ((GuardNode) usage).isNegated() == negated) {</span>
                          return (GuardNode) usage;
                      }
                  }
              }
              if (!condition.graph().getGuardsStage().allowsFloatingGuards()) {
<span class="line-new-header">--- 200,12 ---</span>
          public GuardingNode createGuard(FixedNode before, LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, Speculation speculation, boolean negated,
                          NodeSourcePosition noDeoptSucccessorPosition) {
              StructuredGraph graph = before.graph();
              if (OptEliminateGuards.getValue(graph.getOptions())) {
                  for (Node usage : condition.usages()) {
<span class="line-modified">!                     if (!activeGuards.isNew(usage) &amp;&amp; activeGuards.isMarked(usage) &amp;&amp; ((GuardNode) usage).isNegated() == negated &amp;&amp;</span>
<span class="line-added">+                                     (!before.graph().hasValueProxies() || nodeMap.get(((GuardNode) usage).getAnchor().asNode()).isInSameOrOuterLoopOf(nodeMap.get(before)))) {</span>
                          return (GuardNode) usage;
                      }
                  }
              }
              if (!condition.graph().getGuardsStage().allowsFloatingGuards()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 239,26 ***</span>
       * Checks that second lowering of a given graph did not introduce any new nodes.
       *
       * @param graph a graph that was just {@linkplain #lower lowered}
       * @throws AssertionError if the check fails
       */
<span class="line-modified">!     private boolean checkPostLowering(StructuredGraph graph, PhaseContext context) {</span>
          Mark expectedMark = graph.getMark();
          lower(graph, context, LoweringMode.VERIFY_LOWERING);
          Mark mark = graph.getMark();
          assert mark.equals(expectedMark) : graph + &quot;: a second round in the current lowering phase introduced these new nodes: &quot; + graph.getNewNodes(expectedMark).snapshot();
          return true;
      }
  
      @Override
<span class="line-modified">!     protected void run(final StructuredGraph graph, PhaseContext context) {</span>
          lower(graph, context, LoweringMode.LOWERING);
          assert checkPostLowering(graph, context);
      }
  
<span class="line-modified">!     private void lower(StructuredGraph graph, PhaseContext context, LoweringMode mode) {</span>
<span class="line-modified">!         IncrementalCanonicalizerPhase&lt;PhaseContext&gt; incrementalCanonicalizer = new IncrementalCanonicalizerPhase&lt;&gt;(canonicalizer);</span>
          incrementalCanonicalizer.appendPhase(new Round(context, mode, graph.getOptions()));
          incrementalCanonicalizer.apply(graph, context);
          assert graph.verify();
      }
  
<span class="line-new-header">--- 253,26 ---</span>
       * Checks that second lowering of a given graph did not introduce any new nodes.
       *
       * @param graph a graph that was just {@linkplain #lower lowered}
       * @throws AssertionError if the check fails
       */
<span class="line-modified">!     private boolean checkPostLowering(StructuredGraph graph, CoreProviders context) {</span>
          Mark expectedMark = graph.getMark();
          lower(graph, context, LoweringMode.VERIFY_LOWERING);
          Mark mark = graph.getMark();
          assert mark.equals(expectedMark) : graph + &quot;: a second round in the current lowering phase introduced these new nodes: &quot; + graph.getNewNodes(expectedMark).snapshot();
          return true;
      }
  
      @Override
<span class="line-modified">!     protected void run(final StructuredGraph graph, CoreProviders context) {</span>
          lower(graph, context, LoweringMode.LOWERING);
          assert checkPostLowering(graph, context);
      }
  
<span class="line-modified">!     private void lower(StructuredGraph graph, CoreProviders context, LoweringMode mode) {</span>
<span class="line-modified">!         IncrementalCanonicalizerPhase&lt;CoreProviders&gt; incrementalCanonicalizer = new IncrementalCanonicalizerPhase&lt;&gt;(canonicalizer);</span>
          incrementalCanonicalizer.appendPhase(new Round(context, mode, graph.getOptions()));
          incrementalCanonicalizer.apply(graph, context);
          assert graph.verify();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 298,13 ***</span>
                   * checkpoint. This is only OK if the locations involved don&#39;t affect the memory
                   * graph or if the new kill location doesn&#39;t connect into the existing graph.
                   */
                  boolean isAny = false;
                  if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified">!                     isAny = ((MemoryCheckpoint.Single) n).getLocationIdentity().isAny();</span>
                  } else {
<span class="line-modified">!                     for (LocationIdentity ident : ((MemoryCheckpoint.Multi) n).getLocationIdentities()) {</span>
                          if (ident.isAny()) {
                              isAny = true;
                          }
                      }
                  }
<span class="line-new-header">--- 312,13 ---</span>
                   * checkpoint. This is only OK if the locations involved don&#39;t affect the memory
                   * graph or if the new kill location doesn&#39;t connect into the existing graph.
                   */
                  boolean isAny = false;
                  if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified">!                     isAny = ((MemoryCheckpoint.Single) n).getKilledLocationIdentity().isAny();</span>
                  } else {
<span class="line-modified">!                     for (LocationIdentity ident : ((MemoryCheckpoint.Multi) n).getKilledLocationIdentities()) {</span>
                          if (ident.isAny()) {
                              isAny = true;
                          }
                      }
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,16 ***</span>
          VERIFY_LOWERING
      }
  
      private final class Round extends Phase {
  
<span class="line-modified">!         private final PhaseContext context;</span>
          private final LoweringMode mode;
          private ScheduleResult schedule;
          private final SchedulePhase schedulePhase;
  
<span class="line-modified">!         private Round(PhaseContext context, LoweringMode mode, OptionValues options) {</span>
              this.context = context;
              this.mode = mode;
  
              /*
               * In VERIFY_LOWERING, we want to verify whether the lowering itself changes the graph.
<span class="line-new-header">--- 352,16 ---</span>
          VERIFY_LOWERING
      }
  
      private final class Round extends Phase {
  
<span class="line-modified">!         private final CoreProviders context;</span>
          private final LoweringMode mode;
          private ScheduleResult schedule;
          private final SchedulePhase schedulePhase;
  
<span class="line-modified">!         private Round(CoreProviders context, LoweringMode mode, OptionValues options) {</span>
              this.context = context;
              this.mode = mode;
  
              /*
               * In VERIFY_LOWERING, we want to verify whether the lowering itself changes the graph.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 435,11 ***</span>
          }
  
          @SuppressWarnings(&quot;try&quot;)
          private AnchoringNode process(final Block b, final NodeBitMap activeGuards, final AnchoringNode startAnchor) {
  
<span class="line-modified">!             final LoweringToolImpl loweringTool = new LoweringToolImpl(context, startAnchor, activeGuards, b.getBeginNode());</span>
  
              // Lower the instructions of this block.
              List&lt;Node&gt; nodes = schedule.nodesFor(b);
              for (Node node : nodes) {
  
<span class="line-new-header">--- 449,11 ---</span>
          }
  
          @SuppressWarnings(&quot;try&quot;)
          private AnchoringNode process(final Block b, final NodeBitMap activeGuards, final AnchoringNode startAnchor) {
  
<span class="line-modified">!             final LoweringToolImpl loweringTool = new LoweringToolImpl(context, startAnchor, activeGuards, b.getBeginNode(), this.schedule.getNodeToBlockMap());</span>
  
              // Lower the instructions of this block.
              List&lt;Node&gt; nodes = schedule.nodesFor(b);
              for (Node node : nodes) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 588,73 ***</span>
                          f = f.enter(n);
                          assert f.block.getDominator() == f.parent.block;
                          nextState = ST_PROCESS;
                      }
                  } else {
<span class="line-removed">-                     nextState = ST_LEAVE;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } else if (state == ST_LEAVE) {</span>
<span class="line-removed">-                 f.postprocess();</span>
<span class="line-removed">-                 f = f.parent;</span>
<span class="line-removed">-                 nextState = ST_ENTER;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 throw GraalError.shouldNotReachHere();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             state = nextState;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     public static void processBlockBounded(final Frame&lt;?&gt; rootFrame) {</span>
<span class="line-removed">-         ProcessBlockState state = ST_PROCESS;</span>
<span class="line-removed">-         Frame&lt;?&gt; f = rootFrame;</span>
<span class="line-removed">-         while (f != null) {</span>
<span class="line-removed">-             ProcessBlockState nextState;</span>
<span class="line-removed">-             if (state == ST_PROCESS || state == ST_PROCESS_ALWAYS_REACHED) {</span>
<span class="line-removed">-                 f.preprocess();</span>
<span class="line-removed">-                 nextState = state == ST_PROCESS_ALWAYS_REACHED ? ST_ENTER : ST_ENTER_ALWAYS_REACHED;</span>
<span class="line-removed">-             } else if (state == ST_ENTER_ALWAYS_REACHED) {</span>
<span class="line-removed">-                 if (f.alwaysReachedBlock != null &amp;&amp; f.alwaysReachedBlock.getDominator() == f.block) {</span>
<span class="line-removed">-                     Frame&lt;?&gt; continueRecur = f.enterAlwaysReached(f.alwaysReachedBlock);</span>
<span class="line-removed">-                     if (continueRecur == null) {</span>
<span class="line-removed">-                         // stop recursion here</span>
<span class="line-removed">-                         f.postprocess();</span>
<span class="line-removed">-                         f = f.parent;</span>
<span class="line-removed">-                         state = ST_ENTER;</span>
<span class="line-removed">-                         continue;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     f = continueRecur;</span>
<span class="line-removed">-                     nextState = ST_PROCESS;</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     nextState = ST_ENTER;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } else if (state == ST_ENTER) {</span>
<span class="line-removed">-                 if (f.dominated != null) {</span>
<span class="line-removed">-                     Block n = f.dominated;</span>
<span class="line-removed">-                     f.dominated = n.getDominatedSibling();</span>
<span class="line-removed">-                     if (n == f.alwaysReachedBlock) {</span>
<span class="line-removed">-                         if (f.dominated != null) {</span>
<span class="line-removed">-                             n = f.dominated;</span>
<span class="line-removed">-                             f.dominated = n.getDominatedSibling();</span>
<span class="line-removed">-                         } else {</span>
<span class="line-removed">-                             n = null;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     if (n == null) {</span>
<span class="line-removed">-                         nextState = ST_LEAVE;</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         Frame&lt;?&gt; continueRecur = f.enter(n);</span>
<span class="line-removed">-                         if (continueRecur == null) {</span>
<span class="line-removed">-                             // stop recursion here</span>
<span class="line-removed">-                             f.postprocess();</span>
<span class="line-removed">-                             f = f.parent;</span>
<span class="line-removed">-                             state = ST_ENTER;</span>
<span class="line-removed">-                             continue;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         f = continueRecur;</span>
<span class="line-removed">-                         nextState = ST_PROCESS;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 } else {</span>
                      nextState = ST_LEAVE;
                  }
              } else if (state == ST_LEAVE) {
                  f.postprocess();
                  f = f.parent;
<span class="line-new-header">--- 602,10 ---</span>
</pre>
<center><a href="IterativeConditionalEliminationPhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeCounterPhase.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
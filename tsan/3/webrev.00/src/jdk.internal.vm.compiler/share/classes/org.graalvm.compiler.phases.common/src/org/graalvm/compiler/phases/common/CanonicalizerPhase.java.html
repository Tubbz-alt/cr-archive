<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/CanonicalizerPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.phases.common;
 26 
 27 import static org.graalvm.compiler.phases.common.CanonicalizerPhase.CanonicalizerFeature.CFG_SIMPLIFICATION;
 28 import static org.graalvm.compiler.phases.common.CanonicalizerPhase.CanonicalizerFeature.GVN;
 29 import static org.graalvm.compiler.phases.common.CanonicalizerPhase.CanonicalizerFeature.READ_CANONICALIZATION;
 30 
 31 import java.util.EnumSet;
 32 
 33 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 34 import org.graalvm.compiler.core.common.type.Stamp;
 35 import org.graalvm.compiler.debug.CounterKey;
 36 import org.graalvm.compiler.debug.DebugCloseable;
 37 import org.graalvm.compiler.debug.DebugContext;
 38 import org.graalvm.compiler.graph.GraalGraphError;
 39 import org.graalvm.compiler.graph.Graph;
 40 import org.graalvm.compiler.graph.Graph.Mark;
 41 import org.graalvm.compiler.graph.Graph.NodeEventListener;
 42 import org.graalvm.compiler.graph.Graph.NodeEventScope;
 43 import org.graalvm.compiler.graph.Node;
 44 import org.graalvm.compiler.graph.Node.IndirectCanonicalization;
 45 import org.graalvm.compiler.graph.NodeClass;
 46 import org.graalvm.compiler.graph.NodeWorkList;
 47 import org.graalvm.compiler.graph.spi.Canonicalizable;
 48 import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;
 49 import org.graalvm.compiler.graph.spi.SimplifierTool;
 50 import org.graalvm.compiler.nodeinfo.InputType;
 51 import org.graalvm.compiler.nodes.AbstractBeginNode;
 52 import org.graalvm.compiler.nodes.AbstractMergeNode;
 53 import org.graalvm.compiler.nodes.ConstantNode;
 54 import org.graalvm.compiler.nodes.ControlSinkNode;
 55 import org.graalvm.compiler.nodes.FixedNode;
 56 import org.graalvm.compiler.nodes.FixedWithNextNode;
 57 import org.graalvm.compiler.nodes.NodeView;
 58 import org.graalvm.compiler.nodes.StartNode;
 59 import org.graalvm.compiler.nodes.StructuredGraph;
 60 import org.graalvm.compiler.nodes.ValueNode;
 61 import org.graalvm.compiler.nodes.calc.FloatingNode;
 62 import org.graalvm.compiler.nodes.spi.CoreProviders;
 63 import org.graalvm.compiler.nodes.util.GraphUtil;
 64 import org.graalvm.compiler.options.OptionValues;
 65 import org.graalvm.compiler.phases.BasePhase;
 66 import org.graalvm.compiler.phases.Phase;
 67 
 68 import jdk.vm.ci.meta.Assumptions;
 69 import jdk.vm.ci.meta.Constant;
 70 import jdk.vm.ci.meta.ConstantReflectionProvider;
 71 import jdk.vm.ci.meta.MetaAccessProvider;
 72 
 73 public class CanonicalizerPhase extends BasePhase&lt;CoreProviders&gt; {
 74 
 75     public enum CanonicalizerFeature {
 76         READ_CANONICALIZATION,
 77         CFG_SIMPLIFICATION,
 78         GVN
 79     }
 80 
 81     private static final int MAX_ITERATION_PER_NODE = 10;
 82     private static final CounterKey COUNTER_CANONICALIZED_NODES = DebugContext.counter(&quot;CanonicalizedNodes&quot;);
 83     private static final CounterKey COUNTER_PROCESSED_NODES = DebugContext.counter(&quot;ProcessedNodes&quot;);
 84     private static final CounterKey COUNTER_CANONICALIZATION_CONSIDERED_NODES = DebugContext.counter(&quot;CanonicalizationConsideredNodes&quot;);
 85     private static final CounterKey COUNTER_INFER_STAMP_CALLED = DebugContext.counter(&quot;InferStampCalled&quot;);
 86     private static final CounterKey COUNTER_STAMP_CHANGED = DebugContext.counter(&quot;StampChanged&quot;);
 87     private static final CounterKey COUNTER_SIMPLIFICATION_CONSIDERED_NODES = DebugContext.counter(&quot;SimplificationConsideredNodes&quot;);
 88     private static final CounterKey COUNTER_GLOBAL_VALUE_NUMBERING_HITS = DebugContext.counter(&quot;GlobalValueNumberingHits&quot;);
 89 
 90     private final EnumSet&lt;CanonicalizerFeature&gt; features;
 91     private final CustomCanonicalization customCanonicalization;
 92     private final CustomSimplification customSimplification;
 93 
 94     public interface CustomCanonicalization {
 95         /**
 96          * @param node the node to be canonicalized
 97          * @return the same node if no action should be taken, {@code null} if the node should be
 98          *         deleted, or a new node that should replace the given node
 99          */
100         Node canonicalize(Node node);
101     }
102 
103     public interface CustomSimplification {
104         /**
105          * @param node the node to be simplified
106          * @param tool utility available during the simplification process
107          */
108         void simplify(Node node, SimplifierTool tool);
109     }
110 
111     protected CanonicalizerPhase(EnumSet&lt;CanonicalizerFeature&gt; features) {
112         this(null, null, features);
113     }
114 
115     protected CanonicalizerPhase() {
116         this(null, null, EnumSet.allOf(CanonicalizerFeature.class));
117     }
118 
119     protected CanonicalizerPhase(CustomCanonicalization customCanonicalization, CustomSimplification customSimplification) {
120         this(customCanonicalization, customSimplification, EnumSet.allOf(CanonicalizerFeature.class));
121     }
122 
123     protected CanonicalizerPhase(CustomCanonicalization customCanonicalization, CustomSimplification customSimplification, EnumSet&lt;CanonicalizerFeature&gt; features) {
124         this.customCanonicalization = customCanonicalization;
125         this.customSimplification = customSimplification;
126         this.features = features;
127     }
128 
129     public CanonicalizerPhase copyWithCustomCanonicalization(CustomCanonicalization newCanonicalization) {
130         return new CanonicalizerPhase(newCanonicalization, customSimplification, features);
131     }
132 
133     public CanonicalizerPhase copyWithCustomSimplification(CustomSimplification newSimplification) {
134         return new CanonicalizerPhase(customCanonicalization, newSimplification, features);
135     }
136 
137     public CanonicalizerPhase copyWithoutGVN() {
138         EnumSet&lt;CanonicalizerFeature&gt; newFeatures = EnumSet.copyOf(features);
139         newFeatures.remove(GVN);
140         return new CanonicalizerPhase(customCanonicalization, customSimplification, newFeatures);
141     }
142 
143     public CanonicalizerPhase copyWithoutSimplification() {
144         EnumSet&lt;CanonicalizerFeature&gt; newFeatures = EnumSet.copyOf(features);
145         newFeatures.remove(CFG_SIMPLIFICATION);
146         return new CanonicalizerPhase(customCanonicalization, customSimplification, newFeatures);
147     }
148 
149     public static CanonicalizerPhase create() {
150         return new CanonicalizerPhase(null, null, EnumSet.allOf(CanonicalizerFeature.class));
151     }
152 
153     public static CanonicalizerPhase createWithoutReadCanonicalization() {
154         return new CanonicalizerPhase(EnumSet.complementOf(EnumSet.of(READ_CANONICALIZATION)));
155     }
156 
157     public static CanonicalizerPhase createWithoutGVN() {
158         return new CanonicalizerPhase(EnumSet.complementOf(EnumSet.of(GVN)));
159     }
160 
161     public static CanonicalizerPhase createWithoutCFGSimplification() {
162         return new CanonicalizerPhase(EnumSet.complementOf(EnumSet.of(CFG_SIMPLIFICATION)));
163     }
164 
165     @Override
166     public boolean checkContract() {
167         /*
168          * There are certain canonicalizations we make that heavily increase code size by e.g.
169          * replacing a merge followed by a return of the merge&#39;s phi with returns in each
170          * predecessor.
171          */
172         return false;
173     }
174 
175     @Override
176     protected void run(StructuredGraph graph, CoreProviders context) {
177         new Instance(context).run(graph);
178     }
179 
180     /**
181      * @param newNodesMark only the {@linkplain Graph#getNewNodes(Mark) new nodes} specified by this
182      *            mark are processed
183      */
184     public void applyIncremental(StructuredGraph graph, CoreProviders context, Mark newNodesMark) {
185         applyIncremental(graph, context, newNodesMark, true);
186     }
187 
188     public void applyIncremental(StructuredGraph graph, CoreProviders context, Mark newNodesMark, boolean dumpGraph) {
189         new Instance(context, newNodesMark).apply(graph, dumpGraph);
190     }
191 
192     /**
193      * @param workingSet the initial working set of nodes on which the canonicalizer works, should
194      *            be an auto-grow node bitmap
195      */
196     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet) {
197         applyIncremental(graph, context, workingSet, true);
198     }
199 
200     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, boolean dumpGraph) {
201         new Instance(context, workingSet).apply(graph, dumpGraph);
202     }
203 
204     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark) {
205         applyIncremental(graph, context, workingSet, newNodesMark, true);
206     }
207 
208     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark, boolean dumpGraph) {
209         new Instance(context, workingSet, newNodesMark).apply(graph, dumpGraph);
210     }
211 
212     public NodeView getNodeView() {
213         return NodeView.DEFAULT;
214     }
215 
216     private final class Instance extends Phase {
217 
218         private final Mark newNodesMark;
219         private final CoreProviders context;
220         private final Iterable&lt;? extends Node&gt; initWorkingSet;
221 
222         private NodeWorkList workList;
223         private Tool tool;
224         private DebugContext debug;
225 
226         private Instance(CoreProviders context) {
227             this(context, null, null);
228         }
229 
230         private Instance(CoreProviders context, Iterable&lt;? extends Node&gt; workingSet) {
231             this(context, workingSet, null);
232         }
233 
234         private Instance(CoreProviders context, Mark newNodesMark) {
235             this(context, null, newNodesMark);
236         }
237 
238         private Instance(CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark) {
239             this.newNodesMark = newNodesMark;
240             this.context = context;
241             this.initWorkingSet = workingSet;
242         }
243 
244         @Override
245         public boolean checkContract() {
246             return false;
247         }
248 
249         @Override
250         protected void run(StructuredGraph graph) {
251             this.debug = graph.getDebug();
252             boolean wholeGraph = newNodesMark == null || newNodesMark.isStart();
253             if (initWorkingSet == null) {
254                 workList = graph.createIterativeNodeWorkList(wholeGraph, MAX_ITERATION_PER_NODE);
255             } else {
256                 workList = graph.createIterativeNodeWorkList(false, MAX_ITERATION_PER_NODE);
257                 workList.addAll(initWorkingSet);
258             }
259             if (!wholeGraph) {
260                 workList.addAll(graph.getNewNodes(newNodesMark));
261             }
262 
263             tool = new Tool(graph.getAssumptions(), graph.getOptions());
264             processWorkSet(graph);
265         }
266 
267         @SuppressWarnings(&quot;try&quot;)
268         private int processWorkSet(StructuredGraph graph) {
269             int sum = 0;
270             NodeEventListener listener = new NodeEventListener() {
271 
272                 @Override
273                 public void nodeAdded(Node node) {
274                     workList.add(node);
275                 }
276 
277                 @Override
278                 public void inputChanged(Node node) {
279                     workList.add(node);
280                     if (node instanceof IndirectCanonicalization) {
281                         for (Node usage : node.usages()) {
282                             workList.add(usage);
283                         }
284                     }
285 
286                     if (node instanceof AbstractBeginNode) {
287                         AbstractBeginNode abstractBeginNode = (AbstractBeginNode) node;
288                         if (abstractBeginNode.predecessor() != null) {
289                             workList.add(abstractBeginNode.predecessor());
290                         }
291                     }
292                 }
293 
294                 @Override
295                 public void usagesDroppedToZero(Node node) {
296                     workList.add(node);
297                 }
298             };
299 
300             try (NodeEventScope nes = graph.trackNodeEvents(listener)) {
301                 for (Node n : workList) {
302                     boolean changed = processNode(n);
303                     if (changed &amp;&amp; debug.isDumpEnabled(DebugContext.DETAILED_LEVEL)) {
304                         debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;CanonicalizerPhase %s&quot;, n);
305                     }
306                     ++sum;
307                 }
308             }
309             return sum;
310         }
311 
312         /**
313          * @return true if the graph was changed.
314          */
315         private boolean processNode(Node node) {
316             if (!node.isAlive()) {
317                 return false;
318             }
319             COUNTER_PROCESSED_NODES.increment(debug);
320             if (GraphUtil.tryKillUnused(node)) {
321                 return true;
322             }
323             NodeClass&lt;?&gt; nodeClass = node.getNodeClass();
324             StructuredGraph graph = (StructuredGraph) node.graph();
325             if (tryCanonicalize(node, nodeClass)) {
326                 return true;
327             }
328             if (features.contains(GVN) &amp;&amp; tryGlobalValueNumbering(node, nodeClass)) {
329                 return true;
330             }
331             if (node instanceof ValueNode) {
332                 ValueNode valueNode = (ValueNode) node;
333                 boolean improvedStamp = tryInferStamp(valueNode);
334                 Constant constant = valueNode.stamp(NodeView.DEFAULT).asConstant();
335                 if (constant != null &amp;&amp; !(node instanceof ConstantNode)) {
336                     ConstantNode stampConstant = ConstantNode.forConstant(valueNode.stamp(NodeView.DEFAULT), constant, context.getMetaAccess(), graph);
337                     debug.log(&quot;Canonicalizer: constant stamp replaces %1s with %1s&quot;, valueNode, stampConstant);
338                     valueNode.replaceAtUsages(InputType.Value, stampConstant);
339                     GraphUtil.tryKillUnused(valueNode);
340                     return true;
341                 } else if (improvedStamp) {
342                     // the improved stamp may enable additional canonicalization
343                     if (tryCanonicalize(valueNode, nodeClass)) {
344                         return true;
345                     }
346                     valueNode.usages().forEach(workList::add);
347                 }
348             }
349             return false;
350         }
351 
352         public boolean tryGlobalValueNumbering(Node node, NodeClass&lt;?&gt; nodeClass) {
353             if (nodeClass.valueNumberable()) {
354                 Node newNode = node.graph().findDuplicate(node);
355                 if (newNode != null) {
356                     assert !(node instanceof FixedNode || newNode instanceof FixedNode);
357                     node.replaceAtUsagesAndDelete(newNode);
358                     COUNTER_GLOBAL_VALUE_NUMBERING_HITS.increment(debug);
359                     debug.log(&quot;GVN applied and new node is %1s&quot;, newNode);
360                     return true;
361                 }
362             }
363             return false;
364         }
365 
366         private AutoCloseable getCanonicalizeableContractAssertion(Node node) {
367             boolean needsAssertion = false;
368             assert (needsAssertion = true) == true;
369             if (needsAssertion) {
370                 Mark mark = node.graph().getMark();
371                 return () -&gt; {
372                     assert mark.equals(node.graph().getMark()) : &quot;new node created while canonicalizing &quot; + node.getClass().getSimpleName() + &quot; &quot; + node + &quot;: &quot; +
373                                     node.graph().getNewNodes(mark).snapshot();
374                 };
375             } else {
376                 return null;
377             }
378         }
379 
380         @SuppressWarnings(&quot;try&quot;)
381         public boolean tryCanonicalize(final Node node, NodeClass&lt;?&gt; nodeClass) {
382             try (DebugCloseable position = node.withNodeSourcePosition(); DebugContext.Scope scope = debug.withContext(node)) {
383                 if (nodeClass.isCanonicalizable()) {
384                     COUNTER_CANONICALIZATION_CONSIDERED_NODES.increment(debug);
385                     Node canonical = node;
386                     try (AutoCloseable verify = getCanonicalizeableContractAssertion(node)) {
387                         if (customCanonicalization != null) {
388                             canonical = customCanonicalization.canonicalize(node);
389                         }
390                         if (canonical == node) {
391                             canonical = ((Canonicalizable) node).canonical(tool);
392                             if (canonical == node &amp;&amp; nodeClass.isCommutative()) {
393                                 canonical = ((BinaryCommutative&lt;?&gt;) node).maybeCommuteInputs();
394                             }
395                         }
396                     } catch (Throwable e) {
397                         throw new GraalGraphError(e).addContext(node);
398                     }
399                     if (performReplacement(node, canonical)) {
400                         return true;
401                     }
402                 }
403 
404                 if (features.contains(CFG_SIMPLIFICATION) &amp;&amp; nodeClass.isSimplifiable()) {
405                     debug.log(DebugContext.VERBOSE_LEVEL, &quot;Canonicalizer: simplifying %s&quot;, node);
406                     COUNTER_SIMPLIFICATION_CONSIDERED_NODES.increment(debug);
407                     if (customSimplification != null) {
408                         customSimplification.simplify(node, tool);
409                     }
410                     if (node.isAlive()) {
411                         node.simplify(tool);
412                         if (node.isDeleted()) {
413                             debug.log(&quot;Canonicalizer: simplified %s&quot;, node);
414                         }
415                     }
416                     return node.isDeleted();
417                 }
418                 return false;
419             } catch (Throwable throwable) {
420                 throw debug.handle(throwable);
421             }
422         }
423 
424 // @formatter:off
425 //     cases:                                           original node:
426 //                                         |Floating|Fixed-unconnected|Fixed-connected|
427 //                                         --------------------------------------------
428 //                                     null|   1    |        X        |       3       |
429 //                                         --------------------------------------------
430 //                                 Floating|   2    |        X        |       4       |
431 //       canonical node:                   --------------------------------------------
432 //                        Fixed-unconnected|   X    |        X        |       5       |
433 //                                         --------------------------------------------
434 //                          Fixed-connected|   2    |        X        |       6       |
435 //                                         --------------------------------------------
436 //                              ControlSink|   X    |        X        |       7       |
437 //                                         --------------------------------------------
438 //       X: must not happen (checked with assertions)
439 // @formatter:on
440         private boolean performReplacement(final Node node, Node newCanonical) {
441             if (newCanonical == node) {
442                 debug.log(DebugContext.VERBOSE_LEVEL, &quot;Canonicalizer: work on %1s&quot;, node);
443                 return false;
444             } else {
445                 Node canonical = newCanonical;
446                 debug.log(&quot;Canonicalizer: replacing %1s with %1s&quot;, node, canonical);
447                 COUNTER_CANONICALIZED_NODES.increment(debug);
448                 StructuredGraph graph = (StructuredGraph) node.graph();
449                 if (canonical != null &amp;&amp; !canonical.isAlive()) {
450                     assert !canonical.isDeleted();
451                     canonical = graph.addOrUniqueWithInputs(canonical);
452                 }
453                 if (node instanceof FloatingNode) {
454                     assert canonical == null || !(canonical instanceof FixedNode) ||
455                                     (canonical.predecessor() != null || canonical instanceof StartNode || canonical instanceof AbstractMergeNode) : node +
456                                                     &quot; -&gt; &quot; + canonical + &quot; : replacement should be floating or fixed and connected&quot;;
457                     node.replaceAtUsages(canonical);
458                     GraphUtil.killWithUnusedFloatingInputs(node, true);
459                 } else {
460                     assert node instanceof FixedNode &amp;&amp; node.predecessor() != null : node + &quot; -&gt; &quot; + canonical + &quot; : node should be fixed &amp; connected (&quot; + node.predecessor() + &quot;)&quot;;
461                     FixedNode fixed = (FixedNode) node;
462                     if (canonical instanceof ControlSinkNode) {
463                         // case 7
464                         fixed.replaceAtPredecessor(canonical);
465                         GraphUtil.killCFG(fixed);
466                         return true;
467                     } else {
468                         assert fixed instanceof FixedWithNextNode;
469                         FixedWithNextNode fixedWithNext = (FixedWithNextNode) fixed;
470                         // When removing a fixed node, new canonicalization
471                         // opportunities for its successor may arise
472                         assert fixedWithNext.next() != null;
473                         tool.addToWorkList(fixedWithNext.next());
474                         if (canonical == null) {
475                             // case 3
476                             node.replaceAtUsages(null);
477                             GraphUtil.removeFixedWithUnusedInputs(fixedWithNext);
478                         } else if (canonical instanceof FloatingNode) {
479                             // case 4
480                             graph.replaceFixedWithFloating(fixedWithNext, (FloatingNode) canonical);
481                         } else {
482                             assert canonical instanceof FixedNode;
483                             if (canonical.predecessor() == null) {
484                                 assert !canonical.cfgSuccessors().iterator().hasNext() : &quot;replacement &quot; + canonical + &quot; shouldn&#39;t have successors&quot;;
485                                 // case 5
486                                 graph.replaceFixedWithFixed(fixedWithNext, (FixedWithNextNode) canonical);
487                             } else {
488                                 assert canonical.cfgSuccessors().iterator().hasNext() : &quot;replacement &quot; + canonical + &quot; should have successors&quot;;
489                                 // case 6
490                                 node.replaceAtUsages(canonical);
491                                 GraphUtil.removeFixedWithUnusedInputs(fixedWithNext);
492                             }
493                         }
494                     }
495                 }
496                 return true;
497             }
498         }
499 
500         /**
501          * Calls {@link ValueNode#inferStamp()} on the node and, if it returns true (which means
502          * that the stamp has changed), re-queues the node&#39;s usages. If the stamp has changed then
503          * this method also checks if the stamp now describes a constant integer value, in which
504          * case the node is replaced with a constant.
505          */
506         private boolean tryInferStamp(ValueNode node) {
507             if (node.isAlive()) {
508                 COUNTER_INFER_STAMP_CALLED.increment(debug);
509                 if (node.inferStamp()) {
510                     COUNTER_STAMP_CHANGED.increment(debug);
511                     for (Node usage : node.usages()) {
512                         workList.add(usage);
513                     }
514                     return true;
515                 }
516             }
517             return false;
518         }
519 
520         private final class Tool implements SimplifierTool, NodeView {
521 
522             private final Assumptions assumptions;
523             private final OptionValues options;
524             private NodeView nodeView;
525 
526             Tool(Assumptions assumptions, OptionValues options) {
527                 this.assumptions = assumptions;
528                 this.options = options;
529                 this.nodeView = getNodeView();
530             }
531 
532             @Override
533             public void deleteBranch(Node branch) {
534                 FixedNode fixedBranch = (FixedNode) branch;
535                 fixedBranch.predecessor().replaceFirstSuccessor(fixedBranch, null);
536                 GraphUtil.killCFG(fixedBranch);
537             }
538 
539             @Override
540             public MetaAccessProvider getMetaAccess() {
541                 return context.getMetaAccess();
542             }
543 
544             @Override
545             public ConstantReflectionProvider getConstantReflection() {
546                 return context.getConstantReflection();
547             }
548 
549             @Override
550             public ConstantFieldProvider getConstantFieldProvider() {
551                 return context.getConstantFieldProvider();
552             }
553 
554             @Override
555             public void addToWorkList(Node node) {
556                 workList.add(node);
557             }
558 
559             @Override
560             public void addToWorkList(Iterable&lt;? extends Node&gt; nodes) {
561                 workList.addAll(nodes);
562             }
563 
564             @Override
565             public void removeIfUnused(Node node) {
566                 GraphUtil.tryKillUnused(node);
567             }
568 
569             @Override
570             public boolean canonicalizeReads() {
571                 return features.contains(READ_CANONICALIZATION);
572             }
573 
574             @Override
575             public boolean allUsagesAvailable() {
576                 return true;
577             }
578 
579             @Override
580             public Assumptions getAssumptions() {
581                 return assumptions;
582             }
583 
584             @Override
585             public Integer smallestCompareWidth() {
586                 return context.getLowerer().smallestCompareWidth();
587             }
588 
589             @Override
590             public OptionValues getOptions() {
591                 return options;
592             }
593 
594             @Override
595             public Stamp stamp(ValueNode node) {
596                 return nodeView.stamp(node);
597             }
598         }
599     }
600 
601     public boolean getCanonicalizeReads() {
602         return features.contains(READ_CANONICALIZATION);
603     }
604 
605 }
    </pre>
  </body>
</html>
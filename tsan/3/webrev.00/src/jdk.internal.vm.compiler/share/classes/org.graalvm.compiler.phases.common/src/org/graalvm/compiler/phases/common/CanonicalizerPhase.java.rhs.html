<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/CanonicalizerPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.phases.common;
 26 
<a name="2" id="anc2"></a><span class="line-added"> 27 import static org.graalvm.compiler.phases.common.CanonicalizerPhase.CanonicalizerFeature.CFG_SIMPLIFICATION;</span>
<span class="line-added"> 28 import static org.graalvm.compiler.phases.common.CanonicalizerPhase.CanonicalizerFeature.GVN;</span>
<span class="line-added"> 29 import static org.graalvm.compiler.phases.common.CanonicalizerPhase.CanonicalizerFeature.READ_CANONICALIZATION;</span>
<span class="line-added"> 30 </span>
<span class="line-added"> 31 import java.util.EnumSet;</span>
<span class="line-added"> 32 </span>
 33 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 34 import org.graalvm.compiler.core.common.type.Stamp;
 35 import org.graalvm.compiler.debug.CounterKey;
 36 import org.graalvm.compiler.debug.DebugCloseable;
 37 import org.graalvm.compiler.debug.DebugContext;
 38 import org.graalvm.compiler.graph.GraalGraphError;
 39 import org.graalvm.compiler.graph.Graph;
 40 import org.graalvm.compiler.graph.Graph.Mark;
 41 import org.graalvm.compiler.graph.Graph.NodeEventListener;
 42 import org.graalvm.compiler.graph.Graph.NodeEventScope;
 43 import org.graalvm.compiler.graph.Node;
 44 import org.graalvm.compiler.graph.Node.IndirectCanonicalization;
 45 import org.graalvm.compiler.graph.NodeClass;
 46 import org.graalvm.compiler.graph.NodeWorkList;
 47 import org.graalvm.compiler.graph.spi.Canonicalizable;
 48 import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;
 49 import org.graalvm.compiler.graph.spi.SimplifierTool;
 50 import org.graalvm.compiler.nodeinfo.InputType;
<a name="3" id="anc3"></a><span class="line-added"> 51 import org.graalvm.compiler.nodes.AbstractBeginNode;</span>
 52 import org.graalvm.compiler.nodes.AbstractMergeNode;
 53 import org.graalvm.compiler.nodes.ConstantNode;
 54 import org.graalvm.compiler.nodes.ControlSinkNode;
 55 import org.graalvm.compiler.nodes.FixedNode;
 56 import org.graalvm.compiler.nodes.FixedWithNextNode;
 57 import org.graalvm.compiler.nodes.NodeView;
 58 import org.graalvm.compiler.nodes.StartNode;
 59 import org.graalvm.compiler.nodes.StructuredGraph;
 60 import org.graalvm.compiler.nodes.ValueNode;
 61 import org.graalvm.compiler.nodes.calc.FloatingNode;
<a name="4" id="anc4"></a><span class="line-added"> 62 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 63 import org.graalvm.compiler.nodes.util.GraphUtil;
 64 import org.graalvm.compiler.options.OptionValues;
 65 import org.graalvm.compiler.phases.BasePhase;
 66 import org.graalvm.compiler.phases.Phase;
<a name="5" id="anc5"></a>
 67 
 68 import jdk.vm.ci.meta.Assumptions;
 69 import jdk.vm.ci.meta.Constant;
 70 import jdk.vm.ci.meta.ConstantReflectionProvider;
 71 import jdk.vm.ci.meta.MetaAccessProvider;
 72 
<a name="6" id="anc6"></a><span class="line-modified"> 73 public class CanonicalizerPhase extends BasePhase&lt;CoreProviders&gt; {</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75     public enum CanonicalizerFeature {</span>
<span class="line-added"> 76         READ_CANONICALIZATION,</span>
<span class="line-added"> 77         CFG_SIMPLIFICATION,</span>
<span class="line-added"> 78         GVN</span>
<span class="line-added"> 79     }</span>
 80 
 81     private static final int MAX_ITERATION_PER_NODE = 10;
 82     private static final CounterKey COUNTER_CANONICALIZED_NODES = DebugContext.counter(&quot;CanonicalizedNodes&quot;);
 83     private static final CounterKey COUNTER_PROCESSED_NODES = DebugContext.counter(&quot;ProcessedNodes&quot;);
 84     private static final CounterKey COUNTER_CANONICALIZATION_CONSIDERED_NODES = DebugContext.counter(&quot;CanonicalizationConsideredNodes&quot;);
 85     private static final CounterKey COUNTER_INFER_STAMP_CALLED = DebugContext.counter(&quot;InferStampCalled&quot;);
 86     private static final CounterKey COUNTER_STAMP_CHANGED = DebugContext.counter(&quot;StampChanged&quot;);
 87     private static final CounterKey COUNTER_SIMPLIFICATION_CONSIDERED_NODES = DebugContext.counter(&quot;SimplificationConsideredNodes&quot;);
 88     private static final CounterKey COUNTER_GLOBAL_VALUE_NUMBERING_HITS = DebugContext.counter(&quot;GlobalValueNumberingHits&quot;);
 89 
<a name="7" id="anc7"></a><span class="line-modified"> 90     private final EnumSet&lt;CanonicalizerFeature&gt; features;</span>
<span class="line-modified"> 91     private final CustomCanonicalization customCanonicalization;</span>
<span class="line-modified"> 92     private final CustomSimplification customSimplification;</span>

 93 
<a name="8" id="anc8"></a><span class="line-modified"> 94     public interface CustomCanonicalization {</span>
<span class="line-added"> 95         /**</span>
<span class="line-added"> 96          * @param node the node to be canonicalized</span>
<span class="line-added"> 97          * @return the same node if no action should be taken, {@code null} if the node should be</span>
<span class="line-added"> 98          *         deleted, or a new node that should replace the given node</span>
<span class="line-added"> 99          */</span>
<span class="line-added">100         Node canonicalize(Node node);</span>
<span class="line-added">101     }</span>
102 
<a name="9" id="anc9"></a><span class="line-modified">103     public interface CustomSimplification {</span>
<span class="line-modified">104         /**</span>
<span class="line-modified">105          * @param node the node to be simplified</span>
<span class="line-added">106          * @param tool utility available during the simplification process</span>
<span class="line-added">107          */</span>
<span class="line-added">108         void simplify(Node node, SimplifierTool tool);</span>
<span class="line-added">109     }</span>
110 
<a name="10" id="anc10"></a><span class="line-modified">111     protected CanonicalizerPhase(EnumSet&lt;CanonicalizerFeature&gt; features) {</span>
<span class="line-modified">112         this(null, null, features);</span>
<span class="line-modified">113     }</span>
<span class="line-added">114 </span>
<span class="line-added">115     protected CanonicalizerPhase() {</span>
<span class="line-added">116         this(null, null, EnumSet.allOf(CanonicalizerFeature.class));</span>
<span class="line-added">117     }</span>
<span class="line-added">118 </span>
<span class="line-added">119     protected CanonicalizerPhase(CustomCanonicalization customCanonicalization, CustomSimplification customSimplification) {</span>
<span class="line-added">120         this(customCanonicalization, customSimplification, EnumSet.allOf(CanonicalizerFeature.class));</span>
<span class="line-added">121     }</span>
<span class="line-added">122 </span>
<span class="line-added">123     protected CanonicalizerPhase(CustomCanonicalization customCanonicalization, CustomSimplification customSimplification, EnumSet&lt;CanonicalizerFeature&gt; features) {</span>
<span class="line-added">124         this.customCanonicalization = customCanonicalization;</span>
<span class="line-added">125         this.customSimplification = customSimplification;</span>
<span class="line-added">126         this.features = features;</span>
<span class="line-added">127     }</span>
<span class="line-added">128 </span>
<span class="line-added">129     public CanonicalizerPhase copyWithCustomCanonicalization(CustomCanonicalization newCanonicalization) {</span>
<span class="line-added">130         return new CanonicalizerPhase(newCanonicalization, customSimplification, features);</span>
131     }
132 
<a name="11" id="anc11"></a><span class="line-modified">133     public CanonicalizerPhase copyWithCustomSimplification(CustomSimplification newSimplification) {</span>
<span class="line-modified">134         return new CanonicalizerPhase(customCanonicalization, newSimplification, features);</span>
135     }
136 
<a name="12" id="anc12"></a><span class="line-modified">137     public CanonicalizerPhase copyWithoutGVN() {</span>
<span class="line-modified">138         EnumSet&lt;CanonicalizerFeature&gt; newFeatures = EnumSet.copyOf(features);</span>
<span class="line-added">139         newFeatures.remove(GVN);</span>
<span class="line-added">140         return new CanonicalizerPhase(customCanonicalization, customSimplification, newFeatures);</span>
141     }
142 
<a name="13" id="anc13"></a><span class="line-modified">143     public CanonicalizerPhase copyWithoutSimplification() {</span>
<span class="line-modified">144         EnumSet&lt;CanonicalizerFeature&gt; newFeatures = EnumSet.copyOf(features);</span>
<span class="line-added">145         newFeatures.remove(CFG_SIMPLIFICATION);</span>
<span class="line-added">146         return new CanonicalizerPhase(customCanonicalization, customSimplification, newFeatures);</span>
147     }
148 
<a name="14" id="anc14"></a><span class="line-modified">149     public static CanonicalizerPhase create() {</span>
<span class="line-modified">150         return new CanonicalizerPhase(null, null, EnumSet.allOf(CanonicalizerFeature.class));</span>
151     }
152 
<a name="15" id="anc15"></a><span class="line-modified">153     public static CanonicalizerPhase createWithoutReadCanonicalization() {</span>
<span class="line-modified">154         return new CanonicalizerPhase(EnumSet.complementOf(EnumSet.of(READ_CANONICALIZATION)));</span>
<span class="line-added">155     }</span>
<span class="line-added">156 </span>
<span class="line-added">157     public static CanonicalizerPhase createWithoutGVN() {</span>
<span class="line-added">158         return new CanonicalizerPhase(EnumSet.complementOf(EnumSet.of(GVN)));</span>
<span class="line-added">159     }</span>
<span class="line-added">160 </span>
<span class="line-added">161     public static CanonicalizerPhase createWithoutCFGSimplification() {</span>
<span class="line-added">162         return new CanonicalizerPhase(EnumSet.complementOf(EnumSet.of(CFG_SIMPLIFICATION)));</span>
163     }
164 
165     @Override
166     public boolean checkContract() {
167         /*
168          * There are certain canonicalizations we make that heavily increase code size by e.g.
169          * replacing a merge followed by a return of the merge&#39;s phi with returns in each
170          * predecessor.
171          */
172         return false;
173     }
174 
175     @Override
<a name="16" id="anc16"></a><span class="line-modified">176     protected void run(StructuredGraph graph, CoreProviders context) {</span>
177         new Instance(context).run(graph);
178     }
179 
180     /**
181      * @param newNodesMark only the {@linkplain Graph#getNewNodes(Mark) new nodes} specified by this
182      *            mark are processed
183      */
<a name="17" id="anc17"></a><span class="line-modified">184     public void applyIncremental(StructuredGraph graph, CoreProviders context, Mark newNodesMark) {</span>
185         applyIncremental(graph, context, newNodesMark, true);
186     }
187 
<a name="18" id="anc18"></a><span class="line-modified">188     public void applyIncremental(StructuredGraph graph, CoreProviders context, Mark newNodesMark, boolean dumpGraph) {</span>
189         new Instance(context, newNodesMark).apply(graph, dumpGraph);
190     }
191 
192     /**
193      * @param workingSet the initial working set of nodes on which the canonicalizer works, should
194      *            be an auto-grow node bitmap
195      */
<a name="19" id="anc19"></a><span class="line-modified">196     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet) {</span>
197         applyIncremental(graph, context, workingSet, true);
198     }
199 
<a name="20" id="anc20"></a><span class="line-modified">200     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, boolean dumpGraph) {</span>
201         new Instance(context, workingSet).apply(graph, dumpGraph);
202     }
203 
<a name="21" id="anc21"></a><span class="line-modified">204     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark) {</span>
205         applyIncremental(graph, context, workingSet, newNodesMark, true);
206     }
207 
<a name="22" id="anc22"></a><span class="line-modified">208     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark, boolean dumpGraph) {</span>
209         new Instance(context, workingSet, newNodesMark).apply(graph, dumpGraph);
210     }
211 
212     public NodeView getNodeView() {
213         return NodeView.DEFAULT;
214     }
215 
216     private final class Instance extends Phase {
217 
218         private final Mark newNodesMark;
<a name="23" id="anc23"></a><span class="line-modified">219         private final CoreProviders context;</span>
220         private final Iterable&lt;? extends Node&gt; initWorkingSet;
221 
222         private NodeWorkList workList;
223         private Tool tool;
224         private DebugContext debug;
225 
<a name="24" id="anc24"></a><span class="line-modified">226         private Instance(CoreProviders context) {</span>
227             this(context, null, null);
228         }
229 
<a name="25" id="anc25"></a><span class="line-modified">230         private Instance(CoreProviders context, Iterable&lt;? extends Node&gt; workingSet) {</span>
231             this(context, workingSet, null);
232         }
233 
<a name="26" id="anc26"></a><span class="line-modified">234         private Instance(CoreProviders context, Mark newNodesMark) {</span>
235             this(context, null, newNodesMark);
236         }
237 
<a name="27" id="anc27"></a><span class="line-modified">238         private Instance(CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark) {</span>
239             this.newNodesMark = newNodesMark;
240             this.context = context;
241             this.initWorkingSet = workingSet;
242         }
243 
244         @Override
245         public boolean checkContract() {
246             return false;
247         }
248 
249         @Override
250         protected void run(StructuredGraph graph) {
251             this.debug = graph.getDebug();
252             boolean wholeGraph = newNodesMark == null || newNodesMark.isStart();
253             if (initWorkingSet == null) {
254                 workList = graph.createIterativeNodeWorkList(wholeGraph, MAX_ITERATION_PER_NODE);
255             } else {
256                 workList = graph.createIterativeNodeWorkList(false, MAX_ITERATION_PER_NODE);
257                 workList.addAll(initWorkingSet);
258             }
259             if (!wholeGraph) {
260                 workList.addAll(graph.getNewNodes(newNodesMark));
261             }
<a name="28" id="anc28"></a><span class="line-added">262 </span>
263             tool = new Tool(graph.getAssumptions(), graph.getOptions());
264             processWorkSet(graph);
265         }
266 
267         @SuppressWarnings(&quot;try&quot;)
<a name="29" id="anc29"></a><span class="line-modified">268         private int processWorkSet(StructuredGraph graph) {</span>
<span class="line-added">269             int sum = 0;</span>
270             NodeEventListener listener = new NodeEventListener() {
271 
272                 @Override
273                 public void nodeAdded(Node node) {
274                     workList.add(node);
275                 }
276 
277                 @Override
278                 public void inputChanged(Node node) {
279                     workList.add(node);
280                     if (node instanceof IndirectCanonicalization) {
281                         for (Node usage : node.usages()) {
282                             workList.add(usage);
283                         }
284                     }
<a name="30" id="anc30"></a><span class="line-added">285 </span>
<span class="line-added">286                     if (node instanceof AbstractBeginNode) {</span>
<span class="line-added">287                         AbstractBeginNode abstractBeginNode = (AbstractBeginNode) node;</span>
<span class="line-added">288                         if (abstractBeginNode.predecessor() != null) {</span>
<span class="line-added">289                             workList.add(abstractBeginNode.predecessor());</span>
<span class="line-added">290                         }</span>
<span class="line-added">291                     }</span>
292                 }
293 
294                 @Override
295                 public void usagesDroppedToZero(Node node) {
296                     workList.add(node);
297                 }
298             };
299 
300             try (NodeEventScope nes = graph.trackNodeEvents(listener)) {
301                 for (Node n : workList) {
302                     boolean changed = processNode(n);
303                     if (changed &amp;&amp; debug.isDumpEnabled(DebugContext.DETAILED_LEVEL)) {
304                         debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;CanonicalizerPhase %s&quot;, n);
305                     }
<a name="31" id="anc31"></a><span class="line-added">306                     ++sum;</span>
307                 }
308             }
<a name="32" id="anc32"></a><span class="line-added">309             return sum;</span>
310         }
311 
312         /**
313          * @return true if the graph was changed.
314          */
315         private boolean processNode(Node node) {
316             if (!node.isAlive()) {
317                 return false;
318             }
319             COUNTER_PROCESSED_NODES.increment(debug);
320             if (GraphUtil.tryKillUnused(node)) {
321                 return true;
322             }
323             NodeClass&lt;?&gt; nodeClass = node.getNodeClass();
324             StructuredGraph graph = (StructuredGraph) node.graph();
325             if (tryCanonicalize(node, nodeClass)) {
326                 return true;
327             }
<a name="33" id="anc33"></a><span class="line-modified">328             if (features.contains(GVN) &amp;&amp; tryGlobalValueNumbering(node, nodeClass)) {</span>
329                 return true;
330             }
331             if (node instanceof ValueNode) {
332                 ValueNode valueNode = (ValueNode) node;
333                 boolean improvedStamp = tryInferStamp(valueNode);
334                 Constant constant = valueNode.stamp(NodeView.DEFAULT).asConstant();
335                 if (constant != null &amp;&amp; !(node instanceof ConstantNode)) {
336                     ConstantNode stampConstant = ConstantNode.forConstant(valueNode.stamp(NodeView.DEFAULT), constant, context.getMetaAccess(), graph);
337                     debug.log(&quot;Canonicalizer: constant stamp replaces %1s with %1s&quot;, valueNode, stampConstant);
338                     valueNode.replaceAtUsages(InputType.Value, stampConstant);
339                     GraphUtil.tryKillUnused(valueNode);
340                     return true;
341                 } else if (improvedStamp) {
342                     // the improved stamp may enable additional canonicalization
343                     if (tryCanonicalize(valueNode, nodeClass)) {
344                         return true;
345                     }
346                     valueNode.usages().forEach(workList::add);
347                 }
348             }
349             return false;
350         }
351 
352         public boolean tryGlobalValueNumbering(Node node, NodeClass&lt;?&gt; nodeClass) {
353             if (nodeClass.valueNumberable()) {
354                 Node newNode = node.graph().findDuplicate(node);
355                 if (newNode != null) {
356                     assert !(node instanceof FixedNode || newNode instanceof FixedNode);
357                     node.replaceAtUsagesAndDelete(newNode);
358                     COUNTER_GLOBAL_VALUE_NUMBERING_HITS.increment(debug);
359                     debug.log(&quot;GVN applied and new node is %1s&quot;, newNode);
360                     return true;
361                 }
362             }
363             return false;
364         }
365 
366         private AutoCloseable getCanonicalizeableContractAssertion(Node node) {
367             boolean needsAssertion = false;
368             assert (needsAssertion = true) == true;
369             if (needsAssertion) {
370                 Mark mark = node.graph().getMark();
371                 return () -&gt; {
372                     assert mark.equals(node.graph().getMark()) : &quot;new node created while canonicalizing &quot; + node.getClass().getSimpleName() + &quot; &quot; + node + &quot;: &quot; +
373                                     node.graph().getNewNodes(mark).snapshot();
374                 };
375             } else {
376                 return null;
377             }
378         }
379 
380         @SuppressWarnings(&quot;try&quot;)
381         public boolean tryCanonicalize(final Node node, NodeClass&lt;?&gt; nodeClass) {
382             try (DebugCloseable position = node.withNodeSourcePosition(); DebugContext.Scope scope = debug.withContext(node)) {
<a name="34" id="anc34"></a>










383                 if (nodeClass.isCanonicalizable()) {
384                     COUNTER_CANONICALIZATION_CONSIDERED_NODES.increment(debug);
<a name="35" id="anc35"></a><span class="line-modified">385                     Node canonical = node;</span>
386                     try (AutoCloseable verify = getCanonicalizeableContractAssertion(node)) {
<a name="36" id="anc36"></a><span class="line-modified">387                         if (customCanonicalization != null) {</span>
<span class="line-modified">388                             canonical = customCanonicalization.canonicalize(node);</span>
<span class="line-modified">389                         }</span>
<span class="line-added">390                         if (canonical == node) {</span>
<span class="line-added">391                             canonical = ((Canonicalizable) node).canonical(tool);</span>
<span class="line-added">392                             if (canonical == node &amp;&amp; nodeClass.isCommutative()) {</span>
<span class="line-added">393                                 canonical = ((BinaryCommutative&lt;?&gt;) node).maybeCommuteInputs();</span>
<span class="line-added">394                             }</span>
395                         }
396                     } catch (Throwable e) {
397                         throw new GraalGraphError(e).addContext(node);
398                     }
399                     if (performReplacement(node, canonical)) {
400                         return true;
401                     }
402                 }
403 
<a name="37" id="anc37"></a><span class="line-modified">404                 if (features.contains(CFG_SIMPLIFICATION) &amp;&amp; nodeClass.isSimplifiable()) {</span>
405                     debug.log(DebugContext.VERBOSE_LEVEL, &quot;Canonicalizer: simplifying %s&quot;, node);
406                     COUNTER_SIMPLIFICATION_CONSIDERED_NODES.increment(debug);
<a name="38" id="anc38"></a><span class="line-modified">407                     if (customSimplification != null) {</span>
<span class="line-modified">408                         customSimplification.simplify(node, tool);</span>
<span class="line-modified">409                     }</span>
<span class="line-added">410                     if (node.isAlive()) {</span>
<span class="line-added">411                         node.simplify(tool);</span>
<span class="line-added">412                         if (node.isDeleted()) {</span>
<span class="line-added">413                             debug.log(&quot;Canonicalizer: simplified %s&quot;, node);</span>
<span class="line-added">414                         }</span>
415                     }
416                     return node.isDeleted();
417                 }
418                 return false;
419             } catch (Throwable throwable) {
420                 throw debug.handle(throwable);
421             }
422         }
423 
424 // @formatter:off
425 //     cases:                                           original node:
426 //                                         |Floating|Fixed-unconnected|Fixed-connected|
427 //                                         --------------------------------------------
428 //                                     null|   1    |        X        |       3       |
429 //                                         --------------------------------------------
430 //                                 Floating|   2    |        X        |       4       |
431 //       canonical node:                   --------------------------------------------
432 //                        Fixed-unconnected|   X    |        X        |       5       |
433 //                                         --------------------------------------------
434 //                          Fixed-connected|   2    |        X        |       6       |
435 //                                         --------------------------------------------
436 //                              ControlSink|   X    |        X        |       7       |
437 //                                         --------------------------------------------
438 //       X: must not happen (checked with assertions)
439 // @formatter:on
440         private boolean performReplacement(final Node node, Node newCanonical) {
441             if (newCanonical == node) {
442                 debug.log(DebugContext.VERBOSE_LEVEL, &quot;Canonicalizer: work on %1s&quot;, node);
443                 return false;
444             } else {
445                 Node canonical = newCanonical;
446                 debug.log(&quot;Canonicalizer: replacing %1s with %1s&quot;, node, canonical);
447                 COUNTER_CANONICALIZED_NODES.increment(debug);
448                 StructuredGraph graph = (StructuredGraph) node.graph();
449                 if (canonical != null &amp;&amp; !canonical.isAlive()) {
450                     assert !canonical.isDeleted();
451                     canonical = graph.addOrUniqueWithInputs(canonical);
452                 }
453                 if (node instanceof FloatingNode) {
454                     assert canonical == null || !(canonical instanceof FixedNode) ||
455                                     (canonical.predecessor() != null || canonical instanceof StartNode || canonical instanceof AbstractMergeNode) : node +
456                                                     &quot; -&gt; &quot; + canonical + &quot; : replacement should be floating or fixed and connected&quot;;
457                     node.replaceAtUsages(canonical);
458                     GraphUtil.killWithUnusedFloatingInputs(node, true);
459                 } else {
460                     assert node instanceof FixedNode &amp;&amp; node.predecessor() != null : node + &quot; -&gt; &quot; + canonical + &quot; : node should be fixed &amp; connected (&quot; + node.predecessor() + &quot;)&quot;;
461                     FixedNode fixed = (FixedNode) node;
462                     if (canonical instanceof ControlSinkNode) {
463                         // case 7
464                         fixed.replaceAtPredecessor(canonical);
465                         GraphUtil.killCFG(fixed);
466                         return true;
467                     } else {
468                         assert fixed instanceof FixedWithNextNode;
469                         FixedWithNextNode fixedWithNext = (FixedWithNextNode) fixed;
470                         // When removing a fixed node, new canonicalization
471                         // opportunities for its successor may arise
472                         assert fixedWithNext.next() != null;
473                         tool.addToWorkList(fixedWithNext.next());
474                         if (canonical == null) {
475                             // case 3
476                             node.replaceAtUsages(null);
477                             GraphUtil.removeFixedWithUnusedInputs(fixedWithNext);
478                         } else if (canonical instanceof FloatingNode) {
479                             // case 4
480                             graph.replaceFixedWithFloating(fixedWithNext, (FloatingNode) canonical);
481                         } else {
482                             assert canonical instanceof FixedNode;
483                             if (canonical.predecessor() == null) {
484                                 assert !canonical.cfgSuccessors().iterator().hasNext() : &quot;replacement &quot; + canonical + &quot; shouldn&#39;t have successors&quot;;
485                                 // case 5
486                                 graph.replaceFixedWithFixed(fixedWithNext, (FixedWithNextNode) canonical);
487                             } else {
488                                 assert canonical.cfgSuccessors().iterator().hasNext() : &quot;replacement &quot; + canonical + &quot; should have successors&quot;;
489                                 // case 6
490                                 node.replaceAtUsages(canonical);
491                                 GraphUtil.removeFixedWithUnusedInputs(fixedWithNext);
492                             }
493                         }
494                     }
495                 }
496                 return true;
497             }
498         }
499 
500         /**
501          * Calls {@link ValueNode#inferStamp()} on the node and, if it returns true (which means
502          * that the stamp has changed), re-queues the node&#39;s usages. If the stamp has changed then
503          * this method also checks if the stamp now describes a constant integer value, in which
504          * case the node is replaced with a constant.
505          */
506         private boolean tryInferStamp(ValueNode node) {
507             if (node.isAlive()) {
508                 COUNTER_INFER_STAMP_CALLED.increment(debug);
509                 if (node.inferStamp()) {
510                     COUNTER_STAMP_CHANGED.increment(debug);
511                     for (Node usage : node.usages()) {
512                         workList.add(usage);
513                     }
514                     return true;
515                 }
516             }
517             return false;
518         }
519 
520         private final class Tool implements SimplifierTool, NodeView {
521 
522             private final Assumptions assumptions;
523             private final OptionValues options;
524             private NodeView nodeView;
525 
526             Tool(Assumptions assumptions, OptionValues options) {
527                 this.assumptions = assumptions;
528                 this.options = options;
529                 this.nodeView = getNodeView();
530             }
531 
532             @Override
533             public void deleteBranch(Node branch) {
534                 FixedNode fixedBranch = (FixedNode) branch;
535                 fixedBranch.predecessor().replaceFirstSuccessor(fixedBranch, null);
536                 GraphUtil.killCFG(fixedBranch);
537             }
538 
539             @Override
540             public MetaAccessProvider getMetaAccess() {
541                 return context.getMetaAccess();
542             }
543 
544             @Override
545             public ConstantReflectionProvider getConstantReflection() {
546                 return context.getConstantReflection();
547             }
548 
549             @Override
550             public ConstantFieldProvider getConstantFieldProvider() {
551                 return context.getConstantFieldProvider();
552             }
553 
554             @Override
555             public void addToWorkList(Node node) {
556                 workList.add(node);
557             }
558 
559             @Override
560             public void addToWorkList(Iterable&lt;? extends Node&gt; nodes) {
561                 workList.addAll(nodes);
562             }
563 
564             @Override
565             public void removeIfUnused(Node node) {
566                 GraphUtil.tryKillUnused(node);
567             }
568 
569             @Override
570             public boolean canonicalizeReads() {
<a name="39" id="anc39"></a><span class="line-modified">571                 return features.contains(READ_CANONICALIZATION);</span>
572             }
573 
574             @Override
575             public boolean allUsagesAvailable() {
576                 return true;
577             }
578 
579             @Override
580             public Assumptions getAssumptions() {
581                 return assumptions;
582             }
583 
584             @Override
585             public Integer smallestCompareWidth() {
586                 return context.getLowerer().smallestCompareWidth();
587             }
588 
589             @Override
590             public OptionValues getOptions() {
591                 return options;
592             }
593 
594             @Override
595             public Stamp stamp(ValueNode node) {
596                 return nodeView.stamp(node);
597             }
598         }
599     }
600 
601     public boolean getCanonicalizeReads() {
<a name="40" id="anc40"></a><span class="line-modified">602         return features.contains(READ_CANONICALIZATION);</span>
603     }
604 
605 }
<a name="41" id="anc41"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="41" type="hidden" />
</body>
</html>
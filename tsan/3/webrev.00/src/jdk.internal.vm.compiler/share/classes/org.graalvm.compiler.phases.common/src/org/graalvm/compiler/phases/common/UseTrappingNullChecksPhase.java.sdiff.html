<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RemoveValueProxyPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="inlining/InliningUtil.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 24 
 25 package org.graalvm.compiler.phases.common;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.OptImplicitNullChecks;
 28 
 29 import java.util.List;
 30 
 31 import org.graalvm.compiler.debug.CounterKey;
 32 import org.graalvm.compiler.debug.DebugContext;
 33 import org.graalvm.compiler.graph.Node;
 34 import org.graalvm.compiler.nodeinfo.InputType;
 35 import org.graalvm.compiler.nodes.AbstractBeginNode;
 36 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
 37 import org.graalvm.compiler.nodes.AbstractEndNode;
 38 import org.graalvm.compiler.nodes.AbstractMergeNode;
 39 import org.graalvm.compiler.nodes.BeginNode;
 40 import org.graalvm.compiler.nodes.CompressionNode;
 41 import org.graalvm.compiler.nodes.DeoptimizeNode;
 42 import org.graalvm.compiler.nodes.DeoptimizingFixedWithNextNode;
 43 import org.graalvm.compiler.nodes.DynamicDeoptimizeNode;

 44 import org.graalvm.compiler.nodes.FixedNode;
 45 import org.graalvm.compiler.nodes.IfNode;
 46 import org.graalvm.compiler.nodes.LogicNode;

 47 import org.graalvm.compiler.nodes.StructuredGraph;
 48 import org.graalvm.compiler.nodes.ValueNode;
 49 import org.graalvm.compiler.nodes.ValuePhiNode;
 50 import org.graalvm.compiler.nodes.calc.IsNullNode;
 51 import org.graalvm.compiler.nodes.extended.NullCheckNode;
 52 import org.graalvm.compiler.nodes.memory.FixedAccessNode;
 53 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 54 import org.graalvm.compiler.nodes.util.GraphUtil;
 55 import org.graalvm.compiler.options.Option;
 56 import org.graalvm.compiler.options.OptionKey;
 57 import org.graalvm.compiler.options.OptionType;
 58 import org.graalvm.compiler.phases.BasePhase;
 59 import org.graalvm.compiler.phases.tiers.LowTierContext;
 60 
 61 import jdk.vm.ci.meta.DeoptimizationReason;
 62 import jdk.vm.ci.meta.MetaAccessProvider;
 63 import jdk.vm.ci.meta.SpeculationLog;
 64 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 65 
 66 public class UseTrappingNullChecksPhase extends BasePhase&lt;LowTierContext&gt; {
</pre>
<hr />
<pre>
 98     private static void tryUseTrappingNullCheck(MetaAccessProvider metaAccessProvider, DynamicDeoptimizeNode deopt, long implicitNullCheckLimit) {
 99         Node predecessor = deopt.predecessor();
100         if (predecessor instanceof AbstractMergeNode) {
101             AbstractMergeNode merge = (AbstractMergeNode) predecessor;
102 
103             // Process each predecessor at the merge, unpacking the reasons and speculations as
104             // needed.
105             ValueNode reason = deopt.getActionAndReason();
106             ValuePhiNode reasonPhi = null;
107             List&lt;ValueNode&gt; reasons = null;
108             int expectedPhis = 0;
109 
110             if (reason instanceof ValuePhiNode) {
111                 reasonPhi = (ValuePhiNode) reason;
112                 if (reasonPhi.merge() != merge) {
113                     return;
114                 }
115                 reasons = reasonPhi.values().snapshot();
116                 expectedPhis++;
117             } else if (!reason.isConstant()) {

118                 return;
119             }
120 
121             ValueNode speculation = deopt.getSpeculation();
122             ValuePhiNode speculationPhi = null;
123             List&lt;ValueNode&gt; speculations = null;
124             if (speculation instanceof ValuePhiNode) {
125                 speculationPhi = (ValuePhiNode) speculation;
126                 if (speculationPhi.merge() != merge) {
127                     return;
128                 }
129                 speculations = speculationPhi.values().snapshot();
130                 expectedPhis++;
131             }
132 
133             if (merge.phis().count() != expectedPhis) {
134                 return;
135             }
136 
137             int index = 0;
<span class="line-modified">138             for (AbstractEndNode end : merge.cfgPredecessors().snapshot()) {</span>


139                 ValueNode thisReason = reasons != null ? reasons.get(index) : reason;
<span class="line-modified">140                 ValueNode thisSpeculation = speculations != null ? speculations.get(index++) : speculation;</span>
<span class="line-modified">141                 if (!thisReason.isConstant() || !thisSpeculation.isConstant()) {</span>
<span class="line-modified">142                     continue;</span>





143                 }
<span class="line-modified">144                 Speculation speculationConstant = metaAccessProvider.decodeSpeculation(thisSpeculation.asJavaConstant(), deopt.graph().getSpeculationLog());</span>
<span class="line-modified">145                 if (!speculationConstant.equals(SpeculationLog.NO_SPECULATION)) {</span>


146                     continue;
147                 }
148                 DeoptimizationReason deoptimizationReason = metaAccessProvider.decodeDeoptReason(thisReason.asJavaConstant());
<span class="line-modified">149                 tryUseTrappingNullCheck(deopt, end.predecessor(), deoptimizationReason, SpeculationLog.NO_SPECULATION, implicitNullCheckLimit);</span>

150             }
151         }
152     }
153 
154     private static void tryUseTrappingNullCheck(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, Speculation speculation, long implicitNullCheckLimit) {
<span class="line-modified">155         if (deoptimizationReason != DeoptimizationReason.NullCheckException &amp;&amp; deoptimizationReason != DeoptimizationReason.UnreachedCode) {</span>



156             return;
157         }
158         assert speculation != null;
159         if (!speculation.equals(SpeculationLog.NO_SPECULATION)) {

160             return;
161         }
<span class="line-modified">162         if (predecessor instanceof AbstractMergeNode) {</span>
<span class="line-modified">163             AbstractMergeNode merge = (AbstractMergeNode) predecessor;</span>






164             if (merge.phis().isEmpty()) {
165                 for (AbstractEndNode end : merge.cfgPredecessors().snapshot()) {
166                     checkPredecessor(deopt, end.predecessor(), deoptimizationReason, implicitNullCheckLimit);
167                 }
168             }
<span class="line-modified">169         } else if (predecessor instanceof AbstractBeginNode) {</span>
<span class="line-modified">170             checkPredecessor(deopt, predecessor, deoptimizationReason, implicitNullCheckLimit);</span>


171         }
172     }
173 
174     private static void checkPredecessor(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, long implicitNullCheckLimit) {
175         Node current = predecessor;
176         AbstractBeginNode branch = null;
177         while (current instanceof AbstractBeginNode) {
178             branch = (AbstractBeginNode) current;
179             if (branch.anchored().isNotEmpty()) {
180                 // some input of the deopt framestate is anchored to this branch
181                 return;
182             }
183             current = current.predecessor();
184         }
185         if (current instanceof IfNode) {
186             IfNode ifNode = (IfNode) current;
187             if (branch != ifNode.trueSuccessor()) {
188                 return;
189             }
190             LogicNode condition = ifNode.condition();
</pre>
<hr />
<pre>
215                 FixedAccessNode fixedAccessNode = (FixedAccessNode) nextNonTrapping;
216                 if (fixedAccessNode.canNullCheck()) {
217                     AddressNode address = fixedAccessNode.getAddress();
218                     ValueNode base = address.getBase();
219                     ValueNode index = address.getIndex();
220                     // allow for architectures which cannot fold an
221                     // intervening uncompress out of the address chain
222                     if (base != null &amp;&amp; base instanceof CompressionNode) {
223                         base = ((CompressionNode) base).getValue();
224                     }
225                     if (index != null &amp;&amp; index instanceof CompressionNode) {
226                         index = ((CompressionNode) index).getValue();
227                     }
228                     if (((base == value &amp;&amp; index == null) || (base == null &amp;&amp; index == value)) &amp;&amp; address.getMaxConstantDisplacement() &lt; implicitNullCheckLimit) {
229                         // Opportunity for implicit null check as part of an existing read found!
230                         fixedAccessNode.setStateBefore(deopt.stateBefore());
231                         fixedAccessNode.setNullCheck(true);
232                         deopt.graph().removeSplit(ifNode, nonTrappingContinuation);
233                         trappingNullCheck = fixedAccessNode;
234                         counterTrappingNullCheckExistingRead.increment(debug);

235                     }
236                 }
237             }
238         }
239 
240         if (trappingNullCheck == null) {
241             // Need to add a null check node.
242             trappingNullCheck = deopt.graph().add(new NullCheckNode(value));
243             deopt.graph().replaceSplit(ifNode, trappingNullCheck, nonTrappingContinuation);

244         }
245 
246         trappingNullCheck.setStateBefore(deopt.stateBefore());
247 
248         /*
249          * We now have the pattern NullCheck/BeginNode/... It&#39;s possible some node is using the
250          * BeginNode as a guard input, so replace guard users of the Begin with the NullCheck and
251          * then remove the Begin from the graph.
252          */
253         nonTrappingContinuation.replaceAtUsages(InputType.Guard, trappingNullCheck);
254 
255         if (nonTrappingContinuation instanceof BeginNode) {
256             GraphUtil.unlinkFixedNode(nonTrappingContinuation);
257             nonTrappingContinuation.safeDelete();
258         }
259 
260         GraphUtil.killCFG(trappingContinuation);
261         GraphUtil.tryKillUnused(isNullNode);
262     }
263 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 24 
 25 package org.graalvm.compiler.phases.common;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.OptImplicitNullChecks;
 28 
 29 import java.util.List;
 30 
 31 import org.graalvm.compiler.debug.CounterKey;
 32 import org.graalvm.compiler.debug.DebugContext;
 33 import org.graalvm.compiler.graph.Node;
 34 import org.graalvm.compiler.nodeinfo.InputType;
 35 import org.graalvm.compiler.nodes.AbstractBeginNode;
 36 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
 37 import org.graalvm.compiler.nodes.AbstractEndNode;
 38 import org.graalvm.compiler.nodes.AbstractMergeNode;
 39 import org.graalvm.compiler.nodes.BeginNode;
 40 import org.graalvm.compiler.nodes.CompressionNode;
 41 import org.graalvm.compiler.nodes.DeoptimizeNode;
 42 import org.graalvm.compiler.nodes.DeoptimizingFixedWithNextNode;
 43 import org.graalvm.compiler.nodes.DynamicDeoptimizeNode;
<span class="line-added"> 44 import org.graalvm.compiler.nodes.EndNode;</span>
 45 import org.graalvm.compiler.nodes.FixedNode;
 46 import org.graalvm.compiler.nodes.IfNode;
 47 import org.graalvm.compiler.nodes.LogicNode;
<span class="line-added"> 48 import org.graalvm.compiler.nodes.LoopExitNode;</span>
 49 import org.graalvm.compiler.nodes.StructuredGraph;
 50 import org.graalvm.compiler.nodes.ValueNode;
 51 import org.graalvm.compiler.nodes.ValuePhiNode;
 52 import org.graalvm.compiler.nodes.calc.IsNullNode;
 53 import org.graalvm.compiler.nodes.extended.NullCheckNode;
 54 import org.graalvm.compiler.nodes.memory.FixedAccessNode;
 55 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 56 import org.graalvm.compiler.nodes.util.GraphUtil;
 57 import org.graalvm.compiler.options.Option;
 58 import org.graalvm.compiler.options.OptionKey;
 59 import org.graalvm.compiler.options.OptionType;
 60 import org.graalvm.compiler.phases.BasePhase;
 61 import org.graalvm.compiler.phases.tiers.LowTierContext;
 62 
 63 import jdk.vm.ci.meta.DeoptimizationReason;
 64 import jdk.vm.ci.meta.MetaAccessProvider;
 65 import jdk.vm.ci.meta.SpeculationLog;
 66 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 67 
 68 public class UseTrappingNullChecksPhase extends BasePhase&lt;LowTierContext&gt; {
</pre>
<hr />
<pre>
100     private static void tryUseTrappingNullCheck(MetaAccessProvider metaAccessProvider, DynamicDeoptimizeNode deopt, long implicitNullCheckLimit) {
101         Node predecessor = deopt.predecessor();
102         if (predecessor instanceof AbstractMergeNode) {
103             AbstractMergeNode merge = (AbstractMergeNode) predecessor;
104 
105             // Process each predecessor at the merge, unpacking the reasons and speculations as
106             // needed.
107             ValueNode reason = deopt.getActionAndReason();
108             ValuePhiNode reasonPhi = null;
109             List&lt;ValueNode&gt; reasons = null;
110             int expectedPhis = 0;
111 
112             if (reason instanceof ValuePhiNode) {
113                 reasonPhi = (ValuePhiNode) reason;
114                 if (reasonPhi.merge() != merge) {
115                     return;
116                 }
117                 reasons = reasonPhi.values().snapshot();
118                 expectedPhis++;
119             } else if (!reason.isConstant()) {
<span class="line-added">120                 merge.getDebug().log(&quot;Non constant reason %s&quot;, merge);</span>
121                 return;
122             }
123 
124             ValueNode speculation = deopt.getSpeculation();
125             ValuePhiNode speculationPhi = null;
126             List&lt;ValueNode&gt; speculations = null;
127             if (speculation instanceof ValuePhiNode) {
128                 speculationPhi = (ValuePhiNode) speculation;
129                 if (speculationPhi.merge() != merge) {
130                     return;
131                 }
132                 speculations = speculationPhi.values().snapshot();
133                 expectedPhis++;
134             }
135 
136             if (merge.phis().count() != expectedPhis) {
137                 return;
138             }
139 
140             int index = 0;
<span class="line-modified">141             List&lt;EndNode&gt; predecessors = merge.cfgPredecessors().snapshot();</span>
<span class="line-added">142             for (AbstractEndNode end : predecessors) {</span>
<span class="line-added">143                 Node endPredecesssor = end.predecessor();</span>
144                 ValueNode thisReason = reasons != null ? reasons.get(index) : reason;
<span class="line-modified">145                 ValueNode thisSpeculation = speculations != null ? speculations.get(index) : speculation;</span>
<span class="line-modified">146                 if (!merge.isAlive()) {</span>
<span class="line-modified">147                     // When evacuating a merge the last successor simplfies the merge away so it</span>
<span class="line-added">148                     // must be handled specially.</span>
<span class="line-added">149                     assert predecessors.get(predecessors.size() - 1) == end : &quot;must be last end&quot;;</span>
<span class="line-added">150                     endPredecesssor = deopt.predecessor();</span>
<span class="line-added">151                     thisSpeculation = deopt.getSpeculation();</span>
<span class="line-added">152                     thisReason = deopt.getActionAndReason();</span>
153                 }
<span class="line-modified">154 </span>
<span class="line-modified">155                 index++;</span>
<span class="line-added">156                 if (!thisReason.isConstant() || !thisSpeculation.isConstant()) {</span>
<span class="line-added">157                     end.getDebug().log(&quot;Non constant deopt %s&quot;, end);</span>
158                     continue;
159                 }
160                 DeoptimizationReason deoptimizationReason = metaAccessProvider.decodeDeoptReason(thisReason.asJavaConstant());
<span class="line-modified">161                 Speculation speculationConstant = metaAccessProvider.decodeSpeculation(thisSpeculation.asJavaConstant(), deopt.graph().getSpeculationLog());</span>
<span class="line-added">162                 tryUseTrappingNullCheck(deopt, endPredecesssor, deoptimizationReason, speculationConstant, implicitNullCheckLimit);</span>
163             }
164         }
165     }
166 
167     private static void tryUseTrappingNullCheck(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, Speculation speculation, long implicitNullCheckLimit) {
<span class="line-modified">168         assert predecessor != null;</span>
<span class="line-added">169         if (deoptimizationReason != DeoptimizationReason.NullCheckException &amp;&amp; deoptimizationReason != DeoptimizationReason.UnreachedCode &amp;&amp;</span>
<span class="line-added">170                         deoptimizationReason != DeoptimizationReason.TypeCheckedInliningViolated) {</span>
<span class="line-added">171             deopt.getDebug().log(DebugContext.INFO_LEVEL, &quot;Not a null check or unreached %s&quot;, predecessor);</span>
172             return;
173         }
174         assert speculation != null;
175         if (!speculation.equals(SpeculationLog.NO_SPECULATION)) {
<span class="line-added">176             deopt.getDebug().log(DebugContext.INFO_LEVEL, &quot;Has a speculation %s&quot;, predecessor);</span>
177             return;
178         }
<span class="line-modified">179 </span>
<span class="line-modified">180         // Skip over loop exit nodes.</span>
<span class="line-added">181         Node pred = predecessor;</span>
<span class="line-added">182         while (pred instanceof LoopExitNode) {</span>
<span class="line-added">183             pred = pred.predecessor();</span>
<span class="line-added">184         }</span>
<span class="line-added">185         if (pred instanceof AbstractMergeNode) {</span>
<span class="line-added">186             AbstractMergeNode merge = (AbstractMergeNode) pred;</span>
187             if (merge.phis().isEmpty()) {
188                 for (AbstractEndNode end : merge.cfgPredecessors().snapshot()) {
189                     checkPredecessor(deopt, end.predecessor(), deoptimizationReason, implicitNullCheckLimit);
190                 }
191             }
<span class="line-modified">192         } else if (pred instanceof AbstractBeginNode) {</span>
<span class="line-modified">193             checkPredecessor(deopt, pred, deoptimizationReason, implicitNullCheckLimit);</span>
<span class="line-added">194         } else {</span>
<span class="line-added">195             deopt.getDebug().log(DebugContext.INFO_LEVEL, &quot;Not a Begin or Merge %s&quot;, pred);</span>
196         }
197     }
198 
199     private static void checkPredecessor(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, long implicitNullCheckLimit) {
200         Node current = predecessor;
201         AbstractBeginNode branch = null;
202         while (current instanceof AbstractBeginNode) {
203             branch = (AbstractBeginNode) current;
204             if (branch.anchored().isNotEmpty()) {
205                 // some input of the deopt framestate is anchored to this branch
206                 return;
207             }
208             current = current.predecessor();
209         }
210         if (current instanceof IfNode) {
211             IfNode ifNode = (IfNode) current;
212             if (branch != ifNode.trueSuccessor()) {
213                 return;
214             }
215             LogicNode condition = ifNode.condition();
</pre>
<hr />
<pre>
240                 FixedAccessNode fixedAccessNode = (FixedAccessNode) nextNonTrapping;
241                 if (fixedAccessNode.canNullCheck()) {
242                     AddressNode address = fixedAccessNode.getAddress();
243                     ValueNode base = address.getBase();
244                     ValueNode index = address.getIndex();
245                     // allow for architectures which cannot fold an
246                     // intervening uncompress out of the address chain
247                     if (base != null &amp;&amp; base instanceof CompressionNode) {
248                         base = ((CompressionNode) base).getValue();
249                     }
250                     if (index != null &amp;&amp; index instanceof CompressionNode) {
251                         index = ((CompressionNode) index).getValue();
252                     }
253                     if (((base == value &amp;&amp; index == null) || (base == null &amp;&amp; index == value)) &amp;&amp; address.getMaxConstantDisplacement() &lt; implicitNullCheckLimit) {
254                         // Opportunity for implicit null check as part of an existing read found!
255                         fixedAccessNode.setStateBefore(deopt.stateBefore());
256                         fixedAccessNode.setNullCheck(true);
257                         deopt.graph().removeSplit(ifNode, nonTrappingContinuation);
258                         trappingNullCheck = fixedAccessNode;
259                         counterTrappingNullCheckExistingRead.increment(debug);
<span class="line-added">260                         deopt.getDebug().log(&quot;Added implicit null check to %s&quot;, fixedAccessNode);</span>
261                     }
262                 }
263             }
264         }
265 
266         if (trappingNullCheck == null) {
267             // Need to add a null check node.
268             trappingNullCheck = deopt.graph().add(new NullCheckNode(value));
269             deopt.graph().replaceSplit(ifNode, trappingNullCheck, nonTrappingContinuation);
<span class="line-added">270             deopt.getDebug().log(&quot;Inserted NullCheckNode %s&quot;, trappingNullCheck);</span>
271         }
272 
273         trappingNullCheck.setStateBefore(deopt.stateBefore());
274 
275         /*
276          * We now have the pattern NullCheck/BeginNode/... It&#39;s possible some node is using the
277          * BeginNode as a guard input, so replace guard users of the Begin with the NullCheck and
278          * then remove the Begin from the graph.
279          */
280         nonTrappingContinuation.replaceAtUsages(InputType.Guard, trappingNullCheck);
281 
282         if (nonTrappingContinuation instanceof BeginNode) {
283             GraphUtil.unlinkFixedNode(nonTrappingContinuation);
284             nonTrappingContinuation.safeDelete();
285         }
286 
287         GraphUtil.killCFG(trappingContinuation);
288         GraphUtil.tryKillUnused(isNullNode);
289     }
290 }
</pre>
</td>
</tr>
</table>
<center><a href="RemoveValueProxyPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="inlining/InliningUtil.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
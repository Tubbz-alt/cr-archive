diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/DeoptimizationGroupingPhase.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/DeoptimizationGroupingPhase.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/DeoptimizationGroupingPhase.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/DeoptimizationGroupingPhase.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,21 +22,21 @@
  */
 
 
 package org.graalvm.compiler.phases.common;
 
+import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 
 import org.graalvm.compiler.core.common.cfg.Loop;
 import org.graalvm.compiler.core.common.type.StampFactory;
 import org.graalvm.compiler.debug.DebugCloseable;
 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
 import org.graalvm.compiler.nodes.AbstractMergeNode;
 import org.graalvm.compiler.nodes.DynamicDeoptimizeNode;
 import org.graalvm.compiler.nodes.EndNode;
-import org.graalvm.compiler.nodes.FixedNode;
 import org.graalvm.compiler.nodes.FrameState;
 import org.graalvm.compiler.nodes.LoopBeginNode;
 import org.graalvm.compiler.nodes.LoopExitNode;
 import org.graalvm.compiler.nodes.MergeNode;
 import org.graalvm.compiler.nodes.PhiNode;
@@ -57,58 +57,57 @@
     @Override
     @SuppressWarnings("try")
     protected void run(StructuredGraph graph, MidTierContext context) {
         ControlFlowGraph cfg = null;
         for (FrameState fs : graph.getNodes(FrameState.TYPE)) {
-            FixedNode target = null;
-            PhiNode reasonActionPhi = null;
-            PhiNode speculationPhi = null;
-            List<AbstractDeoptimizeNode> obsoletes = null;
-            for (AbstractDeoptimizeNode deopt : fs.usages().filter(AbstractDeoptimizeNode.class)) {
-                if (target == null) {
-                    target = deopt;
-                } else {
-                    if (cfg == null) {
-                        cfg = ControlFlowGraph.compute(graph, true, true, false, false);
-                    }
-                    AbstractMergeNode merge;
-                    if (target instanceof AbstractDeoptimizeNode) {
-                        merge = graph.add(new MergeNode());
-                        EndNode firstEnd = graph.add(new EndNode());
-                        ValueNode actionAndReason = ((AbstractDeoptimizeNode) target).getActionAndReason(context.getMetaAccess());
-                        ValueNode speculation = ((AbstractDeoptimizeNode) target).getSpeculation(context.getMetaAccess());
-                        reasonActionPhi = graph.addWithoutUnique(new ValuePhiNode(StampFactory.forKind(actionAndReason.getStackKind()), merge));
-                        speculationPhi = graph.addWithoutUnique(new ValuePhiNode(StampFactory.forKind(speculation.getStackKind()), merge));
-                        merge.addForwardEnd(firstEnd);
-                        reasonActionPhi.addInput(actionAndReason);
-                        speculationPhi.addInput(speculation);
-                        target.replaceAtPredecessor(firstEnd);
-
-                        exitLoops((AbstractDeoptimizeNode) target, firstEnd, cfg);
-                        try (DebugCloseable position = target.withNodeSourcePosition()) {
-                            merge.setNext(graph.add(new DynamicDeoptimizeNode(reasonActionPhi, speculationPhi)));
-                        }
-                        obsoletes = new LinkedList<>();
-                        obsoletes.add((AbstractDeoptimizeNode) target);
-                        target = merge;
-                    } else {
-                        merge = (AbstractMergeNode) target;
-                    }
-                    EndNode newEnd = graph.add(new EndNode());
-                    merge.addForwardEnd(newEnd);
-                    reasonActionPhi.addInput(deopt.getActionAndReason(context.getMetaAccess()));
-                    speculationPhi.addInput(deopt.getSpeculation(context.getMetaAccess()));
-                    deopt.replaceAtPredecessor(newEnd);
-                    exitLoops(deopt, newEnd, cfg);
-                    obsoletes.add(deopt);
-                }
+            Iterator<AbstractDeoptimizeNode> iterator = fs.usages().filter(AbstractDeoptimizeNode.class).iterator();
+            if (!iterator.hasNext()) {
+                // No deopt
+                continue;
+            }
+            AbstractDeoptimizeNode first = iterator.next();
+            if (!iterator.hasNext()) {
+                // Only 1 deopt
+                continue;
+            }
+            // There is more than one deopt, create a merge
+            if (cfg == null) {
+                cfg = ControlFlowGraph.compute(graph, true, true, false, false);
             }
-            if (obsoletes != null) {
-                ((DynamicDeoptimizeNode) ((AbstractMergeNode) target).next()).setStateBefore(fs);
-                for (AbstractDeoptimizeNode obsolete : obsoletes) {
-                    obsolete.safeDelete();
-                }
+            AbstractMergeNode merge = graph.add(new MergeNode());
+            EndNode firstEnd = graph.add(new EndNode());
+            ValueNode actionAndReason = first.getActionAndReason(context.getMetaAccess());
+            ValueNode speculation = first.getSpeculation(context.getMetaAccess());
+            PhiNode reasonActionPhi = graph.addWithoutUnique(new ValuePhiNode(StampFactory.forKind(actionAndReason.getStackKind()), merge));
+            PhiNode speculationPhi = graph.addWithoutUnique(new ValuePhiNode(StampFactory.forKind(speculation.getStackKind()), merge));
+            merge.addForwardEnd(firstEnd);
+            reasonActionPhi.addInput(actionAndReason);
+            speculationPhi.addInput(speculation);
+            first.replaceAtPredecessor(firstEnd);
+            exitLoops(first, firstEnd, cfg);
+            DynamicDeoptimizeNode dynamicDeopt;
+            try (DebugCloseable position = first.withNodeSourcePosition()) {
+                dynamicDeopt = new DynamicDeoptimizeNode(reasonActionPhi, speculationPhi);
+                merge.setNext(graph.add(dynamicDeopt));
+            }
+            List<AbstractDeoptimizeNode> obsoletes = new LinkedList<>();
+            obsoletes.add(first);
+
+            do {
+                AbstractDeoptimizeNode deopt = iterator.next();
+                EndNode newEnd = graph.add(new EndNode());
+                merge.addForwardEnd(newEnd);
+                reasonActionPhi.addInput(deopt.getActionAndReason(context.getMetaAccess()));
+                speculationPhi.addInput(deopt.getSpeculation(context.getMetaAccess()));
+                deopt.replaceAtPredecessor(newEnd);
+                exitLoops(deopt, newEnd, cfg);
+                obsoletes.add(deopt);
+            } while (iterator.hasNext());
+
+            dynamicDeopt.setStateBefore(fs);
+            for (AbstractDeoptimizeNode obsolete : obsoletes) {
+                obsolete.safeDelete();
             }
         }
     }
 
     private static void exitLoops(AbstractDeoptimizeNode deopt, EndNode end, ControlFlowGraph cfg) {

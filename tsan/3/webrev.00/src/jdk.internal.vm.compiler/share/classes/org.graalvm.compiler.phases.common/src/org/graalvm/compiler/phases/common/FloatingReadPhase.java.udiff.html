<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/FloatingReadPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FixReadsPhase.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="FrameStateAssignmentPhase.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/FloatingReadPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -46,10 +46,11 @@</span>
  import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
  import org.graalvm.compiler.nodes.LoopBeginNode;
  import org.graalvm.compiler.nodes.LoopEndNode;
  import org.graalvm.compiler.nodes.LoopExitNode;
  import org.graalvm.compiler.nodes.PhiNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.ProxyNode;</span>
  import org.graalvm.compiler.nodes.ReturnNode;
  import org.graalvm.compiler.nodes.StartNode;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNodeUtil;
  import org.graalvm.compiler.nodes.calc.FloatingNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -164,13 +165,13 @@</span>
          return set;
      }
  
      protected void processNode(FixedNode node, EconomicSet&lt;LocationIdentity&gt; currentState) {
          if (node instanceof MemoryCheckpoint.Single) {
<span class="udiff-line-modified-removed">-             processIdentity(currentState, ((MemoryCheckpoint.Single) node).getLocationIdentity());</span>
<span class="udiff-line-modified-added">+             processIdentity(currentState, ((MemoryCheckpoint.Single) node).getKilledLocationIdentity());</span>
          } else if (node instanceof MemoryCheckpoint.Multi) {
<span class="udiff-line-modified-removed">-             for (LocationIdentity identity : ((MemoryCheckpoint.Multi) node).getLocationIdentities()) {</span>
<span class="udiff-line-modified-added">+             for (LocationIdentity identity : ((MemoryCheckpoint.Multi) node).getKilledLocationIdentities()) {</span>
                  processIdentity(currentState, identity);
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -252,10 +253,12 @@</span>
              boolean isPhi = false;
              MemoryNode merged = null;
              for (MemoryMap state : states) {
                  MemoryNode last = state.getLastLocationAccess(key);
                  if (isPhi) {
<span class="udiff-line-added">+                     // Fortify: Suppress Null Deference false positive (`isPhi == true` implies</span>
<span class="udiff-line-added">+                     // `merged != null`)</span>
                      ((MemoryPhiNode) merged).addInput(ValueNodeUtil.asNode(last));
                  } else {
                      if (merged == last) {
                          // nothing to do
                      } else if (merged == null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -270,11 +273,11 @@</span>
                          isPhi = true;
                      }
                  }
                  mergedStatesCount++;
              }
<span class="udiff-line-modified-removed">-             newState.lastMemorySnapshot.put(key, merged);</span>
<span class="udiff-line-modified-added">+             newState.getMap().put(key, merged);</span>
          }
          return newState;
  
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -297,10 +300,20 @@</span>
              this.createMemoryMapNodes = createMemoryMapNodes;
          }
  
          @Override
          protected MemoryMapImpl processNode(FixedNode node, MemoryMapImpl state) {
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (node instanceof LoopExitNode) {</span>
<span class="udiff-line-added">+                 final LoopExitNode loopExitNode = (LoopExitNode) node;</span>
<span class="udiff-line-added">+                 final EconomicSet&lt;LocationIdentity&gt; modifiedInLoop = modifiedInLoops.get(loopExitNode.loopBegin());</span>
<span class="udiff-line-added">+                 final boolean anyModified = modifiedInLoop.contains(LocationIdentity.any());</span>
<span class="udiff-line-added">+                 state.getMap().replaceAll((locationIdentity, memoryNode) -&gt; (anyModified || modifiedInLoop.contains(locationIdentity))</span>
<span class="udiff-line-added">+                                 ? ProxyNode.forMemory(memoryNode, loopExitNode, locationIdentity)</span>
<span class="udiff-line-added">+                                 : memoryNode);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              if (node instanceof MemoryAnchorNode) {
                  processAnchor((MemoryAnchorNode) node, state);
                  return state;
              }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -308,19 +321,20 @@</span>
                  processAccess((MemoryAccess) node, state);
              }
  
              if (createFloatingReads &amp;&amp; node instanceof FloatableAccessNode) {
                  processFloatable((FloatableAccessNode) node, state);
<span class="udiff-line-modified-removed">-             } else if (node instanceof MemoryCheckpoint.Single) {</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-added">+             if (node instanceof MemoryCheckpoint.Single) {</span>
                  processCheckpoint((MemoryCheckpoint.Single) node, state);
              } else if (node instanceof MemoryCheckpoint.Multi) {
                  processCheckpoint((MemoryCheckpoint.Multi) node, state);
              }
              assert MemoryCheckpoint.TypeAssertion.correctType(node) : node;
  
              if (createMemoryMapNodes &amp;&amp; node instanceof ReturnNode) {
<span class="udiff-line-modified-removed">-                 ((ReturnNode) node).setMemoryMap(node.graph().unique(new MemoryMapNode(state.lastMemorySnapshot)));</span>
<span class="udiff-line-modified-added">+                 ((ReturnNode) node).setMemoryMap(node.graph().unique(new MemoryMapNode(state.getMap())));</span>
              }
              return state;
          }
  
          /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -351,25 +365,25 @@</span>
                  access.setLastLocationAccess(lastLocationAccess);
              }
          }
  
          private static void processCheckpoint(MemoryCheckpoint.Single checkpoint, MemoryMapImpl state) {
<span class="udiff-line-modified-removed">-             processIdentity(checkpoint.getLocationIdentity(), checkpoint, state);</span>
<span class="udiff-line-modified-added">+             processIdentity(checkpoint.getKilledLocationIdentity(), checkpoint, state);</span>
          }
  
          private static void processCheckpoint(MemoryCheckpoint.Multi checkpoint, MemoryMapImpl state) {
<span class="udiff-line-modified-removed">-             for (LocationIdentity identity : checkpoint.getLocationIdentities()) {</span>
<span class="udiff-line-modified-added">+             for (LocationIdentity identity : checkpoint.getKilledLocationIdentities()) {</span>
                  processIdentity(identity, checkpoint, state);
              }
          }
  
          private static void processIdentity(LocationIdentity identity, MemoryCheckpoint checkpoint, MemoryMapImpl state) {
              if (identity.isAny()) {
<span class="udiff-line-modified-removed">-                 state.lastMemorySnapshot.clear();</span>
<span class="udiff-line-modified-added">+                 state.getMap().clear();</span>
              }
              if (identity.isMutable()) {
<span class="udiff-line-modified-removed">-                 state.lastMemorySnapshot.put(identity, checkpoint);</span>
<span class="udiff-line-modified-added">+                 state.getMap().put(identity, checkpoint);</span>
              }
          }
  
          @SuppressWarnings(&quot;try&quot;)
          private static void processFloatable(FloatableAccessNode accessNode, MemoryMapImpl state) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -377,11 +391,12 @@</span>
              LocationIdentity locationIdentity = accessNode.getLocationIdentity();
              if (accessNode.canFloat()) {
                  assert accessNode.getNullCheck() == false;
                  MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);
                  try (DebugCloseable position = accessNode.withNodeSourcePosition()) {
<span class="udiff-line-modified-removed">-                     FloatingAccessNode floatingNode = accessNode.asFloatingNode(lastLocationAccess);</span>
<span class="udiff-line-modified-added">+                     FloatingAccessNode floatingNode = accessNode.asFloatingNode();</span>
<span class="udiff-line-added">+                     assert floatingNode.getLastLocationAccess() == lastLocationAccess;</span>
                      graph.replaceFixedWithFloating(accessNode, floatingNode);
                  }
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -400,11 +415,11 @@</span>
                   * schedule anything immediately after the invoke. It can only schedule in the
                   * normal or exceptional successor - and we have to tell the scheduler here which
                   * side it needs to choose by putting in the location identity on both successors.
                   */
                  InvokeWithExceptionNode invoke = (InvokeWithExceptionNode) node.predecessor();
<span class="udiff-line-modified-removed">-                 result.lastMemorySnapshot.put(invoke.getLocationIdentity(), (MemoryCheckpoint) node);</span>
<span class="udiff-line-modified-added">+                 result.getMap().put(invoke.getKilledLocationIdentity(), (MemoryCheckpoint) node);</span>
              }
              return result;
          }
  
          @Override
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -412,17 +427,17 @@</span>
              EconomicSet&lt;LocationIdentity&gt; modifiedLocations = modifiedInLoops.get(loop);
              EconomicMap&lt;LocationIdentity, MemoryPhiNode&gt; phis = EconomicMap.create(Equivalence.DEFAULT);
              if (modifiedLocations.contains(LocationIdentity.any())) {
                  // create phis for all locations if ANY is modified in the loop
                  modifiedLocations = EconomicSet.create(Equivalence.DEFAULT, modifiedLocations);
<span class="udiff-line-modified-removed">-                 modifiedLocations.addAll(initialState.lastMemorySnapshot.getKeys());</span>
<span class="udiff-line-modified-added">+                 modifiedLocations.addAll(initialState.getMap().getKeys());</span>
              }
  
              for (LocationIdentity location : modifiedLocations) {
                  createMemoryPhi(loop, initialState, phis, location);
              }
<span class="udiff-line-modified-removed">-             initialState.lastMemorySnapshot.putAll(phis);</span>
<span class="udiff-line-modified-added">+             initialState.getMap().putAll(phis);</span>
  
              LoopInfo&lt;MemoryMapImpl&gt; loopInfo = ReentrantNodeIterator.processLoop(this, loop, initialState);
  
              UnmodifiableMapCursor&lt;LoopEndNode, MemoryMapImpl&gt; endStateCursor = loopInfo.endStates.getEntries();
              while (endStateCursor.advance()) {
</pre>
<center><a href="FixReadsPhase.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="FrameStateAssignmentPhase.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
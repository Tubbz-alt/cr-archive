<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RemoveValueProxyPhase.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="inlining/InliningUtil.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -39,13 +39,15 @@</span>
  import org.graalvm.compiler.nodes.BeginNode;
  import org.graalvm.compiler.nodes.CompressionNode;
  import org.graalvm.compiler.nodes.DeoptimizeNode;
  import org.graalvm.compiler.nodes.DeoptimizingFixedWithNextNode;
  import org.graalvm.compiler.nodes.DynamicDeoptimizeNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.EndNode;</span>
  import org.graalvm.compiler.nodes.FixedNode;
  import org.graalvm.compiler.nodes.IfNode;
  import org.graalvm.compiler.nodes.LogicNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.LoopExitNode;</span>
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.ValuePhiNode;
  import org.graalvm.compiler.nodes.calc.IsNullNode;
  import org.graalvm.compiler.nodes.extended.NullCheckNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -113,10 +115,11 @@</span>
                      return;
                  }
                  reasons = reasonPhi.values().snapshot();
                  expectedPhis++;
              } else if (!reason.isConstant()) {
<span class="udiff-line-added">+                 merge.getDebug().log(&quot;Non constant reason %s&quot;, merge);</span>
                  return;
              }
  
              ValueNode speculation = deopt.getSpeculation();
              ValuePhiNode speculationPhi = null;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -133,43 +136,65 @@</span>
              if (merge.phis().count() != expectedPhis) {
                  return;
              }
  
              int index = 0;
<span class="udiff-line-modified-removed">-             for (AbstractEndNode end : merge.cfgPredecessors().snapshot()) {</span>
<span class="udiff-line-modified-added">+             List&lt;EndNode&gt; predecessors = merge.cfgPredecessors().snapshot();</span>
<span class="udiff-line-added">+             for (AbstractEndNode end : predecessors) {</span>
<span class="udiff-line-added">+                 Node endPredecesssor = end.predecessor();</span>
                  ValueNode thisReason = reasons != null ? reasons.get(index) : reason;
<span class="udiff-line-modified-removed">-                 ValueNode thisSpeculation = speculations != null ? speculations.get(index++) : speculation;</span>
<span class="udiff-line-modified-removed">-                 if (!thisReason.isConstant() || !thisSpeculation.isConstant()) {</span>
<span class="udiff-line-modified-removed">-                     continue;</span>
<span class="udiff-line-modified-added">+                 ValueNode thisSpeculation = speculations != null ? speculations.get(index) : speculation;</span>
<span class="udiff-line-modified-added">+                 if (!merge.isAlive()) {</span>
<span class="udiff-line-modified-added">+                     // When evacuating a merge the last successor simplfies the merge away so it</span>
<span class="udiff-line-added">+                     // must be handled specially.</span>
<span class="udiff-line-added">+                     assert predecessors.get(predecessors.size() - 1) == end : &quot;must be last end&quot;;</span>
<span class="udiff-line-added">+                     endPredecesssor = deopt.predecessor();</span>
<span class="udiff-line-added">+                     thisSpeculation = deopt.getSpeculation();</span>
<span class="udiff-line-added">+                     thisReason = deopt.getActionAndReason();</span>
                  }
<span class="udiff-line-modified-removed">-                 Speculation speculationConstant = metaAccessProvider.decodeSpeculation(thisSpeculation.asJavaConstant(), deopt.graph().getSpeculationLog());</span>
<span class="udiff-line-modified-removed">-                 if (!speculationConstant.equals(SpeculationLog.NO_SPECULATION)) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 index++;</span>
<span class="udiff-line-added">+                 if (!thisReason.isConstant() || !thisSpeculation.isConstant()) {</span>
<span class="udiff-line-added">+                     end.getDebug().log(&quot;Non constant deopt %s&quot;, end);</span>
                      continue;
                  }
                  DeoptimizationReason deoptimizationReason = metaAccessProvider.decodeDeoptReason(thisReason.asJavaConstant());
<span class="udiff-line-modified-removed">-                 tryUseTrappingNullCheck(deopt, end.predecessor(), deoptimizationReason, SpeculationLog.NO_SPECULATION, implicitNullCheckLimit);</span>
<span class="udiff-line-modified-added">+                 Speculation speculationConstant = metaAccessProvider.decodeSpeculation(thisSpeculation.asJavaConstant(), deopt.graph().getSpeculationLog());</span>
<span class="udiff-line-added">+                 tryUseTrappingNullCheck(deopt, endPredecesssor, deoptimizationReason, speculationConstant, implicitNullCheckLimit);</span>
              }
          }
      }
  
      private static void tryUseTrappingNullCheck(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, Speculation speculation, long implicitNullCheckLimit) {
<span class="udiff-line-modified-removed">-         if (deoptimizationReason != DeoptimizationReason.NullCheckException &amp;&amp; deoptimizationReason != DeoptimizationReason.UnreachedCode) {</span>
<span class="udiff-line-modified-added">+         assert predecessor != null;</span>
<span class="udiff-line-added">+         if (deoptimizationReason != DeoptimizationReason.NullCheckException &amp;&amp; deoptimizationReason != DeoptimizationReason.UnreachedCode &amp;&amp;</span>
<span class="udiff-line-added">+                         deoptimizationReason != DeoptimizationReason.TypeCheckedInliningViolated) {</span>
<span class="udiff-line-added">+             deopt.getDebug().log(DebugContext.INFO_LEVEL, &quot;Not a null check or unreached %s&quot;, predecessor);</span>
              return;
          }
          assert speculation != null;
          if (!speculation.equals(SpeculationLog.NO_SPECULATION)) {
<span class="udiff-line-added">+             deopt.getDebug().log(DebugContext.INFO_LEVEL, &quot;Has a speculation %s&quot;, predecessor);</span>
              return;
          }
<span class="udiff-line-modified-removed">-         if (predecessor instanceof AbstractMergeNode) {</span>
<span class="udiff-line-modified-removed">-             AbstractMergeNode merge = (AbstractMergeNode) predecessor;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         // Skip over loop exit nodes.</span>
<span class="udiff-line-added">+         Node pred = predecessor;</span>
<span class="udiff-line-added">+         while (pred instanceof LoopExitNode) {</span>
<span class="udiff-line-added">+             pred = pred.predecessor();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (pred instanceof AbstractMergeNode) {</span>
<span class="udiff-line-added">+             AbstractMergeNode merge = (AbstractMergeNode) pred;</span>
              if (merge.phis().isEmpty()) {
                  for (AbstractEndNode end : merge.cfgPredecessors().snapshot()) {
                      checkPredecessor(deopt, end.predecessor(), deoptimizationReason, implicitNullCheckLimit);
                  }
              }
<span class="udiff-line-modified-removed">-         } else if (predecessor instanceof AbstractBeginNode) {</span>
<span class="udiff-line-modified-removed">-             checkPredecessor(deopt, predecessor, deoptimizationReason, implicitNullCheckLimit);</span>
<span class="udiff-line-modified-added">+         } else if (pred instanceof AbstractBeginNode) {</span>
<span class="udiff-line-modified-added">+             checkPredecessor(deopt, pred, deoptimizationReason, implicitNullCheckLimit);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             deopt.getDebug().log(DebugContext.INFO_LEVEL, &quot;Not a Begin or Merge %s&quot;, pred);</span>
          }
      }
  
      private static void checkPredecessor(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, long implicitNullCheckLimit) {
          Node current = predecessor;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -230,19 +255,21 @@</span>
                          fixedAccessNode.setStateBefore(deopt.stateBefore());
                          fixedAccessNode.setNullCheck(true);
                          deopt.graph().removeSplit(ifNode, nonTrappingContinuation);
                          trappingNullCheck = fixedAccessNode;
                          counterTrappingNullCheckExistingRead.increment(debug);
<span class="udiff-line-added">+                         deopt.getDebug().log(&quot;Added implicit null check to %s&quot;, fixedAccessNode);</span>
                      }
                  }
              }
          }
  
          if (trappingNullCheck == null) {
              // Need to add a null check node.
              trappingNullCheck = deopt.graph().add(new NullCheckNode(value));
              deopt.graph().replaceSplit(ifNode, trappingNullCheck, nonTrappingContinuation);
<span class="udiff-line-added">+             deopt.getDebug().log(&quot;Inserted NullCheckNode %s&quot;, trappingNullCheck);</span>
          }
  
          trappingNullCheck.setStateBefore(deopt.stateBefore());
  
          /*
</pre>
<center><a href="RemoveValueProxyPhase.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="inlining/InliningUtil.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/CanonicalizerPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AddressLoweringByUsePhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConditionalEliminationPhase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/CanonicalizerPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.phases.common;
 26 






 27 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 28 import org.graalvm.compiler.core.common.type.Stamp;
 29 import org.graalvm.compiler.debug.CounterKey;
 30 import org.graalvm.compiler.debug.DebugCloseable;
 31 import org.graalvm.compiler.debug.DebugContext;
 32 import org.graalvm.compiler.graph.GraalGraphError;
 33 import org.graalvm.compiler.graph.Graph;
 34 import org.graalvm.compiler.graph.Graph.Mark;
 35 import org.graalvm.compiler.graph.Graph.NodeEventListener;
 36 import org.graalvm.compiler.graph.Graph.NodeEventScope;
 37 import org.graalvm.compiler.graph.Node;
 38 import org.graalvm.compiler.graph.Node.IndirectCanonicalization;
 39 import org.graalvm.compiler.graph.NodeClass;
 40 import org.graalvm.compiler.graph.NodeWorkList;
 41 import org.graalvm.compiler.graph.spi.Canonicalizable;
 42 import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;
 43 import org.graalvm.compiler.graph.spi.SimplifierTool;
 44 import org.graalvm.compiler.nodeinfo.InputType;

 45 import org.graalvm.compiler.nodes.AbstractMergeNode;
 46 import org.graalvm.compiler.nodes.ConstantNode;
 47 import org.graalvm.compiler.nodes.ControlSinkNode;
 48 import org.graalvm.compiler.nodes.FixedNode;
 49 import org.graalvm.compiler.nodes.FixedWithNextNode;
 50 import org.graalvm.compiler.nodes.NodeView;
 51 import org.graalvm.compiler.nodes.StartNode;
 52 import org.graalvm.compiler.nodes.StructuredGraph;
 53 import org.graalvm.compiler.nodes.ValueNode;
 54 import org.graalvm.compiler.nodes.calc.FloatingNode;

 55 import org.graalvm.compiler.nodes.util.GraphUtil;
 56 import org.graalvm.compiler.options.OptionValues;
 57 import org.graalvm.compiler.phases.BasePhase;
 58 import org.graalvm.compiler.phases.Phase;
<span class="line-removed"> 59 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 60 
 61 import jdk.vm.ci.meta.Assumptions;
 62 import jdk.vm.ci.meta.Constant;
 63 import jdk.vm.ci.meta.ConstantReflectionProvider;
 64 import jdk.vm.ci.meta.MetaAccessProvider;
 65 
<span class="line-modified"> 66 public class CanonicalizerPhase extends BasePhase&lt;PhaseContext&gt; {</span>






 67 
 68     private static final int MAX_ITERATION_PER_NODE = 10;
 69     private static final CounterKey COUNTER_CANONICALIZED_NODES = DebugContext.counter(&quot;CanonicalizedNodes&quot;);
 70     private static final CounterKey COUNTER_PROCESSED_NODES = DebugContext.counter(&quot;ProcessedNodes&quot;);
 71     private static final CounterKey COUNTER_CANONICALIZATION_CONSIDERED_NODES = DebugContext.counter(&quot;CanonicalizationConsideredNodes&quot;);
 72     private static final CounterKey COUNTER_INFER_STAMP_CALLED = DebugContext.counter(&quot;InferStampCalled&quot;);
 73     private static final CounterKey COUNTER_STAMP_CHANGED = DebugContext.counter(&quot;StampChanged&quot;);
 74     private static final CounterKey COUNTER_SIMPLIFICATION_CONSIDERED_NODES = DebugContext.counter(&quot;SimplificationConsideredNodes&quot;);
 75     private static final CounterKey COUNTER_GLOBAL_VALUE_NUMBERING_HITS = DebugContext.counter(&quot;GlobalValueNumberingHits&quot;);
 76 
<span class="line-modified"> 77     private boolean globalValueNumber = true;</span>
<span class="line-modified"> 78     private boolean canonicalizeReads = true;</span>
<span class="line-modified"> 79     private boolean simplify = true;</span>
<span class="line-removed"> 80     private final CustomCanonicalizer customCanonicalizer;</span>
 81 
<span class="line-modified"> 82     public abstract static class CustomCanonicalizer {</span>







 83 
<span class="line-modified"> 84         public Node canonicalize(Node node) {</span>
<span class="line-modified"> 85             return node;</span>
<span class="line-modified"> 86         }</span>




 87 
<span class="line-modified"> 88         @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-modified"> 89         public void simplify(Node node, SimplifierTool tool) {</span>
<span class="line-modified"> 90         }</span>

















 91     }
 92 
<span class="line-modified"> 93     public CanonicalizerPhase() {</span>
<span class="line-modified"> 94         this(null);</span>
 95     }
 96 
<span class="line-modified"> 97     public CanonicalizerPhase(CustomCanonicalizer customCanonicalizer) {</span>
<span class="line-modified"> 98         this.customCanonicalizer = customCanonicalizer;</span>


 99     }
100 
<span class="line-modified">101     public void disableGVN() {</span>
<span class="line-modified">102         globalValueNumber = false;</span>


103     }
104 
<span class="line-modified">105     public void disableReadCanonicalization() {</span>
<span class="line-modified">106         canonicalizeReads = false;</span>
107     }
108 
<span class="line-modified">109     public void disableSimplification() {</span>
<span class="line-modified">110         simplify = false;</span>








111     }
112 
113     @Override
114     public boolean checkContract() {
115         /*
116          * There are certain canonicalizations we make that heavily increase code size by e.g.
117          * replacing a merge followed by a return of the merge&#39;s phi with returns in each
118          * predecessor.
119          */
120         return false;
121     }
122 
123     @Override
<span class="line-modified">124     protected void run(StructuredGraph graph, PhaseContext context) {</span>
125         new Instance(context).run(graph);
126     }
127 
128     /**
129      * @param newNodesMark only the {@linkplain Graph#getNewNodes(Mark) new nodes} specified by this
130      *            mark are processed
131      */
<span class="line-modified">132     public void applyIncremental(StructuredGraph graph, PhaseContext context, Mark newNodesMark) {</span>
133         applyIncremental(graph, context, newNodesMark, true);
134     }
135 
<span class="line-modified">136     public void applyIncremental(StructuredGraph graph, PhaseContext context, Mark newNodesMark, boolean dumpGraph) {</span>
137         new Instance(context, newNodesMark).apply(graph, dumpGraph);
138     }
139 
140     /**
141      * @param workingSet the initial working set of nodes on which the canonicalizer works, should
142      *            be an auto-grow node bitmap
143      */
<span class="line-modified">144     public void applyIncremental(StructuredGraph graph, PhaseContext context, Iterable&lt;? extends Node&gt; workingSet) {</span>
145         applyIncremental(graph, context, workingSet, true);
146     }
147 
<span class="line-modified">148     public void applyIncremental(StructuredGraph graph, PhaseContext context, Iterable&lt;? extends Node&gt; workingSet, boolean dumpGraph) {</span>
149         new Instance(context, workingSet).apply(graph, dumpGraph);
150     }
151 
<span class="line-modified">152     public void applyIncremental(StructuredGraph graph, PhaseContext context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark) {</span>
153         applyIncremental(graph, context, workingSet, newNodesMark, true);
154     }
155 
<span class="line-modified">156     public void applyIncremental(StructuredGraph graph, PhaseContext context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark, boolean dumpGraph) {</span>
157         new Instance(context, workingSet, newNodesMark).apply(graph, dumpGraph);
158     }
159 
160     public NodeView getNodeView() {
161         return NodeView.DEFAULT;
162     }
163 
164     private final class Instance extends Phase {
165 
166         private final Mark newNodesMark;
<span class="line-modified">167         private final PhaseContext context;</span>
168         private final Iterable&lt;? extends Node&gt; initWorkingSet;
169 
170         private NodeWorkList workList;
171         private Tool tool;
172         private DebugContext debug;
173 
<span class="line-modified">174         private Instance(PhaseContext context) {</span>
175             this(context, null, null);
176         }
177 
<span class="line-modified">178         private Instance(PhaseContext context, Iterable&lt;? extends Node&gt; workingSet) {</span>
179             this(context, workingSet, null);
180         }
181 
<span class="line-modified">182         private Instance(PhaseContext context, Mark newNodesMark) {</span>
183             this(context, null, newNodesMark);
184         }
185 
<span class="line-modified">186         private Instance(PhaseContext context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark) {</span>
187             this.newNodesMark = newNodesMark;
188             this.context = context;
189             this.initWorkingSet = workingSet;
190         }
191 
192         @Override
193         public boolean checkContract() {
194             return false;
195         }
196 
197         @Override
198         protected void run(StructuredGraph graph) {
199             this.debug = graph.getDebug();
200             boolean wholeGraph = newNodesMark == null || newNodesMark.isStart();
201             if (initWorkingSet == null) {
202                 workList = graph.createIterativeNodeWorkList(wholeGraph, MAX_ITERATION_PER_NODE);
203             } else {
204                 workList = graph.createIterativeNodeWorkList(false, MAX_ITERATION_PER_NODE);
205                 workList.addAll(initWorkingSet);
206             }
207             if (!wholeGraph) {
208                 workList.addAll(graph.getNewNodes(newNodesMark));
209             }

210             tool = new Tool(graph.getAssumptions(), graph.getOptions());
211             processWorkSet(graph);
212         }
213 
214         @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">215         private void processWorkSet(StructuredGraph graph) {</span>

216             NodeEventListener listener = new NodeEventListener() {
217 
218                 @Override
219                 public void nodeAdded(Node node) {
220                     workList.add(node);
221                 }
222 
223                 @Override
224                 public void inputChanged(Node node) {
225                     workList.add(node);
226                     if (node instanceof IndirectCanonicalization) {
227                         for (Node usage : node.usages()) {
228                             workList.add(usage);
229                         }
230                     }







231                 }
232 
233                 @Override
234                 public void usagesDroppedToZero(Node node) {
235                     workList.add(node);
236                 }
237             };
238 
239             try (NodeEventScope nes = graph.trackNodeEvents(listener)) {
240                 for (Node n : workList) {
241                     boolean changed = processNode(n);
242                     if (changed &amp;&amp; debug.isDumpEnabled(DebugContext.DETAILED_LEVEL)) {
243                         debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;CanonicalizerPhase %s&quot;, n);
244                     }

245                 }
246             }

247         }
248 
249         /**
250          * @return true if the graph was changed.
251          */
252         private boolean processNode(Node node) {
253             if (!node.isAlive()) {
254                 return false;
255             }
256             COUNTER_PROCESSED_NODES.increment(debug);
257             if (GraphUtil.tryKillUnused(node)) {
258                 return true;
259             }
260             NodeClass&lt;?&gt; nodeClass = node.getNodeClass();
261             StructuredGraph graph = (StructuredGraph) node.graph();
262             if (tryCanonicalize(node, nodeClass)) {
263                 return true;
264             }
<span class="line-modified">265             if (globalValueNumber &amp;&amp; tryGlobalValueNumbering(node, nodeClass)) {</span>
266                 return true;
267             }
268             if (node instanceof ValueNode) {
269                 ValueNode valueNode = (ValueNode) node;
270                 boolean improvedStamp = tryInferStamp(valueNode);
271                 Constant constant = valueNode.stamp(NodeView.DEFAULT).asConstant();
272                 if (constant != null &amp;&amp; !(node instanceof ConstantNode)) {
273                     ConstantNode stampConstant = ConstantNode.forConstant(valueNode.stamp(NodeView.DEFAULT), constant, context.getMetaAccess(), graph);
274                     debug.log(&quot;Canonicalizer: constant stamp replaces %1s with %1s&quot;, valueNode, stampConstant);
275                     valueNode.replaceAtUsages(InputType.Value, stampConstant);
276                     GraphUtil.tryKillUnused(valueNode);
277                     return true;
278                 } else if (improvedStamp) {
279                     // the improved stamp may enable additional canonicalization
280                     if (tryCanonicalize(valueNode, nodeClass)) {
281                         return true;
282                     }
283                     valueNode.usages().forEach(workList::add);
284                 }
285             }
</pre>
<hr />
<pre>
300             return false;
301         }
302 
303         private AutoCloseable getCanonicalizeableContractAssertion(Node node) {
304             boolean needsAssertion = false;
305             assert (needsAssertion = true) == true;
306             if (needsAssertion) {
307                 Mark mark = node.graph().getMark();
308                 return () -&gt; {
309                     assert mark.equals(node.graph().getMark()) : &quot;new node created while canonicalizing &quot; + node.getClass().getSimpleName() + &quot; &quot; + node + &quot;: &quot; +
310                                     node.graph().getNewNodes(mark).snapshot();
311                 };
312             } else {
313                 return null;
314             }
315         }
316 
317         @SuppressWarnings(&quot;try&quot;)
318         public boolean tryCanonicalize(final Node node, NodeClass&lt;?&gt; nodeClass) {
319             try (DebugCloseable position = node.withNodeSourcePosition(); DebugContext.Scope scope = debug.withContext(node)) {
<span class="line-removed">320                 if (customCanonicalizer != null) {</span>
<span class="line-removed">321                     Node canonical = customCanonicalizer.canonicalize(node);</span>
<span class="line-removed">322                     if (performReplacement(node, canonical)) {</span>
<span class="line-removed">323                         return true;</span>
<span class="line-removed">324                     } else {</span>
<span class="line-removed">325                         customCanonicalizer.simplify(node, tool);</span>
<span class="line-removed">326                         if (node.isDeleted()) {</span>
<span class="line-removed">327                             return true;</span>
<span class="line-removed">328                         }</span>
<span class="line-removed">329                     }</span>
<span class="line-removed">330                 }</span>
331                 if (nodeClass.isCanonicalizable()) {
332                     COUNTER_CANONICALIZATION_CONSIDERED_NODES.increment(debug);
<span class="line-modified">333                     Node canonical;</span>
334                     try (AutoCloseable verify = getCanonicalizeableContractAssertion(node)) {
<span class="line-modified">335                         canonical = ((Canonicalizable) node).canonical(tool);</span>
<span class="line-modified">336                         if (canonical == node &amp;&amp; nodeClass.isCommutative()) {</span>
<span class="line-modified">337                             canonical = ((BinaryCommutative&lt;?&gt;) node).maybeCommuteInputs();</span>





338                         }
339                     } catch (Throwable e) {
340                         throw new GraalGraphError(e).addContext(node);
341                     }
342                     if (performReplacement(node, canonical)) {
343                         return true;
344                     }
345                 }
346 
<span class="line-modified">347                 if (nodeClass.isSimplifiable() &amp;&amp; simplify) {</span>
348                     debug.log(DebugContext.VERBOSE_LEVEL, &quot;Canonicalizer: simplifying %s&quot;, node);
349                     COUNTER_SIMPLIFICATION_CONSIDERED_NODES.increment(debug);
<span class="line-modified">350                     node.simplify(tool);</span>
<span class="line-modified">351                     if (node.isDeleted()) {</span>
<span class="line-modified">352                         debug.log(&quot;Canonicalizer: simplified %s&quot;, node);</span>





353                     }
354                     return node.isDeleted();
355                 }
356                 return false;
357             } catch (Throwable throwable) {
358                 throw debug.handle(throwable);
359             }
360         }
361 
362 // @formatter:off
363 //     cases:                                           original node:
364 //                                         |Floating|Fixed-unconnected|Fixed-connected|
365 //                                         --------------------------------------------
366 //                                     null|   1    |        X        |       3       |
367 //                                         --------------------------------------------
368 //                                 Floating|   2    |        X        |       4       |
369 //       canonical node:                   --------------------------------------------
370 //                        Fixed-unconnected|   X    |        X        |       5       |
371 //                                         --------------------------------------------
372 //                          Fixed-connected|   2    |        X        |       6       |
</pre>
<hr />
<pre>
489                 return context.getConstantFieldProvider();
490             }
491 
492             @Override
493             public void addToWorkList(Node node) {
494                 workList.add(node);
495             }
496 
497             @Override
498             public void addToWorkList(Iterable&lt;? extends Node&gt; nodes) {
499                 workList.addAll(nodes);
500             }
501 
502             @Override
503             public void removeIfUnused(Node node) {
504                 GraphUtil.tryKillUnused(node);
505             }
506 
507             @Override
508             public boolean canonicalizeReads() {
<span class="line-modified">509                 return canonicalizeReads;</span>
510             }
511 
512             @Override
513             public boolean allUsagesAvailable() {
514                 return true;
515             }
516 
517             @Override
518             public Assumptions getAssumptions() {
519                 return assumptions;
520             }
521 
522             @Override
523             public Integer smallestCompareWidth() {
524                 return context.getLowerer().smallestCompareWidth();
525             }
526 
527             @Override
528             public OptionValues getOptions() {
529                 return options;
530             }
531 
532             @Override
533             public Stamp stamp(ValueNode node) {
534                 return nodeView.stamp(node);
535             }
536         }
537     }
538 
539     public boolean getCanonicalizeReads() {
<span class="line-modified">540         return canonicalizeReads;</span>
541     }
542 
543 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.phases.common;
 26 
<span class="line-added"> 27 import static org.graalvm.compiler.phases.common.CanonicalizerPhase.CanonicalizerFeature.CFG_SIMPLIFICATION;</span>
<span class="line-added"> 28 import static org.graalvm.compiler.phases.common.CanonicalizerPhase.CanonicalizerFeature.GVN;</span>
<span class="line-added"> 29 import static org.graalvm.compiler.phases.common.CanonicalizerPhase.CanonicalizerFeature.READ_CANONICALIZATION;</span>
<span class="line-added"> 30 </span>
<span class="line-added"> 31 import java.util.EnumSet;</span>
<span class="line-added"> 32 </span>
 33 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 34 import org.graalvm.compiler.core.common.type.Stamp;
 35 import org.graalvm.compiler.debug.CounterKey;
 36 import org.graalvm.compiler.debug.DebugCloseable;
 37 import org.graalvm.compiler.debug.DebugContext;
 38 import org.graalvm.compiler.graph.GraalGraphError;
 39 import org.graalvm.compiler.graph.Graph;
 40 import org.graalvm.compiler.graph.Graph.Mark;
 41 import org.graalvm.compiler.graph.Graph.NodeEventListener;
 42 import org.graalvm.compiler.graph.Graph.NodeEventScope;
 43 import org.graalvm.compiler.graph.Node;
 44 import org.graalvm.compiler.graph.Node.IndirectCanonicalization;
 45 import org.graalvm.compiler.graph.NodeClass;
 46 import org.graalvm.compiler.graph.NodeWorkList;
 47 import org.graalvm.compiler.graph.spi.Canonicalizable;
 48 import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;
 49 import org.graalvm.compiler.graph.spi.SimplifierTool;
 50 import org.graalvm.compiler.nodeinfo.InputType;
<span class="line-added"> 51 import org.graalvm.compiler.nodes.AbstractBeginNode;</span>
 52 import org.graalvm.compiler.nodes.AbstractMergeNode;
 53 import org.graalvm.compiler.nodes.ConstantNode;
 54 import org.graalvm.compiler.nodes.ControlSinkNode;
 55 import org.graalvm.compiler.nodes.FixedNode;
 56 import org.graalvm.compiler.nodes.FixedWithNextNode;
 57 import org.graalvm.compiler.nodes.NodeView;
 58 import org.graalvm.compiler.nodes.StartNode;
 59 import org.graalvm.compiler.nodes.StructuredGraph;
 60 import org.graalvm.compiler.nodes.ValueNode;
 61 import org.graalvm.compiler.nodes.calc.FloatingNode;
<span class="line-added"> 62 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 63 import org.graalvm.compiler.nodes.util.GraphUtil;
 64 import org.graalvm.compiler.options.OptionValues;
 65 import org.graalvm.compiler.phases.BasePhase;
 66 import org.graalvm.compiler.phases.Phase;

 67 
 68 import jdk.vm.ci.meta.Assumptions;
 69 import jdk.vm.ci.meta.Constant;
 70 import jdk.vm.ci.meta.ConstantReflectionProvider;
 71 import jdk.vm.ci.meta.MetaAccessProvider;
 72 
<span class="line-modified"> 73 public class CanonicalizerPhase extends BasePhase&lt;CoreProviders&gt; {</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75     public enum CanonicalizerFeature {</span>
<span class="line-added"> 76         READ_CANONICALIZATION,</span>
<span class="line-added"> 77         CFG_SIMPLIFICATION,</span>
<span class="line-added"> 78         GVN</span>
<span class="line-added"> 79     }</span>
 80 
 81     private static final int MAX_ITERATION_PER_NODE = 10;
 82     private static final CounterKey COUNTER_CANONICALIZED_NODES = DebugContext.counter(&quot;CanonicalizedNodes&quot;);
 83     private static final CounterKey COUNTER_PROCESSED_NODES = DebugContext.counter(&quot;ProcessedNodes&quot;);
 84     private static final CounterKey COUNTER_CANONICALIZATION_CONSIDERED_NODES = DebugContext.counter(&quot;CanonicalizationConsideredNodes&quot;);
 85     private static final CounterKey COUNTER_INFER_STAMP_CALLED = DebugContext.counter(&quot;InferStampCalled&quot;);
 86     private static final CounterKey COUNTER_STAMP_CHANGED = DebugContext.counter(&quot;StampChanged&quot;);
 87     private static final CounterKey COUNTER_SIMPLIFICATION_CONSIDERED_NODES = DebugContext.counter(&quot;SimplificationConsideredNodes&quot;);
 88     private static final CounterKey COUNTER_GLOBAL_VALUE_NUMBERING_HITS = DebugContext.counter(&quot;GlobalValueNumberingHits&quot;);
 89 
<span class="line-modified"> 90     private final EnumSet&lt;CanonicalizerFeature&gt; features;</span>
<span class="line-modified"> 91     private final CustomCanonicalization customCanonicalization;</span>
<span class="line-modified"> 92     private final CustomSimplification customSimplification;</span>

 93 
<span class="line-modified"> 94     public interface CustomCanonicalization {</span>
<span class="line-added"> 95         /**</span>
<span class="line-added"> 96          * @param node the node to be canonicalized</span>
<span class="line-added"> 97          * @return the same node if no action should be taken, {@code null} if the node should be</span>
<span class="line-added"> 98          *         deleted, or a new node that should replace the given node</span>
<span class="line-added"> 99          */</span>
<span class="line-added">100         Node canonicalize(Node node);</span>
<span class="line-added">101     }</span>
102 
<span class="line-modified">103     public interface CustomSimplification {</span>
<span class="line-modified">104         /**</span>
<span class="line-modified">105          * @param node the node to be simplified</span>
<span class="line-added">106          * @param tool utility available during the simplification process</span>
<span class="line-added">107          */</span>
<span class="line-added">108         void simplify(Node node, SimplifierTool tool);</span>
<span class="line-added">109     }</span>
110 
<span class="line-modified">111     protected CanonicalizerPhase(EnumSet&lt;CanonicalizerFeature&gt; features) {</span>
<span class="line-modified">112         this(null, null, features);</span>
<span class="line-modified">113     }</span>
<span class="line-added">114 </span>
<span class="line-added">115     protected CanonicalizerPhase() {</span>
<span class="line-added">116         this(null, null, EnumSet.allOf(CanonicalizerFeature.class));</span>
<span class="line-added">117     }</span>
<span class="line-added">118 </span>
<span class="line-added">119     protected CanonicalizerPhase(CustomCanonicalization customCanonicalization, CustomSimplification customSimplification) {</span>
<span class="line-added">120         this(customCanonicalization, customSimplification, EnumSet.allOf(CanonicalizerFeature.class));</span>
<span class="line-added">121     }</span>
<span class="line-added">122 </span>
<span class="line-added">123     protected CanonicalizerPhase(CustomCanonicalization customCanonicalization, CustomSimplification customSimplification, EnumSet&lt;CanonicalizerFeature&gt; features) {</span>
<span class="line-added">124         this.customCanonicalization = customCanonicalization;</span>
<span class="line-added">125         this.customSimplification = customSimplification;</span>
<span class="line-added">126         this.features = features;</span>
<span class="line-added">127     }</span>
<span class="line-added">128 </span>
<span class="line-added">129     public CanonicalizerPhase copyWithCustomCanonicalization(CustomCanonicalization newCanonicalization) {</span>
<span class="line-added">130         return new CanonicalizerPhase(newCanonicalization, customSimplification, features);</span>
131     }
132 
<span class="line-modified">133     public CanonicalizerPhase copyWithCustomSimplification(CustomSimplification newSimplification) {</span>
<span class="line-modified">134         return new CanonicalizerPhase(customCanonicalization, newSimplification, features);</span>
135     }
136 
<span class="line-modified">137     public CanonicalizerPhase copyWithoutGVN() {</span>
<span class="line-modified">138         EnumSet&lt;CanonicalizerFeature&gt; newFeatures = EnumSet.copyOf(features);</span>
<span class="line-added">139         newFeatures.remove(GVN);</span>
<span class="line-added">140         return new CanonicalizerPhase(customCanonicalization, customSimplification, newFeatures);</span>
141     }
142 
<span class="line-modified">143     public CanonicalizerPhase copyWithoutSimplification() {</span>
<span class="line-modified">144         EnumSet&lt;CanonicalizerFeature&gt; newFeatures = EnumSet.copyOf(features);</span>
<span class="line-added">145         newFeatures.remove(CFG_SIMPLIFICATION);</span>
<span class="line-added">146         return new CanonicalizerPhase(customCanonicalization, customSimplification, newFeatures);</span>
147     }
148 
<span class="line-modified">149     public static CanonicalizerPhase create() {</span>
<span class="line-modified">150         return new CanonicalizerPhase(null, null, EnumSet.allOf(CanonicalizerFeature.class));</span>
151     }
152 
<span class="line-modified">153     public static CanonicalizerPhase createWithoutReadCanonicalization() {</span>
<span class="line-modified">154         return new CanonicalizerPhase(EnumSet.complementOf(EnumSet.of(READ_CANONICALIZATION)));</span>
<span class="line-added">155     }</span>
<span class="line-added">156 </span>
<span class="line-added">157     public static CanonicalizerPhase createWithoutGVN() {</span>
<span class="line-added">158         return new CanonicalizerPhase(EnumSet.complementOf(EnumSet.of(GVN)));</span>
<span class="line-added">159     }</span>
<span class="line-added">160 </span>
<span class="line-added">161     public static CanonicalizerPhase createWithoutCFGSimplification() {</span>
<span class="line-added">162         return new CanonicalizerPhase(EnumSet.complementOf(EnumSet.of(CFG_SIMPLIFICATION)));</span>
163     }
164 
165     @Override
166     public boolean checkContract() {
167         /*
168          * There are certain canonicalizations we make that heavily increase code size by e.g.
169          * replacing a merge followed by a return of the merge&#39;s phi with returns in each
170          * predecessor.
171          */
172         return false;
173     }
174 
175     @Override
<span class="line-modified">176     protected void run(StructuredGraph graph, CoreProviders context) {</span>
177         new Instance(context).run(graph);
178     }
179 
180     /**
181      * @param newNodesMark only the {@linkplain Graph#getNewNodes(Mark) new nodes} specified by this
182      *            mark are processed
183      */
<span class="line-modified">184     public void applyIncremental(StructuredGraph graph, CoreProviders context, Mark newNodesMark) {</span>
185         applyIncremental(graph, context, newNodesMark, true);
186     }
187 
<span class="line-modified">188     public void applyIncremental(StructuredGraph graph, CoreProviders context, Mark newNodesMark, boolean dumpGraph) {</span>
189         new Instance(context, newNodesMark).apply(graph, dumpGraph);
190     }
191 
192     /**
193      * @param workingSet the initial working set of nodes on which the canonicalizer works, should
194      *            be an auto-grow node bitmap
195      */
<span class="line-modified">196     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet) {</span>
197         applyIncremental(graph, context, workingSet, true);
198     }
199 
<span class="line-modified">200     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, boolean dumpGraph) {</span>
201         new Instance(context, workingSet).apply(graph, dumpGraph);
202     }
203 
<span class="line-modified">204     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark) {</span>
205         applyIncremental(graph, context, workingSet, newNodesMark, true);
206     }
207 
<span class="line-modified">208     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark, boolean dumpGraph) {</span>
209         new Instance(context, workingSet, newNodesMark).apply(graph, dumpGraph);
210     }
211 
212     public NodeView getNodeView() {
213         return NodeView.DEFAULT;
214     }
215 
216     private final class Instance extends Phase {
217 
218         private final Mark newNodesMark;
<span class="line-modified">219         private final CoreProviders context;</span>
220         private final Iterable&lt;? extends Node&gt; initWorkingSet;
221 
222         private NodeWorkList workList;
223         private Tool tool;
224         private DebugContext debug;
225 
<span class="line-modified">226         private Instance(CoreProviders context) {</span>
227             this(context, null, null);
228         }
229 
<span class="line-modified">230         private Instance(CoreProviders context, Iterable&lt;? extends Node&gt; workingSet) {</span>
231             this(context, workingSet, null);
232         }
233 
<span class="line-modified">234         private Instance(CoreProviders context, Mark newNodesMark) {</span>
235             this(context, null, newNodesMark);
236         }
237 
<span class="line-modified">238         private Instance(CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark) {</span>
239             this.newNodesMark = newNodesMark;
240             this.context = context;
241             this.initWorkingSet = workingSet;
242         }
243 
244         @Override
245         public boolean checkContract() {
246             return false;
247         }
248 
249         @Override
250         protected void run(StructuredGraph graph) {
251             this.debug = graph.getDebug();
252             boolean wholeGraph = newNodesMark == null || newNodesMark.isStart();
253             if (initWorkingSet == null) {
254                 workList = graph.createIterativeNodeWorkList(wholeGraph, MAX_ITERATION_PER_NODE);
255             } else {
256                 workList = graph.createIterativeNodeWorkList(false, MAX_ITERATION_PER_NODE);
257                 workList.addAll(initWorkingSet);
258             }
259             if (!wholeGraph) {
260                 workList.addAll(graph.getNewNodes(newNodesMark));
261             }
<span class="line-added">262 </span>
263             tool = new Tool(graph.getAssumptions(), graph.getOptions());
264             processWorkSet(graph);
265         }
266 
267         @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">268         private int processWorkSet(StructuredGraph graph) {</span>
<span class="line-added">269             int sum = 0;</span>
270             NodeEventListener listener = new NodeEventListener() {
271 
272                 @Override
273                 public void nodeAdded(Node node) {
274                     workList.add(node);
275                 }
276 
277                 @Override
278                 public void inputChanged(Node node) {
279                     workList.add(node);
280                     if (node instanceof IndirectCanonicalization) {
281                         for (Node usage : node.usages()) {
282                             workList.add(usage);
283                         }
284                     }
<span class="line-added">285 </span>
<span class="line-added">286                     if (node instanceof AbstractBeginNode) {</span>
<span class="line-added">287                         AbstractBeginNode abstractBeginNode = (AbstractBeginNode) node;</span>
<span class="line-added">288                         if (abstractBeginNode.predecessor() != null) {</span>
<span class="line-added">289                             workList.add(abstractBeginNode.predecessor());</span>
<span class="line-added">290                         }</span>
<span class="line-added">291                     }</span>
292                 }
293 
294                 @Override
295                 public void usagesDroppedToZero(Node node) {
296                     workList.add(node);
297                 }
298             };
299 
300             try (NodeEventScope nes = graph.trackNodeEvents(listener)) {
301                 for (Node n : workList) {
302                     boolean changed = processNode(n);
303                     if (changed &amp;&amp; debug.isDumpEnabled(DebugContext.DETAILED_LEVEL)) {
304                         debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;CanonicalizerPhase %s&quot;, n);
305                     }
<span class="line-added">306                     ++sum;</span>
307                 }
308             }
<span class="line-added">309             return sum;</span>
310         }
311 
312         /**
313          * @return true if the graph was changed.
314          */
315         private boolean processNode(Node node) {
316             if (!node.isAlive()) {
317                 return false;
318             }
319             COUNTER_PROCESSED_NODES.increment(debug);
320             if (GraphUtil.tryKillUnused(node)) {
321                 return true;
322             }
323             NodeClass&lt;?&gt; nodeClass = node.getNodeClass();
324             StructuredGraph graph = (StructuredGraph) node.graph();
325             if (tryCanonicalize(node, nodeClass)) {
326                 return true;
327             }
<span class="line-modified">328             if (features.contains(GVN) &amp;&amp; tryGlobalValueNumbering(node, nodeClass)) {</span>
329                 return true;
330             }
331             if (node instanceof ValueNode) {
332                 ValueNode valueNode = (ValueNode) node;
333                 boolean improvedStamp = tryInferStamp(valueNode);
334                 Constant constant = valueNode.stamp(NodeView.DEFAULT).asConstant();
335                 if (constant != null &amp;&amp; !(node instanceof ConstantNode)) {
336                     ConstantNode stampConstant = ConstantNode.forConstant(valueNode.stamp(NodeView.DEFAULT), constant, context.getMetaAccess(), graph);
337                     debug.log(&quot;Canonicalizer: constant stamp replaces %1s with %1s&quot;, valueNode, stampConstant);
338                     valueNode.replaceAtUsages(InputType.Value, stampConstant);
339                     GraphUtil.tryKillUnused(valueNode);
340                     return true;
341                 } else if (improvedStamp) {
342                     // the improved stamp may enable additional canonicalization
343                     if (tryCanonicalize(valueNode, nodeClass)) {
344                         return true;
345                     }
346                     valueNode.usages().forEach(workList::add);
347                 }
348             }
</pre>
<hr />
<pre>
363             return false;
364         }
365 
366         private AutoCloseable getCanonicalizeableContractAssertion(Node node) {
367             boolean needsAssertion = false;
368             assert (needsAssertion = true) == true;
369             if (needsAssertion) {
370                 Mark mark = node.graph().getMark();
371                 return () -&gt; {
372                     assert mark.equals(node.graph().getMark()) : &quot;new node created while canonicalizing &quot; + node.getClass().getSimpleName() + &quot; &quot; + node + &quot;: &quot; +
373                                     node.graph().getNewNodes(mark).snapshot();
374                 };
375             } else {
376                 return null;
377             }
378         }
379 
380         @SuppressWarnings(&quot;try&quot;)
381         public boolean tryCanonicalize(final Node node, NodeClass&lt;?&gt; nodeClass) {
382             try (DebugCloseable position = node.withNodeSourcePosition(); DebugContext.Scope scope = debug.withContext(node)) {











383                 if (nodeClass.isCanonicalizable()) {
384                     COUNTER_CANONICALIZATION_CONSIDERED_NODES.increment(debug);
<span class="line-modified">385                     Node canonical = node;</span>
386                     try (AutoCloseable verify = getCanonicalizeableContractAssertion(node)) {
<span class="line-modified">387                         if (customCanonicalization != null) {</span>
<span class="line-modified">388                             canonical = customCanonicalization.canonicalize(node);</span>
<span class="line-modified">389                         }</span>
<span class="line-added">390                         if (canonical == node) {</span>
<span class="line-added">391                             canonical = ((Canonicalizable) node).canonical(tool);</span>
<span class="line-added">392                             if (canonical == node &amp;&amp; nodeClass.isCommutative()) {</span>
<span class="line-added">393                                 canonical = ((BinaryCommutative&lt;?&gt;) node).maybeCommuteInputs();</span>
<span class="line-added">394                             }</span>
395                         }
396                     } catch (Throwable e) {
397                         throw new GraalGraphError(e).addContext(node);
398                     }
399                     if (performReplacement(node, canonical)) {
400                         return true;
401                     }
402                 }
403 
<span class="line-modified">404                 if (features.contains(CFG_SIMPLIFICATION) &amp;&amp; nodeClass.isSimplifiable()) {</span>
405                     debug.log(DebugContext.VERBOSE_LEVEL, &quot;Canonicalizer: simplifying %s&quot;, node);
406                     COUNTER_SIMPLIFICATION_CONSIDERED_NODES.increment(debug);
<span class="line-modified">407                     if (customSimplification != null) {</span>
<span class="line-modified">408                         customSimplification.simplify(node, tool);</span>
<span class="line-modified">409                     }</span>
<span class="line-added">410                     if (node.isAlive()) {</span>
<span class="line-added">411                         node.simplify(tool);</span>
<span class="line-added">412                         if (node.isDeleted()) {</span>
<span class="line-added">413                             debug.log(&quot;Canonicalizer: simplified %s&quot;, node);</span>
<span class="line-added">414                         }</span>
415                     }
416                     return node.isDeleted();
417                 }
418                 return false;
419             } catch (Throwable throwable) {
420                 throw debug.handle(throwable);
421             }
422         }
423 
424 // @formatter:off
425 //     cases:                                           original node:
426 //                                         |Floating|Fixed-unconnected|Fixed-connected|
427 //                                         --------------------------------------------
428 //                                     null|   1    |        X        |       3       |
429 //                                         --------------------------------------------
430 //                                 Floating|   2    |        X        |       4       |
431 //       canonical node:                   --------------------------------------------
432 //                        Fixed-unconnected|   X    |        X        |       5       |
433 //                                         --------------------------------------------
434 //                          Fixed-connected|   2    |        X        |       6       |
</pre>
<hr />
<pre>
551                 return context.getConstantFieldProvider();
552             }
553 
554             @Override
555             public void addToWorkList(Node node) {
556                 workList.add(node);
557             }
558 
559             @Override
560             public void addToWorkList(Iterable&lt;? extends Node&gt; nodes) {
561                 workList.addAll(nodes);
562             }
563 
564             @Override
565             public void removeIfUnused(Node node) {
566                 GraphUtil.tryKillUnused(node);
567             }
568 
569             @Override
570             public boolean canonicalizeReads() {
<span class="line-modified">571                 return features.contains(READ_CANONICALIZATION);</span>
572             }
573 
574             @Override
575             public boolean allUsagesAvailable() {
576                 return true;
577             }
578 
579             @Override
580             public Assumptions getAssumptions() {
581                 return assumptions;
582             }
583 
584             @Override
585             public Integer smallestCompareWidth() {
586                 return context.getLowerer().smallestCompareWidth();
587             }
588 
589             @Override
590             public OptionValues getOptions() {
591                 return options;
592             }
593 
594             @Override
595             public Stamp stamp(ValueNode node) {
596                 return nodeView.stamp(node);
597             }
598         }
599     }
600 
601     public boolean getCanonicalizeReads() {
<span class="line-modified">602         return features.contains(READ_CANONICALIZATION);</span>
603     }
604 
605 }
</pre>
</td>
</tr>
</table>
<center><a href="AddressLoweringByUsePhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConditionalEliminationPhase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
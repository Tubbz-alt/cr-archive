<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/inlining/InliningUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../UseTrappingNullChecksPhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="info/MultiTypeGuardInlineInfo.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/inlining/InliningUtil.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,10 ***</span>
<span class="line-new-header">--- 54,11 ---</span>
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.NodeInputList;
  import org.graalvm.compiler.graph.NodeMap;
  import org.graalvm.compiler.graph.NodeSourcePosition;
  import org.graalvm.compiler.graph.NodeWorkList;
<span class="line-added">+ import org.graalvm.compiler.nodeinfo.InputType;</span>
  import org.graalvm.compiler.nodeinfo.Verbosity;
  import org.graalvm.compiler.nodes.AbstractBeginNode;
  import org.graalvm.compiler.nodes.AbstractEndNode;
  import org.graalvm.compiler.nodes.AbstractMergeNode;
  import org.graalvm.compiler.nodes.BeginNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,11 ***</span>
  import org.graalvm.compiler.nodes.FrameState;
  import org.graalvm.compiler.nodes.InliningLog;
  import org.graalvm.compiler.nodes.Invoke;
  import org.graalvm.compiler.nodes.InvokeNode;
  import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
<span class="line-removed">- import org.graalvm.compiler.nodes.KillingBeginNode;</span>
  import org.graalvm.compiler.nodes.LogicNode;
  import org.graalvm.compiler.nodes.MergeNode;
  import org.graalvm.compiler.nodes.NodeView;
  import org.graalvm.compiler.nodes.ParameterNode;
  import org.graalvm.compiler.nodes.PhiNode;
<span class="line-new-header">--- 71,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,16 ***</span>
  import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
  import org.graalvm.compiler.nodes.UnwindNode;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.calc.IsNullNode;
  import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  import org.graalvm.compiler.nodes.extended.GuardingNode;
  import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
  import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  import org.graalvm.compiler.nodes.java.MonitorExitNode;
  import org.graalvm.compiler.nodes.java.MonitorIdNode;
<span class="line-removed">- import org.graalvm.compiler.nodes.spi.Replacements;</span>
  import org.graalvm.compiler.nodes.type.StampTool;
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
  import org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener;
  import org.graalvm.compiler.phases.util.ValueMergeUtil;
<span class="line-new-header">--- 86,16 ---</span>
  import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
  import org.graalvm.compiler.nodes.UnwindNode;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.calc.IsNullNode;
  import org.graalvm.compiler.nodes.extended.ForeignCallNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.extended.GuardedNode;</span>
  import org.graalvm.compiler.nodes.extended.GuardingNode;
  import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
  import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  import org.graalvm.compiler.nodes.java.MonitorExitNode;
  import org.graalvm.compiler.nodes.java.MonitorIdNode;
  import org.graalvm.compiler.nodes.type.StampTool;
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
  import org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener;
  import org.graalvm.compiler.phases.util.ValueMergeUtil;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 381,11 ***</span>
          FixedNode firstCFGNode = entryPointNode.next();
          if (firstCFGNode == null) {
              throw new IllegalStateException(&quot;Inlined graph is in invalid state: &quot; + inlineGraph);
          }
          for (Node node : inlineGraph.getNodes()) {
<span class="line-modified">!             if (node == entryPointNode || (node == entryPointNode.stateAfter() &amp;&amp; node.usages().count() == 1) || node instanceof ParameterNode) {</span>
                  // Do nothing.
              } else {
                  nodes.add(node);
                  if (node instanceof ReturnNode) {
                      returnNodes.add((ReturnNode) node);
<span class="line-new-header">--- 381,11 ---</span>
          FixedNode firstCFGNode = entryPointNode.next();
          if (firstCFGNode == null) {
              throw new IllegalStateException(&quot;Inlined graph is in invalid state: &quot; + inlineGraph);
          }
          for (Node node : inlineGraph.getNodes()) {
<span class="line-modified">!             if (node == entryPointNode || (node == entryPointNode.stateAfter() &amp;&amp; node.hasExactlyOneUsage()) || node instanceof ParameterNode) {</span>
                  // Do nothing.
              } else {
                  nodes.add(node);
                  if (node instanceof ReturnNode) {
                      returnNodes.add((ReturnNode) node);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 464,15 ***</span>
          }
          for (Invoke exit : partialIntrinsicExits) {
              // A partial intrinsic exit must be replaced with a call to
              // the intrinsified method.
              Invoke dup = (Invoke) duplicates.get(exit.asNode());
<span class="line-modified">!             if (dup instanceof InvokeNode) {</span>
<span class="line-removed">-                 ((InvokeNode) dup).replaceWithNewBci(invoke.bci());</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 ((InvokeWithExceptionNode) dup).replaceWithNewBci(invoke.bci());</span>
<span class="line-removed">-             }</span>
          }
          if (unwindNode != null) {
              unwindNode = (UnwindNode) duplicates.get(unwindNode);
          }
  
<span class="line-new-header">--- 464,11 ---</span>
          }
          for (Invoke exit : partialIntrinsicExits) {
              // A partial intrinsic exit must be replaced with a call to
              // the intrinsified method.
              Invoke dup = (Invoke) duplicates.get(exit.asNode());
<span class="line-modified">!             dup.replaceBci(invoke.bci());</span>
          }
          if (unwindNode != null) {
              unwindNode = (UnwindNode) duplicates.get(unwindNode);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 530,11 ***</span>
              InvokeWithExceptionNode invokeWithException = ((InvokeWithExceptionNode) invoke);
              if (unwindNode != null &amp;&amp; unwindNode.isAlive()) {
                  assert unwindNode.predecessor() != null;
                  assert invokeWithException.exceptionEdge().successors().count() == 1;
                  ExceptionObjectNode obj = (ExceptionObjectNode) invokeWithException.exceptionEdge();
<span class="line-modified">!                 obj.replaceAtUsages(unwindNode.exception());</span>
                  Node n = obj.next();
                  obj.setNext(null);
                  unwindNode.replaceAndDelete(n);
  
                  obj.replaceAtPredecessor(null);
<span class="line-new-header">--- 526,21 ---</span>
              InvokeWithExceptionNode invokeWithException = ((InvokeWithExceptionNode) invoke);
              if (unwindNode != null &amp;&amp; unwindNode.isAlive()) {
                  assert unwindNode.predecessor() != null;
                  assert invokeWithException.exceptionEdge().successors().count() == 1;
                  ExceptionObjectNode obj = (ExceptionObjectNode) invokeWithException.exceptionEdge();
<span class="line-modified">!                 /*</span>
<span class="line-added">+                  * The exception object node is a begin node, i.e., it can be used as an anchor for</span>
<span class="line-added">+                  * other nodes, thus we need to re-route them to a valid anchor, i.e. the begin node</span>
<span class="line-added">+                  * of the unwind block.</span>
<span class="line-added">+                  */</span>
<span class="line-added">+                 assert obj.usages().filter(x -&gt; x instanceof GuardedNode &amp;&amp; ((GuardedNode) x).getGuard() == obj).count() == 0 : &quot;Must not have guards attached to an exception object node&quot;;</span>
<span class="line-added">+                 AbstractBeginNode replacementAnchor = AbstractBeginNode.prevBegin(unwindNode);</span>
<span class="line-added">+                 assert replacementAnchor != null;</span>
<span class="line-added">+                 obj.replaceAtUsages(InputType.Anchor, replacementAnchor);</span>
<span class="line-added">+                 obj.replaceAtUsages(InputType.Value, unwindNode.exception());</span>
<span class="line-added">+ </span>
                  Node n = obj.next();
                  obj.setNext(null);
                  unwindNode.replaceAndDelete(n);
  
                  obj.replaceAtPredecessor(null);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 542,19 ***</span>
              } else {
                  invokeWithException.killExceptionEdge();
              }
  
              // get rid of memory kill
<span class="line-modified">!             AbstractBeginNode begin = invokeWithException.next();</span>
<span class="line-removed">-             if (begin instanceof KillingBeginNode) {</span>
<span class="line-removed">-                 try (DebugCloseable position = begin.withNodeSourcePosition()) {</span>
<span class="line-removed">-                     AbstractBeginNode newBegin = new BeginNode();</span>
<span class="line-removed">-                     graph.addAfterFixed(begin, graph.add(newBegin));</span>
<span class="line-removed">-                     begin.replaceAtUsages(newBegin);</span>
<span class="line-removed">-                     graph.removeFixed(begin);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
          } else {
              if (unwindNode != null &amp;&amp; unwindNode.isAlive()) {
                  try (DebugCloseable position = unwindNode.withNodeSourcePosition()) {
                      DeoptimizeNode deoptimizeNode = addDeoptimizeNode(graph, DeoptimizationAction.InvalidateRecompile, DeoptimizationReason.NotCompiledExceptionHandler);
                      unwindNode.replaceAndDelete(deoptimizeNode);
<span class="line-new-header">--- 548,11 ---</span>
              } else {
                  invokeWithException.killExceptionEdge();
              }
  
              // get rid of memory kill
<span class="line-modified">!             invokeWithException.killKillingBegin();</span>
          } else {
              if (unwindNode != null &amp;&amp; unwindNode.isAlive()) {
                  try (DebugCloseable position = unwindNode.withNodeSourcePosition()) {
                      DeoptimizeNode deoptimizeNode = addDeoptimizeNode(graph, DeoptimizationAction.InvalidateRecompile, DeoptimizationReason.NotCompiledExceptionHandler);
                      unwindNode.replaceAndDelete(deoptimizeNode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 740,11 ***</span>
      protected static void processFrameStates(Invoke invoke, StructuredGraph inlineGraph, EconomicMap&lt;Node, Node&gt; duplicates, FrameState stateAtExceptionEdge,
                      boolean alwaysDuplicateStateAfter) {
          FrameState stateAtReturn = invoke.stateAfter();
          FrameState outerFrameState = null;
          JavaKind invokeReturnKind = invoke.asNode().getStackKind();
<span class="line-modified">!         EconomicMap&lt;Node, Node&gt; replacements = EconomicMap.create();</span>
          for (FrameState original : inlineGraph.getNodes(FrameState.TYPE)) {
              FrameState frameState = (FrameState) duplicates.get(original);
              if (frameState != null &amp;&amp; frameState.isAlive()) {
                  if (outerFrameState == null) {
                      outerFrameState = stateAtReturn.duplicateModifiedDuringCall(invoke.bci(), invokeReturnKind);
<span class="line-new-header">--- 738,11 ---</span>
      protected static void processFrameStates(Invoke invoke, StructuredGraph inlineGraph, EconomicMap&lt;Node, Node&gt; duplicates, FrameState stateAtExceptionEdge,
                      boolean alwaysDuplicateStateAfter) {
          FrameState stateAtReturn = invoke.stateAfter();
          FrameState outerFrameState = null;
          JavaKind invokeReturnKind = invoke.asNode().getStackKind();
<span class="line-modified">!         EconomicMap&lt;Node, Node&gt; replacements = EconomicMap.create(Equivalence.IDENTITY);</span>
          for (FrameState original : inlineGraph.getNodes(FrameState.TYPE)) {
              FrameState frameState = (FrameState) duplicates.get(original);
              if (frameState != null &amp;&amp; frameState.isAlive()) {
                  if (outerFrameState == null) {
                      outerFrameState = stateAtReturn.duplicateModifiedDuringCall(invoke.bci(), invokeReturnKind);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 834,11 ***</span>
          }
          assert stateAfterReturn.bci != BytecodeFrame.UNKNOWN_BCI;
  
          // Return value does no longer need to be limited by the monitor exit.
          for (MonitorExitNode n : frameState.usages().filter(MonitorExitNode.class)) {
<span class="line-modified">!             n.clearEscapedReturnValue();</span>
          }
  
          frameState.replaceAndDelete(stateAfterReturn);
          return stateAfterReturn;
      }
<span class="line-new-header">--- 832,11 ---</span>
          }
          assert stateAfterReturn.bci != BytecodeFrame.UNKNOWN_BCI;
  
          // Return value does no longer need to be limited by the monitor exit.
          for (MonitorExitNode n : frameState.usages().filter(MonitorExitNode.class)) {
<span class="line-modified">!             n.clearEscapedValue();</span>
          }
  
          frameState.replaceAndDelete(stateAfterReturn);
          return stateAfterReturn;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1003,18 ***</span>
              }
              return newReceiver;
          }
      }
  
<span class="line-removed">-     public static boolean canIntrinsify(Replacements replacements, ResolvedJavaMethod target, int invokeBci) {</span>
<span class="line-removed">-         return replacements.hasSubstitution(target, invokeBci);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     public static StructuredGraph getIntrinsicGraph(Replacements replacements, ResolvedJavaMethod target, int invokeBci, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>
<span class="line-removed">-         return replacements.getSubstitution(target, invokeBci, trackNodeSourcePosition, replaceePosition);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * This method exclude InstrumentationNode from inlining heuristics.
       */
      public static int getNodeCount(StructuredGraph graph) {
          return graph.getNodeCount();
<span class="line-new-header">--- 1001,10 ---</span>
</pre>
<center><a href="../UseTrappingNullChecksPhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="info/MultiTypeGuardInlineInfo.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
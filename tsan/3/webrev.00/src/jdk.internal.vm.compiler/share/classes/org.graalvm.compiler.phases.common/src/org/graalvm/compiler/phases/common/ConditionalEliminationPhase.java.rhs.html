<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ConditionalEliminationPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.phases.common;
 26 
 27 import static org.graalvm.compiler.nodes.StaticDeoptimizingNode.mergeActions;
<a name="2" id="anc2"></a><span class="line-added"> 28 import static org.graalvm.compiler.phases.common.ConditionalEliminationUtil.getOtherSafeStamp;</span>
<span class="line-added"> 29 import static org.graalvm.compiler.phases.common.ConditionalEliminationUtil.getSafeStamp;</span>
<span class="line-added"> 30 import static org.graalvm.compiler.phases.common.ConditionalEliminationUtil.rewireGuards;</span>
 31 
 32 import java.util.ArrayDeque;
 33 import java.util.Deque;
 34 import java.util.List;
 35 
 36 import jdk.internal.vm.compiler.collections.EconomicMap;
 37 import jdk.internal.vm.compiler.collections.Equivalence;
 38 import jdk.internal.vm.compiler.collections.MapCursor;
 39 import jdk.internal.vm.compiler.collections.Pair;
 40 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;
 41 import org.graalvm.compiler.core.common.cfg.BlockMap;
 42 import org.graalvm.compiler.core.common.type.ArithmeticOpTable;
 43 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;
 44 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.And;
 45 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.Or;
 46 import org.graalvm.compiler.core.common.type.IntegerStamp;
 47 import org.graalvm.compiler.core.common.type.ObjectStamp;
 48 import org.graalvm.compiler.core.common.type.Stamp;
 49 import org.graalvm.compiler.core.common.type.StampFactory;
 50 import org.graalvm.compiler.debug.CounterKey;
 51 import org.graalvm.compiler.debug.DebugCloseable;
 52 import org.graalvm.compiler.debug.DebugContext;
 53 import org.graalvm.compiler.graph.Node;
 54 import org.graalvm.compiler.graph.NodeMap;
 55 import org.graalvm.compiler.graph.NodeStack;
 56 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 57 import org.graalvm.compiler.nodeinfo.InputType;
 58 import org.graalvm.compiler.nodes.AbstractBeginNode;
 59 import org.graalvm.compiler.nodes.AbstractMergeNode;
 60 import org.graalvm.compiler.nodes.BinaryOpLogicNode;
 61 import org.graalvm.compiler.nodes.ConditionAnchorNode;
<a name="3" id="anc3"></a><span class="line-added"> 62 import org.graalvm.compiler.nodes.DeoptimizeNode;</span>
 63 import org.graalvm.compiler.nodes.DeoptimizingGuard;
 64 import org.graalvm.compiler.nodes.EndNode;
 65 import org.graalvm.compiler.nodes.FixedGuardNode;
 66 import org.graalvm.compiler.nodes.FixedNode;
 67 import org.graalvm.compiler.nodes.FixedWithNextNode;
 68 import org.graalvm.compiler.nodes.GuardNode;
 69 import org.graalvm.compiler.nodes.IfNode;
 70 import org.graalvm.compiler.nodes.LogicConstantNode;
 71 import org.graalvm.compiler.nodes.LogicNode;
 72 import org.graalvm.compiler.nodes.LoopExitNode;
 73 import org.graalvm.compiler.nodes.MergeNode;
 74 import org.graalvm.compiler.nodes.NodeView;
<a name="4" id="anc4"></a>
 75 import org.graalvm.compiler.nodes.PiNode;
 76 import org.graalvm.compiler.nodes.ProxyNode;
<a name="5" id="anc5"></a>
 77 import org.graalvm.compiler.nodes.StructuredGraph;
 78 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 79 import org.graalvm.compiler.nodes.UnaryOpLogicNode;
 80 import org.graalvm.compiler.nodes.ValueNode;
 81 import org.graalvm.compiler.nodes.ValuePhiNode;
 82 import org.graalvm.compiler.nodes.calc.AndNode;
<a name="6" id="anc6"></a>

 83 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
<a name="7" id="anc7"></a>
 84 import org.graalvm.compiler.nodes.cfg.Block;
 85 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 86 import org.graalvm.compiler.nodes.extended.GuardingNode;
 87 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
 88 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 89 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;
<a name="8" id="anc8"></a><span class="line-added"> 90 import org.graalvm.compiler.nodes.java.InstanceOfNode;</span>
 91 import org.graalvm.compiler.nodes.java.TypeSwitchNode;
<a name="9" id="anc9"></a><span class="line-added"> 92 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 93 import org.graalvm.compiler.nodes.spi.NodeWithState;
 94 import org.graalvm.compiler.nodes.spi.StampInverter;
 95 import org.graalvm.compiler.nodes.util.GraphUtil;
 96 import org.graalvm.compiler.phases.BasePhase;
<a name="10" id="anc10"></a><span class="line-added"> 97 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.GuardFolding;</span>
<span class="line-added"> 98 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.GuardRewirer;</span>
<span class="line-added"> 99 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.GuardedCondition;</span>
<span class="line-added">100 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.InfoElement;</span>
<span class="line-added">101 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.InfoElementProvider;</span>
<span class="line-added">102 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.InputFilter;</span>
<span class="line-added">103 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.Marks;</span>
104 import org.graalvm.compiler.phases.schedule.SchedulePhase;
105 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
<a name="11" id="anc11"></a>
106 
107 import jdk.vm.ci.meta.DeoptimizationAction;
<a name="12" id="anc12"></a>
108 import jdk.vm.ci.meta.SpeculationLog.Speculation;
109 import jdk.vm.ci.meta.TriState;
110 
<a name="13" id="anc13"></a><span class="line-modified">111 public class ConditionalEliminationPhase extends BasePhase&lt;CoreProviders&gt; {</span>
112 
113     private static final CounterKey counterStampsRegistered = DebugContext.counter(&quot;StampsRegistered&quot;);
<a name="14" id="anc14"></a>
114     private static final CounterKey counterIfsKilled = DebugContext.counter(&quot;CE_KilledIfs&quot;);
115     private static final CounterKey counterPhiStampsImproved = DebugContext.counter(&quot;CE_ImprovedPhis&quot;);
116     private final boolean fullSchedule;
117     private final boolean moveGuards;
118 
119     public ConditionalEliminationPhase(boolean fullSchedule) {
120         this(fullSchedule, true);
121     }
122 
123     public ConditionalEliminationPhase(boolean fullSchedule, boolean moveGuards) {
124         this.fullSchedule = fullSchedule;
125         this.moveGuards = moveGuards;
126     }
127 
128     @Override
129     @SuppressWarnings(&quot;try&quot;)
<a name="15" id="anc15"></a><span class="line-modified">130     protected void run(StructuredGraph graph, CoreProviders context) {</span>
131         try (DebugContext.Scope s = graph.getDebug().scope(&quot;DominatorConditionalElimination&quot;)) {
132             BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes = null;
133             NodeMap&lt;Block&gt; nodeToBlock = null;
134             ControlFlowGraph cfg = ControlFlowGraph.compute(graph, true, true, true, true);
135             if (fullSchedule) {
136                 if (moveGuards) {
137                     cfg.visitDominatorTree(new MoveGuardsUpwards(), graph.hasValueProxies());
138                 }
139                 try (DebugContext.Scope scheduleScope = graph.getDebug().scope(SchedulePhase.class)) {
140                     SchedulePhase.run(graph, SchedulingStrategy.EARLIEST_WITH_GUARD_ORDER, cfg);
141                 } catch (Throwable t) {
142                     throw graph.getDebug().handle(t);
143                 }
144                 ScheduleResult r = graph.getLastSchedule();
145                 blockToNodes = r.getBlockToNodesMap();
146                 nodeToBlock = r.getNodeToBlockMap();
147             } else {
148                 nodeToBlock = cfg.getNodeToBlock();
149                 blockToNodes = getBlockToNodes(cfg);
150             }
151             ControlFlowGraph.RecursiveVisitor&lt;?&gt; visitor = createVisitor(graph, cfg, blockToNodes, nodeToBlock, context);
152             cfg.visitDominatorTree(visitor, graph.hasValueProxies());
153         }
154     }
155 
156     protected BlockMap&lt;List&lt;Node&gt;&gt; getBlockToNodes(@SuppressWarnings(&quot;unused&quot;) ControlFlowGraph cfg) {
157         return null;
158     }
159 
160     protected ControlFlowGraph.RecursiveVisitor&lt;?&gt; createVisitor(StructuredGraph graph, @SuppressWarnings(&quot;unused&quot;) ControlFlowGraph cfg, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes,
<a name="16" id="anc16"></a><span class="line-modified">161                     NodeMap&lt;Block&gt; nodeToBlock, CoreProviders context) {</span>
162         return new Instance(graph, blockToNodes, nodeToBlock, context);
163     }
164 
165     public static class MoveGuardsUpwards implements ControlFlowGraph.RecursiveVisitor&lt;Block&gt; {
166 
167         Block anchorBlock;
168 
169         @Override
170         @SuppressWarnings(&quot;try&quot;)
171         public Block enter(Block b) {
172             Block oldAnchorBlock = anchorBlock;
173             if (b.getDominator() == null || b.getDominator().getPostdominator() != b) {
174                 // New anchor.
175                 anchorBlock = b;
176             }
177 
178             AbstractBeginNode beginNode = b.getBeginNode();
179             if (beginNode instanceof AbstractMergeNode &amp;&amp; anchorBlock != b) {
180                 AbstractMergeNode mergeNode = (AbstractMergeNode) beginNode;
<a name="17" id="anc17"></a><span class="line-modified">181                 mergeNode.replaceAtUsages(InputType.Anchor, anchorBlock.getBeginNode());</span>
<span class="line-modified">182                 mergeNode.replaceAtUsages(InputType.Guard, anchorBlock.getBeginNode());</span>
<span class="line-modified">183                 assert mergeNode.anchored().isEmpty();</span>





184             }
185 
186             FixedNode endNode = b.getEndNode();
187             if (endNode instanceof IfNode) {
188                 IfNode node = (IfNode) endNode;
189 
190                 // Check if we can move guards upwards.
191                 AbstractBeginNode trueSuccessor = node.trueSuccessor();
<a name="18" id="anc18"></a><span class="line-added">192                 AbstractBeginNode falseSuccessor = node.falseSuccessor();</span>
<span class="line-added">193 </span>
194                 EconomicMap&lt;LogicNode, GuardNode&gt; trueGuards = EconomicMap.create(Equivalence.IDENTITY);
195                 for (GuardNode guard : trueSuccessor.guards()) {
196                     LogicNode condition = guard.getCondition();
197                     if (condition.hasMoreThanOneUsage()) {
198                         trueGuards.put(condition, guard);
199                     }
200                 }
201 
202                 if (!trueGuards.isEmpty()) {
<a name="19" id="anc19"></a><span class="line-modified">203                     for (GuardNode guard : falseSuccessor.guards().snapshot()) {</span>
204                         GuardNode otherGuard = trueGuards.get(guard.getCondition());
205                         if (otherGuard != null &amp;&amp; guard.isNegated() == otherGuard.isNegated()) {
206                             Speculation speculation = otherGuard.getSpeculation();
207                             if (speculation == null) {
208                                 speculation = guard.getSpeculation();
209                             } else if (guard.getSpeculation() != null &amp;&amp; guard.getSpeculation() != speculation) {
210                                 // Cannot optimize due to different speculations.
211                                 continue;
212                             }
213                             try (DebugCloseable closeable = guard.withNodeSourcePosition()) {
214                                 GuardNode newlyCreatedGuard = new GuardNode(guard.getCondition(), anchorBlock.getBeginNode(), guard.getReason(), guard.getAction(), guard.isNegated(), speculation,
215                                                 guard.getNoDeoptSuccessorPosition());
216                                 GuardNode newGuard = node.graph().unique(newlyCreatedGuard);
217                                 if (otherGuard.isAlive()) {
<a name="20" id="anc20"></a><span class="line-modified">218                                     if (trueSuccessor instanceof LoopExitNode &amp;&amp; beginNode.graph().hasValueProxies()) {</span>
<span class="line-added">219                                         otherGuard.replaceAndDelete(ProxyNode.forGuard(newGuard, (LoopExitNode) trueSuccessor));</span>
<span class="line-added">220                                     } else {</span>
<span class="line-added">221                                         otherGuard.replaceAndDelete(newGuard);</span>
<span class="line-added">222                                     }</span>
<span class="line-added">223                                 }</span>
<span class="line-added">224                                 if (falseSuccessor instanceof LoopExitNode &amp;&amp; beginNode.graph().hasValueProxies()) {</span>
<span class="line-added">225                                     guard.replaceAndDelete(ProxyNode.forGuard(newGuard, (LoopExitNode) falseSuccessor));</span>
<span class="line-added">226                                 } else {</span>
<span class="line-added">227                                     guard.replaceAndDelete(newGuard);</span>
228                                 }
<a name="21" id="anc21"></a>
229                             }
230                         }
231                     }
232                 }
233             }
234             return oldAnchorBlock;
235         }
236 
237         @Override
238         public void exit(Block b, Block value) {
239             anchorBlock = value;
240         }
241 
242     }
243 
244     private static final class PhiInfoElement {
245 
246         private EconomicMap&lt;EndNode, InfoElement&gt; infoElements;
247 
248         public void set(EndNode end, InfoElement infoElement) {
249             if (infoElements == null) {
250                 infoElements = EconomicMap.create(Equivalence.IDENTITY);
251             }
252             infoElements.put(end, infoElement);
253         }
254 
255         public InfoElement get(EndNode end) {
256             if (infoElements == null) {
257                 return null;
258             }
259             return infoElements.get(end);
260         }
261     }
262 
<a name="22" id="anc22"></a>

































263     public static class Instance implements ControlFlowGraph.RecursiveVisitor&lt;Marks&gt; {
264         protected final NodeMap&lt;InfoElement&gt; map;
265         protected final BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes;
266         protected final NodeMap&lt;Block&gt; nodeToBlock;
267         protected final CanonicalizerTool tool;
268         protected final NodeStack undoOperations;
269         protected final StructuredGraph graph;
270         protected final DebugContext debug;
271         protected final EconomicMap&lt;MergeNode, EconomicMap&lt;ValuePhiNode, PhiInfoElement&gt;&gt; mergeMaps;
<a name="23" id="anc23"></a><span class="line-added">272         private final InfoElementProvider infoElementProvider;</span>
<span class="line-added">273         private final GuardFolding guardFolding;</span>
274 
275         protected final ArrayDeque&lt;GuardedCondition&gt; conditions;
276 
277         /**
278          * Tests which may be eliminated because post dominating tests to prove a broader condition.
279          */
280         private Deque&lt;DeoptimizingGuard&gt; pendingTests;
281 
<a name="24" id="anc24"></a><span class="line-modified">282         public Instance(StructuredGraph graph, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes, NodeMap&lt;Block&gt; nodeToBlock, CoreProviders context) {</span>
283             this.graph = graph;
284             this.debug = graph.getDebug();
285             this.blockToNodes = blockToNodes;
286             this.nodeToBlock = nodeToBlock;
287             this.undoOperations = new NodeStack();
288             this.map = graph.createNodeMap();
289             this.pendingTests = new ArrayDeque&lt;&gt;();
290             this.conditions = new ArrayDeque&lt;&gt;();
291             tool = GraphUtil.getDefaultSimplifier(context.getMetaAccess(), context.getConstantReflection(), context.getConstantFieldProvider(), false, graph.getAssumptions(), graph.getOptions(),
292                             context.getLowerer());
<a name="25" id="anc25"></a><span class="line-modified">293             mergeMaps = EconomicMap.create(Equivalence.IDENTITY);</span>
<span class="line-added">294             infoElementProvider = new InfoElementProvider() {</span>
<span class="line-added">295 </span>
<span class="line-added">296                 @Override</span>
<span class="line-added">297                 public InfoElement infoElements(ValueNode value) {</span>
<span class="line-added">298                     return getInfoElements(value);</span>
<span class="line-added">299                 }</span>
<span class="line-added">300             };</span>
<span class="line-added">301             guardFolding = new GuardFolding() {</span>
<span class="line-added">302 </span>
<span class="line-added">303                 @Override</span>
<span class="line-added">304                 public boolean foldGuard(DeoptimizingGuard thisGuard, ValueNode original, Stamp newStamp, GuardRewirer rewireGuardFunction) {</span>
<span class="line-added">305                     return foldPendingTest(thisGuard, original, newStamp, rewireGuardFunction);</span>
<span class="line-added">306                 }</span>
<span class="line-added">307             };</span>
308         }
309 
310         protected void processConditionAnchor(ConditionAnchorNode node) {
<a name="26" id="anc26"></a><span class="line-modified">311             tryProveGuardCondition(null, node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
312                 if (result != node.isNegated()) {
313                     node.replaceAtUsages(guard.asNode());
314                     GraphUtil.unlinkFixedNode(node);
315                     GraphUtil.killWithUnusedFloatingInputs(node);
316                 } else {
317                     ValueAnchorNode valueAnchor = node.graph().add(new ValueAnchorNode(null));
318                     node.replaceAtUsages(valueAnchor);
319                     node.graph().replaceFixedWithFixed(node, valueAnchor);
320                 }
321                 return true;
322             });
323         }
324 
325         protected void processGuard(GuardNode node) {
326             if (!tryProveGuardCondition(node, node.getCondition(), (guard, result, guardedValueStamp, newInput) -&gt; {
327                 if (result != node.isNegated()) {
328                     node.replaceAndDelete(guard.asNode());
<a name="27" id="anc27"></a><span class="line-added">329                     if (guard instanceof DeoptimizingGuard &amp;&amp; !((DeoptimizingGuard) guard).isNegated()) {</span>
<span class="line-added">330                         rebuildPiNodes((DeoptimizingGuard) guard);</span>
<span class="line-added">331                     }</span>
332                 } else {
<a name="28" id="anc28"></a>








333                     AbstractBeginNode beginNode = (AbstractBeginNode) node.getAnchor();
<a name="29" id="anc29"></a>
334 
<a name="30" id="anc30"></a><span class="line-added">335                     if (beginNode.next() instanceof DeoptimizeNode) {</span>
<span class="line-added">336                         // This branch is already dead.</span>
<span class="line-added">337                     } else {</span>
<span class="line-added">338                         /*</span>
<span class="line-added">339                          * Don&#39;t kill this branch immediately because `killCFG` can have complex</span>
<span class="line-added">340                          * implications in the presence of loops: it might replace or delete nodes</span>
<span class="line-added">341                          * in other branches or even above the kill point. Instead of killing</span>
<span class="line-added">342                          * immediately, just leave the graph in a state that is easy to simplify by</span>
<span class="line-added">343                          * a subsequent canonicalizer phase.</span>
<span class="line-added">344                          */</span>
<span class="line-added">345                         FixedGuardNode deopt = new FixedGuardNode(LogicConstantNode.forBoolean(result, node.graph()), node.getReason(), node.getAction(), node.getSpeculation(), node.isNegated(),</span>
<span class="line-added">346                                         node.getNodeSourcePosition());</span>
<span class="line-added">347                         graph.addAfterFixed(beginNode, node.graph().add(deopt));</span>
<span class="line-added">348                     }</span>
349                 }
350                 return true;
351             })) {
352                 registerNewCondition(node.getCondition(), node.isNegated(), node);
353             }
354         }
355 
356         protected void processFixedGuard(FixedGuardNode node) {
357             if (!tryProveGuardCondition(node, node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {
358                 if (result != node.isNegated()) {
359                     node.replaceAtUsages(guard.asNode());
360                     GraphUtil.unlinkFixedNode(node);
361                     GraphUtil.killWithUnusedFloatingInputs(node);
<a name="31" id="anc31"></a><span class="line-added">362                     if (guard instanceof DeoptimizingGuard &amp;&amp; !((DeoptimizingGuard) guard).isNegated()) {</span>
<span class="line-added">363                         rebuildPiNodes((DeoptimizingGuard) guard);</span>
<span class="line-added">364                     }</span>
365                 } else {
366                     node.setCondition(LogicConstantNode.forBoolean(result, node.graph()), node.isNegated());
367                     // Don&#39;t kill this branch immediately, see `processGuard`.
368                 }
<a name="32" id="anc32"></a><span class="line-modified">369 </span>
<span class="line-added">370                 debug.log(&quot;Kill fixed guard %s&quot;, node);</span>
371                 return true;
372             })) {
373                 registerNewCondition(node.condition(), node.isNegated(), node);
374             }
375         }
376 
<a name="33" id="anc33"></a><span class="line-added">377         private void rebuildPiNodes(DeoptimizingGuard guard) {</span>
<span class="line-added">378             LogicNode newCondition = guard.getCondition();</span>
<span class="line-added">379             if (newCondition instanceof InstanceOfNode) {</span>
<span class="line-added">380                 InstanceOfNode inst = (InstanceOfNode) newCondition;</span>
<span class="line-added">381                 ValueNode originalValue = GraphUtil.skipPi(inst.getValue());</span>
<span class="line-added">382                 PiNode pi = null;</span>
<span class="line-added">383                 // Ensure that any Pi that&#39;s weaker than what the instanceof proves is</span>
<span class="line-added">384                 // replaced by one derived from the instanceof itself.</span>
<span class="line-added">385                 for (PiNode existing : guard.asNode().usages().filter(PiNode.class).snapshot()) {</span>
<span class="line-added">386                     if (!existing.isAlive()) {</span>
<span class="line-added">387                         continue;</span>
<span class="line-added">388                     }</span>
<span class="line-added">389                     if (originalValue != GraphUtil.skipPi(existing.object())) {</span>
<span class="line-added">390                         // Somehow these are unrelated values so leave it alone</span>
<span class="line-added">391                         continue;</span>
<span class="line-added">392                     }</span>
<span class="line-added">393                     // If the pi has a weaker stamp or the same stamp but a different input</span>
<span class="line-added">394                     // then replace it.</span>
<span class="line-added">395                     boolean strongerStamp = !existing.piStamp().join(inst.getCheckedStamp()).equals(inst.getCheckedStamp());</span>
<span class="line-added">396                     boolean differentCheckedStamp = !existing.piStamp().equals(inst.getCheckedStamp());</span>
<span class="line-added">397                     boolean differentObject = existing.object() != inst.getValue();</span>
<span class="line-added">398                     if (!strongerStamp &amp;&amp; (differentCheckedStamp || differentObject)) {</span>
<span class="line-added">399                         if (pi == null) {</span>
<span class="line-added">400                             pi = graph.unique(new PiNode(inst.getValue(), inst.getCheckedStamp(), (ValueNode) guard));</span>
<span class="line-added">401                         }</span>
<span class="line-added">402                         if (!pi.stamp(NodeView.DEFAULT).join(existing.stamp(NodeView.DEFAULT)).equals(pi.stamp(NodeView.DEFAULT))) {</span>
<span class="line-added">403                             /*</span>
<span class="line-added">404                              * With a code sequence like null check, type check, null check of type</span>
<span class="line-added">405                              * checked value, CE will use the first null check to prove the second</span>
<span class="line-added">406                              * null check so the graph ends up a Pi guarded by the first null check</span>
<span class="line-added">407                              * but consuming the output Pi from the type check check. In this case</span>
<span class="line-added">408                              * we should still canonicalize the checked stamp for consistency.</span>
<span class="line-added">409                              */</span>
<span class="line-added">410                             if (differentCheckedStamp) {</span>
<span class="line-added">411                                 PiNode alternatePi = graph.unique(new PiNode(existing.object(), inst.getCheckedStamp(), (ValueNode) guard));</span>
<span class="line-added">412                                 /*</span>
<span class="line-added">413                                  * If the resulting stamp is as good or better then do the</span>
<span class="line-added">414                                  * replacement. However when interface types are involved it&#39;s</span>
<span class="line-added">415                                  * possible that improving the checked stamp merges types which</span>
<span class="line-added">416                                  * appear unrelated so there&#39;s we must skip the replacement.</span>
<span class="line-added">417                                  */</span>
<span class="line-added">418                                 if (alternatePi.stamp(NodeView.DEFAULT).join(existing.stamp(NodeView.DEFAULT)).equals(alternatePi.stamp(NodeView.DEFAULT))) {</span>
<span class="line-added">419                                     existing.replaceAndDelete(alternatePi);</span>
<span class="line-added">420                                 }</span>
<span class="line-added">421                             }</span>
<span class="line-added">422                             continue;</span>
<span class="line-added">423                         }</span>
<span class="line-added">424                         existing.replaceAndDelete(pi);</span>
<span class="line-added">425                     }</span>
<span class="line-added">426                 }</span>
<span class="line-added">427             }</span>
<span class="line-added">428         }</span>
<span class="line-added">429 </span>
430         protected void processIf(IfNode node) {
<a name="34" id="anc34"></a><span class="line-modified">431             tryProveGuardCondition(null, node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
432                 node.setCondition(LogicConstantNode.forBoolean(result, node.graph()));
433                 AbstractBeginNode survivingSuccessor = node.getSuccessor(result);
434                 survivingSuccessor.replaceAtUsages(InputType.Guard, guard.asNode());
435                 // Don&#39;t kill the other branch immediately, see `processGuard`.
436                 counterIfsKilled.increment(debug);
437                 return true;
438             });
439         }
440 
441         @Override
442         public Marks enter(Block block) {
443             int infoElementsMark = undoOperations.size();
444             int conditionsMark = conditions.size();
445             debug.log(&quot;[Pre Processing block %s]&quot;, block);
446             // For now conservatively collect guards only within the same block.
447             pendingTests.clear();
448             processNodes(block);
449             return new Marks(infoElementsMark, conditionsMark);
450         }
451 
452         protected void processNodes(Block block) {
453             if (blockToNodes != null) {
454                 for (Node n : blockToNodes.get(block)) {
455                     if (n.isAlive()) {
456                         processNode(n);
457                     }
458                 }
459             } else {
460                 processBlock(block);
461             }
462         }
463 
464         private void processBlock(Block block) {
465             FixedNode n = block.getBeginNode();
466             FixedNode endNode = block.getEndNode();
467             debug.log(&quot;[Processing block %s]&quot;, block);
468             while (n != endNode) {
469                 if (n.isDeleted() || endNode.isDeleted()) {
470                     // This branch was deleted!
471                     return;
472                 }
473                 FixedNode next = ((FixedWithNextNode) n).next();
474                 processNode(n);
475                 n = next;
476             }
477             if (endNode.isAlive()) {
478                 processNode(endNode);
479             }
480         }
481 
482         @SuppressWarnings(&quot;try&quot;)
483         protected void processNode(Node node) {
484             try (DebugCloseable closeable = node.withNodeSourcePosition()) {
485                 if (node instanceof NodeWithState &amp;&amp; !(node instanceof GuardingNode)) {
486                     pendingTests.clear();
487                 }
488 
489                 if (node instanceof MergeNode) {
490                     introducePisForPhis((MergeNode) node);
491                 }
492 
493                 if (node instanceof AbstractBeginNode) {
494                     if (node instanceof LoopExitNode &amp;&amp; graph.hasValueProxies()) {
495                         // Condition must not be used down this path.
496                         return;
497                     }
498                     processAbstractBegin((AbstractBeginNode) node);
499                 } else if (node instanceof FixedGuardNode) {
500                     processFixedGuard((FixedGuardNode) node);
501                 } else if (node instanceof GuardNode) {
502                     processGuard((GuardNode) node);
503                 } else if (node instanceof ConditionAnchorNode) {
504                     processConditionAnchor((ConditionAnchorNode) node);
505                 } else if (node instanceof IfNode) {
506                     processIf((IfNode) node);
507                 } else if (node instanceof EndNode) {
508                     processEnd((EndNode) node);
509                 }
510             }
511         }
512 
513         protected void introducePisForPhis(MergeNode merge) {
514             EconomicMap&lt;ValuePhiNode, PhiInfoElement&gt; mergeMap = this.mergeMaps.get(merge);
515             if (mergeMap != null) {
516                 MapCursor&lt;ValuePhiNode, PhiInfoElement&gt; entries = mergeMap.getEntries();
517                 while (entries.advance()) {
518                     ValuePhiNode phi = entries.getKey();
519                     assert phi.isAlive() || phi.isDeleted();
520                     /*
521                      * Phi might have been killed already via a conditional elimination in another
522                      * branch.
523                      */
524                     if (phi.isDeleted()) {
525                         continue;
526                     }
527                     PhiInfoElement phiInfoElements = entries.getValue();
528                     Stamp bestPossibleStamp = null;
529                     for (int i = 0; i &lt; phi.valueCount(); ++i) {
530                         ValueNode valueAt = phi.valueAt(i);
531                         Stamp curBestStamp = valueAt.stamp(NodeView.DEFAULT);
532                         InfoElement infoElement = phiInfoElements.get(merge.forwardEndAt(i));
533                         if (infoElement != null) {
534                             curBestStamp = curBestStamp.join(infoElement.getStamp());
535                         }
536 
537                         if (bestPossibleStamp == null) {
538                             bestPossibleStamp = curBestStamp;
539                         } else {
540                             bestPossibleStamp = bestPossibleStamp.meet(curBestStamp);
541                         }
542                     }
543 
544                     Stamp oldStamp = phi.stamp(NodeView.DEFAULT);
545                     if (oldStamp.tryImproveWith(bestPossibleStamp) != null) {
546 
547                         // Need to be careful to not run into stamp update cycles with the iterative
548                         // canonicalization.
549                         boolean allow = false;
550                         if (bestPossibleStamp instanceof ObjectStamp) {
551                             // Always allow object stamps.
552                             allow = true;
553                         } else if (bestPossibleStamp instanceof IntegerStamp) {
554                             IntegerStamp integerStamp = (IntegerStamp) bestPossibleStamp;
555                             IntegerStamp oldIntegerStamp = (IntegerStamp) oldStamp;
556                             if (integerStamp.isPositive() != oldIntegerStamp.isPositive()) {
557                                 allow = true;
558                             } else if (integerStamp.isNegative() != oldIntegerStamp.isNegative()) {
559                                 allow = true;
560                             } else if (integerStamp.isStrictlyPositive() != oldIntegerStamp.isStrictlyPositive()) {
561                                 allow = true;
562                             } else if (integerStamp.isStrictlyNegative() != oldIntegerStamp.isStrictlyNegative()) {
563                                 allow = true;
564                             } else if (integerStamp.asConstant() != null) {
565                                 allow = true;
566                             } else if (oldStamp.isUnrestricted()) {
567                                 allow = true;
568                             }
569                         } else {
<a name="35" id="anc35"></a><span class="line-added">570                             // Fortify: Suppress Null Dereference false positive</span>
<span class="line-added">571                             assert bestPossibleStamp != null;</span>
572                             allow = (bestPossibleStamp.asConstant() != null);
573                         }
574 
575                         if (allow) {
576                             ValuePhiNode newPhi = graph.addWithoutUnique(new ValuePhiNode(bestPossibleStamp, merge));
577                             for (int i = 0; i &lt; phi.valueCount(); ++i) {
578                                 ValueNode valueAt = phi.valueAt(i);
579                                 if (bestPossibleStamp.meet(valueAt.stamp(NodeView.DEFAULT)).equals(bestPossibleStamp)) {
580                                     // Pi not required here.
581                                 } else {
582                                     InfoElement infoElement = phiInfoElements.get(merge.forwardEndAt(i));
583                                     assert infoElement != null;
584                                     Stamp curBestStamp = infoElement.getStamp();
585                                     ValueNode input = infoElement.getProxifiedInput();
586                                     if (input == null) {
587                                         input = valueAt;
588                                     }
<a name="36" id="anc36"></a><span class="line-modified">589                                     valueAt = graph.maybeAddOrUnique(PiNode.create(input, curBestStamp, (ValueNode) infoElement.getGuard()));</span>
590                                 }
591                                 newPhi.addInput(valueAt);
592                             }
593                             counterPhiStampsImproved.increment(debug);
594                             phi.replaceAtUsagesAndDelete(newPhi);
595                         }
596                     }
597                 }
598             }
599         }
600 
601         protected void processEnd(EndNode end) {
602             AbstractMergeNode abstractMerge = end.merge();
603             if (abstractMerge instanceof MergeNode) {
604                 MergeNode merge = (MergeNode) abstractMerge;
605 
606                 EconomicMap&lt;ValuePhiNode, PhiInfoElement&gt; mergeMap = this.mergeMaps.get(merge);
607                 for (ValuePhiNode phi : merge.valuePhis()) {
608                     ValueNode valueAt = phi.valueAt(end);
609                     InfoElement infoElement = this.getInfoElements(valueAt);
610                     while (infoElement != null) {
611                         Stamp newStamp = infoElement.getStamp();
612                         if (phi.stamp(NodeView.DEFAULT).tryImproveWith(newStamp) != null) {
613                             if (mergeMap == null) {
<a name="37" id="anc37"></a><span class="line-modified">614                                 mergeMap = EconomicMap.create(Equivalence.IDENTITY);</span>
615                                 mergeMaps.put(merge, mergeMap);
616                             }
617 
618                             PhiInfoElement phiInfoElement = mergeMap.get(phi);
619                             if (phiInfoElement == null) {
620                                 phiInfoElement = new PhiInfoElement();
621                                 mergeMap.put(phi, phiInfoElement);
622                             }
623 
624                             phiInfoElement.set(end, infoElement);
625                             break;
626                         }
627                         infoElement = nextElement(infoElement);
628                     }
629                 }
630             }
631         }
632 
633         protected void registerNewCondition(LogicNode condition, boolean negated, GuardingNode guard) {
634             if (condition instanceof UnaryOpLogicNode) {
635                 UnaryOpLogicNode unaryLogicNode = (UnaryOpLogicNode) condition;
636                 ValueNode value = unaryLogicNode.getValue();
637                 if (maybeMultipleUsages(value)) {
638                     // getSucceedingStampForValue doesn&#39;t take the (potentially a Pi Node) input
639                     // stamp into account, so it can be safely propagated.
640                     Stamp newStamp = unaryLogicNode.getSucceedingStampForValue(negated);
641                     registerNewStamp(value, newStamp, guard, true);
642                 }
643             } else if (condition instanceof BinaryOpLogicNode) {
644                 BinaryOpLogicNode binaryOpLogicNode = (BinaryOpLogicNode) condition;
645                 ValueNode x = binaryOpLogicNode.getX();
646                 ValueNode y = binaryOpLogicNode.getY();
647                 if (!x.isConstant() &amp;&amp; maybeMultipleUsages(x)) {
648                     Stamp newStampX = binaryOpLogicNode.getSucceedingStampForX(negated, getSafeStamp(x), getOtherSafeStamp(y));
649                     registerNewStamp(x, newStampX, guard);
650                 }
651 
652                 if (!y.isConstant() &amp;&amp; maybeMultipleUsages(y)) {
653                     Stamp newStampY = binaryOpLogicNode.getSucceedingStampForY(negated, getOtherSafeStamp(x), getSafeStamp(y));
654                     registerNewStamp(y, newStampY, guard);
655                 }
656 
657                 if (condition instanceof IntegerEqualsNode &amp;&amp; guard instanceof DeoptimizingGuard &amp;&amp; !negated) {
658                     if (y.isConstant() &amp;&amp; x instanceof AndNode) {
659                         AndNode and = (AndNode) x;
660                         ValueNode andX = and.getX();
661                         if (and.getY() == y &amp;&amp; maybeMultipleUsages(andX)) {
662                             /*
663                              * This &#39;and&#39; proves something about some of the bits in and.getX().
664                              * It&#39;s equivalent to or&#39;ing in the mask value since those values are
665                              * known to be set.
666                              */
667                             BinaryOp&lt;Or&gt; op = ArithmeticOpTable.forStamp(x.stamp(NodeView.DEFAULT)).getOr();
668                             IntegerStamp newStampX = (IntegerStamp) op.foldStamp(getSafeStamp(andX), getOtherSafeStamp(y));
669                             registerNewStamp(andX, newStampX, guard);
670                         }
671                     }
672                 }
673             }
674             if (guard instanceof DeoptimizingGuard) {
675                 assert ((DeoptimizingGuard) guard).getCondition() == condition;
676                 pendingTests.push((DeoptimizingGuard) guard);
677             }
678             registerCondition(condition, negated, guard);
679         }
680 
<a name="38" id="anc38"></a>





















































681         /**
682          * Recursively try to fold stamps within this expression using information from
683          * {@link #getInfoElements(ValueNode)}. It&#39;s only safe to use constants and one
684          * {@link InfoElement} otherwise more than one guard would be required.
685          *
686          * @param node
687          * @return the pair of the @{link InfoElement} used and the stamp produced for the whole
688          *         expression
689          */
690         Pair&lt;InfoElement, Stamp&gt; recursiveFoldStampFromInfo(Node node) {
<a name="39" id="anc39"></a><span class="line-modified">691             return ConditionalEliminationUtil.recursiveFoldStamp(infoElementProvider, node);</span>
692         }
693 
694         /**
695          * Look for a preceding guard whose condition is implied by {@code thisGuard}. If we find
696          * one, try to move this guard just above that preceding guard so that we can fold it:
697          *
698          * &lt;pre&gt;
699          *     guard(C1); // preceding guard
700          *     ...
701          *     guard(C2); // thisGuard
702          * &lt;/pre&gt;
703          *
704          * If C2 =&gt; C1, transform to:
705          *
706          * &lt;pre&gt;
707          *     guard(C2);
708          *     ...
709          * &lt;/pre&gt;
710          */
711         protected boolean foldPendingTest(DeoptimizingGuard thisGuard, ValueNode original, Stamp newStamp, GuardRewirer rewireGuardFunction) {
712             for (DeoptimizingGuard pendingGuard : pendingTests) {
713                 LogicNode pendingCondition = pendingGuard.getCondition();
714                 TriState result = TriState.UNKNOWN;
715                 if (pendingCondition instanceof UnaryOpLogicNode) {
716                     UnaryOpLogicNode unaryLogicNode = (UnaryOpLogicNode) pendingCondition;
717                     if (unaryLogicNode.getValue() == original) {
718                         result = unaryLogicNode.tryFold(newStamp);
719                     }
720                 } else if (pendingCondition instanceof BinaryOpLogicNode) {
721                     BinaryOpLogicNode binaryOpLogicNode = (BinaryOpLogicNode) pendingCondition;
722                     ValueNode x = binaryOpLogicNode.getX();
723                     ValueNode y = binaryOpLogicNode.getY();
724                     if (x == original) {
725                         result = binaryOpLogicNode.tryFold(newStamp, getOtherSafeStamp(y));
726                     } else if (y == original) {
727                         result = binaryOpLogicNode.tryFold(getOtherSafeStamp(x), newStamp);
728                     } else if (binaryOpLogicNode instanceof IntegerEqualsNode &amp;&amp; y.isConstant() &amp;&amp; x instanceof AndNode) {
729                         AndNode and = (AndNode) x;
730                         if (and.getY() == y &amp;&amp; and.getX() == original) {
731                             BinaryOp&lt;And&gt; andOp = ArithmeticOpTable.forStamp(newStamp).getAnd();
732                             result = binaryOpLogicNode.tryFold(andOp.foldStamp(newStamp, getOtherSafeStamp(y)), getOtherSafeStamp(y));
733                         }
734                     }
735                 }
736                 if (result.isKnown()) {
737                     /*
738                      * The test case be folded using the information available but the test can only
739                      * be moved up if we&#39;re sure there&#39;s no schedule dependence.
740                      */
741                     if (canScheduleAbove(thisGuard.getCondition(), pendingGuard.asNode(), original) &amp;&amp; foldGuard(thisGuard, pendingGuard, result.toBoolean(), newStamp, rewireGuardFunction)) {
742                         return true;
743                     }
744                 }
745             }
746             return false;
747         }
748 
749         private boolean canScheduleAbove(Node n, Node target, ValueNode knownToBeAbove) {
750             Block targetBlock = nodeToBlock.get(target);
751             Block testBlock = nodeToBlock.get(n);
752             if (targetBlock != null &amp;&amp; testBlock != null) {
753                 if (targetBlock == testBlock) {
754                     for (Node fixed : blockToNodes.get(targetBlock)) {
755                         if (fixed == n) {
756                             return true;
757                         } else if (fixed == target) {
758                             break;
759                         }
760                     }
761                 } else if (AbstractControlFlowGraph.dominates(testBlock, targetBlock)) {
762                     return true;
763                 }
764             }
765             InputFilter v = new InputFilter(knownToBeAbove);
766             n.applyInputs(v);
767             return v.ok;
768         }
769 
770         protected boolean foldGuard(DeoptimizingGuard thisGuard, DeoptimizingGuard otherGuard, boolean outcome, Stamp guardedValueStamp, GuardRewirer rewireGuardFunction) {
771             DeoptimizationAction action = mergeActions(otherGuard.getAction(), thisGuard.getAction());
772             if (action != null &amp;&amp; otherGuard.getSpeculation() == thisGuard.getSpeculation()) {
773                 LogicNode condition = (LogicNode) thisGuard.getCondition().copyWithInputs();
774                 /*
775                  * We have ...; guard(C1); guard(C2);...
776                  *
777                  * Where the first guard is `otherGuard` and the second one `thisGuard`.
778                  *
779                  * Depending on `outcome`, we have C2 =&gt; C1 or C2 =&gt; !C1.
780                  *
781                  * - If C2 =&gt; C1, `mustDeopt` below is false and we transform to ...; guard(C2); ...
782                  *
783                  * - If C2 =&gt; !C1, `mustDeopt` is true and we transform to ..; guard(C1); deopt;
784                  */
785                 // for the second case, the action of the deopt is copied from there:
786                 thisGuard.setAction(action);
787                 GuardRewirer rewirer = (guard, result, innerGuardedValueStamp, newInput) -&gt; {
788                     // `result` is `outcome`, `guard` is `otherGuard`
789                     boolean mustDeopt = result == otherGuard.isNegated();
790                     if (rewireGuardFunction.rewire(guard, mustDeopt == thisGuard.isNegated(), innerGuardedValueStamp, newInput)) {
791                         if (!mustDeopt) {
792                             otherGuard.setCondition(condition, thisGuard.isNegated());
793                             otherGuard.setAction(action);
794                             otherGuard.setReason(thisGuard.getReason());
795                         }
796                         return true;
797                     }
798                     condition.safeDelete();
799                     return false;
800                 };
801                 // Move the later test up
802                 return rewireGuards(otherGuard, outcome, null, guardedValueStamp, rewirer);
803             }
804             return false;
805         }
806 
<a name="40" id="anc40"></a><span class="line-added">807         protected boolean tryProveGuardCondition(DeoptimizingGuard thisGuard, LogicNode node, GuardRewirer rewireGuardFunction) {</span>
<span class="line-added">808             return ConditionalEliminationUtil.tryProveGuardCondition(infoElementProvider, conditions, guardFolding, thisGuard, node, rewireGuardFunction);</span>
<span class="line-added">809         }</span>
<span class="line-added">810 </span>
811         protected void registerCondition(LogicNode condition, boolean negated, GuardingNode guard) {
812             if (condition.hasMoreThanOneUsage()) {
813                 registerNewStamp(condition, negated ? StampFactory.contradiction() : StampFactory.tautology(), guard);
814             }
815             conditions.push(new GuardedCondition(guard, condition, negated));
816         }
817 
818         protected InfoElement getInfoElements(ValueNode proxiedValue) {
819             if (proxiedValue == null) {
820                 return null;
821             }
822             InfoElement infoElement = map.getAndGrow(proxiedValue);
823             if (infoElement == null) {
824                 infoElement = map.getAndGrow(GraphUtil.skipPi(proxiedValue));
825             }
826             return infoElement;
827         }
828 
<a name="41" id="anc41"></a>








829         private InfoElement nextElement(InfoElement current) {
830             InfoElement parent = current.getParent();
831             if (parent != null) {
832                 return parent;
833             } else {
834                 ValueNode proxifiedInput = current.getProxifiedInput();
835                 if (proxifiedInput instanceof PiNode) {
836                     PiNode piNode = (PiNode) proxifiedInput;
837                     return getInfoElements(piNode.getOriginalNode());
838                 }
839             }
840             return null;
841         }
842 
<a name="42" id="anc42"></a>































































































































































843         protected void registerNewStamp(ValueNode maybeProxiedValue, Stamp newStamp, GuardingNode guard) {
844             registerNewStamp(maybeProxiedValue, newStamp, guard, false);
845         }
846 
847         protected void registerNewStamp(ValueNode maybeProxiedValue, Stamp newStamp, GuardingNode guard, boolean propagateThroughPis) {
848             assert maybeProxiedValue != null;
849             assert guard != null;
850 
851             if (newStamp == null || newStamp.isUnrestricted()) {
852                 return;
853             }
854 
855             ValueNode value = maybeProxiedValue;
856             Stamp stamp = newStamp;
857 
858             while (stamp != null &amp;&amp; value != null) {
859                 ValueNode proxiedValue = null;
860                 if (value instanceof PiNode) {
861                     proxiedValue = value;
862                 }
863                 counterStampsRegistered.increment(debug);
864                 debug.log(&quot;\t Saving stamp for node %s stamp %s guarded by %s&quot;, value, stamp, guard);
865                 assert value instanceof LogicNode || stamp.isCompatible(value.stamp(NodeView.DEFAULT)) : stamp + &quot; vs. &quot; + value.stamp(NodeView.DEFAULT) + &quot; (&quot; + value + &quot;)&quot;;
866                 map.setAndGrow(value, new InfoElement(stamp, guard, proxiedValue, map.getAndGrow(value)));
867                 undoOperations.push(value);
868                 if (propagateThroughPis &amp;&amp; value instanceof PiNode) {
869                     PiNode piNode = (PiNode) value;
870                     value = piNode.getOriginalNode();
871                 } else if (value instanceof StampInverter) {
872                     StampInverter stampInverter = (StampInverter) value;
873                     value = stampInverter.getValue();
874                     stamp = stampInverter.invertStamp(stamp);
875                 } else {
876                     break;
877                 }
878             }
879         }
880 
881         protected void processAbstractBegin(AbstractBeginNode beginNode) {
882             Node predecessor = beginNode.predecessor();
883             if (predecessor instanceof IfNode) {
884                 IfNode ifNode = (IfNode) predecessor;
885                 boolean negated = (ifNode.falseSuccessor() == beginNode);
886                 LogicNode condition = ifNode.condition();
887                 registerNewCondition(condition, negated, beginNode);
888             } else if (predecessor instanceof TypeSwitchNode) {
889                 TypeSwitchNode typeSwitch = (TypeSwitchNode) predecessor;
890                 processTypeSwitch(beginNode, typeSwitch);
891             } else if (predecessor instanceof IntegerSwitchNode) {
892                 IntegerSwitchNode integerSwitchNode = (IntegerSwitchNode) predecessor;
893                 processIntegerSwitch(beginNode, integerSwitchNode);
894             }
895         }
896 
897         private static boolean maybeMultipleUsages(ValueNode value) {
898             if (value.hasMoreThanOneUsage()) {
899                 return true;
900             } else {
901                 return value instanceof ProxyNode ||
902                                 value instanceof PiNode ||
903                                 value instanceof StampInverter;
904             }
905         }
906 
907         protected void processIntegerSwitch(AbstractBeginNode beginNode, IntegerSwitchNode integerSwitchNode) {
908             ValueNode value = integerSwitchNode.value();
909             if (maybeMultipleUsages(value)) {
910                 Stamp stamp = integerSwitchNode.getValueStampForSuccessor(beginNode);
911                 if (stamp != null) {
912                     registerNewStamp(value, stamp, beginNode);
913                 }
914             }
915         }
916 
917         protected void processTypeSwitch(AbstractBeginNode beginNode, TypeSwitchNode typeSwitch) {
918             ValueNode hub = typeSwitch.value();
919             if (hub instanceof LoadHubNode) {
920                 LoadHubNode loadHub = (LoadHubNode) hub;
921                 ValueNode value = loadHub.getValue();
922                 if (maybeMultipleUsages(value)) {
923                     Stamp stamp = typeSwitch.getValueStampForSuccessor(beginNode);
924                     if (stamp != null) {
925                         registerNewStamp(value, stamp, beginNode);
926                     }
927                 }
928             }
929         }
930 
931         @Override
932         public void exit(Block b, Marks marks) {
933             int infoElementsMark = marks.infoElementOperations;
934             while (undoOperations.size() &gt; infoElementsMark) {
935                 Node node = undoOperations.pop();
936                 if (node.isAlive()) {
937                     map.set(node, map.get(node).getParent());
938                 }
939             }
940 
941             int conditionsMark = marks.conditions;
942             while (conditions.size() &gt; conditionsMark) {
943                 conditions.pop();
944             }
945         }
946     }
947 
<a name="43" id="anc43"></a>
























































































948     @Override
949     public float codeSizeIncrease() {
950         return 1.5f;
951     }
952 }
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>
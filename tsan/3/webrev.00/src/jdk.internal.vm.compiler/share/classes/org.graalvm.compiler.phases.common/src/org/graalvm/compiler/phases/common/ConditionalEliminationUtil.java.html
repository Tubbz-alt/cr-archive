<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ConditionalEliminationUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.phases.common;
 26 
 27 import java.util.ArrayDeque;
 28 
 29 import jdk.internal.vm.compiler.collections.Pair;
 30 import org.graalvm.compiler.core.common.type.ArithmeticOpTable;
 31 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;
 32 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.Or;
 33 import org.graalvm.compiler.core.common.type.IntegerStamp;
 34 import org.graalvm.compiler.core.common.type.Stamp;
 35 import org.graalvm.compiler.graph.Node;
 36 import org.graalvm.compiler.nodes.BinaryOpLogicNode;
 37 import org.graalvm.compiler.nodes.DeoptimizingGuard;
 38 import org.graalvm.compiler.nodes.LogicNode;
 39 import org.graalvm.compiler.nodes.NodeView;
 40 import org.graalvm.compiler.nodes.ParameterNode;
 41 import org.graalvm.compiler.nodes.PiNode;
 42 import org.graalvm.compiler.nodes.ShortCircuitOrNode;
 43 import org.graalvm.compiler.nodes.UnaryOpLogicNode;
 44 import org.graalvm.compiler.nodes.ValueNode;
 45 import org.graalvm.compiler.nodes.calc.AndNode;
 46 import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;
 47 import org.graalvm.compiler.nodes.calc.BinaryNode;
 48 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
 49 import org.graalvm.compiler.nodes.calc.UnaryNode;
 50 import org.graalvm.compiler.nodes.extended.GuardingNode;
 51 
 52 import jdk.vm.ci.meta.JavaConstant;
 53 import jdk.vm.ci.meta.TriState;
 54 
 55 public class ConditionalEliminationUtil {
 56 
 57     public static final class Marks {
 58 
 59         final int infoElementOperations;
 60         final int conditions;
 61 
 62         public Marks(int infoElementOperations, int conditions) {
 63             this.infoElementOperations = infoElementOperations;
 64             this.conditions = conditions;
 65         }
 66 
 67         public int getInfoElementOperations() {
 68             return infoElementOperations;
 69         }
 70 
 71         public int getConditions() {
 72             return conditions;
 73         }
 74     }
 75 
 76     public static final class GuardedCondition {
 77         private final GuardingNode guard;
 78         private final LogicNode condition;
 79         private final boolean negated;
 80 
 81         public GuardedCondition(GuardingNode guard, LogicNode condition, boolean negated) {
 82             this.guard = guard;
 83             this.condition = condition;
 84             this.negated = negated;
 85         }
 86 
 87         public GuardingNode getGuard() {
 88             return guard;
 89         }
 90 
 91         public LogicNode getCondition() {
 92             return condition;
 93         }
 94 
 95         public boolean isNegated() {
 96             return negated;
 97         }
 98     }
 99 
100     @FunctionalInterface
101     public interface GuardRewirer {
102         /**
103          * Called if the condition could be proven to have a constant value ({@code result}) under
104          * {@code guard}.
105          *
106          * @param guard the guard whose result is proven
107          * @param result the known result of the guard
108          * @param newInput new input to pi nodes depending on the new guard
109          * @return whether the transformation could be applied
110          */
111         boolean rewire(GuardingNode guard, boolean result, Stamp guardedValueStamp, ValueNode newInput);
112     }
113 
114     /**
115      * Checks for safe nodes when moving pending tests up.
116      */
117     public static class InputFilter extends Node.EdgeVisitor {
118         boolean ok;
119         private ValueNode value;
120 
121         InputFilter(ValueNode value) {
122             this.value = value;
123             this.ok = true;
124         }
125 
126         @Override
127         public Node apply(Node node, Node curNode) {
128             if (!ok) {
129                 // Abort the recursion
130                 return curNode;
131             }
132             if (!(curNode instanceof ValueNode)) {
133                 ok = false;
134                 return curNode;
135             }
136             ValueNode curValue = (ValueNode) curNode;
137             if (curValue.isConstant() || curValue == value || curValue instanceof ParameterNode) {
138                 return curNode;
139             }
140             if (curValue instanceof BinaryNode || curValue instanceof UnaryNode) {
141                 curValue.applyInputs(this);
142             } else {
143                 ok = false;
144             }
145             return curNode;
146         }
147     }
148 
149     public static final class InfoElement {
150         private final Stamp stamp;
151         private final GuardingNode guard;
152         private final ValueNode proxifiedInput;
153         private final InfoElement parent;
154 
155         public InfoElement(Stamp stamp, GuardingNode guard, ValueNode proxifiedInput, InfoElement parent) {
156             this.stamp = stamp;
157             this.guard = guard;
158             this.proxifiedInput = proxifiedInput;
159             this.parent = parent;
160         }
161 
162         public InfoElement getParent() {
163             return parent;
164         }
165 
166         public Stamp getStamp() {
167             return stamp;
168         }
169 
170         public GuardingNode getGuard() {
171             return guard;
172         }
173 
174         public ValueNode getProxifiedInput() {
175             return proxifiedInput;
176         }
177 
178         @Override
179         public String toString() {
180             return stamp + &quot; -&gt; &quot; + guard;
181         }
182     }
183 
184     /**
185      * Get the stamp that may be used for the value for which we are registering the condition. We
186      * may directly use the stamp here without restriction, because any later lookup of the
187      * registered info elements is in the same chain of pi nodes.
188      */
189     public static Stamp getSafeStamp(ValueNode x) {
190         return x.stamp(NodeView.DEFAULT);
191     }
192 
193     /**
194      * We can only use the stamp of a second value involved in the condition if we are sure that we
195      * are not implicitly creating a dependency on a pi node that is responsible for that stamp. For
196      * now, we are conservatively only using the stamps of constants. Under certain circumstances,
197      * we may also be able to use the stamp of the value after skipping pi nodes (e.g., the stamp of
198      * a parameter after inlining, or the stamp of a fixed node that can never be replaced with a pi
199      * node via canonicalization).
200      */
201     public static Stamp getOtherSafeStamp(ValueNode x) {
202         if (x.isConstant() || x.graph().isAfterFixedReadPhase()) {
203             return x.stamp(NodeView.DEFAULT);
204         }
205         return x.stamp(NodeView.DEFAULT).unrestricted();
206     }
207 
208     @FunctionalInterface
209     public interface InfoElementProvider {
210         InfoElement infoElements(ValueNode value);
211 
212         default InfoElement nextElement(InfoElement current) {
213             InfoElement parent = current.getParent();
214             if (parent != null) {
215                 return parent;
216             } else {
217                 ValueNode proxifiedInput = current.getProxifiedInput();
218                 if (proxifiedInput instanceof PiNode) {
219                     PiNode piNode = (PiNode) proxifiedInput;
220                     return infoElements(piNode.getOriginalNode());
221                 }
222             }
223             return null;
224         }
225     }
226 
227     public static Pair&lt;InfoElement, Stamp&gt; recursiveFoldStamp(InfoElementProvider infoElementProvider, Node node) {
228         if (node instanceof UnaryNode) {
229             UnaryNode unary = (UnaryNode) node;
230             ValueNode value = unary.getValue();
231             InfoElement infoElement = infoElementProvider.infoElements(value);
232             while (infoElement != null) {
233                 Stamp result = unary.foldStamp(infoElement.getStamp());
234                 if (result != null) {
235                     return Pair.create(infoElement, result);
236                 }
237                 infoElement = infoElementProvider.nextElement(infoElement);
238             }
239         } else if (node instanceof BinaryNode) {
240             BinaryNode binary = (BinaryNode) node;
241             ValueNode y = binary.getY();
242             ValueNode x = binary.getX();
243             if (y.isConstant()) {
244                 InfoElement infoElement = infoElementProvider.infoElements(x);
245                 while (infoElement != null) {
246                     Stamp result = binary.foldStamp(infoElement.getStamp(), y.stamp(NodeView.DEFAULT));
247                     if (result != null) {
248                         return Pair.create(infoElement, result);
249                     }
250                     infoElement = infoElementProvider.nextElement(infoElement);
251                 }
252             }
253         }
254         return null;
255     }
256 
257     /**
258      * Recursively try to fold stamps within this expression using information from
259      * {@link InfoElementProvider#infoElements(ValueNode)}. It&#39;s only safe to use constants and one
260      * {@link InfoElement} otherwise more than one guard would be required.
261      *
262      * @param node
263      * @return the pair of the @{link InfoElement} used and the stamp produced for the whole
264      *         expression
265      */
266     public static Pair&lt;InfoElement, Stamp&gt; recursiveFoldStampFromInfo(InfoElementProvider infoElementProvider, Node node) {
267         return recursiveFoldStamp(infoElementProvider, node);
268     }
269 
270     public static boolean rewireGuards(GuardingNode guard, boolean result, ValueNode proxifiedInput, Stamp guardedValueStamp, GuardRewirer rewireGuardFunction) {
271         return rewireGuardFunction.rewire(guard, result, guardedValueStamp, proxifiedInput);
272     }
273 
274     @FunctionalInterface
275     public interface GuardFolding {
276         boolean foldGuard(DeoptimizingGuard thisGuard, ValueNode original, Stamp newStamp, GuardRewirer rewireGuardFunction);
277     }
278 
279     public static boolean tryProveGuardCondition(InfoElementProvider infoElementProvider, ArrayDeque&lt;GuardedCondition&gt; conditions, GuardFolding guardFolding, DeoptimizingGuard thisGuard,
280                     LogicNode node,
281                     GuardRewirer rewireGuardFunction) {
282         InfoElement infoElement = infoElementProvider.infoElements(node);
283         while (infoElement != null) {
284             Stamp stamp = infoElement.getStamp();
285             JavaConstant constant = (JavaConstant) stamp.asConstant();
286             if (constant != null) {
287                 // No proxified input and stamp required.
288                 return rewireGuards(infoElement.getGuard(), constant.asBoolean(), null, null, rewireGuardFunction);
289             }
290             infoElement = infoElementProvider.nextElement(infoElement);
291         }
292 
293         for (GuardedCondition guardedCondition : conditions) {
294             TriState result = guardedCondition.getCondition().implies(guardedCondition.isNegated(), node);
295             if (result.isKnown()) {
296                 return rewireGuards(guardedCondition.getGuard(), result.toBoolean(), null, null, rewireGuardFunction);
297             }
298         }
299 
300         if (node instanceof UnaryOpLogicNode) {
301             UnaryOpLogicNode unaryLogicNode = (UnaryOpLogicNode) node;
302             ValueNode value = unaryLogicNode.getValue();
303             infoElement = infoElementProvider.infoElements(value);
304             while (infoElement != null) {
305                 Stamp stamp = infoElement.getStamp();
306                 TriState result = unaryLogicNode.tryFold(stamp);
307                 if (result.isKnown()) {
308                     return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), infoElement.getStamp(), rewireGuardFunction);
309                 }
310                 infoElement = infoElementProvider.nextElement(infoElement);
311             }
312             Pair&lt;InfoElement, Stamp&gt; foldResult = recursiveFoldStampFromInfo(infoElementProvider, value);
313             if (foldResult != null) {
314                 TriState result = unaryLogicNode.tryFold(foldResult.getRight());
315                 if (result.isKnown()) {
316                     return rewireGuards(foldResult.getLeft().getGuard(), result.toBoolean(), foldResult.getLeft().getProxifiedInput(), foldResult.getRight(), rewireGuardFunction);
317                 }
318             }
319             if (thisGuard != null &amp;&amp; guardFolding != null) {
320                 Stamp newStamp = unaryLogicNode.getSucceedingStampForValue(thisGuard.isNegated());
321                 if (newStamp != null &amp;&amp; guardFolding.foldGuard(thisGuard, value, newStamp, rewireGuardFunction)) {
322                     return true;
323                 }
324 
325             }
326         } else if (node instanceof BinaryOpLogicNode) {
327             BinaryOpLogicNode binaryOpLogicNode = (BinaryOpLogicNode) node;
328             ValueNode x = binaryOpLogicNode.getX();
329             ValueNode y = binaryOpLogicNode.getY();
330             infoElement = infoElementProvider.infoElements(x);
331             while (infoElement != null) {
332                 TriState result = binaryOpLogicNode.tryFold(infoElement.getStamp(), y.stamp(NodeView.DEFAULT));
333                 if (result.isKnown()) {
334                     return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), infoElement.getStamp(), rewireGuardFunction);
335                 }
336                 infoElement = infoElementProvider.nextElement(infoElement);
337             }
338 
339             if (y.isConstant()) {
340                 Pair&lt;InfoElement, Stamp&gt; foldResult = recursiveFoldStampFromInfo(infoElementProvider, x);
341                 if (foldResult != null) {
342                     TriState result = binaryOpLogicNode.tryFold(foldResult.getRight(), y.stamp(NodeView.DEFAULT));
343                     if (result.isKnown()) {
344                         return rewireGuards(foldResult.getLeft().getGuard(), result.toBoolean(), foldResult.getLeft().getProxifiedInput(), foldResult.getRight(), rewireGuardFunction);
345                     }
346                 }
347             } else {
348                 infoElement = infoElementProvider.infoElements(y);
349                 while (infoElement != null) {
350                     TriState result = binaryOpLogicNode.tryFold(x.stamp(NodeView.DEFAULT), infoElement.getStamp());
351                     if (result.isKnown()) {
352                         return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), infoElement.getStamp(), rewireGuardFunction);
353                     }
354                     infoElement = infoElementProvider.nextElement(infoElement);
355                 }
356             }
357 
358             /*
359              * For complex expressions involving constants, see if it&#39;s possible to fold the tests
360              * by using stamps one level up in the expression. For instance, (x + n &lt; y) might fold
361              * if something is known about x and all other values are constants. The reason for the
362              * constant restriction is that if more than 1 real value is involved the code might
363              * need to adopt multiple guards to have proper dependences.
364              */
365             if (x instanceof BinaryArithmeticNode&lt;?&gt; &amp;&amp; y.isConstant()) {
366                 BinaryArithmeticNode&lt;?&gt; binary = (BinaryArithmeticNode&lt;?&gt;) x;
367                 if (binary.getY().isConstant()) {
368                     infoElement = infoElementProvider.infoElements(binary.getX());
369                     while (infoElement != null) {
370                         Stamp newStampX = binary.foldStamp(infoElement.getStamp(), binary.getY().stamp(NodeView.DEFAULT));
371                         TriState result = binaryOpLogicNode.tryFold(newStampX, y.stamp(NodeView.DEFAULT));
372                         if (result.isKnown()) {
373                             return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), newStampX, rewireGuardFunction);
374                         }
375                         infoElement = infoElementProvider.nextElement(infoElement);
376                     }
377                 }
378             }
379 
380             if (thisGuard != null &amp;&amp; guardFolding != null &amp;&amp; binaryOpLogicNode instanceof IntegerEqualsNode &amp;&amp; !thisGuard.isNegated()) {
381                 if (y.isConstant() &amp;&amp; x instanceof AndNode) {
382                     AndNode and = (AndNode) x;
383                     if (and.getY() == y) {
384                         /*
385                          * This &#39;and&#39; proves something about some of the bits in and.getX(). It&#39;s
386                          * equivalent to or&#39;ing in the mask value since those values are known to be
387                          * set.
388                          */
389                         BinaryOp&lt;Or&gt; op = ArithmeticOpTable.forStamp(x.stamp(NodeView.DEFAULT)).getOr();
390                         IntegerStamp newStampX = (IntegerStamp) op.foldStamp(getSafeStamp(and.getX()), getOtherSafeStamp(y));
391                         if (guardFolding.foldGuard(thisGuard, and.getX(), newStampX, rewireGuardFunction)) {
392                             return true;
393                         }
394                     }
395                 }
396             }
397 
398             if (thisGuard != null &amp;&amp; guardFolding != null) {
399                 if (!x.isConstant()) {
400                     Stamp newStampX = binaryOpLogicNode.getSucceedingStampForX(thisGuard.isNegated(), getSafeStamp(x), getOtherSafeStamp(y));
401                     if (newStampX != null &amp;&amp; guardFolding.foldGuard(thisGuard, x, newStampX, rewireGuardFunction)) {
402                         return true;
403                     }
404                 }
405                 if (!y.isConstant() &amp;&amp; guardFolding != null) {
406                     Stamp newStampY = binaryOpLogicNode.getSucceedingStampForY(thisGuard.isNegated(), getOtherSafeStamp(x), getSafeStamp(y));
407                     if (newStampY != null &amp;&amp; guardFolding.foldGuard(thisGuard, y, newStampY, rewireGuardFunction)) {
408                         return true;
409                     }
410                 }
411             }
412         } else if (node instanceof ShortCircuitOrNode) {
413             final ShortCircuitOrNode shortCircuitOrNode = (ShortCircuitOrNode) node;
414             return tryProveGuardCondition(infoElementProvider, conditions, guardFolding, null, shortCircuitOrNode.getX(), (guard, result, guardedValueStamp, newInput) -&gt; {
415                 if (result == !shortCircuitOrNode.isXNegated()) {
416                     return rewireGuards(guard, true, newInput, guardedValueStamp, rewireGuardFunction);
417                 } else {
418                     return tryProveGuardCondition(infoElementProvider, conditions, guardFolding, null, shortCircuitOrNode.getY(), (innerGuard, innerResult, innerGuardedValueStamp, innerNewInput) -&gt; {
419                         ValueNode proxifiedInput = newInput;
420                         if (proxifiedInput == null) {
421                             proxifiedInput = innerNewInput;
422                         } else if (innerNewInput != null) {
423                             if (innerNewInput != newInput) {
424                                 // Cannot canonicalize due to different proxied inputs.
425                                 return false;
426                             }
427                         }
428                         // Can only canonicalize if the guards are equal.
429                         if (innerGuard == guard) {
430                             return rewireGuards(guard, innerResult ^ shortCircuitOrNode.isYNegated(), proxifiedInput, guardedValueStamp, rewireGuardFunction);
431                         }
432                         return false;
433                     });
434                 }
435             });
436         }
437 
438         return false;
439     }
440 
441 }
    </pre>
  </body>
</html>
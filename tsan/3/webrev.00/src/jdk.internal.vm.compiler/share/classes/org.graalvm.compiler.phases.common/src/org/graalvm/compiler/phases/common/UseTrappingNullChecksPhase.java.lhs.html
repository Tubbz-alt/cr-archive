<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.phases.common;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.OptImplicitNullChecks;
 28 
 29 import java.util.List;
 30 
 31 import org.graalvm.compiler.debug.CounterKey;
 32 import org.graalvm.compiler.debug.DebugContext;
 33 import org.graalvm.compiler.graph.Node;
 34 import org.graalvm.compiler.nodeinfo.InputType;
 35 import org.graalvm.compiler.nodes.AbstractBeginNode;
 36 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
 37 import org.graalvm.compiler.nodes.AbstractEndNode;
 38 import org.graalvm.compiler.nodes.AbstractMergeNode;
 39 import org.graalvm.compiler.nodes.BeginNode;
 40 import org.graalvm.compiler.nodes.CompressionNode;
 41 import org.graalvm.compiler.nodes.DeoptimizeNode;
 42 import org.graalvm.compiler.nodes.DeoptimizingFixedWithNextNode;
 43 import org.graalvm.compiler.nodes.DynamicDeoptimizeNode;
<a name="2" id="anc2"></a>
 44 import org.graalvm.compiler.nodes.FixedNode;
 45 import org.graalvm.compiler.nodes.IfNode;
 46 import org.graalvm.compiler.nodes.LogicNode;
<a name="3" id="anc3"></a>
 47 import org.graalvm.compiler.nodes.StructuredGraph;
 48 import org.graalvm.compiler.nodes.ValueNode;
 49 import org.graalvm.compiler.nodes.ValuePhiNode;
 50 import org.graalvm.compiler.nodes.calc.IsNullNode;
 51 import org.graalvm.compiler.nodes.extended.NullCheckNode;
 52 import org.graalvm.compiler.nodes.memory.FixedAccessNode;
 53 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 54 import org.graalvm.compiler.nodes.util.GraphUtil;
 55 import org.graalvm.compiler.options.Option;
 56 import org.graalvm.compiler.options.OptionKey;
 57 import org.graalvm.compiler.options.OptionType;
 58 import org.graalvm.compiler.phases.BasePhase;
 59 import org.graalvm.compiler.phases.tiers.LowTierContext;
 60 
 61 import jdk.vm.ci.meta.DeoptimizationReason;
 62 import jdk.vm.ci.meta.MetaAccessProvider;
 63 import jdk.vm.ci.meta.SpeculationLog;
 64 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 65 
 66 public class UseTrappingNullChecksPhase extends BasePhase&lt;LowTierContext&gt; {
 67 
 68     private static final CounterKey counterTrappingNullCheck = DebugContext.counter(&quot;TrappingNullCheck&quot;);
 69     private static final CounterKey counterTrappingNullCheckExistingRead = DebugContext.counter(&quot;TrappingNullCheckExistingRead&quot;);
 70     private static final CounterKey counterTrappingNullCheckUnreached = DebugContext.counter(&quot;TrappingNullCheckUnreached&quot;);
 71     private static final CounterKey counterTrappingNullCheckDynamicDeoptimize = DebugContext.counter(&quot;TrappingNullCheckDynamicDeoptimize&quot;);
 72 
 73     public static class Options {
 74 
 75         // @formatter:off
 76         @Option(help = &quot;Use traps for null checks instead of explicit null-checks&quot;, type = OptionType.Expert)
 77         public static final OptionKey&lt;Boolean&gt; UseTrappingNullChecks = new OptionKey&lt;&gt;(true);
 78         // @formatter:on
 79     }
 80 
 81     @Override
 82     protected void run(StructuredGraph graph, LowTierContext context) {
 83         if (!Options.UseTrappingNullChecks.getValue(graph.getOptions()) || context.getTarget().implicitNullCheckLimit &lt;= 0) {
 84             return;
 85         }
 86         assert graph.getGuardsStage().areFrameStatesAtDeopts();
 87 
 88         long implicitNullCheckLimit = context.getTarget().implicitNullCheckLimit;
 89         for (DeoptimizeNode deopt : graph.getNodes(DeoptimizeNode.TYPE)) {
 90             tryUseTrappingNullCheck(deopt, deopt.predecessor(), deopt.getReason(), deopt.getSpeculation(), implicitNullCheckLimit);
 91         }
 92         for (DynamicDeoptimizeNode deopt : graph.getNodes(DynamicDeoptimizeNode.TYPE)) {
 93             tryUseTrappingNullCheck(context.getMetaAccess(), deopt, implicitNullCheckLimit);
 94         }
 95 
 96     }
 97 
 98     private static void tryUseTrappingNullCheck(MetaAccessProvider metaAccessProvider, DynamicDeoptimizeNode deopt, long implicitNullCheckLimit) {
 99         Node predecessor = deopt.predecessor();
100         if (predecessor instanceof AbstractMergeNode) {
101             AbstractMergeNode merge = (AbstractMergeNode) predecessor;
102 
103             // Process each predecessor at the merge, unpacking the reasons and speculations as
104             // needed.
105             ValueNode reason = deopt.getActionAndReason();
106             ValuePhiNode reasonPhi = null;
107             List&lt;ValueNode&gt; reasons = null;
108             int expectedPhis = 0;
109 
110             if (reason instanceof ValuePhiNode) {
111                 reasonPhi = (ValuePhiNode) reason;
112                 if (reasonPhi.merge() != merge) {
113                     return;
114                 }
115                 reasons = reasonPhi.values().snapshot();
116                 expectedPhis++;
117             } else if (!reason.isConstant()) {
<a name="4" id="anc4"></a>
118                 return;
119             }
120 
121             ValueNode speculation = deopt.getSpeculation();
122             ValuePhiNode speculationPhi = null;
123             List&lt;ValueNode&gt; speculations = null;
124             if (speculation instanceof ValuePhiNode) {
125                 speculationPhi = (ValuePhiNode) speculation;
126                 if (speculationPhi.merge() != merge) {
127                     return;
128                 }
129                 speculations = speculationPhi.values().snapshot();
130                 expectedPhis++;
131             }
132 
133             if (merge.phis().count() != expectedPhis) {
134                 return;
135             }
136 
137             int index = 0;
<a name="5" id="anc5"></a><span class="line-modified">138             for (AbstractEndNode end : merge.cfgPredecessors().snapshot()) {</span>


139                 ValueNode thisReason = reasons != null ? reasons.get(index) : reason;
<a name="6" id="anc6"></a><span class="line-modified">140                 ValueNode thisSpeculation = speculations != null ? speculations.get(index++) : speculation;</span>
<span class="line-modified">141                 if (!thisReason.isConstant() || !thisSpeculation.isConstant()) {</span>
<span class="line-modified">142                     continue;</span>





143                 }
<a name="7" id="anc7"></a><span class="line-modified">144                 Speculation speculationConstant = metaAccessProvider.decodeSpeculation(thisSpeculation.asJavaConstant(), deopt.graph().getSpeculationLog());</span>
<span class="line-modified">145                 if (!speculationConstant.equals(SpeculationLog.NO_SPECULATION)) {</span>


146                     continue;
147                 }
148                 DeoptimizationReason deoptimizationReason = metaAccessProvider.decodeDeoptReason(thisReason.asJavaConstant());
<a name="8" id="anc8"></a><span class="line-modified">149                 tryUseTrappingNullCheck(deopt, end.predecessor(), deoptimizationReason, SpeculationLog.NO_SPECULATION, implicitNullCheckLimit);</span>

150             }
151         }
152     }
153 
154     private static void tryUseTrappingNullCheck(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, Speculation speculation, long implicitNullCheckLimit) {
<a name="9" id="anc9"></a><span class="line-modified">155         if (deoptimizationReason != DeoptimizationReason.NullCheckException &amp;&amp; deoptimizationReason != DeoptimizationReason.UnreachedCode) {</span>



156             return;
157         }
158         assert speculation != null;
159         if (!speculation.equals(SpeculationLog.NO_SPECULATION)) {
<a name="10" id="anc10"></a>
160             return;
161         }
<a name="11" id="anc11"></a><span class="line-modified">162         if (predecessor instanceof AbstractMergeNode) {</span>
<span class="line-modified">163             AbstractMergeNode merge = (AbstractMergeNode) predecessor;</span>






164             if (merge.phis().isEmpty()) {
165                 for (AbstractEndNode end : merge.cfgPredecessors().snapshot()) {
166                     checkPredecessor(deopt, end.predecessor(), deoptimizationReason, implicitNullCheckLimit);
167                 }
168             }
<a name="12" id="anc12"></a><span class="line-modified">169         } else if (predecessor instanceof AbstractBeginNode) {</span>
<span class="line-modified">170             checkPredecessor(deopt, predecessor, deoptimizationReason, implicitNullCheckLimit);</span>


171         }
172     }
173 
174     private static void checkPredecessor(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, long implicitNullCheckLimit) {
175         Node current = predecessor;
176         AbstractBeginNode branch = null;
177         while (current instanceof AbstractBeginNode) {
178             branch = (AbstractBeginNode) current;
179             if (branch.anchored().isNotEmpty()) {
180                 // some input of the deopt framestate is anchored to this branch
181                 return;
182             }
183             current = current.predecessor();
184         }
185         if (current instanceof IfNode) {
186             IfNode ifNode = (IfNode) current;
187             if (branch != ifNode.trueSuccessor()) {
188                 return;
189             }
190             LogicNode condition = ifNode.condition();
191             if (condition instanceof IsNullNode) {
192                 replaceWithTrappingNullCheck(deopt, ifNode, condition, deoptimizationReason, implicitNullCheckLimit);
193             }
194         }
195     }
196 
197     private static void replaceWithTrappingNullCheck(AbstractDeoptimizeNode deopt, IfNode ifNode, LogicNode condition, DeoptimizationReason deoptimizationReason, long implicitNullCheckLimit) {
198         DebugContext debug = deopt.getDebug();
199         counterTrappingNullCheck.increment(debug);
200         if (deopt instanceof DynamicDeoptimizeNode) {
201             counterTrappingNullCheckDynamicDeoptimize.increment(debug);
202         }
203         if (deoptimizationReason == DeoptimizationReason.UnreachedCode) {
204             counterTrappingNullCheckUnreached.increment(debug);
205         }
206         IsNullNode isNullNode = (IsNullNode) condition;
207         AbstractBeginNode nonTrappingContinuation = ifNode.falseSuccessor();
208         AbstractBeginNode trappingContinuation = ifNode.trueSuccessor();
209 
210         DeoptimizingFixedWithNextNode trappingNullCheck = null;
211         FixedNode nextNonTrapping = nonTrappingContinuation.next();
212         ValueNode value = isNullNode.getValue();
213         if (OptImplicitNullChecks.getValue(ifNode.graph().getOptions()) &amp;&amp; implicitNullCheckLimit &gt; 0) {
214             if (nextNonTrapping instanceof FixedAccessNode) {
215                 FixedAccessNode fixedAccessNode = (FixedAccessNode) nextNonTrapping;
216                 if (fixedAccessNode.canNullCheck()) {
217                     AddressNode address = fixedAccessNode.getAddress();
218                     ValueNode base = address.getBase();
219                     ValueNode index = address.getIndex();
220                     // allow for architectures which cannot fold an
221                     // intervening uncompress out of the address chain
222                     if (base != null &amp;&amp; base instanceof CompressionNode) {
223                         base = ((CompressionNode) base).getValue();
224                     }
225                     if (index != null &amp;&amp; index instanceof CompressionNode) {
226                         index = ((CompressionNode) index).getValue();
227                     }
228                     if (((base == value &amp;&amp; index == null) || (base == null &amp;&amp; index == value)) &amp;&amp; address.getMaxConstantDisplacement() &lt; implicitNullCheckLimit) {
229                         // Opportunity for implicit null check as part of an existing read found!
230                         fixedAccessNode.setStateBefore(deopt.stateBefore());
231                         fixedAccessNode.setNullCheck(true);
232                         deopt.graph().removeSplit(ifNode, nonTrappingContinuation);
233                         trappingNullCheck = fixedAccessNode;
234                         counterTrappingNullCheckExistingRead.increment(debug);
<a name="13" id="anc13"></a>
235                     }
236                 }
237             }
238         }
239 
240         if (trappingNullCheck == null) {
241             // Need to add a null check node.
242             trappingNullCheck = deopt.graph().add(new NullCheckNode(value));
243             deopt.graph().replaceSplit(ifNode, trappingNullCheck, nonTrappingContinuation);
<a name="14" id="anc14"></a>
244         }
245 
246         trappingNullCheck.setStateBefore(deopt.stateBefore());
247 
248         /*
249          * We now have the pattern NullCheck/BeginNode/... It&#39;s possible some node is using the
250          * BeginNode as a guard input, so replace guard users of the Begin with the NullCheck and
251          * then remove the Begin from the graph.
252          */
253         nonTrappingContinuation.replaceAtUsages(InputType.Guard, trappingNullCheck);
254 
255         if (nonTrappingContinuation instanceof BeginNode) {
256             GraphUtil.unlinkFixedNode(nonTrappingContinuation);
257             nonTrappingContinuation.safeDelete();
258         }
259 
260         GraphUtil.killCFG(trappingContinuation);
261         GraphUtil.tryKillUnused(isNullNode);
262     }
263 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
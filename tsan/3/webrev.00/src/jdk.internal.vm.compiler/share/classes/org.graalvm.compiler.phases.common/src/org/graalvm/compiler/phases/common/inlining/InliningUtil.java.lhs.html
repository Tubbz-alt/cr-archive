<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/inlining/InliningUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.phases.common.inlining;
  26 
  27 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateReprofile;
  28 import static jdk.vm.ci.meta.DeoptimizationReason.NullCheckException;
  29 import static org.graalvm.compiler.core.common.GraalOptions.HotSpotPrintInlining;
  30 
  31 import java.util.ArrayDeque;
  32 import java.util.ArrayList;
  33 import java.util.List;
  34 import java.util.Objects;
  35 import java.util.function.Consumer;
  36 
  37 import jdk.internal.vm.compiler.collections.EconomicMap;
  38 import jdk.internal.vm.compiler.collections.EconomicSet;
  39 import jdk.internal.vm.compiler.collections.Equivalence;
  40 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  41 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
  42 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  43 import org.graalvm.compiler.core.common.GraalOptions;
  44 import org.graalvm.compiler.core.common.type.Stamp;
  45 import org.graalvm.compiler.core.common.type.StampFactory;
  46 import org.graalvm.compiler.core.common.type.TypeReference;
  47 import org.graalvm.compiler.core.common.util.Util;
  48 import org.graalvm.compiler.debug.DebugCloseable;
  49 import org.graalvm.compiler.debug.DebugContext;
  50 import org.graalvm.compiler.debug.GraalError;
  51 import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
  52 import org.graalvm.compiler.graph.Graph.Mark;
  53 import org.graalvm.compiler.graph.Graph.NodeEventScope;
  54 import org.graalvm.compiler.graph.Node;
  55 import org.graalvm.compiler.graph.NodeInputList;
  56 import org.graalvm.compiler.graph.NodeMap;
  57 import org.graalvm.compiler.graph.NodeSourcePosition;
  58 import org.graalvm.compiler.graph.NodeWorkList;
<a name="2" id="anc2"></a>
  59 import org.graalvm.compiler.nodeinfo.Verbosity;
  60 import org.graalvm.compiler.nodes.AbstractBeginNode;
  61 import org.graalvm.compiler.nodes.AbstractEndNode;
  62 import org.graalvm.compiler.nodes.AbstractMergeNode;
  63 import org.graalvm.compiler.nodes.BeginNode;
  64 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
  65 import org.graalvm.compiler.nodes.DeoptimizeNode;
  66 import org.graalvm.compiler.nodes.DeoptimizingGuard;
  67 import org.graalvm.compiler.nodes.EndNode;
  68 import org.graalvm.compiler.nodes.FixedGuardNode;
  69 import org.graalvm.compiler.nodes.FixedNode;
  70 import org.graalvm.compiler.nodes.FrameState;
  71 import org.graalvm.compiler.nodes.InliningLog;
  72 import org.graalvm.compiler.nodes.Invoke;
  73 import org.graalvm.compiler.nodes.InvokeNode;
  74 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
<a name="3" id="anc3"></a><span class="line-removed">  75 import org.graalvm.compiler.nodes.KillingBeginNode;</span>
  76 import org.graalvm.compiler.nodes.LogicNode;
  77 import org.graalvm.compiler.nodes.MergeNode;
  78 import org.graalvm.compiler.nodes.NodeView;
  79 import org.graalvm.compiler.nodes.ParameterNode;
  80 import org.graalvm.compiler.nodes.PhiNode;
  81 import org.graalvm.compiler.nodes.PiNode;
  82 import org.graalvm.compiler.nodes.ReturnNode;
  83 import org.graalvm.compiler.nodes.StartNode;
  84 import org.graalvm.compiler.nodes.StateSplit;
  85 import org.graalvm.compiler.nodes.StructuredGraph;
  86 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
  87 import org.graalvm.compiler.nodes.UnwindNode;
  88 import org.graalvm.compiler.nodes.ValueNode;
  89 import org.graalvm.compiler.nodes.calc.IsNullNode;
  90 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
<a name="4" id="anc4"></a>
  91 import org.graalvm.compiler.nodes.extended.GuardingNode;
  92 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
  93 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  94 import org.graalvm.compiler.nodes.java.MonitorExitNode;
  95 import org.graalvm.compiler.nodes.java.MonitorIdNode;
<a name="5" id="anc5"></a><span class="line-removed">  96 import org.graalvm.compiler.nodes.spi.Replacements;</span>
  97 import org.graalvm.compiler.nodes.type.StampTool;
  98 import org.graalvm.compiler.nodes.util.GraphUtil;
  99 import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
 100 import org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener;
 101 import org.graalvm.compiler.phases.util.ValueMergeUtil;
 102 
 103 import jdk.vm.ci.code.BytecodeFrame;
 104 import jdk.vm.ci.meta.Assumptions;
 105 import jdk.vm.ci.meta.DeoptimizationAction;
 106 import jdk.vm.ci.meta.DeoptimizationReason;
 107 import jdk.vm.ci.meta.JavaKind;
 108 import jdk.vm.ci.meta.ResolvedJavaMethod;
 109 import jdk.vm.ci.meta.ResolvedJavaType;
 110 
 111 public class InliningUtil extends ValueMergeUtil {
 112 
 113     private static final String inliningDecisionsScopeString = &quot;InliningDecisions&quot;;
 114 
 115     /**
 116      * Print a HotSpot-style inlining message to the console.
 117      */
 118     private static void printInlining(final InlineInfo info, final int inliningDepth, final boolean success, final String msg, final Object... args) {
 119         printInlining(info.methodAt(0), info.invoke(), inliningDepth, success, msg, args);
 120     }
 121 
 122     /**
 123      * @see #printInlining
 124      */
 125     private static void printInlining(final ResolvedJavaMethod method, final Invoke invoke, final int inliningDepth, final boolean success, final String msg, final Object... args) {
 126         if (HotSpotPrintInlining.getValue(invoke.asNode().getOptions())) {
 127             Util.printInlining(method, invoke.bci(), inliningDepth, success, msg, args);
 128         }
 129     }
 130 
 131     /**
 132      * Trace a decision to inline a method.
 133      *
 134      * This prints a HotSpot-style inlining message to the console, and it also logs the decision to
 135      * the logging stream.
 136      *
 137      * Phases that perform inlining should use this method to trace the inlining decisions, and use
 138      * the {@link #traceNotInlinedMethod} methods only for debugging purposes.
 139      */
 140     public static void traceInlinedMethod(InlineInfo info, int inliningDepth, boolean allowLogging, String msg, Object... args) {
 141         traceMethod(info, inliningDepth, allowLogging, true, msg, args);
 142     }
 143 
 144     /**
 145      * Trace a decision to inline a method.
 146      *
 147      * This prints a HotSpot-style inlining message to the console, and it also logs the decision to
 148      * the logging stream.
 149      *
 150      * Phases that perform inlining should use this method to trace the inlining decisions, and use
 151      * the {@link #traceNotInlinedMethod} methods only for debugging purposes.
 152      */
 153     public static void traceInlinedMethod(Invoke invoke, int inliningDepth, boolean allowLogging, ResolvedJavaMethod method, String msg, Object... args) {
 154         traceMethod(invoke, inliningDepth, allowLogging, true, method, msg, args);
 155     }
 156 
 157     /**
 158      * Trace a decision to not inline a method.
 159      *
 160      * This prints a HotSpot-style inlining message to the console, and it also logs the decision to
 161      * the logging stream.
 162      *
 163      * Phases that perform inlining should use this method to trace the inlining decisions, and use
 164      * the {@link #traceNotInlinedMethod} methods only for debugging purposes.
 165      */
 166     public static void traceNotInlinedMethod(InlineInfo info, int inliningDepth, String msg, Object... args) {
 167         traceMethod(info, inliningDepth, true, false, msg, args);
 168     }
 169 
 170     /**
 171      * Trace a decision about not inlining a method.
 172      *
 173      * This prints a HotSpot-style inlining message to the console, and it also logs the decision to
 174      * the logging stream.
 175      *
 176      * Phases that perform inlining should use this method to trace the inlining decisions, and use
 177      * the {@link #traceNotInlinedMethod} methods only for debugging purposes.
 178      */
 179     public static void traceNotInlinedMethod(Invoke invoke, int inliningDepth, ResolvedJavaMethod method, String msg, Object... args) {
 180         traceMethod(invoke, inliningDepth, true, false, method, msg, args);
 181     }
 182 
 183     private static void traceMethod(Invoke invoke, int inliningDepth, boolean allowLogging, boolean success, ResolvedJavaMethod method, String msg, Object... args) {
 184         if (allowLogging) {
 185             DebugContext debug = invoke.asNode().getDebug();
 186             printInlining(method, invoke, inliningDepth, success, msg, args);
 187             if (shouldLogMethod(debug)) {
 188                 String methodString = methodName(method, invoke);
 189                 logMethod(debug, methodString, success, msg, args);
 190             }
 191         }
 192     }
 193 
 194     private static void traceMethod(InlineInfo info, int inliningDepth, boolean allowLogging, boolean success, String msg, final Object... args) {
 195         if (allowLogging) {
 196             printInlining(info, inliningDepth, success, msg, args);
 197             DebugContext debug = info.graph().getDebug();
 198             if (shouldLogMethod(debug)) {
 199                 logMethod(debug, methodName(info), success, msg, args);
 200             }
 201         }
 202     }
 203 
 204     /**
 205      * Output a generic inlining decision to the logging stream (e.g. inlining termination
 206      * condition).
 207      *
 208      * Used for debugging purposes.
 209      */
 210     public static void logInliningDecision(DebugContext debug, final String msg, final Object... args) {
 211         logInlining(debug, msg, args);
 212     }
 213 
 214     /**
 215      * Output a decision about not inlining a method to the logging stream, for debugging purposes.
 216      */
 217     public static void logNotInlinedMethod(Invoke invoke, String msg) {
 218         DebugContext debug = invoke.asNode().getDebug();
 219         if (shouldLogMethod(debug)) {
 220             String methodString = invoke.toString();
 221             if (invoke.callTarget() == null) {
 222                 methodString += &quot; callTarget=null&quot;;
 223             } else {
 224                 String targetName = invoke.callTarget().targetName();
 225                 if (!methodString.endsWith(targetName)) {
 226                     methodString += &quot; &quot; + targetName;
 227                 }
 228             }
 229             logMethod(debug, methodString, false, msg, new Object[0]);
 230         }
 231     }
 232 
 233     private static void logMethod(DebugContext debug, final String methodString, final boolean success, final String msg, final Object... args) {
 234         String inliningMsg = &quot;inlining &quot; + methodString + &quot;: &quot; + msg;
 235         if (!success) {
 236             inliningMsg = &quot;not &quot; + inliningMsg;
 237         }
 238         logInlining(debug, inliningMsg, args);
 239     }
 240 
 241     @SuppressWarnings(&quot;try&quot;)
 242     private static void logInlining(DebugContext debug, final String msg, final Object... args) {
 243         try (DebugContext.Scope s = debug.scope(inliningDecisionsScopeString)) {
 244             // Can&#39;t use log here since we are varargs
 245             if (debug.isLogEnabled()) {
 246                 debug.logv(msg, args);
 247             }
 248         }
 249     }
 250 
 251     @SuppressWarnings(&quot;try&quot;)
 252     private static boolean shouldLogMethod(DebugContext debug) {
 253         try (DebugContext.Scope s = debug.scope(inliningDecisionsScopeString)) {
 254             return debug.isLogEnabled();
 255         }
 256     }
 257 
 258     private static String methodName(ResolvedJavaMethod method, Invoke invoke) {
 259         if (invoke != null &amp;&amp; invoke.stateAfter() != null) {
 260             return methodName(invoke.stateAfter(), invoke.bci()) + &quot;: &quot; + method.format(&quot;%H.%n(%p):%r&quot;) + &quot; (&quot; + method.getCodeSize() + &quot; bytes)&quot;;
 261         } else {
 262             return method.format(&quot;%H.%n(%p):%r&quot;) + &quot; (&quot; + method.getCodeSize() + &quot; bytes)&quot;;
 263         }
 264     }
 265 
 266     private static String methodName(InlineInfo info) {
 267         if (info == null) {
 268             return &quot;null&quot;;
 269         } else if (info.invoke() != null &amp;&amp; info.invoke().stateAfter() != null) {
 270             return methodName(info.invoke().stateAfter(), info.invoke().bci()) + &quot;: &quot; + info.toString();
 271         } else {
 272             return info.toString();
 273         }
 274     }
 275 
 276     private static String methodName(FrameState frameState, int bci) {
 277         StringBuilder sb = new StringBuilder();
 278         if (frameState.outerFrameState() != null) {
 279             sb.append(methodName(frameState.outerFrameState(), frameState.outerFrameState().bci));
 280             sb.append(&quot;-&gt;&quot;);
 281         }
 282         ResolvedJavaMethod method = frameState.getMethod();
 283         sb.append(method != null ? method.format(&quot;%h.%n&quot;) : &quot;?&quot;);
 284         sb.append(&quot;@&quot;).append(bci);
 285         return sb.toString();
 286     }
 287 
 288     public static void replaceInvokeCallTarget(Invoke invoke, StructuredGraph graph, InvokeKind invokeKind, ResolvedJavaMethod targetMethod) {
 289         MethodCallTargetNode oldCallTarget = (MethodCallTargetNode) invoke.callTarget();
 290         MethodCallTargetNode newCallTarget = graph.add(new MethodCallTargetNode(invokeKind, targetMethod, oldCallTarget.arguments().toArray(new ValueNode[0]), oldCallTarget.returnStamp(),
 291                         oldCallTarget.getProfile()));
 292         invoke.asNode().replaceFirstInput(oldCallTarget, newCallTarget);
 293     }
 294 
 295     public static PiNode createAnchoredReceiver(StructuredGraph graph, GuardingNode anchor, ResolvedJavaType commonType, ValueNode receiver, boolean exact) {
 296         return createAnchoredReceiver(graph, anchor, receiver,
 297                         exact ? StampFactory.objectNonNull(TypeReference.createExactTrusted(commonType)) : StampFactory.objectNonNull(TypeReference.createTrusted(graph.getAssumptions(), commonType)));
 298     }
 299 
 300     private static PiNode createAnchoredReceiver(StructuredGraph graph, GuardingNode anchor, ValueNode receiver, Stamp stamp) {
 301         // to avoid that floating reads on receiver fields float above the type check
 302         return graph.unique(new PiNode(receiver, stamp, (ValueNode) anchor));
 303     }
 304 
 305     /**
 306      * @return null iff the check succeeds, otherwise a (non-null) descriptive message.
 307      */
 308     public static String checkInvokeConditions(Invoke invoke) {
 309         if (invoke.predecessor() == null || !invoke.asNode().isAlive()) {
 310             return &quot;the invoke is dead code&quot;;
 311         }
 312         if (!(invoke.callTarget() instanceof MethodCallTargetNode)) {
 313             return &quot;the invoke has already been lowered, or has been created as a low-level node&quot;;
 314         }
 315         MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
 316         if (callTarget.targetMethod() == null) {
 317             return &quot;target method is null&quot;;
 318         }
 319         assert invoke.stateAfter() != null : invoke;
 320         if (!invoke.useForInlining()) {
 321             return &quot;the invoke is marked to be not used for inlining&quot;;
 322         }
 323         ValueNode receiver = callTarget.receiver();
 324         if (receiver != null &amp;&amp; receiver.isConstant() &amp;&amp; receiver.isNullConstant()) {
 325             return &quot;receiver is null&quot;;
 326         }
 327         return null;
 328     }
 329 
 330     /**
 331      * Performs an actual inlining, thereby replacing the given invoke with the given
 332      * {@code inlineGraph}.
 333      *
 334      * @param invoke the invoke that will be replaced
 335      * @param inlineGraph the graph that the invoke will be replaced with
 336      * @param receiverNullCheck true if a null check needs to be generated for non-static inlinings,
 337      *            false if no such check is required
 338      * @param inlineeMethod the actual method being inlined. Maybe be null for snippets.
 339      */
 340     @SuppressWarnings(&quot;try&quot;)
 341     public static UnmodifiableEconomicMap&lt;Node, Node&gt; inline(Invoke invoke, StructuredGraph inlineGraph, boolean receiverNullCheck, ResolvedJavaMethod inlineeMethod) {
 342         try {
 343             return inline(invoke, inlineGraph, receiverNullCheck, inlineeMethod, &quot;reason not specified&quot;, &quot;phase not specified&quot;);
 344         } catch (GraalError ex) {
 345             ex.addContext(&quot;inlining into&quot;, invoke.asNode().graph().method());
 346             ex.addContext(&quot;inlinee&quot;, inlineGraph.method());
 347             throw ex;
 348         }
 349     }
 350 
 351     /**
 352      * Performs an actual inlining, thereby replacing the given invoke with the given
 353      * {@code inlineGraph}.
 354      *
 355      * @param invoke the invoke that will be replaced
 356      * @param inlineGraph the graph that the invoke will be replaced with
 357      * @param receiverNullCheck true if a null check needs to be generated for non-static inlinings,
 358      *            false if no such check is required
 359      * @param inlineeMethod the actual method being inlined. Maybe be null for snippets.
 360      * @param reason the reason for inlining, used in tracing
 361      * @param phase the phase that invoked inlining
 362      */
 363     @SuppressWarnings(&quot;try&quot;)
 364     public static UnmodifiableEconomicMap&lt;Node, Node&gt; inline(Invoke invoke, StructuredGraph inlineGraph, boolean receiverNullCheck, ResolvedJavaMethod inlineeMethod, String reason, String phase) {
 365         FixedNode invokeNode = invoke.asNode();
 366         StructuredGraph graph = invokeNode.graph();
 367         final NodeInputList&lt;ValueNode&gt; parameters = invoke.callTarget().arguments();
 368 
 369         assert inlineGraph.getGuardsStage().ordinal() &gt;= graph.getGuardsStage().ordinal();
 370         assert !invokeNode.graph().isAfterFloatingReadPhase() : &quot;inline isn&#39;t handled correctly after floating reads phase&quot;;
 371 
 372         if (receiverNullCheck &amp;&amp; !((MethodCallTargetNode) invoke.callTarget()).isStatic()) {
 373             nonNullReceiver(invoke);
 374         }
 375 
 376         ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(inlineGraph.getNodes().count());
 377         ArrayList&lt;ReturnNode&gt; returnNodes = new ArrayList&lt;&gt;(4);
 378         ArrayList&lt;Invoke&gt; partialIntrinsicExits = new ArrayList&lt;&gt;();
 379         UnwindNode unwindNode = null;
 380         final StartNode entryPointNode = inlineGraph.start();
 381         FixedNode firstCFGNode = entryPointNode.next();
 382         if (firstCFGNode == null) {
 383             throw new IllegalStateException(&quot;Inlined graph is in invalid state: &quot; + inlineGraph);
 384         }
 385         for (Node node : inlineGraph.getNodes()) {
<a name="6" id="anc6"></a><span class="line-modified"> 386             if (node == entryPointNode || (node == entryPointNode.stateAfter() &amp;&amp; node.usages().count() == 1) || node instanceof ParameterNode) {</span>
 387                 // Do nothing.
 388             } else {
 389                 nodes.add(node);
 390                 if (node instanceof ReturnNode) {
 391                     returnNodes.add((ReturnNode) node);
 392                 } else if (node instanceof Invoke) {
 393                     Invoke invokeInInlineGraph = (Invoke) node;
 394                     if (invokeInInlineGraph.bci() == BytecodeFrame.UNKNOWN_BCI) {
 395                         ResolvedJavaMethod target1 = inlineeMethod;
 396                         ResolvedJavaMethod target2 = invokeInInlineGraph.callTarget().targetMethod();
 397                         assert target1.equals(target2) : String.format(&quot;invoke in inlined method expected to be partial intrinsic exit (i.e., call to %s), not a call to %s&quot;,
 398                                         target1.format(&quot;%H.%n(%p)&quot;), target2.format(&quot;%H.%n(%p)&quot;));
 399                         partialIntrinsicExits.add(invokeInInlineGraph);
 400                     }
 401                 } else if (node instanceof UnwindNode) {
 402                     assert unwindNode == null;
 403                     unwindNode = (UnwindNode) node;
 404                 }
 405             }
 406         }
 407 
 408         final AbstractBeginNode prevBegin = AbstractBeginNode.prevBegin(invokeNode);
 409         DuplicationReplacement localReplacement = new DuplicationReplacement() {
 410 
 411             @Override
 412             public Node replacement(Node node) {
 413                 if (node instanceof ParameterNode) {
 414                     return parameters.get(((ParameterNode) node).index());
 415                 } else if (node == entryPointNode) {
 416                     return prevBegin;
 417                 }
 418                 return node;
 419             }
 420         };
 421 
 422         assert invokeNode.successors().first() != null : invoke;
 423         assert invokeNode.predecessor() != null;
 424 
 425         Mark mark = graph.getMark();
 426         // Instead, attach the inlining log of the child graph to the current inlining log.
 427         EconomicMap&lt;Node, Node&gt; duplicates;
 428         try (InliningLog.UpdateScope scope = graph.getInliningLog().openDefaultUpdateScope()) {
 429             duplicates = graph.addDuplicates(nodes, inlineGraph, inlineGraph.getNodeCount(), localReplacement);
 430             if (scope != null) {
 431                 graph.getInliningLog().addDecision(invoke, true, phase, duplicates, inlineGraph.getInliningLog(), reason);
 432             }
 433         }
 434 
 435         FrameState stateAfter = invoke.stateAfter();
 436         assert stateAfter == null || stateAfter.isAlive();
 437 
 438         FrameState stateAtExceptionEdge = null;
 439         if (invoke instanceof InvokeWithExceptionNode) {
 440             InvokeWithExceptionNode invokeWithException = ((InvokeWithExceptionNode) invoke);
 441             if (unwindNode != null) {
 442                 ExceptionObjectNode obj = (ExceptionObjectNode) invokeWithException.exceptionEdge();
 443                 stateAtExceptionEdge = obj.stateAfter();
 444             }
 445         }
 446 
 447         updateSourcePositions(invoke, inlineGraph, duplicates, !Objects.equals(inlineGraph.method(), inlineeMethod), mark);
 448         if (stateAfter != null) {
 449             processFrameStates(invoke, inlineGraph, duplicates, stateAtExceptionEdge, returnNodes.size() &gt; 1);
 450             int callerLockDepth = stateAfter.nestedLockDepth();
 451             if (callerLockDepth != 0) {
 452                 for (MonitorIdNode original : inlineGraph.getNodes(MonitorIdNode.TYPE)) {
 453                     MonitorIdNode monitor = (MonitorIdNode) duplicates.get(original);
 454                     processMonitorId(invoke.stateAfter(), monitor);
 455                 }
 456             }
 457         } else {
 458             assert checkContainsOnlyInvalidOrAfterFrameState(duplicates);
 459         }
 460 
 461         firstCFGNode = (FixedNode) duplicates.get(firstCFGNode);
 462         for (int i = 0; i &lt; returnNodes.size(); i++) {
 463             returnNodes.set(i, (ReturnNode) duplicates.get(returnNodes.get(i)));
 464         }
 465         for (Invoke exit : partialIntrinsicExits) {
 466             // A partial intrinsic exit must be replaced with a call to
 467             // the intrinsified method.
 468             Invoke dup = (Invoke) duplicates.get(exit.asNode());
<a name="7" id="anc7"></a><span class="line-modified"> 469             if (dup instanceof InvokeNode) {</span>
<span class="line-removed"> 470                 ((InvokeNode) dup).replaceWithNewBci(invoke.bci());</span>
<span class="line-removed"> 471             } else {</span>
<span class="line-removed"> 472                 ((InvokeWithExceptionNode) dup).replaceWithNewBci(invoke.bci());</span>
<span class="line-removed"> 473             }</span>
 474         }
 475         if (unwindNode != null) {
 476             unwindNode = (UnwindNode) duplicates.get(unwindNode);
 477         }
 478 
 479         finishInlining(invoke, graph, firstCFGNode, returnNodes, unwindNode, inlineGraph.getAssumptions(), inlineGraph);
 480         GraphUtil.killCFG(invokeNode);
 481 
 482         return duplicates;
 483     }
 484 
 485     /**
 486      * Inline {@code inlineGraph} into the current replacing the node {@code Invoke} and return the
 487      * set of nodes which should be canonicalized. The set should only contain nodes which modified
 488      * by the inlining since the current graph and {@code inlineGraph} are expected to already be
 489      * canonical.
 490      *
 491      * @param invoke
 492      * @param inlineGraph
 493      * @param receiverNullCheck
 494      * @param inlineeMethod
 495      * @return the set of nodes to canonicalize
 496      */
 497     @SuppressWarnings(&quot;try&quot;)
 498     public static EconomicSet&lt;Node&gt; inlineForCanonicalization(Invoke invoke, StructuredGraph inlineGraph, boolean receiverNullCheck, ResolvedJavaMethod inlineeMethod, String reason, String phase) {
 499         return inlineForCanonicalization(invoke, inlineGraph, receiverNullCheck, inlineeMethod, null, reason, phase);
 500     }
 501 
 502     @SuppressWarnings(&quot;try&quot;)
 503     public static EconomicSet&lt;Node&gt; inlineForCanonicalization(Invoke invoke, StructuredGraph inlineGraph, boolean receiverNullCheck, ResolvedJavaMethod inlineeMethod,
 504                     Consumer&lt;UnmodifiableEconomicMap&lt;Node, Node&gt;&gt; duplicatesConsumer, String reason, String phase) {
 505         EconomicSetNodeEventListener listener = new EconomicSetNodeEventListener();
 506         /*
 507          * This code relies on the fact that Graph.addDuplicates doesn&#39;t trigger the
 508          * NodeEventListener to track only nodes which were modified into the process of inlining
 509          * the graph into the current graph.
 510          */
 511         try (NodeEventScope nes = invoke.asNode().graph().trackNodeEvents(listener)) {
 512             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = InliningUtil.inline(invoke, inlineGraph, receiverNullCheck, inlineeMethod, reason, phase);
 513             if (duplicatesConsumer != null) {
 514                 duplicatesConsumer.accept(duplicates);
 515             }
 516         }
 517         return listener.getNodes();
 518     }
 519 
 520     @SuppressWarnings(&quot;try&quot;)
 521     private static ValueNode finishInlining(Invoke invoke, StructuredGraph graph, FixedNode firstNode, List&lt;ReturnNode&gt; returnNodes, UnwindNode unwindNode, Assumptions inlinedAssumptions,
 522                     StructuredGraph inlineGraph) {
 523         FixedNode invokeNode = invoke.asNode();
 524         FrameState stateAfter = invoke.stateAfter();
 525         assert stateAfter == null || stateAfter.isAlive();
 526 
 527         invokeNode.replaceAtPredecessor(firstNode);
 528 
 529         if (invoke instanceof InvokeWithExceptionNode) {
 530             InvokeWithExceptionNode invokeWithException = ((InvokeWithExceptionNode) invoke);
 531             if (unwindNode != null &amp;&amp; unwindNode.isAlive()) {
 532                 assert unwindNode.predecessor() != null;
 533                 assert invokeWithException.exceptionEdge().successors().count() == 1;
 534                 ExceptionObjectNode obj = (ExceptionObjectNode) invokeWithException.exceptionEdge();
<a name="8" id="anc8"></a><span class="line-modified"> 535                 obj.replaceAtUsages(unwindNode.exception());</span>










 536                 Node n = obj.next();
 537                 obj.setNext(null);
 538                 unwindNode.replaceAndDelete(n);
 539 
 540                 obj.replaceAtPredecessor(null);
 541                 obj.safeDelete();
 542             } else {
 543                 invokeWithException.killExceptionEdge();
 544             }
 545 
 546             // get rid of memory kill
<a name="9" id="anc9"></a><span class="line-modified"> 547             AbstractBeginNode begin = invokeWithException.next();</span>
<span class="line-removed"> 548             if (begin instanceof KillingBeginNode) {</span>
<span class="line-removed"> 549                 try (DebugCloseable position = begin.withNodeSourcePosition()) {</span>
<span class="line-removed"> 550                     AbstractBeginNode newBegin = new BeginNode();</span>
<span class="line-removed"> 551                     graph.addAfterFixed(begin, graph.add(newBegin));</span>
<span class="line-removed"> 552                     begin.replaceAtUsages(newBegin);</span>
<span class="line-removed"> 553                     graph.removeFixed(begin);</span>
<span class="line-removed"> 554                 }</span>
<span class="line-removed"> 555             }</span>
 556         } else {
 557             if (unwindNode != null &amp;&amp; unwindNode.isAlive()) {
 558                 try (DebugCloseable position = unwindNode.withNodeSourcePosition()) {
 559                     DeoptimizeNode deoptimizeNode = addDeoptimizeNode(graph, DeoptimizationAction.InvalidateRecompile, DeoptimizationReason.NotCompiledExceptionHandler);
 560                     unwindNode.replaceAndDelete(deoptimizeNode);
 561                 }
 562             }
 563         }
 564 
 565         ValueNode returnValue;
 566         if (!returnNodes.isEmpty()) {
 567             FixedNode n = invoke.next();
 568             invoke.setNext(null);
 569             if (returnNodes.size() == 1) {
 570                 ReturnNode returnNode = returnNodes.get(0);
 571                 returnValue = returnNode.result();
 572                 invokeNode.replaceAtUsages(returnValue);
 573                 returnNode.replaceAndDelete(n);
 574             } else {
 575                 MergeNode merge = graph.add(new MergeNode());
 576                 merge.setStateAfter(stateAfter);
 577                 returnValue = mergeReturns(merge, returnNodes);
 578                 invokeNode.replaceAtUsages(returnValue);
 579                 if (merge.isPhiAtMerge(returnValue)) {
 580                     fixFrameStates(graph, merge, (PhiNode) returnValue);
 581                 }
 582                 merge.setNext(n);
 583             }
 584         } else {
 585             returnValue = null;
 586             invokeNode.replaceAtUsages(null);
 587             GraphUtil.killCFG(invoke.next());
 588         }
 589 
 590         // Copy assumptions from inlinee to caller
 591         Assumptions assumptions = graph.getAssumptions();
 592         if (assumptions != null) {
 593             if (inlinedAssumptions != null) {
 594                 assumptions.record(inlinedAssumptions);
 595             }
 596         } else {
 597             assert inlinedAssumptions == null : String.format(&quot;cannot inline graph (%s) which makes assumptions into a graph (%s) that doesn&#39;t&quot;, inlineGraph, graph);
 598         }
 599 
 600         // Copy inlined methods from inlinee to caller
 601         graph.updateMethods(inlineGraph);
 602 
 603         // Update the set of accessed fields
 604         if (GraalOptions.GeneratePIC.getValue(graph.getOptions())) {
 605             graph.updateFields(inlineGraph);
 606         }
 607 
 608         if (inlineGraph.hasUnsafeAccess()) {
 609             graph.markUnsafeAccess();
 610         }
 611         assert inlineGraph.getSpeculationLog() == null || inlineGraph.getSpeculationLog() == graph.getSpeculationLog() : &quot;Only the root graph should have a speculation log&quot;;
 612 
 613         return returnValue;
 614     }
 615 
 616     private static void fixFrameStates(StructuredGraph graph, MergeNode originalMerge, PhiNode returnPhi) {
 617         // It is possible that some of the frame states that came from AFTER_BCI reference a Phi
 618         // node that was created to merge multiple returns. This can create cycles
 619         // (see GR-3949 and GR-3957).
 620         // To detect this, we follow the control paths starting from the merge node,
 621         // split the Phi node inputs at merges and assign the proper input to each frame state.
 622         NodeMap&lt;Node&gt; seen = new NodeMap&lt;&gt;(graph);
 623         ArrayDeque&lt;Node&gt; workList = new ArrayDeque&lt;&gt;();
 624         ArrayDeque&lt;ValueNode&gt; valueList = new ArrayDeque&lt;&gt;();
 625         workList.push(originalMerge);
 626         valueList.push(returnPhi);
 627         while (!workList.isEmpty()) {
 628             Node current = workList.pop();
 629             ValueNode currentValue = valueList.pop();
 630             if (seen.containsKey(current)) {
 631                 continue;
 632             }
 633             seen.put(current, current);
 634             if (current instanceof StateSplit &amp;&amp; current != originalMerge) {
 635                 StateSplit stateSplit = (StateSplit) current;
 636                 FrameState state = stateSplit.stateAfter();
 637                 if (state != null &amp;&amp; state.values().contains(returnPhi)) {
 638                     int index = 0;
 639                     FrameState duplicate = state.duplicate();
 640                     for (ValueNode value : state.values()) {
 641                         if (value == returnPhi) {
 642                             duplicate.values().set(index, currentValue);
 643                         }
 644                         index++;
 645                     }
 646                     stateSplit.setStateAfter(duplicate);
 647                     GraphUtil.tryKillUnused(state);
 648                 }
 649             }
 650             if (current instanceof AbstractMergeNode) {
 651                 AbstractMergeNode currentMerge = (AbstractMergeNode) current;
 652                 for (EndNode pred : currentMerge.cfgPredecessors()) {
 653                     ValueNode newValue = currentValue;
 654                     if (currentMerge.isPhiAtMerge(currentValue)) {
 655                         PhiNode currentPhi = (PhiNode) currentValue;
 656                         newValue = currentPhi.valueAt(pred);
 657                     }
 658                     workList.push(pred);
 659                     valueList.push(newValue);
 660                 }
 661             } else if (current.predecessor() != null) {
 662                 workList.push(current.predecessor());
 663                 valueList.push(currentValue);
 664             }
 665         }
 666     }
 667 
 668     @SuppressWarnings(&quot;try&quot;)
 669     private static void updateSourcePositions(Invoke invoke, StructuredGraph inlineGraph, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates, boolean isSub, Mark mark) {
 670         FixedNode invokeNode = invoke.asNode();
 671         StructuredGraph invokeGraph = invokeNode.graph();
 672         if (invokeGraph.trackNodeSourcePosition() &amp;&amp; invoke.stateAfter() != null) {
 673             boolean isSubstitution = isSub || inlineGraph.isSubstitution();
 674             assert !invokeGraph.trackNodeSourcePosition() || inlineGraph.trackNodeSourcePosition() ||
 675                             isSubstitution : String.format(&quot;trackNodeSourcePosition mismatch %s %s != %s %s&quot;, invokeGraph, invokeGraph.trackNodeSourcePosition(), inlineGraph,
 676                                             inlineGraph.trackNodeSourcePosition());
 677             final NodeSourcePosition invokePos = invoke.asNode().getNodeSourcePosition();
 678             updateSourcePosition(invokeGraph, duplicates, mark, invokePos, isSubstitution);
 679         }
 680     }
 681 
 682     public static void updateSourcePosition(StructuredGraph invokeGraph, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates, Mark mark, NodeSourcePosition invokePos, boolean isSubstitution) {
 683         /*
 684          * Not every duplicate node is newly created, so only update the position of the newly
 685          * created nodes.
 686          */
 687         EconomicSet&lt;Node&gt; newNodes = EconomicSet.create(Equivalence.DEFAULT);
 688         newNodes.addAll(invokeGraph.getNewNodes(mark));
 689         EconomicMap&lt;NodeSourcePosition, NodeSourcePosition&gt; posMap = EconomicMap.create(Equivalence.DEFAULT);
 690         UnmodifiableMapCursor&lt;Node, Node&gt; cursor = duplicates.getEntries();
 691         ResolvedJavaMethod inlineeRoot = null;
 692         while (cursor.advance()) {
 693             Node value = cursor.getValue();
 694             if (!newNodes.contains(value)) {
 695                 continue;
 696             }
 697             if (isSubstitution &amp;&amp; invokePos == null) {
 698                 // There&#39;s no caller information so the source position for this node will be
 699                 // invalid, so it should be cleared.
 700                 value.clearNodeSourcePosition();
 701             } else {
 702                 NodeSourcePosition pos = cursor.getKey().getNodeSourcePosition();
 703                 if (pos != null) {
 704                     if (inlineeRoot == null) {
 705                         assert (inlineeRoot = pos.getRootMethod()) != null;
 706                     } else {
 707                         assert pos.verifyRootMethod(inlineeRoot);
 708                     }
 709                     NodeSourcePosition callerPos = posMap.get(pos);
 710                     if (callerPos == null) {
 711                         callerPos = pos.addCaller(invokePos, isSubstitution);
 712                         posMap.put(pos, callerPos);
 713                     }
 714                     value.setNodeSourcePosition(callerPos);
 715 
 716                     if (value instanceof DeoptimizingGuard) {
 717                         ((DeoptimizingGuard) value).addCallerToNoDeoptSuccessorPosition(callerPos.getCaller());
 718                     }
 719                 } else {
 720                     if (isSubstitution) {
 721                         /*
 722                          * If no other position is provided at least attribute the substituted node
 723                          * to the original invoke.
 724                          */
 725                         value.setNodeSourcePosition(invokePos);
 726                     }
 727                 }
 728             }
 729         }
 730         assert invokeGraph.verifySourcePositions(false);
 731     }
 732 
 733     public static void processMonitorId(FrameState stateAfter, MonitorIdNode monitorIdNode) {
 734         if (stateAfter != null) {
 735             int callerLockDepth = stateAfter.nestedLockDepth();
 736             monitorIdNode.setLockDepth(monitorIdNode.getLockDepth() + callerLockDepth);
 737         }
 738     }
 739 
 740     protected static void processFrameStates(Invoke invoke, StructuredGraph inlineGraph, EconomicMap&lt;Node, Node&gt; duplicates, FrameState stateAtExceptionEdge,
 741                     boolean alwaysDuplicateStateAfter) {
 742         FrameState stateAtReturn = invoke.stateAfter();
 743         FrameState outerFrameState = null;
 744         JavaKind invokeReturnKind = invoke.asNode().getStackKind();
<a name="10" id="anc10"></a><span class="line-modified"> 745         EconomicMap&lt;Node, Node&gt; replacements = EconomicMap.create();</span>
 746         for (FrameState original : inlineGraph.getNodes(FrameState.TYPE)) {
 747             FrameState frameState = (FrameState) duplicates.get(original);
 748             if (frameState != null &amp;&amp; frameState.isAlive()) {
 749                 if (outerFrameState == null) {
 750                     outerFrameState = stateAtReturn.duplicateModifiedDuringCall(invoke.bci(), invokeReturnKind);
 751                 }
 752                 processFrameState(frameState, invoke, replacements, inlineGraph.method(), stateAtExceptionEdge, outerFrameState, alwaysDuplicateStateAfter, invoke.callTarget().targetMethod(),
 753                                 invoke.callTarget().arguments());
 754             }
 755         }
 756         // If processing the frame states replaced any nodes, update the duplicates map.
 757         duplicates.replaceAll((key, value) -&gt; replacements.containsKey(value) ? replacements.get(value) : value);
 758     }
 759 
 760     public static FrameState processFrameState(FrameState frameState, Invoke invoke, EconomicMap&lt;Node, Node&gt; replacements, ResolvedJavaMethod inlinedMethod, FrameState stateAtExceptionEdge,
 761                     FrameState outerFrameState,
 762                     boolean alwaysDuplicateStateAfter, ResolvedJavaMethod invokeTargetMethod, List&lt;ValueNode&gt; invokeArgsList) {
 763         assert outerFrameState == null || !outerFrameState.isDeleted() : outerFrameState;
 764         final FrameState stateAtReturn = invoke.stateAfter();
 765         JavaKind invokeReturnKind = invoke.asNode().getStackKind();
 766 
 767         if (frameState.bci == BytecodeFrame.AFTER_BCI) {
 768             return handleAfterBciFrameState(frameState, invoke, alwaysDuplicateStateAfter);
 769         } else if (stateAtExceptionEdge != null &amp;&amp; isStateAfterException(frameState)) {
 770             // pop exception object from invoke&#39;s stateAfter and replace with this frameState&#39;s
 771             // exception object (top of stack)
 772             FrameState stateAfterException = stateAtExceptionEdge;
 773             if (frameState.stackSize() &gt; 0 &amp;&amp; stateAtExceptionEdge.stackAt(0) != frameState.stackAt(0)) {
 774                 stateAfterException = stateAtExceptionEdge.duplicateModified(JavaKind.Object, JavaKind.Object, frameState.stackAt(0));
 775             }
 776             frameState.replaceAndDelete(stateAfterException);
 777             return stateAfterException;
 778         } else if ((frameState.bci == BytecodeFrame.UNWIND_BCI &amp;&amp; frameState.graph().getGuardsStage() == GuardsStage.FLOATING_GUARDS) || frameState.bci == BytecodeFrame.AFTER_EXCEPTION_BCI) {
 779             /*
 780              * This path converts the frame states relevant for exception unwinding to
 781              * deoptimization. This is only allowed in configurations when Graal compiles code for
 782              * speculative execution (e.g., JIT compilation in HotSpot) but not when compiled code
 783              * must be deoptimization free (e.g., AOT compilation for native image generation).
 784              * There is currently no global flag in StructuredGraph to distinguish such modes, but
 785              * the GuardsStage during inlining indicates the mode in which Graal operates.
 786              */
 787             handleMissingAfterExceptionFrameState(frameState, invoke, replacements, alwaysDuplicateStateAfter);
 788             return frameState;
 789         } else if (frameState.bci == BytecodeFrame.BEFORE_BCI) {
 790             // This is an intrinsic. Deoptimizing within an intrinsic
 791             // must re-execute the intrinsified invocation
 792             assert frameState.outerFrameState() == null;
 793             ValueNode[] invokeArgs = invokeArgsList.isEmpty() ? NO_ARGS : invokeArgsList.toArray(new ValueNode[invokeArgsList.size()]);
 794             FrameState stateBeforeCall = stateAtReturn.duplicateModifiedBeforeCall(invoke.bci(), invokeReturnKind, invokeTargetMethod.getSignature().toParameterKinds(!invokeTargetMethod.isStatic()),
 795                             invokeArgs);
 796             frameState.replaceAndDelete(stateBeforeCall);
 797             return stateBeforeCall;
 798         } else {
 799             // only handle the outermost frame states
 800             if (frameState.outerFrameState() == null) {
 801                 assert checkInlineeFrameState(invoke, inlinedMethod, frameState);
 802                 frameState.setOuterFrameState(outerFrameState);
 803             }
 804             return frameState;
 805         }
 806     }
 807 
 808     private static FrameState handleAfterBciFrameState(FrameState frameState, Invoke invoke, boolean alwaysDuplicateStateAfter) {
 809         FrameState stateAtReturn = invoke.stateAfter();
 810         JavaKind invokeReturnKind = invoke.asNode().getStackKind();
 811         FrameState stateAfterReturn = stateAtReturn;
 812         if (frameState.getCode() == null) {
 813             // This is a frame state for a side effect within an intrinsic
 814             // that was parsed for post-parse intrinsification
 815             for (Node usage : frameState.usages()) {
 816                 if (usage instanceof ForeignCallNode) {
 817                     // A foreign call inside an intrinsic needs to have
 818                     // the BCI of the invoke being intrinsified
 819                     ForeignCallNode foreign = (ForeignCallNode) usage;
 820                     foreign.setBci(invoke.bci());
 821                 }
 822             }
 823         }
 824 
 825         // pop return kind from invoke&#39;s stateAfter and replace with this frameState&#39;s return
 826         // value (top of stack)
 827         assert !frameState.rethrowException() : frameState;
 828         if (frameState.stackSize() &gt; 0 &amp;&amp; (alwaysDuplicateStateAfter || stateAfterReturn.stackAt(0) != frameState.stackAt(0))) {
 829             // A non-void return value.
 830             stateAfterReturn = stateAtReturn.duplicateModified(invokeReturnKind, invokeReturnKind, frameState.stackAt(0));
 831         } else {
 832             // A void return value.
 833             stateAfterReturn = stateAtReturn.duplicate();
 834         }
 835         assert stateAfterReturn.bci != BytecodeFrame.UNKNOWN_BCI;
 836 
 837         // Return value does no longer need to be limited by the monitor exit.
 838         for (MonitorExitNode n : frameState.usages().filter(MonitorExitNode.class)) {
<a name="11" id="anc11"></a><span class="line-modified"> 839             n.clearEscapedReturnValue();</span>
 840         }
 841 
 842         frameState.replaceAndDelete(stateAfterReturn);
 843         return stateAfterReturn;
 844     }
 845 
 846     static boolean checkInlineeFrameState(Invoke invoke, ResolvedJavaMethod inlinedMethod, FrameState frameState) {
 847         assert frameState.bci != BytecodeFrame.AFTER_EXCEPTION_BCI : frameState;
 848         assert frameState.bci != BytecodeFrame.BEFORE_BCI : frameState;
 849         assert frameState.bci != BytecodeFrame.UNKNOWN_BCI : frameState;
 850         if (frameState.bci != BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 851             ResolvedJavaMethod method = frameState.getMethod();
 852             if (method.equals(inlinedMethod)) {
 853                 // Normal inlining expects all outermost inlinee frame states to
 854                 // denote the inlinee method
 855             } else if (method.equals(invoke.callTarget().targetMethod())) {
 856                 // This occurs when an intrinsic calls back to the original
 857                 // method to handle a slow path. During parsing of such a
 858                 // partial intrinsic, these calls are given frame states
 859                 // that exclude the outer frame state denoting a position
 860                 // in the intrinsic code.
 861                 assert inlinedMethod.getAnnotation(
 862                                 MethodSubstitution.class) != null : &quot;expected an intrinsic when inlinee frame state matches method of call target but does not match the method of the inlinee graph: &quot; +
 863                                                 frameState;
 864             } else if (method.getName().equals(inlinedMethod.getName())) {
 865                 // This can happen for method substitutions.
 866             } else {
 867                 throw new AssertionError(String.format(&quot;inlinedMethod=%s frameState.method=%s frameState=%s invoke.method=%s&quot;, inlinedMethod, method, frameState,
 868                                 invoke.callTarget().targetMethod()));
 869             }
 870         }
 871         return true;
 872     }
 873 
 874     private static final ValueNode[] NO_ARGS = {};
 875 
 876     private static boolean isStateAfterException(FrameState frameState) {
 877         return frameState.bci == BytecodeFrame.AFTER_EXCEPTION_BCI || (frameState.bci == BytecodeFrame.UNWIND_BCI &amp;&amp; !frameState.getMethod().isSynchronized());
 878     }
 879 
 880     @SuppressWarnings(&quot;try&quot;)
 881     public static FrameState handleMissingAfterExceptionFrameState(FrameState nonReplaceableFrameState, Invoke invoke, EconomicMap&lt;Node, Node&gt; replacements, boolean alwaysDuplicateStateAfter) {
 882         StructuredGraph graph = nonReplaceableFrameState.graph();
 883         NodeWorkList workList = graph.createNodeWorkList();
 884         workList.add(nonReplaceableFrameState);
 885         for (Node node : workList) {
 886             FrameState fs = (FrameState) node;
 887             for (Node usage : fs.usages().snapshot()) {
 888                 if (!usage.isAlive()) {
 889                     continue;
 890                 }
 891                 if (usage instanceof FrameState) {
 892                     workList.add(usage);
 893                 } else {
 894                     StateSplit stateSplit = (StateSplit) usage;
 895                     FixedNode fixedStateSplit = stateSplit.asNode();
 896                     if (fixedStateSplit instanceof AbstractMergeNode) {
 897                         AbstractMergeNode merge = (AbstractMergeNode) fixedStateSplit;
 898                         while (merge.isAlive()) {
 899                             AbstractEndNode end = merge.forwardEnds().first();
 900                             try (DebugCloseable position = end.withNodeSourcePosition()) {
 901                                 DeoptimizeNode deoptimizeNode = addDeoptimizeNode(graph, DeoptimizationAction.InvalidateRecompile, DeoptimizationReason.NotCompiledExceptionHandler);
 902                                 end.replaceAtPredecessor(deoptimizeNode);
 903                                 GraphUtil.killCFG(end);
 904                             }
 905                         }
 906                     } else if (fixedStateSplit instanceof ExceptionObjectNode) {
 907                         // The target invoke does not have an exception edge. This means that the
 908                         // bytecode parser made the wrong assumption of making an
 909                         // InvokeWithExceptionNode for the partial intrinsic exit. We therefore
 910                         // replace the InvokeWithExceptionNode with a normal
 911                         // InvokeNode -- the deoptimization occurs when the invoke throws.
 912                         InvokeWithExceptionNode oldInvoke = (InvokeWithExceptionNode) fixedStateSplit.predecessor();
 913                         InvokeNode newInvoke = oldInvoke.replaceWithInvoke();
 914                         if (replacements != null) {
 915                             replacements.put(oldInvoke, newInvoke);
 916                         }
 917                         handleAfterBciFrameState(newInvoke.stateAfter(), invoke, alwaysDuplicateStateAfter);
 918                     } else {
 919                         try (DebugCloseable position = fixedStateSplit.withNodeSourcePosition()) {
 920                             FixedNode deoptimizeNode = addDeoptimizeNode(graph, DeoptimizationAction.InvalidateRecompile, DeoptimizationReason.NotCompiledExceptionHandler);
 921                             if (fixedStateSplit instanceof AbstractBeginNode) {
 922                                 deoptimizeNode = BeginNode.begin(deoptimizeNode);
 923                             }
 924                             fixedStateSplit.replaceAtPredecessor(deoptimizeNode);
 925                             GraphUtil.killCFG(fixedStateSplit);
 926                         }
 927                     }
 928                 }
 929             }
 930         }
 931         return nonReplaceableFrameState;
 932     }
 933 
 934     private static DeoptimizeNode addDeoptimizeNode(StructuredGraph graph, DeoptimizationAction action, DeoptimizationReason reason) {
 935         GraalError.guarantee(graph.getGuardsStage() == GuardsStage.FLOATING_GUARDS, &quot;Cannot introduce speculative deoptimization when Graal is used with fixed guards&quot;);
 936         return graph.add(new DeoptimizeNode(action, reason));
 937     }
 938 
 939     /**
 940      * Ensure that all states are either {@link BytecodeFrame#INVALID_FRAMESTATE_BCI} or one of
 941      * {@link BytecodeFrame#AFTER_BCI} or {@link BytecodeFrame#BEFORE_BCI}. Mixing of before and
 942      * after isn&#39;t allowed.
 943      */
 944     private static boolean checkContainsOnlyInvalidOrAfterFrameState(UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
 945         int okBci = BytecodeFrame.INVALID_FRAMESTATE_BCI;
 946         for (Node node : duplicates.getValues()) {
 947             if (node instanceof FrameState) {
 948                 FrameState frameState = (FrameState) node;
 949                 if (frameState.bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 950                     continue;
 951                 }
 952                 if (frameState.bci == BytecodeFrame.AFTER_BCI || frameState.bci == BytecodeFrame.BEFORE_BCI) {
 953                     if (okBci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 954                         okBci = frameState.bci;
 955                     } else {
 956                         assert okBci == frameState.bci : node.toString(Verbosity.Debugger);
 957                     }
 958                 } else {
 959                     assert false : node.toString(Verbosity.Debugger);
 960                 }
 961             }
 962         }
 963         return true;
 964     }
 965 
 966     /**
 967      * Gets the receiver for an invoke, adding a guard if necessary to ensure it is non-null, and
 968      * ensuring that the resulting type is compatible with the method being invoked.
 969      */
 970     @SuppressWarnings(&quot;try&quot;)
 971     public static ValueNode nonNullReceiver(Invoke invoke) {
 972         try (DebugCloseable position = invoke.asNode().withNodeSourcePosition()) {
 973             MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
 974             assert !callTarget.isStatic() : callTarget.targetMethod();
 975             StructuredGraph graph = callTarget.graph();
 976             ValueNode oldReceiver = callTarget.arguments().get(0);
 977             ValueNode newReceiver = oldReceiver;
 978             if (newReceiver.getStackKind() == JavaKind.Object) {
 979 
 980                 if (invoke.getInvokeKind() == InvokeKind.Special) {
 981                     Stamp paramStamp = newReceiver.stamp(NodeView.DEFAULT);
 982                     Stamp stamp = paramStamp.join(StampFactory.object(TypeReference.create(graph.getAssumptions(), callTarget.targetMethod().getDeclaringClass())));
 983                     if (!stamp.equals(paramStamp)) {
 984                         // The verifier and previous optimizations guarantee unconditionally that
 985                         // the
 986                         // receiver is at least of the type of the method holder for a special
 987                         // invoke.
 988                         newReceiver = graph.unique(new PiNode(newReceiver, stamp));
 989                     }
 990                 }
 991 
 992                 if (!StampTool.isPointerNonNull(newReceiver)) {
 993                     LogicNode condition = graph.unique(IsNullNode.create(newReceiver));
 994                     FixedGuardNode fixedGuard = graph.add(new FixedGuardNode(condition, NullCheckException, InvalidateReprofile, true));
 995                     PiNode nonNullReceiver = graph.unique(new PiNode(newReceiver, StampFactory.objectNonNull(), fixedGuard));
 996                     graph.addBeforeFixed(invoke.asNode(), fixedGuard);
 997                     newReceiver = nonNullReceiver;
 998                 }
 999             }
1000 
1001             if (newReceiver != oldReceiver) {
1002                 callTarget.replaceFirstInput(oldReceiver, newReceiver);
1003             }
1004             return newReceiver;
1005         }
1006     }
1007 
<a name="12" id="anc12"></a><span class="line-removed">1008     public static boolean canIntrinsify(Replacements replacements, ResolvedJavaMethod target, int invokeBci) {</span>
<span class="line-removed">1009         return replacements.hasSubstitution(target, invokeBci);</span>
<span class="line-removed">1010     }</span>
<span class="line-removed">1011 </span>
<span class="line-removed">1012     public static StructuredGraph getIntrinsicGraph(Replacements replacements, ResolvedJavaMethod target, int invokeBci, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>
<span class="line-removed">1013         return replacements.getSubstitution(target, invokeBci, trackNodeSourcePosition, replaceePosition);</span>
<span class="line-removed">1014     }</span>
<span class="line-removed">1015 </span>
1016     /**
1017      * This method exclude InstrumentationNode from inlining heuristics.
1018      */
1019     public static int getNodeCount(StructuredGraph graph) {
1020         return graph.getNodeCount();
1021     }
1022 
1023 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
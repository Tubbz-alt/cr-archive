<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RemoveValueProxyPhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="inlining/InliningUtil.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 39,13 ***</span>
<span class="line-new-header">--- 39,15 ---</span>
  import org.graalvm.compiler.nodes.BeginNode;
  import org.graalvm.compiler.nodes.CompressionNode;
  import org.graalvm.compiler.nodes.DeoptimizeNode;
  import org.graalvm.compiler.nodes.DeoptimizingFixedWithNextNode;
  import org.graalvm.compiler.nodes.DynamicDeoptimizeNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.EndNode;</span>
  import org.graalvm.compiler.nodes.FixedNode;
  import org.graalvm.compiler.nodes.IfNode;
  import org.graalvm.compiler.nodes.LogicNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.LoopExitNode;</span>
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.ValuePhiNode;
  import org.graalvm.compiler.nodes.calc.IsNullNode;
  import org.graalvm.compiler.nodes.extended.NullCheckNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,10 ***</span>
<span class="line-new-header">--- 115,11 ---</span>
                      return;
                  }
                  reasons = reasonPhi.values().snapshot();
                  expectedPhis++;
              } else if (!reason.isConstant()) {
<span class="line-added">+                 merge.getDebug().log(&quot;Non constant reason %s&quot;, merge);</span>
                  return;
              }
  
              ValueNode speculation = deopt.getSpeculation();
              ValuePhiNode speculationPhi = null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,43 ***</span>
              if (merge.phis().count() != expectedPhis) {
                  return;
              }
  
              int index = 0;
<span class="line-modified">!             for (AbstractEndNode end : merge.cfgPredecessors().snapshot()) {</span>
                  ValueNode thisReason = reasons != null ? reasons.get(index) : reason;
<span class="line-modified">!                 ValueNode thisSpeculation = speculations != null ? speculations.get(index++) : speculation;</span>
<span class="line-modified">!                 if (!thisReason.isConstant() || !thisSpeculation.isConstant()) {</span>
<span class="line-modified">!                     continue;</span>
                  }
<span class="line-modified">!                 Speculation speculationConstant = metaAccessProvider.decodeSpeculation(thisSpeculation.asJavaConstant(), deopt.graph().getSpeculationLog());</span>
<span class="line-modified">!                 if (!speculationConstant.equals(SpeculationLog.NO_SPECULATION)) {</span>
                      continue;
                  }
                  DeoptimizationReason deoptimizationReason = metaAccessProvider.decodeDeoptReason(thisReason.asJavaConstant());
<span class="line-modified">!                 tryUseTrappingNullCheck(deopt, end.predecessor(), deoptimizationReason, SpeculationLog.NO_SPECULATION, implicitNullCheckLimit);</span>
              }
          }
      }
  
      private static void tryUseTrappingNullCheck(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, Speculation speculation, long implicitNullCheckLimit) {
<span class="line-modified">!         if (deoptimizationReason != DeoptimizationReason.NullCheckException &amp;&amp; deoptimizationReason != DeoptimizationReason.UnreachedCode) {</span>
              return;
          }
          assert speculation != null;
          if (!speculation.equals(SpeculationLog.NO_SPECULATION)) {
              return;
          }
<span class="line-modified">!         if (predecessor instanceof AbstractMergeNode) {</span>
<span class="line-modified">!             AbstractMergeNode merge = (AbstractMergeNode) predecessor;</span>
              if (merge.phis().isEmpty()) {
                  for (AbstractEndNode end : merge.cfgPredecessors().snapshot()) {
                      checkPredecessor(deopt, end.predecessor(), deoptimizationReason, implicitNullCheckLimit);
                  }
              }
<span class="line-modified">!         } else if (predecessor instanceof AbstractBeginNode) {</span>
<span class="line-modified">!             checkPredecessor(deopt, predecessor, deoptimizationReason, implicitNullCheckLimit);</span>
          }
      }
  
      private static void checkPredecessor(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, long implicitNullCheckLimit) {
          Node current = predecessor;
<span class="line-new-header">--- 136,65 ---</span>
              if (merge.phis().count() != expectedPhis) {
                  return;
              }
  
              int index = 0;
<span class="line-modified">!             List&lt;EndNode&gt; predecessors = merge.cfgPredecessors().snapshot();</span>
<span class="line-added">+             for (AbstractEndNode end : predecessors) {</span>
<span class="line-added">+                 Node endPredecesssor = end.predecessor();</span>
                  ValueNode thisReason = reasons != null ? reasons.get(index) : reason;
<span class="line-modified">!                 ValueNode thisSpeculation = speculations != null ? speculations.get(index) : speculation;</span>
<span class="line-modified">!                 if (!merge.isAlive()) {</span>
<span class="line-modified">!                     // When evacuating a merge the last successor simplfies the merge away so it</span>
<span class="line-added">+                     // must be handled specially.</span>
<span class="line-added">+                     assert predecessors.get(predecessors.size() - 1) == end : &quot;must be last end&quot;;</span>
<span class="line-added">+                     endPredecesssor = deopt.predecessor();</span>
<span class="line-added">+                     thisSpeculation = deopt.getSpeculation();</span>
<span class="line-added">+                     thisReason = deopt.getActionAndReason();</span>
                  }
<span class="line-modified">! </span>
<span class="line-modified">!                 index++;</span>
<span class="line-added">+                 if (!thisReason.isConstant() || !thisSpeculation.isConstant()) {</span>
<span class="line-added">+                     end.getDebug().log(&quot;Non constant deopt %s&quot;, end);</span>
                      continue;
                  }
                  DeoptimizationReason deoptimizationReason = metaAccessProvider.decodeDeoptReason(thisReason.asJavaConstant());
<span class="line-modified">!                 Speculation speculationConstant = metaAccessProvider.decodeSpeculation(thisSpeculation.asJavaConstant(), deopt.graph().getSpeculationLog());</span>
<span class="line-added">+                 tryUseTrappingNullCheck(deopt, endPredecesssor, deoptimizationReason, speculationConstant, implicitNullCheckLimit);</span>
              }
          }
      }
  
      private static void tryUseTrappingNullCheck(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, Speculation speculation, long implicitNullCheckLimit) {
<span class="line-modified">!         assert predecessor != null;</span>
<span class="line-added">+         if (deoptimizationReason != DeoptimizationReason.NullCheckException &amp;&amp; deoptimizationReason != DeoptimizationReason.UnreachedCode &amp;&amp;</span>
<span class="line-added">+                         deoptimizationReason != DeoptimizationReason.TypeCheckedInliningViolated) {</span>
<span class="line-added">+             deopt.getDebug().log(DebugContext.INFO_LEVEL, &quot;Not a null check or unreached %s&quot;, predecessor);</span>
              return;
          }
          assert speculation != null;
          if (!speculation.equals(SpeculationLog.NO_SPECULATION)) {
<span class="line-added">+             deopt.getDebug().log(DebugContext.INFO_LEVEL, &quot;Has a speculation %s&quot;, predecessor);</span>
              return;
          }
<span class="line-modified">! </span>
<span class="line-modified">!         // Skip over loop exit nodes.</span>
<span class="line-added">+         Node pred = predecessor;</span>
<span class="line-added">+         while (pred instanceof LoopExitNode) {</span>
<span class="line-added">+             pred = pred.predecessor();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (pred instanceof AbstractMergeNode) {</span>
<span class="line-added">+             AbstractMergeNode merge = (AbstractMergeNode) pred;</span>
              if (merge.phis().isEmpty()) {
                  for (AbstractEndNode end : merge.cfgPredecessors().snapshot()) {
                      checkPredecessor(deopt, end.predecessor(), deoptimizationReason, implicitNullCheckLimit);
                  }
              }
<span class="line-modified">!         } else if (pred instanceof AbstractBeginNode) {</span>
<span class="line-modified">!             checkPredecessor(deopt, pred, deoptimizationReason, implicitNullCheckLimit);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             deopt.getDebug().log(DebugContext.INFO_LEVEL, &quot;Not a Begin or Merge %s&quot;, pred);</span>
          }
      }
  
      private static void checkPredecessor(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, long implicitNullCheckLimit) {
          Node current = predecessor;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,19 ***</span>
<span class="line-new-header">--- 255,21 ---</span>
                          fixedAccessNode.setStateBefore(deopt.stateBefore());
                          fixedAccessNode.setNullCheck(true);
                          deopt.graph().removeSplit(ifNode, nonTrappingContinuation);
                          trappingNullCheck = fixedAccessNode;
                          counterTrappingNullCheckExistingRead.increment(debug);
<span class="line-added">+                         deopt.getDebug().log(&quot;Added implicit null check to %s&quot;, fixedAccessNode);</span>
                      }
                  }
              }
          }
  
          if (trappingNullCheck == null) {
              // Need to add a null check node.
              trappingNullCheck = deopt.graph().add(new NullCheckNode(value));
              deopt.graph().replaceSplit(ifNode, trappingNullCheck, nonTrappingContinuation);
<span class="line-added">+             deopt.getDebug().log(&quot;Inserted NullCheckNode %s&quot;, trappingNullCheck);</span>
          }
  
          trappingNullCheck.setStateBefore(deopt.stateBefore());
  
          /*
</pre>
<center><a href="RemoveValueProxyPhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="inlining/InliningUtil.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
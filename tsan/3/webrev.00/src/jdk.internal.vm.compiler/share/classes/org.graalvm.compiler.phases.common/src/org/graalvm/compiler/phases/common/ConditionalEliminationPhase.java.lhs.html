<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ConditionalEliminationPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.phases.common;
  26 
  27 import static org.graalvm.compiler.nodes.StaticDeoptimizingNode.mergeActions;
<a name="2" id="anc2"></a>


  28 
  29 import java.util.ArrayDeque;
  30 import java.util.Deque;
  31 import java.util.List;
  32 
  33 import jdk.internal.vm.compiler.collections.EconomicMap;
  34 import jdk.internal.vm.compiler.collections.Equivalence;
  35 import jdk.internal.vm.compiler.collections.MapCursor;
  36 import jdk.internal.vm.compiler.collections.Pair;
  37 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;
  38 import org.graalvm.compiler.core.common.cfg.BlockMap;
  39 import org.graalvm.compiler.core.common.type.ArithmeticOpTable;
  40 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;
  41 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.And;
  42 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.Or;
  43 import org.graalvm.compiler.core.common.type.IntegerStamp;
  44 import org.graalvm.compiler.core.common.type.ObjectStamp;
  45 import org.graalvm.compiler.core.common.type.Stamp;
  46 import org.graalvm.compiler.core.common.type.StampFactory;
  47 import org.graalvm.compiler.debug.CounterKey;
  48 import org.graalvm.compiler.debug.DebugCloseable;
  49 import org.graalvm.compiler.debug.DebugContext;
  50 import org.graalvm.compiler.graph.Node;
  51 import org.graalvm.compiler.graph.NodeMap;
  52 import org.graalvm.compiler.graph.NodeStack;
  53 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
  54 import org.graalvm.compiler.nodeinfo.InputType;
  55 import org.graalvm.compiler.nodes.AbstractBeginNode;
  56 import org.graalvm.compiler.nodes.AbstractMergeNode;
  57 import org.graalvm.compiler.nodes.BinaryOpLogicNode;
  58 import org.graalvm.compiler.nodes.ConditionAnchorNode;
<a name="3" id="anc3"></a>
  59 import org.graalvm.compiler.nodes.DeoptimizingGuard;
  60 import org.graalvm.compiler.nodes.EndNode;
  61 import org.graalvm.compiler.nodes.FixedGuardNode;
  62 import org.graalvm.compiler.nodes.FixedNode;
  63 import org.graalvm.compiler.nodes.FixedWithNextNode;
  64 import org.graalvm.compiler.nodes.GuardNode;
  65 import org.graalvm.compiler.nodes.IfNode;
  66 import org.graalvm.compiler.nodes.LogicConstantNode;
  67 import org.graalvm.compiler.nodes.LogicNode;
  68 import org.graalvm.compiler.nodes.LoopExitNode;
  69 import org.graalvm.compiler.nodes.MergeNode;
  70 import org.graalvm.compiler.nodes.NodeView;
<a name="4" id="anc4"></a><span class="line-removed">  71 import org.graalvm.compiler.nodes.ParameterNode;</span>
  72 import org.graalvm.compiler.nodes.PiNode;
  73 import org.graalvm.compiler.nodes.ProxyNode;
<a name="5" id="anc5"></a><span class="line-removed">  74 import org.graalvm.compiler.nodes.ShortCircuitOrNode;</span>
  75 import org.graalvm.compiler.nodes.StructuredGraph;
  76 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
  77 import org.graalvm.compiler.nodes.UnaryOpLogicNode;
  78 import org.graalvm.compiler.nodes.ValueNode;
  79 import org.graalvm.compiler.nodes.ValuePhiNode;
  80 import org.graalvm.compiler.nodes.calc.AndNode;
<a name="6" id="anc6"></a><span class="line-removed">  81 import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;</span>
<span class="line-removed">  82 import org.graalvm.compiler.nodes.calc.BinaryNode;</span>
  83 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
<a name="7" id="anc7"></a><span class="line-removed">  84 import org.graalvm.compiler.nodes.calc.UnaryNode;</span>
  85 import org.graalvm.compiler.nodes.cfg.Block;
  86 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  87 import org.graalvm.compiler.nodes.extended.GuardingNode;
  88 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
  89 import org.graalvm.compiler.nodes.extended.LoadHubNode;
  90 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;
<a name="8" id="anc8"></a>
  91 import org.graalvm.compiler.nodes.java.TypeSwitchNode;
<a name="9" id="anc9"></a>
  92 import org.graalvm.compiler.nodes.spi.NodeWithState;
  93 import org.graalvm.compiler.nodes.spi.StampInverter;
  94 import org.graalvm.compiler.nodes.util.GraphUtil;
  95 import org.graalvm.compiler.phases.BasePhase;
<a name="10" id="anc10"></a>






  96 import org.graalvm.compiler.phases.schedule.SchedulePhase;
  97 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
<a name="11" id="anc11"></a><span class="line-removed">  98 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
  99 
 100 import jdk.vm.ci.meta.DeoptimizationAction;
<a name="12" id="anc12"></a><span class="line-removed"> 101 import jdk.vm.ci.meta.JavaConstant;</span>
 102 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 103 import jdk.vm.ci.meta.TriState;
 104 
<a name="13" id="anc13"></a><span class="line-modified"> 105 public class ConditionalEliminationPhase extends BasePhase&lt;PhaseContext&gt; {</span>
 106 
 107     private static final CounterKey counterStampsRegistered = DebugContext.counter(&quot;StampsRegistered&quot;);
<a name="14" id="anc14"></a><span class="line-removed"> 108     private static final CounterKey counterStampsFound = DebugContext.counter(&quot;StampsFound&quot;);</span>
 109     private static final CounterKey counterIfsKilled = DebugContext.counter(&quot;CE_KilledIfs&quot;);
 110     private static final CounterKey counterPhiStampsImproved = DebugContext.counter(&quot;CE_ImprovedPhis&quot;);
 111     private final boolean fullSchedule;
 112     private final boolean moveGuards;
 113 
 114     public ConditionalEliminationPhase(boolean fullSchedule) {
 115         this(fullSchedule, true);
 116     }
 117 
 118     public ConditionalEliminationPhase(boolean fullSchedule, boolean moveGuards) {
 119         this.fullSchedule = fullSchedule;
 120         this.moveGuards = moveGuards;
 121     }
 122 
 123     @Override
 124     @SuppressWarnings(&quot;try&quot;)
<a name="15" id="anc15"></a><span class="line-modified"> 125     protected void run(StructuredGraph graph, PhaseContext context) {</span>
 126         try (DebugContext.Scope s = graph.getDebug().scope(&quot;DominatorConditionalElimination&quot;)) {
 127             BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes = null;
 128             NodeMap&lt;Block&gt; nodeToBlock = null;
 129             ControlFlowGraph cfg = ControlFlowGraph.compute(graph, true, true, true, true);
 130             if (fullSchedule) {
 131                 if (moveGuards) {
 132                     cfg.visitDominatorTree(new MoveGuardsUpwards(), graph.hasValueProxies());
 133                 }
 134                 try (DebugContext.Scope scheduleScope = graph.getDebug().scope(SchedulePhase.class)) {
 135                     SchedulePhase.run(graph, SchedulingStrategy.EARLIEST_WITH_GUARD_ORDER, cfg);
 136                 } catch (Throwable t) {
 137                     throw graph.getDebug().handle(t);
 138                 }
 139                 ScheduleResult r = graph.getLastSchedule();
 140                 blockToNodes = r.getBlockToNodesMap();
 141                 nodeToBlock = r.getNodeToBlockMap();
 142             } else {
 143                 nodeToBlock = cfg.getNodeToBlock();
 144                 blockToNodes = getBlockToNodes(cfg);
 145             }
 146             ControlFlowGraph.RecursiveVisitor&lt;?&gt; visitor = createVisitor(graph, cfg, blockToNodes, nodeToBlock, context);
 147             cfg.visitDominatorTree(visitor, graph.hasValueProxies());
 148         }
 149     }
 150 
 151     protected BlockMap&lt;List&lt;Node&gt;&gt; getBlockToNodes(@SuppressWarnings(&quot;unused&quot;) ControlFlowGraph cfg) {
 152         return null;
 153     }
 154 
 155     protected ControlFlowGraph.RecursiveVisitor&lt;?&gt; createVisitor(StructuredGraph graph, @SuppressWarnings(&quot;unused&quot;) ControlFlowGraph cfg, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes,
<a name="16" id="anc16"></a><span class="line-modified"> 156                     NodeMap&lt;Block&gt; nodeToBlock, PhaseContext context) {</span>
 157         return new Instance(graph, blockToNodes, nodeToBlock, context);
 158     }
 159 
 160     public static class MoveGuardsUpwards implements ControlFlowGraph.RecursiveVisitor&lt;Block&gt; {
 161 
 162         Block anchorBlock;
 163 
 164         @Override
 165         @SuppressWarnings(&quot;try&quot;)
 166         public Block enter(Block b) {
 167             Block oldAnchorBlock = anchorBlock;
 168             if (b.getDominator() == null || b.getDominator().getPostdominator() != b) {
 169                 // New anchor.
 170                 anchorBlock = b;
 171             }
 172 
 173             AbstractBeginNode beginNode = b.getBeginNode();
 174             if (beginNode instanceof AbstractMergeNode &amp;&amp; anchorBlock != b) {
 175                 AbstractMergeNode mergeNode = (AbstractMergeNode) beginNode;
<a name="17" id="anc17"></a><span class="line-modified"> 176                 for (GuardNode guard : mergeNode.guards().snapshot()) {</span>
<span class="line-modified"> 177                     try (DebugCloseable closeable = guard.withNodeSourcePosition()) {</span>
<span class="line-modified"> 178                         GuardNode newlyCreatedGuard = new GuardNode(guard.getCondition(), anchorBlock.getBeginNode(), guard.getReason(), guard.getAction(), guard.isNegated(), guard.getSpeculation(),</span>
<span class="line-removed"> 179                                         guard.getNoDeoptSuccessorPosition());</span>
<span class="line-removed"> 180                         GuardNode newGuard = mergeNode.graph().unique(newlyCreatedGuard);</span>
<span class="line-removed"> 181                         guard.replaceAndDelete(newGuard);</span>
<span class="line-removed"> 182                     }</span>
<span class="line-removed"> 183                 }</span>
 184             }
 185 
 186             FixedNode endNode = b.getEndNode();
 187             if (endNode instanceof IfNode) {
 188                 IfNode node = (IfNode) endNode;
 189 
 190                 // Check if we can move guards upwards.
 191                 AbstractBeginNode trueSuccessor = node.trueSuccessor();
<a name="18" id="anc18"></a>

 192                 EconomicMap&lt;LogicNode, GuardNode&gt; trueGuards = EconomicMap.create(Equivalence.IDENTITY);
 193                 for (GuardNode guard : trueSuccessor.guards()) {
 194                     LogicNode condition = guard.getCondition();
 195                     if (condition.hasMoreThanOneUsage()) {
 196                         trueGuards.put(condition, guard);
 197                     }
 198                 }
 199 
 200                 if (!trueGuards.isEmpty()) {
<a name="19" id="anc19"></a><span class="line-modified"> 201                     for (GuardNode guard : node.falseSuccessor().guards().snapshot()) {</span>
 202                         GuardNode otherGuard = trueGuards.get(guard.getCondition());
 203                         if (otherGuard != null &amp;&amp; guard.isNegated() == otherGuard.isNegated()) {
 204                             Speculation speculation = otherGuard.getSpeculation();
 205                             if (speculation == null) {
 206                                 speculation = guard.getSpeculation();
 207                             } else if (guard.getSpeculation() != null &amp;&amp; guard.getSpeculation() != speculation) {
 208                                 // Cannot optimize due to different speculations.
 209                                 continue;
 210                             }
 211                             try (DebugCloseable closeable = guard.withNodeSourcePosition()) {
 212                                 GuardNode newlyCreatedGuard = new GuardNode(guard.getCondition(), anchorBlock.getBeginNode(), guard.getReason(), guard.getAction(), guard.isNegated(), speculation,
 213                                                 guard.getNoDeoptSuccessorPosition());
 214                                 GuardNode newGuard = node.graph().unique(newlyCreatedGuard);
 215                                 if (otherGuard.isAlive()) {
<a name="20" id="anc20"></a><span class="line-modified"> 216                                     otherGuard.replaceAndDelete(newGuard);</span>









 217                                 }
<a name="21" id="anc21"></a><span class="line-removed"> 218                                 guard.replaceAndDelete(newGuard);</span>
 219                             }
 220                         }
 221                     }
 222                 }
 223             }
 224             return oldAnchorBlock;
 225         }
 226 
 227         @Override
 228         public void exit(Block b, Block value) {
 229             anchorBlock = value;
 230         }
 231 
 232     }
 233 
 234     private static final class PhiInfoElement {
 235 
 236         private EconomicMap&lt;EndNode, InfoElement&gt; infoElements;
 237 
 238         public void set(EndNode end, InfoElement infoElement) {
 239             if (infoElements == null) {
 240                 infoElements = EconomicMap.create(Equivalence.IDENTITY);
 241             }
 242             infoElements.put(end, infoElement);
 243         }
 244 
 245         public InfoElement get(EndNode end) {
 246             if (infoElements == null) {
 247                 return null;
 248             }
 249             return infoElements.get(end);
 250         }
 251     }
 252 
<a name="22" id="anc22"></a><span class="line-removed"> 253     public static final class Marks {</span>
<span class="line-removed"> 254         final int infoElementOperations;</span>
<span class="line-removed"> 255         final int conditions;</span>
<span class="line-removed"> 256 </span>
<span class="line-removed"> 257         public Marks(int infoElementOperations, int conditions) {</span>
<span class="line-removed"> 258             this.infoElementOperations = infoElementOperations;</span>
<span class="line-removed"> 259             this.conditions = conditions;</span>
<span class="line-removed"> 260         }</span>
<span class="line-removed"> 261     }</span>
<span class="line-removed"> 262 </span>
<span class="line-removed"> 263     protected static final class GuardedCondition {</span>
<span class="line-removed"> 264         private final GuardingNode guard;</span>
<span class="line-removed"> 265         private final LogicNode condition;</span>
<span class="line-removed"> 266         private final boolean negated;</span>
<span class="line-removed"> 267 </span>
<span class="line-removed"> 268         public GuardedCondition(GuardingNode guard, LogicNode condition, boolean negated) {</span>
<span class="line-removed"> 269             this.guard = guard;</span>
<span class="line-removed"> 270             this.condition = condition;</span>
<span class="line-removed"> 271             this.negated = negated;</span>
<span class="line-removed"> 272         }</span>
<span class="line-removed"> 273 </span>
<span class="line-removed"> 274         public GuardingNode getGuard() {</span>
<span class="line-removed"> 275             return guard;</span>
<span class="line-removed"> 276         }</span>
<span class="line-removed"> 277 </span>
<span class="line-removed"> 278         public LogicNode getCondition() {</span>
<span class="line-removed"> 279             return condition;</span>
<span class="line-removed"> 280         }</span>
<span class="line-removed"> 281 </span>
<span class="line-removed"> 282         public boolean isNegated() {</span>
<span class="line-removed"> 283             return negated;</span>
<span class="line-removed"> 284         }</span>
<span class="line-removed"> 285     }</span>
<span class="line-removed"> 286 </span>
 287     public static class Instance implements ControlFlowGraph.RecursiveVisitor&lt;Marks&gt; {
 288         protected final NodeMap&lt;InfoElement&gt; map;
 289         protected final BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes;
 290         protected final NodeMap&lt;Block&gt; nodeToBlock;
 291         protected final CanonicalizerTool tool;
 292         protected final NodeStack undoOperations;
 293         protected final StructuredGraph graph;
 294         protected final DebugContext debug;
 295         protected final EconomicMap&lt;MergeNode, EconomicMap&lt;ValuePhiNode, PhiInfoElement&gt;&gt; mergeMaps;
<a name="23" id="anc23"></a>

 296 
 297         protected final ArrayDeque&lt;GuardedCondition&gt; conditions;
 298 
 299         /**
 300          * Tests which may be eliminated because post dominating tests to prove a broader condition.
 301          */
 302         private Deque&lt;DeoptimizingGuard&gt; pendingTests;
 303 
<a name="24" id="anc24"></a><span class="line-modified"> 304         public Instance(StructuredGraph graph, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes, NodeMap&lt;Block&gt; nodeToBlock, PhaseContext context) {</span>
 305             this.graph = graph;
 306             this.debug = graph.getDebug();
 307             this.blockToNodes = blockToNodes;
 308             this.nodeToBlock = nodeToBlock;
 309             this.undoOperations = new NodeStack();
 310             this.map = graph.createNodeMap();
 311             this.pendingTests = new ArrayDeque&lt;&gt;();
 312             this.conditions = new ArrayDeque&lt;&gt;();
 313             tool = GraphUtil.getDefaultSimplifier(context.getMetaAccess(), context.getConstantReflection(), context.getConstantFieldProvider(), false, graph.getAssumptions(), graph.getOptions(),
 314                             context.getLowerer());
<a name="25" id="anc25"></a><span class="line-modified"> 315             mergeMaps = EconomicMap.create();</span>














 316         }
 317 
 318         protected void processConditionAnchor(ConditionAnchorNode node) {
<a name="26" id="anc26"></a><span class="line-modified"> 319             tryProveCondition(node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
 320                 if (result != node.isNegated()) {
 321                     node.replaceAtUsages(guard.asNode());
 322                     GraphUtil.unlinkFixedNode(node);
 323                     GraphUtil.killWithUnusedFloatingInputs(node);
 324                 } else {
 325                     ValueAnchorNode valueAnchor = node.graph().add(new ValueAnchorNode(null));
 326                     node.replaceAtUsages(valueAnchor);
 327                     node.graph().replaceFixedWithFixed(node, valueAnchor);
 328                 }
 329                 return true;
 330             });
 331         }
 332 
 333         protected void processGuard(GuardNode node) {
 334             if (!tryProveGuardCondition(node, node.getCondition(), (guard, result, guardedValueStamp, newInput) -&gt; {
 335                 if (result != node.isNegated()) {
 336                     node.replaceAndDelete(guard.asNode());
<a name="27" id="anc27"></a>


 337                 } else {
<a name="28" id="anc28"></a><span class="line-removed"> 338                     /*</span>
<span class="line-removed"> 339                      * Don&#39;t kill this branch immediately because `killCFG` can have complex</span>
<span class="line-removed"> 340                      * implications in the presence of loops: it might replace or delete nodes in</span>
<span class="line-removed"> 341                      * other branches or even above the kill point. Instead of killing immediately,</span>
<span class="line-removed"> 342                      * just leave the graph in a state that is easy to simplify by a subsequent</span>
<span class="line-removed"> 343                      * canonicalizer phase.</span>
<span class="line-removed"> 344                      */</span>
<span class="line-removed"> 345                     FixedGuardNode deopt = new FixedGuardNode(LogicConstantNode.forBoolean(result, node.graph()), node.getReason(), node.getAction(), node.getSpeculation(), node.isNegated(),</span>
<span class="line-removed"> 346                                     node.getNodeSourcePosition());</span>
 347                     AbstractBeginNode beginNode = (AbstractBeginNode) node.getAnchor();
<a name="29" id="anc29"></a><span class="line-removed"> 348                     graph.addAfterFixed(beginNode, node.graph().add(deopt));</span>
 349 
<a name="30" id="anc30"></a>













 350                 }
 351                 return true;
 352             })) {
 353                 registerNewCondition(node.getCondition(), node.isNegated(), node);
 354             }
 355         }
 356 
 357         protected void processFixedGuard(FixedGuardNode node) {
 358             if (!tryProveGuardCondition(node, node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {
 359                 if (result != node.isNegated()) {
 360                     node.replaceAtUsages(guard.asNode());
 361                     GraphUtil.unlinkFixedNode(node);
 362                     GraphUtil.killWithUnusedFloatingInputs(node);
<a name="31" id="anc31"></a>


 363                 } else {
 364                     node.setCondition(LogicConstantNode.forBoolean(result, node.graph()), node.isNegated());
 365                     // Don&#39;t kill this branch immediately, see `processGuard`.
 366                 }
<a name="32" id="anc32"></a><span class="line-modified"> 367                 debug.log(&quot;Kill fixed guard guard&quot;);</span>

 368                 return true;
 369             })) {
 370                 registerNewCondition(node.condition(), node.isNegated(), node);
 371             }
 372         }
 373 
<a name="33" id="anc33"></a>




















































 374         protected void processIf(IfNode node) {
<a name="34" id="anc34"></a><span class="line-modified"> 375             tryProveCondition(node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
 376                 node.setCondition(LogicConstantNode.forBoolean(result, node.graph()));
 377                 AbstractBeginNode survivingSuccessor = node.getSuccessor(result);
 378                 survivingSuccessor.replaceAtUsages(InputType.Guard, guard.asNode());
 379                 // Don&#39;t kill the other branch immediately, see `processGuard`.
 380                 counterIfsKilled.increment(debug);
 381                 return true;
 382             });
 383         }
 384 
 385         @Override
 386         public Marks enter(Block block) {
 387             int infoElementsMark = undoOperations.size();
 388             int conditionsMark = conditions.size();
 389             debug.log(&quot;[Pre Processing block %s]&quot;, block);
 390             // For now conservatively collect guards only within the same block.
 391             pendingTests.clear();
 392             processNodes(block);
 393             return new Marks(infoElementsMark, conditionsMark);
 394         }
 395 
 396         protected void processNodes(Block block) {
 397             if (blockToNodes != null) {
 398                 for (Node n : blockToNodes.get(block)) {
 399                     if (n.isAlive()) {
 400                         processNode(n);
 401                     }
 402                 }
 403             } else {
 404                 processBlock(block);
 405             }
 406         }
 407 
 408         private void processBlock(Block block) {
 409             FixedNode n = block.getBeginNode();
 410             FixedNode endNode = block.getEndNode();
 411             debug.log(&quot;[Processing block %s]&quot;, block);
 412             while (n != endNode) {
 413                 if (n.isDeleted() || endNode.isDeleted()) {
 414                     // This branch was deleted!
 415                     return;
 416                 }
 417                 FixedNode next = ((FixedWithNextNode) n).next();
 418                 processNode(n);
 419                 n = next;
 420             }
 421             if (endNode.isAlive()) {
 422                 processNode(endNode);
 423             }
 424         }
 425 
 426         @SuppressWarnings(&quot;try&quot;)
 427         protected void processNode(Node node) {
 428             try (DebugCloseable closeable = node.withNodeSourcePosition()) {
 429                 if (node instanceof NodeWithState &amp;&amp; !(node instanceof GuardingNode)) {
 430                     pendingTests.clear();
 431                 }
 432 
 433                 if (node instanceof MergeNode) {
 434                     introducePisForPhis((MergeNode) node);
 435                 }
 436 
 437                 if (node instanceof AbstractBeginNode) {
 438                     if (node instanceof LoopExitNode &amp;&amp; graph.hasValueProxies()) {
 439                         // Condition must not be used down this path.
 440                         return;
 441                     }
 442                     processAbstractBegin((AbstractBeginNode) node);
 443                 } else if (node instanceof FixedGuardNode) {
 444                     processFixedGuard((FixedGuardNode) node);
 445                 } else if (node instanceof GuardNode) {
 446                     processGuard((GuardNode) node);
 447                 } else if (node instanceof ConditionAnchorNode) {
 448                     processConditionAnchor((ConditionAnchorNode) node);
 449                 } else if (node instanceof IfNode) {
 450                     processIf((IfNode) node);
 451                 } else if (node instanceof EndNode) {
 452                     processEnd((EndNode) node);
 453                 }
 454             }
 455         }
 456 
 457         protected void introducePisForPhis(MergeNode merge) {
 458             EconomicMap&lt;ValuePhiNode, PhiInfoElement&gt; mergeMap = this.mergeMaps.get(merge);
 459             if (mergeMap != null) {
 460                 MapCursor&lt;ValuePhiNode, PhiInfoElement&gt; entries = mergeMap.getEntries();
 461                 while (entries.advance()) {
 462                     ValuePhiNode phi = entries.getKey();
 463                     assert phi.isAlive() || phi.isDeleted();
 464                     /*
 465                      * Phi might have been killed already via a conditional elimination in another
 466                      * branch.
 467                      */
 468                     if (phi.isDeleted()) {
 469                         continue;
 470                     }
 471                     PhiInfoElement phiInfoElements = entries.getValue();
 472                     Stamp bestPossibleStamp = null;
 473                     for (int i = 0; i &lt; phi.valueCount(); ++i) {
 474                         ValueNode valueAt = phi.valueAt(i);
 475                         Stamp curBestStamp = valueAt.stamp(NodeView.DEFAULT);
 476                         InfoElement infoElement = phiInfoElements.get(merge.forwardEndAt(i));
 477                         if (infoElement != null) {
 478                             curBestStamp = curBestStamp.join(infoElement.getStamp());
 479                         }
 480 
 481                         if (bestPossibleStamp == null) {
 482                             bestPossibleStamp = curBestStamp;
 483                         } else {
 484                             bestPossibleStamp = bestPossibleStamp.meet(curBestStamp);
 485                         }
 486                     }
 487 
 488                     Stamp oldStamp = phi.stamp(NodeView.DEFAULT);
 489                     if (oldStamp.tryImproveWith(bestPossibleStamp) != null) {
 490 
 491                         // Need to be careful to not run into stamp update cycles with the iterative
 492                         // canonicalization.
 493                         boolean allow = false;
 494                         if (bestPossibleStamp instanceof ObjectStamp) {
 495                             // Always allow object stamps.
 496                             allow = true;
 497                         } else if (bestPossibleStamp instanceof IntegerStamp) {
 498                             IntegerStamp integerStamp = (IntegerStamp) bestPossibleStamp;
 499                             IntegerStamp oldIntegerStamp = (IntegerStamp) oldStamp;
 500                             if (integerStamp.isPositive() != oldIntegerStamp.isPositive()) {
 501                                 allow = true;
 502                             } else if (integerStamp.isNegative() != oldIntegerStamp.isNegative()) {
 503                                 allow = true;
 504                             } else if (integerStamp.isStrictlyPositive() != oldIntegerStamp.isStrictlyPositive()) {
 505                                 allow = true;
 506                             } else if (integerStamp.isStrictlyNegative() != oldIntegerStamp.isStrictlyNegative()) {
 507                                 allow = true;
 508                             } else if (integerStamp.asConstant() != null) {
 509                                 allow = true;
 510                             } else if (oldStamp.isUnrestricted()) {
 511                                 allow = true;
 512                             }
 513                         } else {
<a name="35" id="anc35"></a>

 514                             allow = (bestPossibleStamp.asConstant() != null);
 515                         }
 516 
 517                         if (allow) {
 518                             ValuePhiNode newPhi = graph.addWithoutUnique(new ValuePhiNode(bestPossibleStamp, merge));
 519                             for (int i = 0; i &lt; phi.valueCount(); ++i) {
 520                                 ValueNode valueAt = phi.valueAt(i);
 521                                 if (bestPossibleStamp.meet(valueAt.stamp(NodeView.DEFAULT)).equals(bestPossibleStamp)) {
 522                                     // Pi not required here.
 523                                 } else {
 524                                     InfoElement infoElement = phiInfoElements.get(merge.forwardEndAt(i));
 525                                     assert infoElement != null;
 526                                     Stamp curBestStamp = infoElement.getStamp();
 527                                     ValueNode input = infoElement.getProxifiedInput();
 528                                     if (input == null) {
 529                                         input = valueAt;
 530                                     }
<a name="36" id="anc36"></a><span class="line-modified"> 531                                     valueAt = graph.maybeAddOrUnique(PiNode.create(input, curBestStamp, (ValueNode) infoElement.guard));</span>
 532                                 }
 533                                 newPhi.addInput(valueAt);
 534                             }
 535                             counterPhiStampsImproved.increment(debug);
 536                             phi.replaceAtUsagesAndDelete(newPhi);
 537                         }
 538                     }
 539                 }
 540             }
 541         }
 542 
 543         protected void processEnd(EndNode end) {
 544             AbstractMergeNode abstractMerge = end.merge();
 545             if (abstractMerge instanceof MergeNode) {
 546                 MergeNode merge = (MergeNode) abstractMerge;
 547 
 548                 EconomicMap&lt;ValuePhiNode, PhiInfoElement&gt; mergeMap = this.mergeMaps.get(merge);
 549                 for (ValuePhiNode phi : merge.valuePhis()) {
 550                     ValueNode valueAt = phi.valueAt(end);
 551                     InfoElement infoElement = this.getInfoElements(valueAt);
 552                     while (infoElement != null) {
 553                         Stamp newStamp = infoElement.getStamp();
 554                         if (phi.stamp(NodeView.DEFAULT).tryImproveWith(newStamp) != null) {
 555                             if (mergeMap == null) {
<a name="37" id="anc37"></a><span class="line-modified"> 556                                 mergeMap = EconomicMap.create();</span>
 557                                 mergeMaps.put(merge, mergeMap);
 558                             }
 559 
 560                             PhiInfoElement phiInfoElement = mergeMap.get(phi);
 561                             if (phiInfoElement == null) {
 562                                 phiInfoElement = new PhiInfoElement();
 563                                 mergeMap.put(phi, phiInfoElement);
 564                             }
 565 
 566                             phiInfoElement.set(end, infoElement);
 567                             break;
 568                         }
 569                         infoElement = nextElement(infoElement);
 570                     }
 571                 }
 572             }
 573         }
 574 
 575         protected void registerNewCondition(LogicNode condition, boolean negated, GuardingNode guard) {
 576             if (condition instanceof UnaryOpLogicNode) {
 577                 UnaryOpLogicNode unaryLogicNode = (UnaryOpLogicNode) condition;
 578                 ValueNode value = unaryLogicNode.getValue();
 579                 if (maybeMultipleUsages(value)) {
 580                     // getSucceedingStampForValue doesn&#39;t take the (potentially a Pi Node) input
 581                     // stamp into account, so it can be safely propagated.
 582                     Stamp newStamp = unaryLogicNode.getSucceedingStampForValue(negated);
 583                     registerNewStamp(value, newStamp, guard, true);
 584                 }
 585             } else if (condition instanceof BinaryOpLogicNode) {
 586                 BinaryOpLogicNode binaryOpLogicNode = (BinaryOpLogicNode) condition;
 587                 ValueNode x = binaryOpLogicNode.getX();
 588                 ValueNode y = binaryOpLogicNode.getY();
 589                 if (!x.isConstant() &amp;&amp; maybeMultipleUsages(x)) {
 590                     Stamp newStampX = binaryOpLogicNode.getSucceedingStampForX(negated, getSafeStamp(x), getOtherSafeStamp(y));
 591                     registerNewStamp(x, newStampX, guard);
 592                 }
 593 
 594                 if (!y.isConstant() &amp;&amp; maybeMultipleUsages(y)) {
 595                     Stamp newStampY = binaryOpLogicNode.getSucceedingStampForY(negated, getOtherSafeStamp(x), getSafeStamp(y));
 596                     registerNewStamp(y, newStampY, guard);
 597                 }
 598 
 599                 if (condition instanceof IntegerEqualsNode &amp;&amp; guard instanceof DeoptimizingGuard &amp;&amp; !negated) {
 600                     if (y.isConstant() &amp;&amp; x instanceof AndNode) {
 601                         AndNode and = (AndNode) x;
 602                         ValueNode andX = and.getX();
 603                         if (and.getY() == y &amp;&amp; maybeMultipleUsages(andX)) {
 604                             /*
 605                              * This &#39;and&#39; proves something about some of the bits in and.getX().
 606                              * It&#39;s equivalent to or&#39;ing in the mask value since those values are
 607                              * known to be set.
 608                              */
 609                             BinaryOp&lt;Or&gt; op = ArithmeticOpTable.forStamp(x.stamp(NodeView.DEFAULT)).getOr();
 610                             IntegerStamp newStampX = (IntegerStamp) op.foldStamp(getSafeStamp(andX), getOtherSafeStamp(y));
 611                             registerNewStamp(andX, newStampX, guard);
 612                         }
 613                     }
 614                 }
 615             }
 616             if (guard instanceof DeoptimizingGuard) {
 617                 assert ((DeoptimizingGuard) guard).getCondition() == condition;
 618                 pendingTests.push((DeoptimizingGuard) guard);
 619             }
 620             registerCondition(condition, negated, guard);
 621         }
 622 
<a name="38" id="anc38"></a><span class="line-removed"> 623         Pair&lt;InfoElement, Stamp&gt; recursiveFoldStamp(Node node) {</span>
<span class="line-removed"> 624             if (node instanceof UnaryNode) {</span>
<span class="line-removed"> 625                 UnaryNode unary = (UnaryNode) node;</span>
<span class="line-removed"> 626                 ValueNode value = unary.getValue();</span>
<span class="line-removed"> 627                 InfoElement infoElement = getInfoElements(value);</span>
<span class="line-removed"> 628                 while (infoElement != null) {</span>
<span class="line-removed"> 629                     Stamp result = unary.foldStamp(infoElement.getStamp());</span>
<span class="line-removed"> 630                     if (result != null) {</span>
<span class="line-removed"> 631                         return Pair.create(infoElement, result);</span>
<span class="line-removed"> 632                     }</span>
<span class="line-removed"> 633                     infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 634                 }</span>
<span class="line-removed"> 635             } else if (node instanceof BinaryNode) {</span>
<span class="line-removed"> 636                 BinaryNode binary = (BinaryNode) node;</span>
<span class="line-removed"> 637                 ValueNode y = binary.getY();</span>
<span class="line-removed"> 638                 ValueNode x = binary.getX();</span>
<span class="line-removed"> 639                 if (y.isConstant()) {</span>
<span class="line-removed"> 640                     InfoElement infoElement = getInfoElements(x);</span>
<span class="line-removed"> 641                     while (infoElement != null) {</span>
<span class="line-removed"> 642                         Stamp result = binary.foldStamp(infoElement.stamp, y.stamp(NodeView.DEFAULT));</span>
<span class="line-removed"> 643                         if (result != null) {</span>
<span class="line-removed"> 644                             return Pair.create(infoElement, result);</span>
<span class="line-removed"> 645                         }</span>
<span class="line-removed"> 646                         infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 647                     }</span>
<span class="line-removed"> 648                 }</span>
<span class="line-removed"> 649             }</span>
<span class="line-removed"> 650             return null;</span>
<span class="line-removed"> 651         }</span>
<span class="line-removed"> 652 </span>
<span class="line-removed"> 653         /**</span>
<span class="line-removed"> 654          * Get the stamp that may be used for the value for which we are registering the condition.</span>
<span class="line-removed"> 655          * We may directly use the stamp here without restriction, because any later lookup of the</span>
<span class="line-removed"> 656          * registered info elements is in the same chain of pi nodes.</span>
<span class="line-removed"> 657          */</span>
<span class="line-removed"> 658         private static Stamp getSafeStamp(ValueNode x) {</span>
<span class="line-removed"> 659             return x.stamp(NodeView.DEFAULT);</span>
<span class="line-removed"> 660         }</span>
<span class="line-removed"> 661 </span>
<span class="line-removed"> 662         /**</span>
<span class="line-removed"> 663          * We can only use the stamp of a second value involved in the condition if we are sure that</span>
<span class="line-removed"> 664          * we are not implicitly creating a dependency on a pi node that is responsible for that</span>
<span class="line-removed"> 665          * stamp. For now, we are conservatively only using the stamps of constants. Under certain</span>
<span class="line-removed"> 666          * circumstances, we may also be able to use the stamp of the value after skipping pi nodes</span>
<span class="line-removed"> 667          * (e.g., the stamp of a parameter after inlining, or the stamp of a fixed node that can</span>
<span class="line-removed"> 668          * never be replaced with a pi node via canonicalization).</span>
<span class="line-removed"> 669          */</span>
<span class="line-removed"> 670         private static Stamp getOtherSafeStamp(ValueNode x) {</span>
<span class="line-removed"> 671             if (x.isConstant() || x.graph().isAfterFixedReadPhase()) {</span>
<span class="line-removed"> 672                 return x.stamp(NodeView.DEFAULT);</span>
<span class="line-removed"> 673             }</span>
<span class="line-removed"> 674             return x.stamp(NodeView.DEFAULT).unrestricted();</span>
<span class="line-removed"> 675         }</span>
<span class="line-removed"> 676 </span>
 677         /**
 678          * Recursively try to fold stamps within this expression using information from
 679          * {@link #getInfoElements(ValueNode)}. It&#39;s only safe to use constants and one
 680          * {@link InfoElement} otherwise more than one guard would be required.
 681          *
 682          * @param node
 683          * @return the pair of the @{link InfoElement} used and the stamp produced for the whole
 684          *         expression
 685          */
 686         Pair&lt;InfoElement, Stamp&gt; recursiveFoldStampFromInfo(Node node) {
<a name="39" id="anc39"></a><span class="line-modified"> 687             return recursiveFoldStamp(node);</span>
 688         }
 689 
 690         /**
 691          * Look for a preceding guard whose condition is implied by {@code thisGuard}. If we find
 692          * one, try to move this guard just above that preceding guard so that we can fold it:
 693          *
 694          * &lt;pre&gt;
 695          *     guard(C1); // preceding guard
 696          *     ...
 697          *     guard(C2); // thisGuard
 698          * &lt;/pre&gt;
 699          *
 700          * If C2 =&gt; C1, transform to:
 701          *
 702          * &lt;pre&gt;
 703          *     guard(C2);
 704          *     ...
 705          * &lt;/pre&gt;
 706          */
 707         protected boolean foldPendingTest(DeoptimizingGuard thisGuard, ValueNode original, Stamp newStamp, GuardRewirer rewireGuardFunction) {
 708             for (DeoptimizingGuard pendingGuard : pendingTests) {
 709                 LogicNode pendingCondition = pendingGuard.getCondition();
 710                 TriState result = TriState.UNKNOWN;
 711                 if (pendingCondition instanceof UnaryOpLogicNode) {
 712                     UnaryOpLogicNode unaryLogicNode = (UnaryOpLogicNode) pendingCondition;
 713                     if (unaryLogicNode.getValue() == original) {
 714                         result = unaryLogicNode.tryFold(newStamp);
 715                     }
 716                 } else if (pendingCondition instanceof BinaryOpLogicNode) {
 717                     BinaryOpLogicNode binaryOpLogicNode = (BinaryOpLogicNode) pendingCondition;
 718                     ValueNode x = binaryOpLogicNode.getX();
 719                     ValueNode y = binaryOpLogicNode.getY();
 720                     if (x == original) {
 721                         result = binaryOpLogicNode.tryFold(newStamp, getOtherSafeStamp(y));
 722                     } else if (y == original) {
 723                         result = binaryOpLogicNode.tryFold(getOtherSafeStamp(x), newStamp);
 724                     } else if (binaryOpLogicNode instanceof IntegerEqualsNode &amp;&amp; y.isConstant() &amp;&amp; x instanceof AndNode) {
 725                         AndNode and = (AndNode) x;
 726                         if (and.getY() == y &amp;&amp; and.getX() == original) {
 727                             BinaryOp&lt;And&gt; andOp = ArithmeticOpTable.forStamp(newStamp).getAnd();
 728                             result = binaryOpLogicNode.tryFold(andOp.foldStamp(newStamp, getOtherSafeStamp(y)), getOtherSafeStamp(y));
 729                         }
 730                     }
 731                 }
 732                 if (result.isKnown()) {
 733                     /*
 734                      * The test case be folded using the information available but the test can only
 735                      * be moved up if we&#39;re sure there&#39;s no schedule dependence.
 736                      */
 737                     if (canScheduleAbove(thisGuard.getCondition(), pendingGuard.asNode(), original) &amp;&amp; foldGuard(thisGuard, pendingGuard, result.toBoolean(), newStamp, rewireGuardFunction)) {
 738                         return true;
 739                     }
 740                 }
 741             }
 742             return false;
 743         }
 744 
 745         private boolean canScheduleAbove(Node n, Node target, ValueNode knownToBeAbove) {
 746             Block targetBlock = nodeToBlock.get(target);
 747             Block testBlock = nodeToBlock.get(n);
 748             if (targetBlock != null &amp;&amp; testBlock != null) {
 749                 if (targetBlock == testBlock) {
 750                     for (Node fixed : blockToNodes.get(targetBlock)) {
 751                         if (fixed == n) {
 752                             return true;
 753                         } else if (fixed == target) {
 754                             break;
 755                         }
 756                     }
 757                 } else if (AbstractControlFlowGraph.dominates(testBlock, targetBlock)) {
 758                     return true;
 759                 }
 760             }
 761             InputFilter v = new InputFilter(knownToBeAbove);
 762             n.applyInputs(v);
 763             return v.ok;
 764         }
 765 
 766         protected boolean foldGuard(DeoptimizingGuard thisGuard, DeoptimizingGuard otherGuard, boolean outcome, Stamp guardedValueStamp, GuardRewirer rewireGuardFunction) {
 767             DeoptimizationAction action = mergeActions(otherGuard.getAction(), thisGuard.getAction());
 768             if (action != null &amp;&amp; otherGuard.getSpeculation() == thisGuard.getSpeculation()) {
 769                 LogicNode condition = (LogicNode) thisGuard.getCondition().copyWithInputs();
 770                 /*
 771                  * We have ...; guard(C1); guard(C2);...
 772                  *
 773                  * Where the first guard is `otherGuard` and the second one `thisGuard`.
 774                  *
 775                  * Depending on `outcome`, we have C2 =&gt; C1 or C2 =&gt; !C1.
 776                  *
 777                  * - If C2 =&gt; C1, `mustDeopt` below is false and we transform to ...; guard(C2); ...
 778                  *
 779                  * - If C2 =&gt; !C1, `mustDeopt` is true and we transform to ..; guard(C1); deopt;
 780                  */
 781                 // for the second case, the action of the deopt is copied from there:
 782                 thisGuard.setAction(action);
 783                 GuardRewirer rewirer = (guard, result, innerGuardedValueStamp, newInput) -&gt; {
 784                     // `result` is `outcome`, `guard` is `otherGuard`
 785                     boolean mustDeopt = result == otherGuard.isNegated();
 786                     if (rewireGuardFunction.rewire(guard, mustDeopt == thisGuard.isNegated(), innerGuardedValueStamp, newInput)) {
 787                         if (!mustDeopt) {
 788                             otherGuard.setCondition(condition, thisGuard.isNegated());
 789                             otherGuard.setAction(action);
 790                             otherGuard.setReason(thisGuard.getReason());
 791                         }
 792                         return true;
 793                     }
 794                     condition.safeDelete();
 795                     return false;
 796                 };
 797                 // Move the later test up
 798                 return rewireGuards(otherGuard, outcome, null, guardedValueStamp, rewirer);
 799             }
 800             return false;
 801         }
 802 
<a name="40" id="anc40"></a>



 803         protected void registerCondition(LogicNode condition, boolean negated, GuardingNode guard) {
 804             if (condition.hasMoreThanOneUsage()) {
 805                 registerNewStamp(condition, negated ? StampFactory.contradiction() : StampFactory.tautology(), guard);
 806             }
 807             conditions.push(new GuardedCondition(guard, condition, negated));
 808         }
 809 
 810         protected InfoElement getInfoElements(ValueNode proxiedValue) {
 811             if (proxiedValue == null) {
 812                 return null;
 813             }
 814             InfoElement infoElement = map.getAndGrow(proxiedValue);
 815             if (infoElement == null) {
 816                 infoElement = map.getAndGrow(GraphUtil.skipPi(proxiedValue));
 817             }
 818             return infoElement;
 819         }
 820 
<a name="41" id="anc41"></a><span class="line-removed"> 821         protected boolean rewireGuards(GuardingNode guard, boolean result, ValueNode proxifiedInput, Stamp guardedValueStamp, GuardRewirer rewireGuardFunction) {</span>
<span class="line-removed"> 822             counterStampsFound.increment(debug);</span>
<span class="line-removed"> 823             return rewireGuardFunction.rewire(guard, result, guardedValueStamp, proxifiedInput);</span>
<span class="line-removed"> 824         }</span>
<span class="line-removed"> 825 </span>
<span class="line-removed"> 826         protected boolean tryProveCondition(LogicNode node, GuardRewirer rewireGuardFunction) {</span>
<span class="line-removed"> 827             return tryProveGuardCondition(null, node, rewireGuardFunction);</span>
<span class="line-removed"> 828         }</span>
<span class="line-removed"> 829 </span>
 830         private InfoElement nextElement(InfoElement current) {
 831             InfoElement parent = current.getParent();
 832             if (parent != null) {
 833                 return parent;
 834             } else {
 835                 ValueNode proxifiedInput = current.getProxifiedInput();
 836                 if (proxifiedInput instanceof PiNode) {
 837                     PiNode piNode = (PiNode) proxifiedInput;
 838                     return getInfoElements(piNode.getOriginalNode());
 839                 }
 840             }
 841             return null;
 842         }
 843 
<a name="42" id="anc42"></a><span class="line-removed"> 844         protected boolean tryProveGuardCondition(DeoptimizingGuard thisGuard, LogicNode node, GuardRewirer rewireGuardFunction) {</span>
<span class="line-removed"> 845             InfoElement infoElement = getInfoElements(node);</span>
<span class="line-removed"> 846             while (infoElement != null) {</span>
<span class="line-removed"> 847                 Stamp stamp = infoElement.getStamp();</span>
<span class="line-removed"> 848                 JavaConstant constant = (JavaConstant) stamp.asConstant();</span>
<span class="line-removed"> 849                 if (constant != null) {</span>
<span class="line-removed"> 850                     // No proxified input and stamp required.</span>
<span class="line-removed"> 851                     return rewireGuards(infoElement.getGuard(), constant.asBoolean(), null, null, rewireGuardFunction);</span>
<span class="line-removed"> 852                 }</span>
<span class="line-removed"> 853                 infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 854             }</span>
<span class="line-removed"> 855 </span>
<span class="line-removed"> 856             for (GuardedCondition guardedCondition : this.conditions) {</span>
<span class="line-removed"> 857                 TriState result = guardedCondition.getCondition().implies(guardedCondition.isNegated(), node);</span>
<span class="line-removed"> 858                 if (result.isKnown()) {</span>
<span class="line-removed"> 859                     return rewireGuards(guardedCondition.guard, result.toBoolean(), null, null, rewireGuardFunction);</span>
<span class="line-removed"> 860                 }</span>
<span class="line-removed"> 861             }</span>
<span class="line-removed"> 862 </span>
<span class="line-removed"> 863             if (node instanceof UnaryOpLogicNode) {</span>
<span class="line-removed"> 864                 UnaryOpLogicNode unaryLogicNode = (UnaryOpLogicNode) node;</span>
<span class="line-removed"> 865                 ValueNode value = unaryLogicNode.getValue();</span>
<span class="line-removed"> 866                 infoElement = getInfoElements(value);</span>
<span class="line-removed"> 867                 while (infoElement != null) {</span>
<span class="line-removed"> 868                     Stamp stamp = infoElement.getStamp();</span>
<span class="line-removed"> 869                     TriState result = unaryLogicNode.tryFold(stamp);</span>
<span class="line-removed"> 870                     if (result.isKnown()) {</span>
<span class="line-removed"> 871                         return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), infoElement.getStamp(), rewireGuardFunction);</span>
<span class="line-removed"> 872                     }</span>
<span class="line-removed"> 873                     infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 874                 }</span>
<span class="line-removed"> 875                 Pair&lt;InfoElement, Stamp&gt; foldResult = recursiveFoldStampFromInfo(value);</span>
<span class="line-removed"> 876                 if (foldResult != null) {</span>
<span class="line-removed"> 877                     TriState result = unaryLogicNode.tryFold(foldResult.getRight());</span>
<span class="line-removed"> 878                     if (result.isKnown()) {</span>
<span class="line-removed"> 879                         return rewireGuards(foldResult.getLeft().getGuard(), result.toBoolean(), foldResult.getLeft().getProxifiedInput(), foldResult.getRight(), rewireGuardFunction);</span>
<span class="line-removed"> 880                     }</span>
<span class="line-removed"> 881                 }</span>
<span class="line-removed"> 882                 if (thisGuard != null) {</span>
<span class="line-removed"> 883                     Stamp newStamp = unaryLogicNode.getSucceedingStampForValue(thisGuard.isNegated());</span>
<span class="line-removed"> 884                     if (newStamp != null &amp;&amp; foldPendingTest(thisGuard, value, newStamp, rewireGuardFunction)) {</span>
<span class="line-removed"> 885                         return true;</span>
<span class="line-removed"> 886                     }</span>
<span class="line-removed"> 887 </span>
<span class="line-removed"> 888                 }</span>
<span class="line-removed"> 889             } else if (node instanceof BinaryOpLogicNode) {</span>
<span class="line-removed"> 890                 BinaryOpLogicNode binaryOpLogicNode = (BinaryOpLogicNode) node;</span>
<span class="line-removed"> 891                 ValueNode x = binaryOpLogicNode.getX();</span>
<span class="line-removed"> 892                 ValueNode y = binaryOpLogicNode.getY();</span>
<span class="line-removed"> 893                 infoElement = getInfoElements(x);</span>
<span class="line-removed"> 894                 while (infoElement != null) {</span>
<span class="line-removed"> 895                     TriState result = binaryOpLogicNode.tryFold(infoElement.getStamp(), y.stamp(NodeView.DEFAULT));</span>
<span class="line-removed"> 896                     if (result.isKnown()) {</span>
<span class="line-removed"> 897                         return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), infoElement.getStamp(), rewireGuardFunction);</span>
<span class="line-removed"> 898                     }</span>
<span class="line-removed"> 899                     infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 900                 }</span>
<span class="line-removed"> 901 </span>
<span class="line-removed"> 902                 if (y.isConstant()) {</span>
<span class="line-removed"> 903                     Pair&lt;InfoElement, Stamp&gt; foldResult = recursiveFoldStampFromInfo(x);</span>
<span class="line-removed"> 904                     if (foldResult != null) {</span>
<span class="line-removed"> 905                         TriState result = binaryOpLogicNode.tryFold(foldResult.getRight(), y.stamp(NodeView.DEFAULT));</span>
<span class="line-removed"> 906                         if (result.isKnown()) {</span>
<span class="line-removed"> 907                             return rewireGuards(foldResult.getLeft().getGuard(), result.toBoolean(), foldResult.getLeft().getProxifiedInput(), foldResult.getRight(), rewireGuardFunction);</span>
<span class="line-removed"> 908                         }</span>
<span class="line-removed"> 909                     }</span>
<span class="line-removed"> 910                 } else {</span>
<span class="line-removed"> 911                     infoElement = getInfoElements(y);</span>
<span class="line-removed"> 912                     while (infoElement != null) {</span>
<span class="line-removed"> 913                         TriState result = binaryOpLogicNode.tryFold(x.stamp(NodeView.DEFAULT), infoElement.getStamp());</span>
<span class="line-removed"> 914                         if (result.isKnown()) {</span>
<span class="line-removed"> 915                             return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), infoElement.getStamp(), rewireGuardFunction);</span>
<span class="line-removed"> 916                         }</span>
<span class="line-removed"> 917                         infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 918                     }</span>
<span class="line-removed"> 919                 }</span>
<span class="line-removed"> 920 </span>
<span class="line-removed"> 921                 /*</span>
<span class="line-removed"> 922                  * For complex expressions involving constants, see if it&#39;s possible to fold the</span>
<span class="line-removed"> 923                  * tests by using stamps one level up in the expression. For instance, (x + n &lt; y)</span>
<span class="line-removed"> 924                  * might fold if something is known about x and all other values are constants. The</span>
<span class="line-removed"> 925                  * reason for the constant restriction is that if more than 1 real value is involved</span>
<span class="line-removed"> 926                  * the code might need to adopt multiple guards to have proper dependences.</span>
<span class="line-removed"> 927                  */</span>
<span class="line-removed"> 928                 if (x instanceof BinaryArithmeticNode&lt;?&gt; &amp;&amp; y.isConstant()) {</span>
<span class="line-removed"> 929                     BinaryArithmeticNode&lt;?&gt; binary = (BinaryArithmeticNode&lt;?&gt;) x;</span>
<span class="line-removed"> 930                     if (binary.getY().isConstant()) {</span>
<span class="line-removed"> 931                         infoElement = getInfoElements(binary.getX());</span>
<span class="line-removed"> 932                         while (infoElement != null) {</span>
<span class="line-removed"> 933                             Stamp newStampX = binary.foldStamp(infoElement.getStamp(), binary.getY().stamp(NodeView.DEFAULT));</span>
<span class="line-removed"> 934                             TriState result = binaryOpLogicNode.tryFold(newStampX, y.stamp(NodeView.DEFAULT));</span>
<span class="line-removed"> 935                             if (result.isKnown()) {</span>
<span class="line-removed"> 936                                 return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), newStampX, rewireGuardFunction);</span>
<span class="line-removed"> 937                             }</span>
<span class="line-removed"> 938                             infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 939                         }</span>
<span class="line-removed"> 940                     }</span>
<span class="line-removed"> 941                 }</span>
<span class="line-removed"> 942 </span>
<span class="line-removed"> 943                 if (thisGuard != null &amp;&amp; binaryOpLogicNode instanceof IntegerEqualsNode &amp;&amp; !thisGuard.isNegated()) {</span>
<span class="line-removed"> 944                     if (y.isConstant() &amp;&amp; x instanceof AndNode) {</span>
<span class="line-removed"> 945                         AndNode and = (AndNode) x;</span>
<span class="line-removed"> 946                         if (and.getY() == y) {</span>
<span class="line-removed"> 947                             /*</span>
<span class="line-removed"> 948                              * This &#39;and&#39; proves something about some of the bits in and.getX().</span>
<span class="line-removed"> 949                              * It&#39;s equivalent to or&#39;ing in the mask value since those values are</span>
<span class="line-removed"> 950                              * known to be set.</span>
<span class="line-removed"> 951                              */</span>
<span class="line-removed"> 952                             BinaryOp&lt;Or&gt; op = ArithmeticOpTable.forStamp(x.stamp(NodeView.DEFAULT)).getOr();</span>
<span class="line-removed"> 953                             IntegerStamp newStampX = (IntegerStamp) op.foldStamp(getSafeStamp(and.getX()), getOtherSafeStamp(y));</span>
<span class="line-removed"> 954                             if (foldPendingTest(thisGuard, and.getX(), newStampX, rewireGuardFunction)) {</span>
<span class="line-removed"> 955                                 return true;</span>
<span class="line-removed"> 956                             }</span>
<span class="line-removed"> 957                         }</span>
<span class="line-removed"> 958                     }</span>
<span class="line-removed"> 959                 }</span>
<span class="line-removed"> 960 </span>
<span class="line-removed"> 961                 if (thisGuard != null) {</span>
<span class="line-removed"> 962                     if (!x.isConstant()) {</span>
<span class="line-removed"> 963                         Stamp newStampX = binaryOpLogicNode.getSucceedingStampForX(thisGuard.isNegated(), getSafeStamp(x), getOtherSafeStamp(y));</span>
<span class="line-removed"> 964                         if (newStampX != null &amp;&amp; foldPendingTest(thisGuard, x, newStampX, rewireGuardFunction)) {</span>
<span class="line-removed"> 965                             return true;</span>
<span class="line-removed"> 966                         }</span>
<span class="line-removed"> 967                     }</span>
<span class="line-removed"> 968                     if (!y.isConstant()) {</span>
<span class="line-removed"> 969                         Stamp newStampY = binaryOpLogicNode.getSucceedingStampForY(thisGuard.isNegated(), getOtherSafeStamp(x), getSafeStamp(y));</span>
<span class="line-removed"> 970                         if (newStampY != null &amp;&amp; foldPendingTest(thisGuard, y, newStampY, rewireGuardFunction)) {</span>
<span class="line-removed"> 971                             return true;</span>
<span class="line-removed"> 972                         }</span>
<span class="line-removed"> 973                     }</span>
<span class="line-removed"> 974                 }</span>
<span class="line-removed"> 975             } else if (node instanceof ShortCircuitOrNode) {</span>
<span class="line-removed"> 976                 final ShortCircuitOrNode shortCircuitOrNode = (ShortCircuitOrNode) node;</span>
<span class="line-removed"> 977                 return tryProveCondition(shortCircuitOrNode.getX(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
<span class="line-removed"> 978                     if (result == !shortCircuitOrNode.isXNegated()) {</span>
<span class="line-removed"> 979                         return rewireGuards(guard, true, newInput, guardedValueStamp, rewireGuardFunction);</span>
<span class="line-removed"> 980                     } else {</span>
<span class="line-removed"> 981                         return tryProveCondition(shortCircuitOrNode.getY(), (innerGuard, innerResult, innerGuardedValueStamp, innerNewInput) -&gt; {</span>
<span class="line-removed"> 982                             ValueNode proxifiedInput = newInput;</span>
<span class="line-removed"> 983                             if (proxifiedInput == null) {</span>
<span class="line-removed"> 984                                 proxifiedInput = innerNewInput;</span>
<span class="line-removed"> 985                             } else if (innerNewInput != null) {</span>
<span class="line-removed"> 986                                 if (innerNewInput != newInput) {</span>
<span class="line-removed"> 987                                     // Cannot canonicalize due to different proxied inputs.</span>
<span class="line-removed"> 988                                     return false;</span>
<span class="line-removed"> 989                                 }</span>
<span class="line-removed"> 990                             }</span>
<span class="line-removed"> 991                             // Can only canonicalize if the guards are equal.</span>
<span class="line-removed"> 992                             if (innerGuard == guard) {</span>
<span class="line-removed"> 993                                 return rewireGuards(guard, innerResult ^ shortCircuitOrNode.isYNegated(), proxifiedInput, guardedValueStamp, rewireGuardFunction);</span>
<span class="line-removed"> 994                             }</span>
<span class="line-removed"> 995                             return false;</span>
<span class="line-removed"> 996                         });</span>
<span class="line-removed"> 997                     }</span>
<span class="line-removed"> 998                 });</span>
<span class="line-removed"> 999             }</span>
<span class="line-removed">1000 </span>
<span class="line-removed">1001             return false;</span>
<span class="line-removed">1002         }</span>
<span class="line-removed">1003 </span>
1004         protected void registerNewStamp(ValueNode maybeProxiedValue, Stamp newStamp, GuardingNode guard) {
1005             registerNewStamp(maybeProxiedValue, newStamp, guard, false);
1006         }
1007 
1008         protected void registerNewStamp(ValueNode maybeProxiedValue, Stamp newStamp, GuardingNode guard, boolean propagateThroughPis) {
1009             assert maybeProxiedValue != null;
1010             assert guard != null;
1011 
1012             if (newStamp == null || newStamp.isUnrestricted()) {
1013                 return;
1014             }
1015 
1016             ValueNode value = maybeProxiedValue;
1017             Stamp stamp = newStamp;
1018 
1019             while (stamp != null &amp;&amp; value != null) {
1020                 ValueNode proxiedValue = null;
1021                 if (value instanceof PiNode) {
1022                     proxiedValue = value;
1023                 }
1024                 counterStampsRegistered.increment(debug);
1025                 debug.log(&quot;\t Saving stamp for node %s stamp %s guarded by %s&quot;, value, stamp, guard);
1026                 assert value instanceof LogicNode || stamp.isCompatible(value.stamp(NodeView.DEFAULT)) : stamp + &quot; vs. &quot; + value.stamp(NodeView.DEFAULT) + &quot; (&quot; + value + &quot;)&quot;;
1027                 map.setAndGrow(value, new InfoElement(stamp, guard, proxiedValue, map.getAndGrow(value)));
1028                 undoOperations.push(value);
1029                 if (propagateThroughPis &amp;&amp; value instanceof PiNode) {
1030                     PiNode piNode = (PiNode) value;
1031                     value = piNode.getOriginalNode();
1032                 } else if (value instanceof StampInverter) {
1033                     StampInverter stampInverter = (StampInverter) value;
1034                     value = stampInverter.getValue();
1035                     stamp = stampInverter.invertStamp(stamp);
1036                 } else {
1037                     break;
1038                 }
1039             }
1040         }
1041 
1042         protected void processAbstractBegin(AbstractBeginNode beginNode) {
1043             Node predecessor = beginNode.predecessor();
1044             if (predecessor instanceof IfNode) {
1045                 IfNode ifNode = (IfNode) predecessor;
1046                 boolean negated = (ifNode.falseSuccessor() == beginNode);
1047                 LogicNode condition = ifNode.condition();
1048                 registerNewCondition(condition, negated, beginNode);
1049             } else if (predecessor instanceof TypeSwitchNode) {
1050                 TypeSwitchNode typeSwitch = (TypeSwitchNode) predecessor;
1051                 processTypeSwitch(beginNode, typeSwitch);
1052             } else if (predecessor instanceof IntegerSwitchNode) {
1053                 IntegerSwitchNode integerSwitchNode = (IntegerSwitchNode) predecessor;
1054                 processIntegerSwitch(beginNode, integerSwitchNode);
1055             }
1056         }
1057 
1058         private static boolean maybeMultipleUsages(ValueNode value) {
1059             if (value.hasMoreThanOneUsage()) {
1060                 return true;
1061             } else {
1062                 return value instanceof ProxyNode ||
1063                                 value instanceof PiNode ||
1064                                 value instanceof StampInverter;
1065             }
1066         }
1067 
1068         protected void processIntegerSwitch(AbstractBeginNode beginNode, IntegerSwitchNode integerSwitchNode) {
1069             ValueNode value = integerSwitchNode.value();
1070             if (maybeMultipleUsages(value)) {
1071                 Stamp stamp = integerSwitchNode.getValueStampForSuccessor(beginNode);
1072                 if (stamp != null) {
1073                     registerNewStamp(value, stamp, beginNode);
1074                 }
1075             }
1076         }
1077 
1078         protected void processTypeSwitch(AbstractBeginNode beginNode, TypeSwitchNode typeSwitch) {
1079             ValueNode hub = typeSwitch.value();
1080             if (hub instanceof LoadHubNode) {
1081                 LoadHubNode loadHub = (LoadHubNode) hub;
1082                 ValueNode value = loadHub.getValue();
1083                 if (maybeMultipleUsages(value)) {
1084                     Stamp stamp = typeSwitch.getValueStampForSuccessor(beginNode);
1085                     if (stamp != null) {
1086                         registerNewStamp(value, stamp, beginNode);
1087                     }
1088                 }
1089             }
1090         }
1091 
1092         @Override
1093         public void exit(Block b, Marks marks) {
1094             int infoElementsMark = marks.infoElementOperations;
1095             while (undoOperations.size() &gt; infoElementsMark) {
1096                 Node node = undoOperations.pop();
1097                 if (node.isAlive()) {
1098                     map.set(node, map.get(node).getParent());
1099                 }
1100             }
1101 
1102             int conditionsMark = marks.conditions;
1103             while (conditions.size() &gt; conditionsMark) {
1104                 conditions.pop();
1105             }
1106         }
1107     }
1108 
<a name="43" id="anc43"></a><span class="line-removed">1109     @FunctionalInterface</span>
<span class="line-removed">1110     protected interface InfoElementProvider {</span>
<span class="line-removed">1111         Iterable&lt;InfoElement&gt; getInfoElements(ValueNode value);</span>
<span class="line-removed">1112     }</span>
<span class="line-removed">1113 </span>
<span class="line-removed">1114     /**</span>
<span class="line-removed">1115      * Checks for safe nodes when moving pending tests up.</span>
<span class="line-removed">1116      */</span>
<span class="line-removed">1117     static class InputFilter extends Node.EdgeVisitor {</span>
<span class="line-removed">1118         boolean ok;</span>
<span class="line-removed">1119         private ValueNode value;</span>
<span class="line-removed">1120 </span>
<span class="line-removed">1121         InputFilter(ValueNode value) {</span>
<span class="line-removed">1122             this.value = value;</span>
<span class="line-removed">1123             this.ok = true;</span>
<span class="line-removed">1124         }</span>
<span class="line-removed">1125 </span>
<span class="line-removed">1126         @Override</span>
<span class="line-removed">1127         public Node apply(Node node, Node curNode) {</span>
<span class="line-removed">1128             if (!ok) {</span>
<span class="line-removed">1129                 // Abort the recursion</span>
<span class="line-removed">1130                 return curNode;</span>
<span class="line-removed">1131             }</span>
<span class="line-removed">1132             if (!(curNode instanceof ValueNode)) {</span>
<span class="line-removed">1133                 ok = false;</span>
<span class="line-removed">1134                 return curNode;</span>
<span class="line-removed">1135             }</span>
<span class="line-removed">1136             ValueNode curValue = (ValueNode) curNode;</span>
<span class="line-removed">1137             if (curValue.isConstant() || curValue == value || curValue instanceof ParameterNode) {</span>
<span class="line-removed">1138                 return curNode;</span>
<span class="line-removed">1139             }</span>
<span class="line-removed">1140             if (curValue instanceof BinaryNode || curValue instanceof UnaryNode) {</span>
<span class="line-removed">1141                 curValue.applyInputs(this);</span>
<span class="line-removed">1142             } else {</span>
<span class="line-removed">1143                 ok = false;</span>
<span class="line-removed">1144             }</span>
<span class="line-removed">1145             return curNode;</span>
<span class="line-removed">1146         }</span>
<span class="line-removed">1147     }</span>
<span class="line-removed">1148 </span>
<span class="line-removed">1149     @FunctionalInterface</span>
<span class="line-removed">1150     protected interface GuardRewirer {</span>
<span class="line-removed">1151         /**</span>
<span class="line-removed">1152          * Called if the condition could be proven to have a constant value ({@code result}) under</span>
<span class="line-removed">1153          * {@code guard}.</span>
<span class="line-removed">1154          *</span>
<span class="line-removed">1155          * @param guard the guard whose result is proven</span>
<span class="line-removed">1156          * @param result the known result of the guard</span>
<span class="line-removed">1157          * @param newInput new input to pi nodes depending on the new guard</span>
<span class="line-removed">1158          * @return whether the transformation could be applied</span>
<span class="line-removed">1159          */</span>
<span class="line-removed">1160         boolean rewire(GuardingNode guard, boolean result, Stamp guardedValueStamp, ValueNode newInput);</span>
<span class="line-removed">1161     }</span>
<span class="line-removed">1162 </span>
<span class="line-removed">1163     protected static final class InfoElement {</span>
<span class="line-removed">1164         private final Stamp stamp;</span>
<span class="line-removed">1165         private final GuardingNode guard;</span>
<span class="line-removed">1166         private final ValueNode proxifiedInput;</span>
<span class="line-removed">1167         private final InfoElement parent;</span>
<span class="line-removed">1168 </span>
<span class="line-removed">1169         public InfoElement(Stamp stamp, GuardingNode guard, ValueNode proxifiedInput, InfoElement parent) {</span>
<span class="line-removed">1170             this.stamp = stamp;</span>
<span class="line-removed">1171             this.guard = guard;</span>
<span class="line-removed">1172             this.proxifiedInput = proxifiedInput;</span>
<span class="line-removed">1173             this.parent = parent;</span>
<span class="line-removed">1174         }</span>
<span class="line-removed">1175 </span>
<span class="line-removed">1176         public InfoElement getParent() {</span>
<span class="line-removed">1177             return parent;</span>
<span class="line-removed">1178         }</span>
<span class="line-removed">1179 </span>
<span class="line-removed">1180         public Stamp getStamp() {</span>
<span class="line-removed">1181             return stamp;</span>
<span class="line-removed">1182         }</span>
<span class="line-removed">1183 </span>
<span class="line-removed">1184         public GuardingNode getGuard() {</span>
<span class="line-removed">1185             return guard;</span>
<span class="line-removed">1186         }</span>
<span class="line-removed">1187 </span>
<span class="line-removed">1188         public ValueNode getProxifiedInput() {</span>
<span class="line-removed">1189             return proxifiedInput;</span>
<span class="line-removed">1190         }</span>
<span class="line-removed">1191 </span>
<span class="line-removed">1192         @Override</span>
<span class="line-removed">1193         public String toString() {</span>
<span class="line-removed">1194             return stamp + &quot; -&gt; &quot; + guard;</span>
<span class="line-removed">1195         }</span>
<span class="line-removed">1196     }</span>
<span class="line-removed">1197 </span>
1198     @Override
1199     public float codeSizeIncrease() {
1200         return 1.5f;
1201     }
1202 }
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/inlining/walker/InliningData.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../policy/InliningPolicy.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../util/EconomicSetNodeEventListener.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/inlining/walker/InliningData.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 28 import static org.graalvm.compiler.core.common.GraalOptions.MaximumRecursiveInlining;
 29 import static org.graalvm.compiler.core.common.GraalOptions.MegamorphicInliningMinMethodProbability;
 30 
 31 import java.util.ArrayDeque;
 32 import java.util.ArrayList;
 33 import java.util.BitSet;
 34 import java.util.Collection;
 35 import java.util.Iterator;
 36 import java.util.LinkedList;
 37 import java.util.List;
 38 
 39 import jdk.internal.vm.compiler.collections.EconomicSet;
 40 import jdk.internal.vm.compiler.collections.Equivalence;
 41 import org.graalvm.compiler.core.common.type.ObjectStamp;
 42 import org.graalvm.compiler.debug.CounterKey;
 43 import org.graalvm.compiler.debug.DebugContext;
 44 import org.graalvm.compiler.debug.GraalError;
 45 import org.graalvm.compiler.graph.Graph;
 46 import org.graalvm.compiler.graph.Node;
 47 import org.graalvm.compiler.nodes.CallTargetNode;

 48 import org.graalvm.compiler.nodes.Invoke;
 49 import org.graalvm.compiler.nodes.NodeView;
 50 import org.graalvm.compiler.nodes.ParameterNode;
 51 import org.graalvm.compiler.nodes.StructuredGraph;
 52 import org.graalvm.compiler.nodes.ValueNode;
 53 import org.graalvm.compiler.nodes.java.AbstractNewObjectNode;
 54 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 55 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
 56 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 57 import org.graalvm.compiler.options.OptionValues;
 58 import org.graalvm.compiler.phases.OptimisticOptimizations;
 59 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 60 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 61 import org.graalvm.compiler.phases.common.inlining.info.AssumptionInlineInfo;
 62 import org.graalvm.compiler.phases.common.inlining.info.ExactInlineInfo;
 63 import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
 64 import org.graalvm.compiler.phases.common.inlining.info.MultiTypeGuardInlineInfo;
 65 import org.graalvm.compiler.phases.common.inlining.info.TypeGuardInlineInfo;
 66 import org.graalvm.compiler.phases.common.inlining.info.elem.Inlineable;
 67 import org.graalvm.compiler.phases.common.inlining.info.elem.InlineableGraph;
</pre>
<hr />
<pre>
127         this.context = context;
128         this.maxMethodPerInlining = maxMethodPerInlining;
129         this.canonicalizer = canonicalizer;
130         this.inliningPolicy = inliningPolicy;
131         this.maxGraphs = 1;
132         this.rootGraph = rootGraph;
133         this.debug = rootGraph.getDebug();
134 
135         invocationQueue.push(new MethodInvocation(null, 1.0, 1.0, null));
136         graphQueue.push(new CallsiteHolderExplorable(rootGraph, 1.0, 1.0, null, rootInvokes));
137     }
138 
139     public static boolean isFreshInstantiation(ValueNode arg) {
140         return (arg instanceof AbstractNewObjectNode) || (arg instanceof AllocatedObjectNode) || (arg instanceof VirtualObjectNode);
141     }
142 
143     private String checkTargetConditionsHelper(ResolvedJavaMethod method, int invokeBci) {
144         OptionValues options = rootGraph.getOptions();
145         if (method == null) {
146             return &quot;the method is not resolved&quot;;
<span class="line-modified">147         } else if (method.isNative() &amp;&amp; (!Intrinsify.getValue(options) || !InliningUtil.canIntrinsify(context.getReplacements(), method, invokeBci))) {</span>




148             return &quot;it is a non-intrinsic native method&quot;;
149         } else if (method.isAbstract()) {
150             return &quot;it is an abstract method&quot;;
151         } else if (!method.getDeclaringClass().isInitialized()) {
152             return &quot;the method&#39;s class is not initialized&quot;;
153         } else if (!method.canBeInlined()) {
154             return &quot;it is marked non-inlinable&quot;;
155         } else if (countRecursiveInlining(method) &gt; MaximumRecursiveInlining.getValue(options)) {
156             return &quot;it exceeds the maximum recursive inlining depth&quot;;
157         } else {
158             if (new OptimisticOptimizations(rootGraph.getProfilingInfo(method), options).lessOptimisticThan(context.getOptimisticOptimizations())) {
159                 return &quot;the callee uses less optimistic optimizations than caller&quot;;
160             } else {
161                 return null;
162             }
163         }
164     }
165 
166     private boolean checkTargetConditions(Invoke invoke, ResolvedJavaMethod method) {
167         final String failureMessage = checkTargetConditionsHelper(method, invoke.bci());
</pre>
<hr />
<pre>
172             invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null, failureMessage);
173             return false;
174         }
175     }
176 
177     /**
178      * Determines if inlining is possible at the given invoke node.
179      *
180      * @param invoke the invoke that should be inlined
181      * @return an instance of InlineInfo, or null if no inlining is possible at the given invoke
182      */
183     private InlineInfo getInlineInfo(Invoke invoke) {
184         final String failureMessage = InliningUtil.checkInvokeConditions(invoke);
185         if (failureMessage != null) {
186             InliningUtil.logNotInlinedMethod(invoke, failureMessage);
187             return null;
188         }
189         MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
190         ResolvedJavaMethod targetMethod = callTarget.targetMethod();
191 
<span class="line-modified">192         if (callTarget.invokeKind() == CallTargetNode.InvokeKind.Special || targetMethod.canBeStaticallyBound()) {</span>

193             return getExactInlineInfo(invoke, targetMethod);
194         }
195 
<span class="line-modified">196         assert callTarget.invokeKind().isIndirect();</span>
197 
198         ResolvedJavaType holder = targetMethod.getDeclaringClass();
199         if (!(callTarget.receiver().stamp(NodeView.DEFAULT) instanceof ObjectStamp)) {
200             return null;
201         }
202         ObjectStamp receiverStamp = (ObjectStamp) callTarget.receiver().stamp(NodeView.DEFAULT);
203         if (receiverStamp.alwaysNull()) {
204             // Don&#39;t inline if receiver is known to be null
205             return null;
206         }
207         ResolvedJavaType contextType = invoke.getContextType();
208         if (receiverStamp.type() != null) {
209             // the invoke target might be more specific than the holder (happens after inlining:
210             // parameters lose their declared type...)
211             ResolvedJavaType receiverType = receiverStamp.type();
212             if (receiverType != null &amp;&amp; holder.isAssignableFrom(receiverType)) {
213                 holder = receiverType;
214                 if (receiverStamp.isExactType()) {
215                     assert targetMethod.getDeclaringClass().isAssignableFrom(holder) : holder + &quot; subtype of &quot; + targetMethod.getDeclaringClass() + &quot; for &quot; + targetMethod;
216                     ResolvedJavaMethod resolvedMethod = holder.resolveConcreteMethod(targetMethod, contextType);
</pre>
<hr />
<pre>
438     }
439 
440     /**
441      *
442      * This method attempts:
443      * &lt;ol&gt;
444      * &lt;li&gt;to inline at the callsite given by &lt;code&gt;calleeInvocation&lt;/code&gt;, where that callsite
445      * belongs to the {@link CallsiteHolderExplorable} at the top of the {@link #graphQueue}
446      * maintained in this class.&lt;/li&gt;
447      * &lt;li&gt;otherwise, to devirtualize the callsite in question.&lt;/li&gt;
448      * &lt;/ol&gt;
449      *
450      * @return true iff inlining was actually performed
451      */
452     private boolean tryToInline(MethodInvocation calleeInvocation, int inliningDepth) {
453         CallsiteHolderExplorable callerCallsiteHolder = (CallsiteHolderExplorable) currentGraph();
454         InlineInfo calleeInfo = calleeInvocation.callee();
455         assert callerCallsiteHolder.containsInvoke(calleeInfo.invoke());
456         counterInliningConsidered.increment(debug);
457 
<span class="line-modified">458         InliningPolicy.Decision decision = inliningPolicy.isWorthInlining(context.getReplacements(), calleeInvocation, inliningDepth, true);</span>
459         if (decision.shouldInline()) {
460             doInline(callerCallsiteHolder, calleeInvocation, decision.getReason());
461             return true;
462         }
463 
464         if (context.getOptimisticOptimizations().devirtualizeInvokes(calleeInfo.graph().getOptions())) {
465             calleeInfo.tryToDevirtualizeInvoke(new Providers(context));
466         }
467 
468         return false;
469     }
470 
471     /**
472      * This method picks one of the callsites belonging to the current
473      * {@link CallsiteHolderExplorable}. Provided the callsite qualifies to be analyzed for
474      * inlining, this method prepares a new stack top in {@link InliningData} for such callsite,
475      * which comprises:
476      * &lt;ul&gt;
477      * &lt;li&gt;preparing a summary of feasible targets, ie preparing an {@link InlineInfo}&lt;/li&gt;
478      * &lt;li&gt;based on it, preparing the stack top proper which consists of:&lt;/li&gt;
</pre>
<hr />
<pre>
699      * &lt;/p&gt;
700      *
701      * &lt;p&gt;
702      * Some facts about the alternatives above:
703      * &lt;ul&gt;
704      * &lt;li&gt;the first step amounts to backtracking, the 2nd one to depth-search, and the 3rd one also
705      * involves backtracking (however possibly after inlining).&lt;/li&gt;
706      * &lt;li&gt;the choice of abandon-and-backtrack or delve-into depends on
707      * {@link InliningPolicy#isWorthInlining} and {@link InliningPolicy#continueInlining}.&lt;/li&gt;
708      * &lt;li&gt;the 3rd choice is picked whenever none of the previous choices are made&lt;/li&gt;
709      * &lt;/ul&gt;
710      * &lt;/p&gt;
711      *
712      * @return true iff inlining was actually performed
713      */
714     @SuppressWarnings(&quot;try&quot;)
715     public boolean moveForward() {
716 
717         final MethodInvocation currentInvocation = currentInvocation();
718 
<span class="line-modified">719         final boolean backtrack = (!currentInvocation.isRoot() &amp;&amp; !inliningPolicy.isWorthInlining(context.getReplacements(), currentInvocation, inliningDepth(), false).shouldInline());</span>

720         if (backtrack) {
721             int remainingGraphs = currentInvocation.totalGraphs() - currentInvocation.processedGraphs();
722             assert remainingGraphs &gt; 0;
723             popGraphs(remainingGraphs);
724             popInvocation();
725             return false;
726         }
727 
728         final boolean delve = currentGraph().hasRemainingInvokes() &amp;&amp; inliningPolicy.continueInlining(currentGraph().graph());
729         if (delve) {
730             processNextInvoke();
731             return false;
732         }
733 
734         popGraph();
735         if (currentInvocation.isRoot()) {
736             return false;
737         }
738 
739         // try to inline
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 28 import static org.graalvm.compiler.core.common.GraalOptions.MaximumRecursiveInlining;
 29 import static org.graalvm.compiler.core.common.GraalOptions.MegamorphicInliningMinMethodProbability;
 30 
 31 import java.util.ArrayDeque;
 32 import java.util.ArrayList;
 33 import java.util.BitSet;
 34 import java.util.Collection;
 35 import java.util.Iterator;
 36 import java.util.LinkedList;
 37 import java.util.List;
 38 
 39 import jdk.internal.vm.compiler.collections.EconomicSet;
 40 import jdk.internal.vm.compiler.collections.Equivalence;
 41 import org.graalvm.compiler.core.common.type.ObjectStamp;
 42 import org.graalvm.compiler.debug.CounterKey;
 43 import org.graalvm.compiler.debug.DebugContext;
 44 import org.graalvm.compiler.debug.GraalError;
 45 import org.graalvm.compiler.graph.Graph;
 46 import org.graalvm.compiler.graph.Node;
 47 import org.graalvm.compiler.nodes.CallTargetNode;
<span class="line-added"> 48 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;</span>
 49 import org.graalvm.compiler.nodes.Invoke;
 50 import org.graalvm.compiler.nodes.NodeView;
 51 import org.graalvm.compiler.nodes.ParameterNode;
 52 import org.graalvm.compiler.nodes.StructuredGraph;
 53 import org.graalvm.compiler.nodes.ValueNode;
 54 import org.graalvm.compiler.nodes.java.AbstractNewObjectNode;
 55 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 56 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
 57 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 58 import org.graalvm.compiler.options.OptionValues;
 59 import org.graalvm.compiler.phases.OptimisticOptimizations;
 60 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 61 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 62 import org.graalvm.compiler.phases.common.inlining.info.AssumptionInlineInfo;
 63 import org.graalvm.compiler.phases.common.inlining.info.ExactInlineInfo;
 64 import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
 65 import org.graalvm.compiler.phases.common.inlining.info.MultiTypeGuardInlineInfo;
 66 import org.graalvm.compiler.phases.common.inlining.info.TypeGuardInlineInfo;
 67 import org.graalvm.compiler.phases.common.inlining.info.elem.Inlineable;
 68 import org.graalvm.compiler.phases.common.inlining.info.elem.InlineableGraph;
</pre>
<hr />
<pre>
128         this.context = context;
129         this.maxMethodPerInlining = maxMethodPerInlining;
130         this.canonicalizer = canonicalizer;
131         this.inliningPolicy = inliningPolicy;
132         this.maxGraphs = 1;
133         this.rootGraph = rootGraph;
134         this.debug = rootGraph.getDebug();
135 
136         invocationQueue.push(new MethodInvocation(null, 1.0, 1.0, null));
137         graphQueue.push(new CallsiteHolderExplorable(rootGraph, 1.0, 1.0, null, rootInvokes));
138     }
139 
140     public static boolean isFreshInstantiation(ValueNode arg) {
141         return (arg instanceof AbstractNewObjectNode) || (arg instanceof AllocatedObjectNode) || (arg instanceof VirtualObjectNode);
142     }
143 
144     private String checkTargetConditionsHelper(ResolvedJavaMethod method, int invokeBci) {
145         OptionValues options = rootGraph.getOptions();
146         if (method == null) {
147             return &quot;the method is not resolved&quot;;
<span class="line-modified">148         } else if (method.isNative() &amp;&amp; !(Intrinsify.getValue(options) &amp;&amp;</span>
<span class="line-added">149                         context.getReplacements().getSubstitution(method, invokeBci, rootGraph.trackNodeSourcePosition(), null, options) != null)) {</span>
<span class="line-added">150             // We have conditional intrinsic, e.g., String.intern, which may not have inlineable</span>
<span class="line-added">151             // graph depending on the context. The getSubstitution test ensures the inlineable</span>
<span class="line-added">152             // graph is present.</span>
153             return &quot;it is a non-intrinsic native method&quot;;
154         } else if (method.isAbstract()) {
155             return &quot;it is an abstract method&quot;;
156         } else if (!method.getDeclaringClass().isInitialized()) {
157             return &quot;the method&#39;s class is not initialized&quot;;
158         } else if (!method.canBeInlined()) {
159             return &quot;it is marked non-inlinable&quot;;
160         } else if (countRecursiveInlining(method) &gt; MaximumRecursiveInlining.getValue(options)) {
161             return &quot;it exceeds the maximum recursive inlining depth&quot;;
162         } else {
163             if (new OptimisticOptimizations(rootGraph.getProfilingInfo(method), options).lessOptimisticThan(context.getOptimisticOptimizations())) {
164                 return &quot;the callee uses less optimistic optimizations than caller&quot;;
165             } else {
166                 return null;
167             }
168         }
169     }
170 
171     private boolean checkTargetConditions(Invoke invoke, ResolvedJavaMethod method) {
172         final String failureMessage = checkTargetConditionsHelper(method, invoke.bci());
</pre>
<hr />
<pre>
177             invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null, failureMessage);
178             return false;
179         }
180     }
181 
182     /**
183      * Determines if inlining is possible at the given invoke node.
184      *
185      * @param invoke the invoke that should be inlined
186      * @return an instance of InlineInfo, or null if no inlining is possible at the given invoke
187      */
188     private InlineInfo getInlineInfo(Invoke invoke) {
189         final String failureMessage = InliningUtil.checkInvokeConditions(invoke);
190         if (failureMessage != null) {
191             InliningUtil.logNotInlinedMethod(invoke, failureMessage);
192             return null;
193         }
194         MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
195         ResolvedJavaMethod targetMethod = callTarget.targetMethod();
196 
<span class="line-modified">197         InvokeKind invokeKind = callTarget.invokeKind();</span>
<span class="line-added">198         if (invokeKind == CallTargetNode.InvokeKind.Special || invokeKind == CallTargetNode.InvokeKind.Static || targetMethod.canBeStaticallyBound()) {</span>
199             return getExactInlineInfo(invoke, targetMethod);
200         }
201 
<span class="line-modified">202         assert invokeKind.isIndirect();</span>
203 
204         ResolvedJavaType holder = targetMethod.getDeclaringClass();
205         if (!(callTarget.receiver().stamp(NodeView.DEFAULT) instanceof ObjectStamp)) {
206             return null;
207         }
208         ObjectStamp receiverStamp = (ObjectStamp) callTarget.receiver().stamp(NodeView.DEFAULT);
209         if (receiverStamp.alwaysNull()) {
210             // Don&#39;t inline if receiver is known to be null
211             return null;
212         }
213         ResolvedJavaType contextType = invoke.getContextType();
214         if (receiverStamp.type() != null) {
215             // the invoke target might be more specific than the holder (happens after inlining:
216             // parameters lose their declared type...)
217             ResolvedJavaType receiverType = receiverStamp.type();
218             if (receiverType != null &amp;&amp; holder.isAssignableFrom(receiverType)) {
219                 holder = receiverType;
220                 if (receiverStamp.isExactType()) {
221                     assert targetMethod.getDeclaringClass().isAssignableFrom(holder) : holder + &quot; subtype of &quot; + targetMethod.getDeclaringClass() + &quot; for &quot; + targetMethod;
222                     ResolvedJavaMethod resolvedMethod = holder.resolveConcreteMethod(targetMethod, contextType);
</pre>
<hr />
<pre>
444     }
445 
446     /**
447      *
448      * This method attempts:
449      * &lt;ol&gt;
450      * &lt;li&gt;to inline at the callsite given by &lt;code&gt;calleeInvocation&lt;/code&gt;, where that callsite
451      * belongs to the {@link CallsiteHolderExplorable} at the top of the {@link #graphQueue}
452      * maintained in this class.&lt;/li&gt;
453      * &lt;li&gt;otherwise, to devirtualize the callsite in question.&lt;/li&gt;
454      * &lt;/ol&gt;
455      *
456      * @return true iff inlining was actually performed
457      */
458     private boolean tryToInline(MethodInvocation calleeInvocation, int inliningDepth) {
459         CallsiteHolderExplorable callerCallsiteHolder = (CallsiteHolderExplorable) currentGraph();
460         InlineInfo calleeInfo = calleeInvocation.callee();
461         assert callerCallsiteHolder.containsInvoke(calleeInfo.invoke());
462         counterInliningConsidered.increment(debug);
463 
<span class="line-modified">464         InliningPolicy.Decision decision = inliningPolicy.isWorthInlining(context.getReplacements(), calleeInvocation, calleeInfo, inliningDepth, true);</span>
465         if (decision.shouldInline()) {
466             doInline(callerCallsiteHolder, calleeInvocation, decision.getReason());
467             return true;
468         }
469 
470         if (context.getOptimisticOptimizations().devirtualizeInvokes(calleeInfo.graph().getOptions())) {
471             calleeInfo.tryToDevirtualizeInvoke(new Providers(context));
472         }
473 
474         return false;
475     }
476 
477     /**
478      * This method picks one of the callsites belonging to the current
479      * {@link CallsiteHolderExplorable}. Provided the callsite qualifies to be analyzed for
480      * inlining, this method prepares a new stack top in {@link InliningData} for such callsite,
481      * which comprises:
482      * &lt;ul&gt;
483      * &lt;li&gt;preparing a summary of feasible targets, ie preparing an {@link InlineInfo}&lt;/li&gt;
484      * &lt;li&gt;based on it, preparing the stack top proper which consists of:&lt;/li&gt;
</pre>
<hr />
<pre>
705      * &lt;/p&gt;
706      *
707      * &lt;p&gt;
708      * Some facts about the alternatives above:
709      * &lt;ul&gt;
710      * &lt;li&gt;the first step amounts to backtracking, the 2nd one to depth-search, and the 3rd one also
711      * involves backtracking (however possibly after inlining).&lt;/li&gt;
712      * &lt;li&gt;the choice of abandon-and-backtrack or delve-into depends on
713      * {@link InliningPolicy#isWorthInlining} and {@link InliningPolicy#continueInlining}.&lt;/li&gt;
714      * &lt;li&gt;the 3rd choice is picked whenever none of the previous choices are made&lt;/li&gt;
715      * &lt;/ul&gt;
716      * &lt;/p&gt;
717      *
718      * @return true iff inlining was actually performed
719      */
720     @SuppressWarnings(&quot;try&quot;)
721     public boolean moveForward() {
722 
723         final MethodInvocation currentInvocation = currentInvocation();
724 
<span class="line-modified">725         final boolean backtrack = (!currentInvocation.isRoot() &amp;&amp;</span>
<span class="line-added">726                         !inliningPolicy.isWorthInlining(context.getReplacements(), currentInvocation, currentInvocation.callee(), inliningDepth(), false).shouldInline());</span>
727         if (backtrack) {
728             int remainingGraphs = currentInvocation.totalGraphs() - currentInvocation.processedGraphs();
729             assert remainingGraphs &gt; 0;
730             popGraphs(remainingGraphs);
731             popInvocation();
732             return false;
733         }
734 
735         final boolean delve = currentGraph().hasRemainingInvokes() &amp;&amp; inliningPolicy.continueInlining(currentGraph().graph());
736         if (delve) {
737             processNextInvoke();
738             return false;
739         }
740 
741         popGraph();
742         if (currentInvocation.isRoot()) {
743             return false;
744         }
745 
746         // try to inline
</pre>
</td>
</tr>
</table>
<center><a href="../policy/InliningPolicy.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../util/EconomicSetNodeEventListener.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/FloatingReadPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FixReadsPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="FrameStateAssignmentPhase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/FloatingReadPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 31 import java.util.EnumSet;
 32 import java.util.Iterator;
 33 import java.util.List;
 34 
 35 import jdk.internal.vm.compiler.collections.EconomicMap;
 36 import jdk.internal.vm.compiler.collections.EconomicSet;
 37 import jdk.internal.vm.compiler.collections.Equivalence;
 38 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
 39 import org.graalvm.compiler.core.common.cfg.Loop;
 40 import org.graalvm.compiler.debug.DebugCloseable;
 41 import org.graalvm.compiler.graph.Graph.NodeEventScope;
 42 import org.graalvm.compiler.graph.Node;
 43 import org.graalvm.compiler.nodes.AbstractBeginNode;
 44 import org.graalvm.compiler.nodes.AbstractMergeNode;
 45 import org.graalvm.compiler.nodes.FixedNode;
 46 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 47 import org.graalvm.compiler.nodes.LoopBeginNode;
 48 import org.graalvm.compiler.nodes.LoopEndNode;
 49 import org.graalvm.compiler.nodes.LoopExitNode;
 50 import org.graalvm.compiler.nodes.PhiNode;

 51 import org.graalvm.compiler.nodes.ReturnNode;
 52 import org.graalvm.compiler.nodes.StartNode;
 53 import org.graalvm.compiler.nodes.StructuredGraph;
 54 import org.graalvm.compiler.nodes.ValueNodeUtil;
 55 import org.graalvm.compiler.nodes.calc.FloatingNode;
 56 import org.graalvm.compiler.nodes.cfg.Block;
 57 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 58 import org.graalvm.compiler.nodes.cfg.HIRLoop;
 59 import org.graalvm.compiler.nodes.memory.FloatableAccessNode;
 60 import org.graalvm.compiler.nodes.memory.FloatingAccessNode;
 61 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
 62 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 63 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
 64 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;
 65 import org.graalvm.compiler.nodes.memory.MemoryMap;
 66 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
 67 import org.graalvm.compiler.nodes.memory.MemoryNode;
 68 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
 69 import org.graalvm.compiler.nodes.memory.ReadNode;
 70 import org.graalvm.compiler.nodes.util.GraphUtil;
</pre>
<hr />
<pre>
149     private static EconomicSet&lt;Node&gt; removeExternallyUsedNodes(EconomicSet&lt;Node&gt; set) {
150         boolean change;
151         do {
152             change = false;
153             for (Iterator&lt;Node&gt; iter = set.iterator(); iter.hasNext();) {
154                 Node node = iter.next();
155                 for (Node usage : node.usages()) {
156                     if (!set.contains(usage)) {
157                         change = true;
158                         iter.remove();
159                         break;
160                     }
161                 }
162             }
163         } while (change);
164         return set;
165     }
166 
167     protected void processNode(FixedNode node, EconomicSet&lt;LocationIdentity&gt; currentState) {
168         if (node instanceof MemoryCheckpoint.Single) {
<span class="line-modified">169             processIdentity(currentState, ((MemoryCheckpoint.Single) node).getLocationIdentity());</span>
170         } else if (node instanceof MemoryCheckpoint.Multi) {
<span class="line-modified">171             for (LocationIdentity identity : ((MemoryCheckpoint.Multi) node).getLocationIdentities()) {</span>
172                 processIdentity(currentState, identity);
173             }
174         }
175     }
176 
177     private static void processIdentity(EconomicSet&lt;LocationIdentity&gt; currentState, LocationIdentity identity) {
178         if (identity.isMutable()) {
179             currentState.add(identity);
180         }
181     }
182 
183     protected void processBlock(Block b, EconomicSet&lt;LocationIdentity&gt; currentState) {
184         for (FixedNode n : b.getNodes()) {
185             processNode(n, currentState);
186         }
187     }
188 
189     private EconomicSet&lt;LocationIdentity&gt; processLoop(HIRLoop loop, EconomicMap&lt;LoopBeginNode, EconomicSet&lt;LocationIdentity&gt;&gt; modifiedInLoops) {
190         LoopBeginNode loopBegin = (LoopBeginNode) loop.getHeader().getBeginNode();
191         EconomicSet&lt;LocationIdentity&gt; result = modifiedInLoops.get(loopBegin);
</pre>
<hr />
<pre>
237             graph.setAfterFloatingReadPhase(true);
238         }
239     }
240 
241     public static MemoryMapImpl mergeMemoryMaps(AbstractMergeNode merge, List&lt;? extends MemoryMap&gt; states) {
242         MemoryMapImpl newState = new MemoryMapImpl();
243 
244         EconomicSet&lt;LocationIdentity&gt; keys = EconomicSet.create(Equivalence.DEFAULT);
245         for (MemoryMap other : states) {
246             keys.addAll(other.getLocations());
247         }
248         assert checkNoImmutableLocations(keys);
249 
250         for (LocationIdentity key : keys) {
251             int mergedStatesCount = 0;
252             boolean isPhi = false;
253             MemoryNode merged = null;
254             for (MemoryMap state : states) {
255                 MemoryNode last = state.getLastLocationAccess(key);
256                 if (isPhi) {


257                     ((MemoryPhiNode) merged).addInput(ValueNodeUtil.asNode(last));
258                 } else {
259                     if (merged == last) {
260                         // nothing to do
261                     } else if (merged == null) {
262                         merged = last;
263                     } else {
264                         MemoryPhiNode phi = merge.graph().addWithoutUnique(new MemoryPhiNode(merge, key));
265                         for (int j = 0; j &lt; mergedStatesCount; j++) {
266                             phi.addInput(ValueNodeUtil.asNode(merged));
267                         }
268                         phi.addInput(ValueNodeUtil.asNode(last));
269                         merged = phi;
270                         isPhi = true;
271                     }
272                 }
273                 mergedStatesCount++;
274             }
<span class="line-modified">275             newState.lastMemorySnapshot.put(key, merged);</span>
276         }
277         return newState;
278 
279     }
280 
281     private static boolean checkNoImmutableLocations(EconomicSet&lt;LocationIdentity&gt; keys) {
282         keys.forEach(t -&gt; {
283             assert t.isMutable();
284         });
285         return true;
286     }
287 
288     public static class FloatingReadClosure extends NodeIteratorClosure&lt;MemoryMapImpl&gt; {
289 
290         private final EconomicMap&lt;LoopBeginNode, EconomicSet&lt;LocationIdentity&gt;&gt; modifiedInLoops;
291         private boolean createFloatingReads;
292         private boolean createMemoryMapNodes;
293 
294         public FloatingReadClosure(EconomicMap&lt;LoopBeginNode, EconomicSet&lt;LocationIdentity&gt;&gt; modifiedInLoops, boolean createFloatingReads, boolean createMemoryMapNodes) {
295             this.modifiedInLoops = modifiedInLoops;
296             this.createFloatingReads = createFloatingReads;
297             this.createMemoryMapNodes = createMemoryMapNodes;
298         }
299 
300         @Override
301         protected MemoryMapImpl processNode(FixedNode node, MemoryMapImpl state) {










302             if (node instanceof MemoryAnchorNode) {
303                 processAnchor((MemoryAnchorNode) node, state);
304                 return state;
305             }
306 
307             if (node instanceof MemoryAccess) {
308                 processAccess((MemoryAccess) node, state);
309             }
310 
311             if (createFloatingReads &amp;&amp; node instanceof FloatableAccessNode) {
312                 processFloatable((FloatableAccessNode) node, state);
<span class="line-modified">313             } else if (node instanceof MemoryCheckpoint.Single) {</span>

314                 processCheckpoint((MemoryCheckpoint.Single) node, state);
315             } else if (node instanceof MemoryCheckpoint.Multi) {
316                 processCheckpoint((MemoryCheckpoint.Multi) node, state);
317             }
318             assert MemoryCheckpoint.TypeAssertion.correctType(node) : node;
319 
320             if (createMemoryMapNodes &amp;&amp; node instanceof ReturnNode) {
<span class="line-modified">321                 ((ReturnNode) node).setMemoryMap(node.graph().unique(new MemoryMapNode(state.lastMemorySnapshot)));</span>
322             }
323             return state;
324         }
325 
326         /**
327          * Improve the memory graph by re-wiring all usages of a {@link MemoryAnchorNode} to the
328          * real last access location.
329          */
330         private static void processAnchor(MemoryAnchorNode anchor, MemoryMapImpl state) {
331             for (Node node : anchor.usages().snapshot()) {
332                 if (node instanceof MemoryAccess) {
333                     MemoryAccess access = (MemoryAccess) node;
334                     if (access.getLastLocationAccess() == anchor) {
335                         MemoryNode lastLocationAccess = state.getLastLocationAccess(access.getLocationIdentity());
336                         assert lastLocationAccess != null;
337                         access.setLastLocationAccess(lastLocationAccess);
338                     }
339                 }
340             }
341 
342             if (anchor.hasNoUsages()) {
343                 anchor.graph().removeFixed(anchor);
344             }
345         }
346 
347         private static void processAccess(MemoryAccess access, MemoryMapImpl state) {
348             LocationIdentity locationIdentity = access.getLocationIdentity();
349             if (!locationIdentity.equals(LocationIdentity.any())) {
350                 MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);
351                 access.setLastLocationAccess(lastLocationAccess);
352             }
353         }
354 
355         private static void processCheckpoint(MemoryCheckpoint.Single checkpoint, MemoryMapImpl state) {
<span class="line-modified">356             processIdentity(checkpoint.getLocationIdentity(), checkpoint, state);</span>
357         }
358 
359         private static void processCheckpoint(MemoryCheckpoint.Multi checkpoint, MemoryMapImpl state) {
<span class="line-modified">360             for (LocationIdentity identity : checkpoint.getLocationIdentities()) {</span>
361                 processIdentity(identity, checkpoint, state);
362             }
363         }
364 
365         private static void processIdentity(LocationIdentity identity, MemoryCheckpoint checkpoint, MemoryMapImpl state) {
366             if (identity.isAny()) {
<span class="line-modified">367                 state.lastMemorySnapshot.clear();</span>
368             }
369             if (identity.isMutable()) {
<span class="line-modified">370                 state.lastMemorySnapshot.put(identity, checkpoint);</span>
371             }
372         }
373 
374         @SuppressWarnings(&quot;try&quot;)
375         private static void processFloatable(FloatableAccessNode accessNode, MemoryMapImpl state) {
376             StructuredGraph graph = accessNode.graph();
377             LocationIdentity locationIdentity = accessNode.getLocationIdentity();
378             if (accessNode.canFloat()) {
379                 assert accessNode.getNullCheck() == false;
380                 MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);
381                 try (DebugCloseable position = accessNode.withNodeSourcePosition()) {
<span class="line-modified">382                     FloatingAccessNode floatingNode = accessNode.asFloatingNode(lastLocationAccess);</span>

383                     graph.replaceFixedWithFloating(accessNode, floatingNode);
384                 }
385             }
386         }
387 
388         @Override
389         protected MemoryMapImpl merge(AbstractMergeNode merge, List&lt;MemoryMapImpl&gt; states) {
390             return mergeMemoryMaps(merge, states);
391         }
392 
393         @Override
394         protected MemoryMapImpl afterSplit(AbstractBeginNode node, MemoryMapImpl oldState) {
395             MemoryMapImpl result = new MemoryMapImpl(oldState);
396             if (node.predecessor() instanceof InvokeWithExceptionNode) {
397                 /*
398                  * InvokeWithException cannot be the lastLocationAccess for a FloatingReadNode.
399                  * Since it is both the invoke and a control flow split, the scheduler cannot
400                  * schedule anything immediately after the invoke. It can only schedule in the
401                  * normal or exceptional successor - and we have to tell the scheduler here which
402                  * side it needs to choose by putting in the location identity on both successors.
403                  */
404                 InvokeWithExceptionNode invoke = (InvokeWithExceptionNode) node.predecessor();
<span class="line-modified">405                 result.lastMemorySnapshot.put(invoke.getLocationIdentity(), (MemoryCheckpoint) node);</span>
406             }
407             return result;
408         }
409 
410         @Override
411         protected EconomicMap&lt;LoopExitNode, MemoryMapImpl&gt; processLoop(LoopBeginNode loop, MemoryMapImpl initialState) {
412             EconomicSet&lt;LocationIdentity&gt; modifiedLocations = modifiedInLoops.get(loop);
413             EconomicMap&lt;LocationIdentity, MemoryPhiNode&gt; phis = EconomicMap.create(Equivalence.DEFAULT);
414             if (modifiedLocations.contains(LocationIdentity.any())) {
415                 // create phis for all locations if ANY is modified in the loop
416                 modifiedLocations = EconomicSet.create(Equivalence.DEFAULT, modifiedLocations);
<span class="line-modified">417                 modifiedLocations.addAll(initialState.lastMemorySnapshot.getKeys());</span>
418             }
419 
420             for (LocationIdentity location : modifiedLocations) {
421                 createMemoryPhi(loop, initialState, phis, location);
422             }
<span class="line-modified">423             initialState.lastMemorySnapshot.putAll(phis);</span>
424 
425             LoopInfo&lt;MemoryMapImpl&gt; loopInfo = ReentrantNodeIterator.processLoop(this, loop, initialState);
426 
427             UnmodifiableMapCursor&lt;LoopEndNode, MemoryMapImpl&gt; endStateCursor = loopInfo.endStates.getEntries();
428             while (endStateCursor.advance()) {
429                 int endIndex = loop.phiPredecessorIndex(endStateCursor.getKey());
430                 UnmodifiableMapCursor&lt;LocationIdentity, MemoryPhiNode&gt; phiCursor = phis.getEntries();
431                 while (phiCursor.advance()) {
432                     LocationIdentity key = phiCursor.getKey();
433                     PhiNode phi = phiCursor.getValue();
434                     phi.initializeValueAt(endIndex, ValueNodeUtil.asNode(endStateCursor.getValue().getLastLocationAccess(key)));
435                 }
436             }
437             return loopInfo.exitStates;
438         }
439 
440         private static void createMemoryPhi(LoopBeginNode loop, MemoryMapImpl initialState, EconomicMap&lt;LocationIdentity, MemoryPhiNode&gt; phis, LocationIdentity location) {
441             MemoryPhiNode phi = loop.graph().addWithoutUnique(new MemoryPhiNode(loop, location));
442             phi.addInput(ValueNodeUtil.asNode(initialState.getLastLocationAccess(location)));
443             phis.put(location, phi);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 31 import java.util.EnumSet;
 32 import java.util.Iterator;
 33 import java.util.List;
 34 
 35 import jdk.internal.vm.compiler.collections.EconomicMap;
 36 import jdk.internal.vm.compiler.collections.EconomicSet;
 37 import jdk.internal.vm.compiler.collections.Equivalence;
 38 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
 39 import org.graalvm.compiler.core.common.cfg.Loop;
 40 import org.graalvm.compiler.debug.DebugCloseable;
 41 import org.graalvm.compiler.graph.Graph.NodeEventScope;
 42 import org.graalvm.compiler.graph.Node;
 43 import org.graalvm.compiler.nodes.AbstractBeginNode;
 44 import org.graalvm.compiler.nodes.AbstractMergeNode;
 45 import org.graalvm.compiler.nodes.FixedNode;
 46 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 47 import org.graalvm.compiler.nodes.LoopBeginNode;
 48 import org.graalvm.compiler.nodes.LoopEndNode;
 49 import org.graalvm.compiler.nodes.LoopExitNode;
 50 import org.graalvm.compiler.nodes.PhiNode;
<span class="line-added"> 51 import org.graalvm.compiler.nodes.ProxyNode;</span>
 52 import org.graalvm.compiler.nodes.ReturnNode;
 53 import org.graalvm.compiler.nodes.StartNode;
 54 import org.graalvm.compiler.nodes.StructuredGraph;
 55 import org.graalvm.compiler.nodes.ValueNodeUtil;
 56 import org.graalvm.compiler.nodes.calc.FloatingNode;
 57 import org.graalvm.compiler.nodes.cfg.Block;
 58 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 59 import org.graalvm.compiler.nodes.cfg.HIRLoop;
 60 import org.graalvm.compiler.nodes.memory.FloatableAccessNode;
 61 import org.graalvm.compiler.nodes.memory.FloatingAccessNode;
 62 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
 63 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 64 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
 65 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;
 66 import org.graalvm.compiler.nodes.memory.MemoryMap;
 67 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
 68 import org.graalvm.compiler.nodes.memory.MemoryNode;
 69 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
 70 import org.graalvm.compiler.nodes.memory.ReadNode;
 71 import org.graalvm.compiler.nodes.util.GraphUtil;
</pre>
<hr />
<pre>
150     private static EconomicSet&lt;Node&gt; removeExternallyUsedNodes(EconomicSet&lt;Node&gt; set) {
151         boolean change;
152         do {
153             change = false;
154             for (Iterator&lt;Node&gt; iter = set.iterator(); iter.hasNext();) {
155                 Node node = iter.next();
156                 for (Node usage : node.usages()) {
157                     if (!set.contains(usage)) {
158                         change = true;
159                         iter.remove();
160                         break;
161                     }
162                 }
163             }
164         } while (change);
165         return set;
166     }
167 
168     protected void processNode(FixedNode node, EconomicSet&lt;LocationIdentity&gt; currentState) {
169         if (node instanceof MemoryCheckpoint.Single) {
<span class="line-modified">170             processIdentity(currentState, ((MemoryCheckpoint.Single) node).getKilledLocationIdentity());</span>
171         } else if (node instanceof MemoryCheckpoint.Multi) {
<span class="line-modified">172             for (LocationIdentity identity : ((MemoryCheckpoint.Multi) node).getKilledLocationIdentities()) {</span>
173                 processIdentity(currentState, identity);
174             }
175         }
176     }
177 
178     private static void processIdentity(EconomicSet&lt;LocationIdentity&gt; currentState, LocationIdentity identity) {
179         if (identity.isMutable()) {
180             currentState.add(identity);
181         }
182     }
183 
184     protected void processBlock(Block b, EconomicSet&lt;LocationIdentity&gt; currentState) {
185         for (FixedNode n : b.getNodes()) {
186             processNode(n, currentState);
187         }
188     }
189 
190     private EconomicSet&lt;LocationIdentity&gt; processLoop(HIRLoop loop, EconomicMap&lt;LoopBeginNode, EconomicSet&lt;LocationIdentity&gt;&gt; modifiedInLoops) {
191         LoopBeginNode loopBegin = (LoopBeginNode) loop.getHeader().getBeginNode();
192         EconomicSet&lt;LocationIdentity&gt; result = modifiedInLoops.get(loopBegin);
</pre>
<hr />
<pre>
238             graph.setAfterFloatingReadPhase(true);
239         }
240     }
241 
242     public static MemoryMapImpl mergeMemoryMaps(AbstractMergeNode merge, List&lt;? extends MemoryMap&gt; states) {
243         MemoryMapImpl newState = new MemoryMapImpl();
244 
245         EconomicSet&lt;LocationIdentity&gt; keys = EconomicSet.create(Equivalence.DEFAULT);
246         for (MemoryMap other : states) {
247             keys.addAll(other.getLocations());
248         }
249         assert checkNoImmutableLocations(keys);
250 
251         for (LocationIdentity key : keys) {
252             int mergedStatesCount = 0;
253             boolean isPhi = false;
254             MemoryNode merged = null;
255             for (MemoryMap state : states) {
256                 MemoryNode last = state.getLastLocationAccess(key);
257                 if (isPhi) {
<span class="line-added">258                     // Fortify: Suppress Null Deference false positive (`isPhi == true` implies</span>
<span class="line-added">259                     // `merged != null`)</span>
260                     ((MemoryPhiNode) merged).addInput(ValueNodeUtil.asNode(last));
261                 } else {
262                     if (merged == last) {
263                         // nothing to do
264                     } else if (merged == null) {
265                         merged = last;
266                     } else {
267                         MemoryPhiNode phi = merge.graph().addWithoutUnique(new MemoryPhiNode(merge, key));
268                         for (int j = 0; j &lt; mergedStatesCount; j++) {
269                             phi.addInput(ValueNodeUtil.asNode(merged));
270                         }
271                         phi.addInput(ValueNodeUtil.asNode(last));
272                         merged = phi;
273                         isPhi = true;
274                     }
275                 }
276                 mergedStatesCount++;
277             }
<span class="line-modified">278             newState.getMap().put(key, merged);</span>
279         }
280         return newState;
281 
282     }
283 
284     private static boolean checkNoImmutableLocations(EconomicSet&lt;LocationIdentity&gt; keys) {
285         keys.forEach(t -&gt; {
286             assert t.isMutable();
287         });
288         return true;
289     }
290 
291     public static class FloatingReadClosure extends NodeIteratorClosure&lt;MemoryMapImpl&gt; {
292 
293         private final EconomicMap&lt;LoopBeginNode, EconomicSet&lt;LocationIdentity&gt;&gt; modifiedInLoops;
294         private boolean createFloatingReads;
295         private boolean createMemoryMapNodes;
296 
297         public FloatingReadClosure(EconomicMap&lt;LoopBeginNode, EconomicSet&lt;LocationIdentity&gt;&gt; modifiedInLoops, boolean createFloatingReads, boolean createMemoryMapNodes) {
298             this.modifiedInLoops = modifiedInLoops;
299             this.createFloatingReads = createFloatingReads;
300             this.createMemoryMapNodes = createMemoryMapNodes;
301         }
302 
303         @Override
304         protected MemoryMapImpl processNode(FixedNode node, MemoryMapImpl state) {
<span class="line-added">305 </span>
<span class="line-added">306             if (node instanceof LoopExitNode) {</span>
<span class="line-added">307                 final LoopExitNode loopExitNode = (LoopExitNode) node;</span>
<span class="line-added">308                 final EconomicSet&lt;LocationIdentity&gt; modifiedInLoop = modifiedInLoops.get(loopExitNode.loopBegin());</span>
<span class="line-added">309                 final boolean anyModified = modifiedInLoop.contains(LocationIdentity.any());</span>
<span class="line-added">310                 state.getMap().replaceAll((locationIdentity, memoryNode) -&gt; (anyModified || modifiedInLoop.contains(locationIdentity))</span>
<span class="line-added">311                                 ? ProxyNode.forMemory(memoryNode, loopExitNode, locationIdentity)</span>
<span class="line-added">312                                 : memoryNode);</span>
<span class="line-added">313             }</span>
<span class="line-added">314 </span>
315             if (node instanceof MemoryAnchorNode) {
316                 processAnchor((MemoryAnchorNode) node, state);
317                 return state;
318             }
319 
320             if (node instanceof MemoryAccess) {
321                 processAccess((MemoryAccess) node, state);
322             }
323 
324             if (createFloatingReads &amp;&amp; node instanceof FloatableAccessNode) {
325                 processFloatable((FloatableAccessNode) node, state);
<span class="line-modified">326             }</span>
<span class="line-added">327             if (node instanceof MemoryCheckpoint.Single) {</span>
328                 processCheckpoint((MemoryCheckpoint.Single) node, state);
329             } else if (node instanceof MemoryCheckpoint.Multi) {
330                 processCheckpoint((MemoryCheckpoint.Multi) node, state);
331             }
332             assert MemoryCheckpoint.TypeAssertion.correctType(node) : node;
333 
334             if (createMemoryMapNodes &amp;&amp; node instanceof ReturnNode) {
<span class="line-modified">335                 ((ReturnNode) node).setMemoryMap(node.graph().unique(new MemoryMapNode(state.getMap())));</span>
336             }
337             return state;
338         }
339 
340         /**
341          * Improve the memory graph by re-wiring all usages of a {@link MemoryAnchorNode} to the
342          * real last access location.
343          */
344         private static void processAnchor(MemoryAnchorNode anchor, MemoryMapImpl state) {
345             for (Node node : anchor.usages().snapshot()) {
346                 if (node instanceof MemoryAccess) {
347                     MemoryAccess access = (MemoryAccess) node;
348                     if (access.getLastLocationAccess() == anchor) {
349                         MemoryNode lastLocationAccess = state.getLastLocationAccess(access.getLocationIdentity());
350                         assert lastLocationAccess != null;
351                         access.setLastLocationAccess(lastLocationAccess);
352                     }
353                 }
354             }
355 
356             if (anchor.hasNoUsages()) {
357                 anchor.graph().removeFixed(anchor);
358             }
359         }
360 
361         private static void processAccess(MemoryAccess access, MemoryMapImpl state) {
362             LocationIdentity locationIdentity = access.getLocationIdentity();
363             if (!locationIdentity.equals(LocationIdentity.any())) {
364                 MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);
365                 access.setLastLocationAccess(lastLocationAccess);
366             }
367         }
368 
369         private static void processCheckpoint(MemoryCheckpoint.Single checkpoint, MemoryMapImpl state) {
<span class="line-modified">370             processIdentity(checkpoint.getKilledLocationIdentity(), checkpoint, state);</span>
371         }
372 
373         private static void processCheckpoint(MemoryCheckpoint.Multi checkpoint, MemoryMapImpl state) {
<span class="line-modified">374             for (LocationIdentity identity : checkpoint.getKilledLocationIdentities()) {</span>
375                 processIdentity(identity, checkpoint, state);
376             }
377         }
378 
379         private static void processIdentity(LocationIdentity identity, MemoryCheckpoint checkpoint, MemoryMapImpl state) {
380             if (identity.isAny()) {
<span class="line-modified">381                 state.getMap().clear();</span>
382             }
383             if (identity.isMutable()) {
<span class="line-modified">384                 state.getMap().put(identity, checkpoint);</span>
385             }
386         }
387 
388         @SuppressWarnings(&quot;try&quot;)
389         private static void processFloatable(FloatableAccessNode accessNode, MemoryMapImpl state) {
390             StructuredGraph graph = accessNode.graph();
391             LocationIdentity locationIdentity = accessNode.getLocationIdentity();
392             if (accessNode.canFloat()) {
393                 assert accessNode.getNullCheck() == false;
394                 MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);
395                 try (DebugCloseable position = accessNode.withNodeSourcePosition()) {
<span class="line-modified">396                     FloatingAccessNode floatingNode = accessNode.asFloatingNode();</span>
<span class="line-added">397                     assert floatingNode.getLastLocationAccess() == lastLocationAccess;</span>
398                     graph.replaceFixedWithFloating(accessNode, floatingNode);
399                 }
400             }
401         }
402 
403         @Override
404         protected MemoryMapImpl merge(AbstractMergeNode merge, List&lt;MemoryMapImpl&gt; states) {
405             return mergeMemoryMaps(merge, states);
406         }
407 
408         @Override
409         protected MemoryMapImpl afterSplit(AbstractBeginNode node, MemoryMapImpl oldState) {
410             MemoryMapImpl result = new MemoryMapImpl(oldState);
411             if (node.predecessor() instanceof InvokeWithExceptionNode) {
412                 /*
413                  * InvokeWithException cannot be the lastLocationAccess for a FloatingReadNode.
414                  * Since it is both the invoke and a control flow split, the scheduler cannot
415                  * schedule anything immediately after the invoke. It can only schedule in the
416                  * normal or exceptional successor - and we have to tell the scheduler here which
417                  * side it needs to choose by putting in the location identity on both successors.
418                  */
419                 InvokeWithExceptionNode invoke = (InvokeWithExceptionNode) node.predecessor();
<span class="line-modified">420                 result.getMap().put(invoke.getKilledLocationIdentity(), (MemoryCheckpoint) node);</span>
421             }
422             return result;
423         }
424 
425         @Override
426         protected EconomicMap&lt;LoopExitNode, MemoryMapImpl&gt; processLoop(LoopBeginNode loop, MemoryMapImpl initialState) {
427             EconomicSet&lt;LocationIdentity&gt; modifiedLocations = modifiedInLoops.get(loop);
428             EconomicMap&lt;LocationIdentity, MemoryPhiNode&gt; phis = EconomicMap.create(Equivalence.DEFAULT);
429             if (modifiedLocations.contains(LocationIdentity.any())) {
430                 // create phis for all locations if ANY is modified in the loop
431                 modifiedLocations = EconomicSet.create(Equivalence.DEFAULT, modifiedLocations);
<span class="line-modified">432                 modifiedLocations.addAll(initialState.getMap().getKeys());</span>
433             }
434 
435             for (LocationIdentity location : modifiedLocations) {
436                 createMemoryPhi(loop, initialState, phis, location);
437             }
<span class="line-modified">438             initialState.getMap().putAll(phis);</span>
439 
440             LoopInfo&lt;MemoryMapImpl&gt; loopInfo = ReentrantNodeIterator.processLoop(this, loop, initialState);
441 
442             UnmodifiableMapCursor&lt;LoopEndNode, MemoryMapImpl&gt; endStateCursor = loopInfo.endStates.getEntries();
443             while (endStateCursor.advance()) {
444                 int endIndex = loop.phiPredecessorIndex(endStateCursor.getKey());
445                 UnmodifiableMapCursor&lt;LocationIdentity, MemoryPhiNode&gt; phiCursor = phis.getEntries();
446                 while (phiCursor.advance()) {
447                     LocationIdentity key = phiCursor.getKey();
448                     PhiNode phi = phiCursor.getValue();
449                     phi.initializeValueAt(endIndex, ValueNodeUtil.asNode(endStateCursor.getValue().getLastLocationAccess(key)));
450                 }
451             }
452             return loopInfo.exitStates;
453         }
454 
455         private static void createMemoryPhi(LoopBeginNode loop, MemoryMapImpl initialState, EconomicMap&lt;LocationIdentity, MemoryPhiNode&gt; phis, LocationIdentity location) {
456             MemoryPhiNode phi = loop.graph().addWithoutUnique(new MemoryPhiNode(loop, location));
457             phi.addInput(ValueNodeUtil.asNode(initialState.getLastLocationAccess(location)));
458             phis.put(location, phi);
</pre>
</td>
</tr>
</table>
<center><a href="FixReadsPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="FrameStateAssignmentPhase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/CanonicalizerPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AddressLoweringByUsePhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConditionalEliminationPhase.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/CanonicalizerPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,10 ***</span>
<span class="line-new-header">--- 22,16 ---</span>
   */
  
  
  package org.graalvm.compiler.phases.common;
  
<span class="line-added">+ import static org.graalvm.compiler.phases.common.CanonicalizerPhase.CanonicalizerFeature.CFG_SIMPLIFICATION;</span>
<span class="line-added">+ import static org.graalvm.compiler.phases.common.CanonicalizerPhase.CanonicalizerFeature.GVN;</span>
<span class="line-added">+ import static org.graalvm.compiler.phases.common.CanonicalizerPhase.CanonicalizerFeature.READ_CANONICALIZATION;</span>
<span class="line-added">+ </span>
<span class="line-added">+ import java.util.EnumSet;</span>
<span class="line-added">+ </span>
  import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
  import org.graalvm.compiler.core.common.type.Stamp;
  import org.graalvm.compiler.debug.CounterKey;
  import org.graalvm.compiler.debug.DebugCloseable;
  import org.graalvm.compiler.debug.DebugContext;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,76 ***</span>
  import org.graalvm.compiler.graph.NodeWorkList;
  import org.graalvm.compiler.graph.spi.Canonicalizable;
  import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;
  import org.graalvm.compiler.graph.spi.SimplifierTool;
  import org.graalvm.compiler.nodeinfo.InputType;
  import org.graalvm.compiler.nodes.AbstractMergeNode;
  import org.graalvm.compiler.nodes.ConstantNode;
  import org.graalvm.compiler.nodes.ControlSinkNode;
  import org.graalvm.compiler.nodes.FixedNode;
  import org.graalvm.compiler.nodes.FixedWithNextNode;
  import org.graalvm.compiler.nodes.NodeView;
  import org.graalvm.compiler.nodes.StartNode;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.calc.FloatingNode;
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.BasePhase;
  import org.graalvm.compiler.phases.Phase;
<span class="line-removed">- import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
  
  import jdk.vm.ci.meta.Assumptions;
  import jdk.vm.ci.meta.Constant;
  import jdk.vm.ci.meta.ConstantReflectionProvider;
  import jdk.vm.ci.meta.MetaAccessProvider;
  
<span class="line-modified">! public class CanonicalizerPhase extends BasePhase&lt;PhaseContext&gt; {</span>
  
      private static final int MAX_ITERATION_PER_NODE = 10;
      private static final CounterKey COUNTER_CANONICALIZED_NODES = DebugContext.counter(&quot;CanonicalizedNodes&quot;);
      private static final CounterKey COUNTER_PROCESSED_NODES = DebugContext.counter(&quot;ProcessedNodes&quot;);
      private static final CounterKey COUNTER_CANONICALIZATION_CONSIDERED_NODES = DebugContext.counter(&quot;CanonicalizationConsideredNodes&quot;);
      private static final CounterKey COUNTER_INFER_STAMP_CALLED = DebugContext.counter(&quot;InferStampCalled&quot;);
      private static final CounterKey COUNTER_STAMP_CHANGED = DebugContext.counter(&quot;StampChanged&quot;);
      private static final CounterKey COUNTER_SIMPLIFICATION_CONSIDERED_NODES = DebugContext.counter(&quot;SimplificationConsideredNodes&quot;);
      private static final CounterKey COUNTER_GLOBAL_VALUE_NUMBERING_HITS = DebugContext.counter(&quot;GlobalValueNumberingHits&quot;);
  
<span class="line-modified">!     private boolean globalValueNumber = true;</span>
<span class="line-modified">!     private boolean canonicalizeReads = true;</span>
<span class="line-modified">!     private boolean simplify = true;</span>
<span class="line-removed">-     private final CustomCanonicalizer customCanonicalizer;</span>
  
<span class="line-modified">!     public abstract static class CustomCanonicalizer {</span>
  
<span class="line-modified">!         public Node canonicalize(Node node) {</span>
<span class="line-modified">!             return node;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-modified">!         public void simplify(Node node, SimplifierTool tool) {</span>
<span class="line-modified">!         }</span>
      }
  
<span class="line-modified">!     public CanonicalizerPhase() {</span>
<span class="line-modified">!         this(null);</span>
      }
  
<span class="line-modified">!     public CanonicalizerPhase(CustomCanonicalizer customCanonicalizer) {</span>
<span class="line-modified">!         this.customCanonicalizer = customCanonicalizer;</span>
      }
  
<span class="line-modified">!     public void disableGVN() {</span>
<span class="line-modified">!         globalValueNumber = false;</span>
      }
  
<span class="line-modified">!     public void disableReadCanonicalization() {</span>
<span class="line-modified">!         canonicalizeReads = false;</span>
      }
  
<span class="line-modified">!     public void disableSimplification() {</span>
<span class="line-modified">!         simplify = false;</span>
      }
  
      @Override
      public boolean checkContract() {
          /*
<span class="line-new-header">--- 46,122 ---</span>
  import org.graalvm.compiler.graph.NodeWorkList;
  import org.graalvm.compiler.graph.spi.Canonicalizable;
  import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;
  import org.graalvm.compiler.graph.spi.SimplifierTool;
  import org.graalvm.compiler.nodeinfo.InputType;
<span class="line-added">+ import org.graalvm.compiler.nodes.AbstractBeginNode;</span>
  import org.graalvm.compiler.nodes.AbstractMergeNode;
  import org.graalvm.compiler.nodes.ConstantNode;
  import org.graalvm.compiler.nodes.ControlSinkNode;
  import org.graalvm.compiler.nodes.FixedNode;
  import org.graalvm.compiler.nodes.FixedWithNextNode;
  import org.graalvm.compiler.nodes.NodeView;
  import org.graalvm.compiler.nodes.StartNode;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.calc.FloatingNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.BasePhase;
  import org.graalvm.compiler.phases.Phase;
  
  import jdk.vm.ci.meta.Assumptions;
  import jdk.vm.ci.meta.Constant;
  import jdk.vm.ci.meta.ConstantReflectionProvider;
  import jdk.vm.ci.meta.MetaAccessProvider;
  
<span class="line-modified">! public class CanonicalizerPhase extends BasePhase&lt;CoreProviders&gt; {</span>
<span class="line-added">+ </span>
<span class="line-added">+     public enum CanonicalizerFeature {</span>
<span class="line-added">+         READ_CANONICALIZATION,</span>
<span class="line-added">+         CFG_SIMPLIFICATION,</span>
<span class="line-added">+         GVN</span>
<span class="line-added">+     }</span>
  
      private static final int MAX_ITERATION_PER_NODE = 10;
      private static final CounterKey COUNTER_CANONICALIZED_NODES = DebugContext.counter(&quot;CanonicalizedNodes&quot;);
      private static final CounterKey COUNTER_PROCESSED_NODES = DebugContext.counter(&quot;ProcessedNodes&quot;);
      private static final CounterKey COUNTER_CANONICALIZATION_CONSIDERED_NODES = DebugContext.counter(&quot;CanonicalizationConsideredNodes&quot;);
      private static final CounterKey COUNTER_INFER_STAMP_CALLED = DebugContext.counter(&quot;InferStampCalled&quot;);
      private static final CounterKey COUNTER_STAMP_CHANGED = DebugContext.counter(&quot;StampChanged&quot;);
      private static final CounterKey COUNTER_SIMPLIFICATION_CONSIDERED_NODES = DebugContext.counter(&quot;SimplificationConsideredNodes&quot;);
      private static final CounterKey COUNTER_GLOBAL_VALUE_NUMBERING_HITS = DebugContext.counter(&quot;GlobalValueNumberingHits&quot;);
  
<span class="line-modified">!     private final EnumSet&lt;CanonicalizerFeature&gt; features;</span>
<span class="line-modified">!     private final CustomCanonicalization customCanonicalization;</span>
<span class="line-modified">!     private final CustomSimplification customSimplification;</span>
  
<span class="line-modified">!     public interface CustomCanonicalization {</span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * @param node the node to be canonicalized</span>
<span class="line-added">+          * @return the same node if no action should be taken, {@code null} if the node should be</span>
<span class="line-added">+          *         deleted, or a new node that should replace the given node</span>
<span class="line-added">+          */</span>
<span class="line-added">+         Node canonicalize(Node node);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     public interface CustomSimplification {</span>
<span class="line-modified">!         /**</span>
<span class="line-modified">!          * @param node the node to be simplified</span>
<span class="line-added">+          * @param tool utility available during the simplification process</span>
<span class="line-added">+          */</span>
<span class="line-added">+         void simplify(Node node, SimplifierTool tool);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     protected CanonicalizerPhase(EnumSet&lt;CanonicalizerFeature&gt; features) {</span>
<span class="line-modified">!         this(null, null, features);</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     protected CanonicalizerPhase() {</span>
<span class="line-added">+         this(null, null, EnumSet.allOf(CanonicalizerFeature.class));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     protected CanonicalizerPhase(CustomCanonicalization customCanonicalization, CustomSimplification customSimplification) {</span>
<span class="line-added">+         this(customCanonicalization, customSimplification, EnumSet.allOf(CanonicalizerFeature.class));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     protected CanonicalizerPhase(CustomCanonicalization customCanonicalization, CustomSimplification customSimplification, EnumSet&lt;CanonicalizerFeature&gt; features) {</span>
<span class="line-added">+         this.customCanonicalization = customCanonicalization;</span>
<span class="line-added">+         this.customSimplification = customSimplification;</span>
<span class="line-added">+         this.features = features;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public CanonicalizerPhase copyWithCustomCanonicalization(CustomCanonicalization newCanonicalization) {</span>
<span class="line-added">+         return new CanonicalizerPhase(newCanonicalization, customSimplification, features);</span>
      }
  
<span class="line-modified">!     public CanonicalizerPhase copyWithCustomSimplification(CustomSimplification newSimplification) {</span>
<span class="line-modified">!         return new CanonicalizerPhase(customCanonicalization, newSimplification, features);</span>
      }
  
<span class="line-modified">!     public CanonicalizerPhase copyWithoutGVN() {</span>
<span class="line-modified">!         EnumSet&lt;CanonicalizerFeature&gt; newFeatures = EnumSet.copyOf(features);</span>
<span class="line-added">+         newFeatures.remove(GVN);</span>
<span class="line-added">+         return new CanonicalizerPhase(customCanonicalization, customSimplification, newFeatures);</span>
      }
  
<span class="line-modified">!     public CanonicalizerPhase copyWithoutSimplification() {</span>
<span class="line-modified">!         EnumSet&lt;CanonicalizerFeature&gt; newFeatures = EnumSet.copyOf(features);</span>
<span class="line-added">+         newFeatures.remove(CFG_SIMPLIFICATION);</span>
<span class="line-added">+         return new CanonicalizerPhase(customCanonicalization, customSimplification, newFeatures);</span>
      }
  
<span class="line-modified">!     public static CanonicalizerPhase create() {</span>
<span class="line-modified">!         return new CanonicalizerPhase(null, null, EnumSet.allOf(CanonicalizerFeature.class));</span>
      }
  
<span class="line-modified">!     public static CanonicalizerPhase createWithoutReadCanonicalization() {</span>
<span class="line-modified">!         return new CanonicalizerPhase(EnumSet.complementOf(EnumSet.of(READ_CANONICALIZATION)));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public static CanonicalizerPhase createWithoutGVN() {</span>
<span class="line-added">+         return new CanonicalizerPhase(EnumSet.complementOf(EnumSet.of(GVN)));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public static CanonicalizerPhase createWithoutCFGSimplification() {</span>
<span class="line-added">+         return new CanonicalizerPhase(EnumSet.complementOf(EnumSet.of(CFG_SIMPLIFICATION)));</span>
      }
  
      @Override
      public boolean checkContract() {
          /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,73 ***</span>
           */
          return false;
      }
  
      @Override
<span class="line-modified">!     protected void run(StructuredGraph graph, PhaseContext context) {</span>
          new Instance(context).run(graph);
      }
  
      /**
       * @param newNodesMark only the {@linkplain Graph#getNewNodes(Mark) new nodes} specified by this
       *            mark are processed
       */
<span class="line-modified">!     public void applyIncremental(StructuredGraph graph, PhaseContext context, Mark newNodesMark) {</span>
          applyIncremental(graph, context, newNodesMark, true);
      }
  
<span class="line-modified">!     public void applyIncremental(StructuredGraph graph, PhaseContext context, Mark newNodesMark, boolean dumpGraph) {</span>
          new Instance(context, newNodesMark).apply(graph, dumpGraph);
      }
  
      /**
       * @param workingSet the initial working set of nodes on which the canonicalizer works, should
       *            be an auto-grow node bitmap
       */
<span class="line-modified">!     public void applyIncremental(StructuredGraph graph, PhaseContext context, Iterable&lt;? extends Node&gt; workingSet) {</span>
          applyIncremental(graph, context, workingSet, true);
      }
  
<span class="line-modified">!     public void applyIncremental(StructuredGraph graph, PhaseContext context, Iterable&lt;? extends Node&gt; workingSet, boolean dumpGraph) {</span>
          new Instance(context, workingSet).apply(graph, dumpGraph);
      }
  
<span class="line-modified">!     public void applyIncremental(StructuredGraph graph, PhaseContext context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark) {</span>
          applyIncremental(graph, context, workingSet, newNodesMark, true);
      }
  
<span class="line-modified">!     public void applyIncremental(StructuredGraph graph, PhaseContext context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark, boolean dumpGraph) {</span>
          new Instance(context, workingSet, newNodesMark).apply(graph, dumpGraph);
      }
  
      public NodeView getNodeView() {
          return NodeView.DEFAULT;
      }
  
      private final class Instance extends Phase {
  
          private final Mark newNodesMark;
<span class="line-modified">!         private final PhaseContext context;</span>
          private final Iterable&lt;? extends Node&gt; initWorkingSet;
  
          private NodeWorkList workList;
          private Tool tool;
          private DebugContext debug;
  
<span class="line-modified">!         private Instance(PhaseContext context) {</span>
              this(context, null, null);
          }
  
<span class="line-modified">!         private Instance(PhaseContext context, Iterable&lt;? extends Node&gt; workingSet) {</span>
              this(context, workingSet, null);
          }
  
<span class="line-modified">!         private Instance(PhaseContext context, Mark newNodesMark) {</span>
              this(context, null, newNodesMark);
          }
  
<span class="line-modified">!         private Instance(PhaseContext context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark) {</span>
              this.newNodesMark = newNodesMark;
              this.context = context;
              this.initWorkingSet = workingSet;
          }
  
<span class="line-new-header">--- 171,73 ---</span>
           */
          return false;
      }
  
      @Override
<span class="line-modified">!     protected void run(StructuredGraph graph, CoreProviders context) {</span>
          new Instance(context).run(graph);
      }
  
      /**
       * @param newNodesMark only the {@linkplain Graph#getNewNodes(Mark) new nodes} specified by this
       *            mark are processed
       */
<span class="line-modified">!     public void applyIncremental(StructuredGraph graph, CoreProviders context, Mark newNodesMark) {</span>
          applyIncremental(graph, context, newNodesMark, true);
      }
  
<span class="line-modified">!     public void applyIncremental(StructuredGraph graph, CoreProviders context, Mark newNodesMark, boolean dumpGraph) {</span>
          new Instance(context, newNodesMark).apply(graph, dumpGraph);
      }
  
      /**
       * @param workingSet the initial working set of nodes on which the canonicalizer works, should
       *            be an auto-grow node bitmap
       */
<span class="line-modified">!     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet) {</span>
          applyIncremental(graph, context, workingSet, true);
      }
  
<span class="line-modified">!     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, boolean dumpGraph) {</span>
          new Instance(context, workingSet).apply(graph, dumpGraph);
      }
  
<span class="line-modified">!     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark) {</span>
          applyIncremental(graph, context, workingSet, newNodesMark, true);
      }
  
<span class="line-modified">!     public void applyIncremental(StructuredGraph graph, CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark, boolean dumpGraph) {</span>
          new Instance(context, workingSet, newNodesMark).apply(graph, dumpGraph);
      }
  
      public NodeView getNodeView() {
          return NodeView.DEFAULT;
      }
  
      private final class Instance extends Phase {
  
          private final Mark newNodesMark;
<span class="line-modified">!         private final CoreProviders context;</span>
          private final Iterable&lt;? extends Node&gt; initWorkingSet;
  
          private NodeWorkList workList;
          private Tool tool;
          private DebugContext debug;
  
<span class="line-modified">!         private Instance(CoreProviders context) {</span>
              this(context, null, null);
          }
  
<span class="line-modified">!         private Instance(CoreProviders context, Iterable&lt;? extends Node&gt; workingSet) {</span>
              this(context, workingSet, null);
          }
  
<span class="line-modified">!         private Instance(CoreProviders context, Mark newNodesMark) {</span>
              this(context, null, newNodesMark);
          }
  
<span class="line-modified">!         private Instance(CoreProviders context, Iterable&lt;? extends Node&gt; workingSet, Mark newNodesMark) {</span>
              this.newNodesMark = newNodesMark;
              this.context = context;
              this.initWorkingSet = workingSet;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,16 ***</span>
                  workList.addAll(initWorkingSet);
              }
              if (!wholeGraph) {
                  workList.addAll(graph.getNewNodes(newNodesMark));
              }
              tool = new Tool(graph.getAssumptions(), graph.getOptions());
              processWorkSet(graph);
          }
  
          @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!         private void processWorkSet(StructuredGraph graph) {</span>
              NodeEventListener listener = new NodeEventListener() {
  
                  @Override
                  public void nodeAdded(Node node) {
                      workList.add(node);
<span class="line-new-header">--- 257,18 ---</span>
                  workList.addAll(initWorkingSet);
              }
              if (!wholeGraph) {
                  workList.addAll(graph.getNewNodes(newNodesMark));
              }
<span class="line-added">+ </span>
              tool = new Tool(graph.getAssumptions(), graph.getOptions());
              processWorkSet(graph);
          }
  
          @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!         private int processWorkSet(StructuredGraph graph) {</span>
<span class="line-added">+             int sum = 0;</span>
              NodeEventListener listener = new NodeEventListener() {
  
                  @Override
                  public void nodeAdded(Node node) {
                      workList.add(node);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 226,10 ***</span>
<span class="line-new-header">--- 280,17 ---</span>
                      if (node instanceof IndirectCanonicalization) {
                          for (Node usage : node.usages()) {
                              workList.add(usage);
                          }
                      }
<span class="line-added">+ </span>
<span class="line-added">+                     if (node instanceof AbstractBeginNode) {</span>
<span class="line-added">+                         AbstractBeginNode abstractBeginNode = (AbstractBeginNode) node;</span>
<span class="line-added">+                         if (abstractBeginNode.predecessor() != null) {</span>
<span class="line-added">+                             workList.add(abstractBeginNode.predecessor());</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
                  }
  
                  @Override
                  public void usagesDroppedToZero(Node node) {
                      workList.add(node);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 240,12 ***</span>
<span class="line-new-header">--- 301,14 ---</span>
                  for (Node n : workList) {
                      boolean changed = processNode(n);
                      if (changed &amp;&amp; debug.isDumpEnabled(DebugContext.DETAILED_LEVEL)) {
                          debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;CanonicalizerPhase %s&quot;, n);
                      }
<span class="line-added">+                     ++sum;</span>
                  }
              }
<span class="line-added">+             return sum;</span>
          }
  
          /**
           * @return true if the graph was changed.
           */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 260,11 ***</span>
              NodeClass&lt;?&gt; nodeClass = node.getNodeClass();
              StructuredGraph graph = (StructuredGraph) node.graph();
              if (tryCanonicalize(node, nodeClass)) {
                  return true;
              }
<span class="line-modified">!             if (globalValueNumber &amp;&amp; tryGlobalValueNumbering(node, nodeClass)) {</span>
                  return true;
              }
              if (node instanceof ValueNode) {
                  ValueNode valueNode = (ValueNode) node;
                  boolean improvedStamp = tryInferStamp(valueNode);
<span class="line-new-header">--- 323,11 ---</span>
              NodeClass&lt;?&gt; nodeClass = node.getNodeClass();
              StructuredGraph graph = (StructuredGraph) node.graph();
              if (tryCanonicalize(node, nodeClass)) {
                  return true;
              }
<span class="line-modified">!             if (features.contains(GVN) &amp;&amp; tryGlobalValueNumbering(node, nodeClass)) {</span>
                  return true;
              }
              if (node instanceof ValueNode) {
                  ValueNode valueNode = (ValueNode) node;
                  boolean improvedStamp = tryInferStamp(valueNode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 315,43 ***</span>
          }
  
          @SuppressWarnings(&quot;try&quot;)
          public boolean tryCanonicalize(final Node node, NodeClass&lt;?&gt; nodeClass) {
              try (DebugCloseable position = node.withNodeSourcePosition(); DebugContext.Scope scope = debug.withContext(node)) {
<span class="line-removed">-                 if (customCanonicalizer != null) {</span>
<span class="line-removed">-                     Node canonical = customCanonicalizer.canonicalize(node);</span>
<span class="line-removed">-                     if (performReplacement(node, canonical)) {</span>
<span class="line-removed">-                         return true;</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         customCanonicalizer.simplify(node, tool);</span>
<span class="line-removed">-                         if (node.isDeleted()) {</span>
<span class="line-removed">-                             return true;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
                  if (nodeClass.isCanonicalizable()) {
                      COUNTER_CANONICALIZATION_CONSIDERED_NODES.increment(debug);
<span class="line-modified">!                     Node canonical;</span>
                      try (AutoCloseable verify = getCanonicalizeableContractAssertion(node)) {
<span class="line-modified">!                         canonical = ((Canonicalizable) node).canonical(tool);</span>
<span class="line-modified">!                         if (canonical == node &amp;&amp; nodeClass.isCommutative()) {</span>
<span class="line-modified">!                             canonical = ((BinaryCommutative&lt;?&gt;) node).maybeCommuteInputs();</span>
                          }
                      } catch (Throwable e) {
                          throw new GraalGraphError(e).addContext(node);
                      }
                      if (performReplacement(node, canonical)) {
                          return true;
                      }
                  }
  
<span class="line-modified">!                 if (nodeClass.isSimplifiable() &amp;&amp; simplify) {</span>
                      debug.log(DebugContext.VERBOSE_LEVEL, &quot;Canonicalizer: simplifying %s&quot;, node);
                      COUNTER_SIMPLIFICATION_CONSIDERED_NODES.increment(debug);
<span class="line-modified">!                     node.simplify(tool);</span>
<span class="line-modified">!                     if (node.isDeleted()) {</span>
<span class="line-modified">!                         debug.log(&quot;Canonicalizer: simplified %s&quot;, node);</span>
                      }
                      return node.isDeleted();
                  }
                  return false;
              } catch (Throwable throwable) {
<span class="line-new-header">--- 378,42 ---</span>
          }
  
          @SuppressWarnings(&quot;try&quot;)
          public boolean tryCanonicalize(final Node node, NodeClass&lt;?&gt; nodeClass) {
              try (DebugCloseable position = node.withNodeSourcePosition(); DebugContext.Scope scope = debug.withContext(node)) {
                  if (nodeClass.isCanonicalizable()) {
                      COUNTER_CANONICALIZATION_CONSIDERED_NODES.increment(debug);
<span class="line-modified">!                     Node canonical = node;</span>
                      try (AutoCloseable verify = getCanonicalizeableContractAssertion(node)) {
<span class="line-modified">!                         if (customCanonicalization != null) {</span>
<span class="line-modified">!                             canonical = customCanonicalization.canonicalize(node);</span>
<span class="line-modified">!                         }</span>
<span class="line-added">+                         if (canonical == node) {</span>
<span class="line-added">+                             canonical = ((Canonicalizable) node).canonical(tool);</span>
<span class="line-added">+                             if (canonical == node &amp;&amp; nodeClass.isCommutative()) {</span>
<span class="line-added">+                                 canonical = ((BinaryCommutative&lt;?&gt;) node).maybeCommuteInputs();</span>
<span class="line-added">+                             }</span>
                          }
                      } catch (Throwable e) {
                          throw new GraalGraphError(e).addContext(node);
                      }
                      if (performReplacement(node, canonical)) {
                          return true;
                      }
                  }
  
<span class="line-modified">!                 if (features.contains(CFG_SIMPLIFICATION) &amp;&amp; nodeClass.isSimplifiable()) {</span>
                      debug.log(DebugContext.VERBOSE_LEVEL, &quot;Canonicalizer: simplifying %s&quot;, node);
                      COUNTER_SIMPLIFICATION_CONSIDERED_NODES.increment(debug);
<span class="line-modified">!                     if (customSimplification != null) {</span>
<span class="line-modified">!                         customSimplification.simplify(node, tool);</span>
<span class="line-modified">!                     }</span>
<span class="line-added">+                     if (node.isAlive()) {</span>
<span class="line-added">+                         node.simplify(tool);</span>
<span class="line-added">+                         if (node.isDeleted()) {</span>
<span class="line-added">+                             debug.log(&quot;Canonicalizer: simplified %s&quot;, node);</span>
<span class="line-added">+                         }</span>
                      }
                      return node.isDeleted();
                  }
                  return false;
              } catch (Throwable throwable) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 504,11 ***</span>
                  GraphUtil.tryKillUnused(node);
              }
  
              @Override
              public boolean canonicalizeReads() {
<span class="line-modified">!                 return canonicalizeReads;</span>
              }
  
              @Override
              public boolean allUsagesAvailable() {
                  return true;
<span class="line-new-header">--- 566,11 ---</span>
                  GraphUtil.tryKillUnused(node);
              }
  
              @Override
              public boolean canonicalizeReads() {
<span class="line-modified">!                 return features.contains(READ_CANONICALIZATION);</span>
              }
  
              @Override
              public boolean allUsagesAvailable() {
                  return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 535,9 ***</span>
              }
          }
      }
  
      public boolean getCanonicalizeReads() {
<span class="line-modified">!         return canonicalizeReads;</span>
      }
  
  }
<span class="line-new-header">--- 597,9 ---</span>
              }
          }
      }
  
      public boolean getCanonicalizeReads() {
<span class="line-modified">!         return features.contains(READ_CANONICALIZATION);</span>
      }
  
  }
</pre>
<center><a href="AddressLoweringByUsePhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConditionalEliminationPhase.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/DeoptimizationGroupingPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ConditionalEliminationPhase.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ExpandLogicPhase.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/DeoptimizationGroupingPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22,21 +22,21 @@</span>
   */
  
  
  package org.graalvm.compiler.phases.common;
  
<span class="udiff-line-added">+ import java.util.Iterator;</span>
  import java.util.LinkedList;
  import java.util.List;
  
  import org.graalvm.compiler.core.common.cfg.Loop;
  import org.graalvm.compiler.core.common.type.StampFactory;
  import org.graalvm.compiler.debug.DebugCloseable;
  import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
  import org.graalvm.compiler.nodes.AbstractMergeNode;
  import org.graalvm.compiler.nodes.DynamicDeoptimizeNode;
  import org.graalvm.compiler.nodes.EndNode;
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.FixedNode;</span>
  import org.graalvm.compiler.nodes.FrameState;
  import org.graalvm.compiler.nodes.LoopBeginNode;
  import org.graalvm.compiler.nodes.LoopExitNode;
  import org.graalvm.compiler.nodes.MergeNode;
  import org.graalvm.compiler.nodes.PhiNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -57,58 +57,57 @@</span>
      @Override
      @SuppressWarnings(&quot;try&quot;)
      protected void run(StructuredGraph graph, MidTierContext context) {
          ControlFlowGraph cfg = null;
          for (FrameState fs : graph.getNodes(FrameState.TYPE)) {
<span class="udiff-line-modified-removed">-             FixedNode target = null;</span>
<span class="udiff-line-modified-removed">-             PhiNode reasonActionPhi = null;</span>
<span class="udiff-line-modified-removed">-             PhiNode speculationPhi = null;</span>
<span class="udiff-line-modified-removed">-             List&lt;AbstractDeoptimizeNode&gt; obsoletes = null;</span>
<span class="udiff-line-modified-removed">-             for (AbstractDeoptimizeNode deopt : fs.usages().filter(AbstractDeoptimizeNode.class)) {</span>
<span class="udiff-line-modified-removed">-                 if (target == null) {</span>
<span class="udiff-line-modified-removed">-                     target = deopt;</span>
<span class="udiff-line-modified-removed">-                 } else {</span>
<span class="udiff-line-modified-removed">-                     if (cfg == null) {</span>
<span class="udiff-line-modified-removed">-                         cfg = ControlFlowGraph.compute(graph, true, true, false, false);</span>
<span class="udiff-line-modified-removed">-                     }</span>
<span class="udiff-line-modified-removed">-                     AbstractMergeNode merge;</span>
<span class="udiff-line-modified-removed">-                     if (target instanceof AbstractDeoptimizeNode) {</span>
<span class="udiff-line-removed">-                         merge = graph.add(new MergeNode());</span>
<span class="udiff-line-removed">-                         EndNode firstEnd = graph.add(new EndNode());</span>
<span class="udiff-line-removed">-                         ValueNode actionAndReason = ((AbstractDeoptimizeNode) target).getActionAndReason(context.getMetaAccess());</span>
<span class="udiff-line-removed">-                         ValueNode speculation = ((AbstractDeoptimizeNode) target).getSpeculation(context.getMetaAccess());</span>
<span class="udiff-line-removed">-                         reasonActionPhi = graph.addWithoutUnique(new ValuePhiNode(StampFactory.forKind(actionAndReason.getStackKind()), merge));</span>
<span class="udiff-line-removed">-                         speculationPhi = graph.addWithoutUnique(new ValuePhiNode(StampFactory.forKind(speculation.getStackKind()), merge));</span>
<span class="udiff-line-removed">-                         merge.addForwardEnd(firstEnd);</span>
<span class="udiff-line-removed">-                         reasonActionPhi.addInput(actionAndReason);</span>
<span class="udiff-line-removed">-                         speculationPhi.addInput(speculation);</span>
<span class="udiff-line-removed">-                         target.replaceAtPredecessor(firstEnd);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                         exitLoops((AbstractDeoptimizeNode) target, firstEnd, cfg);</span>
<span class="udiff-line-removed">-                         try (DebugCloseable position = target.withNodeSourcePosition()) {</span>
<span class="udiff-line-removed">-                             merge.setNext(graph.add(new DynamicDeoptimizeNode(reasonActionPhi, speculationPhi)));</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         obsoletes = new LinkedList&lt;&gt;();</span>
<span class="udiff-line-removed">-                         obsoletes.add((AbstractDeoptimizeNode) target);</span>
<span class="udiff-line-removed">-                         target = merge;</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         merge = (AbstractMergeNode) target;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     EndNode newEnd = graph.add(new EndNode());</span>
<span class="udiff-line-removed">-                     merge.addForwardEnd(newEnd);</span>
<span class="udiff-line-removed">-                     reasonActionPhi.addInput(deopt.getActionAndReason(context.getMetaAccess()));</span>
<span class="udiff-line-removed">-                     speculationPhi.addInput(deopt.getSpeculation(context.getMetaAccess()));</span>
<span class="udiff-line-removed">-                     deopt.replaceAtPredecessor(newEnd);</span>
<span class="udiff-line-removed">-                     exitLoops(deopt, newEnd, cfg);</span>
<span class="udiff-line-removed">-                     obsoletes.add(deopt);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+             Iterator&lt;AbstractDeoptimizeNode&gt; iterator = fs.usages().filter(AbstractDeoptimizeNode.class).iterator();</span>
<span class="udiff-line-modified-added">+             if (!iterator.hasNext()) {</span>
<span class="udiff-line-modified-added">+                 // No deopt</span>
<span class="udiff-line-modified-added">+                 continue;</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-modified-added">+             AbstractDeoptimizeNode first = iterator.next();</span>
<span class="udiff-line-modified-added">+             if (!iterator.hasNext()) {</span>
<span class="udiff-line-modified-added">+                 // Only 1 deopt</span>
<span class="udiff-line-modified-added">+                 continue;</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-modified-added">+             // There is more than one deopt, create a merge</span>
<span class="udiff-line-modified-added">+             if (cfg == null) {</span>
<span class="udiff-line-modified-added">+                 cfg = ControlFlowGraph.compute(graph, true, true, false, false);</span>
              }
<span class="udiff-line-modified-removed">-             if (obsoletes != null) {</span>
<span class="udiff-line-modified-removed">-                 ((DynamicDeoptimizeNode) ((AbstractMergeNode) target).next()).setStateBefore(fs);</span>
<span class="udiff-line-modified-removed">-                 for (AbstractDeoptimizeNode obsolete : obsoletes) {</span>
<span class="udiff-line-modified-removed">-                     obsolete.safeDelete();</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-added">+             AbstractMergeNode merge = graph.add(new MergeNode());</span>
<span class="udiff-line-modified-added">+             EndNode firstEnd = graph.add(new EndNode());</span>
<span class="udiff-line-modified-added">+             ValueNode actionAndReason = first.getActionAndReason(context.getMetaAccess());</span>
<span class="udiff-line-modified-added">+             ValueNode speculation = first.getSpeculation(context.getMetaAccess());</span>
<span class="udiff-line-modified-added">+             PhiNode reasonActionPhi = graph.addWithoutUnique(new ValuePhiNode(StampFactory.forKind(actionAndReason.getStackKind()), merge));</span>
<span class="udiff-line-added">+             PhiNode speculationPhi = graph.addWithoutUnique(new ValuePhiNode(StampFactory.forKind(speculation.getStackKind()), merge));</span>
<span class="udiff-line-added">+             merge.addForwardEnd(firstEnd);</span>
<span class="udiff-line-added">+             reasonActionPhi.addInput(actionAndReason);</span>
<span class="udiff-line-added">+             speculationPhi.addInput(speculation);</span>
<span class="udiff-line-added">+             first.replaceAtPredecessor(firstEnd);</span>
<span class="udiff-line-added">+             exitLoops(first, firstEnd, cfg);</span>
<span class="udiff-line-added">+             DynamicDeoptimizeNode dynamicDeopt;</span>
<span class="udiff-line-added">+             try (DebugCloseable position = first.withNodeSourcePosition()) {</span>
<span class="udiff-line-added">+                 dynamicDeopt = new DynamicDeoptimizeNode(reasonActionPhi, speculationPhi);</span>
<span class="udiff-line-added">+                 merge.setNext(graph.add(dynamicDeopt));</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             List&lt;AbstractDeoptimizeNode&gt; obsoletes = new LinkedList&lt;&gt;();</span>
<span class="udiff-line-added">+             obsoletes.add(first);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             do {</span>
<span class="udiff-line-added">+                 AbstractDeoptimizeNode deopt = iterator.next();</span>
<span class="udiff-line-added">+                 EndNode newEnd = graph.add(new EndNode());</span>
<span class="udiff-line-added">+                 merge.addForwardEnd(newEnd);</span>
<span class="udiff-line-added">+                 reasonActionPhi.addInput(deopt.getActionAndReason(context.getMetaAccess()));</span>
<span class="udiff-line-added">+                 speculationPhi.addInput(deopt.getSpeculation(context.getMetaAccess()));</span>
<span class="udiff-line-added">+                 deopt.replaceAtPredecessor(newEnd);</span>
<span class="udiff-line-added">+                 exitLoops(deopt, newEnd, cfg);</span>
<span class="udiff-line-added">+                 obsoletes.add(deopt);</span>
<span class="udiff-line-added">+             } while (iterator.hasNext());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             dynamicDeopt.setStateBefore(fs);</span>
<span class="udiff-line-added">+             for (AbstractDeoptimizeNode obsolete : obsoletes) {</span>
<span class="udiff-line-added">+                 obsolete.safeDelete();</span>
              }
          }
      }
  
      private static void exitLoops(AbstractDeoptimizeNode deopt, EndNode end, ControlFlowGraph cfg) {
</pre>
<center><a href="ConditionalEliminationPhase.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ExpandLogicPhase.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
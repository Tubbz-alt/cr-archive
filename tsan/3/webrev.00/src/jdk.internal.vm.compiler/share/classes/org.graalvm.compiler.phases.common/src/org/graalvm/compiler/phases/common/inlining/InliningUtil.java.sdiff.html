<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/inlining/InliningUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../UseTrappingNullChecksPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="info/MultiTypeGuardInlineInfo.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/inlining/InliningUtil.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  39 import jdk.internal.vm.compiler.collections.Equivalence;
  40 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  41 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
  42 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  43 import org.graalvm.compiler.core.common.GraalOptions;
  44 import org.graalvm.compiler.core.common.type.Stamp;
  45 import org.graalvm.compiler.core.common.type.StampFactory;
  46 import org.graalvm.compiler.core.common.type.TypeReference;
  47 import org.graalvm.compiler.core.common.util.Util;
  48 import org.graalvm.compiler.debug.DebugCloseable;
  49 import org.graalvm.compiler.debug.DebugContext;
  50 import org.graalvm.compiler.debug.GraalError;
  51 import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
  52 import org.graalvm.compiler.graph.Graph.Mark;
  53 import org.graalvm.compiler.graph.Graph.NodeEventScope;
  54 import org.graalvm.compiler.graph.Node;
  55 import org.graalvm.compiler.graph.NodeInputList;
  56 import org.graalvm.compiler.graph.NodeMap;
  57 import org.graalvm.compiler.graph.NodeSourcePosition;
  58 import org.graalvm.compiler.graph.NodeWorkList;

  59 import org.graalvm.compiler.nodeinfo.Verbosity;
  60 import org.graalvm.compiler.nodes.AbstractBeginNode;
  61 import org.graalvm.compiler.nodes.AbstractEndNode;
  62 import org.graalvm.compiler.nodes.AbstractMergeNode;
  63 import org.graalvm.compiler.nodes.BeginNode;
  64 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
  65 import org.graalvm.compiler.nodes.DeoptimizeNode;
  66 import org.graalvm.compiler.nodes.DeoptimizingGuard;
  67 import org.graalvm.compiler.nodes.EndNode;
  68 import org.graalvm.compiler.nodes.FixedGuardNode;
  69 import org.graalvm.compiler.nodes.FixedNode;
  70 import org.graalvm.compiler.nodes.FrameState;
  71 import org.graalvm.compiler.nodes.InliningLog;
  72 import org.graalvm.compiler.nodes.Invoke;
  73 import org.graalvm.compiler.nodes.InvokeNode;
  74 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
<span class="line-removed">  75 import org.graalvm.compiler.nodes.KillingBeginNode;</span>
  76 import org.graalvm.compiler.nodes.LogicNode;
  77 import org.graalvm.compiler.nodes.MergeNode;
  78 import org.graalvm.compiler.nodes.NodeView;
  79 import org.graalvm.compiler.nodes.ParameterNode;
  80 import org.graalvm.compiler.nodes.PhiNode;
  81 import org.graalvm.compiler.nodes.PiNode;
  82 import org.graalvm.compiler.nodes.ReturnNode;
  83 import org.graalvm.compiler.nodes.StartNode;
  84 import org.graalvm.compiler.nodes.StateSplit;
  85 import org.graalvm.compiler.nodes.StructuredGraph;
  86 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
  87 import org.graalvm.compiler.nodes.UnwindNode;
  88 import org.graalvm.compiler.nodes.ValueNode;
  89 import org.graalvm.compiler.nodes.calc.IsNullNode;
  90 import org.graalvm.compiler.nodes.extended.ForeignCallNode;

  91 import org.graalvm.compiler.nodes.extended.GuardingNode;
  92 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
  93 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  94 import org.graalvm.compiler.nodes.java.MonitorExitNode;
  95 import org.graalvm.compiler.nodes.java.MonitorIdNode;
<span class="line-removed">  96 import org.graalvm.compiler.nodes.spi.Replacements;</span>
  97 import org.graalvm.compiler.nodes.type.StampTool;
  98 import org.graalvm.compiler.nodes.util.GraphUtil;
  99 import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
 100 import org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener;
 101 import org.graalvm.compiler.phases.util.ValueMergeUtil;
 102 
 103 import jdk.vm.ci.code.BytecodeFrame;
 104 import jdk.vm.ci.meta.Assumptions;
 105 import jdk.vm.ci.meta.DeoptimizationAction;
 106 import jdk.vm.ci.meta.DeoptimizationReason;
 107 import jdk.vm.ci.meta.JavaKind;
 108 import jdk.vm.ci.meta.ResolvedJavaMethod;
 109 import jdk.vm.ci.meta.ResolvedJavaType;
 110 
 111 public class InliningUtil extends ValueMergeUtil {
 112 
 113     private static final String inliningDecisionsScopeString = &quot;InliningDecisions&quot;;
 114 
 115     /**
 116      * Print a HotSpot-style inlining message to the console.
</pre>
<hr />
<pre>
 366         StructuredGraph graph = invokeNode.graph();
 367         final NodeInputList&lt;ValueNode&gt; parameters = invoke.callTarget().arguments();
 368 
 369         assert inlineGraph.getGuardsStage().ordinal() &gt;= graph.getGuardsStage().ordinal();
 370         assert !invokeNode.graph().isAfterFloatingReadPhase() : &quot;inline isn&#39;t handled correctly after floating reads phase&quot;;
 371 
 372         if (receiverNullCheck &amp;&amp; !((MethodCallTargetNode) invoke.callTarget()).isStatic()) {
 373             nonNullReceiver(invoke);
 374         }
 375 
 376         ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(inlineGraph.getNodes().count());
 377         ArrayList&lt;ReturnNode&gt; returnNodes = new ArrayList&lt;&gt;(4);
 378         ArrayList&lt;Invoke&gt; partialIntrinsicExits = new ArrayList&lt;&gt;();
 379         UnwindNode unwindNode = null;
 380         final StartNode entryPointNode = inlineGraph.start();
 381         FixedNode firstCFGNode = entryPointNode.next();
 382         if (firstCFGNode == null) {
 383             throw new IllegalStateException(&quot;Inlined graph is in invalid state: &quot; + inlineGraph);
 384         }
 385         for (Node node : inlineGraph.getNodes()) {
<span class="line-modified"> 386             if (node == entryPointNode || (node == entryPointNode.stateAfter() &amp;&amp; node.usages().count() == 1) || node instanceof ParameterNode) {</span>
 387                 // Do nothing.
 388             } else {
 389                 nodes.add(node);
 390                 if (node instanceof ReturnNode) {
 391                     returnNodes.add((ReturnNode) node);
 392                 } else if (node instanceof Invoke) {
 393                     Invoke invokeInInlineGraph = (Invoke) node;
 394                     if (invokeInInlineGraph.bci() == BytecodeFrame.UNKNOWN_BCI) {
 395                         ResolvedJavaMethod target1 = inlineeMethod;
 396                         ResolvedJavaMethod target2 = invokeInInlineGraph.callTarget().targetMethod();
 397                         assert target1.equals(target2) : String.format(&quot;invoke in inlined method expected to be partial intrinsic exit (i.e., call to %s), not a call to %s&quot;,
 398                                         target1.format(&quot;%H.%n(%p)&quot;), target2.format(&quot;%H.%n(%p)&quot;));
 399                         partialIntrinsicExits.add(invokeInInlineGraph);
 400                     }
 401                 } else if (node instanceof UnwindNode) {
 402                     assert unwindNode == null;
 403                     unwindNode = (UnwindNode) node;
 404                 }
 405             }
 406         }
</pre>
<hr />
<pre>
 449             processFrameStates(invoke, inlineGraph, duplicates, stateAtExceptionEdge, returnNodes.size() &gt; 1);
 450             int callerLockDepth = stateAfter.nestedLockDepth();
 451             if (callerLockDepth != 0) {
 452                 for (MonitorIdNode original : inlineGraph.getNodes(MonitorIdNode.TYPE)) {
 453                     MonitorIdNode monitor = (MonitorIdNode) duplicates.get(original);
 454                     processMonitorId(invoke.stateAfter(), monitor);
 455                 }
 456             }
 457         } else {
 458             assert checkContainsOnlyInvalidOrAfterFrameState(duplicates);
 459         }
 460 
 461         firstCFGNode = (FixedNode) duplicates.get(firstCFGNode);
 462         for (int i = 0; i &lt; returnNodes.size(); i++) {
 463             returnNodes.set(i, (ReturnNode) duplicates.get(returnNodes.get(i)));
 464         }
 465         for (Invoke exit : partialIntrinsicExits) {
 466             // A partial intrinsic exit must be replaced with a call to
 467             // the intrinsified method.
 468             Invoke dup = (Invoke) duplicates.get(exit.asNode());
<span class="line-modified"> 469             if (dup instanceof InvokeNode) {</span>
<span class="line-removed"> 470                 ((InvokeNode) dup).replaceWithNewBci(invoke.bci());</span>
<span class="line-removed"> 471             } else {</span>
<span class="line-removed"> 472                 ((InvokeWithExceptionNode) dup).replaceWithNewBci(invoke.bci());</span>
<span class="line-removed"> 473             }</span>
 474         }
 475         if (unwindNode != null) {
 476             unwindNode = (UnwindNode) duplicates.get(unwindNode);
 477         }
 478 
 479         finishInlining(invoke, graph, firstCFGNode, returnNodes, unwindNode, inlineGraph.getAssumptions(), inlineGraph);
 480         GraphUtil.killCFG(invokeNode);
 481 
 482         return duplicates;
 483     }
 484 
 485     /**
 486      * Inline {@code inlineGraph} into the current replacing the node {@code Invoke} and return the
 487      * set of nodes which should be canonicalized. The set should only contain nodes which modified
 488      * by the inlining since the current graph and {@code inlineGraph} are expected to already be
 489      * canonical.
 490      *
 491      * @param invoke
 492      * @param inlineGraph
 493      * @param receiverNullCheck
</pre>
<hr />
<pre>
 515             }
 516         }
 517         return listener.getNodes();
 518     }
 519 
 520     @SuppressWarnings(&quot;try&quot;)
 521     private static ValueNode finishInlining(Invoke invoke, StructuredGraph graph, FixedNode firstNode, List&lt;ReturnNode&gt; returnNodes, UnwindNode unwindNode, Assumptions inlinedAssumptions,
 522                     StructuredGraph inlineGraph) {
 523         FixedNode invokeNode = invoke.asNode();
 524         FrameState stateAfter = invoke.stateAfter();
 525         assert stateAfter == null || stateAfter.isAlive();
 526 
 527         invokeNode.replaceAtPredecessor(firstNode);
 528 
 529         if (invoke instanceof InvokeWithExceptionNode) {
 530             InvokeWithExceptionNode invokeWithException = ((InvokeWithExceptionNode) invoke);
 531             if (unwindNode != null &amp;&amp; unwindNode.isAlive()) {
 532                 assert unwindNode.predecessor() != null;
 533                 assert invokeWithException.exceptionEdge().successors().count() == 1;
 534                 ExceptionObjectNode obj = (ExceptionObjectNode) invokeWithException.exceptionEdge();
<span class="line-modified"> 535                 obj.replaceAtUsages(unwindNode.exception());</span>










 536                 Node n = obj.next();
 537                 obj.setNext(null);
 538                 unwindNode.replaceAndDelete(n);
 539 
 540                 obj.replaceAtPredecessor(null);
 541                 obj.safeDelete();
 542             } else {
 543                 invokeWithException.killExceptionEdge();
 544             }
 545 
 546             // get rid of memory kill
<span class="line-modified"> 547             AbstractBeginNode begin = invokeWithException.next();</span>
<span class="line-removed"> 548             if (begin instanceof KillingBeginNode) {</span>
<span class="line-removed"> 549                 try (DebugCloseable position = begin.withNodeSourcePosition()) {</span>
<span class="line-removed"> 550                     AbstractBeginNode newBegin = new BeginNode();</span>
<span class="line-removed"> 551                     graph.addAfterFixed(begin, graph.add(newBegin));</span>
<span class="line-removed"> 552                     begin.replaceAtUsages(newBegin);</span>
<span class="line-removed"> 553                     graph.removeFixed(begin);</span>
<span class="line-removed"> 554                 }</span>
<span class="line-removed"> 555             }</span>
 556         } else {
 557             if (unwindNode != null &amp;&amp; unwindNode.isAlive()) {
 558                 try (DebugCloseable position = unwindNode.withNodeSourcePosition()) {
 559                     DeoptimizeNode deoptimizeNode = addDeoptimizeNode(graph, DeoptimizationAction.InvalidateRecompile, DeoptimizationReason.NotCompiledExceptionHandler);
 560                     unwindNode.replaceAndDelete(deoptimizeNode);
 561                 }
 562             }
 563         }
 564 
 565         ValueNode returnValue;
 566         if (!returnNodes.isEmpty()) {
 567             FixedNode n = invoke.next();
 568             invoke.setNext(null);
 569             if (returnNodes.size() == 1) {
 570                 ReturnNode returnNode = returnNodes.get(0);
 571                 returnValue = returnNode.result();
 572                 invokeNode.replaceAtUsages(returnValue);
 573                 returnNode.replaceAndDelete(n);
 574             } else {
 575                 MergeNode merge = graph.add(new MergeNode());
</pre>
<hr />
<pre>
 725                         value.setNodeSourcePosition(invokePos);
 726                     }
 727                 }
 728             }
 729         }
 730         assert invokeGraph.verifySourcePositions(false);
 731     }
 732 
 733     public static void processMonitorId(FrameState stateAfter, MonitorIdNode monitorIdNode) {
 734         if (stateAfter != null) {
 735             int callerLockDepth = stateAfter.nestedLockDepth();
 736             monitorIdNode.setLockDepth(monitorIdNode.getLockDepth() + callerLockDepth);
 737         }
 738     }
 739 
 740     protected static void processFrameStates(Invoke invoke, StructuredGraph inlineGraph, EconomicMap&lt;Node, Node&gt; duplicates, FrameState stateAtExceptionEdge,
 741                     boolean alwaysDuplicateStateAfter) {
 742         FrameState stateAtReturn = invoke.stateAfter();
 743         FrameState outerFrameState = null;
 744         JavaKind invokeReturnKind = invoke.asNode().getStackKind();
<span class="line-modified"> 745         EconomicMap&lt;Node, Node&gt; replacements = EconomicMap.create();</span>
 746         for (FrameState original : inlineGraph.getNodes(FrameState.TYPE)) {
 747             FrameState frameState = (FrameState) duplicates.get(original);
 748             if (frameState != null &amp;&amp; frameState.isAlive()) {
 749                 if (outerFrameState == null) {
 750                     outerFrameState = stateAtReturn.duplicateModifiedDuringCall(invoke.bci(), invokeReturnKind);
 751                 }
 752                 processFrameState(frameState, invoke, replacements, inlineGraph.method(), stateAtExceptionEdge, outerFrameState, alwaysDuplicateStateAfter, invoke.callTarget().targetMethod(),
 753                                 invoke.callTarget().arguments());
 754             }
 755         }
 756         // If processing the frame states replaced any nodes, update the duplicates map.
 757         duplicates.replaceAll((key, value) -&gt; replacements.containsKey(value) ? replacements.get(value) : value);
 758     }
 759 
 760     public static FrameState processFrameState(FrameState frameState, Invoke invoke, EconomicMap&lt;Node, Node&gt; replacements, ResolvedJavaMethod inlinedMethod, FrameState stateAtExceptionEdge,
 761                     FrameState outerFrameState,
 762                     boolean alwaysDuplicateStateAfter, ResolvedJavaMethod invokeTargetMethod, List&lt;ValueNode&gt; invokeArgsList) {
 763         assert outerFrameState == null || !outerFrameState.isDeleted() : outerFrameState;
 764         final FrameState stateAtReturn = invoke.stateAfter();
 765         JavaKind invokeReturnKind = invoke.asNode().getStackKind();
</pre>
<hr />
<pre>
 819                     ForeignCallNode foreign = (ForeignCallNode) usage;
 820                     foreign.setBci(invoke.bci());
 821                 }
 822             }
 823         }
 824 
 825         // pop return kind from invoke&#39;s stateAfter and replace with this frameState&#39;s return
 826         // value (top of stack)
 827         assert !frameState.rethrowException() : frameState;
 828         if (frameState.stackSize() &gt; 0 &amp;&amp; (alwaysDuplicateStateAfter || stateAfterReturn.stackAt(0) != frameState.stackAt(0))) {
 829             // A non-void return value.
 830             stateAfterReturn = stateAtReturn.duplicateModified(invokeReturnKind, invokeReturnKind, frameState.stackAt(0));
 831         } else {
 832             // A void return value.
 833             stateAfterReturn = stateAtReturn.duplicate();
 834         }
 835         assert stateAfterReturn.bci != BytecodeFrame.UNKNOWN_BCI;
 836 
 837         // Return value does no longer need to be limited by the monitor exit.
 838         for (MonitorExitNode n : frameState.usages().filter(MonitorExitNode.class)) {
<span class="line-modified"> 839             n.clearEscapedReturnValue();</span>
 840         }
 841 
 842         frameState.replaceAndDelete(stateAfterReturn);
 843         return stateAfterReturn;
 844     }
 845 
 846     static boolean checkInlineeFrameState(Invoke invoke, ResolvedJavaMethod inlinedMethod, FrameState frameState) {
 847         assert frameState.bci != BytecodeFrame.AFTER_EXCEPTION_BCI : frameState;
 848         assert frameState.bci != BytecodeFrame.BEFORE_BCI : frameState;
 849         assert frameState.bci != BytecodeFrame.UNKNOWN_BCI : frameState;
 850         if (frameState.bci != BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 851             ResolvedJavaMethod method = frameState.getMethod();
 852             if (method.equals(inlinedMethod)) {
 853                 // Normal inlining expects all outermost inlinee frame states to
 854                 // denote the inlinee method
 855             } else if (method.equals(invoke.callTarget().targetMethod())) {
 856                 // This occurs when an intrinsic calls back to the original
 857                 // method to handle a slow path. During parsing of such a
 858                 // partial intrinsic, these calls are given frame states
 859                 // that exclude the outer frame state denoting a position
</pre>
<hr />
<pre>
 988                         newReceiver = graph.unique(new PiNode(newReceiver, stamp));
 989                     }
 990                 }
 991 
 992                 if (!StampTool.isPointerNonNull(newReceiver)) {
 993                     LogicNode condition = graph.unique(IsNullNode.create(newReceiver));
 994                     FixedGuardNode fixedGuard = graph.add(new FixedGuardNode(condition, NullCheckException, InvalidateReprofile, true));
 995                     PiNode nonNullReceiver = graph.unique(new PiNode(newReceiver, StampFactory.objectNonNull(), fixedGuard));
 996                     graph.addBeforeFixed(invoke.asNode(), fixedGuard);
 997                     newReceiver = nonNullReceiver;
 998                 }
 999             }
1000 
1001             if (newReceiver != oldReceiver) {
1002                 callTarget.replaceFirstInput(oldReceiver, newReceiver);
1003             }
1004             return newReceiver;
1005         }
1006     }
1007 
<span class="line-removed">1008     public static boolean canIntrinsify(Replacements replacements, ResolvedJavaMethod target, int invokeBci) {</span>
<span class="line-removed">1009         return replacements.hasSubstitution(target, invokeBci);</span>
<span class="line-removed">1010     }</span>
<span class="line-removed">1011 </span>
<span class="line-removed">1012     public static StructuredGraph getIntrinsicGraph(Replacements replacements, ResolvedJavaMethod target, int invokeBci, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>
<span class="line-removed">1013         return replacements.getSubstitution(target, invokeBci, trackNodeSourcePosition, replaceePosition);</span>
<span class="line-removed">1014     }</span>
<span class="line-removed">1015 </span>
1016     /**
1017      * This method exclude InstrumentationNode from inlining heuristics.
1018      */
1019     public static int getNodeCount(StructuredGraph graph) {
1020         return graph.getNodeCount();
1021     }
1022 
1023 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  39 import jdk.internal.vm.compiler.collections.Equivalence;
  40 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  41 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
  42 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  43 import org.graalvm.compiler.core.common.GraalOptions;
  44 import org.graalvm.compiler.core.common.type.Stamp;
  45 import org.graalvm.compiler.core.common.type.StampFactory;
  46 import org.graalvm.compiler.core.common.type.TypeReference;
  47 import org.graalvm.compiler.core.common.util.Util;
  48 import org.graalvm.compiler.debug.DebugCloseable;
  49 import org.graalvm.compiler.debug.DebugContext;
  50 import org.graalvm.compiler.debug.GraalError;
  51 import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
  52 import org.graalvm.compiler.graph.Graph.Mark;
  53 import org.graalvm.compiler.graph.Graph.NodeEventScope;
  54 import org.graalvm.compiler.graph.Node;
  55 import org.graalvm.compiler.graph.NodeInputList;
  56 import org.graalvm.compiler.graph.NodeMap;
  57 import org.graalvm.compiler.graph.NodeSourcePosition;
  58 import org.graalvm.compiler.graph.NodeWorkList;
<span class="line-added">  59 import org.graalvm.compiler.nodeinfo.InputType;</span>
  60 import org.graalvm.compiler.nodeinfo.Verbosity;
  61 import org.graalvm.compiler.nodes.AbstractBeginNode;
  62 import org.graalvm.compiler.nodes.AbstractEndNode;
  63 import org.graalvm.compiler.nodes.AbstractMergeNode;
  64 import org.graalvm.compiler.nodes.BeginNode;
  65 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
  66 import org.graalvm.compiler.nodes.DeoptimizeNode;
  67 import org.graalvm.compiler.nodes.DeoptimizingGuard;
  68 import org.graalvm.compiler.nodes.EndNode;
  69 import org.graalvm.compiler.nodes.FixedGuardNode;
  70 import org.graalvm.compiler.nodes.FixedNode;
  71 import org.graalvm.compiler.nodes.FrameState;
  72 import org.graalvm.compiler.nodes.InliningLog;
  73 import org.graalvm.compiler.nodes.Invoke;
  74 import org.graalvm.compiler.nodes.InvokeNode;
  75 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;

  76 import org.graalvm.compiler.nodes.LogicNode;
  77 import org.graalvm.compiler.nodes.MergeNode;
  78 import org.graalvm.compiler.nodes.NodeView;
  79 import org.graalvm.compiler.nodes.ParameterNode;
  80 import org.graalvm.compiler.nodes.PhiNode;
  81 import org.graalvm.compiler.nodes.PiNode;
  82 import org.graalvm.compiler.nodes.ReturnNode;
  83 import org.graalvm.compiler.nodes.StartNode;
  84 import org.graalvm.compiler.nodes.StateSplit;
  85 import org.graalvm.compiler.nodes.StructuredGraph;
  86 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
  87 import org.graalvm.compiler.nodes.UnwindNode;
  88 import org.graalvm.compiler.nodes.ValueNode;
  89 import org.graalvm.compiler.nodes.calc.IsNullNode;
  90 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
<span class="line-added">  91 import org.graalvm.compiler.nodes.extended.GuardedNode;</span>
  92 import org.graalvm.compiler.nodes.extended.GuardingNode;
  93 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
  94 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  95 import org.graalvm.compiler.nodes.java.MonitorExitNode;
  96 import org.graalvm.compiler.nodes.java.MonitorIdNode;

  97 import org.graalvm.compiler.nodes.type.StampTool;
  98 import org.graalvm.compiler.nodes.util.GraphUtil;
  99 import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
 100 import org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener;
 101 import org.graalvm.compiler.phases.util.ValueMergeUtil;
 102 
 103 import jdk.vm.ci.code.BytecodeFrame;
 104 import jdk.vm.ci.meta.Assumptions;
 105 import jdk.vm.ci.meta.DeoptimizationAction;
 106 import jdk.vm.ci.meta.DeoptimizationReason;
 107 import jdk.vm.ci.meta.JavaKind;
 108 import jdk.vm.ci.meta.ResolvedJavaMethod;
 109 import jdk.vm.ci.meta.ResolvedJavaType;
 110 
 111 public class InliningUtil extends ValueMergeUtil {
 112 
 113     private static final String inliningDecisionsScopeString = &quot;InliningDecisions&quot;;
 114 
 115     /**
 116      * Print a HotSpot-style inlining message to the console.
</pre>
<hr />
<pre>
 366         StructuredGraph graph = invokeNode.graph();
 367         final NodeInputList&lt;ValueNode&gt; parameters = invoke.callTarget().arguments();
 368 
 369         assert inlineGraph.getGuardsStage().ordinal() &gt;= graph.getGuardsStage().ordinal();
 370         assert !invokeNode.graph().isAfterFloatingReadPhase() : &quot;inline isn&#39;t handled correctly after floating reads phase&quot;;
 371 
 372         if (receiverNullCheck &amp;&amp; !((MethodCallTargetNode) invoke.callTarget()).isStatic()) {
 373             nonNullReceiver(invoke);
 374         }
 375 
 376         ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(inlineGraph.getNodes().count());
 377         ArrayList&lt;ReturnNode&gt; returnNodes = new ArrayList&lt;&gt;(4);
 378         ArrayList&lt;Invoke&gt; partialIntrinsicExits = new ArrayList&lt;&gt;();
 379         UnwindNode unwindNode = null;
 380         final StartNode entryPointNode = inlineGraph.start();
 381         FixedNode firstCFGNode = entryPointNode.next();
 382         if (firstCFGNode == null) {
 383             throw new IllegalStateException(&quot;Inlined graph is in invalid state: &quot; + inlineGraph);
 384         }
 385         for (Node node : inlineGraph.getNodes()) {
<span class="line-modified"> 386             if (node == entryPointNode || (node == entryPointNode.stateAfter() &amp;&amp; node.hasExactlyOneUsage()) || node instanceof ParameterNode) {</span>
 387                 // Do nothing.
 388             } else {
 389                 nodes.add(node);
 390                 if (node instanceof ReturnNode) {
 391                     returnNodes.add((ReturnNode) node);
 392                 } else if (node instanceof Invoke) {
 393                     Invoke invokeInInlineGraph = (Invoke) node;
 394                     if (invokeInInlineGraph.bci() == BytecodeFrame.UNKNOWN_BCI) {
 395                         ResolvedJavaMethod target1 = inlineeMethod;
 396                         ResolvedJavaMethod target2 = invokeInInlineGraph.callTarget().targetMethod();
 397                         assert target1.equals(target2) : String.format(&quot;invoke in inlined method expected to be partial intrinsic exit (i.e., call to %s), not a call to %s&quot;,
 398                                         target1.format(&quot;%H.%n(%p)&quot;), target2.format(&quot;%H.%n(%p)&quot;));
 399                         partialIntrinsicExits.add(invokeInInlineGraph);
 400                     }
 401                 } else if (node instanceof UnwindNode) {
 402                     assert unwindNode == null;
 403                     unwindNode = (UnwindNode) node;
 404                 }
 405             }
 406         }
</pre>
<hr />
<pre>
 449             processFrameStates(invoke, inlineGraph, duplicates, stateAtExceptionEdge, returnNodes.size() &gt; 1);
 450             int callerLockDepth = stateAfter.nestedLockDepth();
 451             if (callerLockDepth != 0) {
 452                 for (MonitorIdNode original : inlineGraph.getNodes(MonitorIdNode.TYPE)) {
 453                     MonitorIdNode monitor = (MonitorIdNode) duplicates.get(original);
 454                     processMonitorId(invoke.stateAfter(), monitor);
 455                 }
 456             }
 457         } else {
 458             assert checkContainsOnlyInvalidOrAfterFrameState(duplicates);
 459         }
 460 
 461         firstCFGNode = (FixedNode) duplicates.get(firstCFGNode);
 462         for (int i = 0; i &lt; returnNodes.size(); i++) {
 463             returnNodes.set(i, (ReturnNode) duplicates.get(returnNodes.get(i)));
 464         }
 465         for (Invoke exit : partialIntrinsicExits) {
 466             // A partial intrinsic exit must be replaced with a call to
 467             // the intrinsified method.
 468             Invoke dup = (Invoke) duplicates.get(exit.asNode());
<span class="line-modified"> 469             dup.replaceBci(invoke.bci());</span>




 470         }
 471         if (unwindNode != null) {
 472             unwindNode = (UnwindNode) duplicates.get(unwindNode);
 473         }
 474 
 475         finishInlining(invoke, graph, firstCFGNode, returnNodes, unwindNode, inlineGraph.getAssumptions(), inlineGraph);
 476         GraphUtil.killCFG(invokeNode);
 477 
 478         return duplicates;
 479     }
 480 
 481     /**
 482      * Inline {@code inlineGraph} into the current replacing the node {@code Invoke} and return the
 483      * set of nodes which should be canonicalized. The set should only contain nodes which modified
 484      * by the inlining since the current graph and {@code inlineGraph} are expected to already be
 485      * canonical.
 486      *
 487      * @param invoke
 488      * @param inlineGraph
 489      * @param receiverNullCheck
</pre>
<hr />
<pre>
 511             }
 512         }
 513         return listener.getNodes();
 514     }
 515 
 516     @SuppressWarnings(&quot;try&quot;)
 517     private static ValueNode finishInlining(Invoke invoke, StructuredGraph graph, FixedNode firstNode, List&lt;ReturnNode&gt; returnNodes, UnwindNode unwindNode, Assumptions inlinedAssumptions,
 518                     StructuredGraph inlineGraph) {
 519         FixedNode invokeNode = invoke.asNode();
 520         FrameState stateAfter = invoke.stateAfter();
 521         assert stateAfter == null || stateAfter.isAlive();
 522 
 523         invokeNode.replaceAtPredecessor(firstNode);
 524 
 525         if (invoke instanceof InvokeWithExceptionNode) {
 526             InvokeWithExceptionNode invokeWithException = ((InvokeWithExceptionNode) invoke);
 527             if (unwindNode != null &amp;&amp; unwindNode.isAlive()) {
 528                 assert unwindNode.predecessor() != null;
 529                 assert invokeWithException.exceptionEdge().successors().count() == 1;
 530                 ExceptionObjectNode obj = (ExceptionObjectNode) invokeWithException.exceptionEdge();
<span class="line-modified"> 531                 /*</span>
<span class="line-added"> 532                  * The exception object node is a begin node, i.e., it can be used as an anchor for</span>
<span class="line-added"> 533                  * other nodes, thus we need to re-route them to a valid anchor, i.e. the begin node</span>
<span class="line-added"> 534                  * of the unwind block.</span>
<span class="line-added"> 535                  */</span>
<span class="line-added"> 536                 assert obj.usages().filter(x -&gt; x instanceof GuardedNode &amp;&amp; ((GuardedNode) x).getGuard() == obj).count() == 0 : &quot;Must not have guards attached to an exception object node&quot;;</span>
<span class="line-added"> 537                 AbstractBeginNode replacementAnchor = AbstractBeginNode.prevBegin(unwindNode);</span>
<span class="line-added"> 538                 assert replacementAnchor != null;</span>
<span class="line-added"> 539                 obj.replaceAtUsages(InputType.Anchor, replacementAnchor);</span>
<span class="line-added"> 540                 obj.replaceAtUsages(InputType.Value, unwindNode.exception());</span>
<span class="line-added"> 541 </span>
 542                 Node n = obj.next();
 543                 obj.setNext(null);
 544                 unwindNode.replaceAndDelete(n);
 545 
 546                 obj.replaceAtPredecessor(null);
 547                 obj.safeDelete();
 548             } else {
 549                 invokeWithException.killExceptionEdge();
 550             }
 551 
 552             // get rid of memory kill
<span class="line-modified"> 553             invokeWithException.killKillingBegin();</span>








 554         } else {
 555             if (unwindNode != null &amp;&amp; unwindNode.isAlive()) {
 556                 try (DebugCloseable position = unwindNode.withNodeSourcePosition()) {
 557                     DeoptimizeNode deoptimizeNode = addDeoptimizeNode(graph, DeoptimizationAction.InvalidateRecompile, DeoptimizationReason.NotCompiledExceptionHandler);
 558                     unwindNode.replaceAndDelete(deoptimizeNode);
 559                 }
 560             }
 561         }
 562 
 563         ValueNode returnValue;
 564         if (!returnNodes.isEmpty()) {
 565             FixedNode n = invoke.next();
 566             invoke.setNext(null);
 567             if (returnNodes.size() == 1) {
 568                 ReturnNode returnNode = returnNodes.get(0);
 569                 returnValue = returnNode.result();
 570                 invokeNode.replaceAtUsages(returnValue);
 571                 returnNode.replaceAndDelete(n);
 572             } else {
 573                 MergeNode merge = graph.add(new MergeNode());
</pre>
<hr />
<pre>
 723                         value.setNodeSourcePosition(invokePos);
 724                     }
 725                 }
 726             }
 727         }
 728         assert invokeGraph.verifySourcePositions(false);
 729     }
 730 
 731     public static void processMonitorId(FrameState stateAfter, MonitorIdNode monitorIdNode) {
 732         if (stateAfter != null) {
 733             int callerLockDepth = stateAfter.nestedLockDepth();
 734             monitorIdNode.setLockDepth(monitorIdNode.getLockDepth() + callerLockDepth);
 735         }
 736     }
 737 
 738     protected static void processFrameStates(Invoke invoke, StructuredGraph inlineGraph, EconomicMap&lt;Node, Node&gt; duplicates, FrameState stateAtExceptionEdge,
 739                     boolean alwaysDuplicateStateAfter) {
 740         FrameState stateAtReturn = invoke.stateAfter();
 741         FrameState outerFrameState = null;
 742         JavaKind invokeReturnKind = invoke.asNode().getStackKind();
<span class="line-modified"> 743         EconomicMap&lt;Node, Node&gt; replacements = EconomicMap.create(Equivalence.IDENTITY);</span>
 744         for (FrameState original : inlineGraph.getNodes(FrameState.TYPE)) {
 745             FrameState frameState = (FrameState) duplicates.get(original);
 746             if (frameState != null &amp;&amp; frameState.isAlive()) {
 747                 if (outerFrameState == null) {
 748                     outerFrameState = stateAtReturn.duplicateModifiedDuringCall(invoke.bci(), invokeReturnKind);
 749                 }
 750                 processFrameState(frameState, invoke, replacements, inlineGraph.method(), stateAtExceptionEdge, outerFrameState, alwaysDuplicateStateAfter, invoke.callTarget().targetMethod(),
 751                                 invoke.callTarget().arguments());
 752             }
 753         }
 754         // If processing the frame states replaced any nodes, update the duplicates map.
 755         duplicates.replaceAll((key, value) -&gt; replacements.containsKey(value) ? replacements.get(value) : value);
 756     }
 757 
 758     public static FrameState processFrameState(FrameState frameState, Invoke invoke, EconomicMap&lt;Node, Node&gt; replacements, ResolvedJavaMethod inlinedMethod, FrameState stateAtExceptionEdge,
 759                     FrameState outerFrameState,
 760                     boolean alwaysDuplicateStateAfter, ResolvedJavaMethod invokeTargetMethod, List&lt;ValueNode&gt; invokeArgsList) {
 761         assert outerFrameState == null || !outerFrameState.isDeleted() : outerFrameState;
 762         final FrameState stateAtReturn = invoke.stateAfter();
 763         JavaKind invokeReturnKind = invoke.asNode().getStackKind();
</pre>
<hr />
<pre>
 817                     ForeignCallNode foreign = (ForeignCallNode) usage;
 818                     foreign.setBci(invoke.bci());
 819                 }
 820             }
 821         }
 822 
 823         // pop return kind from invoke&#39;s stateAfter and replace with this frameState&#39;s return
 824         // value (top of stack)
 825         assert !frameState.rethrowException() : frameState;
 826         if (frameState.stackSize() &gt; 0 &amp;&amp; (alwaysDuplicateStateAfter || stateAfterReturn.stackAt(0) != frameState.stackAt(0))) {
 827             // A non-void return value.
 828             stateAfterReturn = stateAtReturn.duplicateModified(invokeReturnKind, invokeReturnKind, frameState.stackAt(0));
 829         } else {
 830             // A void return value.
 831             stateAfterReturn = stateAtReturn.duplicate();
 832         }
 833         assert stateAfterReturn.bci != BytecodeFrame.UNKNOWN_BCI;
 834 
 835         // Return value does no longer need to be limited by the monitor exit.
 836         for (MonitorExitNode n : frameState.usages().filter(MonitorExitNode.class)) {
<span class="line-modified"> 837             n.clearEscapedValue();</span>
 838         }
 839 
 840         frameState.replaceAndDelete(stateAfterReturn);
 841         return stateAfterReturn;
 842     }
 843 
 844     static boolean checkInlineeFrameState(Invoke invoke, ResolvedJavaMethod inlinedMethod, FrameState frameState) {
 845         assert frameState.bci != BytecodeFrame.AFTER_EXCEPTION_BCI : frameState;
 846         assert frameState.bci != BytecodeFrame.BEFORE_BCI : frameState;
 847         assert frameState.bci != BytecodeFrame.UNKNOWN_BCI : frameState;
 848         if (frameState.bci != BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 849             ResolvedJavaMethod method = frameState.getMethod();
 850             if (method.equals(inlinedMethod)) {
 851                 // Normal inlining expects all outermost inlinee frame states to
 852                 // denote the inlinee method
 853             } else if (method.equals(invoke.callTarget().targetMethod())) {
 854                 // This occurs when an intrinsic calls back to the original
 855                 // method to handle a slow path. During parsing of such a
 856                 // partial intrinsic, these calls are given frame states
 857                 // that exclude the outer frame state denoting a position
</pre>
<hr />
<pre>
 986                         newReceiver = graph.unique(new PiNode(newReceiver, stamp));
 987                     }
 988                 }
 989 
 990                 if (!StampTool.isPointerNonNull(newReceiver)) {
 991                     LogicNode condition = graph.unique(IsNullNode.create(newReceiver));
 992                     FixedGuardNode fixedGuard = graph.add(new FixedGuardNode(condition, NullCheckException, InvalidateReprofile, true));
 993                     PiNode nonNullReceiver = graph.unique(new PiNode(newReceiver, StampFactory.objectNonNull(), fixedGuard));
 994                     graph.addBeforeFixed(invoke.asNode(), fixedGuard);
 995                     newReceiver = nonNullReceiver;
 996                 }
 997             }
 998 
 999             if (newReceiver != oldReceiver) {
1000                 callTarget.replaceFirstInput(oldReceiver, newReceiver);
1001             }
1002             return newReceiver;
1003         }
1004     }
1005 








1006     /**
1007      * This method exclude InstrumentationNode from inlining heuristics.
1008      */
1009     public static int getNodeCount(StructuredGraph graph) {
1010         return graph.getNodeCount();
1011     }
1012 
1013 }
</pre>
</td>
</tr>
</table>
<center><a href="../UseTrappingNullChecksPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="info/MultiTypeGuardInlineInfo.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/inlining/walker/InliningData.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.phases.common.inlining.walker;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.Intrinsify;
 28 import static org.graalvm.compiler.core.common.GraalOptions.MaximumRecursiveInlining;
 29 import static org.graalvm.compiler.core.common.GraalOptions.MegamorphicInliningMinMethodProbability;
 30 
 31 import java.util.ArrayDeque;
 32 import java.util.ArrayList;
 33 import java.util.BitSet;
 34 import java.util.Collection;
 35 import java.util.Iterator;
 36 import java.util.LinkedList;
 37 import java.util.List;
 38 
 39 import jdk.internal.vm.compiler.collections.EconomicSet;
 40 import jdk.internal.vm.compiler.collections.Equivalence;
 41 import org.graalvm.compiler.core.common.type.ObjectStamp;
 42 import org.graalvm.compiler.debug.CounterKey;
 43 import org.graalvm.compiler.debug.DebugContext;
 44 import org.graalvm.compiler.debug.GraalError;
 45 import org.graalvm.compiler.graph.Graph;
 46 import org.graalvm.compiler.graph.Node;
 47 import org.graalvm.compiler.nodes.CallTargetNode;
<a name="2" id="anc2"></a><span class="line-added"> 48 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;</span>
 49 import org.graalvm.compiler.nodes.Invoke;
 50 import org.graalvm.compiler.nodes.NodeView;
 51 import org.graalvm.compiler.nodes.ParameterNode;
 52 import org.graalvm.compiler.nodes.StructuredGraph;
 53 import org.graalvm.compiler.nodes.ValueNode;
 54 import org.graalvm.compiler.nodes.java.AbstractNewObjectNode;
 55 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 56 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
 57 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 58 import org.graalvm.compiler.options.OptionValues;
 59 import org.graalvm.compiler.phases.OptimisticOptimizations;
 60 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 61 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 62 import org.graalvm.compiler.phases.common.inlining.info.AssumptionInlineInfo;
 63 import org.graalvm.compiler.phases.common.inlining.info.ExactInlineInfo;
 64 import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
 65 import org.graalvm.compiler.phases.common.inlining.info.MultiTypeGuardInlineInfo;
 66 import org.graalvm.compiler.phases.common.inlining.info.TypeGuardInlineInfo;
 67 import org.graalvm.compiler.phases.common.inlining.info.elem.Inlineable;
 68 import org.graalvm.compiler.phases.common.inlining.info.elem.InlineableGraph;
 69 import org.graalvm.compiler.phases.common.inlining.policy.InliningPolicy;
 70 import org.graalvm.compiler.phases.tiers.HighTierContext;
 71 import org.graalvm.compiler.phases.util.Providers;
 72 
 73 import jdk.vm.ci.code.BailoutException;
 74 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 75 import jdk.vm.ci.meta.JavaTypeProfile;
 76 import jdk.vm.ci.meta.ResolvedJavaMethod;
 77 import jdk.vm.ci.meta.ResolvedJavaType;
 78 
 79 /**
 80  * &lt;p&gt;
 81  * The space of inlining decisions is explored depth-first with the help of a stack realized by
 82  * {@link InliningData}. At any point in time, the topmost element of that stack consists of:
 83  * &lt;ul&gt;
 84  * &lt;li&gt;the callsite under consideration is tracked as a {@link MethodInvocation}.&lt;/li&gt;
 85  * &lt;li&gt;one or more {@link CallsiteHolder}s, all of them associated to the callsite above. Why more
 86  * than one? Depending on the type-profile for the receiver more than one concrete method may be
 87  * feasible target.&lt;/li&gt;
 88  * &lt;/ul&gt;
 89  * &lt;/p&gt;
 90  *
 91  * &lt;p&gt;
 92  * The bottom element in the stack consists of:
 93  * &lt;ul&gt;
 94  * &lt;li&gt;a single {@link MethodInvocation} (the
 95  * {@link org.graalvm.compiler.phases.common.inlining.walker.MethodInvocation#isRoot root} one, ie
 96  * the unknown caller of the root graph)&lt;/li&gt;
 97  * &lt;li&gt;a single {@link CallsiteHolder} (the root one, for the method on which inlining was called)
 98  * &lt;/li&gt;
 99  * &lt;/ul&gt;
100  * &lt;/p&gt;
101  *
102  * @see #moveForward()
103  */
104 public class InliningData {
105 
106     // Counters
107     private static final CounterKey counterInliningPerformed = DebugContext.counter(&quot;InliningPerformed&quot;);
108     private static final CounterKey counterInliningRuns = DebugContext.counter(&quot;InliningRuns&quot;);
109     private static final CounterKey counterInliningConsidered = DebugContext.counter(&quot;InliningConsidered&quot;);
110 
111     /**
112      * Call hierarchy from outer most call (i.e., compilation unit) to inner most callee.
113      */
114     private final ArrayDeque&lt;CallsiteHolder&gt; graphQueue = new ArrayDeque&lt;&gt;();
115     private final ArrayDeque&lt;MethodInvocation&gt; invocationQueue = new ArrayDeque&lt;&gt;();
116 
117     private final HighTierContext context;
118     private final int maxMethodPerInlining;
119     private final CanonicalizerPhase canonicalizer;
120     private final InliningPolicy inliningPolicy;
121     private final StructuredGraph rootGraph;
122     private final DebugContext debug;
123 
124     private int maxGraphs;
125 
126     public InliningData(StructuredGraph rootGraph, HighTierContext context, int maxMethodPerInlining, CanonicalizerPhase canonicalizer, InliningPolicy inliningPolicy, LinkedList&lt;Invoke&gt; rootInvokes) {
127         assert rootGraph != null;
128         this.context = context;
129         this.maxMethodPerInlining = maxMethodPerInlining;
130         this.canonicalizer = canonicalizer;
131         this.inliningPolicy = inliningPolicy;
132         this.maxGraphs = 1;
133         this.rootGraph = rootGraph;
134         this.debug = rootGraph.getDebug();
135 
136         invocationQueue.push(new MethodInvocation(null, 1.0, 1.0, null));
137         graphQueue.push(new CallsiteHolderExplorable(rootGraph, 1.0, 1.0, null, rootInvokes));
138     }
139 
140     public static boolean isFreshInstantiation(ValueNode arg) {
141         return (arg instanceof AbstractNewObjectNode) || (arg instanceof AllocatedObjectNode) || (arg instanceof VirtualObjectNode);
142     }
143 
144     private String checkTargetConditionsHelper(ResolvedJavaMethod method, int invokeBci) {
145         OptionValues options = rootGraph.getOptions();
146         if (method == null) {
147             return &quot;the method is not resolved&quot;;
<a name="3" id="anc3"></a><span class="line-modified">148         } else if (method.isNative() &amp;&amp; !(Intrinsify.getValue(options) &amp;&amp;</span>
<span class="line-added">149                         context.getReplacements().getSubstitution(method, invokeBci, rootGraph.trackNodeSourcePosition(), null, options) != null)) {</span>
<span class="line-added">150             // We have conditional intrinsic, e.g., String.intern, which may not have inlineable</span>
<span class="line-added">151             // graph depending on the context. The getSubstitution test ensures the inlineable</span>
<span class="line-added">152             // graph is present.</span>
153             return &quot;it is a non-intrinsic native method&quot;;
154         } else if (method.isAbstract()) {
155             return &quot;it is an abstract method&quot;;
156         } else if (!method.getDeclaringClass().isInitialized()) {
157             return &quot;the method&#39;s class is not initialized&quot;;
158         } else if (!method.canBeInlined()) {
159             return &quot;it is marked non-inlinable&quot;;
160         } else if (countRecursiveInlining(method) &gt; MaximumRecursiveInlining.getValue(options)) {
161             return &quot;it exceeds the maximum recursive inlining depth&quot;;
162         } else {
163             if (new OptimisticOptimizations(rootGraph.getProfilingInfo(method), options).lessOptimisticThan(context.getOptimisticOptimizations())) {
164                 return &quot;the callee uses less optimistic optimizations than caller&quot;;
165             } else {
166                 return null;
167             }
168         }
169     }
170 
171     private boolean checkTargetConditions(Invoke invoke, ResolvedJavaMethod method) {
172         final String failureMessage = checkTargetConditionsHelper(method, invoke.bci());
173         if (failureMessage == null) {
174             return true;
175         } else {
176             InliningUtil.traceNotInlinedMethod(invoke, inliningDepth(), method, failureMessage);
177             invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null, failureMessage);
178             return false;
179         }
180     }
181 
182     /**
183      * Determines if inlining is possible at the given invoke node.
184      *
185      * @param invoke the invoke that should be inlined
186      * @return an instance of InlineInfo, or null if no inlining is possible at the given invoke
187      */
188     private InlineInfo getInlineInfo(Invoke invoke) {
189         final String failureMessage = InliningUtil.checkInvokeConditions(invoke);
190         if (failureMessage != null) {
191             InliningUtil.logNotInlinedMethod(invoke, failureMessage);
192             return null;
193         }
194         MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
195         ResolvedJavaMethod targetMethod = callTarget.targetMethod();
196 
<a name="4" id="anc4"></a><span class="line-modified">197         InvokeKind invokeKind = callTarget.invokeKind();</span>
<span class="line-added">198         if (invokeKind == CallTargetNode.InvokeKind.Special || invokeKind == CallTargetNode.InvokeKind.Static || targetMethod.canBeStaticallyBound()) {</span>
199             return getExactInlineInfo(invoke, targetMethod);
200         }
201 
<a name="5" id="anc5"></a><span class="line-modified">202         assert invokeKind.isIndirect();</span>
203 
204         ResolvedJavaType holder = targetMethod.getDeclaringClass();
205         if (!(callTarget.receiver().stamp(NodeView.DEFAULT) instanceof ObjectStamp)) {
206             return null;
207         }
208         ObjectStamp receiverStamp = (ObjectStamp) callTarget.receiver().stamp(NodeView.DEFAULT);
209         if (receiverStamp.alwaysNull()) {
210             // Don&#39;t inline if receiver is known to be null
211             return null;
212         }
213         ResolvedJavaType contextType = invoke.getContextType();
214         if (receiverStamp.type() != null) {
215             // the invoke target might be more specific than the holder (happens after inlining:
216             // parameters lose their declared type...)
217             ResolvedJavaType receiverType = receiverStamp.type();
218             if (receiverType != null &amp;&amp; holder.isAssignableFrom(receiverType)) {
219                 holder = receiverType;
220                 if (receiverStamp.isExactType()) {
221                     assert targetMethod.getDeclaringClass().isAssignableFrom(holder) : holder + &quot; subtype of &quot; + targetMethod.getDeclaringClass() + &quot; for &quot; + targetMethod;
222                     ResolvedJavaMethod resolvedMethod = holder.resolveConcreteMethod(targetMethod, contextType);
223                     if (resolvedMethod != null) {
224                         return getExactInlineInfo(invoke, resolvedMethod);
225                     }
226                 }
227             }
228         }
229 
230         if (holder.isArray()) {
231             // arrays can be treated as Objects
232             ResolvedJavaMethod resolvedMethod = holder.resolveConcreteMethod(targetMethod, contextType);
233             if (resolvedMethod != null) {
234                 return getExactInlineInfo(invoke, resolvedMethod);
235             }
236         }
237 
238         AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = holder.findLeafConcreteSubtype();
239         if (leafConcreteSubtype != null) {
240             ResolvedJavaMethod resolvedMethod = leafConcreteSubtype.getResult().resolveConcreteMethod(targetMethod, contextType);
241             if (resolvedMethod != null &amp;&amp; leafConcreteSubtype.canRecordTo(callTarget.graph().getAssumptions())) {
242                 return getAssumptionInlineInfo(invoke, resolvedMethod, leafConcreteSubtype);
243             }
244         }
245 
246         AssumptionResult&lt;ResolvedJavaMethod&gt; concrete = holder.findUniqueConcreteMethod(targetMethod);
247         if (concrete != null &amp;&amp; concrete.canRecordTo(callTarget.graph().getAssumptions())) {
248             return getAssumptionInlineInfo(invoke, concrete.getResult(), concrete);
249         }
250 
251         // type check based inlining
252         return getTypeCheckedInlineInfo(invoke, targetMethod);
253     }
254 
255     private InlineInfo getTypeCheckedInlineInfo(Invoke invoke, ResolvedJavaMethod targetMethod) {
256         JavaTypeProfile typeProfile = ((MethodCallTargetNode) invoke.callTarget()).getProfile();
257         if (typeProfile == null) {
258             InliningUtil.traceNotInlinedMethod(invoke, inliningDepth(), targetMethod, &quot;no type profile exists&quot;);
259             invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null, &quot;no type profile exists&quot;);
260             return null;
261         }
262 
263         JavaTypeProfile.ProfiledType[] ptypes = typeProfile.getTypes();
264         if (ptypes == null || ptypes.length &lt;= 0) {
265             InliningUtil.traceNotInlinedMethod(invoke, inliningDepth(), targetMethod, &quot;no types in profile&quot;);
266             invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null, &quot;no types in profile&quot;);
267             return null;
268         }
269         ResolvedJavaType contextType = invoke.getContextType();
270         double notRecordedTypeProbability = typeProfile.getNotRecordedProbability();
271         final OptimisticOptimizations optimisticOpts = context.getOptimisticOptimizations();
272         OptionValues options = invoke.asNode().getOptions();
273         if (ptypes.length == 1 &amp;&amp; notRecordedTypeProbability == 0) {
274             if (!optimisticOpts.inlineMonomorphicCalls(options)) {
275                 InliningUtil.traceNotInlinedMethod(invoke, inliningDepth(), targetMethod, &quot;inlining monomorphic calls is disabled&quot;);
276                 invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null, &quot;inlining monomorphic calls is disabled&quot;);
277                 return null;
278             }
279 
280             ResolvedJavaType type = ptypes[0].getType();
281             assert type.isArray() || type.isConcrete();
282             ResolvedJavaMethod concrete = type.resolveConcreteMethod(targetMethod, contextType);
283             if (!checkTargetConditions(invoke, concrete)) {
284                 return null;
285             }
286             return new TypeGuardInlineInfo(invoke, concrete, type);
287         } else {
288             invoke.setPolymorphic(true);
289 
290             if (!optimisticOpts.inlinePolymorphicCalls(options) &amp;&amp; notRecordedTypeProbability == 0) {
291                 InliningUtil.traceNotInlinedMethod(invoke, inliningDepth(), targetMethod, &quot;inlining polymorphic calls is disabled (%d types)&quot;, ptypes.length);
292                 invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null, &quot;inlining polymorphic calls is disabled (%d types)&quot;, ptypes.length);
293                 return null;
294             }
295             if (!optimisticOpts.inlineMegamorphicCalls(options) &amp;&amp; notRecordedTypeProbability &gt; 0) {
296                 // due to filtering impossible types, notRecordedTypeProbability can be &gt; 0 although
297                 // the number of types is lower than what can be recorded in a type profile
298                 InliningUtil.traceNotInlinedMethod(invoke, inliningDepth(), targetMethod, &quot;inlining megamorphic calls is disabled (%d types, %f %% not recorded types)&quot;, ptypes.length,
299                                 notRecordedTypeProbability * 100);
300                 invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null,
301                                 &quot;inlining megamorphic calls is disabled (%d types, %f %% not recorded types)&quot;, ptypes.length, notRecordedTypeProbability);
302                 return null;
303             }
304 
305             // Find unique methods and their probabilities.
306             ArrayList&lt;ResolvedJavaMethod&gt; concreteMethods = new ArrayList&lt;&gt;();
307             ArrayList&lt;Double&gt; concreteMethodsProbabilities = new ArrayList&lt;&gt;();
308             for (int i = 0; i &lt; ptypes.length; i++) {
309                 ResolvedJavaMethod concrete = ptypes[i].getType().resolveConcreteMethod(targetMethod, contextType);
310                 if (concrete == null) {
311                     InliningUtil.traceNotInlinedMethod(invoke, inliningDepth(), targetMethod, &quot;could not resolve method&quot;);
312                     invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null, &quot;could not resolve method&quot;);
313                     return null;
314                 }
315                 int index = concreteMethods.indexOf(concrete);
316                 double curProbability = ptypes[i].getProbability();
317                 if (index &lt; 0) {
318                     index = concreteMethods.size();
319                     concreteMethods.add(concrete);
320                     concreteMethodsProbabilities.add(curProbability);
321                 } else {
322                     concreteMethodsProbabilities.set(index, concreteMethodsProbabilities.get(index) + curProbability);
323                 }
324             }
325 
326             // Clear methods that fall below the threshold.
327             if (notRecordedTypeProbability &gt; 0) {
328                 ArrayList&lt;ResolvedJavaMethod&gt; newConcreteMethods = new ArrayList&lt;&gt;();
329                 ArrayList&lt;Double&gt; newConcreteMethodsProbabilities = new ArrayList&lt;&gt;();
330                 for (int i = 0; i &lt; concreteMethods.size(); ++i) {
331                     if (concreteMethodsProbabilities.get(i) &gt;= MegamorphicInliningMinMethodProbability.getValue(options)) {
332                         newConcreteMethods.add(concreteMethods.get(i));
333                         newConcreteMethodsProbabilities.add(concreteMethodsProbabilities.get(i));
334                     }
335                 }
336 
337                 if (newConcreteMethods.isEmpty()) {
338                     // No method left that is worth inlining.
339                     InliningUtil.traceNotInlinedMethod(invoke, inliningDepth(), targetMethod, &quot;no methods remaining after filtering less frequent methods (%d methods previously)&quot;,
340                                     concreteMethods.size());
341                     invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null,
342                                     &quot;no methods remaining after filtering less frequent methods (%d methods previously)&quot;, concreteMethods.size());
343                     return null;
344                 }
345 
346                 concreteMethods = newConcreteMethods;
347                 concreteMethodsProbabilities = newConcreteMethodsProbabilities;
348             }
349 
350             if (concreteMethods.size() &gt; maxMethodPerInlining) {
351                 InliningUtil.traceNotInlinedMethod(invoke, inliningDepth(), targetMethod, &quot;polymorphic call with more than %d target methods&quot;, maxMethodPerInlining);
352                 invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null, &quot;polymorphic call with more than %d target methods&quot;, maxMethodPerInlining);
353                 return null;
354             }
355 
356             // Clean out types whose methods are no longer available.
357             ArrayList&lt;JavaTypeProfile.ProfiledType&gt; usedTypes = new ArrayList&lt;&gt;();
358             ArrayList&lt;Integer&gt; typesToConcretes = new ArrayList&lt;&gt;();
359             for (JavaTypeProfile.ProfiledType type : ptypes) {
360                 ResolvedJavaMethod concrete = type.getType().resolveConcreteMethod(targetMethod, contextType);
361                 int index = concreteMethods.indexOf(concrete);
362                 if (index == -1) {
363                     notRecordedTypeProbability += type.getProbability();
364                 } else {
365                     assert type.getType().isArray() || !type.getType().isAbstract() : type + &quot; &quot; + concrete;
366                     usedTypes.add(type);
367                     typesToConcretes.add(index);
368                 }
369             }
370 
371             if (usedTypes.isEmpty()) {
372                 // No type left that is worth checking for.
373                 InliningUtil.traceNotInlinedMethod(invoke, inliningDepth(), targetMethod, &quot;no types remaining after filtering less frequent types (%d types previously)&quot;, ptypes.length);
374                 invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null, &quot;no types remaining after filtering less frequent types (%d types previously)&quot;,
375                                 ptypes.length);
376                 return null;
377             }
378 
379             for (ResolvedJavaMethod concrete : concreteMethods) {
380                 if (!checkTargetConditions(invoke, concrete)) {
381                     InliningUtil.traceNotInlinedMethod(invoke, inliningDepth(), targetMethod, &quot;it is a polymorphic method call and at least one invoked method cannot be inlined&quot;);
382                     invoke.asNode().graph().getInliningLog().addDecision(invoke, false, &quot;InliningPhase&quot;, null, null,
383                                     &quot;it is a polymorphic method call and at least one invoked method cannot be inlined&quot;);
384                     return null;
385                 }
386             }
387             return new MultiTypeGuardInlineInfo(invoke, concreteMethods, usedTypes, typesToConcretes, notRecordedTypeProbability);
388         }
389     }
390 
391     private InlineInfo getAssumptionInlineInfo(Invoke invoke, ResolvedJavaMethod concrete, AssumptionResult&lt;?&gt; takenAssumption) {
392         assert concrete.isConcrete();
393         if (checkTargetConditions(invoke, concrete)) {
394             return new AssumptionInlineInfo(invoke, concrete, takenAssumption);
395         }
396         return null;
397     }
398 
399     private InlineInfo getExactInlineInfo(Invoke invoke, ResolvedJavaMethod targetMethod) {
400         assert targetMethod.isConcrete();
401         if (checkTargetConditions(invoke, targetMethod)) {
402             return new ExactInlineInfo(invoke, targetMethod);
403         }
404         return null;
405     }
406 
407     @SuppressWarnings(&quot;try&quot;)
408     private void doInline(CallsiteHolderExplorable callerCallsiteHolder, MethodInvocation calleeInvocation, String reason) {
409         StructuredGraph callerGraph = callerCallsiteHolder.graph();
410         InlineInfo calleeInfo = calleeInvocation.callee();
411         try {
412             try (DebugContext.Scope scope = debug.scope(&quot;doInline&quot;, callerGraph)) {
413                 EconomicSet&lt;Node&gt; canonicalizedNodes = EconomicSet.create(Equivalence.IDENTITY);
414                 canonicalizedNodes.addAll(calleeInfo.invoke().asNode().usages());
415                 EconomicSet&lt;Node&gt; parameterUsages = calleeInfo.inline(new Providers(context), reason);
416                 canonicalizedNodes.addAll(parameterUsages);
417                 counterInliningRuns.increment(debug);
418                 debug.dump(DebugContext.DETAILED_LEVEL, callerGraph, &quot;after %s&quot;, calleeInfo);
419 
420                 Graph.Mark markBeforeCanonicalization = callerGraph.getMark();
421 
422                 canonicalizer.applyIncremental(callerGraph, context, canonicalizedNodes);
423 
424                 // process invokes that are possibly created during canonicalization
425                 for (Node newNode : callerGraph.getNewNodes(markBeforeCanonicalization)) {
426                     if (newNode instanceof Invoke) {
427                         callerCallsiteHolder.pushInvoke((Invoke) newNode);
428                     }
429                 }
430 
431                 callerCallsiteHolder.computeProbabilities();
432 
433                 counterInliningPerformed.increment(debug);
434             }
435         } catch (BailoutException bailout) {
436             throw bailout;
437         } catch (AssertionError | RuntimeException e) {
438             throw new GraalError(e).addContext(calleeInfo.toString());
439         } catch (GraalError e) {
440             throw e.addContext(calleeInfo.toString());
441         } catch (Throwable e) {
442             throw debug.handle(e);
443         }
444     }
445 
446     /**
447      *
448      * This method attempts:
449      * &lt;ol&gt;
450      * &lt;li&gt;to inline at the callsite given by &lt;code&gt;calleeInvocation&lt;/code&gt;, where that callsite
451      * belongs to the {@link CallsiteHolderExplorable} at the top of the {@link #graphQueue}
452      * maintained in this class.&lt;/li&gt;
453      * &lt;li&gt;otherwise, to devirtualize the callsite in question.&lt;/li&gt;
454      * &lt;/ol&gt;
455      *
456      * @return true iff inlining was actually performed
457      */
458     private boolean tryToInline(MethodInvocation calleeInvocation, int inliningDepth) {
459         CallsiteHolderExplorable callerCallsiteHolder = (CallsiteHolderExplorable) currentGraph();
460         InlineInfo calleeInfo = calleeInvocation.callee();
461         assert callerCallsiteHolder.containsInvoke(calleeInfo.invoke());
462         counterInliningConsidered.increment(debug);
463 
<a name="6" id="anc6"></a><span class="line-modified">464         InliningPolicy.Decision decision = inliningPolicy.isWorthInlining(context.getReplacements(), calleeInvocation, calleeInfo, inliningDepth, true);</span>
465         if (decision.shouldInline()) {
466             doInline(callerCallsiteHolder, calleeInvocation, decision.getReason());
467             return true;
468         }
469 
470         if (context.getOptimisticOptimizations().devirtualizeInvokes(calleeInfo.graph().getOptions())) {
471             calleeInfo.tryToDevirtualizeInvoke(new Providers(context));
472         }
473 
474         return false;
475     }
476 
477     /**
478      * This method picks one of the callsites belonging to the current
479      * {@link CallsiteHolderExplorable}. Provided the callsite qualifies to be analyzed for
480      * inlining, this method prepares a new stack top in {@link InliningData} for such callsite,
481      * which comprises:
482      * &lt;ul&gt;
483      * &lt;li&gt;preparing a summary of feasible targets, ie preparing an {@link InlineInfo}&lt;/li&gt;
484      * &lt;li&gt;based on it, preparing the stack top proper which consists of:&lt;/li&gt;
485      * &lt;ul&gt;
486      * &lt;li&gt;one {@link MethodInvocation}&lt;/li&gt;
487      * &lt;li&gt;a {@link CallsiteHolder} for each feasible target&lt;/li&gt;
488      * &lt;/ul&gt;
489      * &lt;/ul&gt;
490      *
491      * &lt;p&gt;
492      * The thus prepared &quot;stack top&quot; is needed by {@link #moveForward()} to explore the space of
493      * inlining decisions (each decision one of: backtracking, delving, inlining).
494      * &lt;/p&gt;
495      *
496      * &lt;p&gt;
497      * The {@link InlineInfo} used to get things rolling is kept around in the
498      * {@link MethodInvocation}, it will be needed in case of inlining, see
499      * {@link InlineInfo#inline(Providers, String)}
500      * &lt;/p&gt;
501      */
502     private void processNextInvoke() {
503         CallsiteHolderExplorable callsiteHolder = (CallsiteHolderExplorable) currentGraph();
504         Invoke invoke = callsiteHolder.popInvoke();
505         InlineInfo info = getInlineInfo(invoke);
506 
507         if (info != null) {
508             info.populateInlinableElements(context, currentGraph().graph(), canonicalizer, rootGraph.getOptions());
509             double invokeProbability = callsiteHolder.invokeProbability(invoke);
510             double invokeRelevance = callsiteHolder.invokeRelevance(invoke);
511             MethodInvocation methodInvocation = new MethodInvocation(info, invokeProbability, invokeRelevance, freshlyInstantiatedArguments(invoke, callsiteHolder.getFixedParams()));
512             pushInvocationAndGraphs(methodInvocation);
513         }
514     }
515 
516     /**
517      * Gets the freshly instantiated arguments.
518      * &lt;p&gt;
519      * A freshly instantiated argument is either:
520      * &lt;uL&gt;
521      * &lt;li&gt;an {@link InliningData#isFreshInstantiation(org.graalvm.compiler.nodes.ValueNode)}&lt;/li&gt;
522      * &lt;li&gt;a fixed-param, ie a {@link ParameterNode} receiving a freshly instantiated argument&lt;/li&gt;
523      * &lt;/uL&gt;
524      * &lt;/p&gt;
525      *
526      * @return the positions of freshly instantiated arguments in the argument list of the
527      *         &lt;code&gt;invoke&lt;/code&gt;, or null if no such positions exist.
528      */
529     public static BitSet freshlyInstantiatedArguments(Invoke invoke, EconomicSet&lt;ParameterNode&gt; fixedParams) {
530         assert fixedParams != null;
531         assert paramsAndInvokeAreInSameGraph(invoke, fixedParams);
532         BitSet result = null;
533         int argIdx = 0;
534         for (ValueNode arg : invoke.callTarget().arguments()) {
535             assert arg != null;
536             if (isFreshInstantiation(arg) || (arg instanceof ParameterNode &amp;&amp; fixedParams.contains((ParameterNode) arg))) {
537                 if (result == null) {
538                     result = new BitSet();
539                 }
540                 result.set(argIdx);
541             }
542             argIdx++;
543         }
544         return result;
545     }
546 
547     private static boolean paramsAndInvokeAreInSameGraph(Invoke invoke, EconomicSet&lt;ParameterNode&gt; fixedParams) {
548         if (fixedParams.isEmpty()) {
549             return true;
550         }
551         for (ParameterNode p : fixedParams) {
552             if (p.graph() != invoke.asNode().graph()) {
553                 return false;
554             }
555         }
556         return true;
557     }
558 
559     public int graphCount() {
560         return graphQueue.size();
561     }
562 
563     public boolean hasUnprocessedGraphs() {
564         return !graphQueue.isEmpty();
565     }
566 
567     private CallsiteHolder currentGraph() {
568         return graphQueue.peek();
569     }
570 
571     private void popGraph() {
572         graphQueue.pop();
573         assert graphQueue.size() &lt;= maxGraphs;
574     }
575 
576     private void popGraphs(int count) {
577         assert count &gt;= 0;
578         for (int i = 0; i &lt; count; i++) {
579             graphQueue.pop();
580         }
581     }
582 
583     private static final Object[] NO_CONTEXT = {};
584 
585     /**
586      * Gets the call hierarchy of this inlining from outer most call to inner most callee.
587      */
588     private Object[] inliningContext() {
589         if (!debug.isDumpEnabled(DebugContext.INFO_LEVEL)) {
590             return NO_CONTEXT;
591         }
592         Object[] result = new Object[graphQueue.size()];
593         int i = 0;
594         for (CallsiteHolder g : graphQueue) {
595             result[i++] = g.method();
596         }
597         return result;
598     }
599 
600     private MethodInvocation currentInvocation() {
601         return invocationQueue.peekFirst();
602     }
603 
604     private void pushInvocationAndGraphs(MethodInvocation methodInvocation) {
605         invocationQueue.addFirst(methodInvocation);
606         InlineInfo info = methodInvocation.callee();
607         maxGraphs += info.numberOfMethods();
608         assert graphQueue.size() &lt;= maxGraphs;
609         for (int i = 0; i &lt; info.numberOfMethods(); i++) {
610             CallsiteHolder ch = methodInvocation.buildCallsiteHolderForElement(i);
611             assert !contains(ch.graph());
612             graphQueue.push(ch);
613             assert graphQueue.size() &lt;= maxGraphs;
614         }
615     }
616 
617     private void popInvocation() {
618         maxGraphs -= invocationQueue.peekFirst().callee().numberOfMethods();
619         assert graphQueue.size() &lt;= maxGraphs;
620         invocationQueue.removeFirst();
621     }
622 
623     public int countRecursiveInlining(ResolvedJavaMethod method) {
624         int count = 0;
625         for (CallsiteHolder callsiteHolder : graphQueue) {
626             if (method.equals(callsiteHolder.method())) {
627                 count++;
628             }
629         }
630         return count;
631     }
632 
633     public int inliningDepth() {
634         assert invocationQueue.size() &gt; 0;
635         return invocationQueue.size() - 1;
636     }
637 
638     @Override
639     public String toString() {
640         StringBuilder result = new StringBuilder(&quot;Invocations: &quot;);
641 
642         for (MethodInvocation invocation : invocationQueue) {
643             if (invocation.callee() != null) {
644                 result.append(invocation.callee().numberOfMethods());
645                 result.append(&quot;x &quot;);
646                 result.append(invocation.callee().invoke());
647                 result.append(&quot;; &quot;);
648             }
649         }
650 
651         result.append(&quot;\nGraphs: &quot;);
652         for (CallsiteHolder graph : graphQueue) {
653             result.append(graph.graph());
654             result.append(&quot;; &quot;);
655         }
656 
657         return result.toString();
658     }
659 
660     /**
661      * Gets a stack trace representing the current inlining stack represented by this object.
662      */
663     public Collection&lt;StackTraceElement&gt; getInvocationStackTrace() {
664         List&lt;StackTraceElement&gt; result = new ArrayList&lt;&gt;();
665         for (CallsiteHolder graph : graphQueue) {
666             result.add(graph.method().asStackTraceElement(0));
667         }
668 
669         return result;
670     }
671 
672     private boolean contains(StructuredGraph graph) {
673         assert graph != null;
674         for (CallsiteHolder info : graphQueue) {
675             if (info.graph() == graph) {
676                 return true;
677             }
678         }
679         return false;
680     }
681 
682     /**
683      * &lt;p&gt;
684      * The stack realized by {@link InliningData} grows and shrinks as choices are made among the
685      * alternatives below:
686      * &lt;ol&gt;
687      * &lt;li&gt;not worth inlining: pop stack top, which comprises:
688      * &lt;ul&gt;
689      * &lt;li&gt;pop any remaining graphs not yet delved into&lt;/li&gt;
690      * &lt;li&gt;pop the current invocation&lt;/li&gt;
691      * &lt;/ul&gt;
692      * &lt;/li&gt;
693      * &lt;li&gt;{@link #processNextInvoke() delve} into one of the callsites hosted in the current graph,
694      * such callsite is explored next by {@link #moveForward()}&lt;/li&gt;
695      * &lt;li&gt;{@link #tryToInline(MethodInvocation, int) try to inline}: move past the current graph
696      * (remove it from the topmost element).
697      * &lt;ul&gt;
698      * &lt;li&gt;If that was the last one then {@link #tryToInline(MethodInvocation, int) try to inline}
699      * the callsite under consideration (ie, the &quot;current invocation&quot;).&lt;/li&gt;
700      * &lt;li&gt;Whether inlining occurs or not, that callsite is removed from the top of
701      * {@link InliningData} .&lt;/li&gt;
702      * &lt;/ul&gt;
703      * &lt;/li&gt;
704      * &lt;/ol&gt;
705      * &lt;/p&gt;
706      *
707      * &lt;p&gt;
708      * Some facts about the alternatives above:
709      * &lt;ul&gt;
710      * &lt;li&gt;the first step amounts to backtracking, the 2nd one to depth-search, and the 3rd one also
711      * involves backtracking (however possibly after inlining).&lt;/li&gt;
712      * &lt;li&gt;the choice of abandon-and-backtrack or delve-into depends on
713      * {@link InliningPolicy#isWorthInlining} and {@link InliningPolicy#continueInlining}.&lt;/li&gt;
714      * &lt;li&gt;the 3rd choice is picked whenever none of the previous choices are made&lt;/li&gt;
715      * &lt;/ul&gt;
716      * &lt;/p&gt;
717      *
718      * @return true iff inlining was actually performed
719      */
720     @SuppressWarnings(&quot;try&quot;)
721     public boolean moveForward() {
722 
723         final MethodInvocation currentInvocation = currentInvocation();
724 
<a name="7" id="anc7"></a><span class="line-modified">725         final boolean backtrack = (!currentInvocation.isRoot() &amp;&amp;</span>
<span class="line-added">726                         !inliningPolicy.isWorthInlining(context.getReplacements(), currentInvocation, currentInvocation.callee(), inliningDepth(), false).shouldInline());</span>
727         if (backtrack) {
728             int remainingGraphs = currentInvocation.totalGraphs() - currentInvocation.processedGraphs();
729             assert remainingGraphs &gt; 0;
730             popGraphs(remainingGraphs);
731             popInvocation();
732             return false;
733         }
734 
735         final boolean delve = currentGraph().hasRemainingInvokes() &amp;&amp; inliningPolicy.continueInlining(currentGraph().graph());
736         if (delve) {
737             processNextInvoke();
738             return false;
739         }
740 
741         popGraph();
742         if (currentInvocation.isRoot()) {
743             return false;
744         }
745 
746         // try to inline
747         assert currentInvocation.callee().invoke().asNode().isAlive();
748         currentInvocation.incrementProcessedGraphs();
749         if (currentInvocation.processedGraphs() == currentInvocation.totalGraphs()) {
750             /*
751              * &quot;all of currentInvocation&#39;s graphs processed&quot; amounts to
752              * &quot;all concrete methods that come into question already had the callees they contain analyzed for inlining&quot;
753              */
754             popInvocation();
755             try (DebugContext.Scope s = debug.scope(&quot;Inlining&quot;, inliningContext())) {
756                 if (tryToInline(currentInvocation, inliningDepth() + 1)) {
757                     // Report real progress only if we inline into the root graph
758                     return currentGraph().graph() == rootGraph;
759                 }
760                 return false;
761             } catch (Throwable e) {
762                 throw debug.handle(e);
763             }
764         }
765 
766         return false;
767     }
768 
769     /**
770      * Checks an invariant that {@link #moveForward()} must maintain: &quot;the top invocation records
771      * how many concrete target methods (for it) remain on the {@link #graphQueue}; those targets
772      * &#39;belong&#39; to the current invocation in question.
773      */
774     private boolean topGraphsForTopInvocation() {
775         if (invocationQueue.isEmpty()) {
776             assert graphQueue.isEmpty();
777             return true;
778         }
779         if (currentInvocation().isRoot()) {
780             if (!graphQueue.isEmpty()) {
781                 assert graphQueue.size() == 1;
782             }
783             return true;
784         }
785         final int remainingGraphs = currentInvocation().totalGraphs() - currentInvocation().processedGraphs();
786         final Iterator&lt;CallsiteHolder&gt; iter = graphQueue.iterator();
787         for (int i = (remainingGraphs - 1); i &gt;= 0; i--) {
788             if (!iter.hasNext()) {
789                 assert false;
790                 return false;
791             }
792             CallsiteHolder queuedTargetCH = iter.next();
793             Inlineable targetIE = currentInvocation().callee().inlineableElementAt(i);
794             InlineableGraph targetIG = (InlineableGraph) targetIE;
795             assert queuedTargetCH.method().equals(targetIG.getGraph().method());
796         }
797         return true;
798     }
799 
800     /**
801      * This method checks invariants for this class. Named after shorthand for &quot;internal
802      * representation is ok&quot;.
803      */
804     public boolean repOK() {
805         assert topGraphsForTopInvocation();
806         return true;
807     }
808 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
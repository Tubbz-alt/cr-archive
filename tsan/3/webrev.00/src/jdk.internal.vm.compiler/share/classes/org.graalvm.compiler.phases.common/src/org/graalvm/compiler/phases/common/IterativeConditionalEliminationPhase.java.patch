diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/IterativeConditionalEliminationPhase.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/IterativeConditionalEliminationPhase.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/IterativeConditionalEliminationPhase.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/IterativeConditionalEliminationPhase.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,24 +22,25 @@
  */
 
 
 package org.graalvm.compiler.phases.common;
 
-import static org.graalvm.compiler.graph.Graph.NodeEvent.NODE_ADDED;
-
-import org.graalvm.compiler.core.common.RetryableBailoutException;
+import org.graalvm.compiler.core.common.GraalOptions;
+import org.graalvm.compiler.core.common.PermanentBailoutException;
+import org.graalvm.compiler.debug.TTY;
 import org.graalvm.compiler.graph.Graph.NodeEventScope;
 import org.graalvm.compiler.graph.Node;
-import org.graalvm.compiler.graph.spi.Simplifiable;
 import org.graalvm.compiler.nodes.StructuredGraph;
+import org.graalvm.compiler.nodes.spi.CoreProviders;
 import org.graalvm.compiler.phases.BasePhase;
 import org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener;
-import org.graalvm.compiler.phases.tiers.PhaseContext;
+import org.graalvm.compiler.phases.common.util.TracingNodeEventListener;
 
-public class IterativeConditionalEliminationPhase extends BasePhase<PhaseContext> {
+public class IterativeConditionalEliminationPhase extends BasePhase<CoreProviders> {
 
-    private static final int MAX_ITERATIONS = 256;
+    private static final boolean DEBUG_PHASE = false;
+    private static final int DEBUG_MAX_ITERATIONS = 256;
 
     private final CanonicalizerPhase canonicalizer;
     private final boolean fullSchedule;
 
     public IterativeConditionalEliminationPhase(CanonicalizerPhase canonicalizer, boolean fullSchedule) {
@@ -47,29 +48,50 @@
         this.fullSchedule = fullSchedule;
     }
 
     @Override
     @SuppressWarnings("try")
-    protected void run(StructuredGraph graph, PhaseContext context) {
-        EconomicSetNodeEventListener listener = new EconomicSetNodeEventListener().exclude(NODE_ADDED);
+    protected void run(StructuredGraph graph, CoreProviders context) {
+        final int maxIterations = GraalOptions.ConditionalEliminationMaxIterations.getValue(graph.getOptions());
+        EconomicSetNodeEventListener listener = new EconomicSetNodeEventListener();
         int count = 0;
+
         while (true) {
+            count++;
             try (NodeEventScope nes = graph.trackNodeEvents(listener)) {
                 new ConditionalEliminationPhase(fullSchedule).apply(graph, context);
             }
             if (listener.getNodes().isEmpty()) {
                 break;
             }
-            for (Node node : graph.getNodes()) {
-                if (node instanceof Simplifiable) {
-                    listener.getNodes().add(node);
-                }
-            }
+
             canonicalizer.applyIncremental(graph, context, listener.getNodes());
             listener.getNodes().clear();
-            if (++count > MAX_ITERATIONS) {
-                throw new RetryableBailoutException("Number of iterations in ConditionalEliminationPhase phase exceeds %d", MAX_ITERATIONS);
+
+            if (count >= maxIterations) {
+                if (DEBUG_PHASE) {
+                    if (count >= DEBUG_MAX_ITERATIONS - 5) {
+                        TTY.println();
+                        TTY.println("------------------------------------");
+                        TTY.println("Iteration " + count);
+                        TTY.println("Conditional elimination changed nodes: ");
+                        for (Node n : listener.getNodes()) {
+                            TTY.println(n.toString());
+                            for (Node input : n.inputs()) {
+                                TTY.println("    input: " + input);
+                            }
+                        }
+                        TTY.println("Canonicalization with node listener: ");
+                        try (NodeEventScope debugNes = graph.trackNodeEvents(new TracingNodeEventListener())) {
+                            canonicalizer.applyIncremental(graph, context, listener.getNodes());
+                        }
+                    }
+                    if (count >= DEBUG_MAX_ITERATIONS) {
+                        throw new PermanentBailoutException("Number of iterations in ConditionalEliminationPhase phase exceeds %d", DEBUG_MAX_ITERATIONS);
+                    }
+                }
+                break;
             }
         }
     }
 
     @Override

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/FloatingReadPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FixReadsPhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="FrameStateAssignmentPhase.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/FloatingReadPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,10 ***</span>
<span class="line-new-header">--- 46,11 ---</span>
  import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
  import org.graalvm.compiler.nodes.LoopBeginNode;
  import org.graalvm.compiler.nodes.LoopEndNode;
  import org.graalvm.compiler.nodes.LoopExitNode;
  import org.graalvm.compiler.nodes.PhiNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.ProxyNode;</span>
  import org.graalvm.compiler.nodes.ReturnNode;
  import org.graalvm.compiler.nodes.StartNode;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNodeUtil;
  import org.graalvm.compiler.nodes.calc.FloatingNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 164,13 ***</span>
          return set;
      }
  
      protected void processNode(FixedNode node, EconomicSet&lt;LocationIdentity&gt; currentState) {
          if (node instanceof MemoryCheckpoint.Single) {
<span class="line-modified">!             processIdentity(currentState, ((MemoryCheckpoint.Single) node).getLocationIdentity());</span>
          } else if (node instanceof MemoryCheckpoint.Multi) {
<span class="line-modified">!             for (LocationIdentity identity : ((MemoryCheckpoint.Multi) node).getLocationIdentities()) {</span>
                  processIdentity(currentState, identity);
              }
          }
      }
  
<span class="line-new-header">--- 165,13 ---</span>
          return set;
      }
  
      protected void processNode(FixedNode node, EconomicSet&lt;LocationIdentity&gt; currentState) {
          if (node instanceof MemoryCheckpoint.Single) {
<span class="line-modified">!             processIdentity(currentState, ((MemoryCheckpoint.Single) node).getKilledLocationIdentity());</span>
          } else if (node instanceof MemoryCheckpoint.Multi) {
<span class="line-modified">!             for (LocationIdentity identity : ((MemoryCheckpoint.Multi) node).getKilledLocationIdentities()) {</span>
                  processIdentity(currentState, identity);
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 252,10 ***</span>
<span class="line-new-header">--- 253,12 ---</span>
              boolean isPhi = false;
              MemoryNode merged = null;
              for (MemoryMap state : states) {
                  MemoryNode last = state.getLastLocationAccess(key);
                  if (isPhi) {
<span class="line-added">+                     // Fortify: Suppress Null Deference false positive (`isPhi == true` implies</span>
<span class="line-added">+                     // `merged != null`)</span>
                      ((MemoryPhiNode) merged).addInput(ValueNodeUtil.asNode(last));
                  } else {
                      if (merged == last) {
                          // nothing to do
                      } else if (merged == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,11 ***</span>
                          isPhi = true;
                      }
                  }
                  mergedStatesCount++;
              }
<span class="line-modified">!             newState.lastMemorySnapshot.put(key, merged);</span>
          }
          return newState;
  
      }
  
<span class="line-new-header">--- 273,11 ---</span>
                          isPhi = true;
                      }
                  }
                  mergedStatesCount++;
              }
<span class="line-modified">!             newState.getMap().put(key, merged);</span>
          }
          return newState;
  
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 297,10 ***</span>
<span class="line-new-header">--- 300,20 ---</span>
              this.createMemoryMapNodes = createMemoryMapNodes;
          }
  
          @Override
          protected MemoryMapImpl processNode(FixedNode node, MemoryMapImpl state) {
<span class="line-added">+ </span>
<span class="line-added">+             if (node instanceof LoopExitNode) {</span>
<span class="line-added">+                 final LoopExitNode loopExitNode = (LoopExitNode) node;</span>
<span class="line-added">+                 final EconomicSet&lt;LocationIdentity&gt; modifiedInLoop = modifiedInLoops.get(loopExitNode.loopBegin());</span>
<span class="line-added">+                 final boolean anyModified = modifiedInLoop.contains(LocationIdentity.any());</span>
<span class="line-added">+                 state.getMap().replaceAll((locationIdentity, memoryNode) -&gt; (anyModified || modifiedInLoop.contains(locationIdentity))</span>
<span class="line-added">+                                 ? ProxyNode.forMemory(memoryNode, loopExitNode, locationIdentity)</span>
<span class="line-added">+                                 : memoryNode);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              if (node instanceof MemoryAnchorNode) {
                  processAnchor((MemoryAnchorNode) node, state);
                  return state;
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,19 ***</span>
                  processAccess((MemoryAccess) node, state);
              }
  
              if (createFloatingReads &amp;&amp; node instanceof FloatableAccessNode) {
                  processFloatable((FloatableAccessNode) node, state);
<span class="line-modified">!             } else if (node instanceof MemoryCheckpoint.Single) {</span>
                  processCheckpoint((MemoryCheckpoint.Single) node, state);
              } else if (node instanceof MemoryCheckpoint.Multi) {
                  processCheckpoint((MemoryCheckpoint.Multi) node, state);
              }
              assert MemoryCheckpoint.TypeAssertion.correctType(node) : node;
  
              if (createMemoryMapNodes &amp;&amp; node instanceof ReturnNode) {
<span class="line-modified">!                 ((ReturnNode) node).setMemoryMap(node.graph().unique(new MemoryMapNode(state.lastMemorySnapshot)));</span>
              }
              return state;
          }
  
          /**
<span class="line-new-header">--- 321,20 ---</span>
                  processAccess((MemoryAccess) node, state);
              }
  
              if (createFloatingReads &amp;&amp; node instanceof FloatableAccessNode) {
                  processFloatable((FloatableAccessNode) node, state);
<span class="line-modified">!             }</span>
<span class="line-added">+             if (node instanceof MemoryCheckpoint.Single) {</span>
                  processCheckpoint((MemoryCheckpoint.Single) node, state);
              } else if (node instanceof MemoryCheckpoint.Multi) {
                  processCheckpoint((MemoryCheckpoint.Multi) node, state);
              }
              assert MemoryCheckpoint.TypeAssertion.correctType(node) : node;
  
              if (createMemoryMapNodes &amp;&amp; node instanceof ReturnNode) {
<span class="line-modified">!                 ((ReturnNode) node).setMemoryMap(node.graph().unique(new MemoryMapNode(state.getMap())));</span>
              }
              return state;
          }
  
          /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 351,25 ***</span>
                  access.setLastLocationAccess(lastLocationAccess);
              }
          }
  
          private static void processCheckpoint(MemoryCheckpoint.Single checkpoint, MemoryMapImpl state) {
<span class="line-modified">!             processIdentity(checkpoint.getLocationIdentity(), checkpoint, state);</span>
          }
  
          private static void processCheckpoint(MemoryCheckpoint.Multi checkpoint, MemoryMapImpl state) {
<span class="line-modified">!             for (LocationIdentity identity : checkpoint.getLocationIdentities()) {</span>
                  processIdentity(identity, checkpoint, state);
              }
          }
  
          private static void processIdentity(LocationIdentity identity, MemoryCheckpoint checkpoint, MemoryMapImpl state) {
              if (identity.isAny()) {
<span class="line-modified">!                 state.lastMemorySnapshot.clear();</span>
              }
              if (identity.isMutable()) {
<span class="line-modified">!                 state.lastMemorySnapshot.put(identity, checkpoint);</span>
              }
          }
  
          @SuppressWarnings(&quot;try&quot;)
          private static void processFloatable(FloatableAccessNode accessNode, MemoryMapImpl state) {
<span class="line-new-header">--- 365,25 ---</span>
                  access.setLastLocationAccess(lastLocationAccess);
              }
          }
  
          private static void processCheckpoint(MemoryCheckpoint.Single checkpoint, MemoryMapImpl state) {
<span class="line-modified">!             processIdentity(checkpoint.getKilledLocationIdentity(), checkpoint, state);</span>
          }
  
          private static void processCheckpoint(MemoryCheckpoint.Multi checkpoint, MemoryMapImpl state) {
<span class="line-modified">!             for (LocationIdentity identity : checkpoint.getKilledLocationIdentities()) {</span>
                  processIdentity(identity, checkpoint, state);
              }
          }
  
          private static void processIdentity(LocationIdentity identity, MemoryCheckpoint checkpoint, MemoryMapImpl state) {
              if (identity.isAny()) {
<span class="line-modified">!                 state.getMap().clear();</span>
              }
              if (identity.isMutable()) {
<span class="line-modified">!                 state.getMap().put(identity, checkpoint);</span>
              }
          }
  
          @SuppressWarnings(&quot;try&quot;)
          private static void processFloatable(FloatableAccessNode accessNode, MemoryMapImpl state) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 377,11 ***</span>
              LocationIdentity locationIdentity = accessNode.getLocationIdentity();
              if (accessNode.canFloat()) {
                  assert accessNode.getNullCheck() == false;
                  MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);
                  try (DebugCloseable position = accessNode.withNodeSourcePosition()) {
<span class="line-modified">!                     FloatingAccessNode floatingNode = accessNode.asFloatingNode(lastLocationAccess);</span>
                      graph.replaceFixedWithFloating(accessNode, floatingNode);
                  }
              }
          }
  
<span class="line-new-header">--- 391,12 ---</span>
              LocationIdentity locationIdentity = accessNode.getLocationIdentity();
              if (accessNode.canFloat()) {
                  assert accessNode.getNullCheck() == false;
                  MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);
                  try (DebugCloseable position = accessNode.withNodeSourcePosition()) {
<span class="line-modified">!                     FloatingAccessNode floatingNode = accessNode.asFloatingNode();</span>
<span class="line-added">+                     assert floatingNode.getLastLocationAccess() == lastLocationAccess;</span>
                      graph.replaceFixedWithFloating(accessNode, floatingNode);
                  }
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 400,11 ***</span>
                   * schedule anything immediately after the invoke. It can only schedule in the
                   * normal or exceptional successor - and we have to tell the scheduler here which
                   * side it needs to choose by putting in the location identity on both successors.
                   */
                  InvokeWithExceptionNode invoke = (InvokeWithExceptionNode) node.predecessor();
<span class="line-modified">!                 result.lastMemorySnapshot.put(invoke.getLocationIdentity(), (MemoryCheckpoint) node);</span>
              }
              return result;
          }
  
          @Override
<span class="line-new-header">--- 415,11 ---</span>
                   * schedule anything immediately after the invoke. It can only schedule in the
                   * normal or exceptional successor - and we have to tell the scheduler here which
                   * side it needs to choose by putting in the location identity on both successors.
                   */
                  InvokeWithExceptionNode invoke = (InvokeWithExceptionNode) node.predecessor();
<span class="line-modified">!                 result.getMap().put(invoke.getKilledLocationIdentity(), (MemoryCheckpoint) node);</span>
              }
              return result;
          }
  
          @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 412,17 ***</span>
              EconomicSet&lt;LocationIdentity&gt; modifiedLocations = modifiedInLoops.get(loop);
              EconomicMap&lt;LocationIdentity, MemoryPhiNode&gt; phis = EconomicMap.create(Equivalence.DEFAULT);
              if (modifiedLocations.contains(LocationIdentity.any())) {
                  // create phis for all locations if ANY is modified in the loop
                  modifiedLocations = EconomicSet.create(Equivalence.DEFAULT, modifiedLocations);
<span class="line-modified">!                 modifiedLocations.addAll(initialState.lastMemorySnapshot.getKeys());</span>
              }
  
              for (LocationIdentity location : modifiedLocations) {
                  createMemoryPhi(loop, initialState, phis, location);
              }
<span class="line-modified">!             initialState.lastMemorySnapshot.putAll(phis);</span>
  
              LoopInfo&lt;MemoryMapImpl&gt; loopInfo = ReentrantNodeIterator.processLoop(this, loop, initialState);
  
              UnmodifiableMapCursor&lt;LoopEndNode, MemoryMapImpl&gt; endStateCursor = loopInfo.endStates.getEntries();
              while (endStateCursor.advance()) {
<span class="line-new-header">--- 427,17 ---</span>
              EconomicSet&lt;LocationIdentity&gt; modifiedLocations = modifiedInLoops.get(loop);
              EconomicMap&lt;LocationIdentity, MemoryPhiNode&gt; phis = EconomicMap.create(Equivalence.DEFAULT);
              if (modifiedLocations.contains(LocationIdentity.any())) {
                  // create phis for all locations if ANY is modified in the loop
                  modifiedLocations = EconomicSet.create(Equivalence.DEFAULT, modifiedLocations);
<span class="line-modified">!                 modifiedLocations.addAll(initialState.getMap().getKeys());</span>
              }
  
              for (LocationIdentity location : modifiedLocations) {
                  createMemoryPhi(loop, initialState, phis, location);
              }
<span class="line-modified">!             initialState.getMap().putAll(phis);</span>
  
              LoopInfo&lt;MemoryMapImpl&gt; loopInfo = ReentrantNodeIterator.processLoop(this, loop, initialState);
  
              UnmodifiableMapCursor&lt;LoopEndNode, MemoryMapImpl&gt; endStateCursor = loopInfo.endStates.getEntries();
              while (endStateCursor.advance()) {
</pre>
<center><a href="FixReadsPhase.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="FrameStateAssignmentPhase.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>